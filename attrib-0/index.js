/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 53);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_color__ = __webpack_require__(11);

/**
 * Preset of render state for OVER compositing,
 * @see T. Porter and T. Duff, "Compositing Digital Images", Proceedings of
 *      SIGGRAPH'84, 18 (1984).
 */
const BLEND_OVER_RENDER_STATE = {
    blend: true,
    blendFuncSrcRgb: 770 /* SRC_ALPHA */,
    blendFuncDstRgb: 771 /* ONE_MINUS_SRC_ALPHA */,
    blendFuncSrcAlpha: 1 /* ONE */,
    blendFuncDstAlpha: 771 /* ONE_MINUS_SRC_ALPHA */
};
/* harmony export (immutable) */ __webpack_exports__["b"] = BLEND_OVER_RENDER_STATE;

const BLEND_OVER_PREMULTIPLIED_ALPHA_RENDER_STATE = {
    blend: true,
    blendFuncSrcRgb: 1 /* ONE */,
    blendFuncDstRgb: 771 /* ONE_MINUS_SRC_ALPHA */,
    blendFuncSrcAlpha: 1 /* ONE */,
    blendFuncDstAlpha: 771 /* ONE_MINUS_SRC_ALPHA */
};
/* harmony export (immutable) */ __webpack_exports__["a"] = BLEND_OVER_PREMULTIPLIED_ALPHA_RENDER_STATE;

/**
 * State of the WebGL rendering pipeline. Doesn't include object bindings since
 * the context handles them.
 */
class RenderState {
    /**
     * Creates a new render state object.
     *
     * @param state Object with state properties that values differ from default
     *      ones.
     */
    constructor(...state) {
        this.clearColor = __WEBPACK_IMPORTED_MODULE_0__util_color__["c" /* create */](0, 0, 0, 0);
        this.clearDepth = 1;
        this.clearStencil = 0;
        this.colorMaskR = true;
        this.colorMaskG = true;
        this.colorMaskB = true;
        this.colorMaskAlpha = true;
        this.blend = false;
        this.blendEquationRgb = 32774 /* ADD */;
        this.blendEquationAlpha = 32774 /* ADD */;
        this.blendFuncSrcRgb = 1 /* ONE */;
        this.blendFuncDstRgb = 0 /* ZERO */;
        this.blendFuncSrcAlpha = 1 /* ONE */;
        this.blendFuncDstAlpha = 0 /* ZERO */;
        this.cullFace = false;
        this.cullFaceMode = 1029 /* BACK */;
        this.frontFaceMode = 2305 /* COUNTERCLOCKWISE */;
        this.depthTest = false;
        this.depthFunc = 513 /* LESS */;
        this.depthRangeNear = 0;
        this.depthRangeFar = 1;
        this.depthMask = true;
        this.dither = true;
        this.drawBuffers = [36064 /* COLOR_ATTACHMENT0 */];
        this.polygonOffset = false;
        this.polygonOffsetFactor = 0;
        this.polygonOffsetUnits = 0;
        this.sampleAlphaToCoverage = false;
        this.sampleCoverage = false;
        this.sampleCoverageValue = 1;
        this.sampleCoverageInvert = false;
        this.scissorTest = false;
        this.scissorX = 0;
        this.scissorY = 0;
        // Actual defaults aren't known here since they depend upon context. -1's
        // as "do not change" values.
        this.scissorWidth = -1;
        this.scissorHeight = -1;
        this.stencilTest = false;
        this.stencilReference = 0;
        this.stencilMask = 0xff;
        this.stencilWriteMask = 0xff;
        this.stencilFrontFunc = 519 /* ALWAYS */;
        this.stencilFrontFailOp = 7680 /* KEEP */;
        this.stencilFrontDepthFailOp = 7680 /* KEEP */;
        this.stencilFrontDepthPassOp = 7680 /* KEEP */;
        this.stencilBackFunc = 519 /* ALWAYS */;
        this.stencilBackFailOp = 7680 /* KEEP */;
        this.stencilBackDepthFailOp = 7680 /* KEEP */;
        this.stencilBackDepthPassOp = 7680 /* KEEP */;
        this.viewportX = 0;
        this.viewportY = 0;
        // Actual defaults aren't known here since they depend upon context. -1's
        // as "do not change" values.
        this.viewportWidth = -1;
        this.viewportHeight = -1;
        Object.assign(this, ...state);
    }
}
/* harmony export (immutable) */ __webpack_exports__["c"] = RenderState;



/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["f"] = create;
/* harmony export (immutable) */ __webpack_exports__["e"] = copy;
/* unused harmony export areEqual */
/* unused harmony export areCollinear */
/* unused harmony export areFuzzyEqual */
/* harmony export (immutable) */ __webpack_exports__["b"] = add;
/* harmony export (immutable) */ __webpack_exports__["s"] = sub;
/* unused harmony export mulv */
/* harmony export (immutable) */ __webpack_exports__["p"] = muln;
/* harmony export (immutable) */ __webpack_exports__["l"] = divv;
/* harmony export (immutable) */ __webpack_exports__["k"] = divn;
/* unused harmony export mod */
/* unused harmony export mix */
/* unused harmony export rotate */
/* unused harmony export rotate45 */
/* harmony export (immutable) */ __webpack_exports__["r"] = rotate90;
/* unused harmony export rotateNeg90 */
/* harmony export (immutable) */ __webpack_exports__["n"] = invert;
/* harmony export (immutable) */ __webpack_exports__["o"] = length;
/* harmony export (immutable) */ __webpack_exports__["j"] = distance;
/* harmony export (immutable) */ __webpack_exports__["q"] = normalize;
/* harmony export (immutable) */ __webpack_exports__["d"] = convert;
/* harmony export (immutable) */ __webpack_exports__["m"] = dot;
/* harmony export (immutable) */ __webpack_exports__["i"] = crossZ;
/* harmony export (immutable) */ __webpack_exports__["g"] = createBBox2;
/* unused harmony export copyBBox2 */
/* unused harmony export bboxesOverlap */
/* unused harmony export pointIsInBBox */
/* harmony export (immutable) */ __webpack_exports__["c"] = computeBBoxForPoints;
/* unused harmony export getLineFromPoints */
/* unused harmony export getSignedDistanceToLine */
/* harmony export (immutable) */ __webpack_exports__["h"] = createExtent2;
/* unused harmony export copyExtent2 */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_fuzzy_equal__ = __webpack_require__(25);

/**
 * Creates a new vector and initializes it with given components.
 *
 * @param x X component of the vector.
 * @param y Y component of the vector.
 * @returns The vector.
 */
function create(x, y) {
    return { x, y };
}
const ZERO = create(0, 0);
/* harmony export (immutable) */ __webpack_exports__["a"] = ZERO;

const ORIGIN = ZERO;
/* unused harmony export ORIGIN */

const POSITIVE_X = create(1, 0);
/* unused harmony export POSITIVE_X */

const NEGATIVE_X = create(-1, 0);
/* unused harmony export NEGATIVE_X */

const POSITIVE_Y = create(0, 1);
/* unused harmony export POSITIVE_Y */

const NEGATIVE_Y = create(0, -1);
/* unused harmony export NEGATIVE_Y */

/**
 * Copies a vector to another one.
 *
 * @param src The source vector.
 * @param dst The vector the source vector will be copied to.
 * @returns `dst`.
 */
function copy(src, dst = create(0, 0)) {
    dst.x = src.x;
    dst.y = src.y;
    return dst;
}
/**
 * Checks if two vectors are strictly equal component-wise.
 *
 * @param v1 The first vector.
 * @param v2 The second vector.
 * @returns `true` if the vectors are equal and `false` otherwise.
 */
function areEqual(v1, v2) {
    return v1.x === v2.x && v1.y === v2.y;
}
/**
 * Checks if two vectors are collinear.
 *
 * @param v1 The first vector.
 * @param v2 The second vector.
 * @returns `true` if the vectors are collinear and `false` otherwise.
 */
function areCollinear(v1, v2) {
    return v1.x / v2.x === v1.y / v2.y;
}
/**
 * Checks if corresponding components of two vectors are all within given
 * tolerance from each other.
 *
 * @param v1 The first vector.
 * @param v2 The second vector.
 * @param tolerance The tolerance.
 * @returns `true` if the vectors are "fuzzy" equal and `false` otherwise.
 */
function areFuzzyEqual(v1, v2, tolerance = __WEBPACK_IMPORTED_MODULE_0__util_fuzzy_equal__["a" /* DEFAULT_TOLERANCE */]) {
    return (Object(__WEBPACK_IMPORTED_MODULE_0__util_fuzzy_equal__["b" /* default */])(v1.x, v2.x, tolerance) &&
        Object(__WEBPACK_IMPORTED_MODULE_0__util_fuzzy_equal__["b" /* default */])(v1.y, v2.y, tolerance));
}
/**
 * Adds two vector and stores the result into a third one, i.e. `dst = a + b`.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function add(a, b, dst = create(0, 0)) {
    dst.x = a.x + b.x;
    dst.y = a.y + b.y;
    return dst;
}
/**
 * Subtracts a vector from another one and stores the result to a third one, i.e.
 * `dst = a - b`.
 *
 * @param a The minuend vector.
 * @param b The subtrahend vector.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function sub(a, b, dst = create(0, 0)) {
    dst.x = a.x - b.x;
    dst.y = a.y - b.y;
    return dst;
}
/**
 * Multiplies two vectors component-wise and stores the result into a third one.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function mulv(a, b, dst = create(0, 0)) {
    dst.x = a.x * b.x;
    dst.y = a.y * b.y;
    return dst;
}
/**
 * Multiplies a vector by a scalar and stores the result into a third vector.
 *
 * @param a The vector.
 * @param n The scalar.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function muln(a, n, dst = create(0, 0)) {
    dst.x = a.x * n;
    dst.y = a.y * n;
    return dst;
}
/**
 * Divides a vector by another one component wise and stores the result into a
 * third one.
 *
 * @param a The dividend vector.
 * @param b The divisor vector.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function divv(a, b, dst = create(0, 0)) {
    dst.x = a.x / b.x;
    dst.y = a.y / b.y;
    return dst;
}
/**
 * Divides a vector by a scalar and stores the result into a third vector.
 *
 * @param a The dividend vector.
 * @param n The scalar.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function divn(a, n, dst = create(0, 0)) {
    dst.x = a.x / n;
    dst.y = a.y / n;
    return dst;
}
/**
 * Calculates the reminder after division of a's components by n and stores the result into a third vector.
 *
 * @param a The dividend vector.
 * @param n The scalar.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function mod(a, n, dst = create(0, 0)) {
    dst.x = a.x % n;
    dst.y = a.y % n;
    return dst;
}
/**
 * Linearly interpolates between two vectors, i.e. computes
 * `(1 - factor) * a + factor * b`, and writes the result into a third vector.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @param factor The interpolation factor.
 * @param dst The vector the result will be written to.
 * @returns `dst`.
 */
function mix(a, b, factor, dst = create(0, 0)) {
    dst.x = (1 - factor) * a.x + factor * b.x;
    dst.y = (1 - factor) * a.y + factor * b.y;
    return dst;
}
/**
 * Rotates a vector by a given angle and stores the result into a second vector.
 * Positive direction is from +X to +Y.
 *
 * @param v The vector to rotate.
 * @param angle The angle of rotation.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function rotate(v, angle, dst = create(0, 0)) {
    const x = v.x;
    const y = v.y;
    const angleCos = Math.cos(angle);
    const angleSin = Math.sin(angle);
    dst.x = angleCos * x - angleSin * y;
    dst.y = angleSin * x + angleCos * y;
    return dst;
}
/**
 * Rotates a vector by 45 degrees and stores the result into a second vector.
 * Analogous to `rotate(v, Math.PI / 4, dst)`, but faster.
 *
 * @param v The vector to rotate.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function rotate45(v, dst = create(0, 0)) {
    const y = v.y;
    const s = Math.SQRT1_2;
    dst.y = s * v.x + s * v.y;
    dst.x = s * v.x - s * y;
    return dst;
}
/**
 * Rotates a vector by 90 degrees and stores the result into a second vector.
 * Analogous to `rotate(v, Math.PI / 2, dst)`, but faster.
 *
 * @param v The vector to rotate.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function rotate90(v, dst = create(0, 0)) {
    const y = v.y;
    dst.y = v.x;
    dst.x = -y;
    return dst;
}
/**
 * Rotates a vector by -90 degrees and stores the result into a second vector.
 * Analogous to `rotate(v, -Math.PI / 2, dst)`, but faster.
 *
 * @param v The vector to rotate.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function rotateNeg90(v, dst = create(0, 0)) {
    const y = v.y;
    dst.y = -v.x;
    dst.x = y;
    return dst;
}
/**
 * Inverts signs of components of a vector and stores the result into a second
 * vector. Analogous to `rotate(v, Math.PI, dst)` (or `rotate(v, -Math.PI, dst)`,
 * which is the same), but faster.
 *
 * @param v The vector to invert.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function invert(v, dst = create(0, 0)) {
    dst.x = -v.x;
    dst.y = -v.y;
    return dst;
}
/**
 * Computes length of a vector.
 *
 * @param v The vector.
 * @returns The length.
 */
function length(v) {
    return Math.hypot(v.x, v.y);
}
/**
 * Computes distance between ends of two vectors.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @returns The distance, i.e. `length(sub(a, b))`.
 */
function distance(a, b) {
    return Math.hypot(a.x - b.x, a.y - b.y);
}
/**
 * Divides a vector by its length (thus making it a unit vector) and stores the
 * result to another one.
 *
 * @param v The vector to be normalized.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function normalize(v, dst = create(0, 0)) {
    return divn(v, length(v), dst);
}
/**
 * Converts each component of vector.
 *
 * @param v The vector to be converted.
 * @param converter The component converter.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function convert(v, converter, dst = create(0, 0)) {
    dst.x = converter(v.x);
    dst.y = converter(v.y);
    return dst;
}
/**
 * Computes dot product of two vectors.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @returns The dot product.
 */
function dot(a, b) {
    return a.x * b.x + a.y * b.y;
}
/**
 * Computes Z-component of a cross product of two vectors.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @returns Z-component of the cross product.
 */
function crossZ(a, b) {
    return a.x * b.y - a.y * b.x;
}
const EMPTY = {
    minX: 0,
    maxX: 0,
    minY: 0,
    maxY: 0
};
/* unused harmony export EMPTY */

const UNIT_BBOX = {
    minX: -1,
    maxX: 1,
    minY: -1,
    maxY: 1
};
/* unused harmony export UNIT_BBOX */

/**
 * Creates a new bbox and initializes it with given components.
 *
 * @param minX Left border of the bbox.
 * @param maxX Right border of the bbox.
 * @param minY Lower border of the bbox.
 * @param maxY Upper border of the bbox.
 * @returns The bbox.
 */
function createBBox2(minX, maxX, minY, maxY) {
    return { minX, maxX, minY, maxY };
}
/**
 * Copies a bbox to another one.
 *
 * @param src The source bbox.
 * @param dst The bbox the source bbox will be copied to.
 * @returns `dst`.
 */
function copyBBox2(src, dst = createBBox2(0, 0, 0, 0)) {
    dst.minX = src.minX;
    dst.maxX = src.maxX;
    dst.minY = src.minY;
    dst.maxY = src.maxY;
    return dst;
}
/**
 * Checks if two bounding boxes overlap.
 *
 * @param bbox1 A bounding box.
 * @param bbox2 Another bounding box.
 * @returns `true` if given bounding boxes do overlap and `false` otherwise.
 */
function bboxesOverlap(bbox1, bbox2) {
    let leftBBox;
    let rightBBox;
    if (bbox1.minX < bbox2.minX) {
        leftBBox = bbox1;
        rightBBox = bbox2;
    }
    else {
        leftBBox = bbox2;
        rightBBox = bbox1;
    }
    let topBBox;
    let bottomBBox;
    if (bbox1.maxY > bbox2.maxY) {
        topBBox = bbox1;
        bottomBBox = bbox2;
    }
    else {
        topBBox = bbox2;
        bottomBBox = bbox1;
    }
    return rightBBox.minX < leftBBox.maxX && bottomBBox.maxY > topBBox.minY;
}
/**
 * Checks if a 2D point lies inside a bounding box or on its border.
 *
 * @param point The point.
 * @param bbox The bounding box.
 * @returns `true` if the point is inside of the box and `false` otherwise.
 */
function pointIsInBBox(point, bbox) {
    return bbox.minX <= point.x && point.x <= bbox.maxX &&
        bbox.minY <= point.y && point.y <= bbox.maxY;
}
/**
 * Computes bounding box of an array of points and stores it to a given object.
 *
 * @param points The array of points.
 * @param dst The bbox the result will be written to. Left unmodified if the array
 *      of points is empty.
 * @returns `dst`.
 */
function computeBBoxForPoints(points, dst = { minX: 0, maxX: 0, minY: 0, maxY: 0 }) {
    if (points.length === 0) {
        return dst;
    }
    dst.minX = dst.maxX = points[0].x;
    dst.minY = dst.maxY = points[0].y;
    for (let i = 1; i < points.length; ++i) {
        const { x, y } = points[i];
        if (x < dst.minX) {
            dst.minX = x;
        }
        if (x > dst.maxX) {
            dst.maxX = x;
        }
        if (y < dst.minY) {
            dst.minY = y;
        }
        if (y > dst.maxY) {
            dst.maxY = y;
        }
    }
    return dst;
}
const X_AXIS = {
    origin: ORIGIN,
    tangent: POSITIVE_X
};
/* unused harmony export X_AXIS */

const Y_AXIS = {
    origin: ORIGIN,
    tangent: POSITIVE_Y
};
/* unused harmony export Y_AXIS */

function getLineFromPoints(p1, p2, dst = {
    origin: create(0, 0),
    tangent: create(0, 0)
}) {
    copy(p1, dst.origin);
    sub(p2, p1, dst.tangent);
    return dst;
}
/**
 * Computes signed distance from a point to a line.
 *
 * @param p The point.
 * @param l1 Start point of the line.
 * @param l2 End point of the line.
 * @returns Distance from the point to the line. It'll be greater than 0 if the
 *      point lies to the left of the line and less than 0 otherwise.
 */
function getSignedDistanceToLine(p, l) {
    const tangent = l.tangent;
    return dot(sub(p, l.origin), create(-tangent.y, tangent.x)) / length(tangent);
}
/**
 * Creates a new extent and initializes it with given components.
 *
 * @param width Width of the extent.
 * @param Height Height of the extent.
 * @returns The extent.
 */
function createExtent2(width, height) {
    return { width, height };
}
/**
 * Copies an extent to another one.
 *
 * @param src The source bbox.
 * @param dst The extent the source extent will be copied to.
 * @returns `dst`.
 */
function copyExtent2(src, dst = createExtent2(0, 0)) {
    dst.width = src.width;
    dst.height = src.height;
    return dst;
}


/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Simple pub/sub implementation. The emitter is supposed to emit only one type of event,
 * if someone has to emit events of different types, multiple emitters should be created.
 */
class EventEmitter {
    constructor() {
        this._listeners = new Set();
    }
    /**
     * Adds listener.
     */
    addListener(listener) {
        this._listeners.add(listener);
    }
    /**
     * Removes listener.
     */
    removeListener(listener) {
        this._listeners.delete(listener);
    }
    /**
     * Calls all the added listeners, the order (e.g. of adding) is not guaranteed.
     */
    fire(data) {
        this._listeners.forEach((listener) => {
            listener(data);
        });
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = EventEmitter;

/**
 * Event emitter with no payload emitted.
 */
class VoidEventEmitter extends EventEmitter {
    fire() {
        super.fire(undefined);
    }
}
/* harmony export (immutable) */ __webpack_exports__["b"] = VoidEventEmitter;



/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_iterable__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_pow_of_2__ = __webpack_require__(55);


/**
 * Gives size of a GL type.
 *
 * @param type The type.
 * @returns Size of the type in bytes.
 */
function getTypeSize(type) {
    switch (type) {
        case 5120 /* BYTE */:
        case 5121 /* UNSIGNED_BYTE */:
            return 1;
        case 5122 /* SHORT */:
        case 5123 /* UNSIGNED_SHORT */:
            return 2;
        case 5124 /* INT */:
        case 5125 /* UNSIGNED_INT */:
        case 5126 /* FLOAT */:
            return 4;
    }
}
/**
 * Description of how particular attributes of a vertex are packed into a vertex
 * buffer.
 */
class AttributeMapping extends Map {
    /**
     * Creates a new attribute mapping with a set of attributes of given types and
     * sizes. Automatically computes offsets of the attributes.
     *
     * @param mapping The mapping from attribute IDs to types and sizes.
     * @param alignment Desired alignment of attributes in the vertex data
     *      structure. Must be a power of 2.
     */
    constructor(mapping, alignment = 4 /* ALIGN_4_BYTES */) {
        let offset = 0;
        super(Object(__WEBPACK_IMPORTED_MODULE_0__util_iterable__["c" /* mapIterable */])(mapping, ([idx, { type, size, normalized }]) => {
            const pointer = [
                idx,
                {
                    type,
                    size,
                    normalized,
                    offset
                }
            ];
            const attributeSize = size * getTypeSize(type);
            const newOffset = Object(__WEBPACK_IMPORTED_MODULE_1__util_pow_of_2__["a" /* align */])(offset + attributeSize, -alignment);
            // TODO(dmikis) Check this in debug mode.
            // if (newOffset - offset > attributeSize) {
            //    console.warn(`${newOffset - offset} byte padding's inserted`);
            // }
            offset = newOffset;
            return pointer;
        }));
        this.vertexByteSize = offset;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = AttributeMapping;



/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Base class for any WebGL renderer, it just defines basic structure of GL-calls allowing to override any part.
 * A specific renderer may need any number of additional arguments to perform rendering, they are provided in
 * additionalParams in the render() method.
 */
class GlRenderer {
    constructor(context, renderState, program) {
        this._context = context;
        this._renderState = renderState;
        this._program = program;
    }
    render(target, ...args) {
        if (this._program) {
            this._prepareProgram(this._program, ...args);
        }
        this._prepareRenderTarget(target, ...args);
        this._render(...args);
    }
    destroy() {
        if (this._program) {
            this._program.destroy();
        }
    }
    /**
     * Binds program and sets required uniforms. Subclasses are supposed to override
     * this method to add their own uniforms.
     */
    _prepareProgram(program, ..._args) {
        this._context.bindProgram(program);
    }
    /**
     * Binds render state and render target, no clear happens here, but this method
     * can be overridden in subclasses to add any setups they need.
     */
    _prepareRenderTarget(target, ..._args) {
        this._context.bindRenderState(this._renderState);
        this._context.bindRenderTarget(target);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = GlRenderer;



/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__gl_renderer__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__memory_count_vertices__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__primitive_batch__ = __webpack_require__(44);



/**
 * Base class for rendering visible primitives. Being visible in the world means that they all need view-projection
 * matrix and camera positions (multiple positions are used for rendering repeated world). These parameters are
 * predefined as external requirements for render() method.
 */
class WorldPrimitiveRenderUnit extends __WEBPACK_IMPORTED_MODULE_0__gl_renderer__["a" /* GlRenderer */] {
    constructor(context, renderState, program, primitiveProvider) {
        super(context, renderState, program);
        this.primitiveProvider = primitiveProvider;
        this.onUpdate = primitiveProvider.onUpdate;
    }
    render(target, viewProjMatrix, cameraPositions, ...args) {
        super.render(target, viewProjMatrix, cameraPositions, ...args);
    }
    _render(_viewProjMatrix, cameraPositions) {
        for (const cameraPosition of cameraPositions) {
            this._program.setVector2Uniform('lookAtHigh', cameraPosition.lookAtHigh);
            this._program.setVector2Uniform('lookAtLow', cameraPosition.lookAtLow);
            for (const memoryBatch of Object(__WEBPACK_IMPORTED_MODULE_2__primitive_batch__["a" /* batchPrimitives */])(this._getPrimitives(), this._canBatchAdjacentPrimitives)) {
                this._renderBatch(memoryBatch);
            }
        }
    }
    _getPrimitives() {
        return this.primitiveProvider.primitives;
    }
    _prepareProgram(program, viewProjMatrix, cameraPositions, ...args) {
        super._prepareProgram(program, viewProjMatrix, cameraPositions, ...args);
        program.setMatrix4Uniform('viewProjMatrix', viewProjMatrix);
    }
    _renderBatch(memoryBatch) {
        this._context.bindVao(memoryBatch.page.vao);
        this._context.drawIndexedMesh(memoryBatch.indexByteOffset, Object(__WEBPACK_IMPORTED_MODULE_1__memory_count_vertices__["a" /* countIndices */])(memoryBatch.indexByteLength, memoryBatch.page.indexType));
    }
    /**
     * Determines if two adjacent primitives can be rendered in one batch (by a single draw call). They already
     * lay successively in memory, but there could be other reasons that forbid batching, like using different textures.
     * The method should be overridden in subclasses if their primitives have such complex rules of batching.
     */
    _canBatchAdjacentPrimitives(_a, _b) {
        return true;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = WorldPrimitiveRenderUnit;



/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__gputypes__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__array__ = __webpack_require__(14);


const WORD_BYTE_SIZE = 4;
/* harmony export (immutable) */ __webpack_exports__["a"] = WORD_BYTE_SIZE;

/**
 * Generates triangles of a fan of a given length as if it is continuous and
 * starts with 0.
 *
 * @param count Number of vertices in the fan.
 * @returns Iterator over indices of triangles.
 */
function* generateFan(count) {
    for (let i = 2; i < count; ++i) {
        yield 0;
        yield i - 1;
        yield i;
    }
}
/**
 * Generates triangles of a strip of a given length as if it is continuous and
 * starts with 0.
 *
 * @param count Number of vertices in the fan.
 * @returns Iterator over indices of triangles.
 */
function* generateStrip(count) {
    yield 0;
    yield 1;
    yield 2;
    let offset0 = 1;
    let offset1 = 2;
    for (let i = 3; i < count; ++i) {
        yield i - offset0;
        yield i - offset1;
        yield i;
        const tmp = offset0;
        offset0 = offset1;
        offset1 = tmp;
    }
}
/**
 * Vertex buffer helper class, that supports sequential writing interface and takes over some single-buffer operations.
 * It is an integral part of the buffer writer class and its main purpose is to make the writer's code easier.
 */
class VertexBuffer {
    /**
     * @param byteSize Initial size of the buffer in bytes. As it gets filled by words
     *      the size must be a multiply of 4.
     */
    constructor(byteSize) {
        this._nextWordOffset = 0;
        this._initBuffers(byteSize);
    }
    /**
     * @returns true if there is no free space remaining in buffer.
     */
    get isFull() {
        return this._nextWordOffset >= this._uint32View.length;
    }
    /**
     * @returns The number of words (4 bytes values) already written.
     */
    get occupiedSize() {
        return this._nextWordOffset;
    }
    /**
     * @return Max number of bytes this buffer is able to store. It can be increased by the extend() method.
     */
    get byteSize() {
        return this._uint32View.byteLength;
    }
    /**
     * Extends buffer to the new size. The new size must be not less than current one and it must be a multiply of 4.
     */
    extend(newByteSize) {
        // TODO assert newByteLength is larger than current _arrayBuffer and its is a multiply of the word size.
        const oldUint32View = this._uint32View;
        this._initBuffers(newByteSize);
        this._uint32View.set(oldUint32View);
    }
    /**
     * Appends value as a uint32 number.
     */
    pushUint32(value) {
        this._uint32View[this._nextWordOffset++] = value;
    }
    /**
     * Appends value as a float32 number.
     */
    pushFloat32(value) {
        this._float32View[this._nextWordOffset++] = value;
    }
    /**
     * @returns uint8 view of this buffer. The size of the view matches the amount of written data.
     */
    asUint32Array() {
        return this._uint32View.subarray(0, this.occupiedSize);
    }
    _initBuffers(byteLength) {
        const arrayBuffer = new ArrayBuffer(byteLength);
        this._uint32View = new Uint32Array(arrayBuffer);
        this._float32View = new Float32Array(arrayBuffer);
    }
    /**
     * Moves "tail" data (from the offset specified to the end of the buffer) of one buffer to another. The cursors of
     * buffers will be appropriately updated to reflect data changes.
     */
    static transferDataTail(src, dst, srcWordOffset, dstOffset = 0) {
        const tailLength = src.occupiedSize - srcWordOffset;
        const srcTail = src._uint32View.subarray(srcWordOffset, src.occupiedSize);
        dst._uint32View.set(srcTail, dstOffset);
        dst._nextWordOffset = tailLength;
        src._nextWordOffset = srcWordOffset;
    }
}
/**
 * Index buffer helper class, that supports sequential writing interface and takes over some single-buffer operations.
 * It is an integral part of the buffer writer class and its main purpose is to make the writer's code easier.
 */
class IndexBuffer {
    /**
     * @param size Initial size of the buffer.
     */
    constructor(size) {
        this._nextIndexOffset = 0;
        this._uint16View = new Uint16Array(size);
    }
    /**
     * @returns The number of indices already written.
     */
    get occupiedSize() {
        return this._nextIndexOffset;
    }
    /**
     * @return Max number of indices this buffer is able to store. It can be increased by the extend() method.
     */
    get size() {
        return this._uint16View.length;
    }
    /**
     * Extends buffer to the new size.
     */
    extend(newSize) {
        // TODO assert newByteLength is larger than current _arrayBuffer
        const oldUint16View = this._uint16View;
        this._uint16View = new Uint16Array(newSize);
        this._uint16View.set(oldUint16View);
    }
    /**
     * Appends index to the end of the buffer.
     */
    push(index) {
        this._uint16View[this._nextIndexOffset++] = index;
    }
    /**
     * @returns uint16 view of this buffer. The size of the view matches the amount of written data.
     */
    asUint16Array() {
        return new Uint16Array(this._uint16View.buffer, 0, this.occupiedSize);
    }
    /**
     * Moves "tail" data (from the offset specified to the end of the buffer) of one buffer to another. The offsets of
     * buffers will be appropriately updated to reflect data changes.
     * baseIndex will be deducted from all moved indices.
     */
    static transferDataTail(src, dst, baseIndex, srcOffset, dstOffset = 0) {
        for (let i = srcOffset, j = dstOffset; i < src.occupiedSize; i++, j++) {
            dst._uint16View[j] = src._uint16View[i] - baseIndex;
        }
        dst._nextIndexOffset = src.occupiedSize - srcOffset;
        src._nextIndexOffset = srcOffset;
    }
}
/**
 * Base buffer writer implementation. Can write unsigned short indices and
 * provides facilities for child classes to handle writing vertex data. Defines
 * a concept of current mesh. Basically, it mean that all vertices and indices
 * written to a writer between two `endMesh` calls (or construction of the writer
 * and an `endMesh` call) must be considered belonging to one atomic piece of
 * geometry and should not be spitted between separate buffers.
 */
class BufferWriter {
    /**
     * Creates a new writer and allocates initial amount of memory to store data.
     * Also implicitly "start" a mesh.
     *
     * @param vertexByteSize
     * @param initVertexBufferSize Init size (in vertices) of growing vertex buffers.
     * @param maxVertexBufferSize Max size (in vertices) of vertex buffers.
     * @param initIndexBufferUint16Size Init size (in uint16 number) of growing index buffers.
     */
    constructor(vertexByteSize, initVertexBufferSize = 0x400, maxVertexBufferSize = 0x10000, initIndexBufferUint16Size = 0xc00) {
        this._vertexByteSize = vertexByteSize;
        this._initVertexBufferByteSize = vertexByteSize * initVertexBufferSize;
        this._maxVertexBufferByteSize = vertexByteSize * maxVertexBufferSize;
        this._initIndexBufferUint16Size = initIndexBufferUint16Size;
        this._vertexBuffer = new VertexBuffer(this._initVertexBufferByteSize);
        this._vertexBuffers = [this._vertexBuffer];
        this._indexBuffer = new IndexBuffer(this._initIndexBufferUint16Size);
        this._indexBuffers = [this._indexBuffer];
        this._currentMeshVertexOffset = 0;
        this._currentMeshIndexOffset = 0;
        this._currentMeshBaseIndex = 0;
    }
    /**
     * Writes a bunch of indices to the underlying storage as unsigned short
     * numbers. If current storage doesn't have enough space to accommodate
     * given indices, the writer will automatically resize it. The writer
     * automatically adds base index to the supplied values, so from a user
     * point of view first vertex of a mesh has index 0 and there's no need
     * to take into account it's offset while generating mesh's topology.
     *
     * @param indices Array of indices to write.
     */
    writeIndices(indices) {
        this._ensureEnoughIndexBufferSpace(indices.length);
        const buffer = this._indexBuffer;
        const baseIndex = this._currentMeshBaseIndex;
        for (let i = 0; i < indices.length; ++i) {
            buffer.push(baseIndex + indices[i]);
        }
    }
    /**
     * Generates triangle indices from an array of indices of a triangle strip
     * (as in GL) and writes generated triplets to the managed index buffer.
     * @see OpenGL ES 2.0 Spec, ยง2.6.1
     *
     * @param indices Indices of the strip.
     */
    writeIndicesForStrip(indices) {
        this._ensureEnoughIndexBufferSpace(3 * (indices.length - 2));
        const buffer = this._indexBuffer;
        const baseIndex = this._currentMeshBaseIndex;
        for (const i of generateStrip(indices.length)) {
            buffer.push(baseIndex + indices[i]);
        }
    }
    /**
     * Generates triangle indices from a continuous triangle strip of a given
     * length and writes generated triplets to managed index buffer.
     * @see OpenGL ES 2.0 Spec, ยง2.6.1
     *
     * @param indexCount
     * @param baseIndexInMesh
     */
    writeIndicesForContinuousStrip(indexCount, baseIndexInMesh = 0) {
        this._ensureEnoughIndexBufferSpace(3 * (indexCount - 2));
        const buffer = this._indexBuffer;
        const baseIndex = this._currentMeshBaseIndex + baseIndexInMesh;
        for (const i of generateStrip(indexCount)) {
            buffer.push(baseIndex + i);
        }
    }
    /**
     * Generates triangle indices from an array of indices of a triangle fan (as
     * in GL) and writes generated triplets to the managed index buffer.
     * @see OpenGL ES 2.0 Spec, ยง2.6.1
     *
     * @param indices Indices of the strip.
     */
    writeIndicesForFan(indices) {
        this._ensureEnoughIndexBufferSpace(3 * (indices.length - 2));
        const buffer = this._indexBuffer;
        const baseIndex = this._currentMeshBaseIndex;
        for (const i of generateFan(indices.length)) {
            buffer.push(baseIndex + indices[i]);
        }
    }
    /**
     * Generates triangle indices from a continuous triangle fan of a given length
     * and writes generated triplets to managed index buffer.
     * @see OpenGL ES 2.0 Spec, ยง2.6.1
     *
     * @param indexCount
     * @param baseIndexInMesh
     */
    writeIndicesForContinuousFan(indexCount, baseIndexInMesh = 0) {
        this._ensureEnoughIndexBufferSpace(3 * (indexCount - 2));
        const buffer = this._indexBuffer;
        const baseIndex = baseIndexInMesh + this._currentMeshBaseIndex;
        for (const i of generateFan(indexCount)) {
            buffer.push(baseIndex + i);
        }
    }
    /**
     * Ends current mesh and implicitly starts a new one.
     *
     * @returns Internal index of vertex and index buffers the mesh was written
     *      to and its memory location in them.
     */
    endMesh() {
        const currentMeshVertexOffset = this._currentMeshVertexOffset;
        const vertexOccupiedSize = this._vertexBuffer.occupiedSize;
        this._currentMeshVertexOffset = vertexOccupiedSize;
        this._currentMeshBaseIndex = (vertexOccupiedSize << 2) / this._vertexByteSize;
        const currentMeshIndexOffset = this._currentMeshIndexOffset;
        const indexOccupiedSize = this._indexBuffer.occupiedSize;
        this._currentMeshIndexOffset = indexOccupiedSize;
        return {
            vertexByteOffset: currentMeshVertexOffset << 2,
            vertexByteLength: vertexOccupiedSize - currentMeshVertexOffset << 2,
            indexByteOffset: currentMeshIndexOffset << 1,
            indexByteLength: indexOccupiedSize - currentMeshIndexOffset << 1,
            // We can't return actual buffer reference since it can change if
            // the buffer gets reallocated.
            bufferIndex: this._vertexBuffers.length - 1
        };
    }
    /**
     * Returns an array of currently owned buffer data. This call's better
     * made when you're done with the writer since if the writer decides to
     * resize any of the buffers some of the references in the returned array
     * may become outdated.
     */
    getBuffers() {
        return Object(__WEBPACK_IMPORTED_MODULE_1__array__["d" /* zip */])(this._vertexBuffers, this._indexBuffers, (vertexBuffer, indexBuffer) => ({
            vertexBuffer: vertexBuffer.asUint32Array(),
            indexBuffer: indexBuffer.asUint16Array()
        }));
    }
    /**
     * Returns an offset in the current vertex buffer to the location where next
     * piece of data will be written.
     */
    getCurrentVertexBufferByteOffset() {
        return this._vertexBuffer.occupiedSize << 2;
    }
    /**
     * Returns index of currently written vertex structure in the current vertex
     * buffer.
     */
    getCurrentVertexIdx() {
        return ((this._vertexBuffer.occupiedSize << 2) / this._vertexByteSize | 0) - this._currentMeshBaseIndex;
    }
    /**
     * Writes a floating point value to the current vertex buffer and advances
     * the offset by 4 bytes.
     *
     * @param value The value to be written.
     */
    _writeFloat32(value) {
        this._ensureEnoughVertexBufferSpace();
        this._vertexBuffer.pushFloat32(value);
    }
    /**
     * Writes an unsigned integer value to the current vertex buffer and advances
     * the offset by 4 bytes.
     *
     * @param value The value to be written.
     */
    _writeWord(value) {
        this._ensureEnoughVertexBufferSpace();
        this._vertexBuffer.pushUint32(value);
    }
    /**
     * Writes an unsigned short value to the current vertex buffer and advances
     * the offset by 2 bytes. Passed values will be truncated to 16 bits.
     *
     * @param value The value to be written.
     */
    _writeHalfWords(v1, v2) {
        this._writeWord(v2 << 16 | v1 & 0xffff);
    }
    /**
     * Writes an unsigned byte value to the current vertex buffer and advances
     * the offset by 1 byte. Passed values will be truncated to 8 bits.
     *
     * @param value The value to be written.
     */
    _writeBytes(v1, v2, v3, v4) {
        this._writeWord(v4 << 24 |
            (v3 & 0xff) << 16 |
            (v2 & 0xff) << 8 |
            v1 & 0xff);
    }
    /**
     * Encodes a world coordinate vector as a pair of 32-bit integers (splitting
     * them in turn into to 16-bit ones).
     *
     * @param c The world coordinate.
     */
    _writeWorldCoordinate(c) {
        // To avoid using GPU singed integer conversions we shift and scale world
        // coordinates so they're in [0, 1] range (instead of [-1, 1]) and then
        // encoded as unsigned 32 bit integers split into to 16 bit ones.
        const xUint32 = Object(__WEBPACK_IMPORTED_MODULE_0__gputypes__["b" /* floatToUint32 */])(0.5 * (c.x + 1));
        const yUint32 = Object(__WEBPACK_IMPORTED_MODULE_0__gputypes__["b" /* floatToUint32 */])(0.5 * (c.y + 1));
        this._writeHalfWords(xUint32 >>> 16, yUint32 >>> 16);
        this._writeHalfWords(xUint32, yUint32);
    }
    /**
     * Computes new bigger size of a vertex buffer based on its current size. By
     * default just double the current size.
     *
     * @param currentByteSize Current size of the index buffer in bytes.
     * @returns The new size.
     */
    _getNextVertexBufferByteSize(currentByteSize) {
        return currentByteSize << 1;
    }
    /**
     * Computes new bigger size of an index buffer based on its current size. By
     * default just double the current size.
     *
     * @param currentUint16Size Current size of the index buffer in shorts.
     * @returns The new size.
     */
    _getNextIndexBufferUint16Size(currentUint16Size) {
        return currentUint16Size << 1;
    }
    /**
     * Ensures that the managed vertex buffer has enough space to fit in a chunk
     * of data of a given size. Either does nothing, resizes the current vertex
     * buffer or creates entirely new pair of vertex and index buffers.
     *
     * @param valueSize Byte size of the data that needs to be accommodated by
     *      the vertex buffer.
     */
    _ensureEnoughVertexBufferSpace() {
        const vertexBuffer = this._vertexBuffer;
        if (!vertexBuffer.isFull) {
            // We have enough space, so nothing to be done.
            return;
        }
        if (vertexBuffer.byteSize < this._maxVertexBufferByteSize) {
            // If we can just resize the current vertex buffer, do that.
            this._vertexBuffer.extend(this._getNextVertexBufferByteSize(vertexBuffer.byteSize));
            return;
        }
        // If there's no enough space in the current vertex buffer and it's
        // already of maximum size, allocate new vertex and index buffers and
        // copy data of the current mesh to them from the current buffers.
        // Then make those buffer the current ones.
        const currentMeshVertexOffset = this._currentMeshVertexOffset;
        const currentMeshVertexByteSize = (vertexBuffer.occupiedSize - currentMeshVertexOffset) * 4;
        const maxVertexBufferByteSize = this._maxVertexBufferByteSize;
        if (currentMeshVertexByteSize === maxVertexBufferByteSize) {
            throw new Error('Mesh is too big to fit in.');
        }
        let newVertexBufferByteSize = this._initVertexBufferByteSize;
        // Initial vertex buffer size may be too small to accommodate the current
        // mesh, so we find next bigger size that is sufficient.
        while (newVertexBufferByteSize <= currentMeshVertexByteSize) {
            newVertexBufferByteSize = this._getNextVertexBufferByteSize(newVertexBufferByteSize);
        }
        const newVertexBuffer = new VertexBuffer(newVertexBufferByteSize);
        VertexBuffer.transferDataTail(vertexBuffer, newVertexBuffer, currentMeshVertexOffset);
        this._vertexBuffer = newVertexBuffer;
        this._vertexBuffers.push(newVertexBuffer);
        this._currentMeshVertexOffset = 0;
        const indexBuffer = this._indexBuffer;
        const currentMeshIndexOffset = this._currentMeshIndexOffset;
        const currentMeshIndexSize = indexBuffer.occupiedSize - currentMeshIndexOffset;
        let newIndexBufferSize = this._initIndexBufferUint16Size;
        // Initial index buffer size may be too small to accommodate the current
        // mesh, so we find next bigger size that is sufficient.
        while (newIndexBufferSize <= currentMeshIndexSize) {
            newIndexBufferSize = this._getNextIndexBufferUint16Size(newIndexBufferSize);
        }
        const newIndexBuffer = new IndexBuffer(newIndexBufferSize);
        // Since the current mesh's copied to the beginning of the new vertex
        // buffer, it's base index now is 0. If the mesh has any written indices,
        // they're already offset by the old base index.
        IndexBuffer.transferDataTail(indexBuffer, newIndexBuffer, this._currentMeshBaseIndex, currentMeshIndexOffset);
        this._currentMeshBaseIndex = 0;
        this._currentMeshIndexOffset = 0;
        this._indexBuffer = newIndexBuffer;
        this._indexBuffers.push(newIndexBuffer);
    }
    /**
     * Ensures that the managed index buffer has enough space to fit in a given
     * number of indices. Either does nothing or resizes the current index
     * buffer.
     *
     * @param indexCount Number of indices client wants to write to the managed
     *      index buffer.
     */
    _ensureEnoughIndexBufferSpace(indexCount) {
        const buffer = this._indexBuffer;
        const requiredSize = buffer.occupiedSize + indexCount;
        if (requiredSize <= buffer.size) {
            // We have enough space so nothing to be done.
            return;
        }
        let newBufferSize = buffer.size;
        // Let's compute new larger size of the index buffer until we can
        // accommodate incoming data.
        while (requiredSize > newBufferSize) {
            newBufferSize = this._getNextIndexBufferUint16Size(newBufferSize);
        }
        this._indexBuffer.extend(newBufferSize);
    }
}
/* harmony export (immutable) */ __webpack_exports__["b"] = BufferWriter;



/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_ref_counted__ = __webpack_require__(20);

/**
 * Base class for primitive objects that are ready to be fed to the renderer.
 */
class RenderablePrimitive extends __WEBPACK_IMPORTED_MODULE_0__util_ref_counted__["a" /* default */] {
    constructor(memorySubChunk) {
        super();
        this.memorySubChunk = memorySubChunk;
    }
    _destroy() {
        this.memorySubChunk.destroy();
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RenderablePrimitive;



/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export findInIterable */
/* harmony export (immutable) */ __webpack_exports__["c"] = mapIterable;
/* harmony export (immutable) */ __webpack_exports__["b"] = filterIterable;
/* unused harmony export reduceIterable */
/* harmony export (immutable) */ __webpack_exports__["d"] = oneOfIterable;
/* harmony export (immutable) */ __webpack_exports__["a"] = allOfIterable;
/* unused harmony export rangeIterable */
/* unused harmony export zipIterables */
/**
 * Searches for the first collection item satisfying a predicate.
 *
 * @param collection The collection.
 * @param predicate The predicate.
 * @returns The first item satisfying the predicate or `undefined` if none found.
 */
function findInIterable(collection, predicate) {
    for (const item of collection) {
        if (predicate(item)) {
            return item;
        }
    }
    return;
}
/**
 * Transforms a collection to another one.
 *
 * @param collection The source collection.
 * @param mapper A function producing items for destination collection.
 * @returns Collection of produced items.
 */
function* mapIterable(collection, mapper) {
    for (const item of collection) {
        yield mapper(item);
    }
}
/**
 * Chooses items of a collection satisfying a predicate.
 *
 * @param collection The collection.
 * @param predicate The predicate.
 * @returns Collection of chosen items.
 */
function* filterIterable(collection, predicate) {
    for (const item of collection) {
        if (predicate(item)) {
            yield item;
        }
    }
}
/**
 * Traverses a collection from left to right recomputing an accumulator on every
 * iteration.
 *
 * @param collection The collection.
 * @param reducer The function used to compute next value of the accumulator.
 * @param initial
 * @returns Value of the accumulator.
 */
function reduceIterable(collection, reducer, initial) {
    let result = initial;
    for (const item of collection) {
        result = reducer(result, item);
    }
    return result;
}
/**
 * Checks if there's at least one item in a collection satisfying a predicate.
 *
 * @param collection The collection.
 * @param predicate The predicate.
 * @returns `true` if for at least one item in the collection the predicate returns
 *      `true` and `false` otherwise.
 */
function oneOfIterable(collection, predicate) {
    for (const item of collection) {
        if (predicate(item)) {
            return true;
        }
    }
    return false;
}
/**
 * Checks if all items of a collection satisfy a predicate.
 *
 * @param collection The collection.
 * @param predicate The predicate.
 * @returns `false` if for at least one item in the collection the predicate returns
 *      `false` and `true` otherwise.
 */
function allOfIterable(collection, predicate) {
    for (const item of collection) {
        if (!predicate(item)) {
            return false;
        }
    }
    return true;
}
/**
 * Creates an iterator for [startIndex, startIndex+length) range.
 */
function* rangeIterable(length, startIndex = 0) {
    const endIndex = startIndex + length;
    for (let i = startIndex; i < endIndex; i++) {
        yield i;
    }
}
function* zipIterables(ts, us, zipper = (t, u) => [t, u]) {
    const tIterator = ts[Symbol.iterator]();
    const uIterator = us[Symbol.iterator]();
    for (let t = tIterator.next(), u = uIterator.next(); !(t.done || u.done); t = tIterator.next(), u = uIterator.next()) {
        yield zipper(t.value, u.value);
    }
}


/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = clamp;
/* harmony export (immutable) */ __webpack_exports__["b"] = cycleRestrict;
/* unused harmony export mix */
/* harmony export (immutable) */ __webpack_exports__["c"] = smoothStep;
/**
 * Clamps a value to a given range.
 *
 * @param x The value.
 * @param min Start of the range.
 * @param max End of the range.
 * @returns Clamped value.
 */
function clamp(x, min, max) {
    return min < x ? x < max ? x : max : min;
}
/**
 * Restricts a value to a given cycled range, i.e. ends of the range are
 * equivalent. E.g. like angles can be restricted to any range of size `2 * PI`.
 *
 * @param x The value.
 * @param min Start of the range.
 * @param max End of the range.
 * @returns Restricted value.
 */
function cycleRestrict(x, min, max) {
    const d = max - min;
    const s = (x - min) / (max - min);
    return min + d * (s - Math.floor(s));
}
/**
 * Linear interpolation.
 *
 * @param min Value that correspond to 0% progress.
 * @param max Value that correspond to 100% progress.
 * @param progress In 0..1.0 range that maps to 0..100% progress. It is allowed to pass a value
 *      outside of this range, that means progress greater then 100% or negative progress.
 */
function mix(min, max, progress) {
    return (1 - progress) * min + progress * max;
}
/**
 * A step function with a smooth transition between given edges. Completely
 * analogous to `smoothstep` in GLSL (GLSL ES 1.0 ยง8.3).
 *
 * @param edge1 The smaller edge.
 * @param edge2
 * @param x `0` if `x < edge1`, `1` if `x > edge2` and an interpolated value for
 *      `edge1 < x < edge2`.
 */
function smoothStep(edge1, edge2, x) {
    const factor = clamp((x - edge1) / (edge2 - edge1), 0, 1);
    return factor * factor * (3 - 2 * factor);
}


/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = getDpr;
/**
 * Gives the device pixel ration if it's greater than 1 and 1 otherwise. This's
 * here purely to be compatible with jsapi which does the same thing for reasons
 * unknows (thanks, kashey).
 *
 * @returns Capped device pixel ratio.
 */
function getDpr() {
    return devicePixelRatio > 1 ? devicePixelRatio : 1;
}


/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["c"] = create;
/* harmony export (immutable) */ __webpack_exports__["b"] = copy;
/* harmony export (immutable) */ __webpack_exports__["a"] = areEqual;
/* unused harmony export decodeAbgr8 */
/* harmony export (immutable) */ __webpack_exports__["d"] = encodeRgba8;
/* unused harmony export isOpaque */
const OPAQUE_BLACK = create(0, 0, 0, 1);
/* unused harmony export OPAQUE_BLACK */

const TRANSPARENT_BLACK = create(0, 0, 0, 0);
/* unused harmony export TRANSPARENT_BLACK */

/**
 * @param r Red component as a normalized value [0..1]
 * @param g Green component as a normalized value [0..1]
 * @param b Blue component as a normalized value [0..1]
 * @param a Alpha component as a normalized value [0..1]
 *
 * @returns A color with given values assigned to components.
 */
function create(r, g, b, a = 1) {
    return { r, g, b, a };
}
/**
 * Copies a color to another one.
 *
 * @param src The source color.
 * @param dst The color the source color will be copied to.
 * @returns `dst`.
 */
function copy(src, dst = create(0, 0, 0, 0)) {
    dst.r = src.r;
    dst.g = src.g;
    dst.b = src.b;
    dst.a = src.a;
    return dst;
}
function areEqual(c1, c2) {
    return c1.r === c2.r && c1.g === c2.g && c1.b === c2.b && c1.a === c2.a;
}
/**
 * Decodes a color represented as four 8-bit channels encoded into a 32-bit
 * number in ABGR order (from MSB to LSB).
 *
 * @param color Color encoded into unsigned 32-bit integer.
 * @returns Decoded color.
 */
function decodeAbgr8(color) {
    return {
        r: (color >>> 24) / 0xff,
        g: (color >>> 16 & 0xff) / 0xff,
        b: (color >>> 8 & 0xff) / 0xff,
        a: (color & 0xff) / 0xff
    };
}
/**
 * Encodes a color components into four 8 bit numbers packed into 32-bit one.
 *
 * @param c The color to be encoded.
 * @returns The color as 32-bit integer.
 */
function encodeRgba8(c) {
    return (c.r * 0xff |
        (c.g * 0xff << 8) |
        (c.b * 0xff << 16) |
        (c.a * 0xff << 24));
}
/**
 * Checks if a color is completely opaque.
 *
 * @param color The color to be checked.
 * @returns `true` if the color is opaque and `false` otherwise.
 */
function isOpaque(color) {
    return color.a === 1;
}


/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["e"] = create;
/* unused harmony export copy */
/* unused harmony export areEqual */
/* unused harmony export areFuzzyEqual */
/* unused harmony export areCollinear */
/* unused harmony export add */
/* harmony export (immutable) */ __webpack_exports__["n"] = sub;
/* harmony export (immutable) */ __webpack_exports__["j"] = mulv;
/* harmony export (immutable) */ __webpack_exports__["i"] = muln;
/* unused harmony export divv */
/* unused harmony export divn */
/* unused harmony export length */
/* unused harmony export distance */
/* harmony export (immutable) */ __webpack_exports__["k"] = normalize;
/* harmony export (immutable) */ __webpack_exports__["g"] = dot;
/* harmony export (immutable) */ __webpack_exports__["f"] = cross;
/* harmony export (immutable) */ __webpack_exports__["l"] = rotateX;
/* unused harmony export rotateY */
/* harmony export (immutable) */ __webpack_exports__["m"] = rotateZ;
/* unused harmony export getPlaneLineIntersection */
/* harmony export (immutable) */ __webpack_exports__["h"] = getPlaneRayIntersection;
/* unused harmony export getPlanePlaneIntersection */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__matrix3__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_fuzzy_equal__ = __webpack_require__(25);


/**
 * Creates a new vector and initializes it with given components.
 *
 * @param x X component of the vector.
 * @param y Y component of the vector.
 * @param z Z component of the vector.
 * @returns The vector.
 */
function create(x, y, z) {
    return { x, y, z };
}
const ORIGIN = create(0, 0, 0);
/* harmony export (immutable) */ __webpack_exports__["a"] = ORIGIN;

const POSITIVE_X = create(1, 0, 0);
/* unused harmony export POSITIVE_X */

const NEGATIVE_X = create(-1, 0, 0);
/* unused harmony export NEGATIVE_X */

const POSITIVE_Y = create(0, 1, 0);
/* harmony export (immutable) */ __webpack_exports__["b"] = POSITIVE_Y;

const NEGATIVE_Y = create(0, -1, 0);
/* unused harmony export NEGATIVE_Y */

const POSITIVE_Z = create(0, 0, 1);
/* harmony export (immutable) */ __webpack_exports__["c"] = POSITIVE_Z;

const NEGATIVE_Z = create(0, 0, -1);
/* unused harmony export NEGATIVE_Z */

/**
 * Copies a vector to another one.
 *
 * @param src The source vector.
 * @param dst The vector the source vector will be copied to.
 * @returns `dst`.
 */
function copy(src, dst = create(0, 0, 0)) {
    dst.x = src.x;
    dst.y = src.y;
    dst.z = src.z;
    return dst;
}
/**
 * Checks if two vectors are strictly equal component-wise.
 *
 * @param v1 The first vector.
 * @param v2 The second vector.
 * @returns `true` if the vectors are equal and `false` otherwise.
 */
function areEqual(v1, v2) {
    return v1.x === v2.x && v1.y === v2.y && v1.z === v2.z;
}
/**
 * Checks if corresponding components of two vectors are all within given
 * tolerance from each other.
 *
 * @param v1 The first vector.
 * @param v2 The second vector.
 * @param tolerance The tolerance.
 * @returns `true` if the vectors are "fuzzy" equal and `false` otherwise.
 */
function areFuzzyEqual(v1, v2, tolerance = __WEBPACK_IMPORTED_MODULE_1__util_fuzzy_equal__["a" /* DEFAULT_TOLERANCE */]) {
    return (Object(__WEBPACK_IMPORTED_MODULE_1__util_fuzzy_equal__["b" /* default */])(v1.x, v2.x, tolerance) &&
        Object(__WEBPACK_IMPORTED_MODULE_1__util_fuzzy_equal__["b" /* default */])(v1.y, v2.y, tolerance) &&
        Object(__WEBPACK_IMPORTED_MODULE_1__util_fuzzy_equal__["b" /* default */])(v1.z, v2.z, tolerance));
}
/**
 * Checks if two vectors are collinear.
 *
 * @param v1 The first vector.
 * @param v2 The second vector.
 * @returns `true` if the vectors are collinear and `false` otherwise.
 */
function areCollinear(v1, v2) {
    const lambdaX = v1.x / v2.x;
    const lambdaY = v1.y / v2.y;
    const lambdaZ = v1.z / v2.z;
    return lambdaX === lambdaY && lambdaY === lambdaZ;
}
/**
 * Adds two vector and stores the result into a third one, i.e. `dst = a + b`.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function add(a, b, dst = create(0, 0, 0)) {
    dst.x = a.x + b.x;
    dst.y = a.y + b.y;
    dst.z = a.z + b.z;
    return dst;
}
/**
 * Subtracts a vector from another one and stores the result to a third one, i.e.
 * `dst = a - b`.
 *
 * @param a The minuend vector.
 * @param b The subtrahend vector.
 * @param dst The vector the result will be stored to.
 */
function sub(a, b, dst = create(0, 0, 0)) {
    dst.x = a.x - b.x;
    dst.y = a.y - b.y;
    dst.z = a.z - b.z;
    return dst;
}
/**
 * Multiplies two vectors component-wise and stores the result into a third one.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function mulv(a, b, dst = create(0, 0, 0)) {
    dst.x = a.x * b.x;
    dst.y = a.y * b.y;
    dst.z = a.z * b.z;
    return dst;
}
/**
 * Multiplies a vector by a scalar and stores the result into a third vector.
 *
 * @param a The vector.
 * @param n The scalar.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function muln(a, n, dst = create(0, 0, 0)) {
    dst.x = a.x * n;
    dst.y = a.y * n;
    dst.z = a.z * n;
    return dst;
}
/**
 * Divides a vector by another one component wise and stores the result into a
 * third one.
 *
 * @param a The dividend vector.
 * @param b The divisor vector.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function divv(a, b, dst = create(0, 0, 0)) {
    dst.x = a.x / b.x;
    dst.y = a.y / b.y;
    dst.z = a.z / b.z;
    return dst;
}
/**
 * Divides a vector by a scalar and stores the result into a third vector.
 *
 * @param a The dividend vector.
 * @param n The scalar.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function divn(a, n, dst = create(0, 0, 0)) {
    dst.x = a.x / n;
    dst.y = a.y / n;
    dst.z = a.z / n;
    return dst;
}
/**
 * Computes length of a vector.
 *
 * @param v The vector.
 * @returns The length.
 */
function length(v) {
    return Math.hypot(v.x, v.y, v.z);
}
/**
 * Computes distance between ends of two vectors.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @returns The distance, i.e. `length(sub(a, b))`.
 */
function distance(a, b) {
    return Math.hypot(a.x - b.x, a.y - b.y, a.z - b.z);
}
/**
 * Divides a vector by its length (thus making it a unit vector) and stores the
 * result to another one.
 *
 * @param v The vector to be normalized.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function normalize(v, dst = create(0, 0, 0)) {
    return divn(v, length(v), dst);
}
/**
 * Computes dot product of two vectors.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @returns The dot product.
 */
function dot(a, b) {
    return a.x * b.x + a.y * b.y + a.z * b.z;
}
/**
 * Computes cross product of two vectors and stores it to a third one.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function cross(a, b, dst = create(0, 0, 0)) {
    // Write components to a separate variables so we don't produce incorrect
    // results in cases when a == dst or b == dst.
    const x = a.y * b.z - a.z * b.y;
    const y = a.z * b.x - a.x * b.z;
    const z = a.x * b.y - a.y * b.x;
    dst.x = x;
    dst.y = y;
    dst.z = z;
    return dst;
}
/**
 * Rotates vector about the X axis.
 *
 * @param v The vector to be rotated.
 * @param angle The angle of rotation (in radians), positive values rotates from +Y to +Z
 * @param dst The vector the result will be stored to.
 */
function rotateX(v, angle, dst = create(0, 0, 0)) {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    const y = v.y;
    dst.x = v.x;
    dst.y = y * cos - v.z * sin;
    dst.z = y * sin + v.z * cos;
    return dst;
}
/**
 * Rotates vector about the Y axis.
 *
 * @param v The vector to be rotated.
 * @param angle The angle of rotation (in radians), positive values rotates from +X to +Z
 * @param dst The vector the result will be stored to.
 */
function rotateY(v, angle, dst = create(0, 0, 0)) {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    // handle the case when source and destination are the same object: related components can break each other
    v = (v === dst) ? copy(v) : v;
    dst.x = v.x * cos + v.z * sin;
    dst.y = v.y;
    dst.z = -v.x * sin + v.z * cos;
    return dst;
}
/**
 * Rotates vector about the Z axis.
 *
 * @param v The vector to be rotated.
 * @param angle The angle of rotation (in radians), positive values rotates from +X to +Y
 * @param dst The vector the result will be stored to.
 */
function rotateZ(v, angle, dst = create(0, 0, 0)) {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    // handle the case when source and destination are the same object: related components can break each other
    v = (v === dst) ? copy(v) : v;
    dst.x = v.x * cos - v.y * sin;
    dst.y = v.x * sin + v.y * cos;
    dst.z = v.z;
    return dst;
}
const X_AXIS = {
    origin: ORIGIN,
    tangent: POSITIVE_X
};
/* unused harmony export X_AXIS */

const Y_AXIS = {
    origin: ORIGIN,
    tangent: POSITIVE_Y
};
/* unused harmony export Y_AXIS */

const Z_AXIS = {
    origin: ORIGIN,
    tangent: POSITIVE_Z
};
/* unused harmony export Z_AXIS */

const XY = {
    normal: POSITIVE_Z,
    distance: 0
};
/* harmony export (immutable) */ __webpack_exports__["d"] = XY;

const YZ = {
    normal: POSITIVE_X,
    distance: 0
};
/* unused harmony export YZ */

const ZX = {
    normal: POSITIVE_Y,
    distance: 0
};
/* unused harmony export ZX */

/**
 * Computes intersection of a plane and a line.
 *
 * @param p The plane.
 * @param l The line.
 * @returns The point or `null` if the line is parallel to the plane.
 */
function getPlaneLineIntersection(p, l) {
    const dotLP = dot(l.tangent, p.normal);
    // If plane normal and line tangent vector are perpendicular intersection is
    // either an empty set or the line itself.
    if (dotLP === 0) {
        return null;
    }
    const intersection = copy(l.tangent);
    muln(intersection, (p.distance - dot(p.normal, l.origin)) / dotLP, intersection);
    add(intersection, l.origin, intersection);
    return intersection;
}
/**
 * Computes an intersection of a plane and a ray and stores it into a given
 * vector.
 *
 * @param plane The plane.
 * @param ray The ray.
 * @param dst The vector the intersection point will be stored to. If there's no
 *      intersection, this vector will be left unmodified.
 * @returns The `dst` or `null` if the ray doesn't have a common point with the
 *      plane.
 */
function getPlaneRayIntersection(plane, ray, dst = create(0, 0, 0)) {
    const dotRP = dot(ray.direction, plane.normal);
    if (dotRP === 0) {
        // The plane normal and the ray direction vector are perpendicular, so
        // intersection is either an empty set or the ray itself.
        return null;
    }
    const lambda = (plane.distance - dot(plane.normal, ray.origin)) / dotRP;
    if (lambda < 0) {
        // The intersection point is on a line that contains the ray, but not on
        // the ray itself.
        return null;
    }
    copy(ray.direction, dst);
    muln(dst, lambda, dst);
    add(dst, ray.origin, dst);
    return dst;
}
/**
 * Computes intersection of two planes.
 *
 * @param p1 The first plane.
 * @param p2 The second plane.
 * @returns The line or `null` if the planes are parallel to each other.
 */
function getPlanePlaneIntersection(p1, p2) {
    const n1 = p1.normal;
    const n2 = p2.normal;
    if (areCollinear(n1, n2)) {
        return null;
    }
    const tangent = cross(n1, n2);
    normalize(tangent);
    return {
        tangent,
        origin: __WEBPACK_IMPORTED_MODULE_0__matrix3__["b" /* solve */](__WEBPACK_IMPORTED_MODULE_0__matrix3__["a" /* fromRows */](n1, n2, tangent), create(p1.distance, p2.distance, 0))
    };
}


/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["c"] = floatToUint8;
/* harmony export (immutable) */ __webpack_exports__["a"] = floatToUint16;
/* unused harmony export floatToInt16 */
/* harmony export (immutable) */ __webpack_exports__["b"] = floatToUint32;
/* unused harmony export floatToInt32 */
/* unused harmony export int32ToFloat */
/* unused harmony export uint32ToFloat */
/* unused harmony export int16ToFloat */
/* harmony export (immutable) */ __webpack_exports__["d"] = uint16ToFloat;
/* unused harmony export uint8ToFloat */
const UINT8_MAX = 0xff;
const UINT16_MAX = 0xffff;
const UINT32_MAX = 0xffffffff;
function floatToUint8(x) {
    return UINT8_MAX * x | 0;
}
function floatToUint16(x) {
    return x * UINT16_MAX | 0;
}
function floatToInt16(x) {
    return (x * UINT16_MAX - 1) / 2 | 0;
}
function floatToUint32(x) {
    return x * UINT32_MAX | 0;
}
function floatToInt32(x) {
    return (x * UINT32_MAX - 1) / 2 | 0;
}
function int32ToFloat(x) {
    return (2 * x + 1) / UINT32_MAX;
}
function uint32ToFloat(x) {
    return x / UINT32_MAX;
}
function int16ToFloat(x) {
    return (2 * x + 1) / UINT16_MAX;
}
function uint16ToFloat(x) {
    return x / UINT16_MAX;
}
function uint8ToFloat(x) {
    return x / UINT8_MAX;
}


/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["c"] = swap;
/* unused harmony export reverse */
/* unused harmony export rotate */
/* harmony export (immutable) */ __webpack_exports__["b"] = copy;
/* unused harmony export shuffle */
/* harmony export (immutable) */ __webpack_exports__["d"] = zip;
/* harmony export (immutable) */ __webpack_exports__["a"] = compare;
/* unused harmony export insertionSort */
/* unused harmony export mergeSort */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__comparator__ = __webpack_require__(19);

/**
 * Swaps two values in an array.
 *
 * @param array The array.
 * @param i Index of a value to be swapped.
 * @param j Index of a value to be swapped.
 */
function swap(array, i, j) {
    const t = array[i];
    array[i] = array[j];
    array[j] = t;
}
/**
 * Reverses order of elements in a range in an array.
 *
 * @param array The array.
 * @param start The start of the range.
 * @param end The end of the range.
 */
function reverse(array, start = 0, end = array.length) {
    for (let i = start, j = end - 1; i < j; ++i, --j) {
        swap(array, i, j);
    }
}
/**
 * Rotates a range of elements in an array by given amount.
 *
 * @param array The array.
 * @param amount The amount.
 * @param start The start of the range.
 * @param end The end of the range.
 */
function rotate(array, amount = 1, start = 0, end = array.length) {
    reverse(array, start, end);
    reverse(array, start, start + amount);
    reverse(array, start + amount, end);
}
/**
 * Copies a range of elements from a source array to a range in a destination
 * array.
 *
 * @param src The source array.
 * @param dst The destination array.
 * @param srcStart The start of the source range.
 * @param srcStart The start of the source range.
 * @param dstStart The start of the destination range.
 */
function copy(src, dst, srcStart = 0, srcEnd = src.length, dstStart = 0) {
    for (let i = srcStart, j = dstStart; i < srcEnd; ++i, ++j) {
        dst[j] = src[i];
    }
}
/**
 * Shuffles randomly a range of elements in an array.
 *
 * @param array The array.
 * @param start The start of the range.
 * @param end The end of the range.
 */
function shuffle(array, start = 0, end = array.length) {
    for (let i = start, j = i + 1; i < end; ++i, ++j) {
        swap(array, i, j + (Math.random() * (end - j) | 0));
    }
}
function zip(ts, us, zipper = (t, u) => [t, u]) {
    const l = Math.min(ts.length, us.length);
    const vs = new Array(l);
    for (let i = 0; i < l; ++i) {
        vs[i] = zipper(ts[i], us[i]);
    }
    return vs;
}
/**
 * Compares two arrays lexicographically. The order is specified be the comparator parameter.
 *
 * @param comparator Elements comparator with standard signature.
 * @param a The first array to compare.
 * @param b The second array to compare.
 * @returns 0 if all elements and lengths are equal,
 *      negative number if the first element is less then the second (lexicographically),
 *      positive number if the first element is greater then the second,
 *      if all the elements are equal the lengths are being compared.
 */
function compare(comparator, a, b) {
    const length = Math.min(a.length, b.length);
    for (let i = 0; i < length; i++) {
        const result = comparator(a[i], b[i]);
        if (result) {
            return result;
        }
    }
    return a.length - b.length;
}
/**
 * Sorts a range of elements of an array in place with insertion sort.
 *
 * @param array The array to be sorted.
 * @param comparator Comparator for array elements.
 * @param start Index of the first element in the range to be sorted.
 * @param end Index of an element behind the last element in the range to be
 *      sorted.
 */
function insertionSort(array, comparator = __WEBPACK_IMPORTED_MODULE_0__comparator__["a" /* DEFAULT_COMPARATOR */], start = 0, end = array.length) {
    for (let i = start; i < end; ++i) {
        for (let j = i; j > start && comparator(array[j - 1], array[j]) > 0; --j) {
            swap(array, j - 1, j);
        }
    }
}
const BLOCK_SIZE = 32;
/**
 * Merges two sorted ranges of an array. Stores the result into another one.
 *
 * @param src The array with the ranges to be merged.
 * @param dst The array the resulting range will be stored to.
 * @param comparator The comparator for array elements.
 * @param start Start of the first range to be merged.
 * @param middle End of the first and simultaneously start of the second range
 *      to be merged.
 * @param end End of the second range to be merged.
 * @param dstOffset Offset of merged range in the result array.
 */
function merge(src, dst, comparator, start, middle, end, dstOffset) {
    let i = dstOffset;
    let j = start;
    let k = middle;
    while (j < middle && k < end) {
        dst[i++] = comparator(src[j], src[k]) > 0 ? src[k++] : src[j++];
    }
    copy(src, dst, j, middle, i);
    copy(src, dst, k, end, i);
}
/**
 * Sorts a range of elements of an array with merge sort.
 *
 * @param array  The array to be sorted.
 * @param comparator Comparator for array elements.
 * @param end Index of an element behind the last element in the range to be
 *      sorted.
 */
function mergeSort(array, comparator = __WEBPACK_IMPORTED_MODULE_0__comparator__["a" /* DEFAULT_COMPARATOR */], start = 0, end = array.length) {
    // First and foremost: if the range is smaller than the block size, just
    // perform insertion sort on it.
    if (end - start <= BLOCK_SIZE) {
        insertionSort(array, comparator, start, end);
        return;
    }
    // First we split the given range into subranges of size BLOCK_SIZE and
    // sort every range with insertion sort.
    {
        let s = start;
        let e = s + BLOCK_SIZE;
        while (e < end) {
            insertionSort(array, comparator, s, e);
            s = e;
            e += BLOCK_SIZE;
        }
        insertionSort(array, comparator, s, end);
    }
    // TODO(dmikis): Implement in-place merge. It seems there're reasonably
    //      complex solutions out there.
    const auxArray = new Array(end - start);
    // Then we merge blocks pairs, increase block size by 2 and repeat.
    for (let blockSize = BLOCK_SIZE; blockSize < end - start; blockSize += blockSize) {
        // TODO(dmikis): Before aforementioned todo maybe implement array
        // pingponging to cut down amount of full copies.
        copy(array, auxArray, start, end);
        let i = start;
        let s = 0;
        let m = blockSize;
        let e = m + blockSize;
        while (e < end - start) {
            merge(auxArray, array, comparator, s, m, e, i);
            s = e;
            m = s + blockSize;
            e = m + blockSize;
            i += 2 * blockSize;
        }
        merge(auxArray, array, comparator, s, Math.min(m, end - start), end - start, i);
    }
}


/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = countVertices;
/* harmony export (immutable) */ __webpack_exports__["a"] = countIndices;
/**
 * @returns Integer number of vertices that fit into a region of specified in bytes size.
 */
function countVertices(vertexByteSize, attribMapping) {
    return vertexByteSize / attribMapping.vertexByteSize | 0;
}
/**
 * @returns Integer number of indices that fit into a region of specified in bytes size.
 */
function countIndices(indexByteSize, type) {
    switch (type) {
        case 5123 /* UNSIGNED_SHORT */:
            return indexByteSize >> 1;
        case 5125 /* UNSIGNED_INT */:
            return indexByteSize >> 2;
        default:
            return -1;
    }
}


/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = getTileIdByRawValues;
/* harmony export (immutable) */ __webpack_exports__["a"] = getTileId;
function getTileIdByRawValues(x, y, zoom) {
    return `${x}:${y}:${zoom}`;
}
function getTileId(tile) {
    return getTileIdByRawValues(tile.x, tile.y, tile.zoom);
}


/***/ }),
/* 17 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export messageIs */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__event_emitter__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__unique_id__ = __webpack_require__(26);
/**
 * Base interface for webworker messages, both incoming and outgoing ones.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Transferable
 */


const MESSAGE_BATCH_MAX_SIZE = 50;
const FLUSH_TIMEOUT = 50;
// each subsequent message debounces postMessage call, that can lead to infinite delay, this const limits it
const MAX_FLUSH_TIMEOUT = 250;
const NO_ID = -1;
/* harmony export (immutable) */ __webpack_exports__["a"] = NO_ID;

/**
 * Checks message type with type guarding. It gives a little bit more elegant alternative
 * to tagged type unions providing the same type safety.
 *
 * @param message to be checked
 * @param type the value of the "type" property
 * @return {boolean}
 */
function messageIs(message, type) {
    return message.type === type;
}
/**
 * Base class for both sides of a webworker: its implementation (separate js that is run in a worker thread) and
 * a controller for the main thread. They have similar mechanism of sending/receiving messages that is implement here.
 */
class WebWorkerCommunicator {
    constructor(addressee) {
        this._addressee = addressee;
        this._events = new __WEBPACK_IMPORTED_MODULE_0__event_emitter__["a" /* EventEmitter */]();
        this._listeners = new Map();
        this._transferableExtractors = new Map();
        this._messages = [];
        this._transferables = [];
        this._timeoutHandle = 0;
        this._flushMessagesBinded = this._flushMessages.bind(this);
    }
    setTransferableExtractor(type, extractor) {
        this._transferableExtractors.set(type, extractor);
    }
    /**
     * Send a message to the opposite side of the web worker communication channel.
     * Messages are batched by delaying postMessage call to group messages that come during this delay and minimize
     * the number of interprocess communications that badly affect performance.
     *
     * @param message Message to be sent.
     * @param urgency IMMEDIATE forces message to be sent immediately (synchronous call) with no batching delay,
     *                DEFAULT debounces sending for another FLUSH_TIMEOUT.
     */
    sendMessage(message, urgency = 0 /* DEFAULT */) {
        const transferableExtractor = this._transferableExtractors.get(message.type);
        const transferables = transferableExtractor ? transferableExtractor(message) : undefined;
        const isFirstMessageInBatch = (this._messages.length === 0);
        if (isFirstMessageInBatch) {
            this._firstMessageTime = performance.now();
        }
        // Send messages asynchronously packing them into one message.
        // We don't want to abuse the web worker communication channel and
        // send messages asynchronously in short period of time or many messages synchronously.
        this._messages.push(message);
        if (transferables) {
            this._transferables = this._transferables.concat(transferables);
        }
        clearTimeout(this._timeoutHandle);
        if (this._messages.length > MESSAGE_BATCH_MAX_SIZE ||
            urgency === 1 /* IMMEDIATE */ ||
            (!isFirstMessageInBatch && (performance.now() - this._firstMessageTime) > MAX_FLUSH_TIMEOUT)) {
            this._flushMessages();
        }
        else {
            this._timeoutHandle = setTimeout(this._flushMessagesBinded, FLUSH_TIMEOUT);
        }
    }
    /**
     * Sends request message to/from worker as promise, the other side can respond and the promise is resolved.
     * Request/response is synchronized by the requestId field.
     */
    request(request, urgency) {
        return new Promise((resolve, reject) => {
            if (request.requestId === NO_ID) {
                request.requestId = Object(__WEBPACK_IMPORTED_MODULE_1__unique_id__["a" /* uniqueId */])();
            }
            const listener = (message) => {
                if (messageIs(message, request.responseType) &&
                    message.requestId === request.requestId) {
                    resolve(message);
                    this._events.removeListener(listener);
                }
                if (messageIs(message, request.errorType) &&
                    message.requestId === request.requestId) {
                    reject();
                    this.off(listener);
                }
            };
            this._events.addListener(listener);
            this.sendMessage(request, urgency);
        });
    }
    /**
     * Responds to provided request.
     */
    respond(request, response, urgency) {
        response.requestId = request.requestId;
        this.sendMessage(response, urgency);
    }
    /**
     * Sets a listener to specific type of incoming messages.
     */
    on(type, listener) {
        const typeSafeListener = (message) => {
            if (messageIs(message, type)) {
                listener(message);
            }
        };
        this._listeners.set(listener, typeSafeListener);
        this._events.addListener(typeSafeListener);
    }
    /**
     * Removes incoming messages listener.
     */
    off(listener) {
        const typeSafeListener = this._listeners.get(listener);
        if (typeSafeListener) {
            this._events.removeListener(typeSafeListener);
        }
    }
    /**
     * Starts listening for incoming messages.
     */
    listen() {
        this._addressee.onmessage = ({ data: messages }) => {
            for (const message of messages) {
                this.onMessage(message);
            }
        };
    }
    /**
     * Handler of incoming messages.
     */
    onMessage(message) {
        this._events.fire(message);
    }
    _flushMessages() {
        this._addressee.postMessage(this._messages, this._transferables);
        this._messages.length = 0;
        this._transferables.length = 0;
    }
}
/* unused harmony export WebWorkerCommunicator */

/**
 * Base class for a webworker controller for the main thread code.
 * It also wraps creation of a native Worker.
 */
class WebWorkerClient extends WebWorkerCommunicator {
    /**
     * @param url URL of webworker's deployed js file
     */
    constructor(url) {
        const worker = new Worker(url);
        super(worker);
        this._worker = worker;
        this.listen();
    }
    destroy() {
        this._worker.terminate();
    }
}
/* harmony export (immutable) */ __webpack_exports__["b"] = WebWorkerClient;

/**
 * Base class for a webworker thread implementation. Concrete class should be the entry point for a webworker js build:
 *     new ConcreteWebWorkerImplementation(<DedicatedWorkerGlobalScope>self).run();
 */
class WebWorkerImplementation extends WebWorkerCommunicator {
    run() {
        this.listen();
    }
}
/* unused harmony export WebWorkerImplementation */



/***/ }),
/* 18 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = countFps;
/* harmony export (immutable) */ __webpack_exports__["b"] = countTileParseTime;
/* harmony export (immutable) */ __webpack_exports__["c"] = countTileProcessingTime;
const PROJECT_ID = 443;
function chooseStatUrl() {
    // FIXME(dmikis) Ideally we should be get this URLs from config.
    const STAT_URLS = {
        ru: 'https://yandex.ru/clck',
        com: 'https://yandex.com/clck',
        tr: 'https://yandex.com.tr/clck'
    };
    const tld = location.hostname.split('.').pop();
    switch (tld) {
        case 'tr':
            return STAT_URLS.tr;
        case 'com':
        case 'fr':
            return STAT_URLS.com;
        default:
            return STAT_URLS.ru;
    }
}
const STAT_URL = chooseStatUrl();
function stringifyVars(vars) {
    return Object.keys(vars).map((key) => `${key}=${vars[key]}`).join(',');
}
function count(pid, cid, path, vars) {
    const url = `${STAT_URL}/counter`;
    const data = `/dtype=stred/pid=${pid}/cid=${cid}` +
        `/path=${path.join('.')}/${vars ? `vars=${stringifyVars(vars)}/` : ''}`;
    if (!(navigator.sendBeacon && navigator.sendBeacon(url, data + '*'))) {
        const image = new Image();
        image.src = url + data + `rnd=${Date.now()}${Math.random() * 100 | 0}/*`;
    }
}
const PERF_COUNTER_ID = 73323;
/**
 * Log user's rendering perf to statface.
 *
 * @param fps FPS
 */
function countFps(fps) {
    const roundedFps = Math.floor(fps / 10) * 10;
    count(PROJECT_ID, PERF_COUNTER_ID, ['fps', `${roundedFps}-${roundedFps + 10}`, (fps * 100).toFixed()]);
}
function encodeTileItem(tileItem) {
    return `${tileItem.x}.${tileItem.y}.${tileItem.zoom}`;
}
function countTileParseTime(layer, minTimeTile, minTime, maxTimeTile, maxTime, medianTimeTile, medianTime) {
    count(PROJECT_ID, PERF_COUNTER_ID, [
        'tile_parse',
        layer
    ], {
        minTime: minTime.toFixed(),
        medianTime: medianTime.toFixed(),
        maxTime: maxTime.toFixed(),
        minTileItem: encodeTileItem(minTimeTile),
        medianTileItem: encodeTileItem(medianTimeTile),
        maxTileItem: encodeTileItem(maxTimeTile)
    });
}
function countTileProcessingTime(layer, items) {
    const varsToLog = {};
    items.forEach((item) => {
        if (item.zoom === 'average') {
            count(PROJECT_ID, PERF_COUNTER_ID, [
                'tile_processing_average',
                layer,
                (Math.ceil(item.time / 250) * 250).toString()
            ]);
        }
        varsToLog[item.zoom] = item.time.toFixed();
    });
    count(PROJECT_ID, PERF_COUNTER_ID, ['tile_processing', layer], varsToLog);
}


/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = DEFAULT_COMPARATOR;
/* harmony export (immutable) */ __webpack_exports__["b"] = NUMERICAL_COMPARATOR;
function DEFAULT_COMPARATOR(a, b) {
    if (a > b) {
        return 1;
    }
    if (a < b) {
        return -1;
    }
    return 0;
}
function NUMERICAL_COMPARATOR(a, b) {
    return a - b;
}


/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Simple reference counting for shared entities that need explicit destruction.
 */
class ReferenceCounted {
    /**
     * Initializes reference count to 1.
     */
    constructor() {
        this._refCount = 1;
    }
    /**
     * Increments reference count.
     */
    retain() {
        if (this._refCount === 0) {
            throw new Error('Tried to retain a destroyed object.');
        }
        this._refCount++;
    }
    /**
     * Decrements reference count and, if it's reached 0, destroys the object.
     */
    release() {
        if (this._refCount === 0) {
            throw new Error('Tried to release a destroyed object.');
        }
        this._refCount--;
        if (this._refCount === 0) {
            this._destroy();
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ReferenceCounted;



/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__primitive_manager__ = __webpack_require__(38);

/**
 * Manager of primitives that have a single assiciated renderable primitive. The "management" is pretty straightforward:
 * it directly adds/removes associated primitives into the storage.
 */
class RenderablePrimitiveManager extends __WEBPACK_IMPORTED_MODULE_0__primitive_manager__["a" /* default */] {
    constructor(primitivesStorage) {
        super();
        this._primitivesStorage = primitivesStorage;
    }
    updateScene(toShow, toHide) {
        this._primitivesStorage.add(...toShow);
        this._primitivesStorage.delete(...toHide);
    }
    destroyPrimitives(_toDestroy) {
        // no need to destroy anything, RenderablePrimitive are released when removed from primmitive storage
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RenderablePrimitiveManager;



/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_polygon_vert__ = __webpack_require__(144);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_polygon_vert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__shader_polygon_vert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_polygon_frag__ = __webpack_require__(145);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_polygon_frag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__shader_polygon_frag__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__render_state__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__world_primitive_render_unit__ = __webpack_require__(5);




const DEFAULT_RENDER_STATE_PARAMS = {
    depthTest: true,
    depthFunc: 518 /* GREATER_OR_EQUAL */
};
/* harmony export (immutable) */ __webpack_exports__["a"] = DEFAULT_RENDER_STATE_PARAMS;

/**
 * Renderer of polygon primitives.
 */
class PolygonRenderUnit extends __WEBPACK_IMPORTED_MODULE_3__world_primitive_render_unit__["a" /* default */] {
    constructor(context, primitiveProvider, renderState = new __WEBPACK_IMPORTED_MODULE_2__render_state__["c" /* default */](DEFAULT_RENDER_STATE_PARAMS)) {
        const program = context.createProgram(__WEBPACK_IMPORTED_MODULE_0__shader_polygon_vert___default.a, __WEBPACK_IMPORTED_MODULE_1__shader_polygon_frag___default.a, {
            attribMap: {
                vertexPosHigh: 0 /* POSITION_HIGH */,
                vertexPosLow: 1 /* POSITION_LOW */,
                vertexColor: 7 /* COLOR */,
                vertexZIndex: 10 /* Z_INDEX */
            }
        });
        super(context, renderState, program, primitiveProvider);
    }
}
/* harmony export (immutable) */ __webpack_exports__["b"] = PolygonRenderUnit;



/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_event_emitter__ = __webpack_require__(2);

class NoBaseRenderUnitError extends Error {
    constructor() {
        super('Base render unit is not in the list');
    }
}
/**
 * Simple implementation of CompositeRenderUnit that just runs sub units in the order of addition.
 */
class ListRenderUnit {
    constructor() {
        this.onUpdate = new __WEBPACK_IMPORTED_MODULE_0__util_event_emitter__["b" /* VoidEventEmitter */]();
        this._subRenderUnits = [];
        this._subRenderUnitUpdateListener = this._onSubRenderUnitUpdate.bind(this);
    }
    /**
     * Adds RenderUnit to the end of the list.
     */
    addRenderUnit(subRenderUnit) {
        this._subRenderUnits.push(subRenderUnit);
        subRenderUnit.onUpdate.addListener(this._subRenderUnitUpdateListener);
    }
    /**
     * Removes RenderUnit from the list.
     */
    removeRenderUnit(subRenderUnit) {
        const index = this._subRenderUnits.indexOf(subRenderUnit);
        if (index !== -1) {
            this._subRenderUnits.splice(index, 1);
            subRenderUnit.onUpdate.removeListener(this._subRenderUnitUpdateListener);
            this.onUpdate.fire();
        }
    }
    /**
     * Adds RenderUnit above the base one. "Above" means that its render() method will be called after the base's one.
     */
    addRenderUnitAbove(base, subRenderUnit) {
        const baseIndex = this._subRenderUnits.indexOf(base);
        if (baseIndex !== -1) {
            this._subRenderUnits.splice(baseIndex + 1, 0, subRenderUnit);
            subRenderUnit.onUpdate.addListener(this._subRenderUnitUpdateListener);
        }
        else {
            throw new NoBaseRenderUnitError();
        }
    }
    /**
     * Adds RenderUnit below the base one. "Below" means that its render() method will be called before the base's one.
     */
    addRenderUnitBelow(base, subRenderUnit) {
        const baseIndex = this._subRenderUnits.indexOf(base);
        if (baseIndex !== -1) {
            this._subRenderUnits.splice(baseIndex, 0, subRenderUnit);
            subRenderUnit.onUpdate.addListener(this._subRenderUnitUpdateListener);
        }
        else {
            throw new NoBaseRenderUnitError();
        }
    }
    render(target, ...args) {
        for (const renderer of this._subRenderUnits) {
            renderer.render(target, ...args);
        }
    }
    _onSubRenderUnitUpdate() {
        this.onUpdate.fire();
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ListRenderUnit;



/***/ }),
/* 24 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export create */
/* unused harmony export zero */
/* harmony export (immutable) */ __webpack_exports__["c"] = copy;
/* unused harmony export rotateX */
/* unused harmony export rotateY */
/* unused harmony export rotateZ */
/* unused harmony export translate */
/* unused harmony export scale */
/* harmony export (immutable) */ __webpack_exports__["d"] = lookAt;
/* harmony export (immutable) */ __webpack_exports__["e"] = perspective;
/* unused harmony export mul */
/* harmony export (immutable) */ __webpack_exports__["b"] = apply;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__vector3__ = __webpack_require__(12);

// TODO(dmikis) RoMatrix4?
const IDENTITY = [
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    0, 0, 0, 1
];
/* harmony export (immutable) */ __webpack_exports__["a"] = IDENTITY;

const ZERO = [
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0
];
/* unused harmony export ZERO */

const MATRIX_SIZE = 16;
/**
 * Creates and returns a new **uninitialized** matrix.
 */
function create() {
    return new Array(MATRIX_SIZE);
}
/**
 * Zeroes a matrix.
 *
 * @param dst The matrix.
 * @returns `dst`.
 */
function zero(dst = create()) {
    for (let i = 0; i < MATRIX_SIZE; ++i) {
        dst[i] = 0;
    }
    return dst;
}
/**
 * Copies a matrix to another one.
 *
 * @param src The matrix to be copied.
 * @param dst The matrix the `src` will be copied to.
 * @returns `dst`.
 */
function copy(src, dst = create()) {
    for (let i = 0; i < MATRIX_SIZE; ++i) {
        dst[i] = src[i];
    }
    return dst;
}
/**
 * Applies a rotation around the X axis by a given angle to a given matrix.
 * Positive direction is from positive Y to positive Z.
 *
 * @param src The matrix to be multiplied by the rotation matrix.
 * @param angle The angle of rotation.
 * @param dst The matrix the product will be stored to. Can be the same as `src`.
 * @returns `dst`.
 */
function rotateX(src, angle, dst = create()) {
    const angleCos = Math.cos(angle);
    const angleSin = Math.sin(angle);
    // The rotation matrix:
    //
    // 1   0    0 0
    // 0 cos -sin 0
    // 0 sin  cos 0
    // 0   0    0 1
    for (let i = 0; i < MATRIX_SIZE; i += 4) {
        dst[i] = src[i];
        const m1i = src[i + 1];
        const m2i = src[i + 2];
        dst[i + 1] = m1i * angleCos - m2i * angleSin;
        dst[i + 2] = m1i * angleSin + m2i * angleCos;
        dst[i + 3] = src[i + 3];
    }
    return dst;
}
/**
 * Applies a rotation around the Y axis by a given angle to a given matrix.
 * Positive direction is from positive X to positive Z.
 *
 * @param src The matrix to be multiplied by the rotation matrix.
 * @param angle The angle of rotation.
 * @param dst The matrix the product will be stored to. Can be the same as `src`.
 * @returns `dst`.
 */
function rotateY(src, angle, dst = create()) {
    const angleCos = Math.cos(angle);
    const angleSin = Math.sin(angle);
    // The rotation matrix:
    //
    // cos 0 -sin 0
    // 0   1    0 0
    // sin 0  cos 0
    // 0    0   0 1
    for (let i = 0; i < MATRIX_SIZE; i += 4) {
        const m0i = src[i];
        const m2i = src[i + 2];
        dst[i] = m0i * angleCos - m2i * angleSin;
        dst[i + 1] = src[i + 1];
        dst[i + 2] = m0i * angleSin + m2i * angleCos;
        dst[i + 3] = src[i + 3];
    }
    return dst;
}
/**
 * Applies a rotation around the X axis by a given angle to a given matrix.
 * Positive direction is from positive X to positive Y.
 *
 * @param src The matrix to be multiplied by the rotation matrix.
 * @param angle The angle of rotation.
 * @param dst The matrix the product will be stored to. Can be the same as `src`.
 * @returns `dst`.
 */
function rotateZ(src, angle, dst = create()) {
    const angleCos = Math.cos(angle);
    const angleSin = Math.sin(angle);
    // The rotation matrix:
    // cos -sin 0 0
    // sin  cos 0 0
    //   0    0 1 0
    //   0    0 0 1
    for (let i = 0; i < MATRIX_SIZE; i += 4) {
        const m0i = src[i];
        const m1i = src[i + 1];
        dst[i] = m0i * angleCos - m1i * angleSin;
        dst[i + 1] = m0i * angleSin + m1i * angleCos;
        dst[i + 2] = src[i + 2];
        dst[i + 3] = src[i + 3];
    }
    return dst;
}
/**
 * Applies a translation by a given vector to a given matrix.
 *
 * @param src The matrix to be multiplied by the translation matrix.
 * @param translation The translation vector.
 * @param dst The matrix the product will be stored to. Can be the same as `src`.
 * @returns `dst`.
 */
function translate(src, translation, dst = create()) {
    for (let i = 0; i < MATRIX_SIZE; i += 4) {
        const m4i = dst[i + 3] = src[i + 3];
        dst[i] = src[i] + m4i * translation.x;
        dst[i + 1] = src[i + 1] + m4i * translation.y;
        dst[i + 2] = src[i + 2] + m4i * translation.z;
    }
    return dst;
}
/**
 * Applies a scale matrix by given factors (packed into a vector) to a given
 * matrix.
 *
 * @param src The matrix to be multiplied by the scale matrix.
 * @param factor The vector the scale factors packed into.
 * @param dst The matrix the product will be stored to. Can be the same as `src`.
 * @returns `dst`.
 */
function scale(src, factor, dst = create()) {
    for (let i = 0; i < MATRIX_SIZE; i += 4) {
        dst[i] = src[i] * factor.x;
        dst[i + 1] = src[i + 1] * factor.y;
        dst[i + 2] = src[i + 2] * factor.z;
        dst[i + 3] = src[i + 3];
    }
    return dst;
}
// The matrix:
// xAxis.x yAxis.x zAxis.x -eye.x
// xAxis.y yAxis.y zAxis.y -eye.y
// xAxis.z yAxis.z zAxis.z -eye.z
//       0       0       0 1
// where xAxis, yAxis and zAxis โ axes of the eye coordinate system, eye โ
// origin of the eye coordinate system.
const lookAtMatrix = copy(IDENTITY);
/**
 * Applies a matrix of transformation into a coordinate system of a camera
 * defined by its position, a point it's looking at and an up direction vector.
 *
 * @param src The matrix to be multiplied by the scale matrix.
 * @param eye The position of the camera.
 * @param center The point the camera's looking at.
 * @param up The up vector.
 * @param dst The matrix the product will be stored to. Can be the same as `src`.
 * @returns `dst`.
 */
function lookAt(src, eye, center, up, dst = create()) {
    const zAxis = __WEBPACK_IMPORTED_MODULE_0__vector3__["n" /* sub */](eye, center);
    __WEBPACK_IMPORTED_MODULE_0__vector3__["k" /* normalize */](zAxis, zAxis);
    const xAxis = __WEBPACK_IMPORTED_MODULE_0__vector3__["f" /* cross */](up, zAxis);
    __WEBPACK_IMPORTED_MODULE_0__vector3__["k" /* normalize */](xAxis, xAxis);
    const yAxis = __WEBPACK_IMPORTED_MODULE_0__vector3__["f" /* cross */](zAxis, xAxis);
    lookAtMatrix[0] = xAxis.x;
    lookAtMatrix[1] = yAxis.x;
    lookAtMatrix[2] = zAxis.x;
    lookAtMatrix[4] = xAxis.y;
    lookAtMatrix[5] = yAxis.y;
    lookAtMatrix[6] = zAxis.y;
    lookAtMatrix[8] = xAxis.z;
    lookAtMatrix[9] = yAxis.z;
    lookAtMatrix[10] = zAxis.z;
    lookAtMatrix[12] = -__WEBPACK_IMPORTED_MODULE_0__vector3__["g" /* dot */](xAxis, eye);
    lookAtMatrix[13] = -__WEBPACK_IMPORTED_MODULE_0__vector3__["g" /* dot */](yAxis, eye);
    lookAtMatrix[14] = -__WEBPACK_IMPORTED_MODULE_0__vector3__["g" /* dot */](zAxis, eye);
    return mul(src, lookAtMatrix, dst);
}
/**
 * Applies a perspective matrix to a given one.
 *
 * @param src The matrix to be multiplied by the perspective matrix.
 * @param fov Vertical field of view angle.
 * @param aspectRatio Screen aspect ratio.
 * @param zNear Z-coordinate of near clipping plane.
 * @param zFar Z-coordinate of far clipping plane.
 * @param dst The matrix the product will be stored to. Can be the same as `src`.
 * @returns `dst`.
 */
function perspective(src, fov, aspect, zNear, zFar, dst = create()) {
    const p11 = 1 / Math.tan(0.5 * fov);
    const p00 = p11 / aspect;
    const p22 = (zNear + zFar) / (zNear - zFar);
    const p32 = 2 * zNear * zFar / (zNear - zFar);
    for (let i = 0; i < MATRIX_SIZE; i += 4) {
        dst[i] = src[i] * p00;
        dst[i + 1] = src[i + 1] * p11;
        const m2i = src[i + 2];
        const m3i = src[i + 3];
        dst[i + 2] = m2i * p22 + m3i * p32;
        dst[i + 3] = -m2i;
    }
    return dst;
}
/**
 * Multiplies a matrix by another one, i.e. `dst = m * src`.
 *
 * @param src The right matrix.
 * @param m The left matrix.
 * @param dst The matrix the product will be stored to. Can be the same as `src`.
 * @returns `dst`.
 */
function mul(src, m, dst = create()) {
    for (let i = 0; i < MATRIX_SIZE; i += 4) {
        const m0i = src[i];
        const m1i = src[i + 1];
        const m2i = src[i + 2];
        const m3i = src[i + 3];
        for (let j = 0; j < 4; ++j) {
            dst[i + j] = m0i * m[j] + m1i * m[4 + j] + m2i * m[8 + j] +
                m3i * m[12 + j];
        }
    }
    return dst;
}
/**
 * Applies a matrix to a vector.
 *
 * @param m The matrix.
 * @param v The vector.
 * @returns Normalized product of multiplying the vector by the matrix.
 */
function apply(m, v, dst = __WEBPACK_IMPORTED_MODULE_0__vector3__["e" /* create */](0, 0, 0)) {
    const w = m[3] * v.x + m[7] * v.y + m[11] * v.z + m[15];
    const x = (m[0] * v.x + m[4] * v.y + m[8] * v.z + m[12]) / w;
    const y = (m[1] * v.x + m[5] * v.y + m[9] * v.z + m[13]) / w;
    const z = (m[2] * v.x + m[6] * v.y + m[10] * v.z + m[14]) / w;
    dst.x = x;
    dst.y = y;
    dst.z = z;
    return dst;
}


/***/ }),
/* 25 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = areFuzzyEqual;
const DEFAULT_TOLERANCE = 1e-6;
/* harmony export (immutable) */ __webpack_exports__["a"] = DEFAULT_TOLERANCE;

/**
 * Checks if two floating point number are within a tolerance from each other.
 *
 * @param a The first number.
 * @param b The second number.
 * @param tolerance The tolerance.
 * @returns `true` if the number are within the tolerance and `false` otherwise.
 */
function areFuzzyEqual(a, b, tolerance = DEFAULT_TOLERANCE) {
    const d = a - b;
    return -tolerance < d && d < tolerance;
}


/***/ }),
/* 26 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = uniqueId;
let id = 1;
/**
 * Generates unique id
*/
function uniqueId() {
    return id++;
}


/***/ }),
/* 27 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__count_vertices__ = __webpack_require__(15);

/**
 * Represents a region in a memory chunk. Memory is allocated by big chunks for performance reasons,
 * and we need a mechanism to control those chunk's suballocation to properly free
 * the occupied memory - that is what this class is for.
 */
class MemorySubChunk {
    constructor(chunk, location) {
        this.memoryChunk = chunk;
        this._location = location;
        chunk.retain();
    }
    /**
     * @returns Offset of vertex data of the chunk in bytes.
     */
    get vertexByteOffset() {
        return this.memoryChunk.vertexByteOffset + this._location.vertexByteOffset;
    }
    /**
     * @returns Offset of index data of the chunk in bytes.
     */
    get indexByteOffset() {
        return this.memoryChunk.indexByteOffset + this._location.indexByteOffset;
    }
    /**
     * @returns Number of indexes occupied by this chunk.
     */
    get indexCount() {
        return Object(__WEBPACK_IMPORTED_MODULE_0__count_vertices__["a" /* countIndices */])(this._location.indexByteLength, this.memoryChunk.page.indexType);
    }
    /**
     * @returns Number of bytes occupied by this chunk for vertex data.
     */
    get vertexByteLength() {
        return this._location.vertexByteLength;
    }
    /**
     * @returns Number of bytes occupied by this chunk for index data.
     */
    get indexByteLength() {
        return this._location.indexByteLength;
    }
    destroy() {
        this.memoryChunk.release();
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = MemorySubChunk;



/***/ }),
/* 28 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__font__ = __webpack_require__(76);

const UNKNOWN_GLYPH = {
    id: -1,
    width: 0,
    height: 0,
    bearingX: 0,
    bearingY: 0,
    advance: 18
};
/**
 * Font whose glyphs are specified in distance field bitmaps. It's "margin" metric specifies glyph bitmap inner padding,
 * that is required to fit a "blurred" glyph image. This margin should be considered during layouting to draw glyphs of
 * proper sizes.
 */
class DfFont extends __WEBPACK_IMPORTED_MODULE_0__font__["a" /* default */] {
    constructor(id, xheight, margin) {
        super(id, xheight, UNKNOWN_GLYPH);
        this.margin = margin;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = DfFont;



/***/ }),
/* 29 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_buffer_writer__ = __webpack_require__(6);


/**
 * Base class for 3D models buffer writers. It is not supposed to write indices, instead it writes vertices (possibly
 * duplicated) in order that correspond to triangular facets of the mesh.
 */
class ModelBufferWriter extends __WEBPACK_IMPORTED_MODULE_1__util_buffer_writer__["b" /* default */] {
    constructor() {
        super(ModelBufferWriter.ATTRIBUTE_MAPPING.vertexByteSize);
    }
    /**
     * Writes a vertex to the vertex buffer.
     */
    _writeVertex(v, colorRgba8) {
        const vertexIdx = this.getCurrentVertexIdx();
        this._writeWorldCoordinate(v);
        this._writeFloat32(v.z);
        this._writeWord(colorRgba8);
        return vertexIdx;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ModelBufferWriter;

/**
 * Description of how attributes of vertices are packed into a vertex buffer.
 */
ModelBufferWriter.ATTRIBUTE_MAPPING = new __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__["a" /* AttributeMapping */]([
    [
        0 /* POSITION_HIGH */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        1 /* POSITION_LOW */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        3 /* HEIGHT */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        7 /* COLOR */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ]
]);


/***/ }),
/* 30 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = intToZIndex;
const MIN_ZINDEX = -1 + Math.pow(2, 1 - 24); // epsilon is added (for normalized 24-bit value) to free up reserved value
function intToZIndex(x) {
    return Math.max(MIN_ZINDEX, x / 0x7fffff);
}


/***/ }),
/* 31 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__ = __webpack_require__(3);

/**
 * Description of how attributes of vertices are packed into a vertex buffer.
 */
const TEXTURED_POLYGON_ATTRIBUTE_MAPPING = new __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__["a" /* AttributeMapping */]([
    [
        0 /* POSITION_HIGH */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        1 /* POSITION_LOW */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        4 /* UV */,
        {
            size: 4,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: false
        }
    ],
    [
        11 /* AUX */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        10 /* Z_INDEX */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ]
]);
/* harmony export (immutable) */ __webpack_exports__["a"] = TEXTURED_POLYGON_ATTRIBUTE_MAPPING;



/***/ }),
/* 32 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__ = __webpack_require__(3);

/**
 * Description of how attributes of vertices are packed into a vertex buffer.
 */
const POLYGON_ATTRIBUTE_MAPPING = new __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__["a" /* AttributeMapping */]([
    [
        0 /* POSITION_HIGH */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        1 /* POSITION_LOW */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        7 /* COLOR */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        10 /* Z_INDEX */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ]
]);
/* harmony export (immutable) */ __webpack_exports__["a"] = POLYGON_ATTRIBUTE_MAPPING;



/***/ }),
/* 33 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__ = __webpack_require__(3);

/**
 * Description of how attributes of vertices are packed into a vertex buffer.
 */
const POLYLINE_ATTRIBUTE_MAPPING = new __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__["a" /* AttributeMapping */]([
    /** Vertex world position. */
    [
        0 /* POSITION */,
        {
            size: 4,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    /** Normal to polyline segment the vertex belong to. */
    [
        5 /* NORMAL */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    /**
     * "UV" vertex that used to compute stroke and dashes. It's components:
     *
     *   - distance to the analytical polyline along segment's normal;
     *   - distance to the analytical polyline along segment.
     */
    [
        4 /* UV */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: false
        }
    ],
    /**
     * Vector with polyline's half width and dash style. It's components:
     *
     *   - half width;
     *   - length of a dash;
     *   - distance between dashes.
     */
    [
        11 /* AUX */,
        {
            size: 3,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    /**
     * Miter (i.e. how much displacement of the vertex is longer then the
     * normal).
     */
    [
        12 /* AUX1 */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    /**
     * Limit on displacement tangent component.Applied to avoid geometry
     * glitches in over-degenerative cases.
     */
    [
        13 /* AUX2 */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    /**
     * Distance to the first vertex along the polyline.
     */
    [
        14 /* AUX3 */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    /** Polyline's color. */
    [
        7 /* COLOR */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    /** Polyline's Z index. */
    [
        10 /* Z_INDEX */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ]
]);
/* harmony export (immutable) */ __webpack_exports__["a"] = POLYLINE_ATTRIBUTE_MAPPING;



/***/ }),
/* 34 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TileProviderMessageType; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__primitive_provider_worker_messages__ = __webpack_require__(89);

var TileProviderMessageType;
(function (TileProviderMessageType) {
    TileProviderMessageType[TileProviderMessageType["INIT"] = 0] = "INIT";
    TileProviderMessageType[TileProviderMessageType["TILE_URL_UPDATE"] = 1] = "TILE_URL_UPDATE";
    TileProviderMessageType[TileProviderMessageType["TILE_REQUEST_BATCH"] = 2] = "TILE_REQUEST_BATCH";
    TileProviderMessageType[TileProviderMessageType["TILE_REQUEST_CANCEL_BATCH"] = 3] = "TILE_REQUEST_CANCEL_BATCH";
    TileProviderMessageType[TileProviderMessageType["TILE_RESPONSE"] = 4] = "TILE_RESPONSE";
    TileProviderMessageType[TileProviderMessageType["TILE_ERROR"] = 5] = "TILE_ERROR";
    TileProviderMessageType[TileProviderMessageType["GEOMETRY_RESPONSE"] = 6] = "GEOMETRY_RESPONSE";
    TileProviderMessageType[TileProviderMessageType["LABELS_RESPONSE"] = 7] = "LABELS_RESPONSE";
    TileProviderMessageType[TileProviderMessageType["MESH_REQUEST"] = 8] = "MESH_REQUEST";
    TileProviderMessageType[TileProviderMessageType["MESH_REQUEST_CANCEL"] = 9] = "MESH_REQUEST_CANCEL";
    TileProviderMessageType[TileProviderMessageType["MESH_RESPONSE"] = 10] = "MESH_RESPONSE";
    TileProviderMessageType[TileProviderMessageType["MESH_ERROR"] = 11] = "MESH_ERROR";
})(TileProviderMessageType || (TileProviderMessageType = {}));
const geometryTransferableExtractor = function (message, transferables = []) {
    Object(__WEBPACK_IMPORTED_MODULE_0__primitive_provider_worker_messages__["a" /* extractTransferables */])(message.polygonPages, transferables);
    Object(__WEBPACK_IMPORTED_MODULE_0__primitive_provider_worker_messages__["a" /* extractTransferables */])(message.transparentPolygonPages, transferables);
    Object(__WEBPACK_IMPORTED_MODULE_0__primitive_provider_worker_messages__["a" /* extractTransferables */])(message.texturedPolygonPages, transferables);
    Object(__WEBPACK_IMPORTED_MODULE_0__primitive_provider_worker_messages__["a" /* extractTransferables */])(message.meshPages, transferables);
    Object(__WEBPACK_IMPORTED_MODULE_0__primitive_provider_worker_messages__["a" /* extractTransferables */])(message.polylinePages, transferables);
    return transferables;
};
/* unused harmony export geometryTransferableExtractor */

const meshTransferableExtractor = function (message) {
    const transferables = [];
    Object(__WEBPACK_IMPORTED_MODULE_0__primitive_provider_worker_messages__["a" /* extractTransferables */])(message.pages, transferables);
    return transferables;
};
/* unused harmony export meshTransferableExtractor */

const labelTransferableExtractor = function (message, transferables = []) {
    Object(__WEBPACK_IMPORTED_MODULE_0__primitive_provider_worker_messages__["a" /* extractTransferables */])(message.pointLabelPages, transferables);
    Object(__WEBPACK_IMPORTED_MODULE_0__primitive_provider_worker_messages__["a" /* extractTransferables */])(message.pointLabelBackgroundPages, transferables);
    Object(__WEBPACK_IMPORTED_MODULE_0__primitive_provider_worker_messages__["a" /* extractTransferables */])(message.curvedLabelPages, transferables);
    return transferables;
};
/* unused harmony export labelTransferableExtractor */

const tileTransferableExtractor = function (message) {
    const transferables = [];
    geometryTransferableExtractor(message, transferables);
    labelTransferableExtractor(message, transferables);
    return transferables;
};
/* unused harmony export tileTransferableExtractor */



/***/ }),
/* 35 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__binary_heap__ = __webpack_require__(92);

function itemComparator(a, b) {
    return a.priority - b.priority;
}
/**
 * Priority queue based on a heap.
 */
class PriorityQueue {
    /**
     * Constructs new empty priority queue.
     */
    constructor() {
        this._heap = new __WEBPACK_IMPORTED_MODULE_0__binary_heap__["a" /* default */](itemComparator);
    }
    /**
     * Adds an item into the queue.
     *
     * @param item The item.
     */
    enqueue(item) {
        this._heap.insert(item);
    }
    /**
     * Removes next item from the queue.
     *
     * @returns The next item or `undefined` if the queue's empty.
     */
    dequeue() {
        return this._heap.pop();
    }
    /**
     * Checks if the queue has no items in it.
     *
     * @returns `true` if there're no items it the queue and `false` otherwise.
     */
    isEmpty() {
        return this._heap.size === 0;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = PriorityQueue;



/***/ }),
/* 36 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__renderable_primitive__ = __webpack_require__(7);

class RenderablePolyline extends __WEBPACK_IMPORTED_MODULE_0__renderable_primitive__["a" /* default */] {
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RenderablePolyline;



/***/ }),
/* 37 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__renderable_primitive__ = __webpack_require__(7);

/**
 * A general primitive that is best suitable for storing simple colored 3D models.
 */
class RenderableModel extends __WEBPACK_IMPORTED_MODULE_0__renderable_primitive__["a" /* default */] {
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RenderableModel;



/***/ }),
/* 38 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Often primitives can't be dirrectly added into or removed from scene, there can be some specific (business) logic
 * associated with these operations. This class provides basic methods for such implementations that
 * allows to manage primitives of all types in the same manner.
 */
class PrimitiveManager {
    destroy() { }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = PrimitiveManager;



/***/ }),
/* 39 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_event_emitter__ = __webpack_require__(2);

/**
 * Primitive storage that stores primitive in a set. It acts as a primitive provider as well.
 */
class PrimitiveSetStorage {
    constructor() {
        this._primitiveSet = new Set();
        this.onUpdate = new __WEBPACK_IMPORTED_MODULE_0__util_event_emitter__["b" /* VoidEventEmitter */]();
    }
    get primitives() {
        return this._primitiveSet;
    }
    add(...primitives) {
        for (const primitive of primitives) {
            primitive.retain();
            this._primitiveSet.add(primitive);
        }
        if (primitives.length > 0) {
            this.onUpdate.fire();
        }
    }
    delete(...primitives) {
        for (const primitive of primitives) {
            if (this._primitiveSet.delete(primitive)) {
                primitive.release();
            }
        }
        if (primitives.length > 0) {
            this.onUpdate.fire();
        }
    }
    clear() {
        this._primitiveSet.clear();
        this.onUpdate.fire();
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = PrimitiveSetStorage;



/***/ }),
/* 40 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__primitive_set_storage__ = __webpack_require__(39);

/**
 * Simple primitive set storage that distinguish visible/hidden primitives. It also acts as a primitive provider.
 */
class DisappearingPrimitiveSetStorage extends __WEBPACK_IMPORTED_MODULE_0__primitive_set_storage__["a" /* default */] {
    constructor() {
        super();
        this._visiblePrimitives = new Set();
    }
    get primitives() {
        return this.visiblePrimitives;
    }
    get visiblePrimitives() {
        return this._visiblePrimitives;
    }
    add(...primitives) {
        super.add(...primitives);
        this.show(...primitives);
    }
    delete(...primitives) {
        this.hide(...primitives);
        super.delete(...primitives);
    }
    show(...primitives) {
        for (const primitive of primitives) {
            if (this._primitiveSet.has(primitive)) {
                this._visiblePrimitives.add(primitive);
            }
        }
    }
    hide(...primitives) {
        for (const primitive of primitives) {
            this._visiblePrimitives.delete(primitive);
        }
    }
    _isAllowedToShowPrimitive(primitive) {
        return this._primitiveSet.has(primitive);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = DisappearingPrimitiveSetStorage;



/***/ }),
/* 41 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
class DelegatorBase {
    constructor() {
        this._delegate = null;
    }
    setDelegate(delegate) {
        this._delegate = delegate;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = DelegatorBase;



/***/ }),
/* 42 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nvarying lowp vec4 color;\n\nvoid main(void) {\n    gl_FragColor = color;\n}\n"

/***/ }),
/* 43 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__colliding_primitive_color_id_renderer__ = __webpack_require__(112);

/**
 * "color id" renderer for labels, both for point and curved ones.
 */
class ColorIdLabelRenderer extends __WEBPACK_IMPORTED_MODULE_0__colliding_primitive_color_id_renderer__["a" /* CollidingPrimitiveColorIdRenderer */] {
    constructor(context, program, primitiveProvider, camera) {
        super(context, program, primitiveProvider);
        this._camera = camera;
    }
    _prepareProgram(program, viewProjMatrix, cameraPositions, state, stabilityShift, visibility, currentZoom) {
        super._prepareProgram(program, viewProjMatrix, cameraPositions, state, stabilityShift, visibility, currentZoom);
        program.setVector2Uniform('pixelSize', this._camera.pixelSize);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ColorIdLabelRenderer;



/***/ }),
/* 44 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = batchPrimitives;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__memory_relative_location__ = __webpack_require__(113);

/**
 * Creates batch from first primitives.
 */
function initBatch(primitive) {
    const subChunk = primitive.memorySubChunk;
    return {
        firstPrimitive: primitive,
        page: subChunk.memoryChunk.page,
        vertexByteOffset: subChunk.vertexByteOffset,
        vertexByteLength: subChunk.vertexByteLength,
        indexByteOffset: subChunk.indexByteOffset,
        indexByteLength: subChunk.indexByteLength
    };
}
/**
 * Batches primitives that can be rendered by a single draw call, that is critical for performance.
 * Performance gain from this method is possible (while it is not strictly required) if primitives
 * are sorted by memory offset and there are no many "holes" between them.
 * Minimal requiremets for batching is location in the same buffer (memory page), additional
 * requirements (such as having shared texture or similar) can be imposed in canBatchPridicate.
 */
function batchPrimitives(primitives, canBatchPridicate) {
    const canBatch = (a, b) => {
        if (
        // minimal requirements for batching is that primitives lay in the same page
        (a.memorySubChunk.memoryChunk.page !== b.memorySubChunk.memoryChunk.page) ||
            // chack external requirements if specified
            (canBatchPridicate && !canBatchPridicate(a, b))) {
            return false;
        }
        else {
            return true;
        }
    };
    return Object(__WEBPACK_IMPORTED_MODULE_0__memory_relative_location__["a" /* batchAllocatedObjects */])(primitives, (primitive) => primitive.memorySubChunk, initBatch, canBatch);
}


/***/ }),
/* 45 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_point_label_vert__ = __webpack_require__(114);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_point_label_vert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__shader_point_label_vert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_df_text_frag__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_df_text_frag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__shader_df_text_frag__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__label_render_unit__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__billboard_rectangle_billboard_rectangle_render_unit__ = __webpack_require__(115);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__util_event_emitter__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__util_iterable__ = __webpack_require__(8);






const PROGRAM_OPTIONS = {
    attribMap: {
        vertexId: 2 /* ID */,
        vertexPosHigh: 0 /* POSITION_HIGH */,
        vertexPosLow: 1 /* POSITION_LOW */,
        vertexDisplacement: 6 /* DISPLACEMENT */,
        vertexUV: 4 /* UV */,
        vertexPriority: 9 /* PRIORITY */,
        vertexColor: 7 /* COLOR */,
        vertexOutlineColor: 8 /* OUTLINE_COLOR */,
        vertexScale: 11 /* AUX */
    }
};
/* harmony export (immutable) */ __webpack_exports__["a"] = PROGRAM_OPTIONS;

/**
 * Renders backgrounds extracted from point labels.
 */
class BackgroundPrimitiveProvider {
    constructor(labelsProvider) {
        this.onUpdate = new __WEBPACK_IMPORTED_MODULE_4__util_event_emitter__["b" /* VoidEventEmitter */]();
        this._labelsProvider = labelsProvider;
    }
    get primitives() {
        return Object(__WEBPACK_IMPORTED_MODULE_5__util_iterable__["c" /* mapIterable */])(Object(__WEBPACK_IMPORTED_MODULE_5__util_iterable__["b" /* filterIterable */])(this._labelsProvider.primitives, (label) => label.background !== undefined), (label) => label.background);
    }
}
/**
 * Point labels renderer. It uses appropriate program to layout glyphs on GPU.
 */
class PointLabelRenderUnit extends __WEBPACK_IMPORTED_MODULE_2__label_render_unit__["a" /* default */] {
    constructor(context, camera, visibilityProvider, primitiveProvider) {
        const program = context.createProgram(__WEBPACK_IMPORTED_MODULE_0__shader_point_label_vert___default.a, __WEBPACK_IMPORTED_MODULE_1__shader_df_text_frag___default.a, PROGRAM_OPTIONS);
        super(context, program, camera, visibilityProvider, primitiveProvider);
        this._backgroundRenderer = new __WEBPACK_IMPORTED_MODULE_3__billboard_rectangle_billboard_rectangle_render_unit__["a" /* default */](context, camera, visibilityProvider, new BackgroundPrimitiveProvider(primitiveProvider));
        this._backgroundRenderer.onUpdate.addListener(() => this.onUpdate.fire());
    }
    render(target, viewProjMatrix, cameraPositions) {
        this._backgroundRenderer.render(target, viewProjMatrix, cameraPositions);
        super.render(target, viewProjMatrix, cameraPositions);
    }
}
/* harmony export (immutable) */ __webpack_exports__["b"] = PointLabelRenderUnit;



/***/ }),
/* 46 */
/***/ (function(module, exports) {

module.exports = "#version 100\n\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform float dpr;\nuniform sampler2D atlas;\nuniform vec2 atlasSize;\n\nvarying vec2 uv;\nvarying lowp vec4 color;\nvarying lowp vec4 outlineColor;\nvarying float scale;\n\nconst float MAX_CORRECTED_GLYPH_SCALE = 0.5;\nconst float GLYPH_BASE_WEIGHT = 0.7;\nconst float GLYPH_BASE_SMOTHNESS = 0.1;\nconst float GLYPH_WEIGHT_SCALE_IMPACT = 0.1;\nconst float GLYPH_SMOOTHNESS_SCALE_IMPACT = 0.06;\nconst float OUTLINE_WEIGHT_SCALE_IMPACT = 0.125;\n\nvoid main(void) {\n    // low scale glyphs (less than 0.5) should be a little bit bolder and smoother\n    float scaleClamped = clamp(scale, 0.0, MAX_CORRECTED_GLYPH_SCALE);\n    // weight is responsible for glyph boldness, the less weight value the bolder the text\n    float weight = GLYPH_BASE_WEIGHT + GLYPH_WEIGHT_SCALE_IMPACT * scaleClamped;\n    // smoothness is how blurred glyphs are, the less smoothness value the less blurring\n    float smoothness = (GLYPH_BASE_SMOTHNESS + GLYPH_SMOOTHNESS_SCALE_IMPACT / scaleClamped) / dpr;\n\n    vec4 resultColor = color;\n    float dist = texture2D(atlas, uv / atlasSize).a;\n    float alpha = smoothstep(weight - smoothness, weight + smoothness, dist);\n\n    if (outlineColor.a != 0.0) {\n        // to render outline the glyph is rendered a little bit bolder with different color at edges\n        weight = weight - OUTLINE_WEIGHT_SCALE_IMPACT / scale;\n        resultColor = mix(outlineColor, color, alpha);\n        alpha = smoothstep(weight - smoothness, weight + smoothness, dist);\n    }\n\n    gl_FragColor = vec4(resultColor.rgb, resultColor.a * alpha);\n}\n"

/***/ }),
/* 47 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__world_primitive_render_unit__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math_vector2__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__render_state__ = __webpack_require__(0);



/**
 * Base renderer that incapsulates all the GL specifics to make labels rendered.
 */
class LabelRenderUnit extends __WEBPACK_IMPORTED_MODULE_0__world_primitive_render_unit__["a" /* default */] {
    constructor(context, program, camera, visibilityProvider, primitiveProvider) {
        super(context, new __WEBPACK_IMPORTED_MODULE_2__render_state__["c" /* default */](__WEBPACK_IMPORTED_MODULE_2__render_state__["b" /* BLEND_OVER_RENDER_STATE */]), program, primitiveProvider);
        this._camera = camera;
        this._visibilityProvider = visibilityProvider;
        this._idHalfPxSizeUniform = __WEBPACK_IMPORTED_MODULE_1__math_vector2__["f" /* create */](0, 0);
        this._atlasSizeUniform = __WEBPACK_IMPORTED_MODULE_1__math_vector2__["f" /* create */](0, 0);
        context.bindProgram(program);
        program.setIntScalarUniform('visibility', 0);
    }
    _prepareProgram(program, viewProjMatrix, cameraPositions) {
        const visibility = this._visibilityProvider();
        super._prepareProgram(program, viewProjMatrix, cameraPositions);
        this._idHalfPxSizeUniform.x = 0.5 / visibility.getWidth();
        this._idHalfPxSizeUniform.y = 0.5 / visibility.getHeight();
        this._context.bindTextureUnit(0);
        this._context.bindTexture(visibility);
        program.setVector2Uniform('idHalfPxSize', this._idHalfPxSizeUniform);
        program.setVector2Uniform('pixelSize', this._camera.pixelSize);
        program.setScalarUniform('dpr', window.devicePixelRatio);
    }
    _renderBatch(memoryBatch) {
        const atlas = memoryBatch.firstPrimitive.atlas;
        this._atlasSizeUniform.x = atlas.width;
        this._atlasSizeUniform.y = atlas.height;
        this._program.setIntScalarUniform('atlas', 1);
        this._program.setVector2Uniform('atlasSize', this._atlasSizeUniform);
        this._context.bindTextureUnit(1);
        this._context.bindTexture(atlas.texture);
        super._renderBatch(memoryBatch);
    }
    _canBatchAdjacentPrimitives(a, b) {
        return super._canBatchAdjacentPrimitives(a, b) && (a.atlas === b.atlas);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = LabelRenderUnit;



/***/ }),
/* 48 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_curved_label_vert__ = __webpack_require__(120);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_curved_label_vert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__shader_curved_label_vert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_df_text_frag__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_df_text_frag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__shader_df_text_frag__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__label_render_unit__ = __webpack_require__(47);



const PROGRAM_OPTIONS = {
    attribMap: {
        vertexId: 2 /* ID */,
        vertexPosHigh: 0 /* POSITION_HIGH */,
        vertexPosLow: 1 /* POSITION_LOW */,
        vertexDisplacements: 6 /* DISPLACEMENT */,
        vertexUV: 4 /* UV */,
        vertexColor: 7 /* COLOR */,
        vertexOutlineColor: 8 /* OUTLINE_COLOR */,
        vertexPriority: 9 /* PRIORITY */,
        leftPolylineRatios: 12 /* AUX1 */,
        leftPolylineAngles: 13 /* AUX2 */,
        rightPolylineRatios: 14 /* AUX3 */,
        rightPolylineAngles: 15 /* AUX4 */,
        polylineLength_vertexScale: 11 /* AUX */
    }
};
/* harmony export (immutable) */ __webpack_exports__["a"] = PROGRAM_OPTIONS;

/**
 * Curved labels renderer. It uses appropriate program to layout glyphs on GPU.
 */
class CurvedLabelRenderUnit extends __WEBPACK_IMPORTED_MODULE_2__label_render_unit__["a" /* default */] {
    constructor(context, camera, visibilityProvider, primitiveProvider) {
        const program = context.createProgram(__WEBPACK_IMPORTED_MODULE_0__shader_curved_label_vert___default.a, __WEBPACK_IMPORTED_MODULE_1__shader_df_text_frag___default.a, PROGRAM_OPTIONS);
        super(context, program, camera, visibilityProvider, primitiveProvider);
    }
}
/* harmony export (immutable) */ __webpack_exports__["b"] = CurvedLabelRenderUnit;



/***/ }),
/* 49 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__world_primitive_render_unit__ = __webpack_require__(5);

/**
 * Base renderer of polyline primitives.
 */
class BasePolylineRenderUnit extends __WEBPACK_IMPORTED_MODULE_0__world_primitive_render_unit__["a" /* default */] {
    constructor(context, renderState, program, primitiveProvider, camera) {
        super(context, renderState, program, primitiveProvider);
        this._camera = camera;
    }
    _prepareProgram(program, viewProjMatrix, cameraPositions) {
        super._prepareProgram(program, viewProjMatrix, cameraPositions);
        program.setScalarUniform('worldToPxFactor', this._camera.worldToPxFactor);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = BasePolylineRenderUnit;



/***/ }),
/* 50 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__binary_tree__ = __webpack_require__(155);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__linked_set__ = __webpack_require__(156);


/**
 * Alignes an offset so it's a multiple of an alignment.
 *
 * @param offset The offset.
 * @param alignment The alignment.
 * @returns Aligned offset.
 */
function align(offset, alignment) {
    return alignment * Math.ceil(offset / alignment);
}
class ArenaAllocator {
    /**
     * Constructs a new empty arena allocator.
     *
     * @param size Size of managed region.
     * @param alignment alignment of offsets.
     */
    constructor(size, alignment = 1) {
        this._size = size;
        this._alignment = alignment;
        this._freeOffset = 0;
        this._allocatedOffsets = new Set();
    }
    get size() {
        return this._size;
    }
    get maxAllocableSize() {
        return this._size - this._freeOffset;
    }
    get isEmpty() {
        return this._allocatedOffsets.size === 0;
    }
    allocate(size) {
        if (this._size >= this._freeOffset + size) {
            const offset = this._freeOffset;
            this._freeOffset = align(offset + size, this._alignment);
            this._allocatedOffsets.add(offset);
            return offset;
        }
        else {
            return -1;
        }
    }
    deallocate(offset) {
        this._allocatedOffsets.delete(offset);
    }
    isAllocated(offset) {
        return offset < this._freeOffset;
    }
    extend(newSize) {
        if (newSize < this._freeOffset) {
            throw new Error('Could not reduce the size because it conflicts with already allocated region.');
        }
        this._size = newSize;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ArenaAllocator;

/**
 * Allocator optimised for both primary operations: allocation and deallocation. It uses BST for efficient lookup of
 * suitable free region during allocation and two way linked list for fast adjacent free regions merge.
 * Max allocable size is also determined by means of the BST.
 */
class FreeListAllocator {
    constructor(size) {
        this._size = size;
        this._allRegions = new __WEBPACK_IMPORTED_MODULE_1__linked_set__["a" /* default */]();
        this._occupiedRegions = new Map();
        this._freeRegions = new __WEBPACK_IMPORTED_MODULE_0__binary_tree__["a" /* BinarySearchTree */]((rangeA, rangeB) => rangeA.size - rangeB.size);
        const initRegion = { offset: 0, size };
        this._allRegions.insert(initRegion);
        initRegion._freeNode = this._freeRegions.insert(initRegion);
    }
    get size() {
        return this._size;
    }
    get maxAllocableSize() {
        const max = this._freeRegions.max;
        return max ? max.size : 0;
    }
    get isEmpty() {
        return this._occupiedRegions.size === 0;
    }
    allocate(size) {
        const node = this._findMinSuitable(size);
        if (!node) {
            return -1;
        }
        const range = node.value;
        // current region is not available anymore
        // it is removed from the free regions pool
        this._freeRegions.remove(node);
        // new occupied one is created
        const occupiedRange = { offset: range.offset, size };
        this._occupiedRegions.set(range.offset, occupiedRange);
        this._allRegions.insertAfter(range, occupiedRange);
        this._allRegions.remove(range);
        // dont loose remaining if any
        // it should be returned back to the free regions pool
        if (range.size > size) {
            const remainingRange = { offset: range.offset + size, size: range.size - size };
            remainingRange._freeNode = this._freeRegions.insert(remainingRange);
            this._allRegions.insertAfter(occupiedRange, remainingRange);
        }
        return occupiedRange.offset;
    }
    deallocate(offset) {
        let region = this._occupiedRegions.get(offset);
        if (region) {
            // check if the region can be merged with its previous neighbor
            const prev = this._allRegions.getPrev(region);
            if (prev && prev._freeNode) {
                const embracingRange = { offset: prev.offset, size: prev.size + region.size };
                this._allRegions.insertAfter(prev, embracingRange);
                this._allRegions.remove(region);
                this._allRegions.remove(prev);
                this._freeRegions.remove(prev._freeNode);
                region = embracingRange;
            }
            // check if the region can be merged with its next neighbor
            const next = this._allRegions.getNext(region);
            if (next && next._freeNode) {
                const embracingRange = { offset: region.offset, size: region.size + next.size };
                this._allRegions.insertBefore(next, embracingRange);
                this._allRegions.remove(region);
                this._allRegions.remove(next);
                this._freeRegions.remove(next._freeNode);
                region = embracingRange;
            }
            this._occupiedRegions.delete(offset);
            region._freeNode = this._freeRegions.insert(region);
        }
    }
    isAllocated(offset) {
        return this._occupiedRegions.has(offset);
    }
    extend(newSize) {
        if (newSize < this._size) {
            throw new Error('Size reducing is not allowed in free list allocator');
        }
        const diff = newSize - this._size;
        const last = this._allRegions.end;
        if (last && last._freeNode) {
            this._freeRegions.remove(last._freeNode);
            const region = { offset: last.offset, size: last.size + diff, isFree: true };
            this._allRegions.insertAfter(last, region);
            this._allRegions.remove(last);
            this._freeRegions.insert(region);
        }
        else {
            const region = { offset: this._size, size: diff, isFree: true };
            this._allRegions.insert(region);
            this._freeRegions.insert(region);
        }
        this._size = newSize;
    }
    /**
     * Traverses BST to find the smallest region required size can fit.
     */
    _findMinSuitable(size) {
        let node = this._freeRegions.root;
        let best;
        while (node) {
            if (node.value.size === size) {
                best = node;
                break;
            }
            else if (node.value.size < size) {
                node = node.right;
            }
            else {
                best = node;
                node = node.left;
            }
        }
        return best;
    }
}
/* harmony export (immutable) */ __webpack_exports__["b"] = FreeListAllocator;



/***/ }),
/* 51 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = calculateCameraPositions;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_vector2__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_gputypes__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_cartesian_grid__ = __webpack_require__(171);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__util_array__ = __webpack_require__(14);




// Maps world coordinates to corresponding points on the cartesian grid.
const WORLD_MIN_COORDINATE = __WEBPACK_IMPORTED_MODULE_0__math_vector2__["f" /* create */](-1, -1);
const GRID_WORLD_RATIO = 0.5;
const GRID_COORDINATES_CONVERTER = (point) => {
    const gridCoordinates = __WEBPACK_IMPORTED_MODULE_0__math_vector2__["e" /* copy */](point);
    __WEBPACK_IMPORTED_MODULE_0__math_vector2__["s" /* sub */](gridCoordinates, WORLD_MIN_COORDINATE, gridCoordinates);
    __WEBPACK_IMPORTED_MODULE_0__math_vector2__["p" /* muln */](gridCoordinates, GRID_WORLD_RATIO, gridCoordinates);
    return gridCoordinates;
};
const CAMERA_POSITION_UINT32_CONVERTER = (component) => 0.5 * (component + 1) * 0xffffffff;
const HIGH_COMPONENT_EXTRACTOR = (component) => Object(__WEBPACK_IMPORTED_MODULE_1__util_gputypes__["d" /* uint16ToFloat */])(Math.trunc(component / 0x10000));
const LOW_COMPONENT_EXTRACTOR = (component) => Object(__WEBPACK_IMPORTED_MODULE_1__util_gputypes__["d" /* uint16ToFloat */])(component & 0xffff);
const REGION_COMPARATOR = (a, b) => a.x - b.x || a.y - b.y;
const tmpCameraPosition = __WEBPACK_IMPORTED_MODULE_0__math_vector2__["f" /* create */](0, 0);
/**
 * If there are multiple worlds visible (large monitors/low zoom) primitives are rendered in multiple passes from
 * different positions (if the wrap mode of corresponding direction is REPEAT) to get correct final picture.
 * This method calculates camera positions and prepare them to be passed to the render() method.
 */
const cachedRegion = [];
const cachedPositions = [];
function calculateCameraPositions(camera) {
    const visibleRegion = camera.getVisibleRegion();
    if (__WEBPACK_IMPORTED_MODULE_3__util_array__["a" /* compare */](REGION_COMPARATOR, cachedRegion, visibleRegion) === 0) {
        return cachedPositions;
    }
    const positions = [];
    for (const worldPosition of Object(__WEBPACK_IMPORTED_MODULE_2__util_cartesian_grid__["a" /* computeSquaresCoveredByConvexPolygon */])(visibleRegion.map(GRID_COORDINATES_CONVERTER))) {
        if ((camera.options.wrapModeX === 2 /* REPEAT */ || worldPosition.x === 0) &&
            (camera.options.wrapModeY === 2 /* REPEAT */ || worldPosition.y === 0)) {
            // 2.0 converts covered square position to the world's center coordinates
            // -1.0 reverses the position of the camera to shot the world from
            __WEBPACK_IMPORTED_MODULE_0__math_vector2__["p" /* muln */](worldPosition, -1.0 * 2.0, tmpCameraPosition);
            __WEBPACK_IMPORTED_MODULE_0__math_vector2__["b" /* add */](camera.center, tmpCameraPosition, tmpCameraPosition);
            __WEBPACK_IMPORTED_MODULE_0__math_vector2__["d" /* convert */](tmpCameraPosition, CAMERA_POSITION_UINT32_CONVERTER, tmpCameraPosition);
            positions.push({
                lookAtHigh: __WEBPACK_IMPORTED_MODULE_0__math_vector2__["d" /* convert */](tmpCameraPosition, HIGH_COMPONENT_EXTRACTOR),
                lookAtLow: __WEBPACK_IMPORTED_MODULE_0__math_vector2__["d" /* convert */](tmpCameraPosition, LOW_COMPONENT_EXTRACTOR)
            });
        }
    }
    __WEBPACK_IMPORTED_MODULE_3__util_array__["b" /* copy */](positions, cachedPositions);
    cachedPositions.length = positions.length;
    cachedRegion.length = visibleRegion.length;
    for (let i = 0; i < visibleRegion.length; i++) {
        cachedRegion[i] = __WEBPACK_IMPORTED_MODULE_0__math_vector2__["e" /* copy */](visibleRegion[i], cachedRegion[i]);
    }
    return positions;
}


/***/ }),
/* 52 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec2 vertexPosition;\nattribute vec2 vertexUv;\n\nuniform float zIndex;\n\n#ifndef YV_LEAST_16b_P\n#   ifdef GL_FRAGMENT_PRECISION_HIGH\n#       define YV_LEAST_16b_P highp\n#   else\n#       define YV_LEAST_16b_P mediump\n#   endif\n#endif\n\nvarying YV_LEAST_16b_P vec2 uv;\n\nvoid main(void) {\n    gl_Position = vec4(vertexPosition, zIndex, 1);\n    uv = vertexUv;\n}\n"

/***/ }),
/* 53 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_vector_render_engine_render_context__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_vector_render_engine_camera__ = __webpack_require__(63);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_vector_render_engine_adapters_vector_api_adapter__ = __webpack_require__(67);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__camera_stuff__ = __webpack_require__(109);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__src_vector_render_engine_visibility_primitives_label_color_id_point_label_renderer__ = __webpack_require__(110);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__src_vector_render_engine_visibility_primitives_label_color_id_curved_label_renderer__ = __webpack_require__(118);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__src_vector_render_engine_render_primitives_label_point_label_render_unit__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__src_vector_render_engine_render_primitives_label_curved_label_render_unit__ = __webpack_require__(48);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__src_vector_render_engine_render_primitives_icon_icon_render_unit__ = __webpack_require__(121);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__src_vector_render_engine_render_primitives_model_model_render_unit__ = __webpack_require__(127);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__src_vector_render_engine_render_primitives_polyline_textured_polyline_render_unit__ = __webpack_require__(133);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__src_vector_render_engine_render_primitives_polyline_polyline_render_unit__ = __webpack_require__(136);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__src_vector_render_engine_render_primitives_polygon_textured_polygon_render_unit__ = __webpack_require__(140);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__src_vector_render_engine_render_primitives_polygon_transparent_polygon_render_unit__ = __webpack_require__(143);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__src_vector_render_engine_render_primitives_polygon_polygon_render_unit__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__src_vector_render_engine_map_engine__ = __webpack_require__(146);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__src_vector_render_engine_util_hd__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__src_vector_render_engine_visibility_primitives_colliding_primitive_reset_removed_renderer__ = __webpack_require__(182);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__src_vector_render_engine_render_loop__ = __webpack_require__(185);



















// import ImageRenderUnit from '../../src/vector_render_engine/render/primitives/image/image_render_unit';
// import RasterTilesAdapter from '../../src/vector_render_engine/adapters/raster_tiles/adapter';
// import {TileItem} from '../../src/vector_render_engine/adapters/tile_based_adapter/util/tile_system';
const GL_CONTEXT_ATTRIBS = {
    alpha: false,
    depth: true,
    stencil: false,
    antialias: false,
    failIfMajorPerformanceCaveat: true
};
const camera = new __WEBPACK_IMPORTED_MODULE_1__src_vector_render_engine_camera__["a" /* default */]({
    wrapModeX: 2 /* REPEAT */,
    wrapModeY: 0 /* NONE */
});
camera.onUpdate.addListener(() => Object(__WEBPACK_IMPORTED_MODULE_3__camera_stuff__["d" /* renderCameraState */])(camera));
camera.center.x = 0.20898437;
camera.center.y = 0.37304687;
camera.zoom = 14;
const canvas = document.querySelector('#canvas');
{
    const { width, height } = canvas.getBoundingClientRect();
    const dpr = Object(__WEBPACK_IMPORTED_MODULE_16__src_vector_render_engine_util_hd__["a" /* default */])();
    canvas.width = dpr * width;
    canvas.height = dpr * height;
    camera.screenSize.width = width;
    camera.screenSize.height = height;
}
const cameraMouseController = new __WEBPACK_IMPORTED_MODULE_3__camera_stuff__["a" /* CameraMouseController */](canvas, camera);
const mouseDragController = new __WEBPACK_IMPORTED_MODULE_3__camera_stuff__["b" /* MouseDragController */](canvas);
mouseDragController.setDelegate(cameraMouseController);
const scrollZoomController = new __WEBPACK_IMPORTED_MODULE_3__camera_stuff__["c" /* ScrollZoomController */](canvas);
scrollZoomController.setDelegate(cameraMouseController);
const context = __WEBPACK_IMPORTED_MODULE_0__src_vector_render_engine_render_context__["a" /* default */].createFromCanvas(canvas, GL_CONTEXT_ATTRIBS);
const engine = new __WEBPACK_IMPORTED_MODULE_15__src_vector_render_engine_map_engine__["a" /* default */](context, camera, new __WEBPACK_IMPORTED_MODULE_18__src_vector_render_engine_render_loop__["a" /* default */]());
const vectorAdapter = new __WEBPACK_IMPORTED_MODULE_2__src_vector_render_engine_adapters_vector_api_adapter__["a" /* default */](engine, camera, './tile_provider_worker.js?worker', 'map', 
// {
//     tileUrlTemplate: 'https://vec-rdr01e.tst.maps.yandex.ru/vmap2/tiles?l=vmap2&lang=ru_RU&x={{x}}&y={{y}}&z={{z}}&zmin={{zmin}}&zmax={{zmax}}',
//     imageUrlTemplate: 'https://vec-rdr01e.tst.maps.yandex.ru/resources?id={{id}}&scale={{scale}}',
//     meshUrlTemplate: 'https://vec-rdr01e.tst.maps.yandex.ru/meshes?id={{id}}',
//     glyphRangeUrlTemplate: 'https://vec-rdr01e.tst.maps.yandex.ru/glyphs?lang=ru_RU&font_id={{fontId}}&range={{range}}'
// }
{
    tileUrlTemplate: 'https://vec0{{hostAlias}}.maps.yandex.net/vmap2/tiles?l=vmap2&lang=RU_ru&x={{x}}&y={{y}}&z={{z}}&zmin={{zmin}}&zmax={{zmax}}',
    imageUrlTemplate: 'https://vec0{{hostAlias}}.maps.yandex.net/resources?id={{id}}&scale={{scale}}',
    meshUrlTemplate: 'https://vec0{{hostAlias}}.maps.yandex.net/vmap2/meshes?id={{id}}',
    glyphRangeUrlTemplate: 'https://vec0{{hostAlias}}.maps.yandex.net/glyphs?lang=RU_ru&font_id={{fontId}}&range={{range}}'
}, 1 /* X4 */);
// class TrafficLayerAdapter extends RasterTilesAdapter {
//     public _getImageUrl(tile: TileItem): string {
//         return `https://jgo.maps.yandex.net/1.1/tiles?trf&l=trf,trfe&lang=ru_UA&x=${tile.x}&y=${tile.y}&z=${tile.zoom}&scale=${window.devicePixelRatio}&tm=${Math.floor(Date.now() / 1000)}`
//         // return `https://sat03.maps.yandex.net/tiles?l=sat&v=3.419.0&x=${tile.x}&y=${tile.y}&z=${tile.zoom}&scale=${window.devicePixelRatio}&lang=ru_UA`
//     }
// }
// const trafficAdapter = new TrafficLayerAdapter(
//     engine,
//     camera,
//     {width: 256 * window.devicePixelRatio, height: 256 * window.devicePixelRatio}
// );
engine.groundLayer.addRenderUnit(new __WEBPACK_IMPORTED_MODULE_14__src_vector_render_engine_render_primitives_polygon_polygon_render_unit__["b" /* default */](context, vectorAdapter.opaquePolygonsProvider));
engine.groundLayer.addRenderUnit(new __WEBPACK_IMPORTED_MODULE_13__src_vector_render_engine_render_primitives_polygon_transparent_polygon_render_unit__["a" /* default */](context, vectorAdapter.transparentPolygonsProvider));
engine.groundLayer.addRenderUnit(new __WEBPACK_IMPORTED_MODULE_12__src_vector_render_engine_render_primitives_polygon_textured_polygon_render_unit__["a" /* default */](context, vectorAdapter.texturedPolygonsProvider));
engine.groundLayer.addRenderUnit(new __WEBPACK_IMPORTED_MODULE_11__src_vector_render_engine_render_primitives_polyline_polyline_render_unit__["a" /* default */](context, camera, vectorAdapter.polylinesProvider));
engine.groundLayer.addRenderUnit(new __WEBPACK_IMPORTED_MODULE_10__src_vector_render_engine_render_primitives_polyline_textured_polyline_render_unit__["a" /* default */](context, camera, vectorAdapter.texturedPolylinesProvider));
engine.buildingsLayer.addRenderUnit(new __WEBPACK_IMPORTED_MODULE_9__src_vector_render_engine_render_primitives_model_model_render_unit__["a" /* default */](context, vectorAdapter.modelsProvider));
// engine.iconsLayer.addRenderUnit(new ImageRenderUnit(context, trafficAdapter.imagesProvider));
engine.iconsLayer.addRenderUnit(new __WEBPACK_IMPORTED_MODULE_8__src_vector_render_engine_render_primitives_icon_icon_render_unit__["a" /* default */](context, camera, vectorAdapter.iconsProvider));
engine.labelsLayer.addRenderUnit(new __WEBPACK_IMPORTED_MODULE_7__src_vector_render_engine_render_primitives_label_curved_label_render_unit__["b" /* default */](context, camera, engine.visbilityTextureProvider, vectorAdapter.curvedLabelsProvider));
engine.labelsLayer.addRenderUnit(new __WEBPACK_IMPORTED_MODULE_6__src_vector_render_engine_render_primitives_label_point_label_render_unit__["b" /* default */](context, camera, engine.visbilityTextureProvider, vectorAdapter.pointLabelsProvider));
engine.visibilityManager.registerCollidingPrimitives(vectorAdapter.curvedLabelsProvider, new __WEBPACK_IMPORTED_MODULE_5__src_vector_render_engine_visibility_primitives_label_color_id_curved_label_renderer__["a" /* default */](context, camera, vectorAdapter.curvedLabelsProvider), new __WEBPACK_IMPORTED_MODULE_17__src_vector_render_engine_visibility_primitives_colliding_primitive_reset_removed_renderer__["a" /* CollidingPrimitivesResetRemovedRenderer */](context, vectorAdapter.curvedLabelsProvider));
engine.visibilityManager.registerCollidingPrimitives(vectorAdapter.pointLabelsProvider, new __WEBPACK_IMPORTED_MODULE_4__src_vector_render_engine_visibility_primitives_label_color_id_point_label_renderer__["a" /* default */](context, camera, vectorAdapter.pointLabelsProvider), new __WEBPACK_IMPORTED_MODULE_17__src_vector_render_engine_visibility_primitives_colliding_primitive_reset_removed_renderer__["a" /* CollidingPrimitivesResetRemovedRenderer */](context, vectorAdapter.pointLabelsProvider));
document.getElementById('plus').addEventListener('click', () => {
    camera.zoom += 0.1;
});
document.getElementById('minus').addEventListener('click', () => {
    camera.zoom -= 0.1;
});
// setTimeout(() => {
//     console.log('Setting new tile url template');
//     vectorAdapter.setTileUrlTemplate('https://vec-rdr01e.tst.maps.yandex.ru/vmap2/tiles?l=vmap2&lang=ru_RU&x={{x}}&y={{y}}&z={{z}}&zmin={{zmin}}&zmax={{zmax}}');
// }, 4000);


/***/ }),
/* 54 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__attrib_mapping__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__gl_buffer__ = __webpack_require__(56);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__gl_framebuffer__ = __webpack_require__(57);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__gl_program__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__gl_renderbuffer__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__capabilities__ = __webpack_require__(60);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__state__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__gl_texture__ = __webpack_require__(61);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__gl_vao__ = __webpack_require__(62);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__util_color__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__util_event_emitter__ = __webpack_require__(2);











const QUAD_VERTEX_DATA = new Float32Array([
    // tslint:disable
    // x   y  u  v
    -1, -1, 0, 0,
    1, 1, 1, 1,
    -1, 1, 0, 1,
    -1, -1, 0, 0,
    1, -1, 1, 0,
    1, 1, 1, 1
    // tslint:enable
]);
const QUAD_ATTRIB_MAPPING = new __WEBPACK_IMPORTED_MODULE_0__attrib_mapping__["a" /* AttributeMapping */]([
    [
        0 /* POSITION */,
        {
            size: 2,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        4 /* UV */,
        {
            size: 2,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ]
]);
/**
 * Default render target of a WebGL context, which is canvas element of the
 * context.
 */
class DefaultRenderTarget {
    constructor(gl) {
        this.isClear = false;
        this._gl = gl;
    }
    bind() {
        const gl = this._gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }
    setSize(width, height) {
        const canvas = this._gl.canvas;
        canvas.width = width;
        canvas.height = height;
    }
    getWidth() {
        return this._gl.drawingBufferWidth;
    }
    getHeight() {
        return this._gl.drawingBufferHeight;
    }
    destroy() {
        // We can't destroy default render target, so do nothing.
        // TODO(dmikis) Throw an exception?
    }
}
/* unused harmony export DefaultRenderTarget */

/**
 * Wrapper around WebGL context. Serves to localize all GL calls to minimum set
 * of objects.
 */
class RenderContext {
    /**
     * Creates a new wrapper for a given WebGL context.
     *
     * @param gl The context to be wrapped.
     */
    constructor(gl) {
        this._gl = gl;
        this.onLoss = new __WEBPACK_IMPORTED_MODULE_10__util_event_emitter__["b" /* VoidEventEmitter */]();
        this._contextLostListener = (e) => {
            e.preventDefault();
            this.onLoss.fire();
        };
        gl.canvas.addEventListener('webglcontextlost', this._contextLostListener);
        this._capabilities = new __WEBPACK_IMPORTED_MODULE_5__capabilities__["a" /* default */](gl);
        const vaoExt = gl.getExtension('OES_vertex_array_object');
        if (!vaoExt) {
            throw new Error('OES_vertex_array_object is required.');
        }
        this._vaoExt = vaoExt;
        if (!gl.getExtension('OES_standard_derivatives')) {
            throw new Error('OES_standard_derivatives is required.');
        }
        const defaultRenderTarget = this._boundRenderTarget =
            this._defaultRenderTarget =
                new DefaultRenderTarget(gl);
        const boundState = this._boundRenderState = new __WEBPACK_IMPORTED_MODULE_6__state__["c" /* default */]();
        this._unpackPremultiplyAlpha = false;
        // Default viewport and scissor rectangle sizes are equal to the size of
        // the canvas of the WebGL context. But we have no way of knowing them in
        // RenderState's constructor. So we're fixing them here.
        boundState.scissorWidth = boundState.viewportWidth =
            defaultRenderTarget.getWidth();
        boundState.scissorHeight = boundState.viewportHeight =
            defaultRenderTarget.getHeight();
        const quadBuffer = this._quadVertexBuffer =
            new __WEBPACK_IMPORTED_MODULE_1__gl_buffer__["a" /* default */](gl, gl.ARRAY_BUFFER, gl.STATIC_DRAW);
        quadBuffer.bind();
        gl.bufferData(gl.ARRAY_BUFFER, QUAD_VERTEX_DATA, gl.STATIC_DRAW);
        this._quadVao = this.createVao(QUAD_ATTRIB_MAPPING, quadBuffer, null);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        this._boundProgram = null;
        this._boundVao = null;
        this._boundTextures = new Array(this._capabilities.getMaxCombinedTextureImageUnits());
        this._boundTextures.fill(null);
        this._boundTextureUnit = 0;
    }
    /**
     * Returns object to request capabilities of the context such as maximum
     * texture size or maximum number of uniform vectors allowed in shaders.
     */
    getCapabilities() {
        return this._capabilities;
    }
    /**
     * Creates a new framebuffer with given attachments.
     *
     * @param descriptor Object containing framebuffer attachments.
     * @returns Created framebuffer object.
     */
    createFramebuffer({ color, depth, stencil, depthStencil }) {
        // TODO Uncomment and put under debug flag (when implemented)
        // if (depthStencil && (depth || stencil)) {
        //     throw new Error(
        //         'Framebuffer can\'t have DEPTH_STENCIL and DEPTH or STENCIL ' +
        //             'attachment simultaneously.'
        //     );
        // }
        const gl = this._gl;
        let width = 0;
        let height = 0;
        if (color) {
            width = color.getWidth();
            height = color.getHeight();
        }
        else if (depth) {
            width = depth.getWidth();
            height = depth.getHeight();
        }
        else if (stencil) {
            width = stencil.getWidth();
            height = stencil.getHeight();
        }
        else if (depthStencil) {
            width = depthStencil.getWidth();
            height = depthStencil.getHeight();
        }
        const framebuffer = new __WEBPACK_IMPORTED_MODULE_2__gl_framebuffer__["a" /* default */](gl, width, height);
        this.bindRenderTarget(framebuffer);
        if (color) {
            color.attachToFramebuffer(gl.COLOR_ATTACHMENT0);
        }
        if (depth) {
            depth.attachToFramebuffer(gl.DEPTH_ATTACHMENT);
        }
        if (stencil) {
            stencil.attachToFramebuffer(gl.STENCIL_ATTACHMENT);
        }
        if (depthStencil) {
            depthStencil.attachToFramebuffer(gl.DEPTH_STENCIL_ATTACHMENT);
        }
        // TODO Uncomment and put under debug flag (when implemented)
        // switch (gl.checkFramebufferStatus(gl.FRAMEBUFFER)) {
        //     case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
        //         throw new Error('Framebuffer attachments are not renderable');
        //     case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
        //         throw new Error('Framebuffer attachments are not same size');
        //     case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
        //         throw new Error('Framebuffer has no attachments');
        //     case gl.FRAMEBUFFER_UNSUPPORTED:
        //         throw new Error('Framebuffer has unsupported attachment');
        // }
        return framebuffer;
    }
    /**
     * Allocates a new renderbuffer with given size and format.
     *
     * @param width Width of the renderbuffer.
     * @param height Height of the renderbuffer.
     * @param format Format of the renderbuffer.
     * @return The allocated renderbuffer.
     *
     */
    createRenderbuffer(width, height, format) {
        const gl = this._gl;
        const renderbuffer = new __WEBPACK_IMPORTED_MODULE_4__gl_renderbuffer__["a" /* default */](gl, width, height);
        renderbuffer.bind();
        gl.renderbufferStorage(gl.RENDERBUFFER, format, width, height);
        return renderbuffer;
    }
    /**
     * Allocates a new texture with given size, format, type and parameters and
     * fills it with zeroes.
     *
     * @param width Width of the texture.
     * @param height Height of the texture.
     * @param format Pixel format of the texture.
     * @param type Pixel type of the texture.
     * @param params Parameters of the texture.
     * @returns Newly allocated texture.
     */
    createEmpty2DTexture(width, height, format, type, params = __WEBPACK_IMPORTED_MODULE_7__gl_texture__["a" /* DEFAULT_TEXTURE_PARAMS */]) {
        const texture = new __WEBPACK_IMPORTED_MODULE_7__gl_texture__["b" /* default */](this._gl, width, height, format, type, params);
        return texture;
    }
    /**
     * Creates a new shader program. Uses cache, i.e. if a program with same
     * source string and options is already created, returns it.
     *
     * @param vertexShaderSource Source code of vertex shader of the program.
     * @param fragmentShaderSource Source code of fragment shader of the program.
     * @param options Options.
     * @returns Newly created program or one from the cache.
     */
    createProgram(vertexShaderSource, fragmentShaderSource, options) {
        return new __WEBPACK_IMPORTED_MODULE_3__gl_program__["a" /* default */](this._gl, vertexShaderSource, fragmentShaderSource, options);
    }
    createVertexBuffer(size, usage = 35044 /* STATIC_DRAW */) {
        return this._createBuffer(this._gl.ARRAY_BUFFER, size, usage);
    }
    createIndexBuffer(size, usage = 35044 /* STATIC_DRAW */) {
        return this._createBuffer(this._gl.ELEMENT_ARRAY_BUFFER, size, usage);
    }
    // TODO: check https://github.com/Microsoft/TypeScript/issues/24195 to update narrowed data type according
    uploadDataToBuffer(buffer, data, offset = 0) {
        buffer.bind();
        this._gl.bufferSubData(buffer.getTarget(), offset, data);
    }
    /**
     * Creates a new vertex array object in the context.
     *
     * @param attributeMapping Mapping of vertex attrbiutes for the VAO.
     * @param vertexBuffer Vertex buffer to be bound to the VAO.
     * @param indexBuffer Index buffer to be bound to the VAO.
     * @returns The new VAO.
     */
    createVao(attributeMapping, vertexBuffer, indexBuffer) {
        const gl = this._gl;
        const vao = new __WEBPACK_IMPORTED_MODULE_8__gl_vao__["a" /* default */](gl, this._vaoExt, attributeMapping);
        vao.bind();
        if (indexBuffer) {
            indexBuffer.bind();
        }
        else {
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        }
        vertexBuffer.bind();
        const vertexByteSize = attributeMapping.vertexByteSize;
        for (const [idx, pointer] of attributeMapping) {
            gl.enableVertexAttribArray(idx);
            gl.vertexAttribPointer(idx, pointer.size, pointer.type, pointer.normalized, vertexByteSize, pointer.offset);
        }
        this._vaoExt.bindVertexArrayOES(null);
        return vao;
    }
    /**
     * Sets new content of texture, provided data must be of length equal to "width * height" and its type
     * must correspond to texture's type {@see PixelType}.
     */
    setTextureData(texture, data) {
        const gl = this._gl;
        const width = texture.getWidth();
        const height = texture.getHeight();
        const format = texture.getFormat();
        const type = texture.getType();
        const params = texture.getParams();
        this._setTextureDataUnpackParams(params);
        this.bindTexture(texture);
        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, height, format, type, data);
        this._onTextureDataUpdated(texture);
    }
    /**
     * Sets new texture content from canvas element.
     */
    setTextureDataFromDomElement(texture, element) {
        const gl = this._gl;
        const format = texture.getFormat();
        const type = texture.getType();
        const params = texture.getParams();
        this._setTextureDataUnpackParams(params);
        this.bindTexture(texture);
        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, format, type, element);
        this._onTextureDataUpdated(texture);
    }
    /**
     * Returns default render target associated with canvas on which the WebGL
     * context operates.
     */
    getDefaultRenderTarget() {
        return this._defaultRenderTarget;
    }
    /**
     * Clears currently bound render target according to a mask.
     *
     * @param mask Bitwise OR of marks, i.e.
     *      `ClearMask.COLOR_BUFFER_BIT | ClearMask.DEPTH_BUFFER_BIT`.
     */
    clearCurrentTarget(mask) {
        if (mask) {
            this._gl.clear(mask);
            this._boundRenderTarget.isClear = true;
        }
    }
    /**
     * Binds a render target to the WebGL context if it's not already bound.
     *
     * @param target The render target to be bound.
     */
    bindRenderTarget(target) {
        if (this._boundRenderTarget !== target) {
            target.bind();
            this._boundRenderTarget = target;
        }
        // Target size could change even if target is already bound.
        // VECTOR-190
        this._setViewportState(new __WEBPACK_IMPORTED_MODULE_6__state__["c" /* default */]({
            viewportWidth: target.getWidth(),
            viewportHeight: target.getHeight()
        }));
    }
    /**
     * Binds a render state to the WebGL context with minimum amount of actual
     * state switching.
     *
     * @param state The state to be bound.
     */
    bindRenderState(state) {
        this._setColorBufferState(state);
        this._setBlendState(state);
        this._setCullFaceState(state);
        this._setFrontFaceState(state);
        this._setDepthTestState(state);
        this._setDitherState(state);
        this._setDrawBuffersState(state);
        this._setPolygonOffsetState(state);
        this._setAlphaToCoverageState(state);
        this._setSampleCoverageState(state);
        this._setStencilTestState(state);
        this._setScissorTestState(state);
        this._setViewportState(state);
    }
    /**
     * Binds a program to the WebGL context if it's not already bound.
     *
     * @param program The program to be bound.
     */
    bindProgram(program) {
        if (this._boundProgram !== program) {
            program.bind();
            this._boundProgram = program;
        }
    }
    /**
     * Binds a vertex array object to the context if it's not already bound.
     *
     * @param vao The vertex array object to bind. Passing `null` will unbind
     *      any currently bound VAO.
     */
    bindVao(vao) {
        if (this._boundVao !== vao) {
            if (vao) {
                vao.bind();
            }
            else {
                this._vaoExt.bindVertexArrayOES(null);
            }
            this._boundVao = vao;
        }
    }
    bindQuadVao() {
        this.bindVao(this._quadVao);
    }
    bindTextureUnit(unit) {
        const gl = this._gl;
        if (this._boundTextureUnit !== unit) {
            gl.activeTexture(gl.TEXTURE0 + unit);
            this._boundTextureUnit = unit;
        }
    }
    bindTexture(texture) {
        const boundUnit = this._boundTextureUnit;
        if (this._boundTextures[boundUnit] !== texture) {
            texture.bind();
            this._boundTextures[boundUnit] = texture;
        }
    }
    /**
     * Draws a quad to currently bound render target with currently bound render
     * state, program and uniform state.
     */
    drawQuad() {
        this.drawMesh(0, 6, 4 /* TRIANGLES */);
    }
    /**
     * Draws a mesh from currently bound to ARRAY_BUFFER buffer.
     *
     * @param offset Index of the vertex to start drawing from.
     * @param count Number of vertices to process.
     * @param primitiveType
     */
    drawMesh(offset, count, primitiveType = 4 /* TRIANGLES */) {
        this._gl.drawArrays(primitiveType, offset, count);
        this._boundRenderTarget.isClear = false;
    }
    /**
     * Draws a mesh to currently bound render target with currently bound render
     * state, program and uniform state.
     *
     * @param offset Offset of indices of the mesh in currently bound memory page.
     * @param indexCount Number of indices in the mesh.
     */
    drawIndexedMesh(offset, indexCount, primitiveType = 4 /* TRIANGLES */) {
        const gl = this._gl;
        gl.drawElements(primitiveType, indexCount, gl.UNSIGNED_SHORT, offset);
        this._boundRenderTarget.isClear = false;
    }
    /**
     * Destroys the context and resources owned by it. Note that resources that
     * were created with `create*` method of the context aren't exactly belong
     * to the context, entities that created them have to destroy them.
     */
    destroy() {
        this._quadVao.destroy();
        this._quadVertexBuffer.destroy();
        this._gl.canvas.removeEventListener('webglcontextlost', this._contextLostListener);
    }
    /**
     * Creates a new context from a canvas.
     *
     * @throws An error if fails to create `webgl` context for the canvas.
     * @param canvas The canvas.
     * @param attribs Attributes of the context.
     */
    static createFromCanvas(canvas, attribs) {
        const gl = canvas.getContext('webgl', attribs);
        if (!gl) {
            throw new Error('Failed to create GL context from canvas.');
        }
        return new RenderContext(gl);
    }
    /**
     * Enables or disables a WebGL capability.
     * @see https://www.khronos.org/registry/OpenGL-Refpages/es2.0/xhtml/glEnable.xml
     *
     * @param capability The capability to be enabled of disabled.
     * @param enabled New state of the capability;
     */
    _setCapabilityEnabled(capability, enabled) {
        if (enabled) {
            this._gl.enable(capability);
        }
        else {
            this._gl.disable(capability);
        }
    }
    /**
     * Sets new clear color and color mask from a state if they're different from
     * currently set ones.
     *
     * @param state The state that contains new clear color and color masks.
     */
    _setColorBufferState(state) {
        const gl = this._gl;
        const boundState = this._boundRenderState;
        const newClearColor = state.clearColor;
        if (!__WEBPACK_IMPORTED_MODULE_9__util_color__["a" /* areEqual */](boundState.clearColor, newClearColor)) {
            gl.clearColor(newClearColor.r, newClearColor.g, newClearColor.b, newClearColor.a);
            __WEBPACK_IMPORTED_MODULE_9__util_color__["b" /* copy */](newClearColor, boundState.clearColor);
        }
        if (boundState.colorMaskR !== state.colorMaskR ||
            boundState.colorMaskG !== state.colorMaskG ||
            boundState.colorMaskB !== state.colorMaskB ||
            boundState.colorMaskAlpha !== state.colorMaskAlpha) {
            this._gl.colorMask(state.colorMaskR, state.colorMaskG, state.colorMaskB, state.colorMaskAlpha);
            boundState.colorMaskR = state.colorMaskR;
            boundState.colorMaskG = state.colorMaskG;
            boundState.colorMaskB = state.colorMaskB;
            boundState.colorMaskAlpha = state.colorMaskAlpha;
        }
    }
    /**
     * Sets blend state and params.
     *
     * @param state The state that contains new blend params.
     */
    _setBlendState(state) {
        const gl = this._gl;
        const boundState = this._boundRenderState;
        if (boundState.blend !== state.blend) {
            this._setCapabilityEnabled(gl.BLEND, state.blend);
            boundState.blend = state.blend;
        }
        if (state.blend) {
            if (boundState.blendEquationRgb !== state.blendEquationRgb ||
                boundState.blendEquationAlpha !== state.blendEquationAlpha) {
                gl.blendEquationSeparate(state.blendEquationRgb, state.blendEquationAlpha);
                boundState.blendEquationRgb = state.blendEquationRgb;
                boundState.blendEquationAlpha = state.blendEquationAlpha;
            }
            if (boundState.blendFuncDstRgb !== state.blendFuncDstRgb ||
                boundState.blendFuncSrcRgb !== state.blendFuncSrcRgb ||
                boundState.blendFuncDstAlpha !== state.blendFuncDstAlpha ||
                boundState.blendFuncSrcAlpha !== state.blendFuncSrcAlpha) {
                gl.blendFuncSeparate(state.blendFuncSrcRgb, state.blendFuncDstRgb, state.blendFuncSrcAlpha, state.blendFuncDstAlpha);
                boundState.blendFuncSrcRgb = state.blendFuncSrcRgb;
                boundState.blendFuncDstRgb = state.blendFuncDstRgb;
                boundState.blendFuncSrcAlpha = state.blendFuncSrcAlpha;
                boundState.blendFuncDstAlpha = state.blendFuncDstAlpha;
            }
        }
    }
    /**
     * Sets cull face state and params.
     *
     * @param state The state that contains new cull face state and mode.
     */
    _setCullFaceState(state) {
        const gl = this._gl;
        const boundState = this._boundRenderState;
        if (boundState.cullFace !== state.cullFace) {
            this._setCapabilityEnabled(gl.CULL_FACE, state.cullFace);
            boundState.cullFace = state.cullFace;
        }
        if (state.cullFace &&
            boundState.cullFaceMode !== state.cullFaceMode) {
            gl.cullFace(state.cullFaceMode);
            boundState.cullFaceMode = state.cullFaceMode;
        }
    }
    /**
     * Sets front face mode.
     *
     * @param state The state that contains new front face mode.
     */
    _setFrontFaceState(state) {
        const boundState = this._boundRenderState;
        if (boundState.frontFaceMode !== state.frontFaceMode) {
            this._gl.frontFace(state.frontFaceMode);
            boundState.frontFaceMode = state.frontFaceMode;
        }
    }
    /**
     * Sets depth test state and params.
     *
     * @param state The state that contains new depth test state and params.
     */
    _setDepthTestState(state) {
        const gl = this._gl;
        const boundState = this._boundRenderState;
        if (boundState.depthTest !== state.depthTest) {
            this._setCapabilityEnabled(gl.DEPTH_TEST, state.depthTest);
            boundState.depthTest = state.depthTest;
        }
        if (state.depthTest) {
            if (boundState.clearDepth !== state.clearDepth) {
                gl.clearDepth(state.clearDepth);
                boundState.clearDepth = state.clearDepth;
            }
            if (boundState.depthMask !== state.depthMask) {
                gl.depthMask(state.depthMask);
                boundState.depthMask = state.depthMask;
            }
            if (boundState.depthFunc !== state.depthFunc) {
                gl.depthFunc(state.depthFunc);
                boundState.depthFunc = state.depthFunc;
            }
            if (boundState.depthRangeNear !== state.depthRangeNear ||
                boundState.depthRangeFar !== state.depthRangeFar) {
                gl.depthRange(state.depthRangeNear, state.depthRangeFar);
                boundState.depthRangeNear = state.depthRangeNear;
                boundState.depthRangeFar = state.depthRangeFar;
            }
        }
    }
    /**
     * Sets dither state.
     *
     * @param state The state that contains new dither state.
     */
    _setDitherState(state) {
        const boundState = this._boundRenderState;
        if (boundState.dither !== state.dither) {
            this._setCapabilityEnabled(this._gl.DITHER, state.dither);
            boundState.dither = state.dither;
        }
    }
    /**
     * Sets draw buffers.
     *
     * @param state The state that contains array of draw buffers.
     */
    _setDrawBuffersState(state) {
        const boundDrawBuffers = this._boundRenderState.drawBuffers;
        if (boundDrawBuffers.length !== state.drawBuffers.length ||
            boundDrawBuffers
                .some((attachment, i) => attachment !== state.drawBuffers[i])) {
            this._boundRenderState.drawBuffers = state.drawBuffers.slice();
        }
    }
    /**
     * Sets polygon offset state and params.
     *
     * @param state The state that contains new polygon offset state and params.
     */
    _setPolygonOffsetState(state) {
        const gl = this._gl;
        const boundState = this._boundRenderState;
        if (boundState.polygonOffset !== state.polygonOffset) {
            this._setCapabilityEnabled(gl.POLYGON_OFFSET_FILL, state.polygonOffset);
            boundState.polygonOffset = state.polygonOffset;
        }
        if (state.polygonOffset &&
            (boundState.polygonOffsetFactor !== state.polygonOffsetFactor ||
                boundState.polygonOffsetUnits !== state.polygonOffsetUnits)) {
            gl.polygonOffset(state.polygonOffsetFactor, state.polygonOffsetUnits);
            boundState.polygonOffsetFactor = state.polygonOffsetFactor;
            boundState.polygonOffsetUnits = state.polygonOffsetUnits;
        }
    }
    /**
     * Sets alpha-to-coverage state.
     *
     * @param state The state that contains new alpha-to-coverage state.
     */
    _setAlphaToCoverageState(state) {
        const boundState = this._boundRenderState;
        if (boundState.sampleAlphaToCoverage !== state.sampleAlphaToCoverage) {
            this._setCapabilityEnabled(this._gl.SAMPLE_ALPHA_TO_COVERAGE, state.sampleAlphaToCoverage);
            boundState.sampleAlphaToCoverage = state.sampleAlphaToCoverage;
        }
    }
    /**
     * Sets sample coverage state.
     *
     * @param state The state that contains new sample coverage state and params.
     */
    _setSampleCoverageState(state) {
        const gl = this._gl;
        const boundState = this._boundRenderState;
        if (boundState.sampleCoverage !== state.sampleCoverage) {
            this._setCapabilityEnabled(gl.SAMPLE_COVERAGE, state.sampleCoverage);
            boundState.sampleCoverage = state.sampleCoverage;
        }
        if (state.sampleCoverage &&
            (boundState.sampleCoverageValue !== state.sampleCoverageValue ||
                boundState.sampleCoverageInvert !== state.sampleCoverageInvert)) {
            gl.sampleCoverage(state.sampleCoverageValue, state.sampleCoverageInvert);
            boundState.sampleCoverageValue = state.sampleCoverageValue;
            boundState.sampleCoverageInvert = state.sampleCoverageInvert;
        }
    }
    /**
     * Sets stencil test state and params.
     *
     * @param state The state that contains new stencil test state and params.
     */
    _setStencilTestState(state) {
        const gl = this._gl;
        const boundState = this._boundRenderState;
        if (boundState.stencilTest !== state.stencilTest) {
            this._setCapabilityEnabled(gl.STENCIL_TEST, state.stencilTest);
            boundState.stencilTest = state.stencilTest;
        }
        if (state.stencilTest) {
            if (boundState.clearStencil !== state.clearStencil) {
                gl.clearStencil(state.clearStencil);
                boundState.clearStencil = state.clearStencil;
            }
            if (boundState.stencilWriteMask !== state.stencilWriteMask) {
                gl.stencilMask(state.stencilWriteMask);
                boundState.stencilWriteMask = state.stencilWriteMask;
            }
            const refOrMaskIsDifferent = (boundState.stencilMask !== state.stencilMask ||
                boundState.stencilReference !== state.stencilReference);
            if (refOrMaskIsDifferent) {
                boundState.stencilMask = state.stencilMask;
                boundState.stencilReference = state.stencilReference;
            }
            if (boundState.stencilFrontFunc !== state.stencilFrontFunc ||
                refOrMaskIsDifferent) {
                gl.stencilFuncSeparate(gl.FRONT, state.stencilFrontFunc, state.stencilReference, state.stencilMask);
                boundState.stencilFrontFunc = state.stencilFrontFunc;
            }
            if (boundState.stencilBackFunc !== state.stencilBackFunc ||
                refOrMaskIsDifferent) {
                gl.stencilFuncSeparate(gl.BACK, state.stencilBackFunc, state.stencilReference, state.stencilMask);
                boundState.stencilBackFunc = state.stencilBackFunc;
            }
            if (boundState.stencilFrontFailOp !== state.stencilFrontFailOp ||
                boundState.stencilFrontDepthFailOp !== state.stencilFrontDepthFailOp ||
                boundState.stencilFrontDepthPassOp !== state.stencilFrontDepthPassOp) {
                gl.stencilOpSeparate(gl.FRONT, state.stencilFrontFailOp, state.stencilFrontDepthFailOp, state.stencilFrontDepthPassOp);
                boundState.stencilFrontFailOp = state.stencilFrontFailOp;
                boundState.stencilFrontDepthFailOp = state.stencilFrontDepthFailOp;
                boundState.stencilFrontDepthPassOp = state.stencilFrontDepthPassOp;
            }
            if (boundState.stencilBackFailOp !== state.stencilBackFailOp ||
                boundState.stencilBackDepthFailOp !== state.stencilBackDepthFailOp ||
                boundState.stencilBackDepthPassOp !== state.stencilBackDepthPassOp) {
                gl.stencilOpSeparate(gl.BACK, state.stencilBackFailOp, state.stencilBackDepthFailOp, state.stencilBackDepthPassOp);
                boundState.stencilBackFailOp = state.stencilBackFailOp;
                boundState.stencilBackDepthFailOp = state.stencilBackDepthFailOp;
                boundState.stencilBackDepthPassOp = state.stencilBackDepthPassOp;
            }
        }
    }
    /**
     * Sets scissor test state and scissor rectangle.
     *
     * @param state The state that contains new scissor test state and scissor
     *      rectangle.
     */
    _setScissorTestState(state) {
        const gl = this._gl;
        const boundState = this._boundRenderState;
        if (boundState.scissorTest !== state.scissorTest) {
            this._setCapabilityEnabled(gl.SCISSOR_TEST, state.scissorTest);
            boundState.scissorTest = state.scissorTest;
        }
        if (state.scissorTest &&
            state.scissorWidth >= 0 &&
            state.scissorHeight >= 0 &&
            (boundState.scissorX !== state.scissorX ||
                boundState.scissorY !== state.scissorY ||
                boundState.scissorWidth !== state.scissorWidth ||
                boundState.scissorHeight !== state.scissorHeight)) {
            gl.scissor(state.scissorX, state.scissorY, state.scissorWidth, state.scissorHeight);
            boundState.scissorX = state.scissorX;
            boundState.scissorY = state.scissorY;
            boundState.scissorWidth = state.scissorWidth;
            boundState.scissorHeight = state.scissorHeight;
        }
    }
    /**
     * Sets viewport.
     *
     * @param state The state that contains new viewport.
     */
    _setViewportState(state) {
        const boundState = this._boundRenderState;
        if (state.viewportWidth >= 0 &&
            state.viewportHeight >= 0 &&
            (boundState.viewportX !== state.viewportX ||
                boundState.viewportY !== state.viewportY ||
                boundState.viewportWidth !== state.viewportWidth ||
                boundState.viewportHeight !== state.viewportHeight)) {
            this._gl.viewport(state.viewportX, state.viewportY, state.viewportWidth, state.viewportHeight);
            boundState.viewportX = state.viewportX;
            boundState.viewportY = state.viewportY;
            boundState.viewportWidth = state.viewportWidth;
            boundState.viewportHeight = state.viewportHeight;
        }
    }
    /**
     * Sets texture data unpack params.
     *
     * @param params Texture params to be set.
     */
    _setTextureDataUnpackParams(params) {
        const gl = this._gl;
        if (this._unpackPremultiplyAlpha !== params.premultipliedAlpha) {
            gl.pixelStorei(37441 /* UNPACK_PREMULTIPLY_ALPHA_WEBGL */, +params.premultipliedAlpha);
            this._unpackPremultiplyAlpha = params.premultipliedAlpha;
        }
    }
    _onTextureDataUpdated(texture) {
        const gl = this._gl;
        const params = texture.getParams();
        if (params.minificationFilter >= 9984 /* NEAREST_MIPMAP_NEAREST */) {
            gl.generateMipmap(gl.TEXTURE_2D);
        }
    }
    /**
     * Creates a new zeroed buffer with a given size and a target.
     *
     * @param target The target of the new buffer, `ARRAY_BUFFER` or
     *      `ELEMENT_ARRAY_BUFFER`.
     * @param size The size of the buffer.
     * @param usage Usage of the buffer.
     * @returns The buffer.
     */
    _createBuffer(target, size, usage = this._gl.STATIC_DRAW) {
        const gl = this._gl;
        const buffer = new __WEBPACK_IMPORTED_MODULE_1__gl_buffer__["a" /* default */](gl, target, size);
        // TODO(dmikis) a cleverer way not to break currently bound VAO;
        this.bindVao(null);
        buffer.bind();
        gl.bufferData(target, size, usage);
        return buffer;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RenderContext;



/***/ }),
/* 55 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export isPowOf2 */
/* harmony export (immutable) */ __webpack_exports__["a"] = align;
/**
 * Checks if a number is a power of 2.
 *
 * @param x The number to check.
 * @returns `true` if the number is an integer power of 2 and `false` otherwise.
 */
function isPowOf2(x) {
    return x > 0 && !(x & (x - 1));
}
/**
 * Aligns an offset by an alignment given by a mask.
 *
 * @param offset The offset.
 * @param alignmentMask The alignment mask โ a bit field that has `log2(alignment)`
 *      of least significant bits unset and other set, e.g. if `alignment` is 4
 *      then the `alignmentMask` will be `0xffffffc`
 * @returns Aligned offset.
 */
function align(offset, alignmentMask) {
    return (offset - 1 & alignmentMask) - alignmentMask;
}


/***/ }),
/* 56 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/** Wrapper around WebGLBuffer object. */
class Buffer {
    /**
     * Creates a new empty buffer in a WebGL context.
     *
     * @param gl The context the buffer will be created in.
     * @param target Binding target of the buffer. Since in WebGL once you've
     *      bound a buffer to a given target you can't bind it any other one,
     *      we "tie" the buffer and it's binding point together.
     * @param size Size of the buffer. We don't do actual allocation in the
     *      wrapper, it's context's responsibility. But it's convenient to be
     *      able to get the size from the wrapper object.
     */
    constructor(gl, target, size) {
        this._gl = gl;
        this._target = target;
        this._handle = gl.createBuffer();
        this._size = size;
    }
    /** Binds the buffer to the context to its binding target. */
    bind() {
        this._gl.bindBuffer(this._target, this._handle);
    }
    /**
     * Returns `true` if the buffer is currently bound to the context to its
     * binding target and `false` otherwise.
     */
    isBound() {
        const gl = this._gl;
        const handle = this._handle;
        switch (this._target) {
            case gl.ARRAY_BUFFER:
                return gl.getParameter(gl.ARRAY_BUFFER_BINDING) === handle;
            case gl.ELEMENT_ARRAY_BUFFER:
                return gl.getParameter(gl.ELEMENT_ARRAY_BUFFER_BINDING) === handle;
        }
        return false;
    }
    /** Returns binding target of the buffer. */
    getTarget() {
        return this._target;
    }
    /** Returns size of the buffer. */
    getSize() {
        return this._size;
    }
    /**
     * Destroys the buffer.
     */
    destroy() {
        this._gl.deleteBuffer(this._handle);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Buffer;



/***/ }),
/* 57 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/** Wrapper around WebGLFramebuffer object. */
class Framebuffer {
    /**
     * Creates a new framebuffer in a WebGL context.
     *
     * @param gl The context the framebuffer will be created in.
     * @param width Width of the framebuffer.
     * @param height Height of the framebuffer.
     */
    constructor(gl, width, height) {
        this.isClear = false;
        this._gl = gl;
        this._handle = gl.createFramebuffer();
        this._width = width;
        this._height = height;
    }
    /**
     * Binds the framebuffer to the WebGL context.
     */
    bind() {
        const gl = this._gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._handle);
    }
    /**
     * Checks if the framebuffer is bound to the WebGL context.
     *
     * @returns `true` if the framebuffer is currently bound to the WebGL context
     *      and `false` otherwise.
     */
    isBound() {
        const gl = this._gl;
        return gl.getParameter(gl.FRAMEBUFFER_BINDING) === this._handle;
    }
    /**
     * Returns width of the framebuffer.
     */
    getWidth() {
        return this._width;
    }
    /**
     * Returns height of the framebuffer.
     */
    getHeight() {
        return this._height;
    }
    /**
     * Reads content of the color attachment as an RGBA bitmap.
     */
    readPixels() {
        const data = new Uint8Array(this.getWidth() * this.getHeight() * 4);
        this._gl.readPixels(0, 0, this._width, this._height, 6408 /* RGBA */, 5121 /* UNSIGNED_BYTE */, data);
        return data;
    }
    /**
     * Destroys the framebuffer.
     */
    destroy() {
        this._gl.deleteFramebuffer(this._handle);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Framebuffer;



/***/ }),
/* 58 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Inserts given parameters as preprocessor define directives into shader source.
 *
 * @param source Shader source.
 * @param defines Dictionary with parameters to define with preprocessor directives.
 * @returns Shader source with preprocessor directives inserted.
 */
function insertDefines(source, defines) {
    const definesString = Object.keys(defines)
        .map((defineName) => '#define ' + defineName + ' ' +
        defines[defineName])
        .join('\n');
    const versionIdx = source.indexOf('#version');
    if (versionIdx === -1) {
        return definesString + '\n' + source;
    }
    const nextLineIdx = source.indexOf('\n', versionIdx) + 1;
    return source.slice(0, nextLineIdx) + definesString + '\n' +
        source.slice(nextLineIdx);
}
/**
 * Creates a new shader of a given type out of a given source string.
 *
 * @param gl WebGL context the shader will be created in.
 * @param type The type of the shader, VERTEX_SHADER or FRAGMENT_SHADER.
 * @param source The source string.
 * @throws An error if compilation of the shader fails.
 * @returns The shader WebGL handle.
 */
function compileShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    // TODO Uncomment and put under debug flag (when implemented)
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        throw new Error('Failed to compile shader:\n' + gl.getShaderInfoLog(shader));
    }
    return shader;
}
/** Wrapper around WebGLProgram objects. */
class Program {
    /**
     * Constructs a new program.
     *
     * @param gl WebGL context the program will be created in.
     * @param vertexShaderSource Source code of vertex shader of the program.
     * @param fragmentShaderSource Source code of fragment shader of the program.
     * @param options Options.
     * @throws An error if shader compilation or program linking fails.
     */
    constructor(gl, vertexShaderSource, fragmentShaderSource, options) {
        this._gl = gl;
        const handle = this._handle = gl.createProgram();
        if (options && options.defines) {
            vertexShaderSource = insertDefines(vertexShaderSource, options.defines);
            fragmentShaderSource = insertDefines(fragmentShaderSource, options.defines);
        }
        const vertexShader = compileShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        gl.attachShader(handle, vertexShader);
        gl.attachShader(handle, fragmentShader);
        gl.deleteShader(vertexShader);
        gl.deleteShader(fragmentShader);
        if (options && options.attribMap) {
            Object.keys(options.attribMap)
                .forEach((attributeName) => gl.bindAttribLocation(handle, options.attribMap[attributeName], attributeName));
        }
        gl.linkProgram(handle);
        // TODO Uncomment and put under debug flag (when implemented)
        if (!gl.getProgramParameter(handle, gl.LINK_STATUS)) {
            throw new Error(`Failed to link program:\n${gl.getProgramInfoLog(handle)}`);
        }
        this._uniformCache = new Map();
    }
    /**
     * Binds the program to the WebGL context.
     */
    bind() {
        const gl = this._gl;
        const handle = this._handle;
        // TODO Uncomment and put under debug flag (when implemented)
        // gl.validateProgram(handle);
        // if (!gl.getProgramParameter(handle, gl.VALIDATE_STATUS)) {
        //     throw new Error(
        //         'Failed to validate program:\n' + gl.getProgramInfoLog(handle)
        //     );
        // }
        gl.useProgram(handle);
    }
    /**
     * Checks if the program is bound to the WebGL context.
     *
     * @returns `true` if the program if currently bound to the WebGL context and
     *      `false` otherwise.
     */
    isBound() {
        const gl = this._gl;
        return gl.getParameter(gl.CURRENT_PROGRAM) === this._handle;
    }
    /**
     * Sets an integer scalar value to a uniform. If there's no uniform with
     * given name in the program, silently does nothing.
     *
     * @param uniformName Name of the uniform.
     * @param value The scalar value.
     */
    setIntScalarUniform(uniformName, value) {
        const location = this._getUniformLocation(uniformName);
        if (location) {
            this._gl.uniform1i(location, value);
        }
    }
    /**
     * Sets a scalar value to a uniform. If there's no uniform with
     * given name in the program, silently does nothing.
     *
     * @param uniformName Name of the uniform.
     * @param value The scalar value.
     */
    setScalarUniform(uniformName, value) {
        const location = this._getUniformLocation(uniformName);
        if (location) {
            this._gl.uniform1f(location, value);
        }
    }
    /**
     * Sets a 2D vector to a uniform. If there's no uniform with given name in
     * the program, silently does nothing.
     *
     * @param uniformName Name of the uniform.
     * @param value The vector.
     */
    setVector2Uniform(uniformName, value) {
        const location = this._getUniformLocation(uniformName);
        if (location) {
            this._gl.uniform2f(location, value.x, value.y);
        }
    }
    /**
     * Sets a 3D vector to a uniform. If there's no uniform with given name in
     * the program, silently does nothing.
     *
     * @param uniformName Name of the uniform.
     * @param value The vector.
     */
    setVector3Uniform(uniformName, value) {
        const location = this._getUniformLocation(uniformName);
        if (location) {
            this._gl.uniform3f(location, value.x, value.y, value.z);
        }
    }
    /**
     * Sets a 4D vector to a uniform. If there's no uniform with given name in
     * the program, silently does nothing.
     *
     * @param uniformName Name of the uniform.
     * @param value The vector.
     */
    setVector4Uniform(uniformName, value) {
        const location = this._getUniformLocation(uniformName);
        if (location) {
            this._gl.uniform4f(location, value.x, value.y, value.z, value.w);
        }
    }
    /**
     * Sets a color to a uniform. If there's no uniform with given name in the
     * program, silently does nothing.
     *
     * @param uniformName Name of the uniform.
     * @param value The color.
     */
    setColorUniform(uniformName, value) {
        const location = this._getUniformLocation(uniformName);
        if (location) {
            this._gl.uniform4f(location, value.r, value.g, value.b, value.a);
        }
    }
    /**
     * Sets a 3x3 matrix to a uniform. If there's no uniform with given name in
     * the program, silently does nothing.
     *
     * @param uniformName Name of the uniform.
     * @param value The matrix.
     */
    setMatrix3Uniform(uniformName, value) {
        const location = this._getUniformLocation(uniformName);
        if (location) {
            this._gl.uniformMatrix3fv(location, false, value);
        }
    }
    /**
     * Sets a 4x4 matrix to a uniform. If there's no uniform with given name in
     * the program, silently does nothing.
     *
     * @param uniformName Name of the uniform.
     * @param value The matrix.
     */
    setMatrix4Uniform(uniformName, value) {
        const location = this._getUniformLocation(uniformName);
        if (location) {
            this._gl.uniformMatrix4fv(location, false, value);
        }
    }
    /**
     * Destroys the program.
     */
    destroy() {
        this._gl.deleteProgram(this._handle);
    }
    _getUniformLocation(name) {
        const cache = this._uniformCache;
        let location = cache.get(name);
        if (!location) {
            location = this._gl.getUniformLocation(this._handle, name);
            if (!location) {
                // TODO Uncomment and put under debug flag (when implemented)
                // console.warn(`Uniform ${name} doesn't exist in program.`);
                return null;
            }
            cache.set(name, location);
        }
        return location;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Program;



/***/ }),
/* 59 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/** Wrapper around WebGLRenderbuffer objects. */
class Renderbuffer {
    /**
     * Creates a new renderbuffer in a WebGL context.
     *
     * @param gl The context the renderbuffer will be created in.
     */
    constructor(gl, width, height) {
        this._gl = gl;
        this._handle = gl.createRenderbuffer();
        this._width = width;
        this._height = height;
    }
    /**
     * Binds the renderbuffer to the WebGL context.
     */
    bind() {
        const gl = this._gl;
        gl.bindRenderbuffer(gl.RENDERBUFFER, this._handle);
    }
    /**
     * Checks if the renderbuffer is bound to the WebGL context.
     *
     * @returns `true` if the renderbuffer is currently bound to the WebGL context
     *      and `false` otherwise.
     */
    isBound() {
        const gl = this._gl;
        return gl.getParameter(gl.RENDERBUFFER_BINDING) === this._handle;
    }
    /**
     * Attaches the renderbuffer to a currently bound to the WebGL context
     * framebuffer.
     *
     * @param attachmentPoint Attachment point the renderbuffer will be attached
     *      to.
     */
    attachToFramebuffer(attachmentPoint) {
        const gl = this._gl;
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachmentPoint, gl.RENDERBUFFER, this._handle);
    }
    getWidth() {
        return this._width;
    }
    getHeight() {
        return this._height;
    }
    /**
     * Destroys the renderbuffer.
     */
    destroy() {
        this._gl.deleteRenderbuffer(this._handle);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Renderbuffer;



/***/ }),
/* 60 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// tslint:disable
/*
    This is automatically generated by /tools/gl_gen/gen_capabilities.js script.
    Instead of modifying it edit the script and regenerate this file.
*/
class RenderContextCapabilitiesManager {
    constructor(gl) {
        this._gl = gl;
        this._paramValues = new Map();
    }
    getAliasedLineWidthRange() { return this._getParam(33902 /* ALIASED_LINE_WIDTH_RANGE */); }
    getAliasedPointSizeRange() { return this._getParam(33901 /* ALIASED_POINT_SIZE_RANGE */); }
    getMaxCombinedTextureImageUnits() { return this._getParam(35661 /* MAX_COMBINED_TEXTURE_IMAGE_UNITS */); }
    getMaxCubeMapTextureSize() { return this._getParam(34076 /* MAX_CUBE_MAP_TEXTURE_SIZE */); }
    getMaxFragmentUniformVectors() { return this._getParam(36349 /* MAX_FRAGMENT_UNIFORM_VECTORS */); }
    getMaxRenderbufferSize() { return this._getParam(34024 /* MAX_RENDERBUFFER_SIZE */); }
    getMaxTextureImageUnits() { return this._getParam(34930 /* MAX_TEXTURE_IMAGE_UNITS */); }
    getMaxTextureSize() { return this._getParam(3379 /* MAX_TEXTURE_SIZE */); }
    getMaxVaryingVectors() { return this._getParam(36348 /* MAX_VARYING_VECTORS */); }
    getMaxVertexAttribs() { return this._getParam(34921 /* MAX_VERTEX_ATTRIBS */); }
    getMaxVertexTextureImageUnits() { return this._getParam(35660 /* MAX_VERTEX_TEXTURE_IMAGE_UNITS */); }
    getMaxVertexUniformVectors() { return this._getParam(36347 /* MAX_VERTEX_UNIFORM_VECTORS */); }
    getMaxViewportDims() { return this._getParam(3386 /* MAX_VIEWPORT_DIMS */); }
    getRenderer() { return this._getParam(7937 /* RENDERER */); }
    getSubpixelBits() { return this._getParam(3408 /* SUBPIXEL_BITS */); }
    getVendor() { return this._getParam(7936 /* VENDOR */); }
    getVersion() { return this._getParam(7938 /* VERSION */); }
    /** Calling this method w/o `WEBGL_debug_renderer_info` enabled will return `null`! */
    getUnmaskedVendor() { return this._getParam(37445 /* UNMASKED_VENDOR */); }
    /** Calling this method w/o `WEBGL_debug_renderer_info` enabled will return `null`! */
    getUnmaskedRenderer() { return this._getParam(37446 /* UNMASKED_RENDERER */); }
    _getParam(param) {
        const paramValues = this._paramValues;
        let paramValue = paramValues.get(param);
        if (!paramValue) {
            paramValue = this._gl.getParameter(param);
            paramValues.set(param, paramValue);
        }
        return paramValue;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RenderContextCapabilitiesManager;



/***/ }),
/* 61 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Our defaults for textures are different from ones in WebGL for two reasons:
 * 1. default minification filter in WebGL is NEAREST_MIPMAP_LINEAR which requires
 *    texture to have all mip levels specified;
 * 2. default wrap modes are REPEAT which isn't supported for NPOT textures.
 */
const DEFAULT_TEXTURE_PARAMS = {
    wrapS: 33071 /* CLAMP_TO_EDGE */,
    wrapT: 33071 /* CLAMP_TO_EDGE */,
    magnificationFilter: 9728 /* NEAREST */,
    minificationFilter: 9728 /* NEAREST */,
    premultipliedAlpha: false
};
/* harmony export (immutable) */ __webpack_exports__["a"] = DEFAULT_TEXTURE_PARAMS;

/** Wrapper around WebGLTexture objects. For now only works with 2D textures. */
class Texture {
    /**
     * Creates a new texture in a WebGL context.
     *
     * @param gl The context the texture will be created in.
     */
    constructor(gl, width, height, format, type, params = DEFAULT_TEXTURE_PARAMS) {
        this._gl = gl;
        this._format = format;
        this._type = type;
        this._params = params;
        this._width = width;
        this._height = height;
        this._handle = gl.createTexture();
        this.bind();
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, params.wrapS);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, params.wrapT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, params.magnificationFilter);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, params.minificationFilter);
        gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, 0, format, type, null);
    }
    /**
     * Binds the texture to the WebGL context as a 2D texture.
     */
    bind() {
        const gl = this._gl;
        gl.bindTexture(gl.TEXTURE_2D, this._handle);
    }
    /**
     * Checks if the texture is bound to the WebGL context.
     *
     * @returns `true` if the texture is currently bound to the WebGL context
     *      and `false` otherwise.
     */
    isBound() {
        const gl = this._gl;
        return gl.getParameter(gl.TEXTURE_BINDING_2D) === this._handle;
    }
    /**
     * Attaches the texture to a currently bound to the WebGL context framebuffer.
     *
     * @param attachmentPoint Attachment point the texture will be attached to.
     */
    attachToFramebuffer(attachmentPoint) {
        const gl = this._gl;
        gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentPoint, gl.TEXTURE_2D, this._handle, 0);
    }
    /** Returns width of the texture. */
    getWidth() {
        return this._width;
    }
    /** Returns height of the texture. */
    getHeight() {
        return this._height;
    }
    /** Returns pixel format of the texture. */
    getFormat() {
        return this._format;
    }
    /** Return pixel type of the texture. */
    getType() {
        return this._type;
    }
    /** Return params of the texture. */
    getParams() {
        return this._params;
    }
    /**
     * Destroys the texture.
     */
    destroy() {
        this._gl.deleteTexture(this._handle);
    }
}
/* harmony export (immutable) */ __webpack_exports__["b"] = Texture;



/***/ }),
/* 62 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Wrapper around vertex array (VAO) object from `OES_vertex_array_object`
 * extension.
 */
class VertexArrayObject {
    /**
     * Creates new VAO in a given WebGL context.
     *
     * @param gl The context.
     * @param vaoExt Instance of `OES_vertex_array_object` extension.
     * @param attributeMapping Mapping of attributes.
     */
    constructor(gl, vaoExt, attributeMapping) {
        this._gl = gl;
        this._vaoExt = vaoExt;
        this._handle = vaoExt.createVertexArrayOES();
        this.attributeMapping = attributeMapping;
    }
    /**
     * Binds the VAO to the context.
     */
    bind() {
        this._vaoExt.bindVertexArrayOES(this._handle);
    }
    /**
     * Checks if the VAO is currently bound to the context.
     *
     * @returns `true` if the VAO is currently bound to the WebGL context and
     *      `false` otherwise.
     */
    isBound() {
        return this._gl.getParameter(this._vaoExt.VERTEX_ARRAY_BINDING_OES) ===
            this._handle;
    }
    /**
     * Destroys the VAO.
     */
    destroy() {
        this._vaoExt.deleteVertexArrayOES(this._handle);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = VertexArrayObject;



/***/ }),
/* 63 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_scalar__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_rad_deg__ = __webpack_require__(64);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_options__ = __webpack_require__(65);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__math_matrix4__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__math_vector2__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__math_vector3__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__util_event_emitter__ = __webpack_require__(2);








// TODO(dmikis) We want to constraint coordinates so visible region doesn't extend
//      out of world boundaries. However, in current implementation it doesn't
//      work properly for aspect ratios >1 on zoom 0 since visible region is
//      larger that the world itself (so there's no way to squeeze it in). For
//      the current case (i.e. cycled in horizontal direction) it is not a problem.
const MAX_TILT = Object(__WEBPACK_IMPORTED_MODULE_1__util_rad_deg__["a" /* deg2rad */])(40);
/**
 * If a camera has zoom less than of equal to `NO_TILT_MAX_ZOOM`, tilt won't be
 * allowed.
 */
const NO_TILT_MAX_ZOOM = 1;
/**
 * If a camera has zoom greater than of equal to `FULL_TILT_MIN_ZOOM`, tilt will
 * be allowed up to `MAX_TILT`.
 */
const FULL_TILT_MIN_ZOOM = NO_TILT_MAX_ZOOM + 1;
const FRUSTUM_DIRECTIONS = [
    // tslint:disable
    __WEBPACK_IMPORTED_MODULE_5__math_vector3__["e" /* create */](-1, 1, -1),
    __WEBPACK_IMPORTED_MODULE_5__math_vector3__["e" /* create */](1, 1, -1),
    __WEBPACK_IMPORTED_MODULE_5__math_vector3__["e" /* create */](1, -1, -1),
    __WEBPACK_IMPORTED_MODULE_5__math_vector3__["e" /* create */](-1, -1, -1)
    // tslint:enable
];
/**
 * How big the world sould be on a screen if zoom is 0, in device independent pixels
 */
const ZOOM_0_WORLD_CSS_PIXEL_SIZE = 256;
const DEFAULT_OPTIONS = {
    wrapModeX: 1 /* CLAMP_TO_EDGE */,
    wrapModeY: 1 /* CLAMP_TO_EDGE */,
    minZoom: 0,
    maxZoom: 24,
    fov: Object(__WEBPACK_IMPORTED_MODULE_1__util_rad_deg__["a" /* deg2rad */])(30)
};
/**
 * Restricts a new value for a center's coordinate according to given wrap mode.
 *
 * @param wrapMode The wrap mode.
 * @param newCoordinate The new value.
 * @param oldCoordinate Current value of the coordinate.
 * @param bboxMin Minimum corresponding coordinate of bounding box of the
 *      visible quadrilateral.
 * @param bboxMax Maximum corresponding coordinate of bounding box of the
 *      visible quadrilateral.
 * @returns Restricted value for the coordinate.
 */
function restrictCoordinate(wrapMode, newCoordinate) {
    switch (wrapMode) {
        case 0 /* NONE */:
            return newCoordinate;
        case 1 /* CLAMP_TO_EDGE */:
            return Object(__WEBPACK_IMPORTED_MODULE_0__math_scalar__["a" /* clamp */])(newCoordinate, -1, 1);
        case 2 /* REPEAT */:
            return Object(__WEBPACK_IMPORTED_MODULE_0__math_scalar__["b" /* cycleRestrict */])(newCoordinate, -1, 1);
    }
}
/**
 * Camera represents user's point of view in the world space, as a real camera it has restricted field of view,
 * it can move and rotate (with or without animation).
 */
class Camera {
    /**
     * Creates a new camera.
     *
     * @param options Options.
     */
    constructor(options) {
        this.options = Object(__WEBPACK_IMPORTED_MODULE_2__util_options__["a" /* default */])(DEFAULT_OPTIONS, options);
        this.center = new Camera._Center(this);
        this.onUpdate = new __WEBPACK_IMPORTED_MODULE_6__util_event_emitter__["b" /* VoidEventEmitter */]();
        const screenSize = new Camera._ScreenSize(this);
        this.screenSize = screenSize;
        this._distanceToCenter = 1;
        this._zoom = this.options.minZoom;
        this._tilt = this._azimuth = 0;
        this._dirtyBits = -1 /* ALL */;
        this._viewProjMatrix = __WEBPACK_IMPORTED_MODULE_3__math_matrix4__["c" /* copy */](__WEBPACK_IMPORTED_MODULE_3__math_matrix4__["a" /* IDENTITY */]);
        this._visibleQuadrilateral = [
            __WEBPACK_IMPORTED_MODULE_5__math_vector3__["e" /* create */](0, 0, 0),
            __WEBPACK_IMPORTED_MODULE_5__math_vector3__["e" /* create */](0, 0, 0),
            __WEBPACK_IMPORTED_MODULE_5__math_vector3__["e" /* create */](0, 0, 0),
            __WEBPACK_IMPORTED_MODULE_5__math_vector3__["e" /* create */](0, 0, 0)
        ];
        this._visibleQuadrilateralBBox =
            __WEBPACK_IMPORTED_MODULE_4__math_vector2__["c" /* computeBBoxForPoints */](this._visibleQuadrilateral);
        this._pixelSize = __WEBPACK_IMPORTED_MODULE_4__math_vector2__["f" /* create */](0, 0);
    }
    get aspectRatio() {
        const { width, height } = this.screenSize;
        if (height !== 0) {
            return width / height;
        }
        else {
            // when height == 0 we cannot compute viewProj matrix or visible region, 1 allows to handle this case with
            // no exceptions thrown, but technically it is not correct and should be reconsidered if any issue is found
            return 1;
        }
    }
    get zoom() {
        return this._zoom;
    }
    get worldToPxFactor() {
        return this._worldToPxFactor;
    }
    /**
     * Sets new zoom to the camera with respect to provided limits in the options.
     */
    set zoom(newZoom) {
        newZoom = Object(__WEBPACK_IMPORTED_MODULE_0__math_scalar__["a" /* clamp */])(newZoom, this.options.minZoom, this.options.maxZoom);
        if (newZoom !== this._zoom) {
            this._zoom = newZoom;
            this._computeDistanceToCenter();
            // Constraints on tilt may have changed, we need to recompute it.
            this._tilt = this._constrainTilt(this._tilt);
            this._worldToPxFactor = 2.0 / (ZOOM_0_WORLD_CSS_PIXEL_SIZE * Math.pow(2, newZoom));
            this._setDirtyBits(1 /* VIEW_PROJ_MATRIX */ | 2 /* VISIBLE_QUADRILATERAL */);
        }
    }
    get tilt() {
        return this._tilt;
    }
    set tilt(newTilt) {
        newTilt = this._constrainTilt(newTilt);
        if (this._tilt !== newTilt) {
            this._tilt = newTilt;
            this._setDirtyBits(1 /* VIEW_PROJ_MATRIX */ | 2 /* VISIBLE_QUADRILATERAL */);
        }
    }
    get azimuth() {
        return this._azimuth;
    }
    set azimuth(newAzimuth) {
        newAzimuth = Object(__WEBPACK_IMPORTED_MODULE_0__math_scalar__["b" /* cycleRestrict */])(newAzimuth, 0, 2 * Math.PI);
        if (this._azimuth !== newAzimuth) {
            this._azimuth = newAzimuth;
            this._setDirtyBits(1 /* VIEW_PROJ_MATRIX */ | 2 /* VISIBLE_QUADRILATERAL */);
        }
    }
    /**
     * Size of a pixel in NDC.
     */
    get pixelSize() {
        return this._pixelSize;
    }
    /**
     * Invalidate all internally cached values (e.g. view matrix).
     */
    setDirty() {
        this._setDirtyBits(-1 /* ALL */);
    }
    /**
     * Recomputes (if needed) the view projection matrix.
     *
     * @returns The view-projection matrix.
     */
    getViewProjMatrix() {
        const viewProjMatrix = this._viewProjMatrix;
        if (this._dirtyBits & 1 /* VIEW_PROJ_MATRIX */) {
            __WEBPACK_IMPORTED_MODULE_3__math_matrix4__["c" /* copy */](__WEBPACK_IMPORTED_MODULE_3__math_matrix4__["a" /* IDENTITY */], viewProjMatrix);
            __WEBPACK_IMPORTED_MODULE_3__math_matrix4__["d" /* lookAt */](viewProjMatrix, this._computeCenterToCameraVector(), __WEBPACK_IMPORTED_MODULE_5__math_vector3__["a" /* ORIGIN */], __WEBPACK_IMPORTED_MODULE_5__math_vector3__["m" /* rotateZ */](__WEBPACK_IMPORTED_MODULE_5__math_vector3__["b" /* POSITIVE_Y */], this._azimuth), viewProjMatrix);
            const { fov } = this.options;
            const tanFactors = Math.tan(this._tilt) * Math.tan(0.5 * fov);
            __WEBPACK_IMPORTED_MODULE_3__math_matrix4__["e" /* perspective */](viewProjMatrix, fov, this.aspectRatio, Math.min(this._distanceToCenter * 0.01, this._distanceToCenter / (1 + tanFactors)), this._distanceToCenter / (1 - tanFactors), viewProjMatrix);
            this._dirtyBits &= ~1 /* VIEW_PROJ_MATRIX */;
        }
        return viewProjMatrix;
    }
    /**
     * Recomputes (if needed) and returns quadrilateral cut on the world plane
     * by frustum of the camera.
     *
     * @return The quadrilateral enclosing visible part of the world plane.
     */
    getVisibleRegion() {
        this._computeVisibleQuadrilateral();
        return this._visibleQuadrilateral;
    }
    /**
     * Recomputes (if needed) and returns bounding box of the visible region.
     *
     * @return Bounding box of the visible quadrilateral.
     */
    getVisibleRegionBBox() {
        this._computeVisibleQuadrilateral();
        return this._visibleQuadrilateralBBox;
    }
    _constrainTilt(tilt) {
        return Object(__WEBPACK_IMPORTED_MODULE_0__math_scalar__["a" /* clamp */])(tilt, 0, MAX_TILT * Object(__WEBPACK_IMPORTED_MODULE_0__math_scalar__["c" /* smoothStep */])(NO_TILT_MAX_ZOOM, FULL_TILT_MIN_ZOOM, this._zoom));
    }
    _setDirtyBits(bits) {
        if (bits ^ (bits & this._dirtyBits)) {
            this._dirtyBits |= bits;
            this.onUpdate.fire();
        }
    }
    _computeDistanceToCenter() {
        this._distanceToCenter =
            this.screenSize.height * Math.pow(2, -this._zoom) /
                (Math.tan(0.5 * this.options.fov) * ZOOM_0_WORLD_CSS_PIXEL_SIZE);
    }
    _computeCenterToCameraVector(dst = __WEBPACK_IMPORTED_MODULE_5__math_vector3__["e" /* create */](0, 0, 0)) {
        __WEBPACK_IMPORTED_MODULE_5__math_vector3__["i" /* muln */](__WEBPACK_IMPORTED_MODULE_5__math_vector3__["c" /* POSITIVE_Z */], this._distanceToCenter, dst);
        __WEBPACK_IMPORTED_MODULE_5__math_vector3__["l" /* rotateX */](dst, this._tilt, dst);
        __WEBPACK_IMPORTED_MODULE_5__math_vector3__["m" /* rotateZ */](dst, this._azimuth, dst);
        return dst;
    }
    _computeVisibleQuadrilateral() {
        if (this._dirtyBits & 2 /* VISIBLE_QUADRILATERAL */) {
            const visibleQuadrilateral = this._visibleQuadrilateral;
            const halfFovTan = Math.tan(0.5 * this.options.fov);
            const origin = this._computeCenterToCameraVector();
            __WEBPACK_IMPORTED_MODULE_4__math_vector2__["b" /* add */](origin, this.center, origin);
            const scale = __WEBPACK_IMPORTED_MODULE_5__math_vector3__["e" /* create */](halfFovTan * this.aspectRatio, halfFovTan, 1);
            const direction = __WEBPACK_IMPORTED_MODULE_5__math_vector3__["e" /* create */](0, 0, 0);
            const ray = { origin, direction };
            for (let i = 0; i < 4; ++i) {
                __WEBPACK_IMPORTED_MODULE_5__math_vector3__["j" /* mulv */](FRUSTUM_DIRECTIONS[i], scale, direction);
                __WEBPACK_IMPORTED_MODULE_5__math_vector3__["l" /* rotateX */](direction, this._tilt, direction);
                __WEBPACK_IMPORTED_MODULE_5__math_vector3__["m" /* rotateZ */](direction, this._azimuth, direction);
                if (!__WEBPACK_IMPORTED_MODULE_5__math_vector3__["h" /* getPlaneRayIntersection */](__WEBPACK_IMPORTED_MODULE_5__math_vector3__["d" /* XY */], ray, visibleQuadrilateral[i])) {
                    throw new Error('Visible quadrilateral is unbounded, engine can\'t handle that case (yet)');
                }
            }
            __WEBPACK_IMPORTED_MODULE_4__math_vector2__["c" /* computeBBoxForPoints */](visibleQuadrilateral, this._visibleQuadrilateralBBox);
            this._dirtyBits &= ~2 /* VISIBLE_QUADRILATERAL */;
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Camera;

/**
 * Implementation of a center vector of a camera. Takes into account wrapping
 * modes and updates camera's dirty flags.
 */
Camera._Center = class {
    /**
     * Creates new center vector for a camera.
     *
     * @param camera The camera.
     */
    constructor(camera) {
        this._camera = camera;
        this._x = this._y = 0;
    }
    /**
     * @returns Values of abscissa of the center vector.
     */
    get x() {
        return this._x;
    }
    /**
     * Properly clamps or wraps new abscissa value and sets it to the vector.
     *
     * @param newX The new
     */
    set x(newX) {
        const camera = this._camera;
        newX = restrictCoordinate(camera.options.wrapModeX, newX);
        if (this._x !== newX) {
            this._x = newX;
            camera._setDirtyBits(2 /* VISIBLE_QUADRILATERAL */);
        }
    }
    /**
     * @returns Values of ordinate of the center vector.
     */
    get y() {
        return this._y;
    }
    /**
     * Properly clamps or wraps new ordinate value and sets it to the vector.
     */
    set y(newY) {
        const camera = this._camera;
        newY = restrictCoordinate(camera.options.wrapModeY, newY);
        if (this._y !== newY) {
            this._y = newY;
            camera._setDirtyBits(2 /* VISIBLE_QUADRILATERAL */);
        }
    }
};
Camera._ScreenSize = class {
    constructor(camera) {
        this._camera = camera;
        this._width = this._height = 0;
    }
    get width() {
        return this._width;
    }
    set width(newWidth) {
        if (this._width !== newWidth) {
            this._width = newWidth;
            const camera = this._camera;
            camera._setDirtyBits(1 /* VIEW_PROJ_MATRIX */ | 2 /* VISIBLE_QUADRILATERAL */);
            camera._pixelSize.x = 2.0 / this._width;
        }
    }
    get height() {
        return this._height;
    }
    set height(newHeight) {
        if (this._height !== newHeight) {
            this._height = newHeight;
            const camera = this._camera;
            camera._computeDistanceToCenter();
            camera._setDirtyBits(1 /* VIEW_PROJ_MATRIX */ | 2 /* VISIBLE_QUADRILATERAL */);
            camera._pixelSize.y = 2.0 / this._height;
        }
    }
};


/***/ }),
/* 64 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = deg2rad;
/* unused harmony export rad2deg */
const DEG_TO_RAD = Math.PI / 180;
function deg2rad(x) {
    return x * DEG_TO_RAD;
}
function rad2deg(x) {
    return x / DEG_TO_RAD;
}


/***/ }),
/* 65 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = getFullOptions;
/**
 * Resolves options.
 *
 * @param defaultOptions Object with default values.
 * @param options Object with custom values for options. Later objects "override"
 *      former ones.
 * @returns New object containing resolved options.
 */
function getFullOptions(defaultOptions, ...options) {
    return Object.assign({}, defaultOptions, ...options);
}


/***/ }),
/* 66 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export create */
/* unused harmony export zero */
/* harmony export (immutable) */ __webpack_exports__["a"] = fromRows;
/* unused harmony export columns */
/* unused harmony export fromColumns */
/* unused harmony export determinant */
/* harmony export (immutable) */ __webpack_exports__["b"] = solve;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__vector3__ = __webpack_require__(12);

const MATRIX_SIZE = 9;
/**
 * Creates and returns a new **uninitialized** matrix.
 */
function create() {
    return new Array(MATRIX_SIZE);
}
/**
 * Zeroes a matrix.
 *
 * @param dst The matrix.
 * @returns `dst`.
 */
function zero(dst = create()) {
    for (let i = 0; i < MATRIX_SIZE; ++i) {
        dst[i] = 0;
    }
    return dst;
}
/**
 * Copies three vectors to a matrix as rows.
 *
 * @param r0 The first row.
 * @param r1 The second row.
 * @param r2 The third row.
 * @param dst The matrix the rows will be written to.
 * @returns `dst`.
 */
function fromRows(r0, r1, r2, dst = create()) {
    dst[0] = r0.x;
    dst[1] = r1.x;
    dst[2] = r2.x;
    dst[3] = r0.y;
    dst[4] = r1.y;
    dst[5] = r2.y;
    dst[6] = r0.z;
    dst[7] = r1.z;
    dst[8] = r2.z;
    return dst;
}
/**
 * Returns array of columns of a matrix.
 *
 * @param m The matrix.
 * @param dst The array columns of the matrix will be written to.
 * @returns `dst`.
 */
function columns(m, dst = [
    __WEBPACK_IMPORTED_MODULE_0__vector3__["e" /* create */](0, 0, 0),
    __WEBPACK_IMPORTED_MODULE_0__vector3__["e" /* create */](0, 0, 0),
    __WEBPACK_IMPORTED_MODULE_0__vector3__["e" /* create */](0, 0, 0)
]) {
    for (let i = 0, j = 0; i < 3; ++i, j += 3) {
        dst[i].x = m[j];
        dst[i].y = m[j + 1];
        dst[i].z = m[j + 2];
    }
    return dst;
}
/**
 * Copies three vectors to a matrix as columns.
 *
 * @param c0 The first column.
 * @param c1 The second column.
 * @param c2 The third column.
 * @param dst The matrix the columns will be written to.
 * @returns `dst`.
 */
function fromColumns(c0, c1, c2, dst = create()) {
    dst[0] = c0.x;
    dst[1] = c0.y;
    dst[2] = c0.z;
    dst[3] = c1.x;
    dst[4] = c1.y;
    dst[5] = c1.z;
    dst[6] = c2.x;
    dst[7] = c2.y;
    dst[8] = c2.z;
    return dst;
}
/**
 * Computes determinant of a matrix.
 *
 * @param m The matrix.
 * @returns The determinant.
 */
function determinant(m) {
    return m[0] * (m[4] * m[8] - m[7] * m[5]) +
        m[3] * (m[1] * m[8] - m[7] * m[2]) +
        m[6] * (m[1] * m[5] - m[4] * m[2]);
}
const staticMatrixColumns = [
    // Not using vector3.create here due to circular dependency.
    { x: 0, y: 0, z: 0 },
    { x: 0, y: 0, z: 0 },
    { x: 0, y: 0, z: 0 }
];
const staticMatrix = create();
/**
 * Solves a system of linear equations represented with a matrix and a vector,
 * i.e.:
 *
 * ```
 * m * (x, y ,z)^T = v
 * ```
 *
 * Uses Cramer's rule.
 * @see https://en.wikipedia.org/wiki/Cramer's_rule
 *
 * @param m The matrix of the system.
 * @param v The vector of the system.
 * @param dst The vector solution of the system will be written to.
 * @return `dst`.
 */
function solve(m, v, dst = __WEBPACK_IMPORTED_MODULE_0__vector3__["e" /* create */](0, 0, 0)) {
    const revDet = 1 / determinant(m);
    const [c0, c1, c2] = columns(m, staticMatrixColumns);
    dst.x = revDet * determinant(fromColumns(v, c1, c2, staticMatrix));
    dst.y = revDet * determinant(fromColumns(c0, v, c2, staticMatrix));
    dst.z = revDet * determinant(fromColumns(c0, c1, v, staticMatrix));
    return dst;
}


/***/ }),
/* 67 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__tile_based_adapter_adapter__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__primitive_icon_icon_buffer_writer__ = __webpack_require__(74);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__render_memory_sub_chunk__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__billboard_identified_image_atlas_manager__ = __webpack_require__(75);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__font_df_font__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__api_image_provider__ = __webpack_require__(77);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__primitive_model_model_buffer_writer__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__primitive_polyline_textured_polyline_buffer_writer__ = __webpack_require__(80);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__billboard_image_manager__ = __webpack_require__(82);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__primitive_polygon_textured_polygon_buffer_rewiter__ = __webpack_require__(83);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__primitive_polygon_polygon_attribute_mapping__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__primitive_polygon_textured_polygon_attribute_mapping__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__primitive_billboard_rectangle_attribute_mapping__ = __webpack_require__(85);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__primitive_label_point_label_attribute_mapping__ = __webpack_require__(86);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__primitive_label_curved_label_attribute_mapping__ = __webpack_require__(87);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__primitive_polyline_polyline_attribute_mapping__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__worker_tile_provider_worker_client__ = __webpack_require__(88);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__worker_tile_provider_worker_messages__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__primitive_polygon_transparent_polygon_attribute_mapping__ = __webpack_require__(90);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__tile_based_adapter_tile_id__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__util_idle_task_queue__ = __webpack_require__(91);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__util_stat__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__util_unique_id__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__primitive_polygon_renderable_polygon__ = __webpack_require__(93);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__primitive_polygon_renderable_textured_polygon__ = __webpack_require__(94);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__primitive_polyline_renderable_polyline__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__primitive_polyline_renderable_textured_polyline__ = __webpack_require__(95);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__primitive_model_renderable_model__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28__tile_data__ = __webpack_require__(96);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29__primitive_manager_renderable_primitive_manager__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_30__render_primitives_primitive_set_storage__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_31__primitive_manager_polygon_manager__ = __webpack_require__(97);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_32__render_primitives_disappearing_primitive_set_storage__ = __webpack_require__(40);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_33__render_primitives_delayed_disappearing_primitive_set_storage__ = __webpack_require__(98);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_34__primitive_manager_zoom_filterable_primitive_manager__ = __webpack_require__(99);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_35__primitive_manager_external_mesh_manager__ = __webpack_require__(100);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_36__primitive_billboard_rectangle_renderable_billboard_rectangle__ = __webpack_require__(101);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_37__primitive_zoom_restricted_label__ = __webpack_require__(102);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_38__primitive_zoom_restricted_icon__ = __webpack_require__(104);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_39__util_task_queue__ = __webpack_require__(108);








































const WORLD_SIZE = 2.0;
const NORMAL_TILE_SIDE_SIZE_PX = 256; // tiles of normal size are optimized for displaying in a 256x256 css px square
function getTileSideSizePx(tileSize) {
    switch (tileSize) {
        case 1 /* X4 */:
            return NORMAL_TILE_SIDE_SIZE_PX * 2;
        case 2 /* X16 */:
            return NORMAL_TILE_SIDE_SIZE_PX * 4;
        default:
            return NORMAL_TILE_SIDE_SIZE_PX;
    }
}
const MAX_PERF_LOG_ITEMS_COUNT = 1024;
const QUEUE_TASK_PRIORITIES = {
    firstTilePortion: 20,
    secondTilePortion: 10
};
const DEFAULT_IDLE_TASK_PRIORITY = 0;
// The values are chosen empirically: https://st.yandex-team.ru/VECTOR-300#5be5b638523211001b9bd941
const MINZOOM_DELTAS = {
    pointLabels: 1,
    curvedLabels: 1,
    icons: 0.75
};
class VectorApiAdapter extends __WEBPACK_IMPORTED_MODULE_0__tile_based_adapter_adapter__["a" /* default */] {
    constructor(engine, camera, tileProviderWorkerUrl, layerName, { imageUrlTemplate, tileUrlTemplate, meshUrlTemplate, glyphRangeUrlTemplate }, tileSize = 0 /* X1 */, preloadedTilesBeltSize = 0) {
        super(engine, camera, tileSize, preloadedTilesBeltSize, layerName);
        this._tileSideSizePx = getTileSideSizePx(tileSize);
        this._perfLogItems = [];
        this._destroyables = [];
        this._tileProvider = new __WEBPACK_IMPORTED_MODULE_16__worker_tile_provider_worker_client__["a" /* TileProviderWorkerClient */](tileProviderWorkerUrl);
        this._tileProvider.sendMessage({
            type: __WEBPACK_IMPORTED_MODULE_17__worker_tile_provider_worker_messages__["a" /* TileProviderMessageType */].INIT,
            tileUrlTemplate,
            meshUrlTemplate,
            glyphRangeUrlTemplate
        }, 1 /* IMMEDIATE */);
        this._memoryManager = engine.memoryManager;
        this._glyphAtlas = engine.glyphAtlas;
        this._fontRegistry = engine.fontRegistry;
        this._imageManagerNearest = new __WEBPACK_IMPORTED_MODULE_8__billboard_image_manager__["a" /* ImageManager */](new __WEBPACK_IMPORTED_MODULE_3__billboard_identified_image_atlas_manager__["a" /* default */](engine.createImageAtlas({
            filter: 9728 /* NEAREST */,
            premultipliedAlpha: false
        })), new __WEBPACK_IMPORTED_MODULE_5__api_image_provider__["a" /* ApiImageProvider */](imageUrlTemplate));
        this._imageManagerLinear = new __WEBPACK_IMPORTED_MODULE_8__billboard_image_manager__["a" /* ImageManager */](new __WEBPACK_IMPORTED_MODULE_3__billboard_identified_image_atlas_manager__["a" /* default */](engine.createImageAtlas({
            filter: 9729 /* LINEAR */,
            premultipliedAlpha: true
        })), new __WEBPACK_IMPORTED_MODULE_5__api_image_provider__["a" /* ApiImageProvider */](imageUrlTemplate));
        const fadeEffect = engine.visibilityManager.fadeEffectDuration;
        const opaquePolygonsProvider = this.opaquePolygonsProvider = new __WEBPACK_IMPORTED_MODULE_30__render_primitives_primitive_set_storage__["a" /* default */]();
        const transparentPolygonsProvider = this.transparentPolygonsProvider = new __WEBPACK_IMPORTED_MODULE_30__render_primitives_primitive_set_storage__["a" /* default */]();
        const texturedPolygonsProvider = this.texturedPolygonsProvider = new __WEBPACK_IMPORTED_MODULE_30__render_primitives_primitive_set_storage__["a" /* default */]();
        const polylinesProvider = this.polylinesProvider = new __WEBPACK_IMPORTED_MODULE_30__render_primitives_primitive_set_storage__["a" /* default */]();
        const texturedPolylinesProvider = this.texturedPolylinesProvider = new __WEBPACK_IMPORTED_MODULE_30__render_primitives_primitive_set_storage__["a" /* default */]();
        const iconsProvider = this.iconsProvider = new __WEBPACK_IMPORTED_MODULE_32__render_primitives_disappearing_primitive_set_storage__["a" /* default */]();
        const pointLabelsProvider = this.pointLabelsProvider = new __WEBPACK_IMPORTED_MODULE_33__render_primitives_delayed_disappearing_primitive_set_storage__["a" /* default */](fadeEffect);
        const curvedLabelsProvider = this.curvedLabelsProvider = new __WEBPACK_IMPORTED_MODULE_33__render_primitives_delayed_disappearing_primitive_set_storage__["a" /* default */](fadeEffect);
        const modelsProvider = this.modelsProvider = new __WEBPACK_IMPORTED_MODULE_30__render_primitives_primitive_set_storage__["a" /* default */]();
        this._destroyables.push(pointLabelsProvider, curvedLabelsProvider);
        this._tileDataManagers = [
            new TileDataManager(new __WEBPACK_IMPORTED_MODULE_31__primitive_manager_polygon_manager__["a" /* default */](opaquePolygonsProvider, transparentPolygonsProvider), __WEBPACK_IMPORTED_MODULE_28__tile_data__["f" /* POLYGON_EXTRACTOR */]),
            new TileDataManager(new __WEBPACK_IMPORTED_MODULE_29__primitive_manager_renderable_primitive_manager__["a" /* default */](texturedPolygonsProvider), __WEBPACK_IMPORTED_MODULE_28__tile_data__["h" /* TEXTURED_POLYGON_EXTRACTOR */]),
            new TileDataManager(new __WEBPACK_IMPORTED_MODULE_29__primitive_manager_renderable_primitive_manager__["a" /* default */](polylinesProvider), __WEBPACK_IMPORTED_MODULE_28__tile_data__["g" /* POLYLINE_EXTRACTOR */]),
            new TileDataManager(new __WEBPACK_IMPORTED_MODULE_29__primitive_manager_renderable_primitive_manager__["a" /* default */](texturedPolylinesProvider), __WEBPACK_IMPORTED_MODULE_28__tile_data__["i" /* TEXTURED_POLYLINE_EXTRACTOR */]),
            new TileDataManager(new __WEBPACK_IMPORTED_MODULE_34__primitive_manager_zoom_filterable_primitive_manager__["a" /* default */](iconsProvider, camera), __WEBPACK_IMPORTED_MODULE_28__tile_data__["d" /* POINT_EXTRACTOR */]),
            new TileDataManager(new __WEBPACK_IMPORTED_MODULE_34__primitive_manager_zoom_filterable_primitive_manager__["a" /* default */](pointLabelsProvider, camera), __WEBPACK_IMPORTED_MODULE_28__tile_data__["e" /* POINT_LABEL_EXTRACTOR */]),
            new TileDataManager(new __WEBPACK_IMPORTED_MODULE_34__primitive_manager_zoom_filterable_primitive_manager__["a" /* default */](curvedLabelsProvider, camera), __WEBPACK_IMPORTED_MODULE_28__tile_data__["a" /* CURVED_LABEL_EXTRACTOR */]),
            new TileDataManager(new __WEBPACK_IMPORTED_MODULE_29__primitive_manager_renderable_primitive_manager__["a" /* default */](modelsProvider), __WEBPACK_IMPORTED_MODULE_28__tile_data__["c" /* MODEL_EXTRACTOR */]),
            new TileDataManager(new __WEBPACK_IMPORTED_MODULE_35__primitive_manager_external_mesh_manager__["a" /* default */](modelsProvider, this._tileProvider, this.engine.memoryManager), __WEBPACK_IMPORTED_MODULE_28__tile_data__["b" /* EXTERNAL_MESH_EXTRACTOR */])
        ];
        this._requestedTilesState = new Map();
        this._taskQueue = new __WEBPACK_IMPORTED_MODULE_39__util_task_queue__["a" /* default */]();
        this._minorTaskQueue = new __WEBPACK_IMPORTED_MODULE_20__util_idle_task_queue__["a" /* default */]();
        this._tileProvider.on(__WEBPACK_IMPORTED_MODULE_17__worker_tile_provider_worker_messages__["a" /* TileProviderMessageType */].TILE_RESPONSE, (response) => this._onTileProviderResponse(response));
        this._tileProvider.on(__WEBPACK_IMPORTED_MODULE_17__worker_tile_provider_worker_messages__["a" /* TileProviderMessageType */].TILE_ERROR, (response) => this._onTileError(response.tile));
        this._onCameraUpdate();
    }
    destroy() {
        this._tileProvider.destroy();
        for (const destroyable of this._destroyables) {
            destroyable.destroy();
        }
        super.destroy();
    }
    setTileUrlTemplate(tileUrlTemplate) {
        this._tileProvider.sendMessage({
            type: __WEBPACK_IMPORTED_MODULE_17__worker_tile_provider_worker_messages__["a" /* TileProviderMessageType */].TILE_URL_UPDATE,
            tileUrlTemplate
        }, 1 /* IMMEDIATE */);
        this._refreshCurrentTiles();
    }
    _createTileRequest(tileItem, priority) {
        const targetZoom = this._getTargetZoom();
        return Object.assign({}, tileItem, { priority, isVisible: this._isTileVisible(tileItem), zoomMin: targetZoom, zoomMax: targetZoom });
    }
    _requestTiles(requests) {
        const requestId = Object(__WEBPACK_IMPORTED_MODULE_22__util_unique_id__["a" /* uniqueId */])();
        this._onTilesRequest(requests, requestId);
        for (const request of requests) {
            const requestedTileData = {
                isGeometryReady: false,
                areLabelsReady: false
            };
            this._requestedTilesState.set(Object(__WEBPACK_IMPORTED_MODULE_19__tile_based_adapter_tile_id__["a" /* getTileId */])(request), requestedTileData);
        }
        const request = {
            type: __WEBPACK_IMPORTED_MODULE_17__worker_tile_provider_worker_messages__["a" /* TileProviderMessageType */].TILE_REQUEST_BATCH,
            responseType: __WEBPACK_IMPORTED_MODULE_17__worker_tile_provider_worker_messages__["a" /* TileProviderMessageType */].TILE_RESPONSE,
            errorType: __WEBPACK_IMPORTED_MODULE_17__worker_tile_provider_worker_messages__["a" /* TileProviderMessageType */].TILE_ERROR,
            requestId,
            requests
        };
        this._tileProvider.sendMessage(request, 1 /* IMMEDIATE */);
    }
    _cancelTileRequests(requests) {
        for (const request of requests) {
            this._requestedTilesState.delete(Object(__WEBPACK_IMPORTED_MODULE_19__tile_based_adapter_tile_id__["a" /* getTileId */])(request.tile));
        }
        this._onCancelTileRequests(requests);
        this._tileProvider.sendMessage({
            type: __WEBPACK_IMPORTED_MODULE_17__worker_tile_provider_worker_messages__["a" /* TileProviderMessageType */].TILE_REQUEST_CANCEL_BATCH,
            requests
        });
    }
    _onTileDataUpdate(dataToShow, dataToHide) {
        for (const primitiveManager of this._tileDataManagers) {
            primitiveManager.updatePrimitives(dataToShow, dataToHide);
        }
    }
    _onTileDestroy(_tileItem, data) {
        // release primitives that we've created in allocators
        for (const portion of data) {
            (portion.polygons || []).forEach(releasePrimitive);
            (portion.texturedPolygons || []).forEach(releasePrimitive);
            (portion.polylines || []).forEach(releasePrimitive);
            (portion.texturedPolylines || []).forEach(releasePrimitive);
            (portion.points || []).forEach(releasePrimitive);
            (portion.pointLabels || []).forEach(releasePrimitive);
            (portion.curvedLabels || []).forEach(releasePrimitive);
            (portion.models || []).forEach(releasePrimitive);
        }
    }
    _sendStatisticsBeforeDestroy() {
        super._sendStatisticsBeforeDestroy();
        if (this._perfLogItems.length === 0) {
            return;
        }
        const items = this._perfLogItems;
        items.sort((a, b) => a.parseTime - b.parseTime);
        const min = items[0];
        const max = items[items.length - 1];
        const median = items[Math.floor(items.length / 2)];
        Object(__WEBPACK_IMPORTED_MODULE_21__util_stat__["b" /* countTileParseTime */])(this._layerName, min.tile, min.parseTime, max.tile, max.parseTime, median.tile, median.parseTime);
    }
    _onTileProviderResponse(response) {
        this._pushPerfLogItem(response.tile, response.parseTime);
        const tile = response.tile;
        const taskPriority = QUEUE_TASK_PRIORITIES.firstTilePortion +
            this._getTilePriority(tile, this._isTileVisible(tile));
        this._taskQueue.enqueue({
            priority: taskPriority,
            execute: () => {
                // atlas must be updated notwithstanding the tile is active or not
                // as these new glyphs will be used in next tiles
                const atlas = response.glyphAtlasToUpdate;
                if (atlas) {
                    this._glyphAtlas.updateContent(atlas.width, atlas.height, atlas.data, new Map(atlas.glyphLocations));
                }
                const registry = response.fontRegistryToUpdate;
                if (registry) {
                    for (const fontData of registry) {
                        let font;
                        if (this._fontRegistry.contains(fontData.id)) {
                            font = this._fontRegistry.get(fontData.id);
                        }
                        else {
                            font = new __WEBPACK_IMPORTED_MODULE_4__font_df_font__["a" /* default */](fontData.id, fontData.xheight, fontData.margin);
                            this._fontRegistry.add(font);
                        }
                        font.addAllGlyphs(fontData.glyphs);
                    }
                }
                const requestId = response.requestId;
                if (!this._isTileStillActive(tile, requestId)) {
                    return;
                }
                // If tile is being refreshed don't visualize any portions until all of them are loaded to avoid a blink
                const isRefreshing = this._isTileRefreshing(tile);
                const iconsSplitted = splitImageDependantPrimitives(response.points, this._imageManagerNearest, (point) => point.styles[0].imageId);
                const texturedPolylinesSplitted = splitImageDependantPrimitives(response.texturedPolylines, this._imageManagerLinear, (polyline) => polyline.styles[0].inline.pattern.imageId);
                const texturedPolygonsImages = getImagesIfAllAllocated(response.texturedPolygons, this._imageManagerNearest, (polygon) => polygon.styles[0].pattern.imageId);
                this._taskQueue.enqueue({
                    priority: QUEUE_TASK_PRIORITIES.secondTilePortion +
                        this._getTilePriority(tile, this._isTileVisible(tile)),
                    execute: () => {
                        if (this._isTileStillActive(tile, response.requestId)) {
                            this._putTileData(tile, {
                                polygons: this._allocatePolygons(response),
                                models: this._allocateMeshes(response),
                                externalMeshes: response.externalMeshes,
                                polylines: this._allocatePolylines(response),
                                pointLabels: this._allocatePointLabels(response),
                                curvedLabels: this._allocateCurvedLabels(response),
                                points: this._allocateIcons(tile, iconsSplitted.primitivesWithAllocatedImages, iconsSplitted.allocatedImages),
                                texturedPolylines: this._allocateTexturedPolylines(tile, texturedPolylinesSplitted.primitivesWithAllocatedImages, texturedPolylinesSplitted.allocatedImages),
                                texturedPolygons: !texturedPolygonsImages.allocatedImages ?
                                    [] :
                                    this._allocateTexturedPolygons(tile, response.texturedPolygons, texturedPolygonsImages.allocatedImages, response.texturedPolygonPages)
                            }, requestId, !isRefreshing);
                            iconsSplitted.allocatedImages.forEach(releasePrimitive);
                            texturedPolylinesSplitted.allocatedImages.forEach(releasePrimitive);
                            if (texturedPolygonsImages.allocatedImages) {
                                texturedPolygonsImages.allocatedImages.forEach(releasePrimitive);
                            }
                            const requestedTileData = this._requestedTilesState.get(Object(__WEBPACK_IMPORTED_MODULE_19__tile_based_adapter_tile_id__["a" /* getTileId */])(tile));
                            if (requestedTileData !== undefined) {
                                // TODO: the data is synced on these two properties
                                //       and this code doesn't make much sense for now,
                                //       but it is left "as is" since it is not clear
                                //       how it will be changed in nearest future
                                requestedTileData.isGeometryReady = true;
                                requestedTileData.areLabelsReady = true;
                                this._onTileDataReady(tile, response.url);
                            }
                        }
                    }
                });
                const putDataPromises = [];
                putDataPromises.push(iconsSplitted.missingImages.then((images) => {
                    this._onMissingIconImagesReady(response, iconsSplitted, images);
                }));
                putDataPromises.push(texturedPolylinesSplitted.missingImages.then((images) => {
                    this._onMissingPolylineImagesReady(response, texturedPolylinesSplitted, images);
                }));
                if (texturedPolygonsImages.missingImages) {
                    putDataPromises.push(texturedPolygonsImages.missingImages.then((images) => this._onMissingPolygonImagesReady(response, images)));
                }
                if (isRefreshing) {
                    // When all the portions are loaded, put empty data to visuazlize it
                    Promise.all(putDataPromises).then(() => this._putTileData(tile, {}, requestId, true));
                }
            }
        });
    }
    _onMissingIconImagesReady(response, iconsSplitted, images) {
        const tile = response.tile;
        this._minorTaskQueue.enqueue({
            priority: DEFAULT_IDLE_TASK_PRIORITY +
                this._getTilePriority(tile, this._isTileVisible(tile)),
            execute: () => {
                if (this._isTileStillActive(tile, response.requestId)) {
                    const points = this._allocateIcons(tile, iconsSplitted.primitivesWithMissingImages, images);
                    this._putTileData(tile, { points }, response.requestId, false);
                }
                images.forEach(releasePrimitive);
            }
        });
    }
    _onMissingPolylineImagesReady(response, texturedPolylinesSplitted, images) {
        const tile = response.tile;
        this._minorTaskQueue.enqueue({
            priority: DEFAULT_IDLE_TASK_PRIORITY + this._getTilePriority(tile, this._isTileVisible(tile)),
            execute: () => {
                if (this._isTileStillActive(tile, response.requestId)) {
                    const texturedPolylines = this._allocateTexturedPolylines(tile, texturedPolylinesSplitted.primitivesWithMissingImages, images);
                    this._putTileData(tile, { texturedPolylines }, response.requestId, false);
                }
                images.forEach(releasePrimitive);
            }
        });
    }
    _onMissingPolygonImagesReady(response, images) {
        const tile = response.tile;
        this._minorTaskQueue.enqueue({
            priority: DEFAULT_IDLE_TASK_PRIORITY +
                this._getTilePriority(tile, this._isTileVisible(tile)),
            execute: () => {
                if (this._isTileStillActive(tile, response.requestId)) {
                    const texturedPolygons = this._allocateTexturedPolygons(tile, response.texturedPolygons, images, response.texturedPolygonPages);
                    this._putTileData(tile, { texturedPolygons }, response.requestId, false);
                }
                images.forEach(releasePrimitive);
            }
        });
    }
    _onTileError(tile) {
        super._onTileError(tile);
        this._requestedTilesState.delete(Object(__WEBPACK_IMPORTED_MODULE_19__tile_based_adapter_tile_id__["a" /* getTileId */])(tile));
    }
    _isTileVisible(tile) {
        return this._currentTiles.has(Object(__WEBPACK_IMPORTED_MODULE_19__tile_based_adapter_tile_id__["a" /* getTileId */])(tile));
    }
    _allocatePolygons(response) {
        const polygonPrimitives = new Array(response.polygons.length + response.transparentPolygons.length);
        const memoryChunks = new MemoryChunks(response.polygonPages, this._memoryManager, __WEBPACK_IMPORTED_MODULE_10__primitive_polygon_polygon_attribute_mapping__["a" /* POLYGON_ATTRIBUTE_MAPPING */]);
        const transparentPolygonsMemoryChunks = new MemoryChunks(response.transparentPolygonPages, this._memoryManager, __WEBPACK_IMPORTED_MODULE_18__primitive_polygon_transparent_polygon_attribute_mapping__["a" /* TRANSPARENT_POLYGON_ATTRIBUTE_MAPPING */]);
        let index = 0;
        for (let i = 0; i < response.polygons.length; i++, index++) {
            const { bufferLocation } = response.polygons[i];
            polygonPrimitives[index] = new __WEBPACK_IMPORTED_MODULE_23__primitive_polygon_renderable_polygon__["a" /* default */](new __WEBPACK_IMPORTED_MODULE_2__render_memory_sub_chunk__["a" /* default */](memoryChunks[bufferLocation.bufferIndex], bufferLocation), true);
        }
        for (let i = 0; i < response.transparentPolygons.length; i++, index++) {
            const { bufferLocation } = response.transparentPolygons[i];
            polygonPrimitives[index] = new __WEBPACK_IMPORTED_MODULE_23__primitive_polygon_renderable_polygon__["a" /* default */](new __WEBPACK_IMPORTED_MODULE_2__render_memory_sub_chunk__["a" /* default */](transparentPolygonsMemoryChunks[bufferLocation.bufferIndex], bufferLocation), false);
        }
        memoryChunks.forEach((chunk) => chunk.release());
        transparentPolygonsMemoryChunks.forEach((chunk) => chunk.release());
        return polygonPrimitives;
    }
    _allocateTexturedPolygons(tile, polygonDescriptions, images, texturedPolygonPages) {
        const texturedPolygonRewriter = new __WEBPACK_IMPORTED_MODULE_9__primitive_polygon_textured_polygon_buffer_rewiter__["a" /* default */](texturedPolygonPages);
        const worldToPxFactor = WORLD_SIZE / (this._tileSideSizePx * Math.pow(2, tile.zoom));
        const locations = polygonDescriptions.map((parsedPolygon, index) => {
            const image = images[index];
            if (image) {
                const allocatedImage = image;
                const pattern = parsedPolygon.styles[0].pattern;
                const imageScale = pattern.width / allocatedImage.descriptor.width;
                texturedPolygonRewriter.rewriteUV(parsedPolygon.bufferLocation, allocatedImage.bbox, worldToPxFactor * imageScale);
                return parsedPolygon.bufferLocation;
            }
            else {
                return null;
            }
        });
        const memoryChunks = new MemoryChunks(texturedPolygonPages, this._memoryManager, __WEBPACK_IMPORTED_MODULE_11__primitive_polygon_textured_polygon_attribute_mapping__["a" /* TEXTURED_POLYGON_ATTRIBUTE_MAPPING */]);
        const texturedPolygonPrimitives = [];
        for (let i = 0; i < locations.length; i++) {
            const location = locations[i];
            const image = images[i];
            if (location && image) {
                const texturedPolygonPrimitive = new __WEBPACK_IMPORTED_MODULE_24__primitive_polygon_renderable_textured_polygon__["a" /* default */](new __WEBPACK_IMPORTED_MODULE_2__render_memory_sub_chunk__["a" /* default */](memoryChunks[location.bufferIndex], location), image);
                texturedPolygonPrimitives.push(texturedPolygonPrimitive);
            }
        }
        memoryChunks.forEach((chunk) => chunk.release());
        return texturedPolygonPrimitives;
    }
    _allocateMeshes(tileResponse) {
        const memoryChunks = tileResponse.meshPages.map((page) => this._memoryManager.allocate(page.vertexBuffer, page.indexBuffer, __WEBPACK_IMPORTED_MODULE_6__primitive_model_model_buffer_writer__["a" /* default */].ATTRIBUTE_MAPPING));
        const meshPrimitives = tileResponse.meshes.map((mesh) => new __WEBPACK_IMPORTED_MODULE_27__primitive_model_renderable_model__["a" /* default */](new __WEBPACK_IMPORTED_MODULE_2__render_memory_sub_chunk__["a" /* default */](memoryChunks[mesh.bufferLocation.bufferIndex], mesh.bufferLocation)));
        memoryChunks.forEach((chunk) => chunk.release());
        return meshPrimitives;
    }
    _allocatePolylines(response) {
        const polylinePrimitives = new Array(response.polylines.length);
        const memoryChunks = new MemoryChunks(response.polylinePages, this._memoryManager, __WEBPACK_IMPORTED_MODULE_15__primitive_polyline_polyline_attribute_mapping__["a" /* POLYLINE_ATTRIBUTE_MAPPING */]);
        let index = 0;
        for (let i = 0; i < response.polylines.length; i++, index++) {
            const { bufferLocation } = response.polylines[i];
            polylinePrimitives[index] = new __WEBPACK_IMPORTED_MODULE_25__primitive_polyline_renderable_polyline__["a" /* default */](new __WEBPACK_IMPORTED_MODULE_2__render_memory_sub_chunk__["a" /* default */](memoryChunks[bufferLocation.bufferIndex], bufferLocation));
        }
        memoryChunks.forEach((chunk) => chunk.release());
        return polylinePrimitives;
    }
    _allocateTexturedPolylines(tile, parsedPolylines, images) {
        const texturedPolylineWriter = new __WEBPACK_IMPORTED_MODULE_7__primitive_polyline_textured_polyline_buffer_writer__["a" /* default */]();
        const worldToPxFactor = WORLD_SIZE / (this._tileSideSizePx * Math.pow(2, tile.zoom));
        const locations = parsedPolylines.map((parsedPolyline, index) => {
            const image = images[index];
            if (image) {
                const style = parsedPolyline.styles[0];
                const width = (style.inline || style.outline).strokeWidth;
                const imageLocation = image.bbox;
                // image size may not match polyline's strokeWidth, so it must be scaled accordingly in
                // both directions, this factor can be passed to the writer in worldToPxFactor updated.
                const pixelRatio = width / (imageLocation.maxY - imageLocation.minY);
                return texturedPolylineWriter.writeTexturedPolyline(parsedPolyline, width, worldToPxFactor * pixelRatio, imageLocation, style.zIndex);
            }
            else {
                return null;
            }
        });
        const pages = texturedPolylineWriter.getBuffers();
        const memoryChunks = new MemoryChunks(pages, this._memoryManager, __WEBPACK_IMPORTED_MODULE_7__primitive_polyline_textured_polyline_buffer_writer__["a" /* default */].ATTRIBUTE_MAPPING);
        const texturedPolylinePrimitives = [];
        for (let i = 0; i < locations.length; i++) {
            const location = locations[i];
            const image = images[i];
            if (location && image) {
                const texturedPolylinePrimitive = new __WEBPACK_IMPORTED_MODULE_26__primitive_polyline_renderable_textured_polyline__["a" /* default */](new __WEBPACK_IMPORTED_MODULE_2__render_memory_sub_chunk__["a" /* default */](memoryChunks[location.bufferIndex], location), image);
                texturedPolylinePrimitives.push(texturedPolylinePrimitive);
            }
        }
        memoryChunks.forEach((chunk) => chunk.release());
        return texturedPolylinePrimitives;
    }
    _allocatePointLabels(response) {
        const memoryChunks = new MemoryChunks(response.pointLabelPages, this._memoryManager, __WEBPACK_IMPORTED_MODULE_13__primitive_label_point_label_attribute_mapping__["a" /* POINT_LABEL_ATTRIBUTE_MAPPING */]);
        const backgroundMemoryChunks = new MemoryChunks(response.pointLabelBackgroundPages, this._memoryManager, __WEBPACK_IMPORTED_MODULE_12__primitive_billboard_rectangle_attribute_mapping__["a" /* BILLBOARD_RECTANGLE_ATTRIBUTE_MAPPING */]);
        const pointLabels = response.pointLabels.map(({ bufferLocation, backgroundBufferLocation }) => {
            const backgroundPrimitive = backgroundBufferLocation ?
                new __WEBPACK_IMPORTED_MODULE_36__primitive_billboard_rectangle_renderable_billboard_rectangle__["a" /* default */](new __WEBPACK_IMPORTED_MODULE_2__render_memory_sub_chunk__["a" /* default */](backgroundMemoryChunks[backgroundBufferLocation.bufferIndex], backgroundBufferLocation)) :
                undefined;
            const labelPrimitive = new __WEBPACK_IMPORTED_MODULE_37__primitive_zoom_restricted_label__["a" /* ZoomRestrictedLabel */](new __WEBPACK_IMPORTED_MODULE_2__render_memory_sub_chunk__["a" /* default */](memoryChunks[bufferLocation.bufferIndex], bufferLocation), this._glyphAtlas, this._computeMinZoom(response.tile, MINZOOM_DELTAS.pointLabels), backgroundPrimitive);
            if (backgroundPrimitive) {
                backgroundPrimitive.release();
            }
            return labelPrimitive;
        });
        backgroundMemoryChunks.forEach((chunk) => chunk.release());
        memoryChunks.forEach((chunk) => chunk.release());
        return pointLabels;
    }
    _allocateCurvedLabels(response) {
        const memoryChunks = new MemoryChunks(response.curvedLabelPages, this._memoryManager, __WEBPACK_IMPORTED_MODULE_14__primitive_label_curved_label_attribute_mapping__["a" /* CURVED_LABEL_ATTRIBUTE_MAPPING */]);
        const curvedLabelPrimitives = response.curvedLabels.map(({ bufferLocation }) => new __WEBPACK_IMPORTED_MODULE_37__primitive_zoom_restricted_label__["a" /* ZoomRestrictedLabel */](new __WEBPACK_IMPORTED_MODULE_2__render_memory_sub_chunk__["a" /* default */](memoryChunks[bufferLocation.bufferIndex], bufferLocation), this._glyphAtlas, this._computeMinZoom(response.tile, MINZOOM_DELTAS.curvedLabels)));
        memoryChunks.forEach((chunk) => chunk.release());
        return curvedLabelPrimitives;
    }
    _allocateIcons(tile, parsedIcons, images) {
        const iconWriter = new __WEBPACK_IMPORTED_MODULE_1__primitive_icon_icon_buffer_writer__["a" /* default */]();
        const locations = parsedIcons.map((parsedIcon, index) => {
            const image = images[index];
            if (image) {
                const style = parsedIcon.styles[0];
                const size = image.descriptor;
                const pixelRatio = style.width / size.width;
                return iconWriter.writeIcon(parsedIcon, image.bbox, size, style.offset, pixelRatio);
            }
            else {
                return null;
            }
        });
        const pages = iconWriter.getBuffers();
        const memoryChunks = new MemoryChunks(pages, this._memoryManager, __WEBPACK_IMPORTED_MODULE_1__primitive_icon_icon_buffer_writer__["a" /* default */].ATTRIBUTE_MAPPING);
        const iconPrimitives = [];
        for (let i = 0; i < locations.length; i++) {
            const location = locations[i];
            const image = images[i];
            if (location && image) {
                const iconPrimitive = new __WEBPACK_IMPORTED_MODULE_38__primitive_zoom_restricted_icon__["a" /* ZoomRestrictedIcon */](new __WEBPACK_IMPORTED_MODULE_2__render_memory_sub_chunk__["a" /* default */](memoryChunks[location.bufferIndex], location), image, this._computeMinZoom(tile, MINZOOM_DELTAS.icons));
                iconPrimitives.push(iconPrimitive);
            }
        }
        memoryChunks.forEach((chunk) => chunk.release());
        return iconPrimitives;
    }
    /**
     * Computes a minimum zoom an object should be still displayed on.
     *
     * @param tile Tile the object belongs to.
     * @param delta Tolerance of the visibility to zooming out, default value was empirically chosen.
     * @returns Minimum zoom for the object.
     */
    _computeMinZoom(tile, delta = 1) {
        return tile.zoom - this._zoomShift - this._targetZoomShift - delta;
    }
    _pushPerfLogItem(tile, parseTime) {
        if (this._perfLogItems.length < MAX_PERF_LOG_ITEMS_COUNT) {
            this._perfLogItems.push({ tile, parseTime });
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = VectorApiAdapter;

/**
 * Helper class for allocation of an array of memory chunks.
 */
class MemoryChunks extends Array {
    constructor(pages, memoryManager, attribMapping) {
        super(pages.length);
        for (let i = 0; i < pages.length; i++) {
            this[i] = memoryManager.allocate(pages[i].vertexBuffer, pages[i].indexBuffer, attribMapping);
        }
    }
}
/**
 * Data managers responsible for specific type of primitives. It just extracts them from TileData and
 * updates appropriate primitive provider.
 */
class TileDataManager {
    constructor(primitiveManager, primitveExtractor) {
        this._primitiveManager = primitiveManager;
        this._primitiveExtractor = primitveExtractor;
    }
    updatePrimitives(toShow, toHide) {
        this._primitiveManager.updateScene(this._primitiveExtractor(toShow), this._primitiveExtractor(toHide));
    }
}
function releasePrimitive(primitive) {
    if (primitive) {
        primitive.release();
    }
}
/**
 * Turns rejection of original promise into null-value resolution. Nulls on appropriate places
 * are required in allocation of textured primitives.
 */
function nullifyRejection(promise) {
    return new Promise((resolve) => promise.then(resolve, () => resolve(null)));
}
/**
 * Splits primitives into two lists: those that have required images allocated and those which images are to be
 * requested. Required images returned in corresponing arrays (requested images as promises).
 */
function splitImageDependantPrimitives(primitives, imageManager, idMapper) {
    const primitivesWithAllocatedImages = [];
    const allocatedImages = [];
    const primitivesWithMissingImages = [];
    const missingImageIds = [];
    for (const primitive of primitives) {
        const id = idMapper(primitive);
        const allocatedImage = imageManager.getImage(id);
        if (allocatedImage) {
            primitivesWithAllocatedImages.push(primitive);
            allocatedImages.push(allocatedImage);
        }
        else {
            primitivesWithMissingImages.push(primitive);
            missingImageIds.push(nullifyRejection(imageManager.requestImage(id)));
        }
    }
    return {
        primitivesWithAllocatedImages,
        allocatedImages,
        primitivesWithMissingImages,
        missingImages: Promise.all(missingImageIds)
    };
}
/**
 * Returns either array of allocated images (if all required images are on the spot) or promises for them (if at least
 * one required image is not yet allocated).
 */
function getImagesIfAllAllocated(primitives, imageManager, idMapper) {
    let isAnyMissing = false;
    const allocatedImages = new Array(primitives.length);
    const missingImages = new Array(primitives.length);
    for (let i = 0; i < primitives.length; i++) {
        const primitive = primitives[i];
        const id = idMapper(primitive);
        const allocatedImage = imageManager.getImage(id);
        if (allocatedImage) {
            allocatedImages[i] = allocatedImage;
        }
        else {
            isAnyMissing = true;
            missingImages[i] = nullifyRejection(imageManager.requestImage(id));
        }
    }
    if (isAnyMissing) {
        for (let i = 0; i < primitives.length; i++) {
            if (allocatedImages[i]) {
                missingImages[i] = Promise.resolve(allocatedImages[i]);
            }
        }
        return { missingImages: Promise.all(missingImages) };
    }
    else {
        return { allocatedImages };
    }
}


/***/ }),
/* 68 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__adapter__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_tile_system__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_iterable__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__tile_id__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__util_event_emitter__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__math_vector2__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__util_worker__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__util_visible_tile__ = __webpack_require__(72);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__belt_tiles__ = __webpack_require__(73);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__util_stat__ = __webpack_require__(18);










const NO_TILES_TO_HANDLE = [];
const MAX_PERF_LOG_ITEMS_COUNT = 1024;
// To select which tile to load camera zoom is rounded so the shift is 0.5.
const TARGET_ZOOM_SHIFT = 0.25;
const VISIBLE_TILE_PRIORITY = 200;
function* flattenVisibleDataPortions(tiles) {
    for (const tile of tiles) {
        yield* tile.data.visible;
    }
}
function getZoomShift(tileSize) {
    switch (tileSize) {
        case 1 /* X4 */:
            return -1;
        case 2 /* X16 */:
            return -2;
        default:
            return 0;
    }
}
/**
 * Base class for adapters that get their data in tiles. Content of tiles that come into field of view should
 * be requested, as well as content of invisible tiles should be removed, also tiles on different zoom levels can
 * overlap each other. Managing of all these cases and other tile-specific logic is the responsibility of this class.
 */
class TileBasedAdapter extends __WEBPACK_IMPORTED_MODULE_0__adapter__["a" /* default */] {
    constructor(engine, camera, tileSize = 0 /* X1 */, preloadedTilesBeltSize = 0, layerName = '') {
        super(engine, camera);
        this._layerName = layerName;
        this._zoomShift = getZoomShift(tileSize);
        this._targetZoomShift = TARGET_ZOOM_SHIFT;
        this._engineRenderListener = () => this._onEngineRenderEvent();
        this.engine.renderer.onRender.addListener(this._engineRenderListener);
        this._currentTiles = new Map();
        this._allTiles = new Map();
        this._readyForRenderTiles = [];
        this.onTileReady = new __WEBPACK_IMPORTED_MODULE_4__util_event_emitter__["a" /* EventEmitter */]();
        this.onTileLoadChange = new __WEBPACK_IMPORTED_MODULE_4__util_event_emitter__["a" /* EventEmitter */]();
        this._requestedTiles = new Map();
        this._tilesToRefresh = new Set();
        this._beltSize = preloadedTilesBeltSize;
        // Sometimes the adapter isn't destroyed, just the page closes. Listen
        // for that and send measurements to the statface.
        window.addEventListener('beforeunload', this._onBeforeUnloadListener = this._sendStatisticsBeforeDestroy.bind(this));
        this._tileLoadLogs = [];
    }
    destroy() {
        window.removeEventListener('beforeunload', this._onBeforeUnloadListener);
        this._sendStatisticsBeforeDestroy();
        this.engine.renderer.onRender.removeListener(this._engineRenderListener);
        super.destroy();
    }
    getVisibleTilesNumber() {
        return this._currentTiles.size;
    }
    getPendingTilesNumber() {
        let pendingCounter = 0;
        this._requestedTiles.forEach((requestedTile) => {
            if (this._currentTiles.get(Object(__WEBPACK_IMPORTED_MODULE_3__tile_id__["a" /* getTileId */])(requestedTile.tileItem))) {
                pendingCounter++;
            }
        });
        return pendingCounter;
    }
    _getTargetZoom() {
        return Math.floor(this.camera.zoom + this._targetZoomShift);
    }
    /**
     * @param tileItem The tile to which the data belongs.
     * @param data Data portion to be shown in tile once it is ready to visualize.
     * @param requestId ID of the request data was requested with. Based on this the data is being displayed, stored for
     * future use or discarded.
     * @param visualize Is this data portion enough to render this tile and replace overlapped ones if any.
     */
    _putTileData(tileItem, data, requestId = __WEBPACK_IMPORTED_MODULE_6__util_worker__["a" /* NO_ID */], visualize = true) {
        const tile = this._allTiles.get(Object(__WEBPACK_IMPORTED_MODULE_3__tile_id__["a" /* getTileId */])(tileItem));
        if (!tile) {
            // Data recieved late and probably the tile had been destroyed.
            // Destroy data too.
            this._onTileDestroy(tileItem, [data]);
            return;
        }
        // NO_ID passed here means concrete adapter doesn't care to label tile data with a requestId which most likely
        // means adapter keeps its data as a whole, not splitting it into portions and, therefore, doesn't need its data
        // to be maintained separately as visible/actual. In this case the data is always treated like an actual data.
        if (requestId === tile.data.visibleRequestId && requestId !== __WEBPACK_IMPORTED_MODULE_6__util_worker__["a" /* NO_ID */]) {
            tile.data.visible.push(data);
            if (tile.isVisible) {
                // The data is currently displayed so the new portion is added to the scene.
                this._updateTileDataPortions([data], []);
            }
        }
        else if (requestId === tile.data.actualRequestId) {
            // The data is actual and either is just being put into the tile or visualizes all `actual` tile data.
            this._putActualTileData(tile, data, visualize);
        }
        else {
            // The data is neither visible nor actual. Destroy data.
            this._onTileDestroy(tileItem, [data]);
        }
    }
    _onCameraUpdate() {
        const camera = this.camera;
        const zoom = this._getTargetZoom();
        const newCurrent = new Set(Object(__WEBPACK_IMPORTED_MODULE_7__util_visible_tile__["a" /* computeVisibleTiles */])(camera.getVisibleRegion(), camera.getVisibleRegionBBox(), camera.options.wrapModeX, camera.options.wrapModeY, Math.max(0, zoom + this._zoomShift)));
        // this._currentTiles contains currently visible tiles, newCurrent contains set of tiles visible from updated
        // camera position, compare these two sets and call this._onVisibleTilesChanged() if there is a difference.
        if (newCurrent.size !== this._currentTiles.size ||
            Object(__WEBPACK_IMPORTED_MODULE_2__util_iterable__["d" /* oneOfIterable */])(newCurrent, (tile) => !this._currentTiles.has(Object(__WEBPACK_IMPORTED_MODULE_3__tile_id__["a" /* getTileId */])(tile)))) {
            this._onVisibleTilesChanged(newCurrent);
        }
        // this checks prevents leaks of tiles when quick zoom-in/zoom-out happens
        for (const tile of this._currentTiles.values()) {
            if (tile.isReadyToVisualize) {
                this._checkTileReplacements(tile);
            }
        }
    }
    _onTilesRequest(requests, requestId = __WEBPACK_IMPORTED_MODULE_6__util_worker__["a" /* NO_ID */]) {
        for (const tileRequest of requests) {
            const requestedTileData = {
                info: {
                    priority: tileRequest.priority
                },
                loadTimestamps: {
                    queued: performance.now(),
                    loaded: 0,
                    rendered: 0,
                    ready: 0
                },
                tileItem: tileRequest
            };
            const tileId = Object(__WEBPACK_IMPORTED_MODULE_3__tile_id__["a" /* getTileId */])(tileRequest);
            this._requestedTiles.set(tileId, requestedTileData);
            this._readyTilesChange = true;
            const tile = this._allTiles.get(tileId);
            if (tile) {
                tile.data.actualRequestId = requestId;
            }
        }
    }
    _onCancelTileRequests(requests) {
        for (const request of requests) {
            const tileId = Object(__WEBPACK_IMPORTED_MODULE_3__tile_id__["a" /* getTileId */])(request.tile);
            if (this._requestedTiles.delete(tileId)) {
                this._readyTilesChange = true;
                this._tilesToRefresh.delete(tileId);
            }
        }
    }
    _onTileError(tileItem) {
        const tileId = Object(__WEBPACK_IMPORTED_MODULE_3__tile_id__["a" /* getTileId */])(tileItem);
        if (this._requestedTiles.delete(tileId)) {
            this._readyTilesChange = true;
            this._tilesToRefresh.delete(tileId);
        }
    }
    /**
     * This method is where the whole magic happens, it manages replacement of current set of visible/preloaded tiles
     * with a new one.
     */
    _onVisibleTilesChanged(visibleTiles) {
        this._currentTiles.clear();
        const tilesToRequest = [];
        for (const tileItem of visibleTiles) {
            let tile = this._allTiles.get(Object(__WEBPACK_IMPORTED_MODULE_3__tile_id__["a" /* getTileId */])(tileItem));
            if (!tile) {
                tile = new Tile(tileItem);
                this._allTiles.set(tile.id, tile);
                this._currentTiles.set(tile.id, tile);
                tilesToRequest.push(this._createTileRequest(tileItem, this._getTilePriority(tile.tileItem, true)));
            }
            else {
                this._currentTiles.set(tile.id, tile);
            }
        }
        if (tilesToRequest.length > 0) {
            this._requestTiles(tilesToRequest);
        }
        const beltTiles = new Map();
        for (const beltTileItem of Object(__WEBPACK_IMPORTED_MODULE_8__belt_tiles__["a" /* calculateBeltTiles */])(visibleTiles, this._beltSize, this.camera.options.wrapModeX === 2 /* REPEAT */, this.camera.options.wrapModeY === 2 /* REPEAT */)) {
            beltTiles.set(Object(__WEBPACK_IMPORTED_MODULE_3__tile_id__["a" /* getTileId */])(beltTileItem), beltTileItem);
        }
        const beltTilesToRequest = [];
        for (const beltTileItem of beltTiles.values()) {
            const tileId = Object(__WEBPACK_IMPORTED_MODULE_3__tile_id__["a" /* getTileId */])(beltTileItem);
            let tile = this._allTiles.get(tileId);
            if (!tile) {
                tile = new Tile(beltTileItem);
                this._allTiles.set(tileId, tile);
                beltTilesToRequest.push(this._createTileRequest(beltTileItem, this._getTilePriority(beltTileItem, false)));
            }
        }
        if (beltTilesToRequest.length) {
            this._requestTiles(beltTilesToRequest);
        }
        // broke current relationships to set them up again but with new set of visible tiles
        for (const tile of this._allTiles.values()) {
            tile.toBeReplacedBy.clear();
            tile.replacementFor.clear();
        }
        // TODO: optimize this n^2 relationships resolver
        for (const currentTile of this._currentTiles.values()) {
            for (const tile of this._allTiles.values()) {
                if (tile.isReadyToVisualize &&
                    (Object(__WEBPACK_IMPORTED_MODULE_1__util_tile_system__["b" /* isParent */])(tile.tileItem, currentTile.tileItem) || Object(__WEBPACK_IMPORTED_MODULE_1__util_tile_system__["b" /* isParent */])(currentTile.tileItem, tile.tileItem))) {
                    tile.toBeReplacedBy.add(currentTile);
                    currentTile.replacementFor.add(tile);
                }
            }
        }
        // remove invisible
        const tilesToCancel = [];
        for (const tile of this._allTiles.values()) {
            if (!this._currentTiles.has(tile.id) && tile.toBeReplacedBy.size === 0) {
                if (tile.isVisible) {
                    this._updateTileData(NO_TILES_TO_HANDLE, [tile]);
                }
                if (!beltTiles.get(tile.id)) {
                    this._destroyTile(tile);
                    tilesToCancel.push(tile);
                }
            }
        }
        if (tilesToCancel.length) {
            // issue cancellation also in case there are non processed data enqueued to try to save some efforts
            this._cancelTileRequests(tilesToCancelations(tilesToCancel));
        }
    }
    _refreshCurrentTiles() {
        const tilesToRequest = [];
        for (const tile of this._currentTiles.values()) {
            const tileItem = tile.tileItem;
            const tileRequest = this._createTileRequest(tileItem, this._getTilePriority(tile.tileItem, true));
            tilesToRequest.push(tileRequest);
            this._tilesToRefresh.add(Object(__WEBPACK_IMPORTED_MODULE_3__tile_id__["a" /* getTileId */])(tile.tileItem));
        }
        this._cancelTileRequests(tilesToCancelations(this._currentTiles.values()));
        this._requestTiles(tilesToRequest);
    }
    _onTileDataReady(tileItem, url) {
        const tileId = Object(__WEBPACK_IMPORTED_MODULE_3__tile_id__["a" /* getTileId */])(tileItem);
        const tileData = this._requestedTiles.get(tileId);
        this._requestedTiles.delete(tileId);
        this._tilesToRefresh.delete(tileId);
        tileData.info.url = url;
        tileData.loadTimestamps.loaded = performance.now();
        if (this._tileLoadLogs.length < MAX_PERF_LOG_ITEMS_COUNT) {
            this._tileLoadLogs.push({
                tileItem,
                processingTime: tileData.loadTimestamps.loaded - tileData.loadTimestamps.queued
            });
        }
        this._readyForRenderTiles.push(tileData);
        if (this._currentTiles.get(tileId)) {
            this._readyTilesChange = true;
        }
    }
    _isTileStillActive(tileItem, requestId = __WEBPACK_IMPORTED_MODULE_6__util_worker__["a" /* NO_ID */]) {
        const tile = this._allTiles.get(Object(__WEBPACK_IMPORTED_MODULE_3__tile_id__["a" /* getTileId */])(tileItem));
        if (!tile) {
            return false;
        }
        const isRequestActive = tile.data.actualRequestId === requestId || tile.data.visibleRequestId === requestId;
        return isRequestActive;
    }
    _isTileRefreshing(tile) {
        return this._tilesToRefresh.has(Object(__WEBPACK_IMPORTED_MODULE_3__tile_id__["a" /* getTileId */])(tile));
    }
    _getTilePriority(tile, isVisible) {
        const center = this._createTileCoordinateSystem().toTileCoordinates(this.camera.center);
        const zoomDiff = Math.ceil(this.camera.zoom) - tile.zoom;
        const distance = __WEBPACK_IMPORTED_MODULE_5__math_vector2__["j" /* distance */](tile, {
            x: Math.floor(center.x / Math.pow(2, zoomDiff)),
            y: Math.floor(center.y / Math.pow(2, zoomDiff))
        });
        return (isVisible ? VISIBLE_TILE_PRIORITY : 0) + 1 / (distance + 1);
    }
    _sendStatisticsBeforeDestroy() {
        if (this._tileLoadLogs.length === 0) {
            return;
        }
        const accumulatedTimings = new Map();
        accumulatedTimings.set('average', {
            sum: 0,
            number: 0
        });
        this._tileLoadLogs.forEach((logItem) => {
            accumulatedTimings.get('average').sum += logItem.processingTime;
            accumulatedTimings.get('average').number++;
            const zoom = logItem.tileItem.zoom.toString();
            if (!accumulatedTimings.has(zoom)) {
                accumulatedTimings.set(zoom, {
                    sum: 0,
                    number: 0
                });
            }
            accumulatedTimings.get(zoom).sum += logItem.processingTime;
            accumulatedTimings.get(zoom).number++;
        });
        const result = [];
        for (const item of accumulatedTimings) {
            result.push({
                zoom: item[0],
                time: (item[1].sum / item[1].number)
            });
        }
        Object(__WEBPACK_IMPORTED_MODULE_9__util_stat__["c" /* countTileProcessingTime */])(this._layerName, result);
    }
    /**
     * Puts actual data into the tile and optionally visualizes it.
     *
     * @param tile Tile to put data into.
     * @param data Data to be stored in the tile until visualization.
     * @param visualize If `true` replaces `visible` tile data with `actual` tile data and updates the scene.
     */
    _putActualTileData(tile, data, visualize) {
        tile.data.actual.push(data);
        if (visualize) {
            this._visualizeTile(tile);
        }
    }
    /**
     * Visualizes tile `actual` data: replaces tile `visible` data with tile `actual` data, adds it to the scene,
     * removes old visible data from the scene and destroys it, checks tile replacements and updates `visibleRequestId`.
     * @param tile Tile to visualize.
     */
    _visualizeTile(tile) {
        const toDestroy = tile.data.visible;
        tile.data.visible = tile.data.actual;
        tile.data.actual = [];
        tile.data.visibleRequestId = tile.data.actualRequestId;
        if (!tile.isReadyToVisualize) {
            tile.isReadyToVisualize = true;
            this._checkTileReplacements(tile);
        }
        else if (tile.isVisible) {
            this._updateTileDataPortions(tile.data.visible, []);
        }
        if (toDestroy.length > 0) {
            this._updateTileDataPortions([], toDestroy);
            this._onTileDestroy(tile.tileItem, toDestroy);
        }
    }
    _createTileCoordinateSystem() {
        return new __WEBPACK_IMPORTED_MODULE_1__util_tile_system__["a" /* default */](this.camera.zoom);
    }
    // We need do detect when tile is rendered to collect perfomance metrics.
    // We expect that tile will be rendered with first render event after
    // tile data is added to scene.
    _onEngineRenderEvent() {
        if (this._readyForRenderTiles.length) {
            this._readyForRenderTiles.forEach((tileData) => {
                if (this._currentTiles.has(Object(__WEBPACK_IMPORTED_MODULE_3__tile_id__["a" /* getTileId */])(tileData.tileItem))) {
                    tileData.loadTimestamps.rendered = performance.now();
                    tileData.loadTimestamps.ready = performance.now();
                    this.onTileReady.fire(tileData);
                }
            });
            this._readyForRenderTiles.length = 0;
        }
        if (this._readyTilesChange) {
            this.onTileLoadChange.fire({
                totalTileNumber: this.getVisibleTilesNumber(),
                readyTileNumber: this.getVisibleTilesNumber() - this.getPendingTilesNumber()
            });
            this._readyTilesChange = false;
        }
    }
    /**
     * Shows/hides tiles if they are not shown/hidden yet. It notifies subclasses by calling appropriate
     * abstract method. Even though visible/invisible tiles are not supposed to be shown/hidden again,
     * there are cases where it simplifies tile visualization logic.
     * It is important to have exactly "update", not "add"/"remove" separately, as some business logic may rely on it,
     * e.g. morphing visible data or managing shared resources.
     */
    _updateTileData(toShow, toRemove) {
        const dataToShow = Array.from(flattenVisibleDataPortions(toShow));
        const dataToRemove = Array.from(flattenVisibleDataPortions(toRemove));
        this._updateTileDataPortions(dataToShow, dataToRemove);
        for (const tile of toShow) {
            tile.isVisible = true;
        }
        for (const tile of toRemove) {
            tile.isVisible = false;
        }
    }
    _updateTileDataPortions(toShow, toRemove) {
        this._onTileDataUpdate(toShow, toRemove);
    }
    /**
     * Removes tile if is not removed with calling all appropriate callbacks (abstract methods)
     * to notify descendant classes. Even though removed tile is not supposed to be removed again,
     * allowing this makes much simpler tile management, especially in tile replacements logic where multiple
     * tiles can have links to the same tile (that is to be removed).
     */
    _destroyTile(tile) {
        if (!tile.isRemoved) {
            tile.isRemoved = true;
            this._allTiles.delete(tile.id);
            this._currentTiles.delete(tile.id);
            this._onTileDestroy(tile.tileItem, [...tile.data.actual, ...tile.data.visible]);
        }
    }
    /**
     * Checks tiles that could be replaced by this one, should be called when tile becomes ready to visualize.
     * As overlapping relationships can happen in both directions (children by parents / parent by children) this
     * method goes one step deeper, i.e. it check not only tiles that should be replaced (to remove them),
     * but also all tiles that cover the replaced ones (to show them).
     */
    _checkTileReplacements(tile) {
        const toDestroy = new Set();
        const toShow = new Set();
        const toHide = new Set();
        for (const tileToReplace of tile.replacementFor) {
            if (Object(__WEBPACK_IMPORTED_MODULE_2__util_iterable__["a" /* allOfIterable */])(tileToReplace.toBeReplacedBy, (tile) => tile.isReadyToVisualize)) {
                if (tileToReplace.isVisible) {
                    toHide.add(tileToReplace);
                }
                if (!tileToReplace.isRemoved) {
                    toDestroy.add(tileToReplace);
                }
                for (const tileToShow of tileToReplace.toBeReplacedBy) {
                    if (!tileToShow.isVisible) {
                        toShow.add(tileToShow);
                    }
                }
            }
        }
        if (tile.replacementFor.size === 0 && !tile.isVisible) {
            toShow.add(tile);
        }
        if (toShow.size > 0 || toHide.size > 0) {
            this._updateTileData(toShow, toHide);
        }
        for (const tileToDestroy of toDestroy) {
            this._destroyTile(tileToDestroy);
        }
        if (toDestroy.size > 0) {
            this._cancelTileRequests(tilesToCancelations(toDestroy));
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = TileBasedAdapter;

/**
 * This class is the main unit of the whole process of tile management. It stores visualizable data and links to
 * dependant tiles (for parent/child overlapping cases).
 */
class Tile {
    constructor(tileItem) {
        this.data = {
            actual: [],
            visible: [],
            actualRequestId: __WEBPACK_IMPORTED_MODULE_6__util_worker__["a" /* NO_ID */],
            visibleRequestId: __WEBPACK_IMPORTED_MODULE_6__util_worker__["a" /* NO_ID */]
        };
        this.tileItem = tileItem;
        this.id = `${tileItem.x}:${tileItem.y}:${tileItem.zoom}`;
        this.isReadyToVisualize = false;
        this.isVisible = false;
        this.isRemoved = false;
        this.toBeReplacedBy = new Set();
        this.replacementFor = new Set();
    }
}
function tilesToCancelations(tiles) {
    return Array.from(tiles, (tile) => ({
        tile: tile.tileItem,
        requestId: tile.data.actualRequestId
    }));
}


/***/ }),
/* 69 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_function__ = __webpack_require__(70);

class Adapter {
    constructor(engine, camera, cameraUpdateDelay = 5) {
        this.engine = engine;
        this.camera = camera;
        this._cameraUpdateListener = Object(__WEBPACK_IMPORTED_MODULE_0__util_function__["a" /* debounce */])(this._onCameraUpdate.bind(this), cameraUpdateDelay);
        camera.onUpdate.addListener(this._cameraUpdateListener);
    }
    destroy() {
        this.camera.onUpdate.removeListener(this._cameraUpdateListener);
    }
    /**
     * Camera update handler, by default do nothing.
     */
    _onCameraUpdate() { }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Adapter;



/***/ }),
/* 70 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = debounce;
/**
 * Creates new function which execution is "debounced".
 */
function debounce(func, wait) {
    let timeout = 0;
    return (...args) => {
        const later = () => {
            timeout = 0;
            func(...args);
        };
        if (timeout) {
            clearTimeout(timeout);
        }
        timeout = setTimeout(later, wait);
    };
}


/***/ }),
/* 71 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = isParent;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_scalar__ = __webpack_require__(9);

/**
 * @return `true` if the first param overlaps the second in tile hierarchy.
 */
function isParent(potentialParent, possibleChild) {
    const zoomDiff = possibleChild.zoom - potentialParent.zoom;
    return zoomDiff > 0 &&
        possibleChild.x >> zoomDiff === potentialParent.x &&
        possibleChild.y >> zoomDiff === potentialParent.y;
}
class TileCoordinateSystem {
    constructor(zoom) {
        this._zoom = Math.ceil(Object(__WEBPACK_IMPORTED_MODULE_0__math_scalar__["a" /* clamp */])(zoom, 0, 31));
        this._tileSize = 2 / (1 << this._zoom);
    }
    getZoom() {
        return this._zoom;
    }
    /**
     * @return Tile side length in units of the world coordinate system.
     */
    getTileSize() {
        return this._tileSize;
    }
    /**
     * @return Top left corner coordinates of the tile.
     */
    getTileOffset(tile) {
        return {
            x: this.getTileSize() * tile.x - 1,
            y: 1 - this.getTileSize() * tile.y
        };
    }
    toTileCoordinates(worldCoordinates) {
        return {
            x: (worldCoordinates.x + 1) / this._tileSize,
            y: (1 - worldCoordinates.y) / this._tileSize
        };
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = TileCoordinateSystem;



/***/ }),
/* 72 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = computeVisibleTiles;
const TILE_0_0_0 = { x: 0, y: 0, zoom: 0 };
/**
 * Computes set of tiles visible through a camera. Tiles in the set are guaranteed
 * to be unique.
 *
 * FIXME(dmikis) The uniqueness guarantee is broken currently, but code that uses
 *      this function doesn't suffer from that.
 *
 * @param camera The camera.
 * @returns An iterator over visible tile items.
 */
function* computeVisibleTiles(visibleRegion, visibleRegionBBox, wrapModeX, wrapModeY, zoom) {
    if (zoom === 0) {
        // The only tile on zoom 0 encompasses the whole world. Thus there's
        // little to no point computing that camera sees it: we can tell that
        // right away.
        yield TILE_0_0_0;
        return;
    }
    const tileCount = 1 << zoom;
    const tileIdxMask = tileCount - 1;
    // The idea behind the code below is quite simple: determine columns of the
    // tile grid that are visible to the camera, then for each column find
    // range of row indices that are visible.
    // Here's how we approach computing tile indices from world coordinates.
    // First, we transform world coordinates from [-1, 1] range to [0, 2],
    // dealing with inconsistency with Y axis direction in world and tile grid
    // coordinate system. Let's designate such a coordinate as C (for either X
    // or Y). Size of a tile is 2 / tileCount. Thus,
    //
    //      tileIdx = Math.floor(C / (2 / tileCount))
    //              = Math.floor(C * tileCount / 2)
    //
    const { minX, maxX, minY, maxY } = visibleRegionBBox;
    const minTX = Math.floor((minX + 1) * tileCount / 2);
    const maxTX = Math.floor((maxX + 1) * tileCount / 2);
    const columnCount = maxTX - minTX + 1;
    // Arrays of indices of bottommost and topmost tiles correspondingly for
    // each column.
    // FIXME(dmikis) If number of columns is too large, we'll consume a lot of
    //      memory here. There's a method to do without the arrays, but it's a
    //      bit more complicated to implement.
    const minYs = new Array(columnCount);
    const maxYs = new Array(columnCount);
    // Common sense suggests that those indices can't be greater (less) than the
    // index of a tile row intersected by a line y = minY (y = maxY). Note that
    // maxY corresponds to a tile row with lesser index, not other way around.
    minYs.fill(Math.floor((1 - minY) * tileCount / 2));
    maxYs.fill(Math.floor((1 - maxY) * tileCount / 2));
    const visiblePolygonLength = visibleRegion.length;
    let prevX = visibleRegion[visiblePolygonLength - 1].x + 1;
    let prevY = 1 - visibleRegion[visiblePolygonLength - 1].y;
    let prevTX = Math.floor(prevX * tileCount / 2);
    let prevTY = Math.floor(prevY * tileCount / 2);
    // Iterate over edges of visible polygon of the camera to compute index of
    // topmost and bottommost tiles for each column.
    for (let i = 0; i < visiblePolygonLength; ++i) {
        const x = visibleRegion[i].x + 1;
        const y = 1 - visibleRegion[i].y;
        const tx = Math.floor(x * tileCount / 2);
        const ty = Math.floor(y * tileCount / 2);
        // For each edge we compute 4-connected line of tiles on the tile grid.
        // Length of a 4-connected line always equals Manhattan distance between
        // its ends. However, to avoid unnecessary computation, we omit last tile
        // for every edge. But, since the polygon is closed, we'll iterate over
        // all tiles intersected by edges anyway.
        const l = Math.abs(tx - prevTX) + Math.abs(ty - prevTY);
        const lx = x - prevX;
        const ly = y - prevY;
        const dtx = lx > 0 ? 1 : -1;
        const dty = ly > 0 ? 1 : -1;
        const a = 2 * dtx * ly;
        const b = -2 * dtx * lx;
        const c = dtx * tileCount * (lx * prevY - ly * prevX) + a * (~dtx >>> 31);
        for (let i = 0, tx = prevTX, ty = prevTY; i < l; ++i) {
            const intercept = a * tx + b * ty + c;
            // The math here is somewhat cumbersome to avoid divisions, but the
            // essence is that we try to check through which side the edge of
            // visible polygon exits the tile. Depending on that we "move" to
            // next tile in either vertical or horizontal direction.
            if (0 <= intercept && intercept <= -b) {
                tx += dtx;
            }
            else {
                ty += dty;
            }
            const yIdx = tx - minTX;
            if (maxYs[yIdx] < ty) {
                maxYs[yIdx] = ty;
            }
            if (minYs[yIdx] > ty) {
                minYs[yIdx] = ty;
            }
        }
        prevX = x;
        prevY = y;
        prevTX = tx;
        prevTY = ty;
    }
    // If the world is repeated along X axis, we need to "fold" the array of columns,
    // i.e. compute union of row intervals for columns tileCount indices apart.
    if (wrapModeX === 2 /* REPEAT */ && columnCount > tileCount) {
        for (let i = 0; i < tileCount; ++i) {
            for (let j = i + tileCount; j < columnCount; j += tileCount) {
                if (maxYs[i] < maxYs[j]) {
                    maxYs[i] = maxYs[j];
                }
                if (minYs[i] > minYs[j]) {
                    minYs[i] = minYs[j];
                }
            }
        }
    }
    // If the world is repeated along Y axis, we need to wrap indices in minYs
    // and maxYs arrays to [0, tileCount) interval.
    if (wrapModeY === 2 /* REPEAT */) {
        for (let i = 0; i < columnCount && i < tileCount; ++i) {
            const dy = maxYs[i] - minYs[i];
            // If there's more than tileCount rows between maxY and minY, then the
            // world is encompassed somewhere within visible region.
            if (dy > tileCount) {
                minYs[i] = 0;
                maxYs[i] = tileIdxMask;
            }
            else {
                const minY = minYs[i] &= tileIdxMask;
                maxYs[i] = minY + dy;
            }
        }
    }
    else {
        for (let i = 0; i < columnCount && i < tileCount; ++i) {
            minYs[i] = Math.max(minYs[i], 0);
            maxYs[i] = Math.min(maxYs[i], tileIdxMask);
        }
    }
    if (wrapModeX === 2 /* REPEAT */) {
        for (let i = 0; i < columnCount && i < tileCount; ++i) {
            const tx = (i + minTX) & tileIdxMask;
            for (let ty = minYs[i]; ty <= maxYs[i]; ++ty) {
                yield {
                    x: tx,
                    y: ty & tileIdxMask,
                    zoom
                };
            }
        }
    }
    else {
        for (let tx = Math.max(minTX, 0), txEnd = Math.min(maxTX, tileIdxMask); tx <= txEnd; ++tx) {
            const i = tx - minTX;
            for (let ty = minYs[i]; ty <= maxYs[i]; ++ty) {
                yield {
                    x: tx,
                    y: ty & tileIdxMask,
                    zoom
                };
            }
        }
    }
}


/***/ }),
/* 73 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = calculateBeltTiles;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__tile_id__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math_vector2__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math_scalar__ = __webpack_require__(9);



const LEFT_SIDE = {
    direction: __WEBPACK_IMPORTED_MODULE_1__math_vector2__["f" /* create */](0, -1),
    normal: __WEBPACK_IMPORTED_MODULE_1__math_vector2__["f" /* create */](-1, 0),
    diagonal: __WEBPACK_IMPORTED_MODULE_1__math_vector2__["f" /* create */](-1, -1),
    prevSide: () => BOTTOM_SIDE,
    nextSide: () => TOP_SIDE
};
const RIGHT_SIDE = {
    direction: __WEBPACK_IMPORTED_MODULE_1__math_vector2__["f" /* create */](0, +1),
    normal: __WEBPACK_IMPORTED_MODULE_1__math_vector2__["f" /* create */](+1, 0),
    diagonal: __WEBPACK_IMPORTED_MODULE_1__math_vector2__["f" /* create */](+1, +1),
    prevSide: () => TOP_SIDE,
    nextSide: () => BOTTOM_SIDE
};
const TOP_SIDE = {
    direction: __WEBPACK_IMPORTED_MODULE_1__math_vector2__["f" /* create */](+1, 0),
    normal: __WEBPACK_IMPORTED_MODULE_1__math_vector2__["f" /* create */](0, -1),
    diagonal: __WEBPACK_IMPORTED_MODULE_1__math_vector2__["f" /* create */](+1, -1),
    prevSide: () => LEFT_SIDE,
    nextSide: () => RIGHT_SIDE
};
const BOTTOM_SIDE = {
    direction: __WEBPACK_IMPORTED_MODULE_1__math_vector2__["f" /* create */](-1, 0),
    normal: __WEBPACK_IMPORTED_MODULE_1__math_vector2__["f" /* create */](0, +1),
    diagonal: __WEBPACK_IMPORTED_MODULE_1__math_vector2__["f" /* create */](-1, +1),
    prevSide: () => RIGHT_SIDE,
    nextSide: () => LEFT_SIDE
};
/**
 * Adds tile to belt tiles if it doesn't fall out of the world. Cycling coordinates can't fall out,
 * they just got adjusted directly in tile item.
 */
function addTileIfAppropriate(tile, beltTiles, maxCoordinate, isXCycled, isYCycled) {
    tile.x = isXCycled ? Object(__WEBPACK_IMPORTED_MODULE_2__math_scalar__["b" /* cycleRestrict */])(tile.x, 0, maxCoordinate) : tile.x;
    tile.y = isYCycled ? Object(__WEBPACK_IMPORTED_MODULE_2__math_scalar__["b" /* cycleRestrict */])(tile.y, 0, maxCoordinate) : tile.y;
    if ((0 <= tile.x) && (tile.x < maxCoordinate) &&
        (0 <= tile.y) && (tile.y < maxCoordinate)) {
        beltTiles.set(Object(__WEBPACK_IMPORTED_MODULE_0__tile_id__["a" /* getTileId */])(tile), tile);
    }
}
/**
 * The algorithm is implemented as a state machine, this method produces belt tiles and sets appropriate state.
 * How to change this state (determine current tile and its side) is described in four TileSide implementations:
 * left, right, top and bottom.
 */
function move(tiles, state, size, maxCoordinate, isXCycled, isYCycled) {
    // add tiles outward in the direction of the normal
    for (let i = 1; i <= size; i++) {
        addTileIfAppropriate({
            x: state.currentTile.x + i * state.currentTileSide.normal.x,
            y: state.currentTile.y + i * state.currentTileSide.normal.y,
            zoom: state.currentTile.zoom
        }, state.beltTiles, maxCoordinate, isXCycled, isYCycled);
    }
    // check diagonal tile
    const diagonalNeighbour = tiles.get(Object(__WEBPACK_IMPORTED_MODULE_0__tile_id__["b" /* getTileIdByRawValues */])(state.currentTile.x + state.currentTileSide.diagonal.x, state.currentTile.y + state.currentTileSide.diagonal.y, state.currentTile.zoom));
    if (diagonalNeighbour) {
        state.currentTile = diagonalNeighbour;
        state.currentTileSide = state.currentTileSide.prevSide();
        return;
    }
    // check neighbour in the same direction
    const neighbour = tiles.get(Object(__WEBPACK_IMPORTED_MODULE_0__tile_id__["b" /* getTileIdByRawValues */])(state.currentTile.x + state.currentTileSide.direction.x, state.currentTile.y + state.currentTileSide.direction.y, state.currentTile.zoom));
    if (neighbour) {
        state.currentTile = neighbour;
        return;
    }
    // handle corner tiles
    for (let i = 1; i <= size; i++) {
        for (let j = 1; j <= size; j++) {
            addTileIfAppropriate({
                x: state.currentTile.x + i * state.currentTileSide.diagonal.x,
                y: state.currentTile.y + j * state.currentTileSide.diagonal.y,
                zoom: state.currentTile.zoom
            }, state.beltTiles, maxCoordinate, isXCycled, isYCycled);
        }
    }
    state.currentTileSide = state.currentTileSide.nextSide();
}
/**
 * Calculates tiles that surround provided region (set of tiles), the region must be one or more convex polygons
 * with no holes, otherwise correctness is not guaranteed. Multiple polygons can happen when the camera looks
 * at the edge of the world capturing cycled tiles from different sides.
 * The logic of including tiles in the "belt" is as follows: shortest distance from "outside" to any point
 * in the original region should be not less than tileSize * beltSize.
 *
 * @param tiles Set of tiles that cover a convex polygon.
 * @param beltSize "thickness" (in tiles) of the surrounding area.
 */
function calculateBeltTiles(tiles, beltSize, isXCycled, isYCycled) {
    // the algorithm in simple words:
    //   1. find a tile on an edge of the polygon (e.g. one of the leftmost ones)
    //   2. go around the polygon tile-by-tile adding surrounding tiles outwardly
    const indexedTiles = new Map();
    const beltTiles = new Map();
    // index tiles
    for (const tileItem of tiles) {
        indexedTiles.set(Object(__WEBPACK_IMPORTED_MODULE_0__tile_id__["a" /* getTileId */])(tileItem), tileItem);
    }
    // tiles are grouped into one or more convex polygons, process these polygons one by one
    const tilesToProcess = new Map(indexedTiles);
    while (tilesToProcess.size > 0) {
        let leftmostTile = { x: Number.POSITIVE_INFINITY, y: 0, zoom: 0 };
        // find the leftmost tile to start walking from
        for (const tileItem of tilesToProcess.values()) {
            if (tileItem.x < leftmostTile.x) {
                leftmostTile = tileItem;
            }
        }
        // save min/max y value per x coordinate to be able
        // to mark these tiles as processed (remove from tilesToProcess)
        const maxY = [];
        const minY = [];
        const initState = { currentTile: leftmostTile, currentTileSide: LEFT_SIDE, beltTiles };
        const state = Object.assign({}, initState);
        const maxCoordinate = Math.pow(2, leftmostTile.zoom);
        do {
            // move around while we don't reach the init position
            move(tilesToProcess, state, beltSize, maxCoordinate, isXCycled, isYCycled);
            const index = state.currentTile.x - initState.currentTile.x;
            maxY[index] = maxY[index] === undefined ? state.currentTile.y : Math.max(maxY[index], state.currentTile.y);
            minY[index] = minY[index] === undefined ? state.currentTile.y : Math.min(minY[index], state.currentTile.y);
        } while (state.currentTile !== initState.currentTile ||
            state.currentTileSide !== initState.currentTileSide);
        // mark tiles from current polygon as processed
        const zoom = leftmostTile.zoom;
        for (let i = 0; i < maxY.length; i++) {
            const x = leftmostTile.x + i;
            for (let y = minY[i]; y <= maxY[i]; y++) {
                tilesToProcess.delete(Object(__WEBPACK_IMPORTED_MODULE_0__tile_id__["b" /* getTileIdByRawValues */])(x, y, zoom));
            }
        }
    }
    // remove belt tiles that overlaps to avoid duplications
    for (const tileId of beltTiles.keys()) {
        if (indexedTiles.has(tileId)) {
            beltTiles.delete(tileId);
        }
    }
    return beltTiles.values();
}


/***/ }),
/* 74 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_buffer_writer__ = __webpack_require__(6);


/**
 * Writer of geometry data of icons.
 */
class IconBufferWriter extends __WEBPACK_IMPORTED_MODULE_1__util_buffer_writer__["b" /* default */] {
    constructor() {
        super(IconBufferWriter.ATTRIBUTE_MAPPING.vertexByteSize);
    }
    /**
     * Writes an icon to buffers.
     *
     * @param icon Icon to be written to buffer.
     * @param location Image location in atlas.
     * @param size Image size in atlas.
     * @param offset Offset of image points in CSS pixels.
     * @param pixelRatio Ratio of image size in CSS pixels to the size in atlas pixels.
     *
     * @returns Location of the icon data in buffers.
     */
    writeIcon(icon, location, size, offset, pixelRatio) {
        const top = offset.y;
        const bottom = offset.y + size.height * pixelRatio;
        const left = offset.x;
        const right = offset.x + size.width * pixelRatio;
        this.writeVertex(icon.position, left, bottom, location.minX, location.minY);
        this.writeVertex(icon.position, left, top, location.minX, location.maxY);
        this.writeVertex(icon.position, right, bottom, location.maxX, location.minY);
        this.writeVertex(icon.position, right, top, location.maxX, location.maxY);
        this.writeIndicesForContinuousStrip(4);
        return this.endMesh();
    }
    /**
     * Writes a vertex to the vertex buffer.
     *
     * @param position Position of the vertex in display coordinates.
     * @param uv UVs of the vertex.
     * @return Index of the written vertex.
     */
    writeVertex(position, displacementX, displacementY, uvX, uvY) {
        const vertexIdx = this.getCurrentVertexIdx();
        this._writeWorldCoordinate(position);
        this._writeHalfWords(displacementX, displacementY);
        this._writeHalfWords(uvX, uvY);
        return vertexIdx;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = IconBufferWriter;

/** Description of how a writer stores vertex data. */
IconBufferWriter.ATTRIBUTE_MAPPING = new __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__["a" /* AttributeMapping */]([
    [
        0 /* POSITION_HIGH */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        1 /* POSITION_LOW */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        6 /* DISPLACEMENT */,
        {
            size: 2,
            type: 5122 /* SHORT */,
            normalized: false
        }
    ],
    [
        4 /* UV */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: false
        }
    ]
]);


/***/ }),
/* 75 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_ref_counted__ = __webpack_require__(20);

/**
 * Represents an allocated image. Allocated image is a shareable resource that should be resealed
 * when there are no clients use it. As it is not possible to rely on the GC, clients should
 * manually retain their required images and release them when they are not required anymore.
 */
class AllocatedImage extends __WEBPACK_IMPORTED_MODULE_0__util_ref_counted__["a" /* default */] {
    constructor(descriptor, bbox, atlasManager) {
        super();
        this.descriptor = descriptor;
        this.bbox = bbox;
        this.atlasManager = atlasManager;
    }
    updateImage(sourceImage, locationRegion, sourceImageRegion) {
        this.atlasManager.atlas.updateImage(this.bbox, sourceImage, locationRegion, sourceImageRegion);
    }
    _destroy() {
        this.atlasManager.removeImage(this.descriptor);
    }
}
/* unused harmony export AllocatedImage */

/**
 * Manages allocation of images by id.
 */
class IdentifiedImageAtlasManager {
    constructor(imageAtlas) {
        this.atlas = imageAtlas;
        this._locations = new Map();
    }
    get size() {
        return this._locations.size;
    }
    getImage(id, retain = false) {
        const imageLocation = this._locations.get(id);
        if (retain && imageLocation) {
            imageLocation.retain();
        }
        return imageLocation || null;
    }
    allocateImage(descriptor, image) {
        const location = this.atlas.allocateImage(descriptor, image);
        if (location) {
            const image = new AllocatedImage(descriptor, location, this);
            this._locations.set(descriptor.id, image);
            return image;
        }
        return null;
    }
    removeImage(image) {
        const location = this._locations.get(image.id);
        if (location) {
            this.atlas.removeImage(location.bbox);
            this._locations.delete(image.id);
        }
    }
    contains(id) {
        return this._locations.has(id);
    }
    reserveLocation(descriptor) {
        const location = this.atlas.reserveLocation(descriptor);
        if (location) {
            const image = new AllocatedImage(descriptor, location, this);
            this._locations.set(descriptor.id, image);
            return image;
        }
        return null;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = IdentifiedImageAtlasManager;



/***/ }),
/* 76 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Font is just a collection of glyph descriptions.
 */
class Font {
    /**
     * @param id Font id.
     * @param xheight The height of the "x" char in abstract points, in fact is used a the font size.
     * @param unknownGlyphInstance An instance of glyph to be served as a stub when nonexistent glyph
     *     is requested. Requesting nonexistent glyphs normally should not happen.
     *     The stub just allows to avoid tedious null checks in font clients.
     */
    constructor(id, xheight, unknownGlyphInstance) {
        this.id = id;
        this.xheight = xheight;
        this._unknownGlyphInstance = unknownGlyphInstance;
        this._glyphs = new Map();
    }
    /**
     * @return Glyph with specified id or unknown glyph instance.
     */
    getGlyph(glyphId) {
        const glyph = this._glyphs.get(glyphId);
        if (glyph) {
            return glyph;
        }
        else {
            console.warn('Wow-wow-wow, something went wrong, you should not request nonexistent glyphs');
            return this._unknownGlyphInstance;
        }
    }
    /**
     * @returns All stored glyphs.
     */
    getAllGlyphs() {
        return [...this._glyphs.values()];
    }
    /**
     * Adds glyph description.
     */
    addGlyph(glyph) {
        this._glyphs.set(glyph.id, glyph);
    }
    /**
     * Adds glyph descriptions from the iterable.
     */
    addAllGlyphs(glyphs) {
        for (const glyph of glyphs) {
            this.addGlyph(glyph);
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Font;



/***/ }),
/* 77 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__billboard_image_provider__ = __webpack_require__(78);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_hd__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_hosts__ = __webpack_require__(79);



/**
 * Image provider that gets images from specific API entry point.
 */
class ApiImageProvider extends __WEBPACK_IMPORTED_MODULE_0__billboard_image_provider__["a" /* ImageProvider */] {
    constructor(imageUrlTemplate) {
        super();
        this._imageUrlTemplate = imageUrlTemplate;
    }
    getImageUrl(id) {
        // API can return scaled images that allows us to request images according
        // to user's DPI and render them properly, non-integer numbers are accepted.
        return this._imageUrlTemplate
            .replace('{{hostAlias}}', Object(__WEBPACK_IMPORTED_MODULE_2__util_hosts__["a" /* getHostAliasByUid */])(id))
            .replace(/\{\{id\}\}/g, id)
            .replace('{{scale}}', Object(__WEBPACK_IMPORTED_MODULE_1__util_hd__["a" /* default */])().toString());
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ApiImageProvider;



/***/ }),
/* 78 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Abstract image content provider, concrete implementations should specify the entry point in getImageUrl().
 */
class ImageProvider {
    /**
     * Gets image bitmap via an HTMLImageElement and a canvas.
     */
    getImage(id) {
        return new Promise((resolve, reject) => {
            const imageElement = new Image();
            imageElement.crossOrigin = 'anonymous';
            imageElement.onload = () => resolve(imageElement);
            imageElement.onerror = reject;
            imageElement.src = this.getImageUrl(id);
        });
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ImageProvider;



/***/ }),
/* 79 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = getHostAliasByUid;
const HOST_ALIASES_N = 4;
function getHostAliasByUid(uid) {
    let sum = 0;
    for (let i = 0; i < uid.length; i++) {
        sum += uid.charCodeAt(i);
    }
    return (sum % HOST_ALIASES_N + 1).toString();
}


/***/ }),
/* 80 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_buffer_writer__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__textured_polyline_geometry__ = __webpack_require__(81);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__util_z_index__ = __webpack_require__(30);




/**
 * Writer of geometry data of polyline hulls.
 */
class TexturedPolylineBufferWriter extends __WEBPACK_IMPORTED_MODULE_1__util_buffer_writer__["b" /* default */] {
    constructor() {
        super(TexturedPolylineBufferWriter.ATTRIBUTE_MAPPING.vertexByteSize);
    }
    /**
     * Generates a hull for a polyline and writes it to the writer.
     *
     * @param polyline The polyline to be written.
     * @param width Thickness of the polyline.
     * @param worldToPxFactor Ratio of world coordinates to pixels.
     * @param imageLocation Image location in atlas.
     * @param zIndex Z-index of the polyline.
     */
    writeTexturedPolyline(polyline, width, worldToPxFactor, imageLocation, zIndex) {
        Object(__WEBPACK_IMPORTED_MODULE_2__textured_polyline_geometry__["a" /* default */])(this, polyline.vertices, worldToPxFactor, imageLocation, width, Object(__WEBPACK_IMPORTED_MODULE_3__util_z_index__["a" /* intToZIndex */])(zIndex + 1));
        return this.endMesh();
    }
    /**
     * Writes a vertex to the vertex buffer.
     *
     * @param position Position of the vertex in world coordinates.
     * @param displacement Displacement vector, in most cases must be normalized, the width is considered in shaders.
     * @param halfWidth Thickness of the polyline.
     * @param patterWidth Width of the image that is repeated along the polyline.
     * @param patternHalfHeight Image half height multiplied by `sign(s)`, where `s` is a [-1; 1] distance to the
     * analytical polyline along segment's normal.
     * @param length Length of the polyline for current vertex, needed to correctly calculate image uv x coordinate.
     * @param uv UV coordinates of the image.
     * @param zIndex Z-index of the polyline.
     *
     * @return Index of the written vertex.
     */
    writeVertex(position, displacement, halfWidth, patternWidth, patternHalfHeight, length, uv, zIndex) {
        const vertexIdx = this.getCurrentVertexIdx();
        this._writeWorldCoordinate(position);
        this._writeFloat32(displacement.x);
        this._writeFloat32(displacement.y);
        this._writeHalfWords(uv.x, uv.y);
        this._writeFloat32(zIndex);
        this._writeFloat32(halfWidth);
        this._writeHalfWords(patternWidth, length);
        this._writeFloat32(patternHalfHeight);
        return vertexIdx;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = TexturedPolylineBufferWriter;

/** Description of how a writer stores vertex data. */
TexturedPolylineBufferWriter.ATTRIBUTE_MAPPING = new __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__["a" /* AttributeMapping */]([
    [
        0 /* POSITION_HIGH */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        1 /* POSITION_LOW */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        6 /* DISPLACEMENT */,
        {
            size: 2,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        4 /* UV */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: false
        }
    ],
    [
        9 /* PRIORITY */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        11 /* AUX */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        12 /* AUX1 */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: false
        }
    ],
    [
        13 /* AUX2 */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ]
]);


/***/ }),
/* 81 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = writeTexturedPolylineGeometry;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_vector2__ = __webpack_require__(1);

/**
 * Writes polyline image geometry (set of triangles that draw up a solid thick polyline) into a buffer writer.
 *
 * @param writer Output buffer writer.
 * @param polyline Polyline to be written.
 * @param worldToPxFactor Ratio of world coordinates to pixels.
 * @param imageLocation Image location in atlas.
 * @param width Thickness of the polyline.
 * @param z Z-index of the polyline.
 */
function writeTexturedPolylineGeometry(writer, polyline, worldToPxFactor, imageLocation, width, z) {
    const hWidth = width / 2;
    const patternWidth = imageLocation.maxX - imageLocation.minX;
    const patternHalfHeight = (imageLocation.maxY - imageLocation.minY) / 2;
    const segment = __WEBPACK_IMPORTED_MODULE_0__math_vector2__["f" /* create */](0, 0);
    const dir = __WEBPACK_IMPORTED_MODULE_0__math_vector2__["f" /* create */](0, 0);
    const prevDir = __WEBPACK_IMPORTED_MODULE_0__math_vector2__["f" /* create */](0, 0);
    const norm = __WEBPACK_IMPORTED_MODULE_0__math_vector2__["f" /* create */](0, 0);
    const normInv = __WEBPACK_IMPORTED_MODULE_0__math_vector2__["f" /* create */](0, 0);
    const uv = __WEBPACK_IMPORTED_MODULE_0__math_vector2__["f" /* create */](imageLocation.minX, 0);
    let prevBottomRight = -1;
    let prevTopRight = -1;
    let length = 0;
    let prevLength = 0;
    for (let i = 1; i < polyline.length; i++) {
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["s" /* sub */](polyline[i], polyline[i - 1], segment);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["q" /* normalize */](segment, dir);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["r" /* rotate90 */](dir, norm);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["p" /* muln */](norm, -1, normInv);
        // segment is written as a rectangle (two triangles)
        uv.y = imageLocation.minY;
        const topLeft = writer.writeVertex(polyline[i - 1], norm, hWidth, patternWidth, patternHalfHeight, length, uv, z);
        uv.y = imageLocation.maxY;
        const bottomLeft = writer.writeVertex(polyline[i - 1], normInv, hWidth, patternWidth, -patternHalfHeight, length, uv, z);
        // update length of the polyline in pixels
        length += __WEBPACK_IMPORTED_MODULE_0__math_vector2__["o" /* length */](segment) / worldToPxFactor;
        uv.y = imageLocation.minY;
        const topRight = writer.writeVertex(polyline[i], norm, hWidth, patternWidth, patternHalfHeight, length, uv, z);
        uv.y = imageLocation.maxY;
        const bottomRight = writer.writeVertex(polyline[i], normInv, hWidth, patternWidth, -patternHalfHeight, length, uv, z);
        // write line join that fills an empty space on corners
        if (1 < i && i < polyline.length) {
            uv.y = (imageLocation.maxY + imageLocation.minY) / 2;
            const joinPointIndex = writer.writeVertex(polyline[i - 1], __WEBPACK_IMPORTED_MODULE_0__math_vector2__["a" /* ZERO */], hWidth, patternWidth, 0, prevLength, uv, z);
            // find out where the fracture of segments is located to create correct join with minimum overdraw
            const turnLeft = __WEBPACK_IMPORTED_MODULE_0__math_vector2__["i" /* crossZ */](prevDir, dir) > 0;
            if (turnLeft) {
                writer.writeIndices([
                    joinPointIndex, bottomLeft, prevBottomRight
                ]);
            }
            else {
                writer.writeIndices([
                    joinPointIndex, prevTopRight, topLeft
                ]);
            }
        }
        writer.writeIndices([
            topLeft, topRight, bottomLeft,
            topRight, bottomRight, bottomLeft
        ]);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["e" /* copy */](dir, prevDir);
        prevBottomRight = bottomRight;
        prevTopRight = topRight;
        prevLength = length;
    }
}


/***/ }),
/* 82 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Manages allocation of requested images. The same images can be requested multiple times from different places,
 * this class takes over duplication of HTTP requests/atlas allocations providing simple async interface for
 * getting allocated images.
 */
class ImageManager {
    constructor(atlas, provider) {
        this._atlas = atlas;
        this._provider = provider;
        this._requests = new Map();
    }
    /**
     * Returns image if it is already allocated. Pay attention that resulted allocated image is "retained",
     * so it must be released once it is passed to a responsible client.
     */
    getImage(id) {
        const image = this._atlas.getImage(id, true);
        if (image) {
            image.retain();
        }
        return image;
    }
    /**
     * Request image from image provider, if it is already allocated no request is made, but it is returned
     * wrapped into a resolved promise. Pay attention that resulted allocated image is "retained", so it must be
     * released once it is passed to a responsible client.
     */
    requestImage(id) {
        const allocatedImage = this._atlas.getImage(id, true);
        if (allocatedImage) {
            return Promise.resolve(allocatedImage);
        }
        else {
            const request = this._requests.get(id);
            if (request) {
                request.then((allocatedImage) => allocatedImage && allocatedImage.retain());
                return request;
            }
            else {
                const request = this._provider
                    .getImage(id)
                    .then((image) => {
                    this._requests.delete(id);
                    const { width, height } = image;
                    const allocatedImage = this._atlas.allocateImage({ id, width, height }, image);
                    if (!allocatedImage) {
                        throw new Error('Couldn\' allocated image');
                    }
                    else {
                        return allocatedImage;
                    }
                }, () => {
                    this._requests.delete(id);
                    throw new Error('Image request failed');
                });
                this._requests.set(id, request);
                return request;
            }
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ImageManager;



/***/ }),
/* 83 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_buffer_rewriter__ = __webpack_require__(84);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__textured_polygon_attribute_mapping__ = __webpack_require__(31);


class TexturedPolygonBufferRewriter extends __WEBPACK_IMPORTED_MODULE_0__util_buffer_rewriter__["a" /* default */] {
    constructor(buffers) {
        super(__WEBPACK_IMPORTED_MODULE_1__textured_polygon_attribute_mapping__["a" /* TEXTURED_POLYGON_ATTRIBUTE_MAPPING */], buffers);
    }
    /**
     * @param location Location of the polygon in memory.
     * @param imageLocation Location of the pattern in atlas.
     * @param imageScale How world coordinates relate to the image size.
     */
    rewriteUV(location, imageLocation, imageScale) {
        const uvOffset = this._getAttribOffset(4 /* UV */);
        const scaleOffset = this._getAttribOffset(11 /* AUX */);
        this._forEachVertex(location, (writer) => {
            writer.writeHalfWords(uvOffset, imageLocation.minX, imageLocation.minY);
            writer.writeHalfWords(uvOffset + 1, imageLocation.maxX - imageLocation.minX, imageLocation.maxY - imageLocation.minY);
            writer.writeFloat32(scaleOffset, imageScale);
        });
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = TexturedPolygonBufferRewriter;



/***/ }),
/* 84 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__buffer_writer__ = __webpack_require__(6);

/**
 * Class that is exposed as an interface for writing to a specific vertex attribute.
 */
class VertexWriter {
    constructor(vertexBuffer) {
        this._vertexBuffer = new Uint32Array(vertexBuffer.buffer, 0, vertexBuffer.length);
        this._vertexBufferFloat32View = new Float32Array(vertexBuffer.buffer, 0, vertexBuffer.length);
    }
    /**
     * Writes float attribute into specific position in buffer.
     *
     * @param attribOffset Offset of an attribute in words (4 bytes), get it from BufferRewriter#_getAttribOffset().
     * @param value Value to be written.
     */
    writeFloat32(attribOffset, value) {
        this._vertexBufferFloat32View[this.vertexOffset + attribOffset] = value;
    }
    /**
     * Writes a word attribute into specific position in buffer.
     *
     * @param attribOffset Offset of an attribute in words (4 bytes), get it from BufferRewriter#_getAttribOffset().
     * @param value Value to be written.
     */
    writeWord(attribOffset, value) {
        this._vertexBuffer[this.vertexOffset + attribOffset] = value;
    }
    /**
     * Writes two half word attribute values into specific position in buffer.
     *
     * @param attribOffset Offset of an attribute in words (4 bytes), get it from BufferRewriter#_getAttribOffset().
     * @param value Value to be written.
     */
    writeHalfWords(attribOffset, v1, v2) {
        this.writeWord(attribOffset, v2 << 16 | v1 & 0xffff);
    }
}
/**
 * Provides some utils for rewriting vertex attribute values, see VertexWriter and tests for some tips of how to do it.
 * TODO: consider supporting of separate buffers for different attributes, that will make this class less useful
 */
class BufferRewriter {
    constructor(attribMapping, buffers) {
        this._attribMapping = attribMapping;
        this._buffers = buffers;
    }
    /**
     * Walks over all vertices exposing VertexWriter for each one by calling the handler argument.
     */
    _forEachVertex(location, handler) {
        const vertexWriter = new VertexWriter(this._buffers[location.bufferIndex].vertexBuffer);
        const vertexByteSize = this._attribMapping.vertexByteSize;
        for (let i = 0; i < location.vertexByteLength; i += vertexByteSize) {
            vertexWriter.vertexOffset = (location.vertexByteOffset + i) / __WEBPACK_IMPORTED_MODULE_0__buffer_writer__["a" /* WORD_BYTE_SIZE */];
            handler(vertexWriter);
        }
    }
    /**
     * @returns Offset in words (4 bytes) of specific attribute in a vertex (format is defined by AttributeMapping).
     */
    _getAttribOffset(attrib) {
        const attribPointer = this._attribMapping.get(attrib);
        return attribPointer ? attribPointer.offset / __WEBPACK_IMPORTED_MODULE_0__buffer_writer__["a" /* WORD_BYTE_SIZE */] : -1;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = BufferRewriter;



/***/ }),
/* 85 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__ = __webpack_require__(3);

/** Description of how a writer stores vertex data. */
const BILLBOARD_RECTANGLE_ATTRIBUTE_MAPPING = new __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__["a" /* AttributeMapping */]([
    [
        2 /* ID */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        0 /* POSITION_HIGH */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        1 /* POSITION_LOW */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        6 /* DISPLACEMENT */,
        {
            size: 2,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        4 /* UV */,
        {
            size: 2,
            type: 5122 /* SHORT */,
            normalized: true
        }
    ],
    [
        7 /* COLOR */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        11 /* AUX */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ]
]);
/* harmony export (immutable) */ __webpack_exports__["a"] = BILLBOARD_RECTANGLE_ATTRIBUTE_MAPPING;



/***/ }),
/* 86 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__ = __webpack_require__(3);

/** Description of how a writer stores vertex data. */
const POINT_LABEL_ATTRIBUTE_MAPPING = new __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__["a" /* AttributeMapping */]([
    [
        2 /* ID */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        0 /* POSITION_HIGH */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        1 /* POSITION_LOW */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        6 /* DISPLACEMENT */,
        {
            size: 2,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        4 /* UV */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: false
        }
    ],
    [
        7 /* COLOR */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        8 /* OUTLINE_COLOR */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        9 /* PRIORITY */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        11 /* AUX */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ]
]);
/* harmony export (immutable) */ __webpack_exports__["a"] = POINT_LABEL_ATTRIBUTE_MAPPING;



/***/ }),
/* 87 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__ = __webpack_require__(3);

/** Description of how a writer stores vertex data. */
const CURVED_LABEL_ATTRIBUTE_MAPPING = new __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__["a" /* AttributeMapping */]([
    [
        2 /* ID */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        0 /* POSITION_HIGH */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        1 /* POSITION_LOW */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        6 /* DISPLACEMENT */,
        {
            size: 3,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        4 /* UV */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: false
        }
    ],
    [
        7 /* COLOR */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        8 /* OUTLINE_COLOR */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        9 /* PRIORITY */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        12 /* AUX1 */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        13 /* AUX2 */,
        {
            size: 4,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        14 /* AUX3 */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        15 /* AUX4 */,
        {
            size: 4,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        11 /* AUX */,
        {
            size: 2,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ]
]);
/* harmony export (immutable) */ __webpack_exports__["a"] = CURVED_LABEL_ATTRIBUTE_MAPPING;



/***/ }),
/* 88 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_worker__ = __webpack_require__(17);

class TileProviderWorkerClient extends __WEBPACK_IMPORTED_MODULE_0__util_worker__["b" /* WebWorkerClient */] {
}
/* harmony export (immutable) */ __webpack_exports__["a"] = TileProviderWorkerClient;



/***/ }),
/* 89 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = extractTransferables;
/**
 * Extract ArrayBuffers (that are tansferable) from pages.
 */
function extractTransferables(pages, output) {
    for (const page of pages) {
        output.push(page.vertexBuffer.buffer, page.indexBuffer.buffer);
    }
}


/***/ }),
/* 90 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__polygon_attribute_mapping__ = __webpack_require__(32);


/**
 * Description of how attributes of vertices are packed into a vertex buffer.
 */
const TRANSPARENT_POLYGON_ATTRIBUTE_MAPPING = new __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__["a" /* AttributeMapping */](__WEBPACK_IMPORTED_MODULE_1__polygon_attribute_mapping__["a" /* POLYGON_ATTRIBUTE_MAPPING */]);
/* harmony export (immutable) */ __webpack_exports__["a"] = TRANSPARENT_POLYGON_ATTRIBUTE_MAPPING;



/***/ }),
/* 91 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__priority_queue__ = __webpack_require__(35);

const MAX_DEQUEUE_TIMEOUT = 1000; // ms
// TODO: remove this shim when all supported browsers implement it
const SHIMMED_PROCESSING_DURATION_MS = 25;
window.cancelIdleCallback = window.cancelIdleCallback || window.clearTimeout;
window.requestIdleCallback = window.requestIdleCallback || function (handler) {
    const startTime = performance.now();
    return setTimeout(() => {
        handler({
            didTimeout: false,
            timeRemaining: () => Math.max(0, SHIMMED_PROCESSING_DURATION_MS - (performance.now() - startTime))
        });
    });
};
/**
 * It is a task queue. Tasks are dequeued during idle period.
 */
class IdleTaskQueue {
    constructor() {
        this._queue = new __WEBPACK_IMPORTED_MODULE_0__priority_queue__["a" /* default */]();
        this._dequeueIdleHandle = 0;
    }
    destroy() {
        cancelIdleCallback(this._dequeueIdleHandle);
    }
    /**
     * Enqueues a task to the queue.
     *
     * @param task The task.
     */
    enqueue(task) {
        this._queue.enqueue(task);
        this._run();
    }
    _dequeue(deadline) {
        const queue = this._queue;
        if (queue.isEmpty()) {
            return;
        }
        if (deadline.didTimeout) {
            queue.dequeue().execute();
        }
        else {
            while (deadline.timeRemaining() && !queue.isEmpty()) {
                queue.dequeue().execute();
            }
        }
        this._dequeueIdleHandle = 0;
        if (!this._queue.isEmpty()) {
            this._run();
        }
    }
    _run() {
        if (!this._dequeueIdleHandle) {
            this._dequeueIdleHandle = requestIdleCallback((deadline) => {
                this._dequeue(deadline);
            }, { timeout: MAX_DEQUEUE_TIMEOUT });
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = IdleTaskQueue;



/***/ }),
/* 92 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__array__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__comparator__ = __webpack_require__(19);


/**
 * Computes index of the parent of an item.
 *
 * @param idx Index of the item.
 * @returns Index of the parent.
 */
function getParentIdx(idx) {
    return (idx + 1 >> 1) - 1;
}
/**
 * Computes index of the left child of an item.
 *
 * @param idx Index of the item.
 * @returns Index of the child.
 */
function getFirstChildIdx(idx) {
    return (idx + 1 << 1) - 1;
}
class BinaryHeap {
    /**
     * Constructs a new empty heap. Order of items in the heap will be defined
     * by a given comparator.
     *
     * @param comparator The comparator.
     */
    constructor(comparator = __WEBPACK_IMPORTED_MODULE_1__comparator__["a" /* DEFAULT_COMPARATOR */]) {
        // TODO(dmikis) Investigate preallocation.
        this._items = [];
        this._comparator = comparator;
    }
    /**
     * Inserts an item into the heap.
     *
     * @param item The item to be inserted.
     */
    insert(item) {
        const items = this._items;
        const comparator = this._comparator;
        // Insert the new item as bottom right-most child of the heap.
        let idx = items.push(item) - 1;
        let parentIdx = getParentIdx(idx);
        // Walk the heap upward and restore heap property on the way.
        while (parentIdx > -1 &&
            comparator(items[idx], items[parentIdx]) > 0) {
            Object(__WEBPACK_IMPORTED_MODULE_0__array__["c" /* swap */])(items, idx, parentIdx);
            idx = parentIdx;
            parentIdx = getParentIdx(idx);
        }
    }
    /**
     * Removes "maximum" item from the head.
     *
     * @returns The removed item or `undefined` is the heap's empty.
     */
    pop() {
        const items = this._items;
        if (items.length === 0) {
            return undefined;
        }
        const newSize = items.length - 1;
        // Place max item at the end of the items array.
        Object(__WEBPACK_IMPORTED_MODULE_0__array__["c" /* swap */])(items, 0, newSize);
        // Walk downward from the new root to restore heap property.
        let idx = 0;
        let childIdx = 1;
        const comparator = this._comparator;
        while (childIdx < newSize) {
            if (childIdx + 1 < newSize &&
                comparator(items[childIdx], items[childIdx + 1]) < 0) {
                childIdx += 1;
            }
            if (comparator(items[idx], items[childIdx]) > 0) {
                break;
            }
            Object(__WEBPACK_IMPORTED_MODULE_0__array__["c" /* swap */])(items, idx, childIdx);
            idx = childIdx;
            childIdx = getFirstChildIdx(childIdx);
        }
        // Remove previously placed at the end previous max item.
        return items.pop();
    }
    /**
     * @returns "Maximum" item in the heap or `undefined` if the head is empty.
     */
    peek() {
        return this._items[0];
    }
    /**
     * @returns Iterator over all items in the heap. Note that order of items
     *      is undefined.
     */
    *[Symbol.iterator]() {
        for (const item of this._items) {
            yield item;
        }
    }
    /**
     * @returns Number of items in the heap.
     */
    get size() {
        return this._items.length;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = BinaryHeap;



/***/ }),
/* 93 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__renderable_primitive__ = __webpack_require__(7);

/**
 * Allocated in GPU memory polygon.
 */
class RenderablePolygon extends __WEBPACK_IMPORTED_MODULE_0__renderable_primitive__["a" /* default */] {
    constructor(memorySubChunk, isOpaque) {
        super(memorySubChunk);
        this.isOpaque = isOpaque;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RenderablePolygon;



/***/ }),
/* 94 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__renderable_primitive__ = __webpack_require__(7);

class RenderableTexturedPolygon extends __WEBPACK_IMPORTED_MODULE_0__renderable_primitive__["a" /* default */] {
    constructor(memoryChunk, allocatedImage) {
        super(memoryChunk);
        this._allocatedImage = allocatedImage;
        this.atlas = allocatedImage.atlasManager.atlas;
        allocatedImage.retain();
    }
    _destroy() {
        this._allocatedImage.release();
        super._destroy();
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RenderableTexturedPolygon;



/***/ }),
/* 95 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__renderable_polyline__ = __webpack_require__(36);

class RenderableTexturedPolyline extends __WEBPACK_IMPORTED_MODULE_0__renderable_polyline__["a" /* default */] {
    constructor(memoryChunk, allocatedImage) {
        super(memoryChunk);
        this._allocatedImage = allocatedImage;
        this.atlas = allocatedImage.atlasManager.atlas;
        allocatedImage.retain();
    }
    _destroy() {
        this._allocatedImage.release();
        super._destroy();
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RenderableTexturedPolyline;



/***/ }),
/* 96 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
const POLYGON_EXTRACTOR = (data) => flat(map('polygons', data));
/* harmony export (immutable) */ __webpack_exports__["f"] = POLYGON_EXTRACTOR;

const TEXTURED_POLYGON_EXTRACTOR = (data) => flat(map('texturedPolygons', data));
/* harmony export (immutable) */ __webpack_exports__["h"] = TEXTURED_POLYGON_EXTRACTOR;

const POLYLINE_EXTRACTOR = (data) => flat(map('polylines', data));
/* harmony export (immutable) */ __webpack_exports__["g"] = POLYLINE_EXTRACTOR;

const TEXTURED_POLYLINE_EXTRACTOR = (data) => flat(map('texturedPolylines', data));
/* harmony export (immutable) */ __webpack_exports__["i"] = TEXTURED_POLYLINE_EXTRACTOR;

const POINT_EXTRACTOR = (data) => flat(map('points', data));
/* harmony export (immutable) */ __webpack_exports__["d"] = POINT_EXTRACTOR;

const POINT_LABEL_EXTRACTOR = (data) => flat(map('pointLabels', data));
/* harmony export (immutable) */ __webpack_exports__["e"] = POINT_LABEL_EXTRACTOR;

const CURVED_LABEL_EXTRACTOR = (data) => flat(map('curvedLabels', data));
/* harmony export (immutable) */ __webpack_exports__["a"] = CURVED_LABEL_EXTRACTOR;

const MODEL_EXTRACTOR = (data) => flat(map('models', data));
/* harmony export (immutable) */ __webpack_exports__["c"] = MODEL_EXTRACTOR;

const EXTERNAL_MESH_EXTRACTOR = (data) => flat(map('externalMeshes', data));
/* harmony export (immutable) */ __webpack_exports__["b"] = EXTERNAL_MESH_EXTRACTOR;

/**
 * Maps list of TileData's into list of specified primitives.
 */
function* map(type, data) {
    for (const portion of data) {
        yield portion[type];
    }
}
/**
 * Flatten two dimensional list of primitives in a single dimensional one.
 */
function* flat(primitives) {
    for (const portion of primitives) {
        if (portion) {
            yield* portion;
        }
    }
}


/***/ }),
/* 97 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__renderable_primitive_manager__ = __webpack_require__(21);

/**
 * Polygons should be separated by opaqueness and there are two distinct primitive providers
 * for them: opaque and tansparent. That is what this manager takes care of.
 */
class PolygonManager extends __WEBPACK_IMPORTED_MODULE_0__renderable_primitive_manager__["a" /* default */] {
    constructor(opaquePolygonStorage, transparentPolygonStorage) {
        super(opaquePolygonStorage);
        this._opaquePolygonStorage = opaquePolygonStorage;
        this._transparentPolygonStorage = transparentPolygonStorage;
    }
    updateScene(toShow, toHide) {
        for (const primitive of toShow) {
            if (primitive.isOpaque) {
                this._opaquePolygonStorage.add(primitive);
            }
            else {
                this._transparentPolygonStorage.add(primitive);
            }
        }
        for (const primitive of toHide) {
            if (primitive.isOpaque) {
                this._opaquePolygonStorage.delete(primitive);
            }
            else {
                this._transparentPolygonStorage.delete(primitive);
            }
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = PolygonManager;



/***/ }),
/* 98 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_iterable__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__disappearing_primitive_set_storage__ = __webpack_require__(40);


/**
 * Primitive storage that stores primitive in a set. It acts as a primitive provider as well.
 */
class DelayedDisappearingPrimitiveSetStorage extends __WEBPACK_IMPORTED_MODULE_1__disappearing_primitive_set_storage__["a" /* default */] {
    constructor(appearingEffectDuration) {
        super();
        this._appearingEffectDuration = appearingEffectDuration;
        this._scheduledRemoves = new Map();
        this._timeoutIds = new Set();
    }
    get primitives() {
        return this._primitiveSet;
    }
    add(...primitives) {
        // primitives that are scheduled for removing was not removed "physically", that is why
        // they should be filtered out to prevent multiple adding of the same primitive in parent
        const notScheduledForRemovePrimitives = [];
        for (const primitive of primitives) {
            const primitivesToDelete = this._scheduledRemoves.get(primitive);
            if (primitivesToDelete) {
                // if this primitive is scheduled for removing it is deleted from its batch,
                // thus canceling the removing in the callback
                primitivesToDelete.delete(primitive);
                this._scheduledRemoves.delete(primitive);
            }
            else {
                notScheduledForRemovePrimitives.push(primitive);
            }
        }
        super.add(...notScheduledForRemovePrimitives);
        this.show(...notScheduledForRemovePrimitives);
    }
    delete(...primitives) {
        this.hide(...primitives);
        // primitives are batched in a set to be deleted in one setTimeout callback for performance,
        // filter out primitives which removing was already scheduled
        const primitivesToDelete = new Set(Object(__WEBPACK_IMPORTED_MODULE_0__util_iterable__["b" /* filterIterable */])(primitives, (primitive) => !this._scheduledRemoves.has(primitive)));
        if (primitivesToDelete.size > 0) {
            const timeoutId = setTimeout(() => {
                // primitivesToDelete contains relevant for removing primitives, it can be updated in the add() method
                // if a primitive is added back, thus, in fact, canceling removing of this specific primitive
                super.delete(...primitivesToDelete);
                for (const primitive of primitivesToDelete) {
                    this._scheduledRemoves.delete(primitive);
                }
                this._timeoutIds.delete(timeoutId);
            }, this._appearingEffectDuration);
            for (const primitive of primitivesToDelete) {
                this._scheduledRemoves.set(primitive, primitivesToDelete);
            }
            this._timeoutIds.add(timeoutId);
        }
    }
    destroy() {
        for (const timeoutId of this._timeoutIds) {
            clearTimeout(timeoutId);
        }
    }
    _isAllowedToShowPrimitive(primitive) {
        return super._isAllowedToShowPrimitive(primitive) && !this._scheduledRemoves.has(primitive);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = DelayedDisappearingPrimitiveSetStorage;



/***/ }),
/* 99 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__renderable_primitive_manager__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_iterable__ = __webpack_require__(8);


/**
 * It is required to hide some primitives (that don't scale with zoom, e.g. labels or icons) by "too irrelevant" zoom,
 * to prevent mess of collapsed objects on the screen. This primitive manager is a temporary solution,
 * proper handling of zoom slices will replace it.
 */
// TODO: this manager is a tmp solution, correct handling of zoom slices is going to replace it
class ZoomFilterablePrimitiveManager extends __WEBPACK_IMPORTED_MODULE_0__renderable_primitive_manager__["a" /* default */] {
    constructor(primitivesStorage, camera) {
        super(primitivesStorage);
        this._disappearingPrimitivesStorage = primitivesStorage;
        this._camera = camera;
        this._primitives = new Set();
        this._prevZoom = camera.zoom;
        this._zoomUpdateListener = this._onZoomUpdated.bind(this);
        this._camera.onUpdate.addListener(this._zoomUpdateListener);
    }
    updateScene(toShow, toHide) {
        // save primitives to filter them later
        super.updateScene(Object(__WEBPACK_IMPORTED_MODULE_1__util_iterable__["c" /* mapIterable */])(toShow, (primitive) => {
            this._primitives.add(primitive);
            return primitive;
        }), Object(__WEBPACK_IMPORTED_MODULE_1__util_iterable__["c" /* mapIterable */])(toHide, (primitive) => {
            this._primitives.delete(primitive);
            return primitive;
        }));
        // check if there are added primitives that could be removed by zoom restrictions
        this._updateZoomVisibility();
    }
    _onZoomUpdated() {
        if (this._prevZoom !== this._camera.zoom) {
            this._updateZoomVisibility();
            this._prevZoom = this._camera.zoom;
        }
    }
    _updateZoomVisibility() {
        const zoom = this._camera.zoom;
        this._disappearingPrimitivesStorage.show(...Object(__WEBPACK_IMPORTED_MODULE_1__util_iterable__["b" /* filterIterable */])(this._primitives, ({ minZoom }) => zoom >= minZoom));
        this._disappearingPrimitivesStorage.hide(...Object(__WEBPACK_IMPORTED_MODULE_1__util_iterable__["b" /* filterIterable */])(this._primitives, ({ minZoom }) => zoom < minZoom));
    }
    destroy() {
        this._camera.onUpdate.removeListener(this._zoomUpdateListener);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ZoomFilterablePrimitiveManager;



/***/ }),
/* 100 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__worker_tile_provider_worker_messages__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__render_memory_sub_chunk__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__primitive_model_model_buffer_writer__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__primitive_manager__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__primitive_model_renderable_model__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__util_worker__ = __webpack_require__(17);






/**
 * External meshes come in polygons (kind of building outlines). This manager controls quering external meshes
 * according to added polygons, as many of them can share the same mesh (usually across multiple tiles).
 */
class ExternalMeshPrimitiveManager extends __WEBPACK_IMPORTED_MODULE_3__primitive_manager__["a" /* default */] {
    constructor(primitivesStorage, geometryProvider, memoryManager) {
        super();
        this._primitivesStorage = primitivesStorage;
        this._tileProvider = geometryProvider;
        this._memoryManager = memoryManager;
        this._externalMeshes = new Map();
    }
    updateScene(toShow, toHide) {
        for (const primitive of toShow) {
            this._addPrimitive(primitive);
        }
        for (const primitive of toHide) {
            this._removePrimitive(primitive);
        }
    }
    _addPrimitive(primitive) {
        const id = getFullMeshId(primitive);
        let external = this._externalMeshes.get(id);
        if (!external) {
            external = {
                visiblePolygons: new Set(),
                isVisible: false
            };
            this._externalMeshes.set(id, external);
            this._tileProvider.request({
                type: __WEBPACK_IMPORTED_MODULE_0__worker_tile_provider_worker_messages__["a" /* TileProviderMessageType */].MESH_REQUEST,
                responseType: __WEBPACK_IMPORTED_MODULE_0__worker_tile_provider_worker_messages__["a" /* TileProviderMessageType */].MESH_RESPONSE,
                errorType: __WEBPACK_IMPORTED_MODULE_0__worker_tile_provider_worker_messages__["a" /* TileProviderMessageType */].MESH_ERROR,
                mesh: primitive,
                requestId: __WEBPACK_IMPORTED_MODULE_5__util_worker__["a" /* NO_ID */]
            }).then((response) => {
                const external = this._externalMeshes.get(id);
                if (external && !external.isVisible) {
                    const location = response.location;
                    const chunks = response.pages.map((page) => this._memoryManager.allocate(page.vertexBuffer, page.indexBuffer, __WEBPACK_IMPORTED_MODULE_2__primitive_model_model_buffer_writer__["a" /* default */].ATTRIBUTE_MAPPING));
                    external.mesh = new __WEBPACK_IMPORTED_MODULE_4__primitive_model_renderable_model__["a" /* default */](new __WEBPACK_IMPORTED_MODULE_1__render_memory_sub_chunk__["a" /* default */](chunks[location.bufferIndex], location));
                    external.isVisible = true;
                    this._primitivesStorage.add(external.mesh);
                    chunks.forEach((chunk) => chunk.release());
                }
            });
        }
        external.visiblePolygons.add(primitive);
    }
    _removePrimitive(primitive) {
        const id = getFullMeshId(primitive);
        const external = this._externalMeshes.get(id);
        if (external) {
            external.visiblePolygons.delete(primitive);
            // destroy external mesh if there is no visible polygons remaining
            if (external.visiblePolygons.size === 0) {
                this._externalMeshes.delete(id);
                if (external.mesh) {
                    external.mesh.release();
                    this._primitivesStorage.delete(external.mesh);
                    external.isVisible = false;
                }
                else {
                    // if no mesh yet returned cancel request
                    this._tileProvider.sendMessage({
                        type: __WEBPACK_IMPORTED_MODULE_0__worker_tile_provider_worker_messages__["a" /* TileProviderMessageType */].MESH_REQUEST_CANCEL,
                        mesh: primitive
                    });
                }
            }
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ExternalMeshPrimitiveManager;

function getFullMeshId(mesh) {
    return mesh.objectId + mesh.meshId;
}


/***/ }),
/* 101 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__renderable_primitive__ = __webpack_require__(7);

class RenderableBillboardRectangle extends __WEBPACK_IMPORTED_MODULE_0__renderable_primitive__["a" /* default */] {
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RenderableBillboardRectangle;



/***/ }),
/* 102 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__primitive_label_renderable_label__ = __webpack_require__(103);

class ZoomRestrictedLabel extends __WEBPACK_IMPORTED_MODULE_0__primitive_label_renderable_label__["a" /* default */] {
    constructor(memorySubChunk, atlas, minZoom, background) {
        super(memorySubChunk, atlas, background);
        this.minZoom = minZoom;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ZoomRestrictedLabel;



/***/ }),
/* 103 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__renderable_primitive__ = __webpack_require__(7);

/**
 * Allocated in GPU memory label.
 */
class RenderableLabel extends __WEBPACK_IMPORTED_MODULE_0__renderable_primitive__["a" /* default */] {
    /**
     * Constructs a new renderable label.
     *
     * @param memorySubChunk
     * @param atlas
     * @param background
     */
    constructor(memorySubChunk, atlas, background) {
        super(memorySubChunk);
        this.atlas = atlas;
        this.background = background;
        if (background) {
            background.retain();
        }
    }
    _destroy() {
        if (this.background) {
            this.background.release();
        }
        super._destroy();
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RenderableLabel;



/***/ }),
/* 104 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__primitive_icon_renderable_icon__ = __webpack_require__(105);

class ZoomRestrictedIcon extends __WEBPACK_IMPORTED_MODULE_0__primitive_icon_renderable_icon__["a" /* default */] {
    constructor(memorySubChunk, allocatedImage, minZoom) {
        super(memorySubChunk, allocatedImage);
        this.minZoom = minZoom;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ZoomRestrictedIcon;



/***/ }),
/* 105 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__image_renderable_image__ = __webpack_require__(106);

class RenderableIcon extends __WEBPACK_IMPORTED_MODULE_0__image_renderable_image__["a" /* default */] {
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RenderableIcon;



/***/ }),
/* 106 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__textured_renderable_primitive__ = __webpack_require__(107);

class RenderableImage extends __WEBPACK_IMPORTED_MODULE_0__textured_renderable_primitive__["a" /* default */] {
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RenderableImage;



/***/ }),
/* 107 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__renderable_primitive__ = __webpack_require__(7);

class TexturedRenderablePrimitive extends __WEBPACK_IMPORTED_MODULE_0__renderable_primitive__["a" /* default */] {
    constructor(memoryChunk, allocatedImage) {
        super(memoryChunk);
        this._allocatedImage = allocatedImage;
        this.atlas = allocatedImage.atlasManager.atlas;
        this._allocatedImage.retain();
    }
    _destroy() {
        this._allocatedImage.release();
        super._destroy();
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = TexturedRenderablePrimitive;



/***/ }),
/* 108 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__priority_queue__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_event_emitter__ = __webpack_require__(2);


const DEQUEUE_TIMEOUT = 1; // ms
/**
 * Prioritized task queue.
 */
class TaskQueue {
    /**
     * Constructs an empty task queue.
     */
    constructor() {
        this._queue = new __WEBPACK_IMPORTED_MODULE_0__priority_queue__["a" /* default */]();
        this._frozen = false;
        this._dequeueTimeoutHandle = 0;
        this.onEmpty = new __WEBPACK_IMPORTED_MODULE_1__util_event_emitter__["b" /* VoidEventEmitter */]();
    }
    /**
     * Destroys the queue. Any remaining tasks won't be executed.
     */
    destroy() {
        clearTimeout(this._dequeueTimeoutHandle);
    }
    /**
     * Enqueues a task to the queue and schedules processing of the queue.
     *
     * @param task The task.
     * @returns Promise that will be fullfilled when the task successfully
     *      finishes or rejected if there's an error.
     */
    enqueue(task) {
        if (!this._frozen) {
            this._setDequeueTimeout();
        }
        return new Promise((resolve, reject) => {
            this._queue.enqueue({
                execute() {
                    try {
                        task.execute();
                        resolve();
                    }
                    catch (error) {
                        reject(error);
                    }
                },
                priority: task.priority
            });
        });
    }
    isEmpty() {
        return this._queue.isEmpty();
    }
    freeze() {
        if (this._dequeueTimeoutHandle) {
            clearTimeout(this._dequeueTimeoutHandle);
            this._dequeueTimeoutHandle = 0;
        }
        this._frozen = true;
    }
    unfreeze() {
        this._frozen = false;
        if (!this._queue.isEmpty()) {
            this._setDequeueTimeout();
        }
    }
    _dequeue() {
        const task = this._queue.dequeue();
        if (task) {
            task.execute();
        }
        if (this._queue.isEmpty()) {
            this._dequeueTimeoutHandle = 0;
            this.onEmpty.fire();
        }
        else {
            this._dequeueTimeoutHandle = setTimeout(() => this._dequeue(), DEQUEUE_TIMEOUT);
        }
    }
    _setDequeueTimeout() {
        if (!this._dequeueTimeoutHandle) {
            this._dequeueTimeoutHandle = setTimeout(() => this._dequeue(), DEQUEUE_TIMEOUT);
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = TaskQueue;



/***/ }),
/* 109 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["d"] = renderCameraState;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_vector_render_engine_util_delegator__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_vector_render_engine_math_vector2__ = __webpack_require__(1);


class MouseDragController extends __WEBPACK_IMPORTED_MODULE_0__src_vector_render_engine_util_delegator__["a" /* DelegatorBase */] {
    constructor(target) {
        super();
        this._target = target;
        this._pressedButton = -1 /* NONE */;
        this._prevMouseCoords = __WEBPACK_IMPORTED_MODULE_1__src_vector_render_engine_math_vector2__["f" /* create */](0, 0);
        target.addEventListener('mousedown', this);
        target.addEventListener('click', this);
        target.addEventListener('contextmenu', this);
    }
    handleEvent(e) {
        switch (e.type) {
            case 'click':
            case 'contextmenu':
                e.preventDefault();
                break;
            case 'mousedown':
                if (this._pressedButton === -1 /* NONE */) {
                    this._pressedButton = e.button;
                    this._prevMouseCoords.x = e.clientX;
                    this._prevMouseCoords.y = e.clientY;
                    document.body.addEventListener('mousemove', this);
                    document.body.addEventListener('mouseup', this);
                }
                e.preventDefault();
                break;
            case 'mousemove':
                if (this._delegate === null) {
                    break;
                }
                const mouseCoords = __WEBPACK_IMPORTED_MODULE_1__src_vector_render_engine_math_vector2__["f" /* create */](e.clientX, e.clientY);
                const delta = __WEBPACK_IMPORTED_MODULE_1__src_vector_render_engine_math_vector2__["s" /* sub */](mouseCoords, this._prevMouseCoords);
                switch (this._pressedButton) {
                    case 0 /* LEFT */:
                        this._delegate.onLeftButtonDrag(delta);
                        break;
                    case 1 /* MIDDLE */:
                        this._delegate.onMiddleButtonDrag(delta);
                        break;
                    case 2 /* RIGHT */:
                        this._delegate.onRightButtonDrag(delta);
                        break;
                }
                __WEBPACK_IMPORTED_MODULE_1__src_vector_render_engine_math_vector2__["e" /* copy */](mouseCoords, this._prevMouseCoords);
                e.preventDefault();
                break;
            case 'mouseup':
                if (this._pressedButton === e.button) {
                    document.body.removeEventListener('mouseup', this);
                    document.body.removeEventListener('mousemove', this);
                    this._pressedButton = -1 /* NONE */;
                }
                e.preventDefault();
                break;
        }
    }
    destroy() {
        this._target.removeEventListener('contextmenu', this);
        this._target.removeEventListener('click', this);
        this._target.removeEventListener('mousedown', this);
    }
}
/* harmony export (immutable) */ __webpack_exports__["b"] = MouseDragController;

class ScrollZoomController extends __WEBPACK_IMPORTED_MODULE_0__src_vector_render_engine_util_delegator__["a" /* DelegatorBase */] {
    constructor(target) {
        super();
        this._target = target;
        target.addEventListener('wheel', this);
    }
    handleEvent(e) {
        const delegate = this._delegate;
        if (!delegate) {
            return;
        }
        if (e.deltaY < 0) {
            delegate.onScrollIn();
        }
        else {
            delegate.onScrollOut();
        }
        e.preventDefault();
    }
    destroy() {
        this._target.removeEventListener('wheel', this);
    }
}
/* harmony export (immutable) */ __webpack_exports__["c"] = ScrollZoomController;

const ZOOM_STEP = 0.1;
const TILT_AZIMUTH_FACTOR = Math.PI / 1024;
class CameraMouseController {
    constructor(canvas, camera) {
        this._camera = camera;
        this._canvasSize = __WEBPACK_IMPORTED_MODULE_1__src_vector_render_engine_math_vector2__["f" /* create */](canvas.width, canvas.height);
        this.dragFactor = 1;
    }
    onLeftButtonDrag(delta) {
        // That's not exact, but good enough for now.
        __WEBPACK_IMPORTED_MODULE_1__src_vector_render_engine_math_vector2__["l" /* divv */](delta, this._canvasSize, delta);
        const camera = this._camera;
        __WEBPACK_IMPORTED_MODULE_1__src_vector_render_engine_math_vector2__["p" /* muln */](delta, this.dragFactor * camera.screenSize.height * Math.pow(2, -camera.zoom) /
            (Math.tan(0.5 * camera.options.fov) * 64), delta);
        const center = this._camera.center;
        center.x -= delta.x;
        center.y += delta.y;
        this._camera.setDirty();
    }
    onMiddleButtonDrag() { }
    onRightButtonDrag(delta) {
        const camera = this._camera;
        camera.tilt += delta.y * TILT_AZIMUTH_FACTOR;
        camera.azimuth += delta.x * TILT_AZIMUTH_FACTOR;
        this._camera.setDirty();
    }
    onScrollIn() {
        this._camera.zoom += ZOOM_STEP;
        this._camera.setDirty();
    }
    onScrollOut() {
        this._camera.zoom -= ZOOM_STEP;
        this._camera.setDirty();
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = CameraMouseController;

const cameraStateElement = document.querySelector('#camera_state');
const cameraStateText = cameraStateElement && cameraStateElement.firstChild;
function renderCameraState(camera) {
    const { center: { x, y }, zoom, tilt, azimuth } = camera;
    cameraStateText.replaceData(0, cameraStateText.length, `center: (${x.toFixed(8)},${y.toFixed(8)}); zoom: ${zoom.toFixed(4)}; ` +
        `tilt: ${tilt.toFixed(4)}; azimuth: ${azimuth.toFixed(4)}`);
}


/***/ }),
/* 110 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_point_label_vert__ = __webpack_require__(111);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_point_label_vert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__shader_point_label_vert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_color_id_frag__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_color_id_frag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__shader_color_id_frag__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__color_id_label_renderer__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__render_primitives_label_point_label_render_unit__ = __webpack_require__(45);




/**
 * Point labels renderer for collision resolution.
 */
class ColorIdPointLabelRenderer extends __WEBPACK_IMPORTED_MODULE_2__color_id_label_renderer__["a" /* default */] {
    constructor(context, camera, primitiveProvider) {
        const program = context.createProgram(__WEBPACK_IMPORTED_MODULE_0__shader_point_label_vert___default.a, __WEBPACK_IMPORTED_MODULE_1__shader_color_id_frag___default.a, __WEBPACK_IMPORTED_MODULE_3__render_primitives_label_point_label_render_unit__["a" /* PROGRAM_OPTIONS */]);
        super(context, program, primitiveProvider, camera);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ColorIdPointLabelRenderer;



/***/ }),
/* 111 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec2 vertexId;\n\n// point in the world the label is anchored to\nattribute vec2 vertexPosHigh;\nattribute vec2 vertexPosLow;\n\n// vector of concrete glyph point displacement (top-left, bottom-left, ...) relative to label's center, in px\nattribute vec2 vertexDisplacement;\n\n// coordinates of the glyph vertex in the atlas\nattribute vec2 vertexUV;\n\nattribute float vertexPriority;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\nuniform vec2 pixelSize;\nuniform sampler2D visibility;\nuniform vec2 idHalfPxSize;\nuniform vec2 shift;\nuniform lowp float currentZoom;\n\nvarying vec2 uv;\nvarying lowp vec4 color;\nvarying lowp vec4 outlineColor;\nvarying mediump float scale;\n\nconst vec4 DISCARD_POSITION = vec4(2, 2, 2, 1);\n\nconst float YV_H_1_0 = 1.999969482421875;\nconst float YV_L_1_1 = 0.000030517112463712692;\n\n/**\n * Projects specific point label vertex onto the screen.\n */\nvec4 projectPointLabelVertex_1_2(\n    mat4 viewProjMatrix,\n    vec2 lookAtHigh,\n    vec2 lookAtLow,\n    vec2 posHigh,\n    vec2 posLow,\n    vec2 displacement,\n    vec2 pxSize\n) {\n    vec4 position = viewProjMatrix * vec4(\n        YV_H_1_0 * (posHigh - lookAtHigh) +\n            YV_L_1_1 * (posLow - lookAtLow),\n        0,\n        1\n    );\n    position = vec4(position.xy / position.w, 0.0, 1.0);\n\n    return position + vec4(displacement * pxSize, 0.0, 0.0);\n}\n\n\n\n\nvoid main(void) {\n    vec2 idTexCoordinate = vertexId.xy + idHalfPxSize;\n    float overlapZoom = texture2D(visibility, idTexCoordinate).b;\n    if (currentZoom < overlapZoom) {\n        gl_Position = DISCARD_POSITION;\n    } else {\n        gl_Position = projectPointLabelVertex_1_2(\n            viewProjMatrix,\n            lookAtHigh,\n            lookAtLow,\n            vertexPosHigh,\n            vertexPosLow,\n            vertexDisplacement,\n            pixelSize\n        );\n        gl_Position.xy += shift;\n        gl_Position.z = vertexPriority;\n        color = vec4(vertexId, 0, 1);\n    }\n\n}\n"

/***/ }),
/* 112 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__render_state__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math_vector2__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__render_primitives_world_primitive_render_unit__ = __webpack_require__(5);



class CollidingPrimitiveColorIdRenderer extends __WEBPACK_IMPORTED_MODULE_2__render_primitives_world_primitive_render_unit__["a" /* default */] {
    constructor(context, program, primitiveProvider) {
        super(context, new __WEBPACK_IMPORTED_MODULE_0__render_state__["c" /* default */](), program, primitiveProvider);
        this._idHalfPxSizeUniform = __WEBPACK_IMPORTED_MODULE_1__math_vector2__["f" /* create */](0, 0);
    }
    _getPrimitives() {
        return this.primitiveProvider.visiblePrimitives;
    }
    _prepareProgram(program, viewProjMatrix, cameraPositions, state, stabilityShift, visibility, currentZoom) {
        super._prepareProgram(program, viewProjMatrix, cameraPositions, state, stabilityShift, visibility, currentZoom);
        this._idHalfPxSizeUniform.x = 0.5 / visibility.getWidth();
        this._idHalfPxSizeUniform.y = 0.5 / visibility.getHeight();
        this._context.bindTextureUnit(0);
        this._context.bindTexture(visibility);
        program.setIntScalarUniform('visibility', 0);
        program.setVector2Uniform('idHalfPxSize', this._idHalfPxSizeUniform);
        program.setVector2Uniform('shift', stabilityShift);
        program.setScalarUniform('currentZoom', currentZoom);
    }
    _prepareRenderTarget(target, _viewProjMatrix, _cameraPositions, state, _stabilityShift, _visibility, _currentZoom) {
        this._context.bindRenderState(state);
        this._context.bindRenderTarget(target);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = CollidingPrimitiveColorIdRenderer;



/***/ }),
/* 113 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export appendToBatch */
/* harmony export (immutable) */ __webpack_exports__["a"] = batchAllocatedObjects;
/**
 * Appends portion of memory to batch if they are adjacent.
 *
 * @returns `true` if both params are adjacent and the batch was successfully updated, `false` otherwise.
 */
function appendToBatch(memoryLocation, batch) {
    if (batch.vertexByteOffset + batch.vertexByteLength === memoryLocation.vertexByteOffset &&
        batch.indexByteOffset + batch.indexByteLength === memoryLocation.indexByteOffset) {
        batch.vertexByteLength += memoryLocation.vertexByteLength;
        batch.indexByteLength += memoryLocation.indexByteLength;
        return true;
    }
    return false;
}
/**
 * Combines objects allocated in memory into batches. No sorting is done in this method, the objects are supposed
 * to be sorted by index/vertex offsets to make batching effective. The batch is created by factory since it can
 * contains problem specific information.
 *
 * @param objects List of allocated objects.
 * @param getMemoryLocation Returns memory location of specific object.
 * @param createBatch Initiates batch by the first object.
 * @param canBatch Checks if two objects can be allocated.
 * @returns Iterable list of batches.
 */
function* batchAllocatedObjects(objects, getMemoryLocation, createBatch, canBatch = () => true) {
    const iterator = objects[Symbol.iterator]();
    let primitive = iterator.next().value;
    if (!primitive) {
        return;
    }
    let prev = primitive;
    let batch = createBatch(prev);
    primitive = iterator.next().value;
    while (primitive) {
        const primitiveMemoryLocation = getMemoryLocation(primitive);
        if (!canBatch(prev, primitive, batch) || !appendToBatch(primitiveMemoryLocation, batch)) {
            yield batch;
            batch = createBatch(primitive);
        }
        prev = primitive;
        primitive = iterator.next().value;
    }
    yield batch;
}


/***/ }),
/* 114 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec2 vertexId;\n\n// point in the world the label is anchored to\nattribute vec2 vertexPosHigh;\nattribute vec2 vertexPosLow;\n\n// vector of concrete glyph point displacement (top-left, bottom-left, ...) relative to label's center, in px\nattribute vec2 vertexDisplacement;\n\n// coordinates of the glyph vertex in the atlas\nattribute vec2 vertexUV;\n\nattribute float vertexPriority;\n\nattribute lowp vec4 vertexColor;\nattribute lowp vec4 vertexOutlineColor;\nattribute float vertexScale;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\nuniform vec2 pixelSize;\nuniform sampler2D visibility;\nuniform vec2 idHalfPxSize;\nuniform vec2 shift;\nuniform lowp float currentZoom;\n\nvarying vec2 uv;\nvarying lowp vec4 color;\nvarying lowp vec4 outlineColor;\nvarying mediump float scale;\n\nconst vec4 DISCARD_POSITION = vec4(2, 2, 2, 1);\n\nconst float YV_H_1_0 = 1.999969482421875;\nconst float YV_L_1_1 = 0.000030517112463712692;\n\n/**\n * Projects specific point label vertex onto the screen.\n */\nvec4 projectPointLabelVertex_1_2(\n    mat4 viewProjMatrix,\n    vec2 lookAtHigh,\n    vec2 lookAtLow,\n    vec2 posHigh,\n    vec2 posLow,\n    vec2 displacement,\n    vec2 pxSize\n) {\n    vec4 position = viewProjMatrix * vec4(\n        YV_H_1_0 * (posHigh - lookAtHigh) +\n            YV_L_1_1 * (posLow - lookAtLow),\n        0,\n        1\n    );\n    position = vec4(position.xy / position.w, 0.0, 1.0);\n\n    return position + vec4(displacement * pxSize, 0.0, 0.0);\n}\n\n\n\n\nvoid main(void) {\n    float visibilityAlpha = texture2D(visibility, vertexId.xy + idHalfPxSize).a;\n    if (visibilityAlpha != 0.0) {\n        gl_Position = projectPointLabelVertex_1_2(\n            viewProjMatrix,\n            lookAtHigh,\n            lookAtLow,\n            vertexPosHigh,\n            vertexPosLow,\n            vertexDisplacement,\n            pixelSize\n        );\n\n        uv = vertexUV;\n        color = vertexColor;\n        outlineColor = vertexOutlineColor;\n        scale = vertexScale;\n\n        color.a *= visibilityAlpha;\n        outlineColor.a *= visibilityAlpha;\n    } else {\n        gl_Position = DISCARD_POSITION;\n    }\n}\n"

/***/ }),
/* 115 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_billboard_rectangle_vert__ = __webpack_require__(116);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_billboard_rectangle_vert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__shader_billboard_rectangle_vert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_billboard_rectangle_frag__ = __webpack_require__(117);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_billboard_rectangle_frag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__shader_billboard_rectangle_frag__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math_vector2__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__world_primitive_render_unit__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__render_state__ = __webpack_require__(0);






const RENDER_STATE = new __WEBPACK_IMPORTED_MODULE_4__render_state__["c" /* default */](__WEBPACK_IMPORTED_MODULE_4__render_state__["b" /* BLEND_OVER_RENDER_STATE */]);
/**
 * Renderer of billboard rectangles.
 */
class BillboardRectangleRenderUnit extends __WEBPACK_IMPORTED_MODULE_3__world_primitive_render_unit__["a" /* default */] {
    constructor(context, camera, visibilityProvider, primitiveProvider) {
        const program = context.createProgram(__WEBPACK_IMPORTED_MODULE_0__shader_billboard_rectangle_vert___default.a, __WEBPACK_IMPORTED_MODULE_1__shader_billboard_rectangle_frag___default.a, {
            attribMap: {
                vertexId: 2 /* ID */,
                vertexPosHigh: 0 /* POSITION_HIGH */,
                vertexPosLow: 1 /* POSITION_LOW */,
                vertexDisplacement: 6 /* DISPLACEMENT */,
                vertexUV: 4 /* UV */,
                vertexColor: 7 /* COLOR */,
                vertexBorderRadii: 11 /* AUX */
            }
        });
        super(context, RENDER_STATE, program, primitiveProvider);
        this._visibilityProvider = visibilityProvider;
        this._camera = camera;
        this._visibilitySizeUniform = __WEBPACK_IMPORTED_MODULE_2__math_vector2__["f" /* create */](0, 0);
        context.bindProgram(program);
        program.setIntScalarUniform('visibility', 0);
    }
    _prepareProgram(program, viewProjMatrix, cameraPositions) {
        super._prepareProgram(program, viewProjMatrix, cameraPositions);
        const visibility = this._visibilityProvider();
        this._visibilitySizeUniform.x = visibility.getWidth();
        this._visibilitySizeUniform.y = visibility.getHeight();
        this._context.bindTextureUnit(0);
        this._context.bindTexture(visibility);
        program.setVector2Uniform('visibilitySize', this._visibilitySizeUniform);
        program.setVector2Uniform('pixelSize', this._camera.pixelSize);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = BillboardRectangleRenderUnit;



/***/ }),
/* 116 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec2 vertexId;\nattribute vec2 vertexPosHigh;\nattribute vec2 vertexPosLow;\nattribute vec2 vertexDisplacement;\nattribute vec2 vertexUV;\nattribute vec4 vertexColor;\nattribute vec2 vertexBorderRadii;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\nuniform vec2 pixelSize;\nuniform sampler2D visibility;\nuniform vec2 visibilitySize;\n\nvarying vec2 uv;\nvarying vec4 color;\nvarying vec2 borderRadii;\n\nconst vec4 DISCARD_POSITION = vec4(2, 2, 2, 1);\nconst float YV_H = 1.999969482421875;\nconst float YV_L = 0.000030517112463712692;\nvec2 VISIBILITY_HALF_PX = 0.5 / visibilitySize;\n\nvoid main(void) {\n    float visibilityAlpha = texture2D(visibility, vertexId.xy + VISIBILITY_HALF_PX).a;\n    if (visibilityAlpha == 0.0) {\n        gl_Position = DISCARD_POSITION;\n        return;\n    }\n\n    vec4 position = viewProjMatrix * vec4(\n        YV_H * (vertexPosHigh - lookAtHigh) +\n            YV_L * (vertexPosLow - lookAtLow),\n        0,\n        1\n    );\n    position.xyz /= position.w;\n    position.w = 1.0;\n\n    gl_Position = position + vec4(vertexDisplacement * pixelSize, 0.0, 0.0);\n\n    uv = vertexUV;\n    color = vertexColor;\n    color.a *= visibilityAlpha;\n    borderRadii = vertexBorderRadii;\n}\n"

/***/ }),
/* 117 */
/***/ (function(module, exports) {

module.exports = "#version 100\n\nprecision mediump float;\n#define GLSLIFY 1\n\nvarying vec2 uv;\nvarying vec4 color;\nvarying vec2 borderRadii;\n\nfloat roundedRectangle(const in vec2 uv, const in vec2 radii) {\n    vec2 absUv = abs(uv);\n    vec2 q = absUv + radii - 1.0;\n    return min(q.x, q.y) > 0.0 ? length(q / radii) : max(absUv.x, absUv.y);\n}\n\nvoid main(void) {\n    gl_FragColor = step(roundedRectangle(uv, borderRadii), 1.0) * color;\n}\n"

/***/ }),
/* 118 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_curved_label_vert__ = __webpack_require__(119);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_curved_label_vert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__shader_curved_label_vert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_color_id_frag__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_color_id_frag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__shader_color_id_frag__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__render_primitives_label_curved_label_render_unit__ = __webpack_require__(48);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__color_id_label_renderer__ = __webpack_require__(43);




/**
 * Curved labels renderer for collision resolution.
 */
class ColorIdCurvedLabelRenderer extends __WEBPACK_IMPORTED_MODULE_3__color_id_label_renderer__["a" /* default */] {
    constructor(context, camera, primitiveProvider) {
        const program = context.createProgram(__WEBPACK_IMPORTED_MODULE_0__shader_curved_label_vert___default.a, __WEBPACK_IMPORTED_MODULE_1__shader_color_id_frag___default.a, __WEBPACK_IMPORTED_MODULE_2__render_primitives_label_curved_label_render_unit__["a" /* PROGRAM_OPTIONS */]);
        super(context, program, primitiveProvider, camera);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ColorIdCurvedLabelRenderer;



/***/ }),
/* 119 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec2 vertexId;\n\n// point in the world the label is anchored to\nattribute vec2 vertexPosHigh;\nattribute vec2 vertexPosLow;\n\n// vector of concrete glyph point displacement (top-left, bottom-left, ...) relative to glyph's center (two values),\n// and distance of the glyph center to label's center (third value), in px\nattribute vec3 vertexDisplacements;\n\n// coordinates of the glyph vertex in the atlas\nattribute vec2 vertexUV;\n\nattribute float vertexPriority;\n\nattribute lowp vec4 vertexColor;\nattribute lowp vec4 vertexOutlineColor;\nattribute vec2 polylineLength_vertexScale;\n\n// deltas relative to the world point encoded in vertexPosHigh/vertexPosLow encoded via lengths and and angles of\n// corresponding vectors\nattribute vec4 leftPolylineRatios;\nattribute vec4 leftPolylineAngles;\nattribute vec4 rightPolylineRatios;\nattribute vec4 rightPolylineAngles;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\nuniform vec2 pixelSize;\nuniform sampler2D visibility;\nuniform vec2 idHalfPxSize;\nuniform vec2 shift;\nuniform lowp float currentZoom;\n\nvarying vec2 uv;\nvarying lowp vec4 color;\nvarying lowp vec4 outlineColor;\nvarying float scale;\n\nconst vec4 DISCARD_POSITION = vec4(2, 2, 2, 1);\n\nconst float YV_H_1_0 = 1.999969482421875;\nconst float YV_L_1_1 = 0.000030517112463712692;\n\nconst float PI_1_2 = 3.1415927410125732;\n\nconst int MAX_POLYLINE_POINTS_1_3 = 4;\nconst float INFINITY_1_4 = 1000000.0; // large enough for a segment length to consider it infinity\n\n/**\n * Returns world coordinate (plus delta) projected on screen, in pixels.\n */\nvec2 project_1_5(\n    mat4 viewProjMatrix,\n    vec2 lookAtHigh,\n    vec2 lookAtLow,\n    vec2 pixelSize,\n    vec2 pointHigh,\n    vec2 pointLow,\n    vec2 delta\n) {\n    vec4 position = viewProjMatrix * vec4(\n            YV_H_1_0 * (pointHigh - lookAtHigh) + YV_L_1_1 * (pointLow - lookAtLow) + delta,\n            0,\n            1\n        );\n    vec2 projected = position.xy / position.w;\n    return projected / pixelSize;\n}\n\n/**\n * Each point of the polyline is encoded as a vector from the polyline center by its normalized angle and the ratio of\n * its length to the polyline's length.\n */\nvec2 decodePolylineDeltas_1_6(float ratio, float angle, float polylineLength) {\n    // denormalize angle back to radians\n    float a = angle * 2.0 * PI_1_2 - PI_1_2;\n    // length of a vector\n    float len = ratio * polylineLength;\n    // restored point's (x, y) coordinates\n    return vec2(cos(a), sin(a)) * len;\n}\n\n/**\n * Projects specific curved label vertex onto the screen. The label is layouted by centering polyline in\n * the vertexPosHigh/vertexPosLow and other points are used to guide concrete gryph vertex.\n * Number of polyline points is hardcoded to pass them in attributes.\n */\nvec4 projectCurvedLabelVertex_1_7(\n    mat4 viewProjMatrix,\n    vec2 lookAtHigh,\n    vec2 lookAtLow,\n    vec2 pxSize,\n    vec2 posHigh,\n    vec2 posLow,\n    vec2 displacement,\n    float lineDisplacement,\n    float polylineLength,\n    vec4 leftPolylineRatios,\n    vec4 leftPolylineAngles,\n    vec4 rightPolylineRatios,\n    vec4 rightPolylineAngles\n) {\n    vec2 polylineDeltas[MAX_POLYLINE_POINTS_1_3];\n    vec2 position = project_1_5(viewProjMatrix, lookAtHigh, lookAtLow, pxSize, posHigh, posLow, vec2(0, 0));\n    float remainingLength = abs(lineDisplacement);\n    for (int i = 0; i < MAX_POLYLINE_POINTS_1_3; i++) {\n        vec2 projectedPoint;\n\n        // figure out the direction (left/right) at the first step\n        if (i == 0) {\n            projectedPoint = project_1_5(\n                viewProjMatrix,\n                lookAtHigh,\n                lookAtLow,\n                pxSize,\n                posHigh,\n                posLow,\n                decodePolylineDeltas_1_6(rightPolylineRatios[0], rightPolylineAngles[0], polylineLength)\n            );\n            bool isRightPart = lineDisplacement > 0.0;\n            bool isInverted = projectedPoint.x < position.x;\n\n            // the map could be rotated and curved label should change its direction if they got upside down\n            // using center segment to identify this case is an approximation (ideally we should check all segments)\n            if (isRightPart ^^ isInverted) {\n                polylineDeltas[0] = decodePolylineDeltas_1_6(rightPolylineRatios[0], rightPolylineAngles[0], polylineLength);\n                polylineDeltas[1] = decodePolylineDeltas_1_6(rightPolylineRatios[1], rightPolylineAngles[1], polylineLength);\n                polylineDeltas[2] = decodePolylineDeltas_1_6(rightPolylineRatios[2], rightPolylineAngles[2], polylineLength);\n                polylineDeltas[3] = decodePolylineDeltas_1_6(rightPolylineRatios[3], rightPolylineAngles[3], polylineLength);\n            } else {\n                polylineDeltas[0] = decodePolylineDeltas_1_6(leftPolylineRatios[0], leftPolylineAngles[0], polylineLength);\n                polylineDeltas[1] = decodePolylineDeltas_1_6(leftPolylineRatios[1], leftPolylineAngles[1], polylineLength);\n                polylineDeltas[2] = decodePolylineDeltas_1_6(leftPolylineRatios[2], leftPolylineAngles[2], polylineLength);\n                polylineDeltas[3] = decodePolylineDeltas_1_6(leftPolylineRatios[3], leftPolylineAngles[3], polylineLength);\n            }\n\n            // the first right point of the segment already calculated,\n            // recalculate the point if this part of the label goes other direction\n            if (!(isRightPart && !isInverted) && !(!isRightPart && isInverted)) {\n                projectedPoint = project_1_5(viewProjMatrix, lookAtHigh, lookAtLow, pxSize, posHigh, posLow, polylineDeltas[i]);\n            }\n        } else {\n            projectedPoint = project_1_5(viewProjMatrix, lookAtHigh, lookAtLow, pxSize, posHigh, posLow, polylineDeltas[i]);\n        }\n\n        vec2 segment = projectedPoint - position;\n        bool isLast = i == (MAX_POLYLINE_POINTS_1_3 - 1);\n        float segmentLength = (isLast || (polylineDeltas[i + 1] == vec2(0, 0))) ? INFINITY_1_4 : length(segment);\n\n        if (segmentLength > remainingLength) {\n            float signFactor = lineDisplacement > 0.0 ? 1.0 : -1.0;\n            vec2 direction = normalize(segment);\n            vec2 normal = vec2(-direction.y, direction.x);\n\n            position += direction * remainingLength;\n            position += signFactor * direction * displacement.x;\n            position += signFactor * normal * displacement.y;\n\n            break;\n        } else {\n            remainingLength -= segmentLength;\n            position += segment;\n        }\n    }\n\n    return vec4(position * pxSize, 0.0, 1.0);\n}\n\n\n\n\n\n/**\n * Curved labels are layouted here: the label is centered in the vertexPosHigh/vertexPosLow and polyline points\n * are used to guide concrete gryph vertex. Number of polyline points is hardcoded to pass them in attributes.\n */\nvoid main(void) {\n    vec2 idTexCoordinate = vertexId.xy + idHalfPxSize;\n    float overlapZoom = texture2D(visibility, idTexCoordinate).b;\n\n    if (currentZoom < overlapZoom) {\n        gl_Position = DISCARD_POSITION;\n    } else {\n        vec2 vertexDisplacement = vertexDisplacements.xy;\n        float vertexLineDisplacement = vertexDisplacements.z;\n        float polylineLength = polylineLength_vertexScale[0];\n        gl_Position = projectCurvedLabelVertex_1_7(\n            viewProjMatrix,\n            lookAtHigh,\n            lookAtLow,\n            pixelSize,\n            vertexPosHigh,\n            vertexPosLow,\n            vertexDisplacement,\n            vertexLineDisplacement,\n            polylineLength,\n            leftPolylineRatios,\n            leftPolylineAngles,\n            rightPolylineRatios,\n            rightPolylineAngles\n        );\n\n        gl_Position.xy += shift;\n        gl_Position.z = vertexPriority;\n\n        color = vec4(vertexId, 0, 1);\n    }\n}\n"

/***/ }),
/* 120 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec2 vertexId;\n\n// point in the world the label is anchored to\nattribute vec2 vertexPosHigh;\nattribute vec2 vertexPosLow;\n\n// vector of concrete glyph point displacement (top-left, bottom-left, ...) relative to glyph's center (two values),\n// and distance of the glyph center to label's center (third value), in px\nattribute vec3 vertexDisplacements;\n\n// coordinates of the glyph vertex in the atlas\nattribute vec2 vertexUV;\n\nattribute float vertexPriority;\n\nattribute lowp vec4 vertexColor;\nattribute lowp vec4 vertexOutlineColor;\nattribute vec2 polylineLength_vertexScale;\n\n// deltas relative to the world point encoded in vertexPosHigh/vertexPosLow encoded via lengths and and angles of\n// corresponding vectors\nattribute vec4 leftPolylineRatios;\nattribute vec4 leftPolylineAngles;\nattribute vec4 rightPolylineRatios;\nattribute vec4 rightPolylineAngles;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\nuniform vec2 pixelSize;\nuniform sampler2D visibility;\nuniform vec2 idHalfPxSize;\nuniform vec2 shift;\nuniform lowp float currentZoom;\n\nvarying vec2 uv;\nvarying lowp vec4 color;\nvarying lowp vec4 outlineColor;\nvarying float scale;\n\nconst vec4 DISCARD_POSITION = vec4(2, 2, 2, 1);\n\nconst float YV_H_1_0 = 1.999969482421875;\nconst float YV_L_1_1 = 0.000030517112463712692;\n\nconst float PI_1_2 = 3.1415927410125732;\n\nconst int MAX_POLYLINE_POINTS_1_3 = 4;\nconst float INFINITY_1_4 = 1000000.0; // large enough for a segment length to consider it infinity\n\n/**\n * Returns world coordinate (plus delta) projected on screen, in pixels.\n */\nvec2 project_1_5(\n    mat4 viewProjMatrix,\n    vec2 lookAtHigh,\n    vec2 lookAtLow,\n    vec2 pixelSize,\n    vec2 pointHigh,\n    vec2 pointLow,\n    vec2 delta\n) {\n    vec4 position = viewProjMatrix * vec4(\n            YV_H_1_0 * (pointHigh - lookAtHigh) + YV_L_1_1 * (pointLow - lookAtLow) + delta,\n            0,\n            1\n        );\n    vec2 projected = position.xy / position.w;\n    return projected / pixelSize;\n}\n\n/**\n * Each point of the polyline is encoded as a vector from the polyline center by its normalized angle and the ratio of\n * its length to the polyline's length.\n */\nvec2 decodePolylineDeltas_1_6(float ratio, float angle, float polylineLength) {\n    // denormalize angle back to radians\n    float a = angle * 2.0 * PI_1_2 - PI_1_2;\n    // length of a vector\n    float len = ratio * polylineLength;\n    // restored point's (x, y) coordinates\n    return vec2(cos(a), sin(a)) * len;\n}\n\n/**\n * Projects specific curved label vertex onto the screen. The label is layouted by centering polyline in\n * the vertexPosHigh/vertexPosLow and other points are used to guide concrete gryph vertex.\n * Number of polyline points is hardcoded to pass them in attributes.\n */\nvec4 projectCurvedLabelVertex_1_7(\n    mat4 viewProjMatrix,\n    vec2 lookAtHigh,\n    vec2 lookAtLow,\n    vec2 pxSize,\n    vec2 posHigh,\n    vec2 posLow,\n    vec2 displacement,\n    float lineDisplacement,\n    float polylineLength,\n    vec4 leftPolylineRatios,\n    vec4 leftPolylineAngles,\n    vec4 rightPolylineRatios,\n    vec4 rightPolylineAngles\n) {\n    vec2 polylineDeltas[MAX_POLYLINE_POINTS_1_3];\n    vec2 position = project_1_5(viewProjMatrix, lookAtHigh, lookAtLow, pxSize, posHigh, posLow, vec2(0, 0));\n    float remainingLength = abs(lineDisplacement);\n    for (int i = 0; i < MAX_POLYLINE_POINTS_1_3; i++) {\n        vec2 projectedPoint;\n\n        // figure out the direction (left/right) at the first step\n        if (i == 0) {\n            projectedPoint = project_1_5(\n                viewProjMatrix,\n                lookAtHigh,\n                lookAtLow,\n                pxSize,\n                posHigh,\n                posLow,\n                decodePolylineDeltas_1_6(rightPolylineRatios[0], rightPolylineAngles[0], polylineLength)\n            );\n            bool isRightPart = lineDisplacement > 0.0;\n            bool isInverted = projectedPoint.x < position.x;\n\n            // the map could be rotated and curved label should change its direction if they got upside down\n            // using center segment to identify this case is an approximation (ideally we should check all segments)\n            if (isRightPart ^^ isInverted) {\n                polylineDeltas[0] = decodePolylineDeltas_1_6(rightPolylineRatios[0], rightPolylineAngles[0], polylineLength);\n                polylineDeltas[1] = decodePolylineDeltas_1_6(rightPolylineRatios[1], rightPolylineAngles[1], polylineLength);\n                polylineDeltas[2] = decodePolylineDeltas_1_6(rightPolylineRatios[2], rightPolylineAngles[2], polylineLength);\n                polylineDeltas[3] = decodePolylineDeltas_1_6(rightPolylineRatios[3], rightPolylineAngles[3], polylineLength);\n            } else {\n                polylineDeltas[0] = decodePolylineDeltas_1_6(leftPolylineRatios[0], leftPolylineAngles[0], polylineLength);\n                polylineDeltas[1] = decodePolylineDeltas_1_6(leftPolylineRatios[1], leftPolylineAngles[1], polylineLength);\n                polylineDeltas[2] = decodePolylineDeltas_1_6(leftPolylineRatios[2], leftPolylineAngles[2], polylineLength);\n                polylineDeltas[3] = decodePolylineDeltas_1_6(leftPolylineRatios[3], leftPolylineAngles[3], polylineLength);\n            }\n\n            // the first right point of the segment already calculated,\n            // recalculate the point if this part of the label goes other direction\n            if (!(isRightPart && !isInverted) && !(!isRightPart && isInverted)) {\n                projectedPoint = project_1_5(viewProjMatrix, lookAtHigh, lookAtLow, pxSize, posHigh, posLow, polylineDeltas[i]);\n            }\n        } else {\n            projectedPoint = project_1_5(viewProjMatrix, lookAtHigh, lookAtLow, pxSize, posHigh, posLow, polylineDeltas[i]);\n        }\n\n        vec2 segment = projectedPoint - position;\n        bool isLast = i == (MAX_POLYLINE_POINTS_1_3 - 1);\n        float segmentLength = (isLast || (polylineDeltas[i + 1] == vec2(0, 0))) ? INFINITY_1_4 : length(segment);\n\n        if (segmentLength > remainingLength) {\n            float signFactor = lineDisplacement > 0.0 ? 1.0 : -1.0;\n            vec2 direction = normalize(segment);\n            vec2 normal = vec2(-direction.y, direction.x);\n\n            position += direction * remainingLength;\n            position += signFactor * direction * displacement.x;\n            position += signFactor * normal * displacement.y;\n\n            break;\n        } else {\n            remainingLength -= segmentLength;\n            position += segment;\n        }\n    }\n\n    return vec4(position * pxSize, 0.0, 1.0);\n}\n\n\n\n\nvoid main(void) {\n    float visibilityAlpha = texture2D(visibility, vertexId.xy + idHalfPxSize).a;\n    if (visibilityAlpha != 0.0) {\n        vec2 vertexDisplacement = vertexDisplacements.xy;\n        float vertexLineDisplacement = vertexDisplacements.z;\n        float polylineLength = polylineLength_vertexScale[0];\n        float vertexScale = polylineLength_vertexScale[1];\n        gl_Position = projectCurvedLabelVertex_1_7(\n            viewProjMatrix,\n            lookAtHigh,\n            lookAtLow,\n            pixelSize,\n            vertexPosHigh,\n            vertexPosLow,\n            vertexDisplacement,\n            vertexLineDisplacement,\n            polylineLength,\n            leftPolylineRatios,\n            leftPolylineAngles,\n            rightPolylineRatios,\n            rightPolylineAngles\n        );\n\n        uv = vertexUV;\n        color = vertexColor;\n        outlineColor = vertexOutlineColor;\n        scale = vertexScale;\n\n        color.a *= visibilityAlpha;\n        outlineColor.a *= visibilityAlpha;\n    } else {\n        gl_Position = DISCARD_POSITION;\n    }\n}\n"

/***/ }),
/* 121 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_icon_vert__ = __webpack_require__(122);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_icon_vert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__shader_icon_vert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_icon_frag__ = __webpack_require__(123);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_icon_frag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__shader_icon_frag__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__image_image_render_unit__ = __webpack_require__(124);



/**
 * Renderer of icon primitives.
 */
class IconRenderUnit extends __WEBPACK_IMPORTED_MODULE_2__image_image_render_unit__["a" /* default */] {
    constructor(context, camera, primitiveProvider) {
        const program = context.createProgram(__WEBPACK_IMPORTED_MODULE_0__shader_icon_vert___default.a, __WEBPACK_IMPORTED_MODULE_1__shader_icon_frag___default.a, {
            attribMap: {
                vertexPosHigh: 0 /* POSITION_HIGH */,
                vertexPosLow: 1 /* POSITION_LOW */,
                vertexDisplacement: 6 /* DISPLACEMENT */,
                vertexUV: 4 /* UV */
            }
        });
        super(context, primitiveProvider, program);
        this._camera = camera;
    }
    _prepareProgram(program, viewProjMatrix, cameraPositions) {
        super._prepareProgram(program, viewProjMatrix, cameraPositions);
        program.setVector2Uniform('pixelSize', this._camera.pixelSize);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = IconRenderUnit;



/***/ }),
/* 122 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec2 vertexPosHigh;\nattribute vec2 vertexPosLow;\nattribute vec2 vertexDisplacement;\nattribute vec2 vertexUV;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\nuniform vec2 pixelSize;\n\nvarying vec2 uv;\n\nconst float YV_H = 1.999969482421875;\nconst float YV_L = 0.000030517112463712692;\n\nvoid main() {\n    vec4 position = viewProjMatrix * vec4(\n        YV_H * (vertexPosHigh - lookAtHigh) +\n            YV_L * (vertexPosLow - lookAtLow),\n        0,\n        1\n    );\n    position = vec4(position.xy / position.w, 0.0, 1.0);\n\n    gl_Position = position + vec4(vertexDisplacement * pixelSize, 0.0, 0.0);\n\n    uv = vertexUV;\n}\n"

/***/ }),
/* 123 */
/***/ (function(module, exports) {

module.exports = "#version 100\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform sampler2D atlas;\nuniform vec2 atlasSize;\n\nvarying vec2 uv;\n\nvoid main() {\n    gl_FragColor = texture2D(atlas, uv / atlasSize);\n}\n"

/***/ }),
/* 124 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_image_vert__ = __webpack_require__(125);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_image_vert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__shader_image_vert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_image_frag__ = __webpack_require__(126);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_image_frag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__shader_image_frag__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math_vector2__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__world_primitive_render_unit__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__render_state__ = __webpack_require__(0);






const RENDER_STATE = new __WEBPACK_IMPORTED_MODULE_4__render_state__["c" /* default */](__WEBPACK_IMPORTED_MODULE_4__render_state__["b" /* BLEND_OVER_RENDER_STATE */]);
function createDefaultProgram(context) {
    return context.createProgram(__WEBPACK_IMPORTED_MODULE_0__shader_image_vert___default.a, __WEBPACK_IMPORTED_MODULE_1__shader_image_frag___default.a, {
        attribMap: {
            vertexPosHigh: 0 /* POSITION_HIGH */,
            vertexPosLow: 1 /* POSITION_LOW */,
            vertexUV: 4 /* UV */
        }
    });
}
/**
 * Renderer of image primitives.
 */
class ImageRenderUnit extends __WEBPACK_IMPORTED_MODULE_3__world_primitive_render_unit__["a" /* default */] {
    constructor(context, primitiveProvider, program = createDefaultProgram(context)) {
        super(context, RENDER_STATE, program, primitiveProvider);
        this._atlasSizeUniform = __WEBPACK_IMPORTED_MODULE_2__math_vector2__["f" /* create */](0, 0);
        context.bindProgram(program);
        program.setIntScalarUniform('atlas', 0);
    }
    _renderBatch(memoryBatch) {
        const atlas = memoryBatch.firstPrimitive.atlas;
        this._atlasSizeUniform.x = atlas.width;
        this._atlasSizeUniform.y = atlas.height;
        if (atlas.isDirty) {
            atlas.syncTexture();
        }
        this._program.setVector2Uniform('atlasSize', this._atlasSizeUniform);
        this._context.bindTextureUnit(0);
        this._context.bindTexture(atlas.texture);
        super._renderBatch(memoryBatch);
    }
    _canBatchAdjacentPrimitives(a, b) {
        return super._canBatchAdjacentPrimitives(a, b) && (a.atlas === b.atlas);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ImageRenderUnit;



/***/ }),
/* 125 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec2 vertexPosHigh;\nattribute vec2 vertexPosLow;\nattribute vec2 vertexUV;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\n\nvarying vec2 uv;\n\nconst float YV_H = 1.999969482421875;\nconst float YV_L = 0.000030517112463712692;\n\nvoid main() {\n    vec4 position = viewProjMatrix * vec4(\n        YV_H * (vertexPosHigh - lookAtHigh) +\n            YV_L * (vertexPosLow - lookAtLow),\n        0,\n        1\n    );\n\n    gl_Position = position;\n\n    uv = vertexUV;\n}\n"

/***/ }),
/* 126 */
/***/ (function(module, exports) {

module.exports = "#version 100\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform sampler2D atlas;\nuniform vec2 atlasSize;\n\nvarying vec2 uv;\n\nvoid main() {\n    gl_FragColor = texture2D(atlas, uv / atlasSize);\n\n    if (gl_FragColor.a == 0.0) {\n        discard;\n    }\n}\n"

/***/ }),
/* 127 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_model_vert__ = __webpack_require__(128);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_model_vert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__shader_model_vert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_model_frag__ = __webpack_require__(129);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_model_frag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__shader_model_frag__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math_vector2__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__overlay_overlay_renderer__ = __webpack_require__(130);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__render_state__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__world_primitive_render_unit__ = __webpack_require__(5);






const RENDER_STATE = new __WEBPACK_IMPORTED_MODULE_4__render_state__["c" /* default */]({
    depthTest: true
});
/**
 * Renderer of models. It renders models into a texture with depth test and then this texture into the render target.
 * It allows to show only the top facets of semi-transparent objects without exposing their inner structure.
 */
class ModelRenderUnit extends __WEBPACK_IMPORTED_MODULE_5__world_primitive_render_unit__["a" /* default */] {
    constructor(context, primitiveProvider) {
        const program = context.createProgram(__WEBPACK_IMPORTED_MODULE_0__shader_model_vert___default.a, __WEBPACK_IMPORTED_MODULE_1__shader_model_frag___default.a, {
            attribMap: {
                vertexPosHigh: 0 /* POSITION_HIGH */,
                vertexPosLow: 1 /* POSITION_LOW */,
                vertexHeight: 3 /* HEIGHT */,
                vertexColor: 7 /* COLOR */
            }
        });
        super(context, RENDER_STATE, program, primitiveProvider);
        this._outputSize = Object(__WEBPACK_IMPORTED_MODULE_2__math_vector2__["h" /* createExtent2 */])(-1, -1);
        this._overlayRenderer = new __WEBPACK_IMPORTED_MODULE_3__overlay_overlay_renderer__["a" /* default */](context);
    }
    render(target, viewProjMatrix, cameraPositions) {
        this._syncOutputBuffer(target);
        super.render(this._outputBuffer, viewProjMatrix, cameraPositions);
        // do not run unnecessary copying if this._outputBuffer was not updated (no models in scene?)
        if (!this._outputBuffer.isClear) {
            // copy into the final target
            this._overlayRenderer.render(target, this._outputTexture);
        }
    }
    destroy() {
        this._overlayRenderer.destroy();
        if (this._outputTexture) {
            this._outputTexture.destroy();
        }
        if (this._outputDepthBuffer) {
            this._outputDepthBuffer.destroy();
        }
        if (this._outputBuffer) {
            this._outputBuffer.destroy();
        }
        super.destroy();
    }
    _syncOutputBuffer(target) {
        // make sure the intermediate texture fits the output target
        if (this._outputSize.width !== target.getWidth() ||
            this._outputSize.height !== target.getHeight()) {
            if (this._outputTexture || this._outputDepthBuffer || this._outputBuffer) {
                this._outputTexture.destroy();
                this._outputDepthBuffer.destroy();
                this._outputBuffer.destroy();
            }
            this._outputSize = { width: target.getWidth(), height: target.getHeight() };
            this._outputTexture = this._context.createEmpty2DTexture(this._outputSize.width, this._outputSize.height, 6408 /* RGBA */, 5121 /* UNSIGNED_BYTE */);
            this._outputDepthBuffer = this._context.createRenderbuffer(this._outputSize.width, this._outputSize.height, 34041 /* DEPTH_STENCIL */);
            this._outputBuffer = this._context.createFramebuffer({
                color: this._outputTexture,
                depthStencil: this._outputDepthBuffer
            });
        }
    }
    /**
     * Overridden _bindRenderTarget() to bind intermediate render target to render models into and
     * later put its content into the final target.
     */
    _prepareRenderTarget(target, viewProjMatrix, cameraPositions) {
        super._prepareRenderTarget(target, viewProjMatrix, cameraPositions);
        this._context.clearCurrentTarget(16384 /* COLOR_BUFFER_BIT */ | 256 /* DEPTH_BUFFER_BIT */);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ModelRenderUnit;



/***/ }),
/* 128 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec3 vertexPosHigh;\nattribute vec3 vertexPosLow;\nattribute float vertexHeight;\nattribute vec4 vertexColor;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\n\nvarying vec4 globalPos;\nvarying vec4 diffuseColor;\n\nconst float YV_H = 1.999969482421875;\nconst float YV_L = 0.000030517112463712692;\n\nvoid main(void) {\n    globalPos = vec4(\n        YV_H * (vertexPosHigh.xy - lookAtHigh) + YV_L * (vertexPosLow.xy - lookAtLow),\n        vertexHeight,\n        1\n    );\n\n    gl_Position = viewProjMatrix * globalPos;\n    diffuseColor = vertexColor;\n}\n"

/***/ }),
/* 129 */
/***/ (function(module, exports) {

module.exports = "#version 100\n\n#extension GL_OES_standard_derivatives : require\n\nprecision mediump float;\n#define GLSLIFY 1\n\nvarying vec4 diffuseColor;\nvarying vec4 globalPos;\n\nconst vec3 LIGHT_DIRECTION = normalize(vec3(0.5, 0.5, 1.0));\nconst float LIGHT_INTENSITY = 0.3;\nconst float AMBIENT_LIGHT_INTENSITY = 1.0 - LIGHT_INTENSITY;\nconst float HORIZONTAL_PLANE_DIFFUSE_INTENSITY =\n    AMBIENT_LIGHT_INTENSITY + 0.5 * LIGHT_INTENSITY * (LIGHT_DIRECTION.z + 1.0);\n\nvoid main(void) {\n    vec3 pos = globalPos.xyz;\n\n    vec3 dxpos = normalize(dFdx(pos));\n    vec3 dypos = normalize(dFdy(pos));\n    vec3 normal = normalize(cross(dxpos, dypos));\n\n    gl_FragColor = vec4(\n        diffuseColor.rgb * (AMBIENT_LIGHT_INTENSITY + 0.5 * LIGHT_INTENSITY * (dot(normal, LIGHT_DIRECTION) + 1.0)) /\n            HORIZONTAL_PLANE_DIFFUSE_INTENSITY,\n        diffuseColor.a\n    );\n}\n"

/***/ }),
/* 130 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_overlay_vert__ = __webpack_require__(131);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_overlay_vert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__shader_overlay_vert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_overlay_frag__ = __webpack_require__(132);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_overlay_frag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__shader_overlay_frag__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__render_gl_renderer__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__render_state__ = __webpack_require__(0);





const RENDER_STATE = new __WEBPACK_IMPORTED_MODULE_3__render_state__["c" /* default */](__WEBPACK_IMPORTED_MODULE_3__render_state__["b" /* BLEND_OVER_RENDER_STATE */]);
/**
 * Renders a texture into a render target with OVER compositing. The texture will completely overlay the target, i.e.
 * it is stretched/shrinked to fit the target width/height, so ideally they should have the same dimensions.
 */
class OverlayRenderer extends __WEBPACK_IMPORTED_MODULE_2__render_gl_renderer__["a" /* GlRenderer */] {
    constructor(context) {
        const program = context.createProgram(__WEBPACK_IMPORTED_MODULE_0__shader_overlay_vert___default.a, __WEBPACK_IMPORTED_MODULE_1__shader_overlay_frag___default.a, {
            attribMap: {
                vertexPosition: 0 /* POSITION */,
                vertexUV: 4 /* UV */
            }
        });
        super(context, RENDER_STATE, program);
    }
    _render(texture) {
        this._context.bindTextureUnit(0);
        this._context.bindTexture(texture);
        this._context.bindQuadVao();
        this._context.drawQuad();
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = OverlayRenderer;



/***/ }),
/* 131 */
/***/ (function(module, exports) {

module.exports = "#version 100\nprecision mediump float;\n#define GLSLIFY 1\n\nattribute vec2 vertexPosition;\nattribute vec2 vertexUV;\n\nvarying vec2 uv;\n\nvoid main() {\n    gl_Position = vec4(vertexPosition, 0, 1);\n    uv = vertexUV;\n}\n"

/***/ }),
/* 132 */
/***/ (function(module, exports) {

module.exports = "#version 100\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform sampler2D texture;\n\nvarying vec2 uv;\n\nvoid main() {\n    gl_FragColor = texture2D(texture, uv);\n}\n"

/***/ }),
/* 133 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_textured_polyline_vert__ = __webpack_require__(134);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_textured_polyline_vert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__shader_textured_polyline_vert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_textured_polyline_frag__ = __webpack_require__(135);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_textured_polyline_frag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__shader_textured_polyline_frag__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math_vector2__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__render_state__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__base_polyline_render_unit__ = __webpack_require__(49);





const FILTER_RADIUS = 1.0 / devicePixelRatio;
const RENDER_STATE = new __WEBPACK_IMPORTED_MODULE_3__render_state__["c" /* default */](__WEBPACK_IMPORTED_MODULE_3__render_state__["a" /* BLEND_OVER_PREMULTIPLIED_ALPHA_RENDER_STATE */], {
    depthTest: true,
    depthMask: false,
    depthFunc: 518 /* GREATER_OR_EQUAL */
});
/**
 * Renderer of polyline primitives.
 */
class TexturedPolylineRenderUnit extends __WEBPACK_IMPORTED_MODULE_4__base_polyline_render_unit__["a" /* default */] {
    constructor(context, camera, primitiveProvider) {
        const program = context.createProgram(__WEBPACK_IMPORTED_MODULE_0__shader_textured_polyline_vert___default.a, __WEBPACK_IMPORTED_MODULE_1__shader_textured_polyline_frag___default.a, {
            defines: {
                FILTER_RADIUS: `float(${FILTER_RADIUS})`
            },
            attribMap: {
                vertexPosHigh: 0 /* POSITION_HIGH */,
                vertexPosLow: 1 /* POSITION_LOW */,
                vertexDisplacement: 6 /* DISPLACEMENT */,
                vertexUV: 4 /* UV */,
                vertexZIndex: 9 /* PRIORITY */,
                vertexHalfWidth: 11 /* AUX */,
                vertexPattern: 12 /* AUX1 */,
                vertexPatternHalfHeight: 13 /* AUX2 */
            }
        });
        super(context, RENDER_STATE, program, primitiveProvider, camera);
        this._atlasSizeUniform = __WEBPACK_IMPORTED_MODULE_2__math_vector2__["f" /* create */](0, 0);
        context.bindProgram(program);
        program.setIntScalarUniform('atlas', 0);
    }
    _renderBatch(memoryBatch) {
        const atlas = memoryBatch.firstPrimitive.atlas;
        this._atlasSizeUniform.x = atlas.width;
        this._atlasSizeUniform.y = atlas.height;
        if (atlas.isDirty) {
            atlas.syncTexture();
        }
        this._program.setVector2Uniform('atlasSize', this._atlasSizeUniform);
        this._context.bindTextureUnit(0);
        this._context.bindTexture(atlas.texture);
        super._renderBatch(memoryBatch);
    }
    _canBatchAdjacentPrimitives(a, b) {
        return super._canBatchAdjacentPrimitives(a, b) && (a.atlas === b.atlas);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = TexturedPolylineRenderUnit;



/***/ }),
/* 134 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\n#ifndef FILTER_RADIUS\n#   error FILTER_RADIUS must be set\n#endif\n\nattribute vec2 vertexPosHigh;\nattribute vec2 vertexPosLow;\nattribute vec2 vertexDisplacement;\nattribute vec2 vertexUV;\nattribute float vertexHalfWidth;\nattribute vec2 vertexPattern;\nattribute float vertexPatternHalfHeight;\nattribute float vertexZIndex;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\nuniform float worldToPxFactor;\n\nvarying vec2 uv;\nvarying float s;\nvarying float patternLength;\nvarying float len;\nvarying float halfWidth;\nvarying float extHalfWidth;\nvarying float patternHalfHeight;\n\nconst float YV_H = 1.999969482421875;\nconst float YV_L = 0.000030517112463712692;\n\nvoid main(void) {\n    halfWidth = vertexHalfWidth;\n    extHalfWidth = halfWidth + FILTER_RADIUS;\n\n    vec4 position = viewProjMatrix * vec4(\n        YV_H * (vertexPosHigh - lookAtHigh) +\n            YV_L * (vertexPosLow - lookAtLow) +\n                worldToPxFactor * extHalfWidth * vertexDisplacement,\n        0,\n        1\n    );\n\n    position.xy /= position.w;\n    position.z = vertexZIndex;\n    position.w = 1.0;\n\n    gl_Position = position;\n\n    patternLength = vertexPattern[0];\n    len = vertexPattern[1];\n    // Distance to the analytical line along segment's normal\n    s = sign(vertexPatternHalfHeight) * extHalfWidth;\n    // The whole texture is being sampled to the original geometry. For pixels in the extended polyline part the topmost\n    // (bottommost) texels are taken. To make this happen the UV texture coordinates are extended in proportion to the\n    // polyline width extension.\n    patternHalfHeight = abs(vertexPatternHalfHeight);\n    uv = vec2(vertexUV.x, vertexUV.y - vertexPatternHalfHeight * FILTER_RADIUS / halfWidth);\n}\n"

/***/ }),
/* 135 */
/***/ (function(module, exports) {

module.exports = "#version 100\n\n#ifndef FILTER_RADIUS\n#   error FILTER_RADIUS must be set\n#endif\n\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform sampler2D atlas;\nuniform vec2 atlasSize;\n\nvarying vec2 uv;\nvarying float s;\nvarying float patternLength;\nvarying float len;\nvarying float halfWidth;\nvarying float extHalfWidth;\nvarying float patternHalfHeight;\n\nvoid main(void) {\n    lowp float alpha = smoothstep(0.0, FILTER_RADIUS + min(FILTER_RADIUS, extHalfWidth), extHalfWidth - abs(s));\n\n    // Clamp texture U coordinate by 0.5px from both sides to avoid bleeding.\n    vec2 uvAdjusted = vec2(uv.x + clamp(mod(len, patternLength), 0.5, patternLength - 0.5), uv.y);\n    // UV texture coordinates have been extended in proportion to the polyline width extension.\n    // Clamp texture V coordinate to the original geometry minus 0.5px to avoid bleeding.\n    float patternToGeometryFactor = halfWidth / patternHalfHeight;\n    float clampTo = halfWidth - 0.5 * patternToGeometryFactor;\n    if (step(clampTo, abs(s)) == 1.) {\n        float delta = s - clamp(s, -clampTo, clampTo);\n        uvAdjusted.y += delta / patternToGeometryFactor;\n    }\n\n    lowp vec4 color = texture2D(atlas, uvAdjusted / atlasSize);\n    gl_FragColor = color * alpha;\n}\n"

/***/ }),
/* 136 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__primitive_polyline_polyline_buffer_writer__ = __webpack_require__(137);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_polyline_vert__ = __webpack_require__(138);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_polyline_vert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__shader_polyline_vert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shader_polyline_frag__ = __webpack_require__(139);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shader_polyline_frag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__shader_polyline_frag__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__base_polyline_render_unit__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__render_state__ = __webpack_require__(0);





// Values was chosen by team consensus in VECTOR-197
const FILTER_RADIUS = 1.0 / devicePixelRatio; // px
const DEFAULT_RENDER_STATE_PARAMS = {
    blend: true,
    blendFuncSrcRgb: 1 /* ONE */,
    blendFuncDstRgb: 771 /* ONE_MINUS_SRC_ALPHA */,
    blendFuncSrcAlpha: 1 /* ONE */,
    blendFuncDstAlpha: 771 /* ONE_MINUS_SRC_ALPHA */
};
/* unused harmony export DEFAULT_RENDER_STATE_PARAMS */

/**
 * Renderer of polyline primitives. Its default render state is aimed to render opaque polylines.
 */
class PolylineRenderUnit extends __WEBPACK_IMPORTED_MODULE_3__base_polyline_render_unit__["a" /* default */] {
    constructor(context, camera, primitiveProvider, renderState = new __WEBPACK_IMPORTED_MODULE_4__render_state__["c" /* default */](DEFAULT_RENDER_STATE_PARAMS)) {
        const program = context.createProgram(__WEBPACK_IMPORTED_MODULE_1__shader_polyline_vert___default.a, __WEBPACK_IMPORTED_MODULE_2__shader_polyline_frag___default.a, {
            defines: {
                FILTER_RADIUS: `float(${FILTER_RADIUS})`,
                MAX_HALF_WIDTH: `float(${__WEBPACK_IMPORTED_MODULE_0__primitive_polyline_polyline_buffer_writer__["b" /* MAX_HALF_WIDTH */]})`,
                MAX_FILL_GAP: `float(${__WEBPACK_IMPORTED_MODULE_0__primitive_polyline_polyline_buffer_writer__["a" /* MAX_FILL_GAP */]})`
            },
            attribMap: {
                vertexPos: 0 /* POSITION */,
                vertexNormalPacked: 5 /* NORMAL */,
                vertexUvPacked: 4 /* UV */,
                vertexWidthFillGap: 11 /* AUX */,
                vertexColor: 7 /* COLOR */,
                vertexMiter: 12 /* AUX1 */,
                vertexVLimit: 13 /* AUX2 */,
                vertexLength: 14 /* AUX3 */
            }
        });
        super(context, renderState, program, primitiveProvider, camera);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = PolylineRenderUnit;



/***/ }),
/* 137 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_vector2__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_color__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_buffer_writer__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__polyline_attribute_mapping__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__util_gputypes__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__util_z_index__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__math_scalar__ = __webpack_require__(9);







/**
 * Computes miter of a join between two segments.
 *
 * @param n1 Normal vector of the first segment.
 * @param n2 Normal vector of the second segment.
 * @returns Miter value, i.e. by how match displacement is longer than a normal
 *      one.
 */
function computeMiter(n1, n2) {
    return Math.sqrt(2 / (1 + __WEBPACK_IMPORTED_MODULE_0__math_vector2__["m" /* dot */](n1, n2)));
}
const SEGMENT_VERTEX_COUNT = 4;
const SQUARE_CAP_VERTEX_COUNT = 5;
const ROUND_CAP_VERTEX_COUNT = 4;
const FLOAT_MAX = 3.4028234663852886e+38;
const MITER_LIMIT = 4;
const UV_POS_ONE_PACKED = 255; // packed 1
const UV_NEG_ONE_PACKED = 1; // packed -1
const UV_ZERO_PACKED = 128;
/**
 * Packs a component of uv into a unsigned 8-bit value. After packing -1 will
 * become 1 and 1 will become 255. That's need to emulate zero-preserving
 * normalization (we can't rely on WebGL to do it for us :().
 *
 * @param c The component.
 * @returns Packed component.
 */
function packUvComponent(c) {
    // We don't truncate here because buffer writer will do that for us.
    return 128 + (127 * c);
}
/**
 * Half width of the polyline is stored in a normalized attribute. This constant
 * defines half width value of 1 corresponds to.
 */
const MAX_HALF_WIDTH = 255 / 4;
/* harmony export (immutable) */ __webpack_exports__["b"] = MAX_HALF_WIDTH;
 // px
/**
 * Same as for polyline half width, but for dash pattern definition.
 */
const MAX_FILL_GAP = 255;
/* harmony export (immutable) */ __webpack_exports__["a"] = MAX_FILL_GAP;
 // px
class PolylineBufferWriter extends __WEBPACK_IMPORTED_MODULE_2__util_buffer_writer__["b" /* default */] {
    constructor() {
        super(__WEBPACK_IMPORTED_MODULE_3__polyline_attribute_mapping__["a" /* POLYLINE_ATTRIBUTE_MAPPING */].vertexByteSize);
        this._displacement = __WEBPACK_IMPORTED_MODULE_0__math_vector2__["f" /* create */](0, 0);
        this._prevDisplacement = __WEBPACK_IMPORTED_MODULE_0__math_vector2__["f" /* create */](0, 0);
        this._initPolylineState([__WEBPACK_IMPORTED_MODULE_0__math_vector2__["a" /* ZERO */], __WEBPACK_IMPORTED_MODULE_0__math_vector2__["a" /* ZERO */]], 0, 0, 0, 0, 0 /* MITER */, 0);
    }
    /**
     * Generates a mesh for a polyline with a given style, baking all necessary
     * parameters into attributes.
     *
     * @param polyline The polyline.
     * @param style The polyline style.
     * @returns Location of the written mesh in the managed buffers.
     */
    writePolyline(polyline, style, zIndex) {
        const { vertices } = polyline;
        const lastIdx = vertices.length - 1;
        if (lastIdx < 1) {
            throw new Error('One vertex in not a polyline. It\'s not even a line.');
        }
        this._initPolylineState(vertices, Object(__WEBPACK_IMPORTED_MODULE_1__util_color__["d" /* encodeRgba8 */])(style.strokeColor), style.strokeWidth, style.dash ? style.dash.fill : 0, style.dash ? style.dash.gap : 0, style.join, Object(__WEBPACK_IMPORTED_MODULE_5__util_z_index__["a" /* intToZIndex */])(zIndex));
        this._writeCap(style.startCap, vertices[0], 1);
        for (let i = 1; i < lastIdx; ++i) {
            this._writeSegment(vertices[i - 1], vertices[i], vertices[i + 1]);
            this._writeJoin(vertices[i]);
        }
        this._writeLastSegment(vertices[lastIdx - 1], vertices[lastIdx]);
        this._writeCap(style.endCap, vertices[lastIdx], 1);
        return this.endMesh();
    }
    _initPolylineState(vertices, colorRgba8, width, fill, gap, join, zIndex) {
        this._baseIndex = this._polylineLength = this._lastDirection = 0;
        this._lastSignedMiter = 1;
        const displacement = __WEBPACK_IMPORTED_MODULE_0__math_vector2__["s" /* sub */](vertices[1], vertices[0], this._displacement);
        this._segmentLength = __WEBPACK_IMPORTED_MODULE_0__math_vector2__["o" /* length */](displacement);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["k" /* divn */](displacement, this._segmentLength, displacement);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["r" /* rotate90 */](displacement, displacement);
        this._colorRgba8 = colorRgba8;
        this._halfWidthFillGapPacked =
            Object(__WEBPACK_IMPORTED_MODULE_4__util_gputypes__["c" /* floatToUint8 */])(Object(__WEBPACK_IMPORTED_MODULE_6__math_scalar__["a" /* clamp */])(0.5 * width, 0, MAX_HALF_WIDTH) / MAX_HALF_WIDTH) |
                Object(__WEBPACK_IMPORTED_MODULE_4__util_gputypes__["c" /* floatToUint8 */])(Object(__WEBPACK_IMPORTED_MODULE_6__math_scalar__["a" /* clamp */])(fill, 0, MAX_FILL_GAP) / MAX_FILL_GAP) << 8 |
                Object(__WEBPACK_IMPORTED_MODULE_4__util_gputypes__["c" /* floatToUint8 */])(Object(__WEBPACK_IMPORTED_MODULE_6__math_scalar__["a" /* clamp */])(gap, 0, MAX_FILL_GAP) / MAX_FILL_GAP) << 16;
        this._join = join;
        this._zIndex = zIndex;
    }
    /**
     * Writes a single vertex into managed vertex buffer.
     *
     * @param position Vertex world position.
     * @param normal Normal of segment the vertex belongs to.
     * @param u Normalized distance to the polyline along the normal.
     * @param v Normalized distance to the polyline along the tangent.
     * @param polylineLength Distance to the first vertex along the polyline.
     * @param miter Join miter.
     * @param lengthCorrectionLimit Limit on the vertex displacement along the
     *      polyline.
     */
    _writeVertex(position, normal, uPacked, vPacked, polylineLength, miter, lengthCorrectionLimit) {
        this._writeWorldCoordinate(position);
        this._writeHalfWords(Object(__WEBPACK_IMPORTED_MODULE_4__util_gputypes__["a" /* floatToUint16 */])(0.5 * (normal.x * Math.SQRT1_2 + 1)), Object(__WEBPACK_IMPORTED_MODULE_4__util_gputypes__["a" /* floatToUint16 */])(0.5 * (normal.y * Math.SQRT1_2 + 1)));
        this._writeHalfWords(uPacked, vPacked);
        this._writeWord(this._halfWidthFillGapPacked);
        this._writeFloat32(miter);
        this._writeFloat32(lengthCorrectionLimit);
        this._writeFloat32(polylineLength);
        this._writeWord(this._colorRgba8);
        this._writeFloat32(this._zIndex);
    }
    _writeCap(cap, endVertex, displacementSign) {
        switch (cap) {
            case 1 /* ROUND */:
                this._writeRoundCap(endVertex, displacementSign);
                break;
            case 2 /* SQUARE */:
                this._writeSquareCap(endVertex, displacementSign);
                break;
        }
    }
    _writeRoundCap(endVertex, displacementSign) {
        const displacement = __WEBPACK_IMPORTED_MODULE_0__math_vector2__["f" /* create */](0, 0);
        const polylineLength = this._polylineLength;
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["p" /* muln */](this._displacement, -displacementSign, displacement);
        this._writeVertex(endVertex, displacement, UV_NEG_ONE_PACKED, UV_ZERO_PACKED, polylineLength, 1, FLOAT_MAX);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["r" /* rotate90 */](this._displacement, displacement);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["s" /* sub */](displacement, this._displacement, displacement);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["p" /* muln */](displacement, displacementSign, displacement);
        this._writeVertex(endVertex, displacement, UV_NEG_ONE_PACKED, UV_POS_ONE_PACKED, polylineLength, 1, FLOAT_MAX);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["p" /* muln */](this._displacement, displacementSign, displacement);
        this._writeVertex(endVertex, displacement, UV_POS_ONE_PACKED, UV_ZERO_PACKED, polylineLength, 1, FLOAT_MAX);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["r" /* rotate90 */](this._displacement, displacement);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["b" /* add */](displacement, this._displacement, displacement);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["p" /* muln */](displacement, displacementSign, displacement);
        this._writeVertex(endVertex, displacement, UV_POS_ONE_PACKED, UV_POS_ONE_PACKED, polylineLength, 1, FLOAT_MAX);
        this.writeIndicesForContinuousStrip(ROUND_CAP_VERTEX_COUNT, this._baseIndex);
        this._baseIndex += ROUND_CAP_VERTEX_COUNT;
    }
    _writeSquareCap(endVertex, displacementSign) {
        const displacement = __WEBPACK_IMPORTED_MODULE_0__math_vector2__["f" /* create */](0, 0);
        const polylineLength = this._polylineLength;
        this._writeVertex(endVertex, __WEBPACK_IMPORTED_MODULE_0__math_vector2__["a" /* ZERO */], UV_ZERO_PACKED, UV_ZERO_PACKED, polylineLength, 1, 0);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["p" /* muln */](this._displacement, -displacementSign, displacement);
        this._writeVertex(endVertex, displacement, UV_POS_ONE_PACKED, UV_ZERO_PACKED, polylineLength, 1, FLOAT_MAX);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["r" /* rotate90 */](this._displacement, displacement);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["s" /* sub */](displacement, this._displacement, displacement);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["p" /* muln */](displacement, displacementSign, displacement);
        this._writeVertex(endVertex, displacement, UV_POS_ONE_PACKED, UV_ZERO_PACKED, polylineLength, 1, FLOAT_MAX);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["r" /* rotate90 */](this._displacement, displacement);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["s" /* sub */](displacement, this._displacement, displacement);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["p" /* muln */](displacement, displacementSign, displacement);
        this._writeVertex(endVertex, displacement, UV_POS_ONE_PACKED, UV_ZERO_PACKED, polylineLength, 1, FLOAT_MAX);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["p" /* muln */](this._displacement, displacementSign, displacement);
        this._writeVertex(endVertex, this._displacement, UV_POS_ONE_PACKED, UV_ZERO_PACKED, polylineLength, 1, FLOAT_MAX);
        this.writeIndicesForContinuousFan(SQUARE_CAP_VERTEX_COUNT, this._baseIndex);
        this._baseIndex += SQUARE_CAP_VERTEX_COUNT;
    }
    _writeSegment(start, end, nextEnd) {
        const displacement = this._displacement;
        const polylineLength = this._polylineLength;
        const nextSegmentLength = __WEBPACK_IMPORTED_MODULE_0__math_vector2__["j" /* distance */](nextEnd, end);
        const nextSegmentNormal = __WEBPACK_IMPORTED_MODULE_0__math_vector2__["s" /* sub */](nextEnd, end);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["k" /* divn */](nextSegmentNormal, nextSegmentLength, nextSegmentNormal);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["r" /* rotate90 */](nextSegmentNormal, nextSegmentNormal);
        const direction1 = this._lastDirection;
        const direction2 = Math.sign(__WEBPACK_IMPORTED_MODULE_0__math_vector2__["i" /* crossZ */](displacement, nextSegmentNormal));
        const miter1 = this._lastSignedMiter;
        const miter2 = computeMiter(displacement, nextSegmentNormal);
        this._writeVertex(start, displacement, UV_POS_ONE_PACKED, UV_ZERO_PACKED, polylineLength, direction1 === -1 && (this._join !== 0 /* MITER */ || Math.abs(miter1) > MITER_LIMIT) ?
            1 :
            miter1, direction1 === -1 ? -FLOAT_MAX : 0.5 * this._segmentLength);
        this._writeVertex(end, displacement, UV_POS_ONE_PACKED, UV_ZERO_PACKED, polylineLength + this._segmentLength, direction2 === -1 && (this._join !== 0 /* MITER */ || miter2 > MITER_LIMIT) ?
            1 :
            direction2 * miter2, direction2 === -1 ? FLOAT_MAX : -0.5 * this._segmentLength);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["n" /* invert */](displacement, displacement);
        this._writeVertex(start, displacement, UV_NEG_ONE_PACKED, UV_ZERO_PACKED, polylineLength, direction1 === 1 && (this._join !== 0 /* MITER */ || Math.abs(miter1) > MITER_LIMIT) ?
            1 :
            miter1, direction1 === 1 ? -FLOAT_MAX : 0.5 * this._segmentLength);
        this._writeVertex(end, displacement, UV_NEG_ONE_PACKED, UV_ZERO_PACKED, polylineLength + this._segmentLength, direction2 === 1 && (this._join !== 0 /* MITER */ || miter2 > MITER_LIMIT) ?
            1 :
            direction2 * miter2, direction2 === 1 ? FLOAT_MAX : -0.5 * this._segmentLength);
        this.writeIndicesForContinuousStrip(SEGMENT_VERTEX_COUNT, this._baseIndex);
        this._baseIndex += SEGMENT_VERTEX_COUNT;
        this._lastSignedMiter = -direction2 * miter2;
        this._lastDirection = direction2;
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["e" /* copy */](displacement, this._prevDisplacement);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["e" /* copy */](nextSegmentNormal, displacement);
        this._polylineLength += this._segmentLength;
        this._segmentLength = nextSegmentLength;
    }
    _writeJoin(joinVertex) {
        switch (this._join) {
            case 2 /* BEVEL */:
                this._writeBevelJoin(joinVertex);
                break;
            case 1 /* ROUND */:
                this._writeRoundJoin(joinVertex);
                break;
            case 0 /* MITER */:
                if (Math.abs(this._lastSignedMiter) > MITER_LIMIT) {
                    this._writeBevelJoin(joinVertex);
                }
                break;
        }
    }
    _writeBevelJoin(joinVertex) {
        const lastDirection = this._lastDirection;
        const displacement = __WEBPACK_IMPORTED_MODULE_0__math_vector2__["n" /* invert */](this._displacement);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["b" /* add */](displacement, this._prevDisplacement, displacement);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["p" /* muln */](displacement, 0.5 * lastDirection, displacement);
        this._writeVertex(joinVertex, displacement, lastDirection === -1 /* LEFT */ ?
            UV_POS_ONE_PACKED :
            UV_NEG_ONE_PACKED, UV_ZERO_PACKED, this._polylineLength, 1, 1);
        const baseIndex = this._baseIndex;
        this.writeIndices([
            baseIndex - 1,
            baseIndex - 3,
            baseIndex,
            baseIndex,
            lastDirection === -1 /* LEFT */ ? baseIndex + 1 : baseIndex + 3,
            lastDirection === -1 /* LEFT */ ? baseIndex + 3 : baseIndex + 1
        ]);
        this._baseIndex += 1;
    }
    _writeRoundJoin(joinVertex) {
        const polylineLength = this._polylineLength;
        this._writeVertex(joinVertex, __WEBPACK_IMPORTED_MODULE_0__math_vector2__["a" /* ZERO */], UV_ZERO_PACKED, UV_ZERO_PACKED, polylineLength, 0, 0);
        const lastDirection = this._lastDirection;
        const middleDisplacement = __WEBPACK_IMPORTED_MODULE_0__math_vector2__["n" /* invert */](this._prevDisplacement);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["b" /* add */](this._displacement, middleDisplacement, middleDisplacement);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["q" /* normalize */](middleDisplacement, middleDisplacement);
        const displacement = __WEBPACK_IMPORTED_MODULE_0__math_vector2__["n" /* invert */](this._prevDisplacement);
        const miter1 = computeMiter(middleDisplacement, displacement);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["b" /* add */](displacement, middleDisplacement, displacement);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["q" /* normalize */](displacement, displacement);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["p" /* muln */](displacement, -lastDirection * miter1, displacement);
        this._writeVertex(joinVertex, displacement, lastDirection === -1 /* LEFT */ ?
            UV_POS_ONE_PACKED :
            UV_NEG_ONE_PACKED, packUvComponent(Math.sqrt(miter1 * miter1 - 1)), polylineLength, 1, FLOAT_MAX);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["p" /* muln */](middleDisplacement, -lastDirection, displacement);
        this._writeVertex(joinVertex, displacement, lastDirection === -1 /* LEFT */ ?
            UV_POS_ONE_PACKED :
            UV_NEG_ONE_PACKED, UV_ZERO_PACKED, polylineLength, 1, FLOAT_MAX);
        const miter2 = computeMiter(middleDisplacement, this._displacement);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["b" /* add */](this._displacement, middleDisplacement, displacement);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["q" /* normalize */](displacement, displacement);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["p" /* muln */](displacement, -lastDirection * miter2, displacement);
        this._writeVertex(joinVertex, displacement, lastDirection === -1 /* LEFT */ ?
            UV_POS_ONE_PACKED :
            UV_NEG_ONE_PACKED, packUvComponent(Math.sqrt(miter2 * miter2 - 1)), polylineLength, 1, FLOAT_MAX);
        const baseIndex = this._baseIndex;
        this.writeIndices([
            baseIndex - 3,
            baseIndex - 1,
            baseIndex,
            baseIndex,
            lastDirection === -1 /* LEFT */ ? baseIndex - 3 : baseIndex - 1,
            baseIndex + 1,
            baseIndex,
            baseIndex + 1,
            baseIndex + 2,
            baseIndex,
            baseIndex + 2,
            baseIndex + 3,
            baseIndex,
            baseIndex + 3,
            lastDirection === -1 /* LEFT */ ? baseIndex + 4 : baseIndex + 6,
            baseIndex,
            baseIndex + 4,
            baseIndex + 6
        ]);
        this._baseIndex += 4;
    }
    _writeLastSegment(start, end) {
        const displacement = this._displacement;
        const lastDirection = this._lastDirection;
        const polylineLength = this._polylineLength;
        const miter = this._lastSignedMiter;
        this._writeVertex(start, displacement, UV_POS_ONE_PACKED, UV_ZERO_PACKED, polylineLength, lastDirection === -1 /* LEFT */ && (this._join !== 0 /* MITER */ || Math.abs(miter) > MITER_LIMIT) ?
            1 :
            miter, lastDirection === -1 /* LEFT */ ? -FLOAT_MAX : this._segmentLength);
        this._writeVertex(end, displacement, UV_POS_ONE_PACKED, UV_ZERO_PACKED, polylineLength + this._segmentLength, 1, FLOAT_MAX);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["n" /* invert */](displacement, displacement);
        this._writeVertex(start, displacement, UV_NEG_ONE_PACKED, UV_ZERO_PACKED, polylineLength, lastDirection === 1 /* RIGHT */ && (this._join !== 0 /* MITER */ || Math.abs(miter) > MITER_LIMIT) ?
            1 :
            miter, lastDirection === 1 /* RIGHT */ ? -FLOAT_MAX : this._segmentLength);
        this._writeVertex(end, displacement, UV_NEG_ONE_PACKED, UV_ZERO_PACKED, polylineLength + this._segmentLength, 1, FLOAT_MAX);
        this.writeIndicesForContinuousStrip(SEGMENT_VERTEX_COUNT, this._baseIndex);
        this._baseIndex += SEGMENT_VERTEX_COUNT;
    }
}
/* unused harmony export default */



/***/ }),
/* 138 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\n#ifndef FILTER_RADIUS\n#   error FILTER_RADIUS must be set\n#endif\n\n#ifndef MAX_HALF_WIDTH\n#   error MAX_HALF_WIDTH must be set\n#endif\n\n#ifndef MAX_FILL_GAP\n#   error MAX_FILL_GAP must be set\n#endif\n\nattribute vec4 vertexPos;\nattribute vec2 vertexNormalPacked;\nattribute vec2 vertexUvPacked;\nattribute vec3 vertexWidthFillGap;\nattribute vec4 vertexColor;\nattribute float vertexMiter;\nattribute float vertexVLimit;\nattribute float vertexLength;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\nuniform float worldToPxFactor;\n\nvarying vec2 uv;\nvarying float len;\nvarying float halfWidth;\nvarying vec3 dash;\nvarying vec4 color;\n\nconst float YV_H = 1.999969482421875;\nconst float YV_L = 0.000030517112463712692;\nconst vec4 YV_HHLL = vec4(YV_H, YV_H, YV_L, YV_L);\n\nconst float SQRT2 = 1.4142135381698608;\n\nvec2 unpackUv(const in vec2 uv) {\n    return (uv - 128.) / 127.;\n}\n\nvoid main(void) {\n    vec2 normal = (2.0 * vertexNormalPacked - 1.0) * SQRT2;\n\n    halfWidth = float(MAX_HALF_WIDTH) * vertexWidthFillGap.x;\n    halfWidth += FILTER_RADIUS;\n\n    float tangentLength = min(\n        sqrt(vertexMiter * vertexMiter - 1.) * halfWidth * worldToPxFactor,\n        abs(vertexVLimit)\n    );\n\n    vec4 lookAt = vec4(lookAtHigh, lookAtLow);\n    vec4 relativeToEyePosition = YV_HHLL * (vertexPos - lookAt);\n\n    gl_Position = viewProjMatrix * vec4(\n        relativeToEyePosition.xy + relativeToEyePosition.zw +\n                worldToPxFactor * halfWidth * normal -\n                    sign(vertexMiter) * tangentLength * vec2(normal.y, -normal.x),\n        0,\n        1\n    );\n\n    uv = unpackUv(vertexUvPacked) * halfWidth;\n    len = (vertexLength + sign(vertexVLimit) * tangentLength) / worldToPxFactor;\n\n    dash.xy = vec2(MAX_FILL_GAP) * vertexWidthFillGap.yz;\n    dash.z = dash.x + dash.y;\n\n    color = vertexColor;\n    color.rgb *= color.a;\n}\n"

/***/ }),
/* 139 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\n#ifndef FILTER_RADIUS\n#   error FILTER_RADIUS must be set\n#endif\n\nvarying highp vec2 uv;\nvarying highp float len;\nvarying highp float halfWidth;\nvarying lowp vec3 dash;\nvarying lowp vec4 color;\n\nvoid main(void) {\n    lowp float alpha =\n        smoothstep(0.0, FILTER_RADIUS + min(FILTER_RADIUS, halfWidth), halfWidth - length(uv));\n\n    if (dash.z > 0.0) {\n        lowp vec3 halfDash = dash * 0.5;\n        lowp float dashPhase = mod(len + halfDash.y, dash.z);\n        lowp float r = min(FILTER_RADIUS, halfDash.y);\n\n        alpha *= smoothstep(-r, r, halfDash.x - abs(dashPhase - halfDash.z));\n    }\n\n    gl_FragColor = color * alpha;\n}\n"

/***/ }),
/* 140 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_textured_polygon_vert__ = __webpack_require__(141);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_textured_polygon_vert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__shader_textured_polygon_vert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_textured_polygon_frag__ = __webpack_require__(142);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_textured_polygon_frag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__shader_textured_polygon_frag__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math_vector2__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__render_state__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__world_primitive_render_unit__ = __webpack_require__(5);






const RENDER_STATE = new __WEBPACK_IMPORTED_MODULE_3__render_state__["c" /* default */](__WEBPACK_IMPORTED_MODULE_3__render_state__["b" /* BLEND_OVER_RENDER_STATE */], {
    depthTest: true,
    depthMask: false,
    depthFunc: 518 /* GREATER_OR_EQUAL */
});
/**
 * Renderer of polyline primitives.
 */
class TexturedPolygonRenderUnit extends __WEBPACK_IMPORTED_MODULE_4__world_primitive_render_unit__["a" /* default */] {
    constructor(context, primitiveProvider) {
        const program = context.createProgram(__WEBPACK_IMPORTED_MODULE_0__shader_textured_polygon_vert___default.a, __WEBPACK_IMPORTED_MODULE_1__shader_textured_polygon_frag___default.a, {
            attribMap: {
                vertexPosHigh: 0 /* POSITION_HIGH */,
                vertexPosLow: 1 /* POSITION_LOW */,
                vertexUV: 4 /* UV */,
                vertexImageScale: 11 /* AUX */,
                vertexZIndex: 10 /* Z_INDEX */
            }
        });
        super(context, RENDER_STATE, program, primitiveProvider);
        this._atlasSizeUniform = __WEBPACK_IMPORTED_MODULE_2__math_vector2__["f" /* create */](0, 0);
        context.bindProgram(program);
        program.setIntScalarUniform('atlas', 0);
    }
    _renderBatch(memoryBatch) {
        const atlas = memoryBatch.firstPrimitive.atlas;
        this._atlasSizeUniform.x = atlas.width;
        this._atlasSizeUniform.y = atlas.height;
        if (atlas.isDirty) {
            atlas.syncTexture();
        }
        this._program.setVector2Uniform('atlasSize', this._atlasSizeUniform);
        this._context.bindTextureUnit(0);
        this._context.bindTexture(atlas.texture);
        super._renderBatch(memoryBatch);
    }
    _canBatchAdjacentPrimitives(a, b) {
        return super._canBatchAdjacentPrimitives(a, b) && (a.atlas === b.atlas);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = TexturedPolygonRenderUnit;



/***/ }),
/* 141 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec2 vertexPosHigh;\nattribute vec2 vertexPosLow;\nattribute vec4 vertexUV;\nattribute float vertexImageScale;\nattribute float vertexZIndex;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\n\nvarying vec2 uvPosition;\nvarying vec2 textureSize;\nvarying vec2 uvDisplacement;\n\nconst float YV_H = 1.999969482421875;\nconst float YV_L = 0.000030517112463712692;\n\nvoid main(void) {\n    uvPosition = vertexUV.xy;\n    textureSize = vertexUV.zw;\n\n    // The same pattern image should match across multiple (usually adjacent) polygons and it should have\n    // stable position realtive to the polygon. Also pattern is repeated at both directions.\n    // To meet these requirements the world is covered (virtually) by a texture of appropriate size (repeated image)\n    // and vertex coordinates are mapped to these texture coordinates (uvDisplacement).\n    // But due to limited precision we've got to work with \"narrow\" floats (as it is done in world position calculation):\n    //   1. calculate how big texture pattern in world coordinates (scaledTextureSize)\n    //   2. find the closest to eye coordinates texture base point (the bottom left point of the pattern)\n    //   3. use vertex position and textureBasePoint vectors to find coordinates in virtual texture\n    //   4. find uv coordinates in real texture using mod operation\n    //\n    // Both textureBasePoint and position are relativelly small vectors so that precision requirements are met,\n    // and correct interpolation of repeated image is possible by using single base point in all vertices.\n\n    vec2 scaledTextureSize = textureSize * vertexImageScale; // texture size in world coordinates\n    vec2 textureBasePoint = mod(YV_H * lookAtHigh, scaledTextureSize) + mod(YV_L * lookAtLow, scaledTextureSize);\n    vec2 position = YV_H * (vertexPosHigh - lookAtHigh) + YV_L * (vertexPosLow - lookAtLow);\n\n    gl_Position = viewProjMatrix * vec4(position, 0, 1);\n    gl_Position.xy /= gl_Position.w;\n    gl_Position.z = vertexZIndex;\n    gl_Position.w = 1.0;\n\n    // convert world coordinates back to teture pixels\n    uvDisplacement = (position + textureBasePoint) / vertexImageScale;\n}\n"

/***/ }),
/* 142 */
/***/ (function(module, exports) {

module.exports = "#version 100\n\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform sampler2D atlas;\nuniform vec2 atlasSize;\n\nvarying vec2 uvPosition;\nvarying vec2 textureSize;\nvarying vec2 uvDisplacement;\n\nvoid main(void) {\n    vec2 uvAdjusted = vec2(\n        uvPosition.x + mod(uvDisplacement.x, textureSize.x),\n        uvPosition.y + mod(uvDisplacement.y, textureSize.y)\n    );\n\n    gl_FragColor = texture2D(atlas, uvAdjusted / atlasSize);\n}\n"

/***/ }),
/* 143 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polygon_render_unit__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__render_state__ = __webpack_require__(0);




/**
 * Renderer of transparent polygon primitives.
 */
class TransparentPolygonRenderUnit extends __WEBPACK_IMPORTED_MODULE_0__polygon_render_unit__["b" /* default */] {
    constructor(context, primitiveProvider) {
        super(context, primitiveProvider, new __WEBPACK_IMPORTED_MODULE_1__render_state__["c" /* default */](__WEBPACK_IMPORTED_MODULE_0__polygon_render_unit__["a" /* DEFAULT_RENDER_STATE_PARAMS */], { depthMask: false }, __WEBPACK_IMPORTED_MODULE_1__render_state__["b" /* BLEND_OVER_RENDER_STATE */]));
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = TransparentPolygonRenderUnit;



/***/ }),
/* 144 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec2 vertexPosHigh;\nattribute vec2 vertexPosLow;\nattribute vec4 vertexColor;\nattribute float vertexZIndex;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\n\nvarying vec4 color;\n\nconst float YV_H = 1.999969482421875;\nconst float YV_L = 0.000030517112463712692;\n\nvoid main(void) {\n    vec4 position = viewProjMatrix * vec4(\n        YV_H * (vertexPosHigh - lookAtHigh) +\n            YV_L * (vertexPosLow - lookAtLow),\n        0,\n        1\n    );\n\n    position.xy /= position.w;\n    position.z = vertexZIndex;\n    position.w = 1.0;\n\n    gl_Position = position;\n\n    color = vertexColor;\n}\n"

/***/ }),
/* 145 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nvarying lowp vec4 color;\n\nvoid main(void) {\n    gl_FragColor = color;\n}\n"

/***/ }),
/* 146 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__engine__ = __webpack_require__(147);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__render_fxaa_render_unit__ = __webpack_require__(177);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__render_background_render_unit__ = __webpack_require__(179);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__render_layer_render_unit__ = __webpack_require__(181);




/**
 * Ground layer with background that goes right after sub render units. It allows to add other LayerRenderUnits above
 * groundLayer without worrying that they destroy depth information collected on ground and broke background (that has
 * a performance optimisation: it uses depth information from the layers below to prevent extensive pixel overwriting).
 */
class BackgroundedGroundLayer extends __WEBPACK_IMPORTED_MODULE_3__render_layer_render_unit__["a" /* default */] {
    constructor(context, depthClearStrategy = 0 /* NO_CLEAR */) {
        super(context, depthClearStrategy);
        this._background = new __WEBPACK_IMPORTED_MODULE_2__render_background_render_unit__["a" /* default */](context);
    }
    render(target, ...args) {
        super.render(target, ...args);
        this._background.render(target);
    }
}
class MapEngine extends __WEBPACK_IMPORTED_MODULE_0__engine__["a" /* default */] {
    constructor(context, camera, renderLoop) {
        super(context, camera, renderLoop);
        this._destroyables = [];
        const antialiasingLayer = new __WEBPACK_IMPORTED_MODULE_1__render_fxaa_render_unit__["a" /* default */](context, this.renderLoop);
        this.backgoundLayer = new __WEBPACK_IMPORTED_MODULE_3__render_layer_render_unit__["a" /* default */](context);
        this.groundLayer = new BackgroundedGroundLayer(context);
        this.buildingsLayer = new __WEBPACK_IMPORTED_MODULE_3__render_layer_render_unit__["a" /* default */](context);
        this.iconsLayer = new __WEBPACK_IMPORTED_MODULE_3__render_layer_render_unit__["a" /* default */](context);
        this.labelsLayer = new __WEBPACK_IMPORTED_MODULE_3__render_layer_render_unit__["a" /* default */](context);
        antialiasingLayer.addRenderUnit(this.buildingsLayer);
        this.renderer.addRenderUnit(this.backgoundLayer);
        this.renderer.addRenderUnit(this.groundLayer);
        this.renderer.addRenderUnit(antialiasingLayer);
        this.renderer.addRenderUnit(this.iconsLayer);
        this.renderer.addRenderUnit(this.labelsLayer);
        this._destroyables.push(antialiasingLayer);
        // force initial rendering (no data yet, just background) as the canvas (black) can already be visible to users,
        // renderer is called directly (without scheduling via render loop) as it is pretty much safe to assume
        // that no rendering is scheduled for this frame, and deferred update can potentially cause a single frame blink
        this.renderer.render(this._renderTarget);
    }
    destroy() {
        // destroy in reverse order to prevent potential issues if destroyables own each other
        for (let i = this._destroyables.length - 1; i >= 0; i--) {
            this._destroyables[i].destroy();
        }
        super.destroy();
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = MapEngine;



/***/ }),
/* 147 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_event_emitter__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__render_font_renderable_df_glyph_atlas__ = __webpack_require__(148);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__font_df_font_registry__ = __webpack_require__(150);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__render_billboard_renderable_image_atlas__ = __webpack_require__(152);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__visibility_visibility_manager__ = __webpack_require__(157);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__util_median_filter__ = __webpack_require__(172);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__util_stat__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__render_main_render_unit__ = __webpack_require__(173);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__render_memory_manager__ = __webpack_require__(174);









class Engine {
    constructor(context, camera, renderLoop) {
        this.context = context;
        this._camera = camera;
        this._renderTarget = context.getDefaultRenderTarget();
        this.renderer = new __WEBPACK_IMPORTED_MODULE_7__render_main_render_unit__["a" /* default */](context, camera);
        this.renderLoop = renderLoop;
        this.memoryManager = new __WEBPACK_IMPORTED_MODULE_8__render_memory_manager__["a" /* default */](context);
        this._atlases = new Set();
        this.visibilityManager = new __WEBPACK_IMPORTED_MODULE_4__visibility_visibility_manager__["a" /* default */](context, camera, renderLoop, this._renderTarget.getWidth(), this._renderTarget.getHeight());
        this.visbilityTextureProvider = () => {
            this.visibilityManager.updateVisibilityIfNeeded();
            return this.visibilityManager.visibilityTexture;
        };
        this._frameTimingsListener = this._onFrameTimesFull.bind(this);
        renderLoop.onFrameTimesFull.addListener(this._frameTimingsListener);
        this._renderListener = this._onRender.bind(this);
        renderLoop.onRender.addListener(this._renderListener);
        this._updateListener = () => this.renderLoop.update();
        this.glyphAtlas = new __WEBPACK_IMPORTED_MODULE_1__render_font_renderable_df_glyph_atlas__["a" /* default */](context);
        this.fontRegistry = new __WEBPACK_IMPORTED_MODULE_2__font_df_font_registry__["a" /* default */]();
        this.onInternalError = new __WEBPACK_IMPORTED_MODULE_0__util_event_emitter__["b" /* VoidEventEmitter */]();
        this._camera.onUpdate.addListener(this._updateListener);
        this.renderer.onUpdate.addListener(this._updateListener);
        this._contextLostListener = () => this.onInternalError.fire();
        this.context.onLoss.addListener(this._contextLostListener);
    }
    setRenderTargetSize(width, height) {
        if (this._renderTarget.getWidth() !== width ||
            this._renderTarget.getHeight() !== height) {
            this._renderTarget.setSize(width, height);
            this.visibilityManager.setTargetSize(width, height);
        }
    }
    createImageAtlas(params) {
        const atlas = new __WEBPACK_IMPORTED_MODULE_3__render_billboard_renderable_image_atlas__["a" /* default */](this.context, params);
        atlas.onContentUpdate.addListener(this._updateListener);
        this._atlases.add(atlas);
        return atlas;
    }
    removeImageAtlas(atlas) {
        atlas.destroy();
        atlas.onContentUpdate.removeListener(this._updateListener);
        this._atlases.delete(atlas);
    }
    getCamera() {
        return this._camera;
    }
    destroy() {
        this._camera.onUpdate.removeListener(this._updateListener);
        this.renderer.onUpdate.removeListener(this._updateListener);
        for (const atlas of this._atlases) {
            atlas.onContentUpdate.removeListener(this._updateListener);
            atlas.destroy();
        }
        this.glyphAtlas.destroy();
        this.context.onLoss.removeListener(this._contextLostListener);
    }
    _onRender() {
        this.renderer.render(this._renderTarget);
    }
    _onFrameTimesFull(times) {
        Object(__WEBPACK_IMPORTED_MODULE_6__util_stat__["a" /* countFps */])(1e3 * times.length / Object(__WEBPACK_IMPORTED_MODULE_5__util_median_filter__["a" /* medianFilter */])(times).reduce((sum, time) => sum + time));
        // For now we acquire frame timing and log them only once a session.
        this.renderLoop.onFrameTimesFull.removeListener(this._frameTimingsListener);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Engine;



/***/ }),
/* 148 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__font_df_glyph_atlas__ = __webpack_require__(149);

/**
 * Atlas that manages allocation in GL texture.
 */
class RenderableDfGlyphAtlas extends __WEBPACK_IMPORTED_MODULE_0__font_df_glyph_atlas__["a" /* default */] {
    constructor(context) {
        super(0, 0, new Uint8Array(0), new Map());
        this._context = context;
        this.texture = this._createTexture(0, 0);
    }
    destroy() {
        this.texture.destroy();
    }
    /**
     * Updates the whole content of the glyph bitmap atlas, texture also get updated.
     *
     * @param width new bitmap width
     * @param height new bitmap height
     * @param data, length should be strictly equal to width * height
     */
    updateContent(width, height, data, glyphLocations) {
        this.width = width;
        this.height = height;
        this.data = data;
        this._glyphLocations = glyphLocations;
        const texture = this.texture;
        if (!texture || texture.getWidth() !== width || texture.getHeight() !== height) {
            if (this.texture) {
                this.texture.destroy();
            }
            this.texture = this._createTexture(width, height);
        }
        this._context.setTextureData(this.texture, data);
    }
    _createTexture(width, height) {
        return this._context.createEmpty2DTexture(width, height, 6406 /* ALPHA */, 5121 /* UNSIGNED_BYTE */, {
            wrapS: 33071 /* CLAMP_TO_EDGE */,
            wrapT: 33071 /* CLAMP_TO_EDGE */,
            magnificationFilter: 9729 /* LINEAR */,
            minificationFilter: 9729 /* LINEAR */,
            premultipliedAlpha: false
        });
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RenderableDfGlyphAtlas;



/***/ }),
/* 149 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
const UNKNOWN_GLYPH_LOCATION = {
    minX: 0,
    maxX: 0,
    minY: 0,
    maxY: 0
};
/**
 * Abstract glyph atlas interface.
 */
class DfGlyphAtlas {
    constructor(width, height, data, glyphLocations) {
        this.width = width;
        this.height = height;
        this.data = data;
        this._glyphLocations = glyphLocations;
    }
    /**
     * @return Glyph location or fake location pointing to the origin (0, 0).
     */
    getGlyphLocation(fontId, glyphId) {
        const glyphLocation = this._glyphLocations.get(fontId + glyphId);
        if (glyphLocation) {
            return glyphLocation;
        }
        else {
            console.warn('Wow-wow-wow, something went wrong, you should not request nonexistent glyph locations');
            return UNKNOWN_GLYPH_LOCATION;
        }
    }
    /**
     * @return All glyph locations as [glyph id, glyph location] array. Glyph id is font id concatenated with glyph id.
     */
    getAllGlyphLocations() {
        return [...this._glyphLocations.entries()];
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = DfGlyphAtlas;



/***/ }),
/* 150 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__font_registry__ = __webpack_require__(151);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__df_font__ = __webpack_require__(28);


/**
 * Registry that stores distance field fonts.
 */
class DfFontRegistry extends __WEBPACK_IMPORTED_MODULE_0__font_registry__["a" /* default */] {
    constructor() {
        super(new __WEBPACK_IMPORTED_MODULE_1__df_font__["a" /* default */]('UNKNOWN_DF_FONT', 14, 0));
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = DfFontRegistry;



/***/ }),
/* 151 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * A central storage of all available fonts.
 */
class FontRegistry {
    /**
     * @param unknownFontInstance An instance of specific font type to be served as a stub when nonexistent font
     *     is requested. Requesting nonexistent fonts normally should not happen.
     *     The stub just allows to avoid tedious null checks in registry clients.
     */
    constructor(unknownFontInstance) {
        this._fonts = new Map();
        this._unknownFontInstance = unknownFontInstance;
    }
    /**
     * @return If a font with specified id is in the registry.
     */
    contains(fontId) {
        return this._fonts.has(fontId);
    }
    /**
     * @return Font with specified id or unknown font instance if it is not found.
     */
    get(fontId) {
        const font = this._fonts.get(fontId);
        if (font) {
            return font;
        }
        else {
            console.warn('Wow-wow-wow, something went wrong, you should not request nonexistent fonts');
            return this._unknownFontInstance;
        }
    }
    /**
     * @return All stored fonts.
     */
    getAll() {
        return [...this._fonts.values()];
    }
    /**
     * Adds new for to the registry.
     */
    add(font) {
        this._fonts.set(font.id, font);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = FontRegistry;



/***/ }),
/* 152 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__billboard_image_atlas__ = __webpack_require__(153);

/**
 * Atlas that manages allocation in GL texture.
 */
class RenderableImageAtlas extends __WEBPACK_IMPORTED_MODULE_0__billboard_image_atlas__["a" /* default */] {
    constructor(context, params) {
        super();
        const { filter, premultipliedAlpha } = params;
        this._context = context;
        this._filter = filter;
        this._premultipliedAlpha = premultipliedAlpha;
        this.texture = this._createTexture(this.width, this.height, filter, premultipliedAlpha);
        this.isDirty = false;
    }
    /**
     * Updates GL texture with changed data. Should be called after each image added to take effect in shaders.
     */
    syncTexture() {
        this._context.setTextureDataFromDomElement(this.texture, this.canvas);
        this.isDirty = false;
    }
    updateImage(location, sourceImage, locationRegion, sourceImageRegion) {
        super.updateImage(location, sourceImage, locationRegion, sourceImageRegion);
        this.isDirty = true;
    }
    destroy() {
        this.texture.destroy();
    }
    _expand(newWidth, newHeight) {
        super._expand(newWidth, newHeight);
        this.texture.destroy();
        this.texture = this._createTexture(this.width, this.height, this._filter, this._premultipliedAlpha);
        this.isDirty = true;
    }
    _createTexture(width, height, filter, premultipliedAlpha) {
        return this._context.createEmpty2DTexture(width, height, 6408 /* RGBA */, 5121 /* UNSIGNED_BYTE */, {
            minificationFilter: filter,
            magnificationFilter: filter,
            wrapS: 33071 /* CLAMP_TO_EDGE */,
            wrapT: 33071 /* CLAMP_TO_EDGE */,
            premultipliedAlpha
        });
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RenderableImageAtlas;



/***/ }),
/* 153 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_vector2__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_allocator_2d__ = __webpack_require__(154);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_event_emitter__ = __webpack_require__(2);



const INIT_ATLAS_WIDTH = 256;
const INIT_ATLAS_HEIGHT = 256;
const MAX_ATLAS_WIDTH = 2048;
const MAX_ATLAS_HEIGHT = 2048;
const EXPAND_FACTOR = 2;
/**
 * Manages allocation of images. It resizes itself (up to a fixed limit) when there is no region
 * of enough size for the next image.
 */
class ImageAtlas {
    constructor(initAtlasWidth = INIT_ATLAS_WIDTH, initAtlasHeight = INIT_ATLAS_HEIGHT) {
        this.onContentUpdate = new __WEBPACK_IMPORTED_MODULE_2__util_event_emitter__["b" /* VoidEventEmitter */]();
        this.canvas = document.createElement('canvas');
        this.canvas.width = initAtlasWidth;
        this.canvas.height = initAtlasHeight;
        this._canvasContext = this.canvas.getContext('2d');
        this._allocator = new __WEBPACK_IMPORTED_MODULE_1__util_allocator_2d__["a" /* ShelfAllocator2D */](this.width, this.height);
    }
    get width() {
        return this.canvas.width;
    }
    get height() {
        return this.canvas.height;
    }
    /**
     * Allocates image bitmap.
     */
    allocateImage(descriptor, image) {
        const location = this._allocate(descriptor);
        if (location) {
            const region = Object(__WEBPACK_IMPORTED_MODULE_0__math_vector2__["g" /* createBBox2 */])(0, descriptor.width, 0, descriptor.height);
            this.updateImage(location, image, region, region);
        }
        return location;
    }
    /**
     * Reserves space of appropriate size that can be updated later with updateImage() method.
     */
    reserveLocation(descriptor) {
        return this._allocate(descriptor);
    }
    /**
     * Updates image content in appropriate location. Assumes that there is really such location reserved,
     * no check for this is done.
     *
     * @param location Location in atlas of the image.
     * @param sourceImage Image to update atlas from.
     * @param locationRegion Region (bbox with coordinates relative to the location's bbox) of the location to update.
     * @param sourceImageRegion Region of the image (BBox2 in image's coordinate space) to be copied into atlas.
     */
    updateImage(location, sourceImage, locationRegion = Object(__WEBPACK_IMPORTED_MODULE_0__math_vector2__["g" /* createBBox2 */])(0, location.maxX - location.minX, 0, location.maxY - location.minY), sourceImageRegion = Object(__WEBPACK_IMPORTED_MODULE_0__math_vector2__["g" /* createBBox2 */])(0, sourceImage.width, 0, sourceImage.height)) {
        const srcX = sourceImageRegion.minX;
        const srcY = sourceImageRegion.minY;
        const srcW = sourceImageRegion.maxX - sourceImageRegion.minX;
        const srcH = sourceImageRegion.maxY - sourceImageRegion.minY;
        const dstX = location.minX + locationRegion.minX;
        const dstY = location.minY + locationRegion.minY;
        const dstW = locationRegion.maxX - locationRegion.minX;
        const dstH = locationRegion.maxY - locationRegion.minY;
        this._canvasContext.clearRect(dstX, dstY, dstW, dstH);
        this._canvasContext.drawImage(sourceImage, srcX, srcY, srcW, srcH, dstX, dstY, dstW, dstH);
        this.onContentUpdate.fire();
    }
    /**
     * Deallocates image from the atlas.
     */
    removeImage(image) {
        this._allocator.deallocate(image);
    }
    _allocate(descriptor) {
        let location = this._allocator.allocate(descriptor);
        // incremental expand can be inefficient if two or more iterations are needed to allocate an image,
        // but it is expected to be a rare (if any) case, rework if it turns out to be wrong
        while (!location) {
            const expandedWidth = this.width * EXPAND_FACTOR;
            const expandedHeight = this.height * EXPAND_FACTOR;
            if (expandedWidth <= MAX_ATLAS_WIDTH && expandedHeight <= MAX_ATLAS_HEIGHT) {
                this._expand(expandedWidth, expandedHeight);
                location = this._allocator.allocate(descriptor);
            }
            else {
                break;
            }
        }
        return location;
    }
    _expand(newWidth, newHeight) {
        this._allocator.resize(newWidth, newHeight);
        // setting new width/height to canvas will clear it,
        // so current data is saved to be restored immediately after resizing
        const data = this._canvasContext.getImageData(0, 0, this.width, this.height);
        this.canvas.width = newWidth;
        this.canvas.height = newHeight;
        this._canvasContext.putImageData(data, 0, 0);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ImageAtlas;



/***/ }),
/* 154 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__allocator__ = __webpack_require__(50);

/**
 * A rectangular region with fixed height. Utility class for shelf allocation defined below.
 */
class Shelf {
    constructor(width, height) {
        this.width = width;
        this.height = height;
        this._allocator = new __WEBPACK_IMPORTED_MODULE_0__allocator__["b" /* FreeListAllocator */](this.width);
    }
    allocate(width) {
        return this._allocator.allocate(width);
    }
    deallocate(offset) {
        this._allocator.deallocate(offset);
    }
    isAllocated(offset) {
        return this._allocator.isAllocated(offset);
    }
    canAllocate(width) {
        return this._allocator.maxAllocableSize >= width;
    }
    resize(width) {
        this._allocator.extend(width);
        this.width = width;
    }
}
/**
 * Allocates rectangles in "shelves" (height fixed regions). They are created of necessity when the next object doesnt
 * fit any existing shelf. To optimize space usage it tries to find the best shelf for allocation (min height diff).
 * A shelf when allocated is never deallocated back and exists during all the allocator lifetime.
 */
class ShelfAllocator2D {
    constructor(width, height) {
        this.width = width;
        this.height = height;
        this._shelves = new Map();
        this._shelfAllocator = new __WEBPACK_IMPORTED_MODULE_0__allocator__["a" /* ArenaAllocator */](height); // no shelf deallocation, that is why ArenaAllocator is fine
    }
    allocate(object) {
        let bestShelf;
        let bestShelfOffset = -1;
        let bestShelfRatio = -1;
        for (const [offset, shelf] of this._shelves.entries()) {
            const shelfRatio = object.height / shelf.height;
            if (shelfRatio === 1 && shelf.canAllocate(object.width)) {
                bestShelf = shelf;
                bestShelfOffset = offset;
                break;
            }
            else if (shelfRatio < 1 && shelfRatio > bestShelfRatio && shelf.canAllocate(object.width)) {
                bestShelf = shelf;
                bestShelfOffset = offset;
                bestShelfRatio = shelfRatio;
            }
        }
        if (!bestShelf && this._shelfAllocator.maxAllocableSize >= object.height && this.width >= object.width) {
            const offset = this._shelfAllocator.allocate(object.height);
            bestShelf = new Shelf(this.width, object.height);
            bestShelfOffset = offset;
            this._shelves.set(offset, bestShelf);
        }
        if (bestShelf) {
            const left = bestShelf.allocate(object.width);
            const top = bestShelfOffset;
            const location = {
                minX: left,
                maxX: left + object.width,
                minY: top,
                maxY: top + object.height
            };
            return location;
        }
        else {
            return null;
        }
    }
    deallocate(objectLocation) {
        const shelf = this._shelves.get(objectLocation.minY);
        if (shelf) {
            shelf.deallocate(objectLocation.minX);
        }
    }
    isAllocated(objectLocation) {
        const shelf = this._shelves.get(objectLocation.minY);
        return !!shelf && shelf.isAllocated(objectLocation.minX);
    }
    resize(width, height) {
        this._shelfAllocator.extend(height);
        for (const shelf of this._shelves.values()) {
            shelf.resize(width);
        }
        this.width = width;
        this.height = height;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ShelfAllocator2D;



/***/ }),
/* 155 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Simple implementation of Binary Search Tree.
 */
class BinarySearchTree {
    /**
     * @param comparator To specify the order of items, that can be any complex objects.
     */
    constructor(comparator) {
        this._comparator = comparator;
        this._size = 0;
    }
    /**
     * @returns The root element or `undefined` if the tree is empty.
     */
    get root() {
        return this._root;
    }
    /**
     * @returns The number of items in the tree.
     */
    get size() {
        return this._size;
    }
    /**
     * @returns The smallest element in the tree or `undefined` the the tree is empty.
     */
    get min() {
        if (this._root) {
            return this._min(this._root).value;
        }
        return undefined;
    }
    /**
     * @returns The biggest element in the tree or `undefined` the the tree is empty.
     */
    get max() {
        if (this._root) {
            return this._max(this._root).value;
        }
        return undefined;
    }
    insert(item) {
        this._size++;
        if (!this._root) {
            this._root = { value: item };
            return this._root;
        }
        let node = this._root;
        while (node) {
            if (this._comparator(item, node.value) < 0) {
                if (!node.left) {
                    return node.left = { parent: node, value: item };
                }
                node = node.left;
            }
            else {
                if (!node.right) {
                    return node.right = { parent: node, value: item };
                }
                node = node.right;
            }
        }
        // impossible to get there, throwing is to make TS analizator happy
        throw new Error();
    }
    remove(node) {
        this._size--;
        if (node.left && node.right) {
            const successor = this._min(node.right);
            this._replaceSubtree(node, successor);
            // update links to children of the removed node
            if (node.left) {
                successor.left = node.left;
                node.left.parent = successor;
            }
            if (node.right) {
                successor.right = node.right;
                node.right.parent = successor;
            }
        }
        else if (node.left) {
            this._replaceSubtree(node, node.left);
        }
        else if (node.right) {
            this._replaceSubtree(node, node.right);
        }
        else {
            this._replaceSubtree(node, undefined);
        }
    }
    /**
     * Iterates elements in ascending order.
     */
    *values(node) {
        if (node) {
            yield* this.values(node.left);
            yield node.value;
            yield* this.values(node.right);
        }
    }
    /**
     * Iterates elements in ascending order.
     */
    [Symbol.iterator]() {
        return this.values(this._root);
    }
    _min(from) {
        let node = from;
        while (node.left) {
            node = node.left;
        }
        return node;
    }
    _max(from) {
        let node = from;
        while (node.right) {
            node = node.right;
        }
        return node;
    }
    /**
     * Reorganizes the tree structure so that the replacement node takes replaceable's position, the latter is removed.
     */
    _replaceSubtree(replaceable, replacement) {
        if (replaceable.parent) {
            if (replaceable.parent.left === replaceable) {
                replaceable.parent.left = replacement;
            }
            else if (replaceable.parent.right === replaceable) {
                replaceable.parent.right = replacement;
            }
        }
        else {
            this._root = replacement;
        }
        if (replacement) {
            // remove replacement from its current location
            if (replacement.parent) {
                if (replacement.parent.left === replacement) {
                    replacement.parent.left = undefined;
                }
                else if (replacement.parent.right === replacement) {
                    replacement.parent.right = undefined;
                }
            }
            replacement.parent = replaceable.parent;
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = BinarySearchTree;



/***/ }),
/* 156 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Set with predictable iteration order. Stores items as a two way linked list thus allowing to insert items in between.
 */
class LinkedSet {
    constructor() {
        this._nodes = new Map();
    }
    get begin() {
        return this._begin && this._begin.value;
    }
    get end() {
        return this._end && this._end.value;
    }
    /**
     * Inserts a new item at the end of the set.
     */
    insert(item) {
        if (!this._nodes.has(item)) {
            const node = { value: item };
            if (this._end) {
                this.insertAfter(this._end.value, item);
            }
            else {
                this._begin = this._end = node;
                this._nodes.set(item, node);
            }
        }
    }
    /**
     * Inserts a new item before the specified one. If the before item is not in the set or
     * the item is already inserted nothing happens.
     */
    insertBefore(before, item) {
        const beforeNode = this._nodes.get(before);
        if (beforeNode && !this._nodes.has(item)) {
            const node = { value: item };
            if (beforeNode.prev) {
                beforeNode.prev.next = node;
                node.prev = beforeNode.prev;
            }
            node.next = beforeNode;
            beforeNode.prev = node;
            this._nodes.set(item, node);
            if (beforeNode === this._begin) {
                this._begin = node;
            }
        }
    }
    /**
     * Inserts a new item after the specified one. If the after item is not in the set or
     * the item is already inserted nothing happens.
     */
    insertAfter(after, item) {
        const afterNode = this._nodes.get(after);
        if (afterNode && !this._nodes.has(item)) {
            const node = { value: item };
            if (afterNode.next) {
                afterNode.next.prev = node;
                node.next = afterNode.next;
            }
            node.prev = afterNode;
            afterNode.next = node;
            this._nodes.set(item, node);
            if (afterNode === this._end) {
                this._end = node;
            }
        }
    }
    /**
     * Removes item from the set.
     */
    remove(item) {
        const node = this._nodes.get(item);
        if (node) {
            if (node === this._begin) {
                this._begin = node.next;
            }
            if (node === this._end) {
                this._end = node.prev;
            }
            if (node.next) {
                node.next.prev = node.prev;
            }
            if (node.prev) {
                node.prev.next = node.next;
            }
            this._nodes.delete(item);
        }
    }
    /**
     * @returns `undefined` if the item is not in the set or it is the first elements.
     */
    getPrev(item) {
        const node = this._nodes.get(item);
        if (node && node.prev) {
            return node.prev.value;
        }
        return undefined;
    }
    /**
     * @returns `undefined` if the item is not in the set or it is the last elements.
     */
    getNext(item) {
        const node = this._nodes.get(item);
        if (node && node.next) {
            return node.next.value;
        }
        return undefined;
    }
    /**
     * Iterates over the set from the fist element to the last (in the order of insertion
     * if the insert method was used only).
     */
    *values() {
        let node = this._begin;
        while (node) {
            yield node.value;
            node = node.next;
        }
    }
    /**
     * Iterates over the set from the fist element to the last (in the order of insertion
     * if the insert method was used only).
     */
    [Symbol.iterator]() {
        return this.values();
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = LinkedSet;



/***/ }),
/* 157 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__render_state__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_color__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math_vector2__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__math_vector3__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__math_matrix4__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__grid_sampler_buffer_writer__ = __webpack_require__(158);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__util_event_emitter__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__grid_renderer__ = __webpack_require__(159);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__visibility_resolution_steps_reset_removed_primitives__ = __webpack_require__(160);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__visibility_resolution_steps_fadeout_all__ = __webpack_require__(161);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__visibility_resolution_steps_fadein_visible__ = __webpack_require__(165);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__visibility_resolution_steps_fadeout_overlapped__ = __webpack_require__(168);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__render_util_camera_position__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__util_hd__ = __webpack_require__(10);














const FADING_STOPPED = -1;
const DEFAULT_FADE_EFFECT_DURATION = 150;
const ID_COMPONENT_SIZE = 256;
const VISIBILITY_INIT_STATE = new __WEBPACK_IMPORTED_MODULE_0__render_state__["c" /* default */]({
    clearColor: __WEBPACK_IMPORTED_MODULE_1__util_color__["c" /* create */](0, 0, 0, 0),
    dither: false
});
const EMPTY_GRID_CELL = __WEBPACK_IMPORTED_MODULE_1__util_color__["c" /* create */](0, 0, 0, 1);
const DIRECT_PRIORITY_GRID_STATE = new __WEBPACK_IMPORTED_MODULE_0__render_state__["c" /* default */]({
    clearColor: EMPTY_GRID_CELL,
    depthTest: true,
    clearDepth: 0,
    // primitives with equal priority are resolved as following: later ones overlap previous
    depthFunc: 518 /* GREATER_OR_EQUAL */,
    dither: false
});
const REVERSE_PRIORITY_GRID_STATE = new __WEBPACK_IMPORTED_MODULE_0__render_state__["c" /* default */]({
    clearColor: EMPTY_GRID_CELL,
    depthTest: true,
    clearDepth: 1,
    depthFunc: 513 /* LESS */,
    dither: false
});
// size of minimal recognizable square side in css pixels.
const GRID_PRECISION_PX = 6;
/**
 * Apart from being removed from scene there are other reasons for primitives to be invisible: e.g. they are
 * overlapped by primitives with higher priority. This state is highly dynamic, primitives may be of different types,
 * from different sources and they can have quite non-trivial shapes. So there should be a single point of collision
 * resolution for all primitives in scene, that is what visibility manager is.
 *
 * Visibility of primitives is calculated every frame. To support fade-in/out animation visibility value is a factor
 * the alpha channel of a finally rendered primitive is to be multiplied by (value from 0.0 to 1.0). For instance,
 * if an object is just appeared on the scene, this factor will be changed from 0.0 to 1.0 in fadeEffectDurationMs ms.
 * There are 4 steps the whole process can be roughly summarized into:
 *  1. actualization - reset values for removed from scene primitives
 *  2. fade-out all - even though all primitives are faded out at this step, this step is intended for invisible
 *     primitives to animate them disappearing.
 *  3. fade-in visible - check which primitive are visible and increase its alpha visibility value.
 *  4. fade-out overlapped - find overlaps by comparing corresponding pixels of the scene rendered in direct and
 *     reverse priority orders.
 *
 *  Due to the fact that we use grid with finite precision there are some cases where this approach produces
 *  unpleasant artifacts (blinking). To cope with it stability shift and storing zoom of the first overlap are
 *  introduced, but it works well for non-tilted map only.
 */
class VisibilityManager {
    constructor(context, camera, renderLoop, targetWidth, targetHeight, fadeEffectDuration = DEFAULT_FADE_EFFECT_DURATION) {
        this.onRerenderRequired = new __WEBPACK_IMPORTED_MODULE_6__util_event_emitter__["b" /* VoidEventEmitter */]();
        this.fadeEffectDuration = fadeEffectDuration;
        this._context = context;
        this._camera = camera;
        this._renderLoop = renderLoop;
        this._lastRenderTimeInLoop = FADING_STOPPED;
        this._prevTargetSize = { width: 0, height: 0 };
        this._sceneUpdateListener = this._onSceneUpdate.bind(this);
        this._camera.onUpdate.addListener(this._sceneUpdateListener);
        this._beforeRenderListener = this._onBeforeRender.bind(this);
        this._renderLoop.onBeforeRender.addListener(this._beforeRenderListener);
        this._directPriorityGridRenderer = new __WEBPACK_IMPORTED_MODULE_7__grid_renderer__["a" /* default */](context, DIRECT_PRIORITY_GRID_STATE);
        this._reversePriorityGridRenderer = new __WEBPACK_IMPORTED_MODULE_7__grid_renderer__["a" /* default */](context, REVERSE_PRIORITY_GRID_STATE);
        this._currentVisibilityTexture = context.createEmpty2DTexture(ID_COMPONENT_SIZE, ID_COMPONENT_SIZE, 6408 /* RGBA */, 5121 /* UNSIGNED_BYTE */);
        this._prevVisibilityTexture = context.createEmpty2DTexture(ID_COMPONENT_SIZE, ID_COMPONENT_SIZE, 6408 /* RGBA */, 5121 /* UNSIGNED_BYTE */);
        this._currentVisibilityBuffer = context.createFramebuffer({ color: this._currentVisibilityTexture });
        this._prevVisibilityBuffer = context.createFramebuffer({ color: this._prevVisibilityTexture });
        this._stabilityShift = __WEBPACK_IMPORTED_MODULE_3__math_vector3__["e" /* create */](0, 0, 0);
        this._gridHalfPxSizeUniform = __WEBPACK_IMPORTED_MODULE_2__math_vector2__["f" /* create */](0, 0);
        this._idHalfPxSizeUniform = __WEBPACK_IMPORTED_MODULE_2__math_vector2__["f" /* create */](0.5 / ID_COMPONENT_SIZE, 0.5 / ID_COMPONENT_SIZE);
        this._step1ResetRemoved = new __WEBPACK_IMPORTED_MODULE_8__visibility_resolution_steps_reset_removed_primitives__["a" /* default */]();
        this._step2FadeoutAll = new __WEBPACK_IMPORTED_MODULE_9__visibility_resolution_steps_fadeout_all__["a" /* default */](context);
        this._step3FadeinVisible = new __WEBPACK_IMPORTED_MODULE_10__visibility_resolution_steps_fadein_visible__["a" /* default */](context);
        this._step4FadeoutOverlapped = new __WEBPACK_IMPORTED_MODULE_11__visibility_resolution_steps_fadeout_overlapped__["a" /* default */](context);
        this._clearVisibility(this._currentVisibilityBuffer);
        this._primitiveProviders = [];
        this._colorIdRenderers = [];
        this._resetRemovedRenderers = [];
        this.setTargetSize(targetWidth, targetHeight);
    }
    get visibilityTexture() {
        return this._currentVisibilityTexture;
    }
    /**
     * To provide proper precision in collision resolution simplified grid size depends on the render target,
     * that can be changed at run time (e.g. the user resizes browser window). A lot of associated GL resources is be
     * updated in that case.
     */
    setTargetSize(width, height) {
        const gridPrecisionTargetPx = GRID_PRECISION_PX * Object(__WEBPACK_IMPORTED_MODULE_13__util_hd__["a" /* default */])();
        const gridWidth = Math.ceil(width / gridPrecisionTargetPx);
        const gridHeight = Math.ceil(height / gridPrecisionTargetPx);
        this._directPriorityGridRenderer.setResolution(gridWidth, gridHeight);
        this._reversePriorityGridRenderer.setResolution(gridWidth, gridHeight);
        if (this._gridSamplerVertexBuffer) {
            this._destroyGridResources();
        }
        const overlapSamplerBufferWriter = new __WEBPACK_IMPORTED_MODULE_5__grid_sampler_buffer_writer__["b" /* default */](gridWidth, gridHeight);
        const context = this._context;
        this._gridSamplerVertexBuffer = context.createVertexBuffer(overlapSamplerBufferWriter.data.byteLength);
        this._gridSamplerVao = context.createVao(__WEBPACK_IMPORTED_MODULE_5__grid_sampler_buffer_writer__["a" /* ATTRIBUTE_MAPPING */], this._gridSamplerVertexBuffer, null);
        this._numberOfGridSamplers = overlapSamplerBufferWriter.numberOfSamplers;
        this._context.uploadDataToBuffer(this._gridSamplerVertexBuffer, overlapSamplerBufferWriter.data);
        this._prevTargetSize.width = width;
        this._prevTargetSize.height = height;
        this._gridHalfPxSizeUniform.x = 0.5 / gridWidth;
        this._gridHalfPxSizeUniform.y = 0.5 / gridHeight;
    }
    /**
     * Recalculates visibility of all colliding primitives in scene.
     *
     * @param target The target the scene is to be rendered into.
     * @param uniforms Set of precalculated uniforms global for current frame.
     * @returns Updated texture with visibility values for all primitives.
     */
    updateVisibilityIfNeeded() {
        if (!this._isDirty) {
            return;
        }
        this._isDirty = false;
        // Rasterization may be not stable in the sense of the shape of pixels occupied by particular object when this
        // object gets shifted (e.g. the user drags the center of the map) and since collisions are detected by
        // overlapped pixels this fact can lead to blinking (found overlapping in one frame/not found in the next/etc).
        // For those objects (and their positions) that are not distorted by perspective it can be fixed by
        // introducing a shift that takes into account the amount of drag and forces vertices to be displaced in the
        // same position in grid's cell.
        const shift = this._stabilityShift;
        __WEBPACK_IMPORTED_MODULE_2__math_vector2__["e" /* copy */](this._camera.center, shift);
        shift.z = 0;
        __WEBPACK_IMPORTED_MODULE_4__math_matrix4__["b" /* apply */](this._camera.getViewProjMatrix(), shift, shift);
        // NDC (-1 : 1) are 2 times larger than texture coordinates (0 : 1)
        shift.x %= 4 * this._gridHalfPxSizeUniform.x;
        shift.y %= 4 * this._gridHalfPxSizeUniform.y;
        const prevTexture = this._prevVisibilityTexture;
        const prevFramebuffer = this._prevVisibilityBuffer;
        const currentTexture = this._currentVisibilityTexture;
        const currentFramebuffer = this._currentVisibilityBuffer;
        this._clearVisibility(prevFramebuffer);
        // on this step
        this._step1ResetRemoved.render(prevFramebuffer, this._resetRemovedRenderers, currentTexture, this._idHalfPxSizeUniform);
        // pass zoom as a value between 0.0 and 1.0, as absolute value is not important
        const zoom = this._camera.zoom / this._camera.options.maxZoom;
        const viewProjMatrix = this._camera.getViewProjMatrix();
        const cameraPositions = Object(__WEBPACK_IMPORTED_MODULE_12__render_util_camera_position__["a" /* calculateCameraPositions */])(this._camera);
        const directPriorityGrid = this._directPriorityGridRenderer.updateGrid(viewProjMatrix, cameraPositions, this._colorIdRenderers, shift, prevTexture, zoom);
        const reversePriorityGrid = this._reversePriorityGridRenderer.updateGrid(viewProjMatrix, cameraPositions, this._colorIdRenderers, shift, prevTexture, zoom);
        const now = performance.now();
        const lastRendering = this._lastRenderTimeInLoop;
        const isAnimationFinished = (now - this._lastSceneUpdateTime) > this.fadeEffectDuration;
        const wasAnimationActive = lastRendering !== FADING_STOPPED;
        const fadeEffect = isAnimationFinished ?
            1.0 : wasAnimationActive ? (now - lastRendering) / this.fadeEffectDuration : 0;
        const idHalfPx = this._idHalfPxSizeUniform;
        const samplerVao = this._gridSamplerVao;
        const numberOfSamplers = this._numberOfGridSamplers;
        this._clearVisibility(currentFramebuffer);
        this._step2FadeoutAll.render(currentFramebuffer, prevTexture, fadeEffect);
        this._step3FadeinVisible.render(currentFramebuffer, samplerVao, numberOfSamplers, directPriorityGrid, prevTexture, idHalfPx, fadeEffect);
        this._step4FadeoutOverlapped.render(currentFramebuffer, samplerVao, numberOfSamplers, directPriorityGrid, reversePriorityGrid, prevTexture, idHalfPx, fadeEffect, zoom);
        // check if we need one more rendering to finish animation
        if (isAnimationFinished) {
            // no more renderings needed for fade effect, its timestamp is marked with special value
            // to take it into account during next fade effect amount calculation
            this._lastRenderTimeInLoop = FADING_STOPPED;
        }
        else {
            this._renderLoop.update();
            this._lastRenderTimeInLoop = now;
        }
    }
    registerCollidingPrimitives(primitiveProvider, colorIdRenderer, resetRemoveRenderer) {
        this._primitiveProviders.push(primitiveProvider);
        this._colorIdRenderers.push(colorIdRenderer);
        this._resetRemovedRenderers.push(resetRemoveRenderer);
        primitiveProvider.onUpdate.addListener(this._sceneUpdateListener);
    }
    deregisterCollidingPrimitives(primitiveProvider, colorIdRenderer, resetRemoveRenderer) {
        let index = this._primitiveProviders.indexOf(primitiveProvider);
        if (index > -1) {
            this._primitiveProviders.splice(index, 1);
        }
        index = this._colorIdRenderers.indexOf(colorIdRenderer);
        if (index > -1) {
            this._colorIdRenderers.splice(index, 1);
        }
        index = this._resetRemovedRenderers.indexOf(resetRemoveRenderer);
        if (index > -1) {
            this._resetRemovedRenderers.splice(index, 1);
        }
        primitiveProvider.onUpdate.removeListener(this._sceneUpdateListener);
    }
    destroy() {
        this._destroyGridResources();
        this._directPriorityGridRenderer.destroy();
        this._reversePriorityGridRenderer.destroy();
        this._camera.onUpdate.removeListener(this._sceneUpdateListener);
        for (const primitiveProvider of this._primitiveProviders) {
            primitiveProvider.onUpdate.removeListener(this._sceneUpdateListener);
        }
    }
    _onSceneUpdate() {
        this._lastSceneUpdateTime = performance.now();
        this._renderLoop.update();
    }
    _onBeforeRender() {
        this._isDirty = true;
    }
    /**
     * Resets visibility texture to its initial state.
     */
    _clearVisibility(target) {
        this._context.bindRenderState(VISIBILITY_INIT_STATE);
        this._context.bindRenderTarget(target);
        this._context.clearCurrentTarget(16384 /* COLOR_BUFFER_BIT */);
    }
    _destroyGridResources() {
        this._gridSamplerVertexBuffer.destroy();
        this._gridSamplerVao.destroy();
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = VisibilityManager;



/***/ }),
/* 158 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_buffer_writer__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_gputypes__ = __webpack_require__(13);



const ATTRIBUTE_MAPPING = new __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__["a" /* AttributeMapping */]([
    [
        0 /* POSITION */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ]
]);
/* harmony export (immutable) */ __webpack_exports__["a"] = ATTRIBUTE_MAPPING;

/**
 * Writes sampler positions into vertex buffer as a regular grid with the step equal to the size of a grid cell.
 * The number of vertices (samplers) is equal to "width x height".
 */
class GridSamplerBufferWriter extends __WEBPACK_IMPORTED_MODULE_1__util_buffer_writer__["b" /* default */] {
    constructor(width, height) {
        const numberOfSamplers = width * height;
        super(ATTRIBUTE_MAPPING.vertexByteSize, numberOfSamplers, undefined, 0);
        const colStep = Object(__WEBPACK_IMPORTED_MODULE_2__util_gputypes__["a" /* floatToUint16 */])(1.0 / width);
        const rowStep = Object(__WEBPACK_IMPORTED_MODULE_2__util_gputypes__["a" /* floatToUint16 */])(1.0 / height);
        const colHalfStep = colStep / 2;
        const rowHalfStep = rowStep / 2;
        for (let i = 0, col = colHalfStep; i < width; i++, col += colStep) {
            for (let j = 0, row = rowHalfStep; j < height; j++, row += rowStep) {
                this._writeHalfWords(col, row);
            }
        }
        this.data = this.getBuffers()[0].vertexBuffer;
        this.numberOfSamplers = numberOfSamplers;
    }
}
/* harmony export (immutable) */ __webpack_exports__["b"] = GridSamplerBufferWriter;



/***/ }),
/* 159 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__render_gl_renderer__ = __webpack_require__(4);

class GridRenderer extends __WEBPACK_IMPORTED_MODULE_0__render_gl_renderer__["a" /* GlRenderer */] {
    constructor(context, renderState) {
        super(context, renderState);
    }
    updateGrid(...args) {
        this.render(this._target, ...args);
        return this._texture;
    }
    _render(viewProjMatrix, cameraPositions, renderers, stabilityShift, prevVisibility, currentZoom) {
        for (const renderer of renderers) {
            renderer.render(this._target, viewProjMatrix, cameraPositions, this._renderState, stabilityShift, prevVisibility, currentZoom);
        }
    }
    /**
     * Updates resolution of the grid.
     */
    setResolution(width, height) {
        this._destroyResources();
        this._depthBuffer = this._context.createRenderbuffer(width, height, 34041 /* DEPTH_STENCIL */);
        this._texture = this._context.createEmpty2DTexture(width, height, 6408 /* RGBA */, 5121 /* UNSIGNED_BYTE */);
        this._target = this._context.createFramebuffer({ color: this._texture, depthStencil: this._depthBuffer });
    }
    destroy() {
        this._destroyResources();
    }
    _prepareRenderTarget(target, ...args) {
        super._prepareRenderTarget(target, ...args);
        this._context.clearCurrentTarget(16384 /* COLOR_BUFFER_BIT */ | 256 /* DEPTH_BUFFER_BIT */);
    }
    _destroyResources() {
        if (this._target) {
            this._target.destroy();
            this._texture.destroy();
            this._depthBuffer.destroy();
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = GridRenderer;



/***/ }),
/* 160 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * One of the steps of primitives visibility resolution process. Basically it does nothing, just call appropriate
 * methods of CollidingPrimitiveRenderer's, but it expects that these renderers will copy visibility value of actual
 * primitives only, thus removed primitive's values will be reset (overlap zoom cleared and all that). It is important
 * for reusing these ids for future primitives.
 */
class ResetRemovedPrimitives {
    render(target, renderers, prevVisibility, idHalfPxSizeUniform) {
        for (const renderer of renderers) {
            renderer.render(target, prevVisibility, idHalfPxSizeUniform);
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ResetRemovedPrimitives;



/***/ }),
/* 161 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shaders_fadeout_all_vert__ = __webpack_require__(162);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shaders_fadeout_all_vert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__shaders_fadeout_all_vert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shaders_fadeout_all_frag__ = __webpack_require__(163);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shaders_fadeout_all_frag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__shaders_fadeout_all_frag__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__render_gl_renderer__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__render_state__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__id_sampler_buffer_writer__ = __webpack_require__(164);





const STATE = new __WEBPACK_IMPORTED_MODULE_3__render_state__["c" /* default */]({
    dither: false
});
/**
 * One of the steps of primitives visibility resolution process. It samples all visibility values and subtract
 * delta (fadeoutAmount) from them, these new values are stored into current visibility texture.
 */
class FadeoutAll extends __WEBPACK_IMPORTED_MODULE_2__render_gl_renderer__["a" /* GlRenderer */] {
    constructor(context) {
        const program = context.createProgram(__WEBPACK_IMPORTED_MODULE_0__shaders_fadeout_all_vert___default.a, __WEBPACK_IMPORTED_MODULE_1__shaders_fadeout_all_frag___default.a, {
            attribMap: {
                position: 0 /* POSITION */
            }
        });
        super(context, STATE, program);
        const idSamplerBufferWriter = new __WEBPACK_IMPORTED_MODULE_4__id_sampler_buffer_writer__["b" /* default */]();
        this._idSamplerVertexBuffer = this._context.createVertexBuffer(idSamplerBufferWriter.vertexData.byteLength);
        this._idSamplerIndexBuffer = this._context.createIndexBuffer(idSamplerBufferWriter.indexData.byteLength);
        this._idSamplerVao = this._context.createVao(__WEBPACK_IMPORTED_MODULE_4__id_sampler_buffer_writer__["a" /* ATTRIBUTE_MAPPING */], this._idSamplerVertexBuffer, this._idSamplerIndexBuffer);
        this._context.uploadDataToBuffer(this._idSamplerVertexBuffer, idSamplerBufferWriter.vertexData);
        this._context.uploadDataToBuffer(this._idSamplerIndexBuffer, idSamplerBufferWriter.indexData);
        context.bindProgram(program);
        program.setIntScalarUniform('prevVisibility', 0);
    }
    _prepareProgram(program, prevVisibility, fadeoutAmount) {
        super._prepareProgram(program, prevVisibility, fadeoutAmount);
        this._context.bindTextureUnit(0);
        this._context.bindTexture(prevVisibility);
        program.setScalarUniform('fadeoutAmount', fadeoutAmount);
    }
    _render() {
        this._context.bindVao(this._idSamplerVao);
        this._context.drawIndexedMesh(0, 6, 4 /* TRIANGLES */);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = FadeoutAll;



/***/ }),
/* 162 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec4 position;\n\nvarying vec2 idTexCoordinates;\n\nvoid main() {\n    gl_Position = vec4(position.xy, 0, 1);\n    idTexCoordinates = position.zw;\n}\n"

/***/ }),
/* 163 */
/***/ (function(module, exports) {

module.exports = "#version 100\n\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform sampler2D prevVisibility;\nuniform float fadeoutAmount;\n\nvarying vec2 idTexCoordinates;\n\nvoid main() {\n    vec4 visibilityValue = texture2D(prevVisibility, idTexCoordinates);\n    visibilityValue.a = clamp(visibilityValue.a - fadeoutAmount, 0.0, 1.0);\n\n    gl_FragColor = visibilityValue;\n}\n"

/***/ }),
/* 164 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_buffer_writer__ = __webpack_require__(6);


const ATTRIBUTE_MAPPING = new __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__["a" /* AttributeMapping */]([
    [
        0 /* POSITION */,
        {
            size: 4,
            type: 5120 /* BYTE */,
            normalized: false
        }
    ]
]);
/* harmony export (immutable) */ __webpack_exports__["a"] = ATTRIBUTE_MAPPING;

/**
 * Write vertices of two triangles that fully cover visibility texture, its values can be sampled in fragment shaders.
 */
class IdSamplerBufferWriter extends __WEBPACK_IMPORTED_MODULE_1__util_buffer_writer__["b" /* default */] {
    constructor() {
        super(ATTRIBUTE_MAPPING.vertexByteSize, 4, 4, 6);
        // window x, window y, texture x, texture y
        this._writeBytes(-1, -1, 0, 0);
        this._writeBytes(-1, 1, 0, 1);
        this._writeBytes(1, 1, 1, 1);
        this._writeBytes(1, -1, 1, 0);
        this.writeIndicesForFan([0, 1, 2, 3]);
        this.vertexData = this.getBuffers()[0].vertexBuffer;
        this.indexData = this.getBuffers()[0].indexBuffer;
    }
}
/* harmony export (immutable) */ __webpack_exports__["b"] = IdSamplerBufferWriter;



/***/ }),
/* 165 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__render_gl_renderer__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shaders_fadein_visible_vert__ = __webpack_require__(166);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shaders_fadein_visible_vert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__shaders_fadein_visible_vert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shaders_fadein_visible_frag__ = __webpack_require__(167);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shaders_fadein_visible_frag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__shaders_fadein_visible_frag__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__render_state__ = __webpack_require__(0);




const STATE = new __WEBPACK_IMPORTED_MODULE_3__render_state__["c" /* default */]({
    dither: false
});
/**
 * One of the steps of primitives visibility resolution process. It samples all pixels of the scene (rendered in direct
 * priority order into simplified grid) and adds delta (fadeinAmount) to alpha visibility of primitive with
 * id in this pixel. Those primitives are considered visible.
 */
class FadeinVisible extends __WEBPACK_IMPORTED_MODULE_0__render_gl_renderer__["a" /* GlRenderer */] {
    constructor(context) {
        const program = context.createProgram(__WEBPACK_IMPORTED_MODULE_1__shaders_fadein_visible_vert___default.a, __WEBPACK_IMPORTED_MODULE_2__shaders_fadein_visible_frag___default.a, {
            attribMap: {
                position: 0 /* POSITION */
            }
        });
        super(context, STATE, program);
        context.bindProgram(program);
        program.setIntScalarUniform('directPriorityGrid', 0);
        program.setIntScalarUniform('prevVisibility', 1);
    }
    _prepareProgram(program, data, samplers, directPriorityGrid, prevVisibility, idHalfPxSize, fadeinAmount) {
        super._prepareProgram(program, data, samplers, directPriorityGrid, prevVisibility, idHalfPxSize, fadeinAmount);
        this._context.bindTextureUnit(0);
        this._context.bindTexture(directPriorityGrid);
        this._context.bindTextureUnit(1);
        this._context.bindTexture(prevVisibility);
        program.setVector2Uniform('idHalfPxSize', idHalfPxSize);
        program.setScalarUniform('fadeinAmount', fadeinAmount);
    }
    _render(data, numberOfSamplers) {
        this._context.bindVao(data);
        this._context.drawMesh(0, numberOfSamplers, 0 /* POINTS */);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = FadeinVisible;



/***/ }),
/* 166 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec2 position;\n\nuniform sampler2D directPriorityGrid;\nuniform sampler2D prevVisibility;\nuniform vec2 idHalfPxSize;\nuniform float fadeinAmount;\n\nvarying lowp vec4 visibilityValue;\n\nconst vec2 NO_ID = vec2(0, 0);\nconst vec4 DISCARD_POSITION = vec4(2, 2, 2, 1);\n\nvoid main() {\n    vec2 primitiveId = texture2D(directPriorityGrid, position).rg;\n\n    if (primitiveId != NO_ID) {\n        vec2 idTexCoordinates = primitiveId + idHalfPxSize;\n        vec4 idWindowCoordinates = vec4(idTexCoordinates * 2.0 - 1.0, 0, 1);\n        gl_Position = idWindowCoordinates;\n        gl_PointSize = 1.0;\n\n        visibilityValue = texture2D(prevVisibility, idTexCoordinates);\n        visibilityValue.a = clamp(visibilityValue.a + fadeinAmount, 0.0, 1.0);\n    } else {\n        gl_Position = DISCARD_POSITION;\n    }\n}\n"

/***/ }),
/* 167 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nvarying lowp vec4 visibilityValue;\n\nvoid main() {\n    gl_FragColor = visibilityValue;\n}\n"

/***/ }),
/* 168 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__render_gl_renderer__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shaders_fadeout_overlapped_vert__ = __webpack_require__(169);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shaders_fadeout_overlapped_vert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__shaders_fadeout_overlapped_vert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shaders_fadeout_overlapped_frag__ = __webpack_require__(170);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shaders_fadeout_overlapped_frag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__shaders_fadeout_overlapped_frag__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__render_state__ = __webpack_require__(0);




const STATE = new __WEBPACK_IMPORTED_MODULE_3__render_state__["c" /* default */]({ dither: false });
class FadeoutOverlapped extends __WEBPACK_IMPORTED_MODULE_0__render_gl_renderer__["a" /* GlRenderer */] {
    constructor(context) {
        const program = context.createProgram(__WEBPACK_IMPORTED_MODULE_1__shaders_fadeout_overlapped_vert___default.a, __WEBPACK_IMPORTED_MODULE_2__shaders_fadeout_overlapped_frag___default.a, {
            attribMap: {
                position: 0 /* POSITION */
            }
        });
        super(context, STATE, program);
        context.bindProgram(program);
        program.setIntScalarUniform('directPriorityGrid', 0);
        program.setIntScalarUniform('reversePriorityGrid', 1);
        program.setIntScalarUniform('prevVisibility', 2);
    }
    _prepareProgram(program, data, samplers, directPriority, reversePriority, prevVisibility, idHalfPxSize, fadeoutAmount, currentZoom) {
        super._prepareProgram(program, data, samplers, directPriority, reversePriority, prevVisibility, idHalfPxSize, fadeoutAmount, currentZoom);
        this._context.bindTextureUnit(0);
        this._context.bindTexture(directPriority);
        this._context.bindTextureUnit(1);
        this._context.bindTexture(reversePriority);
        this._context.bindTextureUnit(2);
        this._context.bindTexture(prevVisibility);
        program.setVector2Uniform('idHalfPxSize', idHalfPxSize);
        program.setScalarUniform('fadeoutAmount', fadeoutAmount);
        program.setScalarUniform('currentZoom', currentZoom);
    }
    _render(data, numberOfSamplers) {
        this._context.bindVao(data);
        this._context.drawMesh(0, numberOfSamplers, 0 /* POINTS */);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = FadeoutOverlapped;



/***/ }),
/* 169 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec2 position;\n\nuniform sampler2D directPriorityGrid;\nuniform sampler2D reversePriorityGrid;\nuniform sampler2D prevVisibility;\nuniform vec2 idHalfPxSize;\nuniform float fadeoutAmount;\nuniform float currentZoom;\n\nvarying vec4 visibilityValue;\n\nconst vec2 NO_ID = vec2(0, 0);\nconst vec4 DISCARD_POSITION = vec4(2, 2, 2, 1);\n\nvoid main() {\n    vec2 primitiveIdReversePriority = texture2D(reversePriorityGrid, position).rg;\n\n    if (\n        primitiveIdReversePriority != NO_ID &&\n        primitiveIdReversePriority != texture2D(directPriorityGrid, position).rg\n    ) {\n        vec2 idTexCoordinates = primitiveIdReversePriority + idHalfPxSize;\n        vec4 idWindowCoordinates = vec4(idTexCoordinates * 2.0 - 1.0, 0, 1);\n\n        gl_Position = idWindowCoordinates;\n        gl_PointSize = 1.0;\n\n        visibilityValue = texture2D(prevVisibility, idTexCoordinates);\n        visibilityValue.b = currentZoom;\n        visibilityValue.a = clamp(visibilityValue.a - fadeoutAmount, 0.0, 1.0);\n    } else {\n        gl_Position = DISCARD_POSITION;\n    }\n}\n"

/***/ }),
/* 170 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nvarying lowp vec4 visibilityValue;\n\nvoid main() {\n    gl_FragColor = visibilityValue;\n}\n"

/***/ }),
/* 171 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = computeSquaresCoveredByConvexPolygon;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_vector2__ = __webpack_require__(1);


/**
 * Container of indexed min/max values with a single update method.
 */
class ExtremumStorage {
    constructor(length) {
        this._mins = new Array(length);
        this._maxs = new Array(length);
        this._mins.fill(Number.POSITIVE_INFINITY);
        this._maxs.fill(Number.NEGATIVE_INFINITY);
    }
    updateValue(index, value) {
        this._mins[index] = Math.min(this._mins[index], value);
        this._maxs[index] = Math.max(this._maxs[index], value);
    }
    *values() {
        const item = { min: 0, max: 0, index: -1 };
        for (let i = 0; i < this._mins.length; i++) {
            item.min = this._mins[i];
            item.max = this._maxs[i];
            item.index = i;
            yield item;
        }
    }
}
/**
 * Squares that are ony touched by a line (with no significant crossing an edge) should not be considered "covered".
 * It happens when a point matches the max coordinate (integer) and this case is handled here.
 */
function floorToCellCoordinate(value, maxValue) {
    return Number.isInteger(value) && maxValue === value ? value - 1 : Math.floor(value);
}
/**
 * Calculates squares covered (at least partially) by a convex polygon.
 *
 * @param points Convex polygon point coordinates (on the grid).
 * @returns List of unit square coordinates.
 */
function computeSquaresCoveredByConvexPolygon(points) {
    const result = [];
    const bbox = Object(__WEBPACK_IMPORTED_MODULE_0__math_vector2__["c" /* computeBBoxForPoints */])(points);
    const minX = Math.floor(bbox.minX);
    const xLength = Math.ceil(bbox.maxX) - minX;
    const extremums = new ExtremumStorage(xLength);
    for (let i = points.length - 1, j = 0; j < points.length; i = j++) {
        let p1 = points[i];
        let p2 = points[j];
        // go from left to right always to not handle the opposite case
        if (p1.x > p2.x) {
            const tmp = p1;
            p1 = p2;
            p2 = tmp;
        }
        // calculate from/to interval so that only "internal" integer x-es are captured
        const fromX = Math.floor(p1.x + 1);
        const toX = Math.ceil(p2.x - 1);
        const slope = (p1.y - p2.y) / (p1.x - p2.x);
        // handle terminal points separately from the "internal" ones
        extremums.updateValue(floorToCellCoordinate(p1.x, bbox.maxX) - minX, floorToCellCoordinate(p1.y, bbox.maxY));
        extremums.updateValue(floorToCellCoordinate(p2.x, bbox.maxX) - minX, floorToCellCoordinate(p2.y, bbox.maxY));
        for (let x = fromX; x <= toX; x++) {
            const yIntercept = (isFinite(slope) ? slope * (x - p1.x) : 0) + p1.y;
            const nextX = x - minX;
            const prevX = nextX - 1;
            const y = Math.floor(yIntercept);
            // check if we hit exactly the intersection of two integer coordinates
            if (Number.isInteger(yIntercept)) {
                if (yIntercept === bbox.maxY) {
                    extremums.updateValue(prevX, y - 1);
                    extremums.updateValue(nextX, y - 1);
                }
                else if (slope > 0) {
                    // two diagonal squares intersected by a line with positive slope
                    extremums.updateValue(prevX, y - 1);
                    extremums.updateValue(nextX, y);
                }
                else if (slope < 0) {
                    // two diagonal squares intersected by a line with negative slope
                    extremums.updateValue(prevX, y);
                    extremums.updateValue(nextX, y - 1);
                }
            }
            else {
                extremums.updateValue(prevX, y);
                extremums.updateValue(nextX, y);
            }
        }
    }
    for (const { min, max, index } of extremums.values()) {
        const x = minX + index;
        for (let y = min; y <= max; y++) {
            result.push(__WEBPACK_IMPORTED_MODULE_0__math_vector2__["f" /* create */](x, y));
        }
    }
    return result;
}


/***/ }),
/* 172 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = medianFilter;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__array__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__comparator__ = __webpack_require__(19);


/**
 * Filters an array of values with median filter.
 *
 * @param values Values to be filtered.
 * @param windowRadius How many values around a sample get into filter window.
 * @returns Array of filtered values.
 */
function medianFilter(values, windowRadius = 3) {
    const window = new Array(2 * windowRadius + 1);
    window.fill(values[0]);
    const length = values.length;
    const result = new Array(length);
    const first = values[0];
    for (let i = 0; i < windowRadius; ++i) {
        window.fill(first, 0, windowRadius - i + 1);
        Object(__WEBPACK_IMPORTED_MODULE_0__array__["b" /* copy */])(values, window, 0, i + windowRadius + 1, windowRadius - i + 1);
        window.sort(__WEBPACK_IMPORTED_MODULE_1__comparator__["b" /* NUMERICAL_COMPARATOR */]);
        result[i] = window[windowRadius];
    }
    for (let i = windowRadius; i < length - windowRadius; ++i) {
        Object(__WEBPACK_IMPORTED_MODULE_0__array__["b" /* copy */])(values, window, i - windowRadius, i + windowRadius + 1);
        window.sort(__WEBPACK_IMPORTED_MODULE_1__comparator__["b" /* NUMERICAL_COMPARATOR */]);
        result[i] = window[windowRadius];
    }
    const last = values[values.length - 1];
    for (let i = length - windowRadius; i < length; ++i) {
        Object(__WEBPACK_IMPORTED_MODULE_0__array__["b" /* copy */])(values, window, i - windowRadius, length);
        window.fill(last, values.length - i + windowRadius);
        window.sort(__WEBPACK_IMPORTED_MODULE_1__comparator__["b" /* NUMERICAL_COMPARATOR */]);
        result[i] = window[windowRadius];
    }
    return result;
}


/***/ }),
/* 173 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__list_render_unit__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_event_emitter__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__state__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__util_camera_position__ = __webpack_require__(51);




const FINAL_RENDER_STATE = new __WEBPACK_IMPORTED_MODULE_2__state__["c" /* default */]({
    clearDepth: 0,
    depthTest: true,
    depthFunc: 518 /* GREATER_OR_EQUAL */
});
/**
 * Root scene renderer. It generates final canvas image composing it from independent layers (LayerRenderUnit).
 */
class MainRenderUnit extends __WEBPACK_IMPORTED_MODULE_0__list_render_unit__["a" /* default */] {
    constructor(context, camera) {
        super();
        this._context = context;
        this._camera = camera;
        this.onRender = new __WEBPACK_IMPORTED_MODULE_1__util_event_emitter__["b" /* VoidEventEmitter */]();
    }
    render(target) {
        const viewProjMatix = this._camera.getViewProjMatrix();
        const cameraPositions = Object(__WEBPACK_IMPORTED_MODULE_3__util_camera_position__["a" /* calculateCameraPositions */])(this._camera);
        this._context.bindRenderTarget(target);
        this._context.bindRenderState(FINAL_RENDER_STATE);
        this._context.clearCurrentTarget(17664 /* ALL */);
        for (const renderer of this._subRenderUnits) {
            renderer.render(target, viewProjMatix, cameraPositions);
        }
        this.onRender.fire();
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = MainRenderUnit;



/***/ }),
/* 174 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__page__ = __webpack_require__(175);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__count_vertices__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_allocator__ = __webpack_require__(50);



const MAX_VERTEX_COUNT = 0x10000;
// FIXME(dmikis) Let's use oversized index buffer til we sort out indices allocation
// both in writers and the manager.
const PAGE_INDEX_BUFFER_BYTE_SIZE = 0x100000;
/**
 * Memory page with the following peculiarity: once allocation is failed it gets closed for any subsequent
 * allocations. It allow to keep related primitives closer in memory.
 */
class SinglePassMemoryPage extends __WEBPACK_IMPORTED_MODULE_0__page__["a" /* default */] {
    constructor(vertexBuffer, indexBuffer, vao, indexType) {
        super(vertexBuffer, indexBuffer, vao, indexType, new __WEBPACK_IMPORTED_MODULE_2__util_allocator__["a" /* ArenaAllocator */](vertexBuffer.getSize()), new __WEBPACK_IMPORTED_MODULE_2__util_allocator__["a" /* ArenaAllocator */](indexBuffer.getSize()));
        this._failedAllocation = false;
    }
    allocate(vertexByteLength, indexByteLength) {
        if (this._failedAllocation) {
            return null;
        }
        const chunk = super.allocate(vertexByteLength, indexByteLength);
        this._failedAllocation = (chunk === null);
        return chunk;
    }
}
/**
 * Manager that controls GL memory allocations and pagination.[]
 */
class MemoryManager {
    /**
     * Creates a new memory manager that will allocate memory in a given context.
     *
     * @param context The context.
     */
    constructor(context) {
        this._context = context;
        this._pages = new Map();
        this._emptyPagesClearTimeout = 0;
    }
    /**
     * Allocates memory for a given data in the manager and uploads given data.
     *
     * @param vertexData Buffer with vertices that needs to be allocated.
     * @param indexData Buffer with indices that needs to be allocated.
     * @param attributeMapping Mapping of vertex attributes.
     * @returns Descriptor of the allocated memory region.
     */
    allocate(vertexData, indexData, attributeMapping) {
        const context = this._context;
        let pageSet = this._pages.get(attributeMapping);
        // If there's no pages for the given attribute mapping, create a new set.
        if (!pageSet) {
            pageSet = new Set();
            this._pages.set(attributeMapping, pageSet);
        }
        // Try to allocate data in the existing pages.
        for (const page of pageSet) {
            const memoryChunk = page.allocate(vertexData.byteLength, indexData.byteLength);
            if (memoryChunk) {
                // Success! Now we just upload the data.
                this._updatePage(page, memoryChunk, vertexData, indexData);
                return memoryChunk;
            }
        }
        // We've failed to allocate the data in any of existing pages. No worries
        // though, we just create a new one:)
        const vertexBuffer = context.createVertexBuffer(
        // some buffer writers don't use indices and MAX_VERTEX_COUNT restriction is not applied in such cases
        Math.max(MAX_VERTEX_COUNT * attributeMapping.vertexByteSize, vertexData.byteLength));
        const indexBuffer = context.createIndexBuffer(PAGE_INDEX_BUFFER_BYTE_SIZE);
        const vao = context.createVao(attributeMapping, vertexBuffer, indexBuffer);
        const page = new SinglePassMemoryPage(vertexBuffer, indexBuffer, vao, 5123 /* UNSIGNED_SHORT */);
        page.setDelegate(this);
        pageSet.add(page);
        // Here we assume we always can allocate data in an empty page.
        const memoryChunk = page.allocate(vertexData.byteLength, indexData.byteLength);
        this._updatePage(page, memoryChunk, vertexData, indexData);
        return memoryChunk;
    }
    onPageEmpty() {
        if (!this._emptyPagesClearTimeout) {
            this._emptyPagesClearTimeout = setTimeout(() => {
                this._clearEmptyPages();
                this._emptyPagesClearTimeout = 0;
            });
        }
    }
    /**
     * Destroys the manager and all its memory pages. All memory chunks that were
     * allocated in the manager become invalid.
     */
    destroy() {
        if (this._emptyPagesClearTimeout) {
            clearTimeout(this._emptyPagesClearTimeout);
        }
        for (const [, pageSet] of this._pages) {
            for (const page of pageSet) {
                page.destroy();
            }
        }
    }
    _updatePage(page, memoryChunk, vertexData, indexData) {
        const context = this._context;
        // Let's ensure that we won't break any bound VAOs.
        context.bindVao(null);
        context.uploadDataToBuffer(page.vertexBuffer, vertexData, memoryChunk.vertexByteOffset);
        // Shift indices.
        const baseIndex = Object(__WEBPACK_IMPORTED_MODULE_1__count_vertices__["b" /* countVertices */])(memoryChunk.vertexByteOffset, page.vao.attributeMapping);
        for (let i = 0; i < indexData.length; ++i) {
            indexData[i] += baseIndex;
        }
        context.uploadDataToBuffer(page.indexBuffer, indexData, memoryChunk.indexByteOffset);
    }
    _clearEmptyPages() {
        for (const pageSet of this._pages.values()) {
            for (const page of pageSet) {
                if (page.isEmpty()) {
                    pageSet.delete(page);
                    page.setDelegate(null);
                    page.destroy();
                }
            }
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = MemoryManager;



/***/ }),
/* 175 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__chunk__ = __webpack_require__(176);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_delegator__ = __webpack_require__(41);


/**
 * A "page" of GPU memory. Comprises vertex and index buffers of a fixed size.
 */
class MemoryPage extends __WEBPACK_IMPORTED_MODULE_1__util_delegator__["a" /* DelegatorBase */] {
    /**
     * Creates a new page to manage given vertex and index buffers.
     *
     * @param vertexBuffer The vertex buffer the page will manage.
     * @param indexBuffer The index buffer the page will manager.
     * @param vao The VAO of the page.
     * @param indexType Type of elements of indexBuffer.
     * @param vertexAllocator Allocator of vertex data, logic of allocation directly impacts the lifecycle of the page.
     * @param indexAllocator Allocator of index data, logic of allocation directly impacts the lifecycle of the page.
     */
    constructor(vertexBuffer, indexBuffer, vao, indexType, vertexAllocator, indexAllocator) {
        super();
        this.vertexBuffer = vertexBuffer;
        this.indexBuffer = indexBuffer;
        this.vao = vao;
        this.indexType = indexType;
        this._vertexAllocator = vertexAllocator;
        this._indexAllocator = indexAllocator;
    }
    /**
     * Allocates and writes vertex and index data to the page. Offsets indices
     * in an index array to appropriately take into account offset of the vertex
     * data.
     *
     * @param vertexByteLength required number of bytes in vertex buffer
     * @param indexByteLength required number of bytes in index buffer
     * @returns memory chunk allocated or `null` if allocation's failed
     */
    allocate(vertexByteLength, indexByteLength) {
        if (this._vertexAllocator.maxAllocableSize >= vertexByteLength &&
            this._indexAllocator.maxAllocableSize >= indexByteLength) {
            return new __WEBPACK_IMPORTED_MODULE_0__chunk__["a" /* default */](this, {
                vertexByteOffset: this._vertexAllocator.allocate(vertexByteLength),
                vertexByteLength: vertexByteLength,
                indexByteOffset: this._indexAllocator.allocate(indexByteLength),
                indexByteLength: indexByteLength
            });
        }
        else {
            return null;
        }
    }
    /**
     * Frees a previously allocated memory chunk.
     *
     * @param chunk The chunk to be freed.
     */
    free(chunk) {
        this._vertexAllocator.deallocate(chunk.vertexByteOffset);
        this._indexAllocator.deallocate(chunk.indexByteOffset);
        if (this.isEmpty() && this._delegate) {
            this._delegate.onPageEmpty(this);
        }
    }
    /**
     * Returns `true` if the page does not contain any previously allocated data
     * and `false` otherwise.
     */
    isEmpty() {
        return this._vertexAllocator.isEmpty && this._indexAllocator.isEmpty;
    }
    /**
     * Destroys the page and all its resources.
     */
    destroy() {
        this.vertexBuffer.destroy();
        this.indexBuffer.destroy();
        this.vao.destroy();
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = MemoryPage;



/***/ }),
/* 176 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_ref_counted__ = __webpack_require__(20);

/** Handler to a allocated memory chunk. */
class MemoryChunk extends __WEBPACK_IMPORTED_MODULE_0__util_ref_counted__["a" /* default */] {
    /**
     * Creates a new handler to a memory chunk with given offsets allocated in
     * a given memory page.
     *
     * @param page The page the chunk was allocated in.
     * @param vertexOffset The offset of chunk's vertex data.
     * @param indexOffset The offset of chunk's index data.
     */
    constructor(page, location) {
        super();
        this.page = page;
        this._location = location;
    }
    /**
     * Returns offset of vertex data of the chunk in bytes.
     */
    get vertexByteOffset() {
        return this._location.vertexByteOffset;
    }
    /**
     * Returns offset of index data of the chunk in bytes.
     */
    get indexByteOffset() {
        return this._location.indexByteOffset;
    }
    _destroy() {
        this.page.free(this);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = MemoryChunk;



/***/ }),
/* 177 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_vector2__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__state__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shaders_fxaa_frag__ = __webpack_require__(178);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shaders_fxaa_frag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__shaders_fxaa_frag__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__shaders_quad_vert__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__shaders_quad_vert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__shaders_quad_vert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__util_hd__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__gl_renderer__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__list_render_unit__ = __webpack_require__(23);








const STATE = new __WEBPACK_IMPORTED_MODULE_1__state__["c" /* default */](__WEBPACK_IMPORTED_MODULE_1__state__["b" /* BLEND_OVER_RENDER_STATE */]);
/**
 * Renderer of FXAA postprocessing pass.
 */
class FxaaRenderUnit extends __WEBPACK_IMPORTED_MODULE_5__gl_renderer__["a" /* GlRenderer */] {
    constructor(context, renderLoop) {
        super(context, STATE, context.createProgram(__WEBPACK_IMPORTED_MODULE_3__shaders_quad_vert___default.a, __WEBPACK_IMPORTED_MODULE_2__shaders_fxaa_frag___default.a, {
            attribMap: {
                vertexPosition: 0 /* POSITION */
            }
        }));
        this._renderers = new __WEBPACK_IMPORTED_MODULE_6__list_render_unit__["a" /* default */]();
        this._renderLoop = renderLoop;
        this.onUpdate = this._renderers.onUpdate;
        this._pixelSize = __WEBPACK_IMPORTED_MODULE_0__math_vector2__["f" /* create */](0, 0);
    }
    addRenderUnit(unit) {
        this._renderers.addRenderUnit(unit);
    }
    removeRenderUnit(unit) {
        this._renderers.removeRenderUnit(unit);
    }
    render(target, ...args) {
        // skip antialiasing if these is action in the scene
        if (this._renderLoop.isActive) {
            this._renderers.render(target, ...args);
            // schedule at least one more rendering to not leave static (stopped) scene in non-antialiased state
            this._renderLoop.update();
            return;
        }
        if (!this._intermediateRendereBuffer) {
            this._initIntermediateRenderTargets(target.getWidth(), target.getHeight());
        }
        else if (this._intermediateRendereBuffer.getWidth() !== target.getWidth() ||
            this._intermediateRendereBuffer.getHeight() !== target.getHeight()) {
            this._destroyInternalRenderTargets();
            this._initIntermediateRenderTargets(target.getWidth(), target.getHeight());
        }
        this._context.bindRenderTarget(this._intermediateRendereBuffer);
        this._context.clearCurrentTarget(17664 /* ALL */);
        this._renderers.render(this._intermediateRendereBuffer, ...args);
        // do not run antialiasing on empty this._intermediateRendereBuffer
        if (!this._intermediateRendereBuffer.isClear) {
            this._updateFrameUniformState(target);
            super.render(target, ...args);
        }
    }
    destroy() {
        if (this._intermediateRendereBuffer) {
            this._destroyInternalRenderTargets();
        }
    }
    _render() {
        this._context.bindQuadVao();
        this._context.drawQuad();
    }
    _prepareProgram(program, ...args) {
        super._prepareProgram(program, ...args);
        this._context.bindTextureUnit(0);
        this._context.bindTexture(this._intermediateColorBuffer);
        program.setIntScalarUniform('texture', 0);
        program.setVector2Uniform('pixelSize', this._pixelSize);
        program.setScalarUniform('dpr', Object(__WEBPACK_IMPORTED_MODULE_4__util_hd__["a" /* default */])());
    }
    _updateFrameUniformState(target) {
        this._pixelSize.x = 1 / target.getWidth();
        this._pixelSize.y = 1 / target.getHeight();
    }
    _initIntermediateRenderTargets(width, height) {
        const context = this._context;
        const intermediateColorBuffer = this._intermediateColorBuffer =
            context.createEmpty2DTexture(width, height, 6408 /* RGBA */, 5121 /* UNSIGNED_BYTE */);
        const intermediateDepthStencilBuffer = this._intermediateDepthStencilBuffer =
            context.createRenderbuffer(width, height, 34041 /* DEPTH_STENCIL */);
        this._intermediateRendereBuffer = context.createFramebuffer({
            color: intermediateColorBuffer,
            depthStencil: intermediateDepthStencilBuffer
        });
    }
    _destroyInternalRenderTargets() {
        this._intermediateRendereBuffer.destroy();
        this._intermediateColorBuffer.destroy();
        this._intermediateDepthStencilBuffer.destroy();
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = FxaaRenderUnit;



/***/ }),
/* 178 */
/***/ (function(module, exports) {

module.exports = "#version 100\n\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform vec2 pixelSize;\nuniform sampler2D texture;\nuniform float dpr;\n\nconst float FXAA_QUALITY_SUBPIX = 0.75;\nconst float FXAA_QUALITY_EDGE_THRESHOLD = 0.063;\nconst float FXAA_QUALITY_EDGE_THRESHOLD_MIN = 0.0625;\nconst float EPSILON = 0.0001;\n\nfloat luma(vec4 rgba) {\n    return dot(rgba.xyz, vec3(0.299, 0.587, 0.114));\n}\n\nvec4 fxaa(\n    vec2 pos,\n    sampler2D tex,\n    vec2 fxaaQualityRcpFrame,\n    // This used to be the FXAA_QUALITY_SUBPIX define.\n    // Choose the amount of sub-pixel aliasing removal.\n    // This can effect sharpness.\n    //   1.00 - upper limit (softer)\n    //   0.75 - default amount of filtering\n    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)\n    //   0.25 - almost off\n    //   0.00 - completely off\n    float fxaaQualitySubpix,\n    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.\n    // The minimum amount of local contrast required to apply algorithm.\n    //   0.333 - too little (faster)\n    //   0.250 - low quality\n    //   0.166 - default\n    //   0.125 - high quality\n    //   0.063 - overkill (slower)\n    float fxaaQualityEdgeThreshold,\n    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.\n    // Trims the algorithm from processing darks.\n    //   0.0833 - upper limit (default, the start of visible unfiltered edges)\n    //   0.0625 - high quality (faster)\n    //   0.0312 - visible limit (slower)\n    float fxaaQualityEdgeThresholdMin\n) {\n    vec2 posM;\n    posM.x = pos.x;\n    posM.y = pos.y;\n    vec4 rgbyM = texture2D(tex, posM);\n    float lumaM = luma(rgbyM);\n\n    float lumaS = luma(texture2D(tex, posM + vec2( 0, 1) * fxaaQualityRcpFrame.xy));\n    float lumaE = luma(texture2D(tex, posM + vec2( 1, 0) * fxaaQualityRcpFrame.xy));\n    float lumaN = luma(texture2D(tex, posM + vec2( 0,-1) * fxaaQualityRcpFrame.xy));\n    float lumaW = luma(texture2D(tex, posM + vec2(-1, 0) * fxaaQualityRcpFrame.xy));\n\n    float maxSM = max(lumaS, lumaM);\n    float minSM = min(lumaS, lumaM);\n    float maxESM = max(lumaE, maxSM);\n    float minESM = min(lumaE, minSM);\n    float maxWN = max(lumaN, lumaW);\n    float minWN = min(lumaN, lumaW);\n    float rangeMax = max(maxWN, maxESM);\n    float rangeMin = min(minWN, minESM);\n    float rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\n    float range = rangeMax - rangeMin;\n    float rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\n    bool earlyExit = range < rangeMaxClamped;\n\n    if (earlyExit)\n        return rgbyM;\n\n    float lumaNW = luma(texture2D(tex, posM + vec2(-1,-1) * fxaaQualityRcpFrame.xy));\n    float lumaSE = luma(texture2D(tex, posM + vec2( 1, 1) * fxaaQualityRcpFrame.xy));\n    float lumaNE = luma(texture2D(tex, posM + vec2( 1,-1) * fxaaQualityRcpFrame.xy));\n    float lumaSW = luma(texture2D(tex, posM + vec2(-1, 1) * fxaaQualityRcpFrame.xy));\n\n    float lumaNS = lumaN + lumaS;\n    float lumaWE = lumaW + lumaE;\n    float subpixRcpRange = 1.0/range;\n    float subpixNSWE = lumaNS + lumaWE;\n    float edgeHorz1 = (-2.0 * lumaM) + lumaNS;\n    float edgeVert1 = (-2.0 * lumaM) + lumaWE;\n\n    float lumaNESE = lumaNE + lumaSE;\n    float lumaNWNE = lumaNW + lumaNE;\n    float edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\n    float edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\n\n    float lumaNWSW = lumaNW + lumaSW;\n    float lumaSWSE = lumaSW + lumaSE;\n    float edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\n    float edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\n    float edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\n    float edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\n    float edgeHorz = abs(edgeHorz3) + edgeHorz4;\n    float edgeVert = abs(edgeVert3) + edgeVert4;\n\n    float subpixNWSWNESE = lumaNWSW + lumaNESE;\n    float lengthSign = fxaaQualityRcpFrame.x;\n    bool horzSpan = edgeHorz >= edgeVert;\n    float subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\n\n    if (horzSpan) {\n        lengthSign = fxaaQualityRcpFrame.y;\n    } else {\n        lumaN = lumaW;\n        lumaS = lumaE;\n    }\n    float subpixB = (subpixA * (1.0/12.0)) - lumaM;\n\n    float gradientN = lumaN - lumaM;\n    float gradientS = lumaS - lumaM;\n    float lumaNN = lumaN + lumaM;\n    float lumaSS = lumaS + lumaM;\n    bool pairN = abs(gradientN) >= abs(gradientS);\n    float gradient = max(abs(gradientN), abs(gradientS));\n    if (pairN) {\n        lengthSign = -lengthSign;\n    } else {\n        lumaNN = lumaSS;\n    }\n    float subpixC = clamp(abs(subpixB) * subpixRcpRange, 0.0, 1.0);\n\n    vec2 posB = posM;\n    vec2 offNP;\n\n    vec2 offHM;\n    if (horzSpan) {\n        offNP = vec2(fxaaQualityRcpFrame.x, 0.0);\n        offHM = vec2(0.0, lengthSign);\n    } else {\n        offNP = vec2(0.0, fxaaQualityRcpFrame.y);\n        offHM = vec2(lengthSign, 0.0);\n    }\n\n    vec2 posN = posB - offNP * 2.;\n    vec2 posP = posB + offNP * 2.;\n\n    float subpixD = ((-2.0)*subpixC) + 3.0;\n    float lumaEndN = luma(\n        mix(\n            texture2D(tex, posN),\n            texture2D(tex, posN + offHM),\n            0.5\n        )\n    );\n    float subpixE = subpixC * subpixC;\n    float lumaEndP = luma(\n        mix(\n            texture2D(tex, posP),\n            texture2D(tex, posP + offHM),\n            0.5\n        )\n    );\n\n    float gradientScaled = gradient * 0.25;\n    float lumaMM = lumaM - lumaNN * 0.5;\n    float subpixF = subpixD * subpixE;\n    bool lumaMLTZero = lumaMM < 0.0;\n\n    lumaEndN -= lumaNN * 0.5;\n    lumaEndP -= lumaNN * 0.5;\n    bool doneN = abs(lumaEndN) >= gradientScaled;\n    bool doneP = abs(lumaEndP) >= gradientScaled;\n    if (!doneN) {\n        posN -= offNP * 3.0;\n    }\n    bool doneNP = (!doneN) || (!doneP);\n    if (!doneP) {\n        posP += offNP * 3.0;\n    }\n\n    if (doneNP) {\n        if (!doneN) {\n            lumaEndN = luma(\n                mix(\n                    texture2D(tex, posN),\n                    texture2D(tex, posN + offHM),\n                    0.5\n                )\n            );\n            lumaEndN = lumaEndN - lumaNN * 0.5;\n        }\n        if (!doneP) {\n            lumaEndP = luma(\n                mix(\n                    texture2D(tex, posP.xy),\n                    texture2D(tex, posP.xy + offHM),\n                    0.5\n                )\n            );\n            lumaEndP = lumaEndP - lumaNN * 0.5;\n        }\n        doneN = abs(lumaEndN) >= gradientScaled;\n        doneP = abs(lumaEndP) >= gradientScaled;\n        if (!doneN) {\n            posN -= offNP * 12.0;\n        }\n        if (!doneP) {\n            posP += offNP * 12.0;\n        }\n    }\n    float dstN = posM.x - posN.x;\n    float dstP = posP.x - posM.x;\n    if (!horzSpan) {\n        dstN = posM.y - posN.y;\n        dstP = posP.y - posM.y;\n    }\n    bool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\n    float spanLength = (dstP + dstN);\n    bool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\n    float spanLengthRcp = 1.0/spanLength;\n    bool directionN = dstN < dstP;\n    float dst = min(dstN, dstP);\n    bool goodSpan = directionN ? goodSpanN : goodSpanP;\n    float subpixG = subpixF * subpixF;\n    float pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\n    float subpixH = subpixG * fxaaQualitySubpix;\n    float pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\n    float pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\n    vec4 color;\n    float factor = pixelOffsetSubpix;\n    if (horzSpan) {\n        color = mix(\n            texture2D(tex, posM),\n            texture2D(tex, posM + vec2(0.0, lengthSign)),\n            factor\n        );\n    } else {\n        color = mix(\n            texture2D(tex, posM),\n            texture2D(tex, posM + vec2(lengthSign, 0.0)),\n            factor\n        );\n    }\n\n    return color;\n}\n\nvoid main() {\n    vec2 pos = gl_FragCoord.xy * pixelSize;\n    vec4 color = fxaa(\n        pos,\n        texture,\n        pixelSize,\n        FXAA_QUALITY_SUBPIX,\n        FXAA_QUALITY_EDGE_THRESHOLD,\n        FXAA_QUALITY_EDGE_THRESHOLD_MIN\n    );\n\n    // If color.a is less than one, then the color has been blended with a black background before.\n    // An original color of transparent objects is vec4(color.xyz / color.a, color.a).\n    // We have to blend an original color with background pattern.\n    // color.a can be too close to zero. Check it.\n    if (color.a > EPSILON) {\n        color.xyz /= color.a;\n    }\n    gl_FragColor = color;\n}\n"

/***/ }),
/* 179 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__gl_renderer__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__state__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_event_emitter__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__shaders_quad_vert__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__shaders_quad_vert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__shaders_quad_vert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__shaders_background_frag__ = __webpack_require__(180);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__shaders_background_frag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4__shaders_background_frag__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__util_hd__ = __webpack_require__(10);






const STATE = new __WEBPACK_IMPORTED_MODULE_1__state__["c" /* default */]({
    depthTest: true,
    depthFunc: 518 /* GREATER_OR_EQUAL */
});
/**
 * Fills map's canvas with background pattern on regions that have no data yet.
 */
class BackgroundRenderUnit extends __WEBPACK_IMPORTED_MODULE_0__gl_renderer__["a" /* GlRenderer */] {
    constructor(context) {
        const program = context.createProgram(__WEBPACK_IMPORTED_MODULE_3__shaders_quad_vert___default.a, __WEBPACK_IMPORTED_MODULE_4__shaders_background_frag___default.a, {
            attribMap: {
                vertexPosition: 0 /* POSITION */,
                vertexUv: 4 /* UV */
            }
        });
        super(context, STATE, program);
        context.bindProgram(program);
        program.setScalarUniform('zIndex', -1);
        this.onUpdate = new __WEBPACK_IMPORTED_MODULE_2__util_event_emitter__["b" /* VoidEventEmitter */]();
    }
    _render() {
        this._context.bindQuadVao();
        this._context.drawQuad();
    }
    _prepareProgram(program) {
        super._prepareProgram(program);
        program.setScalarUniform('dpr', Object(__WEBPACK_IMPORTED_MODULE_5__util_hd__["a" /* default */])());
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = BackgroundRenderUnit;



/***/ }),
/* 180 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nvoid main() {\n    // Background color should match main map layer color.\n    gl_FragColor = vec4(0.98, 0.97, 0.94, 1);\n}\n"

/***/ }),
/* 181 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__list_render_unit__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__state__ = __webpack_require__(0);


const DEPTH_CLEAR_STATE = new __WEBPACK_IMPORTED_MODULE_1__state__["c" /* default */]({
    depthTest: true,
    clearDepth: 0
});
class LayerRenderUnit extends __WEBPACK_IMPORTED_MODULE_0__list_render_unit__["a" /* default */] {
    constructor(context, depthClearStrategy = 0 /* NO_CLEAR */) {
        super();
        this._depthClearStrategy = depthClearStrategy;
        this._context = context;
    }
    render(target, ...args) {
        if (this._depthClearStrategy === 1 /* BEFORE_RENDER */) {
            this._context.bindRenderState(DEPTH_CLEAR_STATE);
            this._context.bindRenderTarget(target);
            this._context.clearCurrentTarget(256 /* DEPTH_BUFFER_BIT */);
        }
        super.render(target, ...args);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = LayerRenderUnit;



/***/ }),
/* 182 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__render_state__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__render_memory_count_vertices__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shaders_reset_removed_vert__ = __webpack_require__(183);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shaders_reset_removed_vert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__shaders_reset_removed_vert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__shaders_reset_removed_frag__ = __webpack_require__(184);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__shaders_reset_removed_frag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__shaders_reset_removed_frag__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__render_gl_renderer__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__render_primitives_primitive_batch__ = __webpack_require__(44);






class CollidingPrimitivesResetRemovedRenderer extends __WEBPACK_IMPORTED_MODULE_4__render_gl_renderer__["a" /* GlRenderer */] {
    constructor(context, primitiveProvider) {
        const program = context.createProgram(__WEBPACK_IMPORTED_MODULE_2__shaders_reset_removed_vert___default.a, __WEBPACK_IMPORTED_MODULE_3__shaders_reset_removed_frag___default.a, {
            attribMap: {
                vertexPosHigh: 0 /* POSITION_HIGH */,
                vertexId: 2 /* ID */
            }
        });
        super(context, new __WEBPACK_IMPORTED_MODULE_0__render_state__["c" /* default */](), program);
        this._primitiveProvider = primitiveProvider;
        context.bindProgram(program);
        program.setIntScalarUniform('prevVisibility', 0);
    }
    _render() {
        const primitives = this._primitiveProvider.primitives;
        for (const memoryBatch of Object(__WEBPACK_IMPORTED_MODULE_5__render_primitives_primitive_batch__["a" /* batchPrimitives */])(primitives)) {
            this._context.bindVao(memoryBatch.page.vao);
            this._context.drawIndexedMesh(memoryBatch.indexByteOffset, Object(__WEBPACK_IMPORTED_MODULE_1__render_memory_count_vertices__["a" /* countIndices */])(memoryBatch.indexByteLength, memoryBatch.page.indexType), 0 /* POINTS */);
        }
    }
    _prepareProgram(program, prevVisibility, idHalfPxSize) {
        super._prepareProgram(program, prevVisibility, idHalfPxSize);
        this._context.bindTextureUnit(0);
        this._context.bindTexture(prevVisibility);
        program.setVector2Uniform('idHalfPxSize', idHalfPxSize);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = CollidingPrimitivesResetRemovedRenderer;



/***/ }),
/* 183 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec2 vertexPosHigh;\nattribute vec2 vertexId;\n\nuniform sampler2D prevVisibility;\nuniform vec2 idHalfPxSize;\n\nvarying lowp vec4 visibilityValue;\n\nvoid main() {\n    vec2 idTexCoordinates = vertexId + idHalfPxSize;\n    vec4 idWindowCoordinates = vec4(idTexCoordinates * 2.0 - 1.0, 0, 1);\n    gl_Position = idWindowCoordinates;\n    gl_PointSize = 1.0;\n\n    visibilityValue = texture2D(prevVisibility, idTexCoordinates);\n}\n"

/***/ }),
/* 184 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nvarying lowp vec4 visibilityValue;\n\nvoid main() {\n    gl_FragColor = visibilityValue;\n}\n"

/***/ }),
/* 185 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_event_emitter__ = __webpack_require__(2);

const MAX_FRAME_TIME_COUNT = 100;
class RenderLoop {
    /**
     * Create a new render loop, but doesn't schedule any animation frames.
     */
    constructor() {
        this.onFrameTimesFull = new __WEBPACK_IMPORTED_MODULE_0__util_event_emitter__["a" /* EventEmitter */]();
        this.onBeforeRender = new __WEBPACK_IMPORTED_MODULE_0__util_event_emitter__["b" /* VoidEventEmitter */]();
        this.onRender = new __WEBPACK_IMPORTED_MODULE_0__util_event_emitter__["b" /* VoidEventEmitter */]();
        this._isRunning = this._updateIsRequested = false;
        this._lastFrameTime = 0;
        this._frameTimes = new Array(MAX_FRAME_TIME_COUNT);
        this._frameTimes.fill(0);
        this._nextFrameTimeIdx = 0;
    }
    /**
     * @returns Whether the loop is running a chain of consecutive animation
     *      frames or not.
     */
    get isActive() {
        return this._isRunning;
    }
    /**
     * Starts a chain of consecutive animation frames.
     */
    start() {
        this._isRunning = true;
        this._requestFrame();
    }
    /**
     * Stops previously started chain of consecutive animation frames. If an
     * update was requested before stopping, one more animation frame will be
     * fired.
     */
    stop() {
        if (this._isRunning) {
            this._isRunning = false;
            if (!this._updateIsRequested) {
                this._cancelFrame();
            }
        }
    }
    /**
     * Schedules a single
     */
    update() {
        this._updateIsRequested = true;
        this._requestFrame();
    }
    /**
     * Stops all the rendering activities.
     */
    destroy() {
        this._cancelFrame();
    }
    _renderFrame(time) {
        this._rafId = 0;
        this._updateIsRequested = false;
        this.onBeforeRender.fire();
        this.onRender.fire();
        if (this._lastFrameTime > 0) {
            const nextFrameTimeIdx = this._nextFrameTimeIdx;
            this._frameTimes[nextFrameTimeIdx] = time - this._lastFrameTime;
            this._nextFrameTimeIdx = (nextFrameTimeIdx + 1) % MAX_FRAME_TIME_COUNT;
            // Next time index being 0 means that the array is full and it's
            // time to notify listeners about that before we start to rewrite
            // values.
            if (this._nextFrameTimeIdx === 0) {
                this.onFrameTimesFull.fire(this._frameTimes);
            }
        }
        if (this._isRunning) {
            this._lastFrameTime = time;
            this._requestFrame();
        }
        else {
            // If we don't schedule next frame immediately there's no way to
            // tell that it will be consecutive to the current one. Hence there's
            // no point in recording a time delta in it.
            this._lastFrameTime = 0;
        }
    }
    _requestFrame() {
        if (!this._rafId) {
            this._rafId = requestAnimationFrame(((time) => this._renderFrame(time)));
        }
    }
    _cancelFrame() {
        cancelAnimationFrame(this._rafId);
        this._rafId = 0;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RenderLoop;



/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgNWE0MjFmZTBiNjhkYzhlMTJlOGMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9zdGF0ZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvbWF0aC92ZWN0b3IyLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL2V2ZW50X2VtaXR0ZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9hdHRyaWJfbWFwcGluZy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL2dsX3JlbmRlcmVyLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy93b3JsZF9wcmltaXRpdmVfcmVuZGVyX3VuaXQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvYnVmZmVyX3dyaXRlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL3JlbmRlcmFibGVfcHJpbWl0aXZlLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL2l0ZXJhYmxlLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9tYXRoL3NjYWxhci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9oZC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9jb2xvci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvbWF0aC92ZWN0b3IzLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL2dwdXR5cGVzLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL2FycmF5LnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvbWVtb3J5L2NvdW50X3ZlcnRpY2VzLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9hZGFwdGVycy90aWxlX2Jhc2VkX2FkYXB0ZXIvdGlsZV9pZC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC93b3JrZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvc3RhdC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9jb21wYXJhdG9yLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL3JlZl9jb3VudGVkLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9hZGFwdGVycy92ZWN0b3JfYXBpL3ByaW1pdGl2ZV9tYW5hZ2VyL3JlbmRlcmFibGVfcHJpbWl0aXZlX21hbmFnZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL3BvbHlnb24vcG9seWdvbl9yZW5kZXJfdW5pdC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL2xpc3RfcmVuZGVyX3VuaXQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL21hdGgvbWF0cml4NC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9mdXp6eV9lcXVhbC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC91bmlxdWVfaWQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9tZW1vcnkvc3ViX2NodW5rLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9mb250L2RmX2ZvbnQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3ByaW1pdGl2ZS9tb2RlbC9tb2RlbF9idWZmZXJfd3JpdGVyLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL3pfaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3ByaW1pdGl2ZS9wb2x5Z29uL3RleHR1cmVkX3BvbHlnb25fYXR0cmlidXRlX21hcHBpbmcudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3ByaW1pdGl2ZS9wb2x5Z29uL3BvbHlnb25fYXR0cmlidXRlX21hcHBpbmcudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3ByaW1pdGl2ZS9wb2x5bGluZS9wb2x5bGluZV9hdHRyaWJ1dGVfbWFwcGluZy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdmVjdG9yX2FwaS93b3JrZXIvdGlsZV9wcm92aWRlcl93b3JrZXJfbWVzc2FnZXMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvcHJpb3JpdHlfcXVldWUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3ByaW1pdGl2ZS9wb2x5bGluZS9yZW5kZXJhYmxlX3BvbHlsaW5lLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9wcmltaXRpdmUvbW9kZWwvcmVuZGVyYWJsZV9tb2RlbC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdmVjdG9yX2FwaS9wcmltaXRpdmVfbWFuYWdlci9wcmltaXRpdmVfbWFuYWdlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvcHJpbWl0aXZlX3NldF9zdG9yYWdlLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9kaXNhcHBlYXJpbmdfcHJpbWl0aXZlX3NldF9zdG9yYWdlLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL2RlbGVnYXRvci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdmlzaWJpbGl0eS9wcmltaXRpdmVzL2xhYmVsL3NoYWRlci9jb2xvcl9pZC5mcmFnIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS92aXNpYmlsaXR5L3ByaW1pdGl2ZXMvbGFiZWwvY29sb3JfaWRfbGFiZWxfcmVuZGVyZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL3ByaW1pdGl2ZV9iYXRjaC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvbGFiZWwvcG9pbnRfbGFiZWxfcmVuZGVyX3VuaXQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL2xhYmVsL3NoYWRlci9kZl90ZXh0LmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL2xhYmVsL2xhYmVsX3JlbmRlcl91bml0LnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9sYWJlbC9jdXJ2ZWRfbGFiZWxfcmVuZGVyX3VuaXQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL3BvbHlsaW5lL2Jhc2VfcG9seWxpbmVfcmVuZGVyX3VuaXQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvYWxsb2NhdG9yLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvdXRpbC9jYW1lcmFfcG9zaXRpb24udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9zaGFkZXJzL3F1YWQudmVydCIsIndlYnBhY2s6Ly8vLi90b29scy9zdGFuZC9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL2NvbnRleHQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvcG93X29mXzIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9nbC9idWZmZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9nbC9mcmFtZWJ1ZmZlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL2dsL3Byb2dyYW0udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9nbC9yZW5kZXJidWZmZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9jYXBhYmlsaXRpZXMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9nbC90ZXh0dXJlLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvZ2wvdmFvLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9jYW1lcmEudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvcmFkX2RlZy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9vcHRpb25zLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9tYXRoL21hdHJpeDMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2FkYXB0ZXJzL3ZlY3Rvcl9hcGkvYWRhcHRlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdGlsZV9iYXNlZF9hZGFwdGVyL2FkYXB0ZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2FkYXB0ZXJzL2FkYXB0ZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvZnVuY3Rpb24udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2FkYXB0ZXJzL3RpbGVfYmFzZWRfYWRhcHRlci91dGlsL3RpbGVfc3lzdGVtLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9hZGFwdGVycy90aWxlX2Jhc2VkX2FkYXB0ZXIvdXRpbC92aXNpYmxlX3RpbGUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2FkYXB0ZXJzL3RpbGVfYmFzZWRfYWRhcHRlci9iZWx0X3RpbGVzLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9wcmltaXRpdmUvaWNvbi9pY29uX2J1ZmZlcl93cml0ZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2JpbGxib2FyZC9pZGVudGlmaWVkX2ltYWdlX2F0bGFzX21hbmFnZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2ZvbnQvZm9udC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdmVjdG9yX2FwaS9hcGlfaW1hZ2VfcHJvdmlkZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2JpbGxib2FyZC9pbWFnZV9wcm92aWRlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdmVjdG9yX2FwaS91dGlsL2hvc3RzLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9wcmltaXRpdmUvcG9seWxpbmUvdGV4dHVyZWRfcG9seWxpbmVfYnVmZmVyX3dyaXRlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL3BvbHlsaW5lL3RleHR1cmVkX3BvbHlsaW5lX2dlb21ldHJ5LnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9iaWxsYm9hcmQvaW1hZ2VfbWFuYWdlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL3BvbHlnb24vdGV4dHVyZWRfcG9seWdvbl9idWZmZXJfcmV3aXRlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9idWZmZXJfcmV3cml0ZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3ByaW1pdGl2ZS9iaWxsYm9hcmRfcmVjdGFuZ2xlL2F0dHJpYnV0ZV9tYXBwaW5nLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9wcmltaXRpdmUvbGFiZWwvcG9pbnRfbGFiZWxfYXR0cmlidXRlX21hcHBpbmcudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3ByaW1pdGl2ZS9sYWJlbC9jdXJ2ZWRfbGFiZWxfYXR0cmlidXRlX21hcHBpbmcudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2FkYXB0ZXJzL3ZlY3Rvcl9hcGkvd29ya2VyL3RpbGVfcHJvdmlkZXJfd29ya2VyX2NsaWVudC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdmVjdG9yX2FwaS93b3JrZXIvcHJpbWl0aXZlX3Byb3ZpZGVyX3dvcmtlcl9tZXNzYWdlcy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL3BvbHlnb24vdHJhbnNwYXJlbnRfcG9seWdvbl9hdHRyaWJ1dGVfbWFwcGluZy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9pZGxlX3Rhc2tfcXVldWUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvYmluYXJ5X2hlYXAudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3ByaW1pdGl2ZS9wb2x5Z29uL3JlbmRlcmFibGVfcG9seWdvbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL3BvbHlnb24vcmVuZGVyYWJsZV90ZXh0dXJlZF9wb2x5Z29uLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9wcmltaXRpdmUvcG9seWxpbmUvcmVuZGVyYWJsZV90ZXh0dXJlZF9wb2x5bGluZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdmVjdG9yX2FwaS90aWxlX2RhdGEudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2FkYXB0ZXJzL3ZlY3Rvcl9hcGkvcHJpbWl0aXZlX21hbmFnZXIvcG9seWdvbl9tYW5hZ2VyLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9kZWxheWVkX2Rpc2FwcGVhcmluZ19wcmltaXRpdmVfc2V0X3N0b3JhZ2UudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2FkYXB0ZXJzL3ZlY3Rvcl9hcGkvcHJpbWl0aXZlX21hbmFnZXIvem9vbV9maWx0ZXJhYmxlX3ByaW1pdGl2ZV9tYW5hZ2VyLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9hZGFwdGVycy92ZWN0b3JfYXBpL3ByaW1pdGl2ZV9tYW5hZ2VyL2V4dGVybmFsX21lc2hfbWFuYWdlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL2JpbGxib2FyZF9yZWN0YW5nbGUvcmVuZGVyYWJsZV9iaWxsYm9hcmRfcmVjdGFuZ2xlLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9hZGFwdGVycy92ZWN0b3JfYXBpL3ByaW1pdGl2ZS96b29tX3Jlc3RyaWN0ZWRfbGFiZWwudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3ByaW1pdGl2ZS9sYWJlbC9yZW5kZXJhYmxlX2xhYmVsLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9hZGFwdGVycy92ZWN0b3JfYXBpL3ByaW1pdGl2ZS96b29tX3Jlc3RyaWN0ZWRfaWNvbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL2ljb24vcmVuZGVyYWJsZV9pY29uLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9wcmltaXRpdmUvaW1hZ2UvcmVuZGVyYWJsZV9pbWFnZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL3RleHR1cmVkX3JlbmRlcmFibGVfcHJpbWl0aXZlLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL3Rhc2tfcXVldWUudHMiLCJ3ZWJwYWNrOi8vLy4vdG9vbHMvc3RhbmQvY2FtZXJhX3N0dWZmLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS92aXNpYmlsaXR5L3ByaW1pdGl2ZXMvbGFiZWwvY29sb3JfaWRfcG9pbnRfbGFiZWxfcmVuZGVyZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3Zpc2liaWxpdHkvcHJpbWl0aXZlcy9sYWJlbC9zaGFkZXIvcG9pbnRfbGFiZWwudmVydCIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdmlzaWJpbGl0eS9wcmltaXRpdmVzL2NvbGxpZGluZ19wcmltaXRpdmVfY29sb3JfaWRfcmVuZGVyZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9tZW1vcnkvcmVsYXRpdmVfbG9jYXRpb24udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL2xhYmVsL3NoYWRlci9wb2ludF9sYWJlbC52ZXJ0Iiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9iaWxsYm9hcmRfcmVjdGFuZ2xlL2JpbGxib2FyZF9yZWN0YW5nbGVfcmVuZGVyX3VuaXQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL2JpbGxib2FyZF9yZWN0YW5nbGUvc2hhZGVyL2JpbGxib2FyZF9yZWN0YW5nbGUudmVydCIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvYmlsbGJvYXJkX3JlY3RhbmdsZS9zaGFkZXIvYmlsbGJvYXJkX3JlY3RhbmdsZS5mcmFnIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS92aXNpYmlsaXR5L3ByaW1pdGl2ZXMvbGFiZWwvY29sb3JfaWRfY3VydmVkX2xhYmVsX3JlbmRlcmVyLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS92aXNpYmlsaXR5L3ByaW1pdGl2ZXMvbGFiZWwvc2hhZGVyL2N1cnZlZF9sYWJlbC52ZXJ0Iiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9sYWJlbC9zaGFkZXIvY3VydmVkX2xhYmVsLnZlcnQiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL2ljb24vaWNvbl9yZW5kZXJfdW5pdC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvaWNvbi9zaGFkZXIvaWNvbi52ZXJ0Iiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9pY29uL3NoYWRlci9pY29uLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL2ltYWdlL2ltYWdlX3JlbmRlcl91bml0LnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9pbWFnZS9zaGFkZXIvaW1hZ2UudmVydCIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvaW1hZ2Uvc2hhZGVyL2ltYWdlLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL21vZGVsL21vZGVsX3JlbmRlcl91bml0LnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9tb2RlbC9zaGFkZXIvbW9kZWwudmVydCIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvbW9kZWwvc2hhZGVyL21vZGVsLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL292ZXJsYXkvb3ZlcmxheV9yZW5kZXJlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvb3ZlcmxheS9zaGFkZXIvb3ZlcmxheS52ZXJ0Iiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9vdmVybGF5L3NoYWRlci9vdmVybGF5LmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL3BvbHlsaW5lL3RleHR1cmVkX3BvbHlsaW5lX3JlbmRlcl91bml0LnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9wb2x5bGluZS9zaGFkZXIvdGV4dHVyZWRfcG9seWxpbmUudmVydCIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvcG9seWxpbmUvc2hhZGVyL3RleHR1cmVkX3BvbHlsaW5lLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL3BvbHlsaW5lL3BvbHlsaW5lX3JlbmRlcl91bml0LnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9wcmltaXRpdmUvcG9seWxpbmUvcG9seWxpbmVfYnVmZmVyX3dyaXRlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvcG9seWxpbmUvc2hhZGVyL3BvbHlsaW5lLnZlcnQiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL3BvbHlsaW5lL3NoYWRlci9wb2x5bGluZS5mcmFnIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9wb2x5Z29uL3RleHR1cmVkX3BvbHlnb25fcmVuZGVyX3VuaXQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL3BvbHlnb24vc2hhZGVyL3RleHR1cmVkX3BvbHlnb24udmVydCIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvcG9seWdvbi9zaGFkZXIvdGV4dHVyZWRfcG9seWdvbi5mcmFnIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9wb2x5Z29uL3RyYW5zcGFyZW50X3BvbHlnb25fcmVuZGVyX3VuaXQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL3BvbHlnb24vc2hhZGVyL3BvbHlnb24udmVydCIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvcG9seWdvbi9zaGFkZXIvcG9seWdvbi5mcmFnIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9tYXBfZW5naW5lLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9lbmdpbmUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9mb250L3JlbmRlcmFibGVfZGZfZ2x5cGhfYXRsYXMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2ZvbnQvZGZfZ2x5cGhfYXRsYXMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2ZvbnQvZGZfZm9udF9yZWdpc3RyeS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvZm9udC9mb250X3JlZ2lzdHJ5LnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvYmlsbGJvYXJkL3JlbmRlcmFibGVfaW1hZ2VfYXRsYXMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2JpbGxib2FyZC9pbWFnZV9hdGxhcy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9hbGxvY2F0b3JfMmQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvYmluYXJ5X3RyZWUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvbGlua2VkX3NldC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdmlzaWJpbGl0eS92aXNpYmlsaXR5X21hbmFnZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3Zpc2liaWxpdHkvZ3JpZF9zYW1wbGVyX2J1ZmZlcl93cml0ZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3Zpc2liaWxpdHkvZ3JpZF9yZW5kZXJlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdmlzaWJpbGl0eS92aXNpYmlsaXR5X3Jlc29sdXRpb25fc3RlcHMvcmVzZXRfcmVtb3ZlZF9wcmltaXRpdmVzLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS92aXNpYmlsaXR5L3Zpc2liaWxpdHlfcmVzb2x1dGlvbl9zdGVwcy9mYWRlb3V0X2FsbC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdmlzaWJpbGl0eS92aXNpYmlsaXR5X3Jlc29sdXRpb25fc3RlcHMvc2hhZGVycy9mYWRlb3V0X2FsbC52ZXJ0Iiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS92aXNpYmlsaXR5L3Zpc2liaWxpdHlfcmVzb2x1dGlvbl9zdGVwcy9zaGFkZXJzL2ZhZGVvdXRfYWxsLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3Zpc2liaWxpdHkvaWRfc2FtcGxlcl9idWZmZXJfd3JpdGVyLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS92aXNpYmlsaXR5L3Zpc2liaWxpdHlfcmVzb2x1dGlvbl9zdGVwcy9mYWRlaW5fdmlzaWJsZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdmlzaWJpbGl0eS92aXNpYmlsaXR5X3Jlc29sdXRpb25fc3RlcHMvc2hhZGVycy9mYWRlaW5fdmlzaWJsZS52ZXJ0Iiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS92aXNpYmlsaXR5L3Zpc2liaWxpdHlfcmVzb2x1dGlvbl9zdGVwcy9zaGFkZXJzL2ZhZGVpbl92aXNpYmxlLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3Zpc2liaWxpdHkvdmlzaWJpbGl0eV9yZXNvbHV0aW9uX3N0ZXBzL2ZhZGVvdXRfb3ZlcmxhcHBlZC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdmlzaWJpbGl0eS92aXNpYmlsaXR5X3Jlc29sdXRpb25fc3RlcHMvc2hhZGVycy9mYWRlb3V0X292ZXJsYXBwZWQudmVydCIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdmlzaWJpbGl0eS92aXNpYmlsaXR5X3Jlc29sdXRpb25fc3RlcHMvc2hhZGVycy9mYWRlb3V0X292ZXJsYXBwZWQuZnJhZyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9jYXJ0ZXNpYW5fZ3JpZC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9tZWRpYW5fZmlsdGVyLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvbWFpbl9yZW5kZXJfdW5pdC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL21lbW9yeS9tYW5hZ2VyLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvbWVtb3J5L3BhZ2UudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9tZW1vcnkvY2h1bmsudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9meGFhX3JlbmRlcl91bml0LnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvc2hhZGVycy9meGFhLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9iYWNrZ3JvdW5kX3JlbmRlcl91bml0LnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvc2hhZGVycy9iYWNrZ3JvdW5kLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9sYXllcl9yZW5kZXJfdW5pdC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdmlzaWJpbGl0eS9wcmltaXRpdmVzL2NvbGxpZGluZ19wcmltaXRpdmVfcmVzZXRfcmVtb3ZlZF9yZW5kZXJlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdmlzaWJpbGl0eS9wcmltaXRpdmVzL3NoYWRlcnMvcmVzZXRfcmVtb3ZlZC52ZXJ0Iiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS92aXNpYmlsaXR5L3ByaW1pdGl2ZXMvc2hhZGVycy9yZXNldF9yZW1vdmVkLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlcl9sb29wLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7QUM3REE7QUFBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFBQTtBQUFBO0FBQ0s7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUFBO0FBQUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMkRBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUFBO0FBQUE7Ozs7Ozs7O0FDMUZEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQTZFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZO0FBQ1o7QUFDTywwQkFBMEI7QUFBQTtBQUFBO0FBQzFCLG9CQUFvQjtBQUFBO0FBQUE7QUFDcEIsZ0NBQWdDO0FBQUE7QUFBQTtBQUNoQyxpQ0FBaUM7QUFBQTtBQUFBO0FBQ2pDLGdDQUFnQztBQUFBO0FBQUE7QUFDaEMsaUNBQWlDO0FBQUE7QUFBQTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sMkNBQTJDLDRFQUFpQjtBQUNuRSxZQUFZLDBFQUFtQjtBQUMvQixRQUFRLDBFQUFtQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQUE7QUFBQTtBQUNLO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQUE7QUFBQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sNkNBQTZDLHFDQUFxQztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QyxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0Es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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxzQkFBc0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9CQUFvQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDJEQUFHO0FBQ2xCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdFQUFhO0FBQ3JDLHdCQUF3Qix3RUFBYTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQUE7QUFBQTs7Ozs7Ozs7QUMzZUQ7QUFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ2Usa0NBQWtDLGtFQUFnQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFBQTtBQUFBOzs7Ozs7OztBQ1pEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLHdEQUF3RCxxQkFBcUI7QUFDN0U7QUFDQTtBQUNBOzs7Ozs7OztBQ3hHQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBOzs7Ozs7OztBQ2hEQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2U7QUFDZjtBQUNBOzs7Ozs7OztBQ1RBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFPLHdDQUF3QztBQUFBO0FBQUE7QUFDeEMsNkNBQTZDO0FBQUE7QUFBQTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBOzs7Ozs7OztBQ2pFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBcUM7QUFDd0M7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsWUFBWTtBQUNaO0FBQ08sK0JBQStCO0FBQUE7QUFBQTtBQUMvQixtQ0FBbUM7QUFBQTtBQUFBO0FBQ25DLG9DQUFvQztBQUFBO0FBQUE7QUFDcEMsbUNBQW1DO0FBQUE7QUFBQTtBQUNuQyxvQ0FBb0M7QUFBQTtBQUFBO0FBQ3BDLG1DQUFtQztBQUFBO0FBQUE7QUFDbkMsb0NBQW9DO0FBQUE7QUFBQTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sMkNBQTJDLDRFQUFpQjtBQUNuRSxZQUFZLDBFQUFtQjtBQUMvQixRQUFRLDBFQUFtQjtBQUMzQixRQUFRLDBFQUFtQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLEVBQUU7QUFBQTtBQUFBO0FBQ0s7QUFDUDtBQUNBO0FBQ0EsRUFBRTtBQUFBO0FBQUE7QUFDSztBQUNQO0FBQ0E7QUFDQSxFQUFFO0FBQUE7QUFBQTtBQUNLO0FBQ1A7QUFDQTtBQUNBLEVBQUU7QUFBQTtBQUFBO0FBQ0s7QUFDUDtBQUNBO0FBQ0EsRUFBRTtBQUFBO0FBQUE7QUFDSztBQUNQO0FBQ0E7QUFDQSxFQUFFO0FBQUE7QUFBQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdURBQWEsQ0FBQywwREFBZ0I7QUFDOUM7QUFDQTs7Ozs7Ozs7QUNuV0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7Ozs7Ozs7O0FDaENBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxvQ0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQUE7QUFBQTs7Ozs7Ozs7QUNuRUQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBcUM7QUFDckM7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUFBO0FBQUE7QUFDSztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUFBO0FBQUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3pEQTtBQUFBLDRDQUE0QztBQUNyQztBQUNQO0FBQ0E7Ozs7Ozs7O0FDSEE7QUFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ08sK0NBQStDLGdGQUFnQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFBQTtBQUFBOzs7Ozs7OztBQzdDSDtBQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDTyxzQ0FBc0MsZ0ZBQWdCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQUE7QUFBQTs7Ozs7Ozs7QUNyQ0g7QUFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ08sdUNBQXVDLGdGQUFnQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx1REFBVztBQUM5QztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDZEQUFjO0FBQzNCO0FBQ0EsWUFBWSx5REFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMkRBQU07QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUFBO0FBQUE7Ozs7Ozs7O0FDbnlCRDtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBOzs7Ozs7OztBQ3BCQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFBQTtBQUFBOzs7Ozs7OztBQ3BERDtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUFBO0FBQUE7Ozs7Ozs7O0FDM0REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2U7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELDZCQUE2QjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFBQTtBQUFBO0FBQ0Q7QUFDQSx5Q0FBeUMsZ0ZBQWdCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNqRkE7QUFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDZCQUE2QixrRUFBZ0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUFBO0FBQUE7QUFDRDtBQUNBO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFBQTtBQUFBOzs7Ozs7OztBQ2xFRDtBQUNBO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUFBO0FBQUE7Ozs7Ozs7O0FDL0ZEO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUFBO0FBQUE7Ozs7Ozs7O0FDcEpEO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUFBO0FBQUE7Ozs7Ozs7O0FDL0hEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBMEM7QUFDSDtBQUNDO0FBQ0E7QUFDQTtBQUM2RTtBQUM1RDtBQUNkO0FBQ2lEO0FBQ3pCO0FBQ007QUFDUTtBQUNQO0FBQzFDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyw4REFBVztBQUM3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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQUE7QUFBQTs7Ozs7OztBQ2hDRCxrRkFBa0YsMEJBQTBCLHFDQUFxQyw0QkFBNEIsc0NBQXNDLGlCQUFpQixzREFBc0QsMEVBQTBFLHdDQUF3Qyx5QkFBeUIsc0VBQXNFLEdBQUcsRzs7Ozs7O0FDQTllLHVGQUF1RixpQkFBaUIscUNBQXFDLEdBQUcsRzs7Ozs7OztBQ0FoSjtBQUFzRTtBQUN0RTtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MseUVBQVk7QUFDaEQsa0NBQWtDLDZFQUFnQjtBQUNsRCw0QkFBNEIsNkVBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUFBO0FBQUEiLCJmaWxlIjoiaW5kZXgudHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSA1Myk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgNWE0MjFmZTBiNjhkYzhlMTJlOGMiLCJpbXBvcnQgKiBhcyBjb2xvciBmcm9tICcuLi91dGlsL2NvbG9yJztcclxuLyoqXHJcbiAqIFByZXNldCBvZiByZW5kZXIgc3RhdGUgZm9yIE9WRVIgY29tcG9zaXRpbmcsXHJcbiAqIEBzZWUgVC4gUG9ydGVyIGFuZCBULiBEdWZmLCBcIkNvbXBvc2l0aW5nIERpZ2l0YWwgSW1hZ2VzXCIsIFByb2NlZWRpbmdzIG9mXHJcbiAqICAgICAgU0lHR1JBUEgnODQsIDE4ICgxOTg0KS5cclxuICovXHJcbmV4cG9ydCBjb25zdCBCTEVORF9PVkVSX1JFTkRFUl9TVEFURSA9IHtcclxuICAgIGJsZW5kOiB0cnVlLFxyXG4gICAgYmxlbmRGdW5jU3JjUmdiOiA3NzAgLyogU1JDX0FMUEhBICovLFxyXG4gICAgYmxlbmRGdW5jRHN0UmdiOiA3NzEgLyogT05FX01JTlVTX1NSQ19BTFBIQSAqLyxcclxuICAgIGJsZW5kRnVuY1NyY0FscGhhOiAxIC8qIE9ORSAqLyxcclxuICAgIGJsZW5kRnVuY0RzdEFscGhhOiA3NzEgLyogT05FX01JTlVTX1NSQ19BTFBIQSAqL1xyXG59O1xyXG5leHBvcnQgY29uc3QgQkxFTkRfT1ZFUl9QUkVNVUxUSVBMSUVEX0FMUEhBX1JFTkRFUl9TVEFURSA9IHtcclxuICAgIGJsZW5kOiB0cnVlLFxyXG4gICAgYmxlbmRGdW5jU3JjUmdiOiAxIC8qIE9ORSAqLyxcclxuICAgIGJsZW5kRnVuY0RzdFJnYjogNzcxIC8qIE9ORV9NSU5VU19TUkNfQUxQSEEgKi8sXHJcbiAgICBibGVuZEZ1bmNTcmNBbHBoYTogMSAvKiBPTkUgKi8sXHJcbiAgICBibGVuZEZ1bmNEc3RBbHBoYTogNzcxIC8qIE9ORV9NSU5VU19TUkNfQUxQSEEgKi9cclxufTtcclxuLyoqXHJcbiAqIFN0YXRlIG9mIHRoZSBXZWJHTCByZW5kZXJpbmcgcGlwZWxpbmUuIERvZXNuJ3QgaW5jbHVkZSBvYmplY3QgYmluZGluZ3Mgc2luY2VcclxuICogdGhlIGNvbnRleHQgaGFuZGxlcyB0aGVtLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVuZGVyU3RhdGUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHJlbmRlciBzdGF0ZSBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHN0YXRlIE9iamVjdCB3aXRoIHN0YXRlIHByb3BlcnRpZXMgdGhhdCB2YWx1ZXMgZGlmZmVyIGZyb20gZGVmYXVsdFxyXG4gICAgICogICAgICBvbmVzLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvciguLi5zdGF0ZSkge1xyXG4gICAgICAgIHRoaXMuY2xlYXJDb2xvciA9IGNvbG9yLmNyZWF0ZSgwLCAwLCAwLCAwKTtcclxuICAgICAgICB0aGlzLmNsZWFyRGVwdGggPSAxO1xyXG4gICAgICAgIHRoaXMuY2xlYXJTdGVuY2lsID0gMDtcclxuICAgICAgICB0aGlzLmNvbG9yTWFza1IgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuY29sb3JNYXNrRyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5jb2xvck1hc2tCID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmNvbG9yTWFza0FscGhhID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmJsZW5kID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5ibGVuZEVxdWF0aW9uUmdiID0gMzI3NzQgLyogQUREICovO1xyXG4gICAgICAgIHRoaXMuYmxlbmRFcXVhdGlvbkFscGhhID0gMzI3NzQgLyogQUREICovO1xyXG4gICAgICAgIHRoaXMuYmxlbmRGdW5jU3JjUmdiID0gMSAvKiBPTkUgKi87XHJcbiAgICAgICAgdGhpcy5ibGVuZEZ1bmNEc3RSZ2IgPSAwIC8qIFpFUk8gKi87XHJcbiAgICAgICAgdGhpcy5ibGVuZEZ1bmNTcmNBbHBoYSA9IDEgLyogT05FICovO1xyXG4gICAgICAgIHRoaXMuYmxlbmRGdW5jRHN0QWxwaGEgPSAwIC8qIFpFUk8gKi87XHJcbiAgICAgICAgdGhpcy5jdWxsRmFjZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuY3VsbEZhY2VNb2RlID0gMTAyOSAvKiBCQUNLICovO1xyXG4gICAgICAgIHRoaXMuZnJvbnRGYWNlTW9kZSA9IDIzMDUgLyogQ09VTlRFUkNMT0NLV0lTRSAqLztcclxuICAgICAgICB0aGlzLmRlcHRoVGVzdCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZGVwdGhGdW5jID0gNTEzIC8qIExFU1MgKi87XHJcbiAgICAgICAgdGhpcy5kZXB0aFJhbmdlTmVhciA9IDA7XHJcbiAgICAgICAgdGhpcy5kZXB0aFJhbmdlRmFyID0gMTtcclxuICAgICAgICB0aGlzLmRlcHRoTWFzayA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5kaXRoZXIgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuZHJhd0J1ZmZlcnMgPSBbMzYwNjQgLyogQ09MT1JfQVRUQUNITUVOVDAgKi9dO1xyXG4gICAgICAgIHRoaXMucG9seWdvbk9mZnNldCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMucG9seWdvbk9mZnNldEZhY3RvciA9IDA7XHJcbiAgICAgICAgdGhpcy5wb2x5Z29uT2Zmc2V0VW5pdHMgPSAwO1xyXG4gICAgICAgIHRoaXMuc2FtcGxlQWxwaGFUb0NvdmVyYWdlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5zYW1wbGVDb3ZlcmFnZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuc2FtcGxlQ292ZXJhZ2VWYWx1ZSA9IDE7XHJcbiAgICAgICAgdGhpcy5zYW1wbGVDb3ZlcmFnZUludmVydCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuc2Npc3NvclRlc3QgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnNjaXNzb3JYID0gMDtcclxuICAgICAgICB0aGlzLnNjaXNzb3JZID0gMDtcclxuICAgICAgICAvLyBBY3R1YWwgZGVmYXVsdHMgYXJlbid0IGtub3duIGhlcmUgc2luY2UgdGhleSBkZXBlbmQgdXBvbiBjb250ZXh0LiAtMSdzXHJcbiAgICAgICAgLy8gYXMgXCJkbyBub3QgY2hhbmdlXCIgdmFsdWVzLlxyXG4gICAgICAgIHRoaXMuc2Npc3NvcldpZHRoID0gLTE7XHJcbiAgICAgICAgdGhpcy5zY2lzc29ySGVpZ2h0ID0gLTE7XHJcbiAgICAgICAgdGhpcy5zdGVuY2lsVGVzdCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuc3RlbmNpbFJlZmVyZW5jZSA9IDA7XHJcbiAgICAgICAgdGhpcy5zdGVuY2lsTWFzayA9IDB4ZmY7XHJcbiAgICAgICAgdGhpcy5zdGVuY2lsV3JpdGVNYXNrID0gMHhmZjtcclxuICAgICAgICB0aGlzLnN0ZW5jaWxGcm9udEZ1bmMgPSA1MTkgLyogQUxXQVlTICovO1xyXG4gICAgICAgIHRoaXMuc3RlbmNpbEZyb250RmFpbE9wID0gNzY4MCAvKiBLRUVQICovO1xyXG4gICAgICAgIHRoaXMuc3RlbmNpbEZyb250RGVwdGhGYWlsT3AgPSA3NjgwIC8qIEtFRVAgKi87XHJcbiAgICAgICAgdGhpcy5zdGVuY2lsRnJvbnREZXB0aFBhc3NPcCA9IDc2ODAgLyogS0VFUCAqLztcclxuICAgICAgICB0aGlzLnN0ZW5jaWxCYWNrRnVuYyA9IDUxOSAvKiBBTFdBWVMgKi87XHJcbiAgICAgICAgdGhpcy5zdGVuY2lsQmFja0ZhaWxPcCA9IDc2ODAgLyogS0VFUCAqLztcclxuICAgICAgICB0aGlzLnN0ZW5jaWxCYWNrRGVwdGhGYWlsT3AgPSA3NjgwIC8qIEtFRVAgKi87XHJcbiAgICAgICAgdGhpcy5zdGVuY2lsQmFja0RlcHRoUGFzc09wID0gNzY4MCAvKiBLRUVQICovO1xyXG4gICAgICAgIHRoaXMudmlld3BvcnRYID0gMDtcclxuICAgICAgICB0aGlzLnZpZXdwb3J0WSA9IDA7XHJcbiAgICAgICAgLy8gQWN0dWFsIGRlZmF1bHRzIGFyZW4ndCBrbm93biBoZXJlIHNpbmNlIHRoZXkgZGVwZW5kIHVwb24gY29udGV4dC4gLTEnc1xyXG4gICAgICAgIC8vIGFzIFwiZG8gbm90IGNoYW5nZVwiIHZhbHVlcy5cclxuICAgICAgICB0aGlzLnZpZXdwb3J0V2lkdGggPSAtMTtcclxuICAgICAgICB0aGlzLnZpZXdwb3J0SGVpZ2h0ID0gLTE7XHJcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCAuLi5zdGF0ZSk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3N0YXRlLnRzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBhcmVGdXp6eUVxdWFsU2NhbGFyLCB7IERFRkFVTFRfVE9MRVJBTkNFIH0gZnJvbSAnLi4vdXRpbC9mdXp6eV9lcXVhbCc7XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IHZlY3RvciBhbmQgaW5pdGlhbGl6ZXMgaXQgd2l0aCBnaXZlbiBjb21wb25lbnRzLlxyXG4gKlxyXG4gKiBAcGFyYW0geCBYIGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yLlxyXG4gKiBAcGFyYW0geSBZIGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yLlxyXG4gKiBAcmV0dXJucyBUaGUgdmVjdG9yLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSh4LCB5KSB7XHJcbiAgICByZXR1cm4geyB4LCB5IH07XHJcbn1cclxuZXhwb3J0IGNvbnN0IFpFUk8gPSBjcmVhdGUoMCwgMCk7XHJcbmV4cG9ydCBjb25zdCBPUklHSU4gPSBaRVJPO1xyXG5leHBvcnQgY29uc3QgUE9TSVRJVkVfWCA9IGNyZWF0ZSgxLCAwKTtcclxuZXhwb3J0IGNvbnN0IE5FR0FUSVZFX1ggPSBjcmVhdGUoLTEsIDApO1xyXG5leHBvcnQgY29uc3QgUE9TSVRJVkVfWSA9IGNyZWF0ZSgwLCAxKTtcclxuZXhwb3J0IGNvbnN0IE5FR0FUSVZFX1kgPSBjcmVhdGUoMCwgLTEpO1xyXG4vKipcclxuICogQ29waWVzIGEgdmVjdG9yIHRvIGFub3RoZXIgb25lLlxyXG4gKlxyXG4gKiBAcGFyYW0gc3JjIFRoZSBzb3VyY2UgdmVjdG9yLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSB2ZWN0b3IgdGhlIHNvdXJjZSB2ZWN0b3Igd2lsbCBiZSBjb3BpZWQgdG8uXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvcHkoc3JjLCBkc3QgPSBjcmVhdGUoMCwgMCkpIHtcclxuICAgIGRzdC54ID0gc3JjLng7XHJcbiAgICBkc3QueSA9IHNyYy55O1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogQ2hlY2tzIGlmIHR3byB2ZWN0b3JzIGFyZSBzdHJpY3RseSBlcXVhbCBjb21wb25lbnQtd2lzZS5cclxuICpcclxuICogQHBhcmFtIHYxIFRoZSBmaXJzdCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSB2MiBUaGUgc2Vjb25kIHZlY3Rvci5cclxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYXJlRXF1YWwodjEsIHYyKSB7XHJcbiAgICByZXR1cm4gdjEueCA9PT0gdjIueCAmJiB2MS55ID09PSB2Mi55O1xyXG59XHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgdHdvIHZlY3RvcnMgYXJlIGNvbGxpbmVhci5cclxuICpcclxuICogQHBhcmFtIHYxIFRoZSBmaXJzdCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSB2MiBUaGUgc2Vjb25kIHZlY3Rvci5cclxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB2ZWN0b3JzIGFyZSBjb2xsaW5lYXIgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGFyZUNvbGxpbmVhcih2MSwgdjIpIHtcclxuICAgIHJldHVybiB2MS54IC8gdjIueCA9PT0gdjEueSAvIHYyLnk7XHJcbn1cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBjb3JyZXNwb25kaW5nIGNvbXBvbmVudHMgb2YgdHdvIHZlY3RvcnMgYXJlIGFsbCB3aXRoaW4gZ2l2ZW5cclxuICogdG9sZXJhbmNlIGZyb20gZWFjaCBvdGhlci5cclxuICpcclxuICogQHBhcmFtIHYxIFRoZSBmaXJzdCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSB2MiBUaGUgc2Vjb25kIHZlY3Rvci5cclxuICogQHBhcmFtIHRvbGVyYW5jZSBUaGUgdG9sZXJhbmNlLlxyXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZlY3RvcnMgYXJlIFwiZnV6enlcIiBlcXVhbCBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYXJlRnV6enlFcXVhbCh2MSwgdjIsIHRvbGVyYW5jZSA9IERFRkFVTFRfVE9MRVJBTkNFKSB7XHJcbiAgICByZXR1cm4gKGFyZUZ1enp5RXF1YWxTY2FsYXIodjEueCwgdjIueCwgdG9sZXJhbmNlKSAmJlxyXG4gICAgICAgIGFyZUZ1enp5RXF1YWxTY2FsYXIodjEueSwgdjIueSwgdG9sZXJhbmNlKSk7XHJcbn1cclxuLyoqXHJcbiAqIEFkZHMgdHdvIHZlY3RvciBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW50byBhIHRoaXJkIG9uZSwgaS5lLiBgZHN0ID0gYSArIGJgLlxyXG4gKlxyXG4gKiBAcGFyYW0gYSBUaGUgZmlyc3QgdmVjdG9yLlxyXG4gKiBAcGFyYW0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cclxuICogQHBhcmFtIGRzdCBUaGUgdmVjdG9yIHRoZSByZXN1bHQgd2lsbCBiZSBzdG9yZWQgdG8uXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGFkZChhLCBiLCBkc3QgPSBjcmVhdGUoMCwgMCkpIHtcclxuICAgIGRzdC54ID0gYS54ICsgYi54O1xyXG4gICAgZHN0LnkgPSBhLnkgKyBiLnk7XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbi8qKlxyXG4gKiBTdWJ0cmFjdHMgYSB2ZWN0b3IgZnJvbSBhbm90aGVyIG9uZSBhbmQgc3RvcmVzIHRoZSByZXN1bHQgdG8gYSB0aGlyZCBvbmUsIGkuZS5cclxuICogYGRzdCA9IGEgLSBiYC5cclxuICpcclxuICogQHBhcmFtIGEgVGhlIG1pbnVlbmQgdmVjdG9yLlxyXG4gKiBAcGFyYW0gYiBUaGUgc3VidHJhaGVuZCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBkc3QgVGhlIHZlY3RvciB0aGUgcmVzdWx0IHdpbGwgYmUgc3RvcmVkIHRvLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzdWIoYSwgYiwgZHN0ID0gY3JlYXRlKDAsIDApKSB7XHJcbiAgICBkc3QueCA9IGEueCAtIGIueDtcclxuICAgIGRzdC55ID0gYS55IC0gYi55O1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogTXVsdGlwbGllcyB0d28gdmVjdG9ycyBjb21wb25lbnQtd2lzZSBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW50byBhIHRoaXJkIG9uZS5cclxuICpcclxuICogQHBhcmFtIGEgVGhlIGZpcnN0IHZlY3Rvci5cclxuICogQHBhcmFtIGIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBkc3QgVGhlIHZlY3RvciB0aGUgcmVzdWx0IHdpbGwgYmUgc3RvcmVkIHRvLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBtdWx2KGEsIGIsIGRzdCA9IGNyZWF0ZSgwLCAwKSkge1xyXG4gICAgZHN0LnggPSBhLnggKiBiLng7XHJcbiAgICBkc3QueSA9IGEueSAqIGIueTtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIE11bHRpcGxpZXMgYSB2ZWN0b3IgYnkgYSBzY2FsYXIgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGludG8gYSB0aGlyZCB2ZWN0b3IuXHJcbiAqXHJcbiAqIEBwYXJhbSBhIFRoZSB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBuIFRoZSBzY2FsYXIuXHJcbiAqIEBwYXJhbSBkc3QgVGhlIHZlY3RvciB0aGUgcmVzdWx0IHdpbGwgYmUgc3RvcmVkIHRvLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBtdWxuKGEsIG4sIGRzdCA9IGNyZWF0ZSgwLCAwKSkge1xyXG4gICAgZHN0LnggPSBhLnggKiBuO1xyXG4gICAgZHN0LnkgPSBhLnkgKiBuO1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogRGl2aWRlcyBhIHZlY3RvciBieSBhbm90aGVyIG9uZSBjb21wb25lbnQgd2lzZSBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW50byBhXHJcbiAqIHRoaXJkIG9uZS5cclxuICpcclxuICogQHBhcmFtIGEgVGhlIGRpdmlkZW5kIHZlY3Rvci5cclxuICogQHBhcmFtIGIgVGhlIGRpdmlzb3IgdmVjdG9yLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSB2ZWN0b3IgdGhlIHJlc3VsdCB3aWxsIGJlIHN0b3JlZCB0by5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZGl2dihhLCBiLCBkc3QgPSBjcmVhdGUoMCwgMCkpIHtcclxuICAgIGRzdC54ID0gYS54IC8gYi54O1xyXG4gICAgZHN0LnkgPSBhLnkgLyBiLnk7XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbi8qKlxyXG4gKiBEaXZpZGVzIGEgdmVjdG9yIGJ5IGEgc2NhbGFyIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbnRvIGEgdGhpcmQgdmVjdG9yLlxyXG4gKlxyXG4gKiBAcGFyYW0gYSBUaGUgZGl2aWRlbmQgdmVjdG9yLlxyXG4gKiBAcGFyYW0gbiBUaGUgc2NhbGFyLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSB2ZWN0b3IgdGhlIHJlc3VsdCB3aWxsIGJlIHN0b3JlZCB0by5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZGl2bihhLCBuLCBkc3QgPSBjcmVhdGUoMCwgMCkpIHtcclxuICAgIGRzdC54ID0gYS54IC8gbjtcclxuICAgIGRzdC55ID0gYS55IC8gbjtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIHJlbWluZGVyIGFmdGVyIGRpdmlzaW9uIG9mIGEncyBjb21wb25lbnRzIGJ5IG4gYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGludG8gYSB0aGlyZCB2ZWN0b3IuXHJcbiAqXHJcbiAqIEBwYXJhbSBhIFRoZSBkaXZpZGVuZCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBuIFRoZSBzY2FsYXIuXHJcbiAqIEBwYXJhbSBkc3QgVGhlIHZlY3RvciB0aGUgcmVzdWx0IHdpbGwgYmUgc3RvcmVkIHRvLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBtb2QoYSwgbiwgZHN0ID0gY3JlYXRlKDAsIDApKSB7XHJcbiAgICBkc3QueCA9IGEueCAlIG47XHJcbiAgICBkc3QueSA9IGEueSAlIG47XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbi8qKlxyXG4gKiBMaW5lYXJseSBpbnRlcnBvbGF0ZXMgYmV0d2VlbiB0d28gdmVjdG9ycywgaS5lLiBjb21wdXRlc1xyXG4gKiBgKDEgLSBmYWN0b3IpICogYSArIGZhY3RvciAqIGJgLCBhbmQgd3JpdGVzIHRoZSByZXN1bHQgaW50byBhIHRoaXJkIHZlY3Rvci5cclxuICpcclxuICogQHBhcmFtIGEgVGhlIGZpcnN0IHZlY3Rvci5cclxuICogQHBhcmFtIGIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBmYWN0b3IgVGhlIGludGVycG9sYXRpb24gZmFjdG9yLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSB2ZWN0b3IgdGhlIHJlc3VsdCB3aWxsIGJlIHdyaXR0ZW4gdG8uXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG1peChhLCBiLCBmYWN0b3IsIGRzdCA9IGNyZWF0ZSgwLCAwKSkge1xyXG4gICAgZHN0LnggPSAoMSAtIGZhY3RvcikgKiBhLnggKyBmYWN0b3IgKiBiLng7XHJcbiAgICBkc3QueSA9ICgxIC0gZmFjdG9yKSAqIGEueSArIGZhY3RvciAqIGIueTtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIFJvdGF0ZXMgYSB2ZWN0b3IgYnkgYSBnaXZlbiBhbmdsZSBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW50byBhIHNlY29uZCB2ZWN0b3IuXHJcbiAqIFBvc2l0aXZlIGRpcmVjdGlvbiBpcyBmcm9tICtYIHRvICtZLlxyXG4gKlxyXG4gKiBAcGFyYW0gdiBUaGUgdmVjdG9yIHRvIHJvdGF0ZS5cclxuICogQHBhcmFtIGFuZ2xlIFRoZSBhbmdsZSBvZiByb3RhdGlvbi5cclxuICogQHBhcmFtIGRzdCBUaGUgdmVjdG9yIHRoZSByZXN1bHQgd2lsbCBiZSBzdG9yZWQgdG8uXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZSh2LCBhbmdsZSwgZHN0ID0gY3JlYXRlKDAsIDApKSB7XHJcbiAgICBjb25zdCB4ID0gdi54O1xyXG4gICAgY29uc3QgeSA9IHYueTtcclxuICAgIGNvbnN0IGFuZ2xlQ29zID0gTWF0aC5jb3MoYW5nbGUpO1xyXG4gICAgY29uc3QgYW5nbGVTaW4gPSBNYXRoLnNpbihhbmdsZSk7XHJcbiAgICBkc3QueCA9IGFuZ2xlQ29zICogeCAtIGFuZ2xlU2luICogeTtcclxuICAgIGRzdC55ID0gYW5nbGVTaW4gKiB4ICsgYW5nbGVDb3MgKiB5O1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogUm90YXRlcyBhIHZlY3RvciBieSA0NSBkZWdyZWVzIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbnRvIGEgc2Vjb25kIHZlY3Rvci5cclxuICogQW5hbG9nb3VzIHRvIGByb3RhdGUodiwgTWF0aC5QSSAvIDQsIGRzdClgLCBidXQgZmFzdGVyLlxyXG4gKlxyXG4gKiBAcGFyYW0gdiBUaGUgdmVjdG9yIHRvIHJvdGF0ZS5cclxuICogQHBhcmFtIGRzdCBUaGUgdmVjdG9yIHRoZSByZXN1bHQgd2lsbCBiZSBzdG9yZWQgdG8uXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZTQ1KHYsIGRzdCA9IGNyZWF0ZSgwLCAwKSkge1xyXG4gICAgY29uc3QgeSA9IHYueTtcclxuICAgIGNvbnN0IHMgPSBNYXRoLlNRUlQxXzI7XHJcbiAgICBkc3QueSA9IHMgKiB2LnggKyBzICogdi55O1xyXG4gICAgZHN0LnggPSBzICogdi54IC0gcyAqIHk7XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbi8qKlxyXG4gKiBSb3RhdGVzIGEgdmVjdG9yIGJ5IDkwIGRlZ3JlZXMgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGludG8gYSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBBbmFsb2dvdXMgdG8gYHJvdGF0ZSh2LCBNYXRoLlBJIC8gMiwgZHN0KWAsIGJ1dCBmYXN0ZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB2IFRoZSB2ZWN0b3IgdG8gcm90YXRlLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSB2ZWN0b3IgdGhlIHJlc3VsdCB3aWxsIGJlIHN0b3JlZCB0by5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlOTAodiwgZHN0ID0gY3JlYXRlKDAsIDApKSB7XHJcbiAgICBjb25zdCB5ID0gdi55O1xyXG4gICAgZHN0LnkgPSB2Lng7XHJcbiAgICBkc3QueCA9IC15O1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogUm90YXRlcyBhIHZlY3RvciBieSAtOTAgZGVncmVlcyBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW50byBhIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEFuYWxvZ291cyB0byBgcm90YXRlKHYsIC1NYXRoLlBJIC8gMiwgZHN0KWAsIGJ1dCBmYXN0ZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB2IFRoZSB2ZWN0b3IgdG8gcm90YXRlLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSB2ZWN0b3IgdGhlIHJlc3VsdCB3aWxsIGJlIHN0b3JlZCB0by5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlTmVnOTAodiwgZHN0ID0gY3JlYXRlKDAsIDApKSB7XHJcbiAgICBjb25zdCB5ID0gdi55O1xyXG4gICAgZHN0LnkgPSAtdi54O1xyXG4gICAgZHN0LnggPSB5O1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogSW52ZXJ0cyBzaWducyBvZiBjb21wb25lbnRzIG9mIGEgdmVjdG9yIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbnRvIGEgc2Vjb25kXHJcbiAqIHZlY3Rvci4gQW5hbG9nb3VzIHRvIGByb3RhdGUodiwgTWF0aC5QSSwgZHN0KWAgKG9yIGByb3RhdGUodiwgLU1hdGguUEksIGRzdClgLFxyXG4gKiB3aGljaCBpcyB0aGUgc2FtZSksIGJ1dCBmYXN0ZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB2IFRoZSB2ZWN0b3IgdG8gaW52ZXJ0LlxyXG4gKiBAcGFyYW0gZHN0IFRoZSB2ZWN0b3IgdGhlIHJlc3VsdCB3aWxsIGJlIHN0b3JlZCB0by5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJ0KHYsIGRzdCA9IGNyZWF0ZSgwLCAwKSkge1xyXG4gICAgZHN0LnggPSAtdi54O1xyXG4gICAgZHN0LnkgPSAtdi55O1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogQ29tcHV0ZXMgbGVuZ3RoIG9mIGEgdmVjdG9yLlxyXG4gKlxyXG4gKiBAcGFyYW0gdiBUaGUgdmVjdG9yLlxyXG4gKiBAcmV0dXJucyBUaGUgbGVuZ3RoLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGxlbmd0aCh2KSB7XHJcbiAgICByZXR1cm4gTWF0aC5oeXBvdCh2LngsIHYueSk7XHJcbn1cclxuLyoqXHJcbiAqIENvbXB1dGVzIGRpc3RhbmNlIGJldHdlZW4gZW5kcyBvZiB0d28gdmVjdG9ycy5cclxuICpcclxuICogQHBhcmFtIGEgVGhlIGZpcnN0IHZlY3Rvci5cclxuICogQHBhcmFtIGIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEByZXR1cm5zIFRoZSBkaXN0YW5jZSwgaS5lLiBgbGVuZ3RoKHN1YihhLCBiKSlgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRpc3RhbmNlKGEsIGIpIHtcclxuICAgIHJldHVybiBNYXRoLmh5cG90KGEueCAtIGIueCwgYS55IC0gYi55KTtcclxufVxyXG4vKipcclxuICogRGl2aWRlcyBhIHZlY3RvciBieSBpdHMgbGVuZ3RoICh0aHVzIG1ha2luZyBpdCBhIHVuaXQgdmVjdG9yKSBhbmQgc3RvcmVzIHRoZVxyXG4gKiByZXN1bHQgdG8gYW5vdGhlciBvbmUuXHJcbiAqXHJcbiAqIEBwYXJhbSB2IFRoZSB2ZWN0b3IgdG8gYmUgbm9ybWFsaXplZC5cclxuICogQHBhcmFtIGRzdCBUaGUgdmVjdG9yIHRoZSByZXN1bHQgd2lsbCBiZSBzdG9yZWQgdG8uXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZSh2LCBkc3QgPSBjcmVhdGUoMCwgMCkpIHtcclxuICAgIHJldHVybiBkaXZuKHYsIGxlbmd0aCh2KSwgZHN0KTtcclxufVxyXG4vKipcclxuICogQ29udmVydHMgZWFjaCBjb21wb25lbnQgb2YgdmVjdG9yLlxyXG4gKlxyXG4gKiBAcGFyYW0gdiBUaGUgdmVjdG9yIHRvIGJlIGNvbnZlcnRlZC5cclxuICogQHBhcmFtIGNvbnZlcnRlciBUaGUgY29tcG9uZW50IGNvbnZlcnRlci5cclxuICogQHBhcmFtIGRzdCBUaGUgdmVjdG9yIHRoZSByZXN1bHQgd2lsbCBiZSBzdG9yZWQgdG8uXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnQodiwgY29udmVydGVyLCBkc3QgPSBjcmVhdGUoMCwgMCkpIHtcclxuICAgIGRzdC54ID0gY29udmVydGVyKHYueCk7XHJcbiAgICBkc3QueSA9IGNvbnZlcnRlcih2LnkpO1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogQ29tcHV0ZXMgZG90IHByb2R1Y3Qgb2YgdHdvIHZlY3RvcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSBhIFRoZSBmaXJzdCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBAcmV0dXJucyBUaGUgZG90IHByb2R1Y3QuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZG90KGEsIGIpIHtcclxuICAgIHJldHVybiBhLnggKiBiLnggKyBhLnkgKiBiLnk7XHJcbn1cclxuLyoqXHJcbiAqIENvbXB1dGVzIFotY29tcG9uZW50IG9mIGEgY3Jvc3MgcHJvZHVjdCBvZiB0d28gdmVjdG9ycy5cclxuICpcclxuICogQHBhcmFtIGEgVGhlIGZpcnN0IHZlY3Rvci5cclxuICogQHBhcmFtIGIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEByZXR1cm5zIFotY29tcG9uZW50IG9mIHRoZSBjcm9zcyBwcm9kdWN0LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNyb3NzWihhLCBiKSB7XHJcbiAgICByZXR1cm4gYS54ICogYi55IC0gYS55ICogYi54O1xyXG59XHJcbmV4cG9ydCBjb25zdCBFTVBUWSA9IHtcclxuICAgIG1pblg6IDAsXHJcbiAgICBtYXhYOiAwLFxyXG4gICAgbWluWTogMCxcclxuICAgIG1heFk6IDBcclxufTtcclxuZXhwb3J0IGNvbnN0IFVOSVRfQkJPWCA9IHtcclxuICAgIG1pblg6IC0xLFxyXG4gICAgbWF4WDogMSxcclxuICAgIG1pblk6IC0xLFxyXG4gICAgbWF4WTogMVxyXG59O1xyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBiYm94IGFuZCBpbml0aWFsaXplcyBpdCB3aXRoIGdpdmVuIGNvbXBvbmVudHMuXHJcbiAqXHJcbiAqIEBwYXJhbSBtaW5YIExlZnQgYm9yZGVyIG9mIHRoZSBiYm94LlxyXG4gKiBAcGFyYW0gbWF4WCBSaWdodCBib3JkZXIgb2YgdGhlIGJib3guXHJcbiAqIEBwYXJhbSBtaW5ZIExvd2VyIGJvcmRlciBvZiB0aGUgYmJveC5cclxuICogQHBhcmFtIG1heFkgVXBwZXIgYm9yZGVyIG9mIHRoZSBiYm94LlxyXG4gKiBAcmV0dXJucyBUaGUgYmJveC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVCQm94MihtaW5YLCBtYXhYLCBtaW5ZLCBtYXhZKSB7XHJcbiAgICByZXR1cm4geyBtaW5YLCBtYXhYLCBtaW5ZLCBtYXhZIH07XHJcbn1cclxuLyoqXHJcbiAqIENvcGllcyBhIGJib3ggdG8gYW5vdGhlciBvbmUuXHJcbiAqXHJcbiAqIEBwYXJhbSBzcmMgVGhlIHNvdXJjZSBiYm94LlxyXG4gKiBAcGFyYW0gZHN0IFRoZSBiYm94IHRoZSBzb3VyY2UgYmJveCB3aWxsIGJlIGNvcGllZCB0by5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29weUJCb3gyKHNyYywgZHN0ID0gY3JlYXRlQkJveDIoMCwgMCwgMCwgMCkpIHtcclxuICAgIGRzdC5taW5YID0gc3JjLm1pblg7XHJcbiAgICBkc3QubWF4WCA9IHNyYy5tYXhYO1xyXG4gICAgZHN0Lm1pblkgPSBzcmMubWluWTtcclxuICAgIGRzdC5tYXhZID0gc3JjLm1heFk7XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgdHdvIGJvdW5kaW5nIGJveGVzIG92ZXJsYXAuXHJcbiAqXHJcbiAqIEBwYXJhbSBiYm94MSBBIGJvdW5kaW5nIGJveC5cclxuICogQHBhcmFtIGJib3gyIEFub3RoZXIgYm91bmRpbmcgYm94LlxyXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgZ2l2ZW4gYm91bmRpbmcgYm94ZXMgZG8gb3ZlcmxhcCBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYmJveGVzT3ZlcmxhcChiYm94MSwgYmJveDIpIHtcclxuICAgIGxldCBsZWZ0QkJveDtcclxuICAgIGxldCByaWdodEJCb3g7XHJcbiAgICBpZiAoYmJveDEubWluWCA8IGJib3gyLm1pblgpIHtcclxuICAgICAgICBsZWZ0QkJveCA9IGJib3gxO1xyXG4gICAgICAgIHJpZ2h0QkJveCA9IGJib3gyO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbGVmdEJCb3ggPSBiYm94MjtcclxuICAgICAgICByaWdodEJCb3ggPSBiYm94MTtcclxuICAgIH1cclxuICAgIGxldCB0b3BCQm94O1xyXG4gICAgbGV0IGJvdHRvbUJCb3g7XHJcbiAgICBpZiAoYmJveDEubWF4WSA+IGJib3gyLm1heFkpIHtcclxuICAgICAgICB0b3BCQm94ID0gYmJveDE7XHJcbiAgICAgICAgYm90dG9tQkJveCA9IGJib3gyO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdG9wQkJveCA9IGJib3gyO1xyXG4gICAgICAgIGJvdHRvbUJCb3ggPSBiYm94MTtcclxuICAgIH1cclxuICAgIHJldHVybiByaWdodEJCb3gubWluWCA8IGxlZnRCQm94Lm1heFggJiYgYm90dG9tQkJveC5tYXhZID4gdG9wQkJveC5taW5ZO1xyXG59XHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYSAyRCBwb2ludCBsaWVzIGluc2lkZSBhIGJvdW5kaW5nIGJveCBvciBvbiBpdHMgYm9yZGVyLlxyXG4gKlxyXG4gKiBAcGFyYW0gcG9pbnQgVGhlIHBvaW50LlxyXG4gKiBAcGFyYW0gYmJveCBUaGUgYm91bmRpbmcgYm94LlxyXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHBvaW50IGlzIGluc2lkZSBvZiB0aGUgYm94IGFuZCBgZmFsc2VgIG90aGVyd2lzZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBwb2ludElzSW5CQm94KHBvaW50LCBiYm94KSB7XHJcbiAgICByZXR1cm4gYmJveC5taW5YIDw9IHBvaW50LnggJiYgcG9pbnQueCA8PSBiYm94Lm1heFggJiZcclxuICAgICAgICBiYm94Lm1pblkgPD0gcG9pbnQueSAmJiBwb2ludC55IDw9IGJib3gubWF4WTtcclxufVxyXG4vKipcclxuICogQ29tcHV0ZXMgYm91bmRpbmcgYm94IG9mIGFuIGFycmF5IG9mIHBvaW50cyBhbmQgc3RvcmVzIGl0IHRvIGEgZ2l2ZW4gb2JqZWN0LlxyXG4gKlxyXG4gKiBAcGFyYW0gcG9pbnRzIFRoZSBhcnJheSBvZiBwb2ludHMuXHJcbiAqIEBwYXJhbSBkc3QgVGhlIGJib3ggdGhlIHJlc3VsdCB3aWxsIGJlIHdyaXR0ZW4gdG8uIExlZnQgdW5tb2RpZmllZCBpZiB0aGUgYXJyYXlcclxuICogICAgICBvZiBwb2ludHMgaXMgZW1wdHkuXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVCQm94Rm9yUG9pbnRzKHBvaW50cywgZHN0ID0geyBtaW5YOiAwLCBtYXhYOiAwLCBtaW5ZOiAwLCBtYXhZOiAwIH0pIHtcclxuICAgIGlmIChwb2ludHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGRzdDtcclxuICAgIH1cclxuICAgIGRzdC5taW5YID0gZHN0Lm1heFggPSBwb2ludHNbMF0ueDtcclxuICAgIGRzdC5taW5ZID0gZHN0Lm1heFkgPSBwb2ludHNbMF0ueTtcclxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcG9pbnRzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBwb2ludHNbaV07XHJcbiAgICAgICAgaWYgKHggPCBkc3QubWluWCkge1xyXG4gICAgICAgICAgICBkc3QubWluWCA9IHg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh4ID4gZHN0Lm1heFgpIHtcclxuICAgICAgICAgICAgZHN0Lm1heFggPSB4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoeSA8IGRzdC5taW5ZKSB7XHJcbiAgICAgICAgICAgIGRzdC5taW5ZID0geTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHkgPiBkc3QubWF4WSkge1xyXG4gICAgICAgICAgICBkc3QubWF4WSA9IHk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG5leHBvcnQgY29uc3QgWF9BWElTID0ge1xyXG4gICAgb3JpZ2luOiBPUklHSU4sXHJcbiAgICB0YW5nZW50OiBQT1NJVElWRV9YXHJcbn07XHJcbmV4cG9ydCBjb25zdCBZX0FYSVMgPSB7XHJcbiAgICBvcmlnaW46IE9SSUdJTixcclxuICAgIHRhbmdlbnQ6IFBPU0lUSVZFX1lcclxufTtcclxuZXhwb3J0IGZ1bmN0aW9uIGdldExpbmVGcm9tUG9pbnRzKHAxLCBwMiwgZHN0ID0ge1xyXG4gICAgb3JpZ2luOiBjcmVhdGUoMCwgMCksXHJcbiAgICB0YW5nZW50OiBjcmVhdGUoMCwgMClcclxufSkge1xyXG4gICAgY29weShwMSwgZHN0Lm9yaWdpbik7XHJcbiAgICBzdWIocDIsIHAxLCBkc3QudGFuZ2VudCk7XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbi8qKlxyXG4gKiBDb21wdXRlcyBzaWduZWQgZGlzdGFuY2UgZnJvbSBhIHBvaW50IHRvIGEgbGluZS5cclxuICpcclxuICogQHBhcmFtIHAgVGhlIHBvaW50LlxyXG4gKiBAcGFyYW0gbDEgU3RhcnQgcG9pbnQgb2YgdGhlIGxpbmUuXHJcbiAqIEBwYXJhbSBsMiBFbmQgcG9pbnQgb2YgdGhlIGxpbmUuXHJcbiAqIEByZXR1cm5zIERpc3RhbmNlIGZyb20gdGhlIHBvaW50IHRvIHRoZSBsaW5lLiBJdCdsbCBiZSBncmVhdGVyIHRoYW4gMCBpZiB0aGVcclxuICogICAgICBwb2ludCBsaWVzIHRvIHRoZSBsZWZ0IG9mIHRoZSBsaW5lIGFuZCBsZXNzIHRoYW4gMCBvdGhlcndpc2UuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2lnbmVkRGlzdGFuY2VUb0xpbmUocCwgbCkge1xyXG4gICAgY29uc3QgdGFuZ2VudCA9IGwudGFuZ2VudDtcclxuICAgIHJldHVybiBkb3Qoc3ViKHAsIGwub3JpZ2luKSwgY3JlYXRlKC10YW5nZW50LnksIHRhbmdlbnQueCkpIC8gbGVuZ3RoKHRhbmdlbnQpO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IGV4dGVudCBhbmQgaW5pdGlhbGl6ZXMgaXQgd2l0aCBnaXZlbiBjb21wb25lbnRzLlxyXG4gKlxyXG4gKiBAcGFyYW0gd2lkdGggV2lkdGggb2YgdGhlIGV4dGVudC5cclxuICogQHBhcmFtIEhlaWdodCBIZWlnaHQgb2YgdGhlIGV4dGVudC5cclxuICogQHJldHVybnMgVGhlIGV4dGVudC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFeHRlbnQyKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgIHJldHVybiB7IHdpZHRoLCBoZWlnaHQgfTtcclxufVxyXG4vKipcclxuICogQ29waWVzIGFuIGV4dGVudCB0byBhbm90aGVyIG9uZS5cclxuICpcclxuICogQHBhcmFtIHNyYyBUaGUgc291cmNlIGJib3guXHJcbiAqIEBwYXJhbSBkc3QgVGhlIGV4dGVudCB0aGUgc291cmNlIGV4dGVudCB3aWxsIGJlIGNvcGllZCB0by5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29weUV4dGVudDIoc3JjLCBkc3QgPSBjcmVhdGVFeHRlbnQyKDAsIDApKSB7XHJcbiAgICBkc3Qud2lkdGggPSBzcmMud2lkdGg7XHJcbiAgICBkc3QuaGVpZ2h0ID0gc3JjLmhlaWdodDtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvbWF0aC92ZWN0b3IyLnRzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiBTaW1wbGUgcHViL3N1YiBpbXBsZW1lbnRhdGlvbi4gVGhlIGVtaXR0ZXIgaXMgc3VwcG9zZWQgdG8gZW1pdCBvbmx5IG9uZSB0eXBlIG9mIGV2ZW50LFxyXG4gKiBpZiBzb21lb25lIGhhcyB0byBlbWl0IGV2ZW50cyBvZiBkaWZmZXJlbnQgdHlwZXMsIG11bHRpcGxlIGVtaXR0ZXJzIHNob3VsZCBiZSBjcmVhdGVkLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEV2ZW50RW1pdHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSBuZXcgU2V0KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgbGlzdGVuZXIuXHJcbiAgICAgKi9cclxuICAgIGFkZExpc3RlbmVyKGxpc3RlbmVyKSB7XHJcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzLmFkZChsaXN0ZW5lcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgbGlzdGVuZXIuXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZUxpc3RlbmVyKGxpc3RlbmVyKSB7XHJcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbGxzIGFsbCB0aGUgYWRkZWQgbGlzdGVuZXJzLCB0aGUgb3JkZXIgKGUuZy4gb2YgYWRkaW5nKSBpcyBub3QgZ3VhcmFudGVlZC5cclxuICAgICAqL1xyXG4gICAgZmlyZShkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKSA9PiB7XHJcbiAgICAgICAgICAgIGxpc3RlbmVyKGRhdGEpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBFdmVudCBlbWl0dGVyIHdpdGggbm8gcGF5bG9hZCBlbWl0dGVkLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFZvaWRFdmVudEVtaXR0ZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xyXG4gICAgZmlyZSgpIHtcclxuICAgICAgICBzdXBlci5maXJlKHVuZGVmaW5lZCk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9ldmVudF9lbWl0dGVyLnRzXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IG1hcEl0ZXJhYmxlIH0gZnJvbSAnLi4vdXRpbC9pdGVyYWJsZSc7XHJcbmltcG9ydCB7IGFsaWduIH0gZnJvbSAnLi4vdXRpbC9wb3dfb2ZfMic7XHJcbi8qKlxyXG4gKiBHaXZlcyBzaXplIG9mIGEgR0wgdHlwZS5cclxuICpcclxuICogQHBhcmFtIHR5cGUgVGhlIHR5cGUuXHJcbiAqIEByZXR1cm5zIFNpemUgb2YgdGhlIHR5cGUgaW4gYnl0ZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRUeXBlU2l6ZSh0eXBlKSB7XHJcbiAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICBjYXNlIDUxMjAgLyogQllURSAqLzpcclxuICAgICAgICBjYXNlIDUxMjEgLyogVU5TSUdORURfQllURSAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgY2FzZSA1MTIyIC8qIFNIT1JUICovOlxyXG4gICAgICAgIGNhc2UgNTEyMyAvKiBVTlNJR05FRF9TSE9SVCAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIDI7XHJcbiAgICAgICAgY2FzZSA1MTI0IC8qIElOVCAqLzpcclxuICAgICAgICBjYXNlIDUxMjUgLyogVU5TSUdORURfSU5UICovOlxyXG4gICAgICAgIGNhc2UgNTEyNiAvKiBGTE9BVCAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIDQ7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIERlc2NyaXB0aW9uIG9mIGhvdyBwYXJ0aWN1bGFyIGF0dHJpYnV0ZXMgb2YgYSB2ZXJ0ZXggYXJlIHBhY2tlZCBpbnRvIGEgdmVydGV4XHJcbiAqIGJ1ZmZlci5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBBdHRyaWJ1dGVNYXBwaW5nIGV4dGVuZHMgTWFwIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBhdHRyaWJ1dGUgbWFwcGluZyB3aXRoIGEgc2V0IG9mIGF0dHJpYnV0ZXMgb2YgZ2l2ZW4gdHlwZXMgYW5kXHJcbiAgICAgKiBzaXplcy4gQXV0b21hdGljYWxseSBjb21wdXRlcyBvZmZzZXRzIG9mIHRoZSBhdHRyaWJ1dGVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtYXBwaW5nIFRoZSBtYXBwaW5nIGZyb20gYXR0cmlidXRlIElEcyB0byB0eXBlcyBhbmQgc2l6ZXMuXHJcbiAgICAgKiBAcGFyYW0gYWxpZ25tZW50IERlc2lyZWQgYWxpZ25tZW50IG9mIGF0dHJpYnV0ZXMgaW4gdGhlIHZlcnRleCBkYXRhXHJcbiAgICAgKiAgICAgIHN0cnVjdHVyZS4gTXVzdCBiZSBhIHBvd2VyIG9mIDIuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG1hcHBpbmcsIGFsaWdubWVudCA9IDQgLyogQUxJR05fNF9CWVRFUyAqLykge1xyXG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xyXG4gICAgICAgIHN1cGVyKG1hcEl0ZXJhYmxlKG1hcHBpbmcsIChbaWR4LCB7IHR5cGUsIHNpemUsIG5vcm1hbGl6ZWQgfV0pID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcG9pbnRlciA9IFtcclxuICAgICAgICAgICAgICAgIGlkeCxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlLFxyXG4gICAgICAgICAgICAgICAgICAgIHNpemUsXHJcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZCxcclxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgY29uc3QgYXR0cmlidXRlU2l6ZSA9IHNpemUgKiBnZXRUeXBlU2l6ZSh0eXBlKTtcclxuICAgICAgICAgICAgY29uc3QgbmV3T2Zmc2V0ID0gYWxpZ24ob2Zmc2V0ICsgYXR0cmlidXRlU2l6ZSwgLWFsaWdubWVudCk7XHJcbiAgICAgICAgICAgIC8vIFRPRE8oZG1pa2lzKSBDaGVjayB0aGlzIGluIGRlYnVnIG1vZGUuXHJcbiAgICAgICAgICAgIC8vIGlmIChuZXdPZmZzZXQgLSBvZmZzZXQgPiBhdHRyaWJ1dGVTaXplKSB7XHJcbiAgICAgICAgICAgIC8vICAgIGNvbnNvbGUud2FybihgJHtuZXdPZmZzZXQgLSBvZmZzZXR9IGJ5dGUgcGFkZGluZydzIGluc2VydGVkYCk7XHJcbiAgICAgICAgICAgIC8vIH1cclxuICAgICAgICAgICAgb2Zmc2V0ID0gbmV3T2Zmc2V0O1xyXG4gICAgICAgICAgICByZXR1cm4gcG9pbnRlcjtcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhCeXRlU2l6ZSA9IG9mZnNldDtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvYXR0cmliX21hcHBpbmcudHNcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIEJhc2UgY2xhc3MgZm9yIGFueSBXZWJHTCByZW5kZXJlciwgaXQganVzdCBkZWZpbmVzIGJhc2ljIHN0cnVjdHVyZSBvZiBHTC1jYWxscyBhbGxvd2luZyB0byBvdmVycmlkZSBhbnkgcGFydC5cclxuICogQSBzcGVjaWZpYyByZW5kZXJlciBtYXkgbmVlZCBhbnkgbnVtYmVyIG9mIGFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIHBlcmZvcm0gcmVuZGVyaW5nLCB0aGV5IGFyZSBwcm92aWRlZCBpblxyXG4gKiBhZGRpdGlvbmFsUGFyYW1zIGluIHRoZSByZW5kZXIoKSBtZXRob2QuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgR2xSZW5kZXJlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCByZW5kZXJTdGF0ZSwgcHJvZ3JhbSkge1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgICAgIHRoaXMuX3JlbmRlclN0YXRlID0gcmVuZGVyU3RhdGU7XHJcbiAgICAgICAgdGhpcy5fcHJvZ3JhbSA9IHByb2dyYW07XHJcbiAgICB9XHJcbiAgICByZW5kZXIodGFyZ2V0LCAuLi5hcmdzKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3Byb2dyYW0pIHtcclxuICAgICAgICAgICAgdGhpcy5fcHJlcGFyZVByb2dyYW0odGhpcy5fcHJvZ3JhbSwgLi4uYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3ByZXBhcmVSZW5kZXJUYXJnZXQodGFyZ2V0LCAuLi5hcmdzKTtcclxuICAgICAgICB0aGlzLl9yZW5kZXIoLi4uYXJncyk7XHJcbiAgICB9XHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9wcm9ncmFtKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Byb2dyYW0uZGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQmluZHMgcHJvZ3JhbSBhbmQgc2V0cyByZXF1aXJlZCB1bmlmb3Jtcy4gU3ViY2xhc3NlcyBhcmUgc3VwcG9zZWQgdG8gb3ZlcnJpZGVcclxuICAgICAqIHRoaXMgbWV0aG9kIHRvIGFkZCB0aGVpciBvd24gdW5pZm9ybXMuXHJcbiAgICAgKi9cclxuICAgIF9wcmVwYXJlUHJvZ3JhbShwcm9ncmFtLCAuLi5fYXJncykge1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFByb2dyYW0ocHJvZ3JhbSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEJpbmRzIHJlbmRlciBzdGF0ZSBhbmQgcmVuZGVyIHRhcmdldCwgbm8gY2xlYXIgaGFwcGVucyBoZXJlLCBidXQgdGhpcyBtZXRob2RcclxuICAgICAqIGNhbiBiZSBvdmVycmlkZGVuIGluIHN1YmNsYXNzZXMgdG8gYWRkIGFueSBzZXR1cHMgdGhleSBuZWVkLlxyXG4gICAgICovXHJcbiAgICBfcHJlcGFyZVJlbmRlclRhcmdldCh0YXJnZXQsIC4uLl9hcmdzKSB7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kUmVuZGVyU3RhdGUodGhpcy5fcmVuZGVyU3RhdGUpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFJlbmRlclRhcmdldCh0YXJnZXQpO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9nbF9yZW5kZXJlci50c1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBHbFJlbmRlcmVyIH0gZnJvbSAnLi4vZ2xfcmVuZGVyZXInO1xyXG5pbXBvcnQgeyBjb3VudEluZGljZXMgfSBmcm9tICcuLi9tZW1vcnkvY291bnRfdmVydGljZXMnO1xyXG5pbXBvcnQgeyBiYXRjaFByaW1pdGl2ZXMgfSBmcm9tICcuL3ByaW1pdGl2ZV9iYXRjaCc7XHJcbi8qKlxyXG4gKiBCYXNlIGNsYXNzIGZvciByZW5kZXJpbmcgdmlzaWJsZSBwcmltaXRpdmVzLiBCZWluZyB2aXNpYmxlIGluIHRoZSB3b3JsZCBtZWFucyB0aGF0IHRoZXkgYWxsIG5lZWQgdmlldy1wcm9qZWN0aW9uXHJcbiAqIG1hdHJpeCBhbmQgY2FtZXJhIHBvc2l0aW9ucyAobXVsdGlwbGUgcG9zaXRpb25zIGFyZSB1c2VkIGZvciByZW5kZXJpbmcgcmVwZWF0ZWQgd29ybGQpLiBUaGVzZSBwYXJhbWV0ZXJzIGFyZVxyXG4gKiBwcmVkZWZpbmVkIGFzIGV4dGVybmFsIHJlcXVpcmVtZW50cyBmb3IgcmVuZGVyKCkgbWV0aG9kLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV29ybGRQcmltaXRpdmVSZW5kZXJVbml0IGV4dGVuZHMgR2xSZW5kZXJlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCByZW5kZXJTdGF0ZSwgcHJvZ3JhbSwgcHJpbWl0aXZlUHJvdmlkZXIpIHtcclxuICAgICAgICBzdXBlcihjb250ZXh0LCByZW5kZXJTdGF0ZSwgcHJvZ3JhbSk7XHJcbiAgICAgICAgdGhpcy5wcmltaXRpdmVQcm92aWRlciA9IHByaW1pdGl2ZVByb3ZpZGVyO1xyXG4gICAgICAgIHRoaXMub25VcGRhdGUgPSBwcmltaXRpdmVQcm92aWRlci5vblVwZGF0ZTtcclxuICAgIH1cclxuICAgIHJlbmRlcih0YXJnZXQsIHZpZXdQcm9qTWF0cml4LCBjYW1lcmFQb3NpdGlvbnMsIC4uLmFyZ3MpIHtcclxuICAgICAgICBzdXBlci5yZW5kZXIodGFyZ2V0LCB2aWV3UHJvak1hdHJpeCwgY2FtZXJhUG9zaXRpb25zLCAuLi5hcmdzKTtcclxuICAgIH1cclxuICAgIF9yZW5kZXIoX3ZpZXdQcm9qTWF0cml4LCBjYW1lcmFQb3NpdGlvbnMpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGNhbWVyYVBvc2l0aW9uIG9mIGNhbWVyYVBvc2l0aW9ucykge1xyXG4gICAgICAgICAgICB0aGlzLl9wcm9ncmFtLnNldFZlY3RvcjJVbmlmb3JtKCdsb29rQXRIaWdoJywgY2FtZXJhUG9zaXRpb24ubG9va0F0SGlnaCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3Byb2dyYW0uc2V0VmVjdG9yMlVuaWZvcm0oJ2xvb2tBdExvdycsIGNhbWVyYVBvc2l0aW9uLmxvb2tBdExvdyk7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgbWVtb3J5QmF0Y2ggb2YgYmF0Y2hQcmltaXRpdmVzKHRoaXMuX2dldFByaW1pdGl2ZXMoKSwgdGhpcy5fY2FuQmF0Y2hBZGphY2VudFByaW1pdGl2ZXMpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJCYXRjaChtZW1vcnlCYXRjaCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfZ2V0UHJpbWl0aXZlcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wcmltaXRpdmVQcm92aWRlci5wcmltaXRpdmVzO1xyXG4gICAgfVxyXG4gICAgX3ByZXBhcmVQcm9ncmFtKHByb2dyYW0sIHZpZXdQcm9qTWF0cml4LCBjYW1lcmFQb3NpdGlvbnMsIC4uLmFyZ3MpIHtcclxuICAgICAgICBzdXBlci5fcHJlcGFyZVByb2dyYW0ocHJvZ3JhbSwgdmlld1Byb2pNYXRyaXgsIGNhbWVyYVBvc2l0aW9ucywgLi4uYXJncyk7XHJcbiAgICAgICAgcHJvZ3JhbS5zZXRNYXRyaXg0VW5pZm9ybSgndmlld1Byb2pNYXRyaXgnLCB2aWV3UHJvak1hdHJpeCk7XHJcbiAgICB9XHJcbiAgICBfcmVuZGVyQmF0Y2gobWVtb3J5QmF0Y2gpIHtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRWYW8obWVtb3J5QmF0Y2gucGFnZS52YW8pO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuZHJhd0luZGV4ZWRNZXNoKG1lbW9yeUJhdGNoLmluZGV4Qnl0ZU9mZnNldCwgY291bnRJbmRpY2VzKG1lbW9yeUJhdGNoLmluZGV4Qnl0ZUxlbmd0aCwgbWVtb3J5QmF0Y2gucGFnZS5pbmRleFR5cGUpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGV0ZXJtaW5lcyBpZiB0d28gYWRqYWNlbnQgcHJpbWl0aXZlcyBjYW4gYmUgcmVuZGVyZWQgaW4gb25lIGJhdGNoIChieSBhIHNpbmdsZSBkcmF3IGNhbGwpLiBUaGV5IGFscmVhZHlcclxuICAgICAqIGxheSBzdWNjZXNzaXZlbHkgaW4gbWVtb3J5LCBidXQgdGhlcmUgY291bGQgYmUgb3RoZXIgcmVhc29ucyB0aGF0IGZvcmJpZCBiYXRjaGluZywgbGlrZSB1c2luZyBkaWZmZXJlbnQgdGV4dHVyZXMuXHJcbiAgICAgKiBUaGUgbWV0aG9kIHNob3VsZCBiZSBvdmVycmlkZGVuIGluIHN1YmNsYXNzZXMgaWYgdGhlaXIgcHJpbWl0aXZlcyBoYXZlIHN1Y2ggY29tcGxleCBydWxlcyBvZiBiYXRjaGluZy5cclxuICAgICAqL1xyXG4gICAgX2NhbkJhdGNoQWRqYWNlbnRQcmltaXRpdmVzKF9hLCBfYikge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL3dvcmxkX3ByaW1pdGl2ZV9yZW5kZXJfdW5pdC50c1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBmbG9hdFRvVWludDMyIH0gZnJvbSAnLi9ncHV0eXBlcyc7XHJcbmltcG9ydCB7IHppcCB9IGZyb20gJy4vYXJyYXknO1xyXG5leHBvcnQgY29uc3QgV09SRF9CWVRFX1NJWkUgPSA0O1xyXG4vKipcclxuICogR2VuZXJhdGVzIHRyaWFuZ2xlcyBvZiBhIGZhbiBvZiBhIGdpdmVuIGxlbmd0aCBhcyBpZiBpdCBpcyBjb250aW51b3VzIGFuZFxyXG4gKiBzdGFydHMgd2l0aCAwLlxyXG4gKlxyXG4gKiBAcGFyYW0gY291bnQgTnVtYmVyIG9mIHZlcnRpY2VzIGluIHRoZSBmYW4uXHJcbiAqIEByZXR1cm5zIEl0ZXJhdG9yIG92ZXIgaW5kaWNlcyBvZiB0cmlhbmdsZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiogZ2VuZXJhdGVGYW4oY291bnQpIHtcclxuICAgIGZvciAobGV0IGkgPSAyOyBpIDwgY291bnQ7ICsraSkge1xyXG4gICAgICAgIHlpZWxkIDA7XHJcbiAgICAgICAgeWllbGQgaSAtIDE7XHJcbiAgICAgICAgeWllbGQgaTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogR2VuZXJhdGVzIHRyaWFuZ2xlcyBvZiBhIHN0cmlwIG9mIGEgZ2l2ZW4gbGVuZ3RoIGFzIGlmIGl0IGlzIGNvbnRpbnVvdXMgYW5kXHJcbiAqIHN0YXJ0cyB3aXRoIDAuXHJcbiAqXHJcbiAqIEBwYXJhbSBjb3VudCBOdW1iZXIgb2YgdmVydGljZXMgaW4gdGhlIGZhbi5cclxuICogQHJldHVybnMgSXRlcmF0b3Igb3ZlciBpbmRpY2VzIG9mIHRyaWFuZ2xlcy5cclxuICovXHJcbmZ1bmN0aW9uKiBnZW5lcmF0ZVN0cmlwKGNvdW50KSB7XHJcbiAgICB5aWVsZCAwO1xyXG4gICAgeWllbGQgMTtcclxuICAgIHlpZWxkIDI7XHJcbiAgICBsZXQgb2Zmc2V0MCA9IDE7XHJcbiAgICBsZXQgb2Zmc2V0MSA9IDI7XHJcbiAgICBmb3IgKGxldCBpID0gMzsgaSA8IGNvdW50OyArK2kpIHtcclxuICAgICAgICB5aWVsZCBpIC0gb2Zmc2V0MDtcclxuICAgICAgICB5aWVsZCBpIC0gb2Zmc2V0MTtcclxuICAgICAgICB5aWVsZCBpO1xyXG4gICAgICAgIGNvbnN0IHRtcCA9IG9mZnNldDA7XHJcbiAgICAgICAgb2Zmc2V0MCA9IG9mZnNldDE7XHJcbiAgICAgICAgb2Zmc2V0MSA9IHRtcDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVmVydGV4IGJ1ZmZlciBoZWxwZXIgY2xhc3MsIHRoYXQgc3VwcG9ydHMgc2VxdWVudGlhbCB3cml0aW5nIGludGVyZmFjZSBhbmQgdGFrZXMgb3ZlciBzb21lIHNpbmdsZS1idWZmZXIgb3BlcmF0aW9ucy5cclxuICogSXQgaXMgYW4gaW50ZWdyYWwgcGFydCBvZiB0aGUgYnVmZmVyIHdyaXRlciBjbGFzcyBhbmQgaXRzIG1haW4gcHVycG9zZSBpcyB0byBtYWtlIHRoZSB3cml0ZXIncyBjb2RlIGVhc2llci5cclxuICovXHJcbmNsYXNzIFZlcnRleEJ1ZmZlciB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBieXRlU2l6ZSBJbml0aWFsIHNpemUgb2YgdGhlIGJ1ZmZlciBpbiBieXRlcy4gQXMgaXQgZ2V0cyBmaWxsZWQgYnkgd29yZHNcclxuICAgICAqICAgICAgdGhlIHNpemUgbXVzdCBiZSBhIG11bHRpcGx5IG9mIDQuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGJ5dGVTaXplKSB7XHJcbiAgICAgICAgdGhpcy5fbmV4dFdvcmRPZmZzZXQgPSAwO1xyXG4gICAgICAgIHRoaXMuX2luaXRCdWZmZXJzKGJ5dGVTaXplKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGVyZSBpcyBubyBmcmVlIHNwYWNlIHJlbWFpbmluZyBpbiBidWZmZXIuXHJcbiAgICAgKi9cclxuICAgIGdldCBpc0Z1bGwoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX25leHRXb3JkT2Zmc2V0ID49IHRoaXMuX3VpbnQzMlZpZXcubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIHdvcmRzICg0IGJ5dGVzIHZhbHVlcykgYWxyZWFkeSB3cml0dGVuLlxyXG4gICAgICovXHJcbiAgICBnZXQgb2NjdXBpZWRTaXplKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9uZXh0V29yZE9mZnNldDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiBNYXggbnVtYmVyIG9mIGJ5dGVzIHRoaXMgYnVmZmVyIGlzIGFibGUgdG8gc3RvcmUuIEl0IGNhbiBiZSBpbmNyZWFzZWQgYnkgdGhlIGV4dGVuZCgpIG1ldGhvZC5cclxuICAgICAqL1xyXG4gICAgZ2V0IGJ5dGVTaXplKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl91aW50MzJWaWV3LmJ5dGVMZW5ndGg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEV4dGVuZHMgYnVmZmVyIHRvIHRoZSBuZXcgc2l6ZS4gVGhlIG5ldyBzaXplIG11c3QgYmUgbm90IGxlc3MgdGhhbiBjdXJyZW50IG9uZSBhbmQgaXQgbXVzdCBiZSBhIG11bHRpcGx5IG9mIDQuXHJcbiAgICAgKi9cclxuICAgIGV4dGVuZChuZXdCeXRlU2l6ZSkge1xyXG4gICAgICAgIC8vIFRPRE8gYXNzZXJ0IG5ld0J5dGVMZW5ndGggaXMgbGFyZ2VyIHRoYW4gY3VycmVudCBfYXJyYXlCdWZmZXIgYW5kIGl0cyBpcyBhIG11bHRpcGx5IG9mIHRoZSB3b3JkIHNpemUuXHJcbiAgICAgICAgY29uc3Qgb2xkVWludDMyVmlldyA9IHRoaXMuX3VpbnQzMlZpZXc7XHJcbiAgICAgICAgdGhpcy5faW5pdEJ1ZmZlcnMobmV3Qnl0ZVNpemUpO1xyXG4gICAgICAgIHRoaXMuX3VpbnQzMlZpZXcuc2V0KG9sZFVpbnQzMlZpZXcpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBlbmRzIHZhbHVlIGFzIGEgdWludDMyIG51bWJlci5cclxuICAgICAqL1xyXG4gICAgcHVzaFVpbnQzMih2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX3VpbnQzMlZpZXdbdGhpcy5fbmV4dFdvcmRPZmZzZXQrK10gPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXBwZW5kcyB2YWx1ZSBhcyBhIGZsb2F0MzIgbnVtYmVyLlxyXG4gICAgICovXHJcbiAgICBwdXNoRmxvYXQzMih2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX2Zsb2F0MzJWaWV3W3RoaXMuX25leHRXb3JkT2Zmc2V0KytdID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIHVpbnQ4IHZpZXcgb2YgdGhpcyBidWZmZXIuIFRoZSBzaXplIG9mIHRoZSB2aWV3IG1hdGNoZXMgdGhlIGFtb3VudCBvZiB3cml0dGVuIGRhdGEuXHJcbiAgICAgKi9cclxuICAgIGFzVWludDMyQXJyYXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VpbnQzMlZpZXcuc3ViYXJyYXkoMCwgdGhpcy5vY2N1cGllZFNpemUpO1xyXG4gICAgfVxyXG4gICAgX2luaXRCdWZmZXJzKGJ5dGVMZW5ndGgpIHtcclxuICAgICAgICBjb25zdCBhcnJheUJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihieXRlTGVuZ3RoKTtcclxuICAgICAgICB0aGlzLl91aW50MzJWaWV3ID0gbmV3IFVpbnQzMkFycmF5KGFycmF5QnVmZmVyKTtcclxuICAgICAgICB0aGlzLl9mbG9hdDMyVmlldyA9IG5ldyBGbG9hdDMyQXJyYXkoYXJyYXlCdWZmZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBNb3ZlcyBcInRhaWxcIiBkYXRhIChmcm9tIHRoZSBvZmZzZXQgc3BlY2lmaWVkIHRvIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlcikgb2Ygb25lIGJ1ZmZlciB0byBhbm90aGVyLiBUaGUgY3Vyc29ycyBvZlxyXG4gICAgICogYnVmZmVycyB3aWxsIGJlIGFwcHJvcHJpYXRlbHkgdXBkYXRlZCB0byByZWZsZWN0IGRhdGEgY2hhbmdlcy5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHRyYW5zZmVyRGF0YVRhaWwoc3JjLCBkc3QsIHNyY1dvcmRPZmZzZXQsIGRzdE9mZnNldCA9IDApIHtcclxuICAgICAgICBjb25zdCB0YWlsTGVuZ3RoID0gc3JjLm9jY3VwaWVkU2l6ZSAtIHNyY1dvcmRPZmZzZXQ7XHJcbiAgICAgICAgY29uc3Qgc3JjVGFpbCA9IHNyYy5fdWludDMyVmlldy5zdWJhcnJheShzcmNXb3JkT2Zmc2V0LCBzcmMub2NjdXBpZWRTaXplKTtcclxuICAgICAgICBkc3QuX3VpbnQzMlZpZXcuc2V0KHNyY1RhaWwsIGRzdE9mZnNldCk7XHJcbiAgICAgICAgZHN0Ll9uZXh0V29yZE9mZnNldCA9IHRhaWxMZW5ndGg7XHJcbiAgICAgICAgc3JjLl9uZXh0V29yZE9mZnNldCA9IHNyY1dvcmRPZmZzZXQ7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEluZGV4IGJ1ZmZlciBoZWxwZXIgY2xhc3MsIHRoYXQgc3VwcG9ydHMgc2VxdWVudGlhbCB3cml0aW5nIGludGVyZmFjZSBhbmQgdGFrZXMgb3ZlciBzb21lIHNpbmdsZS1idWZmZXIgb3BlcmF0aW9ucy5cclxuICogSXQgaXMgYW4gaW50ZWdyYWwgcGFydCBvZiB0aGUgYnVmZmVyIHdyaXRlciBjbGFzcyBhbmQgaXRzIG1haW4gcHVycG9zZSBpcyB0byBtYWtlIHRoZSB3cml0ZXIncyBjb2RlIGVhc2llci5cclxuICovXHJcbmNsYXNzIEluZGV4QnVmZmVyIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHNpemUgSW5pdGlhbCBzaXplIG9mIHRoZSBidWZmZXIuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHNpemUpIHtcclxuICAgICAgICB0aGlzLl9uZXh0SW5kZXhPZmZzZXQgPSAwO1xyXG4gICAgICAgIHRoaXMuX3VpbnQxNlZpZXcgPSBuZXcgVWludDE2QXJyYXkoc2l6ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgaW5kaWNlcyBhbHJlYWR5IHdyaXR0ZW4uXHJcbiAgICAgKi9cclxuICAgIGdldCBvY2N1cGllZFNpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX25leHRJbmRleE9mZnNldDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiBNYXggbnVtYmVyIG9mIGluZGljZXMgdGhpcyBidWZmZXIgaXMgYWJsZSB0byBzdG9yZS4gSXQgY2FuIGJlIGluY3JlYXNlZCBieSB0aGUgZXh0ZW5kKCkgbWV0aG9kLlxyXG4gICAgICovXHJcbiAgICBnZXQgc2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdWludDE2Vmlldy5sZW5ndGg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEV4dGVuZHMgYnVmZmVyIHRvIHRoZSBuZXcgc2l6ZS5cclxuICAgICAqL1xyXG4gICAgZXh0ZW5kKG5ld1NpemUpIHtcclxuICAgICAgICAvLyBUT0RPIGFzc2VydCBuZXdCeXRlTGVuZ3RoIGlzIGxhcmdlciB0aGFuIGN1cnJlbnQgX2FycmF5QnVmZmVyXHJcbiAgICAgICAgY29uc3Qgb2xkVWludDE2VmlldyA9IHRoaXMuX3VpbnQxNlZpZXc7XHJcbiAgICAgICAgdGhpcy5fdWludDE2VmlldyA9IG5ldyBVaW50MTZBcnJheShuZXdTaXplKTtcclxuICAgICAgICB0aGlzLl91aW50MTZWaWV3LnNldChvbGRVaW50MTZWaWV3KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXBwZW5kcyBpbmRleCB0byB0aGUgZW5kIG9mIHRoZSBidWZmZXIuXHJcbiAgICAgKi9cclxuICAgIHB1c2goaW5kZXgpIHtcclxuICAgICAgICB0aGlzLl91aW50MTZWaWV3W3RoaXMuX25leHRJbmRleE9mZnNldCsrXSA9IGluZGV4O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyB1aW50MTYgdmlldyBvZiB0aGlzIGJ1ZmZlci4gVGhlIHNpemUgb2YgdGhlIHZpZXcgbWF0Y2hlcyB0aGUgYW1vdW50IG9mIHdyaXR0ZW4gZGF0YS5cclxuICAgICAqL1xyXG4gICAgYXNVaW50MTZBcnJheSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQxNkFycmF5KHRoaXMuX3VpbnQxNlZpZXcuYnVmZmVyLCAwLCB0aGlzLm9jY3VwaWVkU2l6ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE1vdmVzIFwidGFpbFwiIGRhdGEgKGZyb20gdGhlIG9mZnNldCBzcGVjaWZpZWQgdG8gdGhlIGVuZCBvZiB0aGUgYnVmZmVyKSBvZiBvbmUgYnVmZmVyIHRvIGFub3RoZXIuIFRoZSBvZmZzZXRzIG9mXHJcbiAgICAgKiBidWZmZXJzIHdpbGwgYmUgYXBwcm9wcmlhdGVseSB1cGRhdGVkIHRvIHJlZmxlY3QgZGF0YSBjaGFuZ2VzLlxyXG4gICAgICogYmFzZUluZGV4IHdpbGwgYmUgZGVkdWN0ZWQgZnJvbSBhbGwgbW92ZWQgaW5kaWNlcy5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHRyYW5zZmVyRGF0YVRhaWwoc3JjLCBkc3QsIGJhc2VJbmRleCwgc3JjT2Zmc2V0LCBkc3RPZmZzZXQgPSAwKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IHNyY09mZnNldCwgaiA9IGRzdE9mZnNldDsgaSA8IHNyYy5vY2N1cGllZFNpemU7IGkrKywgaisrKSB7XHJcbiAgICAgICAgICAgIGRzdC5fdWludDE2Vmlld1tqXSA9IHNyYy5fdWludDE2Vmlld1tpXSAtIGJhc2VJbmRleDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZHN0Ll9uZXh0SW5kZXhPZmZzZXQgPSBzcmMub2NjdXBpZWRTaXplIC0gc3JjT2Zmc2V0O1xyXG4gICAgICAgIHNyYy5fbmV4dEluZGV4T2Zmc2V0ID0gc3JjT2Zmc2V0O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBCYXNlIGJ1ZmZlciB3cml0ZXIgaW1wbGVtZW50YXRpb24uIENhbiB3cml0ZSB1bnNpZ25lZCBzaG9ydCBpbmRpY2VzIGFuZFxyXG4gKiBwcm92aWRlcyBmYWNpbGl0aWVzIGZvciBjaGlsZCBjbGFzc2VzIHRvIGhhbmRsZSB3cml0aW5nIHZlcnRleCBkYXRhLiBEZWZpbmVzXHJcbiAqIGEgY29uY2VwdCBvZiBjdXJyZW50IG1lc2guIEJhc2ljYWxseSwgaXQgbWVhbiB0aGF0IGFsbCB2ZXJ0aWNlcyBhbmQgaW5kaWNlc1xyXG4gKiB3cml0dGVuIHRvIGEgd3JpdGVyIGJldHdlZW4gdHdvIGBlbmRNZXNoYCBjYWxscyAob3IgY29uc3RydWN0aW9uIG9mIHRoZSB3cml0ZXJcclxuICogYW5kIGFuIGBlbmRNZXNoYCBjYWxsKSBtdXN0IGJlIGNvbnNpZGVyZWQgYmVsb25naW5nIHRvIG9uZSBhdG9taWMgcGllY2Ugb2ZcclxuICogZ2VvbWV0cnkgYW5kIHNob3VsZCBub3QgYmUgc3BpdHRlZCBiZXR3ZWVuIHNlcGFyYXRlIGJ1ZmZlcnMuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCdWZmZXJXcml0ZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHdyaXRlciBhbmQgYWxsb2NhdGVzIGluaXRpYWwgYW1vdW50IG9mIG1lbW9yeSB0byBzdG9yZSBkYXRhLlxyXG4gICAgICogQWxzbyBpbXBsaWNpdGx5IFwic3RhcnRcIiBhIG1lc2guXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZlcnRleEJ5dGVTaXplXHJcbiAgICAgKiBAcGFyYW0gaW5pdFZlcnRleEJ1ZmZlclNpemUgSW5pdCBzaXplIChpbiB2ZXJ0aWNlcykgb2YgZ3Jvd2luZyB2ZXJ0ZXggYnVmZmVycy5cclxuICAgICAqIEBwYXJhbSBtYXhWZXJ0ZXhCdWZmZXJTaXplIE1heCBzaXplIChpbiB2ZXJ0aWNlcykgb2YgdmVydGV4IGJ1ZmZlcnMuXHJcbiAgICAgKiBAcGFyYW0gaW5pdEluZGV4QnVmZmVyVWludDE2U2l6ZSBJbml0IHNpemUgKGluIHVpbnQxNiBudW1iZXIpIG9mIGdyb3dpbmcgaW5kZXggYnVmZmVycy5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IodmVydGV4Qnl0ZVNpemUsIGluaXRWZXJ0ZXhCdWZmZXJTaXplID0gMHg0MDAsIG1heFZlcnRleEJ1ZmZlclNpemUgPSAweDEwMDAwLCBpbml0SW5kZXhCdWZmZXJVaW50MTZTaXplID0gMHhjMDApIHtcclxuICAgICAgICB0aGlzLl92ZXJ0ZXhCeXRlU2l6ZSA9IHZlcnRleEJ5dGVTaXplO1xyXG4gICAgICAgIHRoaXMuX2luaXRWZXJ0ZXhCdWZmZXJCeXRlU2l6ZSA9IHZlcnRleEJ5dGVTaXplICogaW5pdFZlcnRleEJ1ZmZlclNpemU7XHJcbiAgICAgICAgdGhpcy5fbWF4VmVydGV4QnVmZmVyQnl0ZVNpemUgPSB2ZXJ0ZXhCeXRlU2l6ZSAqIG1heFZlcnRleEJ1ZmZlclNpemU7XHJcbiAgICAgICAgdGhpcy5faW5pdEluZGV4QnVmZmVyVWludDE2U2l6ZSA9IGluaXRJbmRleEJ1ZmZlclVpbnQxNlNpemU7XHJcbiAgICAgICAgdGhpcy5fdmVydGV4QnVmZmVyID0gbmV3IFZlcnRleEJ1ZmZlcih0aGlzLl9pbml0VmVydGV4QnVmZmVyQnl0ZVNpemUpO1xyXG4gICAgICAgIHRoaXMuX3ZlcnRleEJ1ZmZlcnMgPSBbdGhpcy5fdmVydGV4QnVmZmVyXTtcclxuICAgICAgICB0aGlzLl9pbmRleEJ1ZmZlciA9IG5ldyBJbmRleEJ1ZmZlcih0aGlzLl9pbml0SW5kZXhCdWZmZXJVaW50MTZTaXplKTtcclxuICAgICAgICB0aGlzLl9pbmRleEJ1ZmZlcnMgPSBbdGhpcy5faW5kZXhCdWZmZXJdO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRNZXNoVmVydGV4T2Zmc2V0ID0gMDtcclxuICAgICAgICB0aGlzLl9jdXJyZW50TWVzaEluZGV4T2Zmc2V0ID0gMDtcclxuICAgICAgICB0aGlzLl9jdXJyZW50TWVzaEJhc2VJbmRleCA9IDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIGJ1bmNoIG9mIGluZGljZXMgdG8gdGhlIHVuZGVybHlpbmcgc3RvcmFnZSBhcyB1bnNpZ25lZCBzaG9ydFxyXG4gICAgICogbnVtYmVycy4gSWYgY3VycmVudCBzdG9yYWdlIGRvZXNuJ3QgaGF2ZSBlbm91Z2ggc3BhY2UgdG8gYWNjb21tb2RhdGVcclxuICAgICAqIGdpdmVuIGluZGljZXMsIHRoZSB3cml0ZXIgd2lsbCBhdXRvbWF0aWNhbGx5IHJlc2l6ZSBpdC4gVGhlIHdyaXRlclxyXG4gICAgICogYXV0b21hdGljYWxseSBhZGRzIGJhc2UgaW5kZXggdG8gdGhlIHN1cHBsaWVkIHZhbHVlcywgc28gZnJvbSBhIHVzZXJcclxuICAgICAqIHBvaW50IG9mIHZpZXcgZmlyc3QgdmVydGV4IG9mIGEgbWVzaCBoYXMgaW5kZXggMCBhbmQgdGhlcmUncyBubyBuZWVkXHJcbiAgICAgKiB0byB0YWtlIGludG8gYWNjb3VudCBpdCdzIG9mZnNldCB3aGlsZSBnZW5lcmF0aW5nIG1lc2gncyB0b3BvbG9neS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaW5kaWNlcyBBcnJheSBvZiBpbmRpY2VzIHRvIHdyaXRlLlxyXG4gICAgICovXHJcbiAgICB3cml0ZUluZGljZXMoaW5kaWNlcykge1xyXG4gICAgICAgIHRoaXMuX2Vuc3VyZUVub3VnaEluZGV4QnVmZmVyU3BhY2UoaW5kaWNlcy5sZW5ndGgpO1xyXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuX2luZGV4QnVmZmVyO1xyXG4gICAgICAgIGNvbnN0IGJhc2VJbmRleCA9IHRoaXMuX2N1cnJlbnRNZXNoQmFzZUluZGV4O1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kaWNlcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBidWZmZXIucHVzaChiYXNlSW5kZXggKyBpbmRpY2VzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlcyB0cmlhbmdsZSBpbmRpY2VzIGZyb20gYW4gYXJyYXkgb2YgaW5kaWNlcyBvZiBhIHRyaWFuZ2xlIHN0cmlwXHJcbiAgICAgKiAoYXMgaW4gR0wpIGFuZCB3cml0ZXMgZ2VuZXJhdGVkIHRyaXBsZXRzIHRvIHRoZSBtYW5hZ2VkIGluZGV4IGJ1ZmZlci5cclxuICAgICAqIEBzZWUgT3BlbkdMIEVTIDIuMCBTcGVjLCDCpzIuNi4xXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGluZGljZXMgSW5kaWNlcyBvZiB0aGUgc3RyaXAuXHJcbiAgICAgKi9cclxuICAgIHdyaXRlSW5kaWNlc0ZvclN0cmlwKGluZGljZXMpIHtcclxuICAgICAgICB0aGlzLl9lbnN1cmVFbm91Z2hJbmRleEJ1ZmZlclNwYWNlKDMgKiAoaW5kaWNlcy5sZW5ndGggLSAyKSk7XHJcbiAgICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5faW5kZXhCdWZmZXI7XHJcbiAgICAgICAgY29uc3QgYmFzZUluZGV4ID0gdGhpcy5fY3VycmVudE1lc2hCYXNlSW5kZXg7XHJcbiAgICAgICAgZm9yIChjb25zdCBpIG9mIGdlbmVyYXRlU3RyaXAoaW5kaWNlcy5sZW5ndGgpKSB7XHJcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoKGJhc2VJbmRleCArIGluZGljZXNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJhdGVzIHRyaWFuZ2xlIGluZGljZXMgZnJvbSBhIGNvbnRpbnVvdXMgdHJpYW5nbGUgc3RyaXAgb2YgYSBnaXZlblxyXG4gICAgICogbGVuZ3RoIGFuZCB3cml0ZXMgZ2VuZXJhdGVkIHRyaXBsZXRzIHRvIG1hbmFnZWQgaW5kZXggYnVmZmVyLlxyXG4gICAgICogQHNlZSBPcGVuR0wgRVMgMi4wIFNwZWMsIMKnMi42LjFcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaW5kZXhDb3VudFxyXG4gICAgICogQHBhcmFtIGJhc2VJbmRleEluTWVzaFxyXG4gICAgICovXHJcbiAgICB3cml0ZUluZGljZXNGb3JDb250aW51b3VzU3RyaXAoaW5kZXhDb3VudCwgYmFzZUluZGV4SW5NZXNoID0gMCkge1xyXG4gICAgICAgIHRoaXMuX2Vuc3VyZUVub3VnaEluZGV4QnVmZmVyU3BhY2UoMyAqIChpbmRleENvdW50IC0gMikpO1xyXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuX2luZGV4QnVmZmVyO1xyXG4gICAgICAgIGNvbnN0IGJhc2VJbmRleCA9IHRoaXMuX2N1cnJlbnRNZXNoQmFzZUluZGV4ICsgYmFzZUluZGV4SW5NZXNoO1xyXG4gICAgICAgIGZvciAoY29uc3QgaSBvZiBnZW5lcmF0ZVN0cmlwKGluZGV4Q291bnQpKSB7XHJcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoKGJhc2VJbmRleCArIGkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJhdGVzIHRyaWFuZ2xlIGluZGljZXMgZnJvbSBhbiBhcnJheSBvZiBpbmRpY2VzIG9mIGEgdHJpYW5nbGUgZmFuIChhc1xyXG4gICAgICogaW4gR0wpIGFuZCB3cml0ZXMgZ2VuZXJhdGVkIHRyaXBsZXRzIHRvIHRoZSBtYW5hZ2VkIGluZGV4IGJ1ZmZlci5cclxuICAgICAqIEBzZWUgT3BlbkdMIEVTIDIuMCBTcGVjLCDCpzIuNi4xXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGluZGljZXMgSW5kaWNlcyBvZiB0aGUgc3RyaXAuXHJcbiAgICAgKi9cclxuICAgIHdyaXRlSW5kaWNlc0ZvckZhbihpbmRpY2VzKSB7XHJcbiAgICAgICAgdGhpcy5fZW5zdXJlRW5vdWdoSW5kZXhCdWZmZXJTcGFjZSgzICogKGluZGljZXMubGVuZ3RoIC0gMikpO1xyXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuX2luZGV4QnVmZmVyO1xyXG4gICAgICAgIGNvbnN0IGJhc2VJbmRleCA9IHRoaXMuX2N1cnJlbnRNZXNoQmFzZUluZGV4O1xyXG4gICAgICAgIGZvciAoY29uc3QgaSBvZiBnZW5lcmF0ZUZhbihpbmRpY2VzLmxlbmd0aCkpIHtcclxuICAgICAgICAgICAgYnVmZmVyLnB1c2goYmFzZUluZGV4ICsgaW5kaWNlc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZXMgdHJpYW5nbGUgaW5kaWNlcyBmcm9tIGEgY29udGludW91cyB0cmlhbmdsZSBmYW4gb2YgYSBnaXZlbiBsZW5ndGhcclxuICAgICAqIGFuZCB3cml0ZXMgZ2VuZXJhdGVkIHRyaXBsZXRzIHRvIG1hbmFnZWQgaW5kZXggYnVmZmVyLlxyXG4gICAgICogQHNlZSBPcGVuR0wgRVMgMi4wIFNwZWMsIMKnMi42LjFcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaW5kZXhDb3VudFxyXG4gICAgICogQHBhcmFtIGJhc2VJbmRleEluTWVzaFxyXG4gICAgICovXHJcbiAgICB3cml0ZUluZGljZXNGb3JDb250aW51b3VzRmFuKGluZGV4Q291bnQsIGJhc2VJbmRleEluTWVzaCA9IDApIHtcclxuICAgICAgICB0aGlzLl9lbnN1cmVFbm91Z2hJbmRleEJ1ZmZlclNwYWNlKDMgKiAoaW5kZXhDb3VudCAtIDIpKTtcclxuICAgICAgICBjb25zdCBidWZmZXIgPSB0aGlzLl9pbmRleEJ1ZmZlcjtcclxuICAgICAgICBjb25zdCBiYXNlSW5kZXggPSBiYXNlSW5kZXhJbk1lc2ggKyB0aGlzLl9jdXJyZW50TWVzaEJhc2VJbmRleDtcclxuICAgICAgICBmb3IgKGNvbnN0IGkgb2YgZ2VuZXJhdGVGYW4oaW5kZXhDb3VudCkpIHtcclxuICAgICAgICAgICAgYnVmZmVyLnB1c2goYmFzZUluZGV4ICsgaSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmRzIGN1cnJlbnQgbWVzaCBhbmQgaW1wbGljaXRseSBzdGFydHMgYSBuZXcgb25lLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIEludGVybmFsIGluZGV4IG9mIHZlcnRleCBhbmQgaW5kZXggYnVmZmVycyB0aGUgbWVzaCB3YXMgd3JpdHRlblxyXG4gICAgICogICAgICB0byBhbmQgaXRzIG1lbW9yeSBsb2NhdGlvbiBpbiB0aGVtLlxyXG4gICAgICovXHJcbiAgICBlbmRNZXNoKCkge1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRNZXNoVmVydGV4T2Zmc2V0ID0gdGhpcy5fY3VycmVudE1lc2hWZXJ0ZXhPZmZzZXQ7XHJcbiAgICAgICAgY29uc3QgdmVydGV4T2NjdXBpZWRTaXplID0gdGhpcy5fdmVydGV4QnVmZmVyLm9jY3VwaWVkU2l6ZTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50TWVzaFZlcnRleE9mZnNldCA9IHZlcnRleE9jY3VwaWVkU2l6ZTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50TWVzaEJhc2VJbmRleCA9ICh2ZXJ0ZXhPY2N1cGllZFNpemUgPDwgMikgLyB0aGlzLl92ZXJ0ZXhCeXRlU2l6ZTtcclxuICAgICAgICBjb25zdCBjdXJyZW50TWVzaEluZGV4T2Zmc2V0ID0gdGhpcy5fY3VycmVudE1lc2hJbmRleE9mZnNldDtcclxuICAgICAgICBjb25zdCBpbmRleE9jY3VwaWVkU2l6ZSA9IHRoaXMuX2luZGV4QnVmZmVyLm9jY3VwaWVkU2l6ZTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50TWVzaEluZGV4T2Zmc2V0ID0gaW5kZXhPY2N1cGllZFNpemU7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdmVydGV4Qnl0ZU9mZnNldDogY3VycmVudE1lc2hWZXJ0ZXhPZmZzZXQgPDwgMixcclxuICAgICAgICAgICAgdmVydGV4Qnl0ZUxlbmd0aDogdmVydGV4T2NjdXBpZWRTaXplIC0gY3VycmVudE1lc2hWZXJ0ZXhPZmZzZXQgPDwgMixcclxuICAgICAgICAgICAgaW5kZXhCeXRlT2Zmc2V0OiBjdXJyZW50TWVzaEluZGV4T2Zmc2V0IDw8IDEsXHJcbiAgICAgICAgICAgIGluZGV4Qnl0ZUxlbmd0aDogaW5kZXhPY2N1cGllZFNpemUgLSBjdXJyZW50TWVzaEluZGV4T2Zmc2V0IDw8IDEsXHJcbiAgICAgICAgICAgIC8vIFdlIGNhbid0IHJldHVybiBhY3R1YWwgYnVmZmVyIHJlZmVyZW5jZSBzaW5jZSBpdCBjYW4gY2hhbmdlIGlmXHJcbiAgICAgICAgICAgIC8vIHRoZSBidWZmZXIgZ2V0cyByZWFsbG9jYXRlZC5cclxuICAgICAgICAgICAgYnVmZmVySW5kZXg6IHRoaXMuX3ZlcnRleEJ1ZmZlcnMubGVuZ3RoIC0gMVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgY3VycmVudGx5IG93bmVkIGJ1ZmZlciBkYXRhLiBUaGlzIGNhbGwncyBiZXR0ZXJcclxuICAgICAqIG1hZGUgd2hlbiB5b3UncmUgZG9uZSB3aXRoIHRoZSB3cml0ZXIgc2luY2UgaWYgdGhlIHdyaXRlciBkZWNpZGVzIHRvXHJcbiAgICAgKiByZXNpemUgYW55IG9mIHRoZSBidWZmZXJzIHNvbWUgb2YgdGhlIHJlZmVyZW5jZXMgaW4gdGhlIHJldHVybmVkIGFycmF5XHJcbiAgICAgKiBtYXkgYmVjb21lIG91dGRhdGVkLlxyXG4gICAgICovXHJcbiAgICBnZXRCdWZmZXJzKCkge1xyXG4gICAgICAgIHJldHVybiB6aXAodGhpcy5fdmVydGV4QnVmZmVycywgdGhpcy5faW5kZXhCdWZmZXJzLCAodmVydGV4QnVmZmVyLCBpbmRleEJ1ZmZlcikgPT4gKHtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyOiB2ZXJ0ZXhCdWZmZXIuYXNVaW50MzJBcnJheSgpLFxyXG4gICAgICAgICAgICBpbmRleEJ1ZmZlcjogaW5kZXhCdWZmZXIuYXNVaW50MTZBcnJheSgpXHJcbiAgICAgICAgfSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFuIG9mZnNldCBpbiB0aGUgY3VycmVudCB2ZXJ0ZXggYnVmZmVyIHRvIHRoZSBsb2NhdGlvbiB3aGVyZSBuZXh0XHJcbiAgICAgKiBwaWVjZSBvZiBkYXRhIHdpbGwgYmUgd3JpdHRlbi5cclxuICAgICAqL1xyXG4gICAgZ2V0Q3VycmVudFZlcnRleEJ1ZmZlckJ5dGVPZmZzZXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZlcnRleEJ1ZmZlci5vY2N1cGllZFNpemUgPDwgMjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBpbmRleCBvZiBjdXJyZW50bHkgd3JpdHRlbiB2ZXJ0ZXggc3RydWN0dXJlIGluIHRoZSBjdXJyZW50IHZlcnRleFxyXG4gICAgICogYnVmZmVyLlxyXG4gICAgICovXHJcbiAgICBnZXRDdXJyZW50VmVydGV4SWR4KCkge1xyXG4gICAgICAgIHJldHVybiAoKHRoaXMuX3ZlcnRleEJ1ZmZlci5vY2N1cGllZFNpemUgPDwgMikgLyB0aGlzLl92ZXJ0ZXhCeXRlU2l6ZSB8IDApIC0gdGhpcy5fY3VycmVudE1lc2hCYXNlSW5kZXg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIGZsb2F0aW5nIHBvaW50IHZhbHVlIHRvIHRoZSBjdXJyZW50IHZlcnRleCBidWZmZXIgYW5kIGFkdmFuY2VzXHJcbiAgICAgKiB0aGUgb2Zmc2V0IGJ5IDQgYnl0ZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBiZSB3cml0dGVuLlxyXG4gICAgICovXHJcbiAgICBfd3JpdGVGbG9hdDMyKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fZW5zdXJlRW5vdWdoVmVydGV4QnVmZmVyU3BhY2UoKTtcclxuICAgICAgICB0aGlzLl92ZXJ0ZXhCdWZmZXIucHVzaEZsb2F0MzIodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYW4gdW5zaWduZWQgaW50ZWdlciB2YWx1ZSB0byB0aGUgY3VycmVudCB2ZXJ0ZXggYnVmZmVyIGFuZCBhZHZhbmNlc1xyXG4gICAgICogdGhlIG9mZnNldCBieSA0IGJ5dGVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgd3JpdHRlbi5cclxuICAgICAqL1xyXG4gICAgX3dyaXRlV29yZCh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX2Vuc3VyZUVub3VnaFZlcnRleEJ1ZmZlclNwYWNlKCk7XHJcbiAgICAgICAgdGhpcy5fdmVydGV4QnVmZmVyLnB1c2hVaW50MzIodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYW4gdW5zaWduZWQgc2hvcnQgdmFsdWUgdG8gdGhlIGN1cnJlbnQgdmVydGV4IGJ1ZmZlciBhbmQgYWR2YW5jZXNcclxuICAgICAqIHRoZSBvZmZzZXQgYnkgMiBieXRlcy4gUGFzc2VkIHZhbHVlcyB3aWxsIGJlIHRydW5jYXRlZCB0byAxNiBiaXRzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgd3JpdHRlbi5cclxuICAgICAqL1xyXG4gICAgX3dyaXRlSGFsZldvcmRzKHYxLCB2Mikge1xyXG4gICAgICAgIHRoaXMuX3dyaXRlV29yZCh2MiA8PCAxNiB8IHYxICYgMHhmZmZmKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGFuIHVuc2lnbmVkIGJ5dGUgdmFsdWUgdG8gdGhlIGN1cnJlbnQgdmVydGV4IGJ1ZmZlciBhbmQgYWR2YW5jZXNcclxuICAgICAqIHRoZSBvZmZzZXQgYnkgMSBieXRlLiBQYXNzZWQgdmFsdWVzIHdpbGwgYmUgdHJ1bmNhdGVkIHRvIDggYml0cy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIHdyaXR0ZW4uXHJcbiAgICAgKi9cclxuICAgIF93cml0ZUJ5dGVzKHYxLCB2MiwgdjMsIHY0KSB7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVXb3JkKHY0IDw8IDI0IHxcclxuICAgICAgICAgICAgKHYzICYgMHhmZikgPDwgMTYgfFxyXG4gICAgICAgICAgICAodjIgJiAweGZmKSA8PCA4IHxcclxuICAgICAgICAgICAgdjEgJiAweGZmKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRW5jb2RlcyBhIHdvcmxkIGNvb3JkaW5hdGUgdmVjdG9yIGFzIGEgcGFpciBvZiAzMi1iaXQgaW50ZWdlcnMgKHNwbGl0dGluZ1xyXG4gICAgICogdGhlbSBpbiB0dXJuIGludG8gdG8gMTYtYml0IG9uZXMpLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjIFRoZSB3b3JsZCBjb29yZGluYXRlLlxyXG4gICAgICovXHJcbiAgICBfd3JpdGVXb3JsZENvb3JkaW5hdGUoYykge1xyXG4gICAgICAgIC8vIFRvIGF2b2lkIHVzaW5nIEdQVSBzaW5nZWQgaW50ZWdlciBjb252ZXJzaW9ucyB3ZSBzaGlmdCBhbmQgc2NhbGUgd29ybGRcclxuICAgICAgICAvLyBjb29yZGluYXRlcyBzbyB0aGV5J3JlIGluIFswLCAxXSByYW5nZSAoaW5zdGVhZCBvZiBbLTEsIDFdKSBhbmQgdGhlblxyXG4gICAgICAgIC8vIGVuY29kZWQgYXMgdW5zaWduZWQgMzIgYml0IGludGVnZXJzIHNwbGl0IGludG8gdG8gMTYgYml0IG9uZXMuXHJcbiAgICAgICAgY29uc3QgeFVpbnQzMiA9IGZsb2F0VG9VaW50MzIoMC41ICogKGMueCArIDEpKTtcclxuICAgICAgICBjb25zdCB5VWludDMyID0gZmxvYXRUb1VpbnQzMigwLjUgKiAoYy55ICsgMSkpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlSGFsZldvcmRzKHhVaW50MzIgPj4+IDE2LCB5VWludDMyID4+PiAxNik7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVIYWxmV29yZHMoeFVpbnQzMiwgeVVpbnQzMik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbXB1dGVzIG5ldyBiaWdnZXIgc2l6ZSBvZiBhIHZlcnRleCBidWZmZXIgYmFzZWQgb24gaXRzIGN1cnJlbnQgc2l6ZS4gQnlcclxuICAgICAqIGRlZmF1bHQganVzdCBkb3VibGUgdGhlIGN1cnJlbnQgc2l6ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3VycmVudEJ5dGVTaXplIEN1cnJlbnQgc2l6ZSBvZiB0aGUgaW5kZXggYnVmZmVyIGluIGJ5dGVzLlxyXG4gICAgICogQHJldHVybnMgVGhlIG5ldyBzaXplLlxyXG4gICAgICovXHJcbiAgICBfZ2V0TmV4dFZlcnRleEJ1ZmZlckJ5dGVTaXplKGN1cnJlbnRCeXRlU2l6ZSkge1xyXG4gICAgICAgIHJldHVybiBjdXJyZW50Qnl0ZVNpemUgPDwgMTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgbmV3IGJpZ2dlciBzaXplIG9mIGFuIGluZGV4IGJ1ZmZlciBiYXNlZCBvbiBpdHMgY3VycmVudCBzaXplLiBCeVxyXG4gICAgICogZGVmYXVsdCBqdXN0IGRvdWJsZSB0aGUgY3VycmVudCBzaXplLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjdXJyZW50VWludDE2U2l6ZSBDdXJyZW50IHNpemUgb2YgdGhlIGluZGV4IGJ1ZmZlciBpbiBzaG9ydHMuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgbmV3IHNpemUuXHJcbiAgICAgKi9cclxuICAgIF9nZXROZXh0SW5kZXhCdWZmZXJVaW50MTZTaXplKGN1cnJlbnRVaW50MTZTaXplKSB7XHJcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRVaW50MTZTaXplIDw8IDE7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVuc3VyZXMgdGhhdCB0aGUgbWFuYWdlZCB2ZXJ0ZXggYnVmZmVyIGhhcyBlbm91Z2ggc3BhY2UgdG8gZml0IGluIGEgY2h1bmtcclxuICAgICAqIG9mIGRhdGEgb2YgYSBnaXZlbiBzaXplLiBFaXRoZXIgZG9lcyBub3RoaW5nLCByZXNpemVzIHRoZSBjdXJyZW50IHZlcnRleFxyXG4gICAgICogYnVmZmVyIG9yIGNyZWF0ZXMgZW50aXJlbHkgbmV3IHBhaXIgb2YgdmVydGV4IGFuZCBpbmRleCBidWZmZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB2YWx1ZVNpemUgQnl0ZSBzaXplIG9mIHRoZSBkYXRhIHRoYXQgbmVlZHMgdG8gYmUgYWNjb21tb2RhdGVkIGJ5XHJcbiAgICAgKiAgICAgIHRoZSB2ZXJ0ZXggYnVmZmVyLlxyXG4gICAgICovXHJcbiAgICBfZW5zdXJlRW5vdWdoVmVydGV4QnVmZmVyU3BhY2UoKSB7XHJcbiAgICAgICAgY29uc3QgdmVydGV4QnVmZmVyID0gdGhpcy5fdmVydGV4QnVmZmVyO1xyXG4gICAgICAgIGlmICghdmVydGV4QnVmZmVyLmlzRnVsbCkge1xyXG4gICAgICAgICAgICAvLyBXZSBoYXZlIGVub3VnaCBzcGFjZSwgc28gbm90aGluZyB0byBiZSBkb25lLlxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2ZXJ0ZXhCdWZmZXIuYnl0ZVNpemUgPCB0aGlzLl9tYXhWZXJ0ZXhCdWZmZXJCeXRlU2l6ZSkge1xyXG4gICAgICAgICAgICAvLyBJZiB3ZSBjYW4ganVzdCByZXNpemUgdGhlIGN1cnJlbnQgdmVydGV4IGJ1ZmZlciwgZG8gdGhhdC5cclxuICAgICAgICAgICAgdGhpcy5fdmVydGV4QnVmZmVyLmV4dGVuZCh0aGlzLl9nZXROZXh0VmVydGV4QnVmZmVyQnl0ZVNpemUodmVydGV4QnVmZmVyLmJ5dGVTaXplKSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWYgdGhlcmUncyBubyBlbm91Z2ggc3BhY2UgaW4gdGhlIGN1cnJlbnQgdmVydGV4IGJ1ZmZlciBhbmQgaXQnc1xyXG4gICAgICAgIC8vIGFscmVhZHkgb2YgbWF4aW11bSBzaXplLCBhbGxvY2F0ZSBuZXcgdmVydGV4IGFuZCBpbmRleCBidWZmZXJzIGFuZFxyXG4gICAgICAgIC8vIGNvcHkgZGF0YSBvZiB0aGUgY3VycmVudCBtZXNoIHRvIHRoZW0gZnJvbSB0aGUgY3VycmVudCBidWZmZXJzLlxyXG4gICAgICAgIC8vIFRoZW4gbWFrZSB0aG9zZSBidWZmZXIgdGhlIGN1cnJlbnQgb25lcy5cclxuICAgICAgICBjb25zdCBjdXJyZW50TWVzaFZlcnRleE9mZnNldCA9IHRoaXMuX2N1cnJlbnRNZXNoVmVydGV4T2Zmc2V0O1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRNZXNoVmVydGV4Qnl0ZVNpemUgPSAodmVydGV4QnVmZmVyLm9jY3VwaWVkU2l6ZSAtIGN1cnJlbnRNZXNoVmVydGV4T2Zmc2V0KSAqIDQ7XHJcbiAgICAgICAgY29uc3QgbWF4VmVydGV4QnVmZmVyQnl0ZVNpemUgPSB0aGlzLl9tYXhWZXJ0ZXhCdWZmZXJCeXRlU2l6ZTtcclxuICAgICAgICBpZiAoY3VycmVudE1lc2hWZXJ0ZXhCeXRlU2l6ZSA9PT0gbWF4VmVydGV4QnVmZmVyQnl0ZVNpemUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXNoIGlzIHRvbyBiaWcgdG8gZml0IGluLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgbmV3VmVydGV4QnVmZmVyQnl0ZVNpemUgPSB0aGlzLl9pbml0VmVydGV4QnVmZmVyQnl0ZVNpemU7XHJcbiAgICAgICAgLy8gSW5pdGlhbCB2ZXJ0ZXggYnVmZmVyIHNpemUgbWF5IGJlIHRvbyBzbWFsbCB0byBhY2NvbW1vZGF0ZSB0aGUgY3VycmVudFxyXG4gICAgICAgIC8vIG1lc2gsIHNvIHdlIGZpbmQgbmV4dCBiaWdnZXIgc2l6ZSB0aGF0IGlzIHN1ZmZpY2llbnQuXHJcbiAgICAgICAgd2hpbGUgKG5ld1ZlcnRleEJ1ZmZlckJ5dGVTaXplIDw9IGN1cnJlbnRNZXNoVmVydGV4Qnl0ZVNpemUpIHtcclxuICAgICAgICAgICAgbmV3VmVydGV4QnVmZmVyQnl0ZVNpemUgPSB0aGlzLl9nZXROZXh0VmVydGV4QnVmZmVyQnl0ZVNpemUobmV3VmVydGV4QnVmZmVyQnl0ZVNpemUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBuZXdWZXJ0ZXhCdWZmZXIgPSBuZXcgVmVydGV4QnVmZmVyKG5ld1ZlcnRleEJ1ZmZlckJ5dGVTaXplKTtcclxuICAgICAgICBWZXJ0ZXhCdWZmZXIudHJhbnNmZXJEYXRhVGFpbCh2ZXJ0ZXhCdWZmZXIsIG5ld1ZlcnRleEJ1ZmZlciwgY3VycmVudE1lc2hWZXJ0ZXhPZmZzZXQpO1xyXG4gICAgICAgIHRoaXMuX3ZlcnRleEJ1ZmZlciA9IG5ld1ZlcnRleEJ1ZmZlcjtcclxuICAgICAgICB0aGlzLl92ZXJ0ZXhCdWZmZXJzLnB1c2gobmV3VmVydGV4QnVmZmVyKTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50TWVzaFZlcnRleE9mZnNldCA9IDA7XHJcbiAgICAgICAgY29uc3QgaW5kZXhCdWZmZXIgPSB0aGlzLl9pbmRleEJ1ZmZlcjtcclxuICAgICAgICBjb25zdCBjdXJyZW50TWVzaEluZGV4T2Zmc2V0ID0gdGhpcy5fY3VycmVudE1lc2hJbmRleE9mZnNldDtcclxuICAgICAgICBjb25zdCBjdXJyZW50TWVzaEluZGV4U2l6ZSA9IGluZGV4QnVmZmVyLm9jY3VwaWVkU2l6ZSAtIGN1cnJlbnRNZXNoSW5kZXhPZmZzZXQ7XHJcbiAgICAgICAgbGV0IG5ld0luZGV4QnVmZmVyU2l6ZSA9IHRoaXMuX2luaXRJbmRleEJ1ZmZlclVpbnQxNlNpemU7XHJcbiAgICAgICAgLy8gSW5pdGlhbCBpbmRleCBidWZmZXIgc2l6ZSBtYXkgYmUgdG9vIHNtYWxsIHRvIGFjY29tbW9kYXRlIHRoZSBjdXJyZW50XHJcbiAgICAgICAgLy8gbWVzaCwgc28gd2UgZmluZCBuZXh0IGJpZ2dlciBzaXplIHRoYXQgaXMgc3VmZmljaWVudC5cclxuICAgICAgICB3aGlsZSAobmV3SW5kZXhCdWZmZXJTaXplIDw9IGN1cnJlbnRNZXNoSW5kZXhTaXplKSB7XHJcbiAgICAgICAgICAgIG5ld0luZGV4QnVmZmVyU2l6ZSA9IHRoaXMuX2dldE5leHRJbmRleEJ1ZmZlclVpbnQxNlNpemUobmV3SW5kZXhCdWZmZXJTaXplKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbmV3SW5kZXhCdWZmZXIgPSBuZXcgSW5kZXhCdWZmZXIobmV3SW5kZXhCdWZmZXJTaXplKTtcclxuICAgICAgICAvLyBTaW5jZSB0aGUgY3VycmVudCBtZXNoJ3MgY29waWVkIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIG5ldyB2ZXJ0ZXhcclxuICAgICAgICAvLyBidWZmZXIsIGl0J3MgYmFzZSBpbmRleCBub3cgaXMgMC4gSWYgdGhlIG1lc2ggaGFzIGFueSB3cml0dGVuIGluZGljZXMsXHJcbiAgICAgICAgLy8gdGhleSdyZSBhbHJlYWR5IG9mZnNldCBieSB0aGUgb2xkIGJhc2UgaW5kZXguXHJcbiAgICAgICAgSW5kZXhCdWZmZXIudHJhbnNmZXJEYXRhVGFpbChpbmRleEJ1ZmZlciwgbmV3SW5kZXhCdWZmZXIsIHRoaXMuX2N1cnJlbnRNZXNoQmFzZUluZGV4LCBjdXJyZW50TWVzaEluZGV4T2Zmc2V0KTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50TWVzaEJhc2VJbmRleCA9IDA7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudE1lc2hJbmRleE9mZnNldCA9IDA7XHJcbiAgICAgICAgdGhpcy5faW5kZXhCdWZmZXIgPSBuZXdJbmRleEJ1ZmZlcjtcclxuICAgICAgICB0aGlzLl9pbmRleEJ1ZmZlcnMucHVzaChuZXdJbmRleEJ1ZmZlcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVuc3VyZXMgdGhhdCB0aGUgbWFuYWdlZCBpbmRleCBidWZmZXIgaGFzIGVub3VnaCBzcGFjZSB0byBmaXQgaW4gYSBnaXZlblxyXG4gICAgICogbnVtYmVyIG9mIGluZGljZXMuIEVpdGhlciBkb2VzIG5vdGhpbmcgb3IgcmVzaXplcyB0aGUgY3VycmVudCBpbmRleFxyXG4gICAgICogYnVmZmVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpbmRleENvdW50IE51bWJlciBvZiBpbmRpY2VzIGNsaWVudCB3YW50cyB0byB3cml0ZSB0byB0aGUgbWFuYWdlZFxyXG4gICAgICogICAgICBpbmRleCBidWZmZXIuXHJcbiAgICAgKi9cclxuICAgIF9lbnN1cmVFbm91Z2hJbmRleEJ1ZmZlclNwYWNlKGluZGV4Q291bnQpIHtcclxuICAgICAgICBjb25zdCBidWZmZXIgPSB0aGlzLl9pbmRleEJ1ZmZlcjtcclxuICAgICAgICBjb25zdCByZXF1aXJlZFNpemUgPSBidWZmZXIub2NjdXBpZWRTaXplICsgaW5kZXhDb3VudDtcclxuICAgICAgICBpZiAocmVxdWlyZWRTaXplIDw9IGJ1ZmZlci5zaXplKSB7XHJcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgZW5vdWdoIHNwYWNlIHNvIG5vdGhpbmcgdG8gYmUgZG9uZS5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgbmV3QnVmZmVyU2l6ZSA9IGJ1ZmZlci5zaXplO1xyXG4gICAgICAgIC8vIExldCdzIGNvbXB1dGUgbmV3IGxhcmdlciBzaXplIG9mIHRoZSBpbmRleCBidWZmZXIgdW50aWwgd2UgY2FuXHJcbiAgICAgICAgLy8gYWNjb21tb2RhdGUgaW5jb21pbmcgZGF0YS5cclxuICAgICAgICB3aGlsZSAocmVxdWlyZWRTaXplID4gbmV3QnVmZmVyU2l6ZSkge1xyXG4gICAgICAgICAgICBuZXdCdWZmZXJTaXplID0gdGhpcy5fZ2V0TmV4dEluZGV4QnVmZmVyVWludDE2U2l6ZShuZXdCdWZmZXJTaXplKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5faW5kZXhCdWZmZXIuZXh0ZW5kKG5ld0J1ZmZlclNpemUpO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvYnVmZmVyX3dyaXRlci50c1xuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgUmVmZXJlbmNlQ291bnRlZCBmcm9tICcuLi91dGlsL3JlZl9jb3VudGVkJztcclxuLyoqXHJcbiAqIEJhc2UgY2xhc3MgZm9yIHByaW1pdGl2ZSBvYmplY3RzIHRoYXQgYXJlIHJlYWR5IHRvIGJlIGZlZCB0byB0aGUgcmVuZGVyZXIuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW5kZXJhYmxlUHJpbWl0aXZlIGV4dGVuZHMgUmVmZXJlbmNlQ291bnRlZCB7XHJcbiAgICBjb25zdHJ1Y3RvcihtZW1vcnlTdWJDaHVuaykge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5tZW1vcnlTdWJDaHVuayA9IG1lbW9yeVN1YkNodW5rO1xyXG4gICAgfVxyXG4gICAgX2Rlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5tZW1vcnlTdWJDaHVuay5kZXN0cm95KCk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL3JlbmRlcmFibGVfcHJpbWl0aXZlLnRzXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiBTZWFyY2hlcyBmb3IgdGhlIGZpcnN0IGNvbGxlY3Rpb24gaXRlbSBzYXRpc2Z5aW5nIGEgcHJlZGljYXRlLlxyXG4gKlxyXG4gKiBAcGFyYW0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbi5cclxuICogQHBhcmFtIHByZWRpY2F0ZSBUaGUgcHJlZGljYXRlLlxyXG4gKiBAcmV0dXJucyBUaGUgZmlyc3QgaXRlbSBzYXRpc2Z5aW5nIHRoZSBwcmVkaWNhdGUgb3IgYHVuZGVmaW5lZGAgaWYgbm9uZSBmb3VuZC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBmaW5kSW5JdGVyYWJsZShjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcclxuICAgIGZvciAoY29uc3QgaXRlbSBvZiBjb2xsZWN0aW9uKSB7XHJcbiAgICAgICAgaWYgKHByZWRpY2F0ZShpdGVtKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm47XHJcbn1cclxuLyoqXHJcbiAqIFRyYW5zZm9ybXMgYSBjb2xsZWN0aW9uIHRvIGFub3RoZXIgb25lLlxyXG4gKlxyXG4gKiBAcGFyYW0gY29sbGVjdGlvbiBUaGUgc291cmNlIGNvbGxlY3Rpb24uXHJcbiAqIEBwYXJhbSBtYXBwZXIgQSBmdW5jdGlvbiBwcm9kdWNpbmcgaXRlbXMgZm9yIGRlc3RpbmF0aW9uIGNvbGxlY3Rpb24uXHJcbiAqIEByZXR1cm5zIENvbGxlY3Rpb24gb2YgcHJvZHVjZWQgaXRlbXMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24qIG1hcEl0ZXJhYmxlKGNvbGxlY3Rpb24sIG1hcHBlcikge1xyXG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGNvbGxlY3Rpb24pIHtcclxuICAgICAgICB5aWVsZCBtYXBwZXIoaXRlbSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENob29zZXMgaXRlbXMgb2YgYSBjb2xsZWN0aW9uIHNhdGlzZnlpbmcgYSBwcmVkaWNhdGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uLlxyXG4gKiBAcGFyYW0gcHJlZGljYXRlIFRoZSBwcmVkaWNhdGUuXHJcbiAqIEByZXR1cm5zIENvbGxlY3Rpb24gb2YgY2hvc2VuIGl0ZW1zLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uKiBmaWx0ZXJJdGVyYWJsZShjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcclxuICAgIGZvciAoY29uc3QgaXRlbSBvZiBjb2xsZWN0aW9uKSB7XHJcbiAgICAgICAgaWYgKHByZWRpY2F0ZShpdGVtKSkge1xyXG4gICAgICAgICAgICB5aWVsZCBpdGVtO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogVHJhdmVyc2VzIGEgY29sbGVjdGlvbiBmcm9tIGxlZnQgdG8gcmlnaHQgcmVjb21wdXRpbmcgYW4gYWNjdW11bGF0b3Igb24gZXZlcnlcclxuICogaXRlcmF0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbi5cclxuICogQHBhcmFtIHJlZHVjZXIgVGhlIGZ1bmN0aW9uIHVzZWQgdG8gY29tcHV0ZSBuZXh0IHZhbHVlIG9mIHRoZSBhY2N1bXVsYXRvci5cclxuICogQHBhcmFtIGluaXRpYWxcclxuICogQHJldHVybnMgVmFsdWUgb2YgdGhlIGFjY3VtdWxhdG9yLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHJlZHVjZUl0ZXJhYmxlKGNvbGxlY3Rpb24sIHJlZHVjZXIsIGluaXRpYWwpIHtcclxuICAgIGxldCByZXN1bHQgPSBpbml0aWFsO1xyXG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGNvbGxlY3Rpb24pIHtcclxuICAgICAgICByZXN1bHQgPSByZWR1Y2VyKHJlc3VsdCwgaXRlbSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgdGhlcmUncyBhdCBsZWFzdCBvbmUgaXRlbSBpbiBhIGNvbGxlY3Rpb24gc2F0aXNmeWluZyBhIHByZWRpY2F0ZS5cclxuICpcclxuICogQHBhcmFtIGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24uXHJcbiAqIEBwYXJhbSBwcmVkaWNhdGUgVGhlIHByZWRpY2F0ZS5cclxuICogQHJldHVybnMgYHRydWVgIGlmIGZvciBhdCBsZWFzdCBvbmUgaXRlbSBpbiB0aGUgY29sbGVjdGlvbiB0aGUgcHJlZGljYXRlIHJldHVybnNcclxuICogICAgICBgdHJ1ZWAgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG9uZU9mSXRlcmFibGUoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XHJcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgY29sbGVjdGlvbikge1xyXG4gICAgICAgIGlmIChwcmVkaWNhdGUoaXRlbSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYWxsIGl0ZW1zIG9mIGEgY29sbGVjdGlvbiBzYXRpc2Z5IGEgcHJlZGljYXRlLlxyXG4gKlxyXG4gKiBAcGFyYW0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbi5cclxuICogQHBhcmFtIHByZWRpY2F0ZSBUaGUgcHJlZGljYXRlLlxyXG4gKiBAcmV0dXJucyBgZmFsc2VgIGlmIGZvciBhdCBsZWFzdCBvbmUgaXRlbSBpbiB0aGUgY29sbGVjdGlvbiB0aGUgcHJlZGljYXRlIHJldHVybnNcclxuICogICAgICBgZmFsc2VgIGFuZCBgdHJ1ZWAgb3RoZXJ3aXNlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGFsbE9mSXRlcmFibGUoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XHJcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgY29sbGVjdGlvbikge1xyXG4gICAgICAgIGlmICghcHJlZGljYXRlKGl0ZW0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhbiBpdGVyYXRvciBmb3IgW3N0YXJ0SW5kZXgsIHN0YXJ0SW5kZXgrbGVuZ3RoKSByYW5nZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiogcmFuZ2VJdGVyYWJsZShsZW5ndGgsIHN0YXJ0SW5kZXggPSAwKSB7XHJcbiAgICBjb25zdCBlbmRJbmRleCA9IHN0YXJ0SW5kZXggKyBsZW5ndGg7XHJcbiAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSA8IGVuZEluZGV4OyBpKyspIHtcclxuICAgICAgICB5aWVsZCBpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiogemlwSXRlcmFibGVzKHRzLCB1cywgemlwcGVyID0gKHQsIHUpID0+IFt0LCB1XSkge1xyXG4gICAgY29uc3QgdEl0ZXJhdG9yID0gdHNbU3ltYm9sLml0ZXJhdG9yXSgpO1xyXG4gICAgY29uc3QgdUl0ZXJhdG9yID0gdXNbU3ltYm9sLml0ZXJhdG9yXSgpO1xyXG4gICAgZm9yIChsZXQgdCA9IHRJdGVyYXRvci5uZXh0KCksIHUgPSB1SXRlcmF0b3IubmV4dCgpOyAhKHQuZG9uZSB8fCB1LmRvbmUpOyB0ID0gdEl0ZXJhdG9yLm5leHQoKSwgdSA9IHVJdGVyYXRvci5uZXh0KCkpIHtcclxuICAgICAgICB5aWVsZCB6aXBwZXIodC52YWx1ZSwgdS52YWx1ZSk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9pdGVyYWJsZS50c1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICogQ2xhbXBzIGEgdmFsdWUgdG8gYSBnaXZlbiByYW5nZS5cclxuICpcclxuICogQHBhcmFtIHggVGhlIHZhbHVlLlxyXG4gKiBAcGFyYW0gbWluIFN0YXJ0IG9mIHRoZSByYW5nZS5cclxuICogQHBhcmFtIG1heCBFbmQgb2YgdGhlIHJhbmdlLlxyXG4gKiBAcmV0dXJucyBDbGFtcGVkIHZhbHVlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNsYW1wKHgsIG1pbiwgbWF4KSB7XHJcbiAgICByZXR1cm4gbWluIDwgeCA/IHggPCBtYXggPyB4IDogbWF4IDogbWluO1xyXG59XHJcbi8qKlxyXG4gKiBSZXN0cmljdHMgYSB2YWx1ZSB0byBhIGdpdmVuIGN5Y2xlZCByYW5nZSwgaS5lLiBlbmRzIG9mIHRoZSByYW5nZSBhcmVcclxuICogZXF1aXZhbGVudC4gRS5nLiBsaWtlIGFuZ2xlcyBjYW4gYmUgcmVzdHJpY3RlZCB0byBhbnkgcmFuZ2Ugb2Ygc2l6ZSBgMiAqIFBJYC5cclxuICpcclxuICogQHBhcmFtIHggVGhlIHZhbHVlLlxyXG4gKiBAcGFyYW0gbWluIFN0YXJ0IG9mIHRoZSByYW5nZS5cclxuICogQHBhcmFtIG1heCBFbmQgb2YgdGhlIHJhbmdlLlxyXG4gKiBAcmV0dXJucyBSZXN0cmljdGVkIHZhbHVlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGN5Y2xlUmVzdHJpY3QoeCwgbWluLCBtYXgpIHtcclxuICAgIGNvbnN0IGQgPSBtYXggLSBtaW47XHJcbiAgICBjb25zdCBzID0gKHggLSBtaW4pIC8gKG1heCAtIG1pbik7XHJcbiAgICByZXR1cm4gbWluICsgZCAqIChzIC0gTWF0aC5mbG9vcihzKSk7XHJcbn1cclxuLyoqXHJcbiAqIExpbmVhciBpbnRlcnBvbGF0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0gbWluIFZhbHVlIHRoYXQgY29ycmVzcG9uZCB0byAwJSBwcm9ncmVzcy5cclxuICogQHBhcmFtIG1heCBWYWx1ZSB0aGF0IGNvcnJlc3BvbmQgdG8gMTAwJSBwcm9ncmVzcy5cclxuICogQHBhcmFtIHByb2dyZXNzIEluIDAuLjEuMCByYW5nZSB0aGF0IG1hcHMgdG8gMC4uMTAwJSBwcm9ncmVzcy4gSXQgaXMgYWxsb3dlZCB0byBwYXNzIGEgdmFsdWVcclxuICogICAgICBvdXRzaWRlIG9mIHRoaXMgcmFuZ2UsIHRoYXQgbWVhbnMgcHJvZ3Jlc3MgZ3JlYXRlciB0aGVuIDEwMCUgb3IgbmVnYXRpdmUgcHJvZ3Jlc3MuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbWl4KG1pbiwgbWF4LCBwcm9ncmVzcykge1xyXG4gICAgcmV0dXJuICgxIC0gcHJvZ3Jlc3MpICogbWluICsgcHJvZ3Jlc3MgKiBtYXg7XHJcbn1cclxuLyoqXHJcbiAqIEEgc3RlcCBmdW5jdGlvbiB3aXRoIGEgc21vb3RoIHRyYW5zaXRpb24gYmV0d2VlbiBnaXZlbiBlZGdlcy4gQ29tcGxldGVseVxyXG4gKiBhbmFsb2dvdXMgdG8gYHNtb290aHN0ZXBgIGluIEdMU0wgKEdMU0wgRVMgMS4wIMKnOC4zKS5cclxuICpcclxuICogQHBhcmFtIGVkZ2UxIFRoZSBzbWFsbGVyIGVkZ2UuXHJcbiAqIEBwYXJhbSBlZGdlMlxyXG4gKiBAcGFyYW0geCBgMGAgaWYgYHggPCBlZGdlMWAsIGAxYCBpZiBgeCA+IGVkZ2UyYCBhbmQgYW4gaW50ZXJwb2xhdGVkIHZhbHVlIGZvclxyXG4gKiAgICAgIGBlZGdlMSA8IHggPCBlZGdlMmAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc21vb3RoU3RlcChlZGdlMSwgZWRnZTIsIHgpIHtcclxuICAgIGNvbnN0IGZhY3RvciA9IGNsYW1wKCh4IC0gZWRnZTEpIC8gKGVkZ2UyIC0gZWRnZTEpLCAwLCAxKTtcclxuICAgIHJldHVybiBmYWN0b3IgKiBmYWN0b3IgKiAoMyAtIDIgKiBmYWN0b3IpO1xyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL21hdGgvc2NhbGFyLnRzXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiBHaXZlcyB0aGUgZGV2aWNlIHBpeGVsIHJhdGlvbiBpZiBpdCdzIGdyZWF0ZXIgdGhhbiAxIGFuZCAxIG90aGVyd2lzZS4gVGhpcydzXHJcbiAqIGhlcmUgcHVyZWx5IHRvIGJlIGNvbXBhdGlibGUgd2l0aCBqc2FwaSB3aGljaCBkb2VzIHRoZSBzYW1lIHRoaW5nIGZvciByZWFzb25zXHJcbiAqIHVua25vd3MgKHRoYW5rcywga2FzaGV5KS5cclxuICpcclxuICogQHJldHVybnMgQ2FwcGVkIGRldmljZSBwaXhlbCByYXRpby5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldERwcigpIHtcclxuICAgIHJldHVybiBkZXZpY2VQaXhlbFJhdGlvID4gMSA/IGRldmljZVBpeGVsUmF0aW8gOiAxO1xyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvaGQudHNcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydCBjb25zdCBPUEFRVUVfQkxBQ0sgPSBjcmVhdGUoMCwgMCwgMCwgMSk7XHJcbmV4cG9ydCBjb25zdCBUUkFOU1BBUkVOVF9CTEFDSyA9IGNyZWF0ZSgwLCAwLCAwLCAwKTtcclxuLyoqXHJcbiAqIEBwYXJhbSByIFJlZCBjb21wb25lbnQgYXMgYSBub3JtYWxpemVkIHZhbHVlIFswLi4xXVxyXG4gKiBAcGFyYW0gZyBHcmVlbiBjb21wb25lbnQgYXMgYSBub3JtYWxpemVkIHZhbHVlIFswLi4xXVxyXG4gKiBAcGFyYW0gYiBCbHVlIGNvbXBvbmVudCBhcyBhIG5vcm1hbGl6ZWQgdmFsdWUgWzAuLjFdXHJcbiAqIEBwYXJhbSBhIEFscGhhIGNvbXBvbmVudCBhcyBhIG5vcm1hbGl6ZWQgdmFsdWUgWzAuLjFdXHJcbiAqXHJcbiAqIEByZXR1cm5zIEEgY29sb3Igd2l0aCBnaXZlbiB2YWx1ZXMgYXNzaWduZWQgdG8gY29tcG9uZW50cy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUociwgZywgYiwgYSA9IDEpIHtcclxuICAgIHJldHVybiB7IHIsIGcsIGIsIGEgfTtcclxufVxyXG4vKipcclxuICogQ29waWVzIGEgY29sb3IgdG8gYW5vdGhlciBvbmUuXHJcbiAqXHJcbiAqIEBwYXJhbSBzcmMgVGhlIHNvdXJjZSBjb2xvci5cclxuICogQHBhcmFtIGRzdCBUaGUgY29sb3IgdGhlIHNvdXJjZSBjb2xvciB3aWxsIGJlIGNvcGllZCB0by5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29weShzcmMsIGRzdCA9IGNyZWF0ZSgwLCAwLCAwLCAwKSkge1xyXG4gICAgZHN0LnIgPSBzcmMucjtcclxuICAgIGRzdC5nID0gc3JjLmc7XHJcbiAgICBkc3QuYiA9IHNyYy5iO1xyXG4gICAgZHN0LmEgPSBzcmMuYTtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGFyZUVxdWFsKGMxLCBjMikge1xyXG4gICAgcmV0dXJuIGMxLnIgPT09IGMyLnIgJiYgYzEuZyA9PT0gYzIuZyAmJiBjMS5iID09PSBjMi5iICYmIGMxLmEgPT09IGMyLmE7XHJcbn1cclxuLyoqXHJcbiAqIERlY29kZXMgYSBjb2xvciByZXByZXNlbnRlZCBhcyBmb3VyIDgtYml0IGNoYW5uZWxzIGVuY29kZWQgaW50byBhIDMyLWJpdFxyXG4gKiBudW1iZXIgaW4gQUJHUiBvcmRlciAoZnJvbSBNU0IgdG8gTFNCKS5cclxuICpcclxuICogQHBhcmFtIGNvbG9yIENvbG9yIGVuY29kZWQgaW50byB1bnNpZ25lZCAzMi1iaXQgaW50ZWdlci5cclxuICogQHJldHVybnMgRGVjb2RlZCBjb2xvci5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVBYmdyOChjb2xvcikge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByOiAoY29sb3IgPj4+IDI0KSAvIDB4ZmYsXHJcbiAgICAgICAgZzogKGNvbG9yID4+PiAxNiAmIDB4ZmYpIC8gMHhmZixcclxuICAgICAgICBiOiAoY29sb3IgPj4+IDggJiAweGZmKSAvIDB4ZmYsXHJcbiAgICAgICAgYTogKGNvbG9yICYgMHhmZikgLyAweGZmXHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBFbmNvZGVzIGEgY29sb3IgY29tcG9uZW50cyBpbnRvIGZvdXIgOCBiaXQgbnVtYmVycyBwYWNrZWQgaW50byAzMi1iaXQgb25lLlxyXG4gKlxyXG4gKiBAcGFyYW0gYyBUaGUgY29sb3IgdG8gYmUgZW5jb2RlZC5cclxuICogQHJldHVybnMgVGhlIGNvbG9yIGFzIDMyLWJpdCBpbnRlZ2VyLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZVJnYmE4KGMpIHtcclxuICAgIHJldHVybiAoYy5yICogMHhmZiB8XHJcbiAgICAgICAgKGMuZyAqIDB4ZmYgPDwgOCkgfFxyXG4gICAgICAgIChjLmIgKiAweGZmIDw8IDE2KSB8XHJcbiAgICAgICAgKGMuYSAqIDB4ZmYgPDwgMjQpKTtcclxufVxyXG4vKipcclxuICogQ2hlY2tzIGlmIGEgY29sb3IgaXMgY29tcGxldGVseSBvcGFxdWUuXHJcbiAqXHJcbiAqIEBwYXJhbSBjb2xvciBUaGUgY29sb3IgdG8gYmUgY2hlY2tlZC5cclxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBjb2xvciBpcyBvcGFxdWUgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzT3BhcXVlKGNvbG9yKSB7XHJcbiAgICByZXR1cm4gY29sb3IuYSA9PT0gMTtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL2NvbG9yLnRzXG4vLyBtb2R1bGUgaWQgPSAxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgKiBhcyBtYXRyaXgzIGZyb20gJy4vbWF0cml4Myc7XHJcbmltcG9ydCBhcmVGdXp6eUVxdWFsU2NhbGFyLCB7IERFRkFVTFRfVE9MRVJBTkNFIH0gZnJvbSAnLi4vdXRpbC9mdXp6eV9lcXVhbCc7XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IHZlY3RvciBhbmQgaW5pdGlhbGl6ZXMgaXQgd2l0aCBnaXZlbiBjb21wb25lbnRzLlxyXG4gKlxyXG4gKiBAcGFyYW0geCBYIGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yLlxyXG4gKiBAcGFyYW0geSBZIGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yLlxyXG4gKiBAcGFyYW0geiBaIGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yLlxyXG4gKiBAcmV0dXJucyBUaGUgdmVjdG9yLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSh4LCB5LCB6KSB7XHJcbiAgICByZXR1cm4geyB4LCB5LCB6IH07XHJcbn1cclxuZXhwb3J0IGNvbnN0IE9SSUdJTiA9IGNyZWF0ZSgwLCAwLCAwKTtcclxuZXhwb3J0IGNvbnN0IFBPU0lUSVZFX1ggPSBjcmVhdGUoMSwgMCwgMCk7XHJcbmV4cG9ydCBjb25zdCBORUdBVElWRV9YID0gY3JlYXRlKC0xLCAwLCAwKTtcclxuZXhwb3J0IGNvbnN0IFBPU0lUSVZFX1kgPSBjcmVhdGUoMCwgMSwgMCk7XHJcbmV4cG9ydCBjb25zdCBORUdBVElWRV9ZID0gY3JlYXRlKDAsIC0xLCAwKTtcclxuZXhwb3J0IGNvbnN0IFBPU0lUSVZFX1ogPSBjcmVhdGUoMCwgMCwgMSk7XHJcbmV4cG9ydCBjb25zdCBORUdBVElWRV9aID0gY3JlYXRlKDAsIDAsIC0xKTtcclxuLyoqXHJcbiAqIENvcGllcyBhIHZlY3RvciB0byBhbm90aGVyIG9uZS5cclxuICpcclxuICogQHBhcmFtIHNyYyBUaGUgc291cmNlIHZlY3Rvci5cclxuICogQHBhcmFtIGRzdCBUaGUgdmVjdG9yIHRoZSBzb3VyY2UgdmVjdG9yIHdpbGwgYmUgY29waWVkIHRvLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb3B5KHNyYywgZHN0ID0gY3JlYXRlKDAsIDAsIDApKSB7XHJcbiAgICBkc3QueCA9IHNyYy54O1xyXG4gICAgZHN0LnkgPSBzcmMueTtcclxuICAgIGRzdC56ID0gc3JjLno7XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgdHdvIHZlY3RvcnMgYXJlIHN0cmljdGx5IGVxdWFsIGNvbXBvbmVudC13aXNlLlxyXG4gKlxyXG4gKiBAcGFyYW0gdjEgVGhlIGZpcnN0IHZlY3Rvci5cclxuICogQHBhcmFtIHYyIFRoZSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsIGFuZCBgZmFsc2VgIG90aGVyd2lzZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBhcmVFcXVhbCh2MSwgdjIpIHtcclxuICAgIHJldHVybiB2MS54ID09PSB2Mi54ICYmIHYxLnkgPT09IHYyLnkgJiYgdjEueiA9PT0gdjIuejtcclxufVxyXG4vKipcclxuICogQ2hlY2tzIGlmIGNvcnJlc3BvbmRpbmcgY29tcG9uZW50cyBvZiB0d28gdmVjdG9ycyBhcmUgYWxsIHdpdGhpbiBnaXZlblxyXG4gKiB0b2xlcmFuY2UgZnJvbSBlYWNoIG90aGVyLlxyXG4gKlxyXG4gKiBAcGFyYW0gdjEgVGhlIGZpcnN0IHZlY3Rvci5cclxuICogQHBhcmFtIHYyIFRoZSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBAcGFyYW0gdG9sZXJhbmNlIFRoZSB0b2xlcmFuY2UuXHJcbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmVjdG9ycyBhcmUgXCJmdXp6eVwiIGVxdWFsIGFuZCBgZmFsc2VgIG90aGVyd2lzZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBhcmVGdXp6eUVxdWFsKHYxLCB2MiwgdG9sZXJhbmNlID0gREVGQVVMVF9UT0xFUkFOQ0UpIHtcclxuICAgIHJldHVybiAoYXJlRnV6enlFcXVhbFNjYWxhcih2MS54LCB2Mi54LCB0b2xlcmFuY2UpICYmXHJcbiAgICAgICAgYXJlRnV6enlFcXVhbFNjYWxhcih2MS55LCB2Mi55LCB0b2xlcmFuY2UpICYmXHJcbiAgICAgICAgYXJlRnV6enlFcXVhbFNjYWxhcih2MS56LCB2Mi56LCB0b2xlcmFuY2UpKTtcclxufVxyXG4vKipcclxuICogQ2hlY2tzIGlmIHR3byB2ZWN0b3JzIGFyZSBjb2xsaW5lYXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB2MSBUaGUgZmlyc3QgdmVjdG9yLlxyXG4gKiBAcGFyYW0gdjIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmVjdG9ycyBhcmUgY29sbGluZWFyIGFuZCBgZmFsc2VgIG90aGVyd2lzZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBhcmVDb2xsaW5lYXIodjEsIHYyKSB7XHJcbiAgICBjb25zdCBsYW1iZGFYID0gdjEueCAvIHYyLng7XHJcbiAgICBjb25zdCBsYW1iZGFZID0gdjEueSAvIHYyLnk7XHJcbiAgICBjb25zdCBsYW1iZGFaID0gdjEueiAvIHYyLno7XHJcbiAgICByZXR1cm4gbGFtYmRhWCA9PT0gbGFtYmRhWSAmJiBsYW1iZGFZID09PSBsYW1iZGFaO1xyXG59XHJcbi8qKlxyXG4gKiBBZGRzIHR3byB2ZWN0b3IgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGludG8gYSB0aGlyZCBvbmUsIGkuZS4gYGRzdCA9IGEgKyBiYC5cclxuICpcclxuICogQHBhcmFtIGEgVGhlIGZpcnN0IHZlY3Rvci5cclxuICogQHBhcmFtIGIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBkc3QgVGhlIHZlY3RvciB0aGUgcmVzdWx0IHdpbGwgYmUgc3RvcmVkIHRvLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBhZGQoYSwgYiwgZHN0ID0gY3JlYXRlKDAsIDAsIDApKSB7XHJcbiAgICBkc3QueCA9IGEueCArIGIueDtcclxuICAgIGRzdC55ID0gYS55ICsgYi55O1xyXG4gICAgZHN0LnogPSBhLnogKyBiLno7XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbi8qKlxyXG4gKiBTdWJ0cmFjdHMgYSB2ZWN0b3IgZnJvbSBhbm90aGVyIG9uZSBhbmQgc3RvcmVzIHRoZSByZXN1bHQgdG8gYSB0aGlyZCBvbmUsIGkuZS5cclxuICogYGRzdCA9IGEgLSBiYC5cclxuICpcclxuICogQHBhcmFtIGEgVGhlIG1pbnVlbmQgdmVjdG9yLlxyXG4gKiBAcGFyYW0gYiBUaGUgc3VidHJhaGVuZCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBkc3QgVGhlIHZlY3RvciB0aGUgcmVzdWx0IHdpbGwgYmUgc3RvcmVkIHRvLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHN1YihhLCBiLCBkc3QgPSBjcmVhdGUoMCwgMCwgMCkpIHtcclxuICAgIGRzdC54ID0gYS54IC0gYi54O1xyXG4gICAgZHN0LnkgPSBhLnkgLSBiLnk7XHJcbiAgICBkc3QueiA9IGEueiAtIGIuejtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIE11bHRpcGxpZXMgdHdvIHZlY3RvcnMgY29tcG9uZW50LXdpc2UgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGludG8gYSB0aGlyZCBvbmUuXHJcbiAqXHJcbiAqIEBwYXJhbSBhIFRoZSBmaXJzdCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSB2ZWN0b3IgdGhlIHJlc3VsdCB3aWxsIGJlIHN0b3JlZCB0by5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbXVsdihhLCBiLCBkc3QgPSBjcmVhdGUoMCwgMCwgMCkpIHtcclxuICAgIGRzdC54ID0gYS54ICogYi54O1xyXG4gICAgZHN0LnkgPSBhLnkgKiBiLnk7XHJcbiAgICBkc3QueiA9IGEueiAqIGIuejtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIE11bHRpcGxpZXMgYSB2ZWN0b3IgYnkgYSBzY2FsYXIgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGludG8gYSB0aGlyZCB2ZWN0b3IuXHJcbiAqXHJcbiAqIEBwYXJhbSBhIFRoZSB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBuIFRoZSBzY2FsYXIuXHJcbiAqIEBwYXJhbSBkc3QgVGhlIHZlY3RvciB0aGUgcmVzdWx0IHdpbGwgYmUgc3RvcmVkIHRvLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBtdWxuKGEsIG4sIGRzdCA9IGNyZWF0ZSgwLCAwLCAwKSkge1xyXG4gICAgZHN0LnggPSBhLnggKiBuO1xyXG4gICAgZHN0LnkgPSBhLnkgKiBuO1xyXG4gICAgZHN0LnogPSBhLnogKiBuO1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogRGl2aWRlcyBhIHZlY3RvciBieSBhbm90aGVyIG9uZSBjb21wb25lbnQgd2lzZSBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW50byBhXHJcbiAqIHRoaXJkIG9uZS5cclxuICpcclxuICogQHBhcmFtIGEgVGhlIGRpdmlkZW5kIHZlY3Rvci5cclxuICogQHBhcmFtIGIgVGhlIGRpdmlzb3IgdmVjdG9yLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSB2ZWN0b3IgdGhlIHJlc3VsdCB3aWxsIGJlIHN0b3JlZCB0by5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZGl2dihhLCBiLCBkc3QgPSBjcmVhdGUoMCwgMCwgMCkpIHtcclxuICAgIGRzdC54ID0gYS54IC8gYi54O1xyXG4gICAgZHN0LnkgPSBhLnkgLyBiLnk7XHJcbiAgICBkc3QueiA9IGEueiAvIGIuejtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIERpdmlkZXMgYSB2ZWN0b3IgYnkgYSBzY2FsYXIgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGludG8gYSB0aGlyZCB2ZWN0b3IuXHJcbiAqXHJcbiAqIEBwYXJhbSBhIFRoZSBkaXZpZGVuZCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBuIFRoZSBzY2FsYXIuXHJcbiAqIEBwYXJhbSBkc3QgVGhlIHZlY3RvciB0aGUgcmVzdWx0IHdpbGwgYmUgc3RvcmVkIHRvLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBkaXZuKGEsIG4sIGRzdCA9IGNyZWF0ZSgwLCAwLCAwKSkge1xyXG4gICAgZHN0LnggPSBhLnggLyBuO1xyXG4gICAgZHN0LnkgPSBhLnkgLyBuO1xyXG4gICAgZHN0LnogPSBhLnogLyBuO1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogQ29tcHV0ZXMgbGVuZ3RoIG9mIGEgdmVjdG9yLlxyXG4gKlxyXG4gKiBAcGFyYW0gdiBUaGUgdmVjdG9yLlxyXG4gKiBAcmV0dXJucyBUaGUgbGVuZ3RoLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGxlbmd0aCh2KSB7XHJcbiAgICByZXR1cm4gTWF0aC5oeXBvdCh2LngsIHYueSwgdi56KTtcclxufVxyXG4vKipcclxuICogQ29tcHV0ZXMgZGlzdGFuY2UgYmV0d2VlbiBlbmRzIG9mIHR3byB2ZWN0b3JzLlxyXG4gKlxyXG4gKiBAcGFyYW0gYSBUaGUgZmlyc3QgdmVjdG9yLlxyXG4gKiBAcGFyYW0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cclxuICogQHJldHVybnMgVGhlIGRpc3RhbmNlLCBpLmUuIGBsZW5ndGgoc3ViKGEsIGIpKWAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZGlzdGFuY2UoYSwgYikge1xyXG4gICAgcmV0dXJuIE1hdGguaHlwb3QoYS54IC0gYi54LCBhLnkgLSBiLnksIGEueiAtIGIueik7XHJcbn1cclxuLyoqXHJcbiAqIERpdmlkZXMgYSB2ZWN0b3IgYnkgaXRzIGxlbmd0aCAodGh1cyBtYWtpbmcgaXQgYSB1bml0IHZlY3RvcikgYW5kIHN0b3JlcyB0aGVcclxuICogcmVzdWx0IHRvIGFub3RoZXIgb25lLlxyXG4gKlxyXG4gKiBAcGFyYW0gdiBUaGUgdmVjdG9yIHRvIGJlIG5vcm1hbGl6ZWQuXHJcbiAqIEBwYXJhbSBkc3QgVGhlIHZlY3RvciB0aGUgcmVzdWx0IHdpbGwgYmUgc3RvcmVkIHRvLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUodiwgZHN0ID0gY3JlYXRlKDAsIDAsIDApKSB7XHJcbiAgICByZXR1cm4gZGl2bih2LCBsZW5ndGgodiksIGRzdCk7XHJcbn1cclxuLyoqXHJcbiAqIENvbXB1dGVzIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWN0b3JzLlxyXG4gKlxyXG4gKiBAcGFyYW0gYSBUaGUgZmlyc3QgdmVjdG9yLlxyXG4gKiBAcGFyYW0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cclxuICogQHJldHVybnMgVGhlIGRvdCBwcm9kdWN0LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRvdChhLCBiKSB7XHJcbiAgICByZXR1cm4gYS54ICogYi54ICsgYS55ICogYi55ICsgYS56ICogYi56O1xyXG59XHJcbi8qKlxyXG4gKiBDb21wdXRlcyBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWN0b3JzIGFuZCBzdG9yZXMgaXQgdG8gYSB0aGlyZCBvbmUuXHJcbiAqXHJcbiAqIEBwYXJhbSBhIFRoZSBmaXJzdCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSB2ZWN0b3IgdGhlIHJlc3VsdCB3aWxsIGJlIHN0b3JlZCB0by5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY3Jvc3MoYSwgYiwgZHN0ID0gY3JlYXRlKDAsIDAsIDApKSB7XHJcbiAgICAvLyBXcml0ZSBjb21wb25lbnRzIHRvIGEgc2VwYXJhdGUgdmFyaWFibGVzIHNvIHdlIGRvbid0IHByb2R1Y2UgaW5jb3JyZWN0XHJcbiAgICAvLyByZXN1bHRzIGluIGNhc2VzIHdoZW4gYSA9PSBkc3Qgb3IgYiA9PSBkc3QuXHJcbiAgICBjb25zdCB4ID0gYS55ICogYi56IC0gYS56ICogYi55O1xyXG4gICAgY29uc3QgeSA9IGEueiAqIGIueCAtIGEueCAqIGIuejtcclxuICAgIGNvbnN0IHogPSBhLnggKiBiLnkgLSBhLnkgKiBiLng7XHJcbiAgICBkc3QueCA9IHg7XHJcbiAgICBkc3QueSA9IHk7XHJcbiAgICBkc3QueiA9IHo7XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbi8qKlxyXG4gKiBSb3RhdGVzIHZlY3RvciBhYm91dCB0aGUgWCBheGlzLlxyXG4gKlxyXG4gKiBAcGFyYW0gdiBUaGUgdmVjdG9yIHRvIGJlIHJvdGF0ZWQuXHJcbiAqIEBwYXJhbSBhbmdsZSBUaGUgYW5nbGUgb2Ygcm90YXRpb24gKGluIHJhZGlhbnMpLCBwb3NpdGl2ZSB2YWx1ZXMgcm90YXRlcyBmcm9tICtZIHRvICtaXHJcbiAqIEBwYXJhbSBkc3QgVGhlIHZlY3RvciB0aGUgcmVzdWx0IHdpbGwgYmUgc3RvcmVkIHRvLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVgodiwgYW5nbGUsIGRzdCA9IGNyZWF0ZSgwLCAwLCAwKSkge1xyXG4gICAgY29uc3QgY29zID0gTWF0aC5jb3MoYW5nbGUpO1xyXG4gICAgY29uc3Qgc2luID0gTWF0aC5zaW4oYW5nbGUpO1xyXG4gICAgY29uc3QgeSA9IHYueTtcclxuICAgIGRzdC54ID0gdi54O1xyXG4gICAgZHN0LnkgPSB5ICogY29zIC0gdi56ICogc2luO1xyXG4gICAgZHN0LnogPSB5ICogc2luICsgdi56ICogY29zO1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogUm90YXRlcyB2ZWN0b3IgYWJvdXQgdGhlIFkgYXhpcy5cclxuICpcclxuICogQHBhcmFtIHYgVGhlIHZlY3RvciB0byBiZSByb3RhdGVkLlxyXG4gKiBAcGFyYW0gYW5nbGUgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uIChpbiByYWRpYW5zKSwgcG9zaXRpdmUgdmFsdWVzIHJvdGF0ZXMgZnJvbSArWCB0byArWlxyXG4gKiBAcGFyYW0gZHN0IFRoZSB2ZWN0b3IgdGhlIHJlc3VsdCB3aWxsIGJlIHN0b3JlZCB0by5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVZKHYsIGFuZ2xlLCBkc3QgPSBjcmVhdGUoMCwgMCwgMCkpIHtcclxuICAgIGNvbnN0IGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcclxuICAgIGNvbnN0IHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcclxuICAgIC8vIGhhbmRsZSB0aGUgY2FzZSB3aGVuIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gYXJlIHRoZSBzYW1lIG9iamVjdDogcmVsYXRlZCBjb21wb25lbnRzIGNhbiBicmVhayBlYWNoIG90aGVyXHJcbiAgICB2ID0gKHYgPT09IGRzdCkgPyBjb3B5KHYpIDogdjtcclxuICAgIGRzdC54ID0gdi54ICogY29zICsgdi56ICogc2luO1xyXG4gICAgZHN0LnkgPSB2Lnk7XHJcbiAgICBkc3QueiA9IC12LnggKiBzaW4gKyB2LnogKiBjb3M7XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbi8qKlxyXG4gKiBSb3RhdGVzIHZlY3RvciBhYm91dCB0aGUgWiBheGlzLlxyXG4gKlxyXG4gKiBAcGFyYW0gdiBUaGUgdmVjdG9yIHRvIGJlIHJvdGF0ZWQuXHJcbiAqIEBwYXJhbSBhbmdsZSBUaGUgYW5nbGUgb2Ygcm90YXRpb24gKGluIHJhZGlhbnMpLCBwb3NpdGl2ZSB2YWx1ZXMgcm90YXRlcyBmcm9tICtYIHRvICtZXHJcbiAqIEBwYXJhbSBkc3QgVGhlIHZlY3RvciB0aGUgcmVzdWx0IHdpbGwgYmUgc3RvcmVkIHRvLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVoodiwgYW5nbGUsIGRzdCA9IGNyZWF0ZSgwLCAwLCAwKSkge1xyXG4gICAgY29uc3QgY29zID0gTWF0aC5jb3MoYW5nbGUpO1xyXG4gICAgY29uc3Qgc2luID0gTWF0aC5zaW4oYW5nbGUpO1xyXG4gICAgLy8gaGFuZGxlIHRoZSBjYXNlIHdoZW4gc291cmNlIGFuZCBkZXN0aW5hdGlvbiBhcmUgdGhlIHNhbWUgb2JqZWN0OiByZWxhdGVkIGNvbXBvbmVudHMgY2FuIGJyZWFrIGVhY2ggb3RoZXJcclxuICAgIHYgPSAodiA9PT0gZHN0KSA/IGNvcHkodikgOiB2O1xyXG4gICAgZHN0LnggPSB2LnggKiBjb3MgLSB2LnkgKiBzaW47XHJcbiAgICBkc3QueSA9IHYueCAqIHNpbiArIHYueSAqIGNvcztcclxuICAgIGRzdC56ID0gdi56O1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG5leHBvcnQgY29uc3QgWF9BWElTID0ge1xyXG4gICAgb3JpZ2luOiBPUklHSU4sXHJcbiAgICB0YW5nZW50OiBQT1NJVElWRV9YXHJcbn07XHJcbmV4cG9ydCBjb25zdCBZX0FYSVMgPSB7XHJcbiAgICBvcmlnaW46IE9SSUdJTixcclxuICAgIHRhbmdlbnQ6IFBPU0lUSVZFX1lcclxufTtcclxuZXhwb3J0IGNvbnN0IFpfQVhJUyA9IHtcclxuICAgIG9yaWdpbjogT1JJR0lOLFxyXG4gICAgdGFuZ2VudDogUE9TSVRJVkVfWlxyXG59O1xyXG5leHBvcnQgY29uc3QgWFkgPSB7XHJcbiAgICBub3JtYWw6IFBPU0lUSVZFX1osXHJcbiAgICBkaXN0YW5jZTogMFxyXG59O1xyXG5leHBvcnQgY29uc3QgWVogPSB7XHJcbiAgICBub3JtYWw6IFBPU0lUSVZFX1gsXHJcbiAgICBkaXN0YW5jZTogMFxyXG59O1xyXG5leHBvcnQgY29uc3QgWlggPSB7XHJcbiAgICBub3JtYWw6IFBPU0lUSVZFX1ksXHJcbiAgICBkaXN0YW5jZTogMFxyXG59O1xyXG4vKipcclxuICogQ29tcHV0ZXMgaW50ZXJzZWN0aW9uIG9mIGEgcGxhbmUgYW5kIGEgbGluZS5cclxuICpcclxuICogQHBhcmFtIHAgVGhlIHBsYW5lLlxyXG4gKiBAcGFyYW0gbCBUaGUgbGluZS5cclxuICogQHJldHVybnMgVGhlIHBvaW50IG9yIGBudWxsYCBpZiB0aGUgbGluZSBpcyBwYXJhbGxlbCB0byB0aGUgcGxhbmUuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGxhbmVMaW5lSW50ZXJzZWN0aW9uKHAsIGwpIHtcclxuICAgIGNvbnN0IGRvdExQID0gZG90KGwudGFuZ2VudCwgcC5ub3JtYWwpO1xyXG4gICAgLy8gSWYgcGxhbmUgbm9ybWFsIGFuZCBsaW5lIHRhbmdlbnQgdmVjdG9yIGFyZSBwZXJwZW5kaWN1bGFyIGludGVyc2VjdGlvbiBpc1xyXG4gICAgLy8gZWl0aGVyIGFuIGVtcHR5IHNldCBvciB0aGUgbGluZSBpdHNlbGYuXHJcbiAgICBpZiAoZG90TFAgPT09IDApIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGNvbnN0IGludGVyc2VjdGlvbiA9IGNvcHkobC50YW5nZW50KTtcclxuICAgIG11bG4oaW50ZXJzZWN0aW9uLCAocC5kaXN0YW5jZSAtIGRvdChwLm5vcm1hbCwgbC5vcmlnaW4pKSAvIGRvdExQLCBpbnRlcnNlY3Rpb24pO1xyXG4gICAgYWRkKGludGVyc2VjdGlvbiwgbC5vcmlnaW4sIGludGVyc2VjdGlvbik7XHJcbiAgICByZXR1cm4gaW50ZXJzZWN0aW9uO1xyXG59XHJcbi8qKlxyXG4gKiBDb21wdXRlcyBhbiBpbnRlcnNlY3Rpb24gb2YgYSBwbGFuZSBhbmQgYSByYXkgYW5kIHN0b3JlcyBpdCBpbnRvIGEgZ2l2ZW5cclxuICogdmVjdG9yLlxyXG4gKlxyXG4gKiBAcGFyYW0gcGxhbmUgVGhlIHBsYW5lLlxyXG4gKiBAcGFyYW0gcmF5IFRoZSByYXkuXHJcbiAqIEBwYXJhbSBkc3QgVGhlIHZlY3RvciB0aGUgaW50ZXJzZWN0aW9uIHBvaW50IHdpbGwgYmUgc3RvcmVkIHRvLiBJZiB0aGVyZSdzIG5vXHJcbiAqICAgICAgaW50ZXJzZWN0aW9uLCB0aGlzIHZlY3RvciB3aWxsIGJlIGxlZnQgdW5tb2RpZmllZC5cclxuICogQHJldHVybnMgVGhlIGBkc3RgIG9yIGBudWxsYCBpZiB0aGUgcmF5IGRvZXNuJ3QgaGF2ZSBhIGNvbW1vbiBwb2ludCB3aXRoIHRoZVxyXG4gKiAgICAgIHBsYW5lLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFBsYW5lUmF5SW50ZXJzZWN0aW9uKHBsYW5lLCByYXksIGRzdCA9IGNyZWF0ZSgwLCAwLCAwKSkge1xyXG4gICAgY29uc3QgZG90UlAgPSBkb3QocmF5LmRpcmVjdGlvbiwgcGxhbmUubm9ybWFsKTtcclxuICAgIGlmIChkb3RSUCA9PT0gMCkge1xyXG4gICAgICAgIC8vIFRoZSBwbGFuZSBub3JtYWwgYW5kIHRoZSByYXkgZGlyZWN0aW9uIHZlY3RvciBhcmUgcGVycGVuZGljdWxhciwgc29cclxuICAgICAgICAvLyBpbnRlcnNlY3Rpb24gaXMgZWl0aGVyIGFuIGVtcHR5IHNldCBvciB0aGUgcmF5IGl0c2VsZi5cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGNvbnN0IGxhbWJkYSA9IChwbGFuZS5kaXN0YW5jZSAtIGRvdChwbGFuZS5ub3JtYWwsIHJheS5vcmlnaW4pKSAvIGRvdFJQO1xyXG4gICAgaWYgKGxhbWJkYSA8IDApIHtcclxuICAgICAgICAvLyBUaGUgaW50ZXJzZWN0aW9uIHBvaW50IGlzIG9uIGEgbGluZSB0aGF0IGNvbnRhaW5zIHRoZSByYXksIGJ1dCBub3Qgb25cclxuICAgICAgICAvLyB0aGUgcmF5IGl0c2VsZi5cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGNvcHkocmF5LmRpcmVjdGlvbiwgZHN0KTtcclxuICAgIG11bG4oZHN0LCBsYW1iZGEsIGRzdCk7XHJcbiAgICBhZGQoZHN0LCByYXkub3JpZ2luLCBkc3QpO1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogQ29tcHV0ZXMgaW50ZXJzZWN0aW9uIG9mIHR3byBwbGFuZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSBwMSBUaGUgZmlyc3QgcGxhbmUuXHJcbiAqIEBwYXJhbSBwMiBUaGUgc2Vjb25kIHBsYW5lLlxyXG4gKiBAcmV0dXJucyBUaGUgbGluZSBvciBgbnVsbGAgaWYgdGhlIHBsYW5lcyBhcmUgcGFyYWxsZWwgdG8gZWFjaCBvdGhlci5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRQbGFuZVBsYW5lSW50ZXJzZWN0aW9uKHAxLCBwMikge1xyXG4gICAgY29uc3QgbjEgPSBwMS5ub3JtYWw7XHJcbiAgICBjb25zdCBuMiA9IHAyLm5vcm1hbDtcclxuICAgIGlmIChhcmVDb2xsaW5lYXIobjEsIG4yKSkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgY29uc3QgdGFuZ2VudCA9IGNyb3NzKG4xLCBuMik7XHJcbiAgICBub3JtYWxpemUodGFuZ2VudCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHRhbmdlbnQsXHJcbiAgICAgICAgb3JpZ2luOiBtYXRyaXgzLnNvbHZlKG1hdHJpeDMuZnJvbVJvd3MobjEsIG4yLCB0YW5nZW50KSwgY3JlYXRlKHAxLmRpc3RhbmNlLCBwMi5kaXN0YW5jZSwgMCkpXHJcbiAgICB9O1xyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL21hdGgvdmVjdG9yMy50c1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiY29uc3QgVUlOVDhfTUFYID0gMHhmZjtcclxuY29uc3QgVUlOVDE2X01BWCA9IDB4ZmZmZjtcclxuY29uc3QgVUlOVDMyX01BWCA9IDB4ZmZmZmZmZmY7XHJcbmV4cG9ydCBmdW5jdGlvbiBmbG9hdFRvVWludDgoeCkge1xyXG4gICAgcmV0dXJuIFVJTlQ4X01BWCAqIHggfCAwO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBmbG9hdFRvVWludDE2KHgpIHtcclxuICAgIHJldHVybiB4ICogVUlOVDE2X01BWCB8IDA7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGZsb2F0VG9JbnQxNih4KSB7XHJcbiAgICByZXR1cm4gKHggKiBVSU5UMTZfTUFYIC0gMSkgLyAyIHwgMDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gZmxvYXRUb1VpbnQzMih4KSB7XHJcbiAgICByZXR1cm4geCAqIFVJTlQzMl9NQVggfCAwO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBmbG9hdFRvSW50MzIoeCkge1xyXG4gICAgcmV0dXJuICh4ICogVUlOVDMyX01BWCAtIDEpIC8gMiB8IDA7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGludDMyVG9GbG9hdCh4KSB7XHJcbiAgICByZXR1cm4gKDIgKiB4ICsgMSkgLyBVSU5UMzJfTUFYO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiB1aW50MzJUb0Zsb2F0KHgpIHtcclxuICAgIHJldHVybiB4IC8gVUlOVDMyX01BWDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gaW50MTZUb0Zsb2F0KHgpIHtcclxuICAgIHJldHVybiAoMiAqIHggKyAxKSAvIFVJTlQxNl9NQVg7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIHVpbnQxNlRvRmxvYXQoeCkge1xyXG4gICAgcmV0dXJuIHggLyBVSU5UMTZfTUFYO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiB1aW50OFRvRmxvYXQoeCkge1xyXG4gICAgcmV0dXJuIHggLyBVSU5UOF9NQVg7XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9ncHV0eXBlcy50c1xuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgREVGQVVMVF9DT01QQVJBVE9SIH0gZnJvbSAnLi9jb21wYXJhdG9yJztcclxuLyoqXHJcbiAqIFN3YXBzIHR3byB2YWx1ZXMgaW4gYW4gYXJyYXkuXHJcbiAqXHJcbiAqIEBwYXJhbSBhcnJheSBUaGUgYXJyYXkuXHJcbiAqIEBwYXJhbSBpIEluZGV4IG9mIGEgdmFsdWUgdG8gYmUgc3dhcHBlZC5cclxuICogQHBhcmFtIGogSW5kZXggb2YgYSB2YWx1ZSB0byBiZSBzd2FwcGVkLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHN3YXAoYXJyYXksIGksIGopIHtcclxuICAgIGNvbnN0IHQgPSBhcnJheVtpXTtcclxuICAgIGFycmF5W2ldID0gYXJyYXlbal07XHJcbiAgICBhcnJheVtqXSA9IHQ7XHJcbn1cclxuLyoqXHJcbiAqIFJldmVyc2VzIG9yZGVyIG9mIGVsZW1lbnRzIGluIGEgcmFuZ2UgaW4gYW4gYXJyYXkuXHJcbiAqXHJcbiAqIEBwYXJhbSBhcnJheSBUaGUgYXJyYXkuXHJcbiAqIEBwYXJhbSBzdGFydCBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxyXG4gKiBAcGFyYW0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHJldmVyc2UoYXJyYXksIHN0YXJ0ID0gMCwgZW5kID0gYXJyYXkubGVuZ3RoKSB7XHJcbiAgICBmb3IgKGxldCBpID0gc3RhcnQsIGogPSBlbmQgLSAxOyBpIDwgajsgKytpLCAtLWopIHtcclxuICAgICAgICBzd2FwKGFycmF5LCBpLCBqKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUm90YXRlcyBhIHJhbmdlIG9mIGVsZW1lbnRzIGluIGFuIGFycmF5IGJ5IGdpdmVuIGFtb3VudC5cclxuICpcclxuICogQHBhcmFtIGFycmF5IFRoZSBhcnJheS5cclxuICogQHBhcmFtIGFtb3VudCBUaGUgYW1vdW50LlxyXG4gKiBAcGFyYW0gc3RhcnQgVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cclxuICogQHBhcmFtIGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiByb3RhdGUoYXJyYXksIGFtb3VudCA9IDEsIHN0YXJ0ID0gMCwgZW5kID0gYXJyYXkubGVuZ3RoKSB7XHJcbiAgICByZXZlcnNlKGFycmF5LCBzdGFydCwgZW5kKTtcclxuICAgIHJldmVyc2UoYXJyYXksIHN0YXJ0LCBzdGFydCArIGFtb3VudCk7XHJcbiAgICByZXZlcnNlKGFycmF5LCBzdGFydCArIGFtb3VudCwgZW5kKTtcclxufVxyXG4vKipcclxuICogQ29waWVzIGEgcmFuZ2Ugb2YgZWxlbWVudHMgZnJvbSBhIHNvdXJjZSBhcnJheSB0byBhIHJhbmdlIGluIGEgZGVzdGluYXRpb25cclxuICogYXJyYXkuXHJcbiAqXHJcbiAqIEBwYXJhbSBzcmMgVGhlIHNvdXJjZSBhcnJheS5cclxuICogQHBhcmFtIGRzdCBUaGUgZGVzdGluYXRpb24gYXJyYXkuXHJcbiAqIEBwYXJhbSBzcmNTdGFydCBUaGUgc3RhcnQgb2YgdGhlIHNvdXJjZSByYW5nZS5cclxuICogQHBhcmFtIHNyY1N0YXJ0IFRoZSBzdGFydCBvZiB0aGUgc291cmNlIHJhbmdlLlxyXG4gKiBAcGFyYW0gZHN0U3RhcnQgVGhlIHN0YXJ0IG9mIHRoZSBkZXN0aW5hdGlvbiByYW5nZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb3B5KHNyYywgZHN0LCBzcmNTdGFydCA9IDAsIHNyY0VuZCA9IHNyYy5sZW5ndGgsIGRzdFN0YXJ0ID0gMCkge1xyXG4gICAgZm9yIChsZXQgaSA9IHNyY1N0YXJ0LCBqID0gZHN0U3RhcnQ7IGkgPCBzcmNFbmQ7ICsraSwgKytqKSB7XHJcbiAgICAgICAgZHN0W2pdID0gc3JjW2ldO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBTaHVmZmxlcyByYW5kb21seSBhIHJhbmdlIG9mIGVsZW1lbnRzIGluIGFuIGFycmF5LlxyXG4gKlxyXG4gKiBAcGFyYW0gYXJyYXkgVGhlIGFycmF5LlxyXG4gKiBAcGFyYW0gc3RhcnQgVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cclxuICogQHBhcmFtIGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzaHVmZmxlKGFycmF5LCBzdGFydCA9IDAsIGVuZCA9IGFycmF5Lmxlbmd0aCkge1xyXG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0LCBqID0gaSArIDE7IGkgPCBlbmQ7ICsraSwgKytqKSB7XHJcbiAgICAgICAgc3dhcChhcnJheSwgaSwgaiArIChNYXRoLnJhbmRvbSgpICogKGVuZCAtIGopIHwgMCkpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiB6aXAodHMsIHVzLCB6aXBwZXIgPSAodCwgdSkgPT4gW3QsIHVdKSB7XHJcbiAgICBjb25zdCBsID0gTWF0aC5taW4odHMubGVuZ3RoLCB1cy5sZW5ndGgpO1xyXG4gICAgY29uc3QgdnMgPSBuZXcgQXJyYXkobCk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7ICsraSkge1xyXG4gICAgICAgIHZzW2ldID0gemlwcGVyKHRzW2ldLCB1c1tpXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdnM7XHJcbn1cclxuLyoqXHJcbiAqIENvbXBhcmVzIHR3byBhcnJheXMgbGV4aWNvZ3JhcGhpY2FsbHkuIFRoZSBvcmRlciBpcyBzcGVjaWZpZWQgYmUgdGhlIGNvbXBhcmF0b3IgcGFyYW1ldGVyLlxyXG4gKlxyXG4gKiBAcGFyYW0gY29tcGFyYXRvciBFbGVtZW50cyBjb21wYXJhdG9yIHdpdGggc3RhbmRhcmQgc2lnbmF0dXJlLlxyXG4gKiBAcGFyYW0gYSBUaGUgZmlyc3QgYXJyYXkgdG8gY29tcGFyZS5cclxuICogQHBhcmFtIGIgVGhlIHNlY29uZCBhcnJheSB0byBjb21wYXJlLlxyXG4gKiBAcmV0dXJucyAwIGlmIGFsbCBlbGVtZW50cyBhbmQgbGVuZ3RocyBhcmUgZXF1YWwsXHJcbiAqICAgICAgbmVnYXRpdmUgbnVtYmVyIGlmIHRoZSBmaXJzdCBlbGVtZW50IGlzIGxlc3MgdGhlbiB0aGUgc2Vjb25kIChsZXhpY29ncmFwaGljYWxseSksXHJcbiAqICAgICAgcG9zaXRpdmUgbnVtYmVyIGlmIHRoZSBmaXJzdCBlbGVtZW50IGlzIGdyZWF0ZXIgdGhlbiB0aGUgc2Vjb25kLFxyXG4gKiAgICAgIGlmIGFsbCB0aGUgZWxlbWVudHMgYXJlIGVxdWFsIHRoZSBsZW5ndGhzIGFyZSBiZWluZyBjb21wYXJlZC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb21wYXJlKGNvbXBhcmF0b3IsIGEsIGIpIHtcclxuICAgIGNvbnN0IGxlbmd0aCA9IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aCk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gY29tcGFyYXRvcihhW2ldLCBiW2ldKTtcclxuICAgICAgICBpZiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGEubGVuZ3RoIC0gYi5sZW5ndGg7XHJcbn1cclxuLyoqXHJcbiAqIFNvcnRzIGEgcmFuZ2Ugb2YgZWxlbWVudHMgb2YgYW4gYXJyYXkgaW4gcGxhY2Ugd2l0aCBpbnNlcnRpb24gc29ydC5cclxuICpcclxuICogQHBhcmFtIGFycmF5IFRoZSBhcnJheSB0byBiZSBzb3J0ZWQuXHJcbiAqIEBwYXJhbSBjb21wYXJhdG9yIENvbXBhcmF0b3IgZm9yIGFycmF5IGVsZW1lbnRzLlxyXG4gKiBAcGFyYW0gc3RhcnQgSW5kZXggb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHJhbmdlIHRvIGJlIHNvcnRlZC5cclxuICogQHBhcmFtIGVuZCBJbmRleCBvZiBhbiBlbGVtZW50IGJlaGluZCB0aGUgbGFzdCBlbGVtZW50IGluIHRoZSByYW5nZSB0byBiZVxyXG4gKiAgICAgIHNvcnRlZC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpbnNlcnRpb25Tb3J0KGFycmF5LCBjb21wYXJhdG9yID0gREVGQVVMVF9DT01QQVJBVE9SLCBzdGFydCA9IDAsIGVuZCA9IGFycmF5Lmxlbmd0aCkge1xyXG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcclxuICAgICAgICBmb3IgKGxldCBqID0gaTsgaiA+IHN0YXJ0ICYmIGNvbXBhcmF0b3IoYXJyYXlbaiAtIDFdLCBhcnJheVtqXSkgPiAwOyAtLWopIHtcclxuICAgICAgICAgICAgc3dhcChhcnJheSwgaiAtIDEsIGopO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5jb25zdCBCTE9DS19TSVpFID0gMzI7XHJcbi8qKlxyXG4gKiBNZXJnZXMgdHdvIHNvcnRlZCByYW5nZXMgb2YgYW4gYXJyYXkuIFN0b3JlcyB0aGUgcmVzdWx0IGludG8gYW5vdGhlciBvbmUuXHJcbiAqXHJcbiAqIEBwYXJhbSBzcmMgVGhlIGFycmF5IHdpdGggdGhlIHJhbmdlcyB0byBiZSBtZXJnZWQuXHJcbiAqIEBwYXJhbSBkc3QgVGhlIGFycmF5IHRoZSByZXN1bHRpbmcgcmFuZ2Ugd2lsbCBiZSBzdG9yZWQgdG8uXHJcbiAqIEBwYXJhbSBjb21wYXJhdG9yIFRoZSBjb21wYXJhdG9yIGZvciBhcnJheSBlbGVtZW50cy5cclxuICogQHBhcmFtIHN0YXJ0IFN0YXJ0IG9mIHRoZSBmaXJzdCByYW5nZSB0byBiZSBtZXJnZWQuXHJcbiAqIEBwYXJhbSBtaWRkbGUgRW5kIG9mIHRoZSBmaXJzdCBhbmQgc2ltdWx0YW5lb3VzbHkgc3RhcnQgb2YgdGhlIHNlY29uZCByYW5nZVxyXG4gKiAgICAgIHRvIGJlIG1lcmdlZC5cclxuICogQHBhcmFtIGVuZCBFbmQgb2YgdGhlIHNlY29uZCByYW5nZSB0byBiZSBtZXJnZWQuXHJcbiAqIEBwYXJhbSBkc3RPZmZzZXQgT2Zmc2V0IG9mIG1lcmdlZCByYW5nZSBpbiB0aGUgcmVzdWx0IGFycmF5LlxyXG4gKi9cclxuZnVuY3Rpb24gbWVyZ2Uoc3JjLCBkc3QsIGNvbXBhcmF0b3IsIHN0YXJ0LCBtaWRkbGUsIGVuZCwgZHN0T2Zmc2V0KSB7XHJcbiAgICBsZXQgaSA9IGRzdE9mZnNldDtcclxuICAgIGxldCBqID0gc3RhcnQ7XHJcbiAgICBsZXQgayA9IG1pZGRsZTtcclxuICAgIHdoaWxlIChqIDwgbWlkZGxlICYmIGsgPCBlbmQpIHtcclxuICAgICAgICBkc3RbaSsrXSA9IGNvbXBhcmF0b3Ioc3JjW2pdLCBzcmNba10pID4gMCA/IHNyY1trKytdIDogc3JjW2orK107XHJcbiAgICB9XHJcbiAgICBjb3B5KHNyYywgZHN0LCBqLCBtaWRkbGUsIGkpO1xyXG4gICAgY29weShzcmMsIGRzdCwgaywgZW5kLCBpKTtcclxufVxyXG4vKipcclxuICogU29ydHMgYSByYW5nZSBvZiBlbGVtZW50cyBvZiBhbiBhcnJheSB3aXRoIG1lcmdlIHNvcnQuXHJcbiAqXHJcbiAqIEBwYXJhbSBhcnJheSAgVGhlIGFycmF5IHRvIGJlIHNvcnRlZC5cclxuICogQHBhcmFtIGNvbXBhcmF0b3IgQ29tcGFyYXRvciBmb3IgYXJyYXkgZWxlbWVudHMuXHJcbiAqIEBwYXJhbSBlbmQgSW5kZXggb2YgYW4gZWxlbWVudCBiZWhpbmQgdGhlIGxhc3QgZWxlbWVudCBpbiB0aGUgcmFuZ2UgdG8gYmVcclxuICogICAgICBzb3J0ZWQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VTb3J0KGFycmF5LCBjb21wYXJhdG9yID0gREVGQVVMVF9DT01QQVJBVE9SLCBzdGFydCA9IDAsIGVuZCA9IGFycmF5Lmxlbmd0aCkge1xyXG4gICAgLy8gRmlyc3QgYW5kIGZvcmVtb3N0OiBpZiB0aGUgcmFuZ2UgaXMgc21hbGxlciB0aGFuIHRoZSBibG9jayBzaXplLCBqdXN0XHJcbiAgICAvLyBwZXJmb3JtIGluc2VydGlvbiBzb3J0IG9uIGl0LlxyXG4gICAgaWYgKGVuZCAtIHN0YXJ0IDw9IEJMT0NLX1NJWkUpIHtcclxuICAgICAgICBpbnNlcnRpb25Tb3J0KGFycmF5LCBjb21wYXJhdG9yLCBzdGFydCwgZW5kKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAvLyBGaXJzdCB3ZSBzcGxpdCB0aGUgZ2l2ZW4gcmFuZ2UgaW50byBzdWJyYW5nZXMgb2Ygc2l6ZSBCTE9DS19TSVpFIGFuZFxyXG4gICAgLy8gc29ydCBldmVyeSByYW5nZSB3aXRoIGluc2VydGlvbiBzb3J0LlxyXG4gICAge1xyXG4gICAgICAgIGxldCBzID0gc3RhcnQ7XHJcbiAgICAgICAgbGV0IGUgPSBzICsgQkxPQ0tfU0laRTtcclxuICAgICAgICB3aGlsZSAoZSA8IGVuZCkge1xyXG4gICAgICAgICAgICBpbnNlcnRpb25Tb3J0KGFycmF5LCBjb21wYXJhdG9yLCBzLCBlKTtcclxuICAgICAgICAgICAgcyA9IGU7XHJcbiAgICAgICAgICAgIGUgKz0gQkxPQ0tfU0laRTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaW5zZXJ0aW9uU29ydChhcnJheSwgY29tcGFyYXRvciwgcywgZW5kKTtcclxuICAgIH1cclxuICAgIC8vIFRPRE8oZG1pa2lzKTogSW1wbGVtZW50IGluLXBsYWNlIG1lcmdlLiBJdCBzZWVtcyB0aGVyZSdyZSByZWFzb25hYmx5XHJcbiAgICAvLyAgICAgIGNvbXBsZXggc29sdXRpb25zIG91dCB0aGVyZS5cclxuICAgIGNvbnN0IGF1eEFycmF5ID0gbmV3IEFycmF5KGVuZCAtIHN0YXJ0KTtcclxuICAgIC8vIFRoZW4gd2UgbWVyZ2UgYmxvY2tzIHBhaXJzLCBpbmNyZWFzZSBibG9jayBzaXplIGJ5IDIgYW5kIHJlcGVhdC5cclxuICAgIGZvciAobGV0IGJsb2NrU2l6ZSA9IEJMT0NLX1NJWkU7IGJsb2NrU2l6ZSA8IGVuZCAtIHN0YXJ0OyBibG9ja1NpemUgKz0gYmxvY2tTaXplKSB7XHJcbiAgICAgICAgLy8gVE9ETyhkbWlraXMpOiBCZWZvcmUgYWZvcmVtZW50aW9uZWQgdG9kbyBtYXliZSBpbXBsZW1lbnQgYXJyYXlcclxuICAgICAgICAvLyBwaW5ncG9uZ2luZyB0byBjdXQgZG93biBhbW91bnQgb2YgZnVsbCBjb3BpZXMuXHJcbiAgICAgICAgY29weShhcnJheSwgYXV4QXJyYXksIHN0YXJ0LCBlbmQpO1xyXG4gICAgICAgIGxldCBpID0gc3RhcnQ7XHJcbiAgICAgICAgbGV0IHMgPSAwO1xyXG4gICAgICAgIGxldCBtID0gYmxvY2tTaXplO1xyXG4gICAgICAgIGxldCBlID0gbSArIGJsb2NrU2l6ZTtcclxuICAgICAgICB3aGlsZSAoZSA8IGVuZCAtIHN0YXJ0KSB7XHJcbiAgICAgICAgICAgIG1lcmdlKGF1eEFycmF5LCBhcnJheSwgY29tcGFyYXRvciwgcywgbSwgZSwgaSk7XHJcbiAgICAgICAgICAgIHMgPSBlO1xyXG4gICAgICAgICAgICBtID0gcyArIGJsb2NrU2l6ZTtcclxuICAgICAgICAgICAgZSA9IG0gKyBibG9ja1NpemU7XHJcbiAgICAgICAgICAgIGkgKz0gMiAqIGJsb2NrU2l6ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbWVyZ2UoYXV4QXJyYXksIGFycmF5LCBjb21wYXJhdG9yLCBzLCBNYXRoLm1pbihtLCBlbmQgLSBzdGFydCksIGVuZCAtIHN0YXJ0LCBpKTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL2FycmF5LnRzXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICogQHJldHVybnMgSW50ZWdlciBudW1iZXIgb2YgdmVydGljZXMgdGhhdCBmaXQgaW50byBhIHJlZ2lvbiBvZiBzcGVjaWZpZWQgaW4gYnl0ZXMgc2l6ZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb3VudFZlcnRpY2VzKHZlcnRleEJ5dGVTaXplLCBhdHRyaWJNYXBwaW5nKSB7XHJcbiAgICByZXR1cm4gdmVydGV4Qnl0ZVNpemUgLyBhdHRyaWJNYXBwaW5nLnZlcnRleEJ5dGVTaXplIHwgMDtcclxufVxyXG4vKipcclxuICogQHJldHVybnMgSW50ZWdlciBudW1iZXIgb2YgaW5kaWNlcyB0aGF0IGZpdCBpbnRvIGEgcmVnaW9uIG9mIHNwZWNpZmllZCBpbiBieXRlcyBzaXplLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvdW50SW5kaWNlcyhpbmRleEJ5dGVTaXplLCB0eXBlKSB7XHJcbiAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICBjYXNlIDUxMjMgLyogVU5TSUdORURfU0hPUlQgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBpbmRleEJ5dGVTaXplID4+IDE7XHJcbiAgICAgICAgY2FzZSA1MTI1IC8qIFVOU0lHTkVEX0lOVCAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIGluZGV4Qnl0ZVNpemUgPj4gMjtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL21lbW9yeS9jb3VudF92ZXJ0aWNlcy50c1xuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0IGZ1bmN0aW9uIGdldFRpbGVJZEJ5UmF3VmFsdWVzKHgsIHksIHpvb20pIHtcclxuICAgIHJldHVybiBgJHt4fToke3l9OiR7em9vbX1gO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRUaWxlSWQodGlsZSkge1xyXG4gICAgcmV0dXJuIGdldFRpbGVJZEJ5UmF3VmFsdWVzKHRpbGUueCwgdGlsZS55LCB0aWxlLnpvb20pO1xyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2FkYXB0ZXJzL3RpbGVfYmFzZWRfYWRhcHRlci90aWxlX2lkLnRzXG4vLyBtb2R1bGUgaWQgPSAxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICogQmFzZSBpbnRlcmZhY2UgZm9yIHdlYndvcmtlciBtZXNzYWdlcywgYm90aCBpbmNvbWluZyBhbmQgb3V0Z29pbmcgb25lcy5cclxuICpcclxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVHJhbnNmZXJhYmxlXHJcbiAqL1xyXG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICcuL2V2ZW50X2VtaXR0ZXInO1xyXG5pbXBvcnQgeyB1bmlxdWVJZCB9IGZyb20gJy4vdW5pcXVlX2lkJztcclxuY29uc3QgTUVTU0FHRV9CQVRDSF9NQVhfU0laRSA9IDUwO1xyXG5jb25zdCBGTFVTSF9USU1FT1VUID0gNTA7XHJcbi8vIGVhY2ggc3Vic2VxdWVudCBtZXNzYWdlIGRlYm91bmNlcyBwb3N0TWVzc2FnZSBjYWxsLCB0aGF0IGNhbiBsZWFkIHRvIGluZmluaXRlIGRlbGF5LCB0aGlzIGNvbnN0IGxpbWl0cyBpdFxyXG5jb25zdCBNQVhfRkxVU0hfVElNRU9VVCA9IDI1MDtcclxuZXhwb3J0IGNvbnN0IE5PX0lEID0gLTE7XHJcbi8qKlxyXG4gKiBDaGVja3MgbWVzc2FnZSB0eXBlIHdpdGggdHlwZSBndWFyZGluZy4gSXQgZ2l2ZXMgYSBsaXR0bGUgYml0IG1vcmUgZWxlZ2FudCBhbHRlcm5hdGl2ZVxyXG4gKiB0byB0YWdnZWQgdHlwZSB1bmlvbnMgcHJvdmlkaW5nIHRoZSBzYW1lIHR5cGUgc2FmZXR5LlxyXG4gKlxyXG4gKiBAcGFyYW0gbWVzc2FnZSB0byBiZSBjaGVja2VkXHJcbiAqIEBwYXJhbSB0eXBlIHRoZSB2YWx1ZSBvZiB0aGUgXCJ0eXBlXCIgcHJvcGVydHlcclxuICogQHJldHVybiB7Ym9vbGVhbn1cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBtZXNzYWdlSXMobWVzc2FnZSwgdHlwZSkge1xyXG4gICAgcmV0dXJuIG1lc3NhZ2UudHlwZSA9PT0gdHlwZTtcclxufVxyXG4vKipcclxuICogQmFzZSBjbGFzcyBmb3IgYm90aCBzaWRlcyBvZiBhIHdlYndvcmtlcjogaXRzIGltcGxlbWVudGF0aW9uIChzZXBhcmF0ZSBqcyB0aGF0IGlzIHJ1biBpbiBhIHdvcmtlciB0aHJlYWQpIGFuZFxyXG4gKiBhIGNvbnRyb2xsZXIgZm9yIHRoZSBtYWluIHRocmVhZC4gVGhleSBoYXZlIHNpbWlsYXIgbWVjaGFuaXNtIG9mIHNlbmRpbmcvcmVjZWl2aW5nIG1lc3NhZ2VzIHRoYXQgaXMgaW1wbGVtZW50IGhlcmUuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgV2ViV29ya2VyQ29tbXVuaWNhdG9yIHtcclxuICAgIGNvbnN0cnVjdG9yKGFkZHJlc3NlZSkge1xyXG4gICAgICAgIHRoaXMuX2FkZHJlc3NlZSA9IGFkZHJlc3NlZTtcclxuICAgICAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuX3RyYW5zZmVyYWJsZUV4dHJhY3RvcnMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5fbWVzc2FnZXMgPSBbXTtcclxuICAgICAgICB0aGlzLl90cmFuc2ZlcmFibGVzID0gW107XHJcbiAgICAgICAgdGhpcy5fdGltZW91dEhhbmRsZSA9IDA7XHJcbiAgICAgICAgdGhpcy5fZmx1c2hNZXNzYWdlc0JpbmRlZCA9IHRoaXMuX2ZsdXNoTWVzc2FnZXMuYmluZCh0aGlzKTtcclxuICAgIH1cclxuICAgIHNldFRyYW5zZmVyYWJsZUV4dHJhY3Rvcih0eXBlLCBleHRyYWN0b3IpIHtcclxuICAgICAgICB0aGlzLl90cmFuc2ZlcmFibGVFeHRyYWN0b3JzLnNldCh0eXBlLCBleHRyYWN0b3IpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZW5kIGEgbWVzc2FnZSB0byB0aGUgb3Bwb3NpdGUgc2lkZSBvZiB0aGUgd2ViIHdvcmtlciBjb21tdW5pY2F0aW9uIGNoYW5uZWwuXHJcbiAgICAgKiBNZXNzYWdlcyBhcmUgYmF0Y2hlZCBieSBkZWxheWluZyBwb3N0TWVzc2FnZSBjYWxsIHRvIGdyb3VwIG1lc3NhZ2VzIHRoYXQgY29tZSBkdXJpbmcgdGhpcyBkZWxheSBhbmQgbWluaW1pemVcclxuICAgICAqIHRoZSBudW1iZXIgb2YgaW50ZXJwcm9jZXNzIGNvbW11bmljYXRpb25zIHRoYXQgYmFkbHkgYWZmZWN0IHBlcmZvcm1hbmNlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtZXNzYWdlIE1lc3NhZ2UgdG8gYmUgc2VudC5cclxuICAgICAqIEBwYXJhbSB1cmdlbmN5IElNTUVESUFURSBmb3JjZXMgbWVzc2FnZSB0byBiZSBzZW50IGltbWVkaWF0ZWx5IChzeW5jaHJvbm91cyBjYWxsKSB3aXRoIG5vIGJhdGNoaW5nIGRlbGF5LFxyXG4gICAgICogICAgICAgICAgICAgICAgREVGQVVMVCBkZWJvdW5jZXMgc2VuZGluZyBmb3IgYW5vdGhlciBGTFVTSF9USU1FT1VULlxyXG4gICAgICovXHJcbiAgICBzZW5kTWVzc2FnZShtZXNzYWdlLCB1cmdlbmN5ID0gMCAvKiBERUZBVUxUICovKSB7XHJcbiAgICAgICAgY29uc3QgdHJhbnNmZXJhYmxlRXh0cmFjdG9yID0gdGhpcy5fdHJhbnNmZXJhYmxlRXh0cmFjdG9ycy5nZXQobWVzc2FnZS50eXBlKTtcclxuICAgICAgICBjb25zdCB0cmFuc2ZlcmFibGVzID0gdHJhbnNmZXJhYmxlRXh0cmFjdG9yID8gdHJhbnNmZXJhYmxlRXh0cmFjdG9yKG1lc3NhZ2UpIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIGNvbnN0IGlzRmlyc3RNZXNzYWdlSW5CYXRjaCA9ICh0aGlzLl9tZXNzYWdlcy5sZW5ndGggPT09IDApO1xyXG4gICAgICAgIGlmIChpc0ZpcnN0TWVzc2FnZUluQmF0Y2gpIHtcclxuICAgICAgICAgICAgdGhpcy5fZmlyc3RNZXNzYWdlVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTZW5kIG1lc3NhZ2VzIGFzeW5jaHJvbm91c2x5IHBhY2tpbmcgdGhlbSBpbnRvIG9uZSBtZXNzYWdlLlxyXG4gICAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gYWJ1c2UgdGhlIHdlYiB3b3JrZXIgY29tbXVuaWNhdGlvbiBjaGFubmVsIGFuZFxyXG4gICAgICAgIC8vIHNlbmQgbWVzc2FnZXMgYXN5bmNocm9ub3VzbHkgaW4gc2hvcnQgcGVyaW9kIG9mIHRpbWUgb3IgbWFueSBtZXNzYWdlcyBzeW5jaHJvbm91c2x5LlxyXG4gICAgICAgIHRoaXMuX21lc3NhZ2VzLnB1c2gobWVzc2FnZSk7XHJcbiAgICAgICAgaWYgKHRyYW5zZmVyYWJsZXMpIHtcclxuICAgICAgICAgICAgdGhpcy5fdHJhbnNmZXJhYmxlcyA9IHRoaXMuX3RyYW5zZmVyYWJsZXMuY29uY2F0KHRyYW5zZmVyYWJsZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dEhhbmRsZSk7XHJcbiAgICAgICAgaWYgKHRoaXMuX21lc3NhZ2VzLmxlbmd0aCA+IE1FU1NBR0VfQkFUQ0hfTUFYX1NJWkUgfHxcclxuICAgICAgICAgICAgdXJnZW5jeSA9PT0gMSAvKiBJTU1FRElBVEUgKi8gfHxcclxuICAgICAgICAgICAgKCFpc0ZpcnN0TWVzc2FnZUluQmF0Y2ggJiYgKHBlcmZvcm1hbmNlLm5vdygpIC0gdGhpcy5fZmlyc3RNZXNzYWdlVGltZSkgPiBNQVhfRkxVU0hfVElNRU9VVCkpIHtcclxuICAgICAgICAgICAgdGhpcy5fZmx1c2hNZXNzYWdlcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fdGltZW91dEhhbmRsZSA9IHNldFRpbWVvdXQodGhpcy5fZmx1c2hNZXNzYWdlc0JpbmRlZCwgRkxVU0hfVElNRU9VVCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZW5kcyByZXF1ZXN0IG1lc3NhZ2UgdG8vZnJvbSB3b3JrZXIgYXMgcHJvbWlzZSwgdGhlIG90aGVyIHNpZGUgY2FuIHJlc3BvbmQgYW5kIHRoZSBwcm9taXNlIGlzIHJlc29sdmVkLlxyXG4gICAgICogUmVxdWVzdC9yZXNwb25zZSBpcyBzeW5jaHJvbml6ZWQgYnkgdGhlIHJlcXVlc3RJZCBmaWVsZC5cclxuICAgICAqL1xyXG4gICAgcmVxdWVzdChyZXF1ZXN0LCB1cmdlbmN5KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgaWYgKHJlcXVlc3QucmVxdWVzdElkID09PSBOT19JRCkge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5yZXF1ZXN0SWQgPSB1bmlxdWVJZCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVyID0gKG1lc3NhZ2UpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlSXMobWVzc2FnZSwgcmVxdWVzdC5yZXNwb25zZVR5cGUpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yZXF1ZXN0SWQgPT09IHJlcXVlc3QucmVxdWVzdElkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShtZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIobGlzdGVuZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2VJcyhtZXNzYWdlLCByZXF1ZXN0LmVycm9yVHlwZSkgJiZcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnJlcXVlc3RJZCA9PT0gcmVxdWVzdC5yZXF1ZXN0SWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZihsaXN0ZW5lcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cy5hZGRMaXN0ZW5lcihsaXN0ZW5lcik7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZE1lc3NhZ2UocmVxdWVzdCwgdXJnZW5jeSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlc3BvbmRzIHRvIHByb3ZpZGVkIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIHJlc3BvbmQocmVxdWVzdCwgcmVzcG9uc2UsIHVyZ2VuY3kpIHtcclxuICAgICAgICByZXNwb25zZS5yZXF1ZXN0SWQgPSByZXF1ZXN0LnJlcXVlc3RJZDtcclxuICAgICAgICB0aGlzLnNlbmRNZXNzYWdlKHJlc3BvbnNlLCB1cmdlbmN5KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBhIGxpc3RlbmVyIHRvIHNwZWNpZmljIHR5cGUgb2YgaW5jb21pbmcgbWVzc2FnZXMuXHJcbiAgICAgKi9cclxuICAgIG9uKHR5cGUsIGxpc3RlbmVyKSB7XHJcbiAgICAgICAgY29uc3QgdHlwZVNhZmVMaXN0ZW5lciA9IChtZXNzYWdlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlSXMobWVzc2FnZSwgdHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIGxpc3RlbmVyKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLl9saXN0ZW5lcnMuc2V0KGxpc3RlbmVyLCB0eXBlU2FmZUxpc3RlbmVyKTtcclxuICAgICAgICB0aGlzLl9ldmVudHMuYWRkTGlzdGVuZXIodHlwZVNhZmVMaXN0ZW5lcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgaW5jb21pbmcgbWVzc2FnZXMgbGlzdGVuZXIuXHJcbiAgICAgKi9cclxuICAgIG9mZihsaXN0ZW5lcikge1xyXG4gICAgICAgIGNvbnN0IHR5cGVTYWZlTGlzdGVuZXIgPSB0aGlzLl9saXN0ZW5lcnMuZ2V0KGxpc3RlbmVyKTtcclxuICAgICAgICBpZiAodHlwZVNhZmVMaXN0ZW5lcikge1xyXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIodHlwZVNhZmVMaXN0ZW5lcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydHMgbGlzdGVuaW5nIGZvciBpbmNvbWluZyBtZXNzYWdlcy5cclxuICAgICAqL1xyXG4gICAgbGlzdGVuKCkge1xyXG4gICAgICAgIHRoaXMuX2FkZHJlc3NlZS5vbm1lc3NhZ2UgPSAoeyBkYXRhOiBtZXNzYWdlcyB9KSA9PiB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBtZXNzYWdlcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbk1lc3NhZ2UobWVzc2FnZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGVyIG9mIGluY29taW5nIG1lc3NhZ2VzLlxyXG4gICAgICovXHJcbiAgICBvbk1lc3NhZ2UobWVzc2FnZSkge1xyXG4gICAgICAgIHRoaXMuX2V2ZW50cy5maXJlKG1lc3NhZ2UpO1xyXG4gICAgfVxyXG4gICAgX2ZsdXNoTWVzc2FnZXMoKSB7XHJcbiAgICAgICAgdGhpcy5fYWRkcmVzc2VlLnBvc3RNZXNzYWdlKHRoaXMuX21lc3NhZ2VzLCB0aGlzLl90cmFuc2ZlcmFibGVzKTtcclxuICAgICAgICB0aGlzLl9tZXNzYWdlcy5sZW5ndGggPSAwO1xyXG4gICAgICAgIHRoaXMuX3RyYW5zZmVyYWJsZXMubGVuZ3RoID0gMDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQmFzZSBjbGFzcyBmb3IgYSB3ZWJ3b3JrZXIgY29udHJvbGxlciBmb3IgdGhlIG1haW4gdGhyZWFkIGNvZGUuXHJcbiAqIEl0IGFsc28gd3JhcHMgY3JlYXRpb24gb2YgYSBuYXRpdmUgV29ya2VyLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFdlYldvcmtlckNsaWVudCBleHRlbmRzIFdlYldvcmtlckNvbW11bmljYXRvciB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB1cmwgVVJMIG9mIHdlYndvcmtlcidzIGRlcGxveWVkIGpzIGZpbGVcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IodXJsKSB7XHJcbiAgICAgICAgY29uc3Qgd29ya2VyID0gbmV3IFdvcmtlcih1cmwpO1xyXG4gICAgICAgIHN1cGVyKHdvcmtlcik7XHJcbiAgICAgICAgdGhpcy5fd29ya2VyID0gd29ya2VyO1xyXG4gICAgICAgIHRoaXMubGlzdGVuKCk7XHJcbiAgICB9XHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMuX3dvcmtlci50ZXJtaW5hdGUoKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQmFzZSBjbGFzcyBmb3IgYSB3ZWJ3b3JrZXIgdGhyZWFkIGltcGxlbWVudGF0aW9uLiBDb25jcmV0ZSBjbGFzcyBzaG91bGQgYmUgdGhlIGVudHJ5IHBvaW50IGZvciBhIHdlYndvcmtlciBqcyBidWlsZDpcclxuICogICAgIG5ldyBDb25jcmV0ZVdlYldvcmtlckltcGxlbWVudGF0aW9uKDxEZWRpY2F0ZWRXb3JrZXJHbG9iYWxTY29wZT5zZWxmKS5ydW4oKTtcclxuICovXHJcbmV4cG9ydCBjbGFzcyBXZWJXb3JrZXJJbXBsZW1lbnRhdGlvbiBleHRlbmRzIFdlYldvcmtlckNvbW11bmljYXRvciB7XHJcbiAgICBydW4oKSB7XHJcbiAgICAgICAgdGhpcy5saXN0ZW4oKTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL3dvcmtlci50c1xuLy8gbW9kdWxlIGlkID0gMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiY29uc3QgUFJPSkVDVF9JRCA9IDQ0MztcclxuZnVuY3Rpb24gY2hvb3NlU3RhdFVybCgpIHtcclxuICAgIC8vIEZJWE1FKGRtaWtpcykgSWRlYWxseSB3ZSBzaG91bGQgYmUgZ2V0IHRoaXMgVVJMcyBmcm9tIGNvbmZpZy5cclxuICAgIGNvbnN0IFNUQVRfVVJMUyA9IHtcclxuICAgICAgICBydTogJ2h0dHBzOi8veWFuZGV4LnJ1L2NsY2snLFxyXG4gICAgICAgIGNvbTogJ2h0dHBzOi8veWFuZGV4LmNvbS9jbGNrJyxcclxuICAgICAgICB0cjogJ2h0dHBzOi8veWFuZGV4LmNvbS50ci9jbGNrJ1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHRsZCA9IGxvY2F0aW9uLmhvc3RuYW1lLnNwbGl0KCcuJykucG9wKCk7XHJcbiAgICBzd2l0Y2ggKHRsZCkge1xyXG4gICAgICAgIGNhc2UgJ3RyJzpcclxuICAgICAgICAgICAgcmV0dXJuIFNUQVRfVVJMUy50cjtcclxuICAgICAgICBjYXNlICdjb20nOlxyXG4gICAgICAgIGNhc2UgJ2ZyJzpcclxuICAgICAgICAgICAgcmV0dXJuIFNUQVRfVVJMUy5jb207XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIFNUQVRfVVJMUy5ydTtcclxuICAgIH1cclxufVxyXG5jb25zdCBTVEFUX1VSTCA9IGNob29zZVN0YXRVcmwoKTtcclxuZnVuY3Rpb24gc3RyaW5naWZ5VmFycyh2YXJzKSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LmtleXModmFycykubWFwKChrZXkpID0+IGAke2tleX09JHt2YXJzW2tleV19YCkuam9pbignLCcpO1xyXG59XHJcbmZ1bmN0aW9uIGNvdW50KHBpZCwgY2lkLCBwYXRoLCB2YXJzKSB7XHJcbiAgICBjb25zdCB1cmwgPSBgJHtTVEFUX1VSTH0vY291bnRlcmA7XHJcbiAgICBjb25zdCBkYXRhID0gYC9kdHlwZT1zdHJlZC9waWQ9JHtwaWR9L2NpZD0ke2NpZH1gICtcclxuICAgICAgICBgL3BhdGg9JHtwYXRoLmpvaW4oJy4nKX0vJHt2YXJzID8gYHZhcnM9JHtzdHJpbmdpZnlWYXJzKHZhcnMpfS9gIDogJyd9YDtcclxuICAgIGlmICghKG5hdmlnYXRvci5zZW5kQmVhY29uICYmIG5hdmlnYXRvci5zZW5kQmVhY29uKHVybCwgZGF0YSArICcqJykpKSB7XHJcbiAgICAgICAgY29uc3QgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcclxuICAgICAgICBpbWFnZS5zcmMgPSB1cmwgKyBkYXRhICsgYHJuZD0ke0RhdGUubm93KCl9JHtNYXRoLnJhbmRvbSgpICogMTAwIHwgMH0vKmA7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgUEVSRl9DT1VOVEVSX0lEID0gNzMzMjM7XHJcbi8qKlxyXG4gKiBMb2cgdXNlcidzIHJlbmRlcmluZyBwZXJmIHRvIHN0YXRmYWNlLlxyXG4gKlxyXG4gKiBAcGFyYW0gZnBzIEZQU1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvdW50RnBzKGZwcykge1xyXG4gICAgY29uc3Qgcm91bmRlZEZwcyA9IE1hdGguZmxvb3IoZnBzIC8gMTApICogMTA7XHJcbiAgICBjb3VudChQUk9KRUNUX0lELCBQRVJGX0NPVU5URVJfSUQsIFsnZnBzJywgYCR7cm91bmRlZEZwc30tJHtyb3VuZGVkRnBzICsgMTB9YCwgKGZwcyAqIDEwMCkudG9GaXhlZCgpXSk7XHJcbn1cclxuZnVuY3Rpb24gZW5jb2RlVGlsZUl0ZW0odGlsZUl0ZW0pIHtcclxuICAgIHJldHVybiBgJHt0aWxlSXRlbS54fS4ke3RpbGVJdGVtLnl9LiR7dGlsZUl0ZW0uem9vbX1gO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBjb3VudFRpbGVQYXJzZVRpbWUobGF5ZXIsIG1pblRpbWVUaWxlLCBtaW5UaW1lLCBtYXhUaW1lVGlsZSwgbWF4VGltZSwgbWVkaWFuVGltZVRpbGUsIG1lZGlhblRpbWUpIHtcclxuICAgIGNvdW50KFBST0pFQ1RfSUQsIFBFUkZfQ09VTlRFUl9JRCwgW1xyXG4gICAgICAgICd0aWxlX3BhcnNlJyxcclxuICAgICAgICBsYXllclxyXG4gICAgXSwge1xyXG4gICAgICAgIG1pblRpbWU6IG1pblRpbWUudG9GaXhlZCgpLFxyXG4gICAgICAgIG1lZGlhblRpbWU6IG1lZGlhblRpbWUudG9GaXhlZCgpLFxyXG4gICAgICAgIG1heFRpbWU6IG1heFRpbWUudG9GaXhlZCgpLFxyXG4gICAgICAgIG1pblRpbGVJdGVtOiBlbmNvZGVUaWxlSXRlbShtaW5UaW1lVGlsZSksXHJcbiAgICAgICAgbWVkaWFuVGlsZUl0ZW06IGVuY29kZVRpbGVJdGVtKG1lZGlhblRpbWVUaWxlKSxcclxuICAgICAgICBtYXhUaWxlSXRlbTogZW5jb2RlVGlsZUl0ZW0obWF4VGltZVRpbGUpXHJcbiAgICB9KTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gY291bnRUaWxlUHJvY2Vzc2luZ1RpbWUobGF5ZXIsIGl0ZW1zKSB7XHJcbiAgICBjb25zdCB2YXJzVG9Mb2cgPSB7fTtcclxuICAgIGl0ZW1zLmZvckVhY2goKGl0ZW0pID0+IHtcclxuICAgICAgICBpZiAoaXRlbS56b29tID09PSAnYXZlcmFnZScpIHtcclxuICAgICAgICAgICAgY291bnQoUFJPSkVDVF9JRCwgUEVSRl9DT1VOVEVSX0lELCBbXHJcbiAgICAgICAgICAgICAgICAndGlsZV9wcm9jZXNzaW5nX2F2ZXJhZ2UnLFxyXG4gICAgICAgICAgICAgICAgbGF5ZXIsXHJcbiAgICAgICAgICAgICAgICAoTWF0aC5jZWlsKGl0ZW0udGltZSAvIDI1MCkgKiAyNTApLnRvU3RyaW5nKClcclxuICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhcnNUb0xvZ1tpdGVtLnpvb21dID0gaXRlbS50aW1lLnRvRml4ZWQoKTtcclxuICAgIH0pO1xyXG4gICAgY291bnQoUFJPSkVDVF9JRCwgUEVSRl9DT1VOVEVSX0lELCBbJ3RpbGVfcHJvY2Vzc2luZycsIGxheWVyXSwgdmFyc1RvTG9nKTtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL3N0YXQudHNcbi8vIG1vZHVsZSBpZCA9IDE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydCBmdW5jdGlvbiBERUZBVUxUX0NPTVBBUkFUT1IoYSwgYikge1xyXG4gICAgaWYgKGEgPiBiKSB7XHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcbiAgICBpZiAoYSA8IGIpIHtcclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gMDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gTlVNRVJJQ0FMX0NPTVBBUkFUT1IoYSwgYikge1xyXG4gICAgcmV0dXJuIGEgLSBiO1xyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvY29tcGFyYXRvci50c1xuLy8gbW9kdWxlIGlkID0gMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIFNpbXBsZSByZWZlcmVuY2UgY291bnRpbmcgZm9yIHNoYXJlZCBlbnRpdGllcyB0aGF0IG5lZWQgZXhwbGljaXQgZGVzdHJ1Y3Rpb24uXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWZlcmVuY2VDb3VudGVkIHtcclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6ZXMgcmVmZXJlbmNlIGNvdW50IHRvIDEuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuX3JlZkNvdW50ID0gMTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSW5jcmVtZW50cyByZWZlcmVuY2UgY291bnQuXHJcbiAgICAgKi9cclxuICAgIHJldGFpbigpIHtcclxuICAgICAgICBpZiAodGhpcy5fcmVmQ291bnQgPT09IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmllZCB0byByZXRhaW4gYSBkZXN0cm95ZWQgb2JqZWN0LicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9yZWZDb3VudCsrO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWNyZW1lbnRzIHJlZmVyZW5jZSBjb3VudCBhbmQsIGlmIGl0J3MgcmVhY2hlZCAwLCBkZXN0cm95cyB0aGUgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICByZWxlYXNlKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9yZWZDb3VudCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyaWVkIHRvIHJlbGVhc2UgYSBkZXN0cm95ZWQgb2JqZWN0LicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9yZWZDb3VudC0tO1xyXG4gICAgICAgIGlmICh0aGlzLl9yZWZDb3VudCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLl9kZXN0cm95KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvcmVmX2NvdW50ZWQudHNcbi8vIG1vZHVsZSBpZCA9IDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBQcmltaXRpdmVNYW5hZ2VyIGZyb20gJy4vcHJpbWl0aXZlX21hbmFnZXInO1xyXG4vKipcclxuICogTWFuYWdlciBvZiBwcmltaXRpdmVzIHRoYXQgaGF2ZSBhIHNpbmdsZSBhc3NpY2lhdGVkIHJlbmRlcmFibGUgcHJpbWl0aXZlLiBUaGUgXCJtYW5hZ2VtZW50XCIgaXMgcHJldHR5IHN0cmFpZ2h0Zm9yd2FyZDpcclxuICogaXQgZGlyZWN0bHkgYWRkcy9yZW1vdmVzIGFzc29jaWF0ZWQgcHJpbWl0aXZlcyBpbnRvIHRoZSBzdG9yYWdlLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVuZGVyYWJsZVByaW1pdGl2ZU1hbmFnZXIgZXh0ZW5kcyBQcmltaXRpdmVNYW5hZ2VyIHtcclxuICAgIGNvbnN0cnVjdG9yKHByaW1pdGl2ZXNTdG9yYWdlKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl9wcmltaXRpdmVzU3RvcmFnZSA9IHByaW1pdGl2ZXNTdG9yYWdlO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlU2NlbmUodG9TaG93LCB0b0hpZGUpIHtcclxuICAgICAgICB0aGlzLl9wcmltaXRpdmVzU3RvcmFnZS5hZGQoLi4udG9TaG93KTtcclxuICAgICAgICB0aGlzLl9wcmltaXRpdmVzU3RvcmFnZS5kZWxldGUoLi4udG9IaWRlKTtcclxuICAgIH1cclxuICAgIGRlc3Ryb3lQcmltaXRpdmVzKF90b0Rlc3Ryb3kpIHtcclxuICAgICAgICAvLyBubyBuZWVkIHRvIGRlc3Ryb3kgYW55dGhpbmcsIFJlbmRlcmFibGVQcmltaXRpdmUgYXJlIHJlbGVhc2VkIHdoZW4gcmVtb3ZlZCBmcm9tIHByaW1taXRpdmUgc3RvcmFnZVxyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2FkYXB0ZXJzL3ZlY3Rvcl9hcGkvcHJpbWl0aXZlX21hbmFnZXIvcmVuZGVyYWJsZV9wcmltaXRpdmVfbWFuYWdlci50c1xuLy8gbW9kdWxlIGlkID0gMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHBvbHlnb25WZXJ0ZXhTaGFkZXIgZnJvbSAnLi9zaGFkZXIvcG9seWdvbi52ZXJ0JztcclxuaW1wb3J0IHBvbHlnb25GcmFnbWVudFNoYWRlciBmcm9tICcuL3NoYWRlci9wb2x5Z29uLmZyYWcnO1xyXG5pbXBvcnQgUmVuZGVyU3RhdGUgZnJvbSAnLi4vLi4vLi4vcmVuZGVyL3N0YXRlJztcclxuaW1wb3J0IFdvcmxkUHJpbWl0aXZlUmVuZGVyVW5pdCBmcm9tICcuLi93b3JsZF9wcmltaXRpdmVfcmVuZGVyX3VuaXQnO1xyXG5leHBvcnQgY29uc3QgREVGQVVMVF9SRU5ERVJfU1RBVEVfUEFSQU1TID0ge1xyXG4gICAgZGVwdGhUZXN0OiB0cnVlLFxyXG4gICAgZGVwdGhGdW5jOiA1MTggLyogR1JFQVRFUl9PUl9FUVVBTCAqL1xyXG59O1xyXG4vKipcclxuICogUmVuZGVyZXIgb2YgcG9seWdvbiBwcmltaXRpdmVzLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9seWdvblJlbmRlclVuaXQgZXh0ZW5kcyBXb3JsZFByaW1pdGl2ZVJlbmRlclVuaXQge1xyXG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgcHJpbWl0aXZlUHJvdmlkZXIsIHJlbmRlclN0YXRlID0gbmV3IFJlbmRlclN0YXRlKERFRkFVTFRfUkVOREVSX1NUQVRFX1BBUkFNUykpIHtcclxuICAgICAgICBjb25zdCBwcm9ncmFtID0gY29udGV4dC5jcmVhdGVQcm9ncmFtKHBvbHlnb25WZXJ0ZXhTaGFkZXIsIHBvbHlnb25GcmFnbWVudFNoYWRlciwge1xyXG4gICAgICAgICAgICBhdHRyaWJNYXA6IHtcclxuICAgICAgICAgICAgICAgIHZlcnRleFBvc0hpZ2g6IDAgLyogUE9TSVRJT05fSElHSCAqLyxcclxuICAgICAgICAgICAgICAgIHZlcnRleFBvc0xvdzogMSAvKiBQT1NJVElPTl9MT1cgKi8sXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhDb2xvcjogNyAvKiBDT0xPUiAqLyxcclxuICAgICAgICAgICAgICAgIHZlcnRleFpJbmRleDogMTAgLyogWl9JTkRFWCAqL1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc3VwZXIoY29udGV4dCwgcmVuZGVyU3RhdGUsIHByb2dyYW0sIHByaW1pdGl2ZVByb3ZpZGVyKTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9wb2x5Z29uL3BvbHlnb25fcmVuZGVyX3VuaXQudHNcbi8vIG1vZHVsZSBpZCA9IDIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IFZvaWRFdmVudEVtaXR0ZXIgfSBmcm9tICcuLi91dGlsL2V2ZW50X2VtaXR0ZXInO1xyXG5jbGFzcyBOb0Jhc2VSZW5kZXJVbml0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcignQmFzZSByZW5kZXIgdW5pdCBpcyBub3QgaW4gdGhlIGxpc3QnKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogU2ltcGxlIGltcGxlbWVudGF0aW9uIG9mIENvbXBvc2l0ZVJlbmRlclVuaXQgdGhhdCBqdXN0IHJ1bnMgc3ViIHVuaXRzIGluIHRoZSBvcmRlciBvZiBhZGRpdGlvbi5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpc3RSZW5kZXJVbml0IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMub25VcGRhdGUgPSBuZXcgVm9pZEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMuX3N1YlJlbmRlclVuaXRzID0gW107XHJcbiAgICAgICAgdGhpcy5fc3ViUmVuZGVyVW5pdFVwZGF0ZUxpc3RlbmVyID0gdGhpcy5fb25TdWJSZW5kZXJVbml0VXBkYXRlLmJpbmQodGhpcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgUmVuZGVyVW5pdCB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LlxyXG4gICAgICovXHJcbiAgICBhZGRSZW5kZXJVbml0KHN1YlJlbmRlclVuaXQpIHtcclxuICAgICAgICB0aGlzLl9zdWJSZW5kZXJVbml0cy5wdXNoKHN1YlJlbmRlclVuaXQpO1xyXG4gICAgICAgIHN1YlJlbmRlclVuaXQub25VcGRhdGUuYWRkTGlzdGVuZXIodGhpcy5fc3ViUmVuZGVyVW5pdFVwZGF0ZUxpc3RlbmVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBSZW5kZXJVbml0IGZyb20gdGhlIGxpc3QuXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZVJlbmRlclVuaXQoc3ViUmVuZGVyVW5pdCkge1xyXG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fc3ViUmVuZGVyVW5pdHMuaW5kZXhPZihzdWJSZW5kZXJVbml0KTtcclxuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N1YlJlbmRlclVuaXRzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIHN1YlJlbmRlclVuaXQub25VcGRhdGUucmVtb3ZlTGlzdGVuZXIodGhpcy5fc3ViUmVuZGVyVW5pdFVwZGF0ZUxpc3RlbmVyKTtcclxuICAgICAgICAgICAgdGhpcy5vblVwZGF0ZS5maXJlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIFJlbmRlclVuaXQgYWJvdmUgdGhlIGJhc2Ugb25lLiBcIkFib3ZlXCIgbWVhbnMgdGhhdCBpdHMgcmVuZGVyKCkgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRoZSBiYXNlJ3Mgb25lLlxyXG4gICAgICovXHJcbiAgICBhZGRSZW5kZXJVbml0QWJvdmUoYmFzZSwgc3ViUmVuZGVyVW5pdCkge1xyXG4gICAgICAgIGNvbnN0IGJhc2VJbmRleCA9IHRoaXMuX3N1YlJlbmRlclVuaXRzLmluZGV4T2YoYmFzZSk7XHJcbiAgICAgICAgaWYgKGJhc2VJbmRleCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3ViUmVuZGVyVW5pdHMuc3BsaWNlKGJhc2VJbmRleCArIDEsIDAsIHN1YlJlbmRlclVuaXQpO1xyXG4gICAgICAgICAgICBzdWJSZW5kZXJVbml0Lm9uVXBkYXRlLmFkZExpc3RlbmVyKHRoaXMuX3N1YlJlbmRlclVuaXRVcGRhdGVMaXN0ZW5lcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgTm9CYXNlUmVuZGVyVW5pdEVycm9yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIFJlbmRlclVuaXQgYmVsb3cgdGhlIGJhc2Ugb25lLiBcIkJlbG93XCIgbWVhbnMgdGhhdCBpdHMgcmVuZGVyKCkgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIGJlZm9yZSB0aGUgYmFzZSdzIG9uZS5cclxuICAgICAqL1xyXG4gICAgYWRkUmVuZGVyVW5pdEJlbG93KGJhc2UsIHN1YlJlbmRlclVuaXQpIHtcclxuICAgICAgICBjb25zdCBiYXNlSW5kZXggPSB0aGlzLl9zdWJSZW5kZXJVbml0cy5pbmRleE9mKGJhc2UpO1xyXG4gICAgICAgIGlmIChiYXNlSW5kZXggIT09IC0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N1YlJlbmRlclVuaXRzLnNwbGljZShiYXNlSW5kZXgsIDAsIHN1YlJlbmRlclVuaXQpO1xyXG4gICAgICAgICAgICBzdWJSZW5kZXJVbml0Lm9uVXBkYXRlLmFkZExpc3RlbmVyKHRoaXMuX3N1YlJlbmRlclVuaXRVcGRhdGVMaXN0ZW5lcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgTm9CYXNlUmVuZGVyVW5pdEVycm9yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVuZGVyKHRhcmdldCwgLi4uYXJncykge1xyXG4gICAgICAgIGZvciAoY29uc3QgcmVuZGVyZXIgb2YgdGhpcy5fc3ViUmVuZGVyVW5pdHMpIHtcclxuICAgICAgICAgICAgcmVuZGVyZXIucmVuZGVyKHRhcmdldCwgLi4uYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX29uU3ViUmVuZGVyVW5pdFVwZGF0ZSgpIHtcclxuICAgICAgICB0aGlzLm9uVXBkYXRlLmZpcmUoKTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvbGlzdF9yZW5kZXJfdW5pdC50c1xuLy8gbW9kdWxlIGlkID0gMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICogYXMgdmVjdG9yMyBmcm9tICcuL3ZlY3RvcjMnO1xyXG4vLyBUT0RPKGRtaWtpcykgUm9NYXRyaXg0P1xyXG5leHBvcnQgY29uc3QgSURFTlRJVFkgPSBbXHJcbiAgICAxLCAwLCAwLCAwLFxyXG4gICAgMCwgMSwgMCwgMCxcclxuICAgIDAsIDAsIDEsIDAsXHJcbiAgICAwLCAwLCAwLCAxXHJcbl07XHJcbmV4cG9ydCBjb25zdCBaRVJPID0gW1xyXG4gICAgMCwgMCwgMCwgMCxcclxuICAgIDAsIDAsIDAsIDAsXHJcbiAgICAwLCAwLCAwLCAwLFxyXG4gICAgMCwgMCwgMCwgMFxyXG5dO1xyXG5jb25zdCBNQVRSSVhfU0laRSA9IDE2O1xyXG4vKipcclxuICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIG5ldyAqKnVuaW5pdGlhbGl6ZWQqKiBtYXRyaXguXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKCkge1xyXG4gICAgcmV0dXJuIG5ldyBBcnJheShNQVRSSVhfU0laRSk7XHJcbn1cclxuLyoqXHJcbiAqIFplcm9lcyBhIG1hdHJpeC5cclxuICpcclxuICogQHBhcmFtIGRzdCBUaGUgbWF0cml4LlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB6ZXJvKGRzdCA9IGNyZWF0ZSgpKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1BVFJJWF9TSVpFOyArK2kpIHtcclxuICAgICAgICBkc3RbaV0gPSAwO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogQ29waWVzIGEgbWF0cml4IHRvIGFub3RoZXIgb25lLlxyXG4gKlxyXG4gKiBAcGFyYW0gc3JjIFRoZSBtYXRyaXggdG8gYmUgY29waWVkLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSBtYXRyaXggdGhlIGBzcmNgIHdpbGwgYmUgY29waWVkIHRvLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb3B5KHNyYywgZHN0ID0gY3JlYXRlKCkpIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTUFUUklYX1NJWkU7ICsraSkge1xyXG4gICAgICAgIGRzdFtpXSA9IHNyY1tpXTtcclxuICAgIH1cclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIEFwcGxpZXMgYSByb3RhdGlvbiBhcm91bmQgdGhlIFggYXhpcyBieSBhIGdpdmVuIGFuZ2xlIHRvIGEgZ2l2ZW4gbWF0cml4LlxyXG4gKiBQb3NpdGl2ZSBkaXJlY3Rpb24gaXMgZnJvbSBwb3NpdGl2ZSBZIHRvIHBvc2l0aXZlIFouXHJcbiAqXHJcbiAqIEBwYXJhbSBzcmMgVGhlIG1hdHJpeCB0byBiZSBtdWx0aXBsaWVkIGJ5IHRoZSByb3RhdGlvbiBtYXRyaXguXHJcbiAqIEBwYXJhbSBhbmdsZSBUaGUgYW5nbGUgb2Ygcm90YXRpb24uXHJcbiAqIEBwYXJhbSBkc3QgVGhlIG1hdHJpeCB0aGUgcHJvZHVjdCB3aWxsIGJlIHN0b3JlZCB0by4gQ2FuIGJlIHRoZSBzYW1lIGFzIGBzcmNgLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVYKHNyYywgYW5nbGUsIGRzdCA9IGNyZWF0ZSgpKSB7XHJcbiAgICBjb25zdCBhbmdsZUNvcyA9IE1hdGguY29zKGFuZ2xlKTtcclxuICAgIGNvbnN0IGFuZ2xlU2luID0gTWF0aC5zaW4oYW5nbGUpO1xyXG4gICAgLy8gVGhlIHJvdGF0aW9uIG1hdHJpeDpcclxuICAgIC8vXHJcbiAgICAvLyAxICAgMCAgICAwIDBcclxuICAgIC8vIDAgY29zIC1zaW4gMFxyXG4gICAgLy8gMCBzaW4gIGNvcyAwXHJcbiAgICAvLyAwICAgMCAgICAwIDFcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTUFUUklYX1NJWkU7IGkgKz0gNCkge1xyXG4gICAgICAgIGRzdFtpXSA9IHNyY1tpXTtcclxuICAgICAgICBjb25zdCBtMWkgPSBzcmNbaSArIDFdO1xyXG4gICAgICAgIGNvbnN0IG0yaSA9IHNyY1tpICsgMl07XHJcbiAgICAgICAgZHN0W2kgKyAxXSA9IG0xaSAqIGFuZ2xlQ29zIC0gbTJpICogYW5nbGVTaW47XHJcbiAgICAgICAgZHN0W2kgKyAyXSA9IG0xaSAqIGFuZ2xlU2luICsgbTJpICogYW5nbGVDb3M7XHJcbiAgICAgICAgZHN0W2kgKyAzXSA9IHNyY1tpICsgM107XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbi8qKlxyXG4gKiBBcHBsaWVzIGEgcm90YXRpb24gYXJvdW5kIHRoZSBZIGF4aXMgYnkgYSBnaXZlbiBhbmdsZSB0byBhIGdpdmVuIG1hdHJpeC5cclxuICogUG9zaXRpdmUgZGlyZWN0aW9uIGlzIGZyb20gcG9zaXRpdmUgWCB0byBwb3NpdGl2ZSBaLlxyXG4gKlxyXG4gKiBAcGFyYW0gc3JjIFRoZSBtYXRyaXggdG8gYmUgbXVsdGlwbGllZCBieSB0aGUgcm90YXRpb24gbWF0cml4LlxyXG4gKiBAcGFyYW0gYW5nbGUgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSBtYXRyaXggdGhlIHByb2R1Y3Qgd2lsbCBiZSBzdG9yZWQgdG8uIENhbiBiZSB0aGUgc2FtZSBhcyBgc3JjYC5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWShzcmMsIGFuZ2xlLCBkc3QgPSBjcmVhdGUoKSkge1xyXG4gICAgY29uc3QgYW5nbGVDb3MgPSBNYXRoLmNvcyhhbmdsZSk7XHJcbiAgICBjb25zdCBhbmdsZVNpbiA9IE1hdGguc2luKGFuZ2xlKTtcclxuICAgIC8vIFRoZSByb3RhdGlvbiBtYXRyaXg6XHJcbiAgICAvL1xyXG4gICAgLy8gY29zIDAgLXNpbiAwXHJcbiAgICAvLyAwICAgMSAgICAwIDBcclxuICAgIC8vIHNpbiAwICBjb3MgMFxyXG4gICAgLy8gMCAgICAwICAgMCAxXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1BVFJJWF9TSVpFOyBpICs9IDQpIHtcclxuICAgICAgICBjb25zdCBtMGkgPSBzcmNbaV07XHJcbiAgICAgICAgY29uc3QgbTJpID0gc3JjW2kgKyAyXTtcclxuICAgICAgICBkc3RbaV0gPSBtMGkgKiBhbmdsZUNvcyAtIG0yaSAqIGFuZ2xlU2luO1xyXG4gICAgICAgIGRzdFtpICsgMV0gPSBzcmNbaSArIDFdO1xyXG4gICAgICAgIGRzdFtpICsgMl0gPSBtMGkgKiBhbmdsZVNpbiArIG0yaSAqIGFuZ2xlQ29zO1xyXG4gICAgICAgIGRzdFtpICsgM10gPSBzcmNbaSArIDNdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogQXBwbGllcyBhIHJvdGF0aW9uIGFyb3VuZCB0aGUgWCBheGlzIGJ5IGEgZ2l2ZW4gYW5nbGUgdG8gYSBnaXZlbiBtYXRyaXguXHJcbiAqIFBvc2l0aXZlIGRpcmVjdGlvbiBpcyBmcm9tIHBvc2l0aXZlIFggdG8gcG9zaXRpdmUgWS5cclxuICpcclxuICogQHBhcmFtIHNyYyBUaGUgbWF0cml4IHRvIGJlIG11bHRpcGxpZWQgYnkgdGhlIHJvdGF0aW9uIG1hdHJpeC5cclxuICogQHBhcmFtIGFuZ2xlIFRoZSBhbmdsZSBvZiByb3RhdGlvbi5cclxuICogQHBhcmFtIGRzdCBUaGUgbWF0cml4IHRoZSBwcm9kdWN0IHdpbGwgYmUgc3RvcmVkIHRvLiBDYW4gYmUgdGhlIHNhbWUgYXMgYHNyY2AuXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVooc3JjLCBhbmdsZSwgZHN0ID0gY3JlYXRlKCkpIHtcclxuICAgIGNvbnN0IGFuZ2xlQ29zID0gTWF0aC5jb3MoYW5nbGUpO1xyXG4gICAgY29uc3QgYW5nbGVTaW4gPSBNYXRoLnNpbihhbmdsZSk7XHJcbiAgICAvLyBUaGUgcm90YXRpb24gbWF0cml4OlxyXG4gICAgLy8gY29zIC1zaW4gMCAwXHJcbiAgICAvLyBzaW4gIGNvcyAwIDBcclxuICAgIC8vICAgMCAgICAwIDEgMFxyXG4gICAgLy8gICAwICAgIDAgMCAxXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1BVFJJWF9TSVpFOyBpICs9IDQpIHtcclxuICAgICAgICBjb25zdCBtMGkgPSBzcmNbaV07XHJcbiAgICAgICAgY29uc3QgbTFpID0gc3JjW2kgKyAxXTtcclxuICAgICAgICBkc3RbaV0gPSBtMGkgKiBhbmdsZUNvcyAtIG0xaSAqIGFuZ2xlU2luO1xyXG4gICAgICAgIGRzdFtpICsgMV0gPSBtMGkgKiBhbmdsZVNpbiArIG0xaSAqIGFuZ2xlQ29zO1xyXG4gICAgICAgIGRzdFtpICsgMl0gPSBzcmNbaSArIDJdO1xyXG4gICAgICAgIGRzdFtpICsgM10gPSBzcmNbaSArIDNdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogQXBwbGllcyBhIHRyYW5zbGF0aW9uIGJ5IGEgZ2l2ZW4gdmVjdG9yIHRvIGEgZ2l2ZW4gbWF0cml4LlxyXG4gKlxyXG4gKiBAcGFyYW0gc3JjIFRoZSBtYXRyaXggdG8gYmUgbXVsdGlwbGllZCBieSB0aGUgdHJhbnNsYXRpb24gbWF0cml4LlxyXG4gKiBAcGFyYW0gdHJhbnNsYXRpb24gVGhlIHRyYW5zbGF0aW9uIHZlY3Rvci5cclxuICogQHBhcmFtIGRzdCBUaGUgbWF0cml4IHRoZSBwcm9kdWN0IHdpbGwgYmUgc3RvcmVkIHRvLiBDYW4gYmUgdGhlIHNhbWUgYXMgYHNyY2AuXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zbGF0ZShzcmMsIHRyYW5zbGF0aW9uLCBkc3QgPSBjcmVhdGUoKSkge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNQVRSSVhfU0laRTsgaSArPSA0KSB7XHJcbiAgICAgICAgY29uc3QgbTRpID0gZHN0W2kgKyAzXSA9IHNyY1tpICsgM107XHJcbiAgICAgICAgZHN0W2ldID0gc3JjW2ldICsgbTRpICogdHJhbnNsYXRpb24ueDtcclxuICAgICAgICBkc3RbaSArIDFdID0gc3JjW2kgKyAxXSArIG00aSAqIHRyYW5zbGF0aW9uLnk7XHJcbiAgICAgICAgZHN0W2kgKyAyXSA9IHNyY1tpICsgMl0gKyBtNGkgKiB0cmFuc2xhdGlvbi56O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogQXBwbGllcyBhIHNjYWxlIG1hdHJpeCBieSBnaXZlbiBmYWN0b3JzIChwYWNrZWQgaW50byBhIHZlY3RvcikgdG8gYSBnaXZlblxyXG4gKiBtYXRyaXguXHJcbiAqXHJcbiAqIEBwYXJhbSBzcmMgVGhlIG1hdHJpeCB0byBiZSBtdWx0aXBsaWVkIGJ5IHRoZSBzY2FsZSBtYXRyaXguXHJcbiAqIEBwYXJhbSBmYWN0b3IgVGhlIHZlY3RvciB0aGUgc2NhbGUgZmFjdG9ycyBwYWNrZWQgaW50by5cclxuICogQHBhcmFtIGRzdCBUaGUgbWF0cml4IHRoZSBwcm9kdWN0IHdpbGwgYmUgc3RvcmVkIHRvLiBDYW4gYmUgdGhlIHNhbWUgYXMgYHNyY2AuXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKHNyYywgZmFjdG9yLCBkc3QgPSBjcmVhdGUoKSkge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNQVRSSVhfU0laRTsgaSArPSA0KSB7XHJcbiAgICAgICAgZHN0W2ldID0gc3JjW2ldICogZmFjdG9yLng7XHJcbiAgICAgICAgZHN0W2kgKyAxXSA9IHNyY1tpICsgMV0gKiBmYWN0b3IueTtcclxuICAgICAgICBkc3RbaSArIDJdID0gc3JjW2kgKyAyXSAqIGZhY3Rvci56O1xyXG4gICAgICAgIGRzdFtpICsgM10gPSBzcmNbaSArIDNdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vLyBUaGUgbWF0cml4OlxyXG4vLyB4QXhpcy54IHlBeGlzLnggekF4aXMueCAtZXllLnhcclxuLy8geEF4aXMueSB5QXhpcy55IHpBeGlzLnkgLWV5ZS55XHJcbi8vIHhBeGlzLnogeUF4aXMueiB6QXhpcy56IC1leWUuelxyXG4vLyAgICAgICAwICAgICAgIDAgICAgICAgMCAxXHJcbi8vIHdoZXJlIHhBeGlzLCB5QXhpcyBhbmQgekF4aXMg4oCUIGF4ZXMgb2YgdGhlIGV5ZSBjb29yZGluYXRlIHN5c3RlbSwgZXllIOKAlFxyXG4vLyBvcmlnaW4gb2YgdGhlIGV5ZSBjb29yZGluYXRlIHN5c3RlbS5cclxuY29uc3QgbG9va0F0TWF0cml4ID0gY29weShJREVOVElUWSk7XHJcbi8qKlxyXG4gKiBBcHBsaWVzIGEgbWF0cml4IG9mIHRyYW5zZm9ybWF0aW9uIGludG8gYSBjb29yZGluYXRlIHN5c3RlbSBvZiBhIGNhbWVyYVxyXG4gKiBkZWZpbmVkIGJ5IGl0cyBwb3NpdGlvbiwgYSBwb2ludCBpdCdzIGxvb2tpbmcgYXQgYW5kIGFuIHVwIGRpcmVjdGlvbiB2ZWN0b3IuXHJcbiAqXHJcbiAqIEBwYXJhbSBzcmMgVGhlIG1hdHJpeCB0byBiZSBtdWx0aXBsaWVkIGJ5IHRoZSBzY2FsZSBtYXRyaXguXHJcbiAqIEBwYXJhbSBleWUgVGhlIHBvc2l0aW9uIG9mIHRoZSBjYW1lcmEuXHJcbiAqIEBwYXJhbSBjZW50ZXIgVGhlIHBvaW50IHRoZSBjYW1lcmEncyBsb29raW5nIGF0LlxyXG4gKiBAcGFyYW0gdXAgVGhlIHVwIHZlY3Rvci5cclxuICogQHBhcmFtIGRzdCBUaGUgbWF0cml4IHRoZSBwcm9kdWN0IHdpbGwgYmUgc3RvcmVkIHRvLiBDYW4gYmUgdGhlIHNhbWUgYXMgYHNyY2AuXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGxvb2tBdChzcmMsIGV5ZSwgY2VudGVyLCB1cCwgZHN0ID0gY3JlYXRlKCkpIHtcclxuICAgIGNvbnN0IHpBeGlzID0gdmVjdG9yMy5zdWIoZXllLCBjZW50ZXIpO1xyXG4gICAgdmVjdG9yMy5ub3JtYWxpemUoekF4aXMsIHpBeGlzKTtcclxuICAgIGNvbnN0IHhBeGlzID0gdmVjdG9yMy5jcm9zcyh1cCwgekF4aXMpO1xyXG4gICAgdmVjdG9yMy5ub3JtYWxpemUoeEF4aXMsIHhBeGlzKTtcclxuICAgIGNvbnN0IHlBeGlzID0gdmVjdG9yMy5jcm9zcyh6QXhpcywgeEF4aXMpO1xyXG4gICAgbG9va0F0TWF0cml4WzBdID0geEF4aXMueDtcclxuICAgIGxvb2tBdE1hdHJpeFsxXSA9IHlBeGlzLng7XHJcbiAgICBsb29rQXRNYXRyaXhbMl0gPSB6QXhpcy54O1xyXG4gICAgbG9va0F0TWF0cml4WzRdID0geEF4aXMueTtcclxuICAgIGxvb2tBdE1hdHJpeFs1XSA9IHlBeGlzLnk7XHJcbiAgICBsb29rQXRNYXRyaXhbNl0gPSB6QXhpcy55O1xyXG4gICAgbG9va0F0TWF0cml4WzhdID0geEF4aXMuejtcclxuICAgIGxvb2tBdE1hdHJpeFs5XSA9IHlBeGlzLno7XHJcbiAgICBsb29rQXRNYXRyaXhbMTBdID0gekF4aXMuejtcclxuICAgIGxvb2tBdE1hdHJpeFsxMl0gPSAtdmVjdG9yMy5kb3QoeEF4aXMsIGV5ZSk7XHJcbiAgICBsb29rQXRNYXRyaXhbMTNdID0gLXZlY3RvcjMuZG90KHlBeGlzLCBleWUpO1xyXG4gICAgbG9va0F0TWF0cml4WzE0XSA9IC12ZWN0b3IzLmRvdCh6QXhpcywgZXllKTtcclxuICAgIHJldHVybiBtdWwoc3JjLCBsb29rQXRNYXRyaXgsIGRzdCk7XHJcbn1cclxuLyoqXHJcbiAqIEFwcGxpZXMgYSBwZXJzcGVjdGl2ZSBtYXRyaXggdG8gYSBnaXZlbiBvbmUuXHJcbiAqXHJcbiAqIEBwYXJhbSBzcmMgVGhlIG1hdHJpeCB0byBiZSBtdWx0aXBsaWVkIGJ5IHRoZSBwZXJzcGVjdGl2ZSBtYXRyaXguXHJcbiAqIEBwYXJhbSBmb3YgVmVydGljYWwgZmllbGQgb2YgdmlldyBhbmdsZS5cclxuICogQHBhcmFtIGFzcGVjdFJhdGlvIFNjcmVlbiBhc3BlY3QgcmF0aW8uXHJcbiAqIEBwYXJhbSB6TmVhciBaLWNvb3JkaW5hdGUgb2YgbmVhciBjbGlwcGluZyBwbGFuZS5cclxuICogQHBhcmFtIHpGYXIgWi1jb29yZGluYXRlIG9mIGZhciBjbGlwcGluZyBwbGFuZS5cclxuICogQHBhcmFtIGRzdCBUaGUgbWF0cml4IHRoZSBwcm9kdWN0IHdpbGwgYmUgc3RvcmVkIHRvLiBDYW4gYmUgdGhlIHNhbWUgYXMgYHNyY2AuXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHBlcnNwZWN0aXZlKHNyYywgZm92LCBhc3BlY3QsIHpOZWFyLCB6RmFyLCBkc3QgPSBjcmVhdGUoKSkge1xyXG4gICAgY29uc3QgcDExID0gMSAvIE1hdGgudGFuKDAuNSAqIGZvdik7XHJcbiAgICBjb25zdCBwMDAgPSBwMTEgLyBhc3BlY3Q7XHJcbiAgICBjb25zdCBwMjIgPSAoek5lYXIgKyB6RmFyKSAvICh6TmVhciAtIHpGYXIpO1xyXG4gICAgY29uc3QgcDMyID0gMiAqIHpOZWFyICogekZhciAvICh6TmVhciAtIHpGYXIpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNQVRSSVhfU0laRTsgaSArPSA0KSB7XHJcbiAgICAgICAgZHN0W2ldID0gc3JjW2ldICogcDAwO1xyXG4gICAgICAgIGRzdFtpICsgMV0gPSBzcmNbaSArIDFdICogcDExO1xyXG4gICAgICAgIGNvbnN0IG0yaSA9IHNyY1tpICsgMl07XHJcbiAgICAgICAgY29uc3QgbTNpID0gc3JjW2kgKyAzXTtcclxuICAgICAgICBkc3RbaSArIDJdID0gbTJpICogcDIyICsgbTNpICogcDMyO1xyXG4gICAgICAgIGRzdFtpICsgM10gPSAtbTJpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogTXVsdGlwbGllcyBhIG1hdHJpeCBieSBhbm90aGVyIG9uZSwgaS5lLiBgZHN0ID0gbSAqIHNyY2AuXHJcbiAqXHJcbiAqIEBwYXJhbSBzcmMgVGhlIHJpZ2h0IG1hdHJpeC5cclxuICogQHBhcmFtIG0gVGhlIGxlZnQgbWF0cml4LlxyXG4gKiBAcGFyYW0gZHN0IFRoZSBtYXRyaXggdGhlIHByb2R1Y3Qgd2lsbCBiZSBzdG9yZWQgdG8uIENhbiBiZSB0aGUgc2FtZSBhcyBgc3JjYC5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbXVsKHNyYywgbSwgZHN0ID0gY3JlYXRlKCkpIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTUFUUklYX1NJWkU7IGkgKz0gNCkge1xyXG4gICAgICAgIGNvbnN0IG0waSA9IHNyY1tpXTtcclxuICAgICAgICBjb25zdCBtMWkgPSBzcmNbaSArIDFdO1xyXG4gICAgICAgIGNvbnN0IG0yaSA9IHNyY1tpICsgMl07XHJcbiAgICAgICAgY29uc3QgbTNpID0gc3JjW2kgKyAzXTtcclxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDQ7ICsraikge1xyXG4gICAgICAgICAgICBkc3RbaSArIGpdID0gbTBpICogbVtqXSArIG0xaSAqIG1bNCArIGpdICsgbTJpICogbVs4ICsgal0gK1xyXG4gICAgICAgICAgICAgICAgbTNpICogbVsxMiArIGpdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIEFwcGxpZXMgYSBtYXRyaXggdG8gYSB2ZWN0b3IuXHJcbiAqXHJcbiAqIEBwYXJhbSBtIFRoZSBtYXRyaXguXHJcbiAqIEBwYXJhbSB2IFRoZSB2ZWN0b3IuXHJcbiAqIEByZXR1cm5zIE5vcm1hbGl6ZWQgcHJvZHVjdCBvZiBtdWx0aXBseWluZyB0aGUgdmVjdG9yIGJ5IHRoZSBtYXRyaXguXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYXBwbHkobSwgdiwgZHN0ID0gdmVjdG9yMy5jcmVhdGUoMCwgMCwgMCkpIHtcclxuICAgIGNvbnN0IHcgPSBtWzNdICogdi54ICsgbVs3XSAqIHYueSArIG1bMTFdICogdi56ICsgbVsxNV07XHJcbiAgICBjb25zdCB4ID0gKG1bMF0gKiB2LnggKyBtWzRdICogdi55ICsgbVs4XSAqIHYueiArIG1bMTJdKSAvIHc7XHJcbiAgICBjb25zdCB5ID0gKG1bMV0gKiB2LnggKyBtWzVdICogdi55ICsgbVs5XSAqIHYueiArIG1bMTNdKSAvIHc7XHJcbiAgICBjb25zdCB6ID0gKG1bMl0gKiB2LnggKyBtWzZdICogdi55ICsgbVsxMF0gKiB2LnogKyBtWzE0XSkgLyB3O1xyXG4gICAgZHN0LnggPSB4O1xyXG4gICAgZHN0LnkgPSB5O1xyXG4gICAgZHN0LnogPSB6O1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9tYXRoL21hdHJpeDQudHNcbi8vIG1vZHVsZSBpZCA9IDI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydCBjb25zdCBERUZBVUxUX1RPTEVSQU5DRSA9IDFlLTY7XHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgdHdvIGZsb2F0aW5nIHBvaW50IG51bWJlciBhcmUgd2l0aGluIGEgdG9sZXJhbmNlIGZyb20gZWFjaCBvdGhlci5cclxuICpcclxuICogQHBhcmFtIGEgVGhlIGZpcnN0IG51bWJlci5cclxuICogQHBhcmFtIGIgVGhlIHNlY29uZCBudW1iZXIuXHJcbiAqIEBwYXJhbSB0b2xlcmFuY2UgVGhlIHRvbGVyYW5jZS5cclxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBudW1iZXIgYXJlIHdpdGhpbiB0aGUgdG9sZXJhbmNlIGFuZCBgZmFsc2VgIG90aGVyd2lzZS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFyZUZ1enp5RXF1YWwoYSwgYiwgdG9sZXJhbmNlID0gREVGQVVMVF9UT0xFUkFOQ0UpIHtcclxuICAgIGNvbnN0IGQgPSBhIC0gYjtcclxuICAgIHJldHVybiAtdG9sZXJhbmNlIDwgZCAmJiBkIDwgdG9sZXJhbmNlO1xyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvZnV6enlfZXF1YWwudHNcbi8vIG1vZHVsZSBpZCA9IDI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImxldCBpZCA9IDE7XHJcbi8qKlxyXG4gKiBHZW5lcmF0ZXMgdW5pcXVlIGlkXHJcbiovXHJcbmV4cG9ydCBmdW5jdGlvbiB1bmlxdWVJZCgpIHtcclxuICAgIHJldHVybiBpZCsrO1xyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvdW5pcXVlX2lkLnRzXG4vLyBtb2R1bGUgaWQgPSAyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBjb3VudEluZGljZXMgfSBmcm9tICcuL2NvdW50X3ZlcnRpY2VzJztcclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSByZWdpb24gaW4gYSBtZW1vcnkgY2h1bmsuIE1lbW9yeSBpcyBhbGxvY2F0ZWQgYnkgYmlnIGNodW5rcyBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucyxcclxuICogYW5kIHdlIG5lZWQgYSBtZWNoYW5pc20gdG8gY29udHJvbCB0aG9zZSBjaHVuaydzIHN1YmFsbG9jYXRpb24gdG8gcHJvcGVybHkgZnJlZVxyXG4gKiB0aGUgb2NjdXBpZWQgbWVtb3J5IC0gdGhhdCBpcyB3aGF0IHRoaXMgY2xhc3MgaXMgZm9yLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWVtb3J5U3ViQ2h1bmsge1xyXG4gICAgY29uc3RydWN0b3IoY2h1bmssIGxvY2F0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5tZW1vcnlDaHVuayA9IGNodW5rO1xyXG4gICAgICAgIHRoaXMuX2xvY2F0aW9uID0gbG9jYXRpb247XHJcbiAgICAgICAgY2h1bmsucmV0YWluKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIE9mZnNldCBvZiB2ZXJ0ZXggZGF0YSBvZiB0aGUgY2h1bmsgaW4gYnl0ZXMuXHJcbiAgICAgKi9cclxuICAgIGdldCB2ZXJ0ZXhCeXRlT2Zmc2V0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1lbW9yeUNodW5rLnZlcnRleEJ5dGVPZmZzZXQgKyB0aGlzLl9sb2NhdGlvbi52ZXJ0ZXhCeXRlT2Zmc2V0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBPZmZzZXQgb2YgaW5kZXggZGF0YSBvZiB0aGUgY2h1bmsgaW4gYnl0ZXMuXHJcbiAgICAgKi9cclxuICAgIGdldCBpbmRleEJ5dGVPZmZzZXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWVtb3J5Q2h1bmsuaW5kZXhCeXRlT2Zmc2V0ICsgdGhpcy5fbG9jYXRpb24uaW5kZXhCeXRlT2Zmc2V0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBOdW1iZXIgb2YgaW5kZXhlcyBvY2N1cGllZCBieSB0aGlzIGNodW5rLlxyXG4gICAgICovXHJcbiAgICBnZXQgaW5kZXhDb3VudCgpIHtcclxuICAgICAgICByZXR1cm4gY291bnRJbmRpY2VzKHRoaXMuX2xvY2F0aW9uLmluZGV4Qnl0ZUxlbmd0aCwgdGhpcy5tZW1vcnlDaHVuay5wYWdlLmluZGV4VHlwZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIE51bWJlciBvZiBieXRlcyBvY2N1cGllZCBieSB0aGlzIGNodW5rIGZvciB2ZXJ0ZXggZGF0YS5cclxuICAgICAqL1xyXG4gICAgZ2V0IHZlcnRleEJ5dGVMZW5ndGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2F0aW9uLnZlcnRleEJ5dGVMZW5ndGg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIE51bWJlciBvZiBieXRlcyBvY2N1cGllZCBieSB0aGlzIGNodW5rIGZvciBpbmRleCBkYXRhLlxyXG4gICAgICovXHJcbiAgICBnZXQgaW5kZXhCeXRlTGVuZ3RoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhdGlvbi5pbmRleEJ5dGVMZW5ndGg7XHJcbiAgICB9XHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMubWVtb3J5Q2h1bmsucmVsZWFzZSgpO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9tZW1vcnkvc3ViX2NodW5rLnRzXG4vLyBtb2R1bGUgaWQgPSAyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgRm9udCBmcm9tICcuL2ZvbnQnO1xyXG5jb25zdCBVTktOT1dOX0dMWVBIID0ge1xyXG4gICAgaWQ6IC0xLFxyXG4gICAgd2lkdGg6IDAsXHJcbiAgICBoZWlnaHQ6IDAsXHJcbiAgICBiZWFyaW5nWDogMCxcclxuICAgIGJlYXJpbmdZOiAwLFxyXG4gICAgYWR2YW5jZTogMThcclxufTtcclxuLyoqXHJcbiAqIEZvbnQgd2hvc2UgZ2x5cGhzIGFyZSBzcGVjaWZpZWQgaW4gZGlzdGFuY2UgZmllbGQgYml0bWFwcy4gSXQncyBcIm1hcmdpblwiIG1ldHJpYyBzcGVjaWZpZXMgZ2x5cGggYml0bWFwIGlubmVyIHBhZGRpbmcsXHJcbiAqIHRoYXQgaXMgcmVxdWlyZWQgdG8gZml0IGEgXCJibHVycmVkXCIgZ2x5cGggaW1hZ2UuIFRoaXMgbWFyZ2luIHNob3VsZCBiZSBjb25zaWRlcmVkIGR1cmluZyBsYXlvdXRpbmcgdG8gZHJhdyBnbHlwaHMgb2ZcclxuICogcHJvcGVyIHNpemVzLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGZGb250IGV4dGVuZHMgRm9udCB7XHJcbiAgICBjb25zdHJ1Y3RvcihpZCwgeGhlaWdodCwgbWFyZ2luKSB7XHJcbiAgICAgICAgc3VwZXIoaWQsIHhoZWlnaHQsIFVOS05PV05fR0xZUEgpO1xyXG4gICAgICAgIHRoaXMubWFyZ2luID0gbWFyZ2luO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2ZvbnQvZGZfZm9udC50c1xuLy8gbW9kdWxlIGlkID0gMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgQXR0cmlidXRlTWFwcGluZyB9IGZyb20gJy4uLy4uL3JlbmRlci9hdHRyaWJfbWFwcGluZyc7XHJcbmltcG9ydCBCdWZmZXJXcml0ZXIgZnJvbSAnLi4vLi4vdXRpbC9idWZmZXJfd3JpdGVyJztcclxuLyoqXHJcbiAqIEJhc2UgY2xhc3MgZm9yIDNEIG1vZGVscyBidWZmZXIgd3JpdGVycy4gSXQgaXMgbm90IHN1cHBvc2VkIHRvIHdyaXRlIGluZGljZXMsIGluc3RlYWQgaXQgd3JpdGVzIHZlcnRpY2VzIChwb3NzaWJseVxyXG4gKiBkdXBsaWNhdGVkKSBpbiBvcmRlciB0aGF0IGNvcnJlc3BvbmQgdG8gdHJpYW5ndWxhciBmYWNldHMgb2YgdGhlIG1lc2guXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb2RlbEJ1ZmZlcldyaXRlciBleHRlbmRzIEJ1ZmZlcldyaXRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcihNb2RlbEJ1ZmZlcldyaXRlci5BVFRSSUJVVEVfTUFQUElORy52ZXJ0ZXhCeXRlU2l6ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIHZlcnRleCB0byB0aGUgdmVydGV4IGJ1ZmZlci5cclxuICAgICAqL1xyXG4gICAgX3dyaXRlVmVydGV4KHYsIGNvbG9yUmdiYTgpIHtcclxuICAgICAgICBjb25zdCB2ZXJ0ZXhJZHggPSB0aGlzLmdldEN1cnJlbnRWZXJ0ZXhJZHgoKTtcclxuICAgICAgICB0aGlzLl93cml0ZVdvcmxkQ29vcmRpbmF0ZSh2KTtcclxuICAgICAgICB0aGlzLl93cml0ZUZsb2F0MzIodi56KTtcclxuICAgICAgICB0aGlzLl93cml0ZVdvcmQoY29sb3JSZ2JhOCk7XHJcbiAgICAgICAgcmV0dXJuIHZlcnRleElkeDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogRGVzY3JpcHRpb24gb2YgaG93IGF0dHJpYnV0ZXMgb2YgdmVydGljZXMgYXJlIHBhY2tlZCBpbnRvIGEgdmVydGV4IGJ1ZmZlci5cclxuICovXHJcbk1vZGVsQnVmZmVyV3JpdGVyLkFUVFJJQlVURV9NQVBQSU5HID0gbmV3IEF0dHJpYnV0ZU1hcHBpbmcoW1xyXG4gICAgW1xyXG4gICAgICAgIDAgLyogUE9TSVRJT05fSElHSCAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDIsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjMgLyogVU5TSUdORURfU0hPUlQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDEgLyogUE9TSVRJT05fTE9XICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMixcclxuICAgICAgICAgICAgdHlwZTogNTEyMyAvKiBVTlNJR05FRF9TSE9SVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgMyAvKiBIRUlHSFQgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAxLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTI2IC8qIEZMT0FUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgNyAvKiBDT0xPUiAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDQsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjEgLyogVU5TSUdORURfQllURSAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF1cclxuXSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3ByaW1pdGl2ZS9tb2RlbC9tb2RlbF9idWZmZXJfd3JpdGVyLnRzXG4vLyBtb2R1bGUgaWQgPSAyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJjb25zdCBNSU5fWklOREVYID0gLTEgKyBNYXRoLnBvdygyLCAxIC0gMjQpOyAvLyBlcHNpbG9uIGlzIGFkZGVkIChmb3Igbm9ybWFsaXplZCAyNC1iaXQgdmFsdWUpIHRvIGZyZWUgdXAgcmVzZXJ2ZWQgdmFsdWVcclxuZXhwb3J0IGZ1bmN0aW9uIGludFRvWkluZGV4KHgpIHtcclxuICAgIHJldHVybiBNYXRoLm1heChNSU5fWklOREVYLCB4IC8gMHg3ZmZmZmYpO1xyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvel9pbmRleC50c1xuLy8gbW9kdWxlIGlkID0gMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgQXR0cmlidXRlTWFwcGluZyB9IGZyb20gJy4uLy4uL3JlbmRlci9hdHRyaWJfbWFwcGluZyc7XHJcbi8qKlxyXG4gKiBEZXNjcmlwdGlvbiBvZiBob3cgYXR0cmlidXRlcyBvZiB2ZXJ0aWNlcyBhcmUgcGFja2VkIGludG8gYSB2ZXJ0ZXggYnVmZmVyLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IFRFWFRVUkVEX1BPTFlHT05fQVRUUklCVVRFX01BUFBJTkcgPSBuZXcgQXR0cmlidXRlTWFwcGluZyhbXHJcbiAgICBbXHJcbiAgICAgICAgMCAvKiBQT1NJVElPTl9ISUdIICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMixcclxuICAgICAgICAgICAgdHlwZTogNTEyMyAvKiBVTlNJR05FRF9TSE9SVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgMSAvKiBQT1NJVElPTl9MT1cgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIzIC8qIFVOU0lHTkVEX1NIT1JUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICA0IC8qIFVWICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogNCxcclxuICAgICAgICAgICAgdHlwZTogNTEyMyAvKiBVTlNJR05FRF9TSE9SVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDExIC8qIEFVWCAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDEsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjYgLyogRkxPQVQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICAxMCAvKiBaX0lOREVYICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMSxcclxuICAgICAgICAgICAgdHlwZTogNTEyNiAvKiBGTE9BVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICBdXHJcbl0pO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9wcmltaXRpdmUvcG9seWdvbi90ZXh0dXJlZF9wb2x5Z29uX2F0dHJpYnV0ZV9tYXBwaW5nLnRzXG4vLyBtb2R1bGUgaWQgPSAzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBBdHRyaWJ1dGVNYXBwaW5nIH0gZnJvbSAnLi4vLi4vcmVuZGVyL2F0dHJpYl9tYXBwaW5nJztcclxuLyoqXHJcbiAqIERlc2NyaXB0aW9uIG9mIGhvdyBhdHRyaWJ1dGVzIG9mIHZlcnRpY2VzIGFyZSBwYWNrZWQgaW50byBhIHZlcnRleCBidWZmZXIuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgUE9MWUdPTl9BVFRSSUJVVEVfTUFQUElORyA9IG5ldyBBdHRyaWJ1dGVNYXBwaW5nKFtcclxuICAgIFtcclxuICAgICAgICAwIC8qIFBPU0lUSU9OX0hJR0ggKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIzIC8qIFVOU0lHTkVEX1NIT1JUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICAxIC8qIFBPU0lUSU9OX0xPVyAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDIsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjMgLyogVU5TSUdORURfU0hPUlQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDcgLyogQ09MT1IgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiA0LFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIxIC8qIFVOU0lHTkVEX0JZVEUgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDEwIC8qIFpfSU5ERVggKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAxLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTI2IC8qIEZMT0FUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgIF1cclxuXSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3ByaW1pdGl2ZS9wb2x5Z29uL3BvbHlnb25fYXR0cmlidXRlX21hcHBpbmcudHNcbi8vIG1vZHVsZSBpZCA9IDMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IEF0dHJpYnV0ZU1hcHBpbmcgfSBmcm9tICcuLi8uLi9yZW5kZXIvYXR0cmliX21hcHBpbmcnO1xyXG4vKipcclxuICogRGVzY3JpcHRpb24gb2YgaG93IGF0dHJpYnV0ZXMgb2YgdmVydGljZXMgYXJlIHBhY2tlZCBpbnRvIGEgdmVydGV4IGJ1ZmZlci5cclxuICovXHJcbmV4cG9ydCBjb25zdCBQT0xZTElORV9BVFRSSUJVVEVfTUFQUElORyA9IG5ldyBBdHRyaWJ1dGVNYXBwaW5nKFtcclxuICAgIC8qKiBWZXJ0ZXggd29ybGQgcG9zaXRpb24uICovXHJcbiAgICBbXHJcbiAgICAgICAgMCAvKiBQT1NJVElPTiAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDQsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjMgLyogVU5TSUdORURfU0hPUlQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgLyoqIE5vcm1hbCB0byBwb2x5bGluZSBzZWdtZW50IHRoZSB2ZXJ0ZXggYmVsb25nIHRvLiAqL1xyXG4gICAgW1xyXG4gICAgICAgIDUgLyogTk9STUFMICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMixcclxuICAgICAgICAgICAgdHlwZTogNTEyMyAvKiBVTlNJR05FRF9TSE9SVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICAvKipcclxuICAgICAqIFwiVVZcIiB2ZXJ0ZXggdGhhdCB1c2VkIHRvIGNvbXB1dGUgc3Ryb2tlIGFuZCBkYXNoZXMuIEl0J3MgY29tcG9uZW50czpcclxuICAgICAqXHJcbiAgICAgKiAgIC0gZGlzdGFuY2UgdG8gdGhlIGFuYWx5dGljYWwgcG9seWxpbmUgYWxvbmcgc2VnbWVudCdzIG5vcm1hbDtcclxuICAgICAqICAgLSBkaXN0YW5jZSB0byB0aGUgYW5hbHl0aWNhbCBwb2x5bGluZSBhbG9uZyBzZWdtZW50LlxyXG4gICAgICovXHJcbiAgICBbXHJcbiAgICAgICAgNCAvKiBVViAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDIsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjMgLyogVU5TSUdORURfU0hPUlQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIC8qKlxyXG4gICAgICogVmVjdG9yIHdpdGggcG9seWxpbmUncyBoYWxmIHdpZHRoIGFuZCBkYXNoIHN0eWxlLiBJdCdzIGNvbXBvbmVudHM6XHJcbiAgICAgKlxyXG4gICAgICogICAtIGhhbGYgd2lkdGg7XHJcbiAgICAgKiAgIC0gbGVuZ3RoIG9mIGEgZGFzaDtcclxuICAgICAqICAgLSBkaXN0YW5jZSBiZXR3ZWVuIGRhc2hlcy5cclxuICAgICAqL1xyXG4gICAgW1xyXG4gICAgICAgIDExIC8qIEFVWCAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDMsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjEgLyogVU5TSUdORURfQllURSAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICAvKipcclxuICAgICAqIE1pdGVyIChpLmUuIGhvdyBtdWNoIGRpc3BsYWNlbWVudCBvZiB0aGUgdmVydGV4IGlzIGxvbmdlciB0aGVuIHRoZVxyXG4gICAgICogbm9ybWFsKS5cclxuICAgICAqL1xyXG4gICAgW1xyXG4gICAgICAgIDEyIC8qIEFVWDEgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAxLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTI2IC8qIEZMT0FUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICAvKipcclxuICAgICAqIExpbWl0IG9uIGRpc3BsYWNlbWVudCB0YW5nZW50IGNvbXBvbmVudC5BcHBsaWVkIHRvIGF2b2lkIGdlb21ldHJ5XHJcbiAgICAgKiBnbGl0Y2hlcyBpbiBvdmVyLWRlZ2VuZXJhdGl2ZSBjYXNlcy5cclxuICAgICAqL1xyXG4gICAgW1xyXG4gICAgICAgIDEzIC8qIEFVWDIgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAxLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTI2IC8qIEZMT0FUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICAvKipcclxuICAgICAqIERpc3RhbmNlIHRvIHRoZSBmaXJzdCB2ZXJ0ZXggYWxvbmcgdGhlIHBvbHlsaW5lLlxyXG4gICAgICovXHJcbiAgICBbXHJcbiAgICAgICAgMTQgLyogQVVYMyAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDEsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjYgLyogRkxPQVQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIC8qKiBQb2x5bGluZSdzIGNvbG9yLiAqL1xyXG4gICAgW1xyXG4gICAgICAgIDcgLyogQ09MT1IgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiA0LFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIxIC8qIFVOU0lHTkVEX0JZVEUgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgLyoqIFBvbHlsaW5lJ3MgWiBpbmRleC4gKi9cclxuICAgIFtcclxuICAgICAgICAxMCAvKiBaX0lOREVYICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMSxcclxuICAgICAgICAgICAgdHlwZTogNTEyNiAvKiBGTE9BVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICBdXHJcbl0pO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9wcmltaXRpdmUvcG9seWxpbmUvcG9seWxpbmVfYXR0cmlidXRlX21hcHBpbmcudHNcbi8vIG1vZHVsZSBpZCA9IDMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IGV4dHJhY3RUcmFuc2ZlcmFibGVzIH0gZnJvbSAnLi9wcmltaXRpdmVfcHJvdmlkZXJfd29ya2VyX21lc3NhZ2VzJztcclxuZXhwb3J0IHZhciBUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZTtcclxuKGZ1bmN0aW9uIChUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZSkge1xyXG4gICAgVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGVbVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGVbXCJJTklUXCJdID0gMF0gPSBcIklOSVRcIjtcclxuICAgIFRpbGVQcm92aWRlck1lc3NhZ2VUeXBlW1RpbGVQcm92aWRlck1lc3NhZ2VUeXBlW1wiVElMRV9VUkxfVVBEQVRFXCJdID0gMV0gPSBcIlRJTEVfVVJMX1VQREFURVwiO1xyXG4gICAgVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGVbVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGVbXCJUSUxFX1JFUVVFU1RfQkFUQ0hcIl0gPSAyXSA9IFwiVElMRV9SRVFVRVNUX0JBVENIXCI7XHJcbiAgICBUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZVtUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZVtcIlRJTEVfUkVRVUVTVF9DQU5DRUxfQkFUQ0hcIl0gPSAzXSA9IFwiVElMRV9SRVFVRVNUX0NBTkNFTF9CQVRDSFwiO1xyXG4gICAgVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGVbVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGVbXCJUSUxFX1JFU1BPTlNFXCJdID0gNF0gPSBcIlRJTEVfUkVTUE9OU0VcIjtcclxuICAgIFRpbGVQcm92aWRlck1lc3NhZ2VUeXBlW1RpbGVQcm92aWRlck1lc3NhZ2VUeXBlW1wiVElMRV9FUlJPUlwiXSA9IDVdID0gXCJUSUxFX0VSUk9SXCI7XHJcbiAgICBUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZVtUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZVtcIkdFT01FVFJZX1JFU1BPTlNFXCJdID0gNl0gPSBcIkdFT01FVFJZX1JFU1BPTlNFXCI7XHJcbiAgICBUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZVtUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZVtcIkxBQkVMU19SRVNQT05TRVwiXSA9IDddID0gXCJMQUJFTFNfUkVTUE9OU0VcIjtcclxuICAgIFRpbGVQcm92aWRlck1lc3NhZ2VUeXBlW1RpbGVQcm92aWRlck1lc3NhZ2VUeXBlW1wiTUVTSF9SRVFVRVNUXCJdID0gOF0gPSBcIk1FU0hfUkVRVUVTVFwiO1xyXG4gICAgVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGVbVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGVbXCJNRVNIX1JFUVVFU1RfQ0FOQ0VMXCJdID0gOV0gPSBcIk1FU0hfUkVRVUVTVF9DQU5DRUxcIjtcclxuICAgIFRpbGVQcm92aWRlck1lc3NhZ2VUeXBlW1RpbGVQcm92aWRlck1lc3NhZ2VUeXBlW1wiTUVTSF9SRVNQT05TRVwiXSA9IDEwXSA9IFwiTUVTSF9SRVNQT05TRVwiO1xyXG4gICAgVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGVbVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGVbXCJNRVNIX0VSUk9SXCJdID0gMTFdID0gXCJNRVNIX0VSUk9SXCI7XHJcbn0pKFRpbGVQcm92aWRlck1lc3NhZ2VUeXBlIHx8IChUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZSA9IHt9KSk7XHJcbmV4cG9ydCBjb25zdCBnZW9tZXRyeVRyYW5zZmVyYWJsZUV4dHJhY3RvciA9IGZ1bmN0aW9uIChtZXNzYWdlLCB0cmFuc2ZlcmFibGVzID0gW10pIHtcclxuICAgIGV4dHJhY3RUcmFuc2ZlcmFibGVzKG1lc3NhZ2UucG9seWdvblBhZ2VzLCB0cmFuc2ZlcmFibGVzKTtcclxuICAgIGV4dHJhY3RUcmFuc2ZlcmFibGVzKG1lc3NhZ2UudHJhbnNwYXJlbnRQb2x5Z29uUGFnZXMsIHRyYW5zZmVyYWJsZXMpO1xyXG4gICAgZXh0cmFjdFRyYW5zZmVyYWJsZXMobWVzc2FnZS50ZXh0dXJlZFBvbHlnb25QYWdlcywgdHJhbnNmZXJhYmxlcyk7XHJcbiAgICBleHRyYWN0VHJhbnNmZXJhYmxlcyhtZXNzYWdlLm1lc2hQYWdlcywgdHJhbnNmZXJhYmxlcyk7XHJcbiAgICBleHRyYWN0VHJhbnNmZXJhYmxlcyhtZXNzYWdlLnBvbHlsaW5lUGFnZXMsIHRyYW5zZmVyYWJsZXMpO1xyXG4gICAgcmV0dXJuIHRyYW5zZmVyYWJsZXM7XHJcbn07XHJcbmV4cG9ydCBjb25zdCBtZXNoVHJhbnNmZXJhYmxlRXh0cmFjdG9yID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcclxuICAgIGNvbnN0IHRyYW5zZmVyYWJsZXMgPSBbXTtcclxuICAgIGV4dHJhY3RUcmFuc2ZlcmFibGVzKG1lc3NhZ2UucGFnZXMsIHRyYW5zZmVyYWJsZXMpO1xyXG4gICAgcmV0dXJuIHRyYW5zZmVyYWJsZXM7XHJcbn07XHJcbmV4cG9ydCBjb25zdCBsYWJlbFRyYW5zZmVyYWJsZUV4dHJhY3RvciA9IGZ1bmN0aW9uIChtZXNzYWdlLCB0cmFuc2ZlcmFibGVzID0gW10pIHtcclxuICAgIGV4dHJhY3RUcmFuc2ZlcmFibGVzKG1lc3NhZ2UucG9pbnRMYWJlbFBhZ2VzLCB0cmFuc2ZlcmFibGVzKTtcclxuICAgIGV4dHJhY3RUcmFuc2ZlcmFibGVzKG1lc3NhZ2UucG9pbnRMYWJlbEJhY2tncm91bmRQYWdlcywgdHJhbnNmZXJhYmxlcyk7XHJcbiAgICBleHRyYWN0VHJhbnNmZXJhYmxlcyhtZXNzYWdlLmN1cnZlZExhYmVsUGFnZXMsIHRyYW5zZmVyYWJsZXMpO1xyXG4gICAgcmV0dXJuIHRyYW5zZmVyYWJsZXM7XHJcbn07XHJcbmV4cG9ydCBjb25zdCB0aWxlVHJhbnNmZXJhYmxlRXh0cmFjdG9yID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcclxuICAgIGNvbnN0IHRyYW5zZmVyYWJsZXMgPSBbXTtcclxuICAgIGdlb21ldHJ5VHJhbnNmZXJhYmxlRXh0cmFjdG9yKG1lc3NhZ2UsIHRyYW5zZmVyYWJsZXMpO1xyXG4gICAgbGFiZWxUcmFuc2ZlcmFibGVFeHRyYWN0b3IobWVzc2FnZSwgdHJhbnNmZXJhYmxlcyk7XHJcbiAgICByZXR1cm4gdHJhbnNmZXJhYmxlcztcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdmVjdG9yX2FwaS93b3JrZXIvdGlsZV9wcm92aWRlcl93b3JrZXJfbWVzc2FnZXMudHNcbi8vIG1vZHVsZSBpZCA9IDM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBCaW5hcnlIZWFwIGZyb20gJy4vYmluYXJ5X2hlYXAnO1xyXG5mdW5jdGlvbiBpdGVtQ29tcGFyYXRvcihhLCBiKSB7XHJcbiAgICByZXR1cm4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHk7XHJcbn1cclxuLyoqXHJcbiAqIFByaW9yaXR5IHF1ZXVlIGJhc2VkIG9uIGEgaGVhcC5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByaW9yaXR5UXVldWUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb25zdHJ1Y3RzIG5ldyBlbXB0eSBwcmlvcml0eSBxdWV1ZS5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5faGVhcCA9IG5ldyBCaW5hcnlIZWFwKGl0ZW1Db21wYXJhdG9yKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhbiBpdGVtIGludG8gdGhlIHF1ZXVlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpdGVtIFRoZSBpdGVtLlxyXG4gICAgICovXHJcbiAgICBlbnF1ZXVlKGl0ZW0pIHtcclxuICAgICAgICB0aGlzLl9oZWFwLmluc2VydChpdGVtKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBuZXh0IGl0ZW0gZnJvbSB0aGUgcXVldWUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVGhlIG5leHQgaXRlbSBvciBgdW5kZWZpbmVkYCBpZiB0aGUgcXVldWUncyBlbXB0eS5cclxuICAgICAqL1xyXG4gICAgZGVxdWV1ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faGVhcC5wb3AoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIHRoZSBxdWV1ZSBoYXMgbm8gaXRlbXMgaW4gaXQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZXJlJ3JlIG5vIGl0ZW1zIGl0IHRoZSBxdWV1ZSBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXHJcbiAgICAgKi9cclxuICAgIGlzRW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlYXAuc2l6ZSA9PT0gMDtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL3ByaW9yaXR5X3F1ZXVlLnRzXG4vLyBtb2R1bGUgaWQgPSAzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgUmVuZGVyYWJsZVByaW1pdGl2ZSBmcm9tICcuLi9yZW5kZXJhYmxlX3ByaW1pdGl2ZSc7XHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbmRlcmFibGVQb2x5bGluZSBleHRlbmRzIFJlbmRlcmFibGVQcmltaXRpdmUge1xyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3ByaW1pdGl2ZS9wb2x5bGluZS9yZW5kZXJhYmxlX3BvbHlsaW5lLnRzXG4vLyBtb2R1bGUgaWQgPSAzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgUmVuZGVyYWJsZVByaW1pdGl2ZSBmcm9tICcuLi9yZW5kZXJhYmxlX3ByaW1pdGl2ZSc7XHJcbi8qKlxyXG4gKiBBIGdlbmVyYWwgcHJpbWl0aXZlIHRoYXQgaXMgYmVzdCBzdWl0YWJsZSBmb3Igc3RvcmluZyBzaW1wbGUgY29sb3JlZCAzRCBtb2RlbHMuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW5kZXJhYmxlTW9kZWwgZXh0ZW5kcyBSZW5kZXJhYmxlUHJpbWl0aXZlIHtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9wcmltaXRpdmUvbW9kZWwvcmVuZGVyYWJsZV9tb2RlbC50c1xuLy8gbW9kdWxlIGlkID0gMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIE9mdGVuIHByaW1pdGl2ZXMgY2FuJ3QgYmUgZGlycmVjdGx5IGFkZGVkIGludG8gb3IgcmVtb3ZlZCBmcm9tIHNjZW5lLCB0aGVyZSBjYW4gYmUgc29tZSBzcGVjaWZpYyAoYnVzaW5lc3MpIGxvZ2ljXHJcbiAqIGFzc29jaWF0ZWQgd2l0aCB0aGVzZSBvcGVyYXRpb25zLiBUaGlzIGNsYXNzIHByb3ZpZGVzIGJhc2ljIG1ldGhvZHMgZm9yIHN1Y2ggaW1wbGVtZW50YXRpb25zIHRoYXRcclxuICogYWxsb3dzIHRvIG1hbmFnZSBwcmltaXRpdmVzIG9mIGFsbCB0eXBlcyBpbiB0aGUgc2FtZSBtYW5uZXIuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcmltaXRpdmVNYW5hZ2VyIHtcclxuICAgIGRlc3Ryb3koKSB7IH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9hZGFwdGVycy92ZWN0b3JfYXBpL3ByaW1pdGl2ZV9tYW5hZ2VyL3ByaW1pdGl2ZV9tYW5hZ2VyLnRzXG4vLyBtb2R1bGUgaWQgPSAzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBWb2lkRXZlbnRFbWl0dGVyIH0gZnJvbSAnLi4vLi4vdXRpbC9ldmVudF9lbWl0dGVyJztcclxuLyoqXHJcbiAqIFByaW1pdGl2ZSBzdG9yYWdlIHRoYXQgc3RvcmVzIHByaW1pdGl2ZSBpbiBhIHNldC4gSXQgYWN0cyBhcyBhIHByaW1pdGl2ZSBwcm92aWRlciBhcyB3ZWxsLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJpbWl0aXZlU2V0U3RvcmFnZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLl9wcmltaXRpdmVTZXQgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgdGhpcy5vblVwZGF0ZSA9IG5ldyBWb2lkRXZlbnRFbWl0dGVyKCk7XHJcbiAgICB9XHJcbiAgICBnZXQgcHJpbWl0aXZlcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcHJpbWl0aXZlU2V0O1xyXG4gICAgfVxyXG4gICAgYWRkKC4uLnByaW1pdGl2ZXMpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IHByaW1pdGl2ZSBvZiBwcmltaXRpdmVzKSB7XHJcbiAgICAgICAgICAgIHByaW1pdGl2ZS5yZXRhaW4oKTtcclxuICAgICAgICAgICAgdGhpcy5fcHJpbWl0aXZlU2V0LmFkZChwcmltaXRpdmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocHJpbWl0aXZlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25VcGRhdGUuZmlyZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGRlbGV0ZSguLi5wcmltaXRpdmVzKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBwcmltaXRpdmUgb2YgcHJpbWl0aXZlcykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fcHJpbWl0aXZlU2V0LmRlbGV0ZShwcmltaXRpdmUpKSB7XHJcbiAgICAgICAgICAgICAgICBwcmltaXRpdmUucmVsZWFzZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcmltaXRpdmVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5vblVwZGF0ZS5maXJlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2xlYXIoKSB7XHJcbiAgICAgICAgdGhpcy5fcHJpbWl0aXZlU2V0LmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5vblVwZGF0ZS5maXJlKCk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvcHJpbWl0aXZlX3NldF9zdG9yYWdlLnRzXG4vLyBtb2R1bGUgaWQgPSAzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgUHJpbWl0aXZlU2V0U3RvcmFnZSBmcm9tICcuL3ByaW1pdGl2ZV9zZXRfc3RvcmFnZSc7XHJcbi8qKlxyXG4gKiBTaW1wbGUgcHJpbWl0aXZlIHNldCBzdG9yYWdlIHRoYXQgZGlzdGluZ3Vpc2ggdmlzaWJsZS9oaWRkZW4gcHJpbWl0aXZlcy4gSXQgYWxzbyBhY3RzIGFzIGEgcHJpbWl0aXZlIHByb3ZpZGVyLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGlzYXBwZWFyaW5nUHJpbWl0aXZlU2V0U3RvcmFnZSBleHRlbmRzIFByaW1pdGl2ZVNldFN0b3JhZ2Uge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl92aXNpYmxlUHJpbWl0aXZlcyA9IG5ldyBTZXQoKTtcclxuICAgIH1cclxuICAgIGdldCBwcmltaXRpdmVzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZpc2libGVQcmltaXRpdmVzO1xyXG4gICAgfVxyXG4gICAgZ2V0IHZpc2libGVQcmltaXRpdmVzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpYmxlUHJpbWl0aXZlcztcclxuICAgIH1cclxuICAgIGFkZCguLi5wcmltaXRpdmVzKSB7XHJcbiAgICAgICAgc3VwZXIuYWRkKC4uLnByaW1pdGl2ZXMpO1xyXG4gICAgICAgIHRoaXMuc2hvdyguLi5wcmltaXRpdmVzKTtcclxuICAgIH1cclxuICAgIGRlbGV0ZSguLi5wcmltaXRpdmVzKSB7XHJcbiAgICAgICAgdGhpcy5oaWRlKC4uLnByaW1pdGl2ZXMpO1xyXG4gICAgICAgIHN1cGVyLmRlbGV0ZSguLi5wcmltaXRpdmVzKTtcclxuICAgIH1cclxuICAgIHNob3coLi4ucHJpbWl0aXZlcykge1xyXG4gICAgICAgIGZvciAoY29uc3QgcHJpbWl0aXZlIG9mIHByaW1pdGl2ZXMpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3ByaW1pdGl2ZVNldC5oYXMocHJpbWl0aXZlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdmlzaWJsZVByaW1pdGl2ZXMuYWRkKHByaW1pdGl2ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBoaWRlKC4uLnByaW1pdGl2ZXMpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IHByaW1pdGl2ZSBvZiBwcmltaXRpdmVzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Zpc2libGVQcmltaXRpdmVzLmRlbGV0ZShwcmltaXRpdmUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9pc0FsbG93ZWRUb1Nob3dQcmltaXRpdmUocHJpbWl0aXZlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaW1pdGl2ZVNldC5oYXMocHJpbWl0aXZlKTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9kaXNhcHBlYXJpbmdfcHJpbWl0aXZlX3NldF9zdG9yYWdlLnRzXG4vLyBtb2R1bGUgaWQgPSA0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnQgY2xhc3MgRGVsZWdhdG9yQmFzZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLl9kZWxlZ2F0ZSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBzZXREZWxlZ2F0ZShkZWxlZ2F0ZSkge1xyXG4gICAgICAgIHRoaXMuX2RlbGVnYXRlID0gZGVsZWdhdGU7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9kZWxlZ2F0b3IudHNcbi8vIG1vZHVsZSBpZCA9IDQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbnZhcnlpbmcgbG93cCB2ZWM0IGNvbG9yO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbn1cXG5cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3Zpc2liaWxpdHkvcHJpbWl0aXZlcy9sYWJlbC9zaGFkZXIvY29sb3JfaWQuZnJhZ1xuLy8gbW9kdWxlIGlkID0gNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgQ29sbGlkaW5nUHJpbWl0aXZlQ29sb3JJZFJlbmRlcmVyIH0gZnJvbSAnLi4vY29sbGlkaW5nX3ByaW1pdGl2ZV9jb2xvcl9pZF9yZW5kZXJlcic7XHJcbi8qKlxyXG4gKiBcImNvbG9yIGlkXCIgcmVuZGVyZXIgZm9yIGxhYmVscywgYm90aCBmb3IgcG9pbnQgYW5kIGN1cnZlZCBvbmVzLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29sb3JJZExhYmVsUmVuZGVyZXIgZXh0ZW5kcyBDb2xsaWRpbmdQcmltaXRpdmVDb2xvcklkUmVuZGVyZXIge1xyXG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgcHJvZ3JhbSwgcHJpbWl0aXZlUHJvdmlkZXIsIGNhbWVyYSkge1xyXG4gICAgICAgIHN1cGVyKGNvbnRleHQsIHByb2dyYW0sIHByaW1pdGl2ZVByb3ZpZGVyKTtcclxuICAgICAgICB0aGlzLl9jYW1lcmEgPSBjYW1lcmE7XHJcbiAgICB9XHJcbiAgICBfcHJlcGFyZVByb2dyYW0ocHJvZ3JhbSwgdmlld1Byb2pNYXRyaXgsIGNhbWVyYVBvc2l0aW9ucywgc3RhdGUsIHN0YWJpbGl0eVNoaWZ0LCB2aXNpYmlsaXR5LCBjdXJyZW50Wm9vbSkge1xyXG4gICAgICAgIHN1cGVyLl9wcmVwYXJlUHJvZ3JhbShwcm9ncmFtLCB2aWV3UHJvak1hdHJpeCwgY2FtZXJhUG9zaXRpb25zLCBzdGF0ZSwgc3RhYmlsaXR5U2hpZnQsIHZpc2liaWxpdHksIGN1cnJlbnRab29tKTtcclxuICAgICAgICBwcm9ncmFtLnNldFZlY3RvcjJVbmlmb3JtKCdwaXhlbFNpemUnLCB0aGlzLl9jYW1lcmEucGl4ZWxTaXplKTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS92aXNpYmlsaXR5L3ByaW1pdGl2ZXMvbGFiZWwvY29sb3JfaWRfbGFiZWxfcmVuZGVyZXIudHNcbi8vIG1vZHVsZSBpZCA9IDQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IGJhdGNoQWxsb2NhdGVkT2JqZWN0cyB9IGZyb20gJy4uL21lbW9yeS9yZWxhdGl2ZV9sb2NhdGlvbic7XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGJhdGNoIGZyb20gZmlyc3QgcHJpbWl0aXZlcy5cclxuICovXHJcbmZ1bmN0aW9uIGluaXRCYXRjaChwcmltaXRpdmUpIHtcclxuICAgIGNvbnN0IHN1YkNodW5rID0gcHJpbWl0aXZlLm1lbW9yeVN1YkNodW5rO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBmaXJzdFByaW1pdGl2ZTogcHJpbWl0aXZlLFxyXG4gICAgICAgIHBhZ2U6IHN1YkNodW5rLm1lbW9yeUNodW5rLnBhZ2UsXHJcbiAgICAgICAgdmVydGV4Qnl0ZU9mZnNldDogc3ViQ2h1bmsudmVydGV4Qnl0ZU9mZnNldCxcclxuICAgICAgICB2ZXJ0ZXhCeXRlTGVuZ3RoOiBzdWJDaHVuay52ZXJ0ZXhCeXRlTGVuZ3RoLFxyXG4gICAgICAgIGluZGV4Qnl0ZU9mZnNldDogc3ViQ2h1bmsuaW5kZXhCeXRlT2Zmc2V0LFxyXG4gICAgICAgIGluZGV4Qnl0ZUxlbmd0aDogc3ViQ2h1bmsuaW5kZXhCeXRlTGVuZ3RoXHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBCYXRjaGVzIHByaW1pdGl2ZXMgdGhhdCBjYW4gYmUgcmVuZGVyZWQgYnkgYSBzaW5nbGUgZHJhdyBjYWxsLCB0aGF0IGlzIGNyaXRpY2FsIGZvciBwZXJmb3JtYW5jZS5cclxuICogUGVyZm9ybWFuY2UgZ2FpbiBmcm9tIHRoaXMgbWV0aG9kIGlzIHBvc3NpYmxlICh3aGlsZSBpdCBpcyBub3Qgc3RyaWN0bHkgcmVxdWlyZWQpIGlmIHByaW1pdGl2ZXNcclxuICogYXJlIHNvcnRlZCBieSBtZW1vcnkgb2Zmc2V0IGFuZCB0aGVyZSBhcmUgbm8gbWFueSBcImhvbGVzXCIgYmV0d2VlbiB0aGVtLlxyXG4gKiBNaW5pbWFsIHJlcXVpcmVtZXRzIGZvciBiYXRjaGluZyBpcyBsb2NhdGlvbiBpbiB0aGUgc2FtZSBidWZmZXIgKG1lbW9yeSBwYWdlKSwgYWRkaXRpb25hbFxyXG4gKiByZXF1aXJlbWVudHMgKHN1Y2ggYXMgaGF2aW5nIHNoYXJlZCB0ZXh0dXJlIG9yIHNpbWlsYXIpIGNhbiBiZSBpbXBvc2VkIGluIGNhbkJhdGNoUHJpZGljYXRlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGJhdGNoUHJpbWl0aXZlcyhwcmltaXRpdmVzLCBjYW5CYXRjaFByaWRpY2F0ZSkge1xyXG4gICAgY29uc3QgY2FuQmF0Y2ggPSAoYSwgYikgPT4ge1xyXG4gICAgICAgIGlmIChcclxuICAgICAgICAvLyBtaW5pbWFsIHJlcXVpcmVtZW50cyBmb3IgYmF0Y2hpbmcgaXMgdGhhdCBwcmltaXRpdmVzIGxheSBpbiB0aGUgc2FtZSBwYWdlXHJcbiAgICAgICAgKGEubWVtb3J5U3ViQ2h1bmsubWVtb3J5Q2h1bmsucGFnZSAhPT0gYi5tZW1vcnlTdWJDaHVuay5tZW1vcnlDaHVuay5wYWdlKSB8fFxyXG4gICAgICAgICAgICAvLyBjaGFjayBleHRlcm5hbCByZXF1aXJlbWVudHMgaWYgc3BlY2lmaWVkXHJcbiAgICAgICAgICAgIChjYW5CYXRjaFByaWRpY2F0ZSAmJiAhY2FuQmF0Y2hQcmlkaWNhdGUoYSwgYikpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gYmF0Y2hBbGxvY2F0ZWRPYmplY3RzKHByaW1pdGl2ZXMsIChwcmltaXRpdmUpID0+IHByaW1pdGl2ZS5tZW1vcnlTdWJDaHVuaywgaW5pdEJhdGNoLCBjYW5CYXRjaCk7XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvcHJpbWl0aXZlX2JhdGNoLnRzXG4vLyBtb2R1bGUgaWQgPSA0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgcG9pbnRMYWJlbFZlcnRleFNoYWRlciBmcm9tICcuL3NoYWRlci9wb2ludF9sYWJlbC52ZXJ0JztcclxuaW1wb3J0IGRmVGV4dEZyYWdtZW50U2hhZGVyIGZyb20gJy4vc2hhZGVyL2RmX3RleHQuZnJhZyc7XHJcbmltcG9ydCBMYWJlbFJlbmRlclVuaXQgZnJvbSAnLi9sYWJlbF9yZW5kZXJfdW5pdCc7XHJcbmltcG9ydCBCaWxsYm9hcmRSZWN0YW5nbGVSZW5kZXJVbml0IGZyb20gJy4uL2JpbGxib2FyZF9yZWN0YW5nbGUvYmlsbGJvYXJkX3JlY3RhbmdsZV9yZW5kZXJfdW5pdCc7XHJcbmltcG9ydCB7IFZvaWRFdmVudEVtaXR0ZXIgfSBmcm9tICcuLi8uLi8uLi91dGlsL2V2ZW50X2VtaXR0ZXInO1xyXG5pbXBvcnQgeyBtYXBJdGVyYWJsZSwgZmlsdGVySXRlcmFibGUgfSBmcm9tICcuLi8uLi8uLi91dGlsL2l0ZXJhYmxlJztcclxuZXhwb3J0IGNvbnN0IFBST0dSQU1fT1BUSU9OUyA9IHtcclxuICAgIGF0dHJpYk1hcDoge1xyXG4gICAgICAgIHZlcnRleElkOiAyIC8qIElEICovLFxyXG4gICAgICAgIHZlcnRleFBvc0hpZ2g6IDAgLyogUE9TSVRJT05fSElHSCAqLyxcclxuICAgICAgICB2ZXJ0ZXhQb3NMb3c6IDEgLyogUE9TSVRJT05fTE9XICovLFxyXG4gICAgICAgIHZlcnRleERpc3BsYWNlbWVudDogNiAvKiBESVNQTEFDRU1FTlQgKi8sXHJcbiAgICAgICAgdmVydGV4VVY6IDQgLyogVVYgKi8sXHJcbiAgICAgICAgdmVydGV4UHJpb3JpdHk6IDkgLyogUFJJT1JJVFkgKi8sXHJcbiAgICAgICAgdmVydGV4Q29sb3I6IDcgLyogQ09MT1IgKi8sXHJcbiAgICAgICAgdmVydGV4T3V0bGluZUNvbG9yOiA4IC8qIE9VVExJTkVfQ09MT1IgKi8sXHJcbiAgICAgICAgdmVydGV4U2NhbGU6IDExIC8qIEFVWCAqL1xyXG4gICAgfVxyXG59O1xyXG4vKipcclxuICogUmVuZGVycyBiYWNrZ3JvdW5kcyBleHRyYWN0ZWQgZnJvbSBwb2ludCBsYWJlbHMuXHJcbiAqL1xyXG5jbGFzcyBCYWNrZ3JvdW5kUHJpbWl0aXZlUHJvdmlkZXIge1xyXG4gICAgY29uc3RydWN0b3IobGFiZWxzUHJvdmlkZXIpIHtcclxuICAgICAgICB0aGlzLm9uVXBkYXRlID0gbmV3IFZvaWRFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLl9sYWJlbHNQcm92aWRlciA9IGxhYmVsc1Byb3ZpZGVyO1xyXG4gICAgfVxyXG4gICAgZ2V0IHByaW1pdGl2ZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIG1hcEl0ZXJhYmxlKGZpbHRlckl0ZXJhYmxlKHRoaXMuX2xhYmVsc1Byb3ZpZGVyLnByaW1pdGl2ZXMsIChsYWJlbCkgPT4gbGFiZWwuYmFja2dyb3VuZCAhPT0gdW5kZWZpbmVkKSwgKGxhYmVsKSA9PiBsYWJlbC5iYWNrZ3JvdW5kKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUG9pbnQgbGFiZWxzIHJlbmRlcmVyLiBJdCB1c2VzIGFwcHJvcHJpYXRlIHByb2dyYW0gdG8gbGF5b3V0IGdseXBocyBvbiBHUFUuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb2ludExhYmVsUmVuZGVyVW5pdCBleHRlbmRzIExhYmVsUmVuZGVyVW5pdCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBjYW1lcmEsIHZpc2liaWxpdHlQcm92aWRlciwgcHJpbWl0aXZlUHJvdmlkZXIpIHtcclxuICAgICAgICBjb25zdCBwcm9ncmFtID0gY29udGV4dC5jcmVhdGVQcm9ncmFtKHBvaW50TGFiZWxWZXJ0ZXhTaGFkZXIsIGRmVGV4dEZyYWdtZW50U2hhZGVyLCBQUk9HUkFNX09QVElPTlMpO1xyXG4gICAgICAgIHN1cGVyKGNvbnRleHQsIHByb2dyYW0sIGNhbWVyYSwgdmlzaWJpbGl0eVByb3ZpZGVyLCBwcmltaXRpdmVQcm92aWRlcik7XHJcbiAgICAgICAgdGhpcy5fYmFja2dyb3VuZFJlbmRlcmVyID0gbmV3IEJpbGxib2FyZFJlY3RhbmdsZVJlbmRlclVuaXQoY29udGV4dCwgY2FtZXJhLCB2aXNpYmlsaXR5UHJvdmlkZXIsIG5ldyBCYWNrZ3JvdW5kUHJpbWl0aXZlUHJvdmlkZXIocHJpbWl0aXZlUHJvdmlkZXIpKTtcclxuICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kUmVuZGVyZXIub25VcGRhdGUuYWRkTGlzdGVuZXIoKCkgPT4gdGhpcy5vblVwZGF0ZS5maXJlKCkpO1xyXG4gICAgfVxyXG4gICAgcmVuZGVyKHRhcmdldCwgdmlld1Byb2pNYXRyaXgsIGNhbWVyYVBvc2l0aW9ucykge1xyXG4gICAgICAgIHRoaXMuX2JhY2tncm91bmRSZW5kZXJlci5yZW5kZXIodGFyZ2V0LCB2aWV3UHJvak1hdHJpeCwgY2FtZXJhUG9zaXRpb25zKTtcclxuICAgICAgICBzdXBlci5yZW5kZXIodGFyZ2V0LCB2aWV3UHJvak1hdHJpeCwgY2FtZXJhUG9zaXRpb25zKTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9sYWJlbC9wb2ludF9sYWJlbF9yZW5kZXJfdW5pdC50c1xuLy8gbW9kdWxlIGlkID0gNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcIiN2ZXJzaW9uIDEwMFxcblxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxudW5pZm9ybSBmbG9hdCBkcHI7XFxudW5pZm9ybSBzYW1wbGVyMkQgYXRsYXM7XFxudW5pZm9ybSB2ZWMyIGF0bGFzU2l6ZTtcXG5cXG52YXJ5aW5nIHZlYzIgdXY7XFxudmFyeWluZyBsb3dwIHZlYzQgY29sb3I7XFxudmFyeWluZyBsb3dwIHZlYzQgb3V0bGluZUNvbG9yO1xcbnZhcnlpbmcgZmxvYXQgc2NhbGU7XFxuXFxuY29uc3QgZmxvYXQgTUFYX0NPUlJFQ1RFRF9HTFlQSF9TQ0FMRSA9IDAuNTtcXG5jb25zdCBmbG9hdCBHTFlQSF9CQVNFX1dFSUdIVCA9IDAuNztcXG5jb25zdCBmbG9hdCBHTFlQSF9CQVNFX1NNT1RITkVTUyA9IDAuMTtcXG5jb25zdCBmbG9hdCBHTFlQSF9XRUlHSFRfU0NBTEVfSU1QQUNUID0gMC4xO1xcbmNvbnN0IGZsb2F0IEdMWVBIX1NNT09USE5FU1NfU0NBTEVfSU1QQUNUID0gMC4wNjtcXG5jb25zdCBmbG9hdCBPVVRMSU5FX1dFSUdIVF9TQ0FMRV9JTVBBQ1QgPSAwLjEyNTtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgICAvLyBsb3cgc2NhbGUgZ2x5cGhzIChsZXNzIHRoYW4gMC41KSBzaG91bGQgYmUgYSBsaXR0bGUgYml0IGJvbGRlciBhbmQgc21vb3RoZXJcXG4gICAgZmxvYXQgc2NhbGVDbGFtcGVkID0gY2xhbXAoc2NhbGUsIDAuMCwgTUFYX0NPUlJFQ1RFRF9HTFlQSF9TQ0FMRSk7XFxuICAgIC8vIHdlaWdodCBpcyByZXNwb25zaWJsZSBmb3IgZ2x5cGggYm9sZG5lc3MsIHRoZSBsZXNzIHdlaWdodCB2YWx1ZSB0aGUgYm9sZGVyIHRoZSB0ZXh0XFxuICAgIGZsb2F0IHdlaWdodCA9IEdMWVBIX0JBU0VfV0VJR0hUICsgR0xZUEhfV0VJR0hUX1NDQUxFX0lNUEFDVCAqIHNjYWxlQ2xhbXBlZDtcXG4gICAgLy8gc21vb3RobmVzcyBpcyBob3cgYmx1cnJlZCBnbHlwaHMgYXJlLCB0aGUgbGVzcyBzbW9vdGhuZXNzIHZhbHVlIHRoZSBsZXNzIGJsdXJyaW5nXFxuICAgIGZsb2F0IHNtb290aG5lc3MgPSAoR0xZUEhfQkFTRV9TTU9USE5FU1MgKyBHTFlQSF9TTU9PVEhORVNTX1NDQUxFX0lNUEFDVCAvIHNjYWxlQ2xhbXBlZCkgLyBkcHI7XFxuXFxuICAgIHZlYzQgcmVzdWx0Q29sb3IgPSBjb2xvcjtcXG4gICAgZmxvYXQgZGlzdCA9IHRleHR1cmUyRChhdGxhcywgdXYgLyBhdGxhc1NpemUpLmE7XFxuICAgIGZsb2F0IGFscGhhID0gc21vb3Roc3RlcCh3ZWlnaHQgLSBzbW9vdGhuZXNzLCB3ZWlnaHQgKyBzbW9vdGhuZXNzLCBkaXN0KTtcXG5cXG4gICAgaWYgKG91dGxpbmVDb2xvci5hICE9IDAuMCkge1xcbiAgICAgICAgLy8gdG8gcmVuZGVyIG91dGxpbmUgdGhlIGdseXBoIGlzIHJlbmRlcmVkIGEgbGl0dGxlIGJpdCBib2xkZXIgd2l0aCBkaWZmZXJlbnQgY29sb3IgYXQgZWRnZXNcXG4gICAgICAgIHdlaWdodCA9IHdlaWdodCAtIE9VVExJTkVfV0VJR0hUX1NDQUxFX0lNUEFDVCAvIHNjYWxlO1xcbiAgICAgICAgcmVzdWx0Q29sb3IgPSBtaXgob3V0bGluZUNvbG9yLCBjb2xvciwgYWxwaGEpO1xcbiAgICAgICAgYWxwaGEgPSBzbW9vdGhzdGVwKHdlaWdodCAtIHNtb290aG5lc3MsIHdlaWdodCArIHNtb290aG5lc3MsIGRpc3QpO1xcbiAgICB9XFxuXFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQocmVzdWx0Q29sb3IucmdiLCByZXN1bHRDb2xvci5hICogYWxwaGEpO1xcbn1cXG5cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL2xhYmVsL3NoYWRlci9kZl90ZXh0LmZyYWdcbi8vIG1vZHVsZSBpZCA9IDQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBXb3JsZFByaW1pdGl2ZVJlbmRlclVuaXQgZnJvbSAnLi4vd29ybGRfcHJpbWl0aXZlX3JlbmRlcl91bml0JztcclxuaW1wb3J0ICogYXMgdmVjMiBmcm9tICcuLi8uLi8uLi9tYXRoL3ZlY3RvcjInO1xyXG5pbXBvcnQgUmVuZGVyU3RhdGUsIHsgQkxFTkRfT1ZFUl9SRU5ERVJfU1RBVEUgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXIvc3RhdGUnO1xyXG4vKipcclxuICogQmFzZSByZW5kZXJlciB0aGF0IGluY2Fwc3VsYXRlcyBhbGwgdGhlIEdMIHNwZWNpZmljcyB0byBtYWtlIGxhYmVscyByZW5kZXJlZC5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExhYmVsUmVuZGVyVW5pdCBleHRlbmRzIFdvcmxkUHJpbWl0aXZlUmVuZGVyVW5pdCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBwcm9ncmFtLCBjYW1lcmEsIHZpc2liaWxpdHlQcm92aWRlciwgcHJpbWl0aXZlUHJvdmlkZXIpIHtcclxuICAgICAgICBzdXBlcihjb250ZXh0LCBuZXcgUmVuZGVyU3RhdGUoQkxFTkRfT1ZFUl9SRU5ERVJfU1RBVEUpLCBwcm9ncmFtLCBwcmltaXRpdmVQcm92aWRlcik7XHJcbiAgICAgICAgdGhpcy5fY2FtZXJhID0gY2FtZXJhO1xyXG4gICAgICAgIHRoaXMuX3Zpc2liaWxpdHlQcm92aWRlciA9IHZpc2liaWxpdHlQcm92aWRlcjtcclxuICAgICAgICB0aGlzLl9pZEhhbGZQeFNpemVVbmlmb3JtID0gdmVjMi5jcmVhdGUoMCwgMCk7XHJcbiAgICAgICAgdGhpcy5fYXRsYXNTaXplVW5pZm9ybSA9IHZlYzIuY3JlYXRlKDAsIDApO1xyXG4gICAgICAgIGNvbnRleHQuYmluZFByb2dyYW0ocHJvZ3JhbSk7XHJcbiAgICAgICAgcHJvZ3JhbS5zZXRJbnRTY2FsYXJVbmlmb3JtKCd2aXNpYmlsaXR5JywgMCk7XHJcbiAgICB9XHJcbiAgICBfcHJlcGFyZVByb2dyYW0ocHJvZ3JhbSwgdmlld1Byb2pNYXRyaXgsIGNhbWVyYVBvc2l0aW9ucykge1xyXG4gICAgICAgIGNvbnN0IHZpc2liaWxpdHkgPSB0aGlzLl92aXNpYmlsaXR5UHJvdmlkZXIoKTtcclxuICAgICAgICBzdXBlci5fcHJlcGFyZVByb2dyYW0ocHJvZ3JhbSwgdmlld1Byb2pNYXRyaXgsIGNhbWVyYVBvc2l0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5faWRIYWxmUHhTaXplVW5pZm9ybS54ID0gMC41IC8gdmlzaWJpbGl0eS5nZXRXaWR0aCgpO1xyXG4gICAgICAgIHRoaXMuX2lkSGFsZlB4U2l6ZVVuaWZvcm0ueSA9IDAuNSAvIHZpc2liaWxpdHkuZ2V0SGVpZ2h0KCk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kVGV4dHVyZVVuaXQoMCk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kVGV4dHVyZSh2aXNpYmlsaXR5KTtcclxuICAgICAgICBwcm9ncmFtLnNldFZlY3RvcjJVbmlmb3JtKCdpZEhhbGZQeFNpemUnLCB0aGlzLl9pZEhhbGZQeFNpemVVbmlmb3JtKTtcclxuICAgICAgICBwcm9ncmFtLnNldFZlY3RvcjJVbmlmb3JtKCdwaXhlbFNpemUnLCB0aGlzLl9jYW1lcmEucGl4ZWxTaXplKTtcclxuICAgICAgICBwcm9ncmFtLnNldFNjYWxhclVuaWZvcm0oJ2RwcicsIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKTtcclxuICAgIH1cclxuICAgIF9yZW5kZXJCYXRjaChtZW1vcnlCYXRjaCkge1xyXG4gICAgICAgIGNvbnN0IGF0bGFzID0gbWVtb3J5QmF0Y2guZmlyc3RQcmltaXRpdmUuYXRsYXM7XHJcbiAgICAgICAgdGhpcy5fYXRsYXNTaXplVW5pZm9ybS54ID0gYXRsYXMud2lkdGg7XHJcbiAgICAgICAgdGhpcy5fYXRsYXNTaXplVW5pZm9ybS55ID0gYXRsYXMuaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMuX3Byb2dyYW0uc2V0SW50U2NhbGFyVW5pZm9ybSgnYXRsYXMnLCAxKTtcclxuICAgICAgICB0aGlzLl9wcm9ncmFtLnNldFZlY3RvcjJVbmlmb3JtKCdhdGxhc1NpemUnLCB0aGlzLl9hdGxhc1NpemVVbmlmb3JtKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRUZXh0dXJlVW5pdCgxKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRUZXh0dXJlKGF0bGFzLnRleHR1cmUpO1xyXG4gICAgICAgIHN1cGVyLl9yZW5kZXJCYXRjaChtZW1vcnlCYXRjaCk7XHJcbiAgICB9XHJcbiAgICBfY2FuQmF0Y2hBZGphY2VudFByaW1pdGl2ZXMoYSwgYikge1xyXG4gICAgICAgIHJldHVybiBzdXBlci5fY2FuQmF0Y2hBZGphY2VudFByaW1pdGl2ZXMoYSwgYikgJiYgKGEuYXRsYXMgPT09IGIuYXRsYXMpO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL2xhYmVsL2xhYmVsX3JlbmRlcl91bml0LnRzXG4vLyBtb2R1bGUgaWQgPSA0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgY3VydmVkTGFiZWxWZXJ0ZXhTaGFkZXIgZnJvbSAnLi9zaGFkZXIvY3VydmVkX2xhYmVsLnZlcnQnO1xyXG5pbXBvcnQgZGZUZXh0RnJhZ21lbnRTaGFkZXIgZnJvbSAnLi9zaGFkZXIvZGZfdGV4dC5mcmFnJztcclxuaW1wb3J0IExhYmVsUmVuZGVyVW5pdCBmcm9tICcuL2xhYmVsX3JlbmRlcl91bml0JztcclxuZXhwb3J0IGNvbnN0IFBST0dSQU1fT1BUSU9OUyA9IHtcclxuICAgIGF0dHJpYk1hcDoge1xyXG4gICAgICAgIHZlcnRleElkOiAyIC8qIElEICovLFxyXG4gICAgICAgIHZlcnRleFBvc0hpZ2g6IDAgLyogUE9TSVRJT05fSElHSCAqLyxcclxuICAgICAgICB2ZXJ0ZXhQb3NMb3c6IDEgLyogUE9TSVRJT05fTE9XICovLFxyXG4gICAgICAgIHZlcnRleERpc3BsYWNlbWVudHM6IDYgLyogRElTUExBQ0VNRU5UICovLFxyXG4gICAgICAgIHZlcnRleFVWOiA0IC8qIFVWICovLFxyXG4gICAgICAgIHZlcnRleENvbG9yOiA3IC8qIENPTE9SICovLFxyXG4gICAgICAgIHZlcnRleE91dGxpbmVDb2xvcjogOCAvKiBPVVRMSU5FX0NPTE9SICovLFxyXG4gICAgICAgIHZlcnRleFByaW9yaXR5OiA5IC8qIFBSSU9SSVRZICovLFxyXG4gICAgICAgIGxlZnRQb2x5bGluZVJhdGlvczogMTIgLyogQVVYMSAqLyxcclxuICAgICAgICBsZWZ0UG9seWxpbmVBbmdsZXM6IDEzIC8qIEFVWDIgKi8sXHJcbiAgICAgICAgcmlnaHRQb2x5bGluZVJhdGlvczogMTQgLyogQVVYMyAqLyxcclxuICAgICAgICByaWdodFBvbHlsaW5lQW5nbGVzOiAxNSAvKiBBVVg0ICovLFxyXG4gICAgICAgIHBvbHlsaW5lTGVuZ3RoX3ZlcnRleFNjYWxlOiAxMSAvKiBBVVggKi9cclxuICAgIH1cclxufTtcclxuLyoqXHJcbiAqIEN1cnZlZCBsYWJlbHMgcmVuZGVyZXIuIEl0IHVzZXMgYXBwcm9wcmlhdGUgcHJvZ3JhbSB0byBsYXlvdXQgZ2x5cGhzIG9uIEdQVS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEN1cnZlZExhYmVsUmVuZGVyVW5pdCBleHRlbmRzIExhYmVsUmVuZGVyVW5pdCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBjYW1lcmEsIHZpc2liaWxpdHlQcm92aWRlciwgcHJpbWl0aXZlUHJvdmlkZXIpIHtcclxuICAgICAgICBjb25zdCBwcm9ncmFtID0gY29udGV4dC5jcmVhdGVQcm9ncmFtKGN1cnZlZExhYmVsVmVydGV4U2hhZGVyLCBkZlRleHRGcmFnbWVudFNoYWRlciwgUFJPR1JBTV9PUFRJT05TKTtcclxuICAgICAgICBzdXBlcihjb250ZXh0LCBwcm9ncmFtLCBjYW1lcmEsIHZpc2liaWxpdHlQcm92aWRlciwgcHJpbWl0aXZlUHJvdmlkZXIpO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL2xhYmVsL2N1cnZlZF9sYWJlbF9yZW5kZXJfdW5pdC50c1xuLy8gbW9kdWxlIGlkID0gNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IFdvcmxkUHJpbWl0aXZlUmVuZGVyVW5pdCBmcm9tICcuLi93b3JsZF9wcmltaXRpdmVfcmVuZGVyX3VuaXQnO1xyXG4vKipcclxuICogQmFzZSByZW5kZXJlciBvZiBwb2x5bGluZSBwcmltaXRpdmVzLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFzZVBvbHlsaW5lUmVuZGVyVW5pdCBleHRlbmRzIFdvcmxkUHJpbWl0aXZlUmVuZGVyVW5pdCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCByZW5kZXJTdGF0ZSwgcHJvZ3JhbSwgcHJpbWl0aXZlUHJvdmlkZXIsIGNhbWVyYSkge1xyXG4gICAgICAgIHN1cGVyKGNvbnRleHQsIHJlbmRlclN0YXRlLCBwcm9ncmFtLCBwcmltaXRpdmVQcm92aWRlcik7XHJcbiAgICAgICAgdGhpcy5fY2FtZXJhID0gY2FtZXJhO1xyXG4gICAgfVxyXG4gICAgX3ByZXBhcmVQcm9ncmFtKHByb2dyYW0sIHZpZXdQcm9qTWF0cml4LCBjYW1lcmFQb3NpdGlvbnMpIHtcclxuICAgICAgICBzdXBlci5fcHJlcGFyZVByb2dyYW0ocHJvZ3JhbSwgdmlld1Byb2pNYXRyaXgsIGNhbWVyYVBvc2l0aW9ucyk7XHJcbiAgICAgICAgcHJvZ3JhbS5zZXRTY2FsYXJVbmlmb3JtKCd3b3JsZFRvUHhGYWN0b3InLCB0aGlzLl9jYW1lcmEud29ybGRUb1B4RmFjdG9yKTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9wb2x5bGluZS9iYXNlX3BvbHlsaW5lX3JlbmRlcl91bml0LnRzXG4vLyBtb2R1bGUgaWQgPSA0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBCaW5hcnlTZWFyY2hUcmVlIH0gZnJvbSAnLi9iaW5hcnlfdHJlZSc7XHJcbmltcG9ydCBMaW5rZWRTZXQgZnJvbSAnLi9saW5rZWRfc2V0JztcclxuLyoqXHJcbiAqIEFsaWduZXMgYW4gb2Zmc2V0IHNvIGl0J3MgYSBtdWx0aXBsZSBvZiBhbiBhbGlnbm1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSBvZmZzZXQgVGhlIG9mZnNldC5cclxuICogQHBhcmFtIGFsaWdubWVudCBUaGUgYWxpZ25tZW50LlxyXG4gKiBAcmV0dXJucyBBbGlnbmVkIG9mZnNldC5cclxuICovXHJcbmZ1bmN0aW9uIGFsaWduKG9mZnNldCwgYWxpZ25tZW50KSB7XHJcbiAgICByZXR1cm4gYWxpZ25tZW50ICogTWF0aC5jZWlsKG9mZnNldCAvIGFsaWdubWVudCk7XHJcbn1cclxuZXhwb3J0IGNsYXNzIEFyZW5hQWxsb2NhdG9yIHtcclxuICAgIC8qKlxyXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBlbXB0eSBhcmVuYSBhbGxvY2F0b3IuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHNpemUgU2l6ZSBvZiBtYW5hZ2VkIHJlZ2lvbi5cclxuICAgICAqIEBwYXJhbSBhbGlnbm1lbnQgYWxpZ25tZW50IG9mIG9mZnNldHMuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHNpemUsIGFsaWdubWVudCA9IDEpIHtcclxuICAgICAgICB0aGlzLl9zaXplID0gc2l6ZTtcclxuICAgICAgICB0aGlzLl9hbGlnbm1lbnQgPSBhbGlnbm1lbnQ7XHJcbiAgICAgICAgdGhpcy5fZnJlZU9mZnNldCA9IDA7XHJcbiAgICAgICAgdGhpcy5fYWxsb2NhdGVkT2Zmc2V0cyA9IG5ldyBTZXQoKTtcclxuICAgIH1cclxuICAgIGdldCBzaXplKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zaXplO1xyXG4gICAgfVxyXG4gICAgZ2V0IG1heEFsbG9jYWJsZVNpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpemUgLSB0aGlzLl9mcmVlT2Zmc2V0O1xyXG4gICAgfVxyXG4gICAgZ2V0IGlzRW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FsbG9jYXRlZE9mZnNldHMuc2l6ZSA9PT0gMDtcclxuICAgIH1cclxuICAgIGFsbG9jYXRlKHNpemUpIHtcclxuICAgICAgICBpZiAodGhpcy5fc2l6ZSA+PSB0aGlzLl9mcmVlT2Zmc2V0ICsgc2l6ZSkge1xyXG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLl9mcmVlT2Zmc2V0O1xyXG4gICAgICAgICAgICB0aGlzLl9mcmVlT2Zmc2V0ID0gYWxpZ24ob2Zmc2V0ICsgc2l6ZSwgdGhpcy5fYWxpZ25tZW50KTtcclxuICAgICAgICAgICAgdGhpcy5fYWxsb2NhdGVkT2Zmc2V0cy5hZGQob2Zmc2V0KTtcclxuICAgICAgICAgICAgcmV0dXJuIG9mZnNldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBkZWFsbG9jYXRlKG9mZnNldCkge1xyXG4gICAgICAgIHRoaXMuX2FsbG9jYXRlZE9mZnNldHMuZGVsZXRlKG9mZnNldCk7XHJcbiAgICB9XHJcbiAgICBpc0FsbG9jYXRlZChvZmZzZXQpIHtcclxuICAgICAgICByZXR1cm4gb2Zmc2V0IDwgdGhpcy5fZnJlZU9mZnNldDtcclxuICAgIH1cclxuICAgIGV4dGVuZChuZXdTaXplKSB7XHJcbiAgICAgICAgaWYgKG5ld1NpemUgPCB0aGlzLl9mcmVlT2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IHJlZHVjZSB0aGUgc2l6ZSBiZWNhdXNlIGl0IGNvbmZsaWN0cyB3aXRoIGFscmVhZHkgYWxsb2NhdGVkIHJlZ2lvbi4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fc2l6ZSA9IG5ld1NpemU7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEFsbG9jYXRvciBvcHRpbWlzZWQgZm9yIGJvdGggcHJpbWFyeSBvcGVyYXRpb25zOiBhbGxvY2F0aW9uIGFuZCBkZWFsbG9jYXRpb24uIEl0IHVzZXMgQlNUIGZvciBlZmZpY2llbnQgbG9va3VwIG9mXHJcbiAqIHN1aXRhYmxlIGZyZWUgcmVnaW9uIGR1cmluZyBhbGxvY2F0aW9uIGFuZCB0d28gd2F5IGxpbmtlZCBsaXN0IGZvciBmYXN0IGFkamFjZW50IGZyZWUgcmVnaW9ucyBtZXJnZS5cclxuICogTWF4IGFsbG9jYWJsZSBzaXplIGlzIGFsc28gZGV0ZXJtaW5lZCBieSBtZWFucyBvZiB0aGUgQlNULlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEZyZWVMaXN0QWxsb2NhdG9yIHtcclxuICAgIGNvbnN0cnVjdG9yKHNpemUpIHtcclxuICAgICAgICB0aGlzLl9zaXplID0gc2l6ZTtcclxuICAgICAgICB0aGlzLl9hbGxSZWdpb25zID0gbmV3IExpbmtlZFNldCgpO1xyXG4gICAgICAgIHRoaXMuX29jY3VwaWVkUmVnaW9ucyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLl9mcmVlUmVnaW9ucyA9IG5ldyBCaW5hcnlTZWFyY2hUcmVlKChyYW5nZUEsIHJhbmdlQikgPT4gcmFuZ2VBLnNpemUgLSByYW5nZUIuc2l6ZSk7XHJcbiAgICAgICAgY29uc3QgaW5pdFJlZ2lvbiA9IHsgb2Zmc2V0OiAwLCBzaXplIH07XHJcbiAgICAgICAgdGhpcy5fYWxsUmVnaW9ucy5pbnNlcnQoaW5pdFJlZ2lvbik7XHJcbiAgICAgICAgaW5pdFJlZ2lvbi5fZnJlZU5vZGUgPSB0aGlzLl9mcmVlUmVnaW9ucy5pbnNlcnQoaW5pdFJlZ2lvbik7XHJcbiAgICB9XHJcbiAgICBnZXQgc2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZTtcclxuICAgIH1cclxuICAgIGdldCBtYXhBbGxvY2FibGVTaXplKCkge1xyXG4gICAgICAgIGNvbnN0IG1heCA9IHRoaXMuX2ZyZWVSZWdpb25zLm1heDtcclxuICAgICAgICByZXR1cm4gbWF4ID8gbWF4LnNpemUgOiAwO1xyXG4gICAgfVxyXG4gICAgZ2V0IGlzRW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX29jY3VwaWVkUmVnaW9ucy5zaXplID09PSAwO1xyXG4gICAgfVxyXG4gICAgYWxsb2NhdGUoc2l6ZSkge1xyXG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLl9maW5kTWluU3VpdGFibGUoc2l6ZSk7XHJcbiAgICAgICAgaWYgKCFub2RlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBub2RlLnZhbHVlO1xyXG4gICAgICAgIC8vIGN1cnJlbnQgcmVnaW9uIGlzIG5vdCBhdmFpbGFibGUgYW55bW9yZVxyXG4gICAgICAgIC8vIGl0IGlzIHJlbW92ZWQgZnJvbSB0aGUgZnJlZSByZWdpb25zIHBvb2xcclxuICAgICAgICB0aGlzLl9mcmVlUmVnaW9ucy5yZW1vdmUobm9kZSk7XHJcbiAgICAgICAgLy8gbmV3IG9jY3VwaWVkIG9uZSBpcyBjcmVhdGVkXHJcbiAgICAgICAgY29uc3Qgb2NjdXBpZWRSYW5nZSA9IHsgb2Zmc2V0OiByYW5nZS5vZmZzZXQsIHNpemUgfTtcclxuICAgICAgICB0aGlzLl9vY2N1cGllZFJlZ2lvbnMuc2V0KHJhbmdlLm9mZnNldCwgb2NjdXBpZWRSYW5nZSk7XHJcbiAgICAgICAgdGhpcy5fYWxsUmVnaW9ucy5pbnNlcnRBZnRlcihyYW5nZSwgb2NjdXBpZWRSYW5nZSk7XHJcbiAgICAgICAgdGhpcy5fYWxsUmVnaW9ucy5yZW1vdmUocmFuZ2UpO1xyXG4gICAgICAgIC8vIGRvbnQgbG9vc2UgcmVtYWluaW5nIGlmIGFueVxyXG4gICAgICAgIC8vIGl0IHNob3VsZCBiZSByZXR1cm5lZCBiYWNrIHRvIHRoZSBmcmVlIHJlZ2lvbnMgcG9vbFxyXG4gICAgICAgIGlmIChyYW5nZS5zaXplID4gc2l6ZSkge1xyXG4gICAgICAgICAgICBjb25zdCByZW1haW5pbmdSYW5nZSA9IHsgb2Zmc2V0OiByYW5nZS5vZmZzZXQgKyBzaXplLCBzaXplOiByYW5nZS5zaXplIC0gc2l6ZSB9O1xyXG4gICAgICAgICAgICByZW1haW5pbmdSYW5nZS5fZnJlZU5vZGUgPSB0aGlzLl9mcmVlUmVnaW9ucy5pbnNlcnQocmVtYWluaW5nUmFuZ2UpO1xyXG4gICAgICAgICAgICB0aGlzLl9hbGxSZWdpb25zLmluc2VydEFmdGVyKG9jY3VwaWVkUmFuZ2UsIHJlbWFpbmluZ1JhbmdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9jY3VwaWVkUmFuZ2Uub2Zmc2V0O1xyXG4gICAgfVxyXG4gICAgZGVhbGxvY2F0ZShvZmZzZXQpIHtcclxuICAgICAgICBsZXQgcmVnaW9uID0gdGhpcy5fb2NjdXBpZWRSZWdpb25zLmdldChvZmZzZXQpO1xyXG4gICAgICAgIGlmIChyZWdpb24pIHtcclxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIHJlZ2lvbiBjYW4gYmUgbWVyZ2VkIHdpdGggaXRzIHByZXZpb3VzIG5laWdoYm9yXHJcbiAgICAgICAgICAgIGNvbnN0IHByZXYgPSB0aGlzLl9hbGxSZWdpb25zLmdldFByZXYocmVnaW9uKTtcclxuICAgICAgICAgICAgaWYgKHByZXYgJiYgcHJldi5fZnJlZU5vZGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVtYnJhY2luZ1JhbmdlID0geyBvZmZzZXQ6IHByZXYub2Zmc2V0LCBzaXplOiBwcmV2LnNpemUgKyByZWdpb24uc2l6ZSB9O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWxsUmVnaW9ucy5pbnNlcnRBZnRlcihwcmV2LCBlbWJyYWNpbmdSYW5nZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hbGxSZWdpb25zLnJlbW92ZShyZWdpb24pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWxsUmVnaW9ucy5yZW1vdmUocHJldik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9mcmVlUmVnaW9ucy5yZW1vdmUocHJldi5fZnJlZU5vZGUpO1xyXG4gICAgICAgICAgICAgICAgcmVnaW9uID0gZW1icmFjaW5nUmFuZ2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIHJlZ2lvbiBjYW4gYmUgbWVyZ2VkIHdpdGggaXRzIG5leHQgbmVpZ2hib3JcclxuICAgICAgICAgICAgY29uc3QgbmV4dCA9IHRoaXMuX2FsbFJlZ2lvbnMuZ2V0TmV4dChyZWdpb24pO1xyXG4gICAgICAgICAgICBpZiAobmV4dCAmJiBuZXh0Ll9mcmVlTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZW1icmFjaW5nUmFuZ2UgPSB7IG9mZnNldDogcmVnaW9uLm9mZnNldCwgc2l6ZTogcmVnaW9uLnNpemUgKyBuZXh0LnNpemUgfTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FsbFJlZ2lvbnMuaW5zZXJ0QmVmb3JlKG5leHQsIGVtYnJhY2luZ1JhbmdlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FsbFJlZ2lvbnMucmVtb3ZlKHJlZ2lvbik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hbGxSZWdpb25zLnJlbW92ZShuZXh0KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ZyZWVSZWdpb25zLnJlbW92ZShuZXh0Ll9mcmVlTm9kZSk7XHJcbiAgICAgICAgICAgICAgICByZWdpb24gPSBlbWJyYWNpbmdSYW5nZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9vY2N1cGllZFJlZ2lvbnMuZGVsZXRlKG9mZnNldCk7XHJcbiAgICAgICAgICAgIHJlZ2lvbi5fZnJlZU5vZGUgPSB0aGlzLl9mcmVlUmVnaW9ucy5pbnNlcnQocmVnaW9uKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpc0FsbG9jYXRlZChvZmZzZXQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fb2NjdXBpZWRSZWdpb25zLmhhcyhvZmZzZXQpO1xyXG4gICAgfVxyXG4gICAgZXh0ZW5kKG5ld1NpemUpIHtcclxuICAgICAgICBpZiAobmV3U2l6ZSA8IHRoaXMuX3NpemUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaXplIHJlZHVjaW5nIGlzIG5vdCBhbGxvd2VkIGluIGZyZWUgbGlzdCBhbGxvY2F0b3InKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZGlmZiA9IG5ld1NpemUgLSB0aGlzLl9zaXplO1xyXG4gICAgICAgIGNvbnN0IGxhc3QgPSB0aGlzLl9hbGxSZWdpb25zLmVuZDtcclxuICAgICAgICBpZiAobGFzdCAmJiBsYXN0Ll9mcmVlTm9kZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9mcmVlUmVnaW9ucy5yZW1vdmUobGFzdC5fZnJlZU5vZGUpO1xyXG4gICAgICAgICAgICBjb25zdCByZWdpb24gPSB7IG9mZnNldDogbGFzdC5vZmZzZXQsIHNpemU6IGxhc3Quc2l6ZSArIGRpZmYsIGlzRnJlZTogdHJ1ZSB9O1xyXG4gICAgICAgICAgICB0aGlzLl9hbGxSZWdpb25zLmluc2VydEFmdGVyKGxhc3QsIHJlZ2lvbik7XHJcbiAgICAgICAgICAgIHRoaXMuX2FsbFJlZ2lvbnMucmVtb3ZlKGxhc3QpO1xyXG4gICAgICAgICAgICB0aGlzLl9mcmVlUmVnaW9ucy5pbnNlcnQocmVnaW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlZ2lvbiA9IHsgb2Zmc2V0OiB0aGlzLl9zaXplLCBzaXplOiBkaWZmLCBpc0ZyZWU6IHRydWUgfTtcclxuICAgICAgICAgICAgdGhpcy5fYWxsUmVnaW9ucy5pbnNlcnQocmVnaW9uKTtcclxuICAgICAgICAgICAgdGhpcy5fZnJlZVJlZ2lvbnMuaW5zZXJ0KHJlZ2lvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3NpemUgPSBuZXdTaXplO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmF2ZXJzZXMgQlNUIHRvIGZpbmQgdGhlIHNtYWxsZXN0IHJlZ2lvbiByZXF1aXJlZCBzaXplIGNhbiBmaXQuXHJcbiAgICAgKi9cclxuICAgIF9maW5kTWluU3VpdGFibGUoc2l6ZSkge1xyXG4gICAgICAgIGxldCBub2RlID0gdGhpcy5fZnJlZVJlZ2lvbnMucm9vdDtcclxuICAgICAgICBsZXQgYmVzdDtcclxuICAgICAgICB3aGlsZSAobm9kZSkge1xyXG4gICAgICAgICAgICBpZiAobm9kZS52YWx1ZS5zaXplID09PSBzaXplKSB7XHJcbiAgICAgICAgICAgICAgICBiZXN0ID0gbm9kZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUudmFsdWUuc2l6ZSA8IHNpemUpIHtcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYmVzdCA9IG5vZGU7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBiZXN0O1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvYWxsb2NhdG9yLnRzXG4vLyBtb2R1bGUgaWQgPSA1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgKiBhcyB2ZWMyIGZyb20gJy4uLy4uL21hdGgvdmVjdG9yMic7XHJcbmltcG9ydCB7IHVpbnQxNlRvRmxvYXQgfSBmcm9tICcuLi8uLi91dGlsL2dwdXR5cGVzJztcclxuaW1wb3J0IHsgY29tcHV0ZVNxdWFyZXNDb3ZlcmVkQnlDb252ZXhQb2x5Z29uIH0gZnJvbSAnLi4vLi4vdXRpbC9jYXJ0ZXNpYW5fZ3JpZCc7XHJcbmltcG9ydCAqIGFzIGFycmF5IGZyb20gJy4uLy4uL3V0aWwvYXJyYXknO1xyXG4vLyBNYXBzIHdvcmxkIGNvb3JkaW5hdGVzIHRvIGNvcnJlc3BvbmRpbmcgcG9pbnRzIG9uIHRoZSBjYXJ0ZXNpYW4gZ3JpZC5cclxuY29uc3QgV09STERfTUlOX0NPT1JESU5BVEUgPSB2ZWMyLmNyZWF0ZSgtMSwgLTEpO1xyXG5jb25zdCBHUklEX1dPUkxEX1JBVElPID0gMC41O1xyXG5jb25zdCBHUklEX0NPT1JESU5BVEVTX0NPTlZFUlRFUiA9IChwb2ludCkgPT4ge1xyXG4gICAgY29uc3QgZ3JpZENvb3JkaW5hdGVzID0gdmVjMi5jb3B5KHBvaW50KTtcclxuICAgIHZlYzIuc3ViKGdyaWRDb29yZGluYXRlcywgV09STERfTUlOX0NPT1JESU5BVEUsIGdyaWRDb29yZGluYXRlcyk7XHJcbiAgICB2ZWMyLm11bG4oZ3JpZENvb3JkaW5hdGVzLCBHUklEX1dPUkxEX1JBVElPLCBncmlkQ29vcmRpbmF0ZXMpO1xyXG4gICAgcmV0dXJuIGdyaWRDb29yZGluYXRlcztcclxufTtcclxuY29uc3QgQ0FNRVJBX1BPU0lUSU9OX1VJTlQzMl9DT05WRVJURVIgPSAoY29tcG9uZW50KSA9PiAwLjUgKiAoY29tcG9uZW50ICsgMSkgKiAweGZmZmZmZmZmO1xyXG5jb25zdCBISUdIX0NPTVBPTkVOVF9FWFRSQUNUT1IgPSAoY29tcG9uZW50KSA9PiB1aW50MTZUb0Zsb2F0KE1hdGgudHJ1bmMoY29tcG9uZW50IC8gMHgxMDAwMCkpO1xyXG5jb25zdCBMT1dfQ09NUE9ORU5UX0VYVFJBQ1RPUiA9IChjb21wb25lbnQpID0+IHVpbnQxNlRvRmxvYXQoY29tcG9uZW50ICYgMHhmZmZmKTtcclxuY29uc3QgUkVHSU9OX0NPTVBBUkFUT1IgPSAoYSwgYikgPT4gYS54IC0gYi54IHx8IGEueSAtIGIueTtcclxuY29uc3QgdG1wQ2FtZXJhUG9zaXRpb24gPSB2ZWMyLmNyZWF0ZSgwLCAwKTtcclxuLyoqXHJcbiAqIElmIHRoZXJlIGFyZSBtdWx0aXBsZSB3b3JsZHMgdmlzaWJsZSAobGFyZ2UgbW9uaXRvcnMvbG93IHpvb20pIHByaW1pdGl2ZXMgYXJlIHJlbmRlcmVkIGluIG11bHRpcGxlIHBhc3NlcyBmcm9tXHJcbiAqIGRpZmZlcmVudCBwb3NpdGlvbnMgKGlmIHRoZSB3cmFwIG1vZGUgb2YgY29ycmVzcG9uZGluZyBkaXJlY3Rpb24gaXMgUkVQRUFUKSB0byBnZXQgY29ycmVjdCBmaW5hbCBwaWN0dXJlLlxyXG4gKiBUaGlzIG1ldGhvZCBjYWxjdWxhdGVzIGNhbWVyYSBwb3NpdGlvbnMgYW5kIHByZXBhcmUgdGhlbSB0byBiZSBwYXNzZWQgdG8gdGhlIHJlbmRlcigpIG1ldGhvZC5cclxuICovXHJcbmNvbnN0IGNhY2hlZFJlZ2lvbiA9IFtdO1xyXG5jb25zdCBjYWNoZWRQb3NpdGlvbnMgPSBbXTtcclxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZUNhbWVyYVBvc2l0aW9ucyhjYW1lcmEpIHtcclxuICAgIGNvbnN0IHZpc2libGVSZWdpb24gPSBjYW1lcmEuZ2V0VmlzaWJsZVJlZ2lvbigpO1xyXG4gICAgaWYgKGFycmF5LmNvbXBhcmUoUkVHSU9OX0NPTVBBUkFUT1IsIGNhY2hlZFJlZ2lvbiwgdmlzaWJsZVJlZ2lvbikgPT09IDApIHtcclxuICAgICAgICByZXR1cm4gY2FjaGVkUG9zaXRpb25zO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcG9zaXRpb25zID0gW107XHJcbiAgICBmb3IgKGNvbnN0IHdvcmxkUG9zaXRpb24gb2YgY29tcHV0ZVNxdWFyZXNDb3ZlcmVkQnlDb252ZXhQb2x5Z29uKHZpc2libGVSZWdpb24ubWFwKEdSSURfQ09PUkRJTkFURVNfQ09OVkVSVEVSKSkpIHtcclxuICAgICAgICBpZiAoKGNhbWVyYS5vcHRpb25zLndyYXBNb2RlWCA9PT0gMiAvKiBSRVBFQVQgKi8gfHwgd29ybGRQb3NpdGlvbi54ID09PSAwKSAmJlxyXG4gICAgICAgICAgICAoY2FtZXJhLm9wdGlvbnMud3JhcE1vZGVZID09PSAyIC8qIFJFUEVBVCAqLyB8fCB3b3JsZFBvc2l0aW9uLnkgPT09IDApKSB7XHJcbiAgICAgICAgICAgIC8vIDIuMCBjb252ZXJ0cyBjb3ZlcmVkIHNxdWFyZSBwb3NpdGlvbiB0byB0aGUgd29ybGQncyBjZW50ZXIgY29vcmRpbmF0ZXNcclxuICAgICAgICAgICAgLy8gLTEuMCByZXZlcnNlcyB0aGUgcG9zaXRpb24gb2YgdGhlIGNhbWVyYSB0byBzaG90IHRoZSB3b3JsZCBmcm9tXHJcbiAgICAgICAgICAgIHZlYzIubXVsbih3b3JsZFBvc2l0aW9uLCAtMS4wICogMi4wLCB0bXBDYW1lcmFQb3NpdGlvbik7XHJcbiAgICAgICAgICAgIHZlYzIuYWRkKGNhbWVyYS5jZW50ZXIsIHRtcENhbWVyYVBvc2l0aW9uLCB0bXBDYW1lcmFQb3NpdGlvbik7XHJcbiAgICAgICAgICAgIHZlYzIuY29udmVydCh0bXBDYW1lcmFQb3NpdGlvbiwgQ0FNRVJBX1BPU0lUSU9OX1VJTlQzMl9DT05WRVJURVIsIHRtcENhbWVyYVBvc2l0aW9uKTtcclxuICAgICAgICAgICAgcG9zaXRpb25zLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgbG9va0F0SGlnaDogdmVjMi5jb252ZXJ0KHRtcENhbWVyYVBvc2l0aW9uLCBISUdIX0NPTVBPTkVOVF9FWFRSQUNUT1IpLFxyXG4gICAgICAgICAgICAgICAgbG9va0F0TG93OiB2ZWMyLmNvbnZlcnQodG1wQ2FtZXJhUG9zaXRpb24sIExPV19DT01QT05FTlRfRVhUUkFDVE9SKVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBhcnJheS5jb3B5KHBvc2l0aW9ucywgY2FjaGVkUG9zaXRpb25zKTtcclxuICAgIGNhY2hlZFBvc2l0aW9ucy5sZW5ndGggPSBwb3NpdGlvbnMubGVuZ3RoO1xyXG4gICAgY2FjaGVkUmVnaW9uLmxlbmd0aCA9IHZpc2libGVSZWdpb24ubGVuZ3RoO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2aXNpYmxlUmVnaW9uLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY2FjaGVkUmVnaW9uW2ldID0gdmVjMi5jb3B5KHZpc2libGVSZWdpb25baV0sIGNhY2hlZFJlZ2lvbltpXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcG9zaXRpb25zO1xyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci91dGlsL2NhbWVyYV9wb3NpdGlvbi50c1xuLy8gbW9kdWxlIGlkID0gNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcIiN2ZXJzaW9uIDEwMFxcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxuYXR0cmlidXRlIHZlYzIgdmVydGV4UG9zaXRpb247XFxuYXR0cmlidXRlIHZlYzIgdmVydGV4VXY7XFxuXFxudW5pZm9ybSBmbG9hdCB6SW5kZXg7XFxuXFxuI2lmbmRlZiBZVl9MRUFTVF8xNmJfUFxcbiMgICBpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxcbiMgICAgICAgZGVmaW5lIFlWX0xFQVNUXzE2Yl9QIGhpZ2hwXFxuIyAgIGVsc2VcXG4jICAgICAgIGRlZmluZSBZVl9MRUFTVF8xNmJfUCBtZWRpdW1wXFxuIyAgIGVuZGlmXFxuI2VuZGlmXFxuXFxudmFyeWluZyBZVl9MRUFTVF8xNmJfUCB2ZWMyIHV2O1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIGdsX1Bvc2l0aW9uID0gdmVjNCh2ZXJ0ZXhQb3NpdGlvbiwgekluZGV4LCAxKTtcXG4gICAgdXYgPSB2ZXJ0ZXhVdjtcXG59XFxuXCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvc2hhZGVycy9xdWFkLnZlcnRcbi8vIG1vZHVsZSBpZCA9IDUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBDb250ZXh0IGZyb20gJy4uLy4uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvY29udGV4dCc7XHJcbmltcG9ydCBDYW1lcmEgZnJvbSAnLi4vLi4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2NhbWVyYSc7XHJcbmltcG9ydCBWZWN0b3JBcGlBZGFwdGVyIGZyb20gJy4uLy4uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9hZGFwdGVycy92ZWN0b3JfYXBpL2FkYXB0ZXInO1xyXG5pbXBvcnQgeyBDYW1lcmFNb3VzZUNvbnRyb2xsZXIsIE1vdXNlRHJhZ0NvbnRyb2xsZXIsIFNjcm9sbFpvb21Db250cm9sbGVyLCByZW5kZXJDYW1lcmFTdGF0ZSB9IGZyb20gJy4vY2FtZXJhX3N0dWZmJztcclxuaW1wb3J0IENvbG9ySWRQb2ludExhYmVsUmVuZGVyZXIgZnJvbSAnLi4vLi4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3Zpc2liaWxpdHkvcHJpbWl0aXZlcy9sYWJlbC9jb2xvcl9pZF9wb2ludF9sYWJlbF9yZW5kZXJlcic7XHJcbmltcG9ydCBDb2xvcklkQ3VydmVkTGFiZWxSZW5kZXJlciBmcm9tICcuLi8uLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdmlzaWJpbGl0eS9wcmltaXRpdmVzL2xhYmVsL2NvbG9yX2lkX2N1cnZlZF9sYWJlbF9yZW5kZXJlcic7XHJcbmltcG9ydCBQb2ludExhYmVsUmVuZGVyVW5pdCBmcm9tICcuLi8uLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvbGFiZWwvcG9pbnRfbGFiZWxfcmVuZGVyX3VuaXQnO1xyXG5pbXBvcnQgQ3VydmVkTGFiZWxSZW5kZXJVbml0IGZyb20gJy4uLy4uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9sYWJlbC9jdXJ2ZWRfbGFiZWxfcmVuZGVyX3VuaXQnO1xyXG5pbXBvcnQgSWNvblJlbmRlclVuaXQgZnJvbSAnLi4vLi4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL2ljb24vaWNvbl9yZW5kZXJfdW5pdCc7XHJcbmltcG9ydCBNb2RlbFJlbmRlclVuaXQgZnJvbSAnLi4vLi4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL21vZGVsL21vZGVsX3JlbmRlcl91bml0JztcclxuaW1wb3J0IFRleHR1cmVkUG9seWxpbmVSZW5kZXJVbml0IGZyb20gJy4uLy4uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9wb2x5bGluZS90ZXh0dXJlZF9wb2x5bGluZV9yZW5kZXJfdW5pdCc7XHJcbmltcG9ydCBQb2x5bGluZVJlbmRlclVuaXQgZnJvbSAnLi4vLi4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL3BvbHlsaW5lL3BvbHlsaW5lX3JlbmRlcl91bml0JztcclxuaW1wb3J0IFRleHR1cmVkUG9seWdvblJlbmRlclVuaXQgZnJvbSAnLi4vLi4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL3BvbHlnb24vdGV4dHVyZWRfcG9seWdvbl9yZW5kZXJfdW5pdCc7XHJcbmltcG9ydCBUcmFuc3BhcmVudFBvbHlnb25SZW5kZXJVbml0IGZyb20gJy4uLy4uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9wb2x5Z29uL3RyYW5zcGFyZW50X3BvbHlnb25fcmVuZGVyX3VuaXQnO1xyXG5pbXBvcnQgUG9seWdvblJlbmRlclVuaXQgZnJvbSAnLi4vLi4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL3BvbHlnb24vcG9seWdvbl9yZW5kZXJfdW5pdCc7XHJcbmltcG9ydCBNYXBFbmdpbmUgZnJvbSAnLi4vLi4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL21hcF9lbmdpbmUnO1xyXG5pbXBvcnQgZ2V0RHByIGZyb20gJy4uLy4uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL2hkJztcclxuaW1wb3J0IHsgQ29sbGlkaW5nUHJpbWl0aXZlc1Jlc2V0UmVtb3ZlZFJlbmRlcmVyIH0gZnJvbSAnLi4vLi4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3Zpc2liaWxpdHkvcHJpbWl0aXZlcy9jb2xsaWRpbmdfcHJpbWl0aXZlX3Jlc2V0X3JlbW92ZWRfcmVuZGVyZXInO1xyXG5pbXBvcnQgUmVuZGVyTG9vcCBmcm9tICcuLi8uLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyX2xvb3AnO1xyXG4vLyBpbXBvcnQgSW1hZ2VSZW5kZXJVbml0IGZyb20gJy4uLy4uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9pbWFnZS9pbWFnZV9yZW5kZXJfdW5pdCc7XHJcbi8vIGltcG9ydCBSYXN0ZXJUaWxlc0FkYXB0ZXIgZnJvbSAnLi4vLi4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2FkYXB0ZXJzL3Jhc3Rlcl90aWxlcy9hZGFwdGVyJztcclxuLy8gaW1wb3J0IHtUaWxlSXRlbX0gZnJvbSAnLi4vLi4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2FkYXB0ZXJzL3RpbGVfYmFzZWRfYWRhcHRlci91dGlsL3RpbGVfc3lzdGVtJztcclxuY29uc3QgR0xfQ09OVEVYVF9BVFRSSUJTID0ge1xyXG4gICAgYWxwaGE6IGZhbHNlLFxyXG4gICAgZGVwdGg6IHRydWUsXHJcbiAgICBzdGVuY2lsOiBmYWxzZSxcclxuICAgIGFudGlhbGlhczogZmFsc2UsXHJcbiAgICBmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0OiB0cnVlXHJcbn07XHJcbmNvbnN0IGNhbWVyYSA9IG5ldyBDYW1lcmEoe1xyXG4gICAgd3JhcE1vZGVYOiAyIC8qIFJFUEVBVCAqLyxcclxuICAgIHdyYXBNb2RlWTogMCAvKiBOT05FICovXHJcbn0pO1xyXG5jYW1lcmEub25VcGRhdGUuYWRkTGlzdGVuZXIoKCkgPT4gcmVuZGVyQ2FtZXJhU3RhdGUoY2FtZXJhKSk7XHJcbmNhbWVyYS5jZW50ZXIueCA9IDAuMjA4OTg0Mzc7XHJcbmNhbWVyYS5jZW50ZXIueSA9IDAuMzczMDQ2ODc7XHJcbmNhbWVyYS56b29tID0gMTQ7XHJcbmNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNjYW52YXMnKTtcclxue1xyXG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICBjb25zdCBkcHIgPSBnZXREcHIoKTtcclxuICAgIGNhbnZhcy53aWR0aCA9IGRwciAqIHdpZHRoO1xyXG4gICAgY2FudmFzLmhlaWdodCA9IGRwciAqIGhlaWdodDtcclxuICAgIGNhbWVyYS5zY3JlZW5TaXplLndpZHRoID0gd2lkdGg7XHJcbiAgICBjYW1lcmEuc2NyZWVuU2l6ZS5oZWlnaHQgPSBoZWlnaHQ7XHJcbn1cclxuY29uc3QgY2FtZXJhTW91c2VDb250cm9sbGVyID0gbmV3IENhbWVyYU1vdXNlQ29udHJvbGxlcihjYW52YXMsIGNhbWVyYSk7XHJcbmNvbnN0IG1vdXNlRHJhZ0NvbnRyb2xsZXIgPSBuZXcgTW91c2VEcmFnQ29udHJvbGxlcihjYW52YXMpO1xyXG5tb3VzZURyYWdDb250cm9sbGVyLnNldERlbGVnYXRlKGNhbWVyYU1vdXNlQ29udHJvbGxlcik7XHJcbmNvbnN0IHNjcm9sbFpvb21Db250cm9sbGVyID0gbmV3IFNjcm9sbFpvb21Db250cm9sbGVyKGNhbnZhcyk7XHJcbnNjcm9sbFpvb21Db250cm9sbGVyLnNldERlbGVnYXRlKGNhbWVyYU1vdXNlQ29udHJvbGxlcik7XHJcbmNvbnN0IGNvbnRleHQgPSBDb250ZXh0LmNyZWF0ZUZyb21DYW52YXMoY2FudmFzLCBHTF9DT05URVhUX0FUVFJJQlMpO1xyXG5jb25zdCBlbmdpbmUgPSBuZXcgTWFwRW5naW5lKGNvbnRleHQsIGNhbWVyYSwgbmV3IFJlbmRlckxvb3AoKSk7XHJcbmNvbnN0IHZlY3RvckFkYXB0ZXIgPSBuZXcgVmVjdG9yQXBpQWRhcHRlcihlbmdpbmUsIGNhbWVyYSwgJy4vdGlsZV9wcm92aWRlcl93b3JrZXIuanM/d29ya2VyJywgJ21hcCcsIFxyXG4vLyB7XHJcbi8vICAgICB0aWxlVXJsVGVtcGxhdGU6ICdodHRwczovL3ZlYy1yZHIwMWUudHN0Lm1hcHMueWFuZGV4LnJ1L3ZtYXAyL3RpbGVzP2w9dm1hcDImbGFuZz1ydV9SVSZ4PXt7eH19Jnk9e3t5fX0mej17e3p9fSZ6bWluPXt7em1pbn19JnptYXg9e3t6bWF4fX0nLFxyXG4vLyAgICAgaW1hZ2VVcmxUZW1wbGF0ZTogJ2h0dHBzOi8vdmVjLXJkcjAxZS50c3QubWFwcy55YW5kZXgucnUvcmVzb3VyY2VzP2lkPXt7aWR9fSZzY2FsZT17e3NjYWxlfX0nLFxyXG4vLyAgICAgbWVzaFVybFRlbXBsYXRlOiAnaHR0cHM6Ly92ZWMtcmRyMDFlLnRzdC5tYXBzLnlhbmRleC5ydS9tZXNoZXM/aWQ9e3tpZH19JyxcclxuLy8gICAgIGdseXBoUmFuZ2VVcmxUZW1wbGF0ZTogJ2h0dHBzOi8vdmVjLXJkcjAxZS50c3QubWFwcy55YW5kZXgucnUvZ2x5cGhzP2xhbmc9cnVfUlUmZm9udF9pZD17e2ZvbnRJZH19JnJhbmdlPXt7cmFuZ2V9fSdcclxuLy8gfVxyXG57XHJcbiAgICB0aWxlVXJsVGVtcGxhdGU6ICdodHRwczovL3ZlYzB7e2hvc3RBbGlhc319Lm1hcHMueWFuZGV4Lm5ldC92bWFwMi90aWxlcz9sPXZtYXAyJmxhbmc9UlVfcnUmeD17e3h9fSZ5PXt7eX19Jno9e3t6fX0mem1pbj17e3ptaW59fSZ6bWF4PXt7em1heH19JyxcclxuICAgIGltYWdlVXJsVGVtcGxhdGU6ICdodHRwczovL3ZlYzB7e2hvc3RBbGlhc319Lm1hcHMueWFuZGV4Lm5ldC9yZXNvdXJjZXM/aWQ9e3tpZH19JnNjYWxlPXt7c2NhbGV9fScsXHJcbiAgICBtZXNoVXJsVGVtcGxhdGU6ICdodHRwczovL3ZlYzB7e2hvc3RBbGlhc319Lm1hcHMueWFuZGV4Lm5ldC92bWFwMi9tZXNoZXM/aWQ9e3tpZH19JyxcclxuICAgIGdseXBoUmFuZ2VVcmxUZW1wbGF0ZTogJ2h0dHBzOi8vdmVjMHt7aG9zdEFsaWFzfX0ubWFwcy55YW5kZXgubmV0L2dseXBocz9sYW5nPVJVX3J1JmZvbnRfaWQ9e3tmb250SWR9fSZyYW5nZT17e3JhbmdlfX0nXHJcbn0sIDEgLyogWDQgKi8pO1xyXG4vLyBjbGFzcyBUcmFmZmljTGF5ZXJBZGFwdGVyIGV4dGVuZHMgUmFzdGVyVGlsZXNBZGFwdGVyIHtcclxuLy8gICAgIHB1YmxpYyBfZ2V0SW1hZ2VVcmwodGlsZTogVGlsZUl0ZW0pOiBzdHJpbmcge1xyXG4vLyAgICAgICAgIHJldHVybiBgaHR0cHM6Ly9qZ28ubWFwcy55YW5kZXgubmV0LzEuMS90aWxlcz90cmYmbD10cmYsdHJmZSZsYW5nPXJ1X1VBJng9JHt0aWxlLnh9Jnk9JHt0aWxlLnl9Jno9JHt0aWxlLnpvb219JnNjYWxlPSR7d2luZG93LmRldmljZVBpeGVsUmF0aW99JnRtPSR7TWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCl9YFxyXG4vLyAgICAgICAgIC8vIHJldHVybiBgaHR0cHM6Ly9zYXQwMy5tYXBzLnlhbmRleC5uZXQvdGlsZXM/bD1zYXQmdj0zLjQxOS4wJng9JHt0aWxlLnh9Jnk9JHt0aWxlLnl9Jno9JHt0aWxlLnpvb219JnNjYWxlPSR7d2luZG93LmRldmljZVBpeGVsUmF0aW99Jmxhbmc9cnVfVUFgXHJcbi8vICAgICB9XHJcbi8vIH1cclxuLy8gY29uc3QgdHJhZmZpY0FkYXB0ZXIgPSBuZXcgVHJhZmZpY0xheWVyQWRhcHRlcihcclxuLy8gICAgIGVuZ2luZSxcclxuLy8gICAgIGNhbWVyYSxcclxuLy8gICAgIHt3aWR0aDogMjU2ICogd2luZG93LmRldmljZVBpeGVsUmF0aW8sIGhlaWdodDogMjU2ICogd2luZG93LmRldmljZVBpeGVsUmF0aW99XHJcbi8vICk7XHJcbmVuZ2luZS5ncm91bmRMYXllci5hZGRSZW5kZXJVbml0KG5ldyBQb2x5Z29uUmVuZGVyVW5pdChjb250ZXh0LCB2ZWN0b3JBZGFwdGVyLm9wYXF1ZVBvbHlnb25zUHJvdmlkZXIpKTtcclxuZW5naW5lLmdyb3VuZExheWVyLmFkZFJlbmRlclVuaXQobmV3IFRyYW5zcGFyZW50UG9seWdvblJlbmRlclVuaXQoY29udGV4dCwgdmVjdG9yQWRhcHRlci50cmFuc3BhcmVudFBvbHlnb25zUHJvdmlkZXIpKTtcclxuZW5naW5lLmdyb3VuZExheWVyLmFkZFJlbmRlclVuaXQobmV3IFRleHR1cmVkUG9seWdvblJlbmRlclVuaXQoY29udGV4dCwgdmVjdG9yQWRhcHRlci50ZXh0dXJlZFBvbHlnb25zUHJvdmlkZXIpKTtcclxuZW5naW5lLmdyb3VuZExheWVyLmFkZFJlbmRlclVuaXQobmV3IFBvbHlsaW5lUmVuZGVyVW5pdChjb250ZXh0LCBjYW1lcmEsIHZlY3RvckFkYXB0ZXIucG9seWxpbmVzUHJvdmlkZXIpKTtcclxuZW5naW5lLmdyb3VuZExheWVyLmFkZFJlbmRlclVuaXQobmV3IFRleHR1cmVkUG9seWxpbmVSZW5kZXJVbml0KGNvbnRleHQsIGNhbWVyYSwgdmVjdG9yQWRhcHRlci50ZXh0dXJlZFBvbHlsaW5lc1Byb3ZpZGVyKSk7XHJcbmVuZ2luZS5idWlsZGluZ3NMYXllci5hZGRSZW5kZXJVbml0KG5ldyBNb2RlbFJlbmRlclVuaXQoY29udGV4dCwgdmVjdG9yQWRhcHRlci5tb2RlbHNQcm92aWRlcikpO1xyXG4vLyBlbmdpbmUuaWNvbnNMYXllci5hZGRSZW5kZXJVbml0KG5ldyBJbWFnZVJlbmRlclVuaXQoY29udGV4dCwgdHJhZmZpY0FkYXB0ZXIuaW1hZ2VzUHJvdmlkZXIpKTtcclxuZW5naW5lLmljb25zTGF5ZXIuYWRkUmVuZGVyVW5pdChuZXcgSWNvblJlbmRlclVuaXQoY29udGV4dCwgY2FtZXJhLCB2ZWN0b3JBZGFwdGVyLmljb25zUHJvdmlkZXIpKTtcclxuZW5naW5lLmxhYmVsc0xheWVyLmFkZFJlbmRlclVuaXQobmV3IEN1cnZlZExhYmVsUmVuZGVyVW5pdChjb250ZXh0LCBjYW1lcmEsIGVuZ2luZS52aXNiaWxpdHlUZXh0dXJlUHJvdmlkZXIsIHZlY3RvckFkYXB0ZXIuY3VydmVkTGFiZWxzUHJvdmlkZXIpKTtcclxuZW5naW5lLmxhYmVsc0xheWVyLmFkZFJlbmRlclVuaXQobmV3IFBvaW50TGFiZWxSZW5kZXJVbml0KGNvbnRleHQsIGNhbWVyYSwgZW5naW5lLnZpc2JpbGl0eVRleHR1cmVQcm92aWRlciwgdmVjdG9yQWRhcHRlci5wb2ludExhYmVsc1Byb3ZpZGVyKSk7XHJcbmVuZ2luZS52aXNpYmlsaXR5TWFuYWdlci5yZWdpc3RlckNvbGxpZGluZ1ByaW1pdGl2ZXModmVjdG9yQWRhcHRlci5jdXJ2ZWRMYWJlbHNQcm92aWRlciwgbmV3IENvbG9ySWRDdXJ2ZWRMYWJlbFJlbmRlcmVyKGNvbnRleHQsIGNhbWVyYSwgdmVjdG9yQWRhcHRlci5jdXJ2ZWRMYWJlbHNQcm92aWRlciksIG5ldyBDb2xsaWRpbmdQcmltaXRpdmVzUmVzZXRSZW1vdmVkUmVuZGVyZXIoY29udGV4dCwgdmVjdG9yQWRhcHRlci5jdXJ2ZWRMYWJlbHNQcm92aWRlcikpO1xyXG5lbmdpbmUudmlzaWJpbGl0eU1hbmFnZXIucmVnaXN0ZXJDb2xsaWRpbmdQcmltaXRpdmVzKHZlY3RvckFkYXB0ZXIucG9pbnRMYWJlbHNQcm92aWRlciwgbmV3IENvbG9ySWRQb2ludExhYmVsUmVuZGVyZXIoY29udGV4dCwgY2FtZXJhLCB2ZWN0b3JBZGFwdGVyLnBvaW50TGFiZWxzUHJvdmlkZXIpLCBuZXcgQ29sbGlkaW5nUHJpbWl0aXZlc1Jlc2V0UmVtb3ZlZFJlbmRlcmVyKGNvbnRleHQsIHZlY3RvckFkYXB0ZXIucG9pbnRMYWJlbHNQcm92aWRlcikpO1xyXG5kb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGx1cycpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xyXG4gICAgY2FtZXJhLnpvb20gKz0gMC4xO1xyXG59KTtcclxuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21pbnVzJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XHJcbiAgICBjYW1lcmEuem9vbSAtPSAwLjE7XHJcbn0pO1xyXG4vLyBzZXRUaW1lb3V0KCgpID0+IHtcclxuLy8gICAgIGNvbnNvbGUubG9nKCdTZXR0aW5nIG5ldyB0aWxlIHVybCB0ZW1wbGF0ZScpO1xyXG4vLyAgICAgdmVjdG9yQWRhcHRlci5zZXRUaWxlVXJsVGVtcGxhdGUoJ2h0dHBzOi8vdmVjLXJkcjAxZS50c3QubWFwcy55YW5kZXgucnUvdm1hcDIvdGlsZXM/bD12bWFwMiZsYW5nPXJ1X1JVJng9e3t4fX0meT17e3l9fSZ6PXt7en19JnptaW49e3t6bWlufX0mem1heD17e3ptYXh9fScpO1xyXG4vLyB9LCA0MDAwKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi90b29scy9zdGFuZC9pbmRleC50c1xuLy8gbW9kdWxlIGlkID0gNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgQXR0cmlidXRlTWFwcGluZyB9IGZyb20gJy4vYXR0cmliX21hcHBpbmcnO1xyXG5pbXBvcnQgQnVmZmVyIGZyb20gJy4vZ2wvYnVmZmVyJztcclxuaW1wb3J0IEZyYW1lYnVmZmVyIGZyb20gJy4vZ2wvZnJhbWVidWZmZXInO1xyXG5pbXBvcnQgUHJvZ3JhbSBmcm9tICcuL2dsL3Byb2dyYW0nO1xyXG5pbXBvcnQgUmVuZGVyYnVmZmVyIGZyb20gJy4vZ2wvcmVuZGVyYnVmZmVyJztcclxuaW1wb3J0IFJlbmRlckNvbnRleHRDYXBhYmlsaXRpZXNNYW5hZ2VyIGZyb20gJy4vY2FwYWJpbGl0aWVzJztcclxuaW1wb3J0IFJlbmRlclN0YXRlIGZyb20gJy4vc3RhdGUnO1xyXG5pbXBvcnQgVGV4dHVyZSwgeyBERUZBVUxUX1RFWFRVUkVfUEFSQU1TIH0gZnJvbSAnLi9nbC90ZXh0dXJlJztcclxuaW1wb3J0IFZlcnRleEFycmF5T2JqZWN0IGZyb20gJy4vZ2wvdmFvJztcclxuaW1wb3J0ICogYXMgY29sb3IgZnJvbSAnLi4vdXRpbC9jb2xvcic7XHJcbmltcG9ydCB7IFZvaWRFdmVudEVtaXR0ZXIgfSBmcm9tICcuLi91dGlsL2V2ZW50X2VtaXR0ZXInO1xyXG5jb25zdCBRVUFEX1ZFUlRFWF9EQVRBID0gbmV3IEZsb2F0MzJBcnJheShbXHJcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZVxyXG4gICAgLy8geCAgIHkgIHUgIHZcclxuICAgIC0xLCAtMSwgMCwgMCxcclxuICAgIDEsIDEsIDEsIDEsXHJcbiAgICAtMSwgMSwgMCwgMSxcclxuICAgIC0xLCAtMSwgMCwgMCxcclxuICAgIDEsIC0xLCAxLCAwLFxyXG4gICAgMSwgMSwgMSwgMVxyXG4gICAgLy8gdHNsaW50OmVuYWJsZVxyXG5dKTtcclxuY29uc3QgUVVBRF9BVFRSSUJfTUFQUElORyA9IG5ldyBBdHRyaWJ1dGVNYXBwaW5nKFtcclxuICAgIFtcclxuICAgICAgICAwIC8qIFBPU0lUSU9OICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMixcclxuICAgICAgICAgICAgdHlwZTogNTEyNiAvKiBGTE9BVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDQgLyogVVYgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTI2IC8qIEZMT0FUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgIF1cclxuXSk7XHJcbi8qKlxyXG4gKiBEZWZhdWx0IHJlbmRlciB0YXJnZXQgb2YgYSBXZWJHTCBjb250ZXh0LCB3aGljaCBpcyBjYW52YXMgZWxlbWVudCBvZiB0aGVcclxuICogY29udGV4dC5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBEZWZhdWx0UmVuZGVyVGFyZ2V0IHtcclxuICAgIGNvbnN0cnVjdG9yKGdsKSB7XHJcbiAgICAgICAgdGhpcy5pc0NsZWFyID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fZ2wgPSBnbDtcclxuICAgIH1cclxuICAgIGJpbmQoKSB7XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcclxuICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xyXG4gICAgfVxyXG4gICAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgY29uc3QgY2FudmFzID0gdGhpcy5fZ2wuY2FudmFzO1xyXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICB9XHJcbiAgICBnZXRXaWR0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2wuZHJhd2luZ0J1ZmZlcldpZHRoO1xyXG4gICAgfVxyXG4gICAgZ2V0SGVpZ2h0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9nbC5kcmF3aW5nQnVmZmVySGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICAvLyBXZSBjYW4ndCBkZXN0cm95IGRlZmF1bHQgcmVuZGVyIHRhcmdldCwgc28gZG8gbm90aGluZy5cclxuICAgICAgICAvLyBUT0RPKGRtaWtpcykgVGhyb3cgYW4gZXhjZXB0aW9uP1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBXcmFwcGVyIGFyb3VuZCBXZWJHTCBjb250ZXh0LiBTZXJ2ZXMgdG8gbG9jYWxpemUgYWxsIEdMIGNhbGxzIHRvIG1pbmltdW0gc2V0XHJcbiAqIG9mIG9iamVjdHMuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW5kZXJDb250ZXh0IHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyB3cmFwcGVyIGZvciBhIGdpdmVuIFdlYkdMIGNvbnRleHQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGdsIFRoZSBjb250ZXh0IHRvIGJlIHdyYXBwZWQuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGdsKSB7XHJcbiAgICAgICAgdGhpcy5fZ2wgPSBnbDtcclxuICAgICAgICB0aGlzLm9uTG9zcyA9IG5ldyBWb2lkRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dExvc3RMaXN0ZW5lciA9IChlKSA9PiB7XHJcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgdGhpcy5vbkxvc3MuZmlyZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgZ2wuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dGxvc3QnLCB0aGlzLl9jb250ZXh0TG9zdExpc3RlbmVyKTtcclxuICAgICAgICB0aGlzLl9jYXBhYmlsaXRpZXMgPSBuZXcgUmVuZGVyQ29udGV4dENhcGFiaWxpdGllc01hbmFnZXIoZ2wpO1xyXG4gICAgICAgIGNvbnN0IHZhb0V4dCA9IGdsLmdldEV4dGVuc2lvbignT0VTX3ZlcnRleF9hcnJheV9vYmplY3QnKTtcclxuICAgICAgICBpZiAoIXZhb0V4dCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0IGlzIHJlcXVpcmVkLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl92YW9FeHQgPSB2YW9FeHQ7XHJcbiAgICAgICAgaWYgKCFnbC5nZXRFeHRlbnNpb24oJ09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcycpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzIGlzIHJlcXVpcmVkLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBkZWZhdWx0UmVuZGVyVGFyZ2V0ID0gdGhpcy5fYm91bmRSZW5kZXJUYXJnZXQgPVxyXG4gICAgICAgICAgICB0aGlzLl9kZWZhdWx0UmVuZGVyVGFyZ2V0ID1cclxuICAgICAgICAgICAgICAgIG5ldyBEZWZhdWx0UmVuZGVyVGFyZ2V0KGdsKTtcclxuICAgICAgICBjb25zdCBib3VuZFN0YXRlID0gdGhpcy5fYm91bmRSZW5kZXJTdGF0ZSA9IG5ldyBSZW5kZXJTdGF0ZSgpO1xyXG4gICAgICAgIHRoaXMuX3VucGFja1ByZW11bHRpcGx5QWxwaGEgPSBmYWxzZTtcclxuICAgICAgICAvLyBEZWZhdWx0IHZpZXdwb3J0IGFuZCBzY2lzc29yIHJlY3RhbmdsZSBzaXplcyBhcmUgZXF1YWwgdG8gdGhlIHNpemUgb2ZcclxuICAgICAgICAvLyB0aGUgY2FudmFzIG9mIHRoZSBXZWJHTCBjb250ZXh0LiBCdXQgd2UgaGF2ZSBubyB3YXkgb2Yga25vd2luZyB0aGVtIGluXHJcbiAgICAgICAgLy8gUmVuZGVyU3RhdGUncyBjb25zdHJ1Y3Rvci4gU28gd2UncmUgZml4aW5nIHRoZW0gaGVyZS5cclxuICAgICAgICBib3VuZFN0YXRlLnNjaXNzb3JXaWR0aCA9IGJvdW5kU3RhdGUudmlld3BvcnRXaWR0aCA9XHJcbiAgICAgICAgICAgIGRlZmF1bHRSZW5kZXJUYXJnZXQuZ2V0V2lkdGgoKTtcclxuICAgICAgICBib3VuZFN0YXRlLnNjaXNzb3JIZWlnaHQgPSBib3VuZFN0YXRlLnZpZXdwb3J0SGVpZ2h0ID1cclxuICAgICAgICAgICAgZGVmYXVsdFJlbmRlclRhcmdldC5nZXRIZWlnaHQoKTtcclxuICAgICAgICBjb25zdCBxdWFkQnVmZmVyID0gdGhpcy5fcXVhZFZlcnRleEJ1ZmZlciA9XHJcbiAgICAgICAgICAgIG5ldyBCdWZmZXIoZ2wsIGdsLkFSUkFZX0JVRkZFUiwgZ2wuU1RBVElDX0RSQVcpO1xyXG4gICAgICAgIHF1YWRCdWZmZXIuYmluZCgpO1xyXG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBRVUFEX1ZFUlRFWF9EQVRBLCBnbC5TVEFUSUNfRFJBVyk7XHJcbiAgICAgICAgdGhpcy5fcXVhZFZhbyA9IHRoaXMuY3JlYXRlVmFvKFFVQURfQVRUUklCX01BUFBJTkcsIHF1YWRCdWZmZXIsIG51bGwpO1xyXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBudWxsKTtcclxuICAgICAgICB0aGlzLl9ib3VuZFByb2dyYW0gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2JvdW5kVmFvID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9ib3VuZFRleHR1cmVzID0gbmV3IEFycmF5KHRoaXMuX2NhcGFiaWxpdGllcy5nZXRNYXhDb21iaW5lZFRleHR1cmVJbWFnZVVuaXRzKCkpO1xyXG4gICAgICAgIHRoaXMuX2JvdW5kVGV4dHVyZXMuZmlsbChudWxsKTtcclxuICAgICAgICB0aGlzLl9ib3VuZFRleHR1cmVVbml0ID0gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBvYmplY3QgdG8gcmVxdWVzdCBjYXBhYmlsaXRpZXMgb2YgdGhlIGNvbnRleHQgc3VjaCBhcyBtYXhpbXVtXHJcbiAgICAgKiB0ZXh0dXJlIHNpemUgb3IgbWF4aW11bSBudW1iZXIgb2YgdW5pZm9ybSB2ZWN0b3JzIGFsbG93ZWQgaW4gc2hhZGVycy5cclxuICAgICAqL1xyXG4gICAgZ2V0Q2FwYWJpbGl0aWVzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jYXBhYmlsaXRpZXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgZnJhbWVidWZmZXIgd2l0aCBnaXZlbiBhdHRhY2htZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZGVzY3JpcHRvciBPYmplY3QgY29udGFpbmluZyBmcmFtZWJ1ZmZlciBhdHRhY2htZW50cy5cclxuICAgICAqIEByZXR1cm5zIENyZWF0ZWQgZnJhbWVidWZmZXIgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBjcmVhdGVGcmFtZWJ1ZmZlcih7IGNvbG9yLCBkZXB0aCwgc3RlbmNpbCwgZGVwdGhTdGVuY2lsIH0pIHtcclxuICAgICAgICAvLyBUT0RPIFVuY29tbWVudCBhbmQgcHV0IHVuZGVyIGRlYnVnIGZsYWcgKHdoZW4gaW1wbGVtZW50ZWQpXHJcbiAgICAgICAgLy8gaWYgKGRlcHRoU3RlbmNpbCAmJiAoZGVwdGggfHwgc3RlbmNpbCkpIHtcclxuICAgICAgICAvLyAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgIC8vICAgICAgICAgJ0ZyYW1lYnVmZmVyIGNhblxcJ3QgaGF2ZSBERVBUSF9TVEVOQ0lMIGFuZCBERVBUSCBvciBTVEVOQ0lMICcgK1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICdhdHRhY2htZW50IHNpbXVsdGFuZW91c2x5LidcclxuICAgICAgICAvLyAgICAgKTtcclxuICAgICAgICAvLyB9XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcclxuICAgICAgICBsZXQgd2lkdGggPSAwO1xyXG4gICAgICAgIGxldCBoZWlnaHQgPSAwO1xyXG4gICAgICAgIGlmIChjb2xvcikge1xyXG4gICAgICAgICAgICB3aWR0aCA9IGNvbG9yLmdldFdpZHRoKCk7XHJcbiAgICAgICAgICAgIGhlaWdodCA9IGNvbG9yLmdldEhlaWdodCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkZXB0aCkge1xyXG4gICAgICAgICAgICB3aWR0aCA9IGRlcHRoLmdldFdpZHRoKCk7XHJcbiAgICAgICAgICAgIGhlaWdodCA9IGRlcHRoLmdldEhlaWdodCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzdGVuY2lsKSB7XHJcbiAgICAgICAgICAgIHdpZHRoID0gc3RlbmNpbC5nZXRXaWR0aCgpO1xyXG4gICAgICAgICAgICBoZWlnaHQgPSBzdGVuY2lsLmdldEhlaWdodCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkZXB0aFN0ZW5jaWwpIHtcclxuICAgICAgICAgICAgd2lkdGggPSBkZXB0aFN0ZW5jaWwuZ2V0V2lkdGgoKTtcclxuICAgICAgICAgICAgaGVpZ2h0ID0gZGVwdGhTdGVuY2lsLmdldEhlaWdodCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBmcmFtZWJ1ZmZlciA9IG5ldyBGcmFtZWJ1ZmZlcihnbCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5iaW5kUmVuZGVyVGFyZ2V0KGZyYW1lYnVmZmVyKTtcclxuICAgICAgICBpZiAoY29sb3IpIHtcclxuICAgICAgICAgICAgY29sb3IuYXR0YWNoVG9GcmFtZWJ1ZmZlcihnbC5DT0xPUl9BVFRBQ0hNRU5UMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkZXB0aCkge1xyXG4gICAgICAgICAgICBkZXB0aC5hdHRhY2hUb0ZyYW1lYnVmZmVyKGdsLkRFUFRIX0FUVEFDSE1FTlQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RlbmNpbCkge1xyXG4gICAgICAgICAgICBzdGVuY2lsLmF0dGFjaFRvRnJhbWVidWZmZXIoZ2wuU1RFTkNJTF9BVFRBQ0hNRU5UKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRlcHRoU3RlbmNpbCkge1xyXG4gICAgICAgICAgICBkZXB0aFN0ZW5jaWwuYXR0YWNoVG9GcmFtZWJ1ZmZlcihnbC5ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUT0RPIFVuY29tbWVudCBhbmQgcHV0IHVuZGVyIGRlYnVnIGZsYWcgKHdoZW4gaW1wbGVtZW50ZWQpXHJcbiAgICAgICAgLy8gc3dpdGNoIChnbC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKGdsLkZSQU1FQlVGRkVSKSkge1xyXG4gICAgICAgIC8vICAgICBjYXNlIGdsLkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfQVRUQUNITUVOVDpcclxuICAgICAgICAvLyAgICAgICAgIHRocm93IG5ldyBFcnJvcignRnJhbWVidWZmZXIgYXR0YWNobWVudHMgYXJlIG5vdCByZW5kZXJhYmxlJyk7XHJcbiAgICAgICAgLy8gICAgIGNhc2UgZ2wuRlJBTUVCVUZGRVJfSU5DT01QTEVURV9ESU1FTlNJT05TOlxyXG4gICAgICAgIC8vICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGcmFtZWJ1ZmZlciBhdHRhY2htZW50cyBhcmUgbm90IHNhbWUgc2l6ZScpO1xyXG4gICAgICAgIC8vICAgICBjYXNlIGdsLkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfTUlTU0lOR19BVFRBQ0hNRU5UOlxyXG4gICAgICAgIC8vICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGcmFtZWJ1ZmZlciBoYXMgbm8gYXR0YWNobWVudHMnKTtcclxuICAgICAgICAvLyAgICAgY2FzZSBnbC5GUkFNRUJVRkZFUl9VTlNVUFBPUlRFRDpcclxuICAgICAgICAvLyAgICAgICAgIHRocm93IG5ldyBFcnJvcignRnJhbWVidWZmZXIgaGFzIHVuc3VwcG9ydGVkIGF0dGFjaG1lbnQnKTtcclxuICAgICAgICAvLyB9XHJcbiAgICAgICAgcmV0dXJuIGZyYW1lYnVmZmVyO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBbGxvY2F0ZXMgYSBuZXcgcmVuZGVyYnVmZmVyIHdpdGggZ2l2ZW4gc2l6ZSBhbmQgZm9ybWF0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB3aWR0aCBXaWR0aCBvZiB0aGUgcmVuZGVyYnVmZmVyLlxyXG4gICAgICogQHBhcmFtIGhlaWdodCBIZWlnaHQgb2YgdGhlIHJlbmRlcmJ1ZmZlci5cclxuICAgICAqIEBwYXJhbSBmb3JtYXQgRm9ybWF0IG9mIHRoZSByZW5kZXJidWZmZXIuXHJcbiAgICAgKiBAcmV0dXJuIFRoZSBhbGxvY2F0ZWQgcmVuZGVyYnVmZmVyLlxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgY3JlYXRlUmVuZGVyYnVmZmVyKHdpZHRoLCBoZWlnaHQsIGZvcm1hdCkge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XHJcbiAgICAgICAgY29uc3QgcmVuZGVyYnVmZmVyID0gbmV3IFJlbmRlcmJ1ZmZlcihnbCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgcmVuZGVyYnVmZmVyLmJpbmQoKTtcclxuICAgICAgICBnbC5yZW5kZXJidWZmZXJTdG9yYWdlKGdsLlJFTkRFUkJVRkZFUiwgZm9ybWF0LCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICByZXR1cm4gcmVuZGVyYnVmZmVyO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBbGxvY2F0ZXMgYSBuZXcgdGV4dHVyZSB3aXRoIGdpdmVuIHNpemUsIGZvcm1hdCwgdHlwZSBhbmQgcGFyYW1ldGVycyBhbmRcclxuICAgICAqIGZpbGxzIGl0IHdpdGggemVyb2VzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB3aWR0aCBXaWR0aCBvZiB0aGUgdGV4dHVyZS5cclxuICAgICAqIEBwYXJhbSBoZWlnaHQgSGVpZ2h0IG9mIHRoZSB0ZXh0dXJlLlxyXG4gICAgICogQHBhcmFtIGZvcm1hdCBQaXhlbCBmb3JtYXQgb2YgdGhlIHRleHR1cmUuXHJcbiAgICAgKiBAcGFyYW0gdHlwZSBQaXhlbCB0eXBlIG9mIHRoZSB0ZXh0dXJlLlxyXG4gICAgICogQHBhcmFtIHBhcmFtcyBQYXJhbWV0ZXJzIG9mIHRoZSB0ZXh0dXJlLlxyXG4gICAgICogQHJldHVybnMgTmV3bHkgYWxsb2NhdGVkIHRleHR1cmUuXHJcbiAgICAgKi9cclxuICAgIGNyZWF0ZUVtcHR5MkRUZXh0dXJlKHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgdHlwZSwgcGFyYW1zID0gREVGQVVMVF9URVhUVVJFX1BBUkFNUykge1xyXG4gICAgICAgIGNvbnN0IHRleHR1cmUgPSBuZXcgVGV4dHVyZSh0aGlzLl9nbCwgd2lkdGgsIGhlaWdodCwgZm9ybWF0LCB0eXBlLCBwYXJhbXMpO1xyXG4gICAgICAgIHJldHVybiB0ZXh0dXJlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHNoYWRlciBwcm9ncmFtLiBVc2VzIGNhY2hlLCBpLmUuIGlmIGEgcHJvZ3JhbSB3aXRoIHNhbWVcclxuICAgICAqIHNvdXJjZSBzdHJpbmcgYW5kIG9wdGlvbnMgaXMgYWxyZWFkeSBjcmVhdGVkLCByZXR1cm5zIGl0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB2ZXJ0ZXhTaGFkZXJTb3VyY2UgU291cmNlIGNvZGUgb2YgdmVydGV4IHNoYWRlciBvZiB0aGUgcHJvZ3JhbS5cclxuICAgICAqIEBwYXJhbSBmcmFnbWVudFNoYWRlclNvdXJjZSBTb3VyY2UgY29kZSBvZiBmcmFnbWVudCBzaGFkZXIgb2YgdGhlIHByb2dyYW0uXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zLlxyXG4gICAgICogQHJldHVybnMgTmV3bHkgY3JlYXRlZCBwcm9ncmFtIG9yIG9uZSBmcm9tIHRoZSBjYWNoZS5cclxuICAgICAqL1xyXG4gICAgY3JlYXRlUHJvZ3JhbSh2ZXJ0ZXhTaGFkZXJTb3VyY2UsIGZyYWdtZW50U2hhZGVyU291cmNlLCBvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9ncmFtKHRoaXMuX2dsLCB2ZXJ0ZXhTaGFkZXJTb3VyY2UsIGZyYWdtZW50U2hhZGVyU291cmNlLCBvcHRpb25zKTtcclxuICAgIH1cclxuICAgIGNyZWF0ZVZlcnRleEJ1ZmZlcihzaXplLCB1c2FnZSA9IDM1MDQ0IC8qIFNUQVRJQ19EUkFXICovKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUJ1ZmZlcih0aGlzLl9nbC5BUlJBWV9CVUZGRVIsIHNpemUsIHVzYWdlKTtcclxuICAgIH1cclxuICAgIGNyZWF0ZUluZGV4QnVmZmVyKHNpemUsIHVzYWdlID0gMzUwNDQgLyogU1RBVElDX0RSQVcgKi8pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY3JlYXRlQnVmZmVyKHRoaXMuX2dsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBzaXplLCB1c2FnZSk7XHJcbiAgICB9XHJcbiAgICAvLyBUT0RPOiBjaGVjayBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzI0MTk1IHRvIHVwZGF0ZSBuYXJyb3dlZCBkYXRhIHR5cGUgYWNjb3JkaW5nXHJcbiAgICB1cGxvYWREYXRhVG9CdWZmZXIoYnVmZmVyLCBkYXRhLCBvZmZzZXQgPSAwKSB7XHJcbiAgICAgICAgYnVmZmVyLmJpbmQoKTtcclxuICAgICAgICB0aGlzLl9nbC5idWZmZXJTdWJEYXRhKGJ1ZmZlci5nZXRUYXJnZXQoKSwgb2Zmc2V0LCBkYXRhKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyB2ZXJ0ZXggYXJyYXkgb2JqZWN0IGluIHRoZSBjb250ZXh0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhdHRyaWJ1dGVNYXBwaW5nIE1hcHBpbmcgb2YgdmVydGV4IGF0dHJiaXV0ZXMgZm9yIHRoZSBWQU8uXHJcbiAgICAgKiBAcGFyYW0gdmVydGV4QnVmZmVyIFZlcnRleCBidWZmZXIgdG8gYmUgYm91bmQgdG8gdGhlIFZBTy5cclxuICAgICAqIEBwYXJhbSBpbmRleEJ1ZmZlciBJbmRleCBidWZmZXIgdG8gYmUgYm91bmQgdG8gdGhlIFZBTy5cclxuICAgICAqIEByZXR1cm5zIFRoZSBuZXcgVkFPLlxyXG4gICAgICovXHJcbiAgICBjcmVhdGVWYW8oYXR0cmlidXRlTWFwcGluZywgdmVydGV4QnVmZmVyLCBpbmRleEJ1ZmZlcikge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XHJcbiAgICAgICAgY29uc3QgdmFvID0gbmV3IFZlcnRleEFycmF5T2JqZWN0KGdsLCB0aGlzLl92YW9FeHQsIGF0dHJpYnV0ZU1hcHBpbmcpO1xyXG4gICAgICAgIHZhby5iaW5kKCk7XHJcbiAgICAgICAgaWYgKGluZGV4QnVmZmVyKSB7XHJcbiAgICAgICAgICAgIGluZGV4QnVmZmVyLmJpbmQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2ZXJ0ZXhCdWZmZXIuYmluZCgpO1xyXG4gICAgICAgIGNvbnN0IHZlcnRleEJ5dGVTaXplID0gYXR0cmlidXRlTWFwcGluZy52ZXJ0ZXhCeXRlU2l6ZTtcclxuICAgICAgICBmb3IgKGNvbnN0IFtpZHgsIHBvaW50ZXJdIG9mIGF0dHJpYnV0ZU1hcHBpbmcpIHtcclxuICAgICAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoaWR4KTtcclxuICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihpZHgsIHBvaW50ZXIuc2l6ZSwgcG9pbnRlci50eXBlLCBwb2ludGVyLm5vcm1hbGl6ZWQsIHZlcnRleEJ5dGVTaXplLCBwb2ludGVyLm9mZnNldCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3Zhb0V4dC5iaW5kVmVydGV4QXJyYXlPRVMobnVsbCk7XHJcbiAgICAgICAgcmV0dXJuIHZhbztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBuZXcgY29udGVudCBvZiB0ZXh0dXJlLCBwcm92aWRlZCBkYXRhIG11c3QgYmUgb2YgbGVuZ3RoIGVxdWFsIHRvIFwid2lkdGggKiBoZWlnaHRcIiBhbmQgaXRzIHR5cGVcclxuICAgICAqIG11c3QgY29ycmVzcG9uZCB0byB0ZXh0dXJlJ3MgdHlwZSB7QHNlZSBQaXhlbFR5cGV9LlxyXG4gICAgICovXHJcbiAgICBzZXRUZXh0dXJlRGF0YSh0ZXh0dXJlLCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcclxuICAgICAgICBjb25zdCB3aWR0aCA9IHRleHR1cmUuZ2V0V2lkdGgoKTtcclxuICAgICAgICBjb25zdCBoZWlnaHQgPSB0ZXh0dXJlLmdldEhlaWdodCgpO1xyXG4gICAgICAgIGNvbnN0IGZvcm1hdCA9IHRleHR1cmUuZ2V0Rm9ybWF0KCk7XHJcbiAgICAgICAgY29uc3QgdHlwZSA9IHRleHR1cmUuZ2V0VHlwZSgpO1xyXG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHRleHR1cmUuZ2V0UGFyYW1zKCk7XHJcbiAgICAgICAgdGhpcy5fc2V0VGV4dHVyZURhdGFVbnBhY2tQYXJhbXMocGFyYW1zKTtcclxuICAgICAgICB0aGlzLmJpbmRUZXh0dXJlKHRleHR1cmUpO1xyXG4gICAgICAgIGdsLnRleFN1YkltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgMCwgMCwgd2lkdGgsIGhlaWdodCwgZm9ybWF0LCB0eXBlLCBkYXRhKTtcclxuICAgICAgICB0aGlzLl9vblRleHR1cmVEYXRhVXBkYXRlZCh0ZXh0dXJlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBuZXcgdGV4dHVyZSBjb250ZW50IGZyb20gY2FudmFzIGVsZW1lbnQuXHJcbiAgICAgKi9cclxuICAgIHNldFRleHR1cmVEYXRhRnJvbURvbUVsZW1lbnQodGV4dHVyZSwgZWxlbWVudCkge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XHJcbiAgICAgICAgY29uc3QgZm9ybWF0ID0gdGV4dHVyZS5nZXRGb3JtYXQoKTtcclxuICAgICAgICBjb25zdCB0eXBlID0gdGV4dHVyZS5nZXRUeXBlKCk7XHJcbiAgICAgICAgY29uc3QgcGFyYW1zID0gdGV4dHVyZS5nZXRQYXJhbXMoKTtcclxuICAgICAgICB0aGlzLl9zZXRUZXh0dXJlRGF0YVVucGFja1BhcmFtcyhwYXJhbXMpO1xyXG4gICAgICAgIHRoaXMuYmluZFRleHR1cmUodGV4dHVyZSk7XHJcbiAgICAgICAgZ2wudGV4U3ViSW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCAwLCAwLCBmb3JtYXQsIHR5cGUsIGVsZW1lbnQpO1xyXG4gICAgICAgIHRoaXMuX29uVGV4dHVyZURhdGFVcGRhdGVkKHRleHR1cmUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGRlZmF1bHQgcmVuZGVyIHRhcmdldCBhc3NvY2lhdGVkIHdpdGggY2FudmFzIG9uIHdoaWNoIHRoZSBXZWJHTFxyXG4gICAgICogY29udGV4dCBvcGVyYXRlcy5cclxuICAgICAqL1xyXG4gICAgZ2V0RGVmYXVsdFJlbmRlclRhcmdldCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmYXVsdFJlbmRlclRhcmdldDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXJzIGN1cnJlbnRseSBib3VuZCByZW5kZXIgdGFyZ2V0IGFjY29yZGluZyB0byBhIG1hc2suXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG1hc2sgQml0d2lzZSBPUiBvZiBtYXJrcywgaS5lLlxyXG4gICAgICogICAgICBgQ2xlYXJNYXNrLkNPTE9SX0JVRkZFUl9CSVQgfCBDbGVhck1hc2suREVQVEhfQlVGRkVSX0JJVGAuXHJcbiAgICAgKi9cclxuICAgIGNsZWFyQ3VycmVudFRhcmdldChtYXNrKSB7XHJcbiAgICAgICAgaWYgKG1hc2spIHtcclxuICAgICAgICAgICAgdGhpcy5fZ2wuY2xlYXIobWFzayk7XHJcbiAgICAgICAgICAgIHRoaXMuX2JvdW5kUmVuZGVyVGFyZ2V0LmlzQ2xlYXIgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQmluZHMgYSByZW5kZXIgdGFyZ2V0IHRvIHRoZSBXZWJHTCBjb250ZXh0IGlmIGl0J3Mgbm90IGFscmVhZHkgYm91bmQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRhcmdldCBUaGUgcmVuZGVyIHRhcmdldCB0byBiZSBib3VuZC5cclxuICAgICAqL1xyXG4gICAgYmluZFJlbmRlclRhcmdldCh0YXJnZXQpIHtcclxuICAgICAgICBpZiAodGhpcy5fYm91bmRSZW5kZXJUYXJnZXQgIT09IHRhcmdldCkge1xyXG4gICAgICAgICAgICB0YXJnZXQuYmluZCgpO1xyXG4gICAgICAgICAgICB0aGlzLl9ib3VuZFJlbmRlclRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVGFyZ2V0IHNpemUgY291bGQgY2hhbmdlIGV2ZW4gaWYgdGFyZ2V0IGlzIGFscmVhZHkgYm91bmQuXHJcbiAgICAgICAgLy8gVkVDVE9SLTE5MFxyXG4gICAgICAgIHRoaXMuX3NldFZpZXdwb3J0U3RhdGUobmV3IFJlbmRlclN0YXRlKHtcclxuICAgICAgICAgICAgdmlld3BvcnRXaWR0aDogdGFyZ2V0LmdldFdpZHRoKCksXHJcbiAgICAgICAgICAgIHZpZXdwb3J0SGVpZ2h0OiB0YXJnZXQuZ2V0SGVpZ2h0KClcclxuICAgICAgICB9KSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEJpbmRzIGEgcmVuZGVyIHN0YXRlIHRvIHRoZSBXZWJHTCBjb250ZXh0IHdpdGggbWluaW11bSBhbW91bnQgb2YgYWN0dWFsXHJcbiAgICAgKiBzdGF0ZSBzd2l0Y2hpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHN0YXRlIFRoZSBzdGF0ZSB0byBiZSBib3VuZC5cclxuICAgICAqL1xyXG4gICAgYmluZFJlbmRlclN0YXRlKHN0YXRlKSB7XHJcbiAgICAgICAgdGhpcy5fc2V0Q29sb3JCdWZmZXJTdGF0ZShzdGF0ZSk7XHJcbiAgICAgICAgdGhpcy5fc2V0QmxlbmRTdGF0ZShzdGF0ZSk7XHJcbiAgICAgICAgdGhpcy5fc2V0Q3VsbEZhY2VTdGF0ZShzdGF0ZSk7XHJcbiAgICAgICAgdGhpcy5fc2V0RnJvbnRGYWNlU3RhdGUoc3RhdGUpO1xyXG4gICAgICAgIHRoaXMuX3NldERlcHRoVGVzdFN0YXRlKHN0YXRlKTtcclxuICAgICAgICB0aGlzLl9zZXREaXRoZXJTdGF0ZShzdGF0ZSk7XHJcbiAgICAgICAgdGhpcy5fc2V0RHJhd0J1ZmZlcnNTdGF0ZShzdGF0ZSk7XHJcbiAgICAgICAgdGhpcy5fc2V0UG9seWdvbk9mZnNldFN0YXRlKHN0YXRlKTtcclxuICAgICAgICB0aGlzLl9zZXRBbHBoYVRvQ292ZXJhZ2VTdGF0ZShzdGF0ZSk7XHJcbiAgICAgICAgdGhpcy5fc2V0U2FtcGxlQ292ZXJhZ2VTdGF0ZShzdGF0ZSk7XHJcbiAgICAgICAgdGhpcy5fc2V0U3RlbmNpbFRlc3RTdGF0ZShzdGF0ZSk7XHJcbiAgICAgICAgdGhpcy5fc2V0U2Npc3NvclRlc3RTdGF0ZShzdGF0ZSk7XHJcbiAgICAgICAgdGhpcy5fc2V0Vmlld3BvcnRTdGF0ZShzdGF0ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEJpbmRzIGEgcHJvZ3JhbSB0byB0aGUgV2ViR0wgY29udGV4dCBpZiBpdCdzIG5vdCBhbHJlYWR5IGJvdW5kLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwcm9ncmFtIFRoZSBwcm9ncmFtIHRvIGJlIGJvdW5kLlxyXG4gICAgICovXHJcbiAgICBiaW5kUHJvZ3JhbShwcm9ncmFtKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2JvdW5kUHJvZ3JhbSAhPT0gcHJvZ3JhbSkge1xyXG4gICAgICAgICAgICBwcm9ncmFtLmJpbmQoKTtcclxuICAgICAgICAgICAgdGhpcy5fYm91bmRQcm9ncmFtID0gcHJvZ3JhbTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEJpbmRzIGEgdmVydGV4IGFycmF5IG9iamVjdCB0byB0aGUgY29udGV4dCBpZiBpdCdzIG5vdCBhbHJlYWR5IGJvdW5kLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB2YW8gVGhlIHZlcnRleCBhcnJheSBvYmplY3QgdG8gYmluZC4gUGFzc2luZyBgbnVsbGAgd2lsbCB1bmJpbmRcclxuICAgICAqICAgICAgYW55IGN1cnJlbnRseSBib3VuZCBWQU8uXHJcbiAgICAgKi9cclxuICAgIGJpbmRWYW8odmFvKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2JvdW5kVmFvICE9PSB2YW8pIHtcclxuICAgICAgICAgICAgaWYgKHZhbykge1xyXG4gICAgICAgICAgICAgICAgdmFvLmJpbmQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Zhb0V4dC5iaW5kVmVydGV4QXJyYXlPRVMobnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fYm91bmRWYW8gPSB2YW87XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYmluZFF1YWRWYW8oKSB7XHJcbiAgICAgICAgdGhpcy5iaW5kVmFvKHRoaXMuX3F1YWRWYW8pO1xyXG4gICAgfVxyXG4gICAgYmluZFRleHR1cmVVbml0KHVuaXQpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xyXG4gICAgICAgIGlmICh0aGlzLl9ib3VuZFRleHR1cmVVbml0ICE9PSB1bml0KSB7XHJcbiAgICAgICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB1bml0KTtcclxuICAgICAgICAgICAgdGhpcy5fYm91bmRUZXh0dXJlVW5pdCA9IHVuaXQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYmluZFRleHR1cmUodGV4dHVyZSkge1xyXG4gICAgICAgIGNvbnN0IGJvdW5kVW5pdCA9IHRoaXMuX2JvdW5kVGV4dHVyZVVuaXQ7XHJcbiAgICAgICAgaWYgKHRoaXMuX2JvdW5kVGV4dHVyZXNbYm91bmRVbml0XSAhPT0gdGV4dHVyZSkge1xyXG4gICAgICAgICAgICB0ZXh0dXJlLmJpbmQoKTtcclxuICAgICAgICAgICAgdGhpcy5fYm91bmRUZXh0dXJlc1tib3VuZFVuaXRdID0gdGV4dHVyZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERyYXdzIGEgcXVhZCB0byBjdXJyZW50bHkgYm91bmQgcmVuZGVyIHRhcmdldCB3aXRoIGN1cnJlbnRseSBib3VuZCByZW5kZXJcclxuICAgICAqIHN0YXRlLCBwcm9ncmFtIGFuZCB1bmlmb3JtIHN0YXRlLlxyXG4gICAgICovXHJcbiAgICBkcmF3UXVhZCgpIHtcclxuICAgICAgICB0aGlzLmRyYXdNZXNoKDAsIDYsIDQgLyogVFJJQU5HTEVTICovKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRHJhd3MgYSBtZXNoIGZyb20gY3VycmVudGx5IGJvdW5kIHRvIEFSUkFZX0JVRkZFUiBidWZmZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9mZnNldCBJbmRleCBvZiB0aGUgdmVydGV4IHRvIHN0YXJ0IGRyYXdpbmcgZnJvbS5cclxuICAgICAqIEBwYXJhbSBjb3VudCBOdW1iZXIgb2YgdmVydGljZXMgdG8gcHJvY2Vzcy5cclxuICAgICAqIEBwYXJhbSBwcmltaXRpdmVUeXBlXHJcbiAgICAgKi9cclxuICAgIGRyYXdNZXNoKG9mZnNldCwgY291bnQsIHByaW1pdGl2ZVR5cGUgPSA0IC8qIFRSSUFOR0xFUyAqLykge1xyXG4gICAgICAgIHRoaXMuX2dsLmRyYXdBcnJheXMocHJpbWl0aXZlVHlwZSwgb2Zmc2V0LCBjb3VudCk7XHJcbiAgICAgICAgdGhpcy5fYm91bmRSZW5kZXJUYXJnZXQuaXNDbGVhciA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3cyBhIG1lc2ggdG8gY3VycmVudGx5IGJvdW5kIHJlbmRlciB0YXJnZXQgd2l0aCBjdXJyZW50bHkgYm91bmQgcmVuZGVyXHJcbiAgICAgKiBzdGF0ZSwgcHJvZ3JhbSBhbmQgdW5pZm9ybSBzdGF0ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IE9mZnNldCBvZiBpbmRpY2VzIG9mIHRoZSBtZXNoIGluIGN1cnJlbnRseSBib3VuZCBtZW1vcnkgcGFnZS5cclxuICAgICAqIEBwYXJhbSBpbmRleENvdW50IE51bWJlciBvZiBpbmRpY2VzIGluIHRoZSBtZXNoLlxyXG4gICAgICovXHJcbiAgICBkcmF3SW5kZXhlZE1lc2gob2Zmc2V0LCBpbmRleENvdW50LCBwcmltaXRpdmVUeXBlID0gNCAvKiBUUklBTkdMRVMgKi8pIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xyXG4gICAgICAgIGdsLmRyYXdFbGVtZW50cyhwcmltaXRpdmVUeXBlLCBpbmRleENvdW50LCBnbC5VTlNJR05FRF9TSE9SVCwgb2Zmc2V0KTtcclxuICAgICAgICB0aGlzLl9ib3VuZFJlbmRlclRhcmdldC5pc0NsZWFyID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERlc3Ryb3lzIHRoZSBjb250ZXh0IGFuZCByZXNvdXJjZXMgb3duZWQgYnkgaXQuIE5vdGUgdGhhdCByZXNvdXJjZXMgdGhhdFxyXG4gICAgICogd2VyZSBjcmVhdGVkIHdpdGggYGNyZWF0ZSpgIG1ldGhvZCBvZiB0aGUgY29udGV4dCBhcmVuJ3QgZXhhY3RseSBiZWxvbmdcclxuICAgICAqIHRvIHRoZSBjb250ZXh0LCBlbnRpdGllcyB0aGF0IGNyZWF0ZWQgdGhlbSBoYXZlIHRvIGRlc3Ryb3kgdGhlbS5cclxuICAgICAqL1xyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLl9xdWFkVmFvLmRlc3Ryb3koKTtcclxuICAgICAgICB0aGlzLl9xdWFkVmVydGV4QnVmZmVyLmRlc3Ryb3koKTtcclxuICAgICAgICB0aGlzLl9nbC5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0bG9zdCcsIHRoaXMuX2NvbnRleHRMb3N0TGlzdGVuZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNvbnRleHQgZnJvbSBhIGNhbnZhcy5cclxuICAgICAqXHJcbiAgICAgKiBAdGhyb3dzIEFuIGVycm9yIGlmIGZhaWxzIHRvIGNyZWF0ZSBgd2ViZ2xgIGNvbnRleHQgZm9yIHRoZSBjYW52YXMuXHJcbiAgICAgKiBAcGFyYW0gY2FudmFzIFRoZSBjYW52YXMuXHJcbiAgICAgKiBAcGFyYW0gYXR0cmlicyBBdHRyaWJ1dGVzIG9mIHRoZSBjb250ZXh0LlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlYXRlRnJvbUNhbnZhcyhjYW52YXMsIGF0dHJpYnMpIHtcclxuICAgICAgICBjb25zdCBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcsIGF0dHJpYnMpO1xyXG4gICAgICAgIGlmICghZ2wpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gY3JlYXRlIEdMIGNvbnRleHQgZnJvbSBjYW52YXMuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgUmVuZGVyQ29udGV4dChnbCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgYSBXZWJHTCBjYXBhYmlsaXR5LlxyXG4gICAgICogQHNlZSBodHRwczovL3d3dy5raHJvbm9zLm9yZy9yZWdpc3RyeS9PcGVuR0wtUmVmcGFnZXMvZXMyLjAveGh0bWwvZ2xFbmFibGUueG1sXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNhcGFiaWxpdHkgVGhlIGNhcGFiaWxpdHkgdG8gYmUgZW5hYmxlZCBvZiBkaXNhYmxlZC5cclxuICAgICAqIEBwYXJhbSBlbmFibGVkIE5ldyBzdGF0ZSBvZiB0aGUgY2FwYWJpbGl0eTtcclxuICAgICAqL1xyXG4gICAgX3NldENhcGFiaWxpdHlFbmFibGVkKGNhcGFiaWxpdHksIGVuYWJsZWQpIHtcclxuICAgICAgICBpZiAoZW5hYmxlZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9nbC5lbmFibGUoY2FwYWJpbGl0eSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9nbC5kaXNhYmxlKGNhcGFiaWxpdHkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBuZXcgY2xlYXIgY29sb3IgYW5kIGNvbG9yIG1hc2sgZnJvbSBhIHN0YXRlIGlmIHRoZXkncmUgZGlmZmVyZW50IGZyb21cclxuICAgICAqIGN1cnJlbnRseSBzZXQgb25lcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3RhdGUgVGhlIHN0YXRlIHRoYXQgY29udGFpbnMgbmV3IGNsZWFyIGNvbG9yIGFuZCBjb2xvciBtYXNrcy5cclxuICAgICAqL1xyXG4gICAgX3NldENvbG9yQnVmZmVyU3RhdGUoc3RhdGUpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xyXG4gICAgICAgIGNvbnN0IGJvdW5kU3RhdGUgPSB0aGlzLl9ib3VuZFJlbmRlclN0YXRlO1xyXG4gICAgICAgIGNvbnN0IG5ld0NsZWFyQ29sb3IgPSBzdGF0ZS5jbGVhckNvbG9yO1xyXG4gICAgICAgIGlmICghY29sb3IuYXJlRXF1YWwoYm91bmRTdGF0ZS5jbGVhckNvbG9yLCBuZXdDbGVhckNvbG9yKSkge1xyXG4gICAgICAgICAgICBnbC5jbGVhckNvbG9yKG5ld0NsZWFyQ29sb3IuciwgbmV3Q2xlYXJDb2xvci5nLCBuZXdDbGVhckNvbG9yLmIsIG5ld0NsZWFyQ29sb3IuYSk7XHJcbiAgICAgICAgICAgIGNvbG9yLmNvcHkobmV3Q2xlYXJDb2xvciwgYm91bmRTdGF0ZS5jbGVhckNvbG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGJvdW5kU3RhdGUuY29sb3JNYXNrUiAhPT0gc3RhdGUuY29sb3JNYXNrUiB8fFxyXG4gICAgICAgICAgICBib3VuZFN0YXRlLmNvbG9yTWFza0cgIT09IHN0YXRlLmNvbG9yTWFza0cgfHxcclxuICAgICAgICAgICAgYm91bmRTdGF0ZS5jb2xvck1hc2tCICE9PSBzdGF0ZS5jb2xvck1hc2tCIHx8XHJcbiAgICAgICAgICAgIGJvdW5kU3RhdGUuY29sb3JNYXNrQWxwaGEgIT09IHN0YXRlLmNvbG9yTWFza0FscGhhKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsLmNvbG9yTWFzayhzdGF0ZS5jb2xvck1hc2tSLCBzdGF0ZS5jb2xvck1hc2tHLCBzdGF0ZS5jb2xvck1hc2tCLCBzdGF0ZS5jb2xvck1hc2tBbHBoYSk7XHJcbiAgICAgICAgICAgIGJvdW5kU3RhdGUuY29sb3JNYXNrUiA9IHN0YXRlLmNvbG9yTWFza1I7XHJcbiAgICAgICAgICAgIGJvdW5kU3RhdGUuY29sb3JNYXNrRyA9IHN0YXRlLmNvbG9yTWFza0c7XHJcbiAgICAgICAgICAgIGJvdW5kU3RhdGUuY29sb3JNYXNrQiA9IHN0YXRlLmNvbG9yTWFza0I7XHJcbiAgICAgICAgICAgIGJvdW5kU3RhdGUuY29sb3JNYXNrQWxwaGEgPSBzdGF0ZS5jb2xvck1hc2tBbHBoYTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgYmxlbmQgc3RhdGUgYW5kIHBhcmFtcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3RhdGUgVGhlIHN0YXRlIHRoYXQgY29udGFpbnMgbmV3IGJsZW5kIHBhcmFtcy5cclxuICAgICAqL1xyXG4gICAgX3NldEJsZW5kU3RhdGUoc3RhdGUpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xyXG4gICAgICAgIGNvbnN0IGJvdW5kU3RhdGUgPSB0aGlzLl9ib3VuZFJlbmRlclN0YXRlO1xyXG4gICAgICAgIGlmIChib3VuZFN0YXRlLmJsZW5kICE9PSBzdGF0ZS5ibGVuZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zZXRDYXBhYmlsaXR5RW5hYmxlZChnbC5CTEVORCwgc3RhdGUuYmxlbmQpO1xyXG4gICAgICAgICAgICBib3VuZFN0YXRlLmJsZW5kID0gc3RhdGUuYmxlbmQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdGF0ZS5ibGVuZCkge1xyXG4gICAgICAgICAgICBpZiAoYm91bmRTdGF0ZS5ibGVuZEVxdWF0aW9uUmdiICE9PSBzdGF0ZS5ibGVuZEVxdWF0aW9uUmdiIHx8XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLmJsZW5kRXF1YXRpb25BbHBoYSAhPT0gc3RhdGUuYmxlbmRFcXVhdGlvbkFscGhhKSB7XHJcbiAgICAgICAgICAgICAgICBnbC5ibGVuZEVxdWF0aW9uU2VwYXJhdGUoc3RhdGUuYmxlbmRFcXVhdGlvblJnYiwgc3RhdGUuYmxlbmRFcXVhdGlvbkFscGhhKTtcclxuICAgICAgICAgICAgICAgIGJvdW5kU3RhdGUuYmxlbmRFcXVhdGlvblJnYiA9IHN0YXRlLmJsZW5kRXF1YXRpb25SZ2I7XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLmJsZW5kRXF1YXRpb25BbHBoYSA9IHN0YXRlLmJsZW5kRXF1YXRpb25BbHBoYTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYm91bmRTdGF0ZS5ibGVuZEZ1bmNEc3RSZ2IgIT09IHN0YXRlLmJsZW5kRnVuY0RzdFJnYiB8fFxyXG4gICAgICAgICAgICAgICAgYm91bmRTdGF0ZS5ibGVuZEZ1bmNTcmNSZ2IgIT09IHN0YXRlLmJsZW5kRnVuY1NyY1JnYiB8fFxyXG4gICAgICAgICAgICAgICAgYm91bmRTdGF0ZS5ibGVuZEZ1bmNEc3RBbHBoYSAhPT0gc3RhdGUuYmxlbmRGdW5jRHN0QWxwaGEgfHxcclxuICAgICAgICAgICAgICAgIGJvdW5kU3RhdGUuYmxlbmRGdW5jU3JjQWxwaGEgIT09IHN0YXRlLmJsZW5kRnVuY1NyY0FscGhhKSB7XHJcbiAgICAgICAgICAgICAgICBnbC5ibGVuZEZ1bmNTZXBhcmF0ZShzdGF0ZS5ibGVuZEZ1bmNTcmNSZ2IsIHN0YXRlLmJsZW5kRnVuY0RzdFJnYiwgc3RhdGUuYmxlbmRGdW5jU3JjQWxwaGEsIHN0YXRlLmJsZW5kRnVuY0RzdEFscGhhKTtcclxuICAgICAgICAgICAgICAgIGJvdW5kU3RhdGUuYmxlbmRGdW5jU3JjUmdiID0gc3RhdGUuYmxlbmRGdW5jU3JjUmdiO1xyXG4gICAgICAgICAgICAgICAgYm91bmRTdGF0ZS5ibGVuZEZ1bmNEc3RSZ2IgPSBzdGF0ZS5ibGVuZEZ1bmNEc3RSZ2I7XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLmJsZW5kRnVuY1NyY0FscGhhID0gc3RhdGUuYmxlbmRGdW5jU3JjQWxwaGE7XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLmJsZW5kRnVuY0RzdEFscGhhID0gc3RhdGUuYmxlbmRGdW5jRHN0QWxwaGE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgY3VsbCBmYWNlIHN0YXRlIGFuZCBwYXJhbXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHN0YXRlIFRoZSBzdGF0ZSB0aGF0IGNvbnRhaW5zIG5ldyBjdWxsIGZhY2Ugc3RhdGUgYW5kIG1vZGUuXHJcbiAgICAgKi9cclxuICAgIF9zZXRDdWxsRmFjZVN0YXRlKHN0YXRlKSB7XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcclxuICAgICAgICBjb25zdCBib3VuZFN0YXRlID0gdGhpcy5fYm91bmRSZW5kZXJTdGF0ZTtcclxuICAgICAgICBpZiAoYm91bmRTdGF0ZS5jdWxsRmFjZSAhPT0gc3RhdGUuY3VsbEZhY2UpIHtcclxuICAgICAgICAgICAgdGhpcy5fc2V0Q2FwYWJpbGl0eUVuYWJsZWQoZ2wuQ1VMTF9GQUNFLCBzdGF0ZS5jdWxsRmFjZSk7XHJcbiAgICAgICAgICAgIGJvdW5kU3RhdGUuY3VsbEZhY2UgPSBzdGF0ZS5jdWxsRmFjZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0YXRlLmN1bGxGYWNlICYmXHJcbiAgICAgICAgICAgIGJvdW5kU3RhdGUuY3VsbEZhY2VNb2RlICE9PSBzdGF0ZS5jdWxsRmFjZU1vZGUpIHtcclxuICAgICAgICAgICAgZ2wuY3VsbEZhY2Uoc3RhdGUuY3VsbEZhY2VNb2RlKTtcclxuICAgICAgICAgICAgYm91bmRTdGF0ZS5jdWxsRmFjZU1vZGUgPSBzdGF0ZS5jdWxsRmFjZU1vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIGZyb250IGZhY2UgbW9kZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3RhdGUgVGhlIHN0YXRlIHRoYXQgY29udGFpbnMgbmV3IGZyb250IGZhY2UgbW9kZS5cclxuICAgICAqL1xyXG4gICAgX3NldEZyb250RmFjZVN0YXRlKHN0YXRlKSB7XHJcbiAgICAgICAgY29uc3QgYm91bmRTdGF0ZSA9IHRoaXMuX2JvdW5kUmVuZGVyU3RhdGU7XHJcbiAgICAgICAgaWYgKGJvdW5kU3RhdGUuZnJvbnRGYWNlTW9kZSAhPT0gc3RhdGUuZnJvbnRGYWNlTW9kZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9nbC5mcm9udEZhY2Uoc3RhdGUuZnJvbnRGYWNlTW9kZSk7XHJcbiAgICAgICAgICAgIGJvdW5kU3RhdGUuZnJvbnRGYWNlTW9kZSA9IHN0YXRlLmZyb250RmFjZU1vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIGRlcHRoIHRlc3Qgc3RhdGUgYW5kIHBhcmFtcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3RhdGUgVGhlIHN0YXRlIHRoYXQgY29udGFpbnMgbmV3IGRlcHRoIHRlc3Qgc3RhdGUgYW5kIHBhcmFtcy5cclxuICAgICAqL1xyXG4gICAgX3NldERlcHRoVGVzdFN0YXRlKHN0YXRlKSB7XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcclxuICAgICAgICBjb25zdCBib3VuZFN0YXRlID0gdGhpcy5fYm91bmRSZW5kZXJTdGF0ZTtcclxuICAgICAgICBpZiAoYm91bmRTdGF0ZS5kZXB0aFRlc3QgIT09IHN0YXRlLmRlcHRoVGVzdCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zZXRDYXBhYmlsaXR5RW5hYmxlZChnbC5ERVBUSF9URVNULCBzdGF0ZS5kZXB0aFRlc3QpO1xyXG4gICAgICAgICAgICBib3VuZFN0YXRlLmRlcHRoVGVzdCA9IHN0YXRlLmRlcHRoVGVzdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0YXRlLmRlcHRoVGVzdCkge1xyXG4gICAgICAgICAgICBpZiAoYm91bmRTdGF0ZS5jbGVhckRlcHRoICE9PSBzdGF0ZS5jbGVhckRlcHRoKSB7XHJcbiAgICAgICAgICAgICAgICBnbC5jbGVhckRlcHRoKHN0YXRlLmNsZWFyRGVwdGgpO1xyXG4gICAgICAgICAgICAgICAgYm91bmRTdGF0ZS5jbGVhckRlcHRoID0gc3RhdGUuY2xlYXJEZXB0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYm91bmRTdGF0ZS5kZXB0aE1hc2sgIT09IHN0YXRlLmRlcHRoTWFzaykge1xyXG4gICAgICAgICAgICAgICAgZ2wuZGVwdGhNYXNrKHN0YXRlLmRlcHRoTWFzayk7XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLmRlcHRoTWFzayA9IHN0YXRlLmRlcHRoTWFzaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYm91bmRTdGF0ZS5kZXB0aEZ1bmMgIT09IHN0YXRlLmRlcHRoRnVuYykge1xyXG4gICAgICAgICAgICAgICAgZ2wuZGVwdGhGdW5jKHN0YXRlLmRlcHRoRnVuYyk7XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLmRlcHRoRnVuYyA9IHN0YXRlLmRlcHRoRnVuYztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYm91bmRTdGF0ZS5kZXB0aFJhbmdlTmVhciAhPT0gc3RhdGUuZGVwdGhSYW5nZU5lYXIgfHxcclxuICAgICAgICAgICAgICAgIGJvdW5kU3RhdGUuZGVwdGhSYW5nZUZhciAhPT0gc3RhdGUuZGVwdGhSYW5nZUZhcikge1xyXG4gICAgICAgICAgICAgICAgZ2wuZGVwdGhSYW5nZShzdGF0ZS5kZXB0aFJhbmdlTmVhciwgc3RhdGUuZGVwdGhSYW5nZUZhcik7XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLmRlcHRoUmFuZ2VOZWFyID0gc3RhdGUuZGVwdGhSYW5nZU5lYXI7XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLmRlcHRoUmFuZ2VGYXIgPSBzdGF0ZS5kZXB0aFJhbmdlRmFyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIGRpdGhlciBzdGF0ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3RhdGUgVGhlIHN0YXRlIHRoYXQgY29udGFpbnMgbmV3IGRpdGhlciBzdGF0ZS5cclxuICAgICAqL1xyXG4gICAgX3NldERpdGhlclN0YXRlKHN0YXRlKSB7XHJcbiAgICAgICAgY29uc3QgYm91bmRTdGF0ZSA9IHRoaXMuX2JvdW5kUmVuZGVyU3RhdGU7XHJcbiAgICAgICAgaWYgKGJvdW5kU3RhdGUuZGl0aGVyICE9PSBzdGF0ZS5kaXRoZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5fc2V0Q2FwYWJpbGl0eUVuYWJsZWQodGhpcy5fZ2wuRElUSEVSLCBzdGF0ZS5kaXRoZXIpO1xyXG4gICAgICAgICAgICBib3VuZFN0YXRlLmRpdGhlciA9IHN0YXRlLmRpdGhlcjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgZHJhdyBidWZmZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzdGF0ZSBUaGUgc3RhdGUgdGhhdCBjb250YWlucyBhcnJheSBvZiBkcmF3IGJ1ZmZlcnMuXHJcbiAgICAgKi9cclxuICAgIF9zZXREcmF3QnVmZmVyc1N0YXRlKHN0YXRlKSB7XHJcbiAgICAgICAgY29uc3QgYm91bmREcmF3QnVmZmVycyA9IHRoaXMuX2JvdW5kUmVuZGVyU3RhdGUuZHJhd0J1ZmZlcnM7XHJcbiAgICAgICAgaWYgKGJvdW5kRHJhd0J1ZmZlcnMubGVuZ3RoICE9PSBzdGF0ZS5kcmF3QnVmZmVycy5sZW5ndGggfHxcclxuICAgICAgICAgICAgYm91bmREcmF3QnVmZmVyc1xyXG4gICAgICAgICAgICAgICAgLnNvbWUoKGF0dGFjaG1lbnQsIGkpID0+IGF0dGFjaG1lbnQgIT09IHN0YXRlLmRyYXdCdWZmZXJzW2ldKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9ib3VuZFJlbmRlclN0YXRlLmRyYXdCdWZmZXJzID0gc3RhdGUuZHJhd0J1ZmZlcnMuc2xpY2UoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgcG9seWdvbiBvZmZzZXQgc3RhdGUgYW5kIHBhcmFtcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3RhdGUgVGhlIHN0YXRlIHRoYXQgY29udGFpbnMgbmV3IHBvbHlnb24gb2Zmc2V0IHN0YXRlIGFuZCBwYXJhbXMuXHJcbiAgICAgKi9cclxuICAgIF9zZXRQb2x5Z29uT2Zmc2V0U3RhdGUoc3RhdGUpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xyXG4gICAgICAgIGNvbnN0IGJvdW5kU3RhdGUgPSB0aGlzLl9ib3VuZFJlbmRlclN0YXRlO1xyXG4gICAgICAgIGlmIChib3VuZFN0YXRlLnBvbHlnb25PZmZzZXQgIT09IHN0YXRlLnBvbHlnb25PZmZzZXQpIHtcclxuICAgICAgICAgICAgdGhpcy5fc2V0Q2FwYWJpbGl0eUVuYWJsZWQoZ2wuUE9MWUdPTl9PRkZTRVRfRklMTCwgc3RhdGUucG9seWdvbk9mZnNldCk7XHJcbiAgICAgICAgICAgIGJvdW5kU3RhdGUucG9seWdvbk9mZnNldCA9IHN0YXRlLnBvbHlnb25PZmZzZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdGF0ZS5wb2x5Z29uT2Zmc2V0ICYmXHJcbiAgICAgICAgICAgIChib3VuZFN0YXRlLnBvbHlnb25PZmZzZXRGYWN0b3IgIT09IHN0YXRlLnBvbHlnb25PZmZzZXRGYWN0b3IgfHxcclxuICAgICAgICAgICAgICAgIGJvdW5kU3RhdGUucG9seWdvbk9mZnNldFVuaXRzICE9PSBzdGF0ZS5wb2x5Z29uT2Zmc2V0VW5pdHMpKSB7XHJcbiAgICAgICAgICAgIGdsLnBvbHlnb25PZmZzZXQoc3RhdGUucG9seWdvbk9mZnNldEZhY3Rvciwgc3RhdGUucG9seWdvbk9mZnNldFVuaXRzKTtcclxuICAgICAgICAgICAgYm91bmRTdGF0ZS5wb2x5Z29uT2Zmc2V0RmFjdG9yID0gc3RhdGUucG9seWdvbk9mZnNldEZhY3RvcjtcclxuICAgICAgICAgICAgYm91bmRTdGF0ZS5wb2x5Z29uT2Zmc2V0VW5pdHMgPSBzdGF0ZS5wb2x5Z29uT2Zmc2V0VW5pdHM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIGFscGhhLXRvLWNvdmVyYWdlIHN0YXRlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzdGF0ZSBUaGUgc3RhdGUgdGhhdCBjb250YWlucyBuZXcgYWxwaGEtdG8tY292ZXJhZ2Ugc3RhdGUuXHJcbiAgICAgKi9cclxuICAgIF9zZXRBbHBoYVRvQ292ZXJhZ2VTdGF0ZShzdGF0ZSkge1xyXG4gICAgICAgIGNvbnN0IGJvdW5kU3RhdGUgPSB0aGlzLl9ib3VuZFJlbmRlclN0YXRlO1xyXG4gICAgICAgIGlmIChib3VuZFN0YXRlLnNhbXBsZUFscGhhVG9Db3ZlcmFnZSAhPT0gc3RhdGUuc2FtcGxlQWxwaGFUb0NvdmVyYWdlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldENhcGFiaWxpdHlFbmFibGVkKHRoaXMuX2dsLlNBTVBMRV9BTFBIQV9UT19DT1ZFUkFHRSwgc3RhdGUuc2FtcGxlQWxwaGFUb0NvdmVyYWdlKTtcclxuICAgICAgICAgICAgYm91bmRTdGF0ZS5zYW1wbGVBbHBoYVRvQ292ZXJhZ2UgPSBzdGF0ZS5zYW1wbGVBbHBoYVRvQ292ZXJhZ2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHNhbXBsZSBjb3ZlcmFnZSBzdGF0ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3RhdGUgVGhlIHN0YXRlIHRoYXQgY29udGFpbnMgbmV3IHNhbXBsZSBjb3ZlcmFnZSBzdGF0ZSBhbmQgcGFyYW1zLlxyXG4gICAgICovXHJcbiAgICBfc2V0U2FtcGxlQ292ZXJhZ2VTdGF0ZShzdGF0ZSkge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XHJcbiAgICAgICAgY29uc3QgYm91bmRTdGF0ZSA9IHRoaXMuX2JvdW5kUmVuZGVyU3RhdGU7XHJcbiAgICAgICAgaWYgKGJvdW5kU3RhdGUuc2FtcGxlQ292ZXJhZ2UgIT09IHN0YXRlLnNhbXBsZUNvdmVyYWdlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldENhcGFiaWxpdHlFbmFibGVkKGdsLlNBTVBMRV9DT1ZFUkFHRSwgc3RhdGUuc2FtcGxlQ292ZXJhZ2UpO1xyXG4gICAgICAgICAgICBib3VuZFN0YXRlLnNhbXBsZUNvdmVyYWdlID0gc3RhdGUuc2FtcGxlQ292ZXJhZ2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdGF0ZS5zYW1wbGVDb3ZlcmFnZSAmJlxyXG4gICAgICAgICAgICAoYm91bmRTdGF0ZS5zYW1wbGVDb3ZlcmFnZVZhbHVlICE9PSBzdGF0ZS5zYW1wbGVDb3ZlcmFnZVZhbHVlIHx8XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLnNhbXBsZUNvdmVyYWdlSW52ZXJ0ICE9PSBzdGF0ZS5zYW1wbGVDb3ZlcmFnZUludmVydCkpIHtcclxuICAgICAgICAgICAgZ2wuc2FtcGxlQ292ZXJhZ2Uoc3RhdGUuc2FtcGxlQ292ZXJhZ2VWYWx1ZSwgc3RhdGUuc2FtcGxlQ292ZXJhZ2VJbnZlcnQpO1xyXG4gICAgICAgICAgICBib3VuZFN0YXRlLnNhbXBsZUNvdmVyYWdlVmFsdWUgPSBzdGF0ZS5zYW1wbGVDb3ZlcmFnZVZhbHVlO1xyXG4gICAgICAgICAgICBib3VuZFN0YXRlLnNhbXBsZUNvdmVyYWdlSW52ZXJ0ID0gc3RhdGUuc2FtcGxlQ292ZXJhZ2VJbnZlcnQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHN0ZW5jaWwgdGVzdCBzdGF0ZSBhbmQgcGFyYW1zLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzdGF0ZSBUaGUgc3RhdGUgdGhhdCBjb250YWlucyBuZXcgc3RlbmNpbCB0ZXN0IHN0YXRlIGFuZCBwYXJhbXMuXHJcbiAgICAgKi9cclxuICAgIF9zZXRTdGVuY2lsVGVzdFN0YXRlKHN0YXRlKSB7XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcclxuICAgICAgICBjb25zdCBib3VuZFN0YXRlID0gdGhpcy5fYm91bmRSZW5kZXJTdGF0ZTtcclxuICAgICAgICBpZiAoYm91bmRTdGF0ZS5zdGVuY2lsVGVzdCAhPT0gc3RhdGUuc3RlbmNpbFRlc3QpIHtcclxuICAgICAgICAgICAgdGhpcy5fc2V0Q2FwYWJpbGl0eUVuYWJsZWQoZ2wuU1RFTkNJTF9URVNULCBzdGF0ZS5zdGVuY2lsVGVzdCk7XHJcbiAgICAgICAgICAgIGJvdW5kU3RhdGUuc3RlbmNpbFRlc3QgPSBzdGF0ZS5zdGVuY2lsVGVzdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0YXRlLnN0ZW5jaWxUZXN0KSB7XHJcbiAgICAgICAgICAgIGlmIChib3VuZFN0YXRlLmNsZWFyU3RlbmNpbCAhPT0gc3RhdGUuY2xlYXJTdGVuY2lsKSB7XHJcbiAgICAgICAgICAgICAgICBnbC5jbGVhclN0ZW5jaWwoc3RhdGUuY2xlYXJTdGVuY2lsKTtcclxuICAgICAgICAgICAgICAgIGJvdW5kU3RhdGUuY2xlYXJTdGVuY2lsID0gc3RhdGUuY2xlYXJTdGVuY2lsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChib3VuZFN0YXRlLnN0ZW5jaWxXcml0ZU1hc2sgIT09IHN0YXRlLnN0ZW5jaWxXcml0ZU1hc2spIHtcclxuICAgICAgICAgICAgICAgIGdsLnN0ZW5jaWxNYXNrKHN0YXRlLnN0ZW5jaWxXcml0ZU1hc2spO1xyXG4gICAgICAgICAgICAgICAgYm91bmRTdGF0ZS5zdGVuY2lsV3JpdGVNYXNrID0gc3RhdGUuc3RlbmNpbFdyaXRlTWFzaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCByZWZPck1hc2tJc0RpZmZlcmVudCA9IChib3VuZFN0YXRlLnN0ZW5jaWxNYXNrICE9PSBzdGF0ZS5zdGVuY2lsTWFzayB8fFxyXG4gICAgICAgICAgICAgICAgYm91bmRTdGF0ZS5zdGVuY2lsUmVmZXJlbmNlICE9PSBzdGF0ZS5zdGVuY2lsUmVmZXJlbmNlKTtcclxuICAgICAgICAgICAgaWYgKHJlZk9yTWFza0lzRGlmZmVyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLnN0ZW5jaWxNYXNrID0gc3RhdGUuc3RlbmNpbE1hc2s7XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLnN0ZW5jaWxSZWZlcmVuY2UgPSBzdGF0ZS5zdGVuY2lsUmVmZXJlbmNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChib3VuZFN0YXRlLnN0ZW5jaWxGcm9udEZ1bmMgIT09IHN0YXRlLnN0ZW5jaWxGcm9udEZ1bmMgfHxcclxuICAgICAgICAgICAgICAgIHJlZk9yTWFza0lzRGlmZmVyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBnbC5zdGVuY2lsRnVuY1NlcGFyYXRlKGdsLkZST05ULCBzdGF0ZS5zdGVuY2lsRnJvbnRGdW5jLCBzdGF0ZS5zdGVuY2lsUmVmZXJlbmNlLCBzdGF0ZS5zdGVuY2lsTWFzayk7XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLnN0ZW5jaWxGcm9udEZ1bmMgPSBzdGF0ZS5zdGVuY2lsRnJvbnRGdW5jO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChib3VuZFN0YXRlLnN0ZW5jaWxCYWNrRnVuYyAhPT0gc3RhdGUuc3RlbmNpbEJhY2tGdW5jIHx8XHJcbiAgICAgICAgICAgICAgICByZWZPck1hc2tJc0RpZmZlcmVudCkge1xyXG4gICAgICAgICAgICAgICAgZ2wuc3RlbmNpbEZ1bmNTZXBhcmF0ZShnbC5CQUNLLCBzdGF0ZS5zdGVuY2lsQmFja0Z1bmMsIHN0YXRlLnN0ZW5jaWxSZWZlcmVuY2UsIHN0YXRlLnN0ZW5jaWxNYXNrKTtcclxuICAgICAgICAgICAgICAgIGJvdW5kU3RhdGUuc3RlbmNpbEJhY2tGdW5jID0gc3RhdGUuc3RlbmNpbEJhY2tGdW5jO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChib3VuZFN0YXRlLnN0ZW5jaWxGcm9udEZhaWxPcCAhPT0gc3RhdGUuc3RlbmNpbEZyb250RmFpbE9wIHx8XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLnN0ZW5jaWxGcm9udERlcHRoRmFpbE9wICE9PSBzdGF0ZS5zdGVuY2lsRnJvbnREZXB0aEZhaWxPcCB8fFxyXG4gICAgICAgICAgICAgICAgYm91bmRTdGF0ZS5zdGVuY2lsRnJvbnREZXB0aFBhc3NPcCAhPT0gc3RhdGUuc3RlbmNpbEZyb250RGVwdGhQYXNzT3ApIHtcclxuICAgICAgICAgICAgICAgIGdsLnN0ZW5jaWxPcFNlcGFyYXRlKGdsLkZST05ULCBzdGF0ZS5zdGVuY2lsRnJvbnRGYWlsT3AsIHN0YXRlLnN0ZW5jaWxGcm9udERlcHRoRmFpbE9wLCBzdGF0ZS5zdGVuY2lsRnJvbnREZXB0aFBhc3NPcCk7XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLnN0ZW5jaWxGcm9udEZhaWxPcCA9IHN0YXRlLnN0ZW5jaWxGcm9udEZhaWxPcDtcclxuICAgICAgICAgICAgICAgIGJvdW5kU3RhdGUuc3RlbmNpbEZyb250RGVwdGhGYWlsT3AgPSBzdGF0ZS5zdGVuY2lsRnJvbnREZXB0aEZhaWxPcDtcclxuICAgICAgICAgICAgICAgIGJvdW5kU3RhdGUuc3RlbmNpbEZyb250RGVwdGhQYXNzT3AgPSBzdGF0ZS5zdGVuY2lsRnJvbnREZXB0aFBhc3NPcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYm91bmRTdGF0ZS5zdGVuY2lsQmFja0ZhaWxPcCAhPT0gc3RhdGUuc3RlbmNpbEJhY2tGYWlsT3AgfHxcclxuICAgICAgICAgICAgICAgIGJvdW5kU3RhdGUuc3RlbmNpbEJhY2tEZXB0aEZhaWxPcCAhPT0gc3RhdGUuc3RlbmNpbEJhY2tEZXB0aEZhaWxPcCB8fFxyXG4gICAgICAgICAgICAgICAgYm91bmRTdGF0ZS5zdGVuY2lsQmFja0RlcHRoUGFzc09wICE9PSBzdGF0ZS5zdGVuY2lsQmFja0RlcHRoUGFzc09wKSB7XHJcbiAgICAgICAgICAgICAgICBnbC5zdGVuY2lsT3BTZXBhcmF0ZShnbC5CQUNLLCBzdGF0ZS5zdGVuY2lsQmFja0ZhaWxPcCwgc3RhdGUuc3RlbmNpbEJhY2tEZXB0aEZhaWxPcCwgc3RhdGUuc3RlbmNpbEJhY2tEZXB0aFBhc3NPcCk7XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLnN0ZW5jaWxCYWNrRmFpbE9wID0gc3RhdGUuc3RlbmNpbEJhY2tGYWlsT3A7XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLnN0ZW5jaWxCYWNrRGVwdGhGYWlsT3AgPSBzdGF0ZS5zdGVuY2lsQmFja0RlcHRoRmFpbE9wO1xyXG4gICAgICAgICAgICAgICAgYm91bmRTdGF0ZS5zdGVuY2lsQmFja0RlcHRoUGFzc09wID0gc3RhdGUuc3RlbmNpbEJhY2tEZXB0aFBhc3NPcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBzY2lzc29yIHRlc3Qgc3RhdGUgYW5kIHNjaXNzb3IgcmVjdGFuZ2xlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzdGF0ZSBUaGUgc3RhdGUgdGhhdCBjb250YWlucyBuZXcgc2Npc3NvciB0ZXN0IHN0YXRlIGFuZCBzY2lzc29yXHJcbiAgICAgKiAgICAgIHJlY3RhbmdsZS5cclxuICAgICAqL1xyXG4gICAgX3NldFNjaXNzb3JUZXN0U3RhdGUoc3RhdGUpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xyXG4gICAgICAgIGNvbnN0IGJvdW5kU3RhdGUgPSB0aGlzLl9ib3VuZFJlbmRlclN0YXRlO1xyXG4gICAgICAgIGlmIChib3VuZFN0YXRlLnNjaXNzb3JUZXN0ICE9PSBzdGF0ZS5zY2lzc29yVGVzdCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zZXRDYXBhYmlsaXR5RW5hYmxlZChnbC5TQ0lTU09SX1RFU1QsIHN0YXRlLnNjaXNzb3JUZXN0KTtcclxuICAgICAgICAgICAgYm91bmRTdGF0ZS5zY2lzc29yVGVzdCA9IHN0YXRlLnNjaXNzb3JUZXN0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RhdGUuc2Npc3NvclRlc3QgJiZcclxuICAgICAgICAgICAgc3RhdGUuc2Npc3NvcldpZHRoID49IDAgJiZcclxuICAgICAgICAgICAgc3RhdGUuc2Npc3NvckhlaWdodCA+PSAwICYmXHJcbiAgICAgICAgICAgIChib3VuZFN0YXRlLnNjaXNzb3JYICE9PSBzdGF0ZS5zY2lzc29yWCB8fFxyXG4gICAgICAgICAgICAgICAgYm91bmRTdGF0ZS5zY2lzc29yWSAhPT0gc3RhdGUuc2Npc3NvclkgfHxcclxuICAgICAgICAgICAgICAgIGJvdW5kU3RhdGUuc2Npc3NvcldpZHRoICE9PSBzdGF0ZS5zY2lzc29yV2lkdGggfHxcclxuICAgICAgICAgICAgICAgIGJvdW5kU3RhdGUuc2Npc3NvckhlaWdodCAhPT0gc3RhdGUuc2Npc3NvckhlaWdodCkpIHtcclxuICAgICAgICAgICAgZ2wuc2Npc3NvcihzdGF0ZS5zY2lzc29yWCwgc3RhdGUuc2Npc3NvclksIHN0YXRlLnNjaXNzb3JXaWR0aCwgc3RhdGUuc2Npc3NvckhlaWdodCk7XHJcbiAgICAgICAgICAgIGJvdW5kU3RhdGUuc2Npc3NvclggPSBzdGF0ZS5zY2lzc29yWDtcclxuICAgICAgICAgICAgYm91bmRTdGF0ZS5zY2lzc29yWSA9IHN0YXRlLnNjaXNzb3JZO1xyXG4gICAgICAgICAgICBib3VuZFN0YXRlLnNjaXNzb3JXaWR0aCA9IHN0YXRlLnNjaXNzb3JXaWR0aDtcclxuICAgICAgICAgICAgYm91bmRTdGF0ZS5zY2lzc29ySGVpZ2h0ID0gc3RhdGUuc2Npc3NvckhlaWdodDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdmlld3BvcnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHN0YXRlIFRoZSBzdGF0ZSB0aGF0IGNvbnRhaW5zIG5ldyB2aWV3cG9ydC5cclxuICAgICAqL1xyXG4gICAgX3NldFZpZXdwb3J0U3RhdGUoc3RhdGUpIHtcclxuICAgICAgICBjb25zdCBib3VuZFN0YXRlID0gdGhpcy5fYm91bmRSZW5kZXJTdGF0ZTtcclxuICAgICAgICBpZiAoc3RhdGUudmlld3BvcnRXaWR0aCA+PSAwICYmXHJcbiAgICAgICAgICAgIHN0YXRlLnZpZXdwb3J0SGVpZ2h0ID49IDAgJiZcclxuICAgICAgICAgICAgKGJvdW5kU3RhdGUudmlld3BvcnRYICE9PSBzdGF0ZS52aWV3cG9ydFggfHxcclxuICAgICAgICAgICAgICAgIGJvdW5kU3RhdGUudmlld3BvcnRZICE9PSBzdGF0ZS52aWV3cG9ydFkgfHxcclxuICAgICAgICAgICAgICAgIGJvdW5kU3RhdGUudmlld3BvcnRXaWR0aCAhPT0gc3RhdGUudmlld3BvcnRXaWR0aCB8fFxyXG4gICAgICAgICAgICAgICAgYm91bmRTdGF0ZS52aWV3cG9ydEhlaWdodCAhPT0gc3RhdGUudmlld3BvcnRIZWlnaHQpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsLnZpZXdwb3J0KHN0YXRlLnZpZXdwb3J0WCwgc3RhdGUudmlld3BvcnRZLCBzdGF0ZS52aWV3cG9ydFdpZHRoLCBzdGF0ZS52aWV3cG9ydEhlaWdodCk7XHJcbiAgICAgICAgICAgIGJvdW5kU3RhdGUudmlld3BvcnRYID0gc3RhdGUudmlld3BvcnRYO1xyXG4gICAgICAgICAgICBib3VuZFN0YXRlLnZpZXdwb3J0WSA9IHN0YXRlLnZpZXdwb3J0WTtcclxuICAgICAgICAgICAgYm91bmRTdGF0ZS52aWV3cG9ydFdpZHRoID0gc3RhdGUudmlld3BvcnRXaWR0aDtcclxuICAgICAgICAgICAgYm91bmRTdGF0ZS52aWV3cG9ydEhlaWdodCA9IHN0YXRlLnZpZXdwb3J0SGVpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0ZXh0dXJlIGRhdGEgdW5wYWNrIHBhcmFtcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcGFyYW1zIFRleHR1cmUgcGFyYW1zIHRvIGJlIHNldC5cclxuICAgICAqL1xyXG4gICAgX3NldFRleHR1cmVEYXRhVW5wYWNrUGFyYW1zKHBhcmFtcykge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XHJcbiAgICAgICAgaWYgKHRoaXMuX3VucGFja1ByZW11bHRpcGx5QWxwaGEgIT09IHBhcmFtcy5wcmVtdWx0aXBsaWVkQWxwaGEpIHtcclxuICAgICAgICAgICAgZ2wucGl4ZWxTdG9yZWkoMzc0NDEgLyogVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMICovLCArcGFyYW1zLnByZW11bHRpcGxpZWRBbHBoYSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3VucGFja1ByZW11bHRpcGx5QWxwaGEgPSBwYXJhbXMucHJlbXVsdGlwbGllZEFscGhhO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9vblRleHR1cmVEYXRhVXBkYXRlZCh0ZXh0dXJlKSB7XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcclxuICAgICAgICBjb25zdCBwYXJhbXMgPSB0ZXh0dXJlLmdldFBhcmFtcygpO1xyXG4gICAgICAgIGlmIChwYXJhbXMubWluaWZpY2F0aW9uRmlsdGVyID49IDk5ODQgLyogTkVBUkVTVF9NSVBNQVBfTkVBUkVTVCAqLykge1xyXG4gICAgICAgICAgICBnbC5nZW5lcmF0ZU1pcG1hcChnbC5URVhUVVJFXzJEKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgemVyb2VkIGJ1ZmZlciB3aXRoIGEgZ2l2ZW4gc2l6ZSBhbmQgYSB0YXJnZXQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IG9mIHRoZSBuZXcgYnVmZmVyLCBgQVJSQVlfQlVGRkVSYCBvclxyXG4gICAgICogICAgICBgRUxFTUVOVF9BUlJBWV9CVUZGRVJgLlxyXG4gICAgICogQHBhcmFtIHNpemUgVGhlIHNpemUgb2YgdGhlIGJ1ZmZlci5cclxuICAgICAqIEBwYXJhbSB1c2FnZSBVc2FnZSBvZiB0aGUgYnVmZmVyLlxyXG4gICAgICogQHJldHVybnMgVGhlIGJ1ZmZlci5cclxuICAgICAqL1xyXG4gICAgX2NyZWF0ZUJ1ZmZlcih0YXJnZXQsIHNpemUsIHVzYWdlID0gdGhpcy5fZ2wuU1RBVElDX0RSQVcpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xyXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBCdWZmZXIoZ2wsIHRhcmdldCwgc2l6ZSk7XHJcbiAgICAgICAgLy8gVE9ETyhkbWlraXMpIGEgY2xldmVyZXIgd2F5IG5vdCB0byBicmVhayBjdXJyZW50bHkgYm91bmQgVkFPO1xyXG4gICAgICAgIHRoaXMuYmluZFZhbyhudWxsKTtcclxuICAgICAgICBidWZmZXIuYmluZCgpO1xyXG4gICAgICAgIGdsLmJ1ZmZlckRhdGEodGFyZ2V0LCBzaXplLCB1c2FnZSk7XHJcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvY29udGV4dC50c1xuLy8gbW9kdWxlIGlkID0gNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIENoZWNrcyBpZiBhIG51bWJlciBpcyBhIHBvd2VyIG9mIDIuXHJcbiAqXHJcbiAqIEBwYXJhbSB4IFRoZSBudW1iZXIgdG8gY2hlY2suXHJcbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgbnVtYmVyIGlzIGFuIGludGVnZXIgcG93ZXIgb2YgMiBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNQb3dPZjIoeCkge1xyXG4gICAgcmV0dXJuIHggPiAwICYmICEoeCAmICh4IC0gMSkpO1xyXG59XHJcbi8qKlxyXG4gKiBBbGlnbnMgYW4gb2Zmc2V0IGJ5IGFuIGFsaWdubWVudCBnaXZlbiBieSBhIG1hc2suXHJcbiAqXHJcbiAqIEBwYXJhbSBvZmZzZXQgVGhlIG9mZnNldC5cclxuICogQHBhcmFtIGFsaWdubWVudE1hc2sgVGhlIGFsaWdubWVudCBtYXNrIOKAlCBhIGJpdCBmaWVsZCB0aGF0IGhhcyBgbG9nMihhbGlnbm1lbnQpYFxyXG4gKiAgICAgIG9mIGxlYXN0IHNpZ25pZmljYW50IGJpdHMgdW5zZXQgYW5kIG90aGVyIHNldCwgZS5nLiBpZiBgYWxpZ25tZW50YCBpcyA0XHJcbiAqICAgICAgdGhlbiB0aGUgYGFsaWdubWVudE1hc2tgIHdpbGwgYmUgYDB4ZmZmZmZmY2BcclxuICogQHJldHVybnMgQWxpZ25lZCBvZmZzZXQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYWxpZ24ob2Zmc2V0LCBhbGlnbm1lbnRNYXNrKSB7XHJcbiAgICByZXR1cm4gKG9mZnNldCAtIDEgJiBhbGlnbm1lbnRNYXNrKSAtIGFsaWdubWVudE1hc2s7XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9wb3dfb2ZfMi50c1xuLy8gbW9kdWxlIGlkID0gNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqIFdyYXBwZXIgYXJvdW5kIFdlYkdMQnVmZmVyIG9iamVjdC4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnVmZmVyIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBlbXB0eSBidWZmZXIgaW4gYSBXZWJHTCBjb250ZXh0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBnbCBUaGUgY29udGV4dCB0aGUgYnVmZmVyIHdpbGwgYmUgY3JlYXRlZCBpbi5cclxuICAgICAqIEBwYXJhbSB0YXJnZXQgQmluZGluZyB0YXJnZXQgb2YgdGhlIGJ1ZmZlci4gU2luY2UgaW4gV2ViR0wgb25jZSB5b3UndmVcclxuICAgICAqICAgICAgYm91bmQgYSBidWZmZXIgdG8gYSBnaXZlbiB0YXJnZXQgeW91IGNhbid0IGJpbmQgaXQgYW55IG90aGVyIG9uZSxcclxuICAgICAqICAgICAgd2UgXCJ0aWVcIiB0aGUgYnVmZmVyIGFuZCBpdCdzIGJpbmRpbmcgcG9pbnQgdG9nZXRoZXIuXHJcbiAgICAgKiBAcGFyYW0gc2l6ZSBTaXplIG9mIHRoZSBidWZmZXIuIFdlIGRvbid0IGRvIGFjdHVhbCBhbGxvY2F0aW9uIGluIHRoZVxyXG4gICAgICogICAgICB3cmFwcGVyLCBpdCdzIGNvbnRleHQncyByZXNwb25zaWJpbGl0eS4gQnV0IGl0J3MgY29udmVuaWVudCB0byBiZVxyXG4gICAgICogICAgICBhYmxlIHRvIGdldCB0aGUgc2l6ZSBmcm9tIHRoZSB3cmFwcGVyIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZ2wsIHRhcmdldCwgc2l6ZSkge1xyXG4gICAgICAgIHRoaXMuX2dsID0gZ2w7XHJcbiAgICAgICAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgIHRoaXMuX2hhbmRsZSA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG4gICAgICAgIHRoaXMuX3NpemUgPSBzaXplO1xyXG4gICAgfVxyXG4gICAgLyoqIEJpbmRzIHRoZSBidWZmZXIgdG8gdGhlIGNvbnRleHQgdG8gaXRzIGJpbmRpbmcgdGFyZ2V0LiAqL1xyXG4gICAgYmluZCgpIHtcclxuICAgICAgICB0aGlzLl9nbC5iaW5kQnVmZmVyKHRoaXMuX3RhcmdldCwgdGhpcy5faGFuZGxlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGJ1ZmZlciBpcyBjdXJyZW50bHkgYm91bmQgdG8gdGhlIGNvbnRleHQgdG8gaXRzXHJcbiAgICAgKiBiaW5kaW5nIHRhcmdldCBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXHJcbiAgICAgKi9cclxuICAgIGlzQm91bmQoKSB7XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcclxuICAgICAgICBjb25zdCBoYW5kbGUgPSB0aGlzLl9oYW5kbGU7XHJcbiAgICAgICAgc3dpdGNoICh0aGlzLl90YXJnZXQpIHtcclxuICAgICAgICAgICAgY2FzZSBnbC5BUlJBWV9CVUZGRVI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2wuZ2V0UGFyYW1ldGVyKGdsLkFSUkFZX0JVRkZFUl9CSU5ESU5HKSA9PT0gaGFuZGxlO1xyXG4gICAgICAgICAgICBjYXNlIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdsLmdldFBhcmFtZXRlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUl9CSU5ESU5HKSA9PT0gaGFuZGxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKiogUmV0dXJucyBiaW5kaW5nIHRhcmdldCBvZiB0aGUgYnVmZmVyLiAqL1xyXG4gICAgZ2V0VGFyZ2V0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90YXJnZXQ7XHJcbiAgICB9XHJcbiAgICAvKiogUmV0dXJucyBzaXplIG9mIHRoZSBidWZmZXIuICovXHJcbiAgICBnZXRTaXplKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zaXplO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXN0cm95cyB0aGUgYnVmZmVyLlxyXG4gICAgICovXHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMuX2dsLmRlbGV0ZUJ1ZmZlcih0aGlzLl9oYW5kbGUpO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9nbC9idWZmZXIudHNcbi8vIG1vZHVsZSBpZCA9IDU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKiBXcmFwcGVyIGFyb3VuZCBXZWJHTEZyYW1lYnVmZmVyIG9iamVjdC4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRnJhbWVidWZmZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGZyYW1lYnVmZmVyIGluIGEgV2ViR0wgY29udGV4dC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZ2wgVGhlIGNvbnRleHQgdGhlIGZyYW1lYnVmZmVyIHdpbGwgYmUgY3JlYXRlZCBpbi5cclxuICAgICAqIEBwYXJhbSB3aWR0aCBXaWR0aCBvZiB0aGUgZnJhbWVidWZmZXIuXHJcbiAgICAgKiBAcGFyYW0gaGVpZ2h0IEhlaWdodCBvZiB0aGUgZnJhbWVidWZmZXIuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGdsLCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgdGhpcy5pc0NsZWFyID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fZ2wgPSBnbDtcclxuICAgICAgICB0aGlzLl9oYW5kbGUgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xyXG4gICAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBCaW5kcyB0aGUgZnJhbWVidWZmZXIgdG8gdGhlIFdlYkdMIGNvbnRleHQuXHJcbiAgICAgKi9cclxuICAgIGJpbmQoKSB7XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcclxuICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuX2hhbmRsZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyBpZiB0aGUgZnJhbWVidWZmZXIgaXMgYm91bmQgdG8gdGhlIFdlYkdMIGNvbnRleHQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBmcmFtZWJ1ZmZlciBpcyBjdXJyZW50bHkgYm91bmQgdG8gdGhlIFdlYkdMIGNvbnRleHRcclxuICAgICAqICAgICAgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxyXG4gICAgICovXHJcbiAgICBpc0JvdW5kKCkge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XHJcbiAgICAgICAgcmV0dXJuIGdsLmdldFBhcmFtZXRlcihnbC5GUkFNRUJVRkZFUl9CSU5ESU5HKSA9PT0gdGhpcy5faGFuZGxlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHdpZHRoIG9mIHRoZSBmcmFtZWJ1ZmZlci5cclxuICAgICAqL1xyXG4gICAgZ2V0V2lkdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dpZHRoO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGhlaWdodCBvZiB0aGUgZnJhbWVidWZmZXIuXHJcbiAgICAgKi9cclxuICAgIGdldEhlaWdodCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBjb250ZW50IG9mIHRoZSBjb2xvciBhdHRhY2htZW50IGFzIGFuIFJHQkEgYml0bWFwLlxyXG4gICAgICovXHJcbiAgICByZWFkUGl4ZWxzKCkge1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheSh0aGlzLmdldFdpZHRoKCkgKiB0aGlzLmdldEhlaWdodCgpICogNCk7XHJcbiAgICAgICAgdGhpcy5fZ2wucmVhZFBpeGVscygwLCAwLCB0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0LCA2NDA4IC8qIFJHQkEgKi8sIDUxMjEgLyogVU5TSUdORURfQllURSAqLywgZGF0YSk7XHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERlc3Ryb3lzIHRoZSBmcmFtZWJ1ZmZlci5cclxuICAgICAqL1xyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLl9nbC5kZWxldGVGcmFtZWJ1ZmZlcih0aGlzLl9oYW5kbGUpO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9nbC9mcmFtZWJ1ZmZlci50c1xuLy8gbW9kdWxlIGlkID0gNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIEluc2VydHMgZ2l2ZW4gcGFyYW1ldGVycyBhcyBwcmVwcm9jZXNzb3IgZGVmaW5lIGRpcmVjdGl2ZXMgaW50byBzaGFkZXIgc291cmNlLlxyXG4gKlxyXG4gKiBAcGFyYW0gc291cmNlIFNoYWRlciBzb3VyY2UuXHJcbiAqIEBwYXJhbSBkZWZpbmVzIERpY3Rpb25hcnkgd2l0aCBwYXJhbWV0ZXJzIHRvIGRlZmluZSB3aXRoIHByZXByb2Nlc3NvciBkaXJlY3RpdmVzLlxyXG4gKiBAcmV0dXJucyBTaGFkZXIgc291cmNlIHdpdGggcHJlcHJvY2Vzc29yIGRpcmVjdGl2ZXMgaW5zZXJ0ZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBpbnNlcnREZWZpbmVzKHNvdXJjZSwgZGVmaW5lcykge1xyXG4gICAgY29uc3QgZGVmaW5lc1N0cmluZyA9IE9iamVjdC5rZXlzKGRlZmluZXMpXHJcbiAgICAgICAgLm1hcCgoZGVmaW5lTmFtZSkgPT4gJyNkZWZpbmUgJyArIGRlZmluZU5hbWUgKyAnICcgK1xyXG4gICAgICAgIGRlZmluZXNbZGVmaW5lTmFtZV0pXHJcbiAgICAgICAgLmpvaW4oJ1xcbicpO1xyXG4gICAgY29uc3QgdmVyc2lvbklkeCA9IHNvdXJjZS5pbmRleE9mKCcjdmVyc2lvbicpO1xyXG4gICAgaWYgKHZlcnNpb25JZHggPT09IC0xKSB7XHJcbiAgICAgICAgcmV0dXJuIGRlZmluZXNTdHJpbmcgKyAnXFxuJyArIHNvdXJjZTtcclxuICAgIH1cclxuICAgIGNvbnN0IG5leHRMaW5lSWR4ID0gc291cmNlLmluZGV4T2YoJ1xcbicsIHZlcnNpb25JZHgpICsgMTtcclxuICAgIHJldHVybiBzb3VyY2Uuc2xpY2UoMCwgbmV4dExpbmVJZHgpICsgZGVmaW5lc1N0cmluZyArICdcXG4nICtcclxuICAgICAgICBzb3VyY2Uuc2xpY2UobmV4dExpbmVJZHgpO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IHNoYWRlciBvZiBhIGdpdmVuIHR5cGUgb3V0IG9mIGEgZ2l2ZW4gc291cmNlIHN0cmluZy5cclxuICpcclxuICogQHBhcmFtIGdsIFdlYkdMIGNvbnRleHQgdGhlIHNoYWRlciB3aWxsIGJlIGNyZWF0ZWQgaW4uXHJcbiAqIEBwYXJhbSB0eXBlIFRoZSB0eXBlIG9mIHRoZSBzaGFkZXIsIFZFUlRFWF9TSEFERVIgb3IgRlJBR01FTlRfU0hBREVSLlxyXG4gKiBAcGFyYW0gc291cmNlIFRoZSBzb3VyY2Ugc3RyaW5nLlxyXG4gKiBAdGhyb3dzIEFuIGVycm9yIGlmIGNvbXBpbGF0aW9uIG9mIHRoZSBzaGFkZXIgZmFpbHMuXHJcbiAqIEByZXR1cm5zIFRoZSBzaGFkZXIgV2ViR0wgaGFuZGxlLlxyXG4gKi9cclxuZnVuY3Rpb24gY29tcGlsZVNoYWRlcihnbCwgdHlwZSwgc291cmNlKSB7XHJcbiAgICBjb25zdCBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIodHlwZSk7XHJcbiAgICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzb3VyY2UpO1xyXG4gICAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xyXG4gICAgLy8gVE9ETyBVbmNvbW1lbnQgYW5kIHB1dCB1bmRlciBkZWJ1ZyBmbGFnICh3aGVuIGltcGxlbWVudGVkKVxyXG4gICAgaWYgKCFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBjb21waWxlIHNoYWRlcjpcXG4nICsgZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBzaGFkZXI7XHJcbn1cclxuLyoqIFdyYXBwZXIgYXJvdW5kIFdlYkdMUHJvZ3JhbSBvYmplY3RzLiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcm9ncmFtIHtcclxuICAgIC8qKlxyXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBwcm9ncmFtLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBnbCBXZWJHTCBjb250ZXh0IHRoZSBwcm9ncmFtIHdpbGwgYmUgY3JlYXRlZCBpbi5cclxuICAgICAqIEBwYXJhbSB2ZXJ0ZXhTaGFkZXJTb3VyY2UgU291cmNlIGNvZGUgb2YgdmVydGV4IHNoYWRlciBvZiB0aGUgcHJvZ3JhbS5cclxuICAgICAqIEBwYXJhbSBmcmFnbWVudFNoYWRlclNvdXJjZSBTb3VyY2UgY29kZSBvZiBmcmFnbWVudCBzaGFkZXIgb2YgdGhlIHByb2dyYW0uXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zLlxyXG4gICAgICogQHRocm93cyBBbiBlcnJvciBpZiBzaGFkZXIgY29tcGlsYXRpb24gb3IgcHJvZ3JhbSBsaW5raW5nIGZhaWxzLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihnbCwgdmVydGV4U2hhZGVyU291cmNlLCBmcmFnbWVudFNoYWRlclNvdXJjZSwgb3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMuX2dsID0gZ2w7XHJcbiAgICAgICAgY29uc3QgaGFuZGxlID0gdGhpcy5faGFuZGxlID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xyXG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZGVmaW5lcykge1xyXG4gICAgICAgICAgICB2ZXJ0ZXhTaGFkZXJTb3VyY2UgPSBpbnNlcnREZWZpbmVzKHZlcnRleFNoYWRlclNvdXJjZSwgb3B0aW9ucy5kZWZpbmVzKTtcclxuICAgICAgICAgICAgZnJhZ21lbnRTaGFkZXJTb3VyY2UgPSBpbnNlcnREZWZpbmVzKGZyYWdtZW50U2hhZGVyU291cmNlLCBvcHRpb25zLmRlZmluZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB2ZXJ0ZXhTaGFkZXIgPSBjb21waWxlU2hhZGVyKGdsLCBnbC5WRVJURVhfU0hBREVSLCB2ZXJ0ZXhTaGFkZXJTb3VyY2UpO1xyXG4gICAgICAgIGNvbnN0IGZyYWdtZW50U2hhZGVyID0gY29tcGlsZVNoYWRlcihnbCwgZ2wuRlJBR01FTlRfU0hBREVSLCBmcmFnbWVudFNoYWRlclNvdXJjZSk7XHJcbiAgICAgICAgZ2wuYXR0YWNoU2hhZGVyKGhhbmRsZSwgdmVydGV4U2hhZGVyKTtcclxuICAgICAgICBnbC5hdHRhY2hTaGFkZXIoaGFuZGxlLCBmcmFnbWVudFNoYWRlcik7XHJcbiAgICAgICAgZ2wuZGVsZXRlU2hhZGVyKHZlcnRleFNoYWRlcik7XHJcbiAgICAgICAgZ2wuZGVsZXRlU2hhZGVyKGZyYWdtZW50U2hhZGVyKTtcclxuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmF0dHJpYk1hcCkge1xyXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhvcHRpb25zLmF0dHJpYk1hcClcclxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKChhdHRyaWJ1dGVOYW1lKSA9PiBnbC5iaW5kQXR0cmliTG9jYXRpb24oaGFuZGxlLCBvcHRpb25zLmF0dHJpYk1hcFthdHRyaWJ1dGVOYW1lXSwgYXR0cmlidXRlTmFtZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBnbC5saW5rUHJvZ3JhbShoYW5kbGUpO1xyXG4gICAgICAgIC8vIFRPRE8gVW5jb21tZW50IGFuZCBwdXQgdW5kZXIgZGVidWcgZmxhZyAod2hlbiBpbXBsZW1lbnRlZClcclxuICAgICAgICBpZiAoIWdsLmdldFByb2dyYW1QYXJhbWV0ZXIoaGFuZGxlLCBnbC5MSU5LX1NUQVRVUykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gbGluayBwcm9ncmFtOlxcbiR7Z2wuZ2V0UHJvZ3JhbUluZm9Mb2coaGFuZGxlKX1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fdW5pZm9ybUNhY2hlID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBCaW5kcyB0aGUgcHJvZ3JhbSB0byB0aGUgV2ViR0wgY29udGV4dC5cclxuICAgICAqL1xyXG4gICAgYmluZCgpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xyXG4gICAgICAgIGNvbnN0IGhhbmRsZSA9IHRoaXMuX2hhbmRsZTtcclxuICAgICAgICAvLyBUT0RPIFVuY29tbWVudCBhbmQgcHV0IHVuZGVyIGRlYnVnIGZsYWcgKHdoZW4gaW1wbGVtZW50ZWQpXHJcbiAgICAgICAgLy8gZ2wudmFsaWRhdGVQcm9ncmFtKGhhbmRsZSk7XHJcbiAgICAgICAgLy8gaWYgKCFnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKGhhbmRsZSwgZ2wuVkFMSURBVEVfU1RBVFVTKSkge1xyXG4gICAgICAgIC8vICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgLy8gICAgICAgICAnRmFpbGVkIHRvIHZhbGlkYXRlIHByb2dyYW06XFxuJyArIGdsLmdldFByb2dyYW1JbmZvTG9nKGhhbmRsZSlcclxuICAgICAgICAvLyAgICAgKTtcclxuICAgICAgICAvLyB9XHJcbiAgICAgICAgZ2wudXNlUHJvZ3JhbShoYW5kbGUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgdGhlIHByb2dyYW0gaXMgYm91bmQgdG8gdGhlIFdlYkdMIGNvbnRleHQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBwcm9ncmFtIGlmIGN1cnJlbnRseSBib3VuZCB0byB0aGUgV2ViR0wgY29udGV4dCBhbmRcclxuICAgICAqICAgICAgYGZhbHNlYCBvdGhlcndpc2UuXHJcbiAgICAgKi9cclxuICAgIGlzQm91bmQoKSB7XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcclxuICAgICAgICByZXR1cm4gZ2wuZ2V0UGFyYW1ldGVyKGdsLkNVUlJFTlRfUFJPR1JBTSkgPT09IHRoaXMuX2hhbmRsZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBhbiBpbnRlZ2VyIHNjYWxhciB2YWx1ZSB0byBhIHVuaWZvcm0uIElmIHRoZXJlJ3Mgbm8gdW5pZm9ybSB3aXRoXHJcbiAgICAgKiBnaXZlbiBuYW1lIGluIHRoZSBwcm9ncmFtLCBzaWxlbnRseSBkb2VzIG5vdGhpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHVuaWZvcm1OYW1lIE5hbWUgb2YgdGhlIHVuaWZvcm0uXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHNjYWxhciB2YWx1ZS5cclxuICAgICAqL1xyXG4gICAgc2V0SW50U2NhbGFyVW5pZm9ybSh1bmlmb3JtTmFtZSwgdmFsdWUpIHtcclxuICAgICAgICBjb25zdCBsb2NhdGlvbiA9IHRoaXMuX2dldFVuaWZvcm1Mb2NhdGlvbih1bmlmb3JtTmFtZSk7XHJcbiAgICAgICAgaWYgKGxvY2F0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsLnVuaWZvcm0xaShsb2NhdGlvbiwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBhIHNjYWxhciB2YWx1ZSB0byBhIHVuaWZvcm0uIElmIHRoZXJlJ3Mgbm8gdW5pZm9ybSB3aXRoXHJcbiAgICAgKiBnaXZlbiBuYW1lIGluIHRoZSBwcm9ncmFtLCBzaWxlbnRseSBkb2VzIG5vdGhpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHVuaWZvcm1OYW1lIE5hbWUgb2YgdGhlIHVuaWZvcm0uXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHNjYWxhciB2YWx1ZS5cclxuICAgICAqL1xyXG4gICAgc2V0U2NhbGFyVW5pZm9ybSh1bmlmb3JtTmFtZSwgdmFsdWUpIHtcclxuICAgICAgICBjb25zdCBsb2NhdGlvbiA9IHRoaXMuX2dldFVuaWZvcm1Mb2NhdGlvbih1bmlmb3JtTmFtZSk7XHJcbiAgICAgICAgaWYgKGxvY2F0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsLnVuaWZvcm0xZihsb2NhdGlvbiwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBhIDJEIHZlY3RvciB0byBhIHVuaWZvcm0uIElmIHRoZXJlJ3Mgbm8gdW5pZm9ybSB3aXRoIGdpdmVuIG5hbWUgaW5cclxuICAgICAqIHRoZSBwcm9ncmFtLCBzaWxlbnRseSBkb2VzIG5vdGhpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHVuaWZvcm1OYW1lIE5hbWUgb2YgdGhlIHVuaWZvcm0uXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZlY3Rvci5cclxuICAgICAqL1xyXG4gICAgc2V0VmVjdG9yMlVuaWZvcm0odW5pZm9ybU5hbWUsIHZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgbG9jYXRpb24gPSB0aGlzLl9nZXRVbmlmb3JtTG9jYXRpb24odW5pZm9ybU5hbWUpO1xyXG4gICAgICAgIGlmIChsb2NhdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLl9nbC51bmlmb3JtMmYobG9jYXRpb24sIHZhbHVlLngsIHZhbHVlLnkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBhIDNEIHZlY3RvciB0byBhIHVuaWZvcm0uIElmIHRoZXJlJ3Mgbm8gdW5pZm9ybSB3aXRoIGdpdmVuIG5hbWUgaW5cclxuICAgICAqIHRoZSBwcm9ncmFtLCBzaWxlbnRseSBkb2VzIG5vdGhpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHVuaWZvcm1OYW1lIE5hbWUgb2YgdGhlIHVuaWZvcm0uXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZlY3Rvci5cclxuICAgICAqL1xyXG4gICAgc2V0VmVjdG9yM1VuaWZvcm0odW5pZm9ybU5hbWUsIHZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgbG9jYXRpb24gPSB0aGlzLl9nZXRVbmlmb3JtTG9jYXRpb24odW5pZm9ybU5hbWUpO1xyXG4gICAgICAgIGlmIChsb2NhdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLl9nbC51bmlmb3JtM2YobG9jYXRpb24sIHZhbHVlLngsIHZhbHVlLnksIHZhbHVlLnopO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBhIDREIHZlY3RvciB0byBhIHVuaWZvcm0uIElmIHRoZXJlJ3Mgbm8gdW5pZm9ybSB3aXRoIGdpdmVuIG5hbWUgaW5cclxuICAgICAqIHRoZSBwcm9ncmFtLCBzaWxlbnRseSBkb2VzIG5vdGhpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHVuaWZvcm1OYW1lIE5hbWUgb2YgdGhlIHVuaWZvcm0uXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZlY3Rvci5cclxuICAgICAqL1xyXG4gICAgc2V0VmVjdG9yNFVuaWZvcm0odW5pZm9ybU5hbWUsIHZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgbG9jYXRpb24gPSB0aGlzLl9nZXRVbmlmb3JtTG9jYXRpb24odW5pZm9ybU5hbWUpO1xyXG4gICAgICAgIGlmIChsb2NhdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLl9nbC51bmlmb3JtNGYobG9jYXRpb24sIHZhbHVlLngsIHZhbHVlLnksIHZhbHVlLnosIHZhbHVlLncpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBhIGNvbG9yIHRvIGEgdW5pZm9ybS4gSWYgdGhlcmUncyBubyB1bmlmb3JtIHdpdGggZ2l2ZW4gbmFtZSBpbiB0aGVcclxuICAgICAqIHByb2dyYW0sIHNpbGVudGx5IGRvZXMgbm90aGluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdW5pZm9ybU5hbWUgTmFtZSBvZiB0aGUgdW5pZm9ybS5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgY29sb3IuXHJcbiAgICAgKi9cclxuICAgIHNldENvbG9yVW5pZm9ybSh1bmlmb3JtTmFtZSwgdmFsdWUpIHtcclxuICAgICAgICBjb25zdCBsb2NhdGlvbiA9IHRoaXMuX2dldFVuaWZvcm1Mb2NhdGlvbih1bmlmb3JtTmFtZSk7XHJcbiAgICAgICAgaWYgKGxvY2F0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsLnVuaWZvcm00Zihsb2NhdGlvbiwgdmFsdWUuciwgdmFsdWUuZywgdmFsdWUuYiwgdmFsdWUuYSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIGEgM3gzIG1hdHJpeCB0byBhIHVuaWZvcm0uIElmIHRoZXJlJ3Mgbm8gdW5pZm9ybSB3aXRoIGdpdmVuIG5hbWUgaW5cclxuICAgICAqIHRoZSBwcm9ncmFtLCBzaWxlbnRseSBkb2VzIG5vdGhpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHVuaWZvcm1OYW1lIE5hbWUgb2YgdGhlIHVuaWZvcm0uXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIG1hdHJpeC5cclxuICAgICAqL1xyXG4gICAgc2V0TWF0cml4M1VuaWZvcm0odW5pZm9ybU5hbWUsIHZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgbG9jYXRpb24gPSB0aGlzLl9nZXRVbmlmb3JtTG9jYXRpb24odW5pZm9ybU5hbWUpO1xyXG4gICAgICAgIGlmIChsb2NhdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLl9nbC51bmlmb3JtTWF0cml4M2Z2KGxvY2F0aW9uLCBmYWxzZSwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBhIDR4NCBtYXRyaXggdG8gYSB1bmlmb3JtLiBJZiB0aGVyZSdzIG5vIHVuaWZvcm0gd2l0aCBnaXZlbiBuYW1lIGluXHJcbiAgICAgKiB0aGUgcHJvZ3JhbSwgc2lsZW50bHkgZG9lcyBub3RoaW5nLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB1bmlmb3JtTmFtZSBOYW1lIG9mIHRoZSB1bmlmb3JtLlxyXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSBtYXRyaXguXHJcbiAgICAgKi9cclxuICAgIHNldE1hdHJpeDRVbmlmb3JtKHVuaWZvcm1OYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IGxvY2F0aW9uID0gdGhpcy5fZ2V0VW5pZm9ybUxvY2F0aW9uKHVuaWZvcm1OYW1lKTtcclxuICAgICAgICBpZiAobG9jYXRpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5fZ2wudW5pZm9ybU1hdHJpeDRmdihsb2NhdGlvbiwgZmFsc2UsIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERlc3Ryb3lzIHRoZSBwcm9ncmFtLlxyXG4gICAgICovXHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMuX2dsLmRlbGV0ZVByb2dyYW0odGhpcy5faGFuZGxlKTtcclxuICAgIH1cclxuICAgIF9nZXRVbmlmb3JtTG9jYXRpb24obmFtZSkge1xyXG4gICAgICAgIGNvbnN0IGNhY2hlID0gdGhpcy5fdW5pZm9ybUNhY2hlO1xyXG4gICAgICAgIGxldCBsb2NhdGlvbiA9IGNhY2hlLmdldChuYW1lKTtcclxuICAgICAgICBpZiAoIWxvY2F0aW9uKSB7XHJcbiAgICAgICAgICAgIGxvY2F0aW9uID0gdGhpcy5fZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX2hhbmRsZSwgbmFtZSk7XHJcbiAgICAgICAgICAgIGlmICghbG9jYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE8gVW5jb21tZW50IGFuZCBwdXQgdW5kZXIgZGVidWcgZmxhZyAod2hlbiBpbXBsZW1lbnRlZClcclxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybihgVW5pZm9ybSAke25hbWV9IGRvZXNuJ3QgZXhpc3QgaW4gcHJvZ3JhbS5gKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhY2hlLnNldChuYW1lLCBsb2NhdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBsb2NhdGlvbjtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvZ2wvcHJvZ3JhbS50c1xuLy8gbW9kdWxlIGlkID0gNThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqIFdyYXBwZXIgYXJvdW5kIFdlYkdMUmVuZGVyYnVmZmVyIG9iamVjdHMuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbmRlcmJ1ZmZlciB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgcmVuZGVyYnVmZmVyIGluIGEgV2ViR0wgY29udGV4dC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZ2wgVGhlIGNvbnRleHQgdGhlIHJlbmRlcmJ1ZmZlciB3aWxsIGJlIGNyZWF0ZWQgaW4uXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGdsLCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgdGhpcy5fZ2wgPSBnbDtcclxuICAgICAgICB0aGlzLl9oYW5kbGUgPSBnbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcclxuICAgICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQmluZHMgdGhlIHJlbmRlcmJ1ZmZlciB0byB0aGUgV2ViR0wgY29udGV4dC5cclxuICAgICAqL1xyXG4gICAgYmluZCgpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xyXG4gICAgICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoZ2wuUkVOREVSQlVGRkVSLCB0aGlzLl9oYW5kbGUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgdGhlIHJlbmRlcmJ1ZmZlciBpcyBib3VuZCB0byB0aGUgV2ViR0wgY29udGV4dC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHJlbmRlcmJ1ZmZlciBpcyBjdXJyZW50bHkgYm91bmQgdG8gdGhlIFdlYkdMIGNvbnRleHRcclxuICAgICAqICAgICAgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxyXG4gICAgICovXHJcbiAgICBpc0JvdW5kKCkge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XHJcbiAgICAgICAgcmV0dXJuIGdsLmdldFBhcmFtZXRlcihnbC5SRU5ERVJCVUZGRVJfQklORElORykgPT09IHRoaXMuX2hhbmRsZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXR0YWNoZXMgdGhlIHJlbmRlcmJ1ZmZlciB0byBhIGN1cnJlbnRseSBib3VuZCB0byB0aGUgV2ViR0wgY29udGV4dFxyXG4gICAgICogZnJhbWVidWZmZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGF0dGFjaG1lbnRQb2ludCBBdHRhY2htZW50IHBvaW50IHRoZSByZW5kZXJidWZmZXIgd2lsbCBiZSBhdHRhY2hlZFxyXG4gICAgICogICAgICB0by5cclxuICAgICAqL1xyXG4gICAgYXR0YWNoVG9GcmFtZWJ1ZmZlcihhdHRhY2htZW50UG9pbnQpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xyXG4gICAgICAgIGdsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBhdHRhY2htZW50UG9pbnQsIGdsLlJFTkRFUkJVRkZFUiwgdGhpcy5faGFuZGxlKTtcclxuICAgIH1cclxuICAgIGdldFdpZHRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl93aWR0aDtcclxuICAgIH1cclxuICAgIGdldEhlaWdodCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXN0cm95cyB0aGUgcmVuZGVyYnVmZmVyLlxyXG4gICAgICovXHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMuX2dsLmRlbGV0ZVJlbmRlcmJ1ZmZlcih0aGlzLl9oYW5kbGUpO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9nbC9yZW5kZXJidWZmZXIudHNcbi8vIG1vZHVsZSBpZCA9IDU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHRzbGludDpkaXNhYmxlXHJcbi8qXHJcbiAgICBUaGlzIGlzIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGJ5IC90b29scy9nbF9nZW4vZ2VuX2NhcGFiaWxpdGllcy5qcyBzY3JpcHQuXHJcbiAgICBJbnN0ZWFkIG9mIG1vZGlmeWluZyBpdCBlZGl0IHRoZSBzY3JpcHQgYW5kIHJlZ2VuZXJhdGUgdGhpcyBmaWxlLlxyXG4qL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW5kZXJDb250ZXh0Q2FwYWJpbGl0aWVzTWFuYWdlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihnbCkge1xyXG4gICAgICAgIHRoaXMuX2dsID0gZ2w7XHJcbiAgICAgICAgdGhpcy5fcGFyYW1WYWx1ZXMgPSBuZXcgTWFwKCk7XHJcbiAgICB9XHJcbiAgICBnZXRBbGlhc2VkTGluZVdpZHRoUmFuZ2UoKSB7IHJldHVybiB0aGlzLl9nZXRQYXJhbSgzMzkwMiAvKiBBTElBU0VEX0xJTkVfV0lEVEhfUkFOR0UgKi8pOyB9XHJcbiAgICBnZXRBbGlhc2VkUG9pbnRTaXplUmFuZ2UoKSB7IHJldHVybiB0aGlzLl9nZXRQYXJhbSgzMzkwMSAvKiBBTElBU0VEX1BPSU5UX1NJWkVfUkFOR0UgKi8pOyB9XHJcbiAgICBnZXRNYXhDb21iaW5lZFRleHR1cmVJbWFnZVVuaXRzKCkgeyByZXR1cm4gdGhpcy5fZ2V0UGFyYW0oMzU2NjEgLyogTUFYX0NPTUJJTkVEX1RFWFRVUkVfSU1BR0VfVU5JVFMgKi8pOyB9XHJcbiAgICBnZXRNYXhDdWJlTWFwVGV4dHVyZVNpemUoKSB7IHJldHVybiB0aGlzLl9nZXRQYXJhbSgzNDA3NiAvKiBNQVhfQ1VCRV9NQVBfVEVYVFVSRV9TSVpFICovKTsgfVxyXG4gICAgZ2V0TWF4RnJhZ21lbnRVbmlmb3JtVmVjdG9ycygpIHsgcmV0dXJuIHRoaXMuX2dldFBhcmFtKDM2MzQ5IC8qIE1BWF9GUkFHTUVOVF9VTklGT1JNX1ZFQ1RPUlMgKi8pOyB9XHJcbiAgICBnZXRNYXhSZW5kZXJidWZmZXJTaXplKCkgeyByZXR1cm4gdGhpcy5fZ2V0UGFyYW0oMzQwMjQgLyogTUFYX1JFTkRFUkJVRkZFUl9TSVpFICovKTsgfVxyXG4gICAgZ2V0TWF4VGV4dHVyZUltYWdlVW5pdHMoKSB7IHJldHVybiB0aGlzLl9nZXRQYXJhbSgzNDkzMCAvKiBNQVhfVEVYVFVSRV9JTUFHRV9VTklUUyAqLyk7IH1cclxuICAgIGdldE1heFRleHR1cmVTaXplKCkgeyByZXR1cm4gdGhpcy5fZ2V0UGFyYW0oMzM3OSAvKiBNQVhfVEVYVFVSRV9TSVpFICovKTsgfVxyXG4gICAgZ2V0TWF4VmFyeWluZ1ZlY3RvcnMoKSB7IHJldHVybiB0aGlzLl9nZXRQYXJhbSgzNjM0OCAvKiBNQVhfVkFSWUlOR19WRUNUT1JTICovKTsgfVxyXG4gICAgZ2V0TWF4VmVydGV4QXR0cmlicygpIHsgcmV0dXJuIHRoaXMuX2dldFBhcmFtKDM0OTIxIC8qIE1BWF9WRVJURVhfQVRUUklCUyAqLyk7IH1cclxuICAgIGdldE1heFZlcnRleFRleHR1cmVJbWFnZVVuaXRzKCkgeyByZXR1cm4gdGhpcy5fZ2V0UGFyYW0oMzU2NjAgLyogTUFYX1ZFUlRFWF9URVhUVVJFX0lNQUdFX1VOSVRTICovKTsgfVxyXG4gICAgZ2V0TWF4VmVydGV4VW5pZm9ybVZlY3RvcnMoKSB7IHJldHVybiB0aGlzLl9nZXRQYXJhbSgzNjM0NyAvKiBNQVhfVkVSVEVYX1VOSUZPUk1fVkVDVE9SUyAqLyk7IH1cclxuICAgIGdldE1heFZpZXdwb3J0RGltcygpIHsgcmV0dXJuIHRoaXMuX2dldFBhcmFtKDMzODYgLyogTUFYX1ZJRVdQT1JUX0RJTVMgKi8pOyB9XHJcbiAgICBnZXRSZW5kZXJlcigpIHsgcmV0dXJuIHRoaXMuX2dldFBhcmFtKDc5MzcgLyogUkVOREVSRVIgKi8pOyB9XHJcbiAgICBnZXRTdWJwaXhlbEJpdHMoKSB7IHJldHVybiB0aGlzLl9nZXRQYXJhbSgzNDA4IC8qIFNVQlBJWEVMX0JJVFMgKi8pOyB9XHJcbiAgICBnZXRWZW5kb3IoKSB7IHJldHVybiB0aGlzLl9nZXRQYXJhbSg3OTM2IC8qIFZFTkRPUiAqLyk7IH1cclxuICAgIGdldFZlcnNpb24oKSB7IHJldHVybiB0aGlzLl9nZXRQYXJhbSg3OTM4IC8qIFZFUlNJT04gKi8pOyB9XHJcbiAgICAvKiogQ2FsbGluZyB0aGlzIG1ldGhvZCB3L28gYFdFQkdMX2RlYnVnX3JlbmRlcmVyX2luZm9gIGVuYWJsZWQgd2lsbCByZXR1cm4gYG51bGxgISAqL1xyXG4gICAgZ2V0VW5tYXNrZWRWZW5kb3IoKSB7IHJldHVybiB0aGlzLl9nZXRQYXJhbSgzNzQ0NSAvKiBVTk1BU0tFRF9WRU5ET1IgKi8pOyB9XHJcbiAgICAvKiogQ2FsbGluZyB0aGlzIG1ldGhvZCB3L28gYFdFQkdMX2RlYnVnX3JlbmRlcmVyX2luZm9gIGVuYWJsZWQgd2lsbCByZXR1cm4gYG51bGxgISAqL1xyXG4gICAgZ2V0VW5tYXNrZWRSZW5kZXJlcigpIHsgcmV0dXJuIHRoaXMuX2dldFBhcmFtKDM3NDQ2IC8qIFVOTUFTS0VEX1JFTkRFUkVSICovKTsgfVxyXG4gICAgX2dldFBhcmFtKHBhcmFtKSB7XHJcbiAgICAgICAgY29uc3QgcGFyYW1WYWx1ZXMgPSB0aGlzLl9wYXJhbVZhbHVlcztcclxuICAgICAgICBsZXQgcGFyYW1WYWx1ZSA9IHBhcmFtVmFsdWVzLmdldChwYXJhbSk7XHJcbiAgICAgICAgaWYgKCFwYXJhbVZhbHVlKSB7XHJcbiAgICAgICAgICAgIHBhcmFtVmFsdWUgPSB0aGlzLl9nbC5nZXRQYXJhbWV0ZXIocGFyYW0pO1xyXG4gICAgICAgICAgICBwYXJhbVZhbHVlcy5zZXQocGFyYW0sIHBhcmFtVmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGFyYW1WYWx1ZTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvY2FwYWJpbGl0aWVzLnRzXG4vLyBtb2R1bGUgaWQgPSA2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICogT3VyIGRlZmF1bHRzIGZvciB0ZXh0dXJlcyBhcmUgZGlmZmVyZW50IGZyb20gb25lcyBpbiBXZWJHTCBmb3IgdHdvIHJlYXNvbnM6XHJcbiAqIDEuIGRlZmF1bHQgbWluaWZpY2F0aW9uIGZpbHRlciBpbiBXZWJHTCBpcyBORUFSRVNUX01JUE1BUF9MSU5FQVIgd2hpY2ggcmVxdWlyZXNcclxuICogICAgdGV4dHVyZSB0byBoYXZlIGFsbCBtaXAgbGV2ZWxzIHNwZWNpZmllZDtcclxuICogMi4gZGVmYXVsdCB3cmFwIG1vZGVzIGFyZSBSRVBFQVQgd2hpY2ggaXNuJ3Qgc3VwcG9ydGVkIGZvciBOUE9UIHRleHR1cmVzLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IERFRkFVTFRfVEVYVFVSRV9QQVJBTVMgPSB7XHJcbiAgICB3cmFwUzogMzMwNzEgLyogQ0xBTVBfVE9fRURHRSAqLyxcclxuICAgIHdyYXBUOiAzMzA3MSAvKiBDTEFNUF9UT19FREdFICovLFxyXG4gICAgbWFnbmlmaWNhdGlvbkZpbHRlcjogOTcyOCAvKiBORUFSRVNUICovLFxyXG4gICAgbWluaWZpY2F0aW9uRmlsdGVyOiA5NzI4IC8qIE5FQVJFU1QgKi8sXHJcbiAgICBwcmVtdWx0aXBsaWVkQWxwaGE6IGZhbHNlXHJcbn07XHJcbi8qKiBXcmFwcGVyIGFyb3VuZCBXZWJHTFRleHR1cmUgb2JqZWN0cy4gRm9yIG5vdyBvbmx5IHdvcmtzIHdpdGggMkQgdGV4dHVyZXMuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRleHR1cmUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHRleHR1cmUgaW4gYSBXZWJHTCBjb250ZXh0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBnbCBUaGUgY29udGV4dCB0aGUgdGV4dHVyZSB3aWxsIGJlIGNyZWF0ZWQgaW4uXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGdsLCB3aWR0aCwgaGVpZ2h0LCBmb3JtYXQsIHR5cGUsIHBhcmFtcyA9IERFRkFVTFRfVEVYVFVSRV9QQVJBTVMpIHtcclxuICAgICAgICB0aGlzLl9nbCA9IGdsO1xyXG4gICAgICAgIHRoaXMuX2Zvcm1hdCA9IGZvcm1hdDtcclxuICAgICAgICB0aGlzLl90eXBlID0gdHlwZTtcclxuICAgICAgICB0aGlzLl9wYXJhbXMgPSBwYXJhbXM7XHJcbiAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5faGFuZGxlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xyXG4gICAgICAgIHRoaXMuYmluZCgpO1xyXG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIHBhcmFtcy53cmFwUyk7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgcGFyYW1zLndyYXBUKTtcclxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgcGFyYW1zLm1hZ25pZmljYXRpb25GaWx0ZXIpO1xyXG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBwYXJhbXMubWluaWZpY2F0aW9uRmlsdGVyKTtcclxuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGZvcm1hdCwgd2lkdGgsIGhlaWdodCwgMCwgZm9ybWF0LCB0eXBlLCBudWxsKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQmluZHMgdGhlIHRleHR1cmUgdG8gdGhlIFdlYkdMIGNvbnRleHQgYXMgYSAyRCB0ZXh0dXJlLlxyXG4gICAgICovXHJcbiAgICBiaW5kKCkge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XHJcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy5faGFuZGxlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIHRoZSB0ZXh0dXJlIGlzIGJvdW5kIHRvIHRoZSBXZWJHTCBjb250ZXh0LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdGV4dHVyZSBpcyBjdXJyZW50bHkgYm91bmQgdG8gdGhlIFdlYkdMIGNvbnRleHRcclxuICAgICAqICAgICAgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxyXG4gICAgICovXHJcbiAgICBpc0JvdW5kKCkge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XHJcbiAgICAgICAgcmV0dXJuIGdsLmdldFBhcmFtZXRlcihnbC5URVhUVVJFX0JJTkRJTkdfMkQpID09PSB0aGlzLl9oYW5kbGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEF0dGFjaGVzIHRoZSB0ZXh0dXJlIHRvIGEgY3VycmVudGx5IGJvdW5kIHRvIHRoZSBXZWJHTCBjb250ZXh0IGZyYW1lYnVmZmVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhdHRhY2htZW50UG9pbnQgQXR0YWNobWVudCBwb2ludCB0aGUgdGV4dHVyZSB3aWxsIGJlIGF0dGFjaGVkIHRvLlxyXG4gICAgICovXHJcbiAgICBhdHRhY2hUb0ZyYW1lYnVmZmVyKGF0dGFjaG1lbnRQb2ludCkge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XHJcbiAgICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGF0dGFjaG1lbnRQb2ludCwgZ2wuVEVYVFVSRV8yRCwgdGhpcy5faGFuZGxlLCAwKTtcclxuICAgIH1cclxuICAgIC8qKiBSZXR1cm5zIHdpZHRoIG9mIHRoZSB0ZXh0dXJlLiAqL1xyXG4gICAgZ2V0V2lkdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dpZHRoO1xyXG4gICAgfVxyXG4gICAgLyoqIFJldHVybnMgaGVpZ2h0IG9mIHRoZSB0ZXh0dXJlLiAqL1xyXG4gICAgZ2V0SGVpZ2h0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XHJcbiAgICB9XHJcbiAgICAvKiogUmV0dXJucyBwaXhlbCBmb3JtYXQgb2YgdGhlIHRleHR1cmUuICovXHJcbiAgICBnZXRGb3JtYXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Zvcm1hdDtcclxuICAgIH1cclxuICAgIC8qKiBSZXR1cm4gcGl4ZWwgdHlwZSBvZiB0aGUgdGV4dHVyZS4gKi9cclxuICAgIGdldFR5cGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGU7XHJcbiAgICB9XHJcbiAgICAvKiogUmV0dXJuIHBhcmFtcyBvZiB0aGUgdGV4dHVyZS4gKi9cclxuICAgIGdldFBhcmFtcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcGFyYW1zO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXN0cm95cyB0aGUgdGV4dHVyZS5cclxuICAgICAqL1xyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLl9nbC5kZWxldGVUZXh0dXJlKHRoaXMuX2hhbmRsZSk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL2dsL3RleHR1cmUudHNcbi8vIG1vZHVsZSBpZCA9IDYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiBXcmFwcGVyIGFyb3VuZCB2ZXJ0ZXggYXJyYXkgKFZBTykgb2JqZWN0IGZyb20gYE9FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0YFxyXG4gKiBleHRlbnNpb24uXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWZXJ0ZXhBcnJheU9iamVjdCB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgbmV3IFZBTyBpbiBhIGdpdmVuIFdlYkdMIGNvbnRleHQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGdsIFRoZSBjb250ZXh0LlxyXG4gICAgICogQHBhcmFtIHZhb0V4dCBJbnN0YW5jZSBvZiBgT0VTX3ZlcnRleF9hcnJheV9vYmplY3RgIGV4dGVuc2lvbi5cclxuICAgICAqIEBwYXJhbSBhdHRyaWJ1dGVNYXBwaW5nIE1hcHBpbmcgb2YgYXR0cmlidXRlcy5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZ2wsIHZhb0V4dCwgYXR0cmlidXRlTWFwcGluZykge1xyXG4gICAgICAgIHRoaXMuX2dsID0gZ2w7XHJcbiAgICAgICAgdGhpcy5fdmFvRXh0ID0gdmFvRXh0O1xyXG4gICAgICAgIHRoaXMuX2hhbmRsZSA9IHZhb0V4dC5jcmVhdGVWZXJ0ZXhBcnJheU9FUygpO1xyXG4gICAgICAgIHRoaXMuYXR0cmlidXRlTWFwcGluZyA9IGF0dHJpYnV0ZU1hcHBpbmc7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEJpbmRzIHRoZSBWQU8gdG8gdGhlIGNvbnRleHQuXHJcbiAgICAgKi9cclxuICAgIGJpbmQoKSB7XHJcbiAgICAgICAgdGhpcy5fdmFvRXh0LmJpbmRWZXJ0ZXhBcnJheU9FUyh0aGlzLl9oYW5kbGUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgdGhlIFZBTyBpcyBjdXJyZW50bHkgYm91bmQgdG8gdGhlIGNvbnRleHQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBWQU8gaXMgY3VycmVudGx5IGJvdW5kIHRvIHRoZSBXZWJHTCBjb250ZXh0IGFuZFxyXG4gICAgICogICAgICBgZmFsc2VgIG90aGVyd2lzZS5cclxuICAgICAqL1xyXG4gICAgaXNCb3VuZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2wuZ2V0UGFyYW1ldGVyKHRoaXMuX3Zhb0V4dC5WRVJURVhfQVJSQVlfQklORElOR19PRVMpID09PVxyXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERlc3Ryb3lzIHRoZSBWQU8uXHJcbiAgICAgKi9cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5fdmFvRXh0LmRlbGV0ZVZlcnRleEFycmF5T0VTKHRoaXMuX2hhbmRsZSk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL2dsL3Zhby50c1xuLy8gbW9kdWxlIGlkID0gNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgY2xhbXAsIGN5Y2xlUmVzdHJpY3QgfSBmcm9tICcuL21hdGgvc2NhbGFyJztcclxuaW1wb3J0IHsgZGVnMnJhZCB9IGZyb20gJy4vdXRpbC9yYWRfZGVnJztcclxuaW1wb3J0IGdldEZ1bGxPcHRpb25zIGZyb20gJy4vdXRpbC9vcHRpb25zJztcclxuaW1wb3J0ICogYXMgbWF0NCBmcm9tICcuL21hdGgvbWF0cml4NCc7XHJcbmltcG9ydCB7IHNtb290aFN0ZXAgfSBmcm9tICcuL21hdGgvc2NhbGFyJztcclxuaW1wb3J0ICogYXMgdmVjMiBmcm9tICcuL21hdGgvdmVjdG9yMic7XHJcbmltcG9ydCAqIGFzIHZlYzMgZnJvbSAnLi9tYXRoL3ZlY3RvcjMnO1xyXG5pbXBvcnQgeyBWb2lkRXZlbnRFbWl0dGVyIH0gZnJvbSAnLi91dGlsL2V2ZW50X2VtaXR0ZXInO1xyXG4vLyBUT0RPKGRtaWtpcykgV2Ugd2FudCB0byBjb25zdHJhaW50IGNvb3JkaW5hdGVzIHNvIHZpc2libGUgcmVnaW9uIGRvZXNuJ3QgZXh0ZW5kXHJcbi8vICAgICAgb3V0IG9mIHdvcmxkIGJvdW5kYXJpZXMuIEhvd2V2ZXIsIGluIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gaXQgZG9lc24ndFxyXG4vLyAgICAgIHdvcmsgcHJvcGVybHkgZm9yIGFzcGVjdCByYXRpb3MgPjEgb24gem9vbSAwIHNpbmNlIHZpc2libGUgcmVnaW9uIGlzXHJcbi8vICAgICAgbGFyZ2VyIHRoYXQgdGhlIHdvcmxkIGl0c2VsZiAoc28gdGhlcmUncyBubyB3YXkgdG8gc3F1ZWV6ZSBpdCBpbikuIEZvclxyXG4vLyAgICAgIHRoZSBjdXJyZW50IGNhc2UgKGkuZS4gY3ljbGVkIGluIGhvcml6b250YWwgZGlyZWN0aW9uKSBpdCBpcyBub3QgYSBwcm9ibGVtLlxyXG5jb25zdCBNQVhfVElMVCA9IGRlZzJyYWQoNDApO1xyXG4vKipcclxuICogSWYgYSBjYW1lcmEgaGFzIHpvb20gbGVzcyB0aGFuIG9mIGVxdWFsIHRvIGBOT19USUxUX01BWF9aT09NYCwgdGlsdCB3b24ndCBiZVxyXG4gKiBhbGxvd2VkLlxyXG4gKi9cclxuY29uc3QgTk9fVElMVF9NQVhfWk9PTSA9IDE7XHJcbi8qKlxyXG4gKiBJZiBhIGNhbWVyYSBoYXMgem9vbSBncmVhdGVyIHRoYW4gb2YgZXF1YWwgdG8gYEZVTExfVElMVF9NSU5fWk9PTWAsIHRpbHQgd2lsbFxyXG4gKiBiZSBhbGxvd2VkIHVwIHRvIGBNQVhfVElMVGAuXHJcbiAqL1xyXG5jb25zdCBGVUxMX1RJTFRfTUlOX1pPT00gPSBOT19USUxUX01BWF9aT09NICsgMTtcclxuY29uc3QgRlJVU1RVTV9ESVJFQ1RJT05TID0gW1xyXG4gICAgLy8gdHNsaW50OmRpc2FibGVcclxuICAgIHZlYzMuY3JlYXRlKC0xLCAxLCAtMSksXHJcbiAgICB2ZWMzLmNyZWF0ZSgxLCAxLCAtMSksXHJcbiAgICB2ZWMzLmNyZWF0ZSgxLCAtMSwgLTEpLFxyXG4gICAgdmVjMy5jcmVhdGUoLTEsIC0xLCAtMSlcclxuICAgIC8vIHRzbGludDplbmFibGVcclxuXTtcclxuLyoqXHJcbiAqIEhvdyBiaWcgdGhlIHdvcmxkIHNvdWxkIGJlIG9uIGEgc2NyZWVuIGlmIHpvb20gaXMgMCwgaW4gZGV2aWNlIGluZGVwZW5kZW50IHBpeGVsc1xyXG4gKi9cclxuY29uc3QgWk9PTV8wX1dPUkxEX0NTU19QSVhFTF9TSVpFID0gMjU2O1xyXG5jb25zdCBERUZBVUxUX09QVElPTlMgPSB7XHJcbiAgICB3cmFwTW9kZVg6IDEgLyogQ0xBTVBfVE9fRURHRSAqLyxcclxuICAgIHdyYXBNb2RlWTogMSAvKiBDTEFNUF9UT19FREdFICovLFxyXG4gICAgbWluWm9vbTogMCxcclxuICAgIG1heFpvb206IDI0LFxyXG4gICAgZm92OiBkZWcycmFkKDMwKVxyXG59O1xyXG4vKipcclxuICogUmVzdHJpY3RzIGEgbmV3IHZhbHVlIGZvciBhIGNlbnRlcidzIGNvb3JkaW5hdGUgYWNjb3JkaW5nIHRvIGdpdmVuIHdyYXAgbW9kZS5cclxuICpcclxuICogQHBhcmFtIHdyYXBNb2RlIFRoZSB3cmFwIG1vZGUuXHJcbiAqIEBwYXJhbSBuZXdDb29yZGluYXRlIFRoZSBuZXcgdmFsdWUuXHJcbiAqIEBwYXJhbSBvbGRDb29yZGluYXRlIEN1cnJlbnQgdmFsdWUgb2YgdGhlIGNvb3JkaW5hdGUuXHJcbiAqIEBwYXJhbSBiYm94TWluIE1pbmltdW0gY29ycmVzcG9uZGluZyBjb29yZGluYXRlIG9mIGJvdW5kaW5nIGJveCBvZiB0aGVcclxuICogICAgICB2aXNpYmxlIHF1YWRyaWxhdGVyYWwuXHJcbiAqIEBwYXJhbSBiYm94TWF4IE1heGltdW0gY29ycmVzcG9uZGluZyBjb29yZGluYXRlIG9mIGJvdW5kaW5nIGJveCBvZiB0aGVcclxuICogICAgICB2aXNpYmxlIHF1YWRyaWxhdGVyYWwuXHJcbiAqIEByZXR1cm5zIFJlc3RyaWN0ZWQgdmFsdWUgZm9yIHRoZSBjb29yZGluYXRlLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVzdHJpY3RDb29yZGluYXRlKHdyYXBNb2RlLCBuZXdDb29yZGluYXRlKSB7XHJcbiAgICBzd2l0Y2ggKHdyYXBNb2RlKSB7XHJcbiAgICAgICAgY2FzZSAwIC8qIE5PTkUgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBuZXdDb29yZGluYXRlO1xyXG4gICAgICAgIGNhc2UgMSAvKiBDTEFNUF9UT19FREdFICovOlxyXG4gICAgICAgICAgICByZXR1cm4gY2xhbXAobmV3Q29vcmRpbmF0ZSwgLTEsIDEpO1xyXG4gICAgICAgIGNhc2UgMiAvKiBSRVBFQVQgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBjeWNsZVJlc3RyaWN0KG5ld0Nvb3JkaW5hdGUsIC0xLCAxKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ2FtZXJhIHJlcHJlc2VudHMgdXNlcidzIHBvaW50IG9mIHZpZXcgaW4gdGhlIHdvcmxkIHNwYWNlLCBhcyBhIHJlYWwgY2FtZXJhIGl0IGhhcyByZXN0cmljdGVkIGZpZWxkIG9mIHZpZXcsXHJcbiAqIGl0IGNhbiBtb3ZlIGFuZCByb3RhdGUgKHdpdGggb3Igd2l0aG91dCBhbmltYXRpb24pLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2FtZXJhIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBjYW1lcmEuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucy5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IGdldEZ1bGxPcHRpb25zKERFRkFVTFRfT1BUSU9OUywgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5jZW50ZXIgPSBuZXcgQ2FtZXJhLl9DZW50ZXIodGhpcyk7XHJcbiAgICAgICAgdGhpcy5vblVwZGF0ZSA9IG5ldyBWb2lkRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgY29uc3Qgc2NyZWVuU2l6ZSA9IG5ldyBDYW1lcmEuX1NjcmVlblNpemUodGhpcyk7XHJcbiAgICAgICAgdGhpcy5zY3JlZW5TaXplID0gc2NyZWVuU2l6ZTtcclxuICAgICAgICB0aGlzLl9kaXN0YW5jZVRvQ2VudGVyID0gMTtcclxuICAgICAgICB0aGlzLl96b29tID0gdGhpcy5vcHRpb25zLm1pblpvb207XHJcbiAgICAgICAgdGhpcy5fdGlsdCA9IHRoaXMuX2F6aW11dGggPSAwO1xyXG4gICAgICAgIHRoaXMuX2RpcnR5Qml0cyA9IC0xIC8qIEFMTCAqLztcclxuICAgICAgICB0aGlzLl92aWV3UHJvak1hdHJpeCA9IG1hdDQuY29weShtYXQ0LklERU5USVRZKTtcclxuICAgICAgICB0aGlzLl92aXNpYmxlUXVhZHJpbGF0ZXJhbCA9IFtcclxuICAgICAgICAgICAgdmVjMy5jcmVhdGUoMCwgMCwgMCksXHJcbiAgICAgICAgICAgIHZlYzMuY3JlYXRlKDAsIDAsIDApLFxyXG4gICAgICAgICAgICB2ZWMzLmNyZWF0ZSgwLCAwLCAwKSxcclxuICAgICAgICAgICAgdmVjMy5jcmVhdGUoMCwgMCwgMClcclxuICAgICAgICBdO1xyXG4gICAgICAgIHRoaXMuX3Zpc2libGVRdWFkcmlsYXRlcmFsQkJveCA9XHJcbiAgICAgICAgICAgIHZlYzIuY29tcHV0ZUJCb3hGb3JQb2ludHModGhpcy5fdmlzaWJsZVF1YWRyaWxhdGVyYWwpO1xyXG4gICAgICAgIHRoaXMuX3BpeGVsU2l6ZSA9IHZlYzIuY3JlYXRlKDAsIDApO1xyXG4gICAgfVxyXG4gICAgZ2V0IGFzcGVjdFJhdGlvKCkge1xyXG4gICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdGhpcy5zY3JlZW5TaXplO1xyXG4gICAgICAgIGlmIChoZWlnaHQgIT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHdpZHRoIC8gaGVpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gd2hlbiBoZWlnaHQgPT0gMCB3ZSBjYW5ub3QgY29tcHV0ZSB2aWV3UHJvaiBtYXRyaXggb3IgdmlzaWJsZSByZWdpb24sIDEgYWxsb3dzIHRvIGhhbmRsZSB0aGlzIGNhc2Ugd2l0aFxyXG4gICAgICAgICAgICAvLyBubyBleGNlcHRpb25zIHRocm93biwgYnV0IHRlY2huaWNhbGx5IGl0IGlzIG5vdCBjb3JyZWN0IGFuZCBzaG91bGQgYmUgcmVjb25zaWRlcmVkIGlmIGFueSBpc3N1ZSBpcyBmb3VuZFxyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgem9vbSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fem9vbTtcclxuICAgIH1cclxuICAgIGdldCB3b3JsZFRvUHhGYWN0b3IoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dvcmxkVG9QeEZhY3RvcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBuZXcgem9vbSB0byB0aGUgY2FtZXJhIHdpdGggcmVzcGVjdCB0byBwcm92aWRlZCBsaW1pdHMgaW4gdGhlIG9wdGlvbnMuXHJcbiAgICAgKi9cclxuICAgIHNldCB6b29tKG5ld1pvb20pIHtcclxuICAgICAgICBuZXdab29tID0gY2xhbXAobmV3Wm9vbSwgdGhpcy5vcHRpb25zLm1pblpvb20sIHRoaXMub3B0aW9ucy5tYXhab29tKTtcclxuICAgICAgICBpZiAobmV3Wm9vbSAhPT0gdGhpcy5fem9vbSkge1xyXG4gICAgICAgICAgICB0aGlzLl96b29tID0gbmV3Wm9vbTtcclxuICAgICAgICAgICAgdGhpcy5fY29tcHV0ZURpc3RhbmNlVG9DZW50ZXIoKTtcclxuICAgICAgICAgICAgLy8gQ29uc3RyYWludHMgb24gdGlsdCBtYXkgaGF2ZSBjaGFuZ2VkLCB3ZSBuZWVkIHRvIHJlY29tcHV0ZSBpdC5cclxuICAgICAgICAgICAgdGhpcy5fdGlsdCA9IHRoaXMuX2NvbnN0cmFpblRpbHQodGhpcy5fdGlsdCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3dvcmxkVG9QeEZhY3RvciA9IDIuMCAvIChaT09NXzBfV09STERfQ1NTX1BJWEVMX1NJWkUgKiBNYXRoLnBvdygyLCBuZXdab29tKSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldERpcnR5Qml0cygxIC8qIFZJRVdfUFJPSl9NQVRSSVggKi8gfCAyIC8qIFZJU0lCTEVfUVVBRFJJTEFURVJBTCAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0IHRpbHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RpbHQ7XHJcbiAgICB9XHJcbiAgICBzZXQgdGlsdChuZXdUaWx0KSB7XHJcbiAgICAgICAgbmV3VGlsdCA9IHRoaXMuX2NvbnN0cmFpblRpbHQobmV3VGlsdCk7XHJcbiAgICAgICAgaWYgKHRoaXMuX3RpbHQgIT09IG5ld1RpbHQpIHtcclxuICAgICAgICAgICAgdGhpcy5fdGlsdCA9IG5ld1RpbHQ7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldERpcnR5Qml0cygxIC8qIFZJRVdfUFJPSl9NQVRSSVggKi8gfCAyIC8qIFZJU0lCTEVfUVVBRFJJTEFURVJBTCAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0IGF6aW11dGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2F6aW11dGg7XHJcbiAgICB9XHJcbiAgICBzZXQgYXppbXV0aChuZXdBemltdXRoKSB7XHJcbiAgICAgICAgbmV3QXppbXV0aCA9IGN5Y2xlUmVzdHJpY3QobmV3QXppbXV0aCwgMCwgMiAqIE1hdGguUEkpO1xyXG4gICAgICAgIGlmICh0aGlzLl9hemltdXRoICE9PSBuZXdBemltdXRoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2F6aW11dGggPSBuZXdBemltdXRoO1xyXG4gICAgICAgICAgICB0aGlzLl9zZXREaXJ0eUJpdHMoMSAvKiBWSUVXX1BST0pfTUFUUklYICovIHwgMiAvKiBWSVNJQkxFX1FVQURSSUxBVEVSQUwgKi8pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2l6ZSBvZiBhIHBpeGVsIGluIE5EQy5cclxuICAgICAqL1xyXG4gICAgZ2V0IHBpeGVsU2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcGl4ZWxTaXplO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnZhbGlkYXRlIGFsbCBpbnRlcm5hbGx5IGNhY2hlZCB2YWx1ZXMgKGUuZy4gdmlldyBtYXRyaXgpLlxyXG4gICAgICovXHJcbiAgICBzZXREaXJ0eSgpIHtcclxuICAgICAgICB0aGlzLl9zZXREaXJ0eUJpdHMoLTEgLyogQUxMICovKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVjb21wdXRlcyAoaWYgbmVlZGVkKSB0aGUgdmlldyBwcm9qZWN0aW9uIG1hdHJpeC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgdmlldy1wcm9qZWN0aW9uIG1hdHJpeC5cclxuICAgICAqL1xyXG4gICAgZ2V0Vmlld1Byb2pNYXRyaXgoKSB7XHJcbiAgICAgICAgY29uc3Qgdmlld1Byb2pNYXRyaXggPSB0aGlzLl92aWV3UHJvak1hdHJpeDtcclxuICAgICAgICBpZiAodGhpcy5fZGlydHlCaXRzICYgMSAvKiBWSUVXX1BST0pfTUFUUklYICovKSB7XHJcbiAgICAgICAgICAgIG1hdDQuY29weShtYXQ0LklERU5USVRZLCB2aWV3UHJvak1hdHJpeCk7XHJcbiAgICAgICAgICAgIG1hdDQubG9va0F0KHZpZXdQcm9qTWF0cml4LCB0aGlzLl9jb21wdXRlQ2VudGVyVG9DYW1lcmFWZWN0b3IoKSwgdmVjMy5PUklHSU4sIHZlYzMucm90YXRlWih2ZWMzLlBPU0lUSVZFX1ksIHRoaXMuX2F6aW11dGgpLCB2aWV3UHJvak1hdHJpeCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgZm92IH0gPSB0aGlzLm9wdGlvbnM7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhbkZhY3RvcnMgPSBNYXRoLnRhbih0aGlzLl90aWx0KSAqIE1hdGgudGFuKDAuNSAqIGZvdik7XHJcbiAgICAgICAgICAgIG1hdDQucGVyc3BlY3RpdmUodmlld1Byb2pNYXRyaXgsIGZvdiwgdGhpcy5hc3BlY3RSYXRpbywgTWF0aC5taW4odGhpcy5fZGlzdGFuY2VUb0NlbnRlciAqIDAuMDEsIHRoaXMuX2Rpc3RhbmNlVG9DZW50ZXIgLyAoMSArIHRhbkZhY3RvcnMpKSwgdGhpcy5fZGlzdGFuY2VUb0NlbnRlciAvICgxIC0gdGFuRmFjdG9ycyksIHZpZXdQcm9qTWF0cml4KTtcclxuICAgICAgICAgICAgdGhpcy5fZGlydHlCaXRzICY9IH4xIC8qIFZJRVdfUFJPSl9NQVRSSVggKi87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2aWV3UHJvak1hdHJpeDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVjb21wdXRlcyAoaWYgbmVlZGVkKSBhbmQgcmV0dXJucyBxdWFkcmlsYXRlcmFsIGN1dCBvbiB0aGUgd29ybGQgcGxhbmVcclxuICAgICAqIGJ5IGZydXN0dW0gb2YgdGhlIGNhbWVyYS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIFRoZSBxdWFkcmlsYXRlcmFsIGVuY2xvc2luZyB2aXNpYmxlIHBhcnQgb2YgdGhlIHdvcmxkIHBsYW5lLlxyXG4gICAgICovXHJcbiAgICBnZXRWaXNpYmxlUmVnaW9uKCkge1xyXG4gICAgICAgIHRoaXMuX2NvbXB1dGVWaXNpYmxlUXVhZHJpbGF0ZXJhbCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpYmxlUXVhZHJpbGF0ZXJhbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVjb21wdXRlcyAoaWYgbmVlZGVkKSBhbmQgcmV0dXJucyBib3VuZGluZyBib3ggb2YgdGhlIHZpc2libGUgcmVnaW9uLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4gQm91bmRpbmcgYm94IG9mIHRoZSB2aXNpYmxlIHF1YWRyaWxhdGVyYWwuXHJcbiAgICAgKi9cclxuICAgIGdldFZpc2libGVSZWdpb25CQm94KCkge1xyXG4gICAgICAgIHRoaXMuX2NvbXB1dGVWaXNpYmxlUXVhZHJpbGF0ZXJhbCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpYmxlUXVhZHJpbGF0ZXJhbEJCb3g7XHJcbiAgICB9XHJcbiAgICBfY29uc3RyYWluVGlsdCh0aWx0KSB7XHJcbiAgICAgICAgcmV0dXJuIGNsYW1wKHRpbHQsIDAsIE1BWF9USUxUICogc21vb3RoU3RlcChOT19USUxUX01BWF9aT09NLCBGVUxMX1RJTFRfTUlOX1pPT00sIHRoaXMuX3pvb20pKTtcclxuICAgIH1cclxuICAgIF9zZXREaXJ0eUJpdHMoYml0cykge1xyXG4gICAgICAgIGlmIChiaXRzIF4gKGJpdHMgJiB0aGlzLl9kaXJ0eUJpdHMpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RpcnR5Qml0cyB8PSBiaXRzO1xyXG4gICAgICAgICAgICB0aGlzLm9uVXBkYXRlLmZpcmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfY29tcHV0ZURpc3RhbmNlVG9DZW50ZXIoKSB7XHJcbiAgICAgICAgdGhpcy5fZGlzdGFuY2VUb0NlbnRlciA9XHJcbiAgICAgICAgICAgIHRoaXMuc2NyZWVuU2l6ZS5oZWlnaHQgKiBNYXRoLnBvdygyLCAtdGhpcy5fem9vbSkgL1xyXG4gICAgICAgICAgICAgICAgKE1hdGgudGFuKDAuNSAqIHRoaXMub3B0aW9ucy5mb3YpICogWk9PTV8wX1dPUkxEX0NTU19QSVhFTF9TSVpFKTtcclxuICAgIH1cclxuICAgIF9jb21wdXRlQ2VudGVyVG9DYW1lcmFWZWN0b3IoZHN0ID0gdmVjMy5jcmVhdGUoMCwgMCwgMCkpIHtcclxuICAgICAgICB2ZWMzLm11bG4odmVjMy5QT1NJVElWRV9aLCB0aGlzLl9kaXN0YW5jZVRvQ2VudGVyLCBkc3QpO1xyXG4gICAgICAgIHZlYzMucm90YXRlWChkc3QsIHRoaXMuX3RpbHQsIGRzdCk7XHJcbiAgICAgICAgdmVjMy5yb3RhdGVaKGRzdCwgdGhpcy5fYXppbXV0aCwgZHN0KTtcclxuICAgICAgICByZXR1cm4gZHN0O1xyXG4gICAgfVxyXG4gICAgX2NvbXB1dGVWaXNpYmxlUXVhZHJpbGF0ZXJhbCgpIHtcclxuICAgICAgICBpZiAodGhpcy5fZGlydHlCaXRzICYgMiAvKiBWSVNJQkxFX1FVQURSSUxBVEVSQUwgKi8pIHtcclxuICAgICAgICAgICAgY29uc3QgdmlzaWJsZVF1YWRyaWxhdGVyYWwgPSB0aGlzLl92aXNpYmxlUXVhZHJpbGF0ZXJhbDtcclxuICAgICAgICAgICAgY29uc3QgaGFsZkZvdlRhbiA9IE1hdGgudGFuKDAuNSAqIHRoaXMub3B0aW9ucy5mb3YpO1xyXG4gICAgICAgICAgICBjb25zdCBvcmlnaW4gPSB0aGlzLl9jb21wdXRlQ2VudGVyVG9DYW1lcmFWZWN0b3IoKTtcclxuICAgICAgICAgICAgdmVjMi5hZGQob3JpZ2luLCB0aGlzLmNlbnRlciwgb3JpZ2luKTtcclxuICAgICAgICAgICAgY29uc3Qgc2NhbGUgPSB2ZWMzLmNyZWF0ZShoYWxmRm92VGFuICogdGhpcy5hc3BlY3RSYXRpbywgaGFsZkZvdlRhbiwgMSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IHZlYzMuY3JlYXRlKDAsIDAsIDApO1xyXG4gICAgICAgICAgICBjb25zdCByYXkgPSB7IG9yaWdpbiwgZGlyZWN0aW9uIH07XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICB2ZWMzLm11bHYoRlJVU1RVTV9ESVJFQ1RJT05TW2ldLCBzY2FsZSwgZGlyZWN0aW9uKTtcclxuICAgICAgICAgICAgICAgIHZlYzMucm90YXRlWChkaXJlY3Rpb24sIHRoaXMuX3RpbHQsIGRpcmVjdGlvbik7XHJcbiAgICAgICAgICAgICAgICB2ZWMzLnJvdGF0ZVooZGlyZWN0aW9uLCB0aGlzLl9hemltdXRoLCBkaXJlY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF2ZWMzLmdldFBsYW5lUmF5SW50ZXJzZWN0aW9uKHZlYzMuWFksIHJheSwgdmlzaWJsZVF1YWRyaWxhdGVyYWxbaV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWaXNpYmxlIHF1YWRyaWxhdGVyYWwgaXMgdW5ib3VuZGVkLCBlbmdpbmUgY2FuXFwndCBoYW5kbGUgdGhhdCBjYXNlICh5ZXQpJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmVjMi5jb21wdXRlQkJveEZvclBvaW50cyh2aXNpYmxlUXVhZHJpbGF0ZXJhbCwgdGhpcy5fdmlzaWJsZVF1YWRyaWxhdGVyYWxCQm94KTtcclxuICAgICAgICAgICAgdGhpcy5fZGlydHlCaXRzICY9IH4yIC8qIFZJU0lCTEVfUVVBRFJJTEFURVJBTCAqLztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEltcGxlbWVudGF0aW9uIG9mIGEgY2VudGVyIHZlY3RvciBvZiBhIGNhbWVyYS4gVGFrZXMgaW50byBhY2NvdW50IHdyYXBwaW5nXHJcbiAqIG1vZGVzIGFuZCB1cGRhdGVzIGNhbWVyYSdzIGRpcnR5IGZsYWdzLlxyXG4gKi9cclxuQ2FtZXJhLl9DZW50ZXIgPSBjbGFzcyB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgbmV3IGNlbnRlciB2ZWN0b3IgZm9yIGEgY2FtZXJhLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjYW1lcmEgVGhlIGNhbWVyYS5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoY2FtZXJhKSB7XHJcbiAgICAgICAgdGhpcy5fY2FtZXJhID0gY2FtZXJhO1xyXG4gICAgICAgIHRoaXMuX3ggPSB0aGlzLl95ID0gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVmFsdWVzIG9mIGFic2Npc3NhIG9mIHRoZSBjZW50ZXIgdmVjdG9yLlxyXG4gICAgICovXHJcbiAgICBnZXQgeCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5feDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUHJvcGVybHkgY2xhbXBzIG9yIHdyYXBzIG5ldyBhYnNjaXNzYSB2YWx1ZSBhbmQgc2V0cyBpdCB0byB0aGUgdmVjdG9yLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBuZXdYIFRoZSBuZXdcclxuICAgICAqL1xyXG4gICAgc2V0IHgobmV3WCkge1xyXG4gICAgICAgIGNvbnN0IGNhbWVyYSA9IHRoaXMuX2NhbWVyYTtcclxuICAgICAgICBuZXdYID0gcmVzdHJpY3RDb29yZGluYXRlKGNhbWVyYS5vcHRpb25zLndyYXBNb2RlWCwgbmV3WCk7XHJcbiAgICAgICAgaWYgKHRoaXMuX3ggIT09IG5ld1gpIHtcclxuICAgICAgICAgICAgdGhpcy5feCA9IG5ld1g7XHJcbiAgICAgICAgICAgIGNhbWVyYS5fc2V0RGlydHlCaXRzKDIgLyogVklTSUJMRV9RVUFEUklMQVRFUkFMICovKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFZhbHVlcyBvZiBvcmRpbmF0ZSBvZiB0aGUgY2VudGVyIHZlY3Rvci5cclxuICAgICAqL1xyXG4gICAgZ2V0IHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3k7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFByb3Blcmx5IGNsYW1wcyBvciB3cmFwcyBuZXcgb3JkaW5hdGUgdmFsdWUgYW5kIHNldHMgaXQgdG8gdGhlIHZlY3Rvci5cclxuICAgICAqL1xyXG4gICAgc2V0IHkobmV3WSkge1xyXG4gICAgICAgIGNvbnN0IGNhbWVyYSA9IHRoaXMuX2NhbWVyYTtcclxuICAgICAgICBuZXdZID0gcmVzdHJpY3RDb29yZGluYXRlKGNhbWVyYS5vcHRpb25zLndyYXBNb2RlWSwgbmV3WSk7XHJcbiAgICAgICAgaWYgKHRoaXMuX3kgIT09IG5ld1kpIHtcclxuICAgICAgICAgICAgdGhpcy5feSA9IG5ld1k7XHJcbiAgICAgICAgICAgIGNhbWVyYS5fc2V0RGlydHlCaXRzKDIgLyogVklTSUJMRV9RVUFEUklMQVRFUkFMICovKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbkNhbWVyYS5fU2NyZWVuU2l6ZSA9IGNsYXNzIHtcclxuICAgIGNvbnN0cnVjdG9yKGNhbWVyYSkge1xyXG4gICAgICAgIHRoaXMuX2NhbWVyYSA9IGNhbWVyYTtcclxuICAgICAgICB0aGlzLl93aWR0aCA9IHRoaXMuX2hlaWdodCA9IDA7XHJcbiAgICB9XHJcbiAgICBnZXQgd2lkdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dpZHRoO1xyXG4gICAgfVxyXG4gICAgc2V0IHdpZHRoKG5ld1dpZHRoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3dpZHRoICE9PSBuZXdXaWR0aCkge1xyXG4gICAgICAgICAgICB0aGlzLl93aWR0aCA9IG5ld1dpZHRoO1xyXG4gICAgICAgICAgICBjb25zdCBjYW1lcmEgPSB0aGlzLl9jYW1lcmE7XHJcbiAgICAgICAgICAgIGNhbWVyYS5fc2V0RGlydHlCaXRzKDEgLyogVklFV19QUk9KX01BVFJJWCAqLyB8IDIgLyogVklTSUJMRV9RVUFEUklMQVRFUkFMICovKTtcclxuICAgICAgICAgICAgY2FtZXJhLl9waXhlbFNpemUueCA9IDIuMCAvIHRoaXMuX3dpZHRoO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCBoZWlnaHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlaWdodDtcclxuICAgIH1cclxuICAgIHNldCBoZWlnaHQobmV3SGVpZ2h0KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2hlaWdodCAhPT0gbmV3SGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2hlaWdodCA9IG5ld0hlaWdodDtcclxuICAgICAgICAgICAgY29uc3QgY2FtZXJhID0gdGhpcy5fY2FtZXJhO1xyXG4gICAgICAgICAgICBjYW1lcmEuX2NvbXB1dGVEaXN0YW5jZVRvQ2VudGVyKCk7XHJcbiAgICAgICAgICAgIGNhbWVyYS5fc2V0RGlydHlCaXRzKDEgLyogVklFV19QUk9KX01BVFJJWCAqLyB8IDIgLyogVklTSUJMRV9RVUFEUklMQVRFUkFMICovKTtcclxuICAgICAgICAgICAgY2FtZXJhLl9waXhlbFNpemUueSA9IDIuMCAvIHRoaXMuX2hlaWdodDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2NhbWVyYS50c1xuLy8gbW9kdWxlIGlkID0gNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiY29uc3QgREVHX1RPX1JBRCA9IE1hdGguUEkgLyAxODA7XHJcbmV4cG9ydCBmdW5jdGlvbiBkZWcycmFkKHgpIHtcclxuICAgIHJldHVybiB4ICogREVHX1RPX1JBRDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gcmFkMmRlZyh4KSB7XHJcbiAgICByZXR1cm4geCAvIERFR19UT19SQUQ7XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9yYWRfZGVnLnRzXG4vLyBtb2R1bGUgaWQgPSA2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICogUmVzb2x2ZXMgb3B0aW9ucy5cclxuICpcclxuICogQHBhcmFtIGRlZmF1bHRPcHRpb25zIE9iamVjdCB3aXRoIGRlZmF1bHQgdmFsdWVzLlxyXG4gKiBAcGFyYW0gb3B0aW9ucyBPYmplY3Qgd2l0aCBjdXN0b20gdmFsdWVzIGZvciBvcHRpb25zLiBMYXRlciBvYmplY3RzIFwib3ZlcnJpZGVcIlxyXG4gKiAgICAgIGZvcm1lciBvbmVzLlxyXG4gKiBAcmV0dXJucyBOZXcgb2JqZWN0IGNvbnRhaW5pbmcgcmVzb2x2ZWQgb3B0aW9ucy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEZ1bGxPcHRpb25zKGRlZmF1bHRPcHRpb25zLCAuLi5vcHRpb25zKSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIC4uLm9wdGlvbnMpO1xyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvb3B0aW9ucy50c1xuLy8gbW9kdWxlIGlkID0gNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICogYXMgdmVjdG9yMyBmcm9tICcuL3ZlY3RvcjMnO1xyXG5jb25zdCBNQVRSSVhfU0laRSA9IDk7XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgbmV3ICoqdW5pbml0aWFsaXplZCoqIG1hdHJpeC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoKSB7XHJcbiAgICByZXR1cm4gbmV3IEFycmF5KE1BVFJJWF9TSVpFKTtcclxufVxyXG4vKipcclxuICogWmVyb2VzIGEgbWF0cml4LlxyXG4gKlxyXG4gKiBAcGFyYW0gZHN0IFRoZSBtYXRyaXguXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHplcm8oZHN0ID0gY3JlYXRlKCkpIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTUFUUklYX1NJWkU7ICsraSkge1xyXG4gICAgICAgIGRzdFtpXSA9IDA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbi8qKlxyXG4gKiBDb3BpZXMgdGhyZWUgdmVjdG9ycyB0byBhIG1hdHJpeCBhcyByb3dzLlxyXG4gKlxyXG4gKiBAcGFyYW0gcjAgVGhlIGZpcnN0IHJvdy5cclxuICogQHBhcmFtIHIxIFRoZSBzZWNvbmQgcm93LlxyXG4gKiBAcGFyYW0gcjIgVGhlIHRoaXJkIHJvdy5cclxuICogQHBhcmFtIGRzdCBUaGUgbWF0cml4IHRoZSByb3dzIHdpbGwgYmUgd3JpdHRlbiB0by5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJvd3MocjAsIHIxLCByMiwgZHN0ID0gY3JlYXRlKCkpIHtcclxuICAgIGRzdFswXSA9IHIwLng7XHJcbiAgICBkc3RbMV0gPSByMS54O1xyXG4gICAgZHN0WzJdID0gcjIueDtcclxuICAgIGRzdFszXSA9IHIwLnk7XHJcbiAgICBkc3RbNF0gPSByMS55O1xyXG4gICAgZHN0WzVdID0gcjIueTtcclxuICAgIGRzdFs2XSA9IHIwLno7XHJcbiAgICBkc3RbN10gPSByMS56O1xyXG4gICAgZHN0WzhdID0gcjIuejtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYXJyYXkgb2YgY29sdW1ucyBvZiBhIG1hdHJpeC5cclxuICpcclxuICogQHBhcmFtIG0gVGhlIG1hdHJpeC5cclxuICogQHBhcmFtIGRzdCBUaGUgYXJyYXkgY29sdW1ucyBvZiB0aGUgbWF0cml4IHdpbGwgYmUgd3JpdHRlbiB0by5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29sdW1ucyhtLCBkc3QgPSBbXHJcbiAgICB2ZWN0b3IzLmNyZWF0ZSgwLCAwLCAwKSxcclxuICAgIHZlY3RvcjMuY3JlYXRlKDAsIDAsIDApLFxyXG4gICAgdmVjdG9yMy5jcmVhdGUoMCwgMCwgMClcclxuXSkge1xyXG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgMzsgKytpLCBqICs9IDMpIHtcclxuICAgICAgICBkc3RbaV0ueCA9IG1bal07XHJcbiAgICAgICAgZHN0W2ldLnkgPSBtW2ogKyAxXTtcclxuICAgICAgICBkc3RbaV0ueiA9IG1baiArIDJdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogQ29waWVzIHRocmVlIHZlY3RvcnMgdG8gYSBtYXRyaXggYXMgY29sdW1ucy5cclxuICpcclxuICogQHBhcmFtIGMwIFRoZSBmaXJzdCBjb2x1bW4uXHJcbiAqIEBwYXJhbSBjMSBUaGUgc2Vjb25kIGNvbHVtbi5cclxuICogQHBhcmFtIGMyIFRoZSB0aGlyZCBjb2x1bW4uXHJcbiAqIEBwYXJhbSBkc3QgVGhlIG1hdHJpeCB0aGUgY29sdW1ucyB3aWxsIGJlIHdyaXR0ZW4gdG8uXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGZyb21Db2x1bW5zKGMwLCBjMSwgYzIsIGRzdCA9IGNyZWF0ZSgpKSB7XHJcbiAgICBkc3RbMF0gPSBjMC54O1xyXG4gICAgZHN0WzFdID0gYzAueTtcclxuICAgIGRzdFsyXSA9IGMwLno7XHJcbiAgICBkc3RbM10gPSBjMS54O1xyXG4gICAgZHN0WzRdID0gYzEueTtcclxuICAgIGRzdFs1XSA9IGMxLno7XHJcbiAgICBkc3RbNl0gPSBjMi54O1xyXG4gICAgZHN0WzddID0gYzIueTtcclxuICAgIGRzdFs4XSA9IGMyLno7XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbi8qKlxyXG4gKiBDb21wdXRlcyBkZXRlcm1pbmFudCBvZiBhIG1hdHJpeC5cclxuICpcclxuICogQHBhcmFtIG0gVGhlIG1hdHJpeC5cclxuICogQHJldHVybnMgVGhlIGRldGVybWluYW50LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRldGVybWluYW50KG0pIHtcclxuICAgIHJldHVybiBtWzBdICogKG1bNF0gKiBtWzhdIC0gbVs3XSAqIG1bNV0pICtcclxuICAgICAgICBtWzNdICogKG1bMV0gKiBtWzhdIC0gbVs3XSAqIG1bMl0pICtcclxuICAgICAgICBtWzZdICogKG1bMV0gKiBtWzVdIC0gbVs0XSAqIG1bMl0pO1xyXG59XHJcbmNvbnN0IHN0YXRpY01hdHJpeENvbHVtbnMgPSBbXHJcbiAgICAvLyBOb3QgdXNpbmcgdmVjdG9yMy5jcmVhdGUgaGVyZSBkdWUgdG8gY2lyY3VsYXIgZGVwZW5kZW5jeS5cclxuICAgIHsgeDogMCwgeTogMCwgejogMCB9LFxyXG4gICAgeyB4OiAwLCB5OiAwLCB6OiAwIH0sXHJcbiAgICB7IHg6IDAsIHk6IDAsIHo6IDAgfVxyXG5dO1xyXG5jb25zdCBzdGF0aWNNYXRyaXggPSBjcmVhdGUoKTtcclxuLyoqXHJcbiAqIFNvbHZlcyBhIHN5c3RlbSBvZiBsaW5lYXIgZXF1YXRpb25zIHJlcHJlc2VudGVkIHdpdGggYSBtYXRyaXggYW5kIGEgdmVjdG9yLFxyXG4gKiBpLmUuOlxyXG4gKlxyXG4gKiBgYGBcclxuICogbSAqICh4LCB5ICx6KV5UID0gdlxyXG4gKiBgYGBcclxuICpcclxuICogVXNlcyBDcmFtZXIncyBydWxlLlxyXG4gKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NyYW1lcidzX3J1bGVcclxuICpcclxuICogQHBhcmFtIG0gVGhlIG1hdHJpeCBvZiB0aGUgc3lzdGVtLlxyXG4gKiBAcGFyYW0gdiBUaGUgdmVjdG9yIG9mIHRoZSBzeXN0ZW0uXHJcbiAqIEBwYXJhbSBkc3QgVGhlIHZlY3RvciBzb2x1dGlvbiBvZiB0aGUgc3lzdGVtIHdpbGwgYmUgd3JpdHRlbiB0by5cclxuICogQHJldHVybiBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzb2x2ZShtLCB2LCBkc3QgPSB2ZWN0b3IzLmNyZWF0ZSgwLCAwLCAwKSkge1xyXG4gICAgY29uc3QgcmV2RGV0ID0gMSAvIGRldGVybWluYW50KG0pO1xyXG4gICAgY29uc3QgW2MwLCBjMSwgYzJdID0gY29sdW1ucyhtLCBzdGF0aWNNYXRyaXhDb2x1bW5zKTtcclxuICAgIGRzdC54ID0gcmV2RGV0ICogZGV0ZXJtaW5hbnQoZnJvbUNvbHVtbnModiwgYzEsIGMyLCBzdGF0aWNNYXRyaXgpKTtcclxuICAgIGRzdC55ID0gcmV2RGV0ICogZGV0ZXJtaW5hbnQoZnJvbUNvbHVtbnMoYzAsIHYsIGMyLCBzdGF0aWNNYXRyaXgpKTtcclxuICAgIGRzdC56ID0gcmV2RGV0ICogZGV0ZXJtaW5hbnQoZnJvbUNvbHVtbnMoYzAsIGMxLCB2LCBzdGF0aWNNYXRyaXgpKTtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvbWF0aC9tYXRyaXgzLnRzXG4vLyBtb2R1bGUgaWQgPSA2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgVGlsZUJhc2VkQWRhcHRlciBmcm9tICcuLi90aWxlX2Jhc2VkX2FkYXB0ZXIvYWRhcHRlcic7XHJcbmltcG9ydCBJY29uQnVmZmVyV3JpdGVyIGZyb20gJy4uLy4uL3ByaW1pdGl2ZS9pY29uL2ljb25fYnVmZmVyX3dyaXRlcic7XHJcbmltcG9ydCBNZW1vcnlTdWJDaHVuayBmcm9tICcuLi8uLi9yZW5kZXIvbWVtb3J5L3N1Yl9jaHVuayc7XHJcbmltcG9ydCBJZGVudGlmaWVkSW1hZ2VBdGxhc01hbmFnZXIgZnJvbSAnLi4vLi4vYmlsbGJvYXJkL2lkZW50aWZpZWRfaW1hZ2VfYXRsYXNfbWFuYWdlcic7XHJcbmltcG9ydCBEZkZvbnQgZnJvbSAnLi4vLi4vZm9udC9kZl9mb250JztcclxuaW1wb3J0IHsgQXBpSW1hZ2VQcm92aWRlciB9IGZyb20gJy4vYXBpX2ltYWdlX3Byb3ZpZGVyJztcclxuaW1wb3J0IE1vZGVsQnVmZmVyV3JpdGVyIGZyb20gJy4uLy4uL3ByaW1pdGl2ZS9tb2RlbC9tb2RlbF9idWZmZXJfd3JpdGVyJztcclxuaW1wb3J0IFRleHR1cmVkUG9seWxpbmVCdWZmZXJXcml0ZXIgZnJvbSAnLi4vLi4vcHJpbWl0aXZlL3BvbHlsaW5lL3RleHR1cmVkX3BvbHlsaW5lX2J1ZmZlcl93cml0ZXInO1xyXG5pbXBvcnQgeyBJbWFnZU1hbmFnZXIgfSBmcm9tICcuLi8uLi9iaWxsYm9hcmQvaW1hZ2VfbWFuYWdlcic7XHJcbmltcG9ydCBUZXh0dXJlZFBvbHlnb25CdWZmZXJSZXdyaXRlciBmcm9tICcuLi8uLi9wcmltaXRpdmUvcG9seWdvbi90ZXh0dXJlZF9wb2x5Z29uX2J1ZmZlcl9yZXdpdGVyJztcclxuaW1wb3J0IHsgUE9MWUdPTl9BVFRSSUJVVEVfTUFQUElORyB9IGZyb20gJy4uLy4uL3ByaW1pdGl2ZS9wb2x5Z29uL3BvbHlnb25fYXR0cmlidXRlX21hcHBpbmcnO1xyXG5pbXBvcnQgeyBURVhUVVJFRF9QT0xZR09OX0FUVFJJQlVURV9NQVBQSU5HIH0gZnJvbSAnLi4vLi4vcHJpbWl0aXZlL3BvbHlnb24vdGV4dHVyZWRfcG9seWdvbl9hdHRyaWJ1dGVfbWFwcGluZyc7XHJcbmltcG9ydCB7IEJJTExCT0FSRF9SRUNUQU5HTEVfQVRUUklCVVRFX01BUFBJTkcgfSBmcm9tICcuLi8uLi9wcmltaXRpdmUvYmlsbGJvYXJkX3JlY3RhbmdsZS9hdHRyaWJ1dGVfbWFwcGluZyc7XHJcbmltcG9ydCB7IFBPSU5UX0xBQkVMX0FUVFJJQlVURV9NQVBQSU5HIH0gZnJvbSAnLi4vLi4vcHJpbWl0aXZlL2xhYmVsL3BvaW50X2xhYmVsX2F0dHJpYnV0ZV9tYXBwaW5nJztcclxuaW1wb3J0IHsgQ1VSVkVEX0xBQkVMX0FUVFJJQlVURV9NQVBQSU5HIH0gZnJvbSAnLi4vLi4vcHJpbWl0aXZlL2xhYmVsL2N1cnZlZF9sYWJlbF9hdHRyaWJ1dGVfbWFwcGluZyc7XHJcbmltcG9ydCB7IFBPTFlMSU5FX0FUVFJJQlVURV9NQVBQSU5HIH0gZnJvbSAnLi4vLi4vcHJpbWl0aXZlL3BvbHlsaW5lL3BvbHlsaW5lX2F0dHJpYnV0ZV9tYXBwaW5nJztcclxuaW1wb3J0IHsgVGlsZVByb3ZpZGVyV29ya2VyQ2xpZW50IH0gZnJvbSAnLi93b3JrZXIvdGlsZV9wcm92aWRlcl93b3JrZXJfY2xpZW50JztcclxuaW1wb3J0IHsgVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGUgfSBmcm9tICcuL3dvcmtlci90aWxlX3Byb3ZpZGVyX3dvcmtlcl9tZXNzYWdlcyc7XHJcbmltcG9ydCB7IFRSQU5TUEFSRU5UX1BPTFlHT05fQVRUUklCVVRFX01BUFBJTkcgfSBmcm9tICcuLi8uLi9wcmltaXRpdmUvcG9seWdvbi90cmFuc3BhcmVudF9wb2x5Z29uX2F0dHJpYnV0ZV9tYXBwaW5nJztcclxuaW1wb3J0IHsgZ2V0VGlsZUlkIH0gZnJvbSAnLi4vdGlsZV9iYXNlZF9hZGFwdGVyL3RpbGVfaWQnO1xyXG5pbXBvcnQgSWRsZVRhc2tRdWV1ZSBmcm9tICcuLi8uLi91dGlsL2lkbGVfdGFza19xdWV1ZSc7XHJcbmltcG9ydCB7IGNvdW50VGlsZVBhcnNlVGltZSB9IGZyb20gJy4uLy4uL3V0aWwvc3RhdCc7XHJcbmltcG9ydCB7IHVuaXF1ZUlkIH0gZnJvbSAnLi4vLi4vdXRpbC91bmlxdWVfaWQnO1xyXG5pbXBvcnQgUmVuZGVyYWJsZVBvbHlnb24gZnJvbSAnLi4vLi4vcHJpbWl0aXZlL3BvbHlnb24vcmVuZGVyYWJsZV9wb2x5Z29uJztcclxuaW1wb3J0IFJlbmRlcmFibGVUZXh0dXJlZFBvbHlnb24gZnJvbSAnLi4vLi4vcHJpbWl0aXZlL3BvbHlnb24vcmVuZGVyYWJsZV90ZXh0dXJlZF9wb2x5Z29uJztcclxuaW1wb3J0IFJlbmRlcmFibGVQb2x5bGluZSBmcm9tICcuLi8uLi9wcmltaXRpdmUvcG9seWxpbmUvcmVuZGVyYWJsZV9wb2x5bGluZSc7XHJcbmltcG9ydCBSZW5kZXJhYmxlVGV4dHVyZWRQb2x5bGluZSBmcm9tICcuLi8uLi9wcmltaXRpdmUvcG9seWxpbmUvcmVuZGVyYWJsZV90ZXh0dXJlZF9wb2x5bGluZSc7XHJcbmltcG9ydCBSZW5kZXJhYmxlTW9kZWwgZnJvbSAnLi4vLi4vcHJpbWl0aXZlL21vZGVsL3JlbmRlcmFibGVfbW9kZWwnO1xyXG5pbXBvcnQgeyBQT0xZR09OX0VYVFJBQ1RPUiwgVEVYVFVSRURfUE9MWUdPTl9FWFRSQUNUT1IsIFBPTFlMSU5FX0VYVFJBQ1RPUiwgVEVYVFVSRURfUE9MWUxJTkVfRVhUUkFDVE9SLCBQT0lOVF9FWFRSQUNUT1IsIFBPSU5UX0xBQkVMX0VYVFJBQ1RPUiwgQ1VSVkVEX0xBQkVMX0VYVFJBQ1RPUiwgTU9ERUxfRVhUUkFDVE9SLCBFWFRFUk5BTF9NRVNIX0VYVFJBQ1RPUiB9IGZyb20gJy4vdGlsZV9kYXRhJztcclxuaW1wb3J0IFJlbmRlcmFibGVQcmltaXRpdmVNYW5hZ2VyIGZyb20gJy4vcHJpbWl0aXZlX21hbmFnZXIvcmVuZGVyYWJsZV9wcmltaXRpdmVfbWFuYWdlcic7XHJcbmltcG9ydCBQcmltaXRpdmVTZXRTdG9yYWdlIGZyb20gJy4uLy4uL3JlbmRlci9wcmltaXRpdmVzL3ByaW1pdGl2ZV9zZXRfc3RvcmFnZSc7XHJcbmltcG9ydCBQb2x5Z29uTWFuYWdlciBmcm9tICcuL3ByaW1pdGl2ZV9tYW5hZ2VyL3BvbHlnb25fbWFuYWdlcic7XHJcbmltcG9ydCBEaXNhcHBlYXJpbmdQcmltaXRpdmVTZXRTdG9yYWdlIGZyb20gJy4uLy4uL3JlbmRlci9wcmltaXRpdmVzL2Rpc2FwcGVhcmluZ19wcmltaXRpdmVfc2V0X3N0b3JhZ2UnO1xyXG5pbXBvcnQgRGVsYXllZERpc2FwcGVhcmluZ1ByaW1pdGl2ZVNldFN0b3JhZ2UgZnJvbSAnLi4vLi4vcmVuZGVyL3ByaW1pdGl2ZXMvZGVsYXllZF9kaXNhcHBlYXJpbmdfcHJpbWl0aXZlX3NldF9zdG9yYWdlJztcclxuaW1wb3J0IFpvb21GaWx0ZXJhYmxlUHJpbWl0aXZlTWFuYWdlciBmcm9tICcuL3ByaW1pdGl2ZV9tYW5hZ2VyL3pvb21fZmlsdGVyYWJsZV9wcmltaXRpdmVfbWFuYWdlcic7XHJcbmltcG9ydCBFeHRlcm5hbE1lc2hQcmltaXRpdmVNYW5hZ2VyIGZyb20gJy4vcHJpbWl0aXZlX21hbmFnZXIvZXh0ZXJuYWxfbWVzaF9tYW5hZ2VyJztcclxuaW1wb3J0IFJlbmRlcmFibGVCaWxsYm9hcmRSZWN0YW5nbGUgZnJvbSAnLi4vLi4vcHJpbWl0aXZlL2JpbGxib2FyZF9yZWN0YW5nbGUvcmVuZGVyYWJsZV9iaWxsYm9hcmRfcmVjdGFuZ2xlJztcclxuaW1wb3J0IHsgWm9vbVJlc3RyaWN0ZWRMYWJlbCB9IGZyb20gJy4vcHJpbWl0aXZlL3pvb21fcmVzdHJpY3RlZF9sYWJlbCc7XHJcbmltcG9ydCB7IFpvb21SZXN0cmljdGVkSWNvbiB9IGZyb20gJy4vcHJpbWl0aXZlL3pvb21fcmVzdHJpY3RlZF9pY29uJztcclxuaW1wb3J0IFByaW9yaXR5UXVldWUgZnJvbSAnLi4vLi4vdXRpbC90YXNrX3F1ZXVlJztcclxuY29uc3QgV09STERfU0laRSA9IDIuMDtcclxuY29uc3QgTk9STUFMX1RJTEVfU0lERV9TSVpFX1BYID0gMjU2OyAvLyB0aWxlcyBvZiBub3JtYWwgc2l6ZSBhcmUgb3B0aW1pemVkIGZvciBkaXNwbGF5aW5nIGluIGEgMjU2eDI1NiBjc3MgcHggc3F1YXJlXHJcbmZ1bmN0aW9uIGdldFRpbGVTaWRlU2l6ZVB4KHRpbGVTaXplKSB7XHJcbiAgICBzd2l0Y2ggKHRpbGVTaXplKSB7XHJcbiAgICAgICAgY2FzZSAxIC8qIFg0ICovOlxyXG4gICAgICAgICAgICByZXR1cm4gTk9STUFMX1RJTEVfU0lERV9TSVpFX1BYICogMjtcclxuICAgICAgICBjYXNlIDIgLyogWDE2ICovOlxyXG4gICAgICAgICAgICByZXR1cm4gTk9STUFMX1RJTEVfU0lERV9TSVpFX1BYICogNDtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gTk9STUFMX1RJTEVfU0lERV9TSVpFX1BYO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IE1BWF9QRVJGX0xPR19JVEVNU19DT1VOVCA9IDEwMjQ7XHJcbmNvbnN0IFFVRVVFX1RBU0tfUFJJT1JJVElFUyA9IHtcclxuICAgIGZpcnN0VGlsZVBvcnRpb246IDIwLFxyXG4gICAgc2Vjb25kVGlsZVBvcnRpb246IDEwXHJcbn07XHJcbmNvbnN0IERFRkFVTFRfSURMRV9UQVNLX1BSSU9SSVRZID0gMDtcclxuLy8gVGhlIHZhbHVlcyBhcmUgY2hvc2VuIGVtcGlyaWNhbGx5OiBodHRwczovL3N0LnlhbmRleC10ZWFtLnJ1L1ZFQ1RPUi0zMDAjNWJlNWI2Mzg1MjMyMTEwMDFiOWJkOTQxXHJcbmNvbnN0IE1JTlpPT01fREVMVEFTID0ge1xyXG4gICAgcG9pbnRMYWJlbHM6IDEsXHJcbiAgICBjdXJ2ZWRMYWJlbHM6IDEsXHJcbiAgICBpY29uczogMC43NVxyXG59O1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWZWN0b3JBcGlBZGFwdGVyIGV4dGVuZHMgVGlsZUJhc2VkQWRhcHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihlbmdpbmUsIGNhbWVyYSwgdGlsZVByb3ZpZGVyV29ya2VyVXJsLCBsYXllck5hbWUsIHsgaW1hZ2VVcmxUZW1wbGF0ZSwgdGlsZVVybFRlbXBsYXRlLCBtZXNoVXJsVGVtcGxhdGUsIGdseXBoUmFuZ2VVcmxUZW1wbGF0ZSB9LCB0aWxlU2l6ZSA9IDAgLyogWDEgKi8sIHByZWxvYWRlZFRpbGVzQmVsdFNpemUgPSAwKSB7XHJcbiAgICAgICAgc3VwZXIoZW5naW5lLCBjYW1lcmEsIHRpbGVTaXplLCBwcmVsb2FkZWRUaWxlc0JlbHRTaXplLCBsYXllck5hbWUpO1xyXG4gICAgICAgIHRoaXMuX3RpbGVTaWRlU2l6ZVB4ID0gZ2V0VGlsZVNpZGVTaXplUHgodGlsZVNpemUpO1xyXG4gICAgICAgIHRoaXMuX3BlcmZMb2dJdGVtcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lhYmxlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3RpbGVQcm92aWRlciA9IG5ldyBUaWxlUHJvdmlkZXJXb3JrZXJDbGllbnQodGlsZVByb3ZpZGVyV29ya2VyVXJsKTtcclxuICAgICAgICB0aGlzLl90aWxlUHJvdmlkZXIuc2VuZE1lc3NhZ2Uoe1xyXG4gICAgICAgICAgICB0eXBlOiBUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZS5JTklULFxyXG4gICAgICAgICAgICB0aWxlVXJsVGVtcGxhdGUsXHJcbiAgICAgICAgICAgIG1lc2hVcmxUZW1wbGF0ZSxcclxuICAgICAgICAgICAgZ2x5cGhSYW5nZVVybFRlbXBsYXRlXHJcbiAgICAgICAgfSwgMSAvKiBJTU1FRElBVEUgKi8pO1xyXG4gICAgICAgIHRoaXMuX21lbW9yeU1hbmFnZXIgPSBlbmdpbmUubWVtb3J5TWFuYWdlcjtcclxuICAgICAgICB0aGlzLl9nbHlwaEF0bGFzID0gZW5naW5lLmdseXBoQXRsYXM7XHJcbiAgICAgICAgdGhpcy5fZm9udFJlZ2lzdHJ5ID0gZW5naW5lLmZvbnRSZWdpc3RyeTtcclxuICAgICAgICB0aGlzLl9pbWFnZU1hbmFnZXJOZWFyZXN0ID0gbmV3IEltYWdlTWFuYWdlcihuZXcgSWRlbnRpZmllZEltYWdlQXRsYXNNYW5hZ2VyKGVuZ2luZS5jcmVhdGVJbWFnZUF0bGFzKHtcclxuICAgICAgICAgICAgZmlsdGVyOiA5NzI4IC8qIE5FQVJFU1QgKi8sXHJcbiAgICAgICAgICAgIHByZW11bHRpcGxpZWRBbHBoYTogZmFsc2VcclxuICAgICAgICB9KSksIG5ldyBBcGlJbWFnZVByb3ZpZGVyKGltYWdlVXJsVGVtcGxhdGUpKTtcclxuICAgICAgICB0aGlzLl9pbWFnZU1hbmFnZXJMaW5lYXIgPSBuZXcgSW1hZ2VNYW5hZ2VyKG5ldyBJZGVudGlmaWVkSW1hZ2VBdGxhc01hbmFnZXIoZW5naW5lLmNyZWF0ZUltYWdlQXRsYXMoe1xyXG4gICAgICAgICAgICBmaWx0ZXI6IDk3MjkgLyogTElORUFSICovLFxyXG4gICAgICAgICAgICBwcmVtdWx0aXBsaWVkQWxwaGE6IHRydWVcclxuICAgICAgICB9KSksIG5ldyBBcGlJbWFnZVByb3ZpZGVyKGltYWdlVXJsVGVtcGxhdGUpKTtcclxuICAgICAgICBjb25zdCBmYWRlRWZmZWN0ID0gZW5naW5lLnZpc2liaWxpdHlNYW5hZ2VyLmZhZGVFZmZlY3REdXJhdGlvbjtcclxuICAgICAgICBjb25zdCBvcGFxdWVQb2x5Z29uc1Byb3ZpZGVyID0gdGhpcy5vcGFxdWVQb2x5Z29uc1Byb3ZpZGVyID0gbmV3IFByaW1pdGl2ZVNldFN0b3JhZ2UoKTtcclxuICAgICAgICBjb25zdCB0cmFuc3BhcmVudFBvbHlnb25zUHJvdmlkZXIgPSB0aGlzLnRyYW5zcGFyZW50UG9seWdvbnNQcm92aWRlciA9IG5ldyBQcmltaXRpdmVTZXRTdG9yYWdlKCk7XHJcbiAgICAgICAgY29uc3QgdGV4dHVyZWRQb2x5Z29uc1Byb3ZpZGVyID0gdGhpcy50ZXh0dXJlZFBvbHlnb25zUHJvdmlkZXIgPSBuZXcgUHJpbWl0aXZlU2V0U3RvcmFnZSgpO1xyXG4gICAgICAgIGNvbnN0IHBvbHlsaW5lc1Byb3ZpZGVyID0gdGhpcy5wb2x5bGluZXNQcm92aWRlciA9IG5ldyBQcmltaXRpdmVTZXRTdG9yYWdlKCk7XHJcbiAgICAgICAgY29uc3QgdGV4dHVyZWRQb2x5bGluZXNQcm92aWRlciA9IHRoaXMudGV4dHVyZWRQb2x5bGluZXNQcm92aWRlciA9IG5ldyBQcmltaXRpdmVTZXRTdG9yYWdlKCk7XHJcbiAgICAgICAgY29uc3QgaWNvbnNQcm92aWRlciA9IHRoaXMuaWNvbnNQcm92aWRlciA9IG5ldyBEaXNhcHBlYXJpbmdQcmltaXRpdmVTZXRTdG9yYWdlKCk7XHJcbiAgICAgICAgY29uc3QgcG9pbnRMYWJlbHNQcm92aWRlciA9IHRoaXMucG9pbnRMYWJlbHNQcm92aWRlciA9IG5ldyBEZWxheWVkRGlzYXBwZWFyaW5nUHJpbWl0aXZlU2V0U3RvcmFnZShmYWRlRWZmZWN0KTtcclxuICAgICAgICBjb25zdCBjdXJ2ZWRMYWJlbHNQcm92aWRlciA9IHRoaXMuY3VydmVkTGFiZWxzUHJvdmlkZXIgPSBuZXcgRGVsYXllZERpc2FwcGVhcmluZ1ByaW1pdGl2ZVNldFN0b3JhZ2UoZmFkZUVmZmVjdCk7XHJcbiAgICAgICAgY29uc3QgbW9kZWxzUHJvdmlkZXIgPSB0aGlzLm1vZGVsc1Byb3ZpZGVyID0gbmV3IFByaW1pdGl2ZVNldFN0b3JhZ2UoKTtcclxuICAgICAgICB0aGlzLl9kZXN0cm95YWJsZXMucHVzaChwb2ludExhYmVsc1Byb3ZpZGVyLCBjdXJ2ZWRMYWJlbHNQcm92aWRlcik7XHJcbiAgICAgICAgdGhpcy5fdGlsZURhdGFNYW5hZ2VycyA9IFtcclxuICAgICAgICAgICAgbmV3IFRpbGVEYXRhTWFuYWdlcihuZXcgUG9seWdvbk1hbmFnZXIob3BhcXVlUG9seWdvbnNQcm92aWRlciwgdHJhbnNwYXJlbnRQb2x5Z29uc1Byb3ZpZGVyKSwgUE9MWUdPTl9FWFRSQUNUT1IpLFxyXG4gICAgICAgICAgICBuZXcgVGlsZURhdGFNYW5hZ2VyKG5ldyBSZW5kZXJhYmxlUHJpbWl0aXZlTWFuYWdlcih0ZXh0dXJlZFBvbHlnb25zUHJvdmlkZXIpLCBURVhUVVJFRF9QT0xZR09OX0VYVFJBQ1RPUiksXHJcbiAgICAgICAgICAgIG5ldyBUaWxlRGF0YU1hbmFnZXIobmV3IFJlbmRlcmFibGVQcmltaXRpdmVNYW5hZ2VyKHBvbHlsaW5lc1Byb3ZpZGVyKSwgUE9MWUxJTkVfRVhUUkFDVE9SKSxcclxuICAgICAgICAgICAgbmV3IFRpbGVEYXRhTWFuYWdlcihuZXcgUmVuZGVyYWJsZVByaW1pdGl2ZU1hbmFnZXIodGV4dHVyZWRQb2x5bGluZXNQcm92aWRlciksIFRFWFRVUkVEX1BPTFlMSU5FX0VYVFJBQ1RPUiksXHJcbiAgICAgICAgICAgIG5ldyBUaWxlRGF0YU1hbmFnZXIobmV3IFpvb21GaWx0ZXJhYmxlUHJpbWl0aXZlTWFuYWdlcihpY29uc1Byb3ZpZGVyLCBjYW1lcmEpLCBQT0lOVF9FWFRSQUNUT1IpLFxyXG4gICAgICAgICAgICBuZXcgVGlsZURhdGFNYW5hZ2VyKG5ldyBab29tRmlsdGVyYWJsZVByaW1pdGl2ZU1hbmFnZXIocG9pbnRMYWJlbHNQcm92aWRlciwgY2FtZXJhKSwgUE9JTlRfTEFCRUxfRVhUUkFDVE9SKSxcclxuICAgICAgICAgICAgbmV3IFRpbGVEYXRhTWFuYWdlcihuZXcgWm9vbUZpbHRlcmFibGVQcmltaXRpdmVNYW5hZ2VyKGN1cnZlZExhYmVsc1Byb3ZpZGVyLCBjYW1lcmEpLCBDVVJWRURfTEFCRUxfRVhUUkFDVE9SKSxcclxuICAgICAgICAgICAgbmV3IFRpbGVEYXRhTWFuYWdlcihuZXcgUmVuZGVyYWJsZVByaW1pdGl2ZU1hbmFnZXIobW9kZWxzUHJvdmlkZXIpLCBNT0RFTF9FWFRSQUNUT1IpLFxyXG4gICAgICAgICAgICBuZXcgVGlsZURhdGFNYW5hZ2VyKG5ldyBFeHRlcm5hbE1lc2hQcmltaXRpdmVNYW5hZ2VyKG1vZGVsc1Byb3ZpZGVyLCB0aGlzLl90aWxlUHJvdmlkZXIsIHRoaXMuZW5naW5lLm1lbW9yeU1hbmFnZXIpLCBFWFRFUk5BTF9NRVNIX0VYVFJBQ1RPUilcclxuICAgICAgICBdO1xyXG4gICAgICAgIHRoaXMuX3JlcXVlc3RlZFRpbGVzU3RhdGUgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5fdGFza1F1ZXVlID0gbmV3IFByaW9yaXR5UXVldWUoKTtcclxuICAgICAgICB0aGlzLl9taW5vclRhc2tRdWV1ZSA9IG5ldyBJZGxlVGFza1F1ZXVlKCk7XHJcbiAgICAgICAgdGhpcy5fdGlsZVByb3ZpZGVyLm9uKFRpbGVQcm92aWRlck1lc3NhZ2VUeXBlLlRJTEVfUkVTUE9OU0UsIChyZXNwb25zZSkgPT4gdGhpcy5fb25UaWxlUHJvdmlkZXJSZXNwb25zZShyZXNwb25zZSkpO1xyXG4gICAgICAgIHRoaXMuX3RpbGVQcm92aWRlci5vbihUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZS5USUxFX0VSUk9SLCAocmVzcG9uc2UpID0+IHRoaXMuX29uVGlsZUVycm9yKHJlc3BvbnNlLnRpbGUpKTtcclxuICAgICAgICB0aGlzLl9vbkNhbWVyYVVwZGF0ZSgpO1xyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLl90aWxlUHJvdmlkZXIuZGVzdHJveSgpO1xyXG4gICAgICAgIGZvciAoY29uc3QgZGVzdHJveWFibGUgb2YgdGhpcy5fZGVzdHJveWFibGVzKSB7XHJcbiAgICAgICAgICAgIGRlc3Ryb3lhYmxlLmRlc3Ryb3koKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xyXG4gICAgfVxyXG4gICAgc2V0VGlsZVVybFRlbXBsYXRlKHRpbGVVcmxUZW1wbGF0ZSkge1xyXG4gICAgICAgIHRoaXMuX3RpbGVQcm92aWRlci5zZW5kTWVzc2FnZSh7XHJcbiAgICAgICAgICAgIHR5cGU6IFRpbGVQcm92aWRlck1lc3NhZ2VUeXBlLlRJTEVfVVJMX1VQREFURSxcclxuICAgICAgICAgICAgdGlsZVVybFRlbXBsYXRlXHJcbiAgICAgICAgfSwgMSAvKiBJTU1FRElBVEUgKi8pO1xyXG4gICAgICAgIHRoaXMuX3JlZnJlc2hDdXJyZW50VGlsZXMoKTtcclxuICAgIH1cclxuICAgIF9jcmVhdGVUaWxlUmVxdWVzdCh0aWxlSXRlbSwgcHJpb3JpdHkpIHtcclxuICAgICAgICBjb25zdCB0YXJnZXRab29tID0gdGhpcy5fZ2V0VGFyZ2V0Wm9vbSgpO1xyXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB0aWxlSXRlbSwgeyBwcmlvcml0eSwgaXNWaXNpYmxlOiB0aGlzLl9pc1RpbGVWaXNpYmxlKHRpbGVJdGVtKSwgem9vbU1pbjogdGFyZ2V0Wm9vbSwgem9vbU1heDogdGFyZ2V0Wm9vbSB9KTtcclxuICAgIH1cclxuICAgIF9yZXF1ZXN0VGlsZXMocmVxdWVzdHMpIHtcclxuICAgICAgICBjb25zdCByZXF1ZXN0SWQgPSB1bmlxdWVJZCgpO1xyXG4gICAgICAgIHRoaXMuX29uVGlsZXNSZXF1ZXN0KHJlcXVlc3RzLCByZXF1ZXN0SWQpO1xyXG4gICAgICAgIGZvciAoY29uc3QgcmVxdWVzdCBvZiByZXF1ZXN0cykge1xyXG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ZWRUaWxlRGF0YSA9IHtcclxuICAgICAgICAgICAgICAgIGlzR2VvbWV0cnlSZWFkeTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBhcmVMYWJlbHNSZWFkeTogZmFsc2VcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdGVkVGlsZXNTdGF0ZS5zZXQoZ2V0VGlsZUlkKHJlcXVlc3QpLCByZXF1ZXN0ZWRUaWxlRGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XHJcbiAgICAgICAgICAgIHR5cGU6IFRpbGVQcm92aWRlck1lc3NhZ2VUeXBlLlRJTEVfUkVRVUVTVF9CQVRDSCxcclxuICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiBUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZS5USUxFX1JFU1BPTlNFLFxyXG4gICAgICAgICAgICBlcnJvclR5cGU6IFRpbGVQcm92aWRlck1lc3NhZ2VUeXBlLlRJTEVfRVJST1IsXHJcbiAgICAgICAgICAgIHJlcXVlc3RJZCxcclxuICAgICAgICAgICAgcmVxdWVzdHNcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuX3RpbGVQcm92aWRlci5zZW5kTWVzc2FnZShyZXF1ZXN0LCAxIC8qIElNTUVESUFURSAqLyk7XHJcbiAgICB9XHJcbiAgICBfY2FuY2VsVGlsZVJlcXVlc3RzKHJlcXVlc3RzKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCByZXF1ZXN0IG9mIHJlcXVlc3RzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RlZFRpbGVzU3RhdGUuZGVsZXRlKGdldFRpbGVJZChyZXF1ZXN0LnRpbGUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fb25DYW5jZWxUaWxlUmVxdWVzdHMocmVxdWVzdHMpO1xyXG4gICAgICAgIHRoaXMuX3RpbGVQcm92aWRlci5zZW5kTWVzc2FnZSh7XHJcbiAgICAgICAgICAgIHR5cGU6IFRpbGVQcm92aWRlck1lc3NhZ2VUeXBlLlRJTEVfUkVRVUVTVF9DQU5DRUxfQkFUQ0gsXHJcbiAgICAgICAgICAgIHJlcXVlc3RzXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfb25UaWxlRGF0YVVwZGF0ZShkYXRhVG9TaG93LCBkYXRhVG9IaWRlKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBwcmltaXRpdmVNYW5hZ2VyIG9mIHRoaXMuX3RpbGVEYXRhTWFuYWdlcnMpIHtcclxuICAgICAgICAgICAgcHJpbWl0aXZlTWFuYWdlci51cGRhdGVQcmltaXRpdmVzKGRhdGFUb1Nob3csIGRhdGFUb0hpZGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9vblRpbGVEZXN0cm95KF90aWxlSXRlbSwgZGF0YSkge1xyXG4gICAgICAgIC8vIHJlbGVhc2UgcHJpbWl0aXZlcyB0aGF0IHdlJ3ZlIGNyZWF0ZWQgaW4gYWxsb2NhdG9yc1xyXG4gICAgICAgIGZvciAoY29uc3QgcG9ydGlvbiBvZiBkYXRhKSB7XHJcbiAgICAgICAgICAgIChwb3J0aW9uLnBvbHlnb25zIHx8IFtdKS5mb3JFYWNoKHJlbGVhc2VQcmltaXRpdmUpO1xyXG4gICAgICAgICAgICAocG9ydGlvbi50ZXh0dXJlZFBvbHlnb25zIHx8IFtdKS5mb3JFYWNoKHJlbGVhc2VQcmltaXRpdmUpO1xyXG4gICAgICAgICAgICAocG9ydGlvbi5wb2x5bGluZXMgfHwgW10pLmZvckVhY2gocmVsZWFzZVByaW1pdGl2ZSk7XHJcbiAgICAgICAgICAgIChwb3J0aW9uLnRleHR1cmVkUG9seWxpbmVzIHx8IFtdKS5mb3JFYWNoKHJlbGVhc2VQcmltaXRpdmUpO1xyXG4gICAgICAgICAgICAocG9ydGlvbi5wb2ludHMgfHwgW10pLmZvckVhY2gocmVsZWFzZVByaW1pdGl2ZSk7XHJcbiAgICAgICAgICAgIChwb3J0aW9uLnBvaW50TGFiZWxzIHx8IFtdKS5mb3JFYWNoKHJlbGVhc2VQcmltaXRpdmUpO1xyXG4gICAgICAgICAgICAocG9ydGlvbi5jdXJ2ZWRMYWJlbHMgfHwgW10pLmZvckVhY2gocmVsZWFzZVByaW1pdGl2ZSk7XHJcbiAgICAgICAgICAgIChwb3J0aW9uLm1vZGVscyB8fCBbXSkuZm9yRWFjaChyZWxlYXNlUHJpbWl0aXZlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfc2VuZFN0YXRpc3RpY3NCZWZvcmVEZXN0cm95KCkge1xyXG4gICAgICAgIHN1cGVyLl9zZW5kU3RhdGlzdGljc0JlZm9yZURlc3Ryb3koKTtcclxuICAgICAgICBpZiAodGhpcy5fcGVyZkxvZ0l0ZW1zLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5fcGVyZkxvZ0l0ZW1zO1xyXG4gICAgICAgIGl0ZW1zLnNvcnQoKGEsIGIpID0+IGEucGFyc2VUaW1lIC0gYi5wYXJzZVRpbWUpO1xyXG4gICAgICAgIGNvbnN0IG1pbiA9IGl0ZW1zWzBdO1xyXG4gICAgICAgIGNvbnN0IG1heCA9IGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgIGNvbnN0IG1lZGlhbiA9IGl0ZW1zW01hdGguZmxvb3IoaXRlbXMubGVuZ3RoIC8gMildO1xyXG4gICAgICAgIGNvdW50VGlsZVBhcnNlVGltZSh0aGlzLl9sYXllck5hbWUsIG1pbi50aWxlLCBtaW4ucGFyc2VUaW1lLCBtYXgudGlsZSwgbWF4LnBhcnNlVGltZSwgbWVkaWFuLnRpbGUsIG1lZGlhbi5wYXJzZVRpbWUpO1xyXG4gICAgfVxyXG4gICAgX29uVGlsZVByb3ZpZGVyUmVzcG9uc2UocmVzcG9uc2UpIHtcclxuICAgICAgICB0aGlzLl9wdXNoUGVyZkxvZ0l0ZW0ocmVzcG9uc2UudGlsZSwgcmVzcG9uc2UucGFyc2VUaW1lKTtcclxuICAgICAgICBjb25zdCB0aWxlID0gcmVzcG9uc2UudGlsZTtcclxuICAgICAgICBjb25zdCB0YXNrUHJpb3JpdHkgPSBRVUVVRV9UQVNLX1BSSU9SSVRJRVMuZmlyc3RUaWxlUG9ydGlvbiArXHJcbiAgICAgICAgICAgIHRoaXMuX2dldFRpbGVQcmlvcml0eSh0aWxlLCB0aGlzLl9pc1RpbGVWaXNpYmxlKHRpbGUpKTtcclxuICAgICAgICB0aGlzLl90YXNrUXVldWUuZW5xdWV1ZSh7XHJcbiAgICAgICAgICAgIHByaW9yaXR5OiB0YXNrUHJpb3JpdHksXHJcbiAgICAgICAgICAgIGV4ZWN1dGU6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIGF0bGFzIG11c3QgYmUgdXBkYXRlZCBub3R3aXRoc3RhbmRpbmcgdGhlIHRpbGUgaXMgYWN0aXZlIG9yIG5vdFxyXG4gICAgICAgICAgICAgICAgLy8gYXMgdGhlc2UgbmV3IGdseXBocyB3aWxsIGJlIHVzZWQgaW4gbmV4dCB0aWxlc1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYXRsYXMgPSByZXNwb25zZS5nbHlwaEF0bGFzVG9VcGRhdGU7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXRsYXMpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9nbHlwaEF0bGFzLnVwZGF0ZUNvbnRlbnQoYXRsYXMud2lkdGgsIGF0bGFzLmhlaWdodCwgYXRsYXMuZGF0YSwgbmV3IE1hcChhdGxhcy5nbHlwaExvY2F0aW9ucykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVnaXN0cnkgPSByZXNwb25zZS5mb250UmVnaXN0cnlUb1VwZGF0ZTtcclxuICAgICAgICAgICAgICAgIGlmIChyZWdpc3RyeSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZm9udERhdGEgb2YgcmVnaXN0cnkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZvbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9mb250UmVnaXN0cnkuY29udGFpbnMoZm9udERhdGEuaWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb250ID0gdGhpcy5fZm9udFJlZ2lzdHJ5LmdldChmb250RGF0YS5pZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb250ID0gbmV3IERmRm9udChmb250RGF0YS5pZCwgZm9udERhdGEueGhlaWdodCwgZm9udERhdGEubWFyZ2luKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZvbnRSZWdpc3RyeS5hZGQoZm9udCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9udC5hZGRBbGxHbHlwaHMoZm9udERhdGEuZ2x5cGhzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0SWQgPSByZXNwb25zZS5yZXF1ZXN0SWQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2lzVGlsZVN0aWxsQWN0aXZlKHRpbGUsIHJlcXVlc3RJZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aWxlIGlzIGJlaW5nIHJlZnJlc2hlZCBkb24ndCB2aXN1YWxpemUgYW55IHBvcnRpb25zIHVudGlsIGFsbCBvZiB0aGVtIGFyZSBsb2FkZWQgdG8gYXZvaWQgYSBibGlua1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaXNSZWZyZXNoaW5nID0gdGhpcy5faXNUaWxlUmVmcmVzaGluZyh0aWxlKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGljb25zU3BsaXR0ZWQgPSBzcGxpdEltYWdlRGVwZW5kYW50UHJpbWl0aXZlcyhyZXNwb25zZS5wb2ludHMsIHRoaXMuX2ltYWdlTWFuYWdlck5lYXJlc3QsIChwb2ludCkgPT4gcG9pbnQuc3R5bGVzWzBdLmltYWdlSWQpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dHVyZWRQb2x5bGluZXNTcGxpdHRlZCA9IHNwbGl0SW1hZ2VEZXBlbmRhbnRQcmltaXRpdmVzKHJlc3BvbnNlLnRleHR1cmVkUG9seWxpbmVzLCB0aGlzLl9pbWFnZU1hbmFnZXJMaW5lYXIsIChwb2x5bGluZSkgPT4gcG9seWxpbmUuc3R5bGVzWzBdLmlubGluZS5wYXR0ZXJuLmltYWdlSWQpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dHVyZWRQb2x5Z29uc0ltYWdlcyA9IGdldEltYWdlc0lmQWxsQWxsb2NhdGVkKHJlc3BvbnNlLnRleHR1cmVkUG9seWdvbnMsIHRoaXMuX2ltYWdlTWFuYWdlck5lYXJlc3QsIChwb2x5Z29uKSA9PiBwb2x5Z29uLnN0eWxlc1swXS5wYXR0ZXJuLmltYWdlSWQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdGFza1F1ZXVlLmVucXVldWUoe1xyXG4gICAgICAgICAgICAgICAgICAgIHByaW9yaXR5OiBRVUVVRV9UQVNLX1BSSU9SSVRJRVMuc2Vjb25kVGlsZVBvcnRpb24gK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9nZXRUaWxlUHJpb3JpdHkodGlsZSwgdGhpcy5faXNUaWxlVmlzaWJsZSh0aWxlKSksXHJcbiAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZTogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNUaWxlU3RpbGxBY3RpdmUodGlsZSwgcmVzcG9uc2UucmVxdWVzdElkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHV0VGlsZURhdGEodGlsZSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlnb25zOiB0aGlzLl9hbGxvY2F0ZVBvbHlnb25zKHJlc3BvbnNlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbHM6IHRoaXMuX2FsbG9jYXRlTWVzaGVzKHJlc3BvbnNlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlcm5hbE1lc2hlczogcmVzcG9uc2UuZXh0ZXJuYWxNZXNoZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9seWxpbmVzOiB0aGlzLl9hbGxvY2F0ZVBvbHlsaW5lcyhyZXNwb25zZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRMYWJlbHM6IHRoaXMuX2FsbG9jYXRlUG9pbnRMYWJlbHMocmVzcG9uc2UpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnZlZExhYmVsczogdGhpcy5fYWxsb2NhdGVDdXJ2ZWRMYWJlbHMocmVzcG9uc2UpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50czogdGhpcy5fYWxsb2NhdGVJY29ucyh0aWxlLCBpY29uc1NwbGl0dGVkLnByaW1pdGl2ZXNXaXRoQWxsb2NhdGVkSW1hZ2VzLCBpY29uc1NwbGl0dGVkLmFsbG9jYXRlZEltYWdlcyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZWRQb2x5bGluZXM6IHRoaXMuX2FsbG9jYXRlVGV4dHVyZWRQb2x5bGluZXModGlsZSwgdGV4dHVyZWRQb2x5bGluZXNTcGxpdHRlZC5wcmltaXRpdmVzV2l0aEFsbG9jYXRlZEltYWdlcywgdGV4dHVyZWRQb2x5bGluZXNTcGxpdHRlZC5hbGxvY2F0ZWRJbWFnZXMpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmVkUG9seWdvbnM6ICF0ZXh0dXJlZFBvbHlnb25zSW1hZ2VzLmFsbG9jYXRlZEltYWdlcyA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtdIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWxsb2NhdGVUZXh0dXJlZFBvbHlnb25zKHRpbGUsIHJlc3BvbnNlLnRleHR1cmVkUG9seWdvbnMsIHRleHR1cmVkUG9seWdvbnNJbWFnZXMuYWxsb2NhdGVkSW1hZ2VzLCByZXNwb25zZS50ZXh0dXJlZFBvbHlnb25QYWdlcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHJlcXVlc3RJZCwgIWlzUmVmcmVzaGluZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uc1NwbGl0dGVkLmFsbG9jYXRlZEltYWdlcy5mb3JFYWNoKHJlbGVhc2VQcmltaXRpdmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZWRQb2x5bGluZXNTcGxpdHRlZC5hbGxvY2F0ZWRJbWFnZXMuZm9yRWFjaChyZWxlYXNlUHJpbWl0aXZlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0dXJlZFBvbHlnb25zSW1hZ2VzLmFsbG9jYXRlZEltYWdlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmVkUG9seWdvbnNJbWFnZXMuYWxsb2NhdGVkSW1hZ2VzLmZvckVhY2gocmVsZWFzZVByaW1pdGl2ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0ZWRUaWxlRGF0YSA9IHRoaXMuX3JlcXVlc3RlZFRpbGVzU3RhdGUuZ2V0KGdldFRpbGVJZCh0aWxlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVxdWVzdGVkVGlsZURhdGEgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHRoZSBkYXRhIGlzIHN5bmNlZCBvbiB0aGVzZSB0d28gcHJvcGVydGllc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgIGFuZCB0aGlzIGNvZGUgZG9lc24ndCBtYWtlIG11Y2ggc2Vuc2UgZm9yIG5vdyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICBidXQgaXQgaXMgbGVmdCBcImFzIGlzXCIgc2luY2UgaXQgaXMgbm90IGNsZWFyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgaG93IGl0IHdpbGwgYmUgY2hhbmdlZCBpbiBuZWFyZXN0IGZ1dHVyZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RlZFRpbGVEYXRhLmlzR2VvbWV0cnlSZWFkeSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdGVkVGlsZURhdGEuYXJlTGFiZWxzUmVhZHkgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29uVGlsZURhdGFSZWFkeSh0aWxlLCByZXNwb25zZS51cmwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwdXREYXRhUHJvbWlzZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgIHB1dERhdGFQcm9taXNlcy5wdXNoKGljb25zU3BsaXR0ZWQubWlzc2luZ0ltYWdlcy50aGVuKChpbWFnZXMpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbk1pc3NpbmdJY29uSW1hZ2VzUmVhZHkocmVzcG9uc2UsIGljb25zU3BsaXR0ZWQsIGltYWdlcyk7XHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICBwdXREYXRhUHJvbWlzZXMucHVzaCh0ZXh0dXJlZFBvbHlsaW5lc1NwbGl0dGVkLm1pc3NpbmdJbWFnZXMudGhlbigoaW1hZ2VzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25NaXNzaW5nUG9seWxpbmVJbWFnZXNSZWFkeShyZXNwb25zZSwgdGV4dHVyZWRQb2x5bGluZXNTcGxpdHRlZCwgaW1hZ2VzKTtcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgIGlmICh0ZXh0dXJlZFBvbHlnb25zSW1hZ2VzLm1pc3NpbmdJbWFnZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBwdXREYXRhUHJvbWlzZXMucHVzaCh0ZXh0dXJlZFBvbHlnb25zSW1hZ2VzLm1pc3NpbmdJbWFnZXMudGhlbigoaW1hZ2VzKSA9PiB0aGlzLl9vbk1pc3NpbmdQb2x5Z29uSW1hZ2VzUmVhZHkocmVzcG9uc2UsIGltYWdlcykpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc1JlZnJlc2hpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIGFsbCB0aGUgcG9ydGlvbnMgYXJlIGxvYWRlZCwgcHV0IGVtcHR5IGRhdGEgdG8gdmlzdWF6bGl6ZSBpdFxyXG4gICAgICAgICAgICAgICAgICAgIFByb21pc2UuYWxsKHB1dERhdGFQcm9taXNlcykudGhlbigoKSA9PiB0aGlzLl9wdXRUaWxlRGF0YSh0aWxlLCB7fSwgcmVxdWVzdElkLCB0cnVlKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIF9vbk1pc3NpbmdJY29uSW1hZ2VzUmVhZHkocmVzcG9uc2UsIGljb25zU3BsaXR0ZWQsIGltYWdlcykge1xyXG4gICAgICAgIGNvbnN0IHRpbGUgPSByZXNwb25zZS50aWxlO1xyXG4gICAgICAgIHRoaXMuX21pbm9yVGFza1F1ZXVlLmVucXVldWUoe1xyXG4gICAgICAgICAgICBwcmlvcml0eTogREVGQVVMVF9JRExFX1RBU0tfUFJJT1JJVFkgK1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZ2V0VGlsZVByaW9yaXR5KHRpbGUsIHRoaXMuX2lzVGlsZVZpc2libGUodGlsZSkpLFxyXG4gICAgICAgICAgICBleGVjdXRlOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNUaWxlU3RpbGxBY3RpdmUodGlsZSwgcmVzcG9uc2UucmVxdWVzdElkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50cyA9IHRoaXMuX2FsbG9jYXRlSWNvbnModGlsZSwgaWNvbnNTcGxpdHRlZC5wcmltaXRpdmVzV2l0aE1pc3NpbmdJbWFnZXMsIGltYWdlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHV0VGlsZURhdGEodGlsZSwgeyBwb2ludHMgfSwgcmVzcG9uc2UucmVxdWVzdElkLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpbWFnZXMuZm9yRWFjaChyZWxlYXNlUHJpbWl0aXZlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX29uTWlzc2luZ1BvbHlsaW5lSW1hZ2VzUmVhZHkocmVzcG9uc2UsIHRleHR1cmVkUG9seWxpbmVzU3BsaXR0ZWQsIGltYWdlcykge1xyXG4gICAgICAgIGNvbnN0IHRpbGUgPSByZXNwb25zZS50aWxlO1xyXG4gICAgICAgIHRoaXMuX21pbm9yVGFza1F1ZXVlLmVucXVldWUoe1xyXG4gICAgICAgICAgICBwcmlvcml0eTogREVGQVVMVF9JRExFX1RBU0tfUFJJT1JJVFkgKyB0aGlzLl9nZXRUaWxlUHJpb3JpdHkodGlsZSwgdGhpcy5faXNUaWxlVmlzaWJsZSh0aWxlKSksXHJcbiAgICAgICAgICAgIGV4ZWN1dGU6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc1RpbGVTdGlsbEFjdGl2ZSh0aWxlLCByZXNwb25zZS5yZXF1ZXN0SWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dHVyZWRQb2x5bGluZXMgPSB0aGlzLl9hbGxvY2F0ZVRleHR1cmVkUG9seWxpbmVzKHRpbGUsIHRleHR1cmVkUG9seWxpbmVzU3BsaXR0ZWQucHJpbWl0aXZlc1dpdGhNaXNzaW5nSW1hZ2VzLCBpbWFnZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3B1dFRpbGVEYXRhKHRpbGUsIHsgdGV4dHVyZWRQb2x5bGluZXMgfSwgcmVzcG9uc2UucmVxdWVzdElkLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpbWFnZXMuZm9yRWFjaChyZWxlYXNlUHJpbWl0aXZlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX29uTWlzc2luZ1BvbHlnb25JbWFnZXNSZWFkeShyZXNwb25zZSwgaW1hZ2VzKSB7XHJcbiAgICAgICAgY29uc3QgdGlsZSA9IHJlc3BvbnNlLnRpbGU7XHJcbiAgICAgICAgdGhpcy5fbWlub3JUYXNrUXVldWUuZW5xdWV1ZSh7XHJcbiAgICAgICAgICAgIHByaW9yaXR5OiBERUZBVUxUX0lETEVfVEFTS19QUklPUklUWSArXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9nZXRUaWxlUHJpb3JpdHkodGlsZSwgdGhpcy5faXNUaWxlVmlzaWJsZSh0aWxlKSksXHJcbiAgICAgICAgICAgIGV4ZWN1dGU6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc1RpbGVTdGlsbEFjdGl2ZSh0aWxlLCByZXNwb25zZS5yZXF1ZXN0SWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dHVyZWRQb2x5Z29ucyA9IHRoaXMuX2FsbG9jYXRlVGV4dHVyZWRQb2x5Z29ucyh0aWxlLCByZXNwb25zZS50ZXh0dXJlZFBvbHlnb25zLCBpbWFnZXMsIHJlc3BvbnNlLnRleHR1cmVkUG9seWdvblBhZ2VzKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wdXRUaWxlRGF0YSh0aWxlLCB7IHRleHR1cmVkUG9seWdvbnMgfSwgcmVzcG9uc2UucmVxdWVzdElkLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpbWFnZXMuZm9yRWFjaChyZWxlYXNlUHJpbWl0aXZlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX29uVGlsZUVycm9yKHRpbGUpIHtcclxuICAgICAgICBzdXBlci5fb25UaWxlRXJyb3IodGlsZSk7XHJcbiAgICAgICAgdGhpcy5fcmVxdWVzdGVkVGlsZXNTdGF0ZS5kZWxldGUoZ2V0VGlsZUlkKHRpbGUpKTtcclxuICAgIH1cclxuICAgIF9pc1RpbGVWaXNpYmxlKHRpbGUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudFRpbGVzLmhhcyhnZXRUaWxlSWQodGlsZSkpO1xyXG4gICAgfVxyXG4gICAgX2FsbG9jYXRlUG9seWdvbnMocmVzcG9uc2UpIHtcclxuICAgICAgICBjb25zdCBwb2x5Z29uUHJpbWl0aXZlcyA9IG5ldyBBcnJheShyZXNwb25zZS5wb2x5Z29ucy5sZW5ndGggKyByZXNwb25zZS50cmFuc3BhcmVudFBvbHlnb25zLmxlbmd0aCk7XHJcbiAgICAgICAgY29uc3QgbWVtb3J5Q2h1bmtzID0gbmV3IE1lbW9yeUNodW5rcyhyZXNwb25zZS5wb2x5Z29uUGFnZXMsIHRoaXMuX21lbW9yeU1hbmFnZXIsIFBPTFlHT05fQVRUUklCVVRFX01BUFBJTkcpO1xyXG4gICAgICAgIGNvbnN0IHRyYW5zcGFyZW50UG9seWdvbnNNZW1vcnlDaHVua3MgPSBuZXcgTWVtb3J5Q2h1bmtzKHJlc3BvbnNlLnRyYW5zcGFyZW50UG9seWdvblBhZ2VzLCB0aGlzLl9tZW1vcnlNYW5hZ2VyLCBUUkFOU1BBUkVOVF9QT0xZR09OX0FUVFJJQlVURV9NQVBQSU5HKTtcclxuICAgICAgICBsZXQgaW5kZXggPSAwO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzcG9uc2UucG9seWdvbnMubGVuZ3RoOyBpKyssIGluZGV4KyspIHtcclxuICAgICAgICAgICAgY29uc3QgeyBidWZmZXJMb2NhdGlvbiB9ID0gcmVzcG9uc2UucG9seWdvbnNbaV07XHJcbiAgICAgICAgICAgIHBvbHlnb25QcmltaXRpdmVzW2luZGV4XSA9IG5ldyBSZW5kZXJhYmxlUG9seWdvbihuZXcgTWVtb3J5U3ViQ2h1bmsobWVtb3J5Q2h1bmtzW2J1ZmZlckxvY2F0aW9uLmJ1ZmZlckluZGV4XSwgYnVmZmVyTG9jYXRpb24pLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXNwb25zZS50cmFuc3BhcmVudFBvbHlnb25zLmxlbmd0aDsgaSsrLCBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgYnVmZmVyTG9jYXRpb24gfSA9IHJlc3BvbnNlLnRyYW5zcGFyZW50UG9seWdvbnNbaV07XHJcbiAgICAgICAgICAgIHBvbHlnb25QcmltaXRpdmVzW2luZGV4XSA9IG5ldyBSZW5kZXJhYmxlUG9seWdvbihuZXcgTWVtb3J5U3ViQ2h1bmsodHJhbnNwYXJlbnRQb2x5Z29uc01lbW9yeUNodW5rc1tidWZmZXJMb2NhdGlvbi5idWZmZXJJbmRleF0sIGJ1ZmZlckxvY2F0aW9uKSwgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtZW1vcnlDaHVua3MuZm9yRWFjaCgoY2h1bmspID0+IGNodW5rLnJlbGVhc2UoKSk7XHJcbiAgICAgICAgdHJhbnNwYXJlbnRQb2x5Z29uc01lbW9yeUNodW5rcy5mb3JFYWNoKChjaHVuaykgPT4gY2h1bmsucmVsZWFzZSgpKTtcclxuICAgICAgICByZXR1cm4gcG9seWdvblByaW1pdGl2ZXM7XHJcbiAgICB9XHJcbiAgICBfYWxsb2NhdGVUZXh0dXJlZFBvbHlnb25zKHRpbGUsIHBvbHlnb25EZXNjcmlwdGlvbnMsIGltYWdlcywgdGV4dHVyZWRQb2x5Z29uUGFnZXMpIHtcclxuICAgICAgICBjb25zdCB0ZXh0dXJlZFBvbHlnb25SZXdyaXRlciA9IG5ldyBUZXh0dXJlZFBvbHlnb25CdWZmZXJSZXdyaXRlcih0ZXh0dXJlZFBvbHlnb25QYWdlcyk7XHJcbiAgICAgICAgY29uc3Qgd29ybGRUb1B4RmFjdG9yID0gV09STERfU0laRSAvICh0aGlzLl90aWxlU2lkZVNpemVQeCAqIE1hdGgucG93KDIsIHRpbGUuem9vbSkpO1xyXG4gICAgICAgIGNvbnN0IGxvY2F0aW9ucyA9IHBvbHlnb25EZXNjcmlwdGlvbnMubWFwKChwYXJzZWRQb2x5Z29uLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBpbWFnZSA9IGltYWdlc1tpbmRleF07XHJcbiAgICAgICAgICAgIGlmIChpbWFnZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYWxsb2NhdGVkSW1hZ2UgPSBpbWFnZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSBwYXJzZWRQb2x5Z29uLnN0eWxlc1swXS5wYXR0ZXJuO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW1hZ2VTY2FsZSA9IHBhdHRlcm4ud2lkdGggLyBhbGxvY2F0ZWRJbWFnZS5kZXNjcmlwdG9yLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgdGV4dHVyZWRQb2x5Z29uUmV3cml0ZXIucmV3cml0ZVVWKHBhcnNlZFBvbHlnb24uYnVmZmVyTG9jYXRpb24sIGFsbG9jYXRlZEltYWdlLmJib3gsIHdvcmxkVG9QeEZhY3RvciAqIGltYWdlU2NhbGUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlZFBvbHlnb24uYnVmZmVyTG9jYXRpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IG1lbW9yeUNodW5rcyA9IG5ldyBNZW1vcnlDaHVua3ModGV4dHVyZWRQb2x5Z29uUGFnZXMsIHRoaXMuX21lbW9yeU1hbmFnZXIsIFRFWFRVUkVEX1BPTFlHT05fQVRUUklCVVRFX01BUFBJTkcpO1xyXG4gICAgICAgIGNvbnN0IHRleHR1cmVkUG9seWdvblByaW1pdGl2ZXMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxvY2F0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBsb2NhdGlvbiA9IGxvY2F0aW9uc1tpXTtcclxuICAgICAgICAgICAgY29uc3QgaW1hZ2UgPSBpbWFnZXNbaV07XHJcbiAgICAgICAgICAgIGlmIChsb2NhdGlvbiAmJiBpbWFnZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dHVyZWRQb2x5Z29uUHJpbWl0aXZlID0gbmV3IFJlbmRlcmFibGVUZXh0dXJlZFBvbHlnb24obmV3IE1lbW9yeVN1YkNodW5rKG1lbW9yeUNodW5rc1tsb2NhdGlvbi5idWZmZXJJbmRleF0sIGxvY2F0aW9uKSwgaW1hZ2UpO1xyXG4gICAgICAgICAgICAgICAgdGV4dHVyZWRQb2x5Z29uUHJpbWl0aXZlcy5wdXNoKHRleHR1cmVkUG9seWdvblByaW1pdGl2ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbWVtb3J5Q2h1bmtzLmZvckVhY2goKGNodW5rKSA9PiBjaHVuay5yZWxlYXNlKCkpO1xyXG4gICAgICAgIHJldHVybiB0ZXh0dXJlZFBvbHlnb25QcmltaXRpdmVzO1xyXG4gICAgfVxyXG4gICAgX2FsbG9jYXRlTWVzaGVzKHRpbGVSZXNwb25zZSkge1xyXG4gICAgICAgIGNvbnN0IG1lbW9yeUNodW5rcyA9IHRpbGVSZXNwb25zZS5tZXNoUGFnZXMubWFwKChwYWdlKSA9PiB0aGlzLl9tZW1vcnlNYW5hZ2VyLmFsbG9jYXRlKHBhZ2UudmVydGV4QnVmZmVyLCBwYWdlLmluZGV4QnVmZmVyLCBNb2RlbEJ1ZmZlcldyaXRlci5BVFRSSUJVVEVfTUFQUElORykpO1xyXG4gICAgICAgIGNvbnN0IG1lc2hQcmltaXRpdmVzID0gdGlsZVJlc3BvbnNlLm1lc2hlcy5tYXAoKG1lc2gpID0+IG5ldyBSZW5kZXJhYmxlTW9kZWwobmV3IE1lbW9yeVN1YkNodW5rKG1lbW9yeUNodW5rc1ttZXNoLmJ1ZmZlckxvY2F0aW9uLmJ1ZmZlckluZGV4XSwgbWVzaC5idWZmZXJMb2NhdGlvbikpKTtcclxuICAgICAgICBtZW1vcnlDaHVua3MuZm9yRWFjaCgoY2h1bmspID0+IGNodW5rLnJlbGVhc2UoKSk7XHJcbiAgICAgICAgcmV0dXJuIG1lc2hQcmltaXRpdmVzO1xyXG4gICAgfVxyXG4gICAgX2FsbG9jYXRlUG9seWxpbmVzKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgY29uc3QgcG9seWxpbmVQcmltaXRpdmVzID0gbmV3IEFycmF5KHJlc3BvbnNlLnBvbHlsaW5lcy5sZW5ndGgpO1xyXG4gICAgICAgIGNvbnN0IG1lbW9yeUNodW5rcyA9IG5ldyBNZW1vcnlDaHVua3MocmVzcG9uc2UucG9seWxpbmVQYWdlcywgdGhpcy5fbWVtb3J5TWFuYWdlciwgUE9MWUxJTkVfQVRUUklCVVRFX01BUFBJTkcpO1xyXG4gICAgICAgIGxldCBpbmRleCA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXNwb25zZS5wb2x5bGluZXMubGVuZ3RoOyBpKyssIGluZGV4KyspIHtcclxuICAgICAgICAgICAgY29uc3QgeyBidWZmZXJMb2NhdGlvbiB9ID0gcmVzcG9uc2UucG9seWxpbmVzW2ldO1xyXG4gICAgICAgICAgICBwb2x5bGluZVByaW1pdGl2ZXNbaW5kZXhdID0gbmV3IFJlbmRlcmFibGVQb2x5bGluZShuZXcgTWVtb3J5U3ViQ2h1bmsobWVtb3J5Q2h1bmtzW2J1ZmZlckxvY2F0aW9uLmJ1ZmZlckluZGV4XSwgYnVmZmVyTG9jYXRpb24pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbWVtb3J5Q2h1bmtzLmZvckVhY2goKGNodW5rKSA9PiBjaHVuay5yZWxlYXNlKCkpO1xyXG4gICAgICAgIHJldHVybiBwb2x5bGluZVByaW1pdGl2ZXM7XHJcbiAgICB9XHJcbiAgICBfYWxsb2NhdGVUZXh0dXJlZFBvbHlsaW5lcyh0aWxlLCBwYXJzZWRQb2x5bGluZXMsIGltYWdlcykge1xyXG4gICAgICAgIGNvbnN0IHRleHR1cmVkUG9seWxpbmVXcml0ZXIgPSBuZXcgVGV4dHVyZWRQb2x5bGluZUJ1ZmZlcldyaXRlcigpO1xyXG4gICAgICAgIGNvbnN0IHdvcmxkVG9QeEZhY3RvciA9IFdPUkxEX1NJWkUgLyAodGhpcy5fdGlsZVNpZGVTaXplUHggKiBNYXRoLnBvdygyLCB0aWxlLnpvb20pKTtcclxuICAgICAgICBjb25zdCBsb2NhdGlvbnMgPSBwYXJzZWRQb2x5bGluZXMubWFwKChwYXJzZWRQb2x5bGluZSwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaW1hZ2UgPSBpbWFnZXNbaW5kZXhdO1xyXG4gICAgICAgICAgICBpZiAoaW1hZ2UpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0eWxlID0gcGFyc2VkUG9seWxpbmUuc3R5bGVzWzBdO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgd2lkdGggPSAoc3R5bGUuaW5saW5lIHx8IHN0eWxlLm91dGxpbmUpLnN0cm9rZVdpZHRoO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW1hZ2VMb2NhdGlvbiA9IGltYWdlLmJib3g7XHJcbiAgICAgICAgICAgICAgICAvLyBpbWFnZSBzaXplIG1heSBub3QgbWF0Y2ggcG9seWxpbmUncyBzdHJva2VXaWR0aCwgc28gaXQgbXVzdCBiZSBzY2FsZWQgYWNjb3JkaW5nbHkgaW5cclxuICAgICAgICAgICAgICAgIC8vIGJvdGggZGlyZWN0aW9ucywgdGhpcyBmYWN0b3IgY2FuIGJlIHBhc3NlZCB0byB0aGUgd3JpdGVyIGluIHdvcmxkVG9QeEZhY3RvciB1cGRhdGVkLlxyXG4gICAgICAgICAgICAgICAgY29uc3QgcGl4ZWxSYXRpbyA9IHdpZHRoIC8gKGltYWdlTG9jYXRpb24ubWF4WSAtIGltYWdlTG9jYXRpb24ubWluWSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGV4dHVyZWRQb2x5bGluZVdyaXRlci53cml0ZVRleHR1cmVkUG9seWxpbmUocGFyc2VkUG9seWxpbmUsIHdpZHRoLCB3b3JsZFRvUHhGYWN0b3IgKiBwaXhlbFJhdGlvLCBpbWFnZUxvY2F0aW9uLCBzdHlsZS56SW5kZXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBwYWdlcyA9IHRleHR1cmVkUG9seWxpbmVXcml0ZXIuZ2V0QnVmZmVycygpO1xyXG4gICAgICAgIGNvbnN0IG1lbW9yeUNodW5rcyA9IG5ldyBNZW1vcnlDaHVua3MocGFnZXMsIHRoaXMuX21lbW9yeU1hbmFnZXIsIFRleHR1cmVkUG9seWxpbmVCdWZmZXJXcml0ZXIuQVRUUklCVVRFX01BUFBJTkcpO1xyXG4gICAgICAgIGNvbnN0IHRleHR1cmVkUG9seWxpbmVQcmltaXRpdmVzID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NhdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgbG9jYXRpb24gPSBsb2NhdGlvbnNbaV07XHJcbiAgICAgICAgICAgIGNvbnN0IGltYWdlID0gaW1hZ2VzW2ldO1xyXG4gICAgICAgICAgICBpZiAobG9jYXRpb24gJiYgaW1hZ2UpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRleHR1cmVkUG9seWxpbmVQcmltaXRpdmUgPSBuZXcgUmVuZGVyYWJsZVRleHR1cmVkUG9seWxpbmUobmV3IE1lbW9yeVN1YkNodW5rKG1lbW9yeUNodW5rc1tsb2NhdGlvbi5idWZmZXJJbmRleF0sIGxvY2F0aW9uKSwgaW1hZ2UpO1xyXG4gICAgICAgICAgICAgICAgdGV4dHVyZWRQb2x5bGluZVByaW1pdGl2ZXMucHVzaCh0ZXh0dXJlZFBvbHlsaW5lUHJpbWl0aXZlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBtZW1vcnlDaHVua3MuZm9yRWFjaCgoY2h1bmspID0+IGNodW5rLnJlbGVhc2UoKSk7XHJcbiAgICAgICAgcmV0dXJuIHRleHR1cmVkUG9seWxpbmVQcmltaXRpdmVzO1xyXG4gICAgfVxyXG4gICAgX2FsbG9jYXRlUG9pbnRMYWJlbHMocmVzcG9uc2UpIHtcclxuICAgICAgICBjb25zdCBtZW1vcnlDaHVua3MgPSBuZXcgTWVtb3J5Q2h1bmtzKHJlc3BvbnNlLnBvaW50TGFiZWxQYWdlcywgdGhpcy5fbWVtb3J5TWFuYWdlciwgUE9JTlRfTEFCRUxfQVRUUklCVVRFX01BUFBJTkcpO1xyXG4gICAgICAgIGNvbnN0IGJhY2tncm91bmRNZW1vcnlDaHVua3MgPSBuZXcgTWVtb3J5Q2h1bmtzKHJlc3BvbnNlLnBvaW50TGFiZWxCYWNrZ3JvdW5kUGFnZXMsIHRoaXMuX21lbW9yeU1hbmFnZXIsIEJJTExCT0FSRF9SRUNUQU5HTEVfQVRUUklCVVRFX01BUFBJTkcpO1xyXG4gICAgICAgIGNvbnN0IHBvaW50TGFiZWxzID0gcmVzcG9uc2UucG9pbnRMYWJlbHMubWFwKCh7IGJ1ZmZlckxvY2F0aW9uLCBiYWNrZ3JvdW5kQnVmZmVyTG9jYXRpb24gfSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBiYWNrZ3JvdW5kUHJpbWl0aXZlID0gYmFja2dyb3VuZEJ1ZmZlckxvY2F0aW9uID9cclxuICAgICAgICAgICAgICAgIG5ldyBSZW5kZXJhYmxlQmlsbGJvYXJkUmVjdGFuZ2xlKG5ldyBNZW1vcnlTdWJDaHVuayhiYWNrZ3JvdW5kTWVtb3J5Q2h1bmtzW2JhY2tncm91bmRCdWZmZXJMb2NhdGlvbi5idWZmZXJJbmRleF0sIGJhY2tncm91bmRCdWZmZXJMb2NhdGlvbikpIDpcclxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgY29uc3QgbGFiZWxQcmltaXRpdmUgPSBuZXcgWm9vbVJlc3RyaWN0ZWRMYWJlbChuZXcgTWVtb3J5U3ViQ2h1bmsobWVtb3J5Q2h1bmtzW2J1ZmZlckxvY2F0aW9uLmJ1ZmZlckluZGV4XSwgYnVmZmVyTG9jYXRpb24pLCB0aGlzLl9nbHlwaEF0bGFzLCB0aGlzLl9jb21wdXRlTWluWm9vbShyZXNwb25zZS50aWxlLCBNSU5aT09NX0RFTFRBUy5wb2ludExhYmVscyksIGJhY2tncm91bmRQcmltaXRpdmUpO1xyXG4gICAgICAgICAgICBpZiAoYmFja2dyb3VuZFByaW1pdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZFByaW1pdGl2ZS5yZWxlYXNlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGxhYmVsUHJpbWl0aXZlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGJhY2tncm91bmRNZW1vcnlDaHVua3MuZm9yRWFjaCgoY2h1bmspID0+IGNodW5rLnJlbGVhc2UoKSk7XHJcbiAgICAgICAgbWVtb3J5Q2h1bmtzLmZvckVhY2goKGNodW5rKSA9PiBjaHVuay5yZWxlYXNlKCkpO1xyXG4gICAgICAgIHJldHVybiBwb2ludExhYmVscztcclxuICAgIH1cclxuICAgIF9hbGxvY2F0ZUN1cnZlZExhYmVscyhyZXNwb25zZSkge1xyXG4gICAgICAgIGNvbnN0IG1lbW9yeUNodW5rcyA9IG5ldyBNZW1vcnlDaHVua3MocmVzcG9uc2UuY3VydmVkTGFiZWxQYWdlcywgdGhpcy5fbWVtb3J5TWFuYWdlciwgQ1VSVkVEX0xBQkVMX0FUVFJJQlVURV9NQVBQSU5HKTtcclxuICAgICAgICBjb25zdCBjdXJ2ZWRMYWJlbFByaW1pdGl2ZXMgPSByZXNwb25zZS5jdXJ2ZWRMYWJlbHMubWFwKCh7IGJ1ZmZlckxvY2F0aW9uIH0pID0+IG5ldyBab29tUmVzdHJpY3RlZExhYmVsKG5ldyBNZW1vcnlTdWJDaHVuayhtZW1vcnlDaHVua3NbYnVmZmVyTG9jYXRpb24uYnVmZmVySW5kZXhdLCBidWZmZXJMb2NhdGlvbiksIHRoaXMuX2dseXBoQXRsYXMsIHRoaXMuX2NvbXB1dGVNaW5ab29tKHJlc3BvbnNlLnRpbGUsIE1JTlpPT01fREVMVEFTLmN1cnZlZExhYmVscykpKTtcclxuICAgICAgICBtZW1vcnlDaHVua3MuZm9yRWFjaCgoY2h1bmspID0+IGNodW5rLnJlbGVhc2UoKSk7XHJcbiAgICAgICAgcmV0dXJuIGN1cnZlZExhYmVsUHJpbWl0aXZlcztcclxuICAgIH1cclxuICAgIF9hbGxvY2F0ZUljb25zKHRpbGUsIHBhcnNlZEljb25zLCBpbWFnZXMpIHtcclxuICAgICAgICBjb25zdCBpY29uV3JpdGVyID0gbmV3IEljb25CdWZmZXJXcml0ZXIoKTtcclxuICAgICAgICBjb25zdCBsb2NhdGlvbnMgPSBwYXJzZWRJY29ucy5tYXAoKHBhcnNlZEljb24sIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGltYWdlID0gaW1hZ2VzW2luZGV4XTtcclxuICAgICAgICAgICAgaWYgKGltYWdlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdHlsZSA9IHBhcnNlZEljb24uc3R5bGVzWzBdO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IGltYWdlLmRlc2NyaXB0b3I7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwaXhlbFJhdGlvID0gc3R5bGUud2lkdGggLyBzaXplLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGljb25Xcml0ZXIud3JpdGVJY29uKHBhcnNlZEljb24sIGltYWdlLmJib3gsIHNpemUsIHN0eWxlLm9mZnNldCwgcGl4ZWxSYXRpbyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IHBhZ2VzID0gaWNvbldyaXRlci5nZXRCdWZmZXJzKCk7XHJcbiAgICAgICAgY29uc3QgbWVtb3J5Q2h1bmtzID0gbmV3IE1lbW9yeUNodW5rcyhwYWdlcywgdGhpcy5fbWVtb3J5TWFuYWdlciwgSWNvbkJ1ZmZlcldyaXRlci5BVFRSSUJVVEVfTUFQUElORyk7XHJcbiAgICAgICAgY29uc3QgaWNvblByaW1pdGl2ZXMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxvY2F0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBsb2NhdGlvbiA9IGxvY2F0aW9uc1tpXTtcclxuICAgICAgICAgICAgY29uc3QgaW1hZ2UgPSBpbWFnZXNbaV07XHJcbiAgICAgICAgICAgIGlmIChsb2NhdGlvbiAmJiBpbWFnZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaWNvblByaW1pdGl2ZSA9IG5ldyBab29tUmVzdHJpY3RlZEljb24obmV3IE1lbW9yeVN1YkNodW5rKG1lbW9yeUNodW5rc1tsb2NhdGlvbi5idWZmZXJJbmRleF0sIGxvY2F0aW9uKSwgaW1hZ2UsIHRoaXMuX2NvbXB1dGVNaW5ab29tKHRpbGUsIE1JTlpPT01fREVMVEFTLmljb25zKSk7XHJcbiAgICAgICAgICAgICAgICBpY29uUHJpbWl0aXZlcy5wdXNoKGljb25QcmltaXRpdmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1lbW9yeUNodW5rcy5mb3JFYWNoKChjaHVuaykgPT4gY2h1bmsucmVsZWFzZSgpKTtcclxuICAgICAgICByZXR1cm4gaWNvblByaW1pdGl2ZXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbXB1dGVzIGEgbWluaW11bSB6b29tIGFuIG9iamVjdCBzaG91bGQgYmUgc3RpbGwgZGlzcGxheWVkIG9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0aWxlIFRpbGUgdGhlIG9iamVjdCBiZWxvbmdzIHRvLlxyXG4gICAgICogQHBhcmFtIGRlbHRhIFRvbGVyYW5jZSBvZiB0aGUgdmlzaWJpbGl0eSB0byB6b29taW5nIG91dCwgZGVmYXVsdCB2YWx1ZSB3YXMgZW1waXJpY2FsbHkgY2hvc2VuLlxyXG4gICAgICogQHJldHVybnMgTWluaW11bSB6b29tIGZvciB0aGUgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBfY29tcHV0ZU1pblpvb20odGlsZSwgZGVsdGEgPSAxKSB7XHJcbiAgICAgICAgcmV0dXJuIHRpbGUuem9vbSAtIHRoaXMuX3pvb21TaGlmdCAtIHRoaXMuX3RhcmdldFpvb21TaGlmdCAtIGRlbHRhO1xyXG4gICAgfVxyXG4gICAgX3B1c2hQZXJmTG9nSXRlbSh0aWxlLCBwYXJzZVRpbWUpIHtcclxuICAgICAgICBpZiAodGhpcy5fcGVyZkxvZ0l0ZW1zLmxlbmd0aCA8IE1BWF9QRVJGX0xPR19JVEVNU19DT1VOVCkge1xyXG4gICAgICAgICAgICB0aGlzLl9wZXJmTG9nSXRlbXMucHVzaCh7IHRpbGUsIHBhcnNlVGltZSB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEhlbHBlciBjbGFzcyBmb3IgYWxsb2NhdGlvbiBvZiBhbiBhcnJheSBvZiBtZW1vcnkgY2h1bmtzLlxyXG4gKi9cclxuY2xhc3MgTWVtb3J5Q2h1bmtzIGV4dGVuZHMgQXJyYXkge1xyXG4gICAgY29uc3RydWN0b3IocGFnZXMsIG1lbW9yeU1hbmFnZXIsIGF0dHJpYk1hcHBpbmcpIHtcclxuICAgICAgICBzdXBlcihwYWdlcy5sZW5ndGgpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFnZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpc1tpXSA9IG1lbW9yeU1hbmFnZXIuYWxsb2NhdGUocGFnZXNbaV0udmVydGV4QnVmZmVyLCBwYWdlc1tpXS5pbmRleEJ1ZmZlciwgYXR0cmliTWFwcGluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBEYXRhIG1hbmFnZXJzIHJlc3BvbnNpYmxlIGZvciBzcGVjaWZpYyB0eXBlIG9mIHByaW1pdGl2ZXMuIEl0IGp1c3QgZXh0cmFjdHMgdGhlbSBmcm9tIFRpbGVEYXRhIGFuZFxyXG4gKiB1cGRhdGVzIGFwcHJvcHJpYXRlIHByaW1pdGl2ZSBwcm92aWRlci5cclxuICovXHJcbmNsYXNzIFRpbGVEYXRhTWFuYWdlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihwcmltaXRpdmVNYW5hZ2VyLCBwcmltaXR2ZUV4dHJhY3Rvcikge1xyXG4gICAgICAgIHRoaXMuX3ByaW1pdGl2ZU1hbmFnZXIgPSBwcmltaXRpdmVNYW5hZ2VyO1xyXG4gICAgICAgIHRoaXMuX3ByaW1pdGl2ZUV4dHJhY3RvciA9IHByaW1pdHZlRXh0cmFjdG9yO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlUHJpbWl0aXZlcyh0b1Nob3csIHRvSGlkZSkge1xyXG4gICAgICAgIHRoaXMuX3ByaW1pdGl2ZU1hbmFnZXIudXBkYXRlU2NlbmUodGhpcy5fcHJpbWl0aXZlRXh0cmFjdG9yKHRvU2hvdyksIHRoaXMuX3ByaW1pdGl2ZUV4dHJhY3Rvcih0b0hpZGUpKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiByZWxlYXNlUHJpbWl0aXZlKHByaW1pdGl2ZSkge1xyXG4gICAgaWYgKHByaW1pdGl2ZSkge1xyXG4gICAgICAgIHByaW1pdGl2ZS5yZWxlYXNlKCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFR1cm5zIHJlamVjdGlvbiBvZiBvcmlnaW5hbCBwcm9taXNlIGludG8gbnVsbC12YWx1ZSByZXNvbHV0aW9uLiBOdWxscyBvbiBhcHByb3ByaWF0ZSBwbGFjZXNcclxuICogYXJlIHJlcXVpcmVkIGluIGFsbG9jYXRpb24gb2YgdGV4dHVyZWQgcHJpbWl0aXZlcy5cclxuICovXHJcbmZ1bmN0aW9uIG51bGxpZnlSZWplY3Rpb24ocHJvbWlzZSkge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBwcm9taXNlLnRoZW4ocmVzb2x2ZSwgKCkgPT4gcmVzb2x2ZShudWxsKSkpO1xyXG59XHJcbi8qKlxyXG4gKiBTcGxpdHMgcHJpbWl0aXZlcyBpbnRvIHR3byBsaXN0czogdGhvc2UgdGhhdCBoYXZlIHJlcXVpcmVkIGltYWdlcyBhbGxvY2F0ZWQgYW5kIHRob3NlIHdoaWNoIGltYWdlcyBhcmUgdG8gYmVcclxuICogcmVxdWVzdGVkLiBSZXF1aXJlZCBpbWFnZXMgcmV0dXJuZWQgaW4gY29ycmVzcG9uaW5nIGFycmF5cyAocmVxdWVzdGVkIGltYWdlcyBhcyBwcm9taXNlcykuXHJcbiAqL1xyXG5mdW5jdGlvbiBzcGxpdEltYWdlRGVwZW5kYW50UHJpbWl0aXZlcyhwcmltaXRpdmVzLCBpbWFnZU1hbmFnZXIsIGlkTWFwcGVyKSB7XHJcbiAgICBjb25zdCBwcmltaXRpdmVzV2l0aEFsbG9jYXRlZEltYWdlcyA9IFtdO1xyXG4gICAgY29uc3QgYWxsb2NhdGVkSW1hZ2VzID0gW107XHJcbiAgICBjb25zdCBwcmltaXRpdmVzV2l0aE1pc3NpbmdJbWFnZXMgPSBbXTtcclxuICAgIGNvbnN0IG1pc3NpbmdJbWFnZUlkcyA9IFtdO1xyXG4gICAgZm9yIChjb25zdCBwcmltaXRpdmUgb2YgcHJpbWl0aXZlcykge1xyXG4gICAgICAgIGNvbnN0IGlkID0gaWRNYXBwZXIocHJpbWl0aXZlKTtcclxuICAgICAgICBjb25zdCBhbGxvY2F0ZWRJbWFnZSA9IGltYWdlTWFuYWdlci5nZXRJbWFnZShpZCk7XHJcbiAgICAgICAgaWYgKGFsbG9jYXRlZEltYWdlKSB7XHJcbiAgICAgICAgICAgIHByaW1pdGl2ZXNXaXRoQWxsb2NhdGVkSW1hZ2VzLnB1c2gocHJpbWl0aXZlKTtcclxuICAgICAgICAgICAgYWxsb2NhdGVkSW1hZ2VzLnB1c2goYWxsb2NhdGVkSW1hZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcHJpbWl0aXZlc1dpdGhNaXNzaW5nSW1hZ2VzLnB1c2gocHJpbWl0aXZlKTtcclxuICAgICAgICAgICAgbWlzc2luZ0ltYWdlSWRzLnB1c2gobnVsbGlmeVJlamVjdGlvbihpbWFnZU1hbmFnZXIucmVxdWVzdEltYWdlKGlkKSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcHJpbWl0aXZlc1dpdGhBbGxvY2F0ZWRJbWFnZXMsXHJcbiAgICAgICAgYWxsb2NhdGVkSW1hZ2VzLFxyXG4gICAgICAgIHByaW1pdGl2ZXNXaXRoTWlzc2luZ0ltYWdlcyxcclxuICAgICAgICBtaXNzaW5nSW1hZ2VzOiBQcm9taXNlLmFsbChtaXNzaW5nSW1hZ2VJZHMpXHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGVpdGhlciBhcnJheSBvZiBhbGxvY2F0ZWQgaW1hZ2VzIChpZiBhbGwgcmVxdWlyZWQgaW1hZ2VzIGFyZSBvbiB0aGUgc3BvdCkgb3IgcHJvbWlzZXMgZm9yIHRoZW0gKGlmIGF0IGxlYXN0XHJcbiAqIG9uZSByZXF1aXJlZCBpbWFnZSBpcyBub3QgeWV0IGFsbG9jYXRlZCkuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRJbWFnZXNJZkFsbEFsbG9jYXRlZChwcmltaXRpdmVzLCBpbWFnZU1hbmFnZXIsIGlkTWFwcGVyKSB7XHJcbiAgICBsZXQgaXNBbnlNaXNzaW5nID0gZmFsc2U7XHJcbiAgICBjb25zdCBhbGxvY2F0ZWRJbWFnZXMgPSBuZXcgQXJyYXkocHJpbWl0aXZlcy5sZW5ndGgpO1xyXG4gICAgY29uc3QgbWlzc2luZ0ltYWdlcyA9IG5ldyBBcnJheShwcmltaXRpdmVzLmxlbmd0aCk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByaW1pdGl2ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBwcmltaXRpdmUgPSBwcmltaXRpdmVzW2ldO1xyXG4gICAgICAgIGNvbnN0IGlkID0gaWRNYXBwZXIocHJpbWl0aXZlKTtcclxuICAgICAgICBjb25zdCBhbGxvY2F0ZWRJbWFnZSA9IGltYWdlTWFuYWdlci5nZXRJbWFnZShpZCk7XHJcbiAgICAgICAgaWYgKGFsbG9jYXRlZEltYWdlKSB7XHJcbiAgICAgICAgICAgIGFsbG9jYXRlZEltYWdlc1tpXSA9IGFsbG9jYXRlZEltYWdlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaXNBbnlNaXNzaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgbWlzc2luZ0ltYWdlc1tpXSA9IG51bGxpZnlSZWplY3Rpb24oaW1hZ2VNYW5hZ2VyLnJlcXVlc3RJbWFnZShpZCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChpc0FueU1pc3NpbmcpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByaW1pdGl2ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGFsbG9jYXRlZEltYWdlc1tpXSkge1xyXG4gICAgICAgICAgICAgICAgbWlzc2luZ0ltYWdlc1tpXSA9IFByb21pc2UucmVzb2x2ZShhbGxvY2F0ZWRJbWFnZXNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IG1pc3NpbmdJbWFnZXM6IFByb21pc2UuYWxsKG1pc3NpbmdJbWFnZXMpIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4geyBhbGxvY2F0ZWRJbWFnZXMgfTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9hZGFwdGVycy92ZWN0b3JfYXBpL2FkYXB0ZXIudHNcbi8vIG1vZHVsZSBpZCA9IDY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBBZGFwdGVyIGZyb20gJy4uL2FkYXB0ZXInO1xyXG5pbXBvcnQgVGlsZUNvb3JkaW5hdGVTeXN0ZW0sIHsgaXNQYXJlbnQgfSBmcm9tICcuL3V0aWwvdGlsZV9zeXN0ZW0nO1xyXG5pbXBvcnQgeyBhbGxPZkl0ZXJhYmxlLCBvbmVPZkl0ZXJhYmxlIH0gZnJvbSAnLi4vLi4vdXRpbC9pdGVyYWJsZSc7XHJcbmltcG9ydCB7IGdldFRpbGVJZCB9IGZyb20gJy4vdGlsZV9pZCc7XHJcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJy4uLy4uL3V0aWwvZXZlbnRfZW1pdHRlcic7XHJcbmltcG9ydCAqIGFzIHZlYzIgZnJvbSAnLi4vLi4vbWF0aC92ZWN0b3IyJztcclxuaW1wb3J0IHsgTk9fSUQgfSBmcm9tICcuLi8uLi91dGlsL3dvcmtlcic7XHJcbmltcG9ydCB7IGNvbXB1dGVWaXNpYmxlVGlsZXMgfSBmcm9tICcuL3V0aWwvdmlzaWJsZV90aWxlJztcclxuaW1wb3J0IHsgY2FsY3VsYXRlQmVsdFRpbGVzIH0gZnJvbSAnLi9iZWx0X3RpbGVzJztcclxuaW1wb3J0IHsgY291bnRUaWxlUHJvY2Vzc2luZ1RpbWUgfSBmcm9tICcuLi8uLi91dGlsL3N0YXQnO1xyXG5jb25zdCBOT19USUxFU19UT19IQU5ETEUgPSBbXTtcclxuY29uc3QgTUFYX1BFUkZfTE9HX0lURU1TX0NPVU5UID0gMTAyNDtcclxuLy8gVG8gc2VsZWN0IHdoaWNoIHRpbGUgdG8gbG9hZCBjYW1lcmEgem9vbSBpcyByb3VuZGVkIHNvIHRoZSBzaGlmdCBpcyAwLjUuXHJcbmNvbnN0IFRBUkdFVF9aT09NX1NISUZUID0gMC4yNTtcclxuY29uc3QgVklTSUJMRV9USUxFX1BSSU9SSVRZID0gMjAwO1xyXG5mdW5jdGlvbiogZmxhdHRlblZpc2libGVEYXRhUG9ydGlvbnModGlsZXMpIHtcclxuICAgIGZvciAoY29uc3QgdGlsZSBvZiB0aWxlcykge1xyXG4gICAgICAgIHlpZWxkKiB0aWxlLmRhdGEudmlzaWJsZTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRab29tU2hpZnQodGlsZVNpemUpIHtcclxuICAgIHN3aXRjaCAodGlsZVNpemUpIHtcclxuICAgICAgICBjYXNlIDEgLyogWDQgKi86XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICBjYXNlIDIgLyogWDE2ICovOlxyXG4gICAgICAgICAgICByZXR1cm4gLTI7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEJhc2UgY2xhc3MgZm9yIGFkYXB0ZXJzIHRoYXQgZ2V0IHRoZWlyIGRhdGEgaW4gdGlsZXMuIENvbnRlbnQgb2YgdGlsZXMgdGhhdCBjb21lIGludG8gZmllbGQgb2YgdmlldyBzaG91bGRcclxuICogYmUgcmVxdWVzdGVkLCBhcyB3ZWxsIGFzIGNvbnRlbnQgb2YgaW52aXNpYmxlIHRpbGVzIHNob3VsZCBiZSByZW1vdmVkLCBhbHNvIHRpbGVzIG9uIGRpZmZlcmVudCB6b29tIGxldmVscyBjYW5cclxuICogb3ZlcmxhcCBlYWNoIG90aGVyLiBNYW5hZ2luZyBvZiBhbGwgdGhlc2UgY2FzZXMgYW5kIG90aGVyIHRpbGUtc3BlY2lmaWMgbG9naWMgaXMgdGhlIHJlc3BvbnNpYmlsaXR5IG9mIHRoaXMgY2xhc3MuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaWxlQmFzZWRBZGFwdGVyIGV4dGVuZHMgQWRhcHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihlbmdpbmUsIGNhbWVyYSwgdGlsZVNpemUgPSAwIC8qIFgxICovLCBwcmVsb2FkZWRUaWxlc0JlbHRTaXplID0gMCwgbGF5ZXJOYW1lID0gJycpIHtcclxuICAgICAgICBzdXBlcihlbmdpbmUsIGNhbWVyYSk7XHJcbiAgICAgICAgdGhpcy5fbGF5ZXJOYW1lID0gbGF5ZXJOYW1lO1xyXG4gICAgICAgIHRoaXMuX3pvb21TaGlmdCA9IGdldFpvb21TaGlmdCh0aWxlU2l6ZSk7XHJcbiAgICAgICAgdGhpcy5fdGFyZ2V0Wm9vbVNoaWZ0ID0gVEFSR0VUX1pPT01fU0hJRlQ7XHJcbiAgICAgICAgdGhpcy5fZW5naW5lUmVuZGVyTGlzdGVuZXIgPSAoKSA9PiB0aGlzLl9vbkVuZ2luZVJlbmRlckV2ZW50KCk7XHJcbiAgICAgICAgdGhpcy5lbmdpbmUucmVuZGVyZXIub25SZW5kZXIuYWRkTGlzdGVuZXIodGhpcy5fZW5naW5lUmVuZGVyTGlzdGVuZXIpO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRUaWxlcyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLl9hbGxUaWxlcyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLl9yZWFkeUZvclJlbmRlclRpbGVzID0gW107XHJcbiAgICAgICAgdGhpcy5vblRpbGVSZWFkeSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLm9uVGlsZUxvYWRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5fcmVxdWVzdGVkVGlsZXMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5fdGlsZXNUb1JlZnJlc2ggPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgdGhpcy5fYmVsdFNpemUgPSBwcmVsb2FkZWRUaWxlc0JlbHRTaXplO1xyXG4gICAgICAgIC8vIFNvbWV0aW1lcyB0aGUgYWRhcHRlciBpc24ndCBkZXN0cm95ZWQsIGp1c3QgdGhlIHBhZ2UgY2xvc2VzLiBMaXN0ZW5cclxuICAgICAgICAvLyBmb3IgdGhhdCBhbmQgc2VuZCBtZWFzdXJlbWVudHMgdG8gdGhlIHN0YXRmYWNlLlxyXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCB0aGlzLl9vbkJlZm9yZVVubG9hZExpc3RlbmVyID0gdGhpcy5fc2VuZFN0YXRpc3RpY3NCZWZvcmVEZXN0cm95LmJpbmQodGhpcykpO1xyXG4gICAgICAgIHRoaXMuX3RpbGVMb2FkTG9ncyA9IFtdO1xyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgdGhpcy5fb25CZWZvcmVVbmxvYWRMaXN0ZW5lcik7XHJcbiAgICAgICAgdGhpcy5fc2VuZFN0YXRpc3RpY3NCZWZvcmVEZXN0cm95KCk7XHJcbiAgICAgICAgdGhpcy5lbmdpbmUucmVuZGVyZXIub25SZW5kZXIucmVtb3ZlTGlzdGVuZXIodGhpcy5fZW5naW5lUmVuZGVyTGlzdGVuZXIpO1xyXG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcclxuICAgIH1cclxuICAgIGdldFZpc2libGVUaWxlc051bWJlcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudFRpbGVzLnNpemU7XHJcbiAgICB9XHJcbiAgICBnZXRQZW5kaW5nVGlsZXNOdW1iZXIoKSB7XHJcbiAgICAgICAgbGV0IHBlbmRpbmdDb3VudGVyID0gMDtcclxuICAgICAgICB0aGlzLl9yZXF1ZXN0ZWRUaWxlcy5mb3JFYWNoKChyZXF1ZXN0ZWRUaWxlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50VGlsZXMuZ2V0KGdldFRpbGVJZChyZXF1ZXN0ZWRUaWxlLnRpbGVJdGVtKSkpIHtcclxuICAgICAgICAgICAgICAgIHBlbmRpbmdDb3VudGVyKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcGVuZGluZ0NvdW50ZXI7XHJcbiAgICB9XHJcbiAgICBfZ2V0VGFyZ2V0Wm9vbSgpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcih0aGlzLmNhbWVyYS56b29tICsgdGhpcy5fdGFyZ2V0Wm9vbVNoaWZ0KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHRpbGVJdGVtIFRoZSB0aWxlIHRvIHdoaWNoIHRoZSBkYXRhIGJlbG9uZ3MuXHJcbiAgICAgKiBAcGFyYW0gZGF0YSBEYXRhIHBvcnRpb24gdG8gYmUgc2hvd24gaW4gdGlsZSBvbmNlIGl0IGlzIHJlYWR5IHRvIHZpc3VhbGl6ZS5cclxuICAgICAqIEBwYXJhbSByZXF1ZXN0SWQgSUQgb2YgdGhlIHJlcXVlc3QgZGF0YSB3YXMgcmVxdWVzdGVkIHdpdGguIEJhc2VkIG9uIHRoaXMgdGhlIGRhdGEgaXMgYmVpbmcgZGlzcGxheWVkLCBzdG9yZWQgZm9yXHJcbiAgICAgKiBmdXR1cmUgdXNlIG9yIGRpc2NhcmRlZC5cclxuICAgICAqIEBwYXJhbSB2aXN1YWxpemUgSXMgdGhpcyBkYXRhIHBvcnRpb24gZW5vdWdoIHRvIHJlbmRlciB0aGlzIHRpbGUgYW5kIHJlcGxhY2Ugb3ZlcmxhcHBlZCBvbmVzIGlmIGFueS5cclxuICAgICAqL1xyXG4gICAgX3B1dFRpbGVEYXRhKHRpbGVJdGVtLCBkYXRhLCByZXF1ZXN0SWQgPSBOT19JRCwgdmlzdWFsaXplID0gdHJ1ZSkge1xyXG4gICAgICAgIGNvbnN0IHRpbGUgPSB0aGlzLl9hbGxUaWxlcy5nZXQoZ2V0VGlsZUlkKHRpbGVJdGVtKSk7XHJcbiAgICAgICAgaWYgKCF0aWxlKSB7XHJcbiAgICAgICAgICAgIC8vIERhdGEgcmVjaWV2ZWQgbGF0ZSBhbmQgcHJvYmFibHkgdGhlIHRpbGUgaGFkIGJlZW4gZGVzdHJveWVkLlxyXG4gICAgICAgICAgICAvLyBEZXN0cm95IGRhdGEgdG9vLlxyXG4gICAgICAgICAgICB0aGlzLl9vblRpbGVEZXN0cm95KHRpbGVJdGVtLCBbZGF0YV0pO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE5PX0lEIHBhc3NlZCBoZXJlIG1lYW5zIGNvbmNyZXRlIGFkYXB0ZXIgZG9lc24ndCBjYXJlIHRvIGxhYmVsIHRpbGUgZGF0YSB3aXRoIGEgcmVxdWVzdElkIHdoaWNoIG1vc3QgbGlrZWx5XHJcbiAgICAgICAgLy8gbWVhbnMgYWRhcHRlciBrZWVwcyBpdHMgZGF0YSBhcyBhIHdob2xlLCBub3Qgc3BsaXR0aW5nIGl0IGludG8gcG9ydGlvbnMgYW5kLCB0aGVyZWZvcmUsIGRvZXNuJ3QgbmVlZCBpdHMgZGF0YVxyXG4gICAgICAgIC8vIHRvIGJlIG1haW50YWluZWQgc2VwYXJhdGVseSBhcyB2aXNpYmxlL2FjdHVhbC4gSW4gdGhpcyBjYXNlIHRoZSBkYXRhIGlzIGFsd2F5cyB0cmVhdGVkIGxpa2UgYW4gYWN0dWFsIGRhdGEuXHJcbiAgICAgICAgaWYgKHJlcXVlc3RJZCA9PT0gdGlsZS5kYXRhLnZpc2libGVSZXF1ZXN0SWQgJiYgcmVxdWVzdElkICE9PSBOT19JRCkge1xyXG4gICAgICAgICAgICB0aWxlLmRhdGEudmlzaWJsZS5wdXNoKGRhdGEpO1xyXG4gICAgICAgICAgICBpZiAodGlsZS5pc1Zpc2libGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZSBkYXRhIGlzIGN1cnJlbnRseSBkaXNwbGF5ZWQgc28gdGhlIG5ldyBwb3J0aW9uIGlzIGFkZGVkIHRvIHRoZSBzY2VuZS5cclxuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVRpbGVEYXRhUG9ydGlvbnMoW2RhdGFdLCBbXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocmVxdWVzdElkID09PSB0aWxlLmRhdGEuYWN0dWFsUmVxdWVzdElkKSB7XHJcbiAgICAgICAgICAgIC8vIFRoZSBkYXRhIGlzIGFjdHVhbCBhbmQgZWl0aGVyIGlzIGp1c3QgYmVpbmcgcHV0IGludG8gdGhlIHRpbGUgb3IgdmlzdWFsaXplcyBhbGwgYGFjdHVhbGAgdGlsZSBkYXRhLlxyXG4gICAgICAgICAgICB0aGlzLl9wdXRBY3R1YWxUaWxlRGF0YSh0aWxlLCBkYXRhLCB2aXN1YWxpemUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gVGhlIGRhdGEgaXMgbmVpdGhlciB2aXNpYmxlIG5vciBhY3R1YWwuIERlc3Ryb3kgZGF0YS5cclxuICAgICAgICAgICAgdGhpcy5fb25UaWxlRGVzdHJveSh0aWxlSXRlbSwgW2RhdGFdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfb25DYW1lcmFVcGRhdGUoKSB7XHJcbiAgICAgICAgY29uc3QgY2FtZXJhID0gdGhpcy5jYW1lcmE7XHJcbiAgICAgICAgY29uc3Qgem9vbSA9IHRoaXMuX2dldFRhcmdldFpvb20oKTtcclxuICAgICAgICBjb25zdCBuZXdDdXJyZW50ID0gbmV3IFNldChjb21wdXRlVmlzaWJsZVRpbGVzKGNhbWVyYS5nZXRWaXNpYmxlUmVnaW9uKCksIGNhbWVyYS5nZXRWaXNpYmxlUmVnaW9uQkJveCgpLCBjYW1lcmEub3B0aW9ucy53cmFwTW9kZVgsIGNhbWVyYS5vcHRpb25zLndyYXBNb2RlWSwgTWF0aC5tYXgoMCwgem9vbSArIHRoaXMuX3pvb21TaGlmdCkpKTtcclxuICAgICAgICAvLyB0aGlzLl9jdXJyZW50VGlsZXMgY29udGFpbnMgY3VycmVudGx5IHZpc2libGUgdGlsZXMsIG5ld0N1cnJlbnQgY29udGFpbnMgc2V0IG9mIHRpbGVzIHZpc2libGUgZnJvbSB1cGRhdGVkXHJcbiAgICAgICAgLy8gY2FtZXJhIHBvc2l0aW9uLCBjb21wYXJlIHRoZXNlIHR3byBzZXRzIGFuZCBjYWxsIHRoaXMuX29uVmlzaWJsZVRpbGVzQ2hhbmdlZCgpIGlmIHRoZXJlIGlzIGEgZGlmZmVyZW5jZS5cclxuICAgICAgICBpZiAobmV3Q3VycmVudC5zaXplICE9PSB0aGlzLl9jdXJyZW50VGlsZXMuc2l6ZSB8fFxyXG4gICAgICAgICAgICBvbmVPZkl0ZXJhYmxlKG5ld0N1cnJlbnQsICh0aWxlKSA9PiAhdGhpcy5fY3VycmVudFRpbGVzLmhhcyhnZXRUaWxlSWQodGlsZSkpKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9vblZpc2libGVUaWxlc0NoYW5nZWQobmV3Q3VycmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHRoaXMgY2hlY2tzIHByZXZlbnRzIGxlYWtzIG9mIHRpbGVzIHdoZW4gcXVpY2sgem9vbS1pbi96b29tLW91dCBoYXBwZW5zXHJcbiAgICAgICAgZm9yIChjb25zdCB0aWxlIG9mIHRoaXMuX2N1cnJlbnRUaWxlcy52YWx1ZXMoKSkge1xyXG4gICAgICAgICAgICBpZiAodGlsZS5pc1JlYWR5VG9WaXN1YWxpemUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrVGlsZVJlcGxhY2VtZW50cyh0aWxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9vblRpbGVzUmVxdWVzdChyZXF1ZXN0cywgcmVxdWVzdElkID0gTk9fSUQpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IHRpbGVSZXF1ZXN0IG9mIHJlcXVlc3RzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RlZFRpbGVEYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgaW5mbzoge1xyXG4gICAgICAgICAgICAgICAgICAgIHByaW9yaXR5OiB0aWxlUmVxdWVzdC5wcmlvcml0eVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGxvYWRUaW1lc3RhbXBzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcXVldWVkOiBwZXJmb3JtYW5jZS5ub3coKSxcclxuICAgICAgICAgICAgICAgICAgICBsb2FkZWQ6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZWQ6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVhZHk6IDBcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB0aWxlSXRlbTogdGlsZVJlcXVlc3RcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3QgdGlsZUlkID0gZ2V0VGlsZUlkKHRpbGVSZXF1ZXN0KTtcclxuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdGVkVGlsZXMuc2V0KHRpbGVJZCwgcmVxdWVzdGVkVGlsZURhdGEpO1xyXG4gICAgICAgICAgICB0aGlzLl9yZWFkeVRpbGVzQ2hhbmdlID0gdHJ1ZTtcclxuICAgICAgICAgICAgY29uc3QgdGlsZSA9IHRoaXMuX2FsbFRpbGVzLmdldCh0aWxlSWQpO1xyXG4gICAgICAgICAgICBpZiAodGlsZSkge1xyXG4gICAgICAgICAgICAgICAgdGlsZS5kYXRhLmFjdHVhbFJlcXVlc3RJZCA9IHJlcXVlc3RJZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9vbkNhbmNlbFRpbGVSZXF1ZXN0cyhyZXF1ZXN0cykge1xyXG4gICAgICAgIGZvciAoY29uc3QgcmVxdWVzdCBvZiByZXF1ZXN0cykge1xyXG4gICAgICAgICAgICBjb25zdCB0aWxlSWQgPSBnZXRUaWxlSWQocmVxdWVzdC50aWxlKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3JlcXVlc3RlZFRpbGVzLmRlbGV0ZSh0aWxlSWQpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWFkeVRpbGVzQ2hhbmdlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RpbGVzVG9SZWZyZXNoLmRlbGV0ZSh0aWxlSWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX29uVGlsZUVycm9yKHRpbGVJdGVtKSB7XHJcbiAgICAgICAgY29uc3QgdGlsZUlkID0gZ2V0VGlsZUlkKHRpbGVJdGVtKTtcclxuICAgICAgICBpZiAodGhpcy5fcmVxdWVzdGVkVGlsZXMuZGVsZXRlKHRpbGVJZCkpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVhZHlUaWxlc0NoYW5nZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX3RpbGVzVG9SZWZyZXNoLmRlbGV0ZSh0aWxlSWQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgd2hlcmUgdGhlIHdob2xlIG1hZ2ljIGhhcHBlbnMsIGl0IG1hbmFnZXMgcmVwbGFjZW1lbnQgb2YgY3VycmVudCBzZXQgb2YgdmlzaWJsZS9wcmVsb2FkZWQgdGlsZXNcclxuICAgICAqIHdpdGggYSBuZXcgb25lLlxyXG4gICAgICovXHJcbiAgICBfb25WaXNpYmxlVGlsZXNDaGFuZ2VkKHZpc2libGVUaWxlcykge1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRUaWxlcy5jbGVhcigpO1xyXG4gICAgICAgIGNvbnN0IHRpbGVzVG9SZXF1ZXN0ID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCB0aWxlSXRlbSBvZiB2aXNpYmxlVGlsZXMpIHtcclxuICAgICAgICAgICAgbGV0IHRpbGUgPSB0aGlzLl9hbGxUaWxlcy5nZXQoZ2V0VGlsZUlkKHRpbGVJdGVtKSk7XHJcbiAgICAgICAgICAgIGlmICghdGlsZSkge1xyXG4gICAgICAgICAgICAgICAgdGlsZSA9IG5ldyBUaWxlKHRpbGVJdGVtKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FsbFRpbGVzLnNldCh0aWxlLmlkLCB0aWxlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRUaWxlcy5zZXQodGlsZS5pZCwgdGlsZSk7XHJcbiAgICAgICAgICAgICAgICB0aWxlc1RvUmVxdWVzdC5wdXNoKHRoaXMuX2NyZWF0ZVRpbGVSZXF1ZXN0KHRpbGVJdGVtLCB0aGlzLl9nZXRUaWxlUHJpb3JpdHkodGlsZS50aWxlSXRlbSwgdHJ1ZSkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRUaWxlcy5zZXQodGlsZS5pZCwgdGlsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRpbGVzVG9SZXF1ZXN0Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdFRpbGVzKHRpbGVzVG9SZXF1ZXN0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYmVsdFRpbGVzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIGZvciAoY29uc3QgYmVsdFRpbGVJdGVtIG9mIGNhbGN1bGF0ZUJlbHRUaWxlcyh2aXNpYmxlVGlsZXMsIHRoaXMuX2JlbHRTaXplLCB0aGlzLmNhbWVyYS5vcHRpb25zLndyYXBNb2RlWCA9PT0gMiAvKiBSRVBFQVQgKi8sIHRoaXMuY2FtZXJhLm9wdGlvbnMud3JhcE1vZGVZID09PSAyIC8qIFJFUEVBVCAqLykpIHtcclxuICAgICAgICAgICAgYmVsdFRpbGVzLnNldChnZXRUaWxlSWQoYmVsdFRpbGVJdGVtKSwgYmVsdFRpbGVJdGVtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYmVsdFRpbGVzVG9SZXF1ZXN0ID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBiZWx0VGlsZUl0ZW0gb2YgYmVsdFRpbGVzLnZhbHVlcygpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRpbGVJZCA9IGdldFRpbGVJZChiZWx0VGlsZUl0ZW0pO1xyXG4gICAgICAgICAgICBsZXQgdGlsZSA9IHRoaXMuX2FsbFRpbGVzLmdldCh0aWxlSWQpO1xyXG4gICAgICAgICAgICBpZiAoIXRpbGUpIHtcclxuICAgICAgICAgICAgICAgIHRpbGUgPSBuZXcgVGlsZShiZWx0VGlsZUl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWxsVGlsZXMuc2V0KHRpbGVJZCwgdGlsZSk7XHJcbiAgICAgICAgICAgICAgICBiZWx0VGlsZXNUb1JlcXVlc3QucHVzaCh0aGlzLl9jcmVhdGVUaWxlUmVxdWVzdChiZWx0VGlsZUl0ZW0sIHRoaXMuX2dldFRpbGVQcmlvcml0eShiZWx0VGlsZUl0ZW0sIGZhbHNlKSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChiZWx0VGlsZXNUb1JlcXVlc3QubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RUaWxlcyhiZWx0VGlsZXNUb1JlcXVlc3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBicm9rZSBjdXJyZW50IHJlbGF0aW9uc2hpcHMgdG8gc2V0IHRoZW0gdXAgYWdhaW4gYnV0IHdpdGggbmV3IHNldCBvZiB2aXNpYmxlIHRpbGVzXHJcbiAgICAgICAgZm9yIChjb25zdCB0aWxlIG9mIHRoaXMuX2FsbFRpbGVzLnZhbHVlcygpKSB7XHJcbiAgICAgICAgICAgIHRpbGUudG9CZVJlcGxhY2VkQnkuY2xlYXIoKTtcclxuICAgICAgICAgICAgdGlsZS5yZXBsYWNlbWVudEZvci5jbGVhcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUT0RPOiBvcHRpbWl6ZSB0aGlzIG5eMiByZWxhdGlvbnNoaXBzIHJlc29sdmVyXHJcbiAgICAgICAgZm9yIChjb25zdCBjdXJyZW50VGlsZSBvZiB0aGlzLl9jdXJyZW50VGlsZXMudmFsdWVzKCkpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCB0aWxlIG9mIHRoaXMuX2FsbFRpbGVzLnZhbHVlcygpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGlsZS5pc1JlYWR5VG9WaXN1YWxpemUgJiZcclxuICAgICAgICAgICAgICAgICAgICAoaXNQYXJlbnQodGlsZS50aWxlSXRlbSwgY3VycmVudFRpbGUudGlsZUl0ZW0pIHx8IGlzUGFyZW50KGN1cnJlbnRUaWxlLnRpbGVJdGVtLCB0aWxlLnRpbGVJdGVtKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aWxlLnRvQmVSZXBsYWNlZEJ5LmFkZChjdXJyZW50VGlsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRpbGUucmVwbGFjZW1lbnRGb3IuYWRkKHRpbGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHJlbW92ZSBpbnZpc2libGVcclxuICAgICAgICBjb25zdCB0aWxlc1RvQ2FuY2VsID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCB0aWxlIG9mIHRoaXMuX2FsbFRpbGVzLnZhbHVlcygpKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fY3VycmVudFRpbGVzLmhhcyh0aWxlLmlkKSAmJiB0aWxlLnRvQmVSZXBsYWNlZEJ5LnNpemUgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aWxlLmlzVmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVRpbGVEYXRhKE5PX1RJTEVTX1RPX0hBTkRMRSwgW3RpbGVdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghYmVsdFRpbGVzLmdldCh0aWxlLmlkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3lUaWxlKHRpbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRpbGVzVG9DYW5jZWwucHVzaCh0aWxlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGlsZXNUb0NhbmNlbC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgLy8gaXNzdWUgY2FuY2VsbGF0aW9uIGFsc28gaW4gY2FzZSB0aGVyZSBhcmUgbm9uIHByb2Nlc3NlZCBkYXRhIGVucXVldWVkIHRvIHRyeSB0byBzYXZlIHNvbWUgZWZmb3J0c1xyXG4gICAgICAgICAgICB0aGlzLl9jYW5jZWxUaWxlUmVxdWVzdHModGlsZXNUb0NhbmNlbGF0aW9ucyh0aWxlc1RvQ2FuY2VsKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3JlZnJlc2hDdXJyZW50VGlsZXMoKSB7XHJcbiAgICAgICAgY29uc3QgdGlsZXNUb1JlcXVlc3QgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IHRpbGUgb2YgdGhpcy5fY3VycmVudFRpbGVzLnZhbHVlcygpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRpbGVJdGVtID0gdGlsZS50aWxlSXRlbTtcclxuICAgICAgICAgICAgY29uc3QgdGlsZVJlcXVlc3QgPSB0aGlzLl9jcmVhdGVUaWxlUmVxdWVzdCh0aWxlSXRlbSwgdGhpcy5fZ2V0VGlsZVByaW9yaXR5KHRpbGUudGlsZUl0ZW0sIHRydWUpKTtcclxuICAgICAgICAgICAgdGlsZXNUb1JlcXVlc3QucHVzaCh0aWxlUmVxdWVzdCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3RpbGVzVG9SZWZyZXNoLmFkZChnZXRUaWxlSWQodGlsZS50aWxlSXRlbSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9jYW5jZWxUaWxlUmVxdWVzdHModGlsZXNUb0NhbmNlbGF0aW9ucyh0aGlzLl9jdXJyZW50VGlsZXMudmFsdWVzKCkpKTtcclxuICAgICAgICB0aGlzLl9yZXF1ZXN0VGlsZXModGlsZXNUb1JlcXVlc3QpO1xyXG4gICAgfVxyXG4gICAgX29uVGlsZURhdGFSZWFkeSh0aWxlSXRlbSwgdXJsKSB7XHJcbiAgICAgICAgY29uc3QgdGlsZUlkID0gZ2V0VGlsZUlkKHRpbGVJdGVtKTtcclxuICAgICAgICBjb25zdCB0aWxlRGF0YSA9IHRoaXMuX3JlcXVlc3RlZFRpbGVzLmdldCh0aWxlSWQpO1xyXG4gICAgICAgIHRoaXMuX3JlcXVlc3RlZFRpbGVzLmRlbGV0ZSh0aWxlSWQpO1xyXG4gICAgICAgIHRoaXMuX3RpbGVzVG9SZWZyZXNoLmRlbGV0ZSh0aWxlSWQpO1xyXG4gICAgICAgIHRpbGVEYXRhLmluZm8udXJsID0gdXJsO1xyXG4gICAgICAgIHRpbGVEYXRhLmxvYWRUaW1lc3RhbXBzLmxvYWRlZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgICAgIGlmICh0aGlzLl90aWxlTG9hZExvZ3MubGVuZ3RoIDwgTUFYX1BFUkZfTE9HX0lURU1TX0NPVU5UKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RpbGVMb2FkTG9ncy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHRpbGVJdGVtLFxyXG4gICAgICAgICAgICAgICAgcHJvY2Vzc2luZ1RpbWU6IHRpbGVEYXRhLmxvYWRUaW1lc3RhbXBzLmxvYWRlZCAtIHRpbGVEYXRhLmxvYWRUaW1lc3RhbXBzLnF1ZXVlZFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcmVhZHlGb3JSZW5kZXJUaWxlcy5wdXNoKHRpbGVEYXRhKTtcclxuICAgICAgICBpZiAodGhpcy5fY3VycmVudFRpbGVzLmdldCh0aWxlSWQpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlYWR5VGlsZXNDaGFuZ2UgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9pc1RpbGVTdGlsbEFjdGl2ZSh0aWxlSXRlbSwgcmVxdWVzdElkID0gTk9fSUQpIHtcclxuICAgICAgICBjb25zdCB0aWxlID0gdGhpcy5fYWxsVGlsZXMuZ2V0KGdldFRpbGVJZCh0aWxlSXRlbSkpO1xyXG4gICAgICAgIGlmICghdGlsZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGlzUmVxdWVzdEFjdGl2ZSA9IHRpbGUuZGF0YS5hY3R1YWxSZXF1ZXN0SWQgPT09IHJlcXVlc3RJZCB8fCB0aWxlLmRhdGEudmlzaWJsZVJlcXVlc3RJZCA9PT0gcmVxdWVzdElkO1xyXG4gICAgICAgIHJldHVybiBpc1JlcXVlc3RBY3RpdmU7XHJcbiAgICB9XHJcbiAgICBfaXNUaWxlUmVmcmVzaGluZyh0aWxlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RpbGVzVG9SZWZyZXNoLmhhcyhnZXRUaWxlSWQodGlsZSkpO1xyXG4gICAgfVxyXG4gICAgX2dldFRpbGVQcmlvcml0eSh0aWxlLCBpc1Zpc2libGUpIHtcclxuICAgICAgICBjb25zdCBjZW50ZXIgPSB0aGlzLl9jcmVhdGVUaWxlQ29vcmRpbmF0ZVN5c3RlbSgpLnRvVGlsZUNvb3JkaW5hdGVzKHRoaXMuY2FtZXJhLmNlbnRlcik7XHJcbiAgICAgICAgY29uc3Qgem9vbURpZmYgPSBNYXRoLmNlaWwodGhpcy5jYW1lcmEuem9vbSkgLSB0aWxlLnpvb207XHJcbiAgICAgICAgY29uc3QgZGlzdGFuY2UgPSB2ZWMyLmRpc3RhbmNlKHRpbGUsIHtcclxuICAgICAgICAgICAgeDogTWF0aC5mbG9vcihjZW50ZXIueCAvIE1hdGgucG93KDIsIHpvb21EaWZmKSksXHJcbiAgICAgICAgICAgIHk6IE1hdGguZmxvb3IoY2VudGVyLnkgLyBNYXRoLnBvdygyLCB6b29tRGlmZikpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIChpc1Zpc2libGUgPyBWSVNJQkxFX1RJTEVfUFJJT1JJVFkgOiAwKSArIDEgLyAoZGlzdGFuY2UgKyAxKTtcclxuICAgIH1cclxuICAgIF9zZW5kU3RhdGlzdGljc0JlZm9yZURlc3Ryb3koKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3RpbGVMb2FkTG9ncy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBhY2N1bXVsYXRlZFRpbWluZ3MgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgYWNjdW11bGF0ZWRUaW1pbmdzLnNldCgnYXZlcmFnZScsIHtcclxuICAgICAgICAgICAgc3VtOiAwLFxyXG4gICAgICAgICAgICBudW1iZXI6IDBcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl90aWxlTG9hZExvZ3MuZm9yRWFjaCgobG9nSXRlbSkgPT4ge1xyXG4gICAgICAgICAgICBhY2N1bXVsYXRlZFRpbWluZ3MuZ2V0KCdhdmVyYWdlJykuc3VtICs9IGxvZ0l0ZW0ucHJvY2Vzc2luZ1RpbWU7XHJcbiAgICAgICAgICAgIGFjY3VtdWxhdGVkVGltaW5ncy5nZXQoJ2F2ZXJhZ2UnKS5udW1iZXIrKztcclxuICAgICAgICAgICAgY29uc3Qgem9vbSA9IGxvZ0l0ZW0udGlsZUl0ZW0uem9vbS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBpZiAoIWFjY3VtdWxhdGVkVGltaW5ncy5oYXMoem9vbSkpIHtcclxuICAgICAgICAgICAgICAgIGFjY3VtdWxhdGVkVGltaW5ncy5zZXQoem9vbSwge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1bTogMCxcclxuICAgICAgICAgICAgICAgICAgICBudW1iZXI6IDBcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFjY3VtdWxhdGVkVGltaW5ncy5nZXQoem9vbSkuc3VtICs9IGxvZ0l0ZW0ucHJvY2Vzc2luZ1RpbWU7XHJcbiAgICAgICAgICAgIGFjY3VtdWxhdGVkVGltaW5ncy5nZXQoem9vbSkubnVtYmVyKys7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGFjY3VtdWxhdGVkVGltaW5ncykge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB6b29tOiBpdGVtWzBdLFxyXG4gICAgICAgICAgICAgICAgdGltZTogKGl0ZW1bMV0uc3VtIC8gaXRlbVsxXS5udW1iZXIpXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb3VudFRpbGVQcm9jZXNzaW5nVGltZSh0aGlzLl9sYXllck5hbWUsIHJlc3VsdCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFB1dHMgYWN0dWFsIGRhdGEgaW50byB0aGUgdGlsZSBhbmQgb3B0aW9uYWxseSB2aXN1YWxpemVzIGl0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0aWxlIFRpbGUgdG8gcHV0IGRhdGEgaW50by5cclxuICAgICAqIEBwYXJhbSBkYXRhIERhdGEgdG8gYmUgc3RvcmVkIGluIHRoZSB0aWxlIHVudGlsIHZpc3VhbGl6YXRpb24uXHJcbiAgICAgKiBAcGFyYW0gdmlzdWFsaXplIElmIGB0cnVlYCByZXBsYWNlcyBgdmlzaWJsZWAgdGlsZSBkYXRhIHdpdGggYGFjdHVhbGAgdGlsZSBkYXRhIGFuZCB1cGRhdGVzIHRoZSBzY2VuZS5cclxuICAgICAqL1xyXG4gICAgX3B1dEFjdHVhbFRpbGVEYXRhKHRpbGUsIGRhdGEsIHZpc3VhbGl6ZSkge1xyXG4gICAgICAgIHRpbGUuZGF0YS5hY3R1YWwucHVzaChkYXRhKTtcclxuICAgICAgICBpZiAodmlzdWFsaXplKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Zpc3VhbGl6ZVRpbGUodGlsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBWaXN1YWxpemVzIHRpbGUgYGFjdHVhbGAgZGF0YTogcmVwbGFjZXMgdGlsZSBgdmlzaWJsZWAgZGF0YSB3aXRoIHRpbGUgYGFjdHVhbGAgZGF0YSwgYWRkcyBpdCB0byB0aGUgc2NlbmUsXHJcbiAgICAgKiByZW1vdmVzIG9sZCB2aXNpYmxlIGRhdGEgZnJvbSB0aGUgc2NlbmUgYW5kIGRlc3Ryb3lzIGl0LCBjaGVja3MgdGlsZSByZXBsYWNlbWVudHMgYW5kIHVwZGF0ZXMgYHZpc2libGVSZXF1ZXN0SWRgLlxyXG4gICAgICogQHBhcmFtIHRpbGUgVGlsZSB0byB2aXN1YWxpemUuXHJcbiAgICAgKi9cclxuICAgIF92aXN1YWxpemVUaWxlKHRpbGUpIHtcclxuICAgICAgICBjb25zdCB0b0Rlc3Ryb3kgPSB0aWxlLmRhdGEudmlzaWJsZTtcclxuICAgICAgICB0aWxlLmRhdGEudmlzaWJsZSA9IHRpbGUuZGF0YS5hY3R1YWw7XHJcbiAgICAgICAgdGlsZS5kYXRhLmFjdHVhbCA9IFtdO1xyXG4gICAgICAgIHRpbGUuZGF0YS52aXNpYmxlUmVxdWVzdElkID0gdGlsZS5kYXRhLmFjdHVhbFJlcXVlc3RJZDtcclxuICAgICAgICBpZiAoIXRpbGUuaXNSZWFkeVRvVmlzdWFsaXplKSB7XHJcbiAgICAgICAgICAgIHRpbGUuaXNSZWFkeVRvVmlzdWFsaXplID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5fY2hlY2tUaWxlUmVwbGFjZW1lbnRzKHRpbGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aWxlLmlzVmlzaWJsZSkge1xyXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVUaWxlRGF0YVBvcnRpb25zKHRpbGUuZGF0YS52aXNpYmxlLCBbXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0b0Rlc3Ryb3kubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVUaWxlRGF0YVBvcnRpb25zKFtdLCB0b0Rlc3Ryb3kpO1xyXG4gICAgICAgICAgICB0aGlzLl9vblRpbGVEZXN0cm95KHRpbGUudGlsZUl0ZW0sIHRvRGVzdHJveSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2NyZWF0ZVRpbGVDb29yZGluYXRlU3lzdGVtKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVGlsZUNvb3JkaW5hdGVTeXN0ZW0odGhpcy5jYW1lcmEuem9vbSk7XHJcbiAgICB9XHJcbiAgICAvLyBXZSBuZWVkIGRvIGRldGVjdCB3aGVuIHRpbGUgaXMgcmVuZGVyZWQgdG8gY29sbGVjdCBwZXJmb21hbmNlIG1ldHJpY3MuXHJcbiAgICAvLyBXZSBleHBlY3QgdGhhdCB0aWxlIHdpbGwgYmUgcmVuZGVyZWQgd2l0aCBmaXJzdCByZW5kZXIgZXZlbnQgYWZ0ZXJcclxuICAgIC8vIHRpbGUgZGF0YSBpcyBhZGRlZCB0byBzY2VuZS5cclxuICAgIF9vbkVuZ2luZVJlbmRlckV2ZW50KCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9yZWFkeUZvclJlbmRlclRpbGVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZWFkeUZvclJlbmRlclRpbGVzLmZvckVhY2goKHRpbGVEYXRhKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY3VycmVudFRpbGVzLmhhcyhnZXRUaWxlSWQodGlsZURhdGEudGlsZUl0ZW0pKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRpbGVEYXRhLmxvYWRUaW1lc3RhbXBzLnJlbmRlcmVkID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGlsZURhdGEubG9hZFRpbWVzdGFtcHMucmVhZHkgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uVGlsZVJlYWR5LmZpcmUodGlsZURhdGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5fcmVhZHlGb3JSZW5kZXJUaWxlcy5sZW5ndGggPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fcmVhZHlUaWxlc0NoYW5nZSkge1xyXG4gICAgICAgICAgICB0aGlzLm9uVGlsZUxvYWRDaGFuZ2UuZmlyZSh7XHJcbiAgICAgICAgICAgICAgICB0b3RhbFRpbGVOdW1iZXI6IHRoaXMuZ2V0VmlzaWJsZVRpbGVzTnVtYmVyKCksXHJcbiAgICAgICAgICAgICAgICByZWFkeVRpbGVOdW1iZXI6IHRoaXMuZ2V0VmlzaWJsZVRpbGVzTnVtYmVyKCkgLSB0aGlzLmdldFBlbmRpbmdUaWxlc051bWJlcigpXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLl9yZWFkeVRpbGVzQ2hhbmdlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTaG93cy9oaWRlcyB0aWxlcyBpZiB0aGV5IGFyZSBub3Qgc2hvd24vaGlkZGVuIHlldC4gSXQgbm90aWZpZXMgc3ViY2xhc3NlcyBieSBjYWxsaW5nIGFwcHJvcHJpYXRlXHJcbiAgICAgKiBhYnN0cmFjdCBtZXRob2QuIEV2ZW4gdGhvdWdoIHZpc2libGUvaW52aXNpYmxlIHRpbGVzIGFyZSBub3Qgc3VwcG9zZWQgdG8gYmUgc2hvd24vaGlkZGVuIGFnYWluLFxyXG4gICAgICogdGhlcmUgYXJlIGNhc2VzIHdoZXJlIGl0IHNpbXBsaWZpZXMgdGlsZSB2aXN1YWxpemF0aW9uIGxvZ2ljLlxyXG4gICAgICogSXQgaXMgaW1wb3J0YW50IHRvIGhhdmUgZXhhY3RseSBcInVwZGF0ZVwiLCBub3QgXCJhZGRcIi9cInJlbW92ZVwiIHNlcGFyYXRlbHksIGFzIHNvbWUgYnVzaW5lc3MgbG9naWMgbWF5IHJlbHkgb24gaXQsXHJcbiAgICAgKiBlLmcuIG1vcnBoaW5nIHZpc2libGUgZGF0YSBvciBtYW5hZ2luZyBzaGFyZWQgcmVzb3VyY2VzLlxyXG4gICAgICovXHJcbiAgICBfdXBkYXRlVGlsZURhdGEodG9TaG93LCB0b1JlbW92ZSkge1xyXG4gICAgICAgIGNvbnN0IGRhdGFUb1Nob3cgPSBBcnJheS5mcm9tKGZsYXR0ZW5WaXNpYmxlRGF0YVBvcnRpb25zKHRvU2hvdykpO1xyXG4gICAgICAgIGNvbnN0IGRhdGFUb1JlbW92ZSA9IEFycmF5LmZyb20oZmxhdHRlblZpc2libGVEYXRhUG9ydGlvbnModG9SZW1vdmUpKTtcclxuICAgICAgICB0aGlzLl91cGRhdGVUaWxlRGF0YVBvcnRpb25zKGRhdGFUb1Nob3csIGRhdGFUb1JlbW92ZSk7XHJcbiAgICAgICAgZm9yIChjb25zdCB0aWxlIG9mIHRvU2hvdykge1xyXG4gICAgICAgICAgICB0aWxlLmlzVmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3QgdGlsZSBvZiB0b1JlbW92ZSkge1xyXG4gICAgICAgICAgICB0aWxlLmlzVmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF91cGRhdGVUaWxlRGF0YVBvcnRpb25zKHRvU2hvdywgdG9SZW1vdmUpIHtcclxuICAgICAgICB0aGlzLl9vblRpbGVEYXRhVXBkYXRlKHRvU2hvdywgdG9SZW1vdmUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIHRpbGUgaWYgaXMgbm90IHJlbW92ZWQgd2l0aCBjYWxsaW5nIGFsbCBhcHByb3ByaWF0ZSBjYWxsYmFja3MgKGFic3RyYWN0IG1ldGhvZHMpXHJcbiAgICAgKiB0byBub3RpZnkgZGVzY2VuZGFudCBjbGFzc2VzLiBFdmVuIHRob3VnaCByZW1vdmVkIHRpbGUgaXMgbm90IHN1cHBvc2VkIHRvIGJlIHJlbW92ZWQgYWdhaW4sXHJcbiAgICAgKiBhbGxvd2luZyB0aGlzIG1ha2VzIG11Y2ggc2ltcGxlciB0aWxlIG1hbmFnZW1lbnQsIGVzcGVjaWFsbHkgaW4gdGlsZSByZXBsYWNlbWVudHMgbG9naWMgd2hlcmUgbXVsdGlwbGVcclxuICAgICAqIHRpbGVzIGNhbiBoYXZlIGxpbmtzIHRvIHRoZSBzYW1lIHRpbGUgKHRoYXQgaXMgdG8gYmUgcmVtb3ZlZCkuXHJcbiAgICAgKi9cclxuICAgIF9kZXN0cm95VGlsZSh0aWxlKSB7XHJcbiAgICAgICAgaWYgKCF0aWxlLmlzUmVtb3ZlZCkge1xyXG4gICAgICAgICAgICB0aWxlLmlzUmVtb3ZlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX2FsbFRpbGVzLmRlbGV0ZSh0aWxlLmlkKTtcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudFRpbGVzLmRlbGV0ZSh0aWxlLmlkKTtcclxuICAgICAgICAgICAgdGhpcy5fb25UaWxlRGVzdHJveSh0aWxlLnRpbGVJdGVtLCBbLi4udGlsZS5kYXRhLmFjdHVhbCwgLi4udGlsZS5kYXRhLnZpc2libGVdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB0aWxlcyB0aGF0IGNvdWxkIGJlIHJlcGxhY2VkIGJ5IHRoaXMgb25lLCBzaG91bGQgYmUgY2FsbGVkIHdoZW4gdGlsZSBiZWNvbWVzIHJlYWR5IHRvIHZpc3VhbGl6ZS5cclxuICAgICAqIEFzIG92ZXJsYXBwaW5nIHJlbGF0aW9uc2hpcHMgY2FuIGhhcHBlbiBpbiBib3RoIGRpcmVjdGlvbnMgKGNoaWxkcmVuIGJ5IHBhcmVudHMgLyBwYXJlbnQgYnkgY2hpbGRyZW4pIHRoaXNcclxuICAgICAqIG1ldGhvZCBnb2VzIG9uZSBzdGVwIGRlZXBlciwgaS5lLiBpdCBjaGVjayBub3Qgb25seSB0aWxlcyB0aGF0IHNob3VsZCBiZSByZXBsYWNlZCAodG8gcmVtb3ZlIHRoZW0pLFxyXG4gICAgICogYnV0IGFsc28gYWxsIHRpbGVzIHRoYXQgY292ZXIgdGhlIHJlcGxhY2VkIG9uZXMgKHRvIHNob3cgdGhlbSkuXHJcbiAgICAgKi9cclxuICAgIF9jaGVja1RpbGVSZXBsYWNlbWVudHModGlsZSkge1xyXG4gICAgICAgIGNvbnN0IHRvRGVzdHJveSA9IG5ldyBTZXQoKTtcclxuICAgICAgICBjb25zdCB0b1Nob3cgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgY29uc3QgdG9IaWRlID0gbmV3IFNldCgpO1xyXG4gICAgICAgIGZvciAoY29uc3QgdGlsZVRvUmVwbGFjZSBvZiB0aWxlLnJlcGxhY2VtZW50Rm9yKSB7XHJcbiAgICAgICAgICAgIGlmIChhbGxPZkl0ZXJhYmxlKHRpbGVUb1JlcGxhY2UudG9CZVJlcGxhY2VkQnksICh0aWxlKSA9PiB0aWxlLmlzUmVhZHlUb1Zpc3VhbGl6ZSkpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aWxlVG9SZXBsYWNlLmlzVmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvSGlkZS5hZGQodGlsZVRvUmVwbGFjZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRpbGVUb1JlcGxhY2UuaXNSZW1vdmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9EZXN0cm95LmFkZCh0aWxlVG9SZXBsYWNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdGlsZVRvU2hvdyBvZiB0aWxlVG9SZXBsYWNlLnRvQmVSZXBsYWNlZEJ5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aWxlVG9TaG93LmlzVmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b1Nob3cuYWRkKHRpbGVUb1Nob3cpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGlsZS5yZXBsYWNlbWVudEZvci5zaXplID09PSAwICYmICF0aWxlLmlzVmlzaWJsZSkge1xyXG4gICAgICAgICAgICB0b1Nob3cuYWRkKHRpbGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodG9TaG93LnNpemUgPiAwIHx8IHRvSGlkZS5zaXplID4gMCkge1xyXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVUaWxlRGF0YSh0b1Nob3csIHRvSGlkZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3QgdGlsZVRvRGVzdHJveSBvZiB0b0Rlc3Ryb3kpIHtcclxuICAgICAgICAgICAgdGhpcy5fZGVzdHJveVRpbGUodGlsZVRvRGVzdHJveSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0b0Rlc3Ryb3kuc2l6ZSA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5fY2FuY2VsVGlsZVJlcXVlc3RzKHRpbGVzVG9DYW5jZWxhdGlvbnModG9EZXN0cm95KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUaGlzIGNsYXNzIGlzIHRoZSBtYWluIHVuaXQgb2YgdGhlIHdob2xlIHByb2Nlc3Mgb2YgdGlsZSBtYW5hZ2VtZW50LiBJdCBzdG9yZXMgdmlzdWFsaXphYmxlIGRhdGEgYW5kIGxpbmtzIHRvXHJcbiAqIGRlcGVuZGFudCB0aWxlcyAoZm9yIHBhcmVudC9jaGlsZCBvdmVybGFwcGluZyBjYXNlcykuXHJcbiAqL1xyXG5jbGFzcyBUaWxlIHtcclxuICAgIGNvbnN0cnVjdG9yKHRpbGVJdGVtKSB7XHJcbiAgICAgICAgdGhpcy5kYXRhID0ge1xyXG4gICAgICAgICAgICBhY3R1YWw6IFtdLFxyXG4gICAgICAgICAgICB2aXNpYmxlOiBbXSxcclxuICAgICAgICAgICAgYWN0dWFsUmVxdWVzdElkOiBOT19JRCxcclxuICAgICAgICAgICAgdmlzaWJsZVJlcXVlc3RJZDogTk9fSURcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMudGlsZUl0ZW0gPSB0aWxlSXRlbTtcclxuICAgICAgICB0aGlzLmlkID0gYCR7dGlsZUl0ZW0ueH06JHt0aWxlSXRlbS55fToke3RpbGVJdGVtLnpvb219YDtcclxuICAgICAgICB0aGlzLmlzUmVhZHlUb1Zpc3VhbGl6ZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaXNWaXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pc1JlbW92ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnRvQmVSZXBsYWNlZEJ5ID0gbmV3IFNldCgpO1xyXG4gICAgICAgIHRoaXMucmVwbGFjZW1lbnRGb3IgPSBuZXcgU2V0KCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdGlsZXNUb0NhbmNlbGF0aW9ucyh0aWxlcykge1xyXG4gICAgcmV0dXJuIEFycmF5LmZyb20odGlsZXMsICh0aWxlKSA9PiAoe1xyXG4gICAgICAgIHRpbGU6IHRpbGUudGlsZUl0ZW0sXHJcbiAgICAgICAgcmVxdWVzdElkOiB0aWxlLmRhdGEuYWN0dWFsUmVxdWVzdElkXHJcbiAgICB9KSk7XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdGlsZV9iYXNlZF9hZGFwdGVyL2FkYXB0ZXIudHNcbi8vIG1vZHVsZSBpZCA9IDY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IGRlYm91bmNlIH0gZnJvbSAnLi4vdXRpbC9mdW5jdGlvbic7XHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFkYXB0ZXIge1xyXG4gICAgY29uc3RydWN0b3IoZW5naW5lLCBjYW1lcmEsIGNhbWVyYVVwZGF0ZURlbGF5ID0gNSkge1xyXG4gICAgICAgIHRoaXMuZW5naW5lID0gZW5naW5lO1xyXG4gICAgICAgIHRoaXMuY2FtZXJhID0gY2FtZXJhO1xyXG4gICAgICAgIHRoaXMuX2NhbWVyYVVwZGF0ZUxpc3RlbmVyID0gZGVib3VuY2UodGhpcy5fb25DYW1lcmFVcGRhdGUuYmluZCh0aGlzKSwgY2FtZXJhVXBkYXRlRGVsYXkpO1xyXG4gICAgICAgIGNhbWVyYS5vblVwZGF0ZS5hZGRMaXN0ZW5lcih0aGlzLl9jYW1lcmFVcGRhdGVMaXN0ZW5lcik7XHJcbiAgICB9XHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMuY2FtZXJhLm9uVXBkYXRlLnJlbW92ZUxpc3RlbmVyKHRoaXMuX2NhbWVyYVVwZGF0ZUxpc3RlbmVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FtZXJhIHVwZGF0ZSBoYW5kbGVyLCBieSBkZWZhdWx0IGRvIG5vdGhpbmcuXHJcbiAgICAgKi9cclxuICAgIF9vbkNhbWVyYVVwZGF0ZSgpIHsgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2FkYXB0ZXJzL2FkYXB0ZXIudHNcbi8vIG1vZHVsZSBpZCA9IDY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiBDcmVhdGVzIG5ldyBmdW5jdGlvbiB3aGljaCBleGVjdXRpb24gaXMgXCJkZWJvdW5jZWRcIi5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0KSB7XHJcbiAgICBsZXQgdGltZW91dCA9IDA7XHJcbiAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcclxuICAgICAgICBjb25zdCBsYXRlciA9ICgpID0+IHtcclxuICAgICAgICAgICAgdGltZW91dCA9IDA7XHJcbiAgICAgICAgICAgIGZ1bmMoLi4uYXJncyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAodGltZW91dCkge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcclxuICAgIH07XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9mdW5jdGlvbi50c1xuLy8gbW9kdWxlIGlkID0gNzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgY2xhbXAgfSBmcm9tICcuLi8uLi8uLi9tYXRoL3NjYWxhcic7XHJcbi8qKlxyXG4gKiBAcmV0dXJuIGB0cnVlYCBpZiB0aGUgZmlyc3QgcGFyYW0gb3ZlcmxhcHMgdGhlIHNlY29uZCBpbiB0aWxlIGhpZXJhcmNoeS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1BhcmVudChwb3RlbnRpYWxQYXJlbnQsIHBvc3NpYmxlQ2hpbGQpIHtcclxuICAgIGNvbnN0IHpvb21EaWZmID0gcG9zc2libGVDaGlsZC56b29tIC0gcG90ZW50aWFsUGFyZW50Lnpvb207XHJcbiAgICByZXR1cm4gem9vbURpZmYgPiAwICYmXHJcbiAgICAgICAgcG9zc2libGVDaGlsZC54ID4+IHpvb21EaWZmID09PSBwb3RlbnRpYWxQYXJlbnQueCAmJlxyXG4gICAgICAgIHBvc3NpYmxlQ2hpbGQueSA+PiB6b29tRGlmZiA9PT0gcG90ZW50aWFsUGFyZW50Lnk7XHJcbn1cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGlsZUNvb3JkaW5hdGVTeXN0ZW0ge1xyXG4gICAgY29uc3RydWN0b3Ioem9vbSkge1xyXG4gICAgICAgIHRoaXMuX3pvb20gPSBNYXRoLmNlaWwoY2xhbXAoem9vbSwgMCwgMzEpKTtcclxuICAgICAgICB0aGlzLl90aWxlU2l6ZSA9IDIgLyAoMSA8PCB0aGlzLl96b29tKTtcclxuICAgIH1cclxuICAgIGdldFpvb20oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3pvb207XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gVGlsZSBzaWRlIGxlbmd0aCBpbiB1bml0cyBvZiB0aGUgd29ybGQgY29vcmRpbmF0ZSBzeXN0ZW0uXHJcbiAgICAgKi9cclxuICAgIGdldFRpbGVTaXplKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90aWxlU2l6ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiBUb3AgbGVmdCBjb3JuZXIgY29vcmRpbmF0ZXMgb2YgdGhlIHRpbGUuXHJcbiAgICAgKi9cclxuICAgIGdldFRpbGVPZmZzZXQodGlsZSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHg6IHRoaXMuZ2V0VGlsZVNpemUoKSAqIHRpbGUueCAtIDEsXHJcbiAgICAgICAgICAgIHk6IDEgLSB0aGlzLmdldFRpbGVTaXplKCkgKiB0aWxlLnlcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgdG9UaWxlQ29vcmRpbmF0ZXMod29ybGRDb29yZGluYXRlcykge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHg6ICh3b3JsZENvb3JkaW5hdGVzLnggKyAxKSAvIHRoaXMuX3RpbGVTaXplLFxyXG4gICAgICAgICAgICB5OiAoMSAtIHdvcmxkQ29vcmRpbmF0ZXMueSkgLyB0aGlzLl90aWxlU2l6ZVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdGlsZV9iYXNlZF9hZGFwdGVyL3V0aWwvdGlsZV9zeXN0ZW0udHNcbi8vIG1vZHVsZSBpZCA9IDcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImNvbnN0IFRJTEVfMF8wXzAgPSB7IHg6IDAsIHk6IDAsIHpvb206IDAgfTtcclxuLyoqXHJcbiAqIENvbXB1dGVzIHNldCBvZiB0aWxlcyB2aXNpYmxlIHRocm91Z2ggYSBjYW1lcmEuIFRpbGVzIGluIHRoZSBzZXQgYXJlIGd1YXJhbnRlZWRcclxuICogdG8gYmUgdW5pcXVlLlxyXG4gKlxyXG4gKiBGSVhNRShkbWlraXMpIFRoZSB1bmlxdWVuZXNzIGd1YXJhbnRlZSBpcyBicm9rZW4gY3VycmVudGx5LCBidXQgY29kZSB0aGF0IHVzZXNcclxuICogICAgICB0aGlzIGZ1bmN0aW9uIGRvZXNuJ3Qgc3VmZmVyIGZyb20gdGhhdC5cclxuICpcclxuICogQHBhcmFtIGNhbWVyYSBUaGUgY2FtZXJhLlxyXG4gKiBAcmV0dXJucyBBbiBpdGVyYXRvciBvdmVyIHZpc2libGUgdGlsZSBpdGVtcy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiogY29tcHV0ZVZpc2libGVUaWxlcyh2aXNpYmxlUmVnaW9uLCB2aXNpYmxlUmVnaW9uQkJveCwgd3JhcE1vZGVYLCB3cmFwTW9kZVksIHpvb20pIHtcclxuICAgIGlmICh6b29tID09PSAwKSB7XHJcbiAgICAgICAgLy8gVGhlIG9ubHkgdGlsZSBvbiB6b29tIDAgZW5jb21wYXNzZXMgdGhlIHdob2xlIHdvcmxkLiBUaHVzIHRoZXJlJ3NcclxuICAgICAgICAvLyBsaXR0bGUgdG8gbm8gcG9pbnQgY29tcHV0aW5nIHRoYXQgY2FtZXJhIHNlZXMgaXQ6IHdlIGNhbiB0ZWxsIHRoYXRcclxuICAgICAgICAvLyByaWdodCBhd2F5LlxyXG4gICAgICAgIHlpZWxkIFRJTEVfMF8wXzA7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgdGlsZUNvdW50ID0gMSA8PCB6b29tO1xyXG4gICAgY29uc3QgdGlsZUlkeE1hc2sgPSB0aWxlQ291bnQgLSAxO1xyXG4gICAgLy8gVGhlIGlkZWEgYmVoaW5kIHRoZSBjb2RlIGJlbG93IGlzIHF1aXRlIHNpbXBsZTogZGV0ZXJtaW5lIGNvbHVtbnMgb2YgdGhlXHJcbiAgICAvLyB0aWxlIGdyaWQgdGhhdCBhcmUgdmlzaWJsZSB0byB0aGUgY2FtZXJhLCB0aGVuIGZvciBlYWNoIGNvbHVtbiBmaW5kXHJcbiAgICAvLyByYW5nZSBvZiByb3cgaW5kaWNlcyB0aGF0IGFyZSB2aXNpYmxlLlxyXG4gICAgLy8gSGVyZSdzIGhvdyB3ZSBhcHByb2FjaCBjb21wdXRpbmcgdGlsZSBpbmRpY2VzIGZyb20gd29ybGQgY29vcmRpbmF0ZXMuXHJcbiAgICAvLyBGaXJzdCwgd2UgdHJhbnNmb3JtIHdvcmxkIGNvb3JkaW5hdGVzIGZyb20gWy0xLCAxXSByYW5nZSB0byBbMCwgMl0sXHJcbiAgICAvLyBkZWFsaW5nIHdpdGggaW5jb25zaXN0ZW5jeSB3aXRoIFkgYXhpcyBkaXJlY3Rpb24gaW4gd29ybGQgYW5kIHRpbGUgZ3JpZFxyXG4gICAgLy8gY29vcmRpbmF0ZSBzeXN0ZW0uIExldCdzIGRlc2lnbmF0ZSBzdWNoIGEgY29vcmRpbmF0ZSBhcyBDIChmb3IgZWl0aGVyIFhcclxuICAgIC8vIG9yIFkpLiBTaXplIG9mIGEgdGlsZSBpcyAyIC8gdGlsZUNvdW50LiBUaHVzLFxyXG4gICAgLy9cclxuICAgIC8vICAgICAgdGlsZUlkeCA9IE1hdGguZmxvb3IoQyAvICgyIC8gdGlsZUNvdW50KSlcclxuICAgIC8vICAgICAgICAgICAgICA9IE1hdGguZmxvb3IoQyAqIHRpbGVDb3VudCAvIDIpXHJcbiAgICAvL1xyXG4gICAgY29uc3QgeyBtaW5YLCBtYXhYLCBtaW5ZLCBtYXhZIH0gPSB2aXNpYmxlUmVnaW9uQkJveDtcclxuICAgIGNvbnN0IG1pblRYID0gTWF0aC5mbG9vcigobWluWCArIDEpICogdGlsZUNvdW50IC8gMik7XHJcbiAgICBjb25zdCBtYXhUWCA9IE1hdGguZmxvb3IoKG1heFggKyAxKSAqIHRpbGVDb3VudCAvIDIpO1xyXG4gICAgY29uc3QgY29sdW1uQ291bnQgPSBtYXhUWCAtIG1pblRYICsgMTtcclxuICAgIC8vIEFycmF5cyBvZiBpbmRpY2VzIG9mIGJvdHRvbW1vc3QgYW5kIHRvcG1vc3QgdGlsZXMgY29ycmVzcG9uZGluZ2x5IGZvclxyXG4gICAgLy8gZWFjaCBjb2x1bW4uXHJcbiAgICAvLyBGSVhNRShkbWlraXMpIElmIG51bWJlciBvZiBjb2x1bW5zIGlzIHRvbyBsYXJnZSwgd2UnbGwgY29uc3VtZSBhIGxvdCBvZlxyXG4gICAgLy8gICAgICBtZW1vcnkgaGVyZS4gVGhlcmUncyBhIG1ldGhvZCB0byBkbyB3aXRob3V0IHRoZSBhcnJheXMsIGJ1dCBpdCdzIGFcclxuICAgIC8vICAgICAgYml0IG1vcmUgY29tcGxpY2F0ZWQgdG8gaW1wbGVtZW50LlxyXG4gICAgY29uc3QgbWluWXMgPSBuZXcgQXJyYXkoY29sdW1uQ291bnQpO1xyXG4gICAgY29uc3QgbWF4WXMgPSBuZXcgQXJyYXkoY29sdW1uQ291bnQpO1xyXG4gICAgLy8gQ29tbW9uIHNlbnNlIHN1Z2dlc3RzIHRoYXQgdGhvc2UgaW5kaWNlcyBjYW4ndCBiZSBncmVhdGVyIChsZXNzKSB0aGFuIHRoZVxyXG4gICAgLy8gaW5kZXggb2YgYSB0aWxlIHJvdyBpbnRlcnNlY3RlZCBieSBhIGxpbmUgeSA9IG1pblkgKHkgPSBtYXhZKS4gTm90ZSB0aGF0XHJcbiAgICAvLyBtYXhZIGNvcnJlc3BvbmRzIHRvIGEgdGlsZSByb3cgd2l0aCBsZXNzZXIgaW5kZXgsIG5vdCBvdGhlciB3YXkgYXJvdW5kLlxyXG4gICAgbWluWXMuZmlsbChNYXRoLmZsb29yKCgxIC0gbWluWSkgKiB0aWxlQ291bnQgLyAyKSk7XHJcbiAgICBtYXhZcy5maWxsKE1hdGguZmxvb3IoKDEgLSBtYXhZKSAqIHRpbGVDb3VudCAvIDIpKTtcclxuICAgIGNvbnN0IHZpc2libGVQb2x5Z29uTGVuZ3RoID0gdmlzaWJsZVJlZ2lvbi5sZW5ndGg7XHJcbiAgICBsZXQgcHJldlggPSB2aXNpYmxlUmVnaW9uW3Zpc2libGVQb2x5Z29uTGVuZ3RoIC0gMV0ueCArIDE7XHJcbiAgICBsZXQgcHJldlkgPSAxIC0gdmlzaWJsZVJlZ2lvblt2aXNpYmxlUG9seWdvbkxlbmd0aCAtIDFdLnk7XHJcbiAgICBsZXQgcHJldlRYID0gTWF0aC5mbG9vcihwcmV2WCAqIHRpbGVDb3VudCAvIDIpO1xyXG4gICAgbGV0IHByZXZUWSA9IE1hdGguZmxvb3IocHJldlkgKiB0aWxlQ291bnQgLyAyKTtcclxuICAgIC8vIEl0ZXJhdGUgb3ZlciBlZGdlcyBvZiB2aXNpYmxlIHBvbHlnb24gb2YgdGhlIGNhbWVyYSB0byBjb21wdXRlIGluZGV4IG9mXHJcbiAgICAvLyB0b3Btb3N0IGFuZCBib3R0b21tb3N0IHRpbGVzIGZvciBlYWNoIGNvbHVtbi5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmlzaWJsZVBvbHlnb25MZW5ndGg7ICsraSkge1xyXG4gICAgICAgIGNvbnN0IHggPSB2aXNpYmxlUmVnaW9uW2ldLnggKyAxO1xyXG4gICAgICAgIGNvbnN0IHkgPSAxIC0gdmlzaWJsZVJlZ2lvbltpXS55O1xyXG4gICAgICAgIGNvbnN0IHR4ID0gTWF0aC5mbG9vcih4ICogdGlsZUNvdW50IC8gMik7XHJcbiAgICAgICAgY29uc3QgdHkgPSBNYXRoLmZsb29yKHkgKiB0aWxlQ291bnQgLyAyKTtcclxuICAgICAgICAvLyBGb3IgZWFjaCBlZGdlIHdlIGNvbXB1dGUgNC1jb25uZWN0ZWQgbGluZSBvZiB0aWxlcyBvbiB0aGUgdGlsZSBncmlkLlxyXG4gICAgICAgIC8vIExlbmd0aCBvZiBhIDQtY29ubmVjdGVkIGxpbmUgYWx3YXlzIGVxdWFscyBNYW5oYXR0YW4gZGlzdGFuY2UgYmV0d2VlblxyXG4gICAgICAgIC8vIGl0cyBlbmRzLiBIb3dldmVyLCB0byBhdm9pZCB1bm5lY2Vzc2FyeSBjb21wdXRhdGlvbiwgd2Ugb21pdCBsYXN0IHRpbGVcclxuICAgICAgICAvLyBmb3IgZXZlcnkgZWRnZS4gQnV0LCBzaW5jZSB0aGUgcG9seWdvbiBpcyBjbG9zZWQsIHdlJ2xsIGl0ZXJhdGUgb3ZlclxyXG4gICAgICAgIC8vIGFsbCB0aWxlcyBpbnRlcnNlY3RlZCBieSBlZGdlcyBhbnl3YXkuXHJcbiAgICAgICAgY29uc3QgbCA9IE1hdGguYWJzKHR4IC0gcHJldlRYKSArIE1hdGguYWJzKHR5IC0gcHJldlRZKTtcclxuICAgICAgICBjb25zdCBseCA9IHggLSBwcmV2WDtcclxuICAgICAgICBjb25zdCBseSA9IHkgLSBwcmV2WTtcclxuICAgICAgICBjb25zdCBkdHggPSBseCA+IDAgPyAxIDogLTE7XHJcbiAgICAgICAgY29uc3QgZHR5ID0gbHkgPiAwID8gMSA6IC0xO1xyXG4gICAgICAgIGNvbnN0IGEgPSAyICogZHR4ICogbHk7XHJcbiAgICAgICAgY29uc3QgYiA9IC0yICogZHR4ICogbHg7XHJcbiAgICAgICAgY29uc3QgYyA9IGR0eCAqIHRpbGVDb3VudCAqIChseCAqIHByZXZZIC0gbHkgKiBwcmV2WCkgKyBhICogKH5kdHggPj4+IDMxKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgdHggPSBwcmV2VFgsIHR5ID0gcHJldlRZOyBpIDwgbDsgKytpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGludGVyY2VwdCA9IGEgKiB0eCArIGIgKiB0eSArIGM7XHJcbiAgICAgICAgICAgIC8vIFRoZSBtYXRoIGhlcmUgaXMgc29tZXdoYXQgY3VtYmVyc29tZSB0byBhdm9pZCBkaXZpc2lvbnMsIGJ1dCB0aGVcclxuICAgICAgICAgICAgLy8gZXNzZW5jZSBpcyB0aGF0IHdlIHRyeSB0byBjaGVjayB0aHJvdWdoIHdoaWNoIHNpZGUgdGhlIGVkZ2Ugb2ZcclxuICAgICAgICAgICAgLy8gdmlzaWJsZSBwb2x5Z29uIGV4aXRzIHRoZSB0aWxlLiBEZXBlbmRpbmcgb24gdGhhdCB3ZSBcIm1vdmVcIiB0b1xyXG4gICAgICAgICAgICAvLyBuZXh0IHRpbGUgaW4gZWl0aGVyIHZlcnRpY2FsIG9yIGhvcml6b250YWwgZGlyZWN0aW9uLlxyXG4gICAgICAgICAgICBpZiAoMCA8PSBpbnRlcmNlcHQgJiYgaW50ZXJjZXB0IDw9IC1iKSB7XHJcbiAgICAgICAgICAgICAgICB0eCArPSBkdHg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0eSArPSBkdHk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgeUlkeCA9IHR4IC0gbWluVFg7XHJcbiAgICAgICAgICAgIGlmIChtYXhZc1t5SWR4XSA8IHR5KSB7XHJcbiAgICAgICAgICAgICAgICBtYXhZc1t5SWR4XSA9IHR5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtaW5Zc1t5SWR4XSA+IHR5KSB7XHJcbiAgICAgICAgICAgICAgICBtaW5Zc1t5SWR4XSA9IHR5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByZXZYID0geDtcclxuICAgICAgICBwcmV2WSA9IHk7XHJcbiAgICAgICAgcHJldlRYID0gdHg7XHJcbiAgICAgICAgcHJldlRZID0gdHk7XHJcbiAgICB9XHJcbiAgICAvLyBJZiB0aGUgd29ybGQgaXMgcmVwZWF0ZWQgYWxvbmcgWCBheGlzLCB3ZSBuZWVkIHRvIFwiZm9sZFwiIHRoZSBhcnJheSBvZiBjb2x1bW5zLFxyXG4gICAgLy8gaS5lLiBjb21wdXRlIHVuaW9uIG9mIHJvdyBpbnRlcnZhbHMgZm9yIGNvbHVtbnMgdGlsZUNvdW50IGluZGljZXMgYXBhcnQuXHJcbiAgICBpZiAod3JhcE1vZGVYID09PSAyIC8qIFJFUEVBVCAqLyAmJiBjb2x1bW5Db3VudCA+IHRpbGVDb3VudCkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGlsZUNvdW50OyArK2kpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IGkgKyB0aWxlQ291bnQ7IGogPCBjb2x1bW5Db3VudDsgaiArPSB0aWxlQ291bnQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChtYXhZc1tpXSA8IG1heFlzW2pdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF4WXNbaV0gPSBtYXhZc1tqXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChtaW5Zc1tpXSA+IG1pbllzW2pdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluWXNbaV0gPSBtaW5Zc1tqXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIElmIHRoZSB3b3JsZCBpcyByZXBlYXRlZCBhbG9uZyBZIGF4aXMsIHdlIG5lZWQgdG8gd3JhcCBpbmRpY2VzIGluIG1pbllzXHJcbiAgICAvLyBhbmQgbWF4WXMgYXJyYXlzIHRvIFswLCB0aWxlQ291bnQpIGludGVydmFsLlxyXG4gICAgaWYgKHdyYXBNb2RlWSA9PT0gMiAvKiBSRVBFQVQgKi8pIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHVtbkNvdW50ICYmIGkgPCB0aWxlQ291bnQ7ICsraSkge1xyXG4gICAgICAgICAgICBjb25zdCBkeSA9IG1heFlzW2ldIC0gbWluWXNbaV07XHJcbiAgICAgICAgICAgIC8vIElmIHRoZXJlJ3MgbW9yZSB0aGFuIHRpbGVDb3VudCByb3dzIGJldHdlZW4gbWF4WSBhbmQgbWluWSwgdGhlbiB0aGVcclxuICAgICAgICAgICAgLy8gd29ybGQgaXMgZW5jb21wYXNzZWQgc29tZXdoZXJlIHdpdGhpbiB2aXNpYmxlIHJlZ2lvbi5cclxuICAgICAgICAgICAgaWYgKGR5ID4gdGlsZUNvdW50KSB7XHJcbiAgICAgICAgICAgICAgICBtaW5Zc1tpXSA9IDA7XHJcbiAgICAgICAgICAgICAgICBtYXhZc1tpXSA9IHRpbGVJZHhNYXNrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbWluWSA9IG1pbllzW2ldICY9IHRpbGVJZHhNYXNrO1xyXG4gICAgICAgICAgICAgICAgbWF4WXNbaV0gPSBtaW5ZICsgZHk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHVtbkNvdW50ICYmIGkgPCB0aWxlQ291bnQ7ICsraSkge1xyXG4gICAgICAgICAgICBtaW5Zc1tpXSA9IE1hdGgubWF4KG1pbllzW2ldLCAwKTtcclxuICAgICAgICAgICAgbWF4WXNbaV0gPSBNYXRoLm1pbihtYXhZc1tpXSwgdGlsZUlkeE1hc2spO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICh3cmFwTW9kZVggPT09IDIgLyogUkVQRUFUICovKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2x1bW5Db3VudCAmJiBpIDwgdGlsZUNvdW50OyArK2kpIHtcclxuICAgICAgICAgICAgY29uc3QgdHggPSAoaSArIG1pblRYKSAmIHRpbGVJZHhNYXNrO1xyXG4gICAgICAgICAgICBmb3IgKGxldCB0eSA9IG1pbllzW2ldOyB0eSA8PSBtYXhZc1tpXTsgKyt0eSkge1xyXG4gICAgICAgICAgICAgICAgeWllbGQge1xyXG4gICAgICAgICAgICAgICAgICAgIHg6IHR4LFxyXG4gICAgICAgICAgICAgICAgICAgIHk6IHR5ICYgdGlsZUlkeE1hc2ssXHJcbiAgICAgICAgICAgICAgICAgICAgem9vbVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGZvciAobGV0IHR4ID0gTWF0aC5tYXgobWluVFgsIDApLCB0eEVuZCA9IE1hdGgubWluKG1heFRYLCB0aWxlSWR4TWFzayk7IHR4IDw9IHR4RW5kOyArK3R4KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGkgPSB0eCAtIG1pblRYO1xyXG4gICAgICAgICAgICBmb3IgKGxldCB0eSA9IG1pbllzW2ldOyB0eSA8PSBtYXhZc1tpXTsgKyt0eSkge1xyXG4gICAgICAgICAgICAgICAgeWllbGQge1xyXG4gICAgICAgICAgICAgICAgICAgIHg6IHR4LFxyXG4gICAgICAgICAgICAgICAgICAgIHk6IHR5ICYgdGlsZUlkeE1hc2ssXHJcbiAgICAgICAgICAgICAgICAgICAgem9vbVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9hZGFwdGVycy90aWxlX2Jhc2VkX2FkYXB0ZXIvdXRpbC92aXNpYmxlX3RpbGUudHNcbi8vIG1vZHVsZSBpZCA9IDcyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IGdldFRpbGVJZCwgZ2V0VGlsZUlkQnlSYXdWYWx1ZXMgfSBmcm9tICcuL3RpbGVfaWQnO1xyXG5pbXBvcnQgKiBhcyB2ZWMyIGZyb20gJy4uLy4uL21hdGgvdmVjdG9yMic7XHJcbmltcG9ydCB7IGN5Y2xlUmVzdHJpY3QgfSBmcm9tICcuLi8uLi9tYXRoL3NjYWxhcic7XHJcbmNvbnN0IExFRlRfU0lERSA9IHtcclxuICAgIGRpcmVjdGlvbjogdmVjMi5jcmVhdGUoMCwgLTEpLFxyXG4gICAgbm9ybWFsOiB2ZWMyLmNyZWF0ZSgtMSwgMCksXHJcbiAgICBkaWFnb25hbDogdmVjMi5jcmVhdGUoLTEsIC0xKSxcclxuICAgIHByZXZTaWRlOiAoKSA9PiBCT1RUT01fU0lERSxcclxuICAgIG5leHRTaWRlOiAoKSA9PiBUT1BfU0lERVxyXG59O1xyXG5jb25zdCBSSUdIVF9TSURFID0ge1xyXG4gICAgZGlyZWN0aW9uOiB2ZWMyLmNyZWF0ZSgwLCArMSksXHJcbiAgICBub3JtYWw6IHZlYzIuY3JlYXRlKCsxLCAwKSxcclxuICAgIGRpYWdvbmFsOiB2ZWMyLmNyZWF0ZSgrMSwgKzEpLFxyXG4gICAgcHJldlNpZGU6ICgpID0+IFRPUF9TSURFLFxyXG4gICAgbmV4dFNpZGU6ICgpID0+IEJPVFRPTV9TSURFXHJcbn07XHJcbmNvbnN0IFRPUF9TSURFID0ge1xyXG4gICAgZGlyZWN0aW9uOiB2ZWMyLmNyZWF0ZSgrMSwgMCksXHJcbiAgICBub3JtYWw6IHZlYzIuY3JlYXRlKDAsIC0xKSxcclxuICAgIGRpYWdvbmFsOiB2ZWMyLmNyZWF0ZSgrMSwgLTEpLFxyXG4gICAgcHJldlNpZGU6ICgpID0+IExFRlRfU0lERSxcclxuICAgIG5leHRTaWRlOiAoKSA9PiBSSUdIVF9TSURFXHJcbn07XHJcbmNvbnN0IEJPVFRPTV9TSURFID0ge1xyXG4gICAgZGlyZWN0aW9uOiB2ZWMyLmNyZWF0ZSgtMSwgMCksXHJcbiAgICBub3JtYWw6IHZlYzIuY3JlYXRlKDAsICsxKSxcclxuICAgIGRpYWdvbmFsOiB2ZWMyLmNyZWF0ZSgtMSwgKzEpLFxyXG4gICAgcHJldlNpZGU6ICgpID0+IFJJR0hUX1NJREUsXHJcbiAgICBuZXh0U2lkZTogKCkgPT4gTEVGVF9TSURFXHJcbn07XHJcbi8qKlxyXG4gKiBBZGRzIHRpbGUgdG8gYmVsdCB0aWxlcyBpZiBpdCBkb2Vzbid0IGZhbGwgb3V0IG9mIHRoZSB3b3JsZC4gQ3ljbGluZyBjb29yZGluYXRlcyBjYW4ndCBmYWxsIG91dCxcclxuICogdGhleSBqdXN0IGdvdCBhZGp1c3RlZCBkaXJlY3RseSBpbiB0aWxlIGl0ZW0uXHJcbiAqL1xyXG5mdW5jdGlvbiBhZGRUaWxlSWZBcHByb3ByaWF0ZSh0aWxlLCBiZWx0VGlsZXMsIG1heENvb3JkaW5hdGUsIGlzWEN5Y2xlZCwgaXNZQ3ljbGVkKSB7XHJcbiAgICB0aWxlLnggPSBpc1hDeWNsZWQgPyBjeWNsZVJlc3RyaWN0KHRpbGUueCwgMCwgbWF4Q29vcmRpbmF0ZSkgOiB0aWxlLng7XHJcbiAgICB0aWxlLnkgPSBpc1lDeWNsZWQgPyBjeWNsZVJlc3RyaWN0KHRpbGUueSwgMCwgbWF4Q29vcmRpbmF0ZSkgOiB0aWxlLnk7XHJcbiAgICBpZiAoKDAgPD0gdGlsZS54KSAmJiAodGlsZS54IDwgbWF4Q29vcmRpbmF0ZSkgJiZcclxuICAgICAgICAoMCA8PSB0aWxlLnkpICYmICh0aWxlLnkgPCBtYXhDb29yZGluYXRlKSkge1xyXG4gICAgICAgIGJlbHRUaWxlcy5zZXQoZ2V0VGlsZUlkKHRpbGUpLCB0aWxlKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGhlIGFsZ29yaXRobSBpcyBpbXBsZW1lbnRlZCBhcyBhIHN0YXRlIG1hY2hpbmUsIHRoaXMgbWV0aG9kIHByb2R1Y2VzIGJlbHQgdGlsZXMgYW5kIHNldHMgYXBwcm9wcmlhdGUgc3RhdGUuXHJcbiAqIEhvdyB0byBjaGFuZ2UgdGhpcyBzdGF0ZSAoZGV0ZXJtaW5lIGN1cnJlbnQgdGlsZSBhbmQgaXRzIHNpZGUpIGlzIGRlc2NyaWJlZCBpbiBmb3VyIFRpbGVTaWRlIGltcGxlbWVudGF0aW9uczpcclxuICogbGVmdCwgcmlnaHQsIHRvcCBhbmQgYm90dG9tLlxyXG4gKi9cclxuZnVuY3Rpb24gbW92ZSh0aWxlcywgc3RhdGUsIHNpemUsIG1heENvb3JkaW5hdGUsIGlzWEN5Y2xlZCwgaXNZQ3ljbGVkKSB7XHJcbiAgICAvLyBhZGQgdGlsZXMgb3V0d2FyZCBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBub3JtYWxcclxuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IHNpemU7IGkrKykge1xyXG4gICAgICAgIGFkZFRpbGVJZkFwcHJvcHJpYXRlKHtcclxuICAgICAgICAgICAgeDogc3RhdGUuY3VycmVudFRpbGUueCArIGkgKiBzdGF0ZS5jdXJyZW50VGlsZVNpZGUubm9ybWFsLngsXHJcbiAgICAgICAgICAgIHk6IHN0YXRlLmN1cnJlbnRUaWxlLnkgKyBpICogc3RhdGUuY3VycmVudFRpbGVTaWRlLm5vcm1hbC55LFxyXG4gICAgICAgICAgICB6b29tOiBzdGF0ZS5jdXJyZW50VGlsZS56b29tXHJcbiAgICAgICAgfSwgc3RhdGUuYmVsdFRpbGVzLCBtYXhDb29yZGluYXRlLCBpc1hDeWNsZWQsIGlzWUN5Y2xlZCk7XHJcbiAgICB9XHJcbiAgICAvLyBjaGVjayBkaWFnb25hbCB0aWxlXHJcbiAgICBjb25zdCBkaWFnb25hbE5laWdoYm91ciA9IHRpbGVzLmdldChnZXRUaWxlSWRCeVJhd1ZhbHVlcyhzdGF0ZS5jdXJyZW50VGlsZS54ICsgc3RhdGUuY3VycmVudFRpbGVTaWRlLmRpYWdvbmFsLngsIHN0YXRlLmN1cnJlbnRUaWxlLnkgKyBzdGF0ZS5jdXJyZW50VGlsZVNpZGUuZGlhZ29uYWwueSwgc3RhdGUuY3VycmVudFRpbGUuem9vbSkpO1xyXG4gICAgaWYgKGRpYWdvbmFsTmVpZ2hib3VyKSB7XHJcbiAgICAgICAgc3RhdGUuY3VycmVudFRpbGUgPSBkaWFnb25hbE5laWdoYm91cjtcclxuICAgICAgICBzdGF0ZS5jdXJyZW50VGlsZVNpZGUgPSBzdGF0ZS5jdXJyZW50VGlsZVNpZGUucHJldlNpZGUoKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAvLyBjaGVjayBuZWlnaGJvdXIgaW4gdGhlIHNhbWUgZGlyZWN0aW9uXHJcbiAgICBjb25zdCBuZWlnaGJvdXIgPSB0aWxlcy5nZXQoZ2V0VGlsZUlkQnlSYXdWYWx1ZXMoc3RhdGUuY3VycmVudFRpbGUueCArIHN0YXRlLmN1cnJlbnRUaWxlU2lkZS5kaXJlY3Rpb24ueCwgc3RhdGUuY3VycmVudFRpbGUueSArIHN0YXRlLmN1cnJlbnRUaWxlU2lkZS5kaXJlY3Rpb24ueSwgc3RhdGUuY3VycmVudFRpbGUuem9vbSkpO1xyXG4gICAgaWYgKG5laWdoYm91cikge1xyXG4gICAgICAgIHN0YXRlLmN1cnJlbnRUaWxlID0gbmVpZ2hib3VyO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIC8vIGhhbmRsZSBjb3JuZXIgdGlsZXNcclxuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IHNpemU7IGkrKykge1xyXG4gICAgICAgIGZvciAobGV0IGogPSAxOyBqIDw9IHNpemU7IGorKykge1xyXG4gICAgICAgICAgICBhZGRUaWxlSWZBcHByb3ByaWF0ZSh7XHJcbiAgICAgICAgICAgICAgICB4OiBzdGF0ZS5jdXJyZW50VGlsZS54ICsgaSAqIHN0YXRlLmN1cnJlbnRUaWxlU2lkZS5kaWFnb25hbC54LFxyXG4gICAgICAgICAgICAgICAgeTogc3RhdGUuY3VycmVudFRpbGUueSArIGogKiBzdGF0ZS5jdXJyZW50VGlsZVNpZGUuZGlhZ29uYWwueSxcclxuICAgICAgICAgICAgICAgIHpvb206IHN0YXRlLmN1cnJlbnRUaWxlLnpvb21cclxuICAgICAgICAgICAgfSwgc3RhdGUuYmVsdFRpbGVzLCBtYXhDb29yZGluYXRlLCBpc1hDeWNsZWQsIGlzWUN5Y2xlZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGUuY3VycmVudFRpbGVTaWRlID0gc3RhdGUuY3VycmVudFRpbGVTaWRlLm5leHRTaWRlKCk7XHJcbn1cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGlsZXMgdGhhdCBzdXJyb3VuZCBwcm92aWRlZCByZWdpb24gKHNldCBvZiB0aWxlcyksIHRoZSByZWdpb24gbXVzdCBiZSBvbmUgb3IgbW9yZSBjb252ZXggcG9seWdvbnNcclxuICogd2l0aCBubyBob2xlcywgb3RoZXJ3aXNlIGNvcnJlY3RuZXNzIGlzIG5vdCBndWFyYW50ZWVkLiBNdWx0aXBsZSBwb2x5Z29ucyBjYW4gaGFwcGVuIHdoZW4gdGhlIGNhbWVyYSBsb29rc1xyXG4gKiBhdCB0aGUgZWRnZSBvZiB0aGUgd29ybGQgY2FwdHVyaW5nIGN5Y2xlZCB0aWxlcyBmcm9tIGRpZmZlcmVudCBzaWRlcy5cclxuICogVGhlIGxvZ2ljIG9mIGluY2x1ZGluZyB0aWxlcyBpbiB0aGUgXCJiZWx0XCIgaXMgYXMgZm9sbG93czogc2hvcnRlc3QgZGlzdGFuY2UgZnJvbSBcIm91dHNpZGVcIiB0byBhbnkgcG9pbnRcclxuICogaW4gdGhlIG9yaWdpbmFsIHJlZ2lvbiBzaG91bGQgYmUgbm90IGxlc3MgdGhhbiB0aWxlU2l6ZSAqIGJlbHRTaXplLlxyXG4gKlxyXG4gKiBAcGFyYW0gdGlsZXMgU2V0IG9mIHRpbGVzIHRoYXQgY292ZXIgYSBjb252ZXggcG9seWdvbi5cclxuICogQHBhcmFtIGJlbHRTaXplIFwidGhpY2tuZXNzXCIgKGluIHRpbGVzKSBvZiB0aGUgc3Vycm91bmRpbmcgYXJlYS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVCZWx0VGlsZXModGlsZXMsIGJlbHRTaXplLCBpc1hDeWNsZWQsIGlzWUN5Y2xlZCkge1xyXG4gICAgLy8gdGhlIGFsZ29yaXRobSBpbiBzaW1wbGUgd29yZHM6XHJcbiAgICAvLyAgIDEuIGZpbmQgYSB0aWxlIG9uIGFuIGVkZ2Ugb2YgdGhlIHBvbHlnb24gKGUuZy4gb25lIG9mIHRoZSBsZWZ0bW9zdCBvbmVzKVxyXG4gICAgLy8gICAyLiBnbyBhcm91bmQgdGhlIHBvbHlnb24gdGlsZS1ieS10aWxlIGFkZGluZyBzdXJyb3VuZGluZyB0aWxlcyBvdXR3YXJkbHlcclxuICAgIGNvbnN0IGluZGV4ZWRUaWxlcyA9IG5ldyBNYXAoKTtcclxuICAgIGNvbnN0IGJlbHRUaWxlcyA9IG5ldyBNYXAoKTtcclxuICAgIC8vIGluZGV4IHRpbGVzXHJcbiAgICBmb3IgKGNvbnN0IHRpbGVJdGVtIG9mIHRpbGVzKSB7XHJcbiAgICAgICAgaW5kZXhlZFRpbGVzLnNldChnZXRUaWxlSWQodGlsZUl0ZW0pLCB0aWxlSXRlbSk7XHJcbiAgICB9XHJcbiAgICAvLyB0aWxlcyBhcmUgZ3JvdXBlZCBpbnRvIG9uZSBvciBtb3JlIGNvbnZleCBwb2x5Z29ucywgcHJvY2VzcyB0aGVzZSBwb2x5Z29ucyBvbmUgYnkgb25lXHJcbiAgICBjb25zdCB0aWxlc1RvUHJvY2VzcyA9IG5ldyBNYXAoaW5kZXhlZFRpbGVzKTtcclxuICAgIHdoaWxlICh0aWxlc1RvUHJvY2Vzcy5zaXplID4gMCkge1xyXG4gICAgICAgIGxldCBsZWZ0bW9zdFRpbGUgPSB7IHg6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgeTogMCwgem9vbTogMCB9O1xyXG4gICAgICAgIC8vIGZpbmQgdGhlIGxlZnRtb3N0IHRpbGUgdG8gc3RhcnQgd2Fsa2luZyBmcm9tXHJcbiAgICAgICAgZm9yIChjb25zdCB0aWxlSXRlbSBvZiB0aWxlc1RvUHJvY2Vzcy52YWx1ZXMoKSkge1xyXG4gICAgICAgICAgICBpZiAodGlsZUl0ZW0ueCA8IGxlZnRtb3N0VGlsZS54KSB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0bW9zdFRpbGUgPSB0aWxlSXRlbTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzYXZlIG1pbi9tYXggeSB2YWx1ZSBwZXIgeCBjb29yZGluYXRlIHRvIGJlIGFibGVcclxuICAgICAgICAvLyB0byBtYXJrIHRoZXNlIHRpbGVzIGFzIHByb2Nlc3NlZCAocmVtb3ZlIGZyb20gdGlsZXNUb1Byb2Nlc3MpXHJcbiAgICAgICAgY29uc3QgbWF4WSA9IFtdO1xyXG4gICAgICAgIGNvbnN0IG1pblkgPSBbXTtcclxuICAgICAgICBjb25zdCBpbml0U3RhdGUgPSB7IGN1cnJlbnRUaWxlOiBsZWZ0bW9zdFRpbGUsIGN1cnJlbnRUaWxlU2lkZTogTEVGVF9TSURFLCBiZWx0VGlsZXMgfTtcclxuICAgICAgICBjb25zdCBzdGF0ZSA9IE9iamVjdC5hc3NpZ24oe30sIGluaXRTdGF0ZSk7XHJcbiAgICAgICAgY29uc3QgbWF4Q29vcmRpbmF0ZSA9IE1hdGgucG93KDIsIGxlZnRtb3N0VGlsZS56b29tKTtcclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIC8vIG1vdmUgYXJvdW5kIHdoaWxlIHdlIGRvbid0IHJlYWNoIHRoZSBpbml0IHBvc2l0aW9uXHJcbiAgICAgICAgICAgIG1vdmUodGlsZXNUb1Byb2Nlc3MsIHN0YXRlLCBiZWx0U2l6ZSwgbWF4Q29vcmRpbmF0ZSwgaXNYQ3ljbGVkLCBpc1lDeWNsZWQpO1xyXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHN0YXRlLmN1cnJlbnRUaWxlLnggLSBpbml0U3RhdGUuY3VycmVudFRpbGUueDtcclxuICAgICAgICAgICAgbWF4WVtpbmRleF0gPSBtYXhZW2luZGV4XSA9PT0gdW5kZWZpbmVkID8gc3RhdGUuY3VycmVudFRpbGUueSA6IE1hdGgubWF4KG1heFlbaW5kZXhdLCBzdGF0ZS5jdXJyZW50VGlsZS55KTtcclxuICAgICAgICAgICAgbWluWVtpbmRleF0gPSBtaW5ZW2luZGV4XSA9PT0gdW5kZWZpbmVkID8gc3RhdGUuY3VycmVudFRpbGUueSA6IE1hdGgubWluKG1pbllbaW5kZXhdLCBzdGF0ZS5jdXJyZW50VGlsZS55KTtcclxuICAgICAgICB9IHdoaWxlIChzdGF0ZS5jdXJyZW50VGlsZSAhPT0gaW5pdFN0YXRlLmN1cnJlbnRUaWxlIHx8XHJcbiAgICAgICAgICAgIHN0YXRlLmN1cnJlbnRUaWxlU2lkZSAhPT0gaW5pdFN0YXRlLmN1cnJlbnRUaWxlU2lkZSk7XHJcbiAgICAgICAgLy8gbWFyayB0aWxlcyBmcm9tIGN1cnJlbnQgcG9seWdvbiBhcyBwcm9jZXNzZWRcclxuICAgICAgICBjb25zdCB6b29tID0gbGVmdG1vc3RUaWxlLnpvb207XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhZLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHggPSBsZWZ0bW9zdFRpbGUueCArIGk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSBtaW5ZW2ldOyB5IDw9IG1heFlbaV07IHkrKykge1xyXG4gICAgICAgICAgICAgICAgdGlsZXNUb1Byb2Nlc3MuZGVsZXRlKGdldFRpbGVJZEJ5UmF3VmFsdWVzKHgsIHksIHpvb20pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIHJlbW92ZSBiZWx0IHRpbGVzIHRoYXQgb3ZlcmxhcHMgdG8gYXZvaWQgZHVwbGljYXRpb25zXHJcbiAgICBmb3IgKGNvbnN0IHRpbGVJZCBvZiBiZWx0VGlsZXMua2V5cygpKSB7XHJcbiAgICAgICAgaWYgKGluZGV4ZWRUaWxlcy5oYXModGlsZUlkKSkge1xyXG4gICAgICAgICAgICBiZWx0VGlsZXMuZGVsZXRlKHRpbGVJZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGJlbHRUaWxlcy52YWx1ZXMoKTtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9hZGFwdGVycy90aWxlX2Jhc2VkX2FkYXB0ZXIvYmVsdF90aWxlcy50c1xuLy8gbW9kdWxlIGlkID0gNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgQXR0cmlidXRlTWFwcGluZyB9IGZyb20gJy4uLy4uL3JlbmRlci9hdHRyaWJfbWFwcGluZyc7XHJcbmltcG9ydCBCdWZmZXJXcml0ZXIgZnJvbSAnLi4vLi4vdXRpbC9idWZmZXJfd3JpdGVyJztcclxuLyoqXHJcbiAqIFdyaXRlciBvZiBnZW9tZXRyeSBkYXRhIG9mIGljb25zLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSWNvbkJ1ZmZlcldyaXRlciBleHRlbmRzIEJ1ZmZlcldyaXRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcihJY29uQnVmZmVyV3JpdGVyLkFUVFJJQlVURV9NQVBQSU5HLnZlcnRleEJ5dGVTaXplKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGFuIGljb24gdG8gYnVmZmVycy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaWNvbiBJY29uIHRvIGJlIHdyaXR0ZW4gdG8gYnVmZmVyLlxyXG4gICAgICogQHBhcmFtIGxvY2F0aW9uIEltYWdlIGxvY2F0aW9uIGluIGF0bGFzLlxyXG4gICAgICogQHBhcmFtIHNpemUgSW1hZ2Ugc2l6ZSBpbiBhdGxhcy5cclxuICAgICAqIEBwYXJhbSBvZmZzZXQgT2Zmc2V0IG9mIGltYWdlIHBvaW50cyBpbiBDU1MgcGl4ZWxzLlxyXG4gICAgICogQHBhcmFtIHBpeGVsUmF0aW8gUmF0aW8gb2YgaW1hZ2Ugc2l6ZSBpbiBDU1MgcGl4ZWxzIHRvIHRoZSBzaXplIGluIGF0bGFzIHBpeGVscy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBMb2NhdGlvbiBvZiB0aGUgaWNvbiBkYXRhIGluIGJ1ZmZlcnMuXHJcbiAgICAgKi9cclxuICAgIHdyaXRlSWNvbihpY29uLCBsb2NhdGlvbiwgc2l6ZSwgb2Zmc2V0LCBwaXhlbFJhdGlvKSB7XHJcbiAgICAgICAgY29uc3QgdG9wID0gb2Zmc2V0Lnk7XHJcbiAgICAgICAgY29uc3QgYm90dG9tID0gb2Zmc2V0LnkgKyBzaXplLmhlaWdodCAqIHBpeGVsUmF0aW87XHJcbiAgICAgICAgY29uc3QgbGVmdCA9IG9mZnNldC54O1xyXG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gb2Zmc2V0LnggKyBzaXplLndpZHRoICogcGl4ZWxSYXRpbztcclxuICAgICAgICB0aGlzLndyaXRlVmVydGV4KGljb24ucG9zaXRpb24sIGxlZnQsIGJvdHRvbSwgbG9jYXRpb24ubWluWCwgbG9jYXRpb24ubWluWSk7XHJcbiAgICAgICAgdGhpcy53cml0ZVZlcnRleChpY29uLnBvc2l0aW9uLCBsZWZ0LCB0b3AsIGxvY2F0aW9uLm1pblgsIGxvY2F0aW9uLm1heFkpO1xyXG4gICAgICAgIHRoaXMud3JpdGVWZXJ0ZXgoaWNvbi5wb3NpdGlvbiwgcmlnaHQsIGJvdHRvbSwgbG9jYXRpb24ubWF4WCwgbG9jYXRpb24ubWluWSk7XHJcbiAgICAgICAgdGhpcy53cml0ZVZlcnRleChpY29uLnBvc2l0aW9uLCByaWdodCwgdG9wLCBsb2NhdGlvbi5tYXhYLCBsb2NhdGlvbi5tYXhZKTtcclxuICAgICAgICB0aGlzLndyaXRlSW5kaWNlc0ZvckNvbnRpbnVvdXNTdHJpcCg0KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5lbmRNZXNoKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIHZlcnRleCB0byB0aGUgdmVydGV4IGJ1ZmZlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcG9zaXRpb24gUG9zaXRpb24gb2YgdGhlIHZlcnRleCBpbiBkaXNwbGF5IGNvb3JkaW5hdGVzLlxyXG4gICAgICogQHBhcmFtIHV2IFVWcyBvZiB0aGUgdmVydGV4LlxyXG4gICAgICogQHJldHVybiBJbmRleCBvZiB0aGUgd3JpdHRlbiB2ZXJ0ZXguXHJcbiAgICAgKi9cclxuICAgIHdyaXRlVmVydGV4KHBvc2l0aW9uLCBkaXNwbGFjZW1lbnRYLCBkaXNwbGFjZW1lbnRZLCB1dlgsIHV2WSkge1xyXG4gICAgICAgIGNvbnN0IHZlcnRleElkeCA9IHRoaXMuZ2V0Q3VycmVudFZlcnRleElkeCgpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlV29ybGRDb29yZGluYXRlKHBvc2l0aW9uKTtcclxuICAgICAgICB0aGlzLl93cml0ZUhhbGZXb3JkcyhkaXNwbGFjZW1lbnRYLCBkaXNwbGFjZW1lbnRZKTtcclxuICAgICAgICB0aGlzLl93cml0ZUhhbGZXb3Jkcyh1dlgsIHV2WSk7XHJcbiAgICAgICAgcmV0dXJuIHZlcnRleElkeDtcclxuICAgIH1cclxufVxyXG4vKiogRGVzY3JpcHRpb24gb2YgaG93IGEgd3JpdGVyIHN0b3JlcyB2ZXJ0ZXggZGF0YS4gKi9cclxuSWNvbkJ1ZmZlcldyaXRlci5BVFRSSUJVVEVfTUFQUElORyA9IG5ldyBBdHRyaWJ1dGVNYXBwaW5nKFtcclxuICAgIFtcclxuICAgICAgICAwIC8qIFBPU0lUSU9OX0hJR0ggKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIzIC8qIFVOU0lHTkVEX1NIT1JUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICAxIC8qIFBPU0lUSU9OX0xPVyAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDIsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjMgLyogVU5TSUdORURfU0hPUlQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDYgLyogRElTUExBQ0VNRU5UICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMixcclxuICAgICAgICAgICAgdHlwZTogNTEyMiAvKiBTSE9SVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDQgLyogVVYgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIzIC8qIFVOU0lHTkVEX1NIT1JUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgIF1cclxuXSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3ByaW1pdGl2ZS9pY29uL2ljb25fYnVmZmVyX3dyaXRlci50c1xuLy8gbW9kdWxlIGlkID0gNzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IFJlZmVyZW5jZUNvdW50ZWQgZnJvbSAnLi4vdXRpbC9yZWZfY291bnRlZCc7XHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGFuIGFsbG9jYXRlZCBpbWFnZS4gQWxsb2NhdGVkIGltYWdlIGlzIGEgc2hhcmVhYmxlIHJlc291cmNlIHRoYXQgc2hvdWxkIGJlIHJlc2VhbGVkXHJcbiAqIHdoZW4gdGhlcmUgYXJlIG5vIGNsaWVudHMgdXNlIGl0LiBBcyBpdCBpcyBub3QgcG9zc2libGUgdG8gcmVseSBvbiB0aGUgR0MsIGNsaWVudHMgc2hvdWxkXHJcbiAqIG1hbnVhbGx5IHJldGFpbiB0aGVpciByZXF1aXJlZCBpbWFnZXMgYW5kIHJlbGVhc2UgdGhlbSB3aGVuIHRoZXkgYXJlIG5vdCByZXF1aXJlZCBhbnltb3JlLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEFsbG9jYXRlZEltYWdlIGV4dGVuZHMgUmVmZXJlbmNlQ291bnRlZCB7XHJcbiAgICBjb25zdHJ1Y3RvcihkZXNjcmlwdG9yLCBiYm94LCBhdGxhc01hbmFnZXIpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuZGVzY3JpcHRvciA9IGRlc2NyaXB0b3I7XHJcbiAgICAgICAgdGhpcy5iYm94ID0gYmJveDtcclxuICAgICAgICB0aGlzLmF0bGFzTWFuYWdlciA9IGF0bGFzTWFuYWdlcjtcclxuICAgIH1cclxuICAgIHVwZGF0ZUltYWdlKHNvdXJjZUltYWdlLCBsb2NhdGlvblJlZ2lvbiwgc291cmNlSW1hZ2VSZWdpb24pIHtcclxuICAgICAgICB0aGlzLmF0bGFzTWFuYWdlci5hdGxhcy51cGRhdGVJbWFnZSh0aGlzLmJib3gsIHNvdXJjZUltYWdlLCBsb2NhdGlvblJlZ2lvbiwgc291cmNlSW1hZ2VSZWdpb24pO1xyXG4gICAgfVxyXG4gICAgX2Rlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5hdGxhc01hbmFnZXIucmVtb3ZlSW1hZ2UodGhpcy5kZXNjcmlwdG9yKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogTWFuYWdlcyBhbGxvY2F0aW9uIG9mIGltYWdlcyBieSBpZC5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElkZW50aWZpZWRJbWFnZUF0bGFzTWFuYWdlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihpbWFnZUF0bGFzKSB7XHJcbiAgICAgICAgdGhpcy5hdGxhcyA9IGltYWdlQXRsYXM7XHJcbiAgICAgICAgdGhpcy5fbG9jYXRpb25zID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHNpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2F0aW9ucy5zaXplO1xyXG4gICAgfVxyXG4gICAgZ2V0SW1hZ2UoaWQsIHJldGFpbiA9IGZhbHNlKSB7XHJcbiAgICAgICAgY29uc3QgaW1hZ2VMb2NhdGlvbiA9IHRoaXMuX2xvY2F0aW9ucy5nZXQoaWQpO1xyXG4gICAgICAgIGlmIChyZXRhaW4gJiYgaW1hZ2VMb2NhdGlvbikge1xyXG4gICAgICAgICAgICBpbWFnZUxvY2F0aW9uLnJldGFpbigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaW1hZ2VMb2NhdGlvbiB8fCBudWxsO1xyXG4gICAgfVxyXG4gICAgYWxsb2NhdGVJbWFnZShkZXNjcmlwdG9yLCBpbWFnZSkge1xyXG4gICAgICAgIGNvbnN0IGxvY2F0aW9uID0gdGhpcy5hdGxhcy5hbGxvY2F0ZUltYWdlKGRlc2NyaXB0b3IsIGltYWdlKTtcclxuICAgICAgICBpZiAobG9jYXRpb24pIHtcclxuICAgICAgICAgICAgY29uc3QgaW1hZ2UgPSBuZXcgQWxsb2NhdGVkSW1hZ2UoZGVzY3JpcHRvciwgbG9jYXRpb24sIHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLl9sb2NhdGlvbnMuc2V0KGRlc2NyaXB0b3IuaWQsIGltYWdlKTtcclxuICAgICAgICAgICAgcmV0dXJuIGltYWdlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHJlbW92ZUltYWdlKGltYWdlKSB7XHJcbiAgICAgICAgY29uc3QgbG9jYXRpb24gPSB0aGlzLl9sb2NhdGlvbnMuZ2V0KGltYWdlLmlkKTtcclxuICAgICAgICBpZiAobG9jYXRpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5hdGxhcy5yZW1vdmVJbWFnZShsb2NhdGlvbi5iYm94KTtcclxuICAgICAgICAgICAgdGhpcy5fbG9jYXRpb25zLmRlbGV0ZShpbWFnZS5pZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29udGFpbnMoaWQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYXRpb25zLmhhcyhpZCk7XHJcbiAgICB9XHJcbiAgICByZXNlcnZlTG9jYXRpb24oZGVzY3JpcHRvcikge1xyXG4gICAgICAgIGNvbnN0IGxvY2F0aW9uID0gdGhpcy5hdGxhcy5yZXNlcnZlTG9jYXRpb24oZGVzY3JpcHRvcik7XHJcbiAgICAgICAgaWYgKGxvY2F0aW9uKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGltYWdlID0gbmV3IEFsbG9jYXRlZEltYWdlKGRlc2NyaXB0b3IsIGxvY2F0aW9uLCB0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5fbG9jYXRpb25zLnNldChkZXNjcmlwdG9yLmlkLCBpbWFnZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBpbWFnZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYmlsbGJvYXJkL2lkZW50aWZpZWRfaW1hZ2VfYXRsYXNfbWFuYWdlci50c1xuLy8gbW9kdWxlIGlkID0gNzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIEZvbnQgaXMganVzdCBhIGNvbGxlY3Rpb24gb2YgZ2x5cGggZGVzY3JpcHRpb25zLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRm9udCB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBpZCBGb250IGlkLlxyXG4gICAgICogQHBhcmFtIHhoZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgXCJ4XCIgY2hhciBpbiBhYnN0cmFjdCBwb2ludHMsIGluIGZhY3QgaXMgdXNlZCBhIHRoZSBmb250IHNpemUuXHJcbiAgICAgKiBAcGFyYW0gdW5rbm93bkdseXBoSW5zdGFuY2UgQW4gaW5zdGFuY2Ugb2YgZ2x5cGggdG8gYmUgc2VydmVkIGFzIGEgc3R1YiB3aGVuIG5vbmV4aXN0ZW50IGdseXBoXHJcbiAgICAgKiAgICAgaXMgcmVxdWVzdGVkLiBSZXF1ZXN0aW5nIG5vbmV4aXN0ZW50IGdseXBocyBub3JtYWxseSBzaG91bGQgbm90IGhhcHBlbi5cclxuICAgICAqICAgICBUaGUgc3R1YiBqdXN0IGFsbG93cyB0byBhdm9pZCB0ZWRpb3VzIG51bGwgY2hlY2tzIGluIGZvbnQgY2xpZW50cy5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoaWQsIHhoZWlnaHQsIHVua25vd25HbHlwaEluc3RhbmNlKSB7XHJcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG4gICAgICAgIHRoaXMueGhlaWdodCA9IHhoZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5fdW5rbm93bkdseXBoSW5zdGFuY2UgPSB1bmtub3duR2x5cGhJbnN0YW5jZTtcclxuICAgICAgICB0aGlzLl9nbHlwaHMgPSBuZXcgTWFwKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gR2x5cGggd2l0aCBzcGVjaWZpZWQgaWQgb3IgdW5rbm93biBnbHlwaCBpbnN0YW5jZS5cclxuICAgICAqL1xyXG4gICAgZ2V0R2x5cGgoZ2x5cGhJZCkge1xyXG4gICAgICAgIGNvbnN0IGdseXBoID0gdGhpcy5fZ2x5cGhzLmdldChnbHlwaElkKTtcclxuICAgICAgICBpZiAoZ2x5cGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdseXBoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdXb3ctd293LXdvdywgc29tZXRoaW5nIHdlbnQgd3JvbmcsIHlvdSBzaG91bGQgbm90IHJlcXVlc3Qgbm9uZXhpc3RlbnQgZ2x5cGhzJyk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl91bmtub3duR2x5cGhJbnN0YW5jZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIEFsbCBzdG9yZWQgZ2x5cGhzLlxyXG4gICAgICovXHJcbiAgICBnZXRBbGxHbHlwaHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIFsuLi50aGlzLl9nbHlwaHMudmFsdWVzKCldO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGdseXBoIGRlc2NyaXB0aW9uLlxyXG4gICAgICovXHJcbiAgICBhZGRHbHlwaChnbHlwaCkge1xyXG4gICAgICAgIHRoaXMuX2dseXBocy5zZXQoZ2x5cGguaWQsIGdseXBoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBnbHlwaCBkZXNjcmlwdGlvbnMgZnJvbSB0aGUgaXRlcmFibGUuXHJcbiAgICAgKi9cclxuICAgIGFkZEFsbEdseXBocyhnbHlwaHMpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGdseXBoIG9mIGdseXBocykge1xyXG4gICAgICAgICAgICB0aGlzLmFkZEdseXBoKGdseXBoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvZm9udC9mb250LnRzXG4vLyBtb2R1bGUgaWQgPSA3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBJbWFnZVByb3ZpZGVyIH0gZnJvbSAnLi4vLi4vYmlsbGJvYXJkL2ltYWdlX3Byb3ZpZGVyJztcclxuaW1wb3J0IGdldERwciBmcm9tICcuLi8uLi91dGlsL2hkJztcclxuaW1wb3J0IHsgZ2V0SG9zdEFsaWFzQnlVaWQgfSBmcm9tICcuL3V0aWwvaG9zdHMnO1xyXG4vKipcclxuICogSW1hZ2UgcHJvdmlkZXIgdGhhdCBnZXRzIGltYWdlcyBmcm9tIHNwZWNpZmljIEFQSSBlbnRyeSBwb2ludC5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBBcGlJbWFnZVByb3ZpZGVyIGV4dGVuZHMgSW1hZ2VQcm92aWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihpbWFnZVVybFRlbXBsYXRlKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl9pbWFnZVVybFRlbXBsYXRlID0gaW1hZ2VVcmxUZW1wbGF0ZTtcclxuICAgIH1cclxuICAgIGdldEltYWdlVXJsKGlkKSB7XHJcbiAgICAgICAgLy8gQVBJIGNhbiByZXR1cm4gc2NhbGVkIGltYWdlcyB0aGF0IGFsbG93cyB1cyB0byByZXF1ZXN0IGltYWdlcyBhY2NvcmRpbmdcclxuICAgICAgICAvLyB0byB1c2VyJ3MgRFBJIGFuZCByZW5kZXIgdGhlbSBwcm9wZXJseSwgbm9uLWludGVnZXIgbnVtYmVycyBhcmUgYWNjZXB0ZWQuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ltYWdlVXJsVGVtcGxhdGVcclxuICAgICAgICAgICAgLnJlcGxhY2UoJ3t7aG9zdEFsaWFzfX0nLCBnZXRIb3N0QWxpYXNCeVVpZChpZCkpXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHtcXHtpZFxcfVxcfS9nLCBpZClcclxuICAgICAgICAgICAgLnJlcGxhY2UoJ3t7c2NhbGV9fScsIGdldERwcigpLnRvU3RyaW5nKCkpO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2FkYXB0ZXJzL3ZlY3Rvcl9hcGkvYXBpX2ltYWdlX3Byb3ZpZGVyLnRzXG4vLyBtb2R1bGUgaWQgPSA3N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICogQWJzdHJhY3QgaW1hZ2UgY29udGVudCBwcm92aWRlciwgY29uY3JldGUgaW1wbGVtZW50YXRpb25zIHNob3VsZCBzcGVjaWZ5IHRoZSBlbnRyeSBwb2ludCBpbiBnZXRJbWFnZVVybCgpLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEltYWdlUHJvdmlkZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGltYWdlIGJpdG1hcCB2aWEgYW4gSFRNTEltYWdlRWxlbWVudCBhbmQgYSBjYW52YXMuXHJcbiAgICAgKi9cclxuICAgIGdldEltYWdlKGlkKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaW1hZ2VFbGVtZW50ID0gbmV3IEltYWdlKCk7XHJcbiAgICAgICAgICAgIGltYWdlRWxlbWVudC5jcm9zc09yaWdpbiA9ICdhbm9ueW1vdXMnO1xyXG4gICAgICAgICAgICBpbWFnZUVsZW1lbnQub25sb2FkID0gKCkgPT4gcmVzb2x2ZShpbWFnZUVsZW1lbnQpO1xyXG4gICAgICAgICAgICBpbWFnZUVsZW1lbnQub25lcnJvciA9IHJlamVjdDtcclxuICAgICAgICAgICAgaW1hZ2VFbGVtZW50LnNyYyA9IHRoaXMuZ2V0SW1hZ2VVcmwoaWQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2JpbGxib2FyZC9pbWFnZV9wcm92aWRlci50c1xuLy8gbW9kdWxlIGlkID0gNzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiY29uc3QgSE9TVF9BTElBU0VTX04gPSA0O1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0SG9zdEFsaWFzQnlVaWQodWlkKSB7XHJcbiAgICBsZXQgc3VtID0gMDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdWlkLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgc3VtICs9IHVpZC5jaGFyQ29kZUF0KGkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIChzdW0gJSBIT1NUX0FMSUFTRVNfTiArIDEpLnRvU3RyaW5nKCk7XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdmVjdG9yX2FwaS91dGlsL2hvc3RzLnRzXG4vLyBtb2R1bGUgaWQgPSA3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBBdHRyaWJ1dGVNYXBwaW5nIH0gZnJvbSAnLi4vLi4vcmVuZGVyL2F0dHJpYl9tYXBwaW5nJztcclxuaW1wb3J0IEJ1ZmZlcldyaXRlciBmcm9tICcuLi8uLi91dGlsL2J1ZmZlcl93cml0ZXInO1xyXG5pbXBvcnQgd3JpdGVUZXh0dXJlZFBvbHlsaW5lR2VvbWV0cnkgZnJvbSAnLi90ZXh0dXJlZF9wb2x5bGluZV9nZW9tZXRyeSc7XHJcbmltcG9ydCB7IGludFRvWkluZGV4IH0gZnJvbSAnLi4vLi4vdXRpbC96X2luZGV4JztcclxuLyoqXHJcbiAqIFdyaXRlciBvZiBnZW9tZXRyeSBkYXRhIG9mIHBvbHlsaW5lIGh1bGxzLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGV4dHVyZWRQb2x5bGluZUJ1ZmZlcldyaXRlciBleHRlbmRzIEJ1ZmZlcldyaXRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcihUZXh0dXJlZFBvbHlsaW5lQnVmZmVyV3JpdGVyLkFUVFJJQlVURV9NQVBQSU5HLnZlcnRleEJ5dGVTaXplKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJhdGVzIGEgaHVsbCBmb3IgYSBwb2x5bGluZSBhbmQgd3JpdGVzIGl0IHRvIHRoZSB3cml0ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBvbHlsaW5lIFRoZSBwb2x5bGluZSB0byBiZSB3cml0dGVuLlxyXG4gICAgICogQHBhcmFtIHdpZHRoIFRoaWNrbmVzcyBvZiB0aGUgcG9seWxpbmUuXHJcbiAgICAgKiBAcGFyYW0gd29ybGRUb1B4RmFjdG9yIFJhdGlvIG9mIHdvcmxkIGNvb3JkaW5hdGVzIHRvIHBpeGVscy5cclxuICAgICAqIEBwYXJhbSBpbWFnZUxvY2F0aW9uIEltYWdlIGxvY2F0aW9uIGluIGF0bGFzLlxyXG4gICAgICogQHBhcmFtIHpJbmRleCBaLWluZGV4IG9mIHRoZSBwb2x5bGluZS5cclxuICAgICAqL1xyXG4gICAgd3JpdGVUZXh0dXJlZFBvbHlsaW5lKHBvbHlsaW5lLCB3aWR0aCwgd29ybGRUb1B4RmFjdG9yLCBpbWFnZUxvY2F0aW9uLCB6SW5kZXgpIHtcclxuICAgICAgICB3cml0ZVRleHR1cmVkUG9seWxpbmVHZW9tZXRyeSh0aGlzLCBwb2x5bGluZS52ZXJ0aWNlcywgd29ybGRUb1B4RmFjdG9yLCBpbWFnZUxvY2F0aW9uLCB3aWR0aCwgaW50VG9aSW5kZXgoekluZGV4ICsgMSkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVuZE1lc2goKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGEgdmVydGV4IHRvIHRoZSB2ZXJ0ZXggYnVmZmVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwb3NpdGlvbiBQb3NpdGlvbiBvZiB0aGUgdmVydGV4IGluIHdvcmxkIGNvb3JkaW5hdGVzLlxyXG4gICAgICogQHBhcmFtIGRpc3BsYWNlbWVudCBEaXNwbGFjZW1lbnQgdmVjdG9yLCBpbiBtb3N0IGNhc2VzIG11c3QgYmUgbm9ybWFsaXplZCwgdGhlIHdpZHRoIGlzIGNvbnNpZGVyZWQgaW4gc2hhZGVycy5cclxuICAgICAqIEBwYXJhbSBoYWxmV2lkdGggVGhpY2tuZXNzIG9mIHRoZSBwb2x5bGluZS5cclxuICAgICAqIEBwYXJhbSBwYXR0ZXJXaWR0aCBXaWR0aCBvZiB0aGUgaW1hZ2UgdGhhdCBpcyByZXBlYXRlZCBhbG9uZyB0aGUgcG9seWxpbmUuXHJcbiAgICAgKiBAcGFyYW0gcGF0dGVybkhhbGZIZWlnaHQgSW1hZ2UgaGFsZiBoZWlnaHQgbXVsdGlwbGllZCBieSBgc2lnbihzKWAsIHdoZXJlIGBzYCBpcyBhIFstMTsgMV0gZGlzdGFuY2UgdG8gdGhlXHJcbiAgICAgKiBhbmFseXRpY2FsIHBvbHlsaW5lIGFsb25nIHNlZ21lbnQncyBub3JtYWwuXHJcbiAgICAgKiBAcGFyYW0gbGVuZ3RoIExlbmd0aCBvZiB0aGUgcG9seWxpbmUgZm9yIGN1cnJlbnQgdmVydGV4LCBuZWVkZWQgdG8gY29ycmVjdGx5IGNhbGN1bGF0ZSBpbWFnZSB1diB4IGNvb3JkaW5hdGUuXHJcbiAgICAgKiBAcGFyYW0gdXYgVVYgY29vcmRpbmF0ZXMgb2YgdGhlIGltYWdlLlxyXG4gICAgICogQHBhcmFtIHpJbmRleCBaLWluZGV4IG9mIHRoZSBwb2x5bGluZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIEluZGV4IG9mIHRoZSB3cml0dGVuIHZlcnRleC5cclxuICAgICAqL1xyXG4gICAgd3JpdGVWZXJ0ZXgocG9zaXRpb24sIGRpc3BsYWNlbWVudCwgaGFsZldpZHRoLCBwYXR0ZXJuV2lkdGgsIHBhdHRlcm5IYWxmSGVpZ2h0LCBsZW5ndGgsIHV2LCB6SW5kZXgpIHtcclxuICAgICAgICBjb25zdCB2ZXJ0ZXhJZHggPSB0aGlzLmdldEN1cnJlbnRWZXJ0ZXhJZHgoKTtcclxuICAgICAgICB0aGlzLl93cml0ZVdvcmxkQ29vcmRpbmF0ZShwb3NpdGlvbik7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVGbG9hdDMyKGRpc3BsYWNlbWVudC54KTtcclxuICAgICAgICB0aGlzLl93cml0ZUZsb2F0MzIoZGlzcGxhY2VtZW50LnkpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlSGFsZldvcmRzKHV2LngsIHV2LnkpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlRmxvYXQzMih6SW5kZXgpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlRmxvYXQzMihoYWxmV2lkdGgpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlSGFsZldvcmRzKHBhdHRlcm5XaWR0aCwgbGVuZ3RoKTtcclxuICAgICAgICB0aGlzLl93cml0ZUZsb2F0MzIocGF0dGVybkhhbGZIZWlnaHQpO1xyXG4gICAgICAgIHJldHVybiB2ZXJ0ZXhJZHg7XHJcbiAgICB9XHJcbn1cclxuLyoqIERlc2NyaXB0aW9uIG9mIGhvdyBhIHdyaXRlciBzdG9yZXMgdmVydGV4IGRhdGEuICovXHJcblRleHR1cmVkUG9seWxpbmVCdWZmZXJXcml0ZXIuQVRUUklCVVRFX01BUFBJTkcgPSBuZXcgQXR0cmlidXRlTWFwcGluZyhbXHJcbiAgICBbXHJcbiAgICAgICAgMCAvKiBQT1NJVElPTl9ISUdIICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMixcclxuICAgICAgICAgICAgdHlwZTogNTEyMyAvKiBVTlNJR05FRF9TSE9SVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgMSAvKiBQT1NJVElPTl9MT1cgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIzIC8qIFVOU0lHTkVEX1NIT1JUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICA2IC8qIERJU1BMQUNFTUVOVCAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDIsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjYgLyogRkxPQVQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICA0IC8qIFVWICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMixcclxuICAgICAgICAgICAgdHlwZTogNTEyMyAvKiBVTlNJR05FRF9TSE9SVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDkgLyogUFJJT1JJVFkgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAxLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTI2IC8qIEZMT0FUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgMTEgLyogQVVYICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMSxcclxuICAgICAgICAgICAgdHlwZTogNTEyNiAvKiBGTE9BVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDEyIC8qIEFVWDEgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIzIC8qIFVOU0lHTkVEX1NIT1JUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgMTMgLyogQVVYMiAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDEsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjYgLyogRkxPQVQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgXVxyXG5dKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL3BvbHlsaW5lL3RleHR1cmVkX3BvbHlsaW5lX2J1ZmZlcl93cml0ZXIudHNcbi8vIG1vZHVsZSBpZCA9IDgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAqIGFzIHZlYzIgZnJvbSAnLi4vLi4vbWF0aC92ZWN0b3IyJztcclxuLyoqXHJcbiAqIFdyaXRlcyBwb2x5bGluZSBpbWFnZSBnZW9tZXRyeSAoc2V0IG9mIHRyaWFuZ2xlcyB0aGF0IGRyYXcgdXAgYSBzb2xpZCB0aGljayBwb2x5bGluZSkgaW50byBhIGJ1ZmZlciB3cml0ZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB3cml0ZXIgT3V0cHV0IGJ1ZmZlciB3cml0ZXIuXHJcbiAqIEBwYXJhbSBwb2x5bGluZSBQb2x5bGluZSB0byBiZSB3cml0dGVuLlxyXG4gKiBAcGFyYW0gd29ybGRUb1B4RmFjdG9yIFJhdGlvIG9mIHdvcmxkIGNvb3JkaW5hdGVzIHRvIHBpeGVscy5cclxuICogQHBhcmFtIGltYWdlTG9jYXRpb24gSW1hZ2UgbG9jYXRpb24gaW4gYXRsYXMuXHJcbiAqIEBwYXJhbSB3aWR0aCBUaGlja25lc3Mgb2YgdGhlIHBvbHlsaW5lLlxyXG4gKiBAcGFyYW0geiBaLWluZGV4IG9mIHRoZSBwb2x5bGluZS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHdyaXRlVGV4dHVyZWRQb2x5bGluZUdlb21ldHJ5KHdyaXRlciwgcG9seWxpbmUsIHdvcmxkVG9QeEZhY3RvciwgaW1hZ2VMb2NhdGlvbiwgd2lkdGgsIHopIHtcclxuICAgIGNvbnN0IGhXaWR0aCA9IHdpZHRoIC8gMjtcclxuICAgIGNvbnN0IHBhdHRlcm5XaWR0aCA9IGltYWdlTG9jYXRpb24ubWF4WCAtIGltYWdlTG9jYXRpb24ubWluWDtcclxuICAgIGNvbnN0IHBhdHRlcm5IYWxmSGVpZ2h0ID0gKGltYWdlTG9jYXRpb24ubWF4WSAtIGltYWdlTG9jYXRpb24ubWluWSkgLyAyO1xyXG4gICAgY29uc3Qgc2VnbWVudCA9IHZlYzIuY3JlYXRlKDAsIDApO1xyXG4gICAgY29uc3QgZGlyID0gdmVjMi5jcmVhdGUoMCwgMCk7XHJcbiAgICBjb25zdCBwcmV2RGlyID0gdmVjMi5jcmVhdGUoMCwgMCk7XHJcbiAgICBjb25zdCBub3JtID0gdmVjMi5jcmVhdGUoMCwgMCk7XHJcbiAgICBjb25zdCBub3JtSW52ID0gdmVjMi5jcmVhdGUoMCwgMCk7XHJcbiAgICBjb25zdCB1diA9IHZlYzIuY3JlYXRlKGltYWdlTG9jYXRpb24ubWluWCwgMCk7XHJcbiAgICBsZXQgcHJldkJvdHRvbVJpZ2h0ID0gLTE7XHJcbiAgICBsZXQgcHJldlRvcFJpZ2h0ID0gLTE7XHJcbiAgICBsZXQgbGVuZ3RoID0gMDtcclxuICAgIGxldCBwcmV2TGVuZ3RoID0gMDtcclxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcG9seWxpbmUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2ZWMyLnN1Yihwb2x5bGluZVtpXSwgcG9seWxpbmVbaSAtIDFdLCBzZWdtZW50KTtcclxuICAgICAgICB2ZWMyLm5vcm1hbGl6ZShzZWdtZW50LCBkaXIpO1xyXG4gICAgICAgIHZlYzIucm90YXRlOTAoZGlyLCBub3JtKTtcclxuICAgICAgICB2ZWMyLm11bG4obm9ybSwgLTEsIG5vcm1JbnYpO1xyXG4gICAgICAgIC8vIHNlZ21lbnQgaXMgd3JpdHRlbiBhcyBhIHJlY3RhbmdsZSAodHdvIHRyaWFuZ2xlcylcclxuICAgICAgICB1di55ID0gaW1hZ2VMb2NhdGlvbi5taW5ZO1xyXG4gICAgICAgIGNvbnN0IHRvcExlZnQgPSB3cml0ZXIud3JpdGVWZXJ0ZXgocG9seWxpbmVbaSAtIDFdLCBub3JtLCBoV2lkdGgsIHBhdHRlcm5XaWR0aCwgcGF0dGVybkhhbGZIZWlnaHQsIGxlbmd0aCwgdXYsIHopO1xyXG4gICAgICAgIHV2LnkgPSBpbWFnZUxvY2F0aW9uLm1heFk7XHJcbiAgICAgICAgY29uc3QgYm90dG9tTGVmdCA9IHdyaXRlci53cml0ZVZlcnRleChwb2x5bGluZVtpIC0gMV0sIG5vcm1JbnYsIGhXaWR0aCwgcGF0dGVybldpZHRoLCAtcGF0dGVybkhhbGZIZWlnaHQsIGxlbmd0aCwgdXYsIHopO1xyXG4gICAgICAgIC8vIHVwZGF0ZSBsZW5ndGggb2YgdGhlIHBvbHlsaW5lIGluIHBpeGVsc1xyXG4gICAgICAgIGxlbmd0aCArPSB2ZWMyLmxlbmd0aChzZWdtZW50KSAvIHdvcmxkVG9QeEZhY3RvcjtcclxuICAgICAgICB1di55ID0gaW1hZ2VMb2NhdGlvbi5taW5ZO1xyXG4gICAgICAgIGNvbnN0IHRvcFJpZ2h0ID0gd3JpdGVyLndyaXRlVmVydGV4KHBvbHlsaW5lW2ldLCBub3JtLCBoV2lkdGgsIHBhdHRlcm5XaWR0aCwgcGF0dGVybkhhbGZIZWlnaHQsIGxlbmd0aCwgdXYsIHopO1xyXG4gICAgICAgIHV2LnkgPSBpbWFnZUxvY2F0aW9uLm1heFk7XHJcbiAgICAgICAgY29uc3QgYm90dG9tUmlnaHQgPSB3cml0ZXIud3JpdGVWZXJ0ZXgocG9seWxpbmVbaV0sIG5vcm1JbnYsIGhXaWR0aCwgcGF0dGVybldpZHRoLCAtcGF0dGVybkhhbGZIZWlnaHQsIGxlbmd0aCwgdXYsIHopO1xyXG4gICAgICAgIC8vIHdyaXRlIGxpbmUgam9pbiB0aGF0IGZpbGxzIGFuIGVtcHR5IHNwYWNlIG9uIGNvcm5lcnNcclxuICAgICAgICBpZiAoMSA8IGkgJiYgaSA8IHBvbHlsaW5lLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB1di55ID0gKGltYWdlTG9jYXRpb24ubWF4WSArIGltYWdlTG9jYXRpb24ubWluWSkgLyAyO1xyXG4gICAgICAgICAgICBjb25zdCBqb2luUG9pbnRJbmRleCA9IHdyaXRlci53cml0ZVZlcnRleChwb2x5bGluZVtpIC0gMV0sIHZlYzIuWkVSTywgaFdpZHRoLCBwYXR0ZXJuV2lkdGgsIDAsIHByZXZMZW5ndGgsIHV2LCB6KTtcclxuICAgICAgICAgICAgLy8gZmluZCBvdXQgd2hlcmUgdGhlIGZyYWN0dXJlIG9mIHNlZ21lbnRzIGlzIGxvY2F0ZWQgdG8gY3JlYXRlIGNvcnJlY3Qgam9pbiB3aXRoIG1pbmltdW0gb3ZlcmRyYXdcclxuICAgICAgICAgICAgY29uc3QgdHVybkxlZnQgPSB2ZWMyLmNyb3NzWihwcmV2RGlyLCBkaXIpID4gMDtcclxuICAgICAgICAgICAgaWYgKHR1cm5MZWZ0KSB7XHJcbiAgICAgICAgICAgICAgICB3cml0ZXIud3JpdGVJbmRpY2VzKFtcclxuICAgICAgICAgICAgICAgICAgICBqb2luUG9pbnRJbmRleCwgYm90dG9tTGVmdCwgcHJldkJvdHRvbVJpZ2h0XHJcbiAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHdyaXRlci53cml0ZUluZGljZXMoW1xyXG4gICAgICAgICAgICAgICAgICAgIGpvaW5Qb2ludEluZGV4LCBwcmV2VG9wUmlnaHQsIHRvcExlZnRcclxuICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdyaXRlci53cml0ZUluZGljZXMoW1xyXG4gICAgICAgICAgICB0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tTGVmdCxcclxuICAgICAgICAgICAgdG9wUmlnaHQsIGJvdHRvbVJpZ2h0LCBib3R0b21MZWZ0XHJcbiAgICAgICAgXSk7XHJcbiAgICAgICAgdmVjMi5jb3B5KGRpciwgcHJldkRpcik7XHJcbiAgICAgICAgcHJldkJvdHRvbVJpZ2h0ID0gYm90dG9tUmlnaHQ7XHJcbiAgICAgICAgcHJldlRvcFJpZ2h0ID0gdG9wUmlnaHQ7XHJcbiAgICAgICAgcHJldkxlbmd0aCA9IGxlbmd0aDtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9wcmltaXRpdmUvcG9seWxpbmUvdGV4dHVyZWRfcG9seWxpbmVfZ2VvbWV0cnkudHNcbi8vIG1vZHVsZSBpZCA9IDgxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiBNYW5hZ2VzIGFsbG9jYXRpb24gb2YgcmVxdWVzdGVkIGltYWdlcy4gVGhlIHNhbWUgaW1hZ2VzIGNhbiBiZSByZXF1ZXN0ZWQgbXVsdGlwbGUgdGltZXMgZnJvbSBkaWZmZXJlbnQgcGxhY2VzLFxyXG4gKiB0aGlzIGNsYXNzIHRha2VzIG92ZXIgZHVwbGljYXRpb24gb2YgSFRUUCByZXF1ZXN0cy9hdGxhcyBhbGxvY2F0aW9ucyBwcm92aWRpbmcgc2ltcGxlIGFzeW5jIGludGVyZmFjZSBmb3JcclxuICogZ2V0dGluZyBhbGxvY2F0ZWQgaW1hZ2VzLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEltYWdlTWFuYWdlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihhdGxhcywgcHJvdmlkZXIpIHtcclxuICAgICAgICB0aGlzLl9hdGxhcyA9IGF0bGFzO1xyXG4gICAgICAgIHRoaXMuX3Byb3ZpZGVyID0gcHJvdmlkZXI7XHJcbiAgICAgICAgdGhpcy5fcmVxdWVzdHMgPSBuZXcgTWFwKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgaW1hZ2UgaWYgaXQgaXMgYWxyZWFkeSBhbGxvY2F0ZWQuIFBheSBhdHRlbnRpb24gdGhhdCByZXN1bHRlZCBhbGxvY2F0ZWQgaW1hZ2UgaXMgXCJyZXRhaW5lZFwiLFxyXG4gICAgICogc28gaXQgbXVzdCBiZSByZWxlYXNlZCBvbmNlIGl0IGlzIHBhc3NlZCB0byBhIHJlc3BvbnNpYmxlIGNsaWVudC5cclxuICAgICAqL1xyXG4gICAgZ2V0SW1hZ2UoaWQpIHtcclxuICAgICAgICBjb25zdCBpbWFnZSA9IHRoaXMuX2F0bGFzLmdldEltYWdlKGlkLCB0cnVlKTtcclxuICAgICAgICBpZiAoaW1hZ2UpIHtcclxuICAgICAgICAgICAgaW1hZ2UucmV0YWluKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpbWFnZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVxdWVzdCBpbWFnZSBmcm9tIGltYWdlIHByb3ZpZGVyLCBpZiBpdCBpcyBhbHJlYWR5IGFsbG9jYXRlZCBubyByZXF1ZXN0IGlzIG1hZGUsIGJ1dCBpdCBpcyByZXR1cm5lZFxyXG4gICAgICogd3JhcHBlZCBpbnRvIGEgcmVzb2x2ZWQgcHJvbWlzZS4gUGF5IGF0dGVudGlvbiB0aGF0IHJlc3VsdGVkIGFsbG9jYXRlZCBpbWFnZSBpcyBcInJldGFpbmVkXCIsIHNvIGl0IG11c3QgYmVcclxuICAgICAqIHJlbGVhc2VkIG9uY2UgaXQgaXMgcGFzc2VkIHRvIGEgcmVzcG9uc2libGUgY2xpZW50LlxyXG4gICAgICovXHJcbiAgICByZXF1ZXN0SW1hZ2UoaWQpIHtcclxuICAgICAgICBjb25zdCBhbGxvY2F0ZWRJbWFnZSA9IHRoaXMuX2F0bGFzLmdldEltYWdlKGlkLCB0cnVlKTtcclxuICAgICAgICBpZiAoYWxsb2NhdGVkSW1hZ2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShhbGxvY2F0ZWRJbWFnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5fcmVxdWVzdHMuZ2V0KGlkKTtcclxuICAgICAgICAgICAgaWYgKHJlcXVlc3QpIHtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3QudGhlbigoYWxsb2NhdGVkSW1hZ2UpID0+IGFsbG9jYXRlZEltYWdlICYmIGFsbG9jYXRlZEltYWdlLnJldGFpbigpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXF1ZXN0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuX3Byb3ZpZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgLmdldEltYWdlKGlkKVxyXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKChpbWFnZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RzLmRlbGV0ZShpZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBpbWFnZTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbGxvY2F0ZWRJbWFnZSA9IHRoaXMuX2F0bGFzLmFsbG9jYXRlSW1hZ2UoeyBpZCwgd2lkdGgsIGhlaWdodCB9LCBpbWFnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhbGxvY2F0ZWRJbWFnZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkblxcJyBhbGxvY2F0ZWQgaW1hZ2UnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhbGxvY2F0ZWRJbWFnZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVxdWVzdHMuZGVsZXRlKGlkKTtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIHJlcXVlc3QgZmFpbGVkJyk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RzLnNldChpZCwgcmVxdWVzdCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxdWVzdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9iaWxsYm9hcmQvaW1hZ2VfbWFuYWdlci50c1xuLy8gbW9kdWxlIGlkID0gODJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IEJ1ZmZlclJld3JpdGVyIGZyb20gJy4uLy4uL3V0aWwvYnVmZmVyX3Jld3JpdGVyJztcclxuaW1wb3J0IHsgVEVYVFVSRURfUE9MWUdPTl9BVFRSSUJVVEVfTUFQUElORyB9IGZyb20gJy4vdGV4dHVyZWRfcG9seWdvbl9hdHRyaWJ1dGVfbWFwcGluZyc7XHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRleHR1cmVkUG9seWdvbkJ1ZmZlclJld3JpdGVyIGV4dGVuZHMgQnVmZmVyUmV3cml0ZXIge1xyXG4gICAgY29uc3RydWN0b3IoYnVmZmVycykge1xyXG4gICAgICAgIHN1cGVyKFRFWFRVUkVEX1BPTFlHT05fQVRUUklCVVRFX01BUFBJTkcsIGJ1ZmZlcnMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gbG9jYXRpb24gTG9jYXRpb24gb2YgdGhlIHBvbHlnb24gaW4gbWVtb3J5LlxyXG4gICAgICogQHBhcmFtIGltYWdlTG9jYXRpb24gTG9jYXRpb24gb2YgdGhlIHBhdHRlcm4gaW4gYXRsYXMuXHJcbiAgICAgKiBAcGFyYW0gaW1hZ2VTY2FsZSBIb3cgd29ybGQgY29vcmRpbmF0ZXMgcmVsYXRlIHRvIHRoZSBpbWFnZSBzaXplLlxyXG4gICAgICovXHJcbiAgICByZXdyaXRlVVYobG9jYXRpb24sIGltYWdlTG9jYXRpb24sIGltYWdlU2NhbGUpIHtcclxuICAgICAgICBjb25zdCB1dk9mZnNldCA9IHRoaXMuX2dldEF0dHJpYk9mZnNldCg0IC8qIFVWICovKTtcclxuICAgICAgICBjb25zdCBzY2FsZU9mZnNldCA9IHRoaXMuX2dldEF0dHJpYk9mZnNldCgxMSAvKiBBVVggKi8pO1xyXG4gICAgICAgIHRoaXMuX2ZvckVhY2hWZXJ0ZXgobG9jYXRpb24sICh3cml0ZXIpID0+IHtcclxuICAgICAgICAgICAgd3JpdGVyLndyaXRlSGFsZldvcmRzKHV2T2Zmc2V0LCBpbWFnZUxvY2F0aW9uLm1pblgsIGltYWdlTG9jYXRpb24ubWluWSk7XHJcbiAgICAgICAgICAgIHdyaXRlci53cml0ZUhhbGZXb3Jkcyh1dk9mZnNldCArIDEsIGltYWdlTG9jYXRpb24ubWF4WCAtIGltYWdlTG9jYXRpb24ubWluWCwgaW1hZ2VMb2NhdGlvbi5tYXhZIC0gaW1hZ2VMb2NhdGlvbi5taW5ZKTtcclxuICAgICAgICAgICAgd3JpdGVyLndyaXRlRmxvYXQzMihzY2FsZU9mZnNldCwgaW1hZ2VTY2FsZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL3BvbHlnb24vdGV4dHVyZWRfcG9seWdvbl9idWZmZXJfcmV3aXRlci50c1xuLy8gbW9kdWxlIGlkID0gODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgV09SRF9CWVRFX1NJWkUgfSBmcm9tICcuL2J1ZmZlcl93cml0ZXInO1xyXG4vKipcclxuICogQ2xhc3MgdGhhdCBpcyBleHBvc2VkIGFzIGFuIGludGVyZmFjZSBmb3Igd3JpdGluZyB0byBhIHNwZWNpZmljIHZlcnRleCBhdHRyaWJ1dGUuXHJcbiAqL1xyXG5jbGFzcyBWZXJ0ZXhXcml0ZXIge1xyXG4gICAgY29uc3RydWN0b3IodmVydGV4QnVmZmVyKSB7XHJcbiAgICAgICAgdGhpcy5fdmVydGV4QnVmZmVyID0gbmV3IFVpbnQzMkFycmF5KHZlcnRleEJ1ZmZlci5idWZmZXIsIDAsIHZlcnRleEJ1ZmZlci5sZW5ndGgpO1xyXG4gICAgICAgIHRoaXMuX3ZlcnRleEJ1ZmZlckZsb2F0MzJWaWV3ID0gbmV3IEZsb2F0MzJBcnJheSh2ZXJ0ZXhCdWZmZXIuYnVmZmVyLCAwLCB2ZXJ0ZXhCdWZmZXIubGVuZ3RoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGZsb2F0IGF0dHJpYnV0ZSBpbnRvIHNwZWNpZmljIHBvc2l0aW9uIGluIGJ1ZmZlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYXR0cmliT2Zmc2V0IE9mZnNldCBvZiBhbiBhdHRyaWJ1dGUgaW4gd29yZHMgKDQgYnl0ZXMpLCBnZXQgaXQgZnJvbSBCdWZmZXJSZXdyaXRlciNfZ2V0QXR0cmliT2Zmc2V0KCkuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgVmFsdWUgdG8gYmUgd3JpdHRlbi5cclxuICAgICAqL1xyXG4gICAgd3JpdGVGbG9hdDMyKGF0dHJpYk9mZnNldCwgdmFsdWUpIHtcclxuICAgICAgICB0aGlzLl92ZXJ0ZXhCdWZmZXJGbG9hdDMyVmlld1t0aGlzLnZlcnRleE9mZnNldCArIGF0dHJpYk9mZnNldF0gPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGEgd29yZCBhdHRyaWJ1dGUgaW50byBzcGVjaWZpYyBwb3NpdGlvbiBpbiBidWZmZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGF0dHJpYk9mZnNldCBPZmZzZXQgb2YgYW4gYXR0cmlidXRlIGluIHdvcmRzICg0IGJ5dGVzKSwgZ2V0IGl0IGZyb20gQnVmZmVyUmV3cml0ZXIjX2dldEF0dHJpYk9mZnNldCgpLlxyXG4gICAgICogQHBhcmFtIHZhbHVlIFZhbHVlIHRvIGJlIHdyaXR0ZW4uXHJcbiAgICAgKi9cclxuICAgIHdyaXRlV29yZChhdHRyaWJPZmZzZXQsIHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fdmVydGV4QnVmZmVyW3RoaXMudmVydGV4T2Zmc2V0ICsgYXR0cmliT2Zmc2V0XSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgdHdvIGhhbGYgd29yZCBhdHRyaWJ1dGUgdmFsdWVzIGludG8gc3BlY2lmaWMgcG9zaXRpb24gaW4gYnVmZmVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhdHRyaWJPZmZzZXQgT2Zmc2V0IG9mIGFuIGF0dHJpYnV0ZSBpbiB3b3JkcyAoNCBieXRlcyksIGdldCBpdCBmcm9tIEJ1ZmZlclJld3JpdGVyI19nZXRBdHRyaWJPZmZzZXQoKS5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSBWYWx1ZSB0byBiZSB3cml0dGVuLlxyXG4gICAgICovXHJcbiAgICB3cml0ZUhhbGZXb3JkcyhhdHRyaWJPZmZzZXQsIHYxLCB2Mikge1xyXG4gICAgICAgIHRoaXMud3JpdGVXb3JkKGF0dHJpYk9mZnNldCwgdjIgPDwgMTYgfCB2MSAmIDB4ZmZmZik7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFByb3ZpZGVzIHNvbWUgdXRpbHMgZm9yIHJld3JpdGluZyB2ZXJ0ZXggYXR0cmlidXRlIHZhbHVlcywgc2VlIFZlcnRleFdyaXRlciBhbmQgdGVzdHMgZm9yIHNvbWUgdGlwcyBvZiBob3cgdG8gZG8gaXQuXHJcbiAqIFRPRE86IGNvbnNpZGVyIHN1cHBvcnRpbmcgb2Ygc2VwYXJhdGUgYnVmZmVycyBmb3IgZGlmZmVyZW50IGF0dHJpYnV0ZXMsIHRoYXQgd2lsbCBtYWtlIHRoaXMgY2xhc3MgbGVzcyB1c2VmdWxcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJ1ZmZlclJld3JpdGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGF0dHJpYk1hcHBpbmcsIGJ1ZmZlcnMpIHtcclxuICAgICAgICB0aGlzLl9hdHRyaWJNYXBwaW5nID0gYXR0cmliTWFwcGluZztcclxuICAgICAgICB0aGlzLl9idWZmZXJzID0gYnVmZmVycztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogV2Fsa3Mgb3ZlciBhbGwgdmVydGljZXMgZXhwb3NpbmcgVmVydGV4V3JpdGVyIGZvciBlYWNoIG9uZSBieSBjYWxsaW5nIHRoZSBoYW5kbGVyIGFyZ3VtZW50LlxyXG4gICAgICovXHJcbiAgICBfZm9yRWFjaFZlcnRleChsb2NhdGlvbiwgaGFuZGxlcikge1xyXG4gICAgICAgIGNvbnN0IHZlcnRleFdyaXRlciA9IG5ldyBWZXJ0ZXhXcml0ZXIodGhpcy5fYnVmZmVyc1tsb2NhdGlvbi5idWZmZXJJbmRleF0udmVydGV4QnVmZmVyKTtcclxuICAgICAgICBjb25zdCB2ZXJ0ZXhCeXRlU2l6ZSA9IHRoaXMuX2F0dHJpYk1hcHBpbmcudmVydGV4Qnl0ZVNpemU7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NhdGlvbi52ZXJ0ZXhCeXRlTGVuZ3RoOyBpICs9IHZlcnRleEJ5dGVTaXplKSB7XHJcbiAgICAgICAgICAgIHZlcnRleFdyaXRlci52ZXJ0ZXhPZmZzZXQgPSAobG9jYXRpb24udmVydGV4Qnl0ZU9mZnNldCArIGkpIC8gV09SRF9CWVRFX1NJWkU7XHJcbiAgICAgICAgICAgIGhhbmRsZXIodmVydGV4V3JpdGVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIE9mZnNldCBpbiB3b3JkcyAoNCBieXRlcykgb2Ygc3BlY2lmaWMgYXR0cmlidXRlIGluIGEgdmVydGV4IChmb3JtYXQgaXMgZGVmaW5lZCBieSBBdHRyaWJ1dGVNYXBwaW5nKS5cclxuICAgICAqL1xyXG4gICAgX2dldEF0dHJpYk9mZnNldChhdHRyaWIpIHtcclxuICAgICAgICBjb25zdCBhdHRyaWJQb2ludGVyID0gdGhpcy5fYXR0cmliTWFwcGluZy5nZXQoYXR0cmliKTtcclxuICAgICAgICByZXR1cm4gYXR0cmliUG9pbnRlciA/IGF0dHJpYlBvaW50ZXIub2Zmc2V0IC8gV09SRF9CWVRFX1NJWkUgOiAtMTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL2J1ZmZlcl9yZXdyaXRlci50c1xuLy8gbW9kdWxlIGlkID0gODRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgQXR0cmlidXRlTWFwcGluZyB9IGZyb20gJy4uLy4uL3JlbmRlci9hdHRyaWJfbWFwcGluZyc7XHJcbi8qKiBEZXNjcmlwdGlvbiBvZiBob3cgYSB3cml0ZXIgc3RvcmVzIHZlcnRleCBkYXRhLiAqL1xyXG5leHBvcnQgY29uc3QgQklMTEJPQVJEX1JFQ1RBTkdMRV9BVFRSSUJVVEVfTUFQUElORyA9IG5ldyBBdHRyaWJ1dGVNYXBwaW5nKFtcclxuICAgIFtcclxuICAgICAgICAyIC8qIElEICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogNCxcclxuICAgICAgICAgICAgdHlwZTogNTEyMSAvKiBVTlNJR05FRF9CWVRFICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICAwIC8qIFBPU0lUSU9OX0hJR0ggKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIzIC8qIFVOU0lHTkVEX1NIT1JUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICAxIC8qIFBPU0lUSU9OX0xPVyAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDIsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjMgLyogVU5TSUdORURfU0hPUlQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDYgLyogRElTUExBQ0VNRU5UICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMixcclxuICAgICAgICAgICAgdHlwZTogNTEyNiAvKiBGTE9BVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDQgLyogVVYgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIyIC8qIFNIT1JUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICA3IC8qIENPTE9SICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogNCxcclxuICAgICAgICAgICAgdHlwZTogNTEyMSAvKiBVTlNJR05FRF9CWVRFICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICAxMSAvKiBBVVggKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIzIC8qIFVOU0lHTkVEX1NIT1JUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXVxyXG5dKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL2JpbGxib2FyZF9yZWN0YW5nbGUvYXR0cmlidXRlX21hcHBpbmcudHNcbi8vIG1vZHVsZSBpZCA9IDg1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IEF0dHJpYnV0ZU1hcHBpbmcgfSBmcm9tICcuLi8uLi9yZW5kZXIvYXR0cmliX21hcHBpbmcnO1xyXG4vKiogRGVzY3JpcHRpb24gb2YgaG93IGEgd3JpdGVyIHN0b3JlcyB2ZXJ0ZXggZGF0YS4gKi9cclxuZXhwb3J0IGNvbnN0IFBPSU5UX0xBQkVMX0FUVFJJQlVURV9NQVBQSU5HID0gbmV3IEF0dHJpYnV0ZU1hcHBpbmcoW1xyXG4gICAgW1xyXG4gICAgICAgIDIgLyogSUQgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiA0LFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIxIC8qIFVOU0lHTkVEX0JZVEUgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDAgLyogUE9TSVRJT05fSElHSCAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDIsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjMgLyogVU5TSUdORURfU0hPUlQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDEgLyogUE9TSVRJT05fTE9XICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMixcclxuICAgICAgICAgICAgdHlwZTogNTEyMyAvKiBVTlNJR05FRF9TSE9SVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgNiAvKiBESVNQTEFDRU1FTlQgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTI2IC8qIEZMT0FUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgNCAvKiBVViAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDIsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjMgLyogVU5TSUdORURfU0hPUlQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICA3IC8qIENPTE9SICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogNCxcclxuICAgICAgICAgICAgdHlwZTogNTEyMSAvKiBVTlNJR05FRF9CWVRFICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICA4IC8qIE9VVExJTkVfQ09MT1IgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiA0LFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIxIC8qIFVOU0lHTkVEX0JZVEUgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDkgLyogUFJJT1JJVFkgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAxLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTI2IC8qIEZMT0FUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgMTEgLyogQVVYICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMSxcclxuICAgICAgICAgICAgdHlwZTogNTEyNiAvKiBGTE9BVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICBdXHJcbl0pO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9wcmltaXRpdmUvbGFiZWwvcG9pbnRfbGFiZWxfYXR0cmlidXRlX21hcHBpbmcudHNcbi8vIG1vZHVsZSBpZCA9IDg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IEF0dHJpYnV0ZU1hcHBpbmcgfSBmcm9tICcuLi8uLi9yZW5kZXIvYXR0cmliX21hcHBpbmcnO1xyXG4vKiogRGVzY3JpcHRpb24gb2YgaG93IGEgd3JpdGVyIHN0b3JlcyB2ZXJ0ZXggZGF0YS4gKi9cclxuZXhwb3J0IGNvbnN0IENVUlZFRF9MQUJFTF9BVFRSSUJVVEVfTUFQUElORyA9IG5ldyBBdHRyaWJ1dGVNYXBwaW5nKFtcclxuICAgIFtcclxuICAgICAgICAyIC8qIElEICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogNCxcclxuICAgICAgICAgICAgdHlwZTogNTEyMSAvKiBVTlNJR05FRF9CWVRFICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICAwIC8qIFBPU0lUSU9OX0hJR0ggKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIzIC8qIFVOU0lHTkVEX1NIT1JUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICAxIC8qIFBPU0lUSU9OX0xPVyAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDIsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjMgLyogVU5TSUdORURfU0hPUlQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDYgLyogRElTUExBQ0VNRU5UICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMyxcclxuICAgICAgICAgICAgdHlwZTogNTEyNiAvKiBGTE9BVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDQgLyogVVYgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIzIC8qIFVOU0lHTkVEX1NIT1JUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgNyAvKiBDT0xPUiAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDQsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjEgLyogVU5TSUdORURfQllURSAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgOCAvKiBPVVRMSU5FX0NPTE9SICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogNCxcclxuICAgICAgICAgICAgdHlwZTogNTEyMSAvKiBVTlNJR05FRF9CWVRFICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICA5IC8qIFBSSU9SSVRZICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMSxcclxuICAgICAgICAgICAgdHlwZTogNTEyNiAvKiBGTE9BVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDEyIC8qIEFVWDEgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiA0LFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIxIC8qIFVOU0lHTkVEX0JZVEUgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDEzIC8qIEFVWDIgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiA0LFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIzIC8qIFVOU0lHTkVEX1NIT1JUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICAxNCAvKiBBVVgzICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogNCxcclxuICAgICAgICAgICAgdHlwZTogNTEyMSAvKiBVTlNJR05FRF9CWVRFICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICAxNSAvKiBBVVg0ICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogNCxcclxuICAgICAgICAgICAgdHlwZTogNTEyMyAvKiBVTlNJR05FRF9TSE9SVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgMTEgLyogQVVYICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMixcclxuICAgICAgICAgICAgdHlwZTogNTEyNiAvKiBGTE9BVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICBdXHJcbl0pO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9wcmltaXRpdmUvbGFiZWwvY3VydmVkX2xhYmVsX2F0dHJpYnV0ZV9tYXBwaW5nLnRzXG4vLyBtb2R1bGUgaWQgPSA4N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBXZWJXb3JrZXJDbGllbnQgfSBmcm9tICcuLi8uLi8uLi91dGlsL3dvcmtlcic7XHJcbmV4cG9ydCBjbGFzcyBUaWxlUHJvdmlkZXJXb3JrZXJDbGllbnQgZXh0ZW5kcyBXZWJXb3JrZXJDbGllbnQge1xyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2FkYXB0ZXJzL3ZlY3Rvcl9hcGkvd29ya2VyL3RpbGVfcHJvdmlkZXJfd29ya2VyX2NsaWVudC50c1xuLy8gbW9kdWxlIGlkID0gODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIEV4dHJhY3QgQXJyYXlCdWZmZXJzICh0aGF0IGFyZSB0YW5zZmVyYWJsZSkgZnJvbSBwYWdlcy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0VHJhbnNmZXJhYmxlcyhwYWdlcywgb3V0cHV0KSB7XHJcbiAgICBmb3IgKGNvbnN0IHBhZ2Ugb2YgcGFnZXMpIHtcclxuICAgICAgICBvdXRwdXQucHVzaChwYWdlLnZlcnRleEJ1ZmZlci5idWZmZXIsIHBhZ2UuaW5kZXhCdWZmZXIuYnVmZmVyKTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9hZGFwdGVycy92ZWN0b3JfYXBpL3dvcmtlci9wcmltaXRpdmVfcHJvdmlkZXJfd29ya2VyX21lc3NhZ2VzLnRzXG4vLyBtb2R1bGUgaWQgPSA4OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBBdHRyaWJ1dGVNYXBwaW5nIH0gZnJvbSAnLi4vLi4vcmVuZGVyL2F0dHJpYl9tYXBwaW5nJztcclxuaW1wb3J0IHsgUE9MWUdPTl9BVFRSSUJVVEVfTUFQUElORyB9IGZyb20gJy4vcG9seWdvbl9hdHRyaWJ1dGVfbWFwcGluZyc7XHJcbi8qKlxyXG4gKiBEZXNjcmlwdGlvbiBvZiBob3cgYXR0cmlidXRlcyBvZiB2ZXJ0aWNlcyBhcmUgcGFja2VkIGludG8gYSB2ZXJ0ZXggYnVmZmVyLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IFRSQU5TUEFSRU5UX1BPTFlHT05fQVRUUklCVVRFX01BUFBJTkcgPSBuZXcgQXR0cmlidXRlTWFwcGluZyhQT0xZR09OX0FUVFJJQlVURV9NQVBQSU5HKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL3BvbHlnb24vdHJhbnNwYXJlbnRfcG9seWdvbl9hdHRyaWJ1dGVfbWFwcGluZy50c1xuLy8gbW9kdWxlIGlkID0gOTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IFByaW9yaXR5UXVldWUgZnJvbSAnLi9wcmlvcml0eV9xdWV1ZSc7XHJcbmNvbnN0IE1BWF9ERVFVRVVFX1RJTUVPVVQgPSAxMDAwOyAvLyBtc1xyXG4vLyBUT0RPOiByZW1vdmUgdGhpcyBzaGltIHdoZW4gYWxsIHN1cHBvcnRlZCBicm93c2VycyBpbXBsZW1lbnQgaXRcclxuY29uc3QgU0hJTU1FRF9QUk9DRVNTSU5HX0RVUkFUSU9OX01TID0gMjU7XHJcbndpbmRvdy5jYW5jZWxJZGxlQ2FsbGJhY2sgPSB3aW5kb3cuY2FuY2VsSWRsZUNhbGxiYWNrIHx8IHdpbmRvdy5jbGVhclRpbWVvdXQ7XHJcbndpbmRvdy5yZXF1ZXN0SWRsZUNhbGxiYWNrID0gd2luZG93LnJlcXVlc3RJZGxlQ2FsbGJhY2sgfHwgZnVuY3Rpb24gKGhhbmRsZXIpIHtcclxuICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgcmV0dXJuIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgIGhhbmRsZXIoe1xyXG4gICAgICAgICAgICBkaWRUaW1lb3V0OiBmYWxzZSxcclxuICAgICAgICAgICAgdGltZVJlbWFpbmluZzogKCkgPT4gTWF0aC5tYXgoMCwgU0hJTU1FRF9QUk9DRVNTSU5HX0RVUkFUSU9OX01TIC0gKHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRUaW1lKSlcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59O1xyXG4vKipcclxuICogSXQgaXMgYSB0YXNrIHF1ZXVlLiBUYXNrcyBhcmUgZGVxdWV1ZWQgZHVyaW5nIGlkbGUgcGVyaW9kLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSWRsZVRhc2tRdWV1ZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLl9xdWV1ZSA9IG5ldyBQcmlvcml0eVF1ZXVlKCk7XHJcbiAgICAgICAgdGhpcy5fZGVxdWV1ZUlkbGVIYW5kbGUgPSAwO1xyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICBjYW5jZWxJZGxlQ2FsbGJhY2sodGhpcy5fZGVxdWV1ZUlkbGVIYW5kbGUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFbnF1ZXVlcyBhIHRhc2sgdG8gdGhlIHF1ZXVlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0YXNrIFRoZSB0YXNrLlxyXG4gICAgICovXHJcbiAgICBlbnF1ZXVlKHRhc2spIHtcclxuICAgICAgICB0aGlzLl9xdWV1ZS5lbnF1ZXVlKHRhc2spO1xyXG4gICAgICAgIHRoaXMuX3J1bigpO1xyXG4gICAgfVxyXG4gICAgX2RlcXVldWUoZGVhZGxpbmUpIHtcclxuICAgICAgICBjb25zdCBxdWV1ZSA9IHRoaXMuX3F1ZXVlO1xyXG4gICAgICAgIGlmIChxdWV1ZS5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGVhZGxpbmUuZGlkVGltZW91dCkge1xyXG4gICAgICAgICAgICBxdWV1ZS5kZXF1ZXVlKCkuZXhlY3V0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgd2hpbGUgKGRlYWRsaW5lLnRpbWVSZW1haW5pbmcoKSAmJiAhcXVldWUuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICBxdWV1ZS5kZXF1ZXVlKCkuZXhlY3V0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2RlcXVldWVJZGxlSGFuZGxlID0gMDtcclxuICAgICAgICBpZiAoIXRoaXMuX3F1ZXVlLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9ydW4oKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfcnVuKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fZGVxdWV1ZUlkbGVIYW5kbGUpIHtcclxuICAgICAgICAgICAgdGhpcy5fZGVxdWV1ZUlkbGVIYW5kbGUgPSByZXF1ZXN0SWRsZUNhbGxiYWNrKChkZWFkbGluZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGVxdWV1ZShkZWFkbGluZSk7XHJcbiAgICAgICAgICAgIH0sIHsgdGltZW91dDogTUFYX0RFUVVFVUVfVElNRU9VVCB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9pZGxlX3Rhc2tfcXVldWUudHNcbi8vIG1vZHVsZSBpZCA9IDkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IHN3YXAgfSBmcm9tICcuL2FycmF5JztcclxuaW1wb3J0IHsgREVGQVVMVF9DT01QQVJBVE9SIH0gZnJvbSAnLi9jb21wYXJhdG9yJztcclxuLyoqXHJcbiAqIENvbXB1dGVzIGluZGV4IG9mIHRoZSBwYXJlbnQgb2YgYW4gaXRlbS5cclxuICpcclxuICogQHBhcmFtIGlkeCBJbmRleCBvZiB0aGUgaXRlbS5cclxuICogQHJldHVybnMgSW5kZXggb2YgdGhlIHBhcmVudC5cclxuICovXHJcbmZ1bmN0aW9uIGdldFBhcmVudElkeChpZHgpIHtcclxuICAgIHJldHVybiAoaWR4ICsgMSA+PiAxKSAtIDE7XHJcbn1cclxuLyoqXHJcbiAqIENvbXB1dGVzIGluZGV4IG9mIHRoZSBsZWZ0IGNoaWxkIG9mIGFuIGl0ZW0uXHJcbiAqXHJcbiAqIEBwYXJhbSBpZHggSW5kZXggb2YgdGhlIGl0ZW0uXHJcbiAqIEByZXR1cm5zIEluZGV4IG9mIHRoZSBjaGlsZC5cclxuICovXHJcbmZ1bmN0aW9uIGdldEZpcnN0Q2hpbGRJZHgoaWR4KSB7XHJcbiAgICByZXR1cm4gKGlkeCArIDEgPDwgMSkgLSAxO1xyXG59XHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJpbmFyeUhlYXAge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGVtcHR5IGhlYXAuIE9yZGVyIG9mIGl0ZW1zIGluIHRoZSBoZWFwIHdpbGwgYmUgZGVmaW5lZFxyXG4gICAgICogYnkgYSBnaXZlbiBjb21wYXJhdG9yLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb21wYXJhdG9yIFRoZSBjb21wYXJhdG9yLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihjb21wYXJhdG9yID0gREVGQVVMVF9DT01QQVJBVE9SKSB7XHJcbiAgICAgICAgLy8gVE9ETyhkbWlraXMpIEludmVzdGlnYXRlIHByZWFsbG9jYXRpb24uXHJcbiAgICAgICAgdGhpcy5faXRlbXMgPSBbXTtcclxuICAgICAgICB0aGlzLl9jb21wYXJhdG9yID0gY29tcGFyYXRvcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSW5zZXJ0cyBhbiBpdGVtIGludG8gdGhlIGhlYXAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGl0ZW0gVGhlIGl0ZW0gdG8gYmUgaW5zZXJ0ZWQuXHJcbiAgICAgKi9cclxuICAgIGluc2VydChpdGVtKSB7XHJcbiAgICAgICAgY29uc3QgaXRlbXMgPSB0aGlzLl9pdGVtcztcclxuICAgICAgICBjb25zdCBjb21wYXJhdG9yID0gdGhpcy5fY29tcGFyYXRvcjtcclxuICAgICAgICAvLyBJbnNlcnQgdGhlIG5ldyBpdGVtIGFzIGJvdHRvbSByaWdodC1tb3N0IGNoaWxkIG9mIHRoZSBoZWFwLlxyXG4gICAgICAgIGxldCBpZHggPSBpdGVtcy5wdXNoKGl0ZW0pIC0gMTtcclxuICAgICAgICBsZXQgcGFyZW50SWR4ID0gZ2V0UGFyZW50SWR4KGlkeCk7XHJcbiAgICAgICAgLy8gV2FsayB0aGUgaGVhcCB1cHdhcmQgYW5kIHJlc3RvcmUgaGVhcCBwcm9wZXJ0eSBvbiB0aGUgd2F5LlxyXG4gICAgICAgIHdoaWxlIChwYXJlbnRJZHggPiAtMSAmJlxyXG4gICAgICAgICAgICBjb21wYXJhdG9yKGl0ZW1zW2lkeF0sIGl0ZW1zW3BhcmVudElkeF0pID4gMCkge1xyXG4gICAgICAgICAgICBzd2FwKGl0ZW1zLCBpZHgsIHBhcmVudElkeCk7XHJcbiAgICAgICAgICAgIGlkeCA9IHBhcmVudElkeDtcclxuICAgICAgICAgICAgcGFyZW50SWR4ID0gZ2V0UGFyZW50SWR4KGlkeCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIFwibWF4aW11bVwiIGl0ZW0gZnJvbSB0aGUgaGVhZC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgcmVtb3ZlZCBpdGVtIG9yIGB1bmRlZmluZWRgIGlzIHRoZSBoZWFwJ3MgZW1wdHkuXHJcbiAgICAgKi9cclxuICAgIHBvcCgpIHtcclxuICAgICAgICBjb25zdCBpdGVtcyA9IHRoaXMuX2l0ZW1zO1xyXG4gICAgICAgIGlmIChpdGVtcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbmV3U2l6ZSA9IGl0ZW1zLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgLy8gUGxhY2UgbWF4IGl0ZW0gYXQgdGhlIGVuZCBvZiB0aGUgaXRlbXMgYXJyYXkuXHJcbiAgICAgICAgc3dhcChpdGVtcywgMCwgbmV3U2l6ZSk7XHJcbiAgICAgICAgLy8gV2FsayBkb3dud2FyZCBmcm9tIHRoZSBuZXcgcm9vdCB0byByZXN0b3JlIGhlYXAgcHJvcGVydHkuXHJcbiAgICAgICAgbGV0IGlkeCA9IDA7XHJcbiAgICAgICAgbGV0IGNoaWxkSWR4ID0gMTtcclxuICAgICAgICBjb25zdCBjb21wYXJhdG9yID0gdGhpcy5fY29tcGFyYXRvcjtcclxuICAgICAgICB3aGlsZSAoY2hpbGRJZHggPCBuZXdTaXplKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZElkeCArIDEgPCBuZXdTaXplICYmXHJcbiAgICAgICAgICAgICAgICBjb21wYXJhdG9yKGl0ZW1zW2NoaWxkSWR4XSwgaXRlbXNbY2hpbGRJZHggKyAxXSkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZElkeCArPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjb21wYXJhdG9yKGl0ZW1zW2lkeF0sIGl0ZW1zW2NoaWxkSWR4XSkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzd2FwKGl0ZW1zLCBpZHgsIGNoaWxkSWR4KTtcclxuICAgICAgICAgICAgaWR4ID0gY2hpbGRJZHg7XHJcbiAgICAgICAgICAgIGNoaWxkSWR4ID0gZ2V0Rmlyc3RDaGlsZElkeChjaGlsZElkeCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJlbW92ZSBwcmV2aW91c2x5IHBsYWNlZCBhdCB0aGUgZW5kIHByZXZpb3VzIG1heCBpdGVtLlxyXG4gICAgICAgIHJldHVybiBpdGVtcy5wb3AoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgXCJNYXhpbXVtXCIgaXRlbSBpbiB0aGUgaGVhcCBvciBgdW5kZWZpbmVkYCBpZiB0aGUgaGVhZCBpcyBlbXB0eS5cclxuICAgICAqL1xyXG4gICAgcGVlaygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faXRlbXNbMF07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIEl0ZXJhdG9yIG92ZXIgYWxsIGl0ZW1zIGluIHRoZSBoZWFwLiBOb3RlIHRoYXQgb3JkZXIgb2YgaXRlbXNcclxuICAgICAqICAgICAgaXMgdW5kZWZpbmVkLlxyXG4gICAgICovXHJcbiAgICAqW1N5bWJvbC5pdGVyYXRvcl0oKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuX2l0ZW1zKSB7XHJcbiAgICAgICAgICAgIHlpZWxkIGl0ZW07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBOdW1iZXIgb2YgaXRlbXMgaW4gdGhlIGhlYXAuXHJcbiAgICAgKi9cclxuICAgIGdldCBzaXplKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtcy5sZW5ndGg7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9iaW5hcnlfaGVhcC50c1xuLy8gbW9kdWxlIGlkID0gOTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IFJlbmRlcmFibGVQcmltaXRpdmUgZnJvbSAnLi4vcmVuZGVyYWJsZV9wcmltaXRpdmUnO1xyXG4vKipcclxuICogQWxsb2NhdGVkIGluIEdQVSBtZW1vcnkgcG9seWdvbi5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbmRlcmFibGVQb2x5Z29uIGV4dGVuZHMgUmVuZGVyYWJsZVByaW1pdGl2ZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihtZW1vcnlTdWJDaHVuaywgaXNPcGFxdWUpIHtcclxuICAgICAgICBzdXBlcihtZW1vcnlTdWJDaHVuayk7XHJcbiAgICAgICAgdGhpcy5pc09wYXF1ZSA9IGlzT3BhcXVlO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3ByaW1pdGl2ZS9wb2x5Z29uL3JlbmRlcmFibGVfcG9seWdvbi50c1xuLy8gbW9kdWxlIGlkID0gOTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IFJlbmRlcmFibGVQcmltaXRpdmUgZnJvbSAnLi4vcmVuZGVyYWJsZV9wcmltaXRpdmUnO1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW5kZXJhYmxlVGV4dHVyZWRQb2x5Z29uIGV4dGVuZHMgUmVuZGVyYWJsZVByaW1pdGl2ZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihtZW1vcnlDaHVuaywgYWxsb2NhdGVkSW1hZ2UpIHtcclxuICAgICAgICBzdXBlcihtZW1vcnlDaHVuayk7XHJcbiAgICAgICAgdGhpcy5fYWxsb2NhdGVkSW1hZ2UgPSBhbGxvY2F0ZWRJbWFnZTtcclxuICAgICAgICB0aGlzLmF0bGFzID0gYWxsb2NhdGVkSW1hZ2UuYXRsYXNNYW5hZ2VyLmF0bGFzO1xyXG4gICAgICAgIGFsbG9jYXRlZEltYWdlLnJldGFpbigpO1xyXG4gICAgfVxyXG4gICAgX2Rlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5fYWxsb2NhdGVkSW1hZ2UucmVsZWFzZSgpO1xyXG4gICAgICAgIHN1cGVyLl9kZXN0cm95KCk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL3BvbHlnb24vcmVuZGVyYWJsZV90ZXh0dXJlZF9wb2x5Z29uLnRzXG4vLyBtb2R1bGUgaWQgPSA5NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgUmVuZGVyYWJsZVBvbHlsaW5lIGZyb20gJy4vcmVuZGVyYWJsZV9wb2x5bGluZSc7XHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbmRlcmFibGVUZXh0dXJlZFBvbHlsaW5lIGV4dGVuZHMgUmVuZGVyYWJsZVBvbHlsaW5lIHtcclxuICAgIGNvbnN0cnVjdG9yKG1lbW9yeUNodW5rLCBhbGxvY2F0ZWRJbWFnZSkge1xyXG4gICAgICAgIHN1cGVyKG1lbW9yeUNodW5rKTtcclxuICAgICAgICB0aGlzLl9hbGxvY2F0ZWRJbWFnZSA9IGFsbG9jYXRlZEltYWdlO1xyXG4gICAgICAgIHRoaXMuYXRsYXMgPSBhbGxvY2F0ZWRJbWFnZS5hdGxhc01hbmFnZXIuYXRsYXM7XHJcbiAgICAgICAgYWxsb2NhdGVkSW1hZ2UucmV0YWluKCk7XHJcbiAgICB9XHJcbiAgICBfZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLl9hbGxvY2F0ZWRJbWFnZS5yZWxlYXNlKCk7XHJcbiAgICAgICAgc3VwZXIuX2Rlc3Ryb3koKTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9wcmltaXRpdmUvcG9seWxpbmUvcmVuZGVyYWJsZV90ZXh0dXJlZF9wb2x5bGluZS50c1xuLy8gbW9kdWxlIGlkID0gOTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0IGNvbnN0IFBPTFlHT05fRVhUUkFDVE9SID0gKGRhdGEpID0+IGZsYXQobWFwKCdwb2x5Z29ucycsIGRhdGEpKTtcclxuZXhwb3J0IGNvbnN0IFRFWFRVUkVEX1BPTFlHT05fRVhUUkFDVE9SID0gKGRhdGEpID0+IGZsYXQobWFwKCd0ZXh0dXJlZFBvbHlnb25zJywgZGF0YSkpO1xyXG5leHBvcnQgY29uc3QgUE9MWUxJTkVfRVhUUkFDVE9SID0gKGRhdGEpID0+IGZsYXQobWFwKCdwb2x5bGluZXMnLCBkYXRhKSk7XHJcbmV4cG9ydCBjb25zdCBURVhUVVJFRF9QT0xZTElORV9FWFRSQUNUT1IgPSAoZGF0YSkgPT4gZmxhdChtYXAoJ3RleHR1cmVkUG9seWxpbmVzJywgZGF0YSkpO1xyXG5leHBvcnQgY29uc3QgUE9JTlRfRVhUUkFDVE9SID0gKGRhdGEpID0+IGZsYXQobWFwKCdwb2ludHMnLCBkYXRhKSk7XHJcbmV4cG9ydCBjb25zdCBQT0lOVF9MQUJFTF9FWFRSQUNUT1IgPSAoZGF0YSkgPT4gZmxhdChtYXAoJ3BvaW50TGFiZWxzJywgZGF0YSkpO1xyXG5leHBvcnQgY29uc3QgQ1VSVkVEX0xBQkVMX0VYVFJBQ1RPUiA9IChkYXRhKSA9PiBmbGF0KG1hcCgnY3VydmVkTGFiZWxzJywgZGF0YSkpO1xyXG5leHBvcnQgY29uc3QgTU9ERUxfRVhUUkFDVE9SID0gKGRhdGEpID0+IGZsYXQobWFwKCdtb2RlbHMnLCBkYXRhKSk7XHJcbmV4cG9ydCBjb25zdCBFWFRFUk5BTF9NRVNIX0VYVFJBQ1RPUiA9IChkYXRhKSA9PiBmbGF0KG1hcCgnZXh0ZXJuYWxNZXNoZXMnLCBkYXRhKSk7XHJcbi8qKlxyXG4gKiBNYXBzIGxpc3Qgb2YgVGlsZURhdGEncyBpbnRvIGxpc3Qgb2Ygc3BlY2lmaWVkIHByaW1pdGl2ZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiogbWFwKHR5cGUsIGRhdGEpIHtcclxuICAgIGZvciAoY29uc3QgcG9ydGlvbiBvZiBkYXRhKSB7XHJcbiAgICAgICAgeWllbGQgcG9ydGlvblt0eXBlXTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogRmxhdHRlbiB0d28gZGltZW5zaW9uYWwgbGlzdCBvZiBwcmltaXRpdmVzIGluIGEgc2luZ2xlIGRpbWVuc2lvbmFsIG9uZS5cclxuICovXHJcbmZ1bmN0aW9uKiBmbGF0KHByaW1pdGl2ZXMpIHtcclxuICAgIGZvciAoY29uc3QgcG9ydGlvbiBvZiBwcmltaXRpdmVzKSB7XHJcbiAgICAgICAgaWYgKHBvcnRpb24pIHtcclxuICAgICAgICAgICAgeWllbGQqIHBvcnRpb247XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2FkYXB0ZXJzL3ZlY3Rvcl9hcGkvdGlsZV9kYXRhLnRzXG4vLyBtb2R1bGUgaWQgPSA5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgUmVuZGVyYWJsZVByaW1pdGl2ZU1hbmFnZXIgZnJvbSAnLi9yZW5kZXJhYmxlX3ByaW1pdGl2ZV9tYW5hZ2VyJztcclxuLyoqXHJcbiAqIFBvbHlnb25zIHNob3VsZCBiZSBzZXBhcmF0ZWQgYnkgb3BhcXVlbmVzcyBhbmQgdGhlcmUgYXJlIHR3byBkaXN0aW5jdCBwcmltaXRpdmUgcHJvdmlkZXJzXHJcbiAqIGZvciB0aGVtOiBvcGFxdWUgYW5kIHRhbnNwYXJlbnQuIFRoYXQgaXMgd2hhdCB0aGlzIG1hbmFnZXIgdGFrZXMgY2FyZSBvZi5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvbHlnb25NYW5hZ2VyIGV4dGVuZHMgUmVuZGVyYWJsZVByaW1pdGl2ZU1hbmFnZXIge1xyXG4gICAgY29uc3RydWN0b3Iob3BhcXVlUG9seWdvblN0b3JhZ2UsIHRyYW5zcGFyZW50UG9seWdvblN0b3JhZ2UpIHtcclxuICAgICAgICBzdXBlcihvcGFxdWVQb2x5Z29uU3RvcmFnZSk7XHJcbiAgICAgICAgdGhpcy5fb3BhcXVlUG9seWdvblN0b3JhZ2UgPSBvcGFxdWVQb2x5Z29uU3RvcmFnZTtcclxuICAgICAgICB0aGlzLl90cmFuc3BhcmVudFBvbHlnb25TdG9yYWdlID0gdHJhbnNwYXJlbnRQb2x5Z29uU3RvcmFnZTtcclxuICAgIH1cclxuICAgIHVwZGF0ZVNjZW5lKHRvU2hvdywgdG9IaWRlKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBwcmltaXRpdmUgb2YgdG9TaG93KSB7XHJcbiAgICAgICAgICAgIGlmIChwcmltaXRpdmUuaXNPcGFxdWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX29wYXF1ZVBvbHlnb25TdG9yYWdlLmFkZChwcmltaXRpdmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNwYXJlbnRQb2x5Z29uU3RvcmFnZS5hZGQocHJpbWl0aXZlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IHByaW1pdGl2ZSBvZiB0b0hpZGUpIHtcclxuICAgICAgICAgICAgaWYgKHByaW1pdGl2ZS5pc09wYXF1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fb3BhcXVlUG9seWdvblN0b3JhZ2UuZGVsZXRlKHByaW1pdGl2ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90cmFuc3BhcmVudFBvbHlnb25TdG9yYWdlLmRlbGV0ZShwcmltaXRpdmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2FkYXB0ZXJzL3ZlY3Rvcl9hcGkvcHJpbWl0aXZlX21hbmFnZXIvcG9seWdvbl9tYW5hZ2VyLnRzXG4vLyBtb2R1bGUgaWQgPSA5N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBmaWx0ZXJJdGVyYWJsZSB9IGZyb20gJy4uLy4uL3V0aWwvaXRlcmFibGUnO1xyXG5pbXBvcnQgRGlzYXBwZWFyaW5nUHJpbWl0aXZlU2V0U3RvcmFnZSBmcm9tICcuL2Rpc2FwcGVhcmluZ19wcmltaXRpdmVfc2V0X3N0b3JhZ2UnO1xyXG4vKipcclxuICogUHJpbWl0aXZlIHN0b3JhZ2UgdGhhdCBzdG9yZXMgcHJpbWl0aXZlIGluIGEgc2V0LiBJdCBhY3RzIGFzIGEgcHJpbWl0aXZlIHByb3ZpZGVyIGFzIHdlbGwuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZWxheWVkRGlzYXBwZWFyaW5nUHJpbWl0aXZlU2V0U3RvcmFnZSBleHRlbmRzIERpc2FwcGVhcmluZ1ByaW1pdGl2ZVNldFN0b3JhZ2Uge1xyXG4gICAgY29uc3RydWN0b3IoYXBwZWFyaW5nRWZmZWN0RHVyYXRpb24pIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX2FwcGVhcmluZ0VmZmVjdER1cmF0aW9uID0gYXBwZWFyaW5nRWZmZWN0RHVyYXRpb247XHJcbiAgICAgICAgdGhpcy5fc2NoZWR1bGVkUmVtb3ZlcyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLl90aW1lb3V0SWRzID0gbmV3IFNldCgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHByaW1pdGl2ZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaW1pdGl2ZVNldDtcclxuICAgIH1cclxuICAgIGFkZCguLi5wcmltaXRpdmVzKSB7XHJcbiAgICAgICAgLy8gcHJpbWl0aXZlcyB0aGF0IGFyZSBzY2hlZHVsZWQgZm9yIHJlbW92aW5nIHdhcyBub3QgcmVtb3ZlZCBcInBoeXNpY2FsbHlcIiwgdGhhdCBpcyB3aHlcclxuICAgICAgICAvLyB0aGV5IHNob3VsZCBiZSBmaWx0ZXJlZCBvdXQgdG8gcHJldmVudCBtdWx0aXBsZSBhZGRpbmcgb2YgdGhlIHNhbWUgcHJpbWl0aXZlIGluIHBhcmVudFxyXG4gICAgICAgIGNvbnN0IG5vdFNjaGVkdWxlZEZvclJlbW92ZVByaW1pdGl2ZXMgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IHByaW1pdGl2ZSBvZiBwcmltaXRpdmVzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByaW1pdGl2ZXNUb0RlbGV0ZSA9IHRoaXMuX3NjaGVkdWxlZFJlbW92ZXMuZ2V0KHByaW1pdGl2ZSk7XHJcbiAgICAgICAgICAgIGlmIChwcmltaXRpdmVzVG9EZWxldGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgcHJpbWl0aXZlIGlzIHNjaGVkdWxlZCBmb3IgcmVtb3ZpbmcgaXQgaXMgZGVsZXRlZCBmcm9tIGl0cyBiYXRjaCxcclxuICAgICAgICAgICAgICAgIC8vIHRodXMgY2FuY2VsaW5nIHRoZSByZW1vdmluZyBpbiB0aGUgY2FsbGJhY2tcclxuICAgICAgICAgICAgICAgIHByaW1pdGl2ZXNUb0RlbGV0ZS5kZWxldGUocHJpbWl0aXZlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NjaGVkdWxlZFJlbW92ZXMuZGVsZXRlKHByaW1pdGl2ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBub3RTY2hlZHVsZWRGb3JSZW1vdmVQcmltaXRpdmVzLnB1c2gocHJpbWl0aXZlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBzdXBlci5hZGQoLi4ubm90U2NoZWR1bGVkRm9yUmVtb3ZlUHJpbWl0aXZlcyk7XHJcbiAgICAgICAgdGhpcy5zaG93KC4uLm5vdFNjaGVkdWxlZEZvclJlbW92ZVByaW1pdGl2ZXMpO1xyXG4gICAgfVxyXG4gICAgZGVsZXRlKC4uLnByaW1pdGl2ZXMpIHtcclxuICAgICAgICB0aGlzLmhpZGUoLi4ucHJpbWl0aXZlcyk7XHJcbiAgICAgICAgLy8gcHJpbWl0aXZlcyBhcmUgYmF0Y2hlZCBpbiBhIHNldCB0byBiZSBkZWxldGVkIGluIG9uZSBzZXRUaW1lb3V0IGNhbGxiYWNrIGZvciBwZXJmb3JtYW5jZSxcclxuICAgICAgICAvLyBmaWx0ZXIgb3V0IHByaW1pdGl2ZXMgd2hpY2ggcmVtb3Zpbmcgd2FzIGFscmVhZHkgc2NoZWR1bGVkXHJcbiAgICAgICAgY29uc3QgcHJpbWl0aXZlc1RvRGVsZXRlID0gbmV3IFNldChmaWx0ZXJJdGVyYWJsZShwcmltaXRpdmVzLCAocHJpbWl0aXZlKSA9PiAhdGhpcy5fc2NoZWR1bGVkUmVtb3Zlcy5oYXMocHJpbWl0aXZlKSkpO1xyXG4gICAgICAgIGlmIChwcmltaXRpdmVzVG9EZWxldGUuc2l6ZSA+IDApIHtcclxuICAgICAgICAgICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBwcmltaXRpdmVzVG9EZWxldGUgY29udGFpbnMgcmVsZXZhbnQgZm9yIHJlbW92aW5nIHByaW1pdGl2ZXMsIGl0IGNhbiBiZSB1cGRhdGVkIGluIHRoZSBhZGQoKSBtZXRob2RcclxuICAgICAgICAgICAgICAgIC8vIGlmIGEgcHJpbWl0aXZlIGlzIGFkZGVkIGJhY2ssIHRodXMsIGluIGZhY3QsIGNhbmNlbGluZyByZW1vdmluZyBvZiB0aGlzIHNwZWNpZmljIHByaW1pdGl2ZVxyXG4gICAgICAgICAgICAgICAgc3VwZXIuZGVsZXRlKC4uLnByaW1pdGl2ZXNUb0RlbGV0ZSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHByaW1pdGl2ZSBvZiBwcmltaXRpdmVzVG9EZWxldGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zY2hlZHVsZWRSZW1vdmVzLmRlbGV0ZShwcmltaXRpdmUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fdGltZW91dElkcy5kZWxldGUodGltZW91dElkKTtcclxuICAgICAgICAgICAgfSwgdGhpcy5fYXBwZWFyaW5nRWZmZWN0RHVyYXRpb24pO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByaW1pdGl2ZSBvZiBwcmltaXRpdmVzVG9EZWxldGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NjaGVkdWxlZFJlbW92ZXMuc2V0KHByaW1pdGl2ZSwgcHJpbWl0aXZlc1RvRGVsZXRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl90aW1lb3V0SWRzLmFkZCh0aW1lb3V0SWQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCB0aW1lb3V0SWQgb2YgdGhpcy5fdGltZW91dElkcykge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfaXNBbGxvd2VkVG9TaG93UHJpbWl0aXZlKHByaW1pdGl2ZSkge1xyXG4gICAgICAgIHJldHVybiBzdXBlci5faXNBbGxvd2VkVG9TaG93UHJpbWl0aXZlKHByaW1pdGl2ZSkgJiYgIXRoaXMuX3NjaGVkdWxlZFJlbW92ZXMuaGFzKHByaW1pdGl2ZSk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvZGVsYXllZF9kaXNhcHBlYXJpbmdfcHJpbWl0aXZlX3NldF9zdG9yYWdlLnRzXG4vLyBtb2R1bGUgaWQgPSA5OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgUmVuZGVyYWJsZVByaW1pdGl2ZU1hbmFnZXIgZnJvbSAnLi9yZW5kZXJhYmxlX3ByaW1pdGl2ZV9tYW5hZ2VyJztcclxuaW1wb3J0IHsgbWFwSXRlcmFibGUsIGZpbHRlckl0ZXJhYmxlIH0gZnJvbSAnLi4vLi4vLi4vdXRpbC9pdGVyYWJsZSc7XHJcbi8qKlxyXG4gKiBJdCBpcyByZXF1aXJlZCB0byBoaWRlIHNvbWUgcHJpbWl0aXZlcyAodGhhdCBkb24ndCBzY2FsZSB3aXRoIHpvb20sIGUuZy4gbGFiZWxzIG9yIGljb25zKSBieSBcInRvbyBpcnJlbGV2YW50XCIgem9vbSxcclxuICogdG8gcHJldmVudCBtZXNzIG9mIGNvbGxhcHNlZCBvYmplY3RzIG9uIHRoZSBzY3JlZW4uIFRoaXMgcHJpbWl0aXZlIG1hbmFnZXIgaXMgYSB0ZW1wb3Jhcnkgc29sdXRpb24sXHJcbiAqIHByb3BlciBoYW5kbGluZyBvZiB6b29tIHNsaWNlcyB3aWxsIHJlcGxhY2UgaXQuXHJcbiAqL1xyXG4vLyBUT0RPOiB0aGlzIG1hbmFnZXIgaXMgYSB0bXAgc29sdXRpb24sIGNvcnJlY3QgaGFuZGxpbmcgb2Ygem9vbSBzbGljZXMgaXMgZ29pbmcgdG8gcmVwbGFjZSBpdFxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBab29tRmlsdGVyYWJsZVByaW1pdGl2ZU1hbmFnZXIgZXh0ZW5kcyBSZW5kZXJhYmxlUHJpbWl0aXZlTWFuYWdlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihwcmltaXRpdmVzU3RvcmFnZSwgY2FtZXJhKSB7XHJcbiAgICAgICAgc3VwZXIocHJpbWl0aXZlc1N0b3JhZ2UpO1xyXG4gICAgICAgIHRoaXMuX2Rpc2FwcGVhcmluZ1ByaW1pdGl2ZXNTdG9yYWdlID0gcHJpbWl0aXZlc1N0b3JhZ2U7XHJcbiAgICAgICAgdGhpcy5fY2FtZXJhID0gY2FtZXJhO1xyXG4gICAgICAgIHRoaXMuX3ByaW1pdGl2ZXMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgdGhpcy5fcHJldlpvb20gPSBjYW1lcmEuem9vbTtcclxuICAgICAgICB0aGlzLl96b29tVXBkYXRlTGlzdGVuZXIgPSB0aGlzLl9vblpvb21VcGRhdGVkLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5fY2FtZXJhLm9uVXBkYXRlLmFkZExpc3RlbmVyKHRoaXMuX3pvb21VcGRhdGVMaXN0ZW5lcik7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVTY2VuZSh0b1Nob3csIHRvSGlkZSkge1xyXG4gICAgICAgIC8vIHNhdmUgcHJpbWl0aXZlcyB0byBmaWx0ZXIgdGhlbSBsYXRlclxyXG4gICAgICAgIHN1cGVyLnVwZGF0ZVNjZW5lKG1hcEl0ZXJhYmxlKHRvU2hvdywgKHByaW1pdGl2ZSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9wcmltaXRpdmVzLmFkZChwcmltaXRpdmUpO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJpbWl0aXZlO1xyXG4gICAgICAgIH0pLCBtYXBJdGVyYWJsZSh0b0hpZGUsIChwcmltaXRpdmUpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fcHJpbWl0aXZlcy5kZWxldGUocHJpbWl0aXZlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByaW1pdGl2ZTtcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgYXJlIGFkZGVkIHByaW1pdGl2ZXMgdGhhdCBjb3VsZCBiZSByZW1vdmVkIGJ5IHpvb20gcmVzdHJpY3Rpb25zXHJcbiAgICAgICAgdGhpcy5fdXBkYXRlWm9vbVZpc2liaWxpdHkoKTtcclxuICAgIH1cclxuICAgIF9vblpvb21VcGRhdGVkKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9wcmV2Wm9vbSAhPT0gdGhpcy5fY2FtZXJhLnpvb20pIHtcclxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlWm9vbVZpc2liaWxpdHkoKTtcclxuICAgICAgICAgICAgdGhpcy5fcHJldlpvb20gPSB0aGlzLl9jYW1lcmEuem9vbTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfdXBkYXRlWm9vbVZpc2liaWxpdHkoKSB7XHJcbiAgICAgICAgY29uc3Qgem9vbSA9IHRoaXMuX2NhbWVyYS56b29tO1xyXG4gICAgICAgIHRoaXMuX2Rpc2FwcGVhcmluZ1ByaW1pdGl2ZXNTdG9yYWdlLnNob3coLi4uZmlsdGVySXRlcmFibGUodGhpcy5fcHJpbWl0aXZlcywgKHsgbWluWm9vbSB9KSA9PiB6b29tID49IG1pblpvb20pKTtcclxuICAgICAgICB0aGlzLl9kaXNhcHBlYXJpbmdQcmltaXRpdmVzU3RvcmFnZS5oaWRlKC4uLmZpbHRlckl0ZXJhYmxlKHRoaXMuX3ByaW1pdGl2ZXMsICh7IG1pblpvb20gfSkgPT4gem9vbSA8IG1pblpvb20pKTtcclxuICAgIH1cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5fY2FtZXJhLm9uVXBkYXRlLnJlbW92ZUxpc3RlbmVyKHRoaXMuX3pvb21VcGRhdGVMaXN0ZW5lcik7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdmVjdG9yX2FwaS9wcmltaXRpdmVfbWFuYWdlci96b29tX2ZpbHRlcmFibGVfcHJpbWl0aXZlX21hbmFnZXIudHNcbi8vIG1vZHVsZSBpZCA9IDk5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IFRpbGVQcm92aWRlck1lc3NhZ2VUeXBlIH0gZnJvbSAnLi4vd29ya2VyL3RpbGVfcHJvdmlkZXJfd29ya2VyX21lc3NhZ2VzJztcclxuaW1wb3J0IE1lbW9yeVN1YkNodW5rIGZyb20gJy4uLy4uLy4uL3JlbmRlci9tZW1vcnkvc3ViX2NodW5rJztcclxuaW1wb3J0IE1vZGVsQnVmZmVyV3JpdGVyIGZyb20gJy4uLy4uLy4uL3ByaW1pdGl2ZS9tb2RlbC9tb2RlbF9idWZmZXJfd3JpdGVyJztcclxuaW1wb3J0IFByaW1pdGl2ZU1hbmFnZXIgZnJvbSAnLi9wcmltaXRpdmVfbWFuYWdlcic7XHJcbmltcG9ydCBSZW5kZXJhYmxlTW9kZWwgZnJvbSAnLi4vLi4vLi4vcHJpbWl0aXZlL21vZGVsL3JlbmRlcmFibGVfbW9kZWwnO1xyXG5pbXBvcnQgeyBOT19JRCB9IGZyb20gJy4uLy4uLy4uL3V0aWwvd29ya2VyJztcclxuLyoqXHJcbiAqIEV4dGVybmFsIG1lc2hlcyBjb21lIGluIHBvbHlnb25zIChraW5kIG9mIGJ1aWxkaW5nIG91dGxpbmVzKS4gVGhpcyBtYW5hZ2VyIGNvbnRyb2xzIHF1ZXJpbmcgZXh0ZXJuYWwgbWVzaGVzXHJcbiAqIGFjY29yZGluZyB0byBhZGRlZCBwb2x5Z29ucywgYXMgbWFueSBvZiB0aGVtIGNhbiBzaGFyZSB0aGUgc2FtZSBtZXNoICh1c3VhbGx5IGFjcm9zcyBtdWx0aXBsZSB0aWxlcykuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFeHRlcm5hbE1lc2hQcmltaXRpdmVNYW5hZ2VyIGV4dGVuZHMgUHJpbWl0aXZlTWFuYWdlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihwcmltaXRpdmVzU3RvcmFnZSwgZ2VvbWV0cnlQcm92aWRlciwgbWVtb3J5TWFuYWdlcikge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fcHJpbWl0aXZlc1N0b3JhZ2UgPSBwcmltaXRpdmVzU3RvcmFnZTtcclxuICAgICAgICB0aGlzLl90aWxlUHJvdmlkZXIgPSBnZW9tZXRyeVByb3ZpZGVyO1xyXG4gICAgICAgIHRoaXMuX21lbW9yeU1hbmFnZXIgPSBtZW1vcnlNYW5hZ2VyO1xyXG4gICAgICAgIHRoaXMuX2V4dGVybmFsTWVzaGVzID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlU2NlbmUodG9TaG93LCB0b0hpZGUpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IHByaW1pdGl2ZSBvZiB0b1Nob3cpIHtcclxuICAgICAgICAgICAgdGhpcy5fYWRkUHJpbWl0aXZlKHByaW1pdGl2ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3QgcHJpbWl0aXZlIG9mIHRvSGlkZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVQcmltaXRpdmUocHJpbWl0aXZlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfYWRkUHJpbWl0aXZlKHByaW1pdGl2ZSkge1xyXG4gICAgICAgIGNvbnN0IGlkID0gZ2V0RnVsbE1lc2hJZChwcmltaXRpdmUpO1xyXG4gICAgICAgIGxldCBleHRlcm5hbCA9IHRoaXMuX2V4dGVybmFsTWVzaGVzLmdldChpZCk7XHJcbiAgICAgICAgaWYgKCFleHRlcm5hbCkge1xyXG4gICAgICAgICAgICBleHRlcm5hbCA9IHtcclxuICAgICAgICAgICAgICAgIHZpc2libGVQb2x5Z29uczogbmV3IFNldCgpLFxyXG4gICAgICAgICAgICAgICAgaXNWaXNpYmxlOiBmYWxzZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLl9leHRlcm5hbE1lc2hlcy5zZXQoaWQsIGV4dGVybmFsKTtcclxuICAgICAgICAgICAgdGhpcy5fdGlsZVByb3ZpZGVyLnJlcXVlc3Qoe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGUuTUVTSF9SRVFVRVNULFxyXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiBUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZS5NRVNIX1JFU1BPTlNFLFxyXG4gICAgICAgICAgICAgICAgZXJyb3JUeXBlOiBUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZS5NRVNIX0VSUk9SLFxyXG4gICAgICAgICAgICAgICAgbWVzaDogcHJpbWl0aXZlLFxyXG4gICAgICAgICAgICAgICAgcmVxdWVzdElkOiBOT19JRFxyXG4gICAgICAgICAgICB9KS50aGVuKChyZXNwb25zZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZXh0ZXJuYWwgPSB0aGlzLl9leHRlcm5hbE1lc2hlcy5nZXQoaWQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGV4dGVybmFsICYmICFleHRlcm5hbC5pc1Zpc2libGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2NhdGlvbiA9IHJlc3BvbnNlLmxvY2F0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rcyA9IHJlc3BvbnNlLnBhZ2VzLm1hcCgocGFnZSkgPT4gdGhpcy5fbWVtb3J5TWFuYWdlci5hbGxvY2F0ZShwYWdlLnZlcnRleEJ1ZmZlciwgcGFnZS5pbmRleEJ1ZmZlciwgTW9kZWxCdWZmZXJXcml0ZXIuQVRUUklCVVRFX01BUFBJTkcpKTtcclxuICAgICAgICAgICAgICAgICAgICBleHRlcm5hbC5tZXNoID0gbmV3IFJlbmRlcmFibGVNb2RlbChuZXcgTWVtb3J5U3ViQ2h1bmsoY2h1bmtzW2xvY2F0aW9uLmJ1ZmZlckluZGV4XSwgbG9jYXRpb24pKTtcclxuICAgICAgICAgICAgICAgICAgICBleHRlcm5hbC5pc1Zpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ByaW1pdGl2ZXNTdG9yYWdlLmFkZChleHRlcm5hbC5tZXNoKTtcclxuICAgICAgICAgICAgICAgICAgICBjaHVua3MuZm9yRWFjaCgoY2h1bmspID0+IGNodW5rLnJlbGVhc2UoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBleHRlcm5hbC52aXNpYmxlUG9seWdvbnMuYWRkKHByaW1pdGl2ZSk7XHJcbiAgICB9XHJcbiAgICBfcmVtb3ZlUHJpbWl0aXZlKHByaW1pdGl2ZSkge1xyXG4gICAgICAgIGNvbnN0IGlkID0gZ2V0RnVsbE1lc2hJZChwcmltaXRpdmUpO1xyXG4gICAgICAgIGNvbnN0IGV4dGVybmFsID0gdGhpcy5fZXh0ZXJuYWxNZXNoZXMuZ2V0KGlkKTtcclxuICAgICAgICBpZiAoZXh0ZXJuYWwpIHtcclxuICAgICAgICAgICAgZXh0ZXJuYWwudmlzaWJsZVBvbHlnb25zLmRlbGV0ZShwcmltaXRpdmUpO1xyXG4gICAgICAgICAgICAvLyBkZXN0cm95IGV4dGVybmFsIG1lc2ggaWYgdGhlcmUgaXMgbm8gdmlzaWJsZSBwb2x5Z29ucyByZW1haW5pbmdcclxuICAgICAgICAgICAgaWYgKGV4dGVybmFsLnZpc2libGVQb2x5Z29ucy5zaXplID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9leHRlcm5hbE1lc2hlcy5kZWxldGUoaWQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGV4dGVybmFsLm1lc2gpIHtcclxuICAgICAgICAgICAgICAgICAgICBleHRlcm5hbC5tZXNoLnJlbGVhc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcmltaXRpdmVzU3RvcmFnZS5kZWxldGUoZXh0ZXJuYWwubWVzaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXh0ZXJuYWwuaXNWaXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBubyBtZXNoIHlldCByZXR1cm5lZCBjYW5jZWwgcmVxdWVzdFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RpbGVQcm92aWRlci5zZW5kTWVzc2FnZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFRpbGVQcm92aWRlck1lc3NhZ2VUeXBlLk1FU0hfUkVRVUVTVF9DQU5DRUwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc2g6IHByaW1pdGl2ZVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldEZ1bGxNZXNoSWQobWVzaCkge1xyXG4gICAgcmV0dXJuIG1lc2gub2JqZWN0SWQgKyBtZXNoLm1lc2hJZDtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9hZGFwdGVycy92ZWN0b3JfYXBpL3ByaW1pdGl2ZV9tYW5hZ2VyL2V4dGVybmFsX21lc2hfbWFuYWdlci50c1xuLy8gbW9kdWxlIGlkID0gMTAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBSZW5kZXJhYmxlUHJpbWl0aXZlIGZyb20gJy4uL3JlbmRlcmFibGVfcHJpbWl0aXZlJztcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVuZGVyYWJsZUJpbGxib2FyZFJlY3RhbmdsZSBleHRlbmRzIFJlbmRlcmFibGVQcmltaXRpdmUge1xyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3ByaW1pdGl2ZS9iaWxsYm9hcmRfcmVjdGFuZ2xlL3JlbmRlcmFibGVfYmlsbGJvYXJkX3JlY3RhbmdsZS50c1xuLy8gbW9kdWxlIGlkID0gMTAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBSZW5kZXJhYmxlTGFiZWwgZnJvbSAnLi4vLi4vLi4vcHJpbWl0aXZlL2xhYmVsL3JlbmRlcmFibGVfbGFiZWwnO1xyXG5leHBvcnQgY2xhc3MgWm9vbVJlc3RyaWN0ZWRMYWJlbCBleHRlbmRzIFJlbmRlcmFibGVMYWJlbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihtZW1vcnlTdWJDaHVuaywgYXRsYXMsIG1pblpvb20sIGJhY2tncm91bmQpIHtcclxuICAgICAgICBzdXBlcihtZW1vcnlTdWJDaHVuaywgYXRsYXMsIGJhY2tncm91bmQpO1xyXG4gICAgICAgIHRoaXMubWluWm9vbSA9IG1pblpvb207XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdmVjdG9yX2FwaS9wcmltaXRpdmUvem9vbV9yZXN0cmljdGVkX2xhYmVsLnRzXG4vLyBtb2R1bGUgaWQgPSAxMDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IFJlbmRlcmFibGVQcmltaXRpdmUgZnJvbSAnLi4vcmVuZGVyYWJsZV9wcmltaXRpdmUnO1xyXG4vKipcclxuICogQWxsb2NhdGVkIGluIEdQVSBtZW1vcnkgbGFiZWwuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW5kZXJhYmxlTGFiZWwgZXh0ZW5kcyBSZW5kZXJhYmxlUHJpbWl0aXZlIHtcclxuICAgIC8qKlxyXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyByZW5kZXJhYmxlIGxhYmVsLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtZW1vcnlTdWJDaHVua1xyXG4gICAgICogQHBhcmFtIGF0bGFzXHJcbiAgICAgKiBAcGFyYW0gYmFja2dyb3VuZFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihtZW1vcnlTdWJDaHVuaywgYXRsYXMsIGJhY2tncm91bmQpIHtcclxuICAgICAgICBzdXBlcihtZW1vcnlTdWJDaHVuayk7XHJcbiAgICAgICAgdGhpcy5hdGxhcyA9IGF0bGFzO1xyXG4gICAgICAgIHRoaXMuYmFja2dyb3VuZCA9IGJhY2tncm91bmQ7XHJcbiAgICAgICAgaWYgKGJhY2tncm91bmQpIHtcclxuICAgICAgICAgICAgYmFja2dyb3VuZC5yZXRhaW4oKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfZGVzdHJveSgpIHtcclxuICAgICAgICBpZiAodGhpcy5iYWNrZ3JvdW5kKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYmFja2dyb3VuZC5yZWxlYXNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN1cGVyLl9kZXN0cm95KCk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL2xhYmVsL3JlbmRlcmFibGVfbGFiZWwudHNcbi8vIG1vZHVsZSBpZCA9IDEwM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgUmVuZGVyYWJsZUljb24gZnJvbSAnLi4vLi4vLi4vcHJpbWl0aXZlL2ljb24vcmVuZGVyYWJsZV9pY29uJztcclxuZXhwb3J0IGNsYXNzIFpvb21SZXN0cmljdGVkSWNvbiBleHRlbmRzIFJlbmRlcmFibGVJY29uIHtcclxuICAgIGNvbnN0cnVjdG9yKG1lbW9yeVN1YkNodW5rLCBhbGxvY2F0ZWRJbWFnZSwgbWluWm9vbSkge1xyXG4gICAgICAgIHN1cGVyKG1lbW9yeVN1YkNodW5rLCBhbGxvY2F0ZWRJbWFnZSk7XHJcbiAgICAgICAgdGhpcy5taW5ab29tID0gbWluWm9vbTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9hZGFwdGVycy92ZWN0b3JfYXBpL3ByaW1pdGl2ZS96b29tX3Jlc3RyaWN0ZWRfaWNvbi50c1xuLy8gbW9kdWxlIGlkID0gMTA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBSZW5kZXJhYmxlSW1hZ2UgZnJvbSAnLi4vaW1hZ2UvcmVuZGVyYWJsZV9pbWFnZSc7XHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbmRlcmFibGVJY29uIGV4dGVuZHMgUmVuZGVyYWJsZUltYWdlIHtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9wcmltaXRpdmUvaWNvbi9yZW5kZXJhYmxlX2ljb24udHNcbi8vIG1vZHVsZSBpZCA9IDEwNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgVGV4dHVyZWRSZW5kZXJhYmxlUHJpbWl0aXZlIGZyb20gJy4uL3RleHR1cmVkX3JlbmRlcmFibGVfcHJpbWl0aXZlJztcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVuZGVyYWJsZUltYWdlIGV4dGVuZHMgVGV4dHVyZWRSZW5kZXJhYmxlUHJpbWl0aXZlIHtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9wcmltaXRpdmUvaW1hZ2UvcmVuZGVyYWJsZV9pbWFnZS50c1xuLy8gbW9kdWxlIGlkID0gMTA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBSZW5kZXJhYmxlUHJpbWl0aXZlIGZyb20gJy4vcmVuZGVyYWJsZV9wcmltaXRpdmUnO1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXh0dXJlZFJlbmRlcmFibGVQcmltaXRpdmUgZXh0ZW5kcyBSZW5kZXJhYmxlUHJpbWl0aXZlIHtcclxuICAgIGNvbnN0cnVjdG9yKG1lbW9yeUNodW5rLCBhbGxvY2F0ZWRJbWFnZSkge1xyXG4gICAgICAgIHN1cGVyKG1lbW9yeUNodW5rKTtcclxuICAgICAgICB0aGlzLl9hbGxvY2F0ZWRJbWFnZSA9IGFsbG9jYXRlZEltYWdlO1xyXG4gICAgICAgIHRoaXMuYXRsYXMgPSBhbGxvY2F0ZWRJbWFnZS5hdGxhc01hbmFnZXIuYXRsYXM7XHJcbiAgICAgICAgdGhpcy5fYWxsb2NhdGVkSW1hZ2UucmV0YWluKCk7XHJcbiAgICB9XHJcbiAgICBfZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLl9hbGxvY2F0ZWRJbWFnZS5yZWxlYXNlKCk7XHJcbiAgICAgICAgc3VwZXIuX2Rlc3Ryb3koKTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9wcmltaXRpdmUvdGV4dHVyZWRfcmVuZGVyYWJsZV9wcmltaXRpdmUudHNcbi8vIG1vZHVsZSBpZCA9IDEwN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgUHJpb3JpdHlRZXVldWUgZnJvbSAnLi9wcmlvcml0eV9xdWV1ZSc7XHJcbmltcG9ydCB7IFZvaWRFdmVudEVtaXR0ZXIgfSBmcm9tICcuLi91dGlsL2V2ZW50X2VtaXR0ZXInO1xyXG5jb25zdCBERVFVRVVFX1RJTUVPVVQgPSAxOyAvLyBtc1xyXG4vKipcclxuICogUHJpb3JpdGl6ZWQgdGFzayBxdWV1ZS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRhc2tRdWV1ZSB7XHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cnVjdHMgYW4gZW1wdHkgdGFzayBxdWV1ZS5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5fcXVldWUgPSBuZXcgUHJpb3JpdHlRZXVldWUoKTtcclxuICAgICAgICB0aGlzLl9mcm96ZW4gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9kZXF1ZXVlVGltZW91dEhhbmRsZSA9IDA7XHJcbiAgICAgICAgdGhpcy5vbkVtcHR5ID0gbmV3IFZvaWRFdmVudEVtaXR0ZXIoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGVzdHJveXMgdGhlIHF1ZXVlLiBBbnkgcmVtYWluaW5nIHRhc2tzIHdvbid0IGJlIGV4ZWN1dGVkLlxyXG4gICAgICovXHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9kZXF1ZXVlVGltZW91dEhhbmRsZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVucXVldWVzIGEgdGFzayB0byB0aGUgcXVldWUgYW5kIHNjaGVkdWxlcyBwcm9jZXNzaW5nIG9mIHRoZSBxdWV1ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdGFzayBUaGUgdGFzay5cclxuICAgICAqIEByZXR1cm5zIFByb21pc2UgdGhhdCB3aWxsIGJlIGZ1bGxmaWxsZWQgd2hlbiB0aGUgdGFzayBzdWNjZXNzZnVsbHlcclxuICAgICAqICAgICAgZmluaXNoZXMgb3IgcmVqZWN0ZWQgaWYgdGhlcmUncyBhbiBlcnJvci5cclxuICAgICAqL1xyXG4gICAgZW5xdWV1ZSh0YXNrKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9mcm96ZW4pIHtcclxuICAgICAgICAgICAgdGhpcy5fc2V0RGVxdWV1ZVRpbWVvdXQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fcXVldWUuZW5xdWV1ZSh7XHJcbiAgICAgICAgICAgICAgICBleGVjdXRlKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2suZXhlY3V0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBwcmlvcml0eTogdGFzay5wcmlvcml0eVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGlzRW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3F1ZXVlLmlzRW1wdHkoKTtcclxuICAgIH1cclxuICAgIGZyZWV6ZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5fZGVxdWV1ZVRpbWVvdXRIYW5kbGUpIHtcclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2RlcXVldWVUaW1lb3V0SGFuZGxlKTtcclxuICAgICAgICAgICAgdGhpcy5fZGVxdWV1ZVRpbWVvdXRIYW5kbGUgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9mcm96ZW4gPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgdW5mcmVlemUoKSB7XHJcbiAgICAgICAgdGhpcy5fZnJvemVuID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9xdWV1ZS5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgdGhpcy5fc2V0RGVxdWV1ZVRpbWVvdXQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfZGVxdWV1ZSgpIHtcclxuICAgICAgICBjb25zdCB0YXNrID0gdGhpcy5fcXVldWUuZGVxdWV1ZSgpO1xyXG4gICAgICAgIGlmICh0YXNrKSB7XHJcbiAgICAgICAgICAgIHRhc2suZXhlY3V0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fcXVldWUuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RlcXVldWVUaW1lb3V0SGFuZGxlID0gMDtcclxuICAgICAgICAgICAgdGhpcy5vbkVtcHR5LmZpcmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RlcXVldWVUaW1lb3V0SGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLl9kZXF1ZXVlKCksIERFUVVFVUVfVElNRU9VVCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3NldERlcXVldWVUaW1lb3V0KCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fZGVxdWV1ZVRpbWVvdXRIYW5kbGUpIHtcclxuICAgICAgICAgICAgdGhpcy5fZGVxdWV1ZVRpbWVvdXRIYW5kbGUgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuX2RlcXVldWUoKSwgREVRVUVVRV9USU1FT1VUKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC90YXNrX3F1ZXVlLnRzXG4vLyBtb2R1bGUgaWQgPSAxMDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgRGVsZWdhdG9yQmFzZSB9IGZyb20gJy4uLy4uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL2RlbGVnYXRvcic7XHJcbmltcG9ydCAqIGFzIHZlYzIgZnJvbSAnLi4vLi4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL21hdGgvdmVjdG9yMic7XHJcbmV4cG9ydCBjbGFzcyBNb3VzZURyYWdDb250cm9sbGVyIGV4dGVuZHMgRGVsZWdhdG9yQmFzZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX3RhcmdldCA9IHRhcmdldDtcclxuICAgICAgICB0aGlzLl9wcmVzc2VkQnV0dG9uID0gLTEgLyogTk9ORSAqLztcclxuICAgICAgICB0aGlzLl9wcmV2TW91c2VDb29yZHMgPSB2ZWMyLmNyZWF0ZSgwLCAwKTtcclxuICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcyk7XHJcbiAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcyk7XHJcbiAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgdGhpcyk7XHJcbiAgICB9XHJcbiAgICBoYW5kbGVFdmVudChlKSB7XHJcbiAgICAgICAgc3dpdGNoIChlLnR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSAnY2xpY2snOlxyXG4gICAgICAgICAgICBjYXNlICdjb250ZXh0bWVudSc6XHJcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnbW91c2Vkb3duJzpcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wcmVzc2VkQnV0dG9uID09PSAtMSAvKiBOT05FICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJlc3NlZEJ1dHRvbiA9IGUuYnV0dG9uO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ByZXZNb3VzZUNvb3Jkcy54ID0gZS5jbGllbnRYO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ByZXZNb3VzZUNvb3Jkcy55ID0gZS5jbGllbnRZO1xyXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnbW91c2Vtb3ZlJzpcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9kZWxlZ2F0ZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgbW91c2VDb29yZHMgPSB2ZWMyLmNyZWF0ZShlLmNsaWVudFgsIGUuY2xpZW50WSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkZWx0YSA9IHZlYzIuc3ViKG1vdXNlQ29vcmRzLCB0aGlzLl9wcmV2TW91c2VDb29yZHMpO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9wcmVzc2VkQnV0dG9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwIC8qIExFRlQgKi86XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlbGVnYXRlLm9uTGVmdEJ1dHRvbkRyYWcoZGVsdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDEgLyogTUlERExFICovOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWxlZ2F0ZS5vbk1pZGRsZUJ1dHRvbkRyYWcoZGVsdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDIgLyogUklHSFQgKi86XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlbGVnYXRlLm9uUmlnaHRCdXR0b25EcmFnKGRlbHRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2ZWMyLmNvcHkobW91c2VDb29yZHMsIHRoaXMuX3ByZXZNb3VzZUNvb3Jkcyk7XHJcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnbW91c2V1cCc6XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcHJlc3NlZEJ1dHRvbiA9PT0gZS5idXR0b24pIHtcclxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ByZXNzZWRCdXR0b24gPSAtMSAvKiBOT05FICovO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLl90YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCB0aGlzKTtcclxuICAgICAgICB0aGlzLl90YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzKTtcclxuICAgICAgICB0aGlzLl90YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcyk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGNsYXNzIFNjcm9sbFpvb21Db250cm9sbGVyIGV4dGVuZHMgRGVsZWdhdG9yQmFzZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX3RhcmdldCA9IHRhcmdldDtcclxuICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCB0aGlzKTtcclxuICAgIH1cclxuICAgIGhhbmRsZUV2ZW50KGUpIHtcclxuICAgICAgICBjb25zdCBkZWxlZ2F0ZSA9IHRoaXMuX2RlbGVnYXRlO1xyXG4gICAgICAgIGlmICghZGVsZWdhdGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZS5kZWx0YVkgPCAwKSB7XHJcbiAgICAgICAgICAgIGRlbGVnYXRlLm9uU2Nyb2xsSW4oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRlbGVnYXRlLm9uU2Nyb2xsT3V0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgIH1cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5fdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3doZWVsJywgdGhpcyk7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgWk9PTV9TVEVQID0gMC4xO1xyXG5jb25zdCBUSUxUX0FaSU1VVEhfRkFDVE9SID0gTWF0aC5QSSAvIDEwMjQ7XHJcbmV4cG9ydCBjbGFzcyBDYW1lcmFNb3VzZUNvbnRyb2xsZXIge1xyXG4gICAgY29uc3RydWN0b3IoY2FudmFzLCBjYW1lcmEpIHtcclxuICAgICAgICB0aGlzLl9jYW1lcmEgPSBjYW1lcmE7XHJcbiAgICAgICAgdGhpcy5fY2FudmFzU2l6ZSA9IHZlYzIuY3JlYXRlKGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5kcmFnRmFjdG9yID0gMTtcclxuICAgIH1cclxuICAgIG9uTGVmdEJ1dHRvbkRyYWcoZGVsdGEpIHtcclxuICAgICAgICAvLyBUaGF0J3Mgbm90IGV4YWN0LCBidXQgZ29vZCBlbm91Z2ggZm9yIG5vdy5cclxuICAgICAgICB2ZWMyLmRpdnYoZGVsdGEsIHRoaXMuX2NhbnZhc1NpemUsIGRlbHRhKTtcclxuICAgICAgICBjb25zdCBjYW1lcmEgPSB0aGlzLl9jYW1lcmE7XHJcbiAgICAgICAgdmVjMi5tdWxuKGRlbHRhLCB0aGlzLmRyYWdGYWN0b3IgKiBjYW1lcmEuc2NyZWVuU2l6ZS5oZWlnaHQgKiBNYXRoLnBvdygyLCAtY2FtZXJhLnpvb20pIC9cclxuICAgICAgICAgICAgKE1hdGgudGFuKDAuNSAqIGNhbWVyYS5vcHRpb25zLmZvdikgKiA2NCksIGRlbHRhKTtcclxuICAgICAgICBjb25zdCBjZW50ZXIgPSB0aGlzLl9jYW1lcmEuY2VudGVyO1xyXG4gICAgICAgIGNlbnRlci54IC09IGRlbHRhLng7XHJcbiAgICAgICAgY2VudGVyLnkgKz0gZGVsdGEueTtcclxuICAgICAgICB0aGlzLl9jYW1lcmEuc2V0RGlydHkoKTtcclxuICAgIH1cclxuICAgIG9uTWlkZGxlQnV0dG9uRHJhZygpIHsgfVxyXG4gICAgb25SaWdodEJ1dHRvbkRyYWcoZGVsdGEpIHtcclxuICAgICAgICBjb25zdCBjYW1lcmEgPSB0aGlzLl9jYW1lcmE7XHJcbiAgICAgICAgY2FtZXJhLnRpbHQgKz0gZGVsdGEueSAqIFRJTFRfQVpJTVVUSF9GQUNUT1I7XHJcbiAgICAgICAgY2FtZXJhLmF6aW11dGggKz0gZGVsdGEueCAqIFRJTFRfQVpJTVVUSF9GQUNUT1I7XHJcbiAgICAgICAgdGhpcy5fY2FtZXJhLnNldERpcnR5KCk7XHJcbiAgICB9XHJcbiAgICBvblNjcm9sbEluKCkge1xyXG4gICAgICAgIHRoaXMuX2NhbWVyYS56b29tICs9IFpPT01fU1RFUDtcclxuICAgICAgICB0aGlzLl9jYW1lcmEuc2V0RGlydHkoKTtcclxuICAgIH1cclxuICAgIG9uU2Nyb2xsT3V0KCkge1xyXG4gICAgICAgIHRoaXMuX2NhbWVyYS56b29tIC09IFpPT01fU1RFUDtcclxuICAgICAgICB0aGlzLl9jYW1lcmEuc2V0RGlydHkoKTtcclxuICAgIH1cclxufVxyXG5jb25zdCBjYW1lcmFTdGF0ZUVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjY2FtZXJhX3N0YXRlJyk7XHJcbmNvbnN0IGNhbWVyYVN0YXRlVGV4dCA9IGNhbWVyYVN0YXRlRWxlbWVudCAmJiBjYW1lcmFTdGF0ZUVsZW1lbnQuZmlyc3RDaGlsZDtcclxuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlckNhbWVyYVN0YXRlKGNhbWVyYSkge1xyXG4gICAgY29uc3QgeyBjZW50ZXI6IHsgeCwgeSB9LCB6b29tLCB0aWx0LCBhemltdXRoIH0gPSBjYW1lcmE7XHJcbiAgICBjYW1lcmFTdGF0ZVRleHQucmVwbGFjZURhdGEoMCwgY2FtZXJhU3RhdGVUZXh0Lmxlbmd0aCwgYGNlbnRlcjogKCR7eC50b0ZpeGVkKDgpfSwke3kudG9GaXhlZCg4KX0pOyB6b29tOiAke3pvb20udG9GaXhlZCg0KX07IGAgK1xyXG4gICAgICAgIGB0aWx0OiAke3RpbHQudG9GaXhlZCg0KX07IGF6aW11dGg6ICR7YXppbXV0aC50b0ZpeGVkKDQpfWApO1xyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdG9vbHMvc3RhbmQvY2FtZXJhX3N0dWZmLnRzXG4vLyBtb2R1bGUgaWQgPSAxMDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHBvaW50TGFiZWxWZXJ0ZXhTaGFkZXIgZnJvbSAnLi9zaGFkZXIvcG9pbnRfbGFiZWwudmVydCc7XHJcbmltcG9ydCBjb2xvcklkRnJhZ21lbnRTaGFkZXIgZnJvbSAnLi9zaGFkZXIvY29sb3JfaWQuZnJhZyc7XHJcbmltcG9ydCBDb2xsaWRpbmdMYWJlbENvbG9ySWRSZW5kZXJlciBmcm9tICcuL2NvbG9yX2lkX2xhYmVsX3JlbmRlcmVyJztcclxuaW1wb3J0IHsgUFJPR1JBTV9PUFRJT05TIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyL3ByaW1pdGl2ZXMvbGFiZWwvcG9pbnRfbGFiZWxfcmVuZGVyX3VuaXQnO1xyXG4vKipcclxuICogUG9pbnQgbGFiZWxzIHJlbmRlcmVyIGZvciBjb2xsaXNpb24gcmVzb2x1dGlvbi5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbG9ySWRQb2ludExhYmVsUmVuZGVyZXIgZXh0ZW5kcyBDb2xsaWRpbmdMYWJlbENvbG9ySWRSZW5kZXJlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBjYW1lcmEsIHByaW1pdGl2ZVByb3ZpZGVyKSB7XHJcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IGNvbnRleHQuY3JlYXRlUHJvZ3JhbShwb2ludExhYmVsVmVydGV4U2hhZGVyLCBjb2xvcklkRnJhZ21lbnRTaGFkZXIsIFBST0dSQU1fT1BUSU9OUyk7XHJcbiAgICAgICAgc3VwZXIoY29udGV4dCwgcHJvZ3JhbSwgcHJpbWl0aXZlUHJvdmlkZXIsIGNhbWVyYSk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdmlzaWJpbGl0eS9wcmltaXRpdmVzL2xhYmVsL2NvbG9yX2lkX3BvaW50X2xhYmVsX3JlbmRlcmVyLnRzXG4vLyBtb2R1bGUgaWQgPSAxMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcIiN2ZXJzaW9uIDEwMFxcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxuYXR0cmlidXRlIHZlYzIgdmVydGV4SWQ7XFxuXFxuLy8gcG9pbnQgaW4gdGhlIHdvcmxkIHRoZSBsYWJlbCBpcyBhbmNob3JlZCB0b1xcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleFBvc0hpZ2g7XFxuYXR0cmlidXRlIHZlYzIgdmVydGV4UG9zTG93O1xcblxcbi8vIHZlY3RvciBvZiBjb25jcmV0ZSBnbHlwaCBwb2ludCBkaXNwbGFjZW1lbnQgKHRvcC1sZWZ0LCBib3R0b20tbGVmdCwgLi4uKSByZWxhdGl2ZSB0byBsYWJlbCdzIGNlbnRlciwgaW4gcHhcXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhEaXNwbGFjZW1lbnQ7XFxuXFxuLy8gY29vcmRpbmF0ZXMgb2YgdGhlIGdseXBoIHZlcnRleCBpbiB0aGUgYXRsYXNcXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhVVjtcXG5cXG5hdHRyaWJ1dGUgZmxvYXQgdmVydGV4UHJpb3JpdHk7XFxuXFxudW5pZm9ybSB2ZWMyIGxvb2tBdEhpZ2g7XFxudW5pZm9ybSB2ZWMyIGxvb2tBdExvdztcXG51bmlmb3JtIG1hdDQgdmlld1Byb2pNYXRyaXg7XFxudW5pZm9ybSB2ZWMyIHBpeGVsU2l6ZTtcXG51bmlmb3JtIHNhbXBsZXIyRCB2aXNpYmlsaXR5O1xcbnVuaWZvcm0gdmVjMiBpZEhhbGZQeFNpemU7XFxudW5pZm9ybSB2ZWMyIHNoaWZ0O1xcbnVuaWZvcm0gbG93cCBmbG9hdCBjdXJyZW50Wm9vbTtcXG5cXG52YXJ5aW5nIHZlYzIgdXY7XFxudmFyeWluZyBsb3dwIHZlYzQgY29sb3I7XFxudmFyeWluZyBsb3dwIHZlYzQgb3V0bGluZUNvbG9yO1xcbnZhcnlpbmcgbWVkaXVtcCBmbG9hdCBzY2FsZTtcXG5cXG5jb25zdCB2ZWM0IERJU0NBUkRfUE9TSVRJT04gPSB2ZWM0KDIsIDIsIDIsIDEpO1xcblxcbmNvbnN0IGZsb2F0IFlWX0hfMV8wID0gMS45OTk5Njk0ODI0MjE4NzU7XFxuY29uc3QgZmxvYXQgWVZfTF8xXzEgPSAwLjAwMDAzMDUxNzExMjQ2MzcxMjY5MjtcXG5cXG4vKipcXG4gKiBQcm9qZWN0cyBzcGVjaWZpYyBwb2ludCBsYWJlbCB2ZXJ0ZXggb250byB0aGUgc2NyZWVuLlxcbiAqL1xcbnZlYzQgcHJvamVjdFBvaW50TGFiZWxWZXJ0ZXhfMV8yKFxcbiAgICBtYXQ0IHZpZXdQcm9qTWF0cml4LFxcbiAgICB2ZWMyIGxvb2tBdEhpZ2gsXFxuICAgIHZlYzIgbG9va0F0TG93LFxcbiAgICB2ZWMyIHBvc0hpZ2gsXFxuICAgIHZlYzIgcG9zTG93LFxcbiAgICB2ZWMyIGRpc3BsYWNlbWVudCxcXG4gICAgdmVjMiBweFNpemVcXG4pIHtcXG4gICAgdmVjNCBwb3NpdGlvbiA9IHZpZXdQcm9qTWF0cml4ICogdmVjNChcXG4gICAgICAgIFlWX0hfMV8wICogKHBvc0hpZ2ggLSBsb29rQXRIaWdoKSArXFxuICAgICAgICAgICAgWVZfTF8xXzEgKiAocG9zTG93IC0gbG9va0F0TG93KSxcXG4gICAgICAgIDAsXFxuICAgICAgICAxXFxuICAgICk7XFxuICAgIHBvc2l0aW9uID0gdmVjNChwb3NpdGlvbi54eSAvIHBvc2l0aW9uLncsIDAuMCwgMS4wKTtcXG5cXG4gICAgcmV0dXJuIHBvc2l0aW9uICsgdmVjNChkaXNwbGFjZW1lbnQgKiBweFNpemUsIDAuMCwgMC4wKTtcXG59XFxuXFxuXFxuXFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gICAgdmVjMiBpZFRleENvb3JkaW5hdGUgPSB2ZXJ0ZXhJZC54eSArIGlkSGFsZlB4U2l6ZTtcXG4gICAgZmxvYXQgb3ZlcmxhcFpvb20gPSB0ZXh0dXJlMkQodmlzaWJpbGl0eSwgaWRUZXhDb29yZGluYXRlKS5iO1xcbiAgICBpZiAoY3VycmVudFpvb20gPCBvdmVybGFwWm9vbSkge1xcbiAgICAgICAgZ2xfUG9zaXRpb24gPSBESVNDQVJEX1BPU0lUSU9OO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0UG9pbnRMYWJlbFZlcnRleF8xXzIoXFxuICAgICAgICAgICAgdmlld1Byb2pNYXRyaXgsXFxuICAgICAgICAgICAgbG9va0F0SGlnaCxcXG4gICAgICAgICAgICBsb29rQXRMb3csXFxuICAgICAgICAgICAgdmVydGV4UG9zSGlnaCxcXG4gICAgICAgICAgICB2ZXJ0ZXhQb3NMb3csXFxuICAgICAgICAgICAgdmVydGV4RGlzcGxhY2VtZW50LFxcbiAgICAgICAgICAgIHBpeGVsU2l6ZVxcbiAgICAgICAgKTtcXG4gICAgICAgIGdsX1Bvc2l0aW9uLnh5ICs9IHNoaWZ0O1xcbiAgICAgICAgZ2xfUG9zaXRpb24ueiA9IHZlcnRleFByaW9yaXR5O1xcbiAgICAgICAgY29sb3IgPSB2ZWM0KHZlcnRleElkLCAwLCAxKTtcXG4gICAgfVxcblxcbn1cXG5cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3Zpc2liaWxpdHkvcHJpbWl0aXZlcy9sYWJlbC9zaGFkZXIvcG9pbnRfbGFiZWwudmVydFxuLy8gbW9kdWxlIGlkID0gMTExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBSZW5kZXJTdGF0ZSBmcm9tICcuLi8uLi9yZW5kZXIvc3RhdGUnO1xyXG5pbXBvcnQgKiBhcyB2ZWMyIGZyb20gJy4uLy4uL21hdGgvdmVjdG9yMic7XHJcbmltcG9ydCBXb3JsZFByaW1pdGl2ZVJlbmRlclVuaXQgZnJvbSAnLi4vLi4vcmVuZGVyL3ByaW1pdGl2ZXMvd29ybGRfcHJpbWl0aXZlX3JlbmRlcl91bml0JztcclxuZXhwb3J0IGNsYXNzIENvbGxpZGluZ1ByaW1pdGl2ZUNvbG9ySWRSZW5kZXJlciBleHRlbmRzIFdvcmxkUHJpbWl0aXZlUmVuZGVyVW5pdCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBwcm9ncmFtLCBwcmltaXRpdmVQcm92aWRlcikge1xyXG4gICAgICAgIHN1cGVyKGNvbnRleHQsIG5ldyBSZW5kZXJTdGF0ZSgpLCBwcm9ncmFtLCBwcmltaXRpdmVQcm92aWRlcik7XHJcbiAgICAgICAgdGhpcy5faWRIYWxmUHhTaXplVW5pZm9ybSA9IHZlYzIuY3JlYXRlKDAsIDApO1xyXG4gICAgfVxyXG4gICAgX2dldFByaW1pdGl2ZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHJpbWl0aXZlUHJvdmlkZXIudmlzaWJsZVByaW1pdGl2ZXM7XHJcbiAgICB9XHJcbiAgICBfcHJlcGFyZVByb2dyYW0ocHJvZ3JhbSwgdmlld1Byb2pNYXRyaXgsIGNhbWVyYVBvc2l0aW9ucywgc3RhdGUsIHN0YWJpbGl0eVNoaWZ0LCB2aXNpYmlsaXR5LCBjdXJyZW50Wm9vbSkge1xyXG4gICAgICAgIHN1cGVyLl9wcmVwYXJlUHJvZ3JhbShwcm9ncmFtLCB2aWV3UHJvak1hdHJpeCwgY2FtZXJhUG9zaXRpb25zLCBzdGF0ZSwgc3RhYmlsaXR5U2hpZnQsIHZpc2liaWxpdHksIGN1cnJlbnRab29tKTtcclxuICAgICAgICB0aGlzLl9pZEhhbGZQeFNpemVVbmlmb3JtLnggPSAwLjUgLyB2aXNpYmlsaXR5LmdldFdpZHRoKCk7XHJcbiAgICAgICAgdGhpcy5faWRIYWxmUHhTaXplVW5pZm9ybS55ID0gMC41IC8gdmlzaWJpbGl0eS5nZXRIZWlnaHQoKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRUZXh0dXJlVW5pdCgwKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRUZXh0dXJlKHZpc2liaWxpdHkpO1xyXG4gICAgICAgIHByb2dyYW0uc2V0SW50U2NhbGFyVW5pZm9ybSgndmlzaWJpbGl0eScsIDApO1xyXG4gICAgICAgIHByb2dyYW0uc2V0VmVjdG9yMlVuaWZvcm0oJ2lkSGFsZlB4U2l6ZScsIHRoaXMuX2lkSGFsZlB4U2l6ZVVuaWZvcm0pO1xyXG4gICAgICAgIHByb2dyYW0uc2V0VmVjdG9yMlVuaWZvcm0oJ3NoaWZ0Jywgc3RhYmlsaXR5U2hpZnQpO1xyXG4gICAgICAgIHByb2dyYW0uc2V0U2NhbGFyVW5pZm9ybSgnY3VycmVudFpvb20nLCBjdXJyZW50Wm9vbSk7XHJcbiAgICB9XHJcbiAgICBfcHJlcGFyZVJlbmRlclRhcmdldCh0YXJnZXQsIF92aWV3UHJvak1hdHJpeCwgX2NhbWVyYVBvc2l0aW9ucywgc3RhdGUsIF9zdGFiaWxpdHlTaGlmdCwgX3Zpc2liaWxpdHksIF9jdXJyZW50Wm9vbSkge1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFJlbmRlclN0YXRlKHN0YXRlKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRSZW5kZXJUYXJnZXQodGFyZ2V0KTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS92aXNpYmlsaXR5L3ByaW1pdGl2ZXMvY29sbGlkaW5nX3ByaW1pdGl2ZV9jb2xvcl9pZF9yZW5kZXJlci50c1xuLy8gbW9kdWxlIGlkID0gMTEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiBBcHBlbmRzIHBvcnRpb24gb2YgbWVtb3J5IHRvIGJhdGNoIGlmIHRoZXkgYXJlIGFkamFjZW50LlxyXG4gKlxyXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgYm90aCBwYXJhbXMgYXJlIGFkamFjZW50IGFuZCB0aGUgYmF0Y2ggd2FzIHN1Y2Nlc3NmdWxseSB1cGRhdGVkLCBgZmFsc2VgIG90aGVyd2lzZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRUb0JhdGNoKG1lbW9yeUxvY2F0aW9uLCBiYXRjaCkge1xyXG4gICAgaWYgKGJhdGNoLnZlcnRleEJ5dGVPZmZzZXQgKyBiYXRjaC52ZXJ0ZXhCeXRlTGVuZ3RoID09PSBtZW1vcnlMb2NhdGlvbi52ZXJ0ZXhCeXRlT2Zmc2V0ICYmXHJcbiAgICAgICAgYmF0Y2guaW5kZXhCeXRlT2Zmc2V0ICsgYmF0Y2guaW5kZXhCeXRlTGVuZ3RoID09PSBtZW1vcnlMb2NhdGlvbi5pbmRleEJ5dGVPZmZzZXQpIHtcclxuICAgICAgICBiYXRjaC52ZXJ0ZXhCeXRlTGVuZ3RoICs9IG1lbW9yeUxvY2F0aW9uLnZlcnRleEJ5dGVMZW5ndGg7XHJcbiAgICAgICAgYmF0Y2guaW5kZXhCeXRlTGVuZ3RoICs9IG1lbW9yeUxvY2F0aW9uLmluZGV4Qnl0ZUxlbmd0aDtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG4vKipcclxuICogQ29tYmluZXMgb2JqZWN0cyBhbGxvY2F0ZWQgaW4gbWVtb3J5IGludG8gYmF0Y2hlcy4gTm8gc29ydGluZyBpcyBkb25lIGluIHRoaXMgbWV0aG9kLCB0aGUgb2JqZWN0cyBhcmUgc3VwcG9zZWRcclxuICogdG8gYmUgc29ydGVkIGJ5IGluZGV4L3ZlcnRleCBvZmZzZXRzIHRvIG1ha2UgYmF0Y2hpbmcgZWZmZWN0aXZlLiBUaGUgYmF0Y2ggaXMgY3JlYXRlZCBieSBmYWN0b3J5IHNpbmNlIGl0IGNhblxyXG4gKiBjb250YWlucyBwcm9ibGVtIHNwZWNpZmljIGluZm9ybWF0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0gb2JqZWN0cyBMaXN0IG9mIGFsbG9jYXRlZCBvYmplY3RzLlxyXG4gKiBAcGFyYW0gZ2V0TWVtb3J5TG9jYXRpb24gUmV0dXJucyBtZW1vcnkgbG9jYXRpb24gb2Ygc3BlY2lmaWMgb2JqZWN0LlxyXG4gKiBAcGFyYW0gY3JlYXRlQmF0Y2ggSW5pdGlhdGVzIGJhdGNoIGJ5IHRoZSBmaXJzdCBvYmplY3QuXHJcbiAqIEBwYXJhbSBjYW5CYXRjaCBDaGVja3MgaWYgdHdvIG9iamVjdHMgY2FuIGJlIGFsbG9jYXRlZC5cclxuICogQHJldHVybnMgSXRlcmFibGUgbGlzdCBvZiBiYXRjaGVzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uKiBiYXRjaEFsbG9jYXRlZE9iamVjdHMob2JqZWN0cywgZ2V0TWVtb3J5TG9jYXRpb24sIGNyZWF0ZUJhdGNoLCBjYW5CYXRjaCA9ICgpID0+IHRydWUpIHtcclxuICAgIGNvbnN0IGl0ZXJhdG9yID0gb2JqZWN0c1tTeW1ib2wuaXRlcmF0b3JdKCk7XHJcbiAgICBsZXQgcHJpbWl0aXZlID0gaXRlcmF0b3IubmV4dCgpLnZhbHVlO1xyXG4gICAgaWYgKCFwcmltaXRpdmUpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBsZXQgcHJldiA9IHByaW1pdGl2ZTtcclxuICAgIGxldCBiYXRjaCA9IGNyZWF0ZUJhdGNoKHByZXYpO1xyXG4gICAgcHJpbWl0aXZlID0gaXRlcmF0b3IubmV4dCgpLnZhbHVlO1xyXG4gICAgd2hpbGUgKHByaW1pdGl2ZSkge1xyXG4gICAgICAgIGNvbnN0IHByaW1pdGl2ZU1lbW9yeUxvY2F0aW9uID0gZ2V0TWVtb3J5TG9jYXRpb24ocHJpbWl0aXZlKTtcclxuICAgICAgICBpZiAoIWNhbkJhdGNoKHByZXYsIHByaW1pdGl2ZSwgYmF0Y2gpIHx8ICFhcHBlbmRUb0JhdGNoKHByaW1pdGl2ZU1lbW9yeUxvY2F0aW9uLCBiYXRjaCkpIHtcclxuICAgICAgICAgICAgeWllbGQgYmF0Y2g7XHJcbiAgICAgICAgICAgIGJhdGNoID0gY3JlYXRlQmF0Y2gocHJpbWl0aXZlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHJldiA9IHByaW1pdGl2ZTtcclxuICAgICAgICBwcmltaXRpdmUgPSBpdGVyYXRvci5uZXh0KCkudmFsdWU7XHJcbiAgICB9XHJcbiAgICB5aWVsZCBiYXRjaDtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvbWVtb3J5L3JlbGF0aXZlX2xvY2F0aW9uLnRzXG4vLyBtb2R1bGUgaWQgPSAxMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcIiN2ZXJzaW9uIDEwMFxcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxuYXR0cmlidXRlIHZlYzIgdmVydGV4SWQ7XFxuXFxuLy8gcG9pbnQgaW4gdGhlIHdvcmxkIHRoZSBsYWJlbCBpcyBhbmNob3JlZCB0b1xcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleFBvc0hpZ2g7XFxuYXR0cmlidXRlIHZlYzIgdmVydGV4UG9zTG93O1xcblxcbi8vIHZlY3RvciBvZiBjb25jcmV0ZSBnbHlwaCBwb2ludCBkaXNwbGFjZW1lbnQgKHRvcC1sZWZ0LCBib3R0b20tbGVmdCwgLi4uKSByZWxhdGl2ZSB0byBsYWJlbCdzIGNlbnRlciwgaW4gcHhcXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhEaXNwbGFjZW1lbnQ7XFxuXFxuLy8gY29vcmRpbmF0ZXMgb2YgdGhlIGdseXBoIHZlcnRleCBpbiB0aGUgYXRsYXNcXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhVVjtcXG5cXG5hdHRyaWJ1dGUgZmxvYXQgdmVydGV4UHJpb3JpdHk7XFxuXFxuYXR0cmlidXRlIGxvd3AgdmVjNCB2ZXJ0ZXhDb2xvcjtcXG5hdHRyaWJ1dGUgbG93cCB2ZWM0IHZlcnRleE91dGxpbmVDb2xvcjtcXG5hdHRyaWJ1dGUgZmxvYXQgdmVydGV4U2NhbGU7XFxuXFxudW5pZm9ybSB2ZWMyIGxvb2tBdEhpZ2g7XFxudW5pZm9ybSB2ZWMyIGxvb2tBdExvdztcXG51bmlmb3JtIG1hdDQgdmlld1Byb2pNYXRyaXg7XFxudW5pZm9ybSB2ZWMyIHBpeGVsU2l6ZTtcXG51bmlmb3JtIHNhbXBsZXIyRCB2aXNpYmlsaXR5O1xcbnVuaWZvcm0gdmVjMiBpZEhhbGZQeFNpemU7XFxudW5pZm9ybSB2ZWMyIHNoaWZ0O1xcbnVuaWZvcm0gbG93cCBmbG9hdCBjdXJyZW50Wm9vbTtcXG5cXG52YXJ5aW5nIHZlYzIgdXY7XFxudmFyeWluZyBsb3dwIHZlYzQgY29sb3I7XFxudmFyeWluZyBsb3dwIHZlYzQgb3V0bGluZUNvbG9yO1xcbnZhcnlpbmcgbWVkaXVtcCBmbG9hdCBzY2FsZTtcXG5cXG5jb25zdCB2ZWM0IERJU0NBUkRfUE9TSVRJT04gPSB2ZWM0KDIsIDIsIDIsIDEpO1xcblxcbmNvbnN0IGZsb2F0IFlWX0hfMV8wID0gMS45OTk5Njk0ODI0MjE4NzU7XFxuY29uc3QgZmxvYXQgWVZfTF8xXzEgPSAwLjAwMDAzMDUxNzExMjQ2MzcxMjY5MjtcXG5cXG4vKipcXG4gKiBQcm9qZWN0cyBzcGVjaWZpYyBwb2ludCBsYWJlbCB2ZXJ0ZXggb250byB0aGUgc2NyZWVuLlxcbiAqL1xcbnZlYzQgcHJvamVjdFBvaW50TGFiZWxWZXJ0ZXhfMV8yKFxcbiAgICBtYXQ0IHZpZXdQcm9qTWF0cml4LFxcbiAgICB2ZWMyIGxvb2tBdEhpZ2gsXFxuICAgIHZlYzIgbG9va0F0TG93LFxcbiAgICB2ZWMyIHBvc0hpZ2gsXFxuICAgIHZlYzIgcG9zTG93LFxcbiAgICB2ZWMyIGRpc3BsYWNlbWVudCxcXG4gICAgdmVjMiBweFNpemVcXG4pIHtcXG4gICAgdmVjNCBwb3NpdGlvbiA9IHZpZXdQcm9qTWF0cml4ICogdmVjNChcXG4gICAgICAgIFlWX0hfMV8wICogKHBvc0hpZ2ggLSBsb29rQXRIaWdoKSArXFxuICAgICAgICAgICAgWVZfTF8xXzEgKiAocG9zTG93IC0gbG9va0F0TG93KSxcXG4gICAgICAgIDAsXFxuICAgICAgICAxXFxuICAgICk7XFxuICAgIHBvc2l0aW9uID0gdmVjNChwb3NpdGlvbi54eSAvIHBvc2l0aW9uLncsIDAuMCwgMS4wKTtcXG5cXG4gICAgcmV0dXJuIHBvc2l0aW9uICsgdmVjNChkaXNwbGFjZW1lbnQgKiBweFNpemUsIDAuMCwgMC4wKTtcXG59XFxuXFxuXFxuXFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gICAgZmxvYXQgdmlzaWJpbGl0eUFscGhhID0gdGV4dHVyZTJEKHZpc2liaWxpdHksIHZlcnRleElkLnh5ICsgaWRIYWxmUHhTaXplKS5hO1xcbiAgICBpZiAodmlzaWJpbGl0eUFscGhhICE9IDAuMCkge1xcbiAgICAgICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0UG9pbnRMYWJlbFZlcnRleF8xXzIoXFxuICAgICAgICAgICAgdmlld1Byb2pNYXRyaXgsXFxuICAgICAgICAgICAgbG9va0F0SGlnaCxcXG4gICAgICAgICAgICBsb29rQXRMb3csXFxuICAgICAgICAgICAgdmVydGV4UG9zSGlnaCxcXG4gICAgICAgICAgICB2ZXJ0ZXhQb3NMb3csXFxuICAgICAgICAgICAgdmVydGV4RGlzcGxhY2VtZW50LFxcbiAgICAgICAgICAgIHBpeGVsU2l6ZVxcbiAgICAgICAgKTtcXG5cXG4gICAgICAgIHV2ID0gdmVydGV4VVY7XFxuICAgICAgICBjb2xvciA9IHZlcnRleENvbG9yO1xcbiAgICAgICAgb3V0bGluZUNvbG9yID0gdmVydGV4T3V0bGluZUNvbG9yO1xcbiAgICAgICAgc2NhbGUgPSB2ZXJ0ZXhTY2FsZTtcXG5cXG4gICAgICAgIGNvbG9yLmEgKj0gdmlzaWJpbGl0eUFscGhhO1xcbiAgICAgICAgb3V0bGluZUNvbG9yLmEgKj0gdmlzaWJpbGl0eUFscGhhO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgZ2xfUG9zaXRpb24gPSBESVNDQVJEX1BPU0lUSU9OO1xcbiAgICB9XFxufVxcblwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvbGFiZWwvc2hhZGVyL3BvaW50X2xhYmVsLnZlcnRcbi8vIG1vZHVsZSBpZCA9IDExNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgcmVjdGFuZ2xlVmVydGV4U2hhZGVyIGZyb20gJy4vc2hhZGVyL2JpbGxib2FyZF9yZWN0YW5nbGUudmVydCc7XHJcbmltcG9ydCByZWN0YW5nbGVGcmFnbWVudFNoYWRlciBmcm9tICcuL3NoYWRlci9iaWxsYm9hcmRfcmVjdGFuZ2xlLmZyYWcnO1xyXG5pbXBvcnQgKiBhcyB2ZWMyIGZyb20gJy4uLy4uLy4uL21hdGgvdmVjdG9yMic7XHJcbmltcG9ydCBXb3JsZFByaW1pdGl2ZVJlbmRlclVuaXQgZnJvbSAnLi4vd29ybGRfcHJpbWl0aXZlX3JlbmRlcl91bml0JztcclxuaW1wb3J0IFJlbmRlclN0YXRlIGZyb20gJy4uLy4uLy4uL3JlbmRlci9zdGF0ZSc7XHJcbmltcG9ydCB7IEJMRU5EX09WRVJfUkVOREVSX1NUQVRFIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyL3N0YXRlJztcclxuY29uc3QgUkVOREVSX1NUQVRFID0gbmV3IFJlbmRlclN0YXRlKEJMRU5EX09WRVJfUkVOREVSX1NUQVRFKTtcclxuLyoqXHJcbiAqIFJlbmRlcmVyIG9mIGJpbGxib2FyZCByZWN0YW5nbGVzLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmlsbGJvYXJkUmVjdGFuZ2xlUmVuZGVyVW5pdCBleHRlbmRzIFdvcmxkUHJpbWl0aXZlUmVuZGVyVW5pdCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBjYW1lcmEsIHZpc2liaWxpdHlQcm92aWRlciwgcHJpbWl0aXZlUHJvdmlkZXIpIHtcclxuICAgICAgICBjb25zdCBwcm9ncmFtID0gY29udGV4dC5jcmVhdGVQcm9ncmFtKHJlY3RhbmdsZVZlcnRleFNoYWRlciwgcmVjdGFuZ2xlRnJhZ21lbnRTaGFkZXIsIHtcclxuICAgICAgICAgICAgYXR0cmliTWFwOiB7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhJZDogMiAvKiBJRCAqLyxcclxuICAgICAgICAgICAgICAgIHZlcnRleFBvc0hpZ2g6IDAgLyogUE9TSVRJT05fSElHSCAqLyxcclxuICAgICAgICAgICAgICAgIHZlcnRleFBvc0xvdzogMSAvKiBQT1NJVElPTl9MT1cgKi8sXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhEaXNwbGFjZW1lbnQ6IDYgLyogRElTUExBQ0VNRU5UICovLFxyXG4gICAgICAgICAgICAgICAgdmVydGV4VVY6IDQgLyogVVYgKi8sXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhDb2xvcjogNyAvKiBDT0xPUiAqLyxcclxuICAgICAgICAgICAgICAgIHZlcnRleEJvcmRlclJhZGlpOiAxMSAvKiBBVVggKi9cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHN1cGVyKGNvbnRleHQsIFJFTkRFUl9TVEFURSwgcHJvZ3JhbSwgcHJpbWl0aXZlUHJvdmlkZXIpO1xyXG4gICAgICAgIHRoaXMuX3Zpc2liaWxpdHlQcm92aWRlciA9IHZpc2liaWxpdHlQcm92aWRlcjtcclxuICAgICAgICB0aGlzLl9jYW1lcmEgPSBjYW1lcmE7XHJcbiAgICAgICAgdGhpcy5fdmlzaWJpbGl0eVNpemVVbmlmb3JtID0gdmVjMi5jcmVhdGUoMCwgMCk7XHJcbiAgICAgICAgY29udGV4dC5iaW5kUHJvZ3JhbShwcm9ncmFtKTtcclxuICAgICAgICBwcm9ncmFtLnNldEludFNjYWxhclVuaWZvcm0oJ3Zpc2liaWxpdHknLCAwKTtcclxuICAgIH1cclxuICAgIF9wcmVwYXJlUHJvZ3JhbShwcm9ncmFtLCB2aWV3UHJvak1hdHJpeCwgY2FtZXJhUG9zaXRpb25zKSB7XHJcbiAgICAgICAgc3VwZXIuX3ByZXBhcmVQcm9ncmFtKHByb2dyYW0sIHZpZXdQcm9qTWF0cml4LCBjYW1lcmFQb3NpdGlvbnMpO1xyXG4gICAgICAgIGNvbnN0IHZpc2liaWxpdHkgPSB0aGlzLl92aXNpYmlsaXR5UHJvdmlkZXIoKTtcclxuICAgICAgICB0aGlzLl92aXNpYmlsaXR5U2l6ZVVuaWZvcm0ueCA9IHZpc2liaWxpdHkuZ2V0V2lkdGgoKTtcclxuICAgICAgICB0aGlzLl92aXNpYmlsaXR5U2l6ZVVuaWZvcm0ueSA9IHZpc2liaWxpdHkuZ2V0SGVpZ2h0KCk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kVGV4dHVyZVVuaXQoMCk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kVGV4dHVyZSh2aXNpYmlsaXR5KTtcclxuICAgICAgICBwcm9ncmFtLnNldFZlY3RvcjJVbmlmb3JtKCd2aXNpYmlsaXR5U2l6ZScsIHRoaXMuX3Zpc2liaWxpdHlTaXplVW5pZm9ybSk7XHJcbiAgICAgICAgcHJvZ3JhbS5zZXRWZWN0b3IyVW5pZm9ybSgncGl4ZWxTaXplJywgdGhpcy5fY2FtZXJhLnBpeGVsU2l6ZSk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvYmlsbGJvYXJkX3JlY3RhbmdsZS9iaWxsYm9hcmRfcmVjdGFuZ2xlX3JlbmRlcl91bml0LnRzXG4vLyBtb2R1bGUgaWQgPSAxMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcIiN2ZXJzaW9uIDEwMFxcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxuYXR0cmlidXRlIHZlYzIgdmVydGV4SWQ7XFxuYXR0cmlidXRlIHZlYzIgdmVydGV4UG9zSGlnaDtcXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhQb3NMb3c7XFxuYXR0cmlidXRlIHZlYzIgdmVydGV4RGlzcGxhY2VtZW50O1xcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleFVWO1xcbmF0dHJpYnV0ZSB2ZWM0IHZlcnRleENvbG9yO1xcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleEJvcmRlclJhZGlpO1xcblxcbnVuaWZvcm0gdmVjMiBsb29rQXRIaWdoO1xcbnVuaWZvcm0gdmVjMiBsb29rQXRMb3c7XFxudW5pZm9ybSBtYXQ0IHZpZXdQcm9qTWF0cml4O1xcbnVuaWZvcm0gdmVjMiBwaXhlbFNpemU7XFxudW5pZm9ybSBzYW1wbGVyMkQgdmlzaWJpbGl0eTtcXG51bmlmb3JtIHZlYzIgdmlzaWJpbGl0eVNpemU7XFxuXFxudmFyeWluZyB2ZWMyIHV2O1xcbnZhcnlpbmcgdmVjNCBjb2xvcjtcXG52YXJ5aW5nIHZlYzIgYm9yZGVyUmFkaWk7XFxuXFxuY29uc3QgdmVjNCBESVNDQVJEX1BPU0lUSU9OID0gdmVjNCgyLCAyLCAyLCAxKTtcXG5jb25zdCBmbG9hdCBZVl9IID0gMS45OTk5Njk0ODI0MjE4NzU7XFxuY29uc3QgZmxvYXQgWVZfTCA9IDAuMDAwMDMwNTE3MTEyNDYzNzEyNjkyO1xcbnZlYzIgVklTSUJJTElUWV9IQUxGX1BYID0gMC41IC8gdmlzaWJpbGl0eVNpemU7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gICAgZmxvYXQgdmlzaWJpbGl0eUFscGhhID0gdGV4dHVyZTJEKHZpc2liaWxpdHksIHZlcnRleElkLnh5ICsgVklTSUJJTElUWV9IQUxGX1BYKS5hO1xcbiAgICBpZiAodmlzaWJpbGl0eUFscGhhID09IDAuMCkge1xcbiAgICAgICAgZ2xfUG9zaXRpb24gPSBESVNDQVJEX1BPU0lUSU9OO1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIHZlYzQgcG9zaXRpb24gPSB2aWV3UHJvak1hdHJpeCAqIHZlYzQoXFxuICAgICAgICBZVl9IICogKHZlcnRleFBvc0hpZ2ggLSBsb29rQXRIaWdoKSArXFxuICAgICAgICAgICAgWVZfTCAqICh2ZXJ0ZXhQb3NMb3cgLSBsb29rQXRMb3cpLFxcbiAgICAgICAgMCxcXG4gICAgICAgIDFcXG4gICAgKTtcXG4gICAgcG9zaXRpb24ueHl6IC89IHBvc2l0aW9uLnc7XFxuICAgIHBvc2l0aW9uLncgPSAxLjA7XFxuXFxuICAgIGdsX1Bvc2l0aW9uID0gcG9zaXRpb24gKyB2ZWM0KHZlcnRleERpc3BsYWNlbWVudCAqIHBpeGVsU2l6ZSwgMC4wLCAwLjApO1xcblxcbiAgICB1diA9IHZlcnRleFVWO1xcbiAgICBjb2xvciA9IHZlcnRleENvbG9yO1xcbiAgICBjb2xvci5hICo9IHZpc2liaWxpdHlBbHBoYTtcXG4gICAgYm9yZGVyUmFkaWkgPSB2ZXJ0ZXhCb3JkZXJSYWRpaTtcXG59XFxuXCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9iaWxsYm9hcmRfcmVjdGFuZ2xlL3NoYWRlci9iaWxsYm9hcmRfcmVjdGFuZ2xlLnZlcnRcbi8vIG1vZHVsZSBpZCA9IDExNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwiI3ZlcnNpb24gMTAwXFxuXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG52YXJ5aW5nIHZlYzIgdXY7XFxudmFyeWluZyB2ZWM0IGNvbG9yO1xcbnZhcnlpbmcgdmVjMiBib3JkZXJSYWRpaTtcXG5cXG5mbG9hdCByb3VuZGVkUmVjdGFuZ2xlKGNvbnN0IGluIHZlYzIgdXYsIGNvbnN0IGluIHZlYzIgcmFkaWkpIHtcXG4gICAgdmVjMiBhYnNVdiA9IGFicyh1dik7XFxuICAgIHZlYzIgcSA9IGFic1V2ICsgcmFkaWkgLSAxLjA7XFxuICAgIHJldHVybiBtaW4ocS54LCBxLnkpID4gMC4wID8gbGVuZ3RoKHEgLyByYWRpaSkgOiBtYXgoYWJzVXYueCwgYWJzVXYueSk7XFxufVxcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIGdsX0ZyYWdDb2xvciA9IHN0ZXAocm91bmRlZFJlY3RhbmdsZSh1diwgYm9yZGVyUmFkaWkpLCAxLjApICogY29sb3I7XFxufVxcblwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvYmlsbGJvYXJkX3JlY3RhbmdsZS9zaGFkZXIvYmlsbGJvYXJkX3JlY3RhbmdsZS5mcmFnXG4vLyBtb2R1bGUgaWQgPSAxMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IGN1cnZlZExhYmVsVmVydGV4U2hhZGVyIGZyb20gJy4vc2hhZGVyL2N1cnZlZF9sYWJlbC52ZXJ0JztcclxuaW1wb3J0IGNvbG9ySWRGcmFnbWVudFNoYWRlciBmcm9tICcuL3NoYWRlci9jb2xvcl9pZC5mcmFnJztcclxuaW1wb3J0IHsgUFJPR1JBTV9PUFRJT05TIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyL3ByaW1pdGl2ZXMvbGFiZWwvY3VydmVkX2xhYmVsX3JlbmRlcl91bml0JztcclxuaW1wb3J0IENvbGxpZGluZ0xhYmVsQ29sb3JJZFJlbmRlcmVyIGZyb20gJy4vY29sb3JfaWRfbGFiZWxfcmVuZGVyZXInO1xyXG4vKipcclxuICogQ3VydmVkIGxhYmVscyByZW5kZXJlciBmb3IgY29sbGlzaW9uIHJlc29sdXRpb24uXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb2xvcklkQ3VydmVkTGFiZWxSZW5kZXJlciBleHRlbmRzIENvbGxpZGluZ0xhYmVsQ29sb3JJZFJlbmRlcmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIGNhbWVyYSwgcHJpbWl0aXZlUHJvdmlkZXIpIHtcclxuICAgICAgICBjb25zdCBwcm9ncmFtID0gY29udGV4dC5jcmVhdGVQcm9ncmFtKGN1cnZlZExhYmVsVmVydGV4U2hhZGVyLCBjb2xvcklkRnJhZ21lbnRTaGFkZXIsIFBST0dSQU1fT1BUSU9OUyk7XHJcbiAgICAgICAgc3VwZXIoY29udGV4dCwgcHJvZ3JhbSwgcHJpbWl0aXZlUHJvdmlkZXIsIGNhbWVyYSk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdmlzaWJpbGl0eS9wcmltaXRpdmVzL2xhYmVsL2NvbG9yX2lkX2N1cnZlZF9sYWJlbF9yZW5kZXJlci50c1xuLy8gbW9kdWxlIGlkID0gMTE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleElkO1xcblxcbi8vIHBvaW50IGluIHRoZSB3b3JsZCB0aGUgbGFiZWwgaXMgYW5jaG9yZWQgdG9cXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhQb3NIaWdoO1xcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleFBvc0xvdztcXG5cXG4vLyB2ZWN0b3Igb2YgY29uY3JldGUgZ2x5cGggcG9pbnQgZGlzcGxhY2VtZW50ICh0b3AtbGVmdCwgYm90dG9tLWxlZnQsIC4uLikgcmVsYXRpdmUgdG8gZ2x5cGgncyBjZW50ZXIgKHR3byB2YWx1ZXMpLFxcbi8vIGFuZCBkaXN0YW5jZSBvZiB0aGUgZ2x5cGggY2VudGVyIHRvIGxhYmVsJ3MgY2VudGVyICh0aGlyZCB2YWx1ZSksIGluIHB4XFxuYXR0cmlidXRlIHZlYzMgdmVydGV4RGlzcGxhY2VtZW50cztcXG5cXG4vLyBjb29yZGluYXRlcyBvZiB0aGUgZ2x5cGggdmVydGV4IGluIHRoZSBhdGxhc1xcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleFVWO1xcblxcbmF0dHJpYnV0ZSBmbG9hdCB2ZXJ0ZXhQcmlvcml0eTtcXG5cXG5hdHRyaWJ1dGUgbG93cCB2ZWM0IHZlcnRleENvbG9yO1xcbmF0dHJpYnV0ZSBsb3dwIHZlYzQgdmVydGV4T3V0bGluZUNvbG9yO1xcbmF0dHJpYnV0ZSB2ZWMyIHBvbHlsaW5lTGVuZ3RoX3ZlcnRleFNjYWxlO1xcblxcbi8vIGRlbHRhcyByZWxhdGl2ZSB0byB0aGUgd29ybGQgcG9pbnQgZW5jb2RlZCBpbiB2ZXJ0ZXhQb3NIaWdoL3ZlcnRleFBvc0xvdyBlbmNvZGVkIHZpYSBsZW5ndGhzIGFuZCBhbmQgYW5nbGVzIG9mXFxuLy8gY29ycmVzcG9uZGluZyB2ZWN0b3JzXFxuYXR0cmlidXRlIHZlYzQgbGVmdFBvbHlsaW5lUmF0aW9zO1xcbmF0dHJpYnV0ZSB2ZWM0IGxlZnRQb2x5bGluZUFuZ2xlcztcXG5hdHRyaWJ1dGUgdmVjNCByaWdodFBvbHlsaW5lUmF0aW9zO1xcbmF0dHJpYnV0ZSB2ZWM0IHJpZ2h0UG9seWxpbmVBbmdsZXM7XFxuXFxudW5pZm9ybSB2ZWMyIGxvb2tBdEhpZ2g7XFxudW5pZm9ybSB2ZWMyIGxvb2tBdExvdztcXG51bmlmb3JtIG1hdDQgdmlld1Byb2pNYXRyaXg7XFxudW5pZm9ybSB2ZWMyIHBpeGVsU2l6ZTtcXG51bmlmb3JtIHNhbXBsZXIyRCB2aXNpYmlsaXR5O1xcbnVuaWZvcm0gdmVjMiBpZEhhbGZQeFNpemU7XFxudW5pZm9ybSB2ZWMyIHNoaWZ0O1xcbnVuaWZvcm0gbG93cCBmbG9hdCBjdXJyZW50Wm9vbTtcXG5cXG52YXJ5aW5nIHZlYzIgdXY7XFxudmFyeWluZyBsb3dwIHZlYzQgY29sb3I7XFxudmFyeWluZyBsb3dwIHZlYzQgb3V0bGluZUNvbG9yO1xcbnZhcnlpbmcgZmxvYXQgc2NhbGU7XFxuXFxuY29uc3QgdmVjNCBESVNDQVJEX1BPU0lUSU9OID0gdmVjNCgyLCAyLCAyLCAxKTtcXG5cXG5jb25zdCBmbG9hdCBZVl9IXzFfMCA9IDEuOTk5OTY5NDgyNDIxODc1O1xcbmNvbnN0IGZsb2F0IFlWX0xfMV8xID0gMC4wMDAwMzA1MTcxMTI0NjM3MTI2OTI7XFxuXFxuY29uc3QgZmxvYXQgUElfMV8yID0gMy4xNDE1OTI3NDEwMTI1NzMyO1xcblxcbmNvbnN0IGludCBNQVhfUE9MWUxJTkVfUE9JTlRTXzFfMyA9IDQ7XFxuY29uc3QgZmxvYXQgSU5GSU5JVFlfMV80ID0gMTAwMDAwMC4wOyAvLyBsYXJnZSBlbm91Z2ggZm9yIGEgc2VnbWVudCBsZW5ndGggdG8gY29uc2lkZXIgaXQgaW5maW5pdHlcXG5cXG4vKipcXG4gKiBSZXR1cm5zIHdvcmxkIGNvb3JkaW5hdGUgKHBsdXMgZGVsdGEpIHByb2plY3RlZCBvbiBzY3JlZW4sIGluIHBpeGVscy5cXG4gKi9cXG52ZWMyIHByb2plY3RfMV81KFxcbiAgICBtYXQ0IHZpZXdQcm9qTWF0cml4LFxcbiAgICB2ZWMyIGxvb2tBdEhpZ2gsXFxuICAgIHZlYzIgbG9va0F0TG93LFxcbiAgICB2ZWMyIHBpeGVsU2l6ZSxcXG4gICAgdmVjMiBwb2ludEhpZ2gsXFxuICAgIHZlYzIgcG9pbnRMb3csXFxuICAgIHZlYzIgZGVsdGFcXG4pIHtcXG4gICAgdmVjNCBwb3NpdGlvbiA9IHZpZXdQcm9qTWF0cml4ICogdmVjNChcXG4gICAgICAgICAgICBZVl9IXzFfMCAqIChwb2ludEhpZ2ggLSBsb29rQXRIaWdoKSArIFlWX0xfMV8xICogKHBvaW50TG93IC0gbG9va0F0TG93KSArIGRlbHRhLFxcbiAgICAgICAgICAgIDAsXFxuICAgICAgICAgICAgMVxcbiAgICAgICAgKTtcXG4gICAgdmVjMiBwcm9qZWN0ZWQgPSBwb3NpdGlvbi54eSAvIHBvc2l0aW9uLnc7XFxuICAgIHJldHVybiBwcm9qZWN0ZWQgLyBwaXhlbFNpemU7XFxufVxcblxcbi8qKlxcbiAqIEVhY2ggcG9pbnQgb2YgdGhlIHBvbHlsaW5lIGlzIGVuY29kZWQgYXMgYSB2ZWN0b3IgZnJvbSB0aGUgcG9seWxpbmUgY2VudGVyIGJ5IGl0cyBub3JtYWxpemVkIGFuZ2xlIGFuZCB0aGUgcmF0aW8gb2ZcXG4gKiBpdHMgbGVuZ3RoIHRvIHRoZSBwb2x5bGluZSdzIGxlbmd0aC5cXG4gKi9cXG52ZWMyIGRlY29kZVBvbHlsaW5lRGVsdGFzXzFfNihmbG9hdCByYXRpbywgZmxvYXQgYW5nbGUsIGZsb2F0IHBvbHlsaW5lTGVuZ3RoKSB7XFxuICAgIC8vIGRlbm9ybWFsaXplIGFuZ2xlIGJhY2sgdG8gcmFkaWFuc1xcbiAgICBmbG9hdCBhID0gYW5nbGUgKiAyLjAgKiBQSV8xXzIgLSBQSV8xXzI7XFxuICAgIC8vIGxlbmd0aCBvZiBhIHZlY3RvclxcbiAgICBmbG9hdCBsZW4gPSByYXRpbyAqIHBvbHlsaW5lTGVuZ3RoO1xcbiAgICAvLyByZXN0b3JlZCBwb2ludCdzICh4LCB5KSBjb29yZGluYXRlc1xcbiAgICByZXR1cm4gdmVjMihjb3MoYSksIHNpbihhKSkgKiBsZW47XFxufVxcblxcbi8qKlxcbiAqIFByb2plY3RzIHNwZWNpZmljIGN1cnZlZCBsYWJlbCB2ZXJ0ZXggb250byB0aGUgc2NyZWVuLiBUaGUgbGFiZWwgaXMgbGF5b3V0ZWQgYnkgY2VudGVyaW5nIHBvbHlsaW5lIGluXFxuICogdGhlIHZlcnRleFBvc0hpZ2gvdmVydGV4UG9zTG93IGFuZCBvdGhlciBwb2ludHMgYXJlIHVzZWQgdG8gZ3VpZGUgY29uY3JldGUgZ3J5cGggdmVydGV4LlxcbiAqIE51bWJlciBvZiBwb2x5bGluZSBwb2ludHMgaXMgaGFyZGNvZGVkIHRvIHBhc3MgdGhlbSBpbiBhdHRyaWJ1dGVzLlxcbiAqL1xcbnZlYzQgcHJvamVjdEN1cnZlZExhYmVsVmVydGV4XzFfNyhcXG4gICAgbWF0NCB2aWV3UHJvak1hdHJpeCxcXG4gICAgdmVjMiBsb29rQXRIaWdoLFxcbiAgICB2ZWMyIGxvb2tBdExvdyxcXG4gICAgdmVjMiBweFNpemUsXFxuICAgIHZlYzIgcG9zSGlnaCxcXG4gICAgdmVjMiBwb3NMb3csXFxuICAgIHZlYzIgZGlzcGxhY2VtZW50LFxcbiAgICBmbG9hdCBsaW5lRGlzcGxhY2VtZW50LFxcbiAgICBmbG9hdCBwb2x5bGluZUxlbmd0aCxcXG4gICAgdmVjNCBsZWZ0UG9seWxpbmVSYXRpb3MsXFxuICAgIHZlYzQgbGVmdFBvbHlsaW5lQW5nbGVzLFxcbiAgICB2ZWM0IHJpZ2h0UG9seWxpbmVSYXRpb3MsXFxuICAgIHZlYzQgcmlnaHRQb2x5bGluZUFuZ2xlc1xcbikge1xcbiAgICB2ZWMyIHBvbHlsaW5lRGVsdGFzW01BWF9QT0xZTElORV9QT0lOVFNfMV8zXTtcXG4gICAgdmVjMiBwb3NpdGlvbiA9IHByb2plY3RfMV81KHZpZXdQcm9qTWF0cml4LCBsb29rQXRIaWdoLCBsb29rQXRMb3csIHB4U2l6ZSwgcG9zSGlnaCwgcG9zTG93LCB2ZWMyKDAsIDApKTtcXG4gICAgZmxvYXQgcmVtYWluaW5nTGVuZ3RoID0gYWJzKGxpbmVEaXNwbGFjZW1lbnQpO1xcbiAgICBmb3IgKGludCBpID0gMDsgaSA8IE1BWF9QT0xZTElORV9QT0lOVFNfMV8zOyBpKyspIHtcXG4gICAgICAgIHZlYzIgcHJvamVjdGVkUG9pbnQ7XFxuXFxuICAgICAgICAvLyBmaWd1cmUgb3V0IHRoZSBkaXJlY3Rpb24gKGxlZnQvcmlnaHQpIGF0IHRoZSBmaXJzdCBzdGVwXFxuICAgICAgICBpZiAoaSA9PSAwKSB7XFxuICAgICAgICAgICAgcHJvamVjdGVkUG9pbnQgPSBwcm9qZWN0XzFfNShcXG4gICAgICAgICAgICAgICAgdmlld1Byb2pNYXRyaXgsXFxuICAgICAgICAgICAgICAgIGxvb2tBdEhpZ2gsXFxuICAgICAgICAgICAgICAgIGxvb2tBdExvdyxcXG4gICAgICAgICAgICAgICAgcHhTaXplLFxcbiAgICAgICAgICAgICAgICBwb3NIaWdoLFxcbiAgICAgICAgICAgICAgICBwb3NMb3csXFxuICAgICAgICAgICAgICAgIGRlY29kZVBvbHlsaW5lRGVsdGFzXzFfNihyaWdodFBvbHlsaW5lUmF0aW9zWzBdLCByaWdodFBvbHlsaW5lQW5nbGVzWzBdLCBwb2x5bGluZUxlbmd0aClcXG4gICAgICAgICAgICApO1xcbiAgICAgICAgICAgIGJvb2wgaXNSaWdodFBhcnQgPSBsaW5lRGlzcGxhY2VtZW50ID4gMC4wO1xcbiAgICAgICAgICAgIGJvb2wgaXNJbnZlcnRlZCA9IHByb2plY3RlZFBvaW50LnggPCBwb3NpdGlvbi54O1xcblxcbiAgICAgICAgICAgIC8vIHRoZSBtYXAgY291bGQgYmUgcm90YXRlZCBhbmQgY3VydmVkIGxhYmVsIHNob3VsZCBjaGFuZ2UgaXRzIGRpcmVjdGlvbiBpZiB0aGV5IGdvdCB1cHNpZGUgZG93blxcbiAgICAgICAgICAgIC8vIHVzaW5nIGNlbnRlciBzZWdtZW50IHRvIGlkZW50aWZ5IHRoaXMgY2FzZSBpcyBhbiBhcHByb3hpbWF0aW9uIChpZGVhbGx5IHdlIHNob3VsZCBjaGVjayBhbGwgc2VnbWVudHMpXFxuICAgICAgICAgICAgaWYgKGlzUmlnaHRQYXJ0IF5eIGlzSW52ZXJ0ZWQpIHtcXG4gICAgICAgICAgICAgICAgcG9seWxpbmVEZWx0YXNbMF0gPSBkZWNvZGVQb2x5bGluZURlbHRhc18xXzYocmlnaHRQb2x5bGluZVJhdGlvc1swXSwgcmlnaHRQb2x5bGluZUFuZ2xlc1swXSwgcG9seWxpbmVMZW5ndGgpO1xcbiAgICAgICAgICAgICAgICBwb2x5bGluZURlbHRhc1sxXSA9IGRlY29kZVBvbHlsaW5lRGVsdGFzXzFfNihyaWdodFBvbHlsaW5lUmF0aW9zWzFdLCByaWdodFBvbHlsaW5lQW5nbGVzWzFdLCBwb2x5bGluZUxlbmd0aCk7XFxuICAgICAgICAgICAgICAgIHBvbHlsaW5lRGVsdGFzWzJdID0gZGVjb2RlUG9seWxpbmVEZWx0YXNfMV82KHJpZ2h0UG9seWxpbmVSYXRpb3NbMl0sIHJpZ2h0UG9seWxpbmVBbmdsZXNbMl0sIHBvbHlsaW5lTGVuZ3RoKTtcXG4gICAgICAgICAgICAgICAgcG9seWxpbmVEZWx0YXNbM10gPSBkZWNvZGVQb2x5bGluZURlbHRhc18xXzYocmlnaHRQb2x5bGluZVJhdGlvc1szXSwgcmlnaHRQb2x5bGluZUFuZ2xlc1szXSwgcG9seWxpbmVMZW5ndGgpO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHBvbHlsaW5lRGVsdGFzWzBdID0gZGVjb2RlUG9seWxpbmVEZWx0YXNfMV82KGxlZnRQb2x5bGluZVJhdGlvc1swXSwgbGVmdFBvbHlsaW5lQW5nbGVzWzBdLCBwb2x5bGluZUxlbmd0aCk7XFxuICAgICAgICAgICAgICAgIHBvbHlsaW5lRGVsdGFzWzFdID0gZGVjb2RlUG9seWxpbmVEZWx0YXNfMV82KGxlZnRQb2x5bGluZVJhdGlvc1sxXSwgbGVmdFBvbHlsaW5lQW5nbGVzWzFdLCBwb2x5bGluZUxlbmd0aCk7XFxuICAgICAgICAgICAgICAgIHBvbHlsaW5lRGVsdGFzWzJdID0gZGVjb2RlUG9seWxpbmVEZWx0YXNfMV82KGxlZnRQb2x5bGluZVJhdGlvc1syXSwgbGVmdFBvbHlsaW5lQW5nbGVzWzJdLCBwb2x5bGluZUxlbmd0aCk7XFxuICAgICAgICAgICAgICAgIHBvbHlsaW5lRGVsdGFzWzNdID0gZGVjb2RlUG9seWxpbmVEZWx0YXNfMV82KGxlZnRQb2x5bGluZVJhdGlvc1szXSwgbGVmdFBvbHlsaW5lQW5nbGVzWzNdLCBwb2x5bGluZUxlbmd0aCk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIC8vIHRoZSBmaXJzdCByaWdodCBwb2ludCBvZiB0aGUgc2VnbWVudCBhbHJlYWR5IGNhbGN1bGF0ZWQsXFxuICAgICAgICAgICAgLy8gcmVjYWxjdWxhdGUgdGhlIHBvaW50IGlmIHRoaXMgcGFydCBvZiB0aGUgbGFiZWwgZ29lcyBvdGhlciBkaXJlY3Rpb25cXG4gICAgICAgICAgICBpZiAoIShpc1JpZ2h0UGFydCAmJiAhaXNJbnZlcnRlZCkgJiYgISghaXNSaWdodFBhcnQgJiYgaXNJbnZlcnRlZCkpIHtcXG4gICAgICAgICAgICAgICAgcHJvamVjdGVkUG9pbnQgPSBwcm9qZWN0XzFfNSh2aWV3UHJvak1hdHJpeCwgbG9va0F0SGlnaCwgbG9va0F0TG93LCBweFNpemUsIHBvc0hpZ2gsIHBvc0xvdywgcG9seWxpbmVEZWx0YXNbaV0pO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgcHJvamVjdGVkUG9pbnQgPSBwcm9qZWN0XzFfNSh2aWV3UHJvak1hdHJpeCwgbG9va0F0SGlnaCwgbG9va0F0TG93LCBweFNpemUsIHBvc0hpZ2gsIHBvc0xvdywgcG9seWxpbmVEZWx0YXNbaV0pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdmVjMiBzZWdtZW50ID0gcHJvamVjdGVkUG9pbnQgLSBwb3NpdGlvbjtcXG4gICAgICAgIGJvb2wgaXNMYXN0ID0gaSA9PSAoTUFYX1BPTFlMSU5FX1BPSU5UU18xXzMgLSAxKTtcXG4gICAgICAgIGZsb2F0IHNlZ21lbnRMZW5ndGggPSAoaXNMYXN0IHx8IChwb2x5bGluZURlbHRhc1tpICsgMV0gPT0gdmVjMigwLCAwKSkpID8gSU5GSU5JVFlfMV80IDogbGVuZ3RoKHNlZ21lbnQpO1xcblxcbiAgICAgICAgaWYgKHNlZ21lbnRMZW5ndGggPiByZW1haW5pbmdMZW5ndGgpIHtcXG4gICAgICAgICAgICBmbG9hdCBzaWduRmFjdG9yID0gbGluZURpc3BsYWNlbWVudCA+IDAuMCA/IDEuMCA6IC0xLjA7XFxuICAgICAgICAgICAgdmVjMiBkaXJlY3Rpb24gPSBub3JtYWxpemUoc2VnbWVudCk7XFxuICAgICAgICAgICAgdmVjMiBub3JtYWwgPSB2ZWMyKC1kaXJlY3Rpb24ueSwgZGlyZWN0aW9uLngpO1xcblxcbiAgICAgICAgICAgIHBvc2l0aW9uICs9IGRpcmVjdGlvbiAqIHJlbWFpbmluZ0xlbmd0aDtcXG4gICAgICAgICAgICBwb3NpdGlvbiArPSBzaWduRmFjdG9yICogZGlyZWN0aW9uICogZGlzcGxhY2VtZW50Lng7XFxuICAgICAgICAgICAgcG9zaXRpb24gKz0gc2lnbkZhY3RvciAqIG5vcm1hbCAqIGRpc3BsYWNlbWVudC55O1xcblxcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICByZW1haW5pbmdMZW5ndGggLT0gc2VnbWVudExlbmd0aDtcXG4gICAgICAgICAgICBwb3NpdGlvbiArPSBzZWdtZW50O1xcbiAgICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHJldHVybiB2ZWM0KHBvc2l0aW9uICogcHhTaXplLCAwLjAsIDEuMCk7XFxufVxcblxcblxcblxcblxcblxcbi8qKlxcbiAqIEN1cnZlZCBsYWJlbHMgYXJlIGxheW91dGVkIGhlcmU6IHRoZSBsYWJlbCBpcyBjZW50ZXJlZCBpbiB0aGUgdmVydGV4UG9zSGlnaC92ZXJ0ZXhQb3NMb3cgYW5kIHBvbHlsaW5lIHBvaW50c1xcbiAqIGFyZSB1c2VkIHRvIGd1aWRlIGNvbmNyZXRlIGdyeXBoIHZlcnRleC4gTnVtYmVyIG9mIHBvbHlsaW5lIHBvaW50cyBpcyBoYXJkY29kZWQgdG8gcGFzcyB0aGVtIGluIGF0dHJpYnV0ZXMuXFxuICovXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gICAgdmVjMiBpZFRleENvb3JkaW5hdGUgPSB2ZXJ0ZXhJZC54eSArIGlkSGFsZlB4U2l6ZTtcXG4gICAgZmxvYXQgb3ZlcmxhcFpvb20gPSB0ZXh0dXJlMkQodmlzaWJpbGl0eSwgaWRUZXhDb29yZGluYXRlKS5iO1xcblxcbiAgICBpZiAoY3VycmVudFpvb20gPCBvdmVybGFwWm9vbSkge1xcbiAgICAgICAgZ2xfUG9zaXRpb24gPSBESVNDQVJEX1BPU0lUSU9OO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgdmVjMiB2ZXJ0ZXhEaXNwbGFjZW1lbnQgPSB2ZXJ0ZXhEaXNwbGFjZW1lbnRzLnh5O1xcbiAgICAgICAgZmxvYXQgdmVydGV4TGluZURpc3BsYWNlbWVudCA9IHZlcnRleERpc3BsYWNlbWVudHMuejtcXG4gICAgICAgIGZsb2F0IHBvbHlsaW5lTGVuZ3RoID0gcG9seWxpbmVMZW5ndGhfdmVydGV4U2NhbGVbMF07XFxuICAgICAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3RDdXJ2ZWRMYWJlbFZlcnRleF8xXzcoXFxuICAgICAgICAgICAgdmlld1Byb2pNYXRyaXgsXFxuICAgICAgICAgICAgbG9va0F0SGlnaCxcXG4gICAgICAgICAgICBsb29rQXRMb3csXFxuICAgICAgICAgICAgcGl4ZWxTaXplLFxcbiAgICAgICAgICAgIHZlcnRleFBvc0hpZ2gsXFxuICAgICAgICAgICAgdmVydGV4UG9zTG93LFxcbiAgICAgICAgICAgIHZlcnRleERpc3BsYWNlbWVudCxcXG4gICAgICAgICAgICB2ZXJ0ZXhMaW5lRGlzcGxhY2VtZW50LFxcbiAgICAgICAgICAgIHBvbHlsaW5lTGVuZ3RoLFxcbiAgICAgICAgICAgIGxlZnRQb2x5bGluZVJhdGlvcyxcXG4gICAgICAgICAgICBsZWZ0UG9seWxpbmVBbmdsZXMsXFxuICAgICAgICAgICAgcmlnaHRQb2x5bGluZVJhdGlvcyxcXG4gICAgICAgICAgICByaWdodFBvbHlsaW5lQW5nbGVzXFxuICAgICAgICApO1xcblxcbiAgICAgICAgZ2xfUG9zaXRpb24ueHkgKz0gc2hpZnQ7XFxuICAgICAgICBnbF9Qb3NpdGlvbi56ID0gdmVydGV4UHJpb3JpdHk7XFxuXFxuICAgICAgICBjb2xvciA9IHZlYzQodmVydGV4SWQsIDAsIDEpO1xcbiAgICB9XFxufVxcblwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdmlzaWJpbGl0eS9wcmltaXRpdmVzL2xhYmVsL3NoYWRlci9jdXJ2ZWRfbGFiZWwudmVydFxuLy8gbW9kdWxlIGlkID0gMTE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleElkO1xcblxcbi8vIHBvaW50IGluIHRoZSB3b3JsZCB0aGUgbGFiZWwgaXMgYW5jaG9yZWQgdG9cXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhQb3NIaWdoO1xcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleFBvc0xvdztcXG5cXG4vLyB2ZWN0b3Igb2YgY29uY3JldGUgZ2x5cGggcG9pbnQgZGlzcGxhY2VtZW50ICh0b3AtbGVmdCwgYm90dG9tLWxlZnQsIC4uLikgcmVsYXRpdmUgdG8gZ2x5cGgncyBjZW50ZXIgKHR3byB2YWx1ZXMpLFxcbi8vIGFuZCBkaXN0YW5jZSBvZiB0aGUgZ2x5cGggY2VudGVyIHRvIGxhYmVsJ3MgY2VudGVyICh0aGlyZCB2YWx1ZSksIGluIHB4XFxuYXR0cmlidXRlIHZlYzMgdmVydGV4RGlzcGxhY2VtZW50cztcXG5cXG4vLyBjb29yZGluYXRlcyBvZiB0aGUgZ2x5cGggdmVydGV4IGluIHRoZSBhdGxhc1xcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleFVWO1xcblxcbmF0dHJpYnV0ZSBmbG9hdCB2ZXJ0ZXhQcmlvcml0eTtcXG5cXG5hdHRyaWJ1dGUgbG93cCB2ZWM0IHZlcnRleENvbG9yO1xcbmF0dHJpYnV0ZSBsb3dwIHZlYzQgdmVydGV4T3V0bGluZUNvbG9yO1xcbmF0dHJpYnV0ZSB2ZWMyIHBvbHlsaW5lTGVuZ3RoX3ZlcnRleFNjYWxlO1xcblxcbi8vIGRlbHRhcyByZWxhdGl2ZSB0byB0aGUgd29ybGQgcG9pbnQgZW5jb2RlZCBpbiB2ZXJ0ZXhQb3NIaWdoL3ZlcnRleFBvc0xvdyBlbmNvZGVkIHZpYSBsZW5ndGhzIGFuZCBhbmQgYW5nbGVzIG9mXFxuLy8gY29ycmVzcG9uZGluZyB2ZWN0b3JzXFxuYXR0cmlidXRlIHZlYzQgbGVmdFBvbHlsaW5lUmF0aW9zO1xcbmF0dHJpYnV0ZSB2ZWM0IGxlZnRQb2x5bGluZUFuZ2xlcztcXG5hdHRyaWJ1dGUgdmVjNCByaWdodFBvbHlsaW5lUmF0aW9zO1xcbmF0dHJpYnV0ZSB2ZWM0IHJpZ2h0UG9seWxpbmVBbmdsZXM7XFxuXFxudW5pZm9ybSB2ZWMyIGxvb2tBdEhpZ2g7XFxudW5pZm9ybSB2ZWMyIGxvb2tBdExvdztcXG51bmlmb3JtIG1hdDQgdmlld1Byb2pNYXRyaXg7XFxudW5pZm9ybSB2ZWMyIHBpeGVsU2l6ZTtcXG51bmlmb3JtIHNhbXBsZXIyRCB2aXNpYmlsaXR5O1xcbnVuaWZvcm0gdmVjMiBpZEhhbGZQeFNpemU7XFxudW5pZm9ybSB2ZWMyIHNoaWZ0O1xcbnVuaWZvcm0gbG93cCBmbG9hdCBjdXJyZW50Wm9vbTtcXG5cXG52YXJ5aW5nIHZlYzIgdXY7XFxudmFyeWluZyBsb3dwIHZlYzQgY29sb3I7XFxudmFyeWluZyBsb3dwIHZlYzQgb3V0bGluZUNvbG9yO1xcbnZhcnlpbmcgZmxvYXQgc2NhbGU7XFxuXFxuY29uc3QgdmVjNCBESVNDQVJEX1BPU0lUSU9OID0gdmVjNCgyLCAyLCAyLCAxKTtcXG5cXG5jb25zdCBmbG9hdCBZVl9IXzFfMCA9IDEuOTk5OTY5NDgyNDIxODc1O1xcbmNvbnN0IGZsb2F0IFlWX0xfMV8xID0gMC4wMDAwMzA1MTcxMTI0NjM3MTI2OTI7XFxuXFxuY29uc3QgZmxvYXQgUElfMV8yID0gMy4xNDE1OTI3NDEwMTI1NzMyO1xcblxcbmNvbnN0IGludCBNQVhfUE9MWUxJTkVfUE9JTlRTXzFfMyA9IDQ7XFxuY29uc3QgZmxvYXQgSU5GSU5JVFlfMV80ID0gMTAwMDAwMC4wOyAvLyBsYXJnZSBlbm91Z2ggZm9yIGEgc2VnbWVudCBsZW5ndGggdG8gY29uc2lkZXIgaXQgaW5maW5pdHlcXG5cXG4vKipcXG4gKiBSZXR1cm5zIHdvcmxkIGNvb3JkaW5hdGUgKHBsdXMgZGVsdGEpIHByb2plY3RlZCBvbiBzY3JlZW4sIGluIHBpeGVscy5cXG4gKi9cXG52ZWMyIHByb2plY3RfMV81KFxcbiAgICBtYXQ0IHZpZXdQcm9qTWF0cml4LFxcbiAgICB2ZWMyIGxvb2tBdEhpZ2gsXFxuICAgIHZlYzIgbG9va0F0TG93LFxcbiAgICB2ZWMyIHBpeGVsU2l6ZSxcXG4gICAgdmVjMiBwb2ludEhpZ2gsXFxuICAgIHZlYzIgcG9pbnRMb3csXFxuICAgIHZlYzIgZGVsdGFcXG4pIHtcXG4gICAgdmVjNCBwb3NpdGlvbiA9IHZpZXdQcm9qTWF0cml4ICogdmVjNChcXG4gICAgICAgICAgICBZVl9IXzFfMCAqIChwb2ludEhpZ2ggLSBsb29rQXRIaWdoKSArIFlWX0xfMV8xICogKHBvaW50TG93IC0gbG9va0F0TG93KSArIGRlbHRhLFxcbiAgICAgICAgICAgIDAsXFxuICAgICAgICAgICAgMVxcbiAgICAgICAgKTtcXG4gICAgdmVjMiBwcm9qZWN0ZWQgPSBwb3NpdGlvbi54eSAvIHBvc2l0aW9uLnc7XFxuICAgIHJldHVybiBwcm9qZWN0ZWQgLyBwaXhlbFNpemU7XFxufVxcblxcbi8qKlxcbiAqIEVhY2ggcG9pbnQgb2YgdGhlIHBvbHlsaW5lIGlzIGVuY29kZWQgYXMgYSB2ZWN0b3IgZnJvbSB0aGUgcG9seWxpbmUgY2VudGVyIGJ5IGl0cyBub3JtYWxpemVkIGFuZ2xlIGFuZCB0aGUgcmF0aW8gb2ZcXG4gKiBpdHMgbGVuZ3RoIHRvIHRoZSBwb2x5bGluZSdzIGxlbmd0aC5cXG4gKi9cXG52ZWMyIGRlY29kZVBvbHlsaW5lRGVsdGFzXzFfNihmbG9hdCByYXRpbywgZmxvYXQgYW5nbGUsIGZsb2F0IHBvbHlsaW5lTGVuZ3RoKSB7XFxuICAgIC8vIGRlbm9ybWFsaXplIGFuZ2xlIGJhY2sgdG8gcmFkaWFuc1xcbiAgICBmbG9hdCBhID0gYW5nbGUgKiAyLjAgKiBQSV8xXzIgLSBQSV8xXzI7XFxuICAgIC8vIGxlbmd0aCBvZiBhIHZlY3RvclxcbiAgICBmbG9hdCBsZW4gPSByYXRpbyAqIHBvbHlsaW5lTGVuZ3RoO1xcbiAgICAvLyByZXN0b3JlZCBwb2ludCdzICh4LCB5KSBjb29yZGluYXRlc1xcbiAgICByZXR1cm4gdmVjMihjb3MoYSksIHNpbihhKSkgKiBsZW47XFxufVxcblxcbi8qKlxcbiAqIFByb2plY3RzIHNwZWNpZmljIGN1cnZlZCBsYWJlbCB2ZXJ0ZXggb250byB0aGUgc2NyZWVuLiBUaGUgbGFiZWwgaXMgbGF5b3V0ZWQgYnkgY2VudGVyaW5nIHBvbHlsaW5lIGluXFxuICogdGhlIHZlcnRleFBvc0hpZ2gvdmVydGV4UG9zTG93IGFuZCBvdGhlciBwb2ludHMgYXJlIHVzZWQgdG8gZ3VpZGUgY29uY3JldGUgZ3J5cGggdmVydGV4LlxcbiAqIE51bWJlciBvZiBwb2x5bGluZSBwb2ludHMgaXMgaGFyZGNvZGVkIHRvIHBhc3MgdGhlbSBpbiBhdHRyaWJ1dGVzLlxcbiAqL1xcbnZlYzQgcHJvamVjdEN1cnZlZExhYmVsVmVydGV4XzFfNyhcXG4gICAgbWF0NCB2aWV3UHJvak1hdHJpeCxcXG4gICAgdmVjMiBsb29rQXRIaWdoLFxcbiAgICB2ZWMyIGxvb2tBdExvdyxcXG4gICAgdmVjMiBweFNpemUsXFxuICAgIHZlYzIgcG9zSGlnaCxcXG4gICAgdmVjMiBwb3NMb3csXFxuICAgIHZlYzIgZGlzcGxhY2VtZW50LFxcbiAgICBmbG9hdCBsaW5lRGlzcGxhY2VtZW50LFxcbiAgICBmbG9hdCBwb2x5bGluZUxlbmd0aCxcXG4gICAgdmVjNCBsZWZ0UG9seWxpbmVSYXRpb3MsXFxuICAgIHZlYzQgbGVmdFBvbHlsaW5lQW5nbGVzLFxcbiAgICB2ZWM0IHJpZ2h0UG9seWxpbmVSYXRpb3MsXFxuICAgIHZlYzQgcmlnaHRQb2x5bGluZUFuZ2xlc1xcbikge1xcbiAgICB2ZWMyIHBvbHlsaW5lRGVsdGFzW01BWF9QT0xZTElORV9QT0lOVFNfMV8zXTtcXG4gICAgdmVjMiBwb3NpdGlvbiA9IHByb2plY3RfMV81KHZpZXdQcm9qTWF0cml4LCBsb29rQXRIaWdoLCBsb29rQXRMb3csIHB4U2l6ZSwgcG9zSGlnaCwgcG9zTG93LCB2ZWMyKDAsIDApKTtcXG4gICAgZmxvYXQgcmVtYWluaW5nTGVuZ3RoID0gYWJzKGxpbmVEaXNwbGFjZW1lbnQpO1xcbiAgICBmb3IgKGludCBpID0gMDsgaSA8IE1BWF9QT0xZTElORV9QT0lOVFNfMV8zOyBpKyspIHtcXG4gICAgICAgIHZlYzIgcHJvamVjdGVkUG9pbnQ7XFxuXFxuICAgICAgICAvLyBmaWd1cmUgb3V0IHRoZSBkaXJlY3Rpb24gKGxlZnQvcmlnaHQpIGF0IHRoZSBmaXJzdCBzdGVwXFxuICAgICAgICBpZiAoaSA9PSAwKSB7XFxuICAgICAgICAgICAgcHJvamVjdGVkUG9pbnQgPSBwcm9qZWN0XzFfNShcXG4gICAgICAgICAgICAgICAgdmlld1Byb2pNYXRyaXgsXFxuICAgICAgICAgICAgICAgIGxvb2tBdEhpZ2gsXFxuICAgICAgICAgICAgICAgIGxvb2tBdExvdyxcXG4gICAgICAgICAgICAgICAgcHhTaXplLFxcbiAgICAgICAgICAgICAgICBwb3NIaWdoLFxcbiAgICAgICAgICAgICAgICBwb3NMb3csXFxuICAgICAgICAgICAgICAgIGRlY29kZVBvbHlsaW5lRGVsdGFzXzFfNihyaWdodFBvbHlsaW5lUmF0aW9zWzBdLCByaWdodFBvbHlsaW5lQW5nbGVzWzBdLCBwb2x5bGluZUxlbmd0aClcXG4gICAgICAgICAgICApO1xcbiAgICAgICAgICAgIGJvb2wgaXNSaWdodFBhcnQgPSBsaW5lRGlzcGxhY2VtZW50ID4gMC4wO1xcbiAgICAgICAgICAgIGJvb2wgaXNJbnZlcnRlZCA9IHByb2plY3RlZFBvaW50LnggPCBwb3NpdGlvbi54O1xcblxcbiAgICAgICAgICAgIC8vIHRoZSBtYXAgY291bGQgYmUgcm90YXRlZCBhbmQgY3VydmVkIGxhYmVsIHNob3VsZCBjaGFuZ2UgaXRzIGRpcmVjdGlvbiBpZiB0aGV5IGdvdCB1cHNpZGUgZG93blxcbiAgICAgICAgICAgIC8vIHVzaW5nIGNlbnRlciBzZWdtZW50IHRvIGlkZW50aWZ5IHRoaXMgY2FzZSBpcyBhbiBhcHByb3hpbWF0aW9uIChpZGVhbGx5IHdlIHNob3VsZCBjaGVjayBhbGwgc2VnbWVudHMpXFxuICAgICAgICAgICAgaWYgKGlzUmlnaHRQYXJ0IF5eIGlzSW52ZXJ0ZWQpIHtcXG4gICAgICAgICAgICAgICAgcG9seWxpbmVEZWx0YXNbMF0gPSBkZWNvZGVQb2x5bGluZURlbHRhc18xXzYocmlnaHRQb2x5bGluZVJhdGlvc1swXSwgcmlnaHRQb2x5bGluZUFuZ2xlc1swXSwgcG9seWxpbmVMZW5ndGgpO1xcbiAgICAgICAgICAgICAgICBwb2x5bGluZURlbHRhc1sxXSA9IGRlY29kZVBvbHlsaW5lRGVsdGFzXzFfNihyaWdodFBvbHlsaW5lUmF0aW9zWzFdLCByaWdodFBvbHlsaW5lQW5nbGVzWzFdLCBwb2x5bGluZUxlbmd0aCk7XFxuICAgICAgICAgICAgICAgIHBvbHlsaW5lRGVsdGFzWzJdID0gZGVjb2RlUG9seWxpbmVEZWx0YXNfMV82KHJpZ2h0UG9seWxpbmVSYXRpb3NbMl0sIHJpZ2h0UG9seWxpbmVBbmdsZXNbMl0sIHBvbHlsaW5lTGVuZ3RoKTtcXG4gICAgICAgICAgICAgICAgcG9seWxpbmVEZWx0YXNbM10gPSBkZWNvZGVQb2x5bGluZURlbHRhc18xXzYocmlnaHRQb2x5bGluZVJhdGlvc1szXSwgcmlnaHRQb2x5bGluZUFuZ2xlc1szXSwgcG9seWxpbmVMZW5ndGgpO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHBvbHlsaW5lRGVsdGFzWzBdID0gZGVjb2RlUG9seWxpbmVEZWx0YXNfMV82KGxlZnRQb2x5bGluZVJhdGlvc1swXSwgbGVmdFBvbHlsaW5lQW5nbGVzWzBdLCBwb2x5bGluZUxlbmd0aCk7XFxuICAgICAgICAgICAgICAgIHBvbHlsaW5lRGVsdGFzWzFdID0gZGVjb2RlUG9seWxpbmVEZWx0YXNfMV82KGxlZnRQb2x5bGluZVJhdGlvc1sxXSwgbGVmdFBvbHlsaW5lQW5nbGVzWzFdLCBwb2x5bGluZUxlbmd0aCk7XFxuICAgICAgICAgICAgICAgIHBvbHlsaW5lRGVsdGFzWzJdID0gZGVjb2RlUG9seWxpbmVEZWx0YXNfMV82KGxlZnRQb2x5bGluZVJhdGlvc1syXSwgbGVmdFBvbHlsaW5lQW5nbGVzWzJdLCBwb2x5bGluZUxlbmd0aCk7XFxuICAgICAgICAgICAgICAgIHBvbHlsaW5lRGVsdGFzWzNdID0gZGVjb2RlUG9seWxpbmVEZWx0YXNfMV82KGxlZnRQb2x5bGluZVJhdGlvc1szXSwgbGVmdFBvbHlsaW5lQW5nbGVzWzNdLCBwb2x5bGluZUxlbmd0aCk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIC8vIHRoZSBmaXJzdCByaWdodCBwb2ludCBvZiB0aGUgc2VnbWVudCBhbHJlYWR5IGNhbGN1bGF0ZWQsXFxuICAgICAgICAgICAgLy8gcmVjYWxjdWxhdGUgdGhlIHBvaW50IGlmIHRoaXMgcGFydCBvZiB0aGUgbGFiZWwgZ29lcyBvdGhlciBkaXJlY3Rpb25cXG4gICAgICAgICAgICBpZiAoIShpc1JpZ2h0UGFydCAmJiAhaXNJbnZlcnRlZCkgJiYgISghaXNSaWdodFBhcnQgJiYgaXNJbnZlcnRlZCkpIHtcXG4gICAgICAgICAgICAgICAgcHJvamVjdGVkUG9pbnQgPSBwcm9qZWN0XzFfNSh2aWV3UHJvak1hdHJpeCwgbG9va0F0SGlnaCwgbG9va0F0TG93LCBweFNpemUsIHBvc0hpZ2gsIHBvc0xvdywgcG9seWxpbmVEZWx0YXNbaV0pO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgcHJvamVjdGVkUG9pbnQgPSBwcm9qZWN0XzFfNSh2aWV3UHJvak1hdHJpeCwgbG9va0F0SGlnaCwgbG9va0F0TG93LCBweFNpemUsIHBvc0hpZ2gsIHBvc0xvdywgcG9seWxpbmVEZWx0YXNbaV0pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdmVjMiBzZWdtZW50ID0gcHJvamVjdGVkUG9pbnQgLSBwb3NpdGlvbjtcXG4gICAgICAgIGJvb2wgaXNMYXN0ID0gaSA9PSAoTUFYX1BPTFlMSU5FX1BPSU5UU18xXzMgLSAxKTtcXG4gICAgICAgIGZsb2F0IHNlZ21lbnRMZW5ndGggPSAoaXNMYXN0IHx8IChwb2x5bGluZURlbHRhc1tpICsgMV0gPT0gdmVjMigwLCAwKSkpID8gSU5GSU5JVFlfMV80IDogbGVuZ3RoKHNlZ21lbnQpO1xcblxcbiAgICAgICAgaWYgKHNlZ21lbnRMZW5ndGggPiByZW1haW5pbmdMZW5ndGgpIHtcXG4gICAgICAgICAgICBmbG9hdCBzaWduRmFjdG9yID0gbGluZURpc3BsYWNlbWVudCA+IDAuMCA/IDEuMCA6IC0xLjA7XFxuICAgICAgICAgICAgdmVjMiBkaXJlY3Rpb24gPSBub3JtYWxpemUoc2VnbWVudCk7XFxuICAgICAgICAgICAgdmVjMiBub3JtYWwgPSB2ZWMyKC1kaXJlY3Rpb24ueSwgZGlyZWN0aW9uLngpO1xcblxcbiAgICAgICAgICAgIHBvc2l0aW9uICs9IGRpcmVjdGlvbiAqIHJlbWFpbmluZ0xlbmd0aDtcXG4gICAgICAgICAgICBwb3NpdGlvbiArPSBzaWduRmFjdG9yICogZGlyZWN0aW9uICogZGlzcGxhY2VtZW50Lng7XFxuICAgICAgICAgICAgcG9zaXRpb24gKz0gc2lnbkZhY3RvciAqIG5vcm1hbCAqIGRpc3BsYWNlbWVudC55O1xcblxcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICByZW1haW5pbmdMZW5ndGggLT0gc2VnbWVudExlbmd0aDtcXG4gICAgICAgICAgICBwb3NpdGlvbiArPSBzZWdtZW50O1xcbiAgICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHJldHVybiB2ZWM0KHBvc2l0aW9uICogcHhTaXplLCAwLjAsIDEuMCk7XFxufVxcblxcblxcblxcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIGZsb2F0IHZpc2liaWxpdHlBbHBoYSA9IHRleHR1cmUyRCh2aXNpYmlsaXR5LCB2ZXJ0ZXhJZC54eSArIGlkSGFsZlB4U2l6ZSkuYTtcXG4gICAgaWYgKHZpc2liaWxpdHlBbHBoYSAhPSAwLjApIHtcXG4gICAgICAgIHZlYzIgdmVydGV4RGlzcGxhY2VtZW50ID0gdmVydGV4RGlzcGxhY2VtZW50cy54eTtcXG4gICAgICAgIGZsb2F0IHZlcnRleExpbmVEaXNwbGFjZW1lbnQgPSB2ZXJ0ZXhEaXNwbGFjZW1lbnRzLno7XFxuICAgICAgICBmbG9hdCBwb2x5bGluZUxlbmd0aCA9IHBvbHlsaW5lTGVuZ3RoX3ZlcnRleFNjYWxlWzBdO1xcbiAgICAgICAgZmxvYXQgdmVydGV4U2NhbGUgPSBwb2x5bGluZUxlbmd0aF92ZXJ0ZXhTY2FsZVsxXTtcXG4gICAgICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdEN1cnZlZExhYmVsVmVydGV4XzFfNyhcXG4gICAgICAgICAgICB2aWV3UHJvak1hdHJpeCxcXG4gICAgICAgICAgICBsb29rQXRIaWdoLFxcbiAgICAgICAgICAgIGxvb2tBdExvdyxcXG4gICAgICAgICAgICBwaXhlbFNpemUsXFxuICAgICAgICAgICAgdmVydGV4UG9zSGlnaCxcXG4gICAgICAgICAgICB2ZXJ0ZXhQb3NMb3csXFxuICAgICAgICAgICAgdmVydGV4RGlzcGxhY2VtZW50LFxcbiAgICAgICAgICAgIHZlcnRleExpbmVEaXNwbGFjZW1lbnQsXFxuICAgICAgICAgICAgcG9seWxpbmVMZW5ndGgsXFxuICAgICAgICAgICAgbGVmdFBvbHlsaW5lUmF0aW9zLFxcbiAgICAgICAgICAgIGxlZnRQb2x5bGluZUFuZ2xlcyxcXG4gICAgICAgICAgICByaWdodFBvbHlsaW5lUmF0aW9zLFxcbiAgICAgICAgICAgIHJpZ2h0UG9seWxpbmVBbmdsZXNcXG4gICAgICAgICk7XFxuXFxuICAgICAgICB1diA9IHZlcnRleFVWO1xcbiAgICAgICAgY29sb3IgPSB2ZXJ0ZXhDb2xvcjtcXG4gICAgICAgIG91dGxpbmVDb2xvciA9IHZlcnRleE91dGxpbmVDb2xvcjtcXG4gICAgICAgIHNjYWxlID0gdmVydGV4U2NhbGU7XFxuXFxuICAgICAgICBjb2xvci5hICo9IHZpc2liaWxpdHlBbHBoYTtcXG4gICAgICAgIG91dGxpbmVDb2xvci5hICo9IHZpc2liaWxpdHlBbHBoYTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIGdsX1Bvc2l0aW9uID0gRElTQ0FSRF9QT1NJVElPTjtcXG4gICAgfVxcbn1cXG5cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL2xhYmVsL3NoYWRlci9jdXJ2ZWRfbGFiZWwudmVydFxuLy8gbW9kdWxlIGlkID0gMTIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBpY29uVmVydGV4U2hhZGVyIGZyb20gJy4vc2hhZGVyL2ljb24udmVydCc7XHJcbmltcG9ydCBpY29uRnJhZ21lbnRTaGFkZXIgZnJvbSAnLi9zaGFkZXIvaWNvbi5mcmFnJztcclxuaW1wb3J0IEltYWdlUmVuZGVyVW5pdCBmcm9tICcuLi9pbWFnZS9pbWFnZV9yZW5kZXJfdW5pdCc7XHJcbi8qKlxyXG4gKiBSZW5kZXJlciBvZiBpY29uIHByaW1pdGl2ZXMuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJY29uUmVuZGVyVW5pdCBleHRlbmRzIEltYWdlUmVuZGVyVW5pdCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBjYW1lcmEsIHByaW1pdGl2ZVByb3ZpZGVyKSB7XHJcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IGNvbnRleHQuY3JlYXRlUHJvZ3JhbShpY29uVmVydGV4U2hhZGVyLCBpY29uRnJhZ21lbnRTaGFkZXIsIHtcclxuICAgICAgICAgICAgYXR0cmliTWFwOiB7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhQb3NIaWdoOiAwIC8qIFBPU0lUSU9OX0hJR0ggKi8sXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhQb3NMb3c6IDEgLyogUE9TSVRJT05fTE9XICovLFxyXG4gICAgICAgICAgICAgICAgdmVydGV4RGlzcGxhY2VtZW50OiA2IC8qIERJU1BMQUNFTUVOVCAqLyxcclxuICAgICAgICAgICAgICAgIHZlcnRleFVWOiA0IC8qIFVWICovXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBzdXBlcihjb250ZXh0LCBwcmltaXRpdmVQcm92aWRlciwgcHJvZ3JhbSk7XHJcbiAgICAgICAgdGhpcy5fY2FtZXJhID0gY2FtZXJhO1xyXG4gICAgfVxyXG4gICAgX3ByZXBhcmVQcm9ncmFtKHByb2dyYW0sIHZpZXdQcm9qTWF0cml4LCBjYW1lcmFQb3NpdGlvbnMpIHtcclxuICAgICAgICBzdXBlci5fcHJlcGFyZVByb2dyYW0ocHJvZ3JhbSwgdmlld1Byb2pNYXRyaXgsIGNhbWVyYVBvc2l0aW9ucyk7XHJcbiAgICAgICAgcHJvZ3JhbS5zZXRWZWN0b3IyVW5pZm9ybSgncGl4ZWxTaXplJywgdGhpcy5fY2FtZXJhLnBpeGVsU2l6ZSk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvaWNvbi9pY29uX3JlbmRlcl91bml0LnRzXG4vLyBtb2R1bGUgaWQgPSAxMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcIiN2ZXJzaW9uIDEwMFxcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxuYXR0cmlidXRlIHZlYzIgdmVydGV4UG9zSGlnaDtcXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhQb3NMb3c7XFxuYXR0cmlidXRlIHZlYzIgdmVydGV4RGlzcGxhY2VtZW50O1xcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleFVWO1xcblxcbnVuaWZvcm0gdmVjMiBsb29rQXRIaWdoO1xcbnVuaWZvcm0gdmVjMiBsb29rQXRMb3c7XFxudW5pZm9ybSBtYXQ0IHZpZXdQcm9qTWF0cml4O1xcbnVuaWZvcm0gdmVjMiBwaXhlbFNpemU7XFxuXFxudmFyeWluZyB2ZWMyIHV2O1xcblxcbmNvbnN0IGZsb2F0IFlWX0ggPSAxLjk5OTk2OTQ4MjQyMTg3NTtcXG5jb25zdCBmbG9hdCBZVl9MID0gMC4wMDAwMzA1MTcxMTI0NjM3MTI2OTI7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICB2ZWM0IHBvc2l0aW9uID0gdmlld1Byb2pNYXRyaXggKiB2ZWM0KFxcbiAgICAgICAgWVZfSCAqICh2ZXJ0ZXhQb3NIaWdoIC0gbG9va0F0SGlnaCkgK1xcbiAgICAgICAgICAgIFlWX0wgKiAodmVydGV4UG9zTG93IC0gbG9va0F0TG93KSxcXG4gICAgICAgIDAsXFxuICAgICAgICAxXFxuICAgICk7XFxuICAgIHBvc2l0aW9uID0gdmVjNChwb3NpdGlvbi54eSAvIHBvc2l0aW9uLncsIDAuMCwgMS4wKTtcXG5cXG4gICAgZ2xfUG9zaXRpb24gPSBwb3NpdGlvbiArIHZlYzQodmVydGV4RGlzcGxhY2VtZW50ICogcGl4ZWxTaXplLCAwLjAsIDAuMCk7XFxuXFxuICAgIHV2ID0gdmVydGV4VVY7XFxufVxcblwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvaWNvbi9zaGFkZXIvaWNvbi52ZXJ0XG4vLyBtb2R1bGUgaWQgPSAxMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcIiN2ZXJzaW9uIDEwMFxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgYXRsYXM7XFxudW5pZm9ybSB2ZWMyIGF0bGFzU2l6ZTtcXG5cXG52YXJ5aW5nIHZlYzIgdXY7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQoYXRsYXMsIHV2IC8gYXRsYXNTaXplKTtcXG59XFxuXCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9pY29uL3NoYWRlci9pY29uLmZyYWdcbi8vIG1vZHVsZSBpZCA9IDEyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgaW1hZ2VWZXJ0ZXhTaGFkZXIgZnJvbSAnLi9zaGFkZXIvaW1hZ2UudmVydCc7XHJcbmltcG9ydCBpbWFnZUZyYWdtZW50U2hhZGVyIGZyb20gJy4vc2hhZGVyL2ltYWdlLmZyYWcnO1xyXG5pbXBvcnQgKiBhcyB2ZWMyIGZyb20gJy4uLy4uLy4uL21hdGgvdmVjdG9yMic7XHJcbmltcG9ydCBXb3JsZFByaW1pdGl2ZVJlbmRlclVuaXQgZnJvbSAnLi4vd29ybGRfcHJpbWl0aXZlX3JlbmRlcl91bml0JztcclxuaW1wb3J0IFJlbmRlclN0YXRlIGZyb20gJy4uLy4uLy4uL3JlbmRlci9zdGF0ZSc7XHJcbmltcG9ydCB7IEJMRU5EX09WRVJfUkVOREVSX1NUQVRFIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyL3N0YXRlJztcclxuY29uc3QgUkVOREVSX1NUQVRFID0gbmV3IFJlbmRlclN0YXRlKEJMRU5EX09WRVJfUkVOREVSX1NUQVRFKTtcclxuZnVuY3Rpb24gY3JlYXRlRGVmYXVsdFByb2dyYW0oY29udGV4dCkge1xyXG4gICAgcmV0dXJuIGNvbnRleHQuY3JlYXRlUHJvZ3JhbShpbWFnZVZlcnRleFNoYWRlciwgaW1hZ2VGcmFnbWVudFNoYWRlciwge1xyXG4gICAgICAgIGF0dHJpYk1hcDoge1xyXG4gICAgICAgICAgICB2ZXJ0ZXhQb3NIaWdoOiAwIC8qIFBPU0lUSU9OX0hJR0ggKi8sXHJcbiAgICAgICAgICAgIHZlcnRleFBvc0xvdzogMSAvKiBQT1NJVElPTl9MT1cgKi8sXHJcbiAgICAgICAgICAgIHZlcnRleFVWOiA0IC8qIFVWICovXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIFJlbmRlcmVyIG9mIGltYWdlIHByaW1pdGl2ZXMuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbWFnZVJlbmRlclVuaXQgZXh0ZW5kcyBXb3JsZFByaW1pdGl2ZVJlbmRlclVuaXQge1xyXG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgcHJpbWl0aXZlUHJvdmlkZXIsIHByb2dyYW0gPSBjcmVhdGVEZWZhdWx0UHJvZ3JhbShjb250ZXh0KSkge1xyXG4gICAgICAgIHN1cGVyKGNvbnRleHQsIFJFTkRFUl9TVEFURSwgcHJvZ3JhbSwgcHJpbWl0aXZlUHJvdmlkZXIpO1xyXG4gICAgICAgIHRoaXMuX2F0bGFzU2l6ZVVuaWZvcm0gPSB2ZWMyLmNyZWF0ZSgwLCAwKTtcclxuICAgICAgICBjb250ZXh0LmJpbmRQcm9ncmFtKHByb2dyYW0pO1xyXG4gICAgICAgIHByb2dyYW0uc2V0SW50U2NhbGFyVW5pZm9ybSgnYXRsYXMnLCAwKTtcclxuICAgIH1cclxuICAgIF9yZW5kZXJCYXRjaChtZW1vcnlCYXRjaCkge1xyXG4gICAgICAgIGNvbnN0IGF0bGFzID0gbWVtb3J5QmF0Y2guZmlyc3RQcmltaXRpdmUuYXRsYXM7XHJcbiAgICAgICAgdGhpcy5fYXRsYXNTaXplVW5pZm9ybS54ID0gYXRsYXMud2lkdGg7XHJcbiAgICAgICAgdGhpcy5fYXRsYXNTaXplVW5pZm9ybS55ID0gYXRsYXMuaGVpZ2h0O1xyXG4gICAgICAgIGlmIChhdGxhcy5pc0RpcnR5KSB7XHJcbiAgICAgICAgICAgIGF0bGFzLnN5bmNUZXh0dXJlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3Byb2dyYW0uc2V0VmVjdG9yMlVuaWZvcm0oJ2F0bGFzU2l6ZScsIHRoaXMuX2F0bGFzU2l6ZVVuaWZvcm0pO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFRleHR1cmVVbml0KDApO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFRleHR1cmUoYXRsYXMudGV4dHVyZSk7XHJcbiAgICAgICAgc3VwZXIuX3JlbmRlckJhdGNoKG1lbW9yeUJhdGNoKTtcclxuICAgIH1cclxuICAgIF9jYW5CYXRjaEFkamFjZW50UHJpbWl0aXZlcyhhLCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIHN1cGVyLl9jYW5CYXRjaEFkamFjZW50UHJpbWl0aXZlcyhhLCBiKSAmJiAoYS5hdGxhcyA9PT0gYi5hdGxhcyk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvaW1hZ2UvaW1hZ2VfcmVuZGVyX3VuaXQudHNcbi8vIG1vZHVsZSBpZCA9IDEyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwiI3ZlcnNpb24gMTAwXFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhQb3NIaWdoO1xcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleFBvc0xvdztcXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhVVjtcXG5cXG51bmlmb3JtIHZlYzIgbG9va0F0SGlnaDtcXG51bmlmb3JtIHZlYzIgbG9va0F0TG93O1xcbnVuaWZvcm0gbWF0NCB2aWV3UHJvak1hdHJpeDtcXG5cXG52YXJ5aW5nIHZlYzIgdXY7XFxuXFxuY29uc3QgZmxvYXQgWVZfSCA9IDEuOTk5OTY5NDgyNDIxODc1O1xcbmNvbnN0IGZsb2F0IFlWX0wgPSAwLjAwMDAzMDUxNzExMjQ2MzcxMjY5MjtcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIHZlYzQgcG9zaXRpb24gPSB2aWV3UHJvak1hdHJpeCAqIHZlYzQoXFxuICAgICAgICBZVl9IICogKHZlcnRleFBvc0hpZ2ggLSBsb29rQXRIaWdoKSArXFxuICAgICAgICAgICAgWVZfTCAqICh2ZXJ0ZXhQb3NMb3cgLSBsb29rQXRMb3cpLFxcbiAgICAgICAgMCxcXG4gICAgICAgIDFcXG4gICAgKTtcXG5cXG4gICAgZ2xfUG9zaXRpb24gPSBwb3NpdGlvbjtcXG5cXG4gICAgdXYgPSB2ZXJ0ZXhVVjtcXG59XFxuXCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9pbWFnZS9zaGFkZXIvaW1hZ2UudmVydFxuLy8gbW9kdWxlIGlkID0gMTI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbnVuaWZvcm0gc2FtcGxlcjJEIGF0bGFzO1xcbnVuaWZvcm0gdmVjMiBhdGxhc1NpemU7XFxuXFxudmFyeWluZyB2ZWMyIHV2O1xcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKGF0bGFzLCB1diAvIGF0bGFzU2l6ZSk7XFxuXFxuICAgIGlmIChnbF9GcmFnQ29sb3IuYSA9PSAwLjApIHtcXG4gICAgICAgIGRpc2NhcmQ7XFxuICAgIH1cXG59XFxuXCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9pbWFnZS9zaGFkZXIvaW1hZ2UuZnJhZ1xuLy8gbW9kdWxlIGlkID0gMTI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBtb2RlbFZlcnRleFNoYWRlciBmcm9tICcuL3NoYWRlci9tb2RlbC52ZXJ0JztcclxuaW1wb3J0IG1vZGVsRnJhZ21lbnRTaGFkZXIgZnJvbSAnLi9zaGFkZXIvbW9kZWwuZnJhZyc7XHJcbmltcG9ydCB7IGNyZWF0ZUV4dGVudDIgfSBmcm9tICcuLi8uLi8uLi9tYXRoL3ZlY3RvcjInO1xyXG5pbXBvcnQgT3ZlcmxheVJlbmRlcmVyIGZyb20gJy4uL292ZXJsYXkvb3ZlcmxheV9yZW5kZXJlcic7XHJcbmltcG9ydCBSZW5kZXJTdGF0ZSBmcm9tICcuLi8uLi8uLi9yZW5kZXIvc3RhdGUnO1xyXG5pbXBvcnQgV29ybGRQcmltaXRpdmVSZW5kZXJVbml0IGZyb20gJy4uL3dvcmxkX3ByaW1pdGl2ZV9yZW5kZXJfdW5pdCc7XHJcbmNvbnN0IFJFTkRFUl9TVEFURSA9IG5ldyBSZW5kZXJTdGF0ZSh7XHJcbiAgICBkZXB0aFRlc3Q6IHRydWVcclxufSk7XHJcbi8qKlxyXG4gKiBSZW5kZXJlciBvZiBtb2RlbHMuIEl0IHJlbmRlcnMgbW9kZWxzIGludG8gYSB0ZXh0dXJlIHdpdGggZGVwdGggdGVzdCBhbmQgdGhlbiB0aGlzIHRleHR1cmUgaW50byB0aGUgcmVuZGVyIHRhcmdldC5cclxuICogSXQgYWxsb3dzIHRvIHNob3cgb25seSB0aGUgdG9wIGZhY2V0cyBvZiBzZW1pLXRyYW5zcGFyZW50IG9iamVjdHMgd2l0aG91dCBleHBvc2luZyB0aGVpciBpbm5lciBzdHJ1Y3R1cmUuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb2RlbFJlbmRlclVuaXQgZXh0ZW5kcyBXb3JsZFByaW1pdGl2ZVJlbmRlclVuaXQge1xyXG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgcHJpbWl0aXZlUHJvdmlkZXIpIHtcclxuICAgICAgICBjb25zdCBwcm9ncmFtID0gY29udGV4dC5jcmVhdGVQcm9ncmFtKG1vZGVsVmVydGV4U2hhZGVyLCBtb2RlbEZyYWdtZW50U2hhZGVyLCB7XHJcbiAgICAgICAgICAgIGF0dHJpYk1hcDoge1xyXG4gICAgICAgICAgICAgICAgdmVydGV4UG9zSGlnaDogMCAvKiBQT1NJVElPTl9ISUdIICovLFxyXG4gICAgICAgICAgICAgICAgdmVydGV4UG9zTG93OiAxIC8qIFBPU0lUSU9OX0xPVyAqLyxcclxuICAgICAgICAgICAgICAgIHZlcnRleEhlaWdodDogMyAvKiBIRUlHSFQgKi8sXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhDb2xvcjogNyAvKiBDT0xPUiAqL1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc3VwZXIoY29udGV4dCwgUkVOREVSX1NUQVRFLCBwcm9ncmFtLCBwcmltaXRpdmVQcm92aWRlcik7XHJcbiAgICAgICAgdGhpcy5fb3V0cHV0U2l6ZSA9IGNyZWF0ZUV4dGVudDIoLTEsIC0xKTtcclxuICAgICAgICB0aGlzLl9vdmVybGF5UmVuZGVyZXIgPSBuZXcgT3ZlcmxheVJlbmRlcmVyKGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgcmVuZGVyKHRhcmdldCwgdmlld1Byb2pNYXRyaXgsIGNhbWVyYVBvc2l0aW9ucykge1xyXG4gICAgICAgIHRoaXMuX3N5bmNPdXRwdXRCdWZmZXIodGFyZ2V0KTtcclxuICAgICAgICBzdXBlci5yZW5kZXIodGhpcy5fb3V0cHV0QnVmZmVyLCB2aWV3UHJvak1hdHJpeCwgY2FtZXJhUG9zaXRpb25zKTtcclxuICAgICAgICAvLyBkbyBub3QgcnVuIHVubmVjZXNzYXJ5IGNvcHlpbmcgaWYgdGhpcy5fb3V0cHV0QnVmZmVyIHdhcyBub3QgdXBkYXRlZCAobm8gbW9kZWxzIGluIHNjZW5lPylcclxuICAgICAgICBpZiAoIXRoaXMuX291dHB1dEJ1ZmZlci5pc0NsZWFyKSB7XHJcbiAgICAgICAgICAgIC8vIGNvcHkgaW50byB0aGUgZmluYWwgdGFyZ2V0XHJcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlSZW5kZXJlci5yZW5kZXIodGFyZ2V0LCB0aGlzLl9vdXRwdXRUZXh0dXJlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMuX292ZXJsYXlSZW5kZXJlci5kZXN0cm95KCk7XHJcbiAgICAgICAgaWYgKHRoaXMuX291dHB1dFRleHR1cmUpIHtcclxuICAgICAgICAgICAgdGhpcy5fb3V0cHV0VGV4dHVyZS5kZXN0cm95KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9vdXRwdXREZXB0aEJ1ZmZlcikge1xyXG4gICAgICAgICAgICB0aGlzLl9vdXRwdXREZXB0aEJ1ZmZlci5kZXN0cm95KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9vdXRwdXRCdWZmZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5fb3V0cHV0QnVmZmVyLmRlc3Ryb3koKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xyXG4gICAgfVxyXG4gICAgX3N5bmNPdXRwdXRCdWZmZXIodGFyZ2V0KSB7XHJcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSBpbnRlcm1lZGlhdGUgdGV4dHVyZSBmaXRzIHRoZSBvdXRwdXQgdGFyZ2V0XHJcbiAgICAgICAgaWYgKHRoaXMuX291dHB1dFNpemUud2lkdGggIT09IHRhcmdldC5nZXRXaWR0aCgpIHx8XHJcbiAgICAgICAgICAgIHRoaXMuX291dHB1dFNpemUuaGVpZ2h0ICE9PSB0YXJnZXQuZ2V0SGVpZ2h0KCkpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX291dHB1dFRleHR1cmUgfHwgdGhpcy5fb3V0cHV0RGVwdGhCdWZmZXIgfHwgdGhpcy5fb3V0cHV0QnVmZmVyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9vdXRwdXRUZXh0dXJlLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX291dHB1dERlcHRoQnVmZmVyLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX291dHB1dEJ1ZmZlci5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fb3V0cHV0U2l6ZSA9IHsgd2lkdGg6IHRhcmdldC5nZXRXaWR0aCgpLCBoZWlnaHQ6IHRhcmdldC5nZXRIZWlnaHQoKSB9O1xyXG4gICAgICAgICAgICB0aGlzLl9vdXRwdXRUZXh0dXJlID0gdGhpcy5fY29udGV4dC5jcmVhdGVFbXB0eTJEVGV4dHVyZSh0aGlzLl9vdXRwdXRTaXplLndpZHRoLCB0aGlzLl9vdXRwdXRTaXplLmhlaWdodCwgNjQwOCAvKiBSR0JBICovLCA1MTIxIC8qIFVOU0lHTkVEX0JZVEUgKi8pO1xyXG4gICAgICAgICAgICB0aGlzLl9vdXRwdXREZXB0aEJ1ZmZlciA9IHRoaXMuX2NvbnRleHQuY3JlYXRlUmVuZGVyYnVmZmVyKHRoaXMuX291dHB1dFNpemUud2lkdGgsIHRoaXMuX291dHB1dFNpemUuaGVpZ2h0LCAzNDA0MSAvKiBERVBUSF9TVEVOQ0lMICovKTtcclxuICAgICAgICAgICAgdGhpcy5fb3V0cHV0QnVmZmVyID0gdGhpcy5fY29udGV4dC5jcmVhdGVGcmFtZWJ1ZmZlcih7XHJcbiAgICAgICAgICAgICAgICBjb2xvcjogdGhpcy5fb3V0cHV0VGV4dHVyZSxcclxuICAgICAgICAgICAgICAgIGRlcHRoU3RlbmNpbDogdGhpcy5fb3V0cHV0RGVwdGhCdWZmZXJcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPdmVycmlkZGVuIF9iaW5kUmVuZGVyVGFyZ2V0KCkgdG8gYmluZCBpbnRlcm1lZGlhdGUgcmVuZGVyIHRhcmdldCB0byByZW5kZXIgbW9kZWxzIGludG8gYW5kXHJcbiAgICAgKiBsYXRlciBwdXQgaXRzIGNvbnRlbnQgaW50byB0aGUgZmluYWwgdGFyZ2V0LlxyXG4gICAgICovXHJcbiAgICBfcHJlcGFyZVJlbmRlclRhcmdldCh0YXJnZXQsIHZpZXdQcm9qTWF0cml4LCBjYW1lcmFQb3NpdGlvbnMpIHtcclxuICAgICAgICBzdXBlci5fcHJlcGFyZVJlbmRlclRhcmdldCh0YXJnZXQsIHZpZXdQcm9qTWF0cml4LCBjYW1lcmFQb3NpdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuY2xlYXJDdXJyZW50VGFyZ2V0KDE2Mzg0IC8qIENPTE9SX0JVRkZFUl9CSVQgKi8gfCAyNTYgLyogREVQVEhfQlVGRkVSX0JJVCAqLyk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvbW9kZWwvbW9kZWxfcmVuZGVyX3VuaXQudHNcbi8vIG1vZHVsZSBpZCA9IDEyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwiI3ZlcnNpb24gMTAwXFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG5hdHRyaWJ1dGUgdmVjMyB2ZXJ0ZXhQb3NIaWdoO1xcbmF0dHJpYnV0ZSB2ZWMzIHZlcnRleFBvc0xvdztcXG5hdHRyaWJ1dGUgZmxvYXQgdmVydGV4SGVpZ2h0O1xcbmF0dHJpYnV0ZSB2ZWM0IHZlcnRleENvbG9yO1xcblxcbnVuaWZvcm0gdmVjMiBsb29rQXRIaWdoO1xcbnVuaWZvcm0gdmVjMiBsb29rQXRMb3c7XFxudW5pZm9ybSBtYXQ0IHZpZXdQcm9qTWF0cml4O1xcblxcbnZhcnlpbmcgdmVjNCBnbG9iYWxQb3M7XFxudmFyeWluZyB2ZWM0IGRpZmZ1c2VDb2xvcjtcXG5cXG5jb25zdCBmbG9hdCBZVl9IID0gMS45OTk5Njk0ODI0MjE4NzU7XFxuY29uc3QgZmxvYXQgWVZfTCA9IDAuMDAwMDMwNTE3MTEyNDYzNzEyNjkyO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIGdsb2JhbFBvcyA9IHZlYzQoXFxuICAgICAgICBZVl9IICogKHZlcnRleFBvc0hpZ2gueHkgLSBsb29rQXRIaWdoKSArIFlWX0wgKiAodmVydGV4UG9zTG93Lnh5IC0gbG9va0F0TG93KSxcXG4gICAgICAgIHZlcnRleEhlaWdodCxcXG4gICAgICAgIDFcXG4gICAgKTtcXG5cXG4gICAgZ2xfUG9zaXRpb24gPSB2aWV3UHJvak1hdHJpeCAqIGdsb2JhbFBvcztcXG4gICAgZGlmZnVzZUNvbG9yID0gdmVydGV4Q29sb3I7XFxufVxcblwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvbW9kZWwvc2hhZGVyL21vZGVsLnZlcnRcbi8vIG1vZHVsZSBpZCA9IDEyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwiI3ZlcnNpb24gMTAwXFxuXFxuI2V4dGVuc2lvbiBHTF9PRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMgOiByZXF1aXJlXFxuXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG52YXJ5aW5nIHZlYzQgZGlmZnVzZUNvbG9yO1xcbnZhcnlpbmcgdmVjNCBnbG9iYWxQb3M7XFxuXFxuY29uc3QgdmVjMyBMSUdIVF9ESVJFQ1RJT04gPSBub3JtYWxpemUodmVjMygwLjUsIDAuNSwgMS4wKSk7XFxuY29uc3QgZmxvYXQgTElHSFRfSU5URU5TSVRZID0gMC4zO1xcbmNvbnN0IGZsb2F0IEFNQklFTlRfTElHSFRfSU5URU5TSVRZID0gMS4wIC0gTElHSFRfSU5URU5TSVRZO1xcbmNvbnN0IGZsb2F0IEhPUklaT05UQUxfUExBTkVfRElGRlVTRV9JTlRFTlNJVFkgPVxcbiAgICBBTUJJRU5UX0xJR0hUX0lOVEVOU0lUWSArIDAuNSAqIExJR0hUX0lOVEVOU0lUWSAqIChMSUdIVF9ESVJFQ1RJT04ueiArIDEuMCk7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gICAgdmVjMyBwb3MgPSBnbG9iYWxQb3MueHl6O1xcblxcbiAgICB2ZWMzIGR4cG9zID0gbm9ybWFsaXplKGRGZHgocG9zKSk7XFxuICAgIHZlYzMgZHlwb3MgPSBub3JtYWxpemUoZEZkeShwb3MpKTtcXG4gICAgdmVjMyBub3JtYWwgPSBub3JtYWxpemUoY3Jvc3MoZHhwb3MsIGR5cG9zKSk7XFxuXFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoXFxuICAgICAgICBkaWZmdXNlQ29sb3IucmdiICogKEFNQklFTlRfTElHSFRfSU5URU5TSVRZICsgMC41ICogTElHSFRfSU5URU5TSVRZICogKGRvdChub3JtYWwsIExJR0hUX0RJUkVDVElPTikgKyAxLjApKSAvXFxuICAgICAgICAgICAgSE9SSVpPTlRBTF9QTEFORV9ESUZGVVNFX0lOVEVOU0lUWSxcXG4gICAgICAgIGRpZmZ1c2VDb2xvci5hXFxuICAgICk7XFxufVxcblwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvbW9kZWwvc2hhZGVyL21vZGVsLmZyYWdcbi8vIG1vZHVsZSBpZCA9IDEyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgb3ZlcmxheVZlcnRleFNoYWRlciBmcm9tICcuL3NoYWRlci9vdmVybGF5LnZlcnQnO1xyXG5pbXBvcnQgb3ZlcmxheUZyYWdtZW50U2hhZGVyIGZyb20gJy4vc2hhZGVyL292ZXJsYXkuZnJhZyc7XHJcbmltcG9ydCB7IEdsUmVuZGVyZXIgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXIvZ2xfcmVuZGVyZXInO1xyXG5pbXBvcnQgUmVuZGVyU3RhdGUgZnJvbSAnLi4vLi4vLi4vcmVuZGVyL3N0YXRlJztcclxuaW1wb3J0IHsgQkxFTkRfT1ZFUl9SRU5ERVJfU1RBVEUgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXIvc3RhdGUnO1xyXG5jb25zdCBSRU5ERVJfU1RBVEUgPSBuZXcgUmVuZGVyU3RhdGUoQkxFTkRfT1ZFUl9SRU5ERVJfU1RBVEUpO1xyXG4vKipcclxuICogUmVuZGVycyBhIHRleHR1cmUgaW50byBhIHJlbmRlciB0YXJnZXQgd2l0aCBPVkVSIGNvbXBvc2l0aW5nLiBUaGUgdGV4dHVyZSB3aWxsIGNvbXBsZXRlbHkgb3ZlcmxheSB0aGUgdGFyZ2V0LCBpLmUuXHJcbiAqIGl0IGlzIHN0cmV0Y2hlZC9zaHJpbmtlZCB0byBmaXQgdGhlIHRhcmdldCB3aWR0aC9oZWlnaHQsIHNvIGlkZWFsbHkgdGhleSBzaG91bGQgaGF2ZSB0aGUgc2FtZSBkaW1lbnNpb25zLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT3ZlcmxheVJlbmRlcmVyIGV4dGVuZHMgR2xSZW5kZXJlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XHJcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IGNvbnRleHQuY3JlYXRlUHJvZ3JhbShvdmVybGF5VmVydGV4U2hhZGVyLCBvdmVybGF5RnJhZ21lbnRTaGFkZXIsIHtcclxuICAgICAgICAgICAgYXR0cmliTWFwOiB7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhQb3NpdGlvbjogMCAvKiBQT1NJVElPTiAqLyxcclxuICAgICAgICAgICAgICAgIHZlcnRleFVWOiA0IC8qIFVWICovXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBzdXBlcihjb250ZXh0LCBSRU5ERVJfU1RBVEUsIHByb2dyYW0pO1xyXG4gICAgfVxyXG4gICAgX3JlbmRlcih0ZXh0dXJlKSB7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kVGV4dHVyZVVuaXQoMCk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kVGV4dHVyZSh0ZXh0dXJlKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRRdWFkVmFvKCk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5kcmF3UXVhZCgpO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL292ZXJsYXkvb3ZlcmxheV9yZW5kZXJlci50c1xuLy8gbW9kdWxlIGlkID0gMTMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleFBvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleFVWO1xcblxcbnZhcnlpbmcgdmVjMiB1djtcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIGdsX1Bvc2l0aW9uID0gdmVjNCh2ZXJ0ZXhQb3NpdGlvbiwgMCwgMSk7XFxuICAgIHV2ID0gdmVydGV4VVY7XFxufVxcblwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvb3ZlcmxheS9zaGFkZXIvb3ZlcmxheS52ZXJ0XG4vLyBtb2R1bGUgaWQgPSAxMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcIiN2ZXJzaW9uIDEwMFxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgdGV4dHVyZTtcXG5cXG52YXJ5aW5nIHZlYzIgdXY7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodGV4dHVyZSwgdXYpO1xcbn1cXG5cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL292ZXJsYXkvc2hhZGVyL292ZXJsYXkuZnJhZ1xuLy8gbW9kdWxlIGlkID0gMTMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB0ZXh0dXJlZFBvbHlsaW5lVmVydGV4U2hhZGVyIGZyb20gJy4vc2hhZGVyL3RleHR1cmVkX3BvbHlsaW5lLnZlcnQnO1xyXG5pbXBvcnQgdGV4dHVyZWRQb2x5bGluZUZyYWdtZW50U2hhZGVyIGZyb20gJy4vc2hhZGVyL3RleHR1cmVkX3BvbHlsaW5lLmZyYWcnO1xyXG5pbXBvcnQgKiBhcyB2ZWMyIGZyb20gJy4uLy4uLy4uL21hdGgvdmVjdG9yMic7XHJcbmltcG9ydCBSZW5kZXJTdGF0ZSwgeyBCTEVORF9PVkVSX1BSRU1VTFRJUExJRURfQUxQSEFfUkVOREVSX1NUQVRFIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyL3N0YXRlJztcclxuaW1wb3J0IEJhc2VQb2x5bGluZVJlbmRlclVuaXQgZnJvbSAnLi9iYXNlX3BvbHlsaW5lX3JlbmRlcl91bml0JztcclxuY29uc3QgRklMVEVSX1JBRElVUyA9IDEuMCAvIGRldmljZVBpeGVsUmF0aW87XHJcbmNvbnN0IFJFTkRFUl9TVEFURSA9IG5ldyBSZW5kZXJTdGF0ZShCTEVORF9PVkVSX1BSRU1VTFRJUExJRURfQUxQSEFfUkVOREVSX1NUQVRFLCB7XHJcbiAgICBkZXB0aFRlc3Q6IHRydWUsXHJcbiAgICBkZXB0aE1hc2s6IGZhbHNlLFxyXG4gICAgZGVwdGhGdW5jOiA1MTggLyogR1JFQVRFUl9PUl9FUVVBTCAqL1xyXG59KTtcclxuLyoqXHJcbiAqIFJlbmRlcmVyIG9mIHBvbHlsaW5lIHByaW1pdGl2ZXMuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXh0dXJlZFBvbHlsaW5lUmVuZGVyVW5pdCBleHRlbmRzIEJhc2VQb2x5bGluZVJlbmRlclVuaXQge1xyXG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgY2FtZXJhLCBwcmltaXRpdmVQcm92aWRlcikge1xyXG4gICAgICAgIGNvbnN0IHByb2dyYW0gPSBjb250ZXh0LmNyZWF0ZVByb2dyYW0odGV4dHVyZWRQb2x5bGluZVZlcnRleFNoYWRlciwgdGV4dHVyZWRQb2x5bGluZUZyYWdtZW50U2hhZGVyLCB7XHJcbiAgICAgICAgICAgIGRlZmluZXM6IHtcclxuICAgICAgICAgICAgICAgIEZJTFRFUl9SQURJVVM6IGBmbG9hdCgke0ZJTFRFUl9SQURJVVN9KWBcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYXR0cmliTWFwOiB7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhQb3NIaWdoOiAwIC8qIFBPU0lUSU9OX0hJR0ggKi8sXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhQb3NMb3c6IDEgLyogUE9TSVRJT05fTE9XICovLFxyXG4gICAgICAgICAgICAgICAgdmVydGV4RGlzcGxhY2VtZW50OiA2IC8qIERJU1BMQUNFTUVOVCAqLyxcclxuICAgICAgICAgICAgICAgIHZlcnRleFVWOiA0IC8qIFVWICovLFxyXG4gICAgICAgICAgICAgICAgdmVydGV4WkluZGV4OiA5IC8qIFBSSU9SSVRZICovLFxyXG4gICAgICAgICAgICAgICAgdmVydGV4SGFsZldpZHRoOiAxMSAvKiBBVVggKi8sXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhQYXR0ZXJuOiAxMiAvKiBBVVgxICovLFxyXG4gICAgICAgICAgICAgICAgdmVydGV4UGF0dGVybkhhbGZIZWlnaHQ6IDEzIC8qIEFVWDIgKi9cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHN1cGVyKGNvbnRleHQsIFJFTkRFUl9TVEFURSwgcHJvZ3JhbSwgcHJpbWl0aXZlUHJvdmlkZXIsIGNhbWVyYSk7XHJcbiAgICAgICAgdGhpcy5fYXRsYXNTaXplVW5pZm9ybSA9IHZlYzIuY3JlYXRlKDAsIDApO1xyXG4gICAgICAgIGNvbnRleHQuYmluZFByb2dyYW0ocHJvZ3JhbSk7XHJcbiAgICAgICAgcHJvZ3JhbS5zZXRJbnRTY2FsYXJVbmlmb3JtKCdhdGxhcycsIDApO1xyXG4gICAgfVxyXG4gICAgX3JlbmRlckJhdGNoKG1lbW9yeUJhdGNoKSB7XHJcbiAgICAgICAgY29uc3QgYXRsYXMgPSBtZW1vcnlCYXRjaC5maXJzdFByaW1pdGl2ZS5hdGxhcztcclxuICAgICAgICB0aGlzLl9hdGxhc1NpemVVbmlmb3JtLnggPSBhdGxhcy53aWR0aDtcclxuICAgICAgICB0aGlzLl9hdGxhc1NpemVVbmlmb3JtLnkgPSBhdGxhcy5oZWlnaHQ7XHJcbiAgICAgICAgaWYgKGF0bGFzLmlzRGlydHkpIHtcclxuICAgICAgICAgICAgYXRsYXMuc3luY1RleHR1cmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcHJvZ3JhbS5zZXRWZWN0b3IyVW5pZm9ybSgnYXRsYXNTaXplJywgdGhpcy5fYXRsYXNTaXplVW5pZm9ybSk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kVGV4dHVyZVVuaXQoMCk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kVGV4dHVyZShhdGxhcy50ZXh0dXJlKTtcclxuICAgICAgICBzdXBlci5fcmVuZGVyQmF0Y2gobWVtb3J5QmF0Y2gpO1xyXG4gICAgfVxyXG4gICAgX2NhbkJhdGNoQWRqYWNlbnRQcmltaXRpdmVzKGEsIGIpIHtcclxuICAgICAgICByZXR1cm4gc3VwZXIuX2NhbkJhdGNoQWRqYWNlbnRQcmltaXRpdmVzKGEsIGIpICYmIChhLmF0bGFzID09PSBiLmF0bGFzKTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9wb2x5bGluZS90ZXh0dXJlZF9wb2x5bGluZV9yZW5kZXJfdW5pdC50c1xuLy8gbW9kdWxlIGlkID0gMTMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbiNpZm5kZWYgRklMVEVSX1JBRElVU1xcbiMgICBlcnJvciBGSUxURVJfUkFESVVTIG11c3QgYmUgc2V0XFxuI2VuZGlmXFxuXFxuYXR0cmlidXRlIHZlYzIgdmVydGV4UG9zSGlnaDtcXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhQb3NMb3c7XFxuYXR0cmlidXRlIHZlYzIgdmVydGV4RGlzcGxhY2VtZW50O1xcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleFVWO1xcbmF0dHJpYnV0ZSBmbG9hdCB2ZXJ0ZXhIYWxmV2lkdGg7XFxuYXR0cmlidXRlIHZlYzIgdmVydGV4UGF0dGVybjtcXG5hdHRyaWJ1dGUgZmxvYXQgdmVydGV4UGF0dGVybkhhbGZIZWlnaHQ7XFxuYXR0cmlidXRlIGZsb2F0IHZlcnRleFpJbmRleDtcXG5cXG51bmlmb3JtIHZlYzIgbG9va0F0SGlnaDtcXG51bmlmb3JtIHZlYzIgbG9va0F0TG93O1xcbnVuaWZvcm0gbWF0NCB2aWV3UHJvak1hdHJpeDtcXG51bmlmb3JtIGZsb2F0IHdvcmxkVG9QeEZhY3RvcjtcXG5cXG52YXJ5aW5nIHZlYzIgdXY7XFxudmFyeWluZyBmbG9hdCBzO1xcbnZhcnlpbmcgZmxvYXQgcGF0dGVybkxlbmd0aDtcXG52YXJ5aW5nIGZsb2F0IGxlbjtcXG52YXJ5aW5nIGZsb2F0IGhhbGZXaWR0aDtcXG52YXJ5aW5nIGZsb2F0IGV4dEhhbGZXaWR0aDtcXG52YXJ5aW5nIGZsb2F0IHBhdHRlcm5IYWxmSGVpZ2h0O1xcblxcbmNvbnN0IGZsb2F0IFlWX0ggPSAxLjk5OTk2OTQ4MjQyMTg3NTtcXG5jb25zdCBmbG9hdCBZVl9MID0gMC4wMDAwMzA1MTcxMTI0NjM3MTI2OTI7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gICAgaGFsZldpZHRoID0gdmVydGV4SGFsZldpZHRoO1xcbiAgICBleHRIYWxmV2lkdGggPSBoYWxmV2lkdGggKyBGSUxURVJfUkFESVVTO1xcblxcbiAgICB2ZWM0IHBvc2l0aW9uID0gdmlld1Byb2pNYXRyaXggKiB2ZWM0KFxcbiAgICAgICAgWVZfSCAqICh2ZXJ0ZXhQb3NIaWdoIC0gbG9va0F0SGlnaCkgK1xcbiAgICAgICAgICAgIFlWX0wgKiAodmVydGV4UG9zTG93IC0gbG9va0F0TG93KSArXFxuICAgICAgICAgICAgICAgIHdvcmxkVG9QeEZhY3RvciAqIGV4dEhhbGZXaWR0aCAqIHZlcnRleERpc3BsYWNlbWVudCxcXG4gICAgICAgIDAsXFxuICAgICAgICAxXFxuICAgICk7XFxuXFxuICAgIHBvc2l0aW9uLnh5IC89IHBvc2l0aW9uLnc7XFxuICAgIHBvc2l0aW9uLnogPSB2ZXJ0ZXhaSW5kZXg7XFxuICAgIHBvc2l0aW9uLncgPSAxLjA7XFxuXFxuICAgIGdsX1Bvc2l0aW9uID0gcG9zaXRpb247XFxuXFxuICAgIHBhdHRlcm5MZW5ndGggPSB2ZXJ0ZXhQYXR0ZXJuWzBdO1xcbiAgICBsZW4gPSB2ZXJ0ZXhQYXR0ZXJuWzFdO1xcbiAgICAvLyBEaXN0YW5jZSB0byB0aGUgYW5hbHl0aWNhbCBsaW5lIGFsb25nIHNlZ21lbnQncyBub3JtYWxcXG4gICAgcyA9IHNpZ24odmVydGV4UGF0dGVybkhhbGZIZWlnaHQpICogZXh0SGFsZldpZHRoO1xcbiAgICAvLyBUaGUgd2hvbGUgdGV4dHVyZSBpcyBiZWluZyBzYW1wbGVkIHRvIHRoZSBvcmlnaW5hbCBnZW9tZXRyeS4gRm9yIHBpeGVscyBpbiB0aGUgZXh0ZW5kZWQgcG9seWxpbmUgcGFydCB0aGUgdG9wbW9zdFxcbiAgICAvLyAoYm90dG9tbW9zdCkgdGV4ZWxzIGFyZSB0YWtlbi4gVG8gbWFrZSB0aGlzIGhhcHBlbiB0aGUgVVYgdGV4dHVyZSBjb29yZGluYXRlcyBhcmUgZXh0ZW5kZWQgaW4gcHJvcG9ydGlvbiB0byB0aGVcXG4gICAgLy8gcG9seWxpbmUgd2lkdGggZXh0ZW5zaW9uLlxcbiAgICBwYXR0ZXJuSGFsZkhlaWdodCA9IGFicyh2ZXJ0ZXhQYXR0ZXJuSGFsZkhlaWdodCk7XFxuICAgIHV2ID0gdmVjMih2ZXJ0ZXhVVi54LCB2ZXJ0ZXhVVi55IC0gdmVydGV4UGF0dGVybkhhbGZIZWlnaHQgKiBGSUxURVJfUkFESVVTIC8gaGFsZldpZHRoKTtcXG59XFxuXCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9wb2x5bGluZS9zaGFkZXIvdGV4dHVyZWRfcG9seWxpbmUudmVydFxuLy8gbW9kdWxlIGlkID0gMTM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG5cXG4jaWZuZGVmIEZJTFRFUl9SQURJVVNcXG4jICAgZXJyb3IgRklMVEVSX1JBRElVUyBtdXN0IGJlIHNldFxcbiNlbmRpZlxcblxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgYXRsYXM7XFxudW5pZm9ybSB2ZWMyIGF0bGFzU2l6ZTtcXG5cXG52YXJ5aW5nIHZlYzIgdXY7XFxudmFyeWluZyBmbG9hdCBzO1xcbnZhcnlpbmcgZmxvYXQgcGF0dGVybkxlbmd0aDtcXG52YXJ5aW5nIGZsb2F0IGxlbjtcXG52YXJ5aW5nIGZsb2F0IGhhbGZXaWR0aDtcXG52YXJ5aW5nIGZsb2F0IGV4dEhhbGZXaWR0aDtcXG52YXJ5aW5nIGZsb2F0IHBhdHRlcm5IYWxmSGVpZ2h0O1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIGxvd3AgZmxvYXQgYWxwaGEgPSBzbW9vdGhzdGVwKDAuMCwgRklMVEVSX1JBRElVUyArIG1pbihGSUxURVJfUkFESVVTLCBleHRIYWxmV2lkdGgpLCBleHRIYWxmV2lkdGggLSBhYnMocykpO1xcblxcbiAgICAvLyBDbGFtcCB0ZXh0dXJlIFUgY29vcmRpbmF0ZSBieSAwLjVweCBmcm9tIGJvdGggc2lkZXMgdG8gYXZvaWQgYmxlZWRpbmcuXFxuICAgIHZlYzIgdXZBZGp1c3RlZCA9IHZlYzIodXYueCArIGNsYW1wKG1vZChsZW4sIHBhdHRlcm5MZW5ndGgpLCAwLjUsIHBhdHRlcm5MZW5ndGggLSAwLjUpLCB1di55KTtcXG4gICAgLy8gVVYgdGV4dHVyZSBjb29yZGluYXRlcyBoYXZlIGJlZW4gZXh0ZW5kZWQgaW4gcHJvcG9ydGlvbiB0byB0aGUgcG9seWxpbmUgd2lkdGggZXh0ZW5zaW9uLlxcbiAgICAvLyBDbGFtcCB0ZXh0dXJlIFYgY29vcmRpbmF0ZSB0byB0aGUgb3JpZ2luYWwgZ2VvbWV0cnkgbWludXMgMC41cHggdG8gYXZvaWQgYmxlZWRpbmcuXFxuICAgIGZsb2F0IHBhdHRlcm5Ub0dlb21ldHJ5RmFjdG9yID0gaGFsZldpZHRoIC8gcGF0dGVybkhhbGZIZWlnaHQ7XFxuICAgIGZsb2F0IGNsYW1wVG8gPSBoYWxmV2lkdGggLSAwLjUgKiBwYXR0ZXJuVG9HZW9tZXRyeUZhY3RvcjtcXG4gICAgaWYgKHN0ZXAoY2xhbXBUbywgYWJzKHMpKSA9PSAxLikge1xcbiAgICAgICAgZmxvYXQgZGVsdGEgPSBzIC0gY2xhbXAocywgLWNsYW1wVG8sIGNsYW1wVG8pO1xcbiAgICAgICAgdXZBZGp1c3RlZC55ICs9IGRlbHRhIC8gcGF0dGVyblRvR2VvbWV0cnlGYWN0b3I7XFxuICAgIH1cXG5cXG4gICAgbG93cCB2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKGF0bGFzLCB1dkFkanVzdGVkIC8gYXRsYXNTaXplKTtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gY29sb3IgKiBhbHBoYTtcXG59XFxuXCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9wb2x5bGluZS9zaGFkZXIvdGV4dHVyZWRfcG9seWxpbmUuZnJhZ1xuLy8gbW9kdWxlIGlkID0gMTM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IE1BWF9IQUxGX1dJRFRILCBNQVhfRklMTF9HQVAgfSBmcm9tICcuLi8uLi8uLi9wcmltaXRpdmUvcG9seWxpbmUvcG9seWxpbmVfYnVmZmVyX3dyaXRlcic7XHJcbmltcG9ydCBwb2x5bGluZVZlcnRleFNoYWRlciBmcm9tICcuL3NoYWRlci9wb2x5bGluZS52ZXJ0JztcclxuaW1wb3J0IHBvbHlsaW5lRnJhZ21lbnRTaGFkZXIgZnJvbSAnLi9zaGFkZXIvcG9seWxpbmUuZnJhZyc7XHJcbmltcG9ydCBCYXNlUG9seWxpbmVSZW5kZXJVbml0IGZyb20gJy4vYmFzZV9wb2x5bGluZV9yZW5kZXJfdW5pdCc7XHJcbmltcG9ydCBSZW5kZXJTdGF0ZSBmcm9tICcuLi8uLi8uLi9yZW5kZXIvc3RhdGUnO1xyXG4vLyBWYWx1ZXMgd2FzIGNob3NlbiBieSB0ZWFtIGNvbnNlbnN1cyBpbiBWRUNUT1ItMTk3XHJcbmNvbnN0IEZJTFRFUl9SQURJVVMgPSAxLjAgLyBkZXZpY2VQaXhlbFJhdGlvOyAvLyBweFxyXG5leHBvcnQgY29uc3QgREVGQVVMVF9SRU5ERVJfU1RBVEVfUEFSQU1TID0ge1xyXG4gICAgYmxlbmQ6IHRydWUsXHJcbiAgICBibGVuZEZ1bmNTcmNSZ2I6IDEgLyogT05FICovLFxyXG4gICAgYmxlbmRGdW5jRHN0UmdiOiA3NzEgLyogT05FX01JTlVTX1NSQ19BTFBIQSAqLyxcclxuICAgIGJsZW5kRnVuY1NyY0FscGhhOiAxIC8qIE9ORSAqLyxcclxuICAgIGJsZW5kRnVuY0RzdEFscGhhOiA3NzEgLyogT05FX01JTlVTX1NSQ19BTFBIQSAqL1xyXG59O1xyXG4vKipcclxuICogUmVuZGVyZXIgb2YgcG9seWxpbmUgcHJpbWl0aXZlcy4gSXRzIGRlZmF1bHQgcmVuZGVyIHN0YXRlIGlzIGFpbWVkIHRvIHJlbmRlciBvcGFxdWUgcG9seWxpbmVzLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9seWxpbmVSZW5kZXJVbml0IGV4dGVuZHMgQmFzZVBvbHlsaW5lUmVuZGVyVW5pdCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBjYW1lcmEsIHByaW1pdGl2ZVByb3ZpZGVyLCByZW5kZXJTdGF0ZSA9IG5ldyBSZW5kZXJTdGF0ZShERUZBVUxUX1JFTkRFUl9TVEFURV9QQVJBTVMpKSB7XHJcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IGNvbnRleHQuY3JlYXRlUHJvZ3JhbShwb2x5bGluZVZlcnRleFNoYWRlciwgcG9seWxpbmVGcmFnbWVudFNoYWRlciwge1xyXG4gICAgICAgICAgICBkZWZpbmVzOiB7XHJcbiAgICAgICAgICAgICAgICBGSUxURVJfUkFESVVTOiBgZmxvYXQoJHtGSUxURVJfUkFESVVTfSlgLFxyXG4gICAgICAgICAgICAgICAgTUFYX0hBTEZfV0lEVEg6IGBmbG9hdCgke01BWF9IQUxGX1dJRFRIfSlgLFxyXG4gICAgICAgICAgICAgICAgTUFYX0ZJTExfR0FQOiBgZmxvYXQoJHtNQVhfRklMTF9HQVB9KWBcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYXR0cmliTWFwOiB7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhQb3M6IDAgLyogUE9TSVRJT04gKi8sXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhOb3JtYWxQYWNrZWQ6IDUgLyogTk9STUFMICovLFxyXG4gICAgICAgICAgICAgICAgdmVydGV4VXZQYWNrZWQ6IDQgLyogVVYgKi8sXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhXaWR0aEZpbGxHYXA6IDExIC8qIEFVWCAqLyxcclxuICAgICAgICAgICAgICAgIHZlcnRleENvbG9yOiA3IC8qIENPTE9SICovLFxyXG4gICAgICAgICAgICAgICAgdmVydGV4TWl0ZXI6IDEyIC8qIEFVWDEgKi8sXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhWTGltaXQ6IDEzIC8qIEFVWDIgKi8sXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhMZW5ndGg6IDE0IC8qIEFVWDMgKi9cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHN1cGVyKGNvbnRleHQsIHJlbmRlclN0YXRlLCBwcm9ncmFtLCBwcmltaXRpdmVQcm92aWRlciwgY2FtZXJhKTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9wb2x5bGluZS9wb2x5bGluZV9yZW5kZXJfdW5pdC50c1xuLy8gbW9kdWxlIGlkID0gMTM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAqIGFzIHZlYzIgZnJvbSAnLi4vLi4vbWF0aC92ZWN0b3IyJztcclxuaW1wb3J0IHsgZW5jb2RlUmdiYTggfSBmcm9tICcuLi8uLi91dGlsL2NvbG9yJztcclxuaW1wb3J0IEJ1ZmZlcldyaXRlciBmcm9tICcuLi8uLi91dGlsL2J1ZmZlcl93cml0ZXInO1xyXG5pbXBvcnQgeyBQT0xZTElORV9BVFRSSUJVVEVfTUFQUElORyB9IGZyb20gJy4vcG9seWxpbmVfYXR0cmlidXRlX21hcHBpbmcnO1xyXG5pbXBvcnQgeyBmbG9hdFRvVWludDgsIGZsb2F0VG9VaW50MTYgfSBmcm9tICcuLi8uLi91dGlsL2dwdXR5cGVzJztcclxuaW1wb3J0IHsgaW50VG9aSW5kZXggfSBmcm9tICcuLi8uLi91dGlsL3pfaW5kZXgnO1xyXG5pbXBvcnQgeyBjbGFtcCB9IGZyb20gJy4uLy4uL21hdGgvc2NhbGFyJztcclxuLyoqXHJcbiAqIENvbXB1dGVzIG1pdGVyIG9mIGEgam9pbiBiZXR3ZWVuIHR3byBzZWdtZW50cy5cclxuICpcclxuICogQHBhcmFtIG4xIE5vcm1hbCB2ZWN0b3Igb2YgdGhlIGZpcnN0IHNlZ21lbnQuXHJcbiAqIEBwYXJhbSBuMiBOb3JtYWwgdmVjdG9yIG9mIHRoZSBzZWNvbmQgc2VnbWVudC5cclxuICogQHJldHVybnMgTWl0ZXIgdmFsdWUsIGkuZS4gYnkgaG93IG1hdGNoIGRpc3BsYWNlbWVudCBpcyBsb25nZXIgdGhhbiBhIG5vcm1hbFxyXG4gKiAgICAgIG9uZS5cclxuICovXHJcbmZ1bmN0aW9uIGNvbXB1dGVNaXRlcihuMSwgbjIpIHtcclxuICAgIHJldHVybiBNYXRoLnNxcnQoMiAvICgxICsgdmVjMi5kb3QobjEsIG4yKSkpO1xyXG59XHJcbmNvbnN0IFNFR01FTlRfVkVSVEVYX0NPVU5UID0gNDtcclxuY29uc3QgU1FVQVJFX0NBUF9WRVJURVhfQ09VTlQgPSA1O1xyXG5jb25zdCBST1VORF9DQVBfVkVSVEVYX0NPVU5UID0gNDtcclxuY29uc3QgRkxPQVRfTUFYID0gMy40MDI4MjM0NjYzODUyODg2ZSszODtcclxuY29uc3QgTUlURVJfTElNSVQgPSA0O1xyXG5jb25zdCBVVl9QT1NfT05FX1BBQ0tFRCA9IDI1NTsgLy8gcGFja2VkIDFcclxuY29uc3QgVVZfTkVHX09ORV9QQUNLRUQgPSAxOyAvLyBwYWNrZWQgLTFcclxuY29uc3QgVVZfWkVST19QQUNLRUQgPSAxMjg7XHJcbi8qKlxyXG4gKiBQYWNrcyBhIGNvbXBvbmVudCBvZiB1diBpbnRvIGEgdW5zaWduZWQgOC1iaXQgdmFsdWUuIEFmdGVyIHBhY2tpbmcgLTEgd2lsbFxyXG4gKiBiZWNvbWUgMSBhbmQgMSB3aWxsIGJlY29tZSAyNTUuIFRoYXQncyBuZWVkIHRvIGVtdWxhdGUgemVyby1wcmVzZXJ2aW5nXHJcbiAqIG5vcm1hbGl6YXRpb24gKHdlIGNhbid0IHJlbHkgb24gV2ViR0wgdG8gZG8gaXQgZm9yIHVzIDooKS5cclxuICpcclxuICogQHBhcmFtIGMgVGhlIGNvbXBvbmVudC5cclxuICogQHJldHVybnMgUGFja2VkIGNvbXBvbmVudC5cclxuICovXHJcbmZ1bmN0aW9uIHBhY2tVdkNvbXBvbmVudChjKSB7XHJcbiAgICAvLyBXZSBkb24ndCB0cnVuY2F0ZSBoZXJlIGJlY2F1c2UgYnVmZmVyIHdyaXRlciB3aWxsIGRvIHRoYXQgZm9yIHVzLlxyXG4gICAgcmV0dXJuIDEyOCArICgxMjcgKiBjKTtcclxufVxyXG4vKipcclxuICogSGFsZiB3aWR0aCBvZiB0aGUgcG9seWxpbmUgaXMgc3RvcmVkIGluIGEgbm9ybWFsaXplZCBhdHRyaWJ1dGUuIFRoaXMgY29uc3RhbnRcclxuICogZGVmaW5lcyBoYWxmIHdpZHRoIHZhbHVlIG9mIDEgY29ycmVzcG9uZHMgdG8uXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgTUFYX0hBTEZfV0lEVEggPSAyNTUgLyA0OyAvLyBweFxyXG4vKipcclxuICogU2FtZSBhcyBmb3IgcG9seWxpbmUgaGFsZiB3aWR0aCwgYnV0IGZvciBkYXNoIHBhdHRlcm4gZGVmaW5pdGlvbi5cclxuICovXHJcbmV4cG9ydCBjb25zdCBNQVhfRklMTF9HQVAgPSAyNTU7IC8vIHB4XHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvbHlsaW5lQnVmZmVyV3JpdGVyIGV4dGVuZHMgQnVmZmVyV3JpdGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKFBPTFlMSU5FX0FUVFJJQlVURV9NQVBQSU5HLnZlcnRleEJ5dGVTaXplKTtcclxuICAgICAgICB0aGlzLl9kaXNwbGFjZW1lbnQgPSB2ZWMyLmNyZWF0ZSgwLCAwKTtcclxuICAgICAgICB0aGlzLl9wcmV2RGlzcGxhY2VtZW50ID0gdmVjMi5jcmVhdGUoMCwgMCk7XHJcbiAgICAgICAgdGhpcy5faW5pdFBvbHlsaW5lU3RhdGUoW3ZlYzIuWkVSTywgdmVjMi5aRVJPXSwgMCwgMCwgMCwgMCwgMCAvKiBNSVRFUiAqLywgMCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlcyBhIG1lc2ggZm9yIGEgcG9seWxpbmUgd2l0aCBhIGdpdmVuIHN0eWxlLCBiYWtpbmcgYWxsIG5lY2Vzc2FyeVxyXG4gICAgICogcGFyYW1ldGVycyBpbnRvIGF0dHJpYnV0ZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBvbHlsaW5lIFRoZSBwb2x5bGluZS5cclxuICAgICAqIEBwYXJhbSBzdHlsZSBUaGUgcG9seWxpbmUgc3R5bGUuXHJcbiAgICAgKiBAcmV0dXJucyBMb2NhdGlvbiBvZiB0aGUgd3JpdHRlbiBtZXNoIGluIHRoZSBtYW5hZ2VkIGJ1ZmZlcnMuXHJcbiAgICAgKi9cclxuICAgIHdyaXRlUG9seWxpbmUocG9seWxpbmUsIHN0eWxlLCB6SW5kZXgpIHtcclxuICAgICAgICBjb25zdCB7IHZlcnRpY2VzIH0gPSBwb2x5bGluZTtcclxuICAgICAgICBjb25zdCBsYXN0SWR4ID0gdmVydGljZXMubGVuZ3RoIC0gMTtcclxuICAgICAgICBpZiAobGFzdElkeCA8IDEpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPbmUgdmVydGV4IGluIG5vdCBhIHBvbHlsaW5lLiBJdFxcJ3Mgbm90IGV2ZW4gYSBsaW5lLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9pbml0UG9seWxpbmVTdGF0ZSh2ZXJ0aWNlcywgZW5jb2RlUmdiYTgoc3R5bGUuc3Ryb2tlQ29sb3IpLCBzdHlsZS5zdHJva2VXaWR0aCwgc3R5bGUuZGFzaCA/IHN0eWxlLmRhc2guZmlsbCA6IDAsIHN0eWxlLmRhc2ggPyBzdHlsZS5kYXNoLmdhcCA6IDAsIHN0eWxlLmpvaW4sIGludFRvWkluZGV4KHpJbmRleCkpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlQ2FwKHN0eWxlLnN0YXJ0Q2FwLCB2ZXJ0aWNlc1swXSwgMSk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsYXN0SWR4OyArK2kpIHtcclxuICAgICAgICAgICAgdGhpcy5fd3JpdGVTZWdtZW50KHZlcnRpY2VzW2kgLSAxXSwgdmVydGljZXNbaV0sIHZlcnRpY2VzW2kgKyAxXSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3dyaXRlSm9pbih2ZXJ0aWNlc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3dyaXRlTGFzdFNlZ21lbnQodmVydGljZXNbbGFzdElkeCAtIDFdLCB2ZXJ0aWNlc1tsYXN0SWR4XSk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVDYXAoc3R5bGUuZW5kQ2FwLCB2ZXJ0aWNlc1tsYXN0SWR4XSwgMSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kTWVzaCgpO1xyXG4gICAgfVxyXG4gICAgX2luaXRQb2x5bGluZVN0YXRlKHZlcnRpY2VzLCBjb2xvclJnYmE4LCB3aWR0aCwgZmlsbCwgZ2FwLCBqb2luLCB6SW5kZXgpIHtcclxuICAgICAgICB0aGlzLl9iYXNlSW5kZXggPSB0aGlzLl9wb2x5bGluZUxlbmd0aCA9IHRoaXMuX2xhc3REaXJlY3Rpb24gPSAwO1xyXG4gICAgICAgIHRoaXMuX2xhc3RTaWduZWRNaXRlciA9IDE7XHJcbiAgICAgICAgY29uc3QgZGlzcGxhY2VtZW50ID0gdmVjMi5zdWIodmVydGljZXNbMV0sIHZlcnRpY2VzWzBdLCB0aGlzLl9kaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHRoaXMuX3NlZ21lbnRMZW5ndGggPSB2ZWMyLmxlbmd0aChkaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHZlYzIuZGl2bihkaXNwbGFjZW1lbnQsIHRoaXMuX3NlZ21lbnRMZW5ndGgsIGRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdmVjMi5yb3RhdGU5MChkaXNwbGFjZW1lbnQsIGRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdGhpcy5fY29sb3JSZ2JhOCA9IGNvbG9yUmdiYTg7XHJcbiAgICAgICAgdGhpcy5faGFsZldpZHRoRmlsbEdhcFBhY2tlZCA9XHJcbiAgICAgICAgICAgIGZsb2F0VG9VaW50OChjbGFtcCgwLjUgKiB3aWR0aCwgMCwgTUFYX0hBTEZfV0lEVEgpIC8gTUFYX0hBTEZfV0lEVEgpIHxcclxuICAgICAgICAgICAgICAgIGZsb2F0VG9VaW50OChjbGFtcChmaWxsLCAwLCBNQVhfRklMTF9HQVApIC8gTUFYX0ZJTExfR0FQKSA8PCA4IHxcclxuICAgICAgICAgICAgICAgIGZsb2F0VG9VaW50OChjbGFtcChnYXAsIDAsIE1BWF9GSUxMX0dBUCkgLyBNQVhfRklMTF9HQVApIDw8IDE2O1xyXG4gICAgICAgIHRoaXMuX2pvaW4gPSBqb2luO1xyXG4gICAgICAgIHRoaXMuX3pJbmRleCA9IHpJbmRleDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGEgc2luZ2xlIHZlcnRleCBpbnRvIG1hbmFnZWQgdmVydGV4IGJ1ZmZlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcG9zaXRpb24gVmVydGV4IHdvcmxkIHBvc2l0aW9uLlxyXG4gICAgICogQHBhcmFtIG5vcm1hbCBOb3JtYWwgb2Ygc2VnbWVudCB0aGUgdmVydGV4IGJlbG9uZ3MgdG8uXHJcbiAgICAgKiBAcGFyYW0gdSBOb3JtYWxpemVkIGRpc3RhbmNlIHRvIHRoZSBwb2x5bGluZSBhbG9uZyB0aGUgbm9ybWFsLlxyXG4gICAgICogQHBhcmFtIHYgTm9ybWFsaXplZCBkaXN0YW5jZSB0byB0aGUgcG9seWxpbmUgYWxvbmcgdGhlIHRhbmdlbnQuXHJcbiAgICAgKiBAcGFyYW0gcG9seWxpbmVMZW5ndGggRGlzdGFuY2UgdG8gdGhlIGZpcnN0IHZlcnRleCBhbG9uZyB0aGUgcG9seWxpbmUuXHJcbiAgICAgKiBAcGFyYW0gbWl0ZXIgSm9pbiBtaXRlci5cclxuICAgICAqIEBwYXJhbSBsZW5ndGhDb3JyZWN0aW9uTGltaXQgTGltaXQgb24gdGhlIHZlcnRleCBkaXNwbGFjZW1lbnQgYWxvbmcgdGhlXHJcbiAgICAgKiAgICAgIHBvbHlsaW5lLlxyXG4gICAgICovXHJcbiAgICBfd3JpdGVWZXJ0ZXgocG9zaXRpb24sIG5vcm1hbCwgdVBhY2tlZCwgdlBhY2tlZCwgcG9seWxpbmVMZW5ndGgsIG1pdGVyLCBsZW5ndGhDb3JyZWN0aW9uTGltaXQpIHtcclxuICAgICAgICB0aGlzLl93cml0ZVdvcmxkQ29vcmRpbmF0ZShwb3NpdGlvbik7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVIYWxmV29yZHMoZmxvYXRUb1VpbnQxNigwLjUgKiAobm9ybWFsLnggKiBNYXRoLlNRUlQxXzIgKyAxKSksIGZsb2F0VG9VaW50MTYoMC41ICogKG5vcm1hbC55ICogTWF0aC5TUVJUMV8yICsgMSkpKTtcclxuICAgICAgICB0aGlzLl93cml0ZUhhbGZXb3Jkcyh1UGFja2VkLCB2UGFja2VkKTtcclxuICAgICAgICB0aGlzLl93cml0ZVdvcmQodGhpcy5faGFsZldpZHRoRmlsbEdhcFBhY2tlZCk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVGbG9hdDMyKG1pdGVyKTtcclxuICAgICAgICB0aGlzLl93cml0ZUZsb2F0MzIobGVuZ3RoQ29ycmVjdGlvbkxpbWl0KTtcclxuICAgICAgICB0aGlzLl93cml0ZUZsb2F0MzIocG9seWxpbmVMZW5ndGgpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlV29yZCh0aGlzLl9jb2xvclJnYmE4KTtcclxuICAgICAgICB0aGlzLl93cml0ZUZsb2F0MzIodGhpcy5fekluZGV4KTtcclxuICAgIH1cclxuICAgIF93cml0ZUNhcChjYXAsIGVuZFZlcnRleCwgZGlzcGxhY2VtZW50U2lnbikge1xyXG4gICAgICAgIHN3aXRjaCAoY2FwKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMSAvKiBST1VORCAqLzpcclxuICAgICAgICAgICAgICAgIHRoaXMuX3dyaXRlUm91bmRDYXAoZW5kVmVydGV4LCBkaXNwbGFjZW1lbnRTaWduKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDIgLyogU1FVQVJFICovOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5fd3JpdGVTcXVhcmVDYXAoZW5kVmVydGV4LCBkaXNwbGFjZW1lbnRTaWduKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF93cml0ZVJvdW5kQ2FwKGVuZFZlcnRleCwgZGlzcGxhY2VtZW50U2lnbikge1xyXG4gICAgICAgIGNvbnN0IGRpc3BsYWNlbWVudCA9IHZlYzIuY3JlYXRlKDAsIDApO1xyXG4gICAgICAgIGNvbnN0IHBvbHlsaW5lTGVuZ3RoID0gdGhpcy5fcG9seWxpbmVMZW5ndGg7XHJcbiAgICAgICAgdmVjMi5tdWxuKHRoaXMuX2Rpc3BsYWNlbWVudCwgLWRpc3BsYWNlbWVudFNpZ24sIGRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVWZXJ0ZXgoZW5kVmVydGV4LCBkaXNwbGFjZW1lbnQsIFVWX05FR19PTkVfUEFDS0VELCBVVl9aRVJPX1BBQ0tFRCwgcG9seWxpbmVMZW5ndGgsIDEsIEZMT0FUX01BWCk7XHJcbiAgICAgICAgdmVjMi5yb3RhdGU5MCh0aGlzLl9kaXNwbGFjZW1lbnQsIGRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdmVjMi5zdWIoZGlzcGxhY2VtZW50LCB0aGlzLl9kaXNwbGFjZW1lbnQsIGRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdmVjMi5tdWxuKGRpc3BsYWNlbWVudCwgZGlzcGxhY2VtZW50U2lnbiwgZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB0aGlzLl93cml0ZVZlcnRleChlbmRWZXJ0ZXgsIGRpc3BsYWNlbWVudCwgVVZfTkVHX09ORV9QQUNLRUQsIFVWX1BPU19PTkVfUEFDS0VELCBwb2x5bGluZUxlbmd0aCwgMSwgRkxPQVRfTUFYKTtcclxuICAgICAgICB2ZWMyLm11bG4odGhpcy5fZGlzcGxhY2VtZW50LCBkaXNwbGFjZW1lbnRTaWduLCBkaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlVmVydGV4KGVuZFZlcnRleCwgZGlzcGxhY2VtZW50LCBVVl9QT1NfT05FX1BBQ0tFRCwgVVZfWkVST19QQUNLRUQsIHBvbHlsaW5lTGVuZ3RoLCAxLCBGTE9BVF9NQVgpO1xyXG4gICAgICAgIHZlYzIucm90YXRlOTAodGhpcy5fZGlzcGxhY2VtZW50LCBkaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHZlYzIuYWRkKGRpc3BsYWNlbWVudCwgdGhpcy5fZGlzcGxhY2VtZW50LCBkaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHZlYzIubXVsbihkaXNwbGFjZW1lbnQsIGRpc3BsYWNlbWVudFNpZ24sIGRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVWZXJ0ZXgoZW5kVmVydGV4LCBkaXNwbGFjZW1lbnQsIFVWX1BPU19PTkVfUEFDS0VELCBVVl9QT1NfT05FX1BBQ0tFRCwgcG9seWxpbmVMZW5ndGgsIDEsIEZMT0FUX01BWCk7XHJcbiAgICAgICAgdGhpcy53cml0ZUluZGljZXNGb3JDb250aW51b3VzU3RyaXAoUk9VTkRfQ0FQX1ZFUlRFWF9DT1VOVCwgdGhpcy5fYmFzZUluZGV4KTtcclxuICAgICAgICB0aGlzLl9iYXNlSW5kZXggKz0gUk9VTkRfQ0FQX1ZFUlRFWF9DT1VOVDtcclxuICAgIH1cclxuICAgIF93cml0ZVNxdWFyZUNhcChlbmRWZXJ0ZXgsIGRpc3BsYWNlbWVudFNpZ24pIHtcclxuICAgICAgICBjb25zdCBkaXNwbGFjZW1lbnQgPSB2ZWMyLmNyZWF0ZSgwLCAwKTtcclxuICAgICAgICBjb25zdCBwb2x5bGluZUxlbmd0aCA9IHRoaXMuX3BvbHlsaW5lTGVuZ3RoO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlVmVydGV4KGVuZFZlcnRleCwgdmVjMi5aRVJPLCBVVl9aRVJPX1BBQ0tFRCwgVVZfWkVST19QQUNLRUQsIHBvbHlsaW5lTGVuZ3RoLCAxLCAwKTtcclxuICAgICAgICB2ZWMyLm11bG4odGhpcy5fZGlzcGxhY2VtZW50LCAtZGlzcGxhY2VtZW50U2lnbiwgZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB0aGlzLl93cml0ZVZlcnRleChlbmRWZXJ0ZXgsIGRpc3BsYWNlbWVudCwgVVZfUE9TX09ORV9QQUNLRUQsIFVWX1pFUk9fUEFDS0VELCBwb2x5bGluZUxlbmd0aCwgMSwgRkxPQVRfTUFYKTtcclxuICAgICAgICB2ZWMyLnJvdGF0ZTkwKHRoaXMuX2Rpc3BsYWNlbWVudCwgZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB2ZWMyLnN1YihkaXNwbGFjZW1lbnQsIHRoaXMuX2Rpc3BsYWNlbWVudCwgZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB2ZWMyLm11bG4oZGlzcGxhY2VtZW50LCBkaXNwbGFjZW1lbnRTaWduLCBkaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlVmVydGV4KGVuZFZlcnRleCwgZGlzcGxhY2VtZW50LCBVVl9QT1NfT05FX1BBQ0tFRCwgVVZfWkVST19QQUNLRUQsIHBvbHlsaW5lTGVuZ3RoLCAxLCBGTE9BVF9NQVgpO1xyXG4gICAgICAgIHZlYzIucm90YXRlOTAodGhpcy5fZGlzcGxhY2VtZW50LCBkaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHZlYzIuc3ViKGRpc3BsYWNlbWVudCwgdGhpcy5fZGlzcGxhY2VtZW50LCBkaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHZlYzIubXVsbihkaXNwbGFjZW1lbnQsIGRpc3BsYWNlbWVudFNpZ24sIGRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVWZXJ0ZXgoZW5kVmVydGV4LCBkaXNwbGFjZW1lbnQsIFVWX1BPU19PTkVfUEFDS0VELCBVVl9aRVJPX1BBQ0tFRCwgcG9seWxpbmVMZW5ndGgsIDEsIEZMT0FUX01BWCk7XHJcbiAgICAgICAgdmVjMi5tdWxuKHRoaXMuX2Rpc3BsYWNlbWVudCwgZGlzcGxhY2VtZW50U2lnbiwgZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB0aGlzLl93cml0ZVZlcnRleChlbmRWZXJ0ZXgsIHRoaXMuX2Rpc3BsYWNlbWVudCwgVVZfUE9TX09ORV9QQUNLRUQsIFVWX1pFUk9fUEFDS0VELCBwb2x5bGluZUxlbmd0aCwgMSwgRkxPQVRfTUFYKTtcclxuICAgICAgICB0aGlzLndyaXRlSW5kaWNlc0ZvckNvbnRpbnVvdXNGYW4oU1FVQVJFX0NBUF9WRVJURVhfQ09VTlQsIHRoaXMuX2Jhc2VJbmRleCk7XHJcbiAgICAgICAgdGhpcy5fYmFzZUluZGV4ICs9IFNRVUFSRV9DQVBfVkVSVEVYX0NPVU5UO1xyXG4gICAgfVxyXG4gICAgX3dyaXRlU2VnbWVudChzdGFydCwgZW5kLCBuZXh0RW5kKSB7XHJcbiAgICAgICAgY29uc3QgZGlzcGxhY2VtZW50ID0gdGhpcy5fZGlzcGxhY2VtZW50O1xyXG4gICAgICAgIGNvbnN0IHBvbHlsaW5lTGVuZ3RoID0gdGhpcy5fcG9seWxpbmVMZW5ndGg7XHJcbiAgICAgICAgY29uc3QgbmV4dFNlZ21lbnRMZW5ndGggPSB2ZWMyLmRpc3RhbmNlKG5leHRFbmQsIGVuZCk7XHJcbiAgICAgICAgY29uc3QgbmV4dFNlZ21lbnROb3JtYWwgPSB2ZWMyLnN1YihuZXh0RW5kLCBlbmQpO1xyXG4gICAgICAgIHZlYzIuZGl2bihuZXh0U2VnbWVudE5vcm1hbCwgbmV4dFNlZ21lbnRMZW5ndGgsIG5leHRTZWdtZW50Tm9ybWFsKTtcclxuICAgICAgICB2ZWMyLnJvdGF0ZTkwKG5leHRTZWdtZW50Tm9ybWFsLCBuZXh0U2VnbWVudE5vcm1hbCk7XHJcbiAgICAgICAgY29uc3QgZGlyZWN0aW9uMSA9IHRoaXMuX2xhc3REaXJlY3Rpb247XHJcbiAgICAgICAgY29uc3QgZGlyZWN0aW9uMiA9IE1hdGguc2lnbih2ZWMyLmNyb3NzWihkaXNwbGFjZW1lbnQsIG5leHRTZWdtZW50Tm9ybWFsKSk7XHJcbiAgICAgICAgY29uc3QgbWl0ZXIxID0gdGhpcy5fbGFzdFNpZ25lZE1pdGVyO1xyXG4gICAgICAgIGNvbnN0IG1pdGVyMiA9IGNvbXB1dGVNaXRlcihkaXNwbGFjZW1lbnQsIG5leHRTZWdtZW50Tm9ybWFsKTtcclxuICAgICAgICB0aGlzLl93cml0ZVZlcnRleChzdGFydCwgZGlzcGxhY2VtZW50LCBVVl9QT1NfT05FX1BBQ0tFRCwgVVZfWkVST19QQUNLRUQsIHBvbHlsaW5lTGVuZ3RoLCBkaXJlY3Rpb24xID09PSAtMSAmJiAodGhpcy5fam9pbiAhPT0gMCAvKiBNSVRFUiAqLyB8fCBNYXRoLmFicyhtaXRlcjEpID4gTUlURVJfTElNSVQpID9cclxuICAgICAgICAgICAgMSA6XHJcbiAgICAgICAgICAgIG1pdGVyMSwgZGlyZWN0aW9uMSA9PT0gLTEgPyAtRkxPQVRfTUFYIDogMC41ICogdGhpcy5fc2VnbWVudExlbmd0aCk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVWZXJ0ZXgoZW5kLCBkaXNwbGFjZW1lbnQsIFVWX1BPU19PTkVfUEFDS0VELCBVVl9aRVJPX1BBQ0tFRCwgcG9seWxpbmVMZW5ndGggKyB0aGlzLl9zZWdtZW50TGVuZ3RoLCBkaXJlY3Rpb24yID09PSAtMSAmJiAodGhpcy5fam9pbiAhPT0gMCAvKiBNSVRFUiAqLyB8fCBtaXRlcjIgPiBNSVRFUl9MSU1JVCkgP1xyXG4gICAgICAgICAgICAxIDpcclxuICAgICAgICAgICAgZGlyZWN0aW9uMiAqIG1pdGVyMiwgZGlyZWN0aW9uMiA9PT0gLTEgPyBGTE9BVF9NQVggOiAtMC41ICogdGhpcy5fc2VnbWVudExlbmd0aCk7XHJcbiAgICAgICAgdmVjMi5pbnZlcnQoZGlzcGxhY2VtZW50LCBkaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlVmVydGV4KHN0YXJ0LCBkaXNwbGFjZW1lbnQsIFVWX05FR19PTkVfUEFDS0VELCBVVl9aRVJPX1BBQ0tFRCwgcG9seWxpbmVMZW5ndGgsIGRpcmVjdGlvbjEgPT09IDEgJiYgKHRoaXMuX2pvaW4gIT09IDAgLyogTUlURVIgKi8gfHwgTWF0aC5hYnMobWl0ZXIxKSA+IE1JVEVSX0xJTUlUKSA/XHJcbiAgICAgICAgICAgIDEgOlxyXG4gICAgICAgICAgICBtaXRlcjEsIGRpcmVjdGlvbjEgPT09IDEgPyAtRkxPQVRfTUFYIDogMC41ICogdGhpcy5fc2VnbWVudExlbmd0aCk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVWZXJ0ZXgoZW5kLCBkaXNwbGFjZW1lbnQsIFVWX05FR19PTkVfUEFDS0VELCBVVl9aRVJPX1BBQ0tFRCwgcG9seWxpbmVMZW5ndGggKyB0aGlzLl9zZWdtZW50TGVuZ3RoLCBkaXJlY3Rpb24yID09PSAxICYmICh0aGlzLl9qb2luICE9PSAwIC8qIE1JVEVSICovIHx8IG1pdGVyMiA+IE1JVEVSX0xJTUlUKSA/XHJcbiAgICAgICAgICAgIDEgOlxyXG4gICAgICAgICAgICBkaXJlY3Rpb24yICogbWl0ZXIyLCBkaXJlY3Rpb24yID09PSAxID8gRkxPQVRfTUFYIDogLTAuNSAqIHRoaXMuX3NlZ21lbnRMZW5ndGgpO1xyXG4gICAgICAgIHRoaXMud3JpdGVJbmRpY2VzRm9yQ29udGludW91c1N0cmlwKFNFR01FTlRfVkVSVEVYX0NPVU5ULCB0aGlzLl9iYXNlSW5kZXgpO1xyXG4gICAgICAgIHRoaXMuX2Jhc2VJbmRleCArPSBTRUdNRU5UX1ZFUlRFWF9DT1VOVDtcclxuICAgICAgICB0aGlzLl9sYXN0U2lnbmVkTWl0ZXIgPSAtZGlyZWN0aW9uMiAqIG1pdGVyMjtcclxuICAgICAgICB0aGlzLl9sYXN0RGlyZWN0aW9uID0gZGlyZWN0aW9uMjtcclxuICAgICAgICB2ZWMyLmNvcHkoZGlzcGxhY2VtZW50LCB0aGlzLl9wcmV2RGlzcGxhY2VtZW50KTtcclxuICAgICAgICB2ZWMyLmNvcHkobmV4dFNlZ21lbnROb3JtYWwsIGRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdGhpcy5fcG9seWxpbmVMZW5ndGggKz0gdGhpcy5fc2VnbWVudExlbmd0aDtcclxuICAgICAgICB0aGlzLl9zZWdtZW50TGVuZ3RoID0gbmV4dFNlZ21lbnRMZW5ndGg7XHJcbiAgICB9XHJcbiAgICBfd3JpdGVKb2luKGpvaW5WZXJ0ZXgpIHtcclxuICAgICAgICBzd2l0Y2ggKHRoaXMuX2pvaW4pIHtcclxuICAgICAgICAgICAgY2FzZSAyIC8qIEJFVkVMICovOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5fd3JpdGVCZXZlbEpvaW4oam9pblZlcnRleCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAxIC8qIFJPVU5EICovOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5fd3JpdGVSb3VuZEpvaW4oam9pblZlcnRleCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAwIC8qIE1JVEVSICovOlxyXG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMuX2xhc3RTaWduZWRNaXRlcikgPiBNSVRFUl9MSU1JVCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3dyaXRlQmV2ZWxKb2luKGpvaW5WZXJ0ZXgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3dyaXRlQmV2ZWxKb2luKGpvaW5WZXJ0ZXgpIHtcclxuICAgICAgICBjb25zdCBsYXN0RGlyZWN0aW9uID0gdGhpcy5fbGFzdERpcmVjdGlvbjtcclxuICAgICAgICBjb25zdCBkaXNwbGFjZW1lbnQgPSB2ZWMyLmludmVydCh0aGlzLl9kaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHZlYzIuYWRkKGRpc3BsYWNlbWVudCwgdGhpcy5fcHJldkRpc3BsYWNlbWVudCwgZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB2ZWMyLm11bG4oZGlzcGxhY2VtZW50LCAwLjUgKiBsYXN0RGlyZWN0aW9uLCBkaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlVmVydGV4KGpvaW5WZXJ0ZXgsIGRpc3BsYWNlbWVudCwgbGFzdERpcmVjdGlvbiA9PT0gLTEgLyogTEVGVCAqLyA/XHJcbiAgICAgICAgICAgIFVWX1BPU19PTkVfUEFDS0VEIDpcclxuICAgICAgICAgICAgVVZfTkVHX09ORV9QQUNLRUQsIFVWX1pFUk9fUEFDS0VELCB0aGlzLl9wb2x5bGluZUxlbmd0aCwgMSwgMSk7XHJcbiAgICAgICAgY29uc3QgYmFzZUluZGV4ID0gdGhpcy5fYmFzZUluZGV4O1xyXG4gICAgICAgIHRoaXMud3JpdGVJbmRpY2VzKFtcclxuICAgICAgICAgICAgYmFzZUluZGV4IC0gMSxcclxuICAgICAgICAgICAgYmFzZUluZGV4IC0gMyxcclxuICAgICAgICAgICAgYmFzZUluZGV4LFxyXG4gICAgICAgICAgICBiYXNlSW5kZXgsXHJcbiAgICAgICAgICAgIGxhc3REaXJlY3Rpb24gPT09IC0xIC8qIExFRlQgKi8gPyBiYXNlSW5kZXggKyAxIDogYmFzZUluZGV4ICsgMyxcclxuICAgICAgICAgICAgbGFzdERpcmVjdGlvbiA9PT0gLTEgLyogTEVGVCAqLyA/IGJhc2VJbmRleCArIDMgOiBiYXNlSW5kZXggKyAxXHJcbiAgICAgICAgXSk7XHJcbiAgICAgICAgdGhpcy5fYmFzZUluZGV4ICs9IDE7XHJcbiAgICB9XHJcbiAgICBfd3JpdGVSb3VuZEpvaW4oam9pblZlcnRleCkge1xyXG4gICAgICAgIGNvbnN0IHBvbHlsaW5lTGVuZ3RoID0gdGhpcy5fcG9seWxpbmVMZW5ndGg7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVWZXJ0ZXgoam9pblZlcnRleCwgdmVjMi5aRVJPLCBVVl9aRVJPX1BBQ0tFRCwgVVZfWkVST19QQUNLRUQsIHBvbHlsaW5lTGVuZ3RoLCAwLCAwKTtcclxuICAgICAgICBjb25zdCBsYXN0RGlyZWN0aW9uID0gdGhpcy5fbGFzdERpcmVjdGlvbjtcclxuICAgICAgICBjb25zdCBtaWRkbGVEaXNwbGFjZW1lbnQgPSB2ZWMyLmludmVydCh0aGlzLl9wcmV2RGlzcGxhY2VtZW50KTtcclxuICAgICAgICB2ZWMyLmFkZCh0aGlzLl9kaXNwbGFjZW1lbnQsIG1pZGRsZURpc3BsYWNlbWVudCwgbWlkZGxlRGlzcGxhY2VtZW50KTtcclxuICAgICAgICB2ZWMyLm5vcm1hbGl6ZShtaWRkbGVEaXNwbGFjZW1lbnQsIG1pZGRsZURpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgY29uc3QgZGlzcGxhY2VtZW50ID0gdmVjMi5pbnZlcnQodGhpcy5fcHJldkRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgY29uc3QgbWl0ZXIxID0gY29tcHV0ZU1pdGVyKG1pZGRsZURpc3BsYWNlbWVudCwgZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB2ZWMyLmFkZChkaXNwbGFjZW1lbnQsIG1pZGRsZURpc3BsYWNlbWVudCwgZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB2ZWMyLm5vcm1hbGl6ZShkaXNwbGFjZW1lbnQsIGRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdmVjMi5tdWxuKGRpc3BsYWNlbWVudCwgLWxhc3REaXJlY3Rpb24gKiBtaXRlcjEsIGRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVWZXJ0ZXgoam9pblZlcnRleCwgZGlzcGxhY2VtZW50LCBsYXN0RGlyZWN0aW9uID09PSAtMSAvKiBMRUZUICovID9cclxuICAgICAgICAgICAgVVZfUE9TX09ORV9QQUNLRUQgOlxyXG4gICAgICAgICAgICBVVl9ORUdfT05FX1BBQ0tFRCwgcGFja1V2Q29tcG9uZW50KE1hdGguc3FydChtaXRlcjEgKiBtaXRlcjEgLSAxKSksIHBvbHlsaW5lTGVuZ3RoLCAxLCBGTE9BVF9NQVgpO1xyXG4gICAgICAgIHZlYzIubXVsbihtaWRkbGVEaXNwbGFjZW1lbnQsIC1sYXN0RGlyZWN0aW9uLCBkaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlVmVydGV4KGpvaW5WZXJ0ZXgsIGRpc3BsYWNlbWVudCwgbGFzdERpcmVjdGlvbiA9PT0gLTEgLyogTEVGVCAqLyA/XHJcbiAgICAgICAgICAgIFVWX1BPU19PTkVfUEFDS0VEIDpcclxuICAgICAgICAgICAgVVZfTkVHX09ORV9QQUNLRUQsIFVWX1pFUk9fUEFDS0VELCBwb2x5bGluZUxlbmd0aCwgMSwgRkxPQVRfTUFYKTtcclxuICAgICAgICBjb25zdCBtaXRlcjIgPSBjb21wdXRlTWl0ZXIobWlkZGxlRGlzcGxhY2VtZW50LCB0aGlzLl9kaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHZlYzIuYWRkKHRoaXMuX2Rpc3BsYWNlbWVudCwgbWlkZGxlRGlzcGxhY2VtZW50LCBkaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHZlYzIubm9ybWFsaXplKGRpc3BsYWNlbWVudCwgZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB2ZWMyLm11bG4oZGlzcGxhY2VtZW50LCAtbGFzdERpcmVjdGlvbiAqIG1pdGVyMiwgZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB0aGlzLl93cml0ZVZlcnRleChqb2luVmVydGV4LCBkaXNwbGFjZW1lbnQsIGxhc3REaXJlY3Rpb24gPT09IC0xIC8qIExFRlQgKi8gP1xyXG4gICAgICAgICAgICBVVl9QT1NfT05FX1BBQ0tFRCA6XHJcbiAgICAgICAgICAgIFVWX05FR19PTkVfUEFDS0VELCBwYWNrVXZDb21wb25lbnQoTWF0aC5zcXJ0KG1pdGVyMiAqIG1pdGVyMiAtIDEpKSwgcG9seWxpbmVMZW5ndGgsIDEsIEZMT0FUX01BWCk7XHJcbiAgICAgICAgY29uc3QgYmFzZUluZGV4ID0gdGhpcy5fYmFzZUluZGV4O1xyXG4gICAgICAgIHRoaXMud3JpdGVJbmRpY2VzKFtcclxuICAgICAgICAgICAgYmFzZUluZGV4IC0gMyxcclxuICAgICAgICAgICAgYmFzZUluZGV4IC0gMSxcclxuICAgICAgICAgICAgYmFzZUluZGV4LFxyXG4gICAgICAgICAgICBiYXNlSW5kZXgsXHJcbiAgICAgICAgICAgIGxhc3REaXJlY3Rpb24gPT09IC0xIC8qIExFRlQgKi8gPyBiYXNlSW5kZXggLSAzIDogYmFzZUluZGV4IC0gMSxcclxuICAgICAgICAgICAgYmFzZUluZGV4ICsgMSxcclxuICAgICAgICAgICAgYmFzZUluZGV4LFxyXG4gICAgICAgICAgICBiYXNlSW5kZXggKyAxLFxyXG4gICAgICAgICAgICBiYXNlSW5kZXggKyAyLFxyXG4gICAgICAgICAgICBiYXNlSW5kZXgsXHJcbiAgICAgICAgICAgIGJhc2VJbmRleCArIDIsXHJcbiAgICAgICAgICAgIGJhc2VJbmRleCArIDMsXHJcbiAgICAgICAgICAgIGJhc2VJbmRleCxcclxuICAgICAgICAgICAgYmFzZUluZGV4ICsgMyxcclxuICAgICAgICAgICAgbGFzdERpcmVjdGlvbiA9PT0gLTEgLyogTEVGVCAqLyA/IGJhc2VJbmRleCArIDQgOiBiYXNlSW5kZXggKyA2LFxyXG4gICAgICAgICAgICBiYXNlSW5kZXgsXHJcbiAgICAgICAgICAgIGJhc2VJbmRleCArIDQsXHJcbiAgICAgICAgICAgIGJhc2VJbmRleCArIDZcclxuICAgICAgICBdKTtcclxuICAgICAgICB0aGlzLl9iYXNlSW5kZXggKz0gNDtcclxuICAgIH1cclxuICAgIF93cml0ZUxhc3RTZWdtZW50KHN0YXJ0LCBlbmQpIHtcclxuICAgICAgICBjb25zdCBkaXNwbGFjZW1lbnQgPSB0aGlzLl9kaXNwbGFjZW1lbnQ7XHJcbiAgICAgICAgY29uc3QgbGFzdERpcmVjdGlvbiA9IHRoaXMuX2xhc3REaXJlY3Rpb247XHJcbiAgICAgICAgY29uc3QgcG9seWxpbmVMZW5ndGggPSB0aGlzLl9wb2x5bGluZUxlbmd0aDtcclxuICAgICAgICBjb25zdCBtaXRlciA9IHRoaXMuX2xhc3RTaWduZWRNaXRlcjtcclxuICAgICAgICB0aGlzLl93cml0ZVZlcnRleChzdGFydCwgZGlzcGxhY2VtZW50LCBVVl9QT1NfT05FX1BBQ0tFRCwgVVZfWkVST19QQUNLRUQsIHBvbHlsaW5lTGVuZ3RoLCBsYXN0RGlyZWN0aW9uID09PSAtMSAvKiBMRUZUICovICYmICh0aGlzLl9qb2luICE9PSAwIC8qIE1JVEVSICovIHx8IE1hdGguYWJzKG1pdGVyKSA+IE1JVEVSX0xJTUlUKSA/XHJcbiAgICAgICAgICAgIDEgOlxyXG4gICAgICAgICAgICBtaXRlciwgbGFzdERpcmVjdGlvbiA9PT0gLTEgLyogTEVGVCAqLyA/IC1GTE9BVF9NQVggOiB0aGlzLl9zZWdtZW50TGVuZ3RoKTtcclxuICAgICAgICB0aGlzLl93cml0ZVZlcnRleChlbmQsIGRpc3BsYWNlbWVudCwgVVZfUE9TX09ORV9QQUNLRUQsIFVWX1pFUk9fUEFDS0VELCBwb2x5bGluZUxlbmd0aCArIHRoaXMuX3NlZ21lbnRMZW5ndGgsIDEsIEZMT0FUX01BWCk7XHJcbiAgICAgICAgdmVjMi5pbnZlcnQoZGlzcGxhY2VtZW50LCBkaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlVmVydGV4KHN0YXJ0LCBkaXNwbGFjZW1lbnQsIFVWX05FR19PTkVfUEFDS0VELCBVVl9aRVJPX1BBQ0tFRCwgcG9seWxpbmVMZW5ndGgsIGxhc3REaXJlY3Rpb24gPT09IDEgLyogUklHSFQgKi8gJiYgKHRoaXMuX2pvaW4gIT09IDAgLyogTUlURVIgKi8gfHwgTWF0aC5hYnMobWl0ZXIpID4gTUlURVJfTElNSVQpID9cclxuICAgICAgICAgICAgMSA6XHJcbiAgICAgICAgICAgIG1pdGVyLCBsYXN0RGlyZWN0aW9uID09PSAxIC8qIFJJR0hUICovID8gLUZMT0FUX01BWCA6IHRoaXMuX3NlZ21lbnRMZW5ndGgpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlVmVydGV4KGVuZCwgZGlzcGxhY2VtZW50LCBVVl9ORUdfT05FX1BBQ0tFRCwgVVZfWkVST19QQUNLRUQsIHBvbHlsaW5lTGVuZ3RoICsgdGhpcy5fc2VnbWVudExlbmd0aCwgMSwgRkxPQVRfTUFYKTtcclxuICAgICAgICB0aGlzLndyaXRlSW5kaWNlc0ZvckNvbnRpbnVvdXNTdHJpcChTRUdNRU5UX1ZFUlRFWF9DT1VOVCwgdGhpcy5fYmFzZUluZGV4KTtcclxuICAgICAgICB0aGlzLl9iYXNlSW5kZXggKz0gU0VHTUVOVF9WRVJURVhfQ09VTlQ7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL3BvbHlsaW5lL3BvbHlsaW5lX2J1ZmZlcl93cml0ZXIudHNcbi8vIG1vZHVsZSBpZCA9IDEzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwiI3ZlcnNpb24gMTAwXFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG4jaWZuZGVmIEZJTFRFUl9SQURJVVNcXG4jICAgZXJyb3IgRklMVEVSX1JBRElVUyBtdXN0IGJlIHNldFxcbiNlbmRpZlxcblxcbiNpZm5kZWYgTUFYX0hBTEZfV0lEVEhcXG4jICAgZXJyb3IgTUFYX0hBTEZfV0lEVEggbXVzdCBiZSBzZXRcXG4jZW5kaWZcXG5cXG4jaWZuZGVmIE1BWF9GSUxMX0dBUFxcbiMgICBlcnJvciBNQVhfRklMTF9HQVAgbXVzdCBiZSBzZXRcXG4jZW5kaWZcXG5cXG5hdHRyaWJ1dGUgdmVjNCB2ZXJ0ZXhQb3M7XFxuYXR0cmlidXRlIHZlYzIgdmVydGV4Tm9ybWFsUGFja2VkO1xcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleFV2UGFja2VkO1xcbmF0dHJpYnV0ZSB2ZWMzIHZlcnRleFdpZHRoRmlsbEdhcDtcXG5hdHRyaWJ1dGUgdmVjNCB2ZXJ0ZXhDb2xvcjtcXG5hdHRyaWJ1dGUgZmxvYXQgdmVydGV4TWl0ZXI7XFxuYXR0cmlidXRlIGZsb2F0IHZlcnRleFZMaW1pdDtcXG5hdHRyaWJ1dGUgZmxvYXQgdmVydGV4TGVuZ3RoO1xcblxcbnVuaWZvcm0gdmVjMiBsb29rQXRIaWdoO1xcbnVuaWZvcm0gdmVjMiBsb29rQXRMb3c7XFxudW5pZm9ybSBtYXQ0IHZpZXdQcm9qTWF0cml4O1xcbnVuaWZvcm0gZmxvYXQgd29ybGRUb1B4RmFjdG9yO1xcblxcbnZhcnlpbmcgdmVjMiB1djtcXG52YXJ5aW5nIGZsb2F0IGxlbjtcXG52YXJ5aW5nIGZsb2F0IGhhbGZXaWR0aDtcXG52YXJ5aW5nIHZlYzMgZGFzaDtcXG52YXJ5aW5nIHZlYzQgY29sb3I7XFxuXFxuY29uc3QgZmxvYXQgWVZfSCA9IDEuOTk5OTY5NDgyNDIxODc1O1xcbmNvbnN0IGZsb2F0IFlWX0wgPSAwLjAwMDAzMDUxNzExMjQ2MzcxMjY5MjtcXG5jb25zdCB2ZWM0IFlWX0hITEwgPSB2ZWM0KFlWX0gsIFlWX0gsIFlWX0wsIFlWX0wpO1xcblxcbmNvbnN0IGZsb2F0IFNRUlQyID0gMS40MTQyMTM1MzgxNjk4NjA4O1xcblxcbnZlYzIgdW5wYWNrVXYoY29uc3QgaW4gdmVjMiB1dikge1xcbiAgICByZXR1cm4gKHV2IC0gMTI4LikgLyAxMjcuO1xcbn1cXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgICB2ZWMyIG5vcm1hbCA9ICgyLjAgKiB2ZXJ0ZXhOb3JtYWxQYWNrZWQgLSAxLjApICogU1FSVDI7XFxuXFxuICAgIGhhbGZXaWR0aCA9IGZsb2F0KE1BWF9IQUxGX1dJRFRIKSAqIHZlcnRleFdpZHRoRmlsbEdhcC54O1xcbiAgICBoYWxmV2lkdGggKz0gRklMVEVSX1JBRElVUztcXG5cXG4gICAgZmxvYXQgdGFuZ2VudExlbmd0aCA9IG1pbihcXG4gICAgICAgIHNxcnQodmVydGV4TWl0ZXIgKiB2ZXJ0ZXhNaXRlciAtIDEuKSAqIGhhbGZXaWR0aCAqIHdvcmxkVG9QeEZhY3RvcixcXG4gICAgICAgIGFicyh2ZXJ0ZXhWTGltaXQpXFxuICAgICk7XFxuXFxuICAgIHZlYzQgbG9va0F0ID0gdmVjNChsb29rQXRIaWdoLCBsb29rQXRMb3cpO1xcbiAgICB2ZWM0IHJlbGF0aXZlVG9FeWVQb3NpdGlvbiA9IFlWX0hITEwgKiAodmVydGV4UG9zIC0gbG9va0F0KTtcXG5cXG4gICAgZ2xfUG9zaXRpb24gPSB2aWV3UHJvak1hdHJpeCAqIHZlYzQoXFxuICAgICAgICByZWxhdGl2ZVRvRXllUG9zaXRpb24ueHkgKyByZWxhdGl2ZVRvRXllUG9zaXRpb24uencgK1xcbiAgICAgICAgICAgICAgICB3b3JsZFRvUHhGYWN0b3IgKiBoYWxmV2lkdGggKiBub3JtYWwgLVxcbiAgICAgICAgICAgICAgICAgICAgc2lnbih2ZXJ0ZXhNaXRlcikgKiB0YW5nZW50TGVuZ3RoICogdmVjMihub3JtYWwueSwgLW5vcm1hbC54KSxcXG4gICAgICAgIDAsXFxuICAgICAgICAxXFxuICAgICk7XFxuXFxuICAgIHV2ID0gdW5wYWNrVXYodmVydGV4VXZQYWNrZWQpICogaGFsZldpZHRoO1xcbiAgICBsZW4gPSAodmVydGV4TGVuZ3RoICsgc2lnbih2ZXJ0ZXhWTGltaXQpICogdGFuZ2VudExlbmd0aCkgLyB3b3JsZFRvUHhGYWN0b3I7XFxuXFxuICAgIGRhc2gueHkgPSB2ZWMyKE1BWF9GSUxMX0dBUCkgKiB2ZXJ0ZXhXaWR0aEZpbGxHYXAueXo7XFxuICAgIGRhc2gueiA9IGRhc2gueCArIGRhc2gueTtcXG5cXG4gICAgY29sb3IgPSB2ZXJ0ZXhDb2xvcjtcXG4gICAgY29sb3IucmdiICo9IGNvbG9yLmE7XFxufVxcblwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvcG9seWxpbmUvc2hhZGVyL3BvbHlsaW5lLnZlcnRcbi8vIG1vZHVsZSBpZCA9IDEzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwiI3ZlcnNpb24gMTAwXFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG4jaWZuZGVmIEZJTFRFUl9SQURJVVNcXG4jICAgZXJyb3IgRklMVEVSX1JBRElVUyBtdXN0IGJlIHNldFxcbiNlbmRpZlxcblxcbnZhcnlpbmcgaGlnaHAgdmVjMiB1djtcXG52YXJ5aW5nIGhpZ2hwIGZsb2F0IGxlbjtcXG52YXJ5aW5nIGhpZ2hwIGZsb2F0IGhhbGZXaWR0aDtcXG52YXJ5aW5nIGxvd3AgdmVjMyBkYXNoO1xcbnZhcnlpbmcgbG93cCB2ZWM0IGNvbG9yO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIGxvd3AgZmxvYXQgYWxwaGEgPVxcbiAgICAgICAgc21vb3Roc3RlcCgwLjAsIEZJTFRFUl9SQURJVVMgKyBtaW4oRklMVEVSX1JBRElVUywgaGFsZldpZHRoKSwgaGFsZldpZHRoIC0gbGVuZ3RoKHV2KSk7XFxuXFxuICAgIGlmIChkYXNoLnogPiAwLjApIHtcXG4gICAgICAgIGxvd3AgdmVjMyBoYWxmRGFzaCA9IGRhc2ggKiAwLjU7XFxuICAgICAgICBsb3dwIGZsb2F0IGRhc2hQaGFzZSA9IG1vZChsZW4gKyBoYWxmRGFzaC55LCBkYXNoLnopO1xcbiAgICAgICAgbG93cCBmbG9hdCByID0gbWluKEZJTFRFUl9SQURJVVMsIGhhbGZEYXNoLnkpO1xcblxcbiAgICAgICAgYWxwaGEgKj0gc21vb3Roc3RlcCgtciwgciwgaGFsZkRhc2gueCAtIGFicyhkYXNoUGhhc2UgLSBoYWxmRGFzaC56KSk7XFxuICAgIH1cXG5cXG4gICAgZ2xfRnJhZ0NvbG9yID0gY29sb3IgKiBhbHBoYTtcXG59XFxuXCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9wb2x5bGluZS9zaGFkZXIvcG9seWxpbmUuZnJhZ1xuLy8gbW9kdWxlIGlkID0gMTM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB0ZXh0dXJlZFBvbHlnb25WZXJ0ZXhTaGFkZXIgZnJvbSAnLi9zaGFkZXIvdGV4dHVyZWRfcG9seWdvbi52ZXJ0JztcclxuaW1wb3J0IHRleHR1cmVkUG9seWdvbkZyYWdtZW50U2hhZGVyIGZyb20gJy4vc2hhZGVyL3RleHR1cmVkX3BvbHlnb24uZnJhZyc7XHJcbmltcG9ydCAqIGFzIHZlYzIgZnJvbSAnLi4vLi4vLi4vbWF0aC92ZWN0b3IyJztcclxuaW1wb3J0IFJlbmRlclN0YXRlIGZyb20gJy4uLy4uLy4uL3JlbmRlci9zdGF0ZSc7XHJcbmltcG9ydCB7IEJMRU5EX09WRVJfUkVOREVSX1NUQVRFIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyL3N0YXRlJztcclxuaW1wb3J0IFdvcmxkUHJpbWl0aXZlUmVuZGVyVW5pdCBmcm9tICcuLi93b3JsZF9wcmltaXRpdmVfcmVuZGVyX3VuaXQnO1xyXG5jb25zdCBSRU5ERVJfU1RBVEUgPSBuZXcgUmVuZGVyU3RhdGUoQkxFTkRfT1ZFUl9SRU5ERVJfU1RBVEUsIHtcclxuICAgIGRlcHRoVGVzdDogdHJ1ZSxcclxuICAgIGRlcHRoTWFzazogZmFsc2UsXHJcbiAgICBkZXB0aEZ1bmM6IDUxOCAvKiBHUkVBVEVSX09SX0VRVUFMICovXHJcbn0pO1xyXG4vKipcclxuICogUmVuZGVyZXIgb2YgcG9seWxpbmUgcHJpbWl0aXZlcy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRleHR1cmVkUG9seWdvblJlbmRlclVuaXQgZXh0ZW5kcyBXb3JsZFByaW1pdGl2ZVJlbmRlclVuaXQge1xyXG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgcHJpbWl0aXZlUHJvdmlkZXIpIHtcclxuICAgICAgICBjb25zdCBwcm9ncmFtID0gY29udGV4dC5jcmVhdGVQcm9ncmFtKHRleHR1cmVkUG9seWdvblZlcnRleFNoYWRlciwgdGV4dHVyZWRQb2x5Z29uRnJhZ21lbnRTaGFkZXIsIHtcclxuICAgICAgICAgICAgYXR0cmliTWFwOiB7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhQb3NIaWdoOiAwIC8qIFBPU0lUSU9OX0hJR0ggKi8sXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhQb3NMb3c6IDEgLyogUE9TSVRJT05fTE9XICovLFxyXG4gICAgICAgICAgICAgICAgdmVydGV4VVY6IDQgLyogVVYgKi8sXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhJbWFnZVNjYWxlOiAxMSAvKiBBVVggKi8sXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhaSW5kZXg6IDEwIC8qIFpfSU5ERVggKi9cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHN1cGVyKGNvbnRleHQsIFJFTkRFUl9TVEFURSwgcHJvZ3JhbSwgcHJpbWl0aXZlUHJvdmlkZXIpO1xyXG4gICAgICAgIHRoaXMuX2F0bGFzU2l6ZVVuaWZvcm0gPSB2ZWMyLmNyZWF0ZSgwLCAwKTtcclxuICAgICAgICBjb250ZXh0LmJpbmRQcm9ncmFtKHByb2dyYW0pO1xyXG4gICAgICAgIHByb2dyYW0uc2V0SW50U2NhbGFyVW5pZm9ybSgnYXRsYXMnLCAwKTtcclxuICAgIH1cclxuICAgIF9yZW5kZXJCYXRjaChtZW1vcnlCYXRjaCkge1xyXG4gICAgICAgIGNvbnN0IGF0bGFzID0gbWVtb3J5QmF0Y2guZmlyc3RQcmltaXRpdmUuYXRsYXM7XHJcbiAgICAgICAgdGhpcy5fYXRsYXNTaXplVW5pZm9ybS54ID0gYXRsYXMud2lkdGg7XHJcbiAgICAgICAgdGhpcy5fYXRsYXNTaXplVW5pZm9ybS55ID0gYXRsYXMuaGVpZ2h0O1xyXG4gICAgICAgIGlmIChhdGxhcy5pc0RpcnR5KSB7XHJcbiAgICAgICAgICAgIGF0bGFzLnN5bmNUZXh0dXJlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3Byb2dyYW0uc2V0VmVjdG9yMlVuaWZvcm0oJ2F0bGFzU2l6ZScsIHRoaXMuX2F0bGFzU2l6ZVVuaWZvcm0pO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFRleHR1cmVVbml0KDApO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFRleHR1cmUoYXRsYXMudGV4dHVyZSk7XHJcbiAgICAgICAgc3VwZXIuX3JlbmRlckJhdGNoKG1lbW9yeUJhdGNoKTtcclxuICAgIH1cclxuICAgIF9jYW5CYXRjaEFkamFjZW50UHJpbWl0aXZlcyhhLCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIHN1cGVyLl9jYW5CYXRjaEFkamFjZW50UHJpbWl0aXZlcyhhLCBiKSAmJiAoYS5hdGxhcyA9PT0gYi5hdGxhcyk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvcG9seWdvbi90ZXh0dXJlZF9wb2x5Z29uX3JlbmRlcl91bml0LnRzXG4vLyBtb2R1bGUgaWQgPSAxNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcIiN2ZXJzaW9uIDEwMFxcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxuYXR0cmlidXRlIHZlYzIgdmVydGV4UG9zSGlnaDtcXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhQb3NMb3c7XFxuYXR0cmlidXRlIHZlYzQgdmVydGV4VVY7XFxuYXR0cmlidXRlIGZsb2F0IHZlcnRleEltYWdlU2NhbGU7XFxuYXR0cmlidXRlIGZsb2F0IHZlcnRleFpJbmRleDtcXG5cXG51bmlmb3JtIHZlYzIgbG9va0F0SGlnaDtcXG51bmlmb3JtIHZlYzIgbG9va0F0TG93O1xcbnVuaWZvcm0gbWF0NCB2aWV3UHJvak1hdHJpeDtcXG5cXG52YXJ5aW5nIHZlYzIgdXZQb3NpdGlvbjtcXG52YXJ5aW5nIHZlYzIgdGV4dHVyZVNpemU7XFxudmFyeWluZyB2ZWMyIHV2RGlzcGxhY2VtZW50O1xcblxcbmNvbnN0IGZsb2F0IFlWX0ggPSAxLjk5OTk2OTQ4MjQyMTg3NTtcXG5jb25zdCBmbG9hdCBZVl9MID0gMC4wMDAwMzA1MTcxMTI0NjM3MTI2OTI7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gICAgdXZQb3NpdGlvbiA9IHZlcnRleFVWLnh5O1xcbiAgICB0ZXh0dXJlU2l6ZSA9IHZlcnRleFVWLnp3O1xcblxcbiAgICAvLyBUaGUgc2FtZSBwYXR0ZXJuIGltYWdlIHNob3VsZCBtYXRjaCBhY3Jvc3MgbXVsdGlwbGUgKHVzdWFsbHkgYWRqYWNlbnQpIHBvbHlnb25zIGFuZCBpdCBzaG91bGQgaGF2ZVxcbiAgICAvLyBzdGFibGUgcG9zaXRpb24gcmVhbHRpdmUgdG8gdGhlIHBvbHlnb24uIEFsc28gcGF0dGVybiBpcyByZXBlYXRlZCBhdCBib3RoIGRpcmVjdGlvbnMuXFxuICAgIC8vIFRvIG1lZXQgdGhlc2UgcmVxdWlyZW1lbnRzIHRoZSB3b3JsZCBpcyBjb3ZlcmVkICh2aXJ0dWFsbHkpIGJ5IGEgdGV4dHVyZSBvZiBhcHByb3ByaWF0ZSBzaXplIChyZXBlYXRlZCBpbWFnZSlcXG4gICAgLy8gYW5kIHZlcnRleCBjb29yZGluYXRlcyBhcmUgbWFwcGVkIHRvIHRoZXNlIHRleHR1cmUgY29vcmRpbmF0ZXMgKHV2RGlzcGxhY2VtZW50KS5cXG4gICAgLy8gQnV0IGR1ZSB0byBsaW1pdGVkIHByZWNpc2lvbiB3ZSd2ZSBnb3QgdG8gd29yayB3aXRoIFxcXCJuYXJyb3dcXFwiIGZsb2F0cyAoYXMgaXQgaXMgZG9uZSBpbiB3b3JsZCBwb3NpdGlvbiBjYWxjdWxhdGlvbik6XFxuICAgIC8vICAgMS4gY2FsY3VsYXRlIGhvdyBiaWcgdGV4dHVyZSBwYXR0ZXJuIGluIHdvcmxkIGNvb3JkaW5hdGVzIChzY2FsZWRUZXh0dXJlU2l6ZSlcXG4gICAgLy8gICAyLiBmaW5kIHRoZSBjbG9zZXN0IHRvIGV5ZSBjb29yZGluYXRlcyB0ZXh0dXJlIGJhc2UgcG9pbnQgKHRoZSBib3R0b20gbGVmdCBwb2ludCBvZiB0aGUgcGF0dGVybilcXG4gICAgLy8gICAzLiB1c2UgdmVydGV4IHBvc2l0aW9uIGFuZCB0ZXh0dXJlQmFzZVBvaW50IHZlY3RvcnMgdG8gZmluZCBjb29yZGluYXRlcyBpbiB2aXJ0dWFsIHRleHR1cmVcXG4gICAgLy8gICA0LiBmaW5kIHV2IGNvb3JkaW5hdGVzIGluIHJlYWwgdGV4dHVyZSB1c2luZyBtb2Qgb3BlcmF0aW9uXFxuICAgIC8vXFxuICAgIC8vIEJvdGggdGV4dHVyZUJhc2VQb2ludCBhbmQgcG9zaXRpb24gYXJlIHJlbGF0aXZlbGx5IHNtYWxsIHZlY3RvcnMgc28gdGhhdCBwcmVjaXNpb24gcmVxdWlyZW1lbnRzIGFyZSBtZXQsXFxuICAgIC8vIGFuZCBjb3JyZWN0IGludGVycG9sYXRpb24gb2YgcmVwZWF0ZWQgaW1hZ2UgaXMgcG9zc2libGUgYnkgdXNpbmcgc2luZ2xlIGJhc2UgcG9pbnQgaW4gYWxsIHZlcnRpY2VzLlxcblxcbiAgICB2ZWMyIHNjYWxlZFRleHR1cmVTaXplID0gdGV4dHVyZVNpemUgKiB2ZXJ0ZXhJbWFnZVNjYWxlOyAvLyB0ZXh0dXJlIHNpemUgaW4gd29ybGQgY29vcmRpbmF0ZXNcXG4gICAgdmVjMiB0ZXh0dXJlQmFzZVBvaW50ID0gbW9kKFlWX0ggKiBsb29rQXRIaWdoLCBzY2FsZWRUZXh0dXJlU2l6ZSkgKyBtb2QoWVZfTCAqIGxvb2tBdExvdywgc2NhbGVkVGV4dHVyZVNpemUpO1xcbiAgICB2ZWMyIHBvc2l0aW9uID0gWVZfSCAqICh2ZXJ0ZXhQb3NIaWdoIC0gbG9va0F0SGlnaCkgKyBZVl9MICogKHZlcnRleFBvc0xvdyAtIGxvb2tBdExvdyk7XFxuXFxuICAgIGdsX1Bvc2l0aW9uID0gdmlld1Byb2pNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAwLCAxKTtcXG4gICAgZ2xfUG9zaXRpb24ueHkgLz0gZ2xfUG9zaXRpb24udztcXG4gICAgZ2xfUG9zaXRpb24ueiA9IHZlcnRleFpJbmRleDtcXG4gICAgZ2xfUG9zaXRpb24udyA9IDEuMDtcXG5cXG4gICAgLy8gY29udmVydCB3b3JsZCBjb29yZGluYXRlcyBiYWNrIHRvIHRldHVyZSBwaXhlbHNcXG4gICAgdXZEaXNwbGFjZW1lbnQgPSAocG9zaXRpb24gKyB0ZXh0dXJlQmFzZVBvaW50KSAvIHZlcnRleEltYWdlU2NhbGU7XFxufVxcblwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvcG9seWdvbi9zaGFkZXIvdGV4dHVyZWRfcG9seWdvbi52ZXJ0XG4vLyBtb2R1bGUgaWQgPSAxNDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcIiN2ZXJzaW9uIDEwMFxcblxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgYXRsYXM7XFxudW5pZm9ybSB2ZWMyIGF0bGFzU2l6ZTtcXG5cXG52YXJ5aW5nIHZlYzIgdXZQb3NpdGlvbjtcXG52YXJ5aW5nIHZlYzIgdGV4dHVyZVNpemU7XFxudmFyeWluZyB2ZWMyIHV2RGlzcGxhY2VtZW50O1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIHZlYzIgdXZBZGp1c3RlZCA9IHZlYzIoXFxuICAgICAgICB1dlBvc2l0aW9uLnggKyBtb2QodXZEaXNwbGFjZW1lbnQueCwgdGV4dHVyZVNpemUueCksXFxuICAgICAgICB1dlBvc2l0aW9uLnkgKyBtb2QodXZEaXNwbGFjZW1lbnQueSwgdGV4dHVyZVNpemUueSlcXG4gICAgKTtcXG5cXG4gICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKGF0bGFzLCB1dkFkanVzdGVkIC8gYXRsYXNTaXplKTtcXG59XFxuXCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9wb2x5Z29uL3NoYWRlci90ZXh0dXJlZF9wb2x5Z29uLmZyYWdcbi8vIG1vZHVsZSBpZCA9IDE0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgUG9seWdvblJlbmRlcmVyVW5pdCBmcm9tICcuL3BvbHlnb25fcmVuZGVyX3VuaXQnO1xyXG5pbXBvcnQgUmVuZGVyU3RhdGUgZnJvbSAnLi4vLi4vLi4vcmVuZGVyL3N0YXRlJztcclxuaW1wb3J0IHsgREVGQVVMVF9SRU5ERVJfU1RBVEVfUEFSQU1TIH0gZnJvbSAnLi9wb2x5Z29uX3JlbmRlcl91bml0JztcclxuaW1wb3J0IHsgQkxFTkRfT1ZFUl9SRU5ERVJfU1RBVEUgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXIvc3RhdGUnO1xyXG4vKipcclxuICogUmVuZGVyZXIgb2YgdHJhbnNwYXJlbnQgcG9seWdvbiBwcmltaXRpdmVzLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVHJhbnNwYXJlbnRQb2x5Z29uUmVuZGVyVW5pdCBleHRlbmRzIFBvbHlnb25SZW5kZXJlclVuaXQge1xyXG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgcHJpbWl0aXZlUHJvdmlkZXIpIHtcclxuICAgICAgICBzdXBlcihjb250ZXh0LCBwcmltaXRpdmVQcm92aWRlciwgbmV3IFJlbmRlclN0YXRlKERFRkFVTFRfUkVOREVSX1NUQVRFX1BBUkFNUywgeyBkZXB0aE1hc2s6IGZhbHNlIH0sIEJMRU5EX09WRVJfUkVOREVSX1NUQVRFKSk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvcG9seWdvbi90cmFuc3BhcmVudF9wb2x5Z29uX3JlbmRlcl91bml0LnRzXG4vLyBtb2R1bGUgaWQgPSAxNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcIiN2ZXJzaW9uIDEwMFxcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxuYXR0cmlidXRlIHZlYzIgdmVydGV4UG9zSGlnaDtcXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhQb3NMb3c7XFxuYXR0cmlidXRlIHZlYzQgdmVydGV4Q29sb3I7XFxuYXR0cmlidXRlIGZsb2F0IHZlcnRleFpJbmRleDtcXG5cXG51bmlmb3JtIHZlYzIgbG9va0F0SGlnaDtcXG51bmlmb3JtIHZlYzIgbG9va0F0TG93O1xcbnVuaWZvcm0gbWF0NCB2aWV3UHJvak1hdHJpeDtcXG5cXG52YXJ5aW5nIHZlYzQgY29sb3I7XFxuXFxuY29uc3QgZmxvYXQgWVZfSCA9IDEuOTk5OTY5NDgyNDIxODc1O1xcbmNvbnN0IGZsb2F0IFlWX0wgPSAwLjAwMDAzMDUxNzExMjQ2MzcxMjY5MjtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgICB2ZWM0IHBvc2l0aW9uID0gdmlld1Byb2pNYXRyaXggKiB2ZWM0KFxcbiAgICAgICAgWVZfSCAqICh2ZXJ0ZXhQb3NIaWdoIC0gbG9va0F0SGlnaCkgK1xcbiAgICAgICAgICAgIFlWX0wgKiAodmVydGV4UG9zTG93IC0gbG9va0F0TG93KSxcXG4gICAgICAgIDAsXFxuICAgICAgICAxXFxuICAgICk7XFxuXFxuICAgIHBvc2l0aW9uLnh5IC89IHBvc2l0aW9uLnc7XFxuICAgIHBvc2l0aW9uLnogPSB2ZXJ0ZXhaSW5kZXg7XFxuICAgIHBvc2l0aW9uLncgPSAxLjA7XFxuXFxuICAgIGdsX1Bvc2l0aW9uID0gcG9zaXRpb247XFxuXFxuICAgIGNvbG9yID0gdmVydGV4Q29sb3I7XFxufVxcblwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvcG9seWdvbi9zaGFkZXIvcG9seWdvbi52ZXJ0XG4vLyBtb2R1bGUgaWQgPSAxNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcIiN2ZXJzaW9uIDEwMFxcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxudmFyeWluZyBsb3dwIHZlYzQgY29sb3I7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxufVxcblwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvcG9seWdvbi9zaGFkZXIvcG9seWdvbi5mcmFnXG4vLyBtb2R1bGUgaWQgPSAxNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IEVuZ2luZSBmcm9tICcuL2VuZ2luZSc7XHJcbmltcG9ydCBGeGFhUmVuZGVyVW5pdCBmcm9tICcuL3JlbmRlci9meGFhX3JlbmRlcl91bml0JztcclxuaW1wb3J0IEJhY2tncm91bmRSZW5kZXJVbml0IGZyb20gJy4vcmVuZGVyL2JhY2tncm91bmRfcmVuZGVyX3VuaXQnO1xyXG5pbXBvcnQgTGF5ZXJSZW5kZXJVbml0IGZyb20gJy4vcmVuZGVyL2xheWVyX3JlbmRlcl91bml0JztcclxuLyoqXHJcbiAqIEdyb3VuZCBsYXllciB3aXRoIGJhY2tncm91bmQgdGhhdCBnb2VzIHJpZ2h0IGFmdGVyIHN1YiByZW5kZXIgdW5pdHMuIEl0IGFsbG93cyB0byBhZGQgb3RoZXIgTGF5ZXJSZW5kZXJVbml0cyBhYm92ZVxyXG4gKiBncm91bmRMYXllciB3aXRob3V0IHdvcnJ5aW5nIHRoYXQgdGhleSBkZXN0cm95IGRlcHRoIGluZm9ybWF0aW9uIGNvbGxlY3RlZCBvbiBncm91bmQgYW5kIGJyb2tlIGJhY2tncm91bmQgKHRoYXQgaGFzXHJcbiAqIGEgcGVyZm9ybWFuY2Ugb3B0aW1pc2F0aW9uOiBpdCB1c2VzIGRlcHRoIGluZm9ybWF0aW9uIGZyb20gdGhlIGxheWVycyBiZWxvdyB0byBwcmV2ZW50IGV4dGVuc2l2ZSBwaXhlbCBvdmVyd3JpdGluZykuXHJcbiAqL1xyXG5jbGFzcyBCYWNrZ3JvdW5kZWRHcm91bmRMYXllciBleHRlbmRzIExheWVyUmVuZGVyVW5pdCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBkZXB0aENsZWFyU3RyYXRlZ3kgPSAwIC8qIE5PX0NMRUFSICovKSB7XHJcbiAgICAgICAgc3VwZXIoY29udGV4dCwgZGVwdGhDbGVhclN0cmF0ZWd5KTtcclxuICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kID0gbmV3IEJhY2tncm91bmRSZW5kZXJVbml0KGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgcmVuZGVyKHRhcmdldCwgLi4uYXJncykge1xyXG4gICAgICAgIHN1cGVyLnJlbmRlcih0YXJnZXQsIC4uLmFyZ3MpO1xyXG4gICAgICAgIHRoaXMuX2JhY2tncm91bmQucmVuZGVyKHRhcmdldCk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFwRW5naW5lIGV4dGVuZHMgRW5naW5lIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIGNhbWVyYSwgcmVuZGVyTG9vcCkge1xyXG4gICAgICAgIHN1cGVyKGNvbnRleHQsIGNhbWVyYSwgcmVuZGVyTG9vcCk7XHJcbiAgICAgICAgdGhpcy5fZGVzdHJveWFibGVzID0gW107XHJcbiAgICAgICAgY29uc3QgYW50aWFsaWFzaW5nTGF5ZXIgPSBuZXcgRnhhYVJlbmRlclVuaXQoY29udGV4dCwgdGhpcy5yZW5kZXJMb29wKTtcclxuICAgICAgICB0aGlzLmJhY2tnb3VuZExheWVyID0gbmV3IExheWVyUmVuZGVyVW5pdChjb250ZXh0KTtcclxuICAgICAgICB0aGlzLmdyb3VuZExheWVyID0gbmV3IEJhY2tncm91bmRlZEdyb3VuZExheWVyKGNvbnRleHQpO1xyXG4gICAgICAgIHRoaXMuYnVpbGRpbmdzTGF5ZXIgPSBuZXcgTGF5ZXJSZW5kZXJVbml0KGNvbnRleHQpO1xyXG4gICAgICAgIHRoaXMuaWNvbnNMYXllciA9IG5ldyBMYXllclJlbmRlclVuaXQoY29udGV4dCk7XHJcbiAgICAgICAgdGhpcy5sYWJlbHNMYXllciA9IG5ldyBMYXllclJlbmRlclVuaXQoY29udGV4dCk7XHJcbiAgICAgICAgYW50aWFsaWFzaW5nTGF5ZXIuYWRkUmVuZGVyVW5pdCh0aGlzLmJ1aWxkaW5nc0xheWVyKTtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZFJlbmRlclVuaXQodGhpcy5iYWNrZ291bmRMYXllcik7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRSZW5kZXJVbml0KHRoaXMuZ3JvdW5kTGF5ZXIpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIuYWRkUmVuZGVyVW5pdChhbnRpYWxpYXNpbmdMYXllcik7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRSZW5kZXJVbml0KHRoaXMuaWNvbnNMYXllcik7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRSZW5kZXJVbml0KHRoaXMubGFiZWxzTGF5ZXIpO1xyXG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lhYmxlcy5wdXNoKGFudGlhbGlhc2luZ0xheWVyKTtcclxuICAgICAgICAvLyBmb3JjZSBpbml0aWFsIHJlbmRlcmluZyAobm8gZGF0YSB5ZXQsIGp1c3QgYmFja2dyb3VuZCkgYXMgdGhlIGNhbnZhcyAoYmxhY2spIGNhbiBhbHJlYWR5IGJlIHZpc2libGUgdG8gdXNlcnMsXHJcbiAgICAgICAgLy8gcmVuZGVyZXIgaXMgY2FsbGVkIGRpcmVjdGx5ICh3aXRob3V0IHNjaGVkdWxpbmcgdmlhIHJlbmRlciBsb29wKSBhcyBpdCBpcyBwcmV0dHkgbXVjaCBzYWZlIHRvIGFzc3VtZVxyXG4gICAgICAgIC8vIHRoYXQgbm8gcmVuZGVyaW5nIGlzIHNjaGVkdWxlZCBmb3IgdGhpcyBmcmFtZSwgYW5kIGRlZmVycmVkIHVwZGF0ZSBjYW4gcG90ZW50aWFsbHkgY2F1c2UgYSBzaW5nbGUgZnJhbWUgYmxpbmtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbmRlcih0aGlzLl9yZW5kZXJUYXJnZXQpO1xyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICAvLyBkZXN0cm95IGluIHJldmVyc2Ugb3JkZXIgdG8gcHJldmVudCBwb3RlbnRpYWwgaXNzdWVzIGlmIGRlc3Ryb3lhYmxlcyBvd24gZWFjaCBvdGhlclxyXG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9kZXN0cm95YWJsZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgdGhpcy5fZGVzdHJveWFibGVzW2ldLmRlc3Ryb3koKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL21hcF9lbmdpbmUudHNcbi8vIG1vZHVsZSBpZCA9IDE0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBWb2lkRXZlbnRFbWl0dGVyIH0gZnJvbSAnLi91dGlsL2V2ZW50X2VtaXR0ZXInO1xyXG5pbXBvcnQgUmVuZGVyYWJsZURmR2x5cGhBdGxhcyBmcm9tICcuL3JlbmRlci9mb250L3JlbmRlcmFibGVfZGZfZ2x5cGhfYXRsYXMnO1xyXG5pbXBvcnQgRGZGb250UmVnaXN0cnkgZnJvbSAnLi9mb250L2RmX2ZvbnRfcmVnaXN0cnknO1xyXG5pbXBvcnQgUmVuZGVyYWJsZUltYWdlQXRsYXMgZnJvbSAnLi9yZW5kZXIvYmlsbGJvYXJkL3JlbmRlcmFibGVfaW1hZ2VfYXRsYXMnO1xyXG5pbXBvcnQgVmlzaWJpbGl0eU1hbmFnZXIgZnJvbSAnLi92aXNpYmlsaXR5L3Zpc2liaWxpdHlfbWFuYWdlcic7XHJcbmltcG9ydCB7IG1lZGlhbkZpbHRlciB9IGZyb20gJy4vdXRpbC9tZWRpYW5fZmlsdGVyJztcclxuaW1wb3J0IHsgY291bnRGcHMgfSBmcm9tICcuL3V0aWwvc3RhdCc7XHJcbmltcG9ydCBNYWluUmVuZGVyVW5pdCBmcm9tICcuL3JlbmRlci9tYWluX3JlbmRlcl91bml0JztcclxuaW1wb3J0IE1lbW9yeU1hbmFnZXIgZnJvbSAnLi9yZW5kZXIvbWVtb3J5L21hbmFnZXInO1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbmdpbmUge1xyXG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgY2FtZXJhLCByZW5kZXJMb29wKSB7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcclxuICAgICAgICB0aGlzLl9jYW1lcmEgPSBjYW1lcmE7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyVGFyZ2V0ID0gY29udGV4dC5nZXREZWZhdWx0UmVuZGVyVGFyZ2V0KCk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IG5ldyBNYWluUmVuZGVyVW5pdChjb250ZXh0LCBjYW1lcmEpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyTG9vcCA9IHJlbmRlckxvb3A7XHJcbiAgICAgICAgdGhpcy5tZW1vcnlNYW5hZ2VyID0gbmV3IE1lbW9yeU1hbmFnZXIoY29udGV4dCk7XHJcbiAgICAgICAgdGhpcy5fYXRsYXNlcyA9IG5ldyBTZXQoKTtcclxuICAgICAgICB0aGlzLnZpc2liaWxpdHlNYW5hZ2VyID0gbmV3IFZpc2liaWxpdHlNYW5hZ2VyKGNvbnRleHQsIGNhbWVyYSwgcmVuZGVyTG9vcCwgdGhpcy5fcmVuZGVyVGFyZ2V0LmdldFdpZHRoKCksIHRoaXMuX3JlbmRlclRhcmdldC5nZXRIZWlnaHQoKSk7XHJcbiAgICAgICAgdGhpcy52aXNiaWxpdHlUZXh0dXJlUHJvdmlkZXIgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMudmlzaWJpbGl0eU1hbmFnZXIudXBkYXRlVmlzaWJpbGl0eUlmTmVlZGVkKCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZpc2liaWxpdHlNYW5hZ2VyLnZpc2liaWxpdHlUZXh0dXJlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5fZnJhbWVUaW1pbmdzTGlzdGVuZXIgPSB0aGlzLl9vbkZyYW1lVGltZXNGdWxsLmJpbmQodGhpcyk7XHJcbiAgICAgICAgcmVuZGVyTG9vcC5vbkZyYW1lVGltZXNGdWxsLmFkZExpc3RlbmVyKHRoaXMuX2ZyYW1lVGltaW5nc0xpc3RlbmVyKTtcclxuICAgICAgICB0aGlzLl9yZW5kZXJMaXN0ZW5lciA9IHRoaXMuX29uUmVuZGVyLmJpbmQodGhpcyk7XHJcbiAgICAgICAgcmVuZGVyTG9vcC5vblJlbmRlci5hZGRMaXN0ZW5lcih0aGlzLl9yZW5kZXJMaXN0ZW5lcik7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlTGlzdGVuZXIgPSAoKSA9PiB0aGlzLnJlbmRlckxvb3AudXBkYXRlKCk7XHJcbiAgICAgICAgdGhpcy5nbHlwaEF0bGFzID0gbmV3IFJlbmRlcmFibGVEZkdseXBoQXRsYXMoY29udGV4dCk7XHJcbiAgICAgICAgdGhpcy5mb250UmVnaXN0cnkgPSBuZXcgRGZGb250UmVnaXN0cnkoKTtcclxuICAgICAgICB0aGlzLm9uSW50ZXJuYWxFcnJvciA9IG5ldyBWb2lkRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5fY2FtZXJhLm9uVXBkYXRlLmFkZExpc3RlbmVyKHRoaXMuX3VwZGF0ZUxpc3RlbmVyKTtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyLm9uVXBkYXRlLmFkZExpc3RlbmVyKHRoaXMuX3VwZGF0ZUxpc3RlbmVyKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0TG9zdExpc3RlbmVyID0gKCkgPT4gdGhpcy5vbkludGVybmFsRXJyb3IuZmlyZSgpO1xyXG4gICAgICAgIHRoaXMuY29udGV4dC5vbkxvc3MuYWRkTGlzdGVuZXIodGhpcy5fY29udGV4dExvc3RMaXN0ZW5lcik7XHJcbiAgICB9XHJcbiAgICBzZXRSZW5kZXJUYXJnZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICBpZiAodGhpcy5fcmVuZGVyVGFyZ2V0LmdldFdpZHRoKCkgIT09IHdpZHRoIHx8XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlclRhcmdldC5nZXRIZWlnaHQoKSAhPT0gaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlclRhcmdldC5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgICAgICB0aGlzLnZpc2liaWxpdHlNYW5hZ2VyLnNldFRhcmdldFNpemUod2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY3JlYXRlSW1hZ2VBdGxhcyhwYXJhbXMpIHtcclxuICAgICAgICBjb25zdCBhdGxhcyA9IG5ldyBSZW5kZXJhYmxlSW1hZ2VBdGxhcyh0aGlzLmNvbnRleHQsIHBhcmFtcyk7XHJcbiAgICAgICAgYXRsYXMub25Db250ZW50VXBkYXRlLmFkZExpc3RlbmVyKHRoaXMuX3VwZGF0ZUxpc3RlbmVyKTtcclxuICAgICAgICB0aGlzLl9hdGxhc2VzLmFkZChhdGxhcyk7XHJcbiAgICAgICAgcmV0dXJuIGF0bGFzO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlSW1hZ2VBdGxhcyhhdGxhcykge1xyXG4gICAgICAgIGF0bGFzLmRlc3Ryb3koKTtcclxuICAgICAgICBhdGxhcy5vbkNvbnRlbnRVcGRhdGUucmVtb3ZlTGlzdGVuZXIodGhpcy5fdXBkYXRlTGlzdGVuZXIpO1xyXG4gICAgICAgIHRoaXMuX2F0bGFzZXMuZGVsZXRlKGF0bGFzKTtcclxuICAgIH1cclxuICAgIGdldENhbWVyYSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY2FtZXJhO1xyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLl9jYW1lcmEub25VcGRhdGUucmVtb3ZlTGlzdGVuZXIodGhpcy5fdXBkYXRlTGlzdGVuZXIpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIub25VcGRhdGUucmVtb3ZlTGlzdGVuZXIodGhpcy5fdXBkYXRlTGlzdGVuZXIpO1xyXG4gICAgICAgIGZvciAoY29uc3QgYXRsYXMgb2YgdGhpcy5fYXRsYXNlcykge1xyXG4gICAgICAgICAgICBhdGxhcy5vbkNvbnRlbnRVcGRhdGUucmVtb3ZlTGlzdGVuZXIodGhpcy5fdXBkYXRlTGlzdGVuZXIpO1xyXG4gICAgICAgICAgICBhdGxhcy5kZXN0cm95KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZ2x5cGhBdGxhcy5kZXN0cm95KCk7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0Lm9uTG9zcy5yZW1vdmVMaXN0ZW5lcih0aGlzLl9jb250ZXh0TG9zdExpc3RlbmVyKTtcclxuICAgIH1cclxuICAgIF9vblJlbmRlcigpIHtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbmRlcih0aGlzLl9yZW5kZXJUYXJnZXQpO1xyXG4gICAgfVxyXG4gICAgX29uRnJhbWVUaW1lc0Z1bGwodGltZXMpIHtcclxuICAgICAgICBjb3VudEZwcygxZTMgKiB0aW1lcy5sZW5ndGggLyBtZWRpYW5GaWx0ZXIodGltZXMpLnJlZHVjZSgoc3VtLCB0aW1lKSA9PiBzdW0gKyB0aW1lKSk7XHJcbiAgICAgICAgLy8gRm9yIG5vdyB3ZSBhY3F1aXJlIGZyYW1lIHRpbWluZyBhbmQgbG9nIHRoZW0gb25seSBvbmNlIGEgc2Vzc2lvbi5cclxuICAgICAgICB0aGlzLnJlbmRlckxvb3Aub25GcmFtZVRpbWVzRnVsbC5yZW1vdmVMaXN0ZW5lcih0aGlzLl9mcmFtZVRpbWluZ3NMaXN0ZW5lcik7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvZW5naW5lLnRzXG4vLyBtb2R1bGUgaWQgPSAxNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IERmR2x5cGhBdGxhcyBmcm9tICcuLi8uLi9mb250L2RmX2dseXBoX2F0bGFzJztcclxuLyoqXHJcbiAqIEF0bGFzIHRoYXQgbWFuYWdlcyBhbGxvY2F0aW9uIGluIEdMIHRleHR1cmUuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW5kZXJhYmxlRGZHbHlwaEF0bGFzIGV4dGVuZHMgRGZHbHlwaEF0bGFzIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcclxuICAgICAgICBzdXBlcigwLCAwLCBuZXcgVWludDhBcnJheSgwKSwgbmV3IE1hcCgpKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcclxuICAgICAgICB0aGlzLnRleHR1cmUgPSB0aGlzLl9jcmVhdGVUZXh0dXJlKDAsIDApO1xyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLnRleHR1cmUuZGVzdHJveSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSB3aG9sZSBjb250ZW50IG9mIHRoZSBnbHlwaCBiaXRtYXAgYXRsYXMsIHRleHR1cmUgYWxzbyBnZXQgdXBkYXRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gd2lkdGggbmV3IGJpdG1hcCB3aWR0aFxyXG4gICAgICogQHBhcmFtIGhlaWdodCBuZXcgYml0bWFwIGhlaWdodFxyXG4gICAgICogQHBhcmFtIGRhdGEsIGxlbmd0aCBzaG91bGQgYmUgc3RyaWN0bHkgZXF1YWwgdG8gd2lkdGggKiBoZWlnaHRcclxuICAgICAqL1xyXG4gICAgdXBkYXRlQ29udGVudCh3aWR0aCwgaGVpZ2h0LCBkYXRhLCBnbHlwaExvY2F0aW9ucykge1xyXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgIHRoaXMuX2dseXBoTG9jYXRpb25zID0gZ2x5cGhMb2NhdGlvbnM7XHJcbiAgICAgICAgY29uc3QgdGV4dHVyZSA9IHRoaXMudGV4dHVyZTtcclxuICAgICAgICBpZiAoIXRleHR1cmUgfHwgdGV4dHVyZS5nZXRXaWR0aCgpICE9PSB3aWR0aCB8fCB0ZXh0dXJlLmdldEhlaWdodCgpICE9PSBoZWlnaHQpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudGV4dHVyZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0dXJlLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnRleHR1cmUgPSB0aGlzLl9jcmVhdGVUZXh0dXJlKHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9jb250ZXh0LnNldFRleHR1cmVEYXRhKHRoaXMudGV4dHVyZSwgZGF0YSk7XHJcbiAgICB9XHJcbiAgICBfY3JlYXRlVGV4dHVyZSh3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuY3JlYXRlRW1wdHkyRFRleHR1cmUod2lkdGgsIGhlaWdodCwgNjQwNiAvKiBBTFBIQSAqLywgNTEyMSAvKiBVTlNJR05FRF9CWVRFICovLCB7XHJcbiAgICAgICAgICAgIHdyYXBTOiAzMzA3MSAvKiBDTEFNUF9UT19FREdFICovLFxyXG4gICAgICAgICAgICB3cmFwVDogMzMwNzEgLyogQ0xBTVBfVE9fRURHRSAqLyxcclxuICAgICAgICAgICAgbWFnbmlmaWNhdGlvbkZpbHRlcjogOTcyOSAvKiBMSU5FQVIgKi8sXHJcbiAgICAgICAgICAgIG1pbmlmaWNhdGlvbkZpbHRlcjogOTcyOSAvKiBMSU5FQVIgKi8sXHJcbiAgICAgICAgICAgIHByZW11bHRpcGxpZWRBbHBoYTogZmFsc2VcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvZm9udC9yZW5kZXJhYmxlX2RmX2dseXBoX2F0bGFzLnRzXG4vLyBtb2R1bGUgaWQgPSAxNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiY29uc3QgVU5LTk9XTl9HTFlQSF9MT0NBVElPTiA9IHtcclxuICAgIG1pblg6IDAsXHJcbiAgICBtYXhYOiAwLFxyXG4gICAgbWluWTogMCxcclxuICAgIG1heFk6IDBcclxufTtcclxuLyoqXHJcbiAqIEFic3RyYWN0IGdseXBoIGF0bGFzIGludGVyZmFjZS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERmR2x5cGhBdGxhcyB7XHJcbiAgICBjb25zdHJ1Y3Rvcih3aWR0aCwgaGVpZ2h0LCBkYXRhLCBnbHlwaExvY2F0aW9ucykge1xyXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgIHRoaXMuX2dseXBoTG9jYXRpb25zID0gZ2x5cGhMb2NhdGlvbnM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gR2x5cGggbG9jYXRpb24gb3IgZmFrZSBsb2NhdGlvbiBwb2ludGluZyB0byB0aGUgb3JpZ2luICgwLCAwKS5cclxuICAgICAqL1xyXG4gICAgZ2V0R2x5cGhMb2NhdGlvbihmb250SWQsIGdseXBoSWQpIHtcclxuICAgICAgICBjb25zdCBnbHlwaExvY2F0aW9uID0gdGhpcy5fZ2x5cGhMb2NhdGlvbnMuZ2V0KGZvbnRJZCArIGdseXBoSWQpO1xyXG4gICAgICAgIGlmIChnbHlwaExvY2F0aW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnbHlwaExvY2F0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdXb3ctd293LXdvdywgc29tZXRoaW5nIHdlbnQgd3JvbmcsIHlvdSBzaG91bGQgbm90IHJlcXVlc3Qgbm9uZXhpc3RlbnQgZ2x5cGggbG9jYXRpb25zJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBVTktOT1dOX0dMWVBIX0xPQ0FUSU9OO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiBBbGwgZ2x5cGggbG9jYXRpb25zIGFzIFtnbHlwaCBpZCwgZ2x5cGggbG9jYXRpb25dIGFycmF5LiBHbHlwaCBpZCBpcyBmb250IGlkIGNvbmNhdGVuYXRlZCB3aXRoIGdseXBoIGlkLlxyXG4gICAgICovXHJcbiAgICBnZXRBbGxHbHlwaExvY2F0aW9ucygpIHtcclxuICAgICAgICByZXR1cm4gWy4uLnRoaXMuX2dseXBoTG9jYXRpb25zLmVudHJpZXMoKV07XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvZm9udC9kZl9nbHlwaF9hdGxhcy50c1xuLy8gbW9kdWxlIGlkID0gMTQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBGb250UmVnaXN0cnkgZnJvbSAnLi9mb250X3JlZ2lzdHJ5JztcclxuaW1wb3J0IERmRm9udCBmcm9tICcuL2RmX2ZvbnQnO1xyXG4vKipcclxuICogUmVnaXN0cnkgdGhhdCBzdG9yZXMgZGlzdGFuY2UgZmllbGQgZm9udHMuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZkZvbnRSZWdpc3RyeSBleHRlbmRzIEZvbnRSZWdpc3RyeSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcihuZXcgRGZGb250KCdVTktOT1dOX0RGX0ZPTlQnLCAxNCwgMCkpO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2ZvbnQvZGZfZm9udF9yZWdpc3RyeS50c1xuLy8gbW9kdWxlIGlkID0gMTUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiBBIGNlbnRyYWwgc3RvcmFnZSBvZiBhbGwgYXZhaWxhYmxlIGZvbnRzLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRm9udFJlZ2lzdHJ5IHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHVua25vd25Gb250SW5zdGFuY2UgQW4gaW5zdGFuY2Ugb2Ygc3BlY2lmaWMgZm9udCB0eXBlIHRvIGJlIHNlcnZlZCBhcyBhIHN0dWIgd2hlbiBub25leGlzdGVudCBmb250XHJcbiAgICAgKiAgICAgaXMgcmVxdWVzdGVkLiBSZXF1ZXN0aW5nIG5vbmV4aXN0ZW50IGZvbnRzIG5vcm1hbGx5IHNob3VsZCBub3QgaGFwcGVuLlxyXG4gICAgICogICAgIFRoZSBzdHViIGp1c3QgYWxsb3dzIHRvIGF2b2lkIHRlZGlvdXMgbnVsbCBjaGVja3MgaW4gcmVnaXN0cnkgY2xpZW50cy5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IodW5rbm93bkZvbnRJbnN0YW5jZSkge1xyXG4gICAgICAgIHRoaXMuX2ZvbnRzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuX3Vua25vd25Gb250SW5zdGFuY2UgPSB1bmtub3duRm9udEluc3RhbmNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIElmIGEgZm9udCB3aXRoIHNwZWNpZmllZCBpZCBpcyBpbiB0aGUgcmVnaXN0cnkuXHJcbiAgICAgKi9cclxuICAgIGNvbnRhaW5zKGZvbnRJZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9mb250cy5oYXMoZm9udElkKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiBGb250IHdpdGggc3BlY2lmaWVkIGlkIG9yIHVua25vd24gZm9udCBpbnN0YW5jZSBpZiBpdCBpcyBub3QgZm91bmQuXHJcbiAgICAgKi9cclxuICAgIGdldChmb250SWQpIHtcclxuICAgICAgICBjb25zdCBmb250ID0gdGhpcy5fZm9udHMuZ2V0KGZvbnRJZCk7XHJcbiAgICAgICAgaWYgKGZvbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZvbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1dvdy13b3ctd293LCBzb21ldGhpbmcgd2VudCB3cm9uZywgeW91IHNob3VsZCBub3QgcmVxdWVzdCBub25leGlzdGVudCBmb250cycpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdW5rbm93bkZvbnRJbnN0YW5jZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gQWxsIHN0b3JlZCBmb250cy5cclxuICAgICAqL1xyXG4gICAgZ2V0QWxsKCkge1xyXG4gICAgICAgIHJldHVybiBbLi4udGhpcy5fZm9udHMudmFsdWVzKCldO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIG5ldyBmb3IgdG8gdGhlIHJlZ2lzdHJ5LlxyXG4gICAgICovXHJcbiAgICBhZGQoZm9udCkge1xyXG4gICAgICAgIHRoaXMuX2ZvbnRzLnNldChmb250LmlkLCBmb250KTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9mb250L2ZvbnRfcmVnaXN0cnkudHNcbi8vIG1vZHVsZSBpZCA9IDE1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgSW1hZ2VBdGxhcyBmcm9tICcuLi8uLi9iaWxsYm9hcmQvaW1hZ2VfYXRsYXMnO1xyXG4vKipcclxuICogQXRsYXMgdGhhdCBtYW5hZ2VzIGFsbG9jYXRpb24gaW4gR0wgdGV4dHVyZS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbmRlcmFibGVJbWFnZUF0bGFzIGV4dGVuZHMgSW1hZ2VBdGxhcyB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBwYXJhbXMpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIGNvbnN0IHsgZmlsdGVyLCBwcmVtdWx0aXBsaWVkQWxwaGEgfSA9IHBhcmFtcztcclxuICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcclxuICAgICAgICB0aGlzLl9maWx0ZXIgPSBmaWx0ZXI7XHJcbiAgICAgICAgdGhpcy5fcHJlbXVsdGlwbGllZEFscGhhID0gcHJlbXVsdGlwbGllZEFscGhhO1xyXG4gICAgICAgIHRoaXMudGV4dHVyZSA9IHRoaXMuX2NyZWF0ZVRleHR1cmUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIGZpbHRlciwgcHJlbXVsdGlwbGllZEFscGhhKTtcclxuICAgICAgICB0aGlzLmlzRGlydHkgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyBHTCB0ZXh0dXJlIHdpdGggY2hhbmdlZCBkYXRhLiBTaG91bGQgYmUgY2FsbGVkIGFmdGVyIGVhY2ggaW1hZ2UgYWRkZWQgdG8gdGFrZSBlZmZlY3QgaW4gc2hhZGVycy5cclxuICAgICAqL1xyXG4gICAgc3luY1RleHR1cmUoKSB7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5zZXRUZXh0dXJlRGF0YUZyb21Eb21FbGVtZW50KHRoaXMudGV4dHVyZSwgdGhpcy5jYW52YXMpO1xyXG4gICAgICAgIHRoaXMuaXNEaXJ0eSA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlSW1hZ2UobG9jYXRpb24sIHNvdXJjZUltYWdlLCBsb2NhdGlvblJlZ2lvbiwgc291cmNlSW1hZ2VSZWdpb24pIHtcclxuICAgICAgICBzdXBlci51cGRhdGVJbWFnZShsb2NhdGlvbiwgc291cmNlSW1hZ2UsIGxvY2F0aW9uUmVnaW9uLCBzb3VyY2VJbWFnZVJlZ2lvbik7XHJcbiAgICAgICAgdGhpcy5pc0RpcnR5ID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy50ZXh0dXJlLmRlc3Ryb3koKTtcclxuICAgIH1cclxuICAgIF9leHBhbmQobmV3V2lkdGgsIG5ld0hlaWdodCkge1xyXG4gICAgICAgIHN1cGVyLl9leHBhbmQobmV3V2lkdGgsIG5ld0hlaWdodCk7XHJcbiAgICAgICAgdGhpcy50ZXh0dXJlLmRlc3Ryb3koKTtcclxuICAgICAgICB0aGlzLnRleHR1cmUgPSB0aGlzLl9jcmVhdGVUZXh0dXJlKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB0aGlzLl9maWx0ZXIsIHRoaXMuX3ByZW11bHRpcGxpZWRBbHBoYSk7XHJcbiAgICAgICAgdGhpcy5pc0RpcnR5ID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIF9jcmVhdGVUZXh0dXJlKHdpZHRoLCBoZWlnaHQsIGZpbHRlciwgcHJlbXVsdGlwbGllZEFscGhhKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuY3JlYXRlRW1wdHkyRFRleHR1cmUod2lkdGgsIGhlaWdodCwgNjQwOCAvKiBSR0JBICovLCA1MTIxIC8qIFVOU0lHTkVEX0JZVEUgKi8sIHtcclxuICAgICAgICAgICAgbWluaWZpY2F0aW9uRmlsdGVyOiBmaWx0ZXIsXHJcbiAgICAgICAgICAgIG1hZ25pZmljYXRpb25GaWx0ZXI6IGZpbHRlcixcclxuICAgICAgICAgICAgd3JhcFM6IDMzMDcxIC8qIENMQU1QX1RPX0VER0UgKi8sXHJcbiAgICAgICAgICAgIHdyYXBUOiAzMzA3MSAvKiBDTEFNUF9UT19FREdFICovLFxyXG4gICAgICAgICAgICBwcmVtdWx0aXBsaWVkQWxwaGFcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvYmlsbGJvYXJkL3JlbmRlcmFibGVfaW1hZ2VfYXRsYXMudHNcbi8vIG1vZHVsZSBpZCA9IDE1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBjcmVhdGVCQm94MiB9IGZyb20gJy4uL21hdGgvdmVjdG9yMic7XHJcbmltcG9ydCB7IFNoZWxmQWxsb2NhdG9yMkQgfSBmcm9tICcuLi91dGlsL2FsbG9jYXRvcl8yZCc7XHJcbmltcG9ydCB7IFZvaWRFdmVudEVtaXR0ZXIgfSBmcm9tICcuLi91dGlsL2V2ZW50X2VtaXR0ZXInO1xyXG5jb25zdCBJTklUX0FUTEFTX1dJRFRIID0gMjU2O1xyXG5jb25zdCBJTklUX0FUTEFTX0hFSUdIVCA9IDI1NjtcclxuY29uc3QgTUFYX0FUTEFTX1dJRFRIID0gMjA0ODtcclxuY29uc3QgTUFYX0FUTEFTX0hFSUdIVCA9IDIwNDg7XHJcbmNvbnN0IEVYUEFORF9GQUNUT1IgPSAyO1xyXG4vKipcclxuICogTWFuYWdlcyBhbGxvY2F0aW9uIG9mIGltYWdlcy4gSXQgcmVzaXplcyBpdHNlbGYgKHVwIHRvIGEgZml4ZWQgbGltaXQpIHdoZW4gdGhlcmUgaXMgbm8gcmVnaW9uXHJcbiAqIG9mIGVub3VnaCBzaXplIGZvciB0aGUgbmV4dCBpbWFnZS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEltYWdlQXRsYXMge1xyXG4gICAgY29uc3RydWN0b3IoaW5pdEF0bGFzV2lkdGggPSBJTklUX0FUTEFTX1dJRFRILCBpbml0QXRsYXNIZWlnaHQgPSBJTklUX0FUTEFTX0hFSUdIVCkge1xyXG4gICAgICAgIHRoaXMub25Db250ZW50VXBkYXRlID0gbmV3IFZvaWRFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gaW5pdEF0bGFzV2lkdGg7XHJcbiAgICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gaW5pdEF0bGFzSGVpZ2h0O1xyXG4gICAgICAgIHRoaXMuX2NhbnZhc0NvbnRleHQgPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgIHRoaXMuX2FsbG9jYXRvciA9IG5ldyBTaGVsZkFsbG9jYXRvcjJEKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuICAgIH1cclxuICAgIGdldCB3aWR0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jYW52YXMud2lkdGg7XHJcbiAgICB9XHJcbiAgICBnZXQgaGVpZ2h0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhcy5oZWlnaHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFsbG9jYXRlcyBpbWFnZSBiaXRtYXAuXHJcbiAgICAgKi9cclxuICAgIGFsbG9jYXRlSW1hZ2UoZGVzY3JpcHRvciwgaW1hZ2UpIHtcclxuICAgICAgICBjb25zdCBsb2NhdGlvbiA9IHRoaXMuX2FsbG9jYXRlKGRlc2NyaXB0b3IpO1xyXG4gICAgICAgIGlmIChsb2NhdGlvbikge1xyXG4gICAgICAgICAgICBjb25zdCByZWdpb24gPSBjcmVhdGVCQm94MigwLCBkZXNjcmlwdG9yLndpZHRoLCAwLCBkZXNjcmlwdG9yLmhlaWdodCk7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSW1hZ2UobG9jYXRpb24sIGltYWdlLCByZWdpb24sIHJlZ2lvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBsb2NhdGlvbjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVzZXJ2ZXMgc3BhY2Ugb2YgYXBwcm9wcmlhdGUgc2l6ZSB0aGF0IGNhbiBiZSB1cGRhdGVkIGxhdGVyIHdpdGggdXBkYXRlSW1hZ2UoKSBtZXRob2QuXHJcbiAgICAgKi9cclxuICAgIHJlc2VydmVMb2NhdGlvbihkZXNjcmlwdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FsbG9jYXRlKGRlc2NyaXB0b3IpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIGltYWdlIGNvbnRlbnQgaW4gYXBwcm9wcmlhdGUgbG9jYXRpb24uIEFzc3VtZXMgdGhhdCB0aGVyZSBpcyByZWFsbHkgc3VjaCBsb2NhdGlvbiByZXNlcnZlZCxcclxuICAgICAqIG5vIGNoZWNrIGZvciB0aGlzIGlzIGRvbmUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGxvY2F0aW9uIExvY2F0aW9uIGluIGF0bGFzIG9mIHRoZSBpbWFnZS5cclxuICAgICAqIEBwYXJhbSBzb3VyY2VJbWFnZSBJbWFnZSB0byB1cGRhdGUgYXRsYXMgZnJvbS5cclxuICAgICAqIEBwYXJhbSBsb2NhdGlvblJlZ2lvbiBSZWdpb24gKGJib3ggd2l0aCBjb29yZGluYXRlcyByZWxhdGl2ZSB0byB0aGUgbG9jYXRpb24ncyBiYm94KSBvZiB0aGUgbG9jYXRpb24gdG8gdXBkYXRlLlxyXG4gICAgICogQHBhcmFtIHNvdXJjZUltYWdlUmVnaW9uIFJlZ2lvbiBvZiB0aGUgaW1hZ2UgKEJCb3gyIGluIGltYWdlJ3MgY29vcmRpbmF0ZSBzcGFjZSkgdG8gYmUgY29waWVkIGludG8gYXRsYXMuXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZUltYWdlKGxvY2F0aW9uLCBzb3VyY2VJbWFnZSwgbG9jYXRpb25SZWdpb24gPSBjcmVhdGVCQm94MigwLCBsb2NhdGlvbi5tYXhYIC0gbG9jYXRpb24ubWluWCwgMCwgbG9jYXRpb24ubWF4WSAtIGxvY2F0aW9uLm1pblkpLCBzb3VyY2VJbWFnZVJlZ2lvbiA9IGNyZWF0ZUJCb3gyKDAsIHNvdXJjZUltYWdlLndpZHRoLCAwLCBzb3VyY2VJbWFnZS5oZWlnaHQpKSB7XHJcbiAgICAgICAgY29uc3Qgc3JjWCA9IHNvdXJjZUltYWdlUmVnaW9uLm1pblg7XHJcbiAgICAgICAgY29uc3Qgc3JjWSA9IHNvdXJjZUltYWdlUmVnaW9uLm1pblk7XHJcbiAgICAgICAgY29uc3Qgc3JjVyA9IHNvdXJjZUltYWdlUmVnaW9uLm1heFggLSBzb3VyY2VJbWFnZVJlZ2lvbi5taW5YO1xyXG4gICAgICAgIGNvbnN0IHNyY0ggPSBzb3VyY2VJbWFnZVJlZ2lvbi5tYXhZIC0gc291cmNlSW1hZ2VSZWdpb24ubWluWTtcclxuICAgICAgICBjb25zdCBkc3RYID0gbG9jYXRpb24ubWluWCArIGxvY2F0aW9uUmVnaW9uLm1pblg7XHJcbiAgICAgICAgY29uc3QgZHN0WSA9IGxvY2F0aW9uLm1pblkgKyBsb2NhdGlvblJlZ2lvbi5taW5ZO1xyXG4gICAgICAgIGNvbnN0IGRzdFcgPSBsb2NhdGlvblJlZ2lvbi5tYXhYIC0gbG9jYXRpb25SZWdpb24ubWluWDtcclxuICAgICAgICBjb25zdCBkc3RIID0gbG9jYXRpb25SZWdpb24ubWF4WSAtIGxvY2F0aW9uUmVnaW9uLm1pblk7XHJcbiAgICAgICAgdGhpcy5fY2FudmFzQ29udGV4dC5jbGVhclJlY3QoZHN0WCwgZHN0WSwgZHN0VywgZHN0SCk7XHJcbiAgICAgICAgdGhpcy5fY2FudmFzQ29udGV4dC5kcmF3SW1hZ2Uoc291cmNlSW1hZ2UsIHNyY1gsIHNyY1ksIHNyY1csIHNyY0gsIGRzdFgsIGRzdFksIGRzdFcsIGRzdEgpO1xyXG4gICAgICAgIHRoaXMub25Db250ZW50VXBkYXRlLmZpcmUoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGVhbGxvY2F0ZXMgaW1hZ2UgZnJvbSB0aGUgYXRsYXMuXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZUltYWdlKGltYWdlKSB7XHJcbiAgICAgICAgdGhpcy5fYWxsb2NhdG9yLmRlYWxsb2NhdGUoaW1hZ2UpO1xyXG4gICAgfVxyXG4gICAgX2FsbG9jYXRlKGRlc2NyaXB0b3IpIHtcclxuICAgICAgICBsZXQgbG9jYXRpb24gPSB0aGlzLl9hbGxvY2F0b3IuYWxsb2NhdGUoZGVzY3JpcHRvcik7XHJcbiAgICAgICAgLy8gaW5jcmVtZW50YWwgZXhwYW5kIGNhbiBiZSBpbmVmZmljaWVudCBpZiB0d28gb3IgbW9yZSBpdGVyYXRpb25zIGFyZSBuZWVkZWQgdG8gYWxsb2NhdGUgYW4gaW1hZ2UsXHJcbiAgICAgICAgLy8gYnV0IGl0IGlzIGV4cGVjdGVkIHRvIGJlIGEgcmFyZSAoaWYgYW55KSBjYXNlLCByZXdvcmsgaWYgaXQgdHVybnMgb3V0IHRvIGJlIHdyb25nXHJcbiAgICAgICAgd2hpbGUgKCFsb2NhdGlvbikge1xyXG4gICAgICAgICAgICBjb25zdCBleHBhbmRlZFdpZHRoID0gdGhpcy53aWR0aCAqIEVYUEFORF9GQUNUT1I7XHJcbiAgICAgICAgICAgIGNvbnN0IGV4cGFuZGVkSGVpZ2h0ID0gdGhpcy5oZWlnaHQgKiBFWFBBTkRfRkFDVE9SO1xyXG4gICAgICAgICAgICBpZiAoZXhwYW5kZWRXaWR0aCA8PSBNQVhfQVRMQVNfV0lEVEggJiYgZXhwYW5kZWRIZWlnaHQgPD0gTUFYX0FUTEFTX0hFSUdIVCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZXhwYW5kKGV4cGFuZGVkV2lkdGgsIGV4cGFuZGVkSGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIGxvY2F0aW9uID0gdGhpcy5fYWxsb2NhdG9yLmFsbG9jYXRlKGRlc2NyaXB0b3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGxvY2F0aW9uO1xyXG4gICAgfVxyXG4gICAgX2V4cGFuZChuZXdXaWR0aCwgbmV3SGVpZ2h0KSB7XHJcbiAgICAgICAgdGhpcy5fYWxsb2NhdG9yLnJlc2l6ZShuZXdXaWR0aCwgbmV3SGVpZ2h0KTtcclxuICAgICAgICAvLyBzZXR0aW5nIG5ldyB3aWR0aC9oZWlnaHQgdG8gY2FudmFzIHdpbGwgY2xlYXIgaXQsXHJcbiAgICAgICAgLy8gc28gY3VycmVudCBkYXRhIGlzIHNhdmVkIHRvIGJlIHJlc3RvcmVkIGltbWVkaWF0ZWx5IGFmdGVyIHJlc2l6aW5nXHJcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuX2NhbnZhc0NvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IG5ld1dpZHRoO1xyXG4gICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IG5ld0hlaWdodDtcclxuICAgICAgICB0aGlzLl9jYW52YXNDb250ZXh0LnB1dEltYWdlRGF0YShkYXRhLCAwLCAwKTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9iaWxsYm9hcmQvaW1hZ2VfYXRsYXMudHNcbi8vIG1vZHVsZSBpZCA9IDE1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBBcmVuYUFsbG9jYXRvciwgRnJlZUxpc3RBbGxvY2F0b3IgfSBmcm9tICcuL2FsbG9jYXRvcic7XHJcbi8qKlxyXG4gKiBBIHJlY3Rhbmd1bGFyIHJlZ2lvbiB3aXRoIGZpeGVkIGhlaWdodC4gVXRpbGl0eSBjbGFzcyBmb3Igc2hlbGYgYWxsb2NhdGlvbiBkZWZpbmVkIGJlbG93LlxyXG4gKi9cclxuY2xhc3MgU2hlbGYge1xyXG4gICAgY29uc3RydWN0b3Iod2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICB0aGlzLl9hbGxvY2F0b3IgPSBuZXcgRnJlZUxpc3RBbGxvY2F0b3IodGhpcy53aWR0aCk7XHJcbiAgICB9XHJcbiAgICBhbGxvY2F0ZSh3aWR0aCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hbGxvY2F0b3IuYWxsb2NhdGUod2lkdGgpO1xyXG4gICAgfVxyXG4gICAgZGVhbGxvY2F0ZShvZmZzZXQpIHtcclxuICAgICAgICB0aGlzLl9hbGxvY2F0b3IuZGVhbGxvY2F0ZShvZmZzZXQpO1xyXG4gICAgfVxyXG4gICAgaXNBbGxvY2F0ZWQob2Zmc2V0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FsbG9jYXRvci5pc0FsbG9jYXRlZChvZmZzZXQpO1xyXG4gICAgfVxyXG4gICAgY2FuQWxsb2NhdGUod2lkdGgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWxsb2NhdG9yLm1heEFsbG9jYWJsZVNpemUgPj0gd2lkdGg7XHJcbiAgICB9XHJcbiAgICByZXNpemUod2lkdGgpIHtcclxuICAgICAgICB0aGlzLl9hbGxvY2F0b3IuZXh0ZW5kKHdpZHRoKTtcclxuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEFsbG9jYXRlcyByZWN0YW5nbGVzIGluIFwic2hlbHZlc1wiIChoZWlnaHQgZml4ZWQgcmVnaW9ucykuIFRoZXkgYXJlIGNyZWF0ZWQgb2YgbmVjZXNzaXR5IHdoZW4gdGhlIG5leHQgb2JqZWN0IGRvZXNudFxyXG4gKiBmaXQgYW55IGV4aXN0aW5nIHNoZWxmLiBUbyBvcHRpbWl6ZSBzcGFjZSB1c2FnZSBpdCB0cmllcyB0byBmaW5kIHRoZSBiZXN0IHNoZWxmIGZvciBhbGxvY2F0aW9uIChtaW4gaGVpZ2h0IGRpZmYpLlxyXG4gKiBBIHNoZWxmIHdoZW4gYWxsb2NhdGVkIGlzIG5ldmVyIGRlYWxsb2NhdGVkIGJhY2sgYW5kIGV4aXN0cyBkdXJpbmcgYWxsIHRoZSBhbGxvY2F0b3IgbGlmZXRpbWUuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgU2hlbGZBbGxvY2F0b3IyRCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMuX3NoZWx2ZXMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5fc2hlbGZBbGxvY2F0b3IgPSBuZXcgQXJlbmFBbGxvY2F0b3IoaGVpZ2h0KTsgLy8gbm8gc2hlbGYgZGVhbGxvY2F0aW9uLCB0aGF0IGlzIHdoeSBBcmVuYUFsbG9jYXRvciBpcyBmaW5lXHJcbiAgICB9XHJcbiAgICBhbGxvY2F0ZShvYmplY3QpIHtcclxuICAgICAgICBsZXQgYmVzdFNoZWxmO1xyXG4gICAgICAgIGxldCBiZXN0U2hlbGZPZmZzZXQgPSAtMTtcclxuICAgICAgICBsZXQgYmVzdFNoZWxmUmF0aW8gPSAtMTtcclxuICAgICAgICBmb3IgKGNvbnN0IFtvZmZzZXQsIHNoZWxmXSBvZiB0aGlzLl9zaGVsdmVzLmVudHJpZXMoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBzaGVsZlJhdGlvID0gb2JqZWN0LmhlaWdodCAvIHNoZWxmLmhlaWdodDtcclxuICAgICAgICAgICAgaWYgKHNoZWxmUmF0aW8gPT09IDEgJiYgc2hlbGYuY2FuQWxsb2NhdGUob2JqZWN0LndpZHRoKSkge1xyXG4gICAgICAgICAgICAgICAgYmVzdFNoZWxmID0gc2hlbGY7XHJcbiAgICAgICAgICAgICAgICBiZXN0U2hlbGZPZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzaGVsZlJhdGlvIDwgMSAmJiBzaGVsZlJhdGlvID4gYmVzdFNoZWxmUmF0aW8gJiYgc2hlbGYuY2FuQWxsb2NhdGUob2JqZWN0LndpZHRoKSkge1xyXG4gICAgICAgICAgICAgICAgYmVzdFNoZWxmID0gc2hlbGY7XHJcbiAgICAgICAgICAgICAgICBiZXN0U2hlbGZPZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICBiZXN0U2hlbGZSYXRpbyA9IHNoZWxmUmF0aW87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFiZXN0U2hlbGYgJiYgdGhpcy5fc2hlbGZBbGxvY2F0b3IubWF4QWxsb2NhYmxlU2l6ZSA+PSBvYmplY3QuaGVpZ2h0ICYmIHRoaXMud2lkdGggPj0gb2JqZWN0LndpZHRoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuX3NoZWxmQWxsb2NhdG9yLmFsbG9jYXRlKG9iamVjdC5oZWlnaHQpO1xyXG4gICAgICAgICAgICBiZXN0U2hlbGYgPSBuZXcgU2hlbGYodGhpcy53aWR0aCwgb2JqZWN0LmhlaWdodCk7XHJcbiAgICAgICAgICAgIGJlc3RTaGVsZk9mZnNldCA9IG9mZnNldDtcclxuICAgICAgICAgICAgdGhpcy5fc2hlbHZlcy5zZXQob2Zmc2V0LCBiZXN0U2hlbGYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYmVzdFNoZWxmKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBiZXN0U2hlbGYuYWxsb2NhdGUob2JqZWN0LndpZHRoKTtcclxuICAgICAgICAgICAgY29uc3QgdG9wID0gYmVzdFNoZWxmT2Zmc2V0O1xyXG4gICAgICAgICAgICBjb25zdCBsb2NhdGlvbiA9IHtcclxuICAgICAgICAgICAgICAgIG1pblg6IGxlZnQsXHJcbiAgICAgICAgICAgICAgICBtYXhYOiBsZWZ0ICsgb2JqZWN0LndpZHRoLFxyXG4gICAgICAgICAgICAgICAgbWluWTogdG9wLFxyXG4gICAgICAgICAgICAgICAgbWF4WTogdG9wICsgb2JqZWN0LmhlaWdodFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gbG9jYXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBkZWFsbG9jYXRlKG9iamVjdExvY2F0aW9uKSB7XHJcbiAgICAgICAgY29uc3Qgc2hlbGYgPSB0aGlzLl9zaGVsdmVzLmdldChvYmplY3RMb2NhdGlvbi5taW5ZKTtcclxuICAgICAgICBpZiAoc2hlbGYpIHtcclxuICAgICAgICAgICAgc2hlbGYuZGVhbGxvY2F0ZShvYmplY3RMb2NhdGlvbi5taW5YKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpc0FsbG9jYXRlZChvYmplY3RMb2NhdGlvbikge1xyXG4gICAgICAgIGNvbnN0IHNoZWxmID0gdGhpcy5fc2hlbHZlcy5nZXQob2JqZWN0TG9jYXRpb24ubWluWSk7XHJcbiAgICAgICAgcmV0dXJuICEhc2hlbGYgJiYgc2hlbGYuaXNBbGxvY2F0ZWQob2JqZWN0TG9jYXRpb24ubWluWCk7XHJcbiAgICB9XHJcbiAgICByZXNpemUod2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIHRoaXMuX3NoZWxmQWxsb2NhdG9yLmV4dGVuZChoZWlnaHQpO1xyXG4gICAgICAgIGZvciAoY29uc3Qgc2hlbGYgb2YgdGhpcy5fc2hlbHZlcy52YWx1ZXMoKSkge1xyXG4gICAgICAgICAgICBzaGVsZi5yZXNpemUod2lkdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9hbGxvY2F0b3JfMmQudHNcbi8vIG1vZHVsZSBpZCA9IDE1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICogU2ltcGxlIGltcGxlbWVudGF0aW9uIG9mIEJpbmFyeSBTZWFyY2ggVHJlZS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBCaW5hcnlTZWFyY2hUcmVlIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGNvbXBhcmF0b3IgVG8gc3BlY2lmeSB0aGUgb3JkZXIgb2YgaXRlbXMsIHRoYXQgY2FuIGJlIGFueSBjb21wbGV4IG9iamVjdHMuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGNvbXBhcmF0b3IpIHtcclxuICAgICAgICB0aGlzLl9jb21wYXJhdG9yID0gY29tcGFyYXRvcjtcclxuICAgICAgICB0aGlzLl9zaXplID0gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVGhlIHJvb3QgZWxlbWVudCBvciBgdW5kZWZpbmVkYCBpZiB0aGUgdHJlZSBpcyBlbXB0eS5cclxuICAgICAqL1xyXG4gICAgZ2V0IHJvb3QoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3Q7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIHRyZWUuXHJcbiAgICAgKi9cclxuICAgIGdldCBzaXplKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zaXplO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgc21hbGxlc3QgZWxlbWVudCBpbiB0aGUgdHJlZSBvciBgdW5kZWZpbmVkYCB0aGUgdGhlIHRyZWUgaXMgZW1wdHkuXHJcbiAgICAgKi9cclxuICAgIGdldCBtaW4oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3Jvb3QpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21pbih0aGlzLl9yb290KS52YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVGhlIGJpZ2dlc3QgZWxlbWVudCBpbiB0aGUgdHJlZSBvciBgdW5kZWZpbmVkYCB0aGUgdGhlIHRyZWUgaXMgZW1wdHkuXHJcbiAgICAgKi9cclxuICAgIGdldCBtYXgoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3Jvb3QpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21heCh0aGlzLl9yb290KS52YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIGluc2VydChpdGVtKSB7XHJcbiAgICAgICAgdGhpcy5fc2l6ZSsrO1xyXG4gICAgICAgIGlmICghdGhpcy5fcm9vdCkge1xyXG4gICAgICAgICAgICB0aGlzLl9yb290ID0geyB2YWx1ZTogaXRlbSB9O1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcm9vdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLl9yb290O1xyXG4gICAgICAgIHdoaWxlIChub2RlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9jb21wYXJhdG9yKGl0ZW0sIG5vZGUudmFsdWUpIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFub2RlLmxlZnQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5sZWZ0ID0geyBwYXJlbnQ6IG5vZGUsIHZhbHVlOiBpdGVtIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFub2RlLnJpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUucmlnaHQgPSB7IHBhcmVudDogbm9kZSwgdmFsdWU6IGl0ZW0gfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGltcG9zc2libGUgdG8gZ2V0IHRoZXJlLCB0aHJvd2luZyBpcyB0byBtYWtlIFRTIGFuYWxpemF0b3IgaGFwcHlcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcclxuICAgIH1cclxuICAgIHJlbW92ZShub2RlKSB7XHJcbiAgICAgICAgdGhpcy5fc2l6ZS0tO1xyXG4gICAgICAgIGlmIChub2RlLmxlZnQgJiYgbm9kZS5yaWdodCkge1xyXG4gICAgICAgICAgICBjb25zdCBzdWNjZXNzb3IgPSB0aGlzLl9taW4obm9kZS5yaWdodCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlcGxhY2VTdWJ0cmVlKG5vZGUsIHN1Y2Nlc3Nvcik7XHJcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBsaW5rcyB0byBjaGlsZHJlbiBvZiB0aGUgcmVtb3ZlZCBub2RlXHJcbiAgICAgICAgICAgIGlmIChub2RlLmxlZnQpIHtcclxuICAgICAgICAgICAgICAgIHN1Y2Nlc3Nvci5sZWZ0ID0gbm9kZS5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgbm9kZS5sZWZ0LnBhcmVudCA9IHN1Y2Nlc3NvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobm9kZS5yaWdodCkge1xyXG4gICAgICAgICAgICAgICAgc3VjY2Vzc29yLnJpZ2h0ID0gbm9kZS5yaWdodDtcclxuICAgICAgICAgICAgICAgIG5vZGUucmlnaHQucGFyZW50ID0gc3VjY2Vzc29yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG5vZGUubGVmdCkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZXBsYWNlU3VidHJlZShub2RlLCBub2RlLmxlZnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChub2RlLnJpZ2h0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlcGxhY2VTdWJ0cmVlKG5vZGUsIG5vZGUucmlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVwbGFjZVN1YnRyZWUobm9kZSwgdW5kZWZpbmVkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEl0ZXJhdGVzIGVsZW1lbnRzIGluIGFzY2VuZGluZyBvcmRlci5cclxuICAgICAqL1xyXG4gICAgKnZhbHVlcyhub2RlKSB7XHJcbiAgICAgICAgaWYgKG5vZGUpIHtcclxuICAgICAgICAgICAgeWllbGQqIHRoaXMudmFsdWVzKG5vZGUubGVmdCk7XHJcbiAgICAgICAgICAgIHlpZWxkIG5vZGUudmFsdWU7XHJcbiAgICAgICAgICAgIHlpZWxkKiB0aGlzLnZhbHVlcyhub2RlLnJpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEl0ZXJhdGVzIGVsZW1lbnRzIGluIGFzY2VuZGluZyBvcmRlci5cclxuICAgICAqL1xyXG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzKHRoaXMuX3Jvb3QpO1xyXG4gICAgfVxyXG4gICAgX21pbihmcm9tKSB7XHJcbiAgICAgICAgbGV0IG5vZGUgPSBmcm9tO1xyXG4gICAgICAgIHdoaWxlIChub2RlLmxlZnQpIHtcclxuICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICB9XHJcbiAgICBfbWF4KGZyb20pIHtcclxuICAgICAgICBsZXQgbm9kZSA9IGZyb207XHJcbiAgICAgICAgd2hpbGUgKG5vZGUucmlnaHQpIHtcclxuICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW9yZ2FuaXplcyB0aGUgdHJlZSBzdHJ1Y3R1cmUgc28gdGhhdCB0aGUgcmVwbGFjZW1lbnQgbm9kZSB0YWtlcyByZXBsYWNlYWJsZSdzIHBvc2l0aW9uLCB0aGUgbGF0dGVyIGlzIHJlbW92ZWQuXHJcbiAgICAgKi9cclxuICAgIF9yZXBsYWNlU3VidHJlZShyZXBsYWNlYWJsZSwgcmVwbGFjZW1lbnQpIHtcclxuICAgICAgICBpZiAocmVwbGFjZWFibGUucGFyZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChyZXBsYWNlYWJsZS5wYXJlbnQubGVmdCA9PT0gcmVwbGFjZWFibGUpIHtcclxuICAgICAgICAgICAgICAgIHJlcGxhY2VhYmxlLnBhcmVudC5sZWZ0ID0gcmVwbGFjZW1lbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocmVwbGFjZWFibGUucGFyZW50LnJpZ2h0ID09PSByZXBsYWNlYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgcmVwbGFjZWFibGUucGFyZW50LnJpZ2h0ID0gcmVwbGFjZW1lbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jvb3QgPSByZXBsYWNlbWVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlcGxhY2VtZW50KSB7XHJcbiAgICAgICAgICAgIC8vIHJlbW92ZSByZXBsYWNlbWVudCBmcm9tIGl0cyBjdXJyZW50IGxvY2F0aW9uXHJcbiAgICAgICAgICAgIGlmIChyZXBsYWNlbWVudC5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChyZXBsYWNlbWVudC5wYXJlbnQubGVmdCA9PT0gcmVwbGFjZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudC5wYXJlbnQubGVmdCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlcGxhY2VtZW50LnBhcmVudC5yaWdodCA9PT0gcmVwbGFjZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudC5wYXJlbnQucmlnaHQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVwbGFjZW1lbnQucGFyZW50ID0gcmVwbGFjZWFibGUucGFyZW50O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL2JpbmFyeV90cmVlLnRzXG4vLyBtb2R1bGUgaWQgPSAxNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIFNldCB3aXRoIHByZWRpY3RhYmxlIGl0ZXJhdGlvbiBvcmRlci4gU3RvcmVzIGl0ZW1zIGFzIGEgdHdvIHdheSBsaW5rZWQgbGlzdCB0aHVzIGFsbG93aW5nIHRvIGluc2VydCBpdGVtcyBpbiBiZXR3ZWVuLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGlua2VkU2V0IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuX25vZGVzID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGJlZ2luKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9iZWdpbiAmJiB0aGlzLl9iZWdpbi52YWx1ZTtcclxuICAgIH1cclxuICAgIGdldCBlbmQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuZCAmJiB0aGlzLl9lbmQudmFsdWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEluc2VydHMgYSBuZXcgaXRlbSBhdCB0aGUgZW5kIG9mIHRoZSBzZXQuXHJcbiAgICAgKi9cclxuICAgIGluc2VydChpdGVtKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9ub2Rlcy5oYXMoaXRlbSkpIHtcclxuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHsgdmFsdWU6IGl0ZW0gfTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2VuZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnNlcnRBZnRlcih0aGlzLl9lbmQudmFsdWUsIGl0ZW0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYmVnaW4gPSB0aGlzLl9lbmQgPSBub2RlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbm9kZXMuc2V0KGl0ZW0sIG5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnNlcnRzIGEgbmV3IGl0ZW0gYmVmb3JlIHRoZSBzcGVjaWZpZWQgb25lLiBJZiB0aGUgYmVmb3JlIGl0ZW0gaXMgbm90IGluIHRoZSBzZXQgb3JcclxuICAgICAqIHRoZSBpdGVtIGlzIGFscmVhZHkgaW5zZXJ0ZWQgbm90aGluZyBoYXBwZW5zLlxyXG4gICAgICovXHJcbiAgICBpbnNlcnRCZWZvcmUoYmVmb3JlLCBpdGVtKSB7XHJcbiAgICAgICAgY29uc3QgYmVmb3JlTm9kZSA9IHRoaXMuX25vZGVzLmdldChiZWZvcmUpO1xyXG4gICAgICAgIGlmIChiZWZvcmVOb2RlICYmICF0aGlzLl9ub2Rlcy5oYXMoaXRlbSkpIHtcclxuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHsgdmFsdWU6IGl0ZW0gfTtcclxuICAgICAgICAgICAgaWYgKGJlZm9yZU5vZGUucHJldikge1xyXG4gICAgICAgICAgICAgICAgYmVmb3JlTm9kZS5wcmV2Lm5leHQgPSBub2RlO1xyXG4gICAgICAgICAgICAgICAgbm9kZS5wcmV2ID0gYmVmb3JlTm9kZS5wcmV2O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG5vZGUubmV4dCA9IGJlZm9yZU5vZGU7XHJcbiAgICAgICAgICAgIGJlZm9yZU5vZGUucHJldiA9IG5vZGU7XHJcbiAgICAgICAgICAgIHRoaXMuX25vZGVzLnNldChpdGVtLCBub2RlKTtcclxuICAgICAgICAgICAgaWYgKGJlZm9yZU5vZGUgPT09IHRoaXMuX2JlZ2luKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9iZWdpbiA9IG5vZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEluc2VydHMgYSBuZXcgaXRlbSBhZnRlciB0aGUgc3BlY2lmaWVkIG9uZS4gSWYgdGhlIGFmdGVyIGl0ZW0gaXMgbm90IGluIHRoZSBzZXQgb3JcclxuICAgICAqIHRoZSBpdGVtIGlzIGFscmVhZHkgaW5zZXJ0ZWQgbm90aGluZyBoYXBwZW5zLlxyXG4gICAgICovXHJcbiAgICBpbnNlcnRBZnRlcihhZnRlciwgaXRlbSkge1xyXG4gICAgICAgIGNvbnN0IGFmdGVyTm9kZSA9IHRoaXMuX25vZGVzLmdldChhZnRlcik7XHJcbiAgICAgICAgaWYgKGFmdGVyTm9kZSAmJiAhdGhpcy5fbm9kZXMuaGFzKGl0ZW0pKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB7IHZhbHVlOiBpdGVtIH07XHJcbiAgICAgICAgICAgIGlmIChhZnRlck5vZGUubmV4dCkge1xyXG4gICAgICAgICAgICAgICAgYWZ0ZXJOb2RlLm5leHQucHJldiA9IG5vZGU7XHJcbiAgICAgICAgICAgICAgICBub2RlLm5leHQgPSBhZnRlck5vZGUubmV4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBub2RlLnByZXYgPSBhZnRlck5vZGU7XHJcbiAgICAgICAgICAgIGFmdGVyTm9kZS5uZXh0ID0gbm9kZTtcclxuICAgICAgICAgICAgdGhpcy5fbm9kZXMuc2V0KGl0ZW0sIG5vZGUpO1xyXG4gICAgICAgICAgICBpZiAoYWZ0ZXJOb2RlID09PSB0aGlzLl9lbmQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2VuZCA9IG5vZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgaXRlbSBmcm9tIHRoZSBzZXQuXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZShpdGVtKSB7XHJcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuX25vZGVzLmdldChpdGVtKTtcclxuICAgICAgICBpZiAobm9kZSkge1xyXG4gICAgICAgICAgICBpZiAobm9kZSA9PT0gdGhpcy5fYmVnaW4pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2JlZ2luID0gbm9kZS5uZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChub2RlID09PSB0aGlzLl9lbmQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2VuZCA9IG5vZGUucHJldjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobm9kZS5uZXh0KSB7XHJcbiAgICAgICAgICAgICAgICBub2RlLm5leHQucHJldiA9IG5vZGUucHJldjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobm9kZS5wcmV2KSB7XHJcbiAgICAgICAgICAgICAgICBub2RlLnByZXYubmV4dCA9IG5vZGUubmV4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9ub2Rlcy5kZWxldGUoaXRlbSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBgdW5kZWZpbmVkYCBpZiB0aGUgaXRlbSBpcyBub3QgaW4gdGhlIHNldCBvciBpdCBpcyB0aGUgZmlyc3QgZWxlbWVudHMuXHJcbiAgICAgKi9cclxuICAgIGdldFByZXYoaXRlbSkge1xyXG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLl9ub2Rlcy5nZXQoaXRlbSk7XHJcbiAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS5wcmV2KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlLnByZXYudmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIGB1bmRlZmluZWRgIGlmIHRoZSBpdGVtIGlzIG5vdCBpbiB0aGUgc2V0IG9yIGl0IGlzIHRoZSBsYXN0IGVsZW1lbnRzLlxyXG4gICAgICovXHJcbiAgICBnZXROZXh0KGl0ZW0pIHtcclxuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5fbm9kZXMuZ2V0KGl0ZW0pO1xyXG4gICAgICAgIGlmIChub2RlICYmIG5vZGUubmV4dCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5uZXh0LnZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJdGVyYXRlcyBvdmVyIHRoZSBzZXQgZnJvbSB0aGUgZmlzdCBlbGVtZW50IHRvIHRoZSBsYXN0IChpbiB0aGUgb3JkZXIgb2YgaW5zZXJ0aW9uXHJcbiAgICAgKiBpZiB0aGUgaW5zZXJ0IG1ldGhvZCB3YXMgdXNlZCBvbmx5KS5cclxuICAgICAqL1xyXG4gICAgKnZhbHVlcygpIHtcclxuICAgICAgICBsZXQgbm9kZSA9IHRoaXMuX2JlZ2luO1xyXG4gICAgICAgIHdoaWxlIChub2RlKSB7XHJcbiAgICAgICAgICAgIHlpZWxkIG5vZGUudmFsdWU7XHJcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJdGVyYXRlcyBvdmVyIHRoZSBzZXQgZnJvbSB0aGUgZmlzdCBlbGVtZW50IHRvIHRoZSBsYXN0IChpbiB0aGUgb3JkZXIgb2YgaW5zZXJ0aW9uXHJcbiAgICAgKiBpZiB0aGUgaW5zZXJ0IG1ldGhvZCB3YXMgdXNlZCBvbmx5KS5cclxuICAgICAqL1xyXG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzKCk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9saW5rZWRfc2V0LnRzXG4vLyBtb2R1bGUgaWQgPSAxNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IFJlbmRlclN0YXRlIGZyb20gJy4uL3JlbmRlci9zdGF0ZSc7XHJcbmltcG9ydCAqIGFzIGNvbG9yIGZyb20gJy4uL3V0aWwvY29sb3InO1xyXG5pbXBvcnQgKiBhcyB2ZWMyIGZyb20gJy4uL21hdGgvdmVjdG9yMic7XHJcbmltcG9ydCAqIGFzIHZlYzMgZnJvbSAnLi4vbWF0aC92ZWN0b3IzJztcclxuaW1wb3J0ICogYXMgbWF0NCBmcm9tICcuLi9tYXRoL21hdHJpeDQnO1xyXG5pbXBvcnQgR3JpZFNhbXBsZXJCdWZmZXJXcml0ZXIsIHsgQVRUUklCVVRFX01BUFBJTkcgYXMgR1JJRF9TQU1QTEVSX0FUVFJJQlVURVMgfSBmcm9tICcuL2dyaWRfc2FtcGxlcl9idWZmZXJfd3JpdGVyJztcclxuaW1wb3J0IHsgVm9pZEV2ZW50RW1pdHRlciB9IGZyb20gJy4uL3V0aWwvZXZlbnRfZW1pdHRlcic7XHJcbmltcG9ydCBHcmlkUmVuZGVyZXIgZnJvbSAnLi9ncmlkX3JlbmRlcmVyJztcclxuaW1wb3J0IFJlc2V0UmVtb3ZlZFByaW1pdGl2ZXMgZnJvbSAnLi92aXNpYmlsaXR5X3Jlc29sdXRpb25fc3RlcHMvcmVzZXRfcmVtb3ZlZF9wcmltaXRpdmVzJztcclxuaW1wb3J0IEZhZGVvdXRBbGwgZnJvbSAnLi92aXNpYmlsaXR5X3Jlc29sdXRpb25fc3RlcHMvZmFkZW91dF9hbGwnO1xyXG5pbXBvcnQgRmFkZWluVmlzaWJsZSBmcm9tICcuL3Zpc2liaWxpdHlfcmVzb2x1dGlvbl9zdGVwcy9mYWRlaW5fdmlzaWJsZSc7XHJcbmltcG9ydCBGYWRlb3V0T3ZlcmxhcHBlZCBmcm9tICcuL3Zpc2liaWxpdHlfcmVzb2x1dGlvbl9zdGVwcy9mYWRlb3V0X292ZXJsYXBwZWQnO1xyXG5pbXBvcnQgeyBjYWxjdWxhdGVDYW1lcmFQb3NpdGlvbnMgfSBmcm9tICcuLi9yZW5kZXIvdXRpbC9jYW1lcmFfcG9zaXRpb24nO1xyXG5pbXBvcnQgZ2V0RHByIGZyb20gJy4uL3V0aWwvaGQnO1xyXG5jb25zdCBGQURJTkdfU1RPUFBFRCA9IC0xO1xyXG5jb25zdCBERUZBVUxUX0ZBREVfRUZGRUNUX0RVUkFUSU9OID0gMTUwO1xyXG5jb25zdCBJRF9DT01QT05FTlRfU0laRSA9IDI1NjtcclxuY29uc3QgVklTSUJJTElUWV9JTklUX1NUQVRFID0gbmV3IFJlbmRlclN0YXRlKHtcclxuICAgIGNsZWFyQ29sb3I6IGNvbG9yLmNyZWF0ZSgwLCAwLCAwLCAwKSxcclxuICAgIGRpdGhlcjogZmFsc2VcclxufSk7XHJcbmNvbnN0IEVNUFRZX0dSSURfQ0VMTCA9IGNvbG9yLmNyZWF0ZSgwLCAwLCAwLCAxKTtcclxuY29uc3QgRElSRUNUX1BSSU9SSVRZX0dSSURfU1RBVEUgPSBuZXcgUmVuZGVyU3RhdGUoe1xyXG4gICAgY2xlYXJDb2xvcjogRU1QVFlfR1JJRF9DRUxMLFxyXG4gICAgZGVwdGhUZXN0OiB0cnVlLFxyXG4gICAgY2xlYXJEZXB0aDogMCxcclxuICAgIC8vIHByaW1pdGl2ZXMgd2l0aCBlcXVhbCBwcmlvcml0eSBhcmUgcmVzb2x2ZWQgYXMgZm9sbG93aW5nOiBsYXRlciBvbmVzIG92ZXJsYXAgcHJldmlvdXNcclxuICAgIGRlcHRoRnVuYzogNTE4IC8qIEdSRUFURVJfT1JfRVFVQUwgKi8sXHJcbiAgICBkaXRoZXI6IGZhbHNlXHJcbn0pO1xyXG5jb25zdCBSRVZFUlNFX1BSSU9SSVRZX0dSSURfU1RBVEUgPSBuZXcgUmVuZGVyU3RhdGUoe1xyXG4gICAgY2xlYXJDb2xvcjogRU1QVFlfR1JJRF9DRUxMLFxyXG4gICAgZGVwdGhUZXN0OiB0cnVlLFxyXG4gICAgY2xlYXJEZXB0aDogMSxcclxuICAgIGRlcHRoRnVuYzogNTEzIC8qIExFU1MgKi8sXHJcbiAgICBkaXRoZXI6IGZhbHNlXHJcbn0pO1xyXG4vLyBzaXplIG9mIG1pbmltYWwgcmVjb2duaXphYmxlIHNxdWFyZSBzaWRlIGluIGNzcyBwaXhlbHMuXHJcbmNvbnN0IEdSSURfUFJFQ0lTSU9OX1BYID0gNjtcclxuLyoqXHJcbiAqIEFwYXJ0IGZyb20gYmVpbmcgcmVtb3ZlZCBmcm9tIHNjZW5lIHRoZXJlIGFyZSBvdGhlciByZWFzb25zIGZvciBwcmltaXRpdmVzIHRvIGJlIGludmlzaWJsZTogZS5nLiB0aGV5IGFyZVxyXG4gKiBvdmVybGFwcGVkIGJ5IHByaW1pdGl2ZXMgd2l0aCBoaWdoZXIgcHJpb3JpdHkuIFRoaXMgc3RhdGUgaXMgaGlnaGx5IGR5bmFtaWMsIHByaW1pdGl2ZXMgbWF5IGJlIG9mIGRpZmZlcmVudCB0eXBlcyxcclxuICogZnJvbSBkaWZmZXJlbnQgc291cmNlcyBhbmQgdGhleSBjYW4gaGF2ZSBxdWl0ZSBub24tdHJpdmlhbCBzaGFwZXMuIFNvIHRoZXJlIHNob3VsZCBiZSBhIHNpbmdsZSBwb2ludCBvZiBjb2xsaXNpb25cclxuICogcmVzb2x1dGlvbiBmb3IgYWxsIHByaW1pdGl2ZXMgaW4gc2NlbmUsIHRoYXQgaXMgd2hhdCB2aXNpYmlsaXR5IG1hbmFnZXIgaXMuXHJcbiAqXHJcbiAqIFZpc2liaWxpdHkgb2YgcHJpbWl0aXZlcyBpcyBjYWxjdWxhdGVkIGV2ZXJ5IGZyYW1lLiBUbyBzdXBwb3J0IGZhZGUtaW4vb3V0IGFuaW1hdGlvbiB2aXNpYmlsaXR5IHZhbHVlIGlzIGEgZmFjdG9yXHJcbiAqIHRoZSBhbHBoYSBjaGFubmVsIG9mIGEgZmluYWxseSByZW5kZXJlZCBwcmltaXRpdmUgaXMgdG8gYmUgbXVsdGlwbGllZCBieSAodmFsdWUgZnJvbSAwLjAgdG8gMS4wKS4gRm9yIGluc3RhbmNlLFxyXG4gKiBpZiBhbiBvYmplY3QgaXMganVzdCBhcHBlYXJlZCBvbiB0aGUgc2NlbmUsIHRoaXMgZmFjdG9yIHdpbGwgYmUgY2hhbmdlZCBmcm9tIDAuMCB0byAxLjAgaW4gZmFkZUVmZmVjdER1cmF0aW9uTXMgbXMuXHJcbiAqIFRoZXJlIGFyZSA0IHN0ZXBzIHRoZSB3aG9sZSBwcm9jZXNzIGNhbiBiZSByb3VnaGx5IHN1bW1hcml6ZWQgaW50bzpcclxuICogIDEuIGFjdHVhbGl6YXRpb24gLSByZXNldCB2YWx1ZXMgZm9yIHJlbW92ZWQgZnJvbSBzY2VuZSBwcmltaXRpdmVzXHJcbiAqICAyLiBmYWRlLW91dCBhbGwgLSBldmVuIHRob3VnaCBhbGwgcHJpbWl0aXZlcyBhcmUgZmFkZWQgb3V0IGF0IHRoaXMgc3RlcCwgdGhpcyBzdGVwIGlzIGludGVuZGVkIGZvciBpbnZpc2libGVcclxuICogICAgIHByaW1pdGl2ZXMgdG8gYW5pbWF0ZSB0aGVtIGRpc2FwcGVhcmluZy5cclxuICogIDMuIGZhZGUtaW4gdmlzaWJsZSAtIGNoZWNrIHdoaWNoIHByaW1pdGl2ZSBhcmUgdmlzaWJsZSBhbmQgaW5jcmVhc2UgaXRzIGFscGhhIHZpc2liaWxpdHkgdmFsdWUuXHJcbiAqICA0LiBmYWRlLW91dCBvdmVybGFwcGVkIC0gZmluZCBvdmVybGFwcyBieSBjb21wYXJpbmcgY29ycmVzcG9uZGluZyBwaXhlbHMgb2YgdGhlIHNjZW5lIHJlbmRlcmVkIGluIGRpcmVjdCBhbmRcclxuICogICAgIHJldmVyc2UgcHJpb3JpdHkgb3JkZXJzLlxyXG4gKlxyXG4gKiAgRHVlIHRvIHRoZSBmYWN0IHRoYXQgd2UgdXNlIGdyaWQgd2l0aCBmaW5pdGUgcHJlY2lzaW9uIHRoZXJlIGFyZSBzb21lIGNhc2VzIHdoZXJlIHRoaXMgYXBwcm9hY2ggcHJvZHVjZXNcclxuICogIHVucGxlYXNhbnQgYXJ0aWZhY3RzIChibGlua2luZykuIFRvIGNvcGUgd2l0aCBpdCBzdGFiaWxpdHkgc2hpZnQgYW5kIHN0b3Jpbmcgem9vbSBvZiB0aGUgZmlyc3Qgb3ZlcmxhcCBhcmVcclxuICogIGludHJvZHVjZWQsIGJ1dCBpdCB3b3JrcyB3ZWxsIGZvciBub24tdGlsdGVkIG1hcCBvbmx5LlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmlzaWJpbGl0eU1hbmFnZXIge1xyXG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgY2FtZXJhLCByZW5kZXJMb29wLCB0YXJnZXRXaWR0aCwgdGFyZ2V0SGVpZ2h0LCBmYWRlRWZmZWN0RHVyYXRpb24gPSBERUZBVUxUX0ZBREVfRUZGRUNUX0RVUkFUSU9OKSB7XHJcbiAgICAgICAgdGhpcy5vblJlcmVuZGVyUmVxdWlyZWQgPSBuZXcgVm9pZEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMuZmFkZUVmZmVjdER1cmF0aW9uID0gZmFkZUVmZmVjdER1cmF0aW9uO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgICAgIHRoaXMuX2NhbWVyYSA9IGNhbWVyYTtcclxuICAgICAgICB0aGlzLl9yZW5kZXJMb29wID0gcmVuZGVyTG9vcDtcclxuICAgICAgICB0aGlzLl9sYXN0UmVuZGVyVGltZUluTG9vcCA9IEZBRElOR19TVE9QUEVEO1xyXG4gICAgICAgIHRoaXMuX3ByZXZUYXJnZXRTaXplID0geyB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XHJcbiAgICAgICAgdGhpcy5fc2NlbmVVcGRhdGVMaXN0ZW5lciA9IHRoaXMuX29uU2NlbmVVcGRhdGUuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLl9jYW1lcmEub25VcGRhdGUuYWRkTGlzdGVuZXIodGhpcy5fc2NlbmVVcGRhdGVMaXN0ZW5lcik7XHJcbiAgICAgICAgdGhpcy5fYmVmb3JlUmVuZGVyTGlzdGVuZXIgPSB0aGlzLl9vbkJlZm9yZVJlbmRlci5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX3JlbmRlckxvb3Aub25CZWZvcmVSZW5kZXIuYWRkTGlzdGVuZXIodGhpcy5fYmVmb3JlUmVuZGVyTGlzdGVuZXIpO1xyXG4gICAgICAgIHRoaXMuX2RpcmVjdFByaW9yaXR5R3JpZFJlbmRlcmVyID0gbmV3IEdyaWRSZW5kZXJlcihjb250ZXh0LCBESVJFQ1RfUFJJT1JJVFlfR1JJRF9TVEFURSk7XHJcbiAgICAgICAgdGhpcy5fcmV2ZXJzZVByaW9yaXR5R3JpZFJlbmRlcmVyID0gbmV3IEdyaWRSZW5kZXJlcihjb250ZXh0LCBSRVZFUlNFX1BSSU9SSVRZX0dSSURfU1RBVEUpO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRWaXNpYmlsaXR5VGV4dHVyZSA9IGNvbnRleHQuY3JlYXRlRW1wdHkyRFRleHR1cmUoSURfQ09NUE9ORU5UX1NJWkUsIElEX0NPTVBPTkVOVF9TSVpFLCA2NDA4IC8qIFJHQkEgKi8sIDUxMjEgLyogVU5TSUdORURfQllURSAqLyk7XHJcbiAgICAgICAgdGhpcy5fcHJldlZpc2liaWxpdHlUZXh0dXJlID0gY29udGV4dC5jcmVhdGVFbXB0eTJEVGV4dHVyZShJRF9DT01QT05FTlRfU0laRSwgSURfQ09NUE9ORU5UX1NJWkUsIDY0MDggLyogUkdCQSAqLywgNTEyMSAvKiBVTlNJR05FRF9CWVRFICovKTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50VmlzaWJpbGl0eUJ1ZmZlciA9IGNvbnRleHQuY3JlYXRlRnJhbWVidWZmZXIoeyBjb2xvcjogdGhpcy5fY3VycmVudFZpc2liaWxpdHlUZXh0dXJlIH0pO1xyXG4gICAgICAgIHRoaXMuX3ByZXZWaXNpYmlsaXR5QnVmZmVyID0gY29udGV4dC5jcmVhdGVGcmFtZWJ1ZmZlcih7IGNvbG9yOiB0aGlzLl9wcmV2VmlzaWJpbGl0eVRleHR1cmUgfSk7XHJcbiAgICAgICAgdGhpcy5fc3RhYmlsaXR5U2hpZnQgPSB2ZWMzLmNyZWF0ZSgwLCAwLCAwKTtcclxuICAgICAgICB0aGlzLl9ncmlkSGFsZlB4U2l6ZVVuaWZvcm0gPSB2ZWMyLmNyZWF0ZSgwLCAwKTtcclxuICAgICAgICB0aGlzLl9pZEhhbGZQeFNpemVVbmlmb3JtID0gdmVjMi5jcmVhdGUoMC41IC8gSURfQ09NUE9ORU5UX1NJWkUsIDAuNSAvIElEX0NPTVBPTkVOVF9TSVpFKTtcclxuICAgICAgICB0aGlzLl9zdGVwMVJlc2V0UmVtb3ZlZCA9IG5ldyBSZXNldFJlbW92ZWRQcmltaXRpdmVzKCk7XHJcbiAgICAgICAgdGhpcy5fc3RlcDJGYWRlb3V0QWxsID0gbmV3IEZhZGVvdXRBbGwoY29udGV4dCk7XHJcbiAgICAgICAgdGhpcy5fc3RlcDNGYWRlaW5WaXNpYmxlID0gbmV3IEZhZGVpblZpc2libGUoY29udGV4dCk7XHJcbiAgICAgICAgdGhpcy5fc3RlcDRGYWRlb3V0T3ZlcmxhcHBlZCA9IG5ldyBGYWRlb3V0T3ZlcmxhcHBlZChjb250ZXh0KTtcclxuICAgICAgICB0aGlzLl9jbGVhclZpc2liaWxpdHkodGhpcy5fY3VycmVudFZpc2liaWxpdHlCdWZmZXIpO1xyXG4gICAgICAgIHRoaXMuX3ByaW1pdGl2ZVByb3ZpZGVycyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2NvbG9ySWRSZW5kZXJlcnMgPSBbXTtcclxuICAgICAgICB0aGlzLl9yZXNldFJlbW92ZWRSZW5kZXJlcnMgPSBbXTtcclxuICAgICAgICB0aGlzLnNldFRhcmdldFNpemUodGFyZ2V0V2lkdGgsIHRhcmdldEhlaWdodCk7XHJcbiAgICB9XHJcbiAgICBnZXQgdmlzaWJpbGl0eVRleHR1cmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRWaXNpYmlsaXR5VGV4dHVyZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVG8gcHJvdmlkZSBwcm9wZXIgcHJlY2lzaW9uIGluIGNvbGxpc2lvbiByZXNvbHV0aW9uIHNpbXBsaWZpZWQgZ3JpZCBzaXplIGRlcGVuZHMgb24gdGhlIHJlbmRlciB0YXJnZXQsXHJcbiAgICAgKiB0aGF0IGNhbiBiZSBjaGFuZ2VkIGF0IHJ1biB0aW1lIChlLmcuIHRoZSB1c2VyIHJlc2l6ZXMgYnJvd3NlciB3aW5kb3cpLiBBIGxvdCBvZiBhc3NvY2lhdGVkIEdMIHJlc291cmNlcyBpcyBiZVxyXG4gICAgICogdXBkYXRlZCBpbiB0aGF0IGNhc2UuXHJcbiAgICAgKi9cclxuICAgIHNldFRhcmdldFNpemUod2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIGNvbnN0IGdyaWRQcmVjaXNpb25UYXJnZXRQeCA9IEdSSURfUFJFQ0lTSU9OX1BYICogZ2V0RHByKCk7XHJcbiAgICAgICAgY29uc3QgZ3JpZFdpZHRoID0gTWF0aC5jZWlsKHdpZHRoIC8gZ3JpZFByZWNpc2lvblRhcmdldFB4KTtcclxuICAgICAgICBjb25zdCBncmlkSGVpZ2h0ID0gTWF0aC5jZWlsKGhlaWdodCAvIGdyaWRQcmVjaXNpb25UYXJnZXRQeCk7XHJcbiAgICAgICAgdGhpcy5fZGlyZWN0UHJpb3JpdHlHcmlkUmVuZGVyZXIuc2V0UmVzb2x1dGlvbihncmlkV2lkdGgsIGdyaWRIZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuX3JldmVyc2VQcmlvcml0eUdyaWRSZW5kZXJlci5zZXRSZXNvbHV0aW9uKGdyaWRXaWR0aCwgZ3JpZEhlaWdodCk7XHJcbiAgICAgICAgaWYgKHRoaXMuX2dyaWRTYW1wbGVyVmVydGV4QnVmZmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3lHcmlkUmVzb3VyY2VzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG92ZXJsYXBTYW1wbGVyQnVmZmVyV3JpdGVyID0gbmV3IEdyaWRTYW1wbGVyQnVmZmVyV3JpdGVyKGdyaWRXaWR0aCwgZ3JpZEhlaWdodCk7XHJcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuX2NvbnRleHQ7XHJcbiAgICAgICAgdGhpcy5fZ3JpZFNhbXBsZXJWZXJ0ZXhCdWZmZXIgPSBjb250ZXh0LmNyZWF0ZVZlcnRleEJ1ZmZlcihvdmVybGFwU2FtcGxlckJ1ZmZlcldyaXRlci5kYXRhLmJ5dGVMZW5ndGgpO1xyXG4gICAgICAgIHRoaXMuX2dyaWRTYW1wbGVyVmFvID0gY29udGV4dC5jcmVhdGVWYW8oR1JJRF9TQU1QTEVSX0FUVFJJQlVURVMsIHRoaXMuX2dyaWRTYW1wbGVyVmVydGV4QnVmZmVyLCBudWxsKTtcclxuICAgICAgICB0aGlzLl9udW1iZXJPZkdyaWRTYW1wbGVycyA9IG92ZXJsYXBTYW1wbGVyQnVmZmVyV3JpdGVyLm51bWJlck9mU2FtcGxlcnM7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC51cGxvYWREYXRhVG9CdWZmZXIodGhpcy5fZ3JpZFNhbXBsZXJWZXJ0ZXhCdWZmZXIsIG92ZXJsYXBTYW1wbGVyQnVmZmVyV3JpdGVyLmRhdGEpO1xyXG4gICAgICAgIHRoaXMuX3ByZXZUYXJnZXRTaXplLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy5fcHJldlRhcmdldFNpemUuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMuX2dyaWRIYWxmUHhTaXplVW5pZm9ybS54ID0gMC41IC8gZ3JpZFdpZHRoO1xyXG4gICAgICAgIHRoaXMuX2dyaWRIYWxmUHhTaXplVW5pZm9ybS55ID0gMC41IC8gZ3JpZEhlaWdodDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVjYWxjdWxhdGVzIHZpc2liaWxpdHkgb2YgYWxsIGNvbGxpZGluZyBwcmltaXRpdmVzIGluIHNjZW5lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCB0aGUgc2NlbmUgaXMgdG8gYmUgcmVuZGVyZWQgaW50by5cclxuICAgICAqIEBwYXJhbSB1bmlmb3JtcyBTZXQgb2YgcHJlY2FsY3VsYXRlZCB1bmlmb3JtcyBnbG9iYWwgZm9yIGN1cnJlbnQgZnJhbWUuXHJcbiAgICAgKiBAcmV0dXJucyBVcGRhdGVkIHRleHR1cmUgd2l0aCB2aXNpYmlsaXR5IHZhbHVlcyBmb3IgYWxsIHByaW1pdGl2ZXMuXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZVZpc2liaWxpdHlJZk5lZWRlZCgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2lzRGlydHkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9pc0RpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgLy8gUmFzdGVyaXphdGlvbiBtYXkgYmUgbm90IHN0YWJsZSBpbiB0aGUgc2Vuc2Ugb2YgdGhlIHNoYXBlIG9mIHBpeGVscyBvY2N1cGllZCBieSBwYXJ0aWN1bGFyIG9iamVjdCB3aGVuIHRoaXNcclxuICAgICAgICAvLyBvYmplY3QgZ2V0cyBzaGlmdGVkIChlLmcuIHRoZSB1c2VyIGRyYWdzIHRoZSBjZW50ZXIgb2YgdGhlIG1hcCkgYW5kIHNpbmNlIGNvbGxpc2lvbnMgYXJlIGRldGVjdGVkIGJ5XHJcbiAgICAgICAgLy8gb3ZlcmxhcHBlZCBwaXhlbHMgdGhpcyBmYWN0IGNhbiBsZWFkIHRvIGJsaW5raW5nIChmb3VuZCBvdmVybGFwcGluZyBpbiBvbmUgZnJhbWUvbm90IGZvdW5kIGluIHRoZSBuZXh0L2V0YykuXHJcbiAgICAgICAgLy8gRm9yIHRob3NlIG9iamVjdHMgKGFuZCB0aGVpciBwb3NpdGlvbnMpIHRoYXQgYXJlIG5vdCBkaXN0b3J0ZWQgYnkgcGVyc3BlY3RpdmUgaXQgY2FuIGJlIGZpeGVkIGJ5XHJcbiAgICAgICAgLy8gaW50cm9kdWNpbmcgYSBzaGlmdCB0aGF0IHRha2VzIGludG8gYWNjb3VudCB0aGUgYW1vdW50IG9mIGRyYWcgYW5kIGZvcmNlcyB2ZXJ0aWNlcyB0byBiZSBkaXNwbGFjZWQgaW4gdGhlXHJcbiAgICAgICAgLy8gc2FtZSBwb3NpdGlvbiBpbiBncmlkJ3MgY2VsbC5cclxuICAgICAgICBjb25zdCBzaGlmdCA9IHRoaXMuX3N0YWJpbGl0eVNoaWZ0O1xyXG4gICAgICAgIHZlYzIuY29weSh0aGlzLl9jYW1lcmEuY2VudGVyLCBzaGlmdCk7XHJcbiAgICAgICAgc2hpZnQueiA9IDA7XHJcbiAgICAgICAgbWF0NC5hcHBseSh0aGlzLl9jYW1lcmEuZ2V0Vmlld1Byb2pNYXRyaXgoKSwgc2hpZnQsIHNoaWZ0KTtcclxuICAgICAgICAvLyBOREMgKC0xIDogMSkgYXJlIDIgdGltZXMgbGFyZ2VyIHRoYW4gdGV4dHVyZSBjb29yZGluYXRlcyAoMCA6IDEpXHJcbiAgICAgICAgc2hpZnQueCAlPSA0ICogdGhpcy5fZ3JpZEhhbGZQeFNpemVVbmlmb3JtLng7XHJcbiAgICAgICAgc2hpZnQueSAlPSA0ICogdGhpcy5fZ3JpZEhhbGZQeFNpemVVbmlmb3JtLnk7XHJcbiAgICAgICAgY29uc3QgcHJldlRleHR1cmUgPSB0aGlzLl9wcmV2VmlzaWJpbGl0eVRleHR1cmU7XHJcbiAgICAgICAgY29uc3QgcHJldkZyYW1lYnVmZmVyID0gdGhpcy5fcHJldlZpc2liaWxpdHlCdWZmZXI7XHJcbiAgICAgICAgY29uc3QgY3VycmVudFRleHR1cmUgPSB0aGlzLl9jdXJyZW50VmlzaWJpbGl0eVRleHR1cmU7XHJcbiAgICAgICAgY29uc3QgY3VycmVudEZyYW1lYnVmZmVyID0gdGhpcy5fY3VycmVudFZpc2liaWxpdHlCdWZmZXI7XHJcbiAgICAgICAgdGhpcy5fY2xlYXJWaXNpYmlsaXR5KHByZXZGcmFtZWJ1ZmZlcik7XHJcbiAgICAgICAgLy8gb24gdGhpcyBzdGVwXHJcbiAgICAgICAgdGhpcy5fc3RlcDFSZXNldFJlbW92ZWQucmVuZGVyKHByZXZGcmFtZWJ1ZmZlciwgdGhpcy5fcmVzZXRSZW1vdmVkUmVuZGVyZXJzLCBjdXJyZW50VGV4dHVyZSwgdGhpcy5faWRIYWxmUHhTaXplVW5pZm9ybSk7XHJcbiAgICAgICAgLy8gcGFzcyB6b29tIGFzIGEgdmFsdWUgYmV0d2VlbiAwLjAgYW5kIDEuMCwgYXMgYWJzb2x1dGUgdmFsdWUgaXMgbm90IGltcG9ydGFudFxyXG4gICAgICAgIGNvbnN0IHpvb20gPSB0aGlzLl9jYW1lcmEuem9vbSAvIHRoaXMuX2NhbWVyYS5vcHRpb25zLm1heFpvb207XHJcbiAgICAgICAgY29uc3Qgdmlld1Byb2pNYXRyaXggPSB0aGlzLl9jYW1lcmEuZ2V0Vmlld1Byb2pNYXRyaXgoKTtcclxuICAgICAgICBjb25zdCBjYW1lcmFQb3NpdGlvbnMgPSBjYWxjdWxhdGVDYW1lcmFQb3NpdGlvbnModGhpcy5fY2FtZXJhKTtcclxuICAgICAgICBjb25zdCBkaXJlY3RQcmlvcml0eUdyaWQgPSB0aGlzLl9kaXJlY3RQcmlvcml0eUdyaWRSZW5kZXJlci51cGRhdGVHcmlkKHZpZXdQcm9qTWF0cml4LCBjYW1lcmFQb3NpdGlvbnMsIHRoaXMuX2NvbG9ySWRSZW5kZXJlcnMsIHNoaWZ0LCBwcmV2VGV4dHVyZSwgem9vbSk7XHJcbiAgICAgICAgY29uc3QgcmV2ZXJzZVByaW9yaXR5R3JpZCA9IHRoaXMuX3JldmVyc2VQcmlvcml0eUdyaWRSZW5kZXJlci51cGRhdGVHcmlkKHZpZXdQcm9qTWF0cml4LCBjYW1lcmFQb3NpdGlvbnMsIHRoaXMuX2NvbG9ySWRSZW5kZXJlcnMsIHNoaWZ0LCBwcmV2VGV4dHVyZSwgem9vbSk7XHJcbiAgICAgICAgY29uc3Qgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAgICAgY29uc3QgbGFzdFJlbmRlcmluZyA9IHRoaXMuX2xhc3RSZW5kZXJUaW1lSW5Mb29wO1xyXG4gICAgICAgIGNvbnN0IGlzQW5pbWF0aW9uRmluaXNoZWQgPSAobm93IC0gdGhpcy5fbGFzdFNjZW5lVXBkYXRlVGltZSkgPiB0aGlzLmZhZGVFZmZlY3REdXJhdGlvbjtcclxuICAgICAgICBjb25zdCB3YXNBbmltYXRpb25BY3RpdmUgPSBsYXN0UmVuZGVyaW5nICE9PSBGQURJTkdfU1RPUFBFRDtcclxuICAgICAgICBjb25zdCBmYWRlRWZmZWN0ID0gaXNBbmltYXRpb25GaW5pc2hlZCA/XHJcbiAgICAgICAgICAgIDEuMCA6IHdhc0FuaW1hdGlvbkFjdGl2ZSA/IChub3cgLSBsYXN0UmVuZGVyaW5nKSAvIHRoaXMuZmFkZUVmZmVjdER1cmF0aW9uIDogMDtcclxuICAgICAgICBjb25zdCBpZEhhbGZQeCA9IHRoaXMuX2lkSGFsZlB4U2l6ZVVuaWZvcm07XHJcbiAgICAgICAgY29uc3Qgc2FtcGxlclZhbyA9IHRoaXMuX2dyaWRTYW1wbGVyVmFvO1xyXG4gICAgICAgIGNvbnN0IG51bWJlck9mU2FtcGxlcnMgPSB0aGlzLl9udW1iZXJPZkdyaWRTYW1wbGVycztcclxuICAgICAgICB0aGlzLl9jbGVhclZpc2liaWxpdHkoY3VycmVudEZyYW1lYnVmZmVyKTtcclxuICAgICAgICB0aGlzLl9zdGVwMkZhZGVvdXRBbGwucmVuZGVyKGN1cnJlbnRGcmFtZWJ1ZmZlciwgcHJldlRleHR1cmUsIGZhZGVFZmZlY3QpO1xyXG4gICAgICAgIHRoaXMuX3N0ZXAzRmFkZWluVmlzaWJsZS5yZW5kZXIoY3VycmVudEZyYW1lYnVmZmVyLCBzYW1wbGVyVmFvLCBudW1iZXJPZlNhbXBsZXJzLCBkaXJlY3RQcmlvcml0eUdyaWQsIHByZXZUZXh0dXJlLCBpZEhhbGZQeCwgZmFkZUVmZmVjdCk7XHJcbiAgICAgICAgdGhpcy5fc3RlcDRGYWRlb3V0T3ZlcmxhcHBlZC5yZW5kZXIoY3VycmVudEZyYW1lYnVmZmVyLCBzYW1wbGVyVmFvLCBudW1iZXJPZlNhbXBsZXJzLCBkaXJlY3RQcmlvcml0eUdyaWQsIHJldmVyc2VQcmlvcml0eUdyaWQsIHByZXZUZXh0dXJlLCBpZEhhbGZQeCwgZmFkZUVmZmVjdCwgem9vbSk7XHJcbiAgICAgICAgLy8gY2hlY2sgaWYgd2UgbmVlZCBvbmUgbW9yZSByZW5kZXJpbmcgdG8gZmluaXNoIGFuaW1hdGlvblxyXG4gICAgICAgIGlmIChpc0FuaW1hdGlvbkZpbmlzaGVkKSB7XHJcbiAgICAgICAgICAgIC8vIG5vIG1vcmUgcmVuZGVyaW5ncyBuZWVkZWQgZm9yIGZhZGUgZWZmZWN0LCBpdHMgdGltZXN0YW1wIGlzIG1hcmtlZCB3aXRoIHNwZWNpYWwgdmFsdWVcclxuICAgICAgICAgICAgLy8gdG8gdGFrZSBpdCBpbnRvIGFjY291bnQgZHVyaW5nIG5leHQgZmFkZSBlZmZlY3QgYW1vdW50IGNhbGN1bGF0aW9uXHJcbiAgICAgICAgICAgIHRoaXMuX2xhc3RSZW5kZXJUaW1lSW5Mb29wID0gRkFESU5HX1NUT1BQRUQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJMb29wLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9sYXN0UmVuZGVyVGltZUluTG9vcCA9IG5vdztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZWdpc3RlckNvbGxpZGluZ1ByaW1pdGl2ZXMocHJpbWl0aXZlUHJvdmlkZXIsIGNvbG9ySWRSZW5kZXJlciwgcmVzZXRSZW1vdmVSZW5kZXJlcikge1xyXG4gICAgICAgIHRoaXMuX3ByaW1pdGl2ZVByb3ZpZGVycy5wdXNoKHByaW1pdGl2ZVByb3ZpZGVyKTtcclxuICAgICAgICB0aGlzLl9jb2xvcklkUmVuZGVyZXJzLnB1c2goY29sb3JJZFJlbmRlcmVyKTtcclxuICAgICAgICB0aGlzLl9yZXNldFJlbW92ZWRSZW5kZXJlcnMucHVzaChyZXNldFJlbW92ZVJlbmRlcmVyKTtcclxuICAgICAgICBwcmltaXRpdmVQcm92aWRlci5vblVwZGF0ZS5hZGRMaXN0ZW5lcih0aGlzLl9zY2VuZVVwZGF0ZUxpc3RlbmVyKTtcclxuICAgIH1cclxuICAgIGRlcmVnaXN0ZXJDb2xsaWRpbmdQcmltaXRpdmVzKHByaW1pdGl2ZVByb3ZpZGVyLCBjb2xvcklkUmVuZGVyZXIsIHJlc2V0UmVtb3ZlUmVuZGVyZXIpIHtcclxuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLl9wcmltaXRpdmVQcm92aWRlcnMuaW5kZXhPZihwcmltaXRpdmVQcm92aWRlcik7XHJcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcclxuICAgICAgICAgICAgdGhpcy5fcHJpbWl0aXZlUHJvdmlkZXJzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluZGV4ID0gdGhpcy5fY29sb3JJZFJlbmRlcmVycy5pbmRleE9mKGNvbG9ySWRSZW5kZXJlcik7XHJcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcclxuICAgICAgICAgICAgdGhpcy5fY29sb3JJZFJlbmRlcmVycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbmRleCA9IHRoaXMuX3Jlc2V0UmVtb3ZlZFJlbmRlcmVycy5pbmRleE9mKHJlc2V0UmVtb3ZlUmVuZGVyZXIpO1xyXG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0UmVtb3ZlZFJlbmRlcmVycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwcmltaXRpdmVQcm92aWRlci5vblVwZGF0ZS5yZW1vdmVMaXN0ZW5lcih0aGlzLl9zY2VuZVVwZGF0ZUxpc3RlbmVyKTtcclxuICAgIH1cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5fZGVzdHJveUdyaWRSZXNvdXJjZXMoKTtcclxuICAgICAgICB0aGlzLl9kaXJlY3RQcmlvcml0eUdyaWRSZW5kZXJlci5kZXN0cm95KCk7XHJcbiAgICAgICAgdGhpcy5fcmV2ZXJzZVByaW9yaXR5R3JpZFJlbmRlcmVyLmRlc3Ryb3koKTtcclxuICAgICAgICB0aGlzLl9jYW1lcmEub25VcGRhdGUucmVtb3ZlTGlzdGVuZXIodGhpcy5fc2NlbmVVcGRhdGVMaXN0ZW5lcik7XHJcbiAgICAgICAgZm9yIChjb25zdCBwcmltaXRpdmVQcm92aWRlciBvZiB0aGlzLl9wcmltaXRpdmVQcm92aWRlcnMpIHtcclxuICAgICAgICAgICAgcHJpbWl0aXZlUHJvdmlkZXIub25VcGRhdGUucmVtb3ZlTGlzdGVuZXIodGhpcy5fc2NlbmVVcGRhdGVMaXN0ZW5lcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX29uU2NlbmVVcGRhdGUoKSB7XHJcbiAgICAgICAgdGhpcy5fbGFzdFNjZW5lVXBkYXRlVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgICAgIHRoaXMuX3JlbmRlckxvb3AudXBkYXRlKCk7XHJcbiAgICB9XHJcbiAgICBfb25CZWZvcmVSZW5kZXIoKSB7XHJcbiAgICAgICAgdGhpcy5faXNEaXJ0eSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0cyB2aXNpYmlsaXR5IHRleHR1cmUgdG8gaXRzIGluaXRpYWwgc3RhdGUuXHJcbiAgICAgKi9cclxuICAgIF9jbGVhclZpc2liaWxpdHkodGFyZ2V0KSB7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kUmVuZGVyU3RhdGUoVklTSUJJTElUWV9JTklUX1NUQVRFKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRSZW5kZXJUYXJnZXQodGFyZ2V0KTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmNsZWFyQ3VycmVudFRhcmdldCgxNjM4NCAvKiBDT0xPUl9CVUZGRVJfQklUICovKTtcclxuICAgIH1cclxuICAgIF9kZXN0cm95R3JpZFJlc291cmNlcygpIHtcclxuICAgICAgICB0aGlzLl9ncmlkU2FtcGxlclZlcnRleEJ1ZmZlci5kZXN0cm95KCk7XHJcbiAgICAgICAgdGhpcy5fZ3JpZFNhbXBsZXJWYW8uZGVzdHJveSgpO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3Zpc2liaWxpdHkvdmlzaWJpbGl0eV9tYW5hZ2VyLnRzXG4vLyBtb2R1bGUgaWQgPSAxNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgQXR0cmlidXRlTWFwcGluZyB9IGZyb20gJy4uL3JlbmRlci9hdHRyaWJfbWFwcGluZyc7XHJcbmltcG9ydCBCdWZmZXJXcml0ZXIgZnJvbSAnLi4vdXRpbC9idWZmZXJfd3JpdGVyJztcclxuaW1wb3J0IHsgZmxvYXRUb1VpbnQxNiB9IGZyb20gJy4uL3V0aWwvZ3B1dHlwZXMnO1xyXG5leHBvcnQgY29uc3QgQVRUUklCVVRFX01BUFBJTkcgPSBuZXcgQXR0cmlidXRlTWFwcGluZyhbXHJcbiAgICBbXHJcbiAgICAgICAgMCAvKiBQT1NJVElPTiAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDIsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjMgLyogVU5TSUdORURfU0hPUlQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcclxuICAgICAgICB9XHJcbiAgICBdXHJcbl0pO1xyXG4vKipcclxuICogV3JpdGVzIHNhbXBsZXIgcG9zaXRpb25zIGludG8gdmVydGV4IGJ1ZmZlciBhcyBhIHJlZ3VsYXIgZ3JpZCB3aXRoIHRoZSBzdGVwIGVxdWFsIHRvIHRoZSBzaXplIG9mIGEgZ3JpZCBjZWxsLlxyXG4gKiBUaGUgbnVtYmVyIG9mIHZlcnRpY2VzIChzYW1wbGVycykgaXMgZXF1YWwgdG8gXCJ3aWR0aCB4IGhlaWdodFwiLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR3JpZFNhbXBsZXJCdWZmZXJXcml0ZXIgZXh0ZW5kcyBCdWZmZXJXcml0ZXIge1xyXG4gICAgY29uc3RydWN0b3Iod2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIGNvbnN0IG51bWJlck9mU2FtcGxlcnMgPSB3aWR0aCAqIGhlaWdodDtcclxuICAgICAgICBzdXBlcihBVFRSSUJVVEVfTUFQUElORy52ZXJ0ZXhCeXRlU2l6ZSwgbnVtYmVyT2ZTYW1wbGVycywgdW5kZWZpbmVkLCAwKTtcclxuICAgICAgICBjb25zdCBjb2xTdGVwID0gZmxvYXRUb1VpbnQxNigxLjAgLyB3aWR0aCk7XHJcbiAgICAgICAgY29uc3Qgcm93U3RlcCA9IGZsb2F0VG9VaW50MTYoMS4wIC8gaGVpZ2h0KTtcclxuICAgICAgICBjb25zdCBjb2xIYWxmU3RlcCA9IGNvbFN0ZXAgLyAyO1xyXG4gICAgICAgIGNvbnN0IHJvd0hhbGZTdGVwID0gcm93U3RlcCAvIDI7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGNvbCA9IGNvbEhhbGZTdGVwOyBpIDwgd2lkdGg7IGkrKywgY29sICs9IGNvbFN0ZXApIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDAsIHJvdyA9IHJvd0hhbGZTdGVwOyBqIDwgaGVpZ2h0OyBqKyssIHJvdyArPSByb3dTdGVwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl93cml0ZUhhbGZXb3Jkcyhjb2wsIHJvdyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5kYXRhID0gdGhpcy5nZXRCdWZmZXJzKClbMF0udmVydGV4QnVmZmVyO1xyXG4gICAgICAgIHRoaXMubnVtYmVyT2ZTYW1wbGVycyA9IG51bWJlck9mU2FtcGxlcnM7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdmlzaWJpbGl0eS9ncmlkX3NhbXBsZXJfYnVmZmVyX3dyaXRlci50c1xuLy8gbW9kdWxlIGlkID0gMTU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IEdsUmVuZGVyZXIgfSBmcm9tICcuLi9yZW5kZXIvZ2xfcmVuZGVyZXInO1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHcmlkUmVuZGVyZXIgZXh0ZW5kcyBHbFJlbmRlcmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIHJlbmRlclN0YXRlKSB7XHJcbiAgICAgICAgc3VwZXIoY29udGV4dCwgcmVuZGVyU3RhdGUpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlR3JpZCguLi5hcmdzKSB7XHJcbiAgICAgICAgdGhpcy5yZW5kZXIodGhpcy5fdGFyZ2V0LCAuLi5hcmdzKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdGV4dHVyZTtcclxuICAgIH1cclxuICAgIF9yZW5kZXIodmlld1Byb2pNYXRyaXgsIGNhbWVyYVBvc2l0aW9ucywgcmVuZGVyZXJzLCBzdGFiaWxpdHlTaGlmdCwgcHJldlZpc2liaWxpdHksIGN1cnJlbnRab29tKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCByZW5kZXJlciBvZiByZW5kZXJlcnMpIHtcclxuICAgICAgICAgICAgcmVuZGVyZXIucmVuZGVyKHRoaXMuX3RhcmdldCwgdmlld1Byb2pNYXRyaXgsIGNhbWVyYVBvc2l0aW9ucywgdGhpcy5fcmVuZGVyU3RhdGUsIHN0YWJpbGl0eVNoaWZ0LCBwcmV2VmlzaWJpbGl0eSwgY3VycmVudFpvb20pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyByZXNvbHV0aW9uIG9mIHRoZSBncmlkLlxyXG4gICAgICovXHJcbiAgICBzZXRSZXNvbHV0aW9uKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICB0aGlzLl9kZXN0cm95UmVzb3VyY2VzKCk7XHJcbiAgICAgICAgdGhpcy5fZGVwdGhCdWZmZXIgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZVJlbmRlcmJ1ZmZlcih3aWR0aCwgaGVpZ2h0LCAzNDA0MSAvKiBERVBUSF9TVEVOQ0lMICovKTtcclxuICAgICAgICB0aGlzLl90ZXh0dXJlID0gdGhpcy5fY29udGV4dC5jcmVhdGVFbXB0eTJEVGV4dHVyZSh3aWR0aCwgaGVpZ2h0LCA2NDA4IC8qIFJHQkEgKi8sIDUxMjEgLyogVU5TSUdORURfQllURSAqLyk7XHJcbiAgICAgICAgdGhpcy5fdGFyZ2V0ID0gdGhpcy5fY29udGV4dC5jcmVhdGVGcmFtZWJ1ZmZlcih7IGNvbG9yOiB0aGlzLl90ZXh0dXJlLCBkZXB0aFN0ZW5jaWw6IHRoaXMuX2RlcHRoQnVmZmVyIH0pO1xyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLl9kZXN0cm95UmVzb3VyY2VzKCk7XHJcbiAgICB9XHJcbiAgICBfcHJlcGFyZVJlbmRlclRhcmdldCh0YXJnZXQsIC4uLmFyZ3MpIHtcclxuICAgICAgICBzdXBlci5fcHJlcGFyZVJlbmRlclRhcmdldCh0YXJnZXQsIC4uLmFyZ3MpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuY2xlYXJDdXJyZW50VGFyZ2V0KDE2Mzg0IC8qIENPTE9SX0JVRkZFUl9CSVQgKi8gfCAyNTYgLyogREVQVEhfQlVGRkVSX0JJVCAqLyk7XHJcbiAgICB9XHJcbiAgICBfZGVzdHJveVJlc291cmNlcygpIHtcclxuICAgICAgICBpZiAodGhpcy5fdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldC5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3RleHR1cmUuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9kZXB0aEJ1ZmZlci5kZXN0cm95KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3Zpc2liaWxpdHkvZ3JpZF9yZW5kZXJlci50c1xuLy8gbW9kdWxlIGlkID0gMTU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiBPbmUgb2YgdGhlIHN0ZXBzIG9mIHByaW1pdGl2ZXMgdmlzaWJpbGl0eSByZXNvbHV0aW9uIHByb2Nlc3MuIEJhc2ljYWxseSBpdCBkb2VzIG5vdGhpbmcsIGp1c3QgY2FsbCBhcHByb3ByaWF0ZVxyXG4gKiBtZXRob2RzIG9mIENvbGxpZGluZ1ByaW1pdGl2ZVJlbmRlcmVyJ3MsIGJ1dCBpdCBleHBlY3RzIHRoYXQgdGhlc2UgcmVuZGVyZXJzIHdpbGwgY29weSB2aXNpYmlsaXR5IHZhbHVlIG9mIGFjdHVhbFxyXG4gKiBwcmltaXRpdmVzIG9ubHksIHRodXMgcmVtb3ZlZCBwcmltaXRpdmUncyB2YWx1ZXMgd2lsbCBiZSByZXNldCAob3ZlcmxhcCB6b29tIGNsZWFyZWQgYW5kIGFsbCB0aGF0KS4gSXQgaXMgaW1wb3J0YW50XHJcbiAqIGZvciByZXVzaW5nIHRoZXNlIGlkcyBmb3IgZnV0dXJlIHByaW1pdGl2ZXMuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZXNldFJlbW92ZWRQcmltaXRpdmVzIHtcclxuICAgIHJlbmRlcih0YXJnZXQsIHJlbmRlcmVycywgcHJldlZpc2liaWxpdHksIGlkSGFsZlB4U2l6ZVVuaWZvcm0pIHtcclxuICAgICAgICBmb3IgKGNvbnN0IHJlbmRlcmVyIG9mIHJlbmRlcmVycykge1xyXG4gICAgICAgICAgICByZW5kZXJlci5yZW5kZXIodGFyZ2V0LCBwcmV2VmlzaWJpbGl0eSwgaWRIYWxmUHhTaXplVW5pZm9ybSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3Zpc2liaWxpdHkvdmlzaWJpbGl0eV9yZXNvbHV0aW9uX3N0ZXBzL3Jlc2V0X3JlbW92ZWRfcHJpbWl0aXZlcy50c1xuLy8gbW9kdWxlIGlkID0gMTYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBmYWRlb3V0QWxsVmVydGV4U2hhZGVyIGZyb20gJy4vc2hhZGVycy9mYWRlb3V0X2FsbC52ZXJ0JztcclxuaW1wb3J0IGZhZGVvdXRBbGxGcmFnbWVudFNoYWRlciBmcm9tICcuL3NoYWRlcnMvZmFkZW91dF9hbGwuZnJhZyc7XHJcbmltcG9ydCB7IEdsUmVuZGVyZXIgfSBmcm9tICcuLi8uLi9yZW5kZXIvZ2xfcmVuZGVyZXInO1xyXG5pbXBvcnQgUmVuZGVyU3RhdGUgZnJvbSAnLi4vLi4vcmVuZGVyL3N0YXRlJztcclxuaW1wb3J0IElkU2FtcGxlckJ1ZmZlcldyaXRlciwgeyBBVFRSSUJVVEVfTUFQUElORyB9IGZyb20gJy4uL2lkX3NhbXBsZXJfYnVmZmVyX3dyaXRlcic7XHJcbmNvbnN0IFNUQVRFID0gbmV3IFJlbmRlclN0YXRlKHtcclxuICAgIGRpdGhlcjogZmFsc2VcclxufSk7XHJcbi8qKlxyXG4gKiBPbmUgb2YgdGhlIHN0ZXBzIG9mIHByaW1pdGl2ZXMgdmlzaWJpbGl0eSByZXNvbHV0aW9uIHByb2Nlc3MuIEl0IHNhbXBsZXMgYWxsIHZpc2liaWxpdHkgdmFsdWVzIGFuZCBzdWJ0cmFjdFxyXG4gKiBkZWx0YSAoZmFkZW91dEFtb3VudCkgZnJvbSB0aGVtLCB0aGVzZSBuZXcgdmFsdWVzIGFyZSBzdG9yZWQgaW50byBjdXJyZW50IHZpc2liaWxpdHkgdGV4dHVyZS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZhZGVvdXRBbGwgZXh0ZW5kcyBHbFJlbmRlcmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcclxuICAgICAgICBjb25zdCBwcm9ncmFtID0gY29udGV4dC5jcmVhdGVQcm9ncmFtKGZhZGVvdXRBbGxWZXJ0ZXhTaGFkZXIsIGZhZGVvdXRBbGxGcmFnbWVudFNoYWRlciwge1xyXG4gICAgICAgICAgICBhdHRyaWJNYXA6IHtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAwIC8qIFBPU0lUSU9OICovXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBzdXBlcihjb250ZXh0LCBTVEFURSwgcHJvZ3JhbSk7XHJcbiAgICAgICAgY29uc3QgaWRTYW1wbGVyQnVmZmVyV3JpdGVyID0gbmV3IElkU2FtcGxlckJ1ZmZlcldyaXRlcigpO1xyXG4gICAgICAgIHRoaXMuX2lkU2FtcGxlclZlcnRleEJ1ZmZlciA9IHRoaXMuX2NvbnRleHQuY3JlYXRlVmVydGV4QnVmZmVyKGlkU2FtcGxlckJ1ZmZlcldyaXRlci52ZXJ0ZXhEYXRhLmJ5dGVMZW5ndGgpO1xyXG4gICAgICAgIHRoaXMuX2lkU2FtcGxlckluZGV4QnVmZmVyID0gdGhpcy5fY29udGV4dC5jcmVhdGVJbmRleEJ1ZmZlcihpZFNhbXBsZXJCdWZmZXJXcml0ZXIuaW5kZXhEYXRhLmJ5dGVMZW5ndGgpO1xyXG4gICAgICAgIHRoaXMuX2lkU2FtcGxlclZhbyA9IHRoaXMuX2NvbnRleHQuY3JlYXRlVmFvKEFUVFJJQlVURV9NQVBQSU5HLCB0aGlzLl9pZFNhbXBsZXJWZXJ0ZXhCdWZmZXIsIHRoaXMuX2lkU2FtcGxlckluZGV4QnVmZmVyKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LnVwbG9hZERhdGFUb0J1ZmZlcih0aGlzLl9pZFNhbXBsZXJWZXJ0ZXhCdWZmZXIsIGlkU2FtcGxlckJ1ZmZlcldyaXRlci52ZXJ0ZXhEYXRhKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LnVwbG9hZERhdGFUb0J1ZmZlcih0aGlzLl9pZFNhbXBsZXJJbmRleEJ1ZmZlciwgaWRTYW1wbGVyQnVmZmVyV3JpdGVyLmluZGV4RGF0YSk7XHJcbiAgICAgICAgY29udGV4dC5iaW5kUHJvZ3JhbShwcm9ncmFtKTtcclxuICAgICAgICBwcm9ncmFtLnNldEludFNjYWxhclVuaWZvcm0oJ3ByZXZWaXNpYmlsaXR5JywgMCk7XHJcbiAgICB9XHJcbiAgICBfcHJlcGFyZVByb2dyYW0ocHJvZ3JhbSwgcHJldlZpc2liaWxpdHksIGZhZGVvdXRBbW91bnQpIHtcclxuICAgICAgICBzdXBlci5fcHJlcGFyZVByb2dyYW0ocHJvZ3JhbSwgcHJldlZpc2liaWxpdHksIGZhZGVvdXRBbW91bnQpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFRleHR1cmVVbml0KDApO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFRleHR1cmUocHJldlZpc2liaWxpdHkpO1xyXG4gICAgICAgIHByb2dyYW0uc2V0U2NhbGFyVW5pZm9ybSgnZmFkZW91dEFtb3VudCcsIGZhZGVvdXRBbW91bnQpO1xyXG4gICAgfVxyXG4gICAgX3JlbmRlcigpIHtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRWYW8odGhpcy5faWRTYW1wbGVyVmFvKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmRyYXdJbmRleGVkTWVzaCgwLCA2LCA0IC8qIFRSSUFOR0xFUyAqLyk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdmlzaWJpbGl0eS92aXNpYmlsaXR5X3Jlc29sdXRpb25fc3RlcHMvZmFkZW91dF9hbGwudHNcbi8vIG1vZHVsZSBpZCA9IDE2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwiI3ZlcnNpb24gMTAwXFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG5hdHRyaWJ1dGUgdmVjNCBwb3NpdGlvbjtcXG5cXG52YXJ5aW5nIHZlYzIgaWRUZXhDb29yZGluYXRlcztcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIGdsX1Bvc2l0aW9uID0gdmVjNChwb3NpdGlvbi54eSwgMCwgMSk7XFxuICAgIGlkVGV4Q29vcmRpbmF0ZXMgPSBwb3NpdGlvbi56dztcXG59XFxuXCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS92aXNpYmlsaXR5L3Zpc2liaWxpdHlfcmVzb2x1dGlvbl9zdGVwcy9zaGFkZXJzL2ZhZGVvdXRfYWxsLnZlcnRcbi8vIG1vZHVsZSBpZCA9IDE2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwiI3ZlcnNpb24gMTAwXFxuXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCBwcmV2VmlzaWJpbGl0eTtcXG51bmlmb3JtIGZsb2F0IGZhZGVvdXRBbW91bnQ7XFxuXFxudmFyeWluZyB2ZWMyIGlkVGV4Q29vcmRpbmF0ZXM7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICB2ZWM0IHZpc2liaWxpdHlWYWx1ZSA9IHRleHR1cmUyRChwcmV2VmlzaWJpbGl0eSwgaWRUZXhDb29yZGluYXRlcyk7XFxuICAgIHZpc2liaWxpdHlWYWx1ZS5hID0gY2xhbXAodmlzaWJpbGl0eVZhbHVlLmEgLSBmYWRlb3V0QW1vdW50LCAwLjAsIDEuMCk7XFxuXFxuICAgIGdsX0ZyYWdDb2xvciA9IHZpc2liaWxpdHlWYWx1ZTtcXG59XFxuXCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS92aXNpYmlsaXR5L3Zpc2liaWxpdHlfcmVzb2x1dGlvbl9zdGVwcy9zaGFkZXJzL2ZhZGVvdXRfYWxsLmZyYWdcbi8vIG1vZHVsZSBpZCA9IDE2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBBdHRyaWJ1dGVNYXBwaW5nIH0gZnJvbSAnLi4vcmVuZGVyL2F0dHJpYl9tYXBwaW5nJztcclxuaW1wb3J0IEJ1ZmZlcldyaXRlciBmcm9tICcuLi91dGlsL2J1ZmZlcl93cml0ZXInO1xyXG5leHBvcnQgY29uc3QgQVRUUklCVVRFX01BUFBJTkcgPSBuZXcgQXR0cmlidXRlTWFwcGluZyhbXHJcbiAgICBbXHJcbiAgICAgICAgMCAvKiBQT1NJVElPTiAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDQsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjAgLyogQllURSAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICBdXHJcbl0pO1xyXG4vKipcclxuICogV3JpdGUgdmVydGljZXMgb2YgdHdvIHRyaWFuZ2xlcyB0aGF0IGZ1bGx5IGNvdmVyIHZpc2liaWxpdHkgdGV4dHVyZSwgaXRzIHZhbHVlcyBjYW4gYmUgc2FtcGxlZCBpbiBmcmFnbWVudCBzaGFkZXJzLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSWRTYW1wbGVyQnVmZmVyV3JpdGVyIGV4dGVuZHMgQnVmZmVyV3JpdGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKEFUVFJJQlVURV9NQVBQSU5HLnZlcnRleEJ5dGVTaXplLCA0LCA0LCA2KTtcclxuICAgICAgICAvLyB3aW5kb3cgeCwgd2luZG93IHksIHRleHR1cmUgeCwgdGV4dHVyZSB5XHJcbiAgICAgICAgdGhpcy5fd3JpdGVCeXRlcygtMSwgLTEsIDAsIDApO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlQnl0ZXMoLTEsIDEsIDAsIDEpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlQnl0ZXMoMSwgMSwgMSwgMSk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVCeXRlcygxLCAtMSwgMSwgMCk7XHJcbiAgICAgICAgdGhpcy53cml0ZUluZGljZXNGb3JGYW4oWzAsIDEsIDIsIDNdKTtcclxuICAgICAgICB0aGlzLnZlcnRleERhdGEgPSB0aGlzLmdldEJ1ZmZlcnMoKVswXS52ZXJ0ZXhCdWZmZXI7XHJcbiAgICAgICAgdGhpcy5pbmRleERhdGEgPSB0aGlzLmdldEJ1ZmZlcnMoKVswXS5pbmRleEJ1ZmZlcjtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS92aXNpYmlsaXR5L2lkX3NhbXBsZXJfYnVmZmVyX3dyaXRlci50c1xuLy8gbW9kdWxlIGlkID0gMTY0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IEdsUmVuZGVyZXIgfSBmcm9tICcuLi8uLi9yZW5kZXIvZ2xfcmVuZGVyZXInO1xyXG5pbXBvcnQgZmFkZWluVmlzaWJsZVZlcnRleFNoYWRlciBmcm9tICcuL3NoYWRlcnMvZmFkZWluX3Zpc2libGUudmVydCc7XHJcbmltcG9ydCBmYWRlaW5WaXNpYmxlRnJhZ21lbnRTaGFkZXIgZnJvbSAnLi9zaGFkZXJzL2ZhZGVpbl92aXNpYmxlLmZyYWcnO1xyXG5pbXBvcnQgUmVuZGVyU3RhdGUgZnJvbSAnLi4vLi4vcmVuZGVyL3N0YXRlJztcclxuY29uc3QgU1RBVEUgPSBuZXcgUmVuZGVyU3RhdGUoe1xyXG4gICAgZGl0aGVyOiBmYWxzZVxyXG59KTtcclxuLyoqXHJcbiAqIE9uZSBvZiB0aGUgc3RlcHMgb2YgcHJpbWl0aXZlcyB2aXNpYmlsaXR5IHJlc29sdXRpb24gcHJvY2Vzcy4gSXQgc2FtcGxlcyBhbGwgcGl4ZWxzIG9mIHRoZSBzY2VuZSAocmVuZGVyZWQgaW4gZGlyZWN0XHJcbiAqIHByaW9yaXR5IG9yZGVyIGludG8gc2ltcGxpZmllZCBncmlkKSBhbmQgYWRkcyBkZWx0YSAoZmFkZWluQW1vdW50KSB0byBhbHBoYSB2aXNpYmlsaXR5IG9mIHByaW1pdGl2ZSB3aXRoXHJcbiAqIGlkIGluIHRoaXMgcGl4ZWwuIFRob3NlIHByaW1pdGl2ZXMgYXJlIGNvbnNpZGVyZWQgdmlzaWJsZS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZhZGVpblZpc2libGUgZXh0ZW5kcyBHbFJlbmRlcmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcclxuICAgICAgICBjb25zdCBwcm9ncmFtID0gY29udGV4dC5jcmVhdGVQcm9ncmFtKGZhZGVpblZpc2libGVWZXJ0ZXhTaGFkZXIsIGZhZGVpblZpc2libGVGcmFnbWVudFNoYWRlciwge1xyXG4gICAgICAgICAgICBhdHRyaWJNYXA6IHtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAwIC8qIFBPU0lUSU9OICovXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBzdXBlcihjb250ZXh0LCBTVEFURSwgcHJvZ3JhbSk7XHJcbiAgICAgICAgY29udGV4dC5iaW5kUHJvZ3JhbShwcm9ncmFtKTtcclxuICAgICAgICBwcm9ncmFtLnNldEludFNjYWxhclVuaWZvcm0oJ2RpcmVjdFByaW9yaXR5R3JpZCcsIDApO1xyXG4gICAgICAgIHByb2dyYW0uc2V0SW50U2NhbGFyVW5pZm9ybSgncHJldlZpc2liaWxpdHknLCAxKTtcclxuICAgIH1cclxuICAgIF9wcmVwYXJlUHJvZ3JhbShwcm9ncmFtLCBkYXRhLCBzYW1wbGVycywgZGlyZWN0UHJpb3JpdHlHcmlkLCBwcmV2VmlzaWJpbGl0eSwgaWRIYWxmUHhTaXplLCBmYWRlaW5BbW91bnQpIHtcclxuICAgICAgICBzdXBlci5fcHJlcGFyZVByb2dyYW0ocHJvZ3JhbSwgZGF0YSwgc2FtcGxlcnMsIGRpcmVjdFByaW9yaXR5R3JpZCwgcHJldlZpc2liaWxpdHksIGlkSGFsZlB4U2l6ZSwgZmFkZWluQW1vdW50KTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRUZXh0dXJlVW5pdCgwKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRUZXh0dXJlKGRpcmVjdFByaW9yaXR5R3JpZCk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kVGV4dHVyZVVuaXQoMSk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kVGV4dHVyZShwcmV2VmlzaWJpbGl0eSk7XHJcbiAgICAgICAgcHJvZ3JhbS5zZXRWZWN0b3IyVW5pZm9ybSgnaWRIYWxmUHhTaXplJywgaWRIYWxmUHhTaXplKTtcclxuICAgICAgICBwcm9ncmFtLnNldFNjYWxhclVuaWZvcm0oJ2ZhZGVpbkFtb3VudCcsIGZhZGVpbkFtb3VudCk7XHJcbiAgICB9XHJcbiAgICBfcmVuZGVyKGRhdGEsIG51bWJlck9mU2FtcGxlcnMpIHtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRWYW8oZGF0YSk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5kcmF3TWVzaCgwLCBudW1iZXJPZlNhbXBsZXJzLCAwIC8qIFBPSU5UUyAqLyk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdmlzaWJpbGl0eS92aXNpYmlsaXR5X3Jlc29sdXRpb25fc3RlcHMvZmFkZWluX3Zpc2libGUudHNcbi8vIG1vZHVsZSBpZCA9IDE2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwiI3ZlcnNpb24gMTAwXFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG5hdHRyaWJ1dGUgdmVjMiBwb3NpdGlvbjtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCBkaXJlY3RQcmlvcml0eUdyaWQ7XFxudW5pZm9ybSBzYW1wbGVyMkQgcHJldlZpc2liaWxpdHk7XFxudW5pZm9ybSB2ZWMyIGlkSGFsZlB4U2l6ZTtcXG51bmlmb3JtIGZsb2F0IGZhZGVpbkFtb3VudDtcXG5cXG52YXJ5aW5nIGxvd3AgdmVjNCB2aXNpYmlsaXR5VmFsdWU7XFxuXFxuY29uc3QgdmVjMiBOT19JRCA9IHZlYzIoMCwgMCk7XFxuY29uc3QgdmVjNCBESVNDQVJEX1BPU0lUSU9OID0gdmVjNCgyLCAyLCAyLCAxKTtcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIHZlYzIgcHJpbWl0aXZlSWQgPSB0ZXh0dXJlMkQoZGlyZWN0UHJpb3JpdHlHcmlkLCBwb3NpdGlvbikucmc7XFxuXFxuICAgIGlmIChwcmltaXRpdmVJZCAhPSBOT19JRCkge1xcbiAgICAgICAgdmVjMiBpZFRleENvb3JkaW5hdGVzID0gcHJpbWl0aXZlSWQgKyBpZEhhbGZQeFNpemU7XFxuICAgICAgICB2ZWM0IGlkV2luZG93Q29vcmRpbmF0ZXMgPSB2ZWM0KGlkVGV4Q29vcmRpbmF0ZXMgKiAyLjAgLSAxLjAsIDAsIDEpO1xcbiAgICAgICAgZ2xfUG9zaXRpb24gPSBpZFdpbmRvd0Nvb3JkaW5hdGVzO1xcbiAgICAgICAgZ2xfUG9pbnRTaXplID0gMS4wO1xcblxcbiAgICAgICAgdmlzaWJpbGl0eVZhbHVlID0gdGV4dHVyZTJEKHByZXZWaXNpYmlsaXR5LCBpZFRleENvb3JkaW5hdGVzKTtcXG4gICAgICAgIHZpc2liaWxpdHlWYWx1ZS5hID0gY2xhbXAodmlzaWJpbGl0eVZhbHVlLmEgKyBmYWRlaW5BbW91bnQsIDAuMCwgMS4wKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIGdsX1Bvc2l0aW9uID0gRElTQ0FSRF9QT1NJVElPTjtcXG4gICAgfVxcbn1cXG5cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3Zpc2liaWxpdHkvdmlzaWJpbGl0eV9yZXNvbHV0aW9uX3N0ZXBzL3NoYWRlcnMvZmFkZWluX3Zpc2libGUudmVydFxuLy8gbW9kdWxlIGlkID0gMTY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbnZhcnlpbmcgbG93cCB2ZWM0IHZpc2liaWxpdHlWYWx1ZTtcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIGdsX0ZyYWdDb2xvciA9IHZpc2liaWxpdHlWYWx1ZTtcXG59XFxuXCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS92aXNpYmlsaXR5L3Zpc2liaWxpdHlfcmVzb2x1dGlvbl9zdGVwcy9zaGFkZXJzL2ZhZGVpbl92aXNpYmxlLmZyYWdcbi8vIG1vZHVsZSBpZCA9IDE2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBHbFJlbmRlcmVyIH0gZnJvbSAnLi4vLi4vcmVuZGVyL2dsX3JlbmRlcmVyJztcclxuaW1wb3J0IGZhZGVvdXRPdmVybGFwcGVkVmVydGV4U2hhZGVyIGZyb20gJy4vc2hhZGVycy9mYWRlb3V0X292ZXJsYXBwZWQudmVydCc7XHJcbmltcG9ydCBmYWRlb3V0T3ZlcmxhcHBlZEZyYWdtZW50U2hhZGVyIGZyb20gJy4vc2hhZGVycy9mYWRlb3V0X292ZXJsYXBwZWQuZnJhZyc7XHJcbmltcG9ydCBSZW5kZXJTdGF0ZSBmcm9tICcuLi8uLi9yZW5kZXIvc3RhdGUnO1xyXG5jb25zdCBTVEFURSA9IG5ldyBSZW5kZXJTdGF0ZSh7IGRpdGhlcjogZmFsc2UgfSk7XHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZhZGVvdXRPdmVybGFwcGVkIGV4dGVuZHMgR2xSZW5kZXJlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XHJcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IGNvbnRleHQuY3JlYXRlUHJvZ3JhbShmYWRlb3V0T3ZlcmxhcHBlZFZlcnRleFNoYWRlciwgZmFkZW91dE92ZXJsYXBwZWRGcmFnbWVudFNoYWRlciwge1xyXG4gICAgICAgICAgICBhdHRyaWJNYXA6IHtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAwIC8qIFBPU0lUSU9OICovXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBzdXBlcihjb250ZXh0LCBTVEFURSwgcHJvZ3JhbSk7XHJcbiAgICAgICAgY29udGV4dC5iaW5kUHJvZ3JhbShwcm9ncmFtKTtcclxuICAgICAgICBwcm9ncmFtLnNldEludFNjYWxhclVuaWZvcm0oJ2RpcmVjdFByaW9yaXR5R3JpZCcsIDApO1xyXG4gICAgICAgIHByb2dyYW0uc2V0SW50U2NhbGFyVW5pZm9ybSgncmV2ZXJzZVByaW9yaXR5R3JpZCcsIDEpO1xyXG4gICAgICAgIHByb2dyYW0uc2V0SW50U2NhbGFyVW5pZm9ybSgncHJldlZpc2liaWxpdHknLCAyKTtcclxuICAgIH1cclxuICAgIF9wcmVwYXJlUHJvZ3JhbShwcm9ncmFtLCBkYXRhLCBzYW1wbGVycywgZGlyZWN0UHJpb3JpdHksIHJldmVyc2VQcmlvcml0eSwgcHJldlZpc2liaWxpdHksIGlkSGFsZlB4U2l6ZSwgZmFkZW91dEFtb3VudCwgY3VycmVudFpvb20pIHtcclxuICAgICAgICBzdXBlci5fcHJlcGFyZVByb2dyYW0ocHJvZ3JhbSwgZGF0YSwgc2FtcGxlcnMsIGRpcmVjdFByaW9yaXR5LCByZXZlcnNlUHJpb3JpdHksIHByZXZWaXNpYmlsaXR5LCBpZEhhbGZQeFNpemUsIGZhZGVvdXRBbW91bnQsIGN1cnJlbnRab29tKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRUZXh0dXJlVW5pdCgwKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRUZXh0dXJlKGRpcmVjdFByaW9yaXR5KTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRUZXh0dXJlVW5pdCgxKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRUZXh0dXJlKHJldmVyc2VQcmlvcml0eSk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kVGV4dHVyZVVuaXQoMik7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kVGV4dHVyZShwcmV2VmlzaWJpbGl0eSk7XHJcbiAgICAgICAgcHJvZ3JhbS5zZXRWZWN0b3IyVW5pZm9ybSgnaWRIYWxmUHhTaXplJywgaWRIYWxmUHhTaXplKTtcclxuICAgICAgICBwcm9ncmFtLnNldFNjYWxhclVuaWZvcm0oJ2ZhZGVvdXRBbW91bnQnLCBmYWRlb3V0QW1vdW50KTtcclxuICAgICAgICBwcm9ncmFtLnNldFNjYWxhclVuaWZvcm0oJ2N1cnJlbnRab29tJywgY3VycmVudFpvb20pO1xyXG4gICAgfVxyXG4gICAgX3JlbmRlcihkYXRhLCBudW1iZXJPZlNhbXBsZXJzKSB7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kVmFvKGRhdGEpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuZHJhd01lc2goMCwgbnVtYmVyT2ZTYW1wbGVycywgMCAvKiBQT0lOVFMgKi8pO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3Zpc2liaWxpdHkvdmlzaWJpbGl0eV9yZXNvbHV0aW9uX3N0ZXBzL2ZhZGVvdXRfb3ZlcmxhcHBlZC50c1xuLy8gbW9kdWxlIGlkID0gMTY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbmF0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uO1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIGRpcmVjdFByaW9yaXR5R3JpZDtcXG51bmlmb3JtIHNhbXBsZXIyRCByZXZlcnNlUHJpb3JpdHlHcmlkO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHByZXZWaXNpYmlsaXR5O1xcbnVuaWZvcm0gdmVjMiBpZEhhbGZQeFNpemU7XFxudW5pZm9ybSBmbG9hdCBmYWRlb3V0QW1vdW50O1xcbnVuaWZvcm0gZmxvYXQgY3VycmVudFpvb207XFxuXFxudmFyeWluZyB2ZWM0IHZpc2liaWxpdHlWYWx1ZTtcXG5cXG5jb25zdCB2ZWMyIE5PX0lEID0gdmVjMigwLCAwKTtcXG5jb25zdCB2ZWM0IERJU0NBUkRfUE9TSVRJT04gPSB2ZWM0KDIsIDIsIDIsIDEpO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgdmVjMiBwcmltaXRpdmVJZFJldmVyc2VQcmlvcml0eSA9IHRleHR1cmUyRChyZXZlcnNlUHJpb3JpdHlHcmlkLCBwb3NpdGlvbikucmc7XFxuXFxuICAgIGlmIChcXG4gICAgICAgIHByaW1pdGl2ZUlkUmV2ZXJzZVByaW9yaXR5ICE9IE5PX0lEICYmXFxuICAgICAgICBwcmltaXRpdmVJZFJldmVyc2VQcmlvcml0eSAhPSB0ZXh0dXJlMkQoZGlyZWN0UHJpb3JpdHlHcmlkLCBwb3NpdGlvbikucmdcXG4gICAgKSB7XFxuICAgICAgICB2ZWMyIGlkVGV4Q29vcmRpbmF0ZXMgPSBwcmltaXRpdmVJZFJldmVyc2VQcmlvcml0eSArIGlkSGFsZlB4U2l6ZTtcXG4gICAgICAgIHZlYzQgaWRXaW5kb3dDb29yZGluYXRlcyA9IHZlYzQoaWRUZXhDb29yZGluYXRlcyAqIDIuMCAtIDEuMCwgMCwgMSk7XFxuXFxuICAgICAgICBnbF9Qb3NpdGlvbiA9IGlkV2luZG93Q29vcmRpbmF0ZXM7XFxuICAgICAgICBnbF9Qb2ludFNpemUgPSAxLjA7XFxuXFxuICAgICAgICB2aXNpYmlsaXR5VmFsdWUgPSB0ZXh0dXJlMkQocHJldlZpc2liaWxpdHksIGlkVGV4Q29vcmRpbmF0ZXMpO1xcbiAgICAgICAgdmlzaWJpbGl0eVZhbHVlLmIgPSBjdXJyZW50Wm9vbTtcXG4gICAgICAgIHZpc2liaWxpdHlWYWx1ZS5hID0gY2xhbXAodmlzaWJpbGl0eVZhbHVlLmEgLSBmYWRlb3V0QW1vdW50LCAwLjAsIDEuMCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICBnbF9Qb3NpdGlvbiA9IERJU0NBUkRfUE9TSVRJT047XFxuICAgIH1cXG59XFxuXCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS92aXNpYmlsaXR5L3Zpc2liaWxpdHlfcmVzb2x1dGlvbl9zdGVwcy9zaGFkZXJzL2ZhZGVvdXRfb3ZlcmxhcHBlZC52ZXJ0XG4vLyBtb2R1bGUgaWQgPSAxNjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcIiN2ZXJzaW9uIDEwMFxcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxudmFyeWluZyBsb3dwIHZlYzQgdmlzaWJpbGl0eVZhbHVlO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmlzaWJpbGl0eVZhbHVlO1xcbn1cXG5cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3Zpc2liaWxpdHkvdmlzaWJpbGl0eV9yZXNvbHV0aW9uX3N0ZXBzL3NoYWRlcnMvZmFkZW91dF9vdmVybGFwcGVkLmZyYWdcbi8vIG1vZHVsZSBpZCA9IDE3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgKiBhcyB2ZWMyIGZyb20gJy4uL21hdGgvdmVjdG9yMic7XHJcbmltcG9ydCB7IGNvbXB1dGVCQm94Rm9yUG9pbnRzIH0gZnJvbSAnLi4vbWF0aC92ZWN0b3IyJztcclxuLyoqXHJcbiAqIENvbnRhaW5lciBvZiBpbmRleGVkIG1pbi9tYXggdmFsdWVzIHdpdGggYSBzaW5nbGUgdXBkYXRlIG1ldGhvZC5cclxuICovXHJcbmNsYXNzIEV4dHJlbXVtU3RvcmFnZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgpIHtcclxuICAgICAgICB0aGlzLl9taW5zID0gbmV3IEFycmF5KGxlbmd0aCk7XHJcbiAgICAgICAgdGhpcy5fbWF4cyA9IG5ldyBBcnJheShsZW5ndGgpO1xyXG4gICAgICAgIHRoaXMuX21pbnMuZmlsbChOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xyXG4gICAgICAgIHRoaXMuX21heHMuZmlsbChOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlVmFsdWUoaW5kZXgsIHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fbWluc1tpbmRleF0gPSBNYXRoLm1pbih0aGlzLl9taW5zW2luZGV4XSwgdmFsdWUpO1xyXG4gICAgICAgIHRoaXMuX21heHNbaW5kZXhdID0gTWF0aC5tYXgodGhpcy5fbWF4c1tpbmRleF0sIHZhbHVlKTtcclxuICAgIH1cclxuICAgICp2YWx1ZXMoKSB7XHJcbiAgICAgICAgY29uc3QgaXRlbSA9IHsgbWluOiAwLCBtYXg6IDAsIGluZGV4OiAtMSB9O1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbWlucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpdGVtLm1pbiA9IHRoaXMuX21pbnNbaV07XHJcbiAgICAgICAgICAgIGl0ZW0ubWF4ID0gdGhpcy5fbWF4c1tpXTtcclxuICAgICAgICAgICAgaXRlbS5pbmRleCA9IGk7XHJcbiAgICAgICAgICAgIHlpZWxkIGl0ZW07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBTcXVhcmVzIHRoYXQgYXJlIG9ueSB0b3VjaGVkIGJ5IGEgbGluZSAod2l0aCBubyBzaWduaWZpY2FudCBjcm9zc2luZyBhbiBlZGdlKSBzaG91bGQgbm90IGJlIGNvbnNpZGVyZWQgXCJjb3ZlcmVkXCIuXHJcbiAqIEl0IGhhcHBlbnMgd2hlbiBhIHBvaW50IG1hdGNoZXMgdGhlIG1heCBjb29yZGluYXRlIChpbnRlZ2VyKSBhbmQgdGhpcyBjYXNlIGlzIGhhbmRsZWQgaGVyZS5cclxuICovXHJcbmZ1bmN0aW9uIGZsb29yVG9DZWxsQ29vcmRpbmF0ZSh2YWx1ZSwgbWF4VmFsdWUpIHtcclxuICAgIHJldHVybiBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSAmJiBtYXhWYWx1ZSA9PT0gdmFsdWUgPyB2YWx1ZSAtIDEgOiBNYXRoLmZsb29yKHZhbHVlKTtcclxufVxyXG4vKipcclxuICogQ2FsY3VsYXRlcyBzcXVhcmVzIGNvdmVyZWQgKGF0IGxlYXN0IHBhcnRpYWxseSkgYnkgYSBjb252ZXggcG9seWdvbi5cclxuICpcclxuICogQHBhcmFtIHBvaW50cyBDb252ZXggcG9seWdvbiBwb2ludCBjb29yZGluYXRlcyAob24gdGhlIGdyaWQpLlxyXG4gKiBAcmV0dXJucyBMaXN0IG9mIHVuaXQgc3F1YXJlIGNvb3JkaW5hdGVzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVTcXVhcmVzQ292ZXJlZEJ5Q29udmV4UG9seWdvbihwb2ludHMpIHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgY29uc3QgYmJveCA9IGNvbXB1dGVCQm94Rm9yUG9pbnRzKHBvaW50cyk7XHJcbiAgICBjb25zdCBtaW5YID0gTWF0aC5mbG9vcihiYm94Lm1pblgpO1xyXG4gICAgY29uc3QgeExlbmd0aCA9IE1hdGguY2VpbChiYm94Lm1heFgpIC0gbWluWDtcclxuICAgIGNvbnN0IGV4dHJlbXVtcyA9IG5ldyBFeHRyZW11bVN0b3JhZ2UoeExlbmd0aCk7XHJcbiAgICBmb3IgKGxldCBpID0gcG9pbnRzLmxlbmd0aCAtIDEsIGogPSAwOyBqIDwgcG9pbnRzLmxlbmd0aDsgaSA9IGorKykge1xyXG4gICAgICAgIGxldCBwMSA9IHBvaW50c1tpXTtcclxuICAgICAgICBsZXQgcDIgPSBwb2ludHNbal07XHJcbiAgICAgICAgLy8gZ28gZnJvbSBsZWZ0IHRvIHJpZ2h0IGFsd2F5cyB0byBub3QgaGFuZGxlIHRoZSBvcHBvc2l0ZSBjYXNlXHJcbiAgICAgICAgaWYgKHAxLnggPiBwMi54KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRtcCA9IHAxO1xyXG4gICAgICAgICAgICBwMSA9IHAyO1xyXG4gICAgICAgICAgICBwMiA9IHRtcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY2FsY3VsYXRlIGZyb20vdG8gaW50ZXJ2YWwgc28gdGhhdCBvbmx5IFwiaW50ZXJuYWxcIiBpbnRlZ2VyIHgtZXMgYXJlIGNhcHR1cmVkXHJcbiAgICAgICAgY29uc3QgZnJvbVggPSBNYXRoLmZsb29yKHAxLnggKyAxKTtcclxuICAgICAgICBjb25zdCB0b1ggPSBNYXRoLmNlaWwocDIueCAtIDEpO1xyXG4gICAgICAgIGNvbnN0IHNsb3BlID0gKHAxLnkgLSBwMi55KSAvIChwMS54IC0gcDIueCk7XHJcbiAgICAgICAgLy8gaGFuZGxlIHRlcm1pbmFsIHBvaW50cyBzZXBhcmF0ZWx5IGZyb20gdGhlIFwiaW50ZXJuYWxcIiBvbmVzXHJcbiAgICAgICAgZXh0cmVtdW1zLnVwZGF0ZVZhbHVlKGZsb29yVG9DZWxsQ29vcmRpbmF0ZShwMS54LCBiYm94Lm1heFgpIC0gbWluWCwgZmxvb3JUb0NlbGxDb29yZGluYXRlKHAxLnksIGJib3gubWF4WSkpO1xyXG4gICAgICAgIGV4dHJlbXVtcy51cGRhdGVWYWx1ZShmbG9vclRvQ2VsbENvb3JkaW5hdGUocDIueCwgYmJveC5tYXhYKSAtIG1pblgsIGZsb29yVG9DZWxsQ29vcmRpbmF0ZShwMi55LCBiYm94Lm1heFkpKTtcclxuICAgICAgICBmb3IgKGxldCB4ID0gZnJvbVg7IHggPD0gdG9YOyB4KyspIHtcclxuICAgICAgICAgICAgY29uc3QgeUludGVyY2VwdCA9IChpc0Zpbml0ZShzbG9wZSkgPyBzbG9wZSAqICh4IC0gcDEueCkgOiAwKSArIHAxLnk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5leHRYID0geCAtIG1pblg7XHJcbiAgICAgICAgICAgIGNvbnN0IHByZXZYID0gbmV4dFggLSAxO1xyXG4gICAgICAgICAgICBjb25zdCB5ID0gTWF0aC5mbG9vcih5SW50ZXJjZXB0KTtcclxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgd2UgaGl0IGV4YWN0bHkgdGhlIGludGVyc2VjdGlvbiBvZiB0d28gaW50ZWdlciBjb29yZGluYXRlc1xyXG4gICAgICAgICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcih5SW50ZXJjZXB0KSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHlJbnRlcmNlcHQgPT09IGJib3gubWF4WSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4dHJlbXVtcy51cGRhdGVWYWx1ZShwcmV2WCwgeSAtIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGV4dHJlbXVtcy51cGRhdGVWYWx1ZShuZXh0WCwgeSAtIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2xvcGUgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdHdvIGRpYWdvbmFsIHNxdWFyZXMgaW50ZXJzZWN0ZWQgYnkgYSBsaW5lIHdpdGggcG9zaXRpdmUgc2xvcGVcclxuICAgICAgICAgICAgICAgICAgICBleHRyZW11bXMudXBkYXRlVmFsdWUocHJldlgsIHkgLSAxKTtcclxuICAgICAgICAgICAgICAgICAgICBleHRyZW11bXMudXBkYXRlVmFsdWUobmV4dFgsIHkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2xvcGUgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdHdvIGRpYWdvbmFsIHNxdWFyZXMgaW50ZXJzZWN0ZWQgYnkgYSBsaW5lIHdpdGggbmVnYXRpdmUgc2xvcGVcclxuICAgICAgICAgICAgICAgICAgICBleHRyZW11bXMudXBkYXRlVmFsdWUocHJldlgsIHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGV4dHJlbXVtcy51cGRhdGVWYWx1ZShuZXh0WCwgeSAtIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZXh0cmVtdW1zLnVwZGF0ZVZhbHVlKHByZXZYLCB5KTtcclxuICAgICAgICAgICAgICAgIGV4dHJlbXVtcy51cGRhdGVWYWx1ZShuZXh0WCwgeSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IHsgbWluLCBtYXgsIGluZGV4IH0gb2YgZXh0cmVtdW1zLnZhbHVlcygpKSB7XHJcbiAgICAgICAgY29uc3QgeCA9IG1pblggKyBpbmRleDtcclxuICAgICAgICBmb3IgKGxldCB5ID0gbWluOyB5IDw9IG1heDsgeSsrKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZlYzIuY3JlYXRlKHgsIHkpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvY2FydGVzaWFuX2dyaWQudHNcbi8vIG1vZHVsZSBpZCA9IDE3MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBjb3B5IH0gZnJvbSAnLi9hcnJheSc7XHJcbmltcG9ydCB7IE5VTUVSSUNBTF9DT01QQVJBVE9SIH0gZnJvbSAnLi9jb21wYXJhdG9yJztcclxuLyoqXHJcbiAqIEZpbHRlcnMgYW4gYXJyYXkgb2YgdmFsdWVzIHdpdGggbWVkaWFuIGZpbHRlci5cclxuICpcclxuICogQHBhcmFtIHZhbHVlcyBWYWx1ZXMgdG8gYmUgZmlsdGVyZWQuXHJcbiAqIEBwYXJhbSB3aW5kb3dSYWRpdXMgSG93IG1hbnkgdmFsdWVzIGFyb3VuZCBhIHNhbXBsZSBnZXQgaW50byBmaWx0ZXIgd2luZG93LlxyXG4gKiBAcmV0dXJucyBBcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbWVkaWFuRmlsdGVyKHZhbHVlcywgd2luZG93UmFkaXVzID0gMykge1xyXG4gICAgY29uc3Qgd2luZG93ID0gbmV3IEFycmF5KDIgKiB3aW5kb3dSYWRpdXMgKyAxKTtcclxuICAgIHdpbmRvdy5maWxsKHZhbHVlc1swXSk7XHJcbiAgICBjb25zdCBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoO1xyXG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5KGxlbmd0aCk7XHJcbiAgICBjb25zdCBmaXJzdCA9IHZhbHVlc1swXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2luZG93UmFkaXVzOyArK2kpIHtcclxuICAgICAgICB3aW5kb3cuZmlsbChmaXJzdCwgMCwgd2luZG93UmFkaXVzIC0gaSArIDEpO1xyXG4gICAgICAgIGNvcHkodmFsdWVzLCB3aW5kb3csIDAsIGkgKyB3aW5kb3dSYWRpdXMgKyAxLCB3aW5kb3dSYWRpdXMgLSBpICsgMSk7XHJcbiAgICAgICAgd2luZG93LnNvcnQoTlVNRVJJQ0FMX0NPTVBBUkFUT1IpO1xyXG4gICAgICAgIHJlc3VsdFtpXSA9IHdpbmRvd1t3aW5kb3dSYWRpdXNdO1xyXG4gICAgfVxyXG4gICAgZm9yIChsZXQgaSA9IHdpbmRvd1JhZGl1czsgaSA8IGxlbmd0aCAtIHdpbmRvd1JhZGl1czsgKytpKSB7XHJcbiAgICAgICAgY29weSh2YWx1ZXMsIHdpbmRvdywgaSAtIHdpbmRvd1JhZGl1cywgaSArIHdpbmRvd1JhZGl1cyArIDEpO1xyXG4gICAgICAgIHdpbmRvdy5zb3J0KE5VTUVSSUNBTF9DT01QQVJBVE9SKTtcclxuICAgICAgICByZXN1bHRbaV0gPSB3aW5kb3dbd2luZG93UmFkaXVzXTtcclxuICAgIH1cclxuICAgIGNvbnN0IGxhc3QgPSB2YWx1ZXNbdmFsdWVzLmxlbmd0aCAtIDFdO1xyXG4gICAgZm9yIChsZXQgaSA9IGxlbmd0aCAtIHdpbmRvd1JhZGl1czsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgY29weSh2YWx1ZXMsIHdpbmRvdywgaSAtIHdpbmRvd1JhZGl1cywgbGVuZ3RoKTtcclxuICAgICAgICB3aW5kb3cuZmlsbChsYXN0LCB2YWx1ZXMubGVuZ3RoIC0gaSArIHdpbmRvd1JhZGl1cyk7XHJcbiAgICAgICAgd2luZG93LnNvcnQoTlVNRVJJQ0FMX0NPTVBBUkFUT1IpO1xyXG4gICAgICAgIHJlc3VsdFtpXSA9IHdpbmRvd1t3aW5kb3dSYWRpdXNdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL21lZGlhbl9maWx0ZXIudHNcbi8vIG1vZHVsZSBpZCA9IDE3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgTGlzdFJlbmRlclVuaXQgZnJvbSAnLi9saXN0X3JlbmRlcl91bml0JztcclxuaW1wb3J0IHsgVm9pZEV2ZW50RW1pdHRlciB9IGZyb20gJy4uL3V0aWwvZXZlbnRfZW1pdHRlcic7XHJcbmltcG9ydCBSZW5kZXJTdGF0ZSBmcm9tICcuL3N0YXRlJztcclxuaW1wb3J0IHsgY2FsY3VsYXRlQ2FtZXJhUG9zaXRpb25zIH0gZnJvbSAnLi91dGlsL2NhbWVyYV9wb3NpdGlvbic7XHJcbmNvbnN0IEZJTkFMX1JFTkRFUl9TVEFURSA9IG5ldyBSZW5kZXJTdGF0ZSh7XHJcbiAgICBjbGVhckRlcHRoOiAwLFxyXG4gICAgZGVwdGhUZXN0OiB0cnVlLFxyXG4gICAgZGVwdGhGdW5jOiA1MTggLyogR1JFQVRFUl9PUl9FUVVBTCAqL1xyXG59KTtcclxuLyoqXHJcbiAqIFJvb3Qgc2NlbmUgcmVuZGVyZXIuIEl0IGdlbmVyYXRlcyBmaW5hbCBjYW52YXMgaW1hZ2UgY29tcG9zaW5nIGl0IGZyb20gaW5kZXBlbmRlbnQgbGF5ZXJzIChMYXllclJlbmRlclVuaXQpLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFpblJlbmRlclVuaXQgZXh0ZW5kcyBMaXN0UmVuZGVyVW5pdCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBjYW1lcmEpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgICAgIHRoaXMuX2NhbWVyYSA9IGNhbWVyYTtcclxuICAgICAgICB0aGlzLm9uUmVuZGVyID0gbmV3IFZvaWRFdmVudEVtaXR0ZXIoKTtcclxuICAgIH1cclxuICAgIHJlbmRlcih0YXJnZXQpIHtcclxuICAgICAgICBjb25zdCB2aWV3UHJvak1hdGl4ID0gdGhpcy5fY2FtZXJhLmdldFZpZXdQcm9qTWF0cml4KCk7XHJcbiAgICAgICAgY29uc3QgY2FtZXJhUG9zaXRpb25zID0gY2FsY3VsYXRlQ2FtZXJhUG9zaXRpb25zKHRoaXMuX2NhbWVyYSk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kUmVuZGVyVGFyZ2V0KHRhcmdldCk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kUmVuZGVyU3RhdGUoRklOQUxfUkVOREVSX1NUQVRFKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmNsZWFyQ3VycmVudFRhcmdldCgxNzY2NCAvKiBBTEwgKi8pO1xyXG4gICAgICAgIGZvciAoY29uc3QgcmVuZGVyZXIgb2YgdGhpcy5fc3ViUmVuZGVyVW5pdHMpIHtcclxuICAgICAgICAgICAgcmVuZGVyZXIucmVuZGVyKHRhcmdldCwgdmlld1Byb2pNYXRpeCwgY2FtZXJhUG9zaXRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5vblJlbmRlci5maXJlKCk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL21haW5fcmVuZGVyX3VuaXQudHNcbi8vIG1vZHVsZSBpZCA9IDE3M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgTWVtb3J5UGFnZSBmcm9tICcuL3BhZ2UnO1xyXG5pbXBvcnQgeyBjb3VudFZlcnRpY2VzIH0gZnJvbSAnLi9jb3VudF92ZXJ0aWNlcyc7XHJcbmltcG9ydCB7IEFyZW5hQWxsb2NhdG9yIH0gZnJvbSAnLi4vLi4vdXRpbC9hbGxvY2F0b3InO1xyXG5jb25zdCBNQVhfVkVSVEVYX0NPVU5UID0gMHgxMDAwMDtcclxuLy8gRklYTUUoZG1pa2lzKSBMZXQncyB1c2Ugb3ZlcnNpemVkIGluZGV4IGJ1ZmZlciB0aWwgd2Ugc29ydCBvdXQgaW5kaWNlcyBhbGxvY2F0aW9uXHJcbi8vIGJvdGggaW4gd3JpdGVycyBhbmQgdGhlIG1hbmFnZXIuXHJcbmNvbnN0IFBBR0VfSU5ERVhfQlVGRkVSX0JZVEVfU0laRSA9IDB4MTAwMDAwO1xyXG4vKipcclxuICogTWVtb3J5IHBhZ2Ugd2l0aCB0aGUgZm9sbG93aW5nIHBlY3VsaWFyaXR5OiBvbmNlIGFsbG9jYXRpb24gaXMgZmFpbGVkIGl0IGdldHMgY2xvc2VkIGZvciBhbnkgc3Vic2VxdWVudFxyXG4gKiBhbGxvY2F0aW9ucy4gSXQgYWxsb3cgdG8ga2VlcCByZWxhdGVkIHByaW1pdGl2ZXMgY2xvc2VyIGluIG1lbW9yeS5cclxuICovXHJcbmNsYXNzIFNpbmdsZVBhc3NNZW1vcnlQYWdlIGV4dGVuZHMgTWVtb3J5UGFnZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih2ZXJ0ZXhCdWZmZXIsIGluZGV4QnVmZmVyLCB2YW8sIGluZGV4VHlwZSkge1xyXG4gICAgICAgIHN1cGVyKHZlcnRleEJ1ZmZlciwgaW5kZXhCdWZmZXIsIHZhbywgaW5kZXhUeXBlLCBuZXcgQXJlbmFBbGxvY2F0b3IodmVydGV4QnVmZmVyLmdldFNpemUoKSksIG5ldyBBcmVuYUFsbG9jYXRvcihpbmRleEJ1ZmZlci5nZXRTaXplKCkpKTtcclxuICAgICAgICB0aGlzLl9mYWlsZWRBbGxvY2F0aW9uID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBhbGxvY2F0ZSh2ZXJ0ZXhCeXRlTGVuZ3RoLCBpbmRleEJ5dGVMZW5ndGgpIHtcclxuICAgICAgICBpZiAodGhpcy5fZmFpbGVkQWxsb2NhdGlvbikge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY2h1bmsgPSBzdXBlci5hbGxvY2F0ZSh2ZXJ0ZXhCeXRlTGVuZ3RoLCBpbmRleEJ5dGVMZW5ndGgpO1xyXG4gICAgICAgIHRoaXMuX2ZhaWxlZEFsbG9jYXRpb24gPSAoY2h1bmsgPT09IG51bGwpO1xyXG4gICAgICAgIHJldHVybiBjaHVuaztcclxuICAgIH1cclxufVxyXG4vKipcclxuICogTWFuYWdlciB0aGF0IGNvbnRyb2xzIEdMIG1lbW9yeSBhbGxvY2F0aW9ucyBhbmQgcGFnaW5hdGlvbi5bXVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWVtb3J5TWFuYWdlciB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgbWVtb3J5IG1hbmFnZXIgdGhhdCB3aWxsIGFsbG9jYXRlIG1lbW9yeSBpbiBhIGdpdmVuIGNvbnRleHQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGNvbnRleHQuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcclxuICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcclxuICAgICAgICB0aGlzLl9wYWdlcyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLl9lbXB0eVBhZ2VzQ2xlYXJUaW1lb3V0ID0gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWxsb2NhdGVzIG1lbW9yeSBmb3IgYSBnaXZlbiBkYXRhIGluIHRoZSBtYW5hZ2VyIGFuZCB1cGxvYWRzIGdpdmVuIGRhdGEuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZlcnRleERhdGEgQnVmZmVyIHdpdGggdmVydGljZXMgdGhhdCBuZWVkcyB0byBiZSBhbGxvY2F0ZWQuXHJcbiAgICAgKiBAcGFyYW0gaW5kZXhEYXRhIEJ1ZmZlciB3aXRoIGluZGljZXMgdGhhdCBuZWVkcyB0byBiZSBhbGxvY2F0ZWQuXHJcbiAgICAgKiBAcGFyYW0gYXR0cmlidXRlTWFwcGluZyBNYXBwaW5nIG9mIHZlcnRleCBhdHRyaWJ1dGVzLlxyXG4gICAgICogQHJldHVybnMgRGVzY3JpcHRvciBvZiB0aGUgYWxsb2NhdGVkIG1lbW9yeSByZWdpb24uXHJcbiAgICAgKi9cclxuICAgIGFsbG9jYXRlKHZlcnRleERhdGEsIGluZGV4RGF0YSwgYXR0cmlidXRlTWFwcGluZykge1xyXG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLl9jb250ZXh0O1xyXG4gICAgICAgIGxldCBwYWdlU2V0ID0gdGhpcy5fcGFnZXMuZ2V0KGF0dHJpYnV0ZU1hcHBpbmcpO1xyXG4gICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gcGFnZXMgZm9yIHRoZSBnaXZlbiBhdHRyaWJ1dGUgbWFwcGluZywgY3JlYXRlIGEgbmV3IHNldC5cclxuICAgICAgICBpZiAoIXBhZ2VTZXQpIHtcclxuICAgICAgICAgICAgcGFnZVNldCA9IG5ldyBTZXQoKTtcclxuICAgICAgICAgICAgdGhpcy5fcGFnZXMuc2V0KGF0dHJpYnV0ZU1hcHBpbmcsIHBhZ2VTZXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUcnkgdG8gYWxsb2NhdGUgZGF0YSBpbiB0aGUgZXhpc3RpbmcgcGFnZXMuXHJcbiAgICAgICAgZm9yIChjb25zdCBwYWdlIG9mIHBhZ2VTZXQpIHtcclxuICAgICAgICAgICAgY29uc3QgbWVtb3J5Q2h1bmsgPSBwYWdlLmFsbG9jYXRlKHZlcnRleERhdGEuYnl0ZUxlbmd0aCwgaW5kZXhEYXRhLmJ5dGVMZW5ndGgpO1xyXG4gICAgICAgICAgICBpZiAobWVtb3J5Q2h1bmspIHtcclxuICAgICAgICAgICAgICAgIC8vIFN1Y2Nlc3MhIE5vdyB3ZSBqdXN0IHVwbG9hZCB0aGUgZGF0YS5cclxuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVBhZ2UocGFnZSwgbWVtb3J5Q2h1bmssIHZlcnRleERhdGEsIGluZGV4RGF0YSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVtb3J5Q2h1bms7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gV2UndmUgZmFpbGVkIHRvIGFsbG9jYXRlIHRoZSBkYXRhIGluIGFueSBvZiBleGlzdGluZyBwYWdlcy4gTm8gd29ycmllc1xyXG4gICAgICAgIC8vIHRob3VnaCwgd2UganVzdCBjcmVhdGUgYSBuZXcgb25lOilcclxuICAgICAgICBjb25zdCB2ZXJ0ZXhCdWZmZXIgPSBjb250ZXh0LmNyZWF0ZVZlcnRleEJ1ZmZlcihcclxuICAgICAgICAvLyBzb21lIGJ1ZmZlciB3cml0ZXJzIGRvbid0IHVzZSBpbmRpY2VzIGFuZCBNQVhfVkVSVEVYX0NPVU5UIHJlc3RyaWN0aW9uIGlzIG5vdCBhcHBsaWVkIGluIHN1Y2ggY2FzZXNcclxuICAgICAgICBNYXRoLm1heChNQVhfVkVSVEVYX0NPVU5UICogYXR0cmlidXRlTWFwcGluZy52ZXJ0ZXhCeXRlU2l6ZSwgdmVydGV4RGF0YS5ieXRlTGVuZ3RoKSk7XHJcbiAgICAgICAgY29uc3QgaW5kZXhCdWZmZXIgPSBjb250ZXh0LmNyZWF0ZUluZGV4QnVmZmVyKFBBR0VfSU5ERVhfQlVGRkVSX0JZVEVfU0laRSk7XHJcbiAgICAgICAgY29uc3QgdmFvID0gY29udGV4dC5jcmVhdGVWYW8oYXR0cmlidXRlTWFwcGluZywgdmVydGV4QnVmZmVyLCBpbmRleEJ1ZmZlcik7XHJcbiAgICAgICAgY29uc3QgcGFnZSA9IG5ldyBTaW5nbGVQYXNzTWVtb3J5UGFnZSh2ZXJ0ZXhCdWZmZXIsIGluZGV4QnVmZmVyLCB2YW8sIDUxMjMgLyogVU5TSUdORURfU0hPUlQgKi8pO1xyXG4gICAgICAgIHBhZ2Uuc2V0RGVsZWdhdGUodGhpcyk7XHJcbiAgICAgICAgcGFnZVNldC5hZGQocGFnZSk7XHJcbiAgICAgICAgLy8gSGVyZSB3ZSBhc3N1bWUgd2UgYWx3YXlzIGNhbiBhbGxvY2F0ZSBkYXRhIGluIGFuIGVtcHR5IHBhZ2UuXHJcbiAgICAgICAgY29uc3QgbWVtb3J5Q2h1bmsgPSBwYWdlLmFsbG9jYXRlKHZlcnRleERhdGEuYnl0ZUxlbmd0aCwgaW5kZXhEYXRhLmJ5dGVMZW5ndGgpO1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZVBhZ2UocGFnZSwgbWVtb3J5Q2h1bmssIHZlcnRleERhdGEsIGluZGV4RGF0YSk7XHJcbiAgICAgICAgcmV0dXJuIG1lbW9yeUNodW5rO1xyXG4gICAgfVxyXG4gICAgb25QYWdlRW1wdHkoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9lbXB0eVBhZ2VzQ2xlYXJUaW1lb3V0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2VtcHR5UGFnZXNDbGVhclRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NsZWFyRW1wdHlQYWdlcygpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZW1wdHlQYWdlc0NsZWFyVGltZW91dCA9IDA7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGVzdHJveXMgdGhlIG1hbmFnZXIgYW5kIGFsbCBpdHMgbWVtb3J5IHBhZ2VzLiBBbGwgbWVtb3J5IGNodW5rcyB0aGF0IHdlcmVcclxuICAgICAqIGFsbG9jYXRlZCBpbiB0aGUgbWFuYWdlciBiZWNvbWUgaW52YWxpZC5cclxuICAgICAqL1xyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICBpZiAodGhpcy5fZW1wdHlQYWdlc0NsZWFyVGltZW91dCkge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fZW1wdHlQYWdlc0NsZWFyVGltZW91dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3QgWywgcGFnZVNldF0gb2YgdGhpcy5fcGFnZXMpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBwYWdlIG9mIHBhZ2VTZXQpIHtcclxuICAgICAgICAgICAgICAgIHBhZ2UuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3VwZGF0ZVBhZ2UocGFnZSwgbWVtb3J5Q2h1bmssIHZlcnRleERhdGEsIGluZGV4RGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLl9jb250ZXh0O1xyXG4gICAgICAgIC8vIExldCdzIGVuc3VyZSB0aGF0IHdlIHdvbid0IGJyZWFrIGFueSBib3VuZCBWQU9zLlxyXG4gICAgICAgIGNvbnRleHQuYmluZFZhbyhudWxsKTtcclxuICAgICAgICBjb250ZXh0LnVwbG9hZERhdGFUb0J1ZmZlcihwYWdlLnZlcnRleEJ1ZmZlciwgdmVydGV4RGF0YSwgbWVtb3J5Q2h1bmsudmVydGV4Qnl0ZU9mZnNldCk7XHJcbiAgICAgICAgLy8gU2hpZnQgaW5kaWNlcy5cclxuICAgICAgICBjb25zdCBiYXNlSW5kZXggPSBjb3VudFZlcnRpY2VzKG1lbW9yeUNodW5rLnZlcnRleEJ5dGVPZmZzZXQsIHBhZ2UudmFvLmF0dHJpYnV0ZU1hcHBpbmcpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kZXhEYXRhLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIGluZGV4RGF0YVtpXSArPSBiYXNlSW5kZXg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnRleHQudXBsb2FkRGF0YVRvQnVmZmVyKHBhZ2UuaW5kZXhCdWZmZXIsIGluZGV4RGF0YSwgbWVtb3J5Q2h1bmsuaW5kZXhCeXRlT2Zmc2V0KTtcclxuICAgIH1cclxuICAgIF9jbGVhckVtcHR5UGFnZXMoKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBwYWdlU2V0IG9mIHRoaXMuX3BhZ2VzLnZhbHVlcygpKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGFnZSBvZiBwYWdlU2V0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFnZS5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYWdlU2V0LmRlbGV0ZShwYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICBwYWdlLnNldERlbGVnYXRlKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhZ2UuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9tZW1vcnkvbWFuYWdlci50c1xuLy8gbW9kdWxlIGlkID0gMTc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBDaHVuayBmcm9tICcuL2NodW5rJztcclxuaW1wb3J0IHsgRGVsZWdhdG9yQmFzZSB9IGZyb20gJy4uLy4uL3V0aWwvZGVsZWdhdG9yJztcclxuLyoqXHJcbiAqIEEgXCJwYWdlXCIgb2YgR1BVIG1lbW9yeS4gQ29tcHJpc2VzIHZlcnRleCBhbmQgaW5kZXggYnVmZmVycyBvZiBhIGZpeGVkIHNpemUuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNZW1vcnlQYWdlIGV4dGVuZHMgRGVsZWdhdG9yQmFzZSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgcGFnZSB0byBtYW5hZ2UgZ2l2ZW4gdmVydGV4IGFuZCBpbmRleCBidWZmZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB2ZXJ0ZXhCdWZmZXIgVGhlIHZlcnRleCBidWZmZXIgdGhlIHBhZ2Ugd2lsbCBtYW5hZ2UuXHJcbiAgICAgKiBAcGFyYW0gaW5kZXhCdWZmZXIgVGhlIGluZGV4IGJ1ZmZlciB0aGUgcGFnZSB3aWxsIG1hbmFnZXIuXHJcbiAgICAgKiBAcGFyYW0gdmFvIFRoZSBWQU8gb2YgdGhlIHBhZ2UuXHJcbiAgICAgKiBAcGFyYW0gaW5kZXhUeXBlIFR5cGUgb2YgZWxlbWVudHMgb2YgaW5kZXhCdWZmZXIuXHJcbiAgICAgKiBAcGFyYW0gdmVydGV4QWxsb2NhdG9yIEFsbG9jYXRvciBvZiB2ZXJ0ZXggZGF0YSwgbG9naWMgb2YgYWxsb2NhdGlvbiBkaXJlY3RseSBpbXBhY3RzIHRoZSBsaWZlY3ljbGUgb2YgdGhlIHBhZ2UuXHJcbiAgICAgKiBAcGFyYW0gaW5kZXhBbGxvY2F0b3IgQWxsb2NhdG9yIG9mIGluZGV4IGRhdGEsIGxvZ2ljIG9mIGFsbG9jYXRpb24gZGlyZWN0bHkgaW1wYWN0cyB0aGUgbGlmZWN5Y2xlIG9mIHRoZSBwYWdlLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcih2ZXJ0ZXhCdWZmZXIsIGluZGV4QnVmZmVyLCB2YW8sIGluZGV4VHlwZSwgdmVydGV4QWxsb2NhdG9yLCBpbmRleEFsbG9jYXRvcikge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhCdWZmZXIgPSB2ZXJ0ZXhCdWZmZXI7XHJcbiAgICAgICAgdGhpcy5pbmRleEJ1ZmZlciA9IGluZGV4QnVmZmVyO1xyXG4gICAgICAgIHRoaXMudmFvID0gdmFvO1xyXG4gICAgICAgIHRoaXMuaW5kZXhUeXBlID0gaW5kZXhUeXBlO1xyXG4gICAgICAgIHRoaXMuX3ZlcnRleEFsbG9jYXRvciA9IHZlcnRleEFsbG9jYXRvcjtcclxuICAgICAgICB0aGlzLl9pbmRleEFsbG9jYXRvciA9IGluZGV4QWxsb2NhdG9yO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBbGxvY2F0ZXMgYW5kIHdyaXRlcyB2ZXJ0ZXggYW5kIGluZGV4IGRhdGEgdG8gdGhlIHBhZ2UuIE9mZnNldHMgaW5kaWNlc1xyXG4gICAgICogaW4gYW4gaW5kZXggYXJyYXkgdG8gYXBwcm9wcmlhdGVseSB0YWtlIGludG8gYWNjb3VudCBvZmZzZXQgb2YgdGhlIHZlcnRleFxyXG4gICAgICogZGF0YS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmVydGV4Qnl0ZUxlbmd0aCByZXF1aXJlZCBudW1iZXIgb2YgYnl0ZXMgaW4gdmVydGV4IGJ1ZmZlclxyXG4gICAgICogQHBhcmFtIGluZGV4Qnl0ZUxlbmd0aCByZXF1aXJlZCBudW1iZXIgb2YgYnl0ZXMgaW4gaW5kZXggYnVmZmVyXHJcbiAgICAgKiBAcmV0dXJucyBtZW1vcnkgY2h1bmsgYWxsb2NhdGVkIG9yIGBudWxsYCBpZiBhbGxvY2F0aW9uJ3MgZmFpbGVkXHJcbiAgICAgKi9cclxuICAgIGFsbG9jYXRlKHZlcnRleEJ5dGVMZW5ndGgsIGluZGV4Qnl0ZUxlbmd0aCkge1xyXG4gICAgICAgIGlmICh0aGlzLl92ZXJ0ZXhBbGxvY2F0b3IubWF4QWxsb2NhYmxlU2l6ZSA+PSB2ZXJ0ZXhCeXRlTGVuZ3RoICYmXHJcbiAgICAgICAgICAgIHRoaXMuX2luZGV4QWxsb2NhdG9yLm1heEFsbG9jYWJsZVNpemUgPj0gaW5kZXhCeXRlTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2h1bmsodGhpcywge1xyXG4gICAgICAgICAgICAgICAgdmVydGV4Qnl0ZU9mZnNldDogdGhpcy5fdmVydGV4QWxsb2NhdG9yLmFsbG9jYXRlKHZlcnRleEJ5dGVMZW5ndGgpLFxyXG4gICAgICAgICAgICAgICAgdmVydGV4Qnl0ZUxlbmd0aDogdmVydGV4Qnl0ZUxlbmd0aCxcclxuICAgICAgICAgICAgICAgIGluZGV4Qnl0ZU9mZnNldDogdGhpcy5faW5kZXhBbGxvY2F0b3IuYWxsb2NhdGUoaW5kZXhCeXRlTGVuZ3RoKSxcclxuICAgICAgICAgICAgICAgIGluZGV4Qnl0ZUxlbmd0aDogaW5kZXhCeXRlTGVuZ3RoXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGcmVlcyBhIHByZXZpb3VzbHkgYWxsb2NhdGVkIG1lbW9yeSBjaHVuay5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIGNodW5rIHRvIGJlIGZyZWVkLlxyXG4gICAgICovXHJcbiAgICBmcmVlKGNodW5rKSB7XHJcbiAgICAgICAgdGhpcy5fdmVydGV4QWxsb2NhdG9yLmRlYWxsb2NhdGUoY2h1bmsudmVydGV4Qnl0ZU9mZnNldCk7XHJcbiAgICAgICAgdGhpcy5faW5kZXhBbGxvY2F0b3IuZGVhbGxvY2F0ZShjaHVuay5pbmRleEJ5dGVPZmZzZXQpO1xyXG4gICAgICAgIGlmICh0aGlzLmlzRW1wdHkoKSAmJiB0aGlzLl9kZWxlZ2F0ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9kZWxlZ2F0ZS5vblBhZ2VFbXB0eSh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBwYWdlIGRvZXMgbm90IGNvbnRhaW4gYW55IHByZXZpb3VzbHkgYWxsb2NhdGVkIGRhdGFcclxuICAgICAqIGFuZCBgZmFsc2VgIG90aGVyd2lzZS5cclxuICAgICAqL1xyXG4gICAgaXNFbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdmVydGV4QWxsb2NhdG9yLmlzRW1wdHkgJiYgdGhpcy5faW5kZXhBbGxvY2F0b3IuaXNFbXB0eTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGVzdHJveXMgdGhlIHBhZ2UgYW5kIGFsbCBpdHMgcmVzb3VyY2VzLlxyXG4gICAgICovXHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMudmVydGV4QnVmZmVyLmRlc3Ryb3koKTtcclxuICAgICAgICB0aGlzLmluZGV4QnVmZmVyLmRlc3Ryb3koKTtcclxuICAgICAgICB0aGlzLnZhby5kZXN0cm95KCk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL21lbW9yeS9wYWdlLnRzXG4vLyBtb2R1bGUgaWQgPSAxNzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IFJlZkNvdW50ZWQgZnJvbSAnLi4vLi4vdXRpbC9yZWZfY291bnRlZCc7XHJcbi8qKiBIYW5kbGVyIHRvIGEgYWxsb2NhdGVkIG1lbW9yeSBjaHVuay4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWVtb3J5Q2h1bmsgZXh0ZW5kcyBSZWZDb3VudGVkIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBoYW5kbGVyIHRvIGEgbWVtb3J5IGNodW5rIHdpdGggZ2l2ZW4gb2Zmc2V0cyBhbGxvY2F0ZWQgaW5cclxuICAgICAqIGEgZ2l2ZW4gbWVtb3J5IHBhZ2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBhZ2UgVGhlIHBhZ2UgdGhlIGNodW5rIHdhcyBhbGxvY2F0ZWQgaW4uXHJcbiAgICAgKiBAcGFyYW0gdmVydGV4T2Zmc2V0IFRoZSBvZmZzZXQgb2YgY2h1bmsncyB2ZXJ0ZXggZGF0YS5cclxuICAgICAqIEBwYXJhbSBpbmRleE9mZnNldCBUaGUgb2Zmc2V0IG9mIGNodW5rJ3MgaW5kZXggZGF0YS5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocGFnZSwgbG9jYXRpb24pIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMucGFnZSA9IHBhZ2U7XHJcbiAgICAgICAgdGhpcy5fbG9jYXRpb24gPSBsb2NhdGlvbjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBvZmZzZXQgb2YgdmVydGV4IGRhdGEgb2YgdGhlIGNodW5rIGluIGJ5dGVzLlxyXG4gICAgICovXHJcbiAgICBnZXQgdmVydGV4Qnl0ZU9mZnNldCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYXRpb24udmVydGV4Qnl0ZU9mZnNldDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBvZmZzZXQgb2YgaW5kZXggZGF0YSBvZiB0aGUgY2h1bmsgaW4gYnl0ZXMuXHJcbiAgICAgKi9cclxuICAgIGdldCBpbmRleEJ5dGVPZmZzZXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2F0aW9uLmluZGV4Qnl0ZU9mZnNldDtcclxuICAgIH1cclxuICAgIF9kZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMucGFnZS5mcmVlKHRoaXMpO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9tZW1vcnkvY2h1bmsudHNcbi8vIG1vZHVsZSBpZCA9IDE3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgKiBhcyB2ZWN0b3IyIGZyb20gJy4uL21hdGgvdmVjdG9yMic7XHJcbmltcG9ydCBSZW5kZXJTdGF0ZSBmcm9tICcuL3N0YXRlJztcclxuaW1wb3J0IGZ4YWFGcmFnbWVudFNoYWRlciBmcm9tICcuL3NoYWRlcnMvZnhhYS5mcmFnJztcclxuaW1wb3J0IGZ4YWFWZXJ0ZXhTaGFkZXIgZnJvbSAnLi9zaGFkZXJzL3F1YWQudmVydCc7XHJcbmltcG9ydCBnZXREcHIgZnJvbSAnLi4vdXRpbC9oZCc7XHJcbmltcG9ydCB7IEdsUmVuZGVyZXIgfSBmcm9tICcuL2dsX3JlbmRlcmVyJztcclxuaW1wb3J0IExpc3RSZW5kZXJVbml0IGZyb20gJy4vbGlzdF9yZW5kZXJfdW5pdCc7XHJcbmltcG9ydCB7IEJMRU5EX09WRVJfUkVOREVSX1NUQVRFIH0gZnJvbSAnLi9zdGF0ZSc7XHJcbmNvbnN0IFNUQVRFID0gbmV3IFJlbmRlclN0YXRlKEJMRU5EX09WRVJfUkVOREVSX1NUQVRFKTtcclxuLyoqXHJcbiAqIFJlbmRlcmVyIG9mIEZYQUEgcG9zdHByb2Nlc3NpbmcgcGFzcy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZ4YWFSZW5kZXJVbml0IGV4dGVuZHMgR2xSZW5kZXJlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCByZW5kZXJMb29wKSB7XHJcbiAgICAgICAgc3VwZXIoY29udGV4dCwgU1RBVEUsIGNvbnRleHQuY3JlYXRlUHJvZ3JhbShmeGFhVmVydGV4U2hhZGVyLCBmeGFhRnJhZ21lbnRTaGFkZXIsIHtcclxuICAgICAgICAgICAgYXR0cmliTWFwOiB7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhQb3NpdGlvbjogMCAvKiBQT1NJVElPTiAqL1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIHRoaXMuX3JlbmRlcmVycyA9IG5ldyBMaXN0UmVuZGVyVW5pdCgpO1xyXG4gICAgICAgIHRoaXMuX3JlbmRlckxvb3AgPSByZW5kZXJMb29wO1xyXG4gICAgICAgIHRoaXMub25VcGRhdGUgPSB0aGlzLl9yZW5kZXJlcnMub25VcGRhdGU7XHJcbiAgICAgICAgdGhpcy5fcGl4ZWxTaXplID0gdmVjdG9yMi5jcmVhdGUoMCwgMCk7XHJcbiAgICB9XHJcbiAgICBhZGRSZW5kZXJVbml0KHVuaXQpIHtcclxuICAgICAgICB0aGlzLl9yZW5kZXJlcnMuYWRkUmVuZGVyVW5pdCh1bml0KTtcclxuICAgIH1cclxuICAgIHJlbW92ZVJlbmRlclVuaXQodW5pdCkge1xyXG4gICAgICAgIHRoaXMuX3JlbmRlcmVycy5yZW1vdmVSZW5kZXJVbml0KHVuaXQpO1xyXG4gICAgfVxyXG4gICAgcmVuZGVyKHRhcmdldCwgLi4uYXJncykge1xyXG4gICAgICAgIC8vIHNraXAgYW50aWFsaWFzaW5nIGlmIHRoZXNlIGlzIGFjdGlvbiBpbiB0aGUgc2NlbmVcclxuICAgICAgICBpZiAodGhpcy5fcmVuZGVyTG9vcC5pc0FjdGl2ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlcnMucmVuZGVyKHRhcmdldCwgLi4uYXJncyk7XHJcbiAgICAgICAgICAgIC8vIHNjaGVkdWxlIGF0IGxlYXN0IG9uZSBtb3JlIHJlbmRlcmluZyB0byBub3QgbGVhdmUgc3RhdGljIChzdG9wcGVkKSBzY2VuZSBpbiBub24tYW50aWFsaWFzZWQgc3RhdGVcclxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyTG9vcC51cGRhdGUoKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMuX2ludGVybWVkaWF0ZVJlbmRlcmVCdWZmZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5faW5pdEludGVybWVkaWF0ZVJlbmRlclRhcmdldHModGFyZ2V0LmdldFdpZHRoKCksIHRhcmdldC5nZXRIZWlnaHQoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2ludGVybWVkaWF0ZVJlbmRlcmVCdWZmZXIuZ2V0V2lkdGgoKSAhPT0gdGFyZ2V0LmdldFdpZHRoKCkgfHxcclxuICAgICAgICAgICAgdGhpcy5faW50ZXJtZWRpYXRlUmVuZGVyZUJ1ZmZlci5nZXRIZWlnaHQoKSAhPT0gdGFyZ2V0LmdldEhlaWdodCgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3lJbnRlcm5hbFJlbmRlclRhcmdldHMoKTtcclxuICAgICAgICAgICAgdGhpcy5faW5pdEludGVybWVkaWF0ZVJlbmRlclRhcmdldHModGFyZ2V0LmdldFdpZHRoKCksIHRhcmdldC5nZXRIZWlnaHQoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFJlbmRlclRhcmdldCh0aGlzLl9pbnRlcm1lZGlhdGVSZW5kZXJlQnVmZmVyKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmNsZWFyQ3VycmVudFRhcmdldCgxNzY2NCAvKiBBTEwgKi8pO1xyXG4gICAgICAgIHRoaXMuX3JlbmRlcmVycy5yZW5kZXIodGhpcy5faW50ZXJtZWRpYXRlUmVuZGVyZUJ1ZmZlciwgLi4uYXJncyk7XHJcbiAgICAgICAgLy8gZG8gbm90IHJ1biBhbnRpYWxpYXNpbmcgb24gZW1wdHkgdGhpcy5faW50ZXJtZWRpYXRlUmVuZGVyZUJ1ZmZlclxyXG4gICAgICAgIGlmICghdGhpcy5faW50ZXJtZWRpYXRlUmVuZGVyZUJ1ZmZlci5pc0NsZWFyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUZyYW1lVW5pZm9ybVN0YXRlKHRhcmdldCk7XHJcbiAgICAgICAgICAgIHN1cGVyLnJlbmRlcih0YXJnZXQsIC4uLmFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2ludGVybWVkaWF0ZVJlbmRlcmVCdWZmZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5fZGVzdHJveUludGVybmFsUmVuZGVyVGFyZ2V0cygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9yZW5kZXIoKSB7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kUXVhZFZhbygpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuZHJhd1F1YWQoKTtcclxuICAgIH1cclxuICAgIF9wcmVwYXJlUHJvZ3JhbShwcm9ncmFtLCAuLi5hcmdzKSB7XHJcbiAgICAgICAgc3VwZXIuX3ByZXBhcmVQcm9ncmFtKHByb2dyYW0sIC4uLmFyZ3MpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFRleHR1cmVVbml0KDApO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFRleHR1cmUodGhpcy5faW50ZXJtZWRpYXRlQ29sb3JCdWZmZXIpO1xyXG4gICAgICAgIHByb2dyYW0uc2V0SW50U2NhbGFyVW5pZm9ybSgndGV4dHVyZScsIDApO1xyXG4gICAgICAgIHByb2dyYW0uc2V0VmVjdG9yMlVuaWZvcm0oJ3BpeGVsU2l6ZScsIHRoaXMuX3BpeGVsU2l6ZSk7XHJcbiAgICAgICAgcHJvZ3JhbS5zZXRTY2FsYXJVbmlmb3JtKCdkcHInLCBnZXREcHIoKSk7XHJcbiAgICB9XHJcbiAgICBfdXBkYXRlRnJhbWVVbmlmb3JtU3RhdGUodGFyZ2V0KSB7XHJcbiAgICAgICAgdGhpcy5fcGl4ZWxTaXplLnggPSAxIC8gdGFyZ2V0LmdldFdpZHRoKCk7XHJcbiAgICAgICAgdGhpcy5fcGl4ZWxTaXplLnkgPSAxIC8gdGFyZ2V0LmdldEhlaWdodCgpO1xyXG4gICAgfVxyXG4gICAgX2luaXRJbnRlcm1lZGlhdGVSZW5kZXJUYXJnZXRzKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5fY29udGV4dDtcclxuICAgICAgICBjb25zdCBpbnRlcm1lZGlhdGVDb2xvckJ1ZmZlciA9IHRoaXMuX2ludGVybWVkaWF0ZUNvbG9yQnVmZmVyID1cclxuICAgICAgICAgICAgY29udGV4dC5jcmVhdGVFbXB0eTJEVGV4dHVyZSh3aWR0aCwgaGVpZ2h0LCA2NDA4IC8qIFJHQkEgKi8sIDUxMjEgLyogVU5TSUdORURfQllURSAqLyk7XHJcbiAgICAgICAgY29uc3QgaW50ZXJtZWRpYXRlRGVwdGhTdGVuY2lsQnVmZmVyID0gdGhpcy5faW50ZXJtZWRpYXRlRGVwdGhTdGVuY2lsQnVmZmVyID1cclxuICAgICAgICAgICAgY29udGV4dC5jcmVhdGVSZW5kZXJidWZmZXIod2lkdGgsIGhlaWdodCwgMzQwNDEgLyogREVQVEhfU1RFTkNJTCAqLyk7XHJcbiAgICAgICAgdGhpcy5faW50ZXJtZWRpYXRlUmVuZGVyZUJ1ZmZlciA9IGNvbnRleHQuY3JlYXRlRnJhbWVidWZmZXIoe1xyXG4gICAgICAgICAgICBjb2xvcjogaW50ZXJtZWRpYXRlQ29sb3JCdWZmZXIsXHJcbiAgICAgICAgICAgIGRlcHRoU3RlbmNpbDogaW50ZXJtZWRpYXRlRGVwdGhTdGVuY2lsQnVmZmVyXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfZGVzdHJveUludGVybmFsUmVuZGVyVGFyZ2V0cygpIHtcclxuICAgICAgICB0aGlzLl9pbnRlcm1lZGlhdGVSZW5kZXJlQnVmZmVyLmRlc3Ryb3koKTtcclxuICAgICAgICB0aGlzLl9pbnRlcm1lZGlhdGVDb2xvckJ1ZmZlci5kZXN0cm95KCk7XHJcbiAgICAgICAgdGhpcy5faW50ZXJtZWRpYXRlRGVwdGhTdGVuY2lsQnVmZmVyLmRlc3Ryb3koKTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvZnhhYV9yZW5kZXJfdW5pdC50c1xuLy8gbW9kdWxlIGlkID0gMTc3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG5cXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbnVuaWZvcm0gdmVjMiBwaXhlbFNpemU7XFxudW5pZm9ybSBzYW1wbGVyMkQgdGV4dHVyZTtcXG51bmlmb3JtIGZsb2F0IGRwcjtcXG5cXG5jb25zdCBmbG9hdCBGWEFBX1FVQUxJVFlfU1VCUElYID0gMC43NTtcXG5jb25zdCBmbG9hdCBGWEFBX1FVQUxJVFlfRURHRV9USFJFU0hPTEQgPSAwLjA2MztcXG5jb25zdCBmbG9hdCBGWEFBX1FVQUxJVFlfRURHRV9USFJFU0hPTERfTUlOID0gMC4wNjI1O1xcbmNvbnN0IGZsb2F0IEVQU0lMT04gPSAwLjAwMDE7XFxuXFxuZmxvYXQgbHVtYSh2ZWM0IHJnYmEpIHtcXG4gICAgcmV0dXJuIGRvdChyZ2JhLnh5eiwgdmVjMygwLjI5OSwgMC41ODcsIDAuMTE0KSk7XFxufVxcblxcbnZlYzQgZnhhYShcXG4gICAgdmVjMiBwb3MsXFxuICAgIHNhbXBsZXIyRCB0ZXgsXFxuICAgIHZlYzIgZnhhYVF1YWxpdHlSY3BGcmFtZSxcXG4gICAgLy8gVGhpcyB1c2VkIHRvIGJlIHRoZSBGWEFBX1FVQUxJVFlfU1VCUElYIGRlZmluZS5cXG4gICAgLy8gQ2hvb3NlIHRoZSBhbW91bnQgb2Ygc3ViLXBpeGVsIGFsaWFzaW5nIHJlbW92YWwuXFxuICAgIC8vIFRoaXMgY2FuIGVmZmVjdCBzaGFycG5lc3MuXFxuICAgIC8vICAgMS4wMCAtIHVwcGVyIGxpbWl0IChzb2Z0ZXIpXFxuICAgIC8vICAgMC43NSAtIGRlZmF1bHQgYW1vdW50IG9mIGZpbHRlcmluZ1xcbiAgICAvLyAgIDAuNTAgLSBsb3dlciBsaW1pdCAoc2hhcnBlciwgbGVzcyBzdWItcGl4ZWwgYWxpYXNpbmcgcmVtb3ZhbClcXG4gICAgLy8gICAwLjI1IC0gYWxtb3N0IG9mZlxcbiAgICAvLyAgIDAuMDAgLSBjb21wbGV0ZWx5IG9mZlxcbiAgICBmbG9hdCBmeGFhUXVhbGl0eVN1YnBpeCxcXG4gICAgLy8gVGhpcyB1c2VkIHRvIGJlIHRoZSBGWEFBX1FVQUxJVFlfRURHRV9USFJFU0hPTEQgZGVmaW5lLlxcbiAgICAvLyBUaGUgbWluaW11bSBhbW91bnQgb2YgbG9jYWwgY29udHJhc3QgcmVxdWlyZWQgdG8gYXBwbHkgYWxnb3JpdGhtLlxcbiAgICAvLyAgIDAuMzMzIC0gdG9vIGxpdHRsZSAoZmFzdGVyKVxcbiAgICAvLyAgIDAuMjUwIC0gbG93IHF1YWxpdHlcXG4gICAgLy8gICAwLjE2NiAtIGRlZmF1bHRcXG4gICAgLy8gICAwLjEyNSAtIGhpZ2ggcXVhbGl0eVxcbiAgICAvLyAgIDAuMDYzIC0gb3ZlcmtpbGwgKHNsb3dlcilcXG4gICAgZmxvYXQgZnhhYVF1YWxpdHlFZGdlVGhyZXNob2xkLFxcbiAgICAvLyBUaGlzIHVzZWQgdG8gYmUgdGhlIEZYQUFfUVVBTElUWV9FREdFX1RIUkVTSE9MRF9NSU4gZGVmaW5lLlxcbiAgICAvLyBUcmltcyB0aGUgYWxnb3JpdGhtIGZyb20gcHJvY2Vzc2luZyBkYXJrcy5cXG4gICAgLy8gICAwLjA4MzMgLSB1cHBlciBsaW1pdCAoZGVmYXVsdCwgdGhlIHN0YXJ0IG9mIHZpc2libGUgdW5maWx0ZXJlZCBlZGdlcylcXG4gICAgLy8gICAwLjA2MjUgLSBoaWdoIHF1YWxpdHkgKGZhc3RlcilcXG4gICAgLy8gICAwLjAzMTIgLSB2aXNpYmxlIGxpbWl0IChzbG93ZXIpXFxuICAgIGZsb2F0IGZ4YWFRdWFsaXR5RWRnZVRocmVzaG9sZE1pblxcbikge1xcbiAgICB2ZWMyIHBvc007XFxuICAgIHBvc00ueCA9IHBvcy54O1xcbiAgICBwb3NNLnkgPSBwb3MueTtcXG4gICAgdmVjNCByZ2J5TSA9IHRleHR1cmUyRCh0ZXgsIHBvc00pO1xcbiAgICBmbG9hdCBsdW1hTSA9IGx1bWEocmdieU0pO1xcblxcbiAgICBmbG9hdCBsdW1hUyA9IGx1bWEodGV4dHVyZTJEKHRleCwgcG9zTSArIHZlYzIoIDAsIDEpICogZnhhYVF1YWxpdHlSY3BGcmFtZS54eSkpO1xcbiAgICBmbG9hdCBsdW1hRSA9IGx1bWEodGV4dHVyZTJEKHRleCwgcG9zTSArIHZlYzIoIDEsIDApICogZnhhYVF1YWxpdHlSY3BGcmFtZS54eSkpO1xcbiAgICBmbG9hdCBsdW1hTiA9IGx1bWEodGV4dHVyZTJEKHRleCwgcG9zTSArIHZlYzIoIDAsLTEpICogZnhhYVF1YWxpdHlSY3BGcmFtZS54eSkpO1xcbiAgICBmbG9hdCBsdW1hVyA9IGx1bWEodGV4dHVyZTJEKHRleCwgcG9zTSArIHZlYzIoLTEsIDApICogZnhhYVF1YWxpdHlSY3BGcmFtZS54eSkpO1xcblxcbiAgICBmbG9hdCBtYXhTTSA9IG1heChsdW1hUywgbHVtYU0pO1xcbiAgICBmbG9hdCBtaW5TTSA9IG1pbihsdW1hUywgbHVtYU0pO1xcbiAgICBmbG9hdCBtYXhFU00gPSBtYXgobHVtYUUsIG1heFNNKTtcXG4gICAgZmxvYXQgbWluRVNNID0gbWluKGx1bWFFLCBtaW5TTSk7XFxuICAgIGZsb2F0IG1heFdOID0gbWF4KGx1bWFOLCBsdW1hVyk7XFxuICAgIGZsb2F0IG1pbldOID0gbWluKGx1bWFOLCBsdW1hVyk7XFxuICAgIGZsb2F0IHJhbmdlTWF4ID0gbWF4KG1heFdOLCBtYXhFU00pO1xcbiAgICBmbG9hdCByYW5nZU1pbiA9IG1pbihtaW5XTiwgbWluRVNNKTtcXG4gICAgZmxvYXQgcmFuZ2VNYXhTY2FsZWQgPSByYW5nZU1heCAqIGZ4YWFRdWFsaXR5RWRnZVRocmVzaG9sZDtcXG4gICAgZmxvYXQgcmFuZ2UgPSByYW5nZU1heCAtIHJhbmdlTWluO1xcbiAgICBmbG9hdCByYW5nZU1heENsYW1wZWQgPSBtYXgoZnhhYVF1YWxpdHlFZGdlVGhyZXNob2xkTWluLCByYW5nZU1heFNjYWxlZCk7XFxuICAgIGJvb2wgZWFybHlFeGl0ID0gcmFuZ2UgPCByYW5nZU1heENsYW1wZWQ7XFxuXFxuICAgIGlmIChlYXJseUV4aXQpXFxuICAgICAgICByZXR1cm4gcmdieU07XFxuXFxuICAgIGZsb2F0IGx1bWFOVyA9IGx1bWEodGV4dHVyZTJEKHRleCwgcG9zTSArIHZlYzIoLTEsLTEpICogZnhhYVF1YWxpdHlSY3BGcmFtZS54eSkpO1xcbiAgICBmbG9hdCBsdW1hU0UgPSBsdW1hKHRleHR1cmUyRCh0ZXgsIHBvc00gKyB2ZWMyKCAxLCAxKSAqIGZ4YWFRdWFsaXR5UmNwRnJhbWUueHkpKTtcXG4gICAgZmxvYXQgbHVtYU5FID0gbHVtYSh0ZXh0dXJlMkQodGV4LCBwb3NNICsgdmVjMiggMSwtMSkgKiBmeGFhUXVhbGl0eVJjcEZyYW1lLnh5KSk7XFxuICAgIGZsb2F0IGx1bWFTVyA9IGx1bWEodGV4dHVyZTJEKHRleCwgcG9zTSArIHZlYzIoLTEsIDEpICogZnhhYVF1YWxpdHlSY3BGcmFtZS54eSkpO1xcblxcbiAgICBmbG9hdCBsdW1hTlMgPSBsdW1hTiArIGx1bWFTO1xcbiAgICBmbG9hdCBsdW1hV0UgPSBsdW1hVyArIGx1bWFFO1xcbiAgICBmbG9hdCBzdWJwaXhSY3BSYW5nZSA9IDEuMC9yYW5nZTtcXG4gICAgZmxvYXQgc3VicGl4TlNXRSA9IGx1bWFOUyArIGx1bWFXRTtcXG4gICAgZmxvYXQgZWRnZUhvcnoxID0gKC0yLjAgKiBsdW1hTSkgKyBsdW1hTlM7XFxuICAgIGZsb2F0IGVkZ2VWZXJ0MSA9ICgtMi4wICogbHVtYU0pICsgbHVtYVdFO1xcblxcbiAgICBmbG9hdCBsdW1hTkVTRSA9IGx1bWFORSArIGx1bWFTRTtcXG4gICAgZmxvYXQgbHVtYU5XTkUgPSBsdW1hTlcgKyBsdW1hTkU7XFxuICAgIGZsb2F0IGVkZ2VIb3J6MiA9ICgtMi4wICogbHVtYUUpICsgbHVtYU5FU0U7XFxuICAgIGZsb2F0IGVkZ2VWZXJ0MiA9ICgtMi4wICogbHVtYU4pICsgbHVtYU5XTkU7XFxuXFxuICAgIGZsb2F0IGx1bWFOV1NXID0gbHVtYU5XICsgbHVtYVNXO1xcbiAgICBmbG9hdCBsdW1hU1dTRSA9IGx1bWFTVyArIGx1bWFTRTtcXG4gICAgZmxvYXQgZWRnZUhvcno0ID0gKGFicyhlZGdlSG9yejEpICogMi4wKSArIGFicyhlZGdlSG9yejIpO1xcbiAgICBmbG9hdCBlZGdlVmVydDQgPSAoYWJzKGVkZ2VWZXJ0MSkgKiAyLjApICsgYWJzKGVkZ2VWZXJ0Mik7XFxuICAgIGZsb2F0IGVkZ2VIb3J6MyA9ICgtMi4wICogbHVtYVcpICsgbHVtYU5XU1c7XFxuICAgIGZsb2F0IGVkZ2VWZXJ0MyA9ICgtMi4wICogbHVtYVMpICsgbHVtYVNXU0U7XFxuICAgIGZsb2F0IGVkZ2VIb3J6ID0gYWJzKGVkZ2VIb3J6MykgKyBlZGdlSG9yejQ7XFxuICAgIGZsb2F0IGVkZ2VWZXJ0ID0gYWJzKGVkZ2VWZXJ0MykgKyBlZGdlVmVydDQ7XFxuXFxuICAgIGZsb2F0IHN1YnBpeE5XU1dORVNFID0gbHVtYU5XU1cgKyBsdW1hTkVTRTtcXG4gICAgZmxvYXQgbGVuZ3RoU2lnbiA9IGZ4YWFRdWFsaXR5UmNwRnJhbWUueDtcXG4gICAgYm9vbCBob3J6U3BhbiA9IGVkZ2VIb3J6ID49IGVkZ2VWZXJ0O1xcbiAgICBmbG9hdCBzdWJwaXhBID0gc3VicGl4TlNXRSAqIDIuMCArIHN1YnBpeE5XU1dORVNFO1xcblxcbiAgICBpZiAoaG9yelNwYW4pIHtcXG4gICAgICAgIGxlbmd0aFNpZ24gPSBmeGFhUXVhbGl0eVJjcEZyYW1lLnk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICBsdW1hTiA9IGx1bWFXO1xcbiAgICAgICAgbHVtYVMgPSBsdW1hRTtcXG4gICAgfVxcbiAgICBmbG9hdCBzdWJwaXhCID0gKHN1YnBpeEEgKiAoMS4wLzEyLjApKSAtIGx1bWFNO1xcblxcbiAgICBmbG9hdCBncmFkaWVudE4gPSBsdW1hTiAtIGx1bWFNO1xcbiAgICBmbG9hdCBncmFkaWVudFMgPSBsdW1hUyAtIGx1bWFNO1xcbiAgICBmbG9hdCBsdW1hTk4gPSBsdW1hTiArIGx1bWFNO1xcbiAgICBmbG9hdCBsdW1hU1MgPSBsdW1hUyArIGx1bWFNO1xcbiAgICBib29sIHBhaXJOID0gYWJzKGdyYWRpZW50TikgPj0gYWJzKGdyYWRpZW50Uyk7XFxuICAgIGZsb2F0IGdyYWRpZW50ID0gbWF4KGFicyhncmFkaWVudE4pLCBhYnMoZ3JhZGllbnRTKSk7XFxuICAgIGlmIChwYWlyTikge1xcbiAgICAgICAgbGVuZ3RoU2lnbiA9IC1sZW5ndGhTaWduO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgbHVtYU5OID0gbHVtYVNTO1xcbiAgICB9XFxuICAgIGZsb2F0IHN1YnBpeEMgPSBjbGFtcChhYnMoc3VicGl4QikgKiBzdWJwaXhSY3BSYW5nZSwgMC4wLCAxLjApO1xcblxcbiAgICB2ZWMyIHBvc0IgPSBwb3NNO1xcbiAgICB2ZWMyIG9mZk5QO1xcblxcbiAgICB2ZWMyIG9mZkhNO1xcbiAgICBpZiAoaG9yelNwYW4pIHtcXG4gICAgICAgIG9mZk5QID0gdmVjMihmeGFhUXVhbGl0eVJjcEZyYW1lLngsIDAuMCk7XFxuICAgICAgICBvZmZITSA9IHZlYzIoMC4wLCBsZW5ndGhTaWduKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIG9mZk5QID0gdmVjMigwLjAsIGZ4YWFRdWFsaXR5UmNwRnJhbWUueSk7XFxuICAgICAgICBvZmZITSA9IHZlYzIobGVuZ3RoU2lnbiwgMC4wKTtcXG4gICAgfVxcblxcbiAgICB2ZWMyIHBvc04gPSBwb3NCIC0gb2ZmTlAgKiAyLjtcXG4gICAgdmVjMiBwb3NQID0gcG9zQiArIG9mZk5QICogMi47XFxuXFxuICAgIGZsb2F0IHN1YnBpeEQgPSAoKC0yLjApKnN1YnBpeEMpICsgMy4wO1xcbiAgICBmbG9hdCBsdW1hRW5kTiA9IGx1bWEoXFxuICAgICAgICBtaXgoXFxuICAgICAgICAgICAgdGV4dHVyZTJEKHRleCwgcG9zTiksXFxuICAgICAgICAgICAgdGV4dHVyZTJEKHRleCwgcG9zTiArIG9mZkhNKSxcXG4gICAgICAgICAgICAwLjVcXG4gICAgICAgIClcXG4gICAgKTtcXG4gICAgZmxvYXQgc3VicGl4RSA9IHN1YnBpeEMgKiBzdWJwaXhDO1xcbiAgICBmbG9hdCBsdW1hRW5kUCA9IGx1bWEoXFxuICAgICAgICBtaXgoXFxuICAgICAgICAgICAgdGV4dHVyZTJEKHRleCwgcG9zUCksXFxuICAgICAgICAgICAgdGV4dHVyZTJEKHRleCwgcG9zUCArIG9mZkhNKSxcXG4gICAgICAgICAgICAwLjVcXG4gICAgICAgIClcXG4gICAgKTtcXG5cXG4gICAgZmxvYXQgZ3JhZGllbnRTY2FsZWQgPSBncmFkaWVudCAqIDAuMjU7XFxuICAgIGZsb2F0IGx1bWFNTSA9IGx1bWFNIC0gbHVtYU5OICogMC41O1xcbiAgICBmbG9hdCBzdWJwaXhGID0gc3VicGl4RCAqIHN1YnBpeEU7XFxuICAgIGJvb2wgbHVtYU1MVFplcm8gPSBsdW1hTU0gPCAwLjA7XFxuXFxuICAgIGx1bWFFbmROIC09IGx1bWFOTiAqIDAuNTtcXG4gICAgbHVtYUVuZFAgLT0gbHVtYU5OICogMC41O1xcbiAgICBib29sIGRvbmVOID0gYWJzKGx1bWFFbmROKSA+PSBncmFkaWVudFNjYWxlZDtcXG4gICAgYm9vbCBkb25lUCA9IGFicyhsdW1hRW5kUCkgPj0gZ3JhZGllbnRTY2FsZWQ7XFxuICAgIGlmICghZG9uZU4pIHtcXG4gICAgICAgIHBvc04gLT0gb2ZmTlAgKiAzLjA7XFxuICAgIH1cXG4gICAgYm9vbCBkb25lTlAgPSAoIWRvbmVOKSB8fCAoIWRvbmVQKTtcXG4gICAgaWYgKCFkb25lUCkge1xcbiAgICAgICAgcG9zUCArPSBvZmZOUCAqIDMuMDtcXG4gICAgfVxcblxcbiAgICBpZiAoZG9uZU5QKSB7XFxuICAgICAgICBpZiAoIWRvbmVOKSB7XFxuICAgICAgICAgICAgbHVtYUVuZE4gPSBsdW1hKFxcbiAgICAgICAgICAgICAgICBtaXgoXFxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlMkQodGV4LCBwb3NOKSxcXG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmUyRCh0ZXgsIHBvc04gKyBvZmZITSksXFxuICAgICAgICAgICAgICAgICAgICAwLjVcXG4gICAgICAgICAgICAgICAgKVxcbiAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgbHVtYUVuZE4gPSBsdW1hRW5kTiAtIGx1bWFOTiAqIDAuNTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICghZG9uZVApIHtcXG4gICAgICAgICAgICBsdW1hRW5kUCA9IGx1bWEoXFxuICAgICAgICAgICAgICAgIG1peChcXG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmUyRCh0ZXgsIHBvc1AueHkpLFxcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZTJEKHRleCwgcG9zUC54eSArIG9mZkhNKSxcXG4gICAgICAgICAgICAgICAgICAgIDAuNVxcbiAgICAgICAgICAgICAgICApXFxuICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICBsdW1hRW5kUCA9IGx1bWFFbmRQIC0gbHVtYU5OICogMC41O1xcbiAgICAgICAgfVxcbiAgICAgICAgZG9uZU4gPSBhYnMobHVtYUVuZE4pID49IGdyYWRpZW50U2NhbGVkO1xcbiAgICAgICAgZG9uZVAgPSBhYnMobHVtYUVuZFApID49IGdyYWRpZW50U2NhbGVkO1xcbiAgICAgICAgaWYgKCFkb25lTikge1xcbiAgICAgICAgICAgIHBvc04gLT0gb2ZmTlAgKiAxMi4wO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKCFkb25lUCkge1xcbiAgICAgICAgICAgIHBvc1AgKz0gb2ZmTlAgKiAxMi4wO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIGZsb2F0IGRzdE4gPSBwb3NNLnggLSBwb3NOLng7XFxuICAgIGZsb2F0IGRzdFAgPSBwb3NQLnggLSBwb3NNLng7XFxuICAgIGlmICghaG9yelNwYW4pIHtcXG4gICAgICAgIGRzdE4gPSBwb3NNLnkgLSBwb3NOLnk7XFxuICAgICAgICBkc3RQID0gcG9zUC55IC0gcG9zTS55O1xcbiAgICB9XFxuICAgIGJvb2wgZ29vZFNwYW5OID0gKGx1bWFFbmROIDwgMC4wKSAhPSBsdW1hTUxUWmVybztcXG4gICAgZmxvYXQgc3Bhbkxlbmd0aCA9IChkc3RQICsgZHN0Tik7XFxuICAgIGJvb2wgZ29vZFNwYW5QID0gKGx1bWFFbmRQIDwgMC4wKSAhPSBsdW1hTUxUWmVybztcXG4gICAgZmxvYXQgc3Bhbkxlbmd0aFJjcCA9IDEuMC9zcGFuTGVuZ3RoO1xcbiAgICBib29sIGRpcmVjdGlvbk4gPSBkc3ROIDwgZHN0UDtcXG4gICAgZmxvYXQgZHN0ID0gbWluKGRzdE4sIGRzdFApO1xcbiAgICBib29sIGdvb2RTcGFuID0gZGlyZWN0aW9uTiA/IGdvb2RTcGFuTiA6IGdvb2RTcGFuUDtcXG4gICAgZmxvYXQgc3VicGl4RyA9IHN1YnBpeEYgKiBzdWJwaXhGO1xcbiAgICBmbG9hdCBwaXhlbE9mZnNldCA9IChkc3QgKiAoLXNwYW5MZW5ndGhSY3ApKSArIDAuNTtcXG4gICAgZmxvYXQgc3VicGl4SCA9IHN1YnBpeEcgKiBmeGFhUXVhbGl0eVN1YnBpeDtcXG4gICAgZmxvYXQgcGl4ZWxPZmZzZXRHb29kID0gZ29vZFNwYW4gPyBwaXhlbE9mZnNldCA6IDAuMDtcXG4gICAgZmxvYXQgcGl4ZWxPZmZzZXRTdWJwaXggPSBtYXgocGl4ZWxPZmZzZXRHb29kLCBzdWJwaXhIKTtcXG4gICAgdmVjNCBjb2xvcjtcXG4gICAgZmxvYXQgZmFjdG9yID0gcGl4ZWxPZmZzZXRTdWJwaXg7XFxuICAgIGlmIChob3J6U3Bhbikge1xcbiAgICAgICAgY29sb3IgPSBtaXgoXFxuICAgICAgICAgICAgdGV4dHVyZTJEKHRleCwgcG9zTSksXFxuICAgICAgICAgICAgdGV4dHVyZTJEKHRleCwgcG9zTSArIHZlYzIoMC4wLCBsZW5ndGhTaWduKSksXFxuICAgICAgICAgICAgZmFjdG9yXFxuICAgICAgICApO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgY29sb3IgPSBtaXgoXFxuICAgICAgICAgICAgdGV4dHVyZTJEKHRleCwgcG9zTSksXFxuICAgICAgICAgICAgdGV4dHVyZTJEKHRleCwgcG9zTSArIHZlYzIobGVuZ3RoU2lnbiwgMC4wKSksXFxuICAgICAgICAgICAgZmFjdG9yXFxuICAgICAgICApO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBjb2xvcjtcXG59XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICB2ZWMyIHBvcyA9IGdsX0ZyYWdDb29yZC54eSAqIHBpeGVsU2l6ZTtcXG4gICAgdmVjNCBjb2xvciA9IGZ4YWEoXFxuICAgICAgICBwb3MsXFxuICAgICAgICB0ZXh0dXJlLFxcbiAgICAgICAgcGl4ZWxTaXplLFxcbiAgICAgICAgRlhBQV9RVUFMSVRZX1NVQlBJWCxcXG4gICAgICAgIEZYQUFfUVVBTElUWV9FREdFX1RIUkVTSE9MRCxcXG4gICAgICAgIEZYQUFfUVVBTElUWV9FREdFX1RIUkVTSE9MRF9NSU5cXG4gICAgKTtcXG5cXG4gICAgLy8gSWYgY29sb3IuYSBpcyBsZXNzIHRoYW4gb25lLCB0aGVuIHRoZSBjb2xvciBoYXMgYmVlbiBibGVuZGVkIHdpdGggYSBibGFjayBiYWNrZ3JvdW5kIGJlZm9yZS5cXG4gICAgLy8gQW4gb3JpZ2luYWwgY29sb3Igb2YgdHJhbnNwYXJlbnQgb2JqZWN0cyBpcyB2ZWM0KGNvbG9yLnh5eiAvIGNvbG9yLmEsIGNvbG9yLmEpLlxcbiAgICAvLyBXZSBoYXZlIHRvIGJsZW5kIGFuIG9yaWdpbmFsIGNvbG9yIHdpdGggYmFja2dyb3VuZCBwYXR0ZXJuLlxcbiAgICAvLyBjb2xvci5hIGNhbiBiZSB0b28gY2xvc2UgdG8gemVyby4gQ2hlY2sgaXQuXFxuICAgIGlmIChjb2xvci5hID4gRVBTSUxPTikge1xcbiAgICAgICAgY29sb3IueHl6IC89IGNvbG9yLmE7XFxuICAgIH1cXG4gICAgZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxufVxcblwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3NoYWRlcnMvZnhhYS5mcmFnXG4vLyBtb2R1bGUgaWQgPSAxNzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgR2xSZW5kZXJlciB9IGZyb20gJy4vZ2xfcmVuZGVyZXInO1xyXG5pbXBvcnQgUmVuZGVyU3RhdGUgZnJvbSAnLi9zdGF0ZSc7XHJcbmltcG9ydCB7IFZvaWRFdmVudEVtaXR0ZXIgfSBmcm9tICcuLy4uL3V0aWwvZXZlbnRfZW1pdHRlcic7XHJcbmltcG9ydCBxdWFkVmVydGV4U2hhZGVyIGZyb20gJy4vc2hhZGVycy9xdWFkLnZlcnQnO1xyXG5pbXBvcnQgYmFja2dyb3VuZEZyYWdtZW50U2hhZGVyIGZyb20gJy4vc2hhZGVycy9iYWNrZ3JvdW5kLmZyYWcnO1xyXG5pbXBvcnQgZ2V0RHByIGZyb20gJy4uL3V0aWwvaGQnO1xyXG5jb25zdCBTVEFURSA9IG5ldyBSZW5kZXJTdGF0ZSh7XHJcbiAgICBkZXB0aFRlc3Q6IHRydWUsXHJcbiAgICBkZXB0aEZ1bmM6IDUxOCAvKiBHUkVBVEVSX09SX0VRVUFMICovXHJcbn0pO1xyXG4vKipcclxuICogRmlsbHMgbWFwJ3MgY2FudmFzIHdpdGggYmFja2dyb3VuZCBwYXR0ZXJuIG9uIHJlZ2lvbnMgdGhhdCBoYXZlIG5vIGRhdGEgeWV0LlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFja2dyb3VuZFJlbmRlclVuaXQgZXh0ZW5kcyBHbFJlbmRlcmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcclxuICAgICAgICBjb25zdCBwcm9ncmFtID0gY29udGV4dC5jcmVhdGVQcm9ncmFtKHF1YWRWZXJ0ZXhTaGFkZXIsIGJhY2tncm91bmRGcmFnbWVudFNoYWRlciwge1xyXG4gICAgICAgICAgICBhdHRyaWJNYXA6IHtcclxuICAgICAgICAgICAgICAgIHZlcnRleFBvc2l0aW9uOiAwIC8qIFBPU0lUSU9OICovLFxyXG4gICAgICAgICAgICAgICAgdmVydGV4VXY6IDQgLyogVVYgKi9cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHN1cGVyKGNvbnRleHQsIFNUQVRFLCBwcm9ncmFtKTtcclxuICAgICAgICBjb250ZXh0LmJpbmRQcm9ncmFtKHByb2dyYW0pO1xyXG4gICAgICAgIHByb2dyYW0uc2V0U2NhbGFyVW5pZm9ybSgnekluZGV4JywgLTEpO1xyXG4gICAgICAgIHRoaXMub25VcGRhdGUgPSBuZXcgVm9pZEV2ZW50RW1pdHRlcigpO1xyXG4gICAgfVxyXG4gICAgX3JlbmRlcigpIHtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRRdWFkVmFvKCk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5kcmF3UXVhZCgpO1xyXG4gICAgfVxyXG4gICAgX3ByZXBhcmVQcm9ncmFtKHByb2dyYW0pIHtcclxuICAgICAgICBzdXBlci5fcHJlcGFyZVByb2dyYW0ocHJvZ3JhbSk7XHJcbiAgICAgICAgcHJvZ3JhbS5zZXRTY2FsYXJVbmlmb3JtKCdkcHInLCBnZXREcHIoKSk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL2JhY2tncm91bmRfcmVuZGVyX3VuaXQudHNcbi8vIG1vZHVsZSBpZCA9IDE3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwiI3ZlcnNpb24gMTAwXFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIC8vIEJhY2tncm91bmQgY29sb3Igc2hvdWxkIG1hdGNoIG1haW4gbWFwIGxheWVyIGNvbG9yLlxcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuOTgsIDAuOTcsIDAuOTQsIDEpO1xcbn1cXG5cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9zaGFkZXJzL2JhY2tncm91bmQuZnJhZ1xuLy8gbW9kdWxlIGlkID0gMTgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBMaXN0UmVuZGVyVW5pdCBmcm9tICcuL2xpc3RfcmVuZGVyX3VuaXQnO1xyXG5pbXBvcnQgUmVuZGVyU3RhdGUgZnJvbSAnLi9zdGF0ZSc7XHJcbmNvbnN0IERFUFRIX0NMRUFSX1NUQVRFID0gbmV3IFJlbmRlclN0YXRlKHtcclxuICAgIGRlcHRoVGVzdDogdHJ1ZSxcclxuICAgIGNsZWFyRGVwdGg6IDBcclxufSk7XHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExheWVyUmVuZGVyVW5pdCBleHRlbmRzIExpc3RSZW5kZXJVbml0IHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIGRlcHRoQ2xlYXJTdHJhdGVneSA9IDAgLyogTk9fQ0xFQVIgKi8pIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX2RlcHRoQ2xlYXJTdHJhdGVneSA9IGRlcHRoQ2xlYXJTdHJhdGVneTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcclxuICAgIH1cclxuICAgIHJlbmRlcih0YXJnZXQsIC4uLmFyZ3MpIHtcclxuICAgICAgICBpZiAodGhpcy5fZGVwdGhDbGVhclN0cmF0ZWd5ID09PSAxIC8qIEJFRk9SRV9SRU5ERVIgKi8pIHtcclxuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kUmVuZGVyU3RhdGUoREVQVEhfQ0xFQVJfU1RBVEUpO1xyXG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRSZW5kZXJUYXJnZXQodGFyZ2V0KTtcclxuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5jbGVhckN1cnJlbnRUYXJnZXQoMjU2IC8qIERFUFRIX0JVRkZFUl9CSVQgKi8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdXBlci5yZW5kZXIodGFyZ2V0LCAuLi5hcmdzKTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvbGF5ZXJfcmVuZGVyX3VuaXQudHNcbi8vIG1vZHVsZSBpZCA9IDE4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgUmVuZGVyU3RhdGUgZnJvbSAnLi4vLi4vcmVuZGVyL3N0YXRlJztcclxuaW1wb3J0IHsgY291bnRJbmRpY2VzIH0gZnJvbSAnLi4vLi4vcmVuZGVyL21lbW9yeS9jb3VudF92ZXJ0aWNlcyc7XHJcbmltcG9ydCByZXNldFJlbW92ZWRWZXJ0ZXhTaGFkZXIgZnJvbSAnLi9zaGFkZXJzL3Jlc2V0X3JlbW92ZWQudmVydCc7XHJcbmltcG9ydCByZXNldFJlbW92ZWRGcmFnbWVudFNoYWRlciBmcm9tICcuL3NoYWRlcnMvcmVzZXRfcmVtb3ZlZC5mcmFnJztcclxuaW1wb3J0IHsgR2xSZW5kZXJlciB9IGZyb20gJy4uLy4uL3JlbmRlci9nbF9yZW5kZXJlcic7XHJcbmltcG9ydCB7IGJhdGNoUHJpbWl0aXZlcyB9IGZyb20gJy4uLy4uL3JlbmRlci9wcmltaXRpdmVzL3ByaW1pdGl2ZV9iYXRjaCc7XHJcbmV4cG9ydCBjbGFzcyBDb2xsaWRpbmdQcmltaXRpdmVzUmVzZXRSZW1vdmVkUmVuZGVyZXIgZXh0ZW5kcyBHbFJlbmRlcmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIHByaW1pdGl2ZVByb3ZpZGVyKSB7XHJcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IGNvbnRleHQuY3JlYXRlUHJvZ3JhbShyZXNldFJlbW92ZWRWZXJ0ZXhTaGFkZXIsIHJlc2V0UmVtb3ZlZEZyYWdtZW50U2hhZGVyLCB7XHJcbiAgICAgICAgICAgIGF0dHJpYk1hcDoge1xyXG4gICAgICAgICAgICAgICAgdmVydGV4UG9zSGlnaDogMCAvKiBQT1NJVElPTl9ISUdIICovLFxyXG4gICAgICAgICAgICAgICAgdmVydGV4SWQ6IDIgLyogSUQgKi9cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHN1cGVyKGNvbnRleHQsIG5ldyBSZW5kZXJTdGF0ZSgpLCBwcm9ncmFtKTtcclxuICAgICAgICB0aGlzLl9wcmltaXRpdmVQcm92aWRlciA9IHByaW1pdGl2ZVByb3ZpZGVyO1xyXG4gICAgICAgIGNvbnRleHQuYmluZFByb2dyYW0ocHJvZ3JhbSk7XHJcbiAgICAgICAgcHJvZ3JhbS5zZXRJbnRTY2FsYXJVbmlmb3JtKCdwcmV2VmlzaWJpbGl0eScsIDApO1xyXG4gICAgfVxyXG4gICAgX3JlbmRlcigpIHtcclxuICAgICAgICBjb25zdCBwcmltaXRpdmVzID0gdGhpcy5fcHJpbWl0aXZlUHJvdmlkZXIucHJpbWl0aXZlcztcclxuICAgICAgICBmb3IgKGNvbnN0IG1lbW9yeUJhdGNoIG9mIGJhdGNoUHJpbWl0aXZlcyhwcmltaXRpdmVzKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRWYW8obWVtb3J5QmF0Y2gucGFnZS52YW8pO1xyXG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmRyYXdJbmRleGVkTWVzaChtZW1vcnlCYXRjaC5pbmRleEJ5dGVPZmZzZXQsIGNvdW50SW5kaWNlcyhtZW1vcnlCYXRjaC5pbmRleEJ5dGVMZW5ndGgsIG1lbW9yeUJhdGNoLnBhZ2UuaW5kZXhUeXBlKSwgMCAvKiBQT0lOVFMgKi8pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9wcmVwYXJlUHJvZ3JhbShwcm9ncmFtLCBwcmV2VmlzaWJpbGl0eSwgaWRIYWxmUHhTaXplKSB7XHJcbiAgICAgICAgc3VwZXIuX3ByZXBhcmVQcm9ncmFtKHByb2dyYW0sIHByZXZWaXNpYmlsaXR5LCBpZEhhbGZQeFNpemUpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFRleHR1cmVVbml0KDApO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFRleHR1cmUocHJldlZpc2liaWxpdHkpO1xyXG4gICAgICAgIHByb2dyYW0uc2V0VmVjdG9yMlVuaWZvcm0oJ2lkSGFsZlB4U2l6ZScsIGlkSGFsZlB4U2l6ZSk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdmlzaWJpbGl0eS9wcmltaXRpdmVzL2NvbGxpZGluZ19wcmltaXRpdmVfcmVzZXRfcmVtb3ZlZF9yZW5kZXJlci50c1xuLy8gbW9kdWxlIGlkID0gMTgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleFBvc0hpZ2g7XFxuYXR0cmlidXRlIHZlYzIgdmVydGV4SWQ7XFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgcHJldlZpc2liaWxpdHk7XFxudW5pZm9ybSB2ZWMyIGlkSGFsZlB4U2l6ZTtcXG5cXG52YXJ5aW5nIGxvd3AgdmVjNCB2aXNpYmlsaXR5VmFsdWU7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICB2ZWMyIGlkVGV4Q29vcmRpbmF0ZXMgPSB2ZXJ0ZXhJZCArIGlkSGFsZlB4U2l6ZTtcXG4gICAgdmVjNCBpZFdpbmRvd0Nvb3JkaW5hdGVzID0gdmVjNChpZFRleENvb3JkaW5hdGVzICogMi4wIC0gMS4wLCAwLCAxKTtcXG4gICAgZ2xfUG9zaXRpb24gPSBpZFdpbmRvd0Nvb3JkaW5hdGVzO1xcbiAgICBnbF9Qb2ludFNpemUgPSAxLjA7XFxuXFxuICAgIHZpc2liaWxpdHlWYWx1ZSA9IHRleHR1cmUyRChwcmV2VmlzaWJpbGl0eSwgaWRUZXhDb29yZGluYXRlcyk7XFxufVxcblwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdmlzaWJpbGl0eS9wcmltaXRpdmVzL3NoYWRlcnMvcmVzZXRfcmVtb3ZlZC52ZXJ0XG4vLyBtb2R1bGUgaWQgPSAxODNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcIiN2ZXJzaW9uIDEwMFxcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxudmFyeWluZyBsb3dwIHZlYzQgdmlzaWJpbGl0eVZhbHVlO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmlzaWJpbGl0eVZhbHVlO1xcbn1cXG5cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3Zpc2liaWxpdHkvcHJpbWl0aXZlcy9zaGFkZXJzL3Jlc2V0X3JlbW92ZWQuZnJhZ1xuLy8gbW9kdWxlIGlkID0gMTg0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IEV2ZW50RW1pdHRlciwgVm9pZEV2ZW50RW1pdHRlciB9IGZyb20gJy4vdXRpbC9ldmVudF9lbWl0dGVyJztcclxuY29uc3QgTUFYX0ZSQU1FX1RJTUVfQ09VTlQgPSAxMDA7XHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbmRlckxvb3Age1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBuZXcgcmVuZGVyIGxvb3AsIGJ1dCBkb2Vzbid0IHNjaGVkdWxlIGFueSBhbmltYXRpb24gZnJhbWVzLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLm9uRnJhbWVUaW1lc0Z1bGwgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5vbkJlZm9yZVJlbmRlciA9IG5ldyBWb2lkRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5vblJlbmRlciA9IG5ldyBWb2lkRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5faXNSdW5uaW5nID0gdGhpcy5fdXBkYXRlSXNSZXF1ZXN0ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9sYXN0RnJhbWVUaW1lID0gMDtcclxuICAgICAgICB0aGlzLl9mcmFtZVRpbWVzID0gbmV3IEFycmF5KE1BWF9GUkFNRV9USU1FX0NPVU5UKTtcclxuICAgICAgICB0aGlzLl9mcmFtZVRpbWVzLmZpbGwoMCk7XHJcbiAgICAgICAgdGhpcy5fbmV4dEZyYW1lVGltZUlkeCA9IDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGxvb3AgaXMgcnVubmluZyBhIGNoYWluIG9mIGNvbnNlY3V0aXZlIGFuaW1hdGlvblxyXG4gICAgICogICAgICBmcmFtZXMgb3Igbm90LlxyXG4gICAgICovXHJcbiAgICBnZXQgaXNBY3RpdmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzUnVubmluZztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3RhcnRzIGEgY2hhaW4gb2YgY29uc2VjdXRpdmUgYW5pbWF0aW9uIGZyYW1lcy5cclxuICAgICAqL1xyXG4gICAgc3RhcnQoKSB7XHJcbiAgICAgICAgdGhpcy5faXNSdW5uaW5nID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9yZXF1ZXN0RnJhbWUoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3RvcHMgcHJldmlvdXNseSBzdGFydGVkIGNoYWluIG9mIGNvbnNlY3V0aXZlIGFuaW1hdGlvbiBmcmFtZXMuIElmIGFuXHJcbiAgICAgKiB1cGRhdGUgd2FzIHJlcXVlc3RlZCBiZWZvcmUgc3RvcHBpbmcsIG9uZSBtb3JlIGFuaW1hdGlvbiBmcmFtZSB3aWxsIGJlXHJcbiAgICAgKiBmaXJlZC5cclxuICAgICAqL1xyXG4gICAgc3RvcCgpIHtcclxuICAgICAgICBpZiAodGhpcy5faXNSdW5uaW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzUnVubmluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3VwZGF0ZUlzUmVxdWVzdGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jYW5jZWxGcmFtZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTY2hlZHVsZXMgYSBzaW5nbGVcclxuICAgICAqL1xyXG4gICAgdXBkYXRlKCkge1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZUlzUmVxdWVzdGVkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9yZXF1ZXN0RnJhbWUoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3RvcHMgYWxsIHRoZSByZW5kZXJpbmcgYWN0aXZpdGllcy5cclxuICAgICAqL1xyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLl9jYW5jZWxGcmFtZSgpO1xyXG4gICAgfVxyXG4gICAgX3JlbmRlckZyYW1lKHRpbWUpIHtcclxuICAgICAgICB0aGlzLl9yYWZJZCA9IDA7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlSXNSZXF1ZXN0ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLm9uQmVmb3JlUmVuZGVyLmZpcmUoKTtcclxuICAgICAgICB0aGlzLm9uUmVuZGVyLmZpcmUoKTtcclxuICAgICAgICBpZiAodGhpcy5fbGFzdEZyYW1lVGltZSA+IDApIHtcclxuICAgICAgICAgICAgY29uc3QgbmV4dEZyYW1lVGltZUlkeCA9IHRoaXMuX25leHRGcmFtZVRpbWVJZHg7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZyYW1lVGltZXNbbmV4dEZyYW1lVGltZUlkeF0gPSB0aW1lIC0gdGhpcy5fbGFzdEZyYW1lVGltZTtcclxuICAgICAgICAgICAgdGhpcy5fbmV4dEZyYW1lVGltZUlkeCA9IChuZXh0RnJhbWVUaW1lSWR4ICsgMSkgJSBNQVhfRlJBTUVfVElNRV9DT1VOVDtcclxuICAgICAgICAgICAgLy8gTmV4dCB0aW1lIGluZGV4IGJlaW5nIDAgbWVhbnMgdGhhdCB0aGUgYXJyYXkgaXMgZnVsbCBhbmQgaXQnc1xyXG4gICAgICAgICAgICAvLyB0aW1lIHRvIG5vdGlmeSBsaXN0ZW5lcnMgYWJvdXQgdGhhdCBiZWZvcmUgd2Ugc3RhcnQgdG8gcmV3cml0ZVxyXG4gICAgICAgICAgICAvLyB2YWx1ZXMuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9uZXh0RnJhbWVUaW1lSWR4ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uRnJhbWVUaW1lc0Z1bGwuZmlyZSh0aGlzLl9mcmFtZVRpbWVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5faXNSdW5uaW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xhc3RGcmFtZVRpbWUgPSB0aW1lO1xyXG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0RnJhbWUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIElmIHdlIGRvbid0IHNjaGVkdWxlIG5leHQgZnJhbWUgaW1tZWRpYXRlbHkgdGhlcmUncyBubyB3YXkgdG9cclxuICAgICAgICAgICAgLy8gdGVsbCB0aGF0IGl0IHdpbGwgYmUgY29uc2VjdXRpdmUgdG8gdGhlIGN1cnJlbnQgb25lLiBIZW5jZSB0aGVyZSdzXHJcbiAgICAgICAgICAgIC8vIG5vIHBvaW50IGluIHJlY29yZGluZyBhIHRpbWUgZGVsdGEgaW4gaXQuXHJcbiAgICAgICAgICAgIHRoaXMuX2xhc3RGcmFtZVRpbWUgPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9yZXF1ZXN0RnJhbWUoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9yYWZJZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9yYWZJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKHRpbWUpID0+IHRoaXMuX3JlbmRlckZyYW1lKHRpbWUpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2NhbmNlbEZyYW1lKCkge1xyXG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX3JhZklkKTtcclxuICAgICAgICB0aGlzLl9yYWZJZCA9IDA7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyX2xvb3AudHNcbi8vIG1vZHVsZSBpZCA9IDE4NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9
;console.warn(`Hash: 5a421fe0b68dc8e12e8c
Version: webpack 3.8.1
Time: 160ms
      Asset     Size  Chunks         Chunk Names
index.ts.js  1.45 MB       0  [big]  index
  [10] ./src/vector_render_engine/util/hd.ts 343 bytes {0}
  [22] ./src/vector_render_engine/render/primitives/polygon/polygon_render_unit.ts 1.01 kB {0}
  [45] ./src/vector_render_engine/render/primitives/label/point_label_render_unit.ts 2.16 kB {0}
  [48] ./src/vector_render_engine/render/primitives/label/curved_label_render_unit.ts 1.25 kB {0}
  [53] ./tools/stand/index.ts 7.34 kB {0}
  [54] ./src/vector_render_engine/render/context.ts 32.6 kB {0}
  [63] ./src/vector_render_engine/camera.ts 11.6 kB {0}
  [67] ./src/vector_render_engine/adapters/vector_api/adapter.ts 33.1 kB {0} [1 error]
 [133] ./src/vector_render_engine/render/primitives/polyline/textured_polyline_render_unit.ts 2.29 kB {0}
 [136] ./src/vector_render_engine/render/primitives/polyline/polyline_render_unit.ts 1.82 kB {0}
 [140] ./src/vector_render_engine/render/primitives/polygon/textured_polygon_render_unit.ts 1.97 kB {0}
 [143] ./src/vector_render_engine/render/primitives/polygon/transparent_polygon_render_unit.ts 577 bytes {0}
 [146] ./src/vector_render_engine/map_engine.ts 2.6 kB {0}
 [182] ./src/vector_render_engine/visibility/primitives/colliding_primitive_reset_removed_renderer.ts 1.66 kB {0}
 [185] ./src/vector_render_engine/render_loop.ts 3.06 kB {0}
    + 171 hidden modules

ERROR in ./src/vector_render_engine/adapters/vector_api/adapter.ts
[90m[tsl] [39m[1m[31mERROR[39m[22m[1m[31m in [39m[22m[1m[36mC:\Users\allergic\workspace\jsapi-v3\src\vector_render_engine\adapters\vector_api\adapter.ts(272,13)[39m[22m
[1m[31m      TS2322: Type '{ priority: number; isVisible: boolean; zoomMin: number; zoomMax: number; zoom: number; x: number; y: number; }' is not assignable to type 'VMapTileRequest'.[39m[22m
[1m[31m  Object literal may only specify known properties, and 'isVisible' does not exist in type 'VMapTileRequest'.[39m[22m`);