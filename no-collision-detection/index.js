/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _src_vector_render_engine_render_context__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _src_vector_render_engine_camera__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15);
/* harmony import */ var _src_vector_render_engine_adapters_vector_api_adapter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(24);
/* harmony import */ var _camera_stuff__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(93);
/* harmony import */ var _src_vector_render_engine_visibility_primitives_label_color_id_point_label_renderer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(95);
/* harmony import */ var _src_vector_render_engine_visibility_primitives_label_color_id_curved_label_renderer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(111);
/* harmony import */ var _src_vector_render_engine_render_primitives_label_point_label_render_unit__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(104);
/* harmony import */ var _src_vector_render_engine_render_primitives_label_curved_label_render_unit__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(113);
/* harmony import */ var _src_vector_render_engine_render_primitives_icon_icon_render_unit__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(115);
/* harmony import */ var _src_vector_render_engine_render_primitives_model_model_render_unit__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(121);
/* harmony import */ var _src_vector_render_engine_render_primitives_polyline_textured_polyline_render_unit__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(127);
/* harmony import */ var _src_vector_render_engine_render_primitives_polyline_polyline_render_unit__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(131);
/* harmony import */ var _src_vector_render_engine_render_primitives_polygon_textured_polygon_render_unit__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(135);
/* harmony import */ var _src_vector_render_engine_render_primitives_polygon_transparent_polygon_render_unit__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(138);
/* harmony import */ var _src_vector_render_engine_render_primitives_polygon_polygon_render_unit__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(139);
/* harmony import */ var _src_vector_render_engine_map_engine__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(142);
/* harmony import */ var _src_vector_render_engine_util_hd__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(48);
/* harmony import */ var _src_vector_render_engine_visibility_primitives_colliding_primitive_reset_removed_renderer__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(182);
/* harmony import */ var _src_vector_render_engine_render_loop__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(185);



















// import ImageRenderUnit from '../../src/vector_render_engine/render/primitives/image/image_render_unit';
// import RasterTilesAdapter from '../../src/vector_render_engine/adapters/raster_tiles/adapter';
// import {TileItem} from '../../src/vector_render_engine/adapters/tile_based_adapter/util/tile_system';
const GL_CONTEXT_ATTRIBS = {
    alpha: false,
    depth: true,
    stencil: false,
    antialias: false,
    failIfMajorPerformanceCaveat: true
};
const camera = new _src_vector_render_engine_camera__WEBPACK_IMPORTED_MODULE_1__["default"]({
    wrapModeX: 2 /* REPEAT */,
    wrapModeY: 0 /* NONE */
});
camera.onUpdate.addListener(() => Object(_camera_stuff__WEBPACK_IMPORTED_MODULE_3__["renderCameraState"])(camera));
camera.center.x = 0.20898437;
camera.center.y = 0.37304687;
camera.zoom = 14;
const canvas = document.querySelector('#canvas');
{
    const { width, height } = canvas.getBoundingClientRect();
    const dpr = Object(_src_vector_render_engine_util_hd__WEBPACK_IMPORTED_MODULE_16__["default"])();
    canvas.width = dpr * width;
    canvas.height = dpr * height;
    camera.screenSize.width = width;
    camera.screenSize.height = height;
}
const cameraMouseController = new _camera_stuff__WEBPACK_IMPORTED_MODULE_3__["CameraMouseController"](canvas, camera);
const mouseDragController = new _camera_stuff__WEBPACK_IMPORTED_MODULE_3__["MouseDragController"](canvas);
mouseDragController.setDelegate(cameraMouseController);
const scrollZoomController = new _camera_stuff__WEBPACK_IMPORTED_MODULE_3__["ScrollZoomController"](canvas);
scrollZoomController.setDelegate(cameraMouseController);
const context = _src_vector_render_engine_render_context__WEBPACK_IMPORTED_MODULE_0__["default"].createFromCanvas(canvas, GL_CONTEXT_ATTRIBS);
const engine = new _src_vector_render_engine_map_engine__WEBPACK_IMPORTED_MODULE_15__["default"](context, camera, new _src_vector_render_engine_render_loop__WEBPACK_IMPORTED_MODULE_18__["default"]());
const vectorAdapter = new _src_vector_render_engine_adapters_vector_api_adapter__WEBPACK_IMPORTED_MODULE_2__["default"](engine, camera, './tile_provider_worker.js?worker', 
// '/src/vector_render_engine/adapters/vector_api/worker/tile_provider_worker.js?worker',
'map', 
// {
//     tileUrlTemplate: 'https://vec-rdr01e.tst.maps.yandex.ru/vmap2/tiles?l=vmap2&lang=ru_RU&x={{x}}&y={{y}}&z={{z}}&zmin={{zmin}}&zmax={{zmax}}',
//     imageUrlTemplate: 'https://vec-rdr01e.tst.maps.yandex.ru/resources?id={{id}}&scale={{scale}}',
//     meshUrlTemplate: 'https://vec-rdr01e.tst.maps.yandex.ru/meshes?id={{id}}',
//     glyphRangeUrlTemplate: 'https://vec-rdr01e.tst.maps.yandex.ru/glyphs?lang=ru_RU&font_id={{fontId}}&range={{range}}'
// }
{
    tileUrlTemplate: 'https://vec0{{hostAlias}}.maps.yandex.net/vmap2/tiles?l=vmap2&lang=RU_ru&x={{x}}&y={{y}}&z={{z}}&zmin={{zmin}}&zmax={{zmax}}',
    imageUrlTemplate: 'https://vec0{{hostAlias}}.maps.yandex.net/resources?id={{id}}&scale={{scale}}',
    meshUrlTemplate: 'https://vec0{{hostAlias}}.maps.yandex.net/vmap2/meshes?id={{id}}',
    glyphRangeUrlTemplate: 'https://vec0{{hostAlias}}.maps.yandex.net/glyphs?lang=RU_ru&font_id={{fontId}}&range={{range}}'
}, 1 /* X4 */);
// class TrafficLayerAdapter extends RasterTilesAdapter {
//     public _getImageUrl(tile: TileItem): string {
//         return `https://jgo.maps.yandex.net/1.1/tiles?trf&l=trf,trfe&lang=ru_UA&x=${tile.x}&y=${tile.y}&z=${tile.zoom}&scale=${window.devicePixelRatio}&tm=${Math.floor(Date.now() / 1000)}`
//         // return `https://sat03.maps.yandex.net/tiles?l=sat&v=3.419.0&x=${tile.x}&y=${tile.y}&z=${tile.zoom}&scale=${window.devicePixelRatio}&lang=ru_UA`
//     }
// }
// const trafficAdapter = new TrafficLayerAdapter(
//     engine,
//     camera,
//     {width: 256 * window.devicePixelRatio, height: 256 * window.devicePixelRatio}
// );
engine.groundLayer.addRenderUnit(new _src_vector_render_engine_render_primitives_polygon_polygon_render_unit__WEBPACK_IMPORTED_MODULE_14__["default"](context, vectorAdapter.opaquePolygonsProvider));
engine.groundLayer.addRenderUnit(new _src_vector_render_engine_render_primitives_polygon_transparent_polygon_render_unit__WEBPACK_IMPORTED_MODULE_13__["default"](context, vectorAdapter.transparentPolygonsProvider));
engine.groundLayer.addRenderUnit(new _src_vector_render_engine_render_primitives_polygon_textured_polygon_render_unit__WEBPACK_IMPORTED_MODULE_12__["default"](context, vectorAdapter.texturedPolygonsProvider));
engine.groundLayer.addRenderUnit(new _src_vector_render_engine_render_primitives_polyline_polyline_render_unit__WEBPACK_IMPORTED_MODULE_11__["default"](context, camera, vectorAdapter.polylinesProvider));
engine.groundLayer.addRenderUnit(new _src_vector_render_engine_render_primitives_polyline_textured_polyline_render_unit__WEBPACK_IMPORTED_MODULE_10__["default"](context, camera, vectorAdapter.texturedPolylinesProvider));
engine.buildingsLayer.addRenderUnit(new _src_vector_render_engine_render_primitives_model_model_render_unit__WEBPACK_IMPORTED_MODULE_9__["default"](context, vectorAdapter.modelsProvider));
// engine.iconsLayer.addRenderUnit(new ImageRenderUnit(context, trafficAdapter.imagesProvider));
engine.iconsLayer.addRenderUnit(new _src_vector_render_engine_render_primitives_icon_icon_render_unit__WEBPACK_IMPORTED_MODULE_8__["default"](context, camera, vectorAdapter.iconsProvider));
engine.labelsLayer.addRenderUnit(new _src_vector_render_engine_render_primitives_label_curved_label_render_unit__WEBPACK_IMPORTED_MODULE_7__["default"](context, camera, engine.visbilityTextureProvider, vectorAdapter.curvedLabelsProvider));
engine.labelsLayer.addRenderUnit(new _src_vector_render_engine_render_primitives_label_point_label_render_unit__WEBPACK_IMPORTED_MODULE_6__["default"](context, camera, engine.visbilityTextureProvider, vectorAdapter.pointLabelsProvider));
engine.visibilityManager.registerCollidingPrimitives(vectorAdapter.curvedLabelsProvider, new _src_vector_render_engine_visibility_primitives_label_color_id_curved_label_renderer__WEBPACK_IMPORTED_MODULE_5__["default"](context, camera, vectorAdapter.curvedLabelsProvider), new _src_vector_render_engine_visibility_primitives_colliding_primitive_reset_removed_renderer__WEBPACK_IMPORTED_MODULE_17__["CollidingPrimitivesResetRemovedRenderer"](context, vectorAdapter.curvedLabelsProvider));
engine.visibilityManager.registerCollidingPrimitives(vectorAdapter.pointLabelsProvider, new _src_vector_render_engine_visibility_primitives_label_color_id_point_label_renderer__WEBPACK_IMPORTED_MODULE_4__["default"](context, camera, vectorAdapter.pointLabelsProvider), new _src_vector_render_engine_visibility_primitives_colliding_primitive_reset_removed_renderer__WEBPACK_IMPORTED_MODULE_17__["CollidingPrimitivesResetRemovedRenderer"](context, vectorAdapter.pointLabelsProvider));
document.getElementById('plus').addEventListener('click', () => {
    camera.zoom += 0.1;
});
document.getElementById('minus').addEventListener('click', () => {
    camera.zoom -= 0.1;
});
// setTimeout(() => {
//     console.log('Setting new tile url template');
//     vectorAdapter.setTileUrlTemplate('https://vec-rdr01e.tst.maps.yandex.ru/vmap2/tiles?l=vmap2&lang=ru_RU&x={{x}}&y={{y}}&z={{z}}&zmin={{zmin}}&zmax={{zmax}}');
// }, 4000);


/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultRenderTarget", function() { return DefaultRenderTarget; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RenderContext; });
/* harmony import */ var _attrib_mapping__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _gl_buffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var _gl_framebuffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6);
/* harmony import */ var _gl_program__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7);
/* harmony import */ var _gl_renderbuffer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(8);
/* harmony import */ var _capabilities__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(9);
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(10);
/* harmony import */ var _gl_texture__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(12);
/* harmony import */ var _gl_vao__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(13);
/* harmony import */ var _util_color__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(11);
/* harmony import */ var _util_event_emitter__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(14);











const QUAD_VERTEX_DATA = new Float32Array([
    // tslint:disable
    // x   y  u  v
    -1, -1, 0, 0,
    1, 1, 1, 1,
    -1, 1, 0, 1,
    -1, -1, 0, 0,
    1, -1, 1, 0,
    1, 1, 1, 1
    // tslint:enable
]);
const QUAD_ATTRIB_MAPPING = new _attrib_mapping__WEBPACK_IMPORTED_MODULE_0__["AttributeMapping"]([
    [
        0 /* POSITION */,
        {
            size: 2,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        4 /* UV */,
        {
            size: 2,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ]
]);
/**
 * Default render target of a WebGL context, which is canvas element of the
 * context.
 */
class DefaultRenderTarget {
    constructor(gl) {
        this.isClear = false;
        this._gl = gl;
    }
    bind() {
        const gl = this._gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }
    setSize(width, height) {
        const canvas = this._gl.canvas;
        canvas.width = width;
        canvas.height = height;
    }
    getWidth() {
        return this._gl.drawingBufferWidth;
    }
    getHeight() {
        return this._gl.drawingBufferHeight;
    }
    destroy() {
        // We can't destroy default render target, so do nothing.
        // TODO(dmikis) Throw an exception?
    }
}
/**
 * Wrapper around WebGL context. Serves to localize all GL calls to minimum set
 * of objects.
 */
class RenderContext {
    /**
     * Creates a new wrapper for a given WebGL context.
     *
     * @param gl The context to be wrapped.
     */
    constructor(gl) {
        this._gl = gl;
        this.onLoss = new _util_event_emitter__WEBPACK_IMPORTED_MODULE_10__["VoidEventEmitter"]();
        this._contextLostListener = (e) => {
            e.preventDefault();
            this.onLoss.fire();
        };
        gl.canvas.addEventListener('webglcontextlost', this._contextLostListener);
        this._capabilities = new _capabilities__WEBPACK_IMPORTED_MODULE_5__["default"](gl);
        const vaoExt = gl.getExtension('OES_vertex_array_object');
        if (!vaoExt) {
            throw new Error('OES_vertex_array_object is required.');
        }
        this._vaoExt = vaoExt;
        if (!gl.getExtension('OES_standard_derivatives')) {
            throw new Error('OES_standard_derivatives is required.');
        }
        const defaultRenderTarget = this._boundRenderTarget =
            this._defaultRenderTarget =
                new DefaultRenderTarget(gl);
        const boundState = this._boundRenderState = new _state__WEBPACK_IMPORTED_MODULE_6__["default"]();
        this._unpackPremultiplyAlpha = false;
        // Default viewport and scissor rectangle sizes are equal to the size of
        // the canvas of the WebGL context. But we have no way of knowing them in
        // RenderState's constructor. So we're fixing them here.
        boundState.scissorWidth = boundState.viewportWidth =
            defaultRenderTarget.getWidth();
        boundState.scissorHeight = boundState.viewportHeight =
            defaultRenderTarget.getHeight();
        const quadBuffer = this._quadVertexBuffer =
            new _gl_buffer__WEBPACK_IMPORTED_MODULE_1__["default"](gl, gl.ARRAY_BUFFER, gl.STATIC_DRAW);
        quadBuffer.bind();
        gl.bufferData(gl.ARRAY_BUFFER, QUAD_VERTEX_DATA, gl.STATIC_DRAW);
        this._quadVao = this.createVao(QUAD_ATTRIB_MAPPING, quadBuffer, null);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        this._boundProgram = null;
        this._boundVao = null;
        this._boundTextures = new Array(this._capabilities.getMaxCombinedTextureImageUnits());
        this._boundTextures.fill(null);
        this._boundTextureUnit = 0;
    }
    /**
     * Returns object to request capabilities of the context such as maximum
     * texture size or maximum number of uniform vectors allowed in shaders.
     */
    getCapabilities() {
        return this._capabilities;
    }
    /**
     * Creates a new framebuffer with given attachments.
     *
     * @param descriptor Object containing framebuffer attachments.
     * @returns Created framebuffer object.
     */
    createFramebuffer({ color, depth, stencil, depthStencil }) {
        // TODO Uncomment and put under debug flag (when implemented)
        // if (depthStencil && (depth || stencil)) {
        //     throw new Error(
        //         'Framebuffer can\'t have DEPTH_STENCIL and DEPTH or STENCIL ' +
        //             'attachment simultaneously.'
        //     );
        // }
        const gl = this._gl;
        let width = 0;
        let height = 0;
        if (color) {
            width = color.getWidth();
            height = color.getHeight();
        }
        else if (depth) {
            width = depth.getWidth();
            height = depth.getHeight();
        }
        else if (stencil) {
            width = stencil.getWidth();
            height = stencil.getHeight();
        }
        else if (depthStencil) {
            width = depthStencil.getWidth();
            height = depthStencil.getHeight();
        }
        const framebuffer = new _gl_framebuffer__WEBPACK_IMPORTED_MODULE_2__["default"](gl, width, height);
        this.bindRenderTarget(framebuffer);
        if (color) {
            color.attachToFramebuffer(gl.COLOR_ATTACHMENT0);
        }
        if (depth) {
            depth.attachToFramebuffer(gl.DEPTH_ATTACHMENT);
        }
        if (stencil) {
            stencil.attachToFramebuffer(gl.STENCIL_ATTACHMENT);
        }
        if (depthStencil) {
            depthStencil.attachToFramebuffer(gl.DEPTH_STENCIL_ATTACHMENT);
        }
        // TODO Uncomment and put under debug flag (when implemented)
        // switch (gl.checkFramebufferStatus(gl.FRAMEBUFFER)) {
        //     case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
        //         throw new Error('Framebuffer attachments are not renderable');
        //     case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
        //         throw new Error('Framebuffer attachments are not same size');
        //     case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
        //         throw new Error('Framebuffer has no attachments');
        //     case gl.FRAMEBUFFER_UNSUPPORTED:
        //         throw new Error('Framebuffer has unsupported attachment');
        // }
        return framebuffer;
    }
    /**
     * Allocates a new renderbuffer with given size and format.
     *
     * @param width Width of the renderbuffer.
     * @param height Height of the renderbuffer.
     * @param format Format of the renderbuffer.
     * @return The allocated renderbuffer.
     *
     */
    createRenderbuffer(width, height, format) {
        const gl = this._gl;
        const renderbuffer = new _gl_renderbuffer__WEBPACK_IMPORTED_MODULE_4__["default"](gl, width, height);
        renderbuffer.bind();
        gl.renderbufferStorage(gl.RENDERBUFFER, format, width, height);
        return renderbuffer;
    }
    /**
     * Allocates a new texture with given size, format, type and parameters and
     * fills it with zeroes.
     *
     * @param width Width of the texture.
     * @param height Height of the texture.
     * @param format Pixel format of the texture.
     * @param type Pixel type of the texture.
     * @param params Parameters of the texture.
     * @returns Newly allocated texture.
     */
    createEmpty2DTexture(width, height, format, type, params = _gl_texture__WEBPACK_IMPORTED_MODULE_7__["DEFAULT_TEXTURE_PARAMS"]) {
        const texture = new _gl_texture__WEBPACK_IMPORTED_MODULE_7__["default"](this._gl, width, height, format, type, params);
        return texture;
    }
    /**
     * Creates a new shader program. Uses cache, i.e. if a program with same
     * source string and options is already created, returns it.
     *
     * @param vertexShaderSource Source code of vertex shader of the program.
     * @param fragmentShaderSource Source code of fragment shader of the program.
     * @param options Options.
     * @returns Newly created program or one from the cache.
     */
    createProgram(vertexShaderSource, fragmentShaderSource, options) {
        return new _gl_program__WEBPACK_IMPORTED_MODULE_3__["default"](this._gl, vertexShaderSource, fragmentShaderSource, options);
    }
    createVertexBuffer(size, usage = 35044 /* STATIC_DRAW */) {
        return this._createBuffer(this._gl.ARRAY_BUFFER, size, usage);
    }
    createIndexBuffer(size, usage = 35044 /* STATIC_DRAW */) {
        return this._createBuffer(this._gl.ELEMENT_ARRAY_BUFFER, size, usage);
    }
    // TODO: check https://github.com/Microsoft/TypeScript/issues/24195 to update narrowed data type according
    uploadDataToBuffer(buffer, data, offset = 0) {
        buffer.bind();
        this._gl.bufferSubData(buffer.getTarget(), offset, data);
    }
    /**
     * Creates a new vertex array object in the context.
     *
     * @param attributeMapping Mapping of vertex attrbiutes for the VAO.
     * @param vertexBuffer Vertex buffer to be bound to the VAO.
     * @param indexBuffer Index buffer to be bound to the VAO.
     * @returns The new VAO.
     */
    createVao(attributeMapping, vertexBuffer, indexBuffer) {
        const gl = this._gl;
        const vao = new _gl_vao__WEBPACK_IMPORTED_MODULE_8__["default"](gl, this._vaoExt, attributeMapping);
        vao.bind();
        if (indexBuffer) {
            indexBuffer.bind();
        }
        else {
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        }
        vertexBuffer.bind();
        const vertexByteSize = attributeMapping.vertexByteSize;
        for (const [idx, pointer] of attributeMapping) {
            gl.enableVertexAttribArray(idx);
            gl.vertexAttribPointer(idx, pointer.size, pointer.type, pointer.normalized, vertexByteSize, pointer.offset);
        }
        this._vaoExt.bindVertexArrayOES(null);
        return vao;
    }
    /**
     * Sets new content of texture, provided data must be of length equal to "width * height" and its type
     * must correspond to texture's type {@see PixelType}.
     */
    setTextureData(texture, data) {
        const gl = this._gl;
        const width = texture.getWidth();
        const height = texture.getHeight();
        const format = texture.getFormat();
        const type = texture.getType();
        const params = texture.getParams();
        this._setTextureDataUnpackParams(params);
        this.bindTexture(texture);
        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, height, format, type, data);
        this._onTextureDataUpdated(texture);
    }
    /**
     * Sets new texture content from canvas element.
     */
    setTextureDataFromDomElement(texture, element) {
        const gl = this._gl;
        const format = texture.getFormat();
        const type = texture.getType();
        const params = texture.getParams();
        this._setTextureDataUnpackParams(params);
        this.bindTexture(texture);
        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, format, type, element);
        this._onTextureDataUpdated(texture);
    }
    /**
     * Returns default render target associated with canvas on which the WebGL
     * context operates.
     */
    getDefaultRenderTarget() {
        return this._defaultRenderTarget;
    }
    /**
     * Clears currently bound render target according to a mask.
     *
     * @param mask Bitwise OR of marks, i.e.
     *      `ClearMask.COLOR_BUFFER_BIT | ClearMask.DEPTH_BUFFER_BIT`.
     */
    clearCurrentTarget(mask) {
        if (mask) {
            this._gl.clear(mask);
            this._boundRenderTarget.isClear = true;
        }
    }
    /**
     * Binds a render target to the WebGL context if it's not already bound.
     *
     * @param target The render target to be bound.
     */
    bindRenderTarget(target) {
        if (this._boundRenderTarget !== target) {
            target.bind();
            this._boundRenderTarget = target;
        }
        // Target size could change even if target is already bound.
        // VECTOR-190
        this._setViewportState(new _state__WEBPACK_IMPORTED_MODULE_6__["default"]({
            viewportWidth: target.getWidth(),
            viewportHeight: target.getHeight()
        }));
    }
    /**
     * Binds a render state to the WebGL context with minimum amount of actual
     * state switching.
     *
     * @param state The state to be bound.
     */
    bindRenderState(state) {
        this._setColorBufferState(state);
        this._setBlendState(state);
        this._setCullFaceState(state);
        this._setFrontFaceState(state);
        this._setDepthTestState(state);
        this._setDitherState(state);
        this._setDrawBuffersState(state);
        this._setPolygonOffsetState(state);
        this._setAlphaToCoverageState(state);
        this._setSampleCoverageState(state);
        this._setStencilTestState(state);
        this._setScissorTestState(state);
        this._setViewportState(state);
    }
    /**
     * Binds a program to the WebGL context if it's not already bound.
     *
     * @param program The program to be bound.
     */
    bindProgram(program) {
        if (this._boundProgram !== program) {
            program.bind();
            this._boundProgram = program;
        }
    }
    /**
     * Binds a vertex array object to the context if it's not already bound.
     *
     * @param vao The vertex array object to bind. Passing `null` will unbind
     *      any currently bound VAO.
     */
    bindVao(vao) {
        if (this._boundVao !== vao) {
            if (vao) {
                vao.bind();
            }
            else {
                this._vaoExt.bindVertexArrayOES(null);
            }
            this._boundVao = vao;
        }
    }
    bindQuadVao() {
        this.bindVao(this._quadVao);
    }
    bindTextureUnit(unit) {
        const gl = this._gl;
        if (this._boundTextureUnit !== unit) {
            gl.activeTexture(gl.TEXTURE0 + unit);
            this._boundTextureUnit = unit;
        }
    }
    bindTexture(texture) {
        const boundUnit = this._boundTextureUnit;
        if (this._boundTextures[boundUnit] !== texture) {
            texture.bind();
            this._boundTextures[boundUnit] = texture;
        }
    }
    /**
     * Draws a quad to currently bound render target with currently bound render
     * state, program and uniform state.
     */
    drawQuad() {
        this.drawMesh(0, 6, 4 /* TRIANGLES */);
    }
    /**
     * Draws a mesh from currently bound to ARRAY_BUFFER buffer.
     *
     * @param offset Index of the vertex to start drawing from.
     * @param count Number of vertices to process.
     * @param primitiveType
     */
    drawMesh(offset, count, primitiveType = 4 /* TRIANGLES */) {
        this._gl.drawArrays(primitiveType, offset, count);
        this._boundRenderTarget.isClear = false;
    }
    /**
     * Draws a mesh to currently bound render target with currently bound render
     * state, program and uniform state.
     *
     * @param offset Offset of indices of the mesh in currently bound memory page.
     * @param indexCount Number of indices in the mesh.
     */
    drawIndexedMesh(offset, indexCount, primitiveType = 4 /* TRIANGLES */) {
        const gl = this._gl;
        gl.drawElements(primitiveType, indexCount, gl.UNSIGNED_SHORT, offset);
        this._boundRenderTarget.isClear = false;
    }
    /**
     * Destroys the context and resources owned by it. Note that resources that
     * were created with `create*` method of the context aren't exactly belong
     * to the context, entities that created them have to destroy them.
     */
    destroy() {
        this._quadVao.destroy();
        this._quadVertexBuffer.destroy();
        this._gl.canvas.removeEventListener('webglcontextlost', this._contextLostListener);
    }
    /**
     * Creates a new context from a canvas.
     *
     * @throws An error if fails to create `webgl` context for the canvas.
     * @param canvas The canvas.
     * @param attribs Attributes of the context.
     */
    static createFromCanvas(canvas, attribs) {
        const gl = canvas.getContext('webgl', attribs);
        if (!gl) {
            throw new Error('Failed to create GL context from canvas.');
        }
        return new RenderContext(gl);
    }
    /**
     * Enables or disables a WebGL capability.
     * @see https://www.khronos.org/registry/OpenGL-Refpages/es2.0/xhtml/glEnable.xml
     *
     * @param capability The capability to be enabled of disabled.
     * @param enabled New state of the capability;
     */
    _setCapabilityEnabled(capability, enabled) {
        if (enabled) {
            this._gl.enable(capability);
        }
        else {
            this._gl.disable(capability);
        }
    }
    /**
     * Sets new clear color and color mask from a state if they're different from
     * currently set ones.
     *
     * @param state The state that contains new clear color and color masks.
     */
    _setColorBufferState(state) {
        const gl = this._gl;
        const boundState = this._boundRenderState;
        const newClearColor = state.clearColor;
        if (!_util_color__WEBPACK_IMPORTED_MODULE_9__["areEqual"](boundState.clearColor, newClearColor)) {
            gl.clearColor(newClearColor.r, newClearColor.g, newClearColor.b, newClearColor.a);
            _util_color__WEBPACK_IMPORTED_MODULE_9__["copy"](newClearColor, boundState.clearColor);
        }
        if (boundState.colorMaskR !== state.colorMaskR ||
            boundState.colorMaskG !== state.colorMaskG ||
            boundState.colorMaskB !== state.colorMaskB ||
            boundState.colorMaskAlpha !== state.colorMaskAlpha) {
            this._gl.colorMask(state.colorMaskR, state.colorMaskG, state.colorMaskB, state.colorMaskAlpha);
            boundState.colorMaskR = state.colorMaskR;
            boundState.colorMaskG = state.colorMaskG;
            boundState.colorMaskB = state.colorMaskB;
            boundState.colorMaskAlpha = state.colorMaskAlpha;
        }
    }
    /**
     * Sets blend state and params.
     *
     * @param state The state that contains new blend params.
     */
    _setBlendState(state) {
        const gl = this._gl;
        const boundState = this._boundRenderState;
        if (boundState.blend !== state.blend) {
            this._setCapabilityEnabled(gl.BLEND, state.blend);
            boundState.blend = state.blend;
        }
        if (state.blend) {
            if (boundState.blendEquationRgb !== state.blendEquationRgb ||
                boundState.blendEquationAlpha !== state.blendEquationAlpha) {
                gl.blendEquationSeparate(state.blendEquationRgb, state.blendEquationAlpha);
                boundState.blendEquationRgb = state.blendEquationRgb;
                boundState.blendEquationAlpha = state.blendEquationAlpha;
            }
            if (boundState.blendFuncDstRgb !== state.blendFuncDstRgb ||
                boundState.blendFuncSrcRgb !== state.blendFuncSrcRgb ||
                boundState.blendFuncDstAlpha !== state.blendFuncDstAlpha ||
                boundState.blendFuncSrcAlpha !== state.blendFuncSrcAlpha) {
                gl.blendFuncSeparate(state.blendFuncSrcRgb, state.blendFuncDstRgb, state.blendFuncSrcAlpha, state.blendFuncDstAlpha);
                boundState.blendFuncSrcRgb = state.blendFuncSrcRgb;
                boundState.blendFuncDstRgb = state.blendFuncDstRgb;
                boundState.blendFuncSrcAlpha = state.blendFuncSrcAlpha;
                boundState.blendFuncDstAlpha = state.blendFuncDstAlpha;
            }
        }
    }
    /**
     * Sets cull face state and params.
     *
     * @param state The state that contains new cull face state and mode.
     */
    _setCullFaceState(state) {
        const gl = this._gl;
        const boundState = this._boundRenderState;
        if (boundState.cullFace !== state.cullFace) {
            this._setCapabilityEnabled(gl.CULL_FACE, state.cullFace);
            boundState.cullFace = state.cullFace;
        }
        if (state.cullFace &&
            boundState.cullFaceMode !== state.cullFaceMode) {
            gl.cullFace(state.cullFaceMode);
            boundState.cullFaceMode = state.cullFaceMode;
        }
    }
    /**
     * Sets front face mode.
     *
     * @param state The state that contains new front face mode.
     */
    _setFrontFaceState(state) {
        const boundState = this._boundRenderState;
        if (boundState.frontFaceMode !== state.frontFaceMode) {
            this._gl.frontFace(state.frontFaceMode);
            boundState.frontFaceMode = state.frontFaceMode;
        }
    }
    /**
     * Sets depth test state and params.
     *
     * @param state The state that contains new depth test state and params.
     */
    _setDepthTestState(state) {
        const gl = this._gl;
        const boundState = this._boundRenderState;
        if (boundState.depthTest !== state.depthTest) {
            this._setCapabilityEnabled(gl.DEPTH_TEST, state.depthTest);
            boundState.depthTest = state.depthTest;
        }
        if (state.depthTest) {
            if (boundState.clearDepth !== state.clearDepth) {
                gl.clearDepth(state.clearDepth);
                boundState.clearDepth = state.clearDepth;
            }
            if (boundState.depthMask !== state.depthMask) {
                gl.depthMask(state.depthMask);
                boundState.depthMask = state.depthMask;
            }
            if (boundState.depthFunc !== state.depthFunc) {
                gl.depthFunc(state.depthFunc);
                boundState.depthFunc = state.depthFunc;
            }
            if (boundState.depthRangeNear !== state.depthRangeNear ||
                boundState.depthRangeFar !== state.depthRangeFar) {
                gl.depthRange(state.depthRangeNear, state.depthRangeFar);
                boundState.depthRangeNear = state.depthRangeNear;
                boundState.depthRangeFar = state.depthRangeFar;
            }
        }
    }
    /**
     * Sets dither state.
     *
     * @param state The state that contains new dither state.
     */
    _setDitherState(state) {
        const boundState = this._boundRenderState;
        if (boundState.dither !== state.dither) {
            this._setCapabilityEnabled(this._gl.DITHER, state.dither);
            boundState.dither = state.dither;
        }
    }
    /**
     * Sets draw buffers.
     *
     * @param state The state that contains array of draw buffers.
     */
    _setDrawBuffersState(state) {
        const boundDrawBuffers = this._boundRenderState.drawBuffers;
        if (boundDrawBuffers.length !== state.drawBuffers.length ||
            boundDrawBuffers
                .some((attachment, i) => attachment !== state.drawBuffers[i])) {
            this._boundRenderState.drawBuffers = state.drawBuffers.slice();
        }
    }
    /**
     * Sets polygon offset state and params.
     *
     * @param state The state that contains new polygon offset state and params.
     */
    _setPolygonOffsetState(state) {
        const gl = this._gl;
        const boundState = this._boundRenderState;
        if (boundState.polygonOffset !== state.polygonOffset) {
            this._setCapabilityEnabled(gl.POLYGON_OFFSET_FILL, state.polygonOffset);
            boundState.polygonOffset = state.polygonOffset;
        }
        if (state.polygonOffset &&
            (boundState.polygonOffsetFactor !== state.polygonOffsetFactor ||
                boundState.polygonOffsetUnits !== state.polygonOffsetUnits)) {
            gl.polygonOffset(state.polygonOffsetFactor, state.polygonOffsetUnits);
            boundState.polygonOffsetFactor = state.polygonOffsetFactor;
            boundState.polygonOffsetUnits = state.polygonOffsetUnits;
        }
    }
    /**
     * Sets alpha-to-coverage state.
     *
     * @param state The state that contains new alpha-to-coverage state.
     */
    _setAlphaToCoverageState(state) {
        const boundState = this._boundRenderState;
        if (boundState.sampleAlphaToCoverage !== state.sampleAlphaToCoverage) {
            this._setCapabilityEnabled(this._gl.SAMPLE_ALPHA_TO_COVERAGE, state.sampleAlphaToCoverage);
            boundState.sampleAlphaToCoverage = state.sampleAlphaToCoverage;
        }
    }
    /**
     * Sets sample coverage state.
     *
     * @param state The state that contains new sample coverage state and params.
     */
    _setSampleCoverageState(state) {
        const gl = this._gl;
        const boundState = this._boundRenderState;
        if (boundState.sampleCoverage !== state.sampleCoverage) {
            this._setCapabilityEnabled(gl.SAMPLE_COVERAGE, state.sampleCoverage);
            boundState.sampleCoverage = state.sampleCoverage;
        }
        if (state.sampleCoverage &&
            (boundState.sampleCoverageValue !== state.sampleCoverageValue ||
                boundState.sampleCoverageInvert !== state.sampleCoverageInvert)) {
            gl.sampleCoverage(state.sampleCoverageValue, state.sampleCoverageInvert);
            boundState.sampleCoverageValue = state.sampleCoverageValue;
            boundState.sampleCoverageInvert = state.sampleCoverageInvert;
        }
    }
    /**
     * Sets stencil test state and params.
     *
     * @param state The state that contains new stencil test state and params.
     */
    _setStencilTestState(state) {
        const gl = this._gl;
        const boundState = this._boundRenderState;
        if (boundState.stencilTest !== state.stencilTest) {
            this._setCapabilityEnabled(gl.STENCIL_TEST, state.stencilTest);
            boundState.stencilTest = state.stencilTest;
        }
        if (state.stencilTest) {
            if (boundState.clearStencil !== state.clearStencil) {
                gl.clearStencil(state.clearStencil);
                boundState.clearStencil = state.clearStencil;
            }
            if (boundState.stencilWriteMask !== state.stencilWriteMask) {
                gl.stencilMask(state.stencilWriteMask);
                boundState.stencilWriteMask = state.stencilWriteMask;
            }
            const refOrMaskIsDifferent = (boundState.stencilMask !== state.stencilMask ||
                boundState.stencilReference !== state.stencilReference);
            if (refOrMaskIsDifferent) {
                boundState.stencilMask = state.stencilMask;
                boundState.stencilReference = state.stencilReference;
            }
            if (boundState.stencilFrontFunc !== state.stencilFrontFunc ||
                refOrMaskIsDifferent) {
                gl.stencilFuncSeparate(gl.FRONT, state.stencilFrontFunc, state.stencilReference, state.stencilMask);
                boundState.stencilFrontFunc = state.stencilFrontFunc;
            }
            if (boundState.stencilBackFunc !== state.stencilBackFunc ||
                refOrMaskIsDifferent) {
                gl.stencilFuncSeparate(gl.BACK, state.stencilBackFunc, state.stencilReference, state.stencilMask);
                boundState.stencilBackFunc = state.stencilBackFunc;
            }
            if (boundState.stencilFrontFailOp !== state.stencilFrontFailOp ||
                boundState.stencilFrontDepthFailOp !== state.stencilFrontDepthFailOp ||
                boundState.stencilFrontDepthPassOp !== state.stencilFrontDepthPassOp) {
                gl.stencilOpSeparate(gl.FRONT, state.stencilFrontFailOp, state.stencilFrontDepthFailOp, state.stencilFrontDepthPassOp);
                boundState.stencilFrontFailOp = state.stencilFrontFailOp;
                boundState.stencilFrontDepthFailOp = state.stencilFrontDepthFailOp;
                boundState.stencilFrontDepthPassOp = state.stencilFrontDepthPassOp;
            }
            if (boundState.stencilBackFailOp !== state.stencilBackFailOp ||
                boundState.stencilBackDepthFailOp !== state.stencilBackDepthFailOp ||
                boundState.stencilBackDepthPassOp !== state.stencilBackDepthPassOp) {
                gl.stencilOpSeparate(gl.BACK, state.stencilBackFailOp, state.stencilBackDepthFailOp, state.stencilBackDepthPassOp);
                boundState.stencilBackFailOp = state.stencilBackFailOp;
                boundState.stencilBackDepthFailOp = state.stencilBackDepthFailOp;
                boundState.stencilBackDepthPassOp = state.stencilBackDepthPassOp;
            }
        }
    }
    /**
     * Sets scissor test state and scissor rectangle.
     *
     * @param state The state that contains new scissor test state and scissor
     *      rectangle.
     */
    _setScissorTestState(state) {
        const gl = this._gl;
        const boundState = this._boundRenderState;
        if (boundState.scissorTest !== state.scissorTest) {
            this._setCapabilityEnabled(gl.SCISSOR_TEST, state.scissorTest);
            boundState.scissorTest = state.scissorTest;
        }
        if (state.scissorTest &&
            state.scissorWidth >= 0 &&
            state.scissorHeight >= 0 &&
            (boundState.scissorX !== state.scissorX ||
                boundState.scissorY !== state.scissorY ||
                boundState.scissorWidth !== state.scissorWidth ||
                boundState.scissorHeight !== state.scissorHeight)) {
            gl.scissor(state.scissorX, state.scissorY, state.scissorWidth, state.scissorHeight);
            boundState.scissorX = state.scissorX;
            boundState.scissorY = state.scissorY;
            boundState.scissorWidth = state.scissorWidth;
            boundState.scissorHeight = state.scissorHeight;
        }
    }
    /**
     * Sets viewport.
     *
     * @param state The state that contains new viewport.
     */
    _setViewportState(state) {
        const boundState = this._boundRenderState;
        if (state.viewportWidth >= 0 &&
            state.viewportHeight >= 0 &&
            (boundState.viewportX !== state.viewportX ||
                boundState.viewportY !== state.viewportY ||
                boundState.viewportWidth !== state.viewportWidth ||
                boundState.viewportHeight !== state.viewportHeight)) {
            this._gl.viewport(state.viewportX, state.viewportY, state.viewportWidth, state.viewportHeight);
            boundState.viewportX = state.viewportX;
            boundState.viewportY = state.viewportY;
            boundState.viewportWidth = state.viewportWidth;
            boundState.viewportHeight = state.viewportHeight;
        }
    }
    /**
     * Sets texture data unpack params.
     *
     * @param params Texture params to be set.
     */
    _setTextureDataUnpackParams(params) {
        const gl = this._gl;
        if (this._unpackPremultiplyAlpha !== params.premultipliedAlpha) {
            gl.pixelStorei(37441 /* UNPACK_PREMULTIPLY_ALPHA_WEBGL */, +params.premultipliedAlpha);
            this._unpackPremultiplyAlpha = params.premultipliedAlpha;
        }
    }
    _onTextureDataUpdated(texture) {
        const gl = this._gl;
        const params = texture.getParams();
        if (params.minificationFilter >= 9984 /* NEAREST_MIPMAP_NEAREST */) {
            gl.generateMipmap(gl.TEXTURE_2D);
        }
    }
    /**
     * Creates a new zeroed buffer with a given size and a target.
     *
     * @param target The target of the new buffer, `ARRAY_BUFFER` or
     *      `ELEMENT_ARRAY_BUFFER`.
     * @param size The size of the buffer.
     * @param usage Usage of the buffer.
     * @returns The buffer.
     */
    _createBuffer(target, size, usage = this._gl.STATIC_DRAW) {
        const gl = this._gl;
        const buffer = new _gl_buffer__WEBPACK_IMPORTED_MODULE_1__["default"](gl, target, size);
        // TODO(dmikis) a cleverer way not to break currently bound VAO;
        this.bindVao(null);
        buffer.bind();
        gl.bufferData(target, size, usage);
        return buffer;
    }
}


/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AttributeMapping", function() { return AttributeMapping; });
/* harmony import */ var _util_iterable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _util_pow_of_2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4);


/**
 * Gives size of a GL type.
 *
 * @param type The type.
 * @returns Size of the type in bytes.
 */
function getTypeSize(type) {
    switch (type) {
        case 5120 /* BYTE */:
        case 5121 /* UNSIGNED_BYTE */:
            return 1;
        case 5122 /* SHORT */:
        case 5123 /* UNSIGNED_SHORT */:
            return 2;
        case 5124 /* INT */:
        case 5125 /* UNSIGNED_INT */:
        case 5126 /* FLOAT */:
            return 4;
    }
}
/**
 * Description of how particular attributes of a vertex are packed into a vertex
 * buffer.
 */
class AttributeMapping extends Map {
    /**
     * Creates a new attribute mapping with a set of attributes of given types and
     * sizes. Automatically computes offsets of the attributes.
     *
     * @param mapping The mapping from attribute IDs to types and sizes.
     * @param alignment Desired alignment of attributes in the vertex data
     *      structure. Must be a power of 2.
     */
    constructor(mapping, alignment = 4 /* ALIGN_4_BYTES */) {
        let offset = 0;
        super(Object(_util_iterable__WEBPACK_IMPORTED_MODULE_0__["mapIterable"])(mapping, ([idx, { type, size, normalized }]) => {
            const pointer = [
                idx,
                {
                    type,
                    size,
                    normalized,
                    offset
                }
            ];
            const attributeSize = size * getTypeSize(type);
            const newOffset = Object(_util_pow_of_2__WEBPACK_IMPORTED_MODULE_1__["align"])(offset + attributeSize, -alignment);
            // TODO(dmikis) Check this in debug mode.
            // if (newOffset - offset > attributeSize) {
            //    console.warn(`${newOffset - offset} byte padding's inserted`);
            // }
            offset = newOffset;
            return pointer;
        }));
        this.vertexByteSize = offset;
    }
}


/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findInIterable", function() { return findInIterable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mapIterable", function() { return mapIterable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "filterIterable", function() { return filterIterable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reduceIterable", function() { return reduceIterable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "oneOfIterable", function() { return oneOfIterable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "allOfIterable", function() { return allOfIterable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rangeIterable", function() { return rangeIterable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zipIterables", function() { return zipIterables; });
/**
 * Searches for the first collection item satisfying a predicate.
 *
 * @param collection The collection.
 * @param predicate The predicate.
 * @returns The first item satisfying the predicate or `undefined` if none found.
 */
function findInIterable(collection, predicate) {
    for (const item of collection) {
        if (predicate(item)) {
            return item;
        }
    }
    return;
}
/**
 * Transforms a collection to another one.
 *
 * @param collection The source collection.
 * @param mapper A function producing items for destination collection.
 * @returns Collection of produced items.
 */
function* mapIterable(collection, mapper) {
    for (const item of collection) {
        yield mapper(item);
    }
}
/**
 * Chooses items of a collection satisfying a predicate.
 *
 * @param collection The collection.
 * @param predicate The predicate.
 * @returns Collection of chosen items.
 */
function* filterIterable(collection, predicate) {
    for (const item of collection) {
        if (predicate(item)) {
            yield item;
        }
    }
}
/**
 * Traverses a collection from left to right recomputing an accumulator on every
 * iteration.
 *
 * @param collection The collection.
 * @param reducer The function used to compute next value of the accumulator.
 * @param initial
 * @returns Value of the accumulator.
 */
function reduceIterable(collection, reducer, initial) {
    let result = initial;
    for (const item of collection) {
        result = reducer(result, item);
    }
    return result;
}
/**
 * Checks if there's at least one item in a collection satisfying a predicate.
 *
 * @param collection The collection.
 * @param predicate The predicate.
 * @returns `true` if for at least one item in the collection the predicate returns
 *      `true` and `false` otherwise.
 */
function oneOfIterable(collection, predicate) {
    for (const item of collection) {
        if (predicate(item)) {
            return true;
        }
    }
    return false;
}
/**
 * Checks if all items of a collection satisfy a predicate.
 *
 * @param collection The collection.
 * @param predicate The predicate.
 * @returns `false` if for at least one item in the collection the predicate returns
 *      `false` and `true` otherwise.
 */
function allOfIterable(collection, predicate) {
    for (const item of collection) {
        if (!predicate(item)) {
            return false;
        }
    }
    return true;
}
/**
 * Creates an iterator for [startIndex, startIndex+length) range.
 */
function* rangeIterable(length, startIndex = 0) {
    const endIndex = startIndex + length;
    for (let i = startIndex; i < endIndex; i++) {
        yield i;
    }
}
function* zipIterables(ts, us, zipper = (t, u) => [t, u]) {
    const tIterator = ts[Symbol.iterator]();
    const uIterator = us[Symbol.iterator]();
    for (let t = tIterator.next(), u = uIterator.next(); !(t.done || u.done); t = tIterator.next(), u = uIterator.next()) {
        yield zipper(t.value, u.value);
    }
}


/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isPowOf2", function() { return isPowOf2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "align", function() { return align; });
/**
 * Checks if a number is a power of 2.
 *
 * @param x The number to check.
 * @returns `true` if the number is an integer power of 2 and `false` otherwise.
 */
function isPowOf2(x) {
    return x > 0 && !(x & (x - 1));
}
/**
 * Aligns an offset by an alignment given by a mask.
 *
 * @param offset The offset.
 * @param alignmentMask The alignment mask — a bit field that has `log2(alignment)`
 *      of least significant bits unset and other set, e.g. if `alignment` is 4
 *      then the `alignmentMask` will be `0xffffffc`
 * @returns Aligned offset.
 */
function align(offset, alignmentMask) {
    return (offset - 1 & alignmentMask) - alignmentMask;
}


/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Buffer; });
/** Wrapper around WebGLBuffer object. */
class Buffer {
    /**
     * Creates a new empty buffer in a WebGL context.
     *
     * @param gl The context the buffer will be created in.
     * @param target Binding target of the buffer. Since in WebGL once you've
     *      bound a buffer to a given target you can't bind it any other one,
     *      we "tie" the buffer and it's binding point together.
     * @param size Size of the buffer. We don't do actual allocation in the
     *      wrapper, it's context's responsibility. But it's convenient to be
     *      able to get the size from the wrapper object.
     */
    constructor(gl, target, size) {
        this._gl = gl;
        this._target = target;
        this._handle = gl.createBuffer();
        this._size = size;
    }
    /** Binds the buffer to the context to its binding target. */
    bind() {
        this._gl.bindBuffer(this._target, this._handle);
    }
    /**
     * Returns `true` if the buffer is currently bound to the context to its
     * binding target and `false` otherwise.
     */
    isBound() {
        const gl = this._gl;
        const handle = this._handle;
        switch (this._target) {
            case gl.ARRAY_BUFFER:
                return gl.getParameter(gl.ARRAY_BUFFER_BINDING) === handle;
            case gl.ELEMENT_ARRAY_BUFFER:
                return gl.getParameter(gl.ELEMENT_ARRAY_BUFFER_BINDING) === handle;
        }
        return false;
    }
    /** Returns binding target of the buffer. */
    getTarget() {
        return this._target;
    }
    /** Returns size of the buffer. */
    getSize() {
        return this._size;
    }
    /**
     * Destroys the buffer.
     */
    destroy() {
        this._gl.deleteBuffer(this._handle);
    }
}


/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Framebuffer; });
/** Wrapper around WebGLFramebuffer object. */
class Framebuffer {
    /**
     * Creates a new framebuffer in a WebGL context.
     *
     * @param gl The context the framebuffer will be created in.
     * @param width Width of the framebuffer.
     * @param height Height of the framebuffer.
     */
    constructor(gl, width, height) {
        this.isClear = false;
        this._gl = gl;
        this._handle = gl.createFramebuffer();
        this._width = width;
        this._height = height;
    }
    /**
     * Binds the framebuffer to the WebGL context.
     */
    bind() {
        const gl = this._gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._handle);
    }
    /**
     * Checks if the framebuffer is bound to the WebGL context.
     *
     * @returns `true` if the framebuffer is currently bound to the WebGL context
     *      and `false` otherwise.
     */
    isBound() {
        const gl = this._gl;
        return gl.getParameter(gl.FRAMEBUFFER_BINDING) === this._handle;
    }
    /**
     * Returns width of the framebuffer.
     */
    getWidth() {
        return this._width;
    }
    /**
     * Returns height of the framebuffer.
     */
    getHeight() {
        return this._height;
    }
    /**
     * Reads content of the color attachment as an RGBA bitmap.
     */
    readPixels() {
        const data = new Uint8Array(this.getWidth() * this.getHeight() * 4);
        this._gl.readPixels(0, 0, this._width, this._height, 6408 /* RGBA */, 5121 /* UNSIGNED_BYTE */, data);
        return data;
    }
    /**
     * Destroys the framebuffer.
     */
    destroy() {
        this._gl.deleteFramebuffer(this._handle);
    }
}


/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Program; });
/**
 * Inserts given parameters as preprocessor define directives into shader source.
 *
 * @param source Shader source.
 * @param defines Dictionary with parameters to define with preprocessor directives.
 * @returns Shader source with preprocessor directives inserted.
 */
function insertDefines(source, defines) {
    const definesString = Object.keys(defines)
        .map((defineName) => '#define ' + defineName + ' ' +
        defines[defineName])
        .join('\n');
    const versionIdx = source.indexOf('#version');
    if (versionIdx === -1) {
        return definesString + '\n' + source;
    }
    const nextLineIdx = source.indexOf('\n', versionIdx) + 1;
    return source.slice(0, nextLineIdx) + definesString + '\n' +
        source.slice(nextLineIdx);
}
/**
 * Creates a new shader of a given type out of a given source string.
 *
 * @param gl WebGL context the shader will be created in.
 * @param type The type of the shader, VERTEX_SHADER or FRAGMENT_SHADER.
 * @param source The source string.
 * @throws An error if compilation of the shader fails.
 * @returns The shader WebGL handle.
 */
function compileShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    // TODO Uncomment and put under debug flag (when implemented)
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        throw new Error('Failed to compile shader:\n' + gl.getShaderInfoLog(shader));
    }
    return shader;
}
/** Wrapper around WebGLProgram objects. */
class Program {
    /**
     * Constructs a new program.
     *
     * @param gl WebGL context the program will be created in.
     * @param vertexShaderSource Source code of vertex shader of the program.
     * @param fragmentShaderSource Source code of fragment shader of the program.
     * @param options Options.
     * @throws An error if shader compilation or program linking fails.
     */
    constructor(gl, vertexShaderSource, fragmentShaderSource, options) {
        this._gl = gl;
        const handle = this._handle = gl.createProgram();
        if (options && options.defines) {
            vertexShaderSource = insertDefines(vertexShaderSource, options.defines);
            fragmentShaderSource = insertDefines(fragmentShaderSource, options.defines);
        }
        const vertexShader = compileShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        gl.attachShader(handle, vertexShader);
        gl.attachShader(handle, fragmentShader);
        gl.deleteShader(vertexShader);
        gl.deleteShader(fragmentShader);
        if (options && options.attribMap) {
            Object.keys(options.attribMap)
                .forEach((attributeName) => gl.bindAttribLocation(handle, options.attribMap[attributeName], attributeName));
        }
        gl.linkProgram(handle);
        // TODO Uncomment and put under debug flag (when implemented)
        if (!gl.getProgramParameter(handle, gl.LINK_STATUS)) {
            throw new Error(`Failed to link program:\n${gl.getProgramInfoLog(handle)}`);
        }
        this._uniformCache = new Map();
    }
    /**
     * Binds the program to the WebGL context.
     */
    bind() {
        const gl = this._gl;
        const handle = this._handle;
        // TODO Uncomment and put under debug flag (when implemented)
        // gl.validateProgram(handle);
        // if (!gl.getProgramParameter(handle, gl.VALIDATE_STATUS)) {
        //     throw new Error(
        //         'Failed to validate program:\n' + gl.getProgramInfoLog(handle)
        //     );
        // }
        gl.useProgram(handle);
    }
    /**
     * Checks if the program is bound to the WebGL context.
     *
     * @returns `true` if the program if currently bound to the WebGL context and
     *      `false` otherwise.
     */
    isBound() {
        const gl = this._gl;
        return gl.getParameter(gl.CURRENT_PROGRAM) === this._handle;
    }
    /**
     * Sets an integer scalar value to a uniform. If there's no uniform with
     * given name in the program, silently does nothing.
     *
     * @param uniformName Name of the uniform.
     * @param value The scalar value.
     */
    setIntScalarUniform(uniformName, value) {
        const location = this._getUniformLocation(uniformName);
        if (location) {
            this._gl.uniform1i(location, value);
        }
    }
    /**
     * Sets a scalar value to a uniform. If there's no uniform with
     * given name in the program, silently does nothing.
     *
     * @param uniformName Name of the uniform.
     * @param value The scalar value.
     */
    setScalarUniform(uniformName, value) {
        const location = this._getUniformLocation(uniformName);
        if (location) {
            this._gl.uniform1f(location, value);
        }
    }
    /**
     * Sets a 2D vector to a uniform. If there's no uniform with given name in
     * the program, silently does nothing.
     *
     * @param uniformName Name of the uniform.
     * @param value The vector.
     */
    setVector2Uniform(uniformName, value) {
        const location = this._getUniformLocation(uniformName);
        if (location) {
            this._gl.uniform2f(location, value.x, value.y);
        }
    }
    /**
     * Sets a 3D vector to a uniform. If there's no uniform with given name in
     * the program, silently does nothing.
     *
     * @param uniformName Name of the uniform.
     * @param value The vector.
     */
    setVector3Uniform(uniformName, value) {
        const location = this._getUniformLocation(uniformName);
        if (location) {
            this._gl.uniform3f(location, value.x, value.y, value.z);
        }
    }
    /**
     * Sets a 4D vector to a uniform. If there's no uniform with given name in
     * the program, silently does nothing.
     *
     * @param uniformName Name of the uniform.
     * @param value The vector.
     */
    setVector4Uniform(uniformName, value) {
        const location = this._getUniformLocation(uniformName);
        if (location) {
            this._gl.uniform4f(location, value.x, value.y, value.z, value.w);
        }
    }
    /**
     * Sets a color to a uniform. If there's no uniform with given name in the
     * program, silently does nothing.
     *
     * @param uniformName Name of the uniform.
     * @param value The color.
     */
    setColorUniform(uniformName, value) {
        const location = this._getUniformLocation(uniformName);
        if (location) {
            this._gl.uniform4f(location, value.r, value.g, value.b, value.a);
        }
    }
    /**
     * Sets a 3x3 matrix to a uniform. If there's no uniform with given name in
     * the program, silently does nothing.
     *
     * @param uniformName Name of the uniform.
     * @param value The matrix.
     */
    setMatrix3Uniform(uniformName, value) {
        const location = this._getUniformLocation(uniformName);
        if (location) {
            this._gl.uniformMatrix3fv(location, false, value);
        }
    }
    /**
     * Sets a 4x4 matrix to a uniform. If there's no uniform with given name in
     * the program, silently does nothing.
     *
     * @param uniformName Name of the uniform.
     * @param value The matrix.
     */
    setMatrix4Uniform(uniformName, value) {
        const location = this._getUniformLocation(uniformName);
        if (location) {
            this._gl.uniformMatrix4fv(location, false, value);
        }
    }
    /**
     * Destroys the program.
     */
    destroy() {
        this._gl.deleteProgram(this._handle);
    }
    _getUniformLocation(name) {
        const cache = this._uniformCache;
        let location = cache.get(name);
        if (!location) {
            location = this._gl.getUniformLocation(this._handle, name);
            if (!location) {
                // TODO Uncomment and put under debug flag (when implemented)
                // console.warn(`Uniform ${name} doesn't exist in program.`);
                return null;
            }
            cache.set(name, location);
        }
        return location;
    }
}


/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Renderbuffer; });
/** Wrapper around WebGLRenderbuffer objects. */
class Renderbuffer {
    /**
     * Creates a new renderbuffer in a WebGL context.
     *
     * @param gl The context the renderbuffer will be created in.
     */
    constructor(gl, width, height) {
        this._gl = gl;
        this._handle = gl.createRenderbuffer();
        this._width = width;
        this._height = height;
    }
    /**
     * Binds the renderbuffer to the WebGL context.
     */
    bind() {
        const gl = this._gl;
        gl.bindRenderbuffer(gl.RENDERBUFFER, this._handle);
    }
    /**
     * Checks if the renderbuffer is bound to the WebGL context.
     *
     * @returns `true` if the renderbuffer is currently bound to the WebGL context
     *      and `false` otherwise.
     */
    isBound() {
        const gl = this._gl;
        return gl.getParameter(gl.RENDERBUFFER_BINDING) === this._handle;
    }
    /**
     * Attaches the renderbuffer to a currently bound to the WebGL context
     * framebuffer.
     *
     * @param attachmentPoint Attachment point the renderbuffer will be attached
     *      to.
     */
    attachToFramebuffer(attachmentPoint) {
        const gl = this._gl;
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachmentPoint, gl.RENDERBUFFER, this._handle);
    }
    getWidth() {
        return this._width;
    }
    getHeight() {
        return this._height;
    }
    /**
     * Destroys the renderbuffer.
     */
    destroy() {
        this._gl.deleteRenderbuffer(this._handle);
    }
}


/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RenderContextCapabilitiesManager; });
// tslint:disable
/*
    This is automatically generated by /tools/gl_gen/gen_capabilities.js script.
    Instead of modifying it edit the script and regenerate this file.
*/
class RenderContextCapabilitiesManager {
    constructor(gl) {
        this._gl = gl;
        this._paramValues = new Map();
    }
    getAliasedLineWidthRange() { return this._getParam(33902 /* ALIASED_LINE_WIDTH_RANGE */); }
    getAliasedPointSizeRange() { return this._getParam(33901 /* ALIASED_POINT_SIZE_RANGE */); }
    getMaxCombinedTextureImageUnits() { return this._getParam(35661 /* MAX_COMBINED_TEXTURE_IMAGE_UNITS */); }
    getMaxCubeMapTextureSize() { return this._getParam(34076 /* MAX_CUBE_MAP_TEXTURE_SIZE */); }
    getMaxFragmentUniformVectors() { return this._getParam(36349 /* MAX_FRAGMENT_UNIFORM_VECTORS */); }
    getMaxRenderbufferSize() { return this._getParam(34024 /* MAX_RENDERBUFFER_SIZE */); }
    getMaxTextureImageUnits() { return this._getParam(34930 /* MAX_TEXTURE_IMAGE_UNITS */); }
    getMaxTextureSize() { return this._getParam(3379 /* MAX_TEXTURE_SIZE */); }
    getMaxVaryingVectors() { return this._getParam(36348 /* MAX_VARYING_VECTORS */); }
    getMaxVertexAttribs() { return this._getParam(34921 /* MAX_VERTEX_ATTRIBS */); }
    getMaxVertexTextureImageUnits() { return this._getParam(35660 /* MAX_VERTEX_TEXTURE_IMAGE_UNITS */); }
    getMaxVertexUniformVectors() { return this._getParam(36347 /* MAX_VERTEX_UNIFORM_VECTORS */); }
    getMaxViewportDims() { return this._getParam(3386 /* MAX_VIEWPORT_DIMS */); }
    getRenderer() { return this._getParam(7937 /* RENDERER */); }
    getSubpixelBits() { return this._getParam(3408 /* SUBPIXEL_BITS */); }
    getVendor() { return this._getParam(7936 /* VENDOR */); }
    getVersion() { return this._getParam(7938 /* VERSION */); }
    /** Calling this method w/o `WEBGL_debug_renderer_info` enabled will return `null`! */
    getUnmaskedVendor() { return this._getParam(37445 /* UNMASKED_VENDOR */); }
    /** Calling this method w/o `WEBGL_debug_renderer_info` enabled will return `null`! */
    getUnmaskedRenderer() { return this._getParam(37446 /* UNMASKED_RENDERER */); }
    _getParam(param) {
        const paramValues = this._paramValues;
        let paramValue = paramValues.get(param);
        if (!paramValue) {
            paramValue = this._gl.getParameter(param);
            paramValues.set(param, paramValue);
        }
        return paramValue;
    }
}


/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BLEND_OVER_RENDER_STATE", function() { return BLEND_OVER_RENDER_STATE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BLEND_OVER_PREMULTIPLIED_ALPHA_RENDER_STATE", function() { return BLEND_OVER_PREMULTIPLIED_ALPHA_RENDER_STATE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RenderState; });
/* harmony import */ var _util_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(11);

/**
 * Preset of render state for OVER compositing,
 * @see T. Porter and T. Duff, "Compositing Digital Images", Proceedings of
 *      SIGGRAPH'84, 18 (1984).
 */
const BLEND_OVER_RENDER_STATE = {
    blend: true,
    blendFuncSrcRgb: 770 /* SRC_ALPHA */,
    blendFuncDstRgb: 771 /* ONE_MINUS_SRC_ALPHA */,
    blendFuncSrcAlpha: 1 /* ONE */,
    blendFuncDstAlpha: 771 /* ONE_MINUS_SRC_ALPHA */
};
const BLEND_OVER_PREMULTIPLIED_ALPHA_RENDER_STATE = {
    blend: true,
    blendFuncSrcRgb: 1 /* ONE */,
    blendFuncDstRgb: 771 /* ONE_MINUS_SRC_ALPHA */,
    blendFuncSrcAlpha: 1 /* ONE */,
    blendFuncDstAlpha: 771 /* ONE_MINUS_SRC_ALPHA */
};
/**
 * State of the WebGL rendering pipeline. Doesn't include object bindings since
 * the context handles them.
 */
class RenderState {
    /**
     * Creates a new render state object.
     *
     * @param state Object with state properties that values differ from default
     *      ones.
     */
    constructor(...state) {
        this.clearColor = _util_color__WEBPACK_IMPORTED_MODULE_0__["create"](0, 0, 0, 0);
        this.clearDepth = 1;
        this.clearStencil = 0;
        this.colorMaskR = true;
        this.colorMaskG = true;
        this.colorMaskB = true;
        this.colorMaskAlpha = true;
        this.blend = false;
        this.blendEquationRgb = 32774 /* ADD */;
        this.blendEquationAlpha = 32774 /* ADD */;
        this.blendFuncSrcRgb = 1 /* ONE */;
        this.blendFuncDstRgb = 0 /* ZERO */;
        this.blendFuncSrcAlpha = 1 /* ONE */;
        this.blendFuncDstAlpha = 0 /* ZERO */;
        this.cullFace = false;
        this.cullFaceMode = 1029 /* BACK */;
        this.frontFaceMode = 2305 /* COUNTERCLOCKWISE */;
        this.depthTest = false;
        this.depthFunc = 513 /* LESS */;
        this.depthRangeNear = 0;
        this.depthRangeFar = 1;
        this.depthMask = true;
        this.dither = true;
        this.drawBuffers = [36064 /* COLOR_ATTACHMENT0 */];
        this.polygonOffset = false;
        this.polygonOffsetFactor = 0;
        this.polygonOffsetUnits = 0;
        this.sampleAlphaToCoverage = false;
        this.sampleCoverage = false;
        this.sampleCoverageValue = 1;
        this.sampleCoverageInvert = false;
        this.scissorTest = false;
        this.scissorX = 0;
        this.scissorY = 0;
        // Actual defaults aren't known here since they depend upon context. -1's
        // as "do not change" values.
        this.scissorWidth = -1;
        this.scissorHeight = -1;
        this.stencilTest = false;
        this.stencilReference = 0;
        this.stencilMask = 0xff;
        this.stencilWriteMask = 0xff;
        this.stencilFrontFunc = 519 /* ALWAYS */;
        this.stencilFrontFailOp = 7680 /* KEEP */;
        this.stencilFrontDepthFailOp = 7680 /* KEEP */;
        this.stencilFrontDepthPassOp = 7680 /* KEEP */;
        this.stencilBackFunc = 519 /* ALWAYS */;
        this.stencilBackFailOp = 7680 /* KEEP */;
        this.stencilBackDepthFailOp = 7680 /* KEEP */;
        this.stencilBackDepthPassOp = 7680 /* KEEP */;
        this.viewportX = 0;
        this.viewportY = 0;
        // Actual defaults aren't known here since they depend upon context. -1's
        // as "do not change" values.
        this.viewportWidth = -1;
        this.viewportHeight = -1;
        Object.assign(this, ...state);
    }
}


/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OPAQUE_BLACK", function() { return OPAQUE_BLACK; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TRANSPARENT_BLACK", function() { return TRANSPARENT_BLACK; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "areEqual", function() { return areEqual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodeAbgr8", function() { return decodeAbgr8; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encodeRgba8", function() { return encodeRgba8; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isOpaque", function() { return isOpaque; });
const OPAQUE_BLACK = create(0, 0, 0, 1);
const TRANSPARENT_BLACK = create(0, 0, 0, 0);
/**
 * @param r Red component as a normalized value [0..1]
 * @param g Green component as a normalized value [0..1]
 * @param b Blue component as a normalized value [0..1]
 * @param a Alpha component as a normalized value [0..1]
 *
 * @returns A color with given values assigned to components.
 */
function create(r, g, b, a = 1) {
    return { r, g, b, a };
}
/**
 * Copies a color to another one.
 *
 * @param src The source color.
 * @param dst The color the source color will be copied to.
 * @returns `dst`.
 */
function copy(src, dst = create(0, 0, 0, 0)) {
    dst.r = src.r;
    dst.g = src.g;
    dst.b = src.b;
    dst.a = src.a;
    return dst;
}
function areEqual(c1, c2) {
    return c1.r === c2.r && c1.g === c2.g && c1.b === c2.b && c1.a === c2.a;
}
/**
 * Decodes a color represented as four 8-bit channels encoded into a 32-bit
 * number in ABGR order (from MSB to LSB).
 *
 * @param color Color encoded into unsigned 32-bit integer.
 * @returns Decoded color.
 */
function decodeAbgr8(color) {
    return {
        r: (color >>> 24) / 0xff,
        g: (color >>> 16 & 0xff) / 0xff,
        b: (color >>> 8 & 0xff) / 0xff,
        a: (color & 0xff) / 0xff
    };
}
/**
 * Encodes a color components into four 8 bit numbers packed into 32-bit one.
 *
 * @param c The color to be encoded.
 * @returns The color as 32-bit integer.
 */
function encodeRgba8(c) {
    return (c.r * 0xff |
        (c.g * 0xff << 8) |
        (c.b * 0xff << 16) |
        (c.a * 0xff << 24));
}
/**
 * Checks if a color is completely opaque.
 *
 * @param color The color to be checked.
 * @returns `true` if the color is opaque and `false` otherwise.
 */
function isOpaque(color) {
    return color.a === 1;
}


/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_TEXTURE_PARAMS", function() { return DEFAULT_TEXTURE_PARAMS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Texture; });
/**
 * Our defaults for textures are different from ones in WebGL for two reasons:
 * 1. default minification filter in WebGL is NEAREST_MIPMAP_LINEAR which requires
 *    texture to have all mip levels specified;
 * 2. default wrap modes are REPEAT which isn't supported for NPOT textures.
 */
const DEFAULT_TEXTURE_PARAMS = {
    wrapS: 33071 /* CLAMP_TO_EDGE */,
    wrapT: 33071 /* CLAMP_TO_EDGE */,
    magnificationFilter: 9728 /* NEAREST */,
    minificationFilter: 9728 /* NEAREST */,
    premultipliedAlpha: false
};
/** Wrapper around WebGLTexture objects. For now only works with 2D textures. */
class Texture {
    /**
     * Creates a new texture in a WebGL context.
     *
     * @param gl The context the texture will be created in.
     */
    constructor(gl, width, height, format, type, params = DEFAULT_TEXTURE_PARAMS) {
        this._gl = gl;
        this._format = format;
        this._type = type;
        this._params = params;
        this._width = width;
        this._height = height;
        this._handle = gl.createTexture();
        this.bind();
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, params.wrapS);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, params.wrapT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, params.magnificationFilter);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, params.minificationFilter);
        gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, 0, format, type, null);
    }
    /**
     * Binds the texture to the WebGL context as a 2D texture.
     */
    bind() {
        const gl = this._gl;
        gl.bindTexture(gl.TEXTURE_2D, this._handle);
    }
    /**
     * Checks if the texture is bound to the WebGL context.
     *
     * @returns `true` if the texture is currently bound to the WebGL context
     *      and `false` otherwise.
     */
    isBound() {
        const gl = this._gl;
        return gl.getParameter(gl.TEXTURE_BINDING_2D) === this._handle;
    }
    /**
     * Attaches the texture to a currently bound to the WebGL context framebuffer.
     *
     * @param attachmentPoint Attachment point the texture will be attached to.
     */
    attachToFramebuffer(attachmentPoint) {
        const gl = this._gl;
        gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentPoint, gl.TEXTURE_2D, this._handle, 0);
    }
    /** Returns width of the texture. */
    getWidth() {
        return this._width;
    }
    /** Returns height of the texture. */
    getHeight() {
        return this._height;
    }
    /** Returns pixel format of the texture. */
    getFormat() {
        return this._format;
    }
    /** Return pixel type of the texture. */
    getType() {
        return this._type;
    }
    /** Return params of the texture. */
    getParams() {
        return this._params;
    }
    /**
     * Destroys the texture.
     */
    destroy() {
        this._gl.deleteTexture(this._handle);
    }
}


/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return VertexArrayObject; });
/**
 * Wrapper around vertex array (VAO) object from `OES_vertex_array_object`
 * extension.
 */
class VertexArrayObject {
    /**
     * Creates new VAO in a given WebGL context.
     *
     * @param gl The context.
     * @param vaoExt Instance of `OES_vertex_array_object` extension.
     * @param attributeMapping Mapping of attributes.
     */
    constructor(gl, vaoExt, attributeMapping) {
        this._gl = gl;
        this._vaoExt = vaoExt;
        this._handle = vaoExt.createVertexArrayOES();
        this.attributeMapping = attributeMapping;
    }
    /**
     * Binds the VAO to the context.
     */
    bind() {
        this._vaoExt.bindVertexArrayOES(this._handle);
    }
    /**
     * Checks if the VAO is currently bound to the context.
     *
     * @returns `true` if the VAO is currently bound to the WebGL context and
     *      `false` otherwise.
     */
    isBound() {
        return this._gl.getParameter(this._vaoExt.VERTEX_ARRAY_BINDING_OES) ===
            this._handle;
    }
    /**
     * Destroys the VAO.
     */
    destroy() {
        this._vaoExt.deleteVertexArrayOES(this._handle);
    }
}


/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EventEmitter", function() { return EventEmitter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VoidEventEmitter", function() { return VoidEventEmitter; });
/**
 * Simple pub/sub implementation. The emitter is supposed to emit only one type of event,
 * if someone has to emit events of different types, multiple emitters should be created.
 */
class EventEmitter {
    constructor() {
        this._listeners = new Set();
    }
    /**
     * Adds listener.
     */
    addListener(listener) {
        this._listeners.add(listener);
    }
    /**
     * Removes listener.
     */
    removeListener(listener) {
        this._listeners.delete(listener);
    }
    /**
     * Calls all the added listeners, the order (e.g. of adding) is not guaranteed.
     */
    fire(data) {
        this._listeners.forEach((listener) => {
            listener(data);
        });
    }
}
/**
 * Event emitter with no payload emitted.
 */
class VoidEventEmitter extends EventEmitter {
    fire() {
        super.fire(undefined);
    }
}


/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Camera; });
/* harmony import */ var _math_scalar__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(16);
/* harmony import */ var _util_rad_deg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17);
/* harmony import */ var _util_options__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(18);
/* harmony import */ var _math_matrix4__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(19);
/* harmony import */ var _math_vector2__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(23);
/* harmony import */ var _math_vector3__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(20);
/* harmony import */ var _util_event_emitter__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(14);








// TODO(dmikis) We want to constraint coordinates so visible region doesn't extend
//      out of world boundaries. However, in current implementation it doesn't
//      work properly for aspect ratios >1 on zoom 0 since visible region is
//      larger that the world itself (so there's no way to squeeze it in). For
//      the current case (i.e. cycled in horizontal direction) it is not a problem.
const MAX_TILT = Object(_util_rad_deg__WEBPACK_IMPORTED_MODULE_1__["deg2rad"])(40);
/**
 * If a camera has zoom less than of equal to `NO_TILT_MAX_ZOOM`, tilt won't be
 * allowed.
 */
const NO_TILT_MAX_ZOOM = 1;
/**
 * If a camera has zoom greater than of equal to `FULL_TILT_MIN_ZOOM`, tilt will
 * be allowed up to `MAX_TILT`.
 */
const FULL_TILT_MIN_ZOOM = NO_TILT_MAX_ZOOM + 1;
const FRUSTUM_DIRECTIONS = [
    // tslint:disable
    _math_vector3__WEBPACK_IMPORTED_MODULE_5__["create"](-1, 1, -1),
    _math_vector3__WEBPACK_IMPORTED_MODULE_5__["create"](1, 1, -1),
    _math_vector3__WEBPACK_IMPORTED_MODULE_5__["create"](1, -1, -1),
    _math_vector3__WEBPACK_IMPORTED_MODULE_5__["create"](-1, -1, -1)
    // tslint:enable
];
/**
 * How big the world sould be on a screen if zoom is 0, in device independent pixels
 */
const ZOOM_0_WORLD_CSS_PIXEL_SIZE = 256;
const DEFAULT_OPTIONS = {
    wrapModeX: 1 /* CLAMP_TO_EDGE */,
    wrapModeY: 1 /* CLAMP_TO_EDGE */,
    minZoom: 0,
    maxZoom: 24,
    fov: Object(_util_rad_deg__WEBPACK_IMPORTED_MODULE_1__["deg2rad"])(30)
};
/**
 * Restricts a new value for a center's coordinate according to given wrap mode.
 *
 * @param wrapMode The wrap mode.
 * @param newCoordinate The new value.
 * @param oldCoordinate Current value of the coordinate.
 * @param bboxMin Minimum corresponding coordinate of bounding box of the
 *      visible quadrilateral.
 * @param bboxMax Maximum corresponding coordinate of bounding box of the
 *      visible quadrilateral.
 * @returns Restricted value for the coordinate.
 */
function restrictCoordinate(wrapMode, newCoordinate) {
    switch (wrapMode) {
        case 0 /* NONE */:
            return newCoordinate;
        case 1 /* CLAMP_TO_EDGE */:
            return Object(_math_scalar__WEBPACK_IMPORTED_MODULE_0__["clamp"])(newCoordinate, -1, 1);
        case 2 /* REPEAT */:
            return Object(_math_scalar__WEBPACK_IMPORTED_MODULE_0__["cycleRestrict"])(newCoordinate, -1, 1);
    }
}
/**
 * Camera represents user's point of view in the world space, as a real camera it has restricted field of view,
 * it can move and rotate (with or without animation).
 */
class Camera {
    /**
     * Creates a new camera.
     *
     * @param options Options.
     */
    constructor(options) {
        this.options = Object(_util_options__WEBPACK_IMPORTED_MODULE_2__["default"])(DEFAULT_OPTIONS, options);
        this.center = new Camera._Center(this);
        this.onUpdate = new _util_event_emitter__WEBPACK_IMPORTED_MODULE_6__["VoidEventEmitter"]();
        const screenSize = new Camera._ScreenSize(this);
        this.screenSize = screenSize;
        this._distanceToCenter = 1;
        this._zoom = this.options.minZoom;
        this._tilt = this._azimuth = 0;
        this._dirtyBits = -1 /* ALL */;
        this._viewProjMatrix = _math_matrix4__WEBPACK_IMPORTED_MODULE_3__["copy"](_math_matrix4__WEBPACK_IMPORTED_MODULE_3__["IDENTITY"]);
        this._visibleQuadrilateral = [
            _math_vector3__WEBPACK_IMPORTED_MODULE_5__["create"](0, 0, 0),
            _math_vector3__WEBPACK_IMPORTED_MODULE_5__["create"](0, 0, 0),
            _math_vector3__WEBPACK_IMPORTED_MODULE_5__["create"](0, 0, 0),
            _math_vector3__WEBPACK_IMPORTED_MODULE_5__["create"](0, 0, 0)
        ];
        this._visibleQuadrilateralBBox =
            _math_vector2__WEBPACK_IMPORTED_MODULE_4__["computeBBoxForPoints"](this._visibleQuadrilateral);
        this._pixelSize = _math_vector2__WEBPACK_IMPORTED_MODULE_4__["create"](0, 0);
    }
    get aspectRatio() {
        const { width, height } = this.screenSize;
        if (height !== 0) {
            return width / height;
        }
        else {
            // when height == 0 we cannot compute viewProj matrix or visible region, 1 allows to handle this case with
            // no exceptions thrown, but technically it is not correct and should be reconsidered if any issue is found
            return 1;
        }
    }
    get zoom() {
        return this._zoom;
    }
    get worldToPxFactor() {
        return this._worldToPxFactor;
    }
    /**
     * Sets new zoom to the camera with respect to provided limits in the options.
     */
    set zoom(newZoom) {
        newZoom = Object(_math_scalar__WEBPACK_IMPORTED_MODULE_0__["clamp"])(newZoom, this.options.minZoom, this.options.maxZoom);
        if (newZoom !== this._zoom) {
            this._zoom = newZoom;
            this._computeDistanceToCenter();
            // Constraints on tilt may have changed, we need to recompute it.
            this._tilt = this._constrainTilt(this._tilt);
            this._worldToPxFactor = 2.0 / (ZOOM_0_WORLD_CSS_PIXEL_SIZE * Math.pow(2, newZoom));
            this._setDirtyBits(1 /* VIEW_PROJ_MATRIX */ | 2 /* VISIBLE_QUADRILATERAL */);
        }
    }
    get tilt() {
        return this._tilt;
    }
    set tilt(newTilt) {
        newTilt = this._constrainTilt(newTilt);
        if (this._tilt !== newTilt) {
            this._tilt = newTilt;
            this._setDirtyBits(1 /* VIEW_PROJ_MATRIX */ | 2 /* VISIBLE_QUADRILATERAL */);
        }
    }
    get azimuth() {
        return this._azimuth;
    }
    set azimuth(newAzimuth) {
        newAzimuth = Object(_math_scalar__WEBPACK_IMPORTED_MODULE_0__["cycleRestrict"])(newAzimuth, 0, 2 * Math.PI);
        if (this._azimuth !== newAzimuth) {
            this._azimuth = newAzimuth;
            this._setDirtyBits(1 /* VIEW_PROJ_MATRIX */ | 2 /* VISIBLE_QUADRILATERAL */);
        }
    }
    /**
     * Size of a pixel in NDC.
     */
    get pixelSize() {
        return this._pixelSize;
    }
    /**
     * Invalidate all internally cached values (e.g. view matrix).
     */
    setDirty() {
        this._setDirtyBits(-1 /* ALL */);
    }
    /**
     * Recomputes (if needed) the view projection matrix.
     *
     * @returns The view-projection matrix.
     */
    getViewProjMatrix() {
        const viewProjMatrix = this._viewProjMatrix;
        if (this._dirtyBits & 1 /* VIEW_PROJ_MATRIX */) {
            _math_matrix4__WEBPACK_IMPORTED_MODULE_3__["copy"](_math_matrix4__WEBPACK_IMPORTED_MODULE_3__["IDENTITY"], viewProjMatrix);
            _math_matrix4__WEBPACK_IMPORTED_MODULE_3__["lookAt"](viewProjMatrix, this._computeCenterToCameraVector(), _math_vector3__WEBPACK_IMPORTED_MODULE_5__["ORIGIN"], _math_vector3__WEBPACK_IMPORTED_MODULE_5__["rotateZ"](_math_vector3__WEBPACK_IMPORTED_MODULE_5__["POSITIVE_Y"], this._azimuth), viewProjMatrix);
            const { fov } = this.options;
            const tanFactors = Math.tan(this._tilt) * Math.tan(0.5 * fov);
            _math_matrix4__WEBPACK_IMPORTED_MODULE_3__["perspective"](viewProjMatrix, fov, this.aspectRatio, Math.min(this._distanceToCenter * 0.01, this._distanceToCenter / (1 + tanFactors)), this._distanceToCenter / (1 - tanFactors), viewProjMatrix);
            this._dirtyBits &= ~1 /* VIEW_PROJ_MATRIX */;
        }
        return viewProjMatrix;
    }
    /**
     * Recomputes (if needed) and returns quadrilateral cut on the world plane
     * by frustum of the camera.
     *
     * @return The quadrilateral enclosing visible part of the world plane.
     */
    getVisibleRegion() {
        this._computeVisibleQuadrilateral();
        return this._visibleQuadrilateral;
    }
    /**
     * Recomputes (if needed) and returns bounding box of the visible region.
     *
     * @return Bounding box of the visible quadrilateral.
     */
    getVisibleRegionBBox() {
        this._computeVisibleQuadrilateral();
        return this._visibleQuadrilateralBBox;
    }
    _constrainTilt(tilt) {
        return Object(_math_scalar__WEBPACK_IMPORTED_MODULE_0__["clamp"])(tilt, 0, MAX_TILT * Object(_math_scalar__WEBPACK_IMPORTED_MODULE_0__["smoothStep"])(NO_TILT_MAX_ZOOM, FULL_TILT_MIN_ZOOM, this._zoom));
    }
    _setDirtyBits(bits) {
        if (bits ^ (bits & this._dirtyBits)) {
            this._dirtyBits |= bits;
            this.onUpdate.fire();
        }
    }
    _computeDistanceToCenter() {
        this._distanceToCenter =
            this.screenSize.height * Math.pow(2, -this._zoom) /
                (Math.tan(0.5 * this.options.fov) * ZOOM_0_WORLD_CSS_PIXEL_SIZE);
    }
    _computeCenterToCameraVector(dst = _math_vector3__WEBPACK_IMPORTED_MODULE_5__["create"](0, 0, 0)) {
        _math_vector3__WEBPACK_IMPORTED_MODULE_5__["muln"](_math_vector3__WEBPACK_IMPORTED_MODULE_5__["POSITIVE_Z"], this._distanceToCenter, dst);
        _math_vector3__WEBPACK_IMPORTED_MODULE_5__["rotateX"](dst, this._tilt, dst);
        _math_vector3__WEBPACK_IMPORTED_MODULE_5__["rotateZ"](dst, this._azimuth, dst);
        return dst;
    }
    _computeVisibleQuadrilateral() {
        if (this._dirtyBits & 2 /* VISIBLE_QUADRILATERAL */) {
            const visibleQuadrilateral = this._visibleQuadrilateral;
            const halfFovTan = Math.tan(0.5 * this.options.fov);
            const origin = this._computeCenterToCameraVector();
            _math_vector2__WEBPACK_IMPORTED_MODULE_4__["add"](origin, this.center, origin);
            const scale = _math_vector3__WEBPACK_IMPORTED_MODULE_5__["create"](halfFovTan * this.aspectRatio, halfFovTan, 1);
            const direction = _math_vector3__WEBPACK_IMPORTED_MODULE_5__["create"](0, 0, 0);
            const ray = { origin, direction };
            for (let i = 0; i < 4; ++i) {
                _math_vector3__WEBPACK_IMPORTED_MODULE_5__["mulv"](FRUSTUM_DIRECTIONS[i], scale, direction);
                _math_vector3__WEBPACK_IMPORTED_MODULE_5__["rotateX"](direction, this._tilt, direction);
                _math_vector3__WEBPACK_IMPORTED_MODULE_5__["rotateZ"](direction, this._azimuth, direction);
                if (!_math_vector3__WEBPACK_IMPORTED_MODULE_5__["getPlaneRayIntersection"](_math_vector3__WEBPACK_IMPORTED_MODULE_5__["XY"], ray, visibleQuadrilateral[i])) {
                    throw new Error('Visible quadrilateral is unbounded, engine can\'t handle that case (yet)');
                }
            }
            _math_vector2__WEBPACK_IMPORTED_MODULE_4__["computeBBoxForPoints"](visibleQuadrilateral, this._visibleQuadrilateralBBox);
            this._dirtyBits &= ~2 /* VISIBLE_QUADRILATERAL */;
        }
    }
}
/**
 * Implementation of a center vector of a camera. Takes into account wrapping
 * modes and updates camera's dirty flags.
 */
Camera._Center = class {
    /**
     * Creates new center vector for a camera.
     *
     * @param camera The camera.
     */
    constructor(camera) {
        this._camera = camera;
        this._x = this._y = 0;
    }
    /**
     * @returns Values of abscissa of the center vector.
     */
    get x() {
        return this._x;
    }
    /**
     * Properly clamps or wraps new abscissa value and sets it to the vector.
     *
     * @param newX The new
     */
    set x(newX) {
        const camera = this._camera;
        newX = restrictCoordinate(camera.options.wrapModeX, newX);
        if (this._x !== newX) {
            this._x = newX;
            camera._setDirtyBits(2 /* VISIBLE_QUADRILATERAL */);
        }
    }
    /**
     * @returns Values of ordinate of the center vector.
     */
    get y() {
        return this._y;
    }
    /**
     * Properly clamps or wraps new ordinate value and sets it to the vector.
     */
    set y(newY) {
        const camera = this._camera;
        newY = restrictCoordinate(camera.options.wrapModeY, newY);
        if (this._y !== newY) {
            this._y = newY;
            camera._setDirtyBits(2 /* VISIBLE_QUADRILATERAL */);
        }
    }
};
Camera._ScreenSize = class {
    constructor(camera) {
        this._camera = camera;
        this._width = this._height = 0;
    }
    get width() {
        return this._width;
    }
    set width(newWidth) {
        if (this._width !== newWidth) {
            this._width = newWidth;
            const camera = this._camera;
            camera._setDirtyBits(1 /* VIEW_PROJ_MATRIX */ | 2 /* VISIBLE_QUADRILATERAL */);
            camera._pixelSize.x = 2.0 / this._width;
        }
    }
    get height() {
        return this._height;
    }
    set height(newHeight) {
        if (this._height !== newHeight) {
            this._height = newHeight;
            const camera = this._camera;
            camera._computeDistanceToCenter();
            camera._setDirtyBits(1 /* VIEW_PROJ_MATRIX */ | 2 /* VISIBLE_QUADRILATERAL */);
            camera._pixelSize.y = 2.0 / this._height;
        }
    }
};


/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clamp", function() { return clamp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cycleRestrict", function() { return cycleRestrict; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mix", function() { return mix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "smoothStep", function() { return smoothStep; });
/**
 * Clamps a value to a given range.
 *
 * @param x The value.
 * @param min Start of the range.
 * @param max End of the range.
 * @returns Clamped value.
 */
function clamp(x, min, max) {
    return min < x ? x < max ? x : max : min;
}
/**
 * Restricts a value to a given cycled range, i.e. ends of the range are
 * equivalent. E.g. like angles can be restricted to any range of size `2 * PI`.
 *
 * @param x The value.
 * @param min Start of the range.
 * @param max End of the range.
 * @returns Restricted value.
 */
function cycleRestrict(x, min, max) {
    const d = max - min;
    const s = (x - min) / (max - min);
    return min + d * (s - Math.floor(s));
}
/**
 * Linear interpolation.
 *
 * @param min Value that correspond to 0% progress.
 * @param max Value that correspond to 100% progress.
 * @param progress In 0..1.0 range that maps to 0..100% progress. It is allowed to pass a value
 *      outside of this range, that means progress greater then 100% or negative progress.
 */
function mix(min, max, progress) {
    return (1 - progress) * min + progress * max;
}
/**
 * A step function with a smooth transition between given edges. Completely
 * analogous to `smoothstep` in GLSL (GLSL ES 1.0 §8.3).
 *
 * @param edge1 The smaller edge.
 * @param edge2
 * @param x `0` if `x < edge1`, `1` if `x > edge2` and an interpolated value for
 *      `edge1 < x < edge2`.
 */
function smoothStep(edge1, edge2, x) {
    const factor = clamp((x - edge1) / (edge2 - edge1), 0, 1);
    return factor * factor * (3 - 2 * factor);
}


/***/ }),
/* 17 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deg2rad", function() { return deg2rad; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rad2deg", function() { return rad2deg; });
const DEG_TO_RAD = Math.PI / 180;
function deg2rad(x) {
    return x * DEG_TO_RAD;
}
function rad2deg(x) {
    return x / DEG_TO_RAD;
}


/***/ }),
/* 18 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getFullOptions; });
/**
 * Resolves options.
 *
 * @param defaultOptions Object with default values.
 * @param options Object with custom values for options. Later objects "override"
 *      former ones.
 * @returns New object containing resolved options.
 */
function getFullOptions(defaultOptions, ...options) {
    return Object.assign({}, defaultOptions, ...options);
}


/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IDENTITY", function() { return IDENTITY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZERO", function() { return ZERO; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zero", function() { return zero; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateX", function() { return rotateX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateY", function() { return rotateY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateZ", function() { return rotateZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lookAt", function() { return lookAt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "perspective", function() { return perspective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "apply", function() { return apply; });
/* harmony import */ var _vector3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(20);

// TODO(dmikis) RoMatrix4?
const IDENTITY = [
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    0, 0, 0, 1
];
const ZERO = [
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0
];
const MATRIX_SIZE = 16;
/**
 * Creates and returns a new **uninitialized** matrix.
 */
function create() {
    return new Array(MATRIX_SIZE);
}
/**
 * Zeroes a matrix.
 *
 * @param dst The matrix.
 * @returns `dst`.
 */
function zero(dst = create()) {
    for (let i = 0; i < MATRIX_SIZE; ++i) {
        dst[i] = 0;
    }
    return dst;
}
/**
 * Copies a matrix to another one.
 *
 * @param src The matrix to be copied.
 * @param dst The matrix the `src` will be copied to.
 * @returns `dst`.
 */
function copy(src, dst = create()) {
    for (let i = 0; i < MATRIX_SIZE; ++i) {
        dst[i] = src[i];
    }
    return dst;
}
/**
 * Applies a rotation around the X axis by a given angle to a given matrix.
 * Positive direction is from positive Y to positive Z.
 *
 * @param src The matrix to be multiplied by the rotation matrix.
 * @param angle The angle of rotation.
 * @param dst The matrix the product will be stored to. Can be the same as `src`.
 * @returns `dst`.
 */
function rotateX(src, angle, dst = create()) {
    const angleCos = Math.cos(angle);
    const angleSin = Math.sin(angle);
    // The rotation matrix:
    //
    // 1   0    0 0
    // 0 cos -sin 0
    // 0 sin  cos 0
    // 0   0    0 1
    for (let i = 0; i < MATRIX_SIZE; i += 4) {
        dst[i] = src[i];
        const m1i = src[i + 1];
        const m2i = src[i + 2];
        dst[i + 1] = m1i * angleCos - m2i * angleSin;
        dst[i + 2] = m1i * angleSin + m2i * angleCos;
        dst[i + 3] = src[i + 3];
    }
    return dst;
}
/**
 * Applies a rotation around the Y axis by a given angle to a given matrix.
 * Positive direction is from positive X to positive Z.
 *
 * @param src The matrix to be multiplied by the rotation matrix.
 * @param angle The angle of rotation.
 * @param dst The matrix the product will be stored to. Can be the same as `src`.
 * @returns `dst`.
 */
function rotateY(src, angle, dst = create()) {
    const angleCos = Math.cos(angle);
    const angleSin = Math.sin(angle);
    // The rotation matrix:
    //
    // cos 0 -sin 0
    // 0   1    0 0
    // sin 0  cos 0
    // 0    0   0 1
    for (let i = 0; i < MATRIX_SIZE; i += 4) {
        const m0i = src[i];
        const m2i = src[i + 2];
        dst[i] = m0i * angleCos - m2i * angleSin;
        dst[i + 1] = src[i + 1];
        dst[i + 2] = m0i * angleSin + m2i * angleCos;
        dst[i + 3] = src[i + 3];
    }
    return dst;
}
/**
 * Applies a rotation around the X axis by a given angle to a given matrix.
 * Positive direction is from positive X to positive Y.
 *
 * @param src The matrix to be multiplied by the rotation matrix.
 * @param angle The angle of rotation.
 * @param dst The matrix the product will be stored to. Can be the same as `src`.
 * @returns `dst`.
 */
function rotateZ(src, angle, dst = create()) {
    const angleCos = Math.cos(angle);
    const angleSin = Math.sin(angle);
    // The rotation matrix:
    // cos -sin 0 0
    // sin  cos 0 0
    //   0    0 1 0
    //   0    0 0 1
    for (let i = 0; i < MATRIX_SIZE; i += 4) {
        const m0i = src[i];
        const m1i = src[i + 1];
        dst[i] = m0i * angleCos - m1i * angleSin;
        dst[i + 1] = m0i * angleSin + m1i * angleCos;
        dst[i + 2] = src[i + 2];
        dst[i + 3] = src[i + 3];
    }
    return dst;
}
/**
 * Applies a translation by a given vector to a given matrix.
 *
 * @param src The matrix to be multiplied by the translation matrix.
 * @param translation The translation vector.
 * @param dst The matrix the product will be stored to. Can be the same as `src`.
 * @returns `dst`.
 */
function translate(src, translation, dst = create()) {
    for (let i = 0; i < MATRIX_SIZE; i += 4) {
        const m4i = dst[i + 3] = src[i + 3];
        dst[i] = src[i] + m4i * translation.x;
        dst[i + 1] = src[i + 1] + m4i * translation.y;
        dst[i + 2] = src[i + 2] + m4i * translation.z;
    }
    return dst;
}
/**
 * Applies a scale matrix by given factors (packed into a vector) to a given
 * matrix.
 *
 * @param src The matrix to be multiplied by the scale matrix.
 * @param factor The vector the scale factors packed into.
 * @param dst The matrix the product will be stored to. Can be the same as `src`.
 * @returns `dst`.
 */
function scale(src, factor, dst = create()) {
    for (let i = 0; i < MATRIX_SIZE; i += 4) {
        dst[i] = src[i] * factor.x;
        dst[i + 1] = src[i + 1] * factor.y;
        dst[i + 2] = src[i + 2] * factor.z;
        dst[i + 3] = src[i + 3];
    }
    return dst;
}
// The matrix:
// xAxis.x yAxis.x zAxis.x -eye.x
// xAxis.y yAxis.y zAxis.y -eye.y
// xAxis.z yAxis.z zAxis.z -eye.z
//       0       0       0 1
// where xAxis, yAxis and zAxis — axes of the eye coordinate system, eye —
// origin of the eye coordinate system.
const lookAtMatrix = copy(IDENTITY);
/**
 * Applies a matrix of transformation into a coordinate system of a camera
 * defined by its position, a point it's looking at and an up direction vector.
 *
 * @param src The matrix to be multiplied by the scale matrix.
 * @param eye The position of the camera.
 * @param center The point the camera's looking at.
 * @param up The up vector.
 * @param dst The matrix the product will be stored to. Can be the same as `src`.
 * @returns `dst`.
 */
function lookAt(src, eye, center, up, dst = create()) {
    const zAxis = _vector3__WEBPACK_IMPORTED_MODULE_0__["sub"](eye, center);
    _vector3__WEBPACK_IMPORTED_MODULE_0__["normalize"](zAxis, zAxis);
    const xAxis = _vector3__WEBPACK_IMPORTED_MODULE_0__["cross"](up, zAxis);
    _vector3__WEBPACK_IMPORTED_MODULE_0__["normalize"](xAxis, xAxis);
    const yAxis = _vector3__WEBPACK_IMPORTED_MODULE_0__["cross"](zAxis, xAxis);
    lookAtMatrix[0] = xAxis.x;
    lookAtMatrix[1] = yAxis.x;
    lookAtMatrix[2] = zAxis.x;
    lookAtMatrix[4] = xAxis.y;
    lookAtMatrix[5] = yAxis.y;
    lookAtMatrix[6] = zAxis.y;
    lookAtMatrix[8] = xAxis.z;
    lookAtMatrix[9] = yAxis.z;
    lookAtMatrix[10] = zAxis.z;
    lookAtMatrix[12] = -_vector3__WEBPACK_IMPORTED_MODULE_0__["dot"](xAxis, eye);
    lookAtMatrix[13] = -_vector3__WEBPACK_IMPORTED_MODULE_0__["dot"](yAxis, eye);
    lookAtMatrix[14] = -_vector3__WEBPACK_IMPORTED_MODULE_0__["dot"](zAxis, eye);
    return mul(src, lookAtMatrix, dst);
}
/**
 * Applies a perspective matrix to a given one.
 *
 * @param src The matrix to be multiplied by the perspective matrix.
 * @param fov Vertical field of view angle.
 * @param aspectRatio Screen aspect ratio.
 * @param zNear Z-coordinate of near clipping plane.
 * @param zFar Z-coordinate of far clipping plane.
 * @param dst The matrix the product will be stored to. Can be the same as `src`.
 * @returns `dst`.
 */
function perspective(src, fov, aspect, zNear, zFar, dst = create()) {
    const p11 = 1 / Math.tan(0.5 * fov);
    const p00 = p11 / aspect;
    const p22 = (zNear + zFar) / (zNear - zFar);
    const p32 = 2 * zNear * zFar / (zNear - zFar);
    for (let i = 0; i < MATRIX_SIZE; i += 4) {
        dst[i] = src[i] * p00;
        dst[i + 1] = src[i + 1] * p11;
        const m2i = src[i + 2];
        const m3i = src[i + 3];
        dst[i + 2] = m2i * p22 + m3i * p32;
        dst[i + 3] = -m2i;
    }
    return dst;
}
/**
 * Multiplies a matrix by another one, i.e. `dst = m * src`.
 *
 * @param src The right matrix.
 * @param m The left matrix.
 * @param dst The matrix the product will be stored to. Can be the same as `src`.
 * @returns `dst`.
 */
function mul(src, m, dst = create()) {
    for (let i = 0; i < MATRIX_SIZE; i += 4) {
        const m0i = src[i];
        const m1i = src[i + 1];
        const m2i = src[i + 2];
        const m3i = src[i + 3];
        for (let j = 0; j < 4; ++j) {
            dst[i + j] = m0i * m[j] + m1i * m[4 + j] + m2i * m[8 + j] +
                m3i * m[12 + j];
        }
    }
    return dst;
}
/**
 * Applies a matrix to a vector.
 *
 * @param m The matrix.
 * @param v The vector.
 * @returns Normalized product of multiplying the vector by the matrix.
 */
function apply(m, v, dst = _vector3__WEBPACK_IMPORTED_MODULE_0__["create"](0, 0, 0)) {
    const w = m[3] * v.x + m[7] * v.y + m[11] * v.z + m[15];
    const x = (m[0] * v.x + m[4] * v.y + m[8] * v.z + m[12]) / w;
    const y = (m[1] * v.x + m[5] * v.y + m[9] * v.z + m[13]) / w;
    const z = (m[2] * v.x + m[6] * v.y + m[10] * v.z + m[14]) / w;
    dst.x = x;
    dst.y = y;
    dst.z = z;
    return dst;
}


/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ORIGIN", function() { return ORIGIN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "POSITIVE_X", function() { return POSITIVE_X; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NEGATIVE_X", function() { return NEGATIVE_X; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "POSITIVE_Y", function() { return POSITIVE_Y; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NEGATIVE_Y", function() { return NEGATIVE_Y; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "POSITIVE_Z", function() { return POSITIVE_Z; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NEGATIVE_Z", function() { return NEGATIVE_Z; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "areEqual", function() { return areEqual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "areFuzzyEqual", function() { return areFuzzyEqual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "areCollinear", function() { return areCollinear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mulv", function() { return mulv; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "muln", function() { return muln; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divv", function() { return divv; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divn", function() { return divn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cross", function() { return cross; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateX", function() { return rotateX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateY", function() { return rotateY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateZ", function() { return rotateZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "X_AXIS", function() { return X_AXIS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Y_AXIS", function() { return Y_AXIS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Z_AXIS", function() { return Z_AXIS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "XY", function() { return XY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "YZ", function() { return YZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZX", function() { return ZX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPlaneLineIntersection", function() { return getPlaneLineIntersection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPlaneRayIntersection", function() { return getPlaneRayIntersection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPlanePlaneIntersection", function() { return getPlanePlaneIntersection; });
/* harmony import */ var _matrix3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21);
/* harmony import */ var _util_fuzzy_equal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(22);


/**
 * Creates a new vector and initializes it with given components.
 *
 * @param x X component of the vector.
 * @param y Y component of the vector.
 * @param z Z component of the vector.
 * @returns The vector.
 */
function create(x, y, z) {
    return { x, y, z };
}
const ORIGIN = create(0, 0, 0);
const POSITIVE_X = create(1, 0, 0);
const NEGATIVE_X = create(-1, 0, 0);
const POSITIVE_Y = create(0, 1, 0);
const NEGATIVE_Y = create(0, -1, 0);
const POSITIVE_Z = create(0, 0, 1);
const NEGATIVE_Z = create(0, 0, -1);
/**
 * Copies a vector to another one.
 *
 * @param src The source vector.
 * @param dst The vector the source vector will be copied to.
 * @returns `dst`.
 */
function copy(src, dst = create(0, 0, 0)) {
    dst.x = src.x;
    dst.y = src.y;
    dst.z = src.z;
    return dst;
}
/**
 * Checks if two vectors are strictly equal component-wise.
 *
 * @param v1 The first vector.
 * @param v2 The second vector.
 * @returns `true` if the vectors are equal and `false` otherwise.
 */
function areEqual(v1, v2) {
    return v1.x === v2.x && v1.y === v2.y && v1.z === v2.z;
}
/**
 * Checks if corresponding components of two vectors are all within given
 * tolerance from each other.
 *
 * @param v1 The first vector.
 * @param v2 The second vector.
 * @param tolerance The tolerance.
 * @returns `true` if the vectors are "fuzzy" equal and `false` otherwise.
 */
function areFuzzyEqual(v1, v2, tolerance = _util_fuzzy_equal__WEBPACK_IMPORTED_MODULE_1__["DEFAULT_TOLERANCE"]) {
    return (Object(_util_fuzzy_equal__WEBPACK_IMPORTED_MODULE_1__["default"])(v1.x, v2.x, tolerance) &&
        Object(_util_fuzzy_equal__WEBPACK_IMPORTED_MODULE_1__["default"])(v1.y, v2.y, tolerance) &&
        Object(_util_fuzzy_equal__WEBPACK_IMPORTED_MODULE_1__["default"])(v1.z, v2.z, tolerance));
}
/**
 * Checks if two vectors are collinear.
 *
 * @param v1 The first vector.
 * @param v2 The second vector.
 * @returns `true` if the vectors are collinear and `false` otherwise.
 */
function areCollinear(v1, v2) {
    const lambdaX = v1.x / v2.x;
    const lambdaY = v1.y / v2.y;
    const lambdaZ = v1.z / v2.z;
    return lambdaX === lambdaY && lambdaY === lambdaZ;
}
/**
 * Adds two vector and stores the result into a third one, i.e. `dst = a + b`.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function add(a, b, dst = create(0, 0, 0)) {
    dst.x = a.x + b.x;
    dst.y = a.y + b.y;
    dst.z = a.z + b.z;
    return dst;
}
/**
 * Subtracts a vector from another one and stores the result to a third one, i.e.
 * `dst = a - b`.
 *
 * @param a The minuend vector.
 * @param b The subtrahend vector.
 * @param dst The vector the result will be stored to.
 */
function sub(a, b, dst = create(0, 0, 0)) {
    dst.x = a.x - b.x;
    dst.y = a.y - b.y;
    dst.z = a.z - b.z;
    return dst;
}
/**
 * Multiplies two vectors component-wise and stores the result into a third one.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function mulv(a, b, dst = create(0, 0, 0)) {
    dst.x = a.x * b.x;
    dst.y = a.y * b.y;
    dst.z = a.z * b.z;
    return dst;
}
/**
 * Multiplies a vector by a scalar and stores the result into a third vector.
 *
 * @param a The vector.
 * @param n The scalar.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function muln(a, n, dst = create(0, 0, 0)) {
    dst.x = a.x * n;
    dst.y = a.y * n;
    dst.z = a.z * n;
    return dst;
}
/**
 * Divides a vector by another one component wise and stores the result into a
 * third one.
 *
 * @param a The dividend vector.
 * @param b The divisor vector.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function divv(a, b, dst = create(0, 0, 0)) {
    dst.x = a.x / b.x;
    dst.y = a.y / b.y;
    dst.z = a.z / b.z;
    return dst;
}
/**
 * Divides a vector by a scalar and stores the result into a third vector.
 *
 * @param a The dividend vector.
 * @param n The scalar.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function divn(a, n, dst = create(0, 0, 0)) {
    dst.x = a.x / n;
    dst.y = a.y / n;
    dst.z = a.z / n;
    return dst;
}
/**
 * Computes length of a vector.
 *
 * @param v The vector.
 * @returns The length.
 */
function length(v) {
    return Math.hypot(v.x, v.y, v.z);
}
/**
 * Computes distance between ends of two vectors.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @returns The distance, i.e. `length(sub(a, b))`.
 */
function distance(a, b) {
    return Math.hypot(a.x - b.x, a.y - b.y, a.z - b.z);
}
/**
 * Divides a vector by its length (thus making it a unit vector) and stores the
 * result to another one.
 *
 * @param v The vector to be normalized.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function normalize(v, dst = create(0, 0, 0)) {
    return divn(v, length(v), dst);
}
/**
 * Computes dot product of two vectors.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @returns The dot product.
 */
function dot(a, b) {
    return a.x * b.x + a.y * b.y + a.z * b.z;
}
/**
 * Computes cross product of two vectors and stores it to a third one.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function cross(a, b, dst = create(0, 0, 0)) {
    // Write components to a separate variables so we don't produce incorrect
    // results in cases when a == dst or b == dst.
    const x = a.y * b.z - a.z * b.y;
    const y = a.z * b.x - a.x * b.z;
    const z = a.x * b.y - a.y * b.x;
    dst.x = x;
    dst.y = y;
    dst.z = z;
    return dst;
}
/**
 * Rotates vector about the X axis.
 *
 * @param v The vector to be rotated.
 * @param angle The angle of rotation (in radians), positive values rotates from +Y to +Z
 * @param dst The vector the result will be stored to.
 */
function rotateX(v, angle, dst = create(0, 0, 0)) {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    const y = v.y;
    dst.x = v.x;
    dst.y = y * cos - v.z * sin;
    dst.z = y * sin + v.z * cos;
    return dst;
}
/**
 * Rotates vector about the Y axis.
 *
 * @param v The vector to be rotated.
 * @param angle The angle of rotation (in radians), positive values rotates from +X to +Z
 * @param dst The vector the result will be stored to.
 */
function rotateY(v, angle, dst = create(0, 0, 0)) {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    // handle the case when source and destination are the same object: related components can break each other
    v = (v === dst) ? copy(v) : v;
    dst.x = v.x * cos + v.z * sin;
    dst.y = v.y;
    dst.z = -v.x * sin + v.z * cos;
    return dst;
}
/**
 * Rotates vector about the Z axis.
 *
 * @param v The vector to be rotated.
 * @param angle The angle of rotation (in radians), positive values rotates from +X to +Y
 * @param dst The vector the result will be stored to.
 */
function rotateZ(v, angle, dst = create(0, 0, 0)) {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    // handle the case when source and destination are the same object: related components can break each other
    v = (v === dst) ? copy(v) : v;
    dst.x = v.x * cos - v.y * sin;
    dst.y = v.x * sin + v.y * cos;
    dst.z = v.z;
    return dst;
}
const X_AXIS = {
    origin: ORIGIN,
    tangent: POSITIVE_X
};
const Y_AXIS = {
    origin: ORIGIN,
    tangent: POSITIVE_Y
};
const Z_AXIS = {
    origin: ORIGIN,
    tangent: POSITIVE_Z
};
const XY = {
    normal: POSITIVE_Z,
    distance: 0
};
const YZ = {
    normal: POSITIVE_X,
    distance: 0
};
const ZX = {
    normal: POSITIVE_Y,
    distance: 0
};
/**
 * Computes intersection of a plane and a line.
 *
 * @param p The plane.
 * @param l The line.
 * @returns The point or `null` if the line is parallel to the plane.
 */
function getPlaneLineIntersection(p, l) {
    const dotLP = dot(l.tangent, p.normal);
    // If plane normal and line tangent vector are perpendicular intersection is
    // either an empty set or the line itself.
    if (dotLP === 0) {
        return null;
    }
    const intersection = copy(l.tangent);
    muln(intersection, (p.distance - dot(p.normal, l.origin)) / dotLP, intersection);
    add(intersection, l.origin, intersection);
    return intersection;
}
/**
 * Computes an intersection of a plane and a ray and stores it into a given
 * vector.
 *
 * @param plane The plane.
 * @param ray The ray.
 * @param dst The vector the intersection point will be stored to. If there's no
 *      intersection, this vector will be left unmodified.
 * @returns The `dst` or `null` if the ray doesn't have a common point with the
 *      plane.
 */
function getPlaneRayIntersection(plane, ray, dst = create(0, 0, 0)) {
    const dotRP = dot(ray.direction, plane.normal);
    if (dotRP === 0) {
        // The plane normal and the ray direction vector are perpendicular, so
        // intersection is either an empty set or the ray itself.
        return null;
    }
    const lambda = (plane.distance - dot(plane.normal, ray.origin)) / dotRP;
    if (lambda < 0) {
        // The intersection point is on a line that contains the ray, but not on
        // the ray itself.
        return null;
    }
    copy(ray.direction, dst);
    muln(dst, lambda, dst);
    add(dst, ray.origin, dst);
    return dst;
}
/**
 * Computes intersection of two planes.
 *
 * @param p1 The first plane.
 * @param p2 The second plane.
 * @returns The line or `null` if the planes are parallel to each other.
 */
function getPlanePlaneIntersection(p1, p2) {
    const n1 = p1.normal;
    const n2 = p2.normal;
    if (areCollinear(n1, n2)) {
        return null;
    }
    const tangent = cross(n1, n2);
    normalize(tangent);
    return {
        tangent,
        origin: _matrix3__WEBPACK_IMPORTED_MODULE_0__["solve"](_matrix3__WEBPACK_IMPORTED_MODULE_0__["fromRows"](n1, n2, tangent), create(p1.distance, p2.distance, 0))
    };
}


/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zero", function() { return zero; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRows", function() { return fromRows; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "columns", function() { return columns; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromColumns", function() { return fromColumns; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "determinant", function() { return determinant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "solve", function() { return solve; });
/* harmony import */ var _vector3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(20);

const MATRIX_SIZE = 9;
/**
 * Creates and returns a new **uninitialized** matrix.
 */
function create() {
    return new Array(MATRIX_SIZE);
}
/**
 * Zeroes a matrix.
 *
 * @param dst The matrix.
 * @returns `dst`.
 */
function zero(dst = create()) {
    for (let i = 0; i < MATRIX_SIZE; ++i) {
        dst[i] = 0;
    }
    return dst;
}
/**
 * Copies three vectors to a matrix as rows.
 *
 * @param r0 The first row.
 * @param r1 The second row.
 * @param r2 The third row.
 * @param dst The matrix the rows will be written to.
 * @returns `dst`.
 */
function fromRows(r0, r1, r2, dst = create()) {
    dst[0] = r0.x;
    dst[1] = r1.x;
    dst[2] = r2.x;
    dst[3] = r0.y;
    dst[4] = r1.y;
    dst[5] = r2.y;
    dst[6] = r0.z;
    dst[7] = r1.z;
    dst[8] = r2.z;
    return dst;
}
/**
 * Returns array of columns of a matrix.
 *
 * @param m The matrix.
 * @param dst The array columns of the matrix will be written to.
 * @returns `dst`.
 */
function columns(m, dst = [
    _vector3__WEBPACK_IMPORTED_MODULE_0__["create"](0, 0, 0),
    _vector3__WEBPACK_IMPORTED_MODULE_0__["create"](0, 0, 0),
    _vector3__WEBPACK_IMPORTED_MODULE_0__["create"](0, 0, 0)
]) {
    for (let i = 0, j = 0; i < 3; ++i, j += 3) {
        dst[i].x = m[j];
        dst[i].y = m[j + 1];
        dst[i].z = m[j + 2];
    }
    return dst;
}
/**
 * Copies three vectors to a matrix as columns.
 *
 * @param c0 The first column.
 * @param c1 The second column.
 * @param c2 The third column.
 * @param dst The matrix the columns will be written to.
 * @returns `dst`.
 */
function fromColumns(c0, c1, c2, dst = create()) {
    dst[0] = c0.x;
    dst[1] = c0.y;
    dst[2] = c0.z;
    dst[3] = c1.x;
    dst[4] = c1.y;
    dst[5] = c1.z;
    dst[6] = c2.x;
    dst[7] = c2.y;
    dst[8] = c2.z;
    return dst;
}
/**
 * Computes determinant of a matrix.
 *
 * @param m The matrix.
 * @returns The determinant.
 */
function determinant(m) {
    return m[0] * (m[4] * m[8] - m[7] * m[5]) +
        m[3] * (m[1] * m[8] - m[7] * m[2]) +
        m[6] * (m[1] * m[5] - m[4] * m[2]);
}
const staticMatrixColumns = [
    // Not using vector3.create here due to circular dependency.
    { x: 0, y: 0, z: 0 },
    { x: 0, y: 0, z: 0 },
    { x: 0, y: 0, z: 0 }
];
const staticMatrix = create();
/**
 * Solves a system of linear equations represented with a matrix and a vector,
 * i.e.:
 *
 * ```
 * m * (x, y ,z)^T = v
 * ```
 *
 * Uses Cramer's rule.
 * @see https://en.wikipedia.org/wiki/Cramer's_rule
 *
 * @param m The matrix of the system.
 * @param v The vector of the system.
 * @param dst The vector solution of the system will be written to.
 * @return `dst`.
 */
function solve(m, v, dst = _vector3__WEBPACK_IMPORTED_MODULE_0__["create"](0, 0, 0)) {
    const revDet = 1 / determinant(m);
    const [c0, c1, c2] = columns(m, staticMatrixColumns);
    dst.x = revDet * determinant(fromColumns(v, c1, c2, staticMatrix));
    dst.y = revDet * determinant(fromColumns(c0, v, c2, staticMatrix));
    dst.z = revDet * determinant(fromColumns(c0, c1, v, staticMatrix));
    return dst;
}


/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_TOLERANCE", function() { return DEFAULT_TOLERANCE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return areFuzzyEqual; });
const DEFAULT_TOLERANCE = 1e-6;
/**
 * Checks if two floating point number are within a tolerance from each other.
 *
 * @param a The first number.
 * @param b The second number.
 * @param tolerance The tolerance.
 * @returns `true` if the number are within the tolerance and `false` otherwise.
 */
function areFuzzyEqual(a, b, tolerance = DEFAULT_TOLERANCE) {
    const d = a - b;
    return -tolerance < d && d < tolerance;
}


/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZERO", function() { return ZERO; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ORIGIN", function() { return ORIGIN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "POSITIVE_X", function() { return POSITIVE_X; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NEGATIVE_X", function() { return NEGATIVE_X; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "POSITIVE_Y", function() { return POSITIVE_Y; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NEGATIVE_Y", function() { return NEGATIVE_Y; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "areEqual", function() { return areEqual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "areCollinear", function() { return areCollinear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "areFuzzyEqual", function() { return areFuzzyEqual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mulv", function() { return mulv; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "muln", function() { return muln; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divv", function() { return divv; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divn", function() { return divn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mod", function() { return mod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mix", function() { return mix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate45", function() { return rotate45; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate90", function() { return rotate90; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateNeg90", function() { return rotateNeg90; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "convert", function() { return convert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "crossZ", function() { return crossZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EMPTY", function() { return EMPTY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UNIT_BBOX", function() { return UNIT_BBOX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createBBox2", function() { return createBBox2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyBBox2", function() { return copyBBox2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bboxesOverlap", function() { return bboxesOverlap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pointIsInBBox", function() { return pointIsInBBox; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "computeBBoxForPoints", function() { return computeBBoxForPoints; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "X_AXIS", function() { return X_AXIS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Y_AXIS", function() { return Y_AXIS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLineFromPoints", function() { return getLineFromPoints; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSignedDistanceToLine", function() { return getSignedDistanceToLine; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createExtent2", function() { return createExtent2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyExtent2", function() { return copyExtent2; });
/* harmony import */ var _util_fuzzy_equal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(22);

/**
 * Creates a new vector and initializes it with given components.
 *
 * @param x X component of the vector.
 * @param y Y component of the vector.
 * @returns The vector.
 */
function create(x, y) {
    return { x, y };
}
const ZERO = create(0, 0);
const ORIGIN = ZERO;
const POSITIVE_X = create(1, 0);
const NEGATIVE_X = create(-1, 0);
const POSITIVE_Y = create(0, 1);
const NEGATIVE_Y = create(0, -1);
/**
 * Copies a vector to another one.
 *
 * @param src The source vector.
 * @param dst The vector the source vector will be copied to.
 * @returns `dst`.
 */
function copy(src, dst = create(0, 0)) {
    dst.x = src.x;
    dst.y = src.y;
    return dst;
}
/**
 * Checks if two vectors are strictly equal component-wise.
 *
 * @param v1 The first vector.
 * @param v2 The second vector.
 * @returns `true` if the vectors are equal and `false` otherwise.
 */
function areEqual(v1, v2) {
    return v1.x === v2.x && v1.y === v2.y;
}
/**
 * Checks if two vectors are collinear.
 *
 * @param v1 The first vector.
 * @param v2 The second vector.
 * @returns `true` if the vectors are collinear and `false` otherwise.
 */
function areCollinear(v1, v2) {
    return v1.x / v2.x === v1.y / v2.y;
}
/**
 * Checks if corresponding components of two vectors are all within given
 * tolerance from each other.
 *
 * @param v1 The first vector.
 * @param v2 The second vector.
 * @param tolerance The tolerance.
 * @returns `true` if the vectors are "fuzzy" equal and `false` otherwise.
 */
function areFuzzyEqual(v1, v2, tolerance = _util_fuzzy_equal__WEBPACK_IMPORTED_MODULE_0__["DEFAULT_TOLERANCE"]) {
    return (Object(_util_fuzzy_equal__WEBPACK_IMPORTED_MODULE_0__["default"])(v1.x, v2.x, tolerance) &&
        Object(_util_fuzzy_equal__WEBPACK_IMPORTED_MODULE_0__["default"])(v1.y, v2.y, tolerance));
}
/**
 * Adds two vector and stores the result into a third one, i.e. `dst = a + b`.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function add(a, b, dst = create(0, 0)) {
    dst.x = a.x + b.x;
    dst.y = a.y + b.y;
    return dst;
}
/**
 * Subtracts a vector from another one and stores the result to a third one, i.e.
 * `dst = a - b`.
 *
 * @param a The minuend vector.
 * @param b The subtrahend vector.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function sub(a, b, dst = create(0, 0)) {
    dst.x = a.x - b.x;
    dst.y = a.y - b.y;
    return dst;
}
/**
 * Multiplies two vectors component-wise and stores the result into a third one.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function mulv(a, b, dst = create(0, 0)) {
    dst.x = a.x * b.x;
    dst.y = a.y * b.y;
    return dst;
}
/**
 * Multiplies a vector by a scalar and stores the result into a third vector.
 *
 * @param a The vector.
 * @param n The scalar.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function muln(a, n, dst = create(0, 0)) {
    dst.x = a.x * n;
    dst.y = a.y * n;
    return dst;
}
/**
 * Divides a vector by another one component wise and stores the result into a
 * third one.
 *
 * @param a The dividend vector.
 * @param b The divisor vector.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function divv(a, b, dst = create(0, 0)) {
    dst.x = a.x / b.x;
    dst.y = a.y / b.y;
    return dst;
}
/**
 * Divides a vector by a scalar and stores the result into a third vector.
 *
 * @param a The dividend vector.
 * @param n The scalar.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function divn(a, n, dst = create(0, 0)) {
    dst.x = a.x / n;
    dst.y = a.y / n;
    return dst;
}
/**
 * Calculates the reminder after division of a's components by n and stores the result into a third vector.
 *
 * @param a The dividend vector.
 * @param n The scalar.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function mod(a, n, dst = create(0, 0)) {
    dst.x = a.x % n;
    dst.y = a.y % n;
    return dst;
}
/**
 * Linearly interpolates between two vectors, i.e. computes
 * `(1 - factor) * a + factor * b`, and writes the result into a third vector.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @param factor The interpolation factor.
 * @param dst The vector the result will be written to.
 * @returns `dst`.
 */
function mix(a, b, factor, dst = create(0, 0)) {
    dst.x = (1 - factor) * a.x + factor * b.x;
    dst.y = (1 - factor) * a.y + factor * b.y;
    return dst;
}
/**
 * Rotates a vector by a given angle and stores the result into a second vector.
 * Positive direction is from +X to +Y.
 *
 * @param v The vector to rotate.
 * @param angle The angle of rotation.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function rotate(v, angle, dst = create(0, 0)) {
    const x = v.x;
    const y = v.y;
    const angleCos = Math.cos(angle);
    const angleSin = Math.sin(angle);
    dst.x = angleCos * x - angleSin * y;
    dst.y = angleSin * x + angleCos * y;
    return dst;
}
/**
 * Rotates a vector by 45 degrees and stores the result into a second vector.
 * Analogous to `rotate(v, Math.PI / 4, dst)`, but faster.
 *
 * @param v The vector to rotate.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function rotate45(v, dst = create(0, 0)) {
    const y = v.y;
    const s = Math.SQRT1_2;
    dst.y = s * v.x + s * v.y;
    dst.x = s * v.x - s * y;
    return dst;
}
/**
 * Rotates a vector by 90 degrees and stores the result into a second vector.
 * Analogous to `rotate(v, Math.PI / 2, dst)`, but faster.
 *
 * @param v The vector to rotate.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function rotate90(v, dst = create(0, 0)) {
    const y = v.y;
    dst.y = v.x;
    dst.x = -y;
    return dst;
}
/**
 * Rotates a vector by -90 degrees and stores the result into a second vector.
 * Analogous to `rotate(v, -Math.PI / 2, dst)`, but faster.
 *
 * @param v The vector to rotate.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function rotateNeg90(v, dst = create(0, 0)) {
    const y = v.y;
    dst.y = -v.x;
    dst.x = y;
    return dst;
}
/**
 * Inverts signs of components of a vector and stores the result into a second
 * vector. Analogous to `rotate(v, Math.PI, dst)` (or `rotate(v, -Math.PI, dst)`,
 * which is the same), but faster.
 *
 * @param v The vector to invert.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function invert(v, dst = create(0, 0)) {
    dst.x = -v.x;
    dst.y = -v.y;
    return dst;
}
/**
 * Computes length of a vector.
 *
 * @param v The vector.
 * @returns The length.
 */
function length(v) {
    return Math.hypot(v.x, v.y);
}
/**
 * Computes distance between ends of two vectors.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @returns The distance, i.e. `length(sub(a, b))`.
 */
function distance(a, b) {
    return Math.hypot(a.x - b.x, a.y - b.y);
}
/**
 * Divides a vector by its length (thus making it a unit vector) and stores the
 * result to another one.
 *
 * @param v The vector to be normalized.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function normalize(v, dst = create(0, 0)) {
    return divn(v, length(v), dst);
}
/**
 * Converts each component of vector.
 *
 * @param v The vector to be converted.
 * @param converter The component converter.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function convert(v, converter, dst = create(0, 0)) {
    dst.x = converter(v.x);
    dst.y = converter(v.y);
    return dst;
}
/**
 * Computes dot product of two vectors.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @returns The dot product.
 */
function dot(a, b) {
    return a.x * b.x + a.y * b.y;
}
/**
 * Computes Z-component of a cross product of two vectors.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @returns Z-component of the cross product.
 */
function crossZ(a, b) {
    return a.x * b.y - a.y * b.x;
}
const EMPTY = {
    minX: 0,
    maxX: 0,
    minY: 0,
    maxY: 0
};
const UNIT_BBOX = {
    minX: -1,
    maxX: 1,
    minY: -1,
    maxY: 1
};
/**
 * Creates a new bbox and initializes it with given components.
 *
 * @param minX Left border of the bbox.
 * @param maxX Right border of the bbox.
 * @param minY Lower border of the bbox.
 * @param maxY Upper border of the bbox.
 * @returns The bbox.
 */
function createBBox2(minX, maxX, minY, maxY) {
    return { minX, maxX, minY, maxY };
}
/**
 * Copies a bbox to another one.
 *
 * @param src The source bbox.
 * @param dst The bbox the source bbox will be copied to.
 * @returns `dst`.
 */
function copyBBox2(src, dst = createBBox2(0, 0, 0, 0)) {
    dst.minX = src.minX;
    dst.maxX = src.maxX;
    dst.minY = src.minY;
    dst.maxY = src.maxY;
    return dst;
}
/**
 * Checks if two bounding boxes overlap.
 *
 * @param bbox1 A bounding box.
 * @param bbox2 Another bounding box.
 * @returns `true` if given bounding boxes do overlap and `false` otherwise.
 */
function bboxesOverlap(bbox1, bbox2) {
    let leftBBox;
    let rightBBox;
    if (bbox1.minX < bbox2.minX) {
        leftBBox = bbox1;
        rightBBox = bbox2;
    }
    else {
        leftBBox = bbox2;
        rightBBox = bbox1;
    }
    let topBBox;
    let bottomBBox;
    if (bbox1.maxY > bbox2.maxY) {
        topBBox = bbox1;
        bottomBBox = bbox2;
    }
    else {
        topBBox = bbox2;
        bottomBBox = bbox1;
    }
    return rightBBox.minX < leftBBox.maxX && bottomBBox.maxY > topBBox.minY;
}
/**
 * Checks if a 2D point lies inside a bounding box or on its border.
 *
 * @param point The point.
 * @param bbox The bounding box.
 * @returns `true` if the point is inside of the box and `false` otherwise.
 */
function pointIsInBBox(point, bbox) {
    return bbox.minX <= point.x && point.x <= bbox.maxX &&
        bbox.minY <= point.y && point.y <= bbox.maxY;
}
/**
 * Computes bounding box of an array of points and stores it to a given object.
 *
 * @param points The array of points.
 * @param dst The bbox the result will be written to. Left unmodified if the array
 *      of points is empty.
 * @returns `dst`.
 */
function computeBBoxForPoints(points, dst = { minX: 0, maxX: 0, minY: 0, maxY: 0 }) {
    if (points.length === 0) {
        return dst;
    }
    dst.minX = dst.maxX = points[0].x;
    dst.minY = dst.maxY = points[0].y;
    for (let i = 1; i < points.length; ++i) {
        const { x, y } = points[i];
        if (x < dst.minX) {
            dst.minX = x;
        }
        if (x > dst.maxX) {
            dst.maxX = x;
        }
        if (y < dst.minY) {
            dst.minY = y;
        }
        if (y > dst.maxY) {
            dst.maxY = y;
        }
    }
    return dst;
}
const X_AXIS = {
    origin: ORIGIN,
    tangent: POSITIVE_X
};
const Y_AXIS = {
    origin: ORIGIN,
    tangent: POSITIVE_Y
};
function getLineFromPoints(p1, p2, dst = {
    origin: create(0, 0),
    tangent: create(0, 0)
}) {
    copy(p1, dst.origin);
    sub(p2, p1, dst.tangent);
    return dst;
}
/**
 * Computes signed distance from a point to a line.
 *
 * @param p The point.
 * @param l1 Start point of the line.
 * @param l2 End point of the line.
 * @returns Distance from the point to the line. It'll be greater than 0 if the
 *      point lies to the left of the line and less than 0 otherwise.
 */
function getSignedDistanceToLine(p, l) {
    const tangent = l.tangent;
    return dot(sub(p, l.origin), create(-tangent.y, tangent.x)) / length(tangent);
}
/**
 * Creates a new extent and initializes it with given components.
 *
 * @param width Width of the extent.
 * @param Height Height of the extent.
 * @returns The extent.
 */
function createExtent2(width, height) {
    return { width, height };
}
/**
 * Copies an extent to another one.
 *
 * @param src The source bbox.
 * @param dst The extent the source extent will be copied to.
 * @returns `dst`.
 */
function copyExtent2(src, dst = createExtent2(0, 0)) {
    dst.width = src.width;
    dst.height = src.height;
    return dst;
}


/***/ }),
/* 24 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return VectorApiAdapter; });
/* harmony import */ var _tile_based_adapter_adapter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(25);
/* harmony import */ var _primitive_icon_icon_buffer_writer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(35);
/* harmony import */ var _render_memory_sub_chunk__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(40);
/* harmony import */ var _billboard_identified_image_atlas_manager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(42);
/* harmony import */ var _font_df_font__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(44);
/* harmony import */ var _api_image_provider__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(46);
/* harmony import */ var _primitive_model_model_buffer_writer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(50);
/* harmony import */ var _primitive_polyline_textured_polyline_buffer_writer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(51);
/* harmony import */ var _billboard_image_manager__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(54);
/* harmony import */ var _primitive_polygon_textured_polygon_buffer_rewiter__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(55);
/* harmony import */ var _primitive_polygon_polygon_attribute_mapping__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(58);
/* harmony import */ var _primitive_polygon_textured_polygon_attribute_mapping__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(57);
/* harmony import */ var _primitive_billboard_rectangle_attribute_mapping__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(59);
/* harmony import */ var _primitive_label_point_label_attribute_mapping__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(60);
/* harmony import */ var _primitive_label_curved_label_attribute_mapping__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(61);
/* harmony import */ var _primitive_polyline_polyline_attribute_mapping__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(62);
/* harmony import */ var _worker_tile_provider_worker_client__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(63);
/* harmony import */ var _worker_tile_provider_worker_messages__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(64);
/* harmony import */ var _primitive_polygon_transparent_polygon_attribute_mapping__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(66);
/* harmony import */ var _tile_based_adapter_tile_id__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(29);
/* harmony import */ var _util_idle_task_queue__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(67);
/* harmony import */ var _util_stat__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(34);
/* harmony import */ var _util_unique_id__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(31);
/* harmony import */ var _primitive_polygon_renderable_polygon__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(70);
/* harmony import */ var _primitive_polygon_renderable_textured_polygon__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(72);
/* harmony import */ var _primitive_polyline_renderable_polyline__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(73);
/* harmony import */ var _primitive_polyline_renderable_textured_polyline__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(74);
/* harmony import */ var _primitive_model_renderable_model__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(75);
/* harmony import */ var _tile_data__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(76);
/* harmony import */ var _primitive_manager_renderable_primitive_manager__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(77);
/* harmony import */ var _render_primitives_primitive_set_storage__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(79);
/* harmony import */ var _primitive_manager_polygon_manager__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(80);
/* harmony import */ var _render_primitives_disappearing_primitive_set_storage__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(81);
/* harmony import */ var _render_primitives_delayed_disappearing_primitive_set_storage__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(82);
/* harmony import */ var _primitive_manager_zoom_filterable_primitive_manager__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(83);
/* harmony import */ var _primitive_manager_external_mesh_manager__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(84);
/* harmony import */ var _primitive_billboard_rectangle_renderable_billboard_rectangle__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(85);
/* harmony import */ var _primitive_zoom_restricted_label__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(86);
/* harmony import */ var _primitive_zoom_restricted_icon__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(88);
/* harmony import */ var _util_task_queue__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(92);








































const WORLD_SIZE = 2.0;
const NORMAL_TILE_SIDE_SIZE_PX = 256; // tiles of normal size are optimized for displaying in a 256x256 css px square
function getTileSideSizePx(tileSize) {
    switch (tileSize) {
        case 1 /* X4 */:
            return NORMAL_TILE_SIDE_SIZE_PX * 2;
        case 2 /* X16 */:
            return NORMAL_TILE_SIDE_SIZE_PX * 4;
        default:
            return NORMAL_TILE_SIDE_SIZE_PX;
    }
}
const MAX_PERF_LOG_ITEMS_COUNT = 1024;
const QUEUE_TASK_PRIORITIES = {
    firstTilePortion: 20,
    secondTilePortion: 10
};
const DEFAULT_IDLE_TASK_PRIORITY = 0;
// The values are chosen empirically: https://st.yandex-team.ru/VECTOR-300#5be5b638523211001b9bd941
const MINZOOM_DELTAS = {
    pointLabels: 1,
    curvedLabels: 1,
    icons: 0.75
};
class VectorApiAdapter extends _tile_based_adapter_adapter__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(engine, camera, tileProviderWorkerUrl, layerName, { imageUrlTemplate, tileUrlTemplate, meshUrlTemplate, glyphRangeUrlTemplate }, tileSize = 0 /* X1 */, preloadedTilesBeltSize = 0) {
        super(engine, camera, tileSize, preloadedTilesBeltSize, layerName);
        this._tileSideSizePx = getTileSideSizePx(tileSize);
        this._perfLogItems = [];
        this._destroyables = [];
        this._tileProvider = new _worker_tile_provider_worker_client__WEBPACK_IMPORTED_MODULE_16__["TileProviderWorkerClient"](tileProviderWorkerUrl);
        this._tileProvider.sendMessage({
            type: _worker_tile_provider_worker_messages__WEBPACK_IMPORTED_MODULE_17__["TileProviderMessageType"].INIT,
            tileUrlTemplate,
            meshUrlTemplate,
            glyphRangeUrlTemplate
        }, 1 /* IMMEDIATE */);
        this._memoryManager = engine.memoryManager;
        this._glyphAtlas = engine.glyphAtlas;
        this._fontRegistry = engine.fontRegistry;
        this._imageManagerNearest = new _billboard_image_manager__WEBPACK_IMPORTED_MODULE_8__["ImageManager"](new _billboard_identified_image_atlas_manager__WEBPACK_IMPORTED_MODULE_3__["default"](engine.createImageAtlas({
            filter: 9728 /* NEAREST */,
            premultipliedAlpha: false
        })), new _api_image_provider__WEBPACK_IMPORTED_MODULE_5__["ApiImageProvider"](imageUrlTemplate));
        this._imageManagerLinear = new _billboard_image_manager__WEBPACK_IMPORTED_MODULE_8__["ImageManager"](new _billboard_identified_image_atlas_manager__WEBPACK_IMPORTED_MODULE_3__["default"](engine.createImageAtlas({
            filter: 9729 /* LINEAR */,
            premultipliedAlpha: true
        })), new _api_image_provider__WEBPACK_IMPORTED_MODULE_5__["ApiImageProvider"](imageUrlTemplate));
        const fadeEffect = engine.visibilityManager.fadeEffectDuration;
        const opaquePolygonsProvider = this.opaquePolygonsProvider = new _render_primitives_primitive_set_storage__WEBPACK_IMPORTED_MODULE_30__["default"]();
        const transparentPolygonsProvider = this.transparentPolygonsProvider = new _render_primitives_primitive_set_storage__WEBPACK_IMPORTED_MODULE_30__["default"]();
        const texturedPolygonsProvider = this.texturedPolygonsProvider = new _render_primitives_primitive_set_storage__WEBPACK_IMPORTED_MODULE_30__["default"]();
        const polylinesProvider = this.polylinesProvider = new _render_primitives_primitive_set_storage__WEBPACK_IMPORTED_MODULE_30__["default"]();
        const texturedPolylinesProvider = this.texturedPolylinesProvider = new _render_primitives_primitive_set_storage__WEBPACK_IMPORTED_MODULE_30__["default"]();
        const iconsProvider = this.iconsProvider = new _render_primitives_disappearing_primitive_set_storage__WEBPACK_IMPORTED_MODULE_32__["default"]();
        const pointLabelsProvider = this.pointLabelsProvider = new _render_primitives_delayed_disappearing_primitive_set_storage__WEBPACK_IMPORTED_MODULE_33__["default"](fadeEffect);
        const curvedLabelsProvider = this.curvedLabelsProvider = new _render_primitives_delayed_disappearing_primitive_set_storage__WEBPACK_IMPORTED_MODULE_33__["default"](fadeEffect);
        const modelsProvider = this.modelsProvider = new _render_primitives_primitive_set_storage__WEBPACK_IMPORTED_MODULE_30__["default"]();
        this._destroyables.push(pointLabelsProvider, curvedLabelsProvider);
        this._tileDataManagers = [
            new TileDataManager(new _primitive_manager_polygon_manager__WEBPACK_IMPORTED_MODULE_31__["default"](opaquePolygonsProvider, transparentPolygonsProvider), _tile_data__WEBPACK_IMPORTED_MODULE_28__["POLYGON_EXTRACTOR"]),
            new TileDataManager(new _primitive_manager_renderable_primitive_manager__WEBPACK_IMPORTED_MODULE_29__["default"](texturedPolygonsProvider), _tile_data__WEBPACK_IMPORTED_MODULE_28__["TEXTURED_POLYGON_EXTRACTOR"]),
            new TileDataManager(new _primitive_manager_renderable_primitive_manager__WEBPACK_IMPORTED_MODULE_29__["default"](polylinesProvider), _tile_data__WEBPACK_IMPORTED_MODULE_28__["POLYLINE_EXTRACTOR"]),
            new TileDataManager(new _primitive_manager_renderable_primitive_manager__WEBPACK_IMPORTED_MODULE_29__["default"](texturedPolylinesProvider), _tile_data__WEBPACK_IMPORTED_MODULE_28__["TEXTURED_POLYLINE_EXTRACTOR"]),
            new TileDataManager(new _primitive_manager_zoom_filterable_primitive_manager__WEBPACK_IMPORTED_MODULE_34__["default"](iconsProvider, camera), _tile_data__WEBPACK_IMPORTED_MODULE_28__["POINT_EXTRACTOR"]),
            new TileDataManager(new _primitive_manager_zoom_filterable_primitive_manager__WEBPACK_IMPORTED_MODULE_34__["default"](pointLabelsProvider, camera), _tile_data__WEBPACK_IMPORTED_MODULE_28__["POINT_LABEL_EXTRACTOR"]),
            new TileDataManager(new _primitive_manager_zoom_filterable_primitive_manager__WEBPACK_IMPORTED_MODULE_34__["default"](curvedLabelsProvider, camera), _tile_data__WEBPACK_IMPORTED_MODULE_28__["CURVED_LABEL_EXTRACTOR"]),
            new TileDataManager(new _primitive_manager_renderable_primitive_manager__WEBPACK_IMPORTED_MODULE_29__["default"](modelsProvider), _tile_data__WEBPACK_IMPORTED_MODULE_28__["MODEL_EXTRACTOR"]),
            new TileDataManager(new _primitive_manager_external_mesh_manager__WEBPACK_IMPORTED_MODULE_35__["default"](modelsProvider, this._tileProvider, this.engine.memoryManager), _tile_data__WEBPACK_IMPORTED_MODULE_28__["EXTERNAL_MESH_EXTRACTOR"])
        ];
        this._requestedTilesState = new Map();
        this._taskQueue = new _util_task_queue__WEBPACK_IMPORTED_MODULE_39__["default"]();
        this._minorTaskQueue = new _util_idle_task_queue__WEBPACK_IMPORTED_MODULE_20__["default"]();
        this._tileProvider.on(_worker_tile_provider_worker_messages__WEBPACK_IMPORTED_MODULE_17__["TileProviderMessageType"].TILE_RESPONSE, (response) => this._onTileProviderResponse(response));
        this._tileProvider.on(_worker_tile_provider_worker_messages__WEBPACK_IMPORTED_MODULE_17__["TileProviderMessageType"].TILE_ERROR, (response) => this._onTileError(response.tile));
        this._onCameraUpdate();
    }
    destroy() {
        this._tileProvider.destroy();
        for (const destroyable of this._destroyables) {
            destroyable.destroy();
        }
        super.destroy();
    }
    setTileUrlTemplate(tileUrlTemplate) {
        this._tileProvider.sendMessage({
            type: _worker_tile_provider_worker_messages__WEBPACK_IMPORTED_MODULE_17__["TileProviderMessageType"].TILE_URL_UPDATE,
            tileUrlTemplate
        }, 1 /* IMMEDIATE */);
        this._refreshCurrentTiles();
    }
    _createTileRequest(tileItem, priority) {
        const targetZoom = this._getTargetZoom();
        return Object.assign({}, tileItem, { priority, isVisible: this._isTileVisible(tileItem), zoomMin: targetZoom, zoomMax: targetZoom });
    }
    _requestTiles(requests) {
        const requestId = Object(_util_unique_id__WEBPACK_IMPORTED_MODULE_22__["uniqueId"])();
        this._onTilesRequest(requests, requestId);
        for (const request of requests) {
            const requestedTileData = {
                isGeometryReady: false,
                areLabelsReady: false
            };
            this._requestedTilesState.set(Object(_tile_based_adapter_tile_id__WEBPACK_IMPORTED_MODULE_19__["getTileId"])(request), requestedTileData);
        }
        const request = {
            type: _worker_tile_provider_worker_messages__WEBPACK_IMPORTED_MODULE_17__["TileProviderMessageType"].TILE_REQUEST_BATCH,
            responseType: _worker_tile_provider_worker_messages__WEBPACK_IMPORTED_MODULE_17__["TileProviderMessageType"].TILE_RESPONSE,
            errorType: _worker_tile_provider_worker_messages__WEBPACK_IMPORTED_MODULE_17__["TileProviderMessageType"].TILE_ERROR,
            requestId,
            requests
        };
        this._tileProvider.sendMessage(request, 1 /* IMMEDIATE */);
    }
    _cancelTileRequests(requests) {
        for (const request of requests) {
            this._requestedTilesState.delete(Object(_tile_based_adapter_tile_id__WEBPACK_IMPORTED_MODULE_19__["getTileId"])(request.tile));
        }
        this._onCancelTileRequests(requests);
        this._tileProvider.sendMessage({
            type: _worker_tile_provider_worker_messages__WEBPACK_IMPORTED_MODULE_17__["TileProviderMessageType"].TILE_REQUEST_CANCEL_BATCH,
            requests
        });
    }
    _onTileDataUpdate(dataToShow, dataToHide) {
        for (const primitiveManager of this._tileDataManagers) {
            primitiveManager.updatePrimitives(dataToShow, dataToHide);
        }
    }
    _onTileDestroy(_tileItem, data) {
        // release primitives that we've created in allocators
        for (const portion of data) {
            (portion.polygons || []).forEach(releasePrimitive);
            (portion.texturedPolygons || []).forEach(releasePrimitive);
            (portion.polylines || []).forEach(releasePrimitive);
            (portion.texturedPolylines || []).forEach(releasePrimitive);
            (portion.points || []).forEach(releasePrimitive);
            (portion.pointLabels || []).forEach(releasePrimitive);
            (portion.curvedLabels || []).forEach(releasePrimitive);
            (portion.models || []).forEach(releasePrimitive);
        }
    }
    _sendStatisticsBeforeDestroy() {
        super._sendStatisticsBeforeDestroy();
        if (this._perfLogItems.length === 0) {
            return;
        }
        const items = this._perfLogItems;
        items.sort((a, b) => a.parseTime - b.parseTime);
        const min = items[0];
        const max = items[items.length - 1];
        const median = items[Math.floor(items.length / 2)];
        Object(_util_stat__WEBPACK_IMPORTED_MODULE_21__["countTileParseTime"])(this._layerName, min.tile, min.parseTime, max.tile, max.parseTime, median.tile, median.parseTime);
    }
    _onTileProviderResponse(response) {
        this._pushPerfLogItem(response.tile, response.parseTime);
        const tile = response.tile;
        const taskPriority = QUEUE_TASK_PRIORITIES.firstTilePortion +
            this._getTilePriority(tile, this._isTileVisible(tile));
        this._taskQueue.enqueue({
            priority: taskPriority,
            execute: () => {
                // atlas must be updated notwithstanding the tile is active or not
                // as these new glyphs will be used in next tiles
                const atlas = response.glyphAtlasToUpdate;
                if (atlas) {
                    this._glyphAtlas.updateContent(atlas.width, atlas.height, atlas.data, new Map(atlas.glyphLocations));
                }
                const registry = response.fontRegistryToUpdate;
                if (registry) {
                    for (const fontData of registry) {
                        let font;
                        if (this._fontRegistry.contains(fontData.id)) {
                            font = this._fontRegistry.get(fontData.id);
                        }
                        else {
                            font = new _font_df_font__WEBPACK_IMPORTED_MODULE_4__["default"](fontData.id, fontData.xheight, fontData.margin);
                            this._fontRegistry.add(font);
                        }
                        font.addAllGlyphs(fontData.glyphs);
                    }
                }
                const requestId = response.requestId;
                if (!this._isTileStillActive(tile, requestId)) {
                    return;
                }
                // If tile is being refreshed don't visualize any portions until all of them are loaded to avoid a blink
                const isRefreshing = this._isTileRefreshing(tile);
                const iconsSplitted = splitImageDependantPrimitives(response.points, this._imageManagerNearest, (point) => point.styles[0].imageId);
                const texturedPolylinesSplitted = splitImageDependantPrimitives(response.texturedPolylines, this._imageManagerLinear, (polyline) => polyline.styles[0].inline.pattern.imageId);
                const texturedPolygonsImages = getImagesIfAllAllocated(response.texturedPolygons, this._imageManagerNearest, (polygon) => polygon.styles[0].pattern.imageId);
                this._taskQueue.enqueue({
                    priority: QUEUE_TASK_PRIORITIES.secondTilePortion +
                        this._getTilePriority(tile, this._isTileVisible(tile)),
                    execute: () => {
                        if (this._isTileStillActive(tile, response.requestId)) {
                            this._putTileData(tile, {
                                polygons: this._allocatePolygons(response),
                                models: this._allocateMeshes(response),
                                externalMeshes: response.externalMeshes,
                                polylines: this._allocatePolylines(response),
                                pointLabels: this._allocatePointLabels(response),
                                curvedLabels: this._allocateCurvedLabels(response),
                                points: this._allocateIcons(tile, iconsSplitted.primitivesWithAllocatedImages, iconsSplitted.allocatedImages),
                                texturedPolylines: this._allocateTexturedPolylines(tile, texturedPolylinesSplitted.primitivesWithAllocatedImages, texturedPolylinesSplitted.allocatedImages),
                                texturedPolygons: !texturedPolygonsImages.allocatedImages ?
                                    [] :
                                    this._allocateTexturedPolygons(tile, response.texturedPolygons, texturedPolygonsImages.allocatedImages, response.texturedPolygonPages)
                            }, requestId, !isRefreshing);
                            iconsSplitted.allocatedImages.forEach(releasePrimitive);
                            texturedPolylinesSplitted.allocatedImages.forEach(releasePrimitive);
                            if (texturedPolygonsImages.allocatedImages) {
                                texturedPolygonsImages.allocatedImages.forEach(releasePrimitive);
                            }
                            const requestedTileData = this._requestedTilesState.get(Object(_tile_based_adapter_tile_id__WEBPACK_IMPORTED_MODULE_19__["getTileId"])(tile));
                            if (requestedTileData !== undefined) {
                                // TODO: the data is synced on these two properties
                                //       and this code doesn't make much sense for now,
                                //       but it is left "as is" since it is not clear
                                //       how it will be changed in nearest future
                                requestedTileData.isGeometryReady = true;
                                requestedTileData.areLabelsReady = true;
                                this._onTileDataReady(tile, response.url);
                            }
                        }
                    }
                });
                const putDataPromises = [];
                putDataPromises.push(iconsSplitted.missingImages.then((images) => {
                    this._onMissingIconImagesReady(response, iconsSplitted, images);
                }));
                putDataPromises.push(texturedPolylinesSplitted.missingImages.then((images) => {
                    this._onMissingPolylineImagesReady(response, texturedPolylinesSplitted, images);
                }));
                if (texturedPolygonsImages.missingImages) {
                    putDataPromises.push(texturedPolygonsImages.missingImages.then((images) => this._onMissingPolygonImagesReady(response, images)));
                }
                if (isRefreshing) {
                    // When all the portions are loaded, put empty data to visuazlize it
                    Promise.all(putDataPromises).then(() => this._putTileData(tile, {}, requestId, true));
                }
            }
        });
    }
    _onMissingIconImagesReady(response, iconsSplitted, images) {
        const tile = response.tile;
        this._minorTaskQueue.enqueue({
            priority: DEFAULT_IDLE_TASK_PRIORITY +
                this._getTilePriority(tile, this._isTileVisible(tile)),
            execute: () => {
                if (this._isTileStillActive(tile, response.requestId)) {
                    const points = this._allocateIcons(tile, iconsSplitted.primitivesWithMissingImages, images);
                    this._putTileData(tile, { points }, response.requestId, false);
                }
                images.forEach(releasePrimitive);
            }
        });
    }
    _onMissingPolylineImagesReady(response, texturedPolylinesSplitted, images) {
        const tile = response.tile;
        this._minorTaskQueue.enqueue({
            priority: DEFAULT_IDLE_TASK_PRIORITY + this._getTilePriority(tile, this._isTileVisible(tile)),
            execute: () => {
                if (this._isTileStillActive(tile, response.requestId)) {
                    const texturedPolylines = this._allocateTexturedPolylines(tile, texturedPolylinesSplitted.primitivesWithMissingImages, images);
                    this._putTileData(tile, { texturedPolylines }, response.requestId, false);
                }
                images.forEach(releasePrimitive);
            }
        });
    }
    _onMissingPolygonImagesReady(response, images) {
        const tile = response.tile;
        this._minorTaskQueue.enqueue({
            priority: DEFAULT_IDLE_TASK_PRIORITY +
                this._getTilePriority(tile, this._isTileVisible(tile)),
            execute: () => {
                if (this._isTileStillActive(tile, response.requestId)) {
                    const texturedPolygons = this._allocateTexturedPolygons(tile, response.texturedPolygons, images, response.texturedPolygonPages);
                    this._putTileData(tile, { texturedPolygons }, response.requestId, false);
                }
                images.forEach(releasePrimitive);
            }
        });
    }
    _onTileError(tile) {
        super._onTileError(tile);
        this._requestedTilesState.delete(Object(_tile_based_adapter_tile_id__WEBPACK_IMPORTED_MODULE_19__["getTileId"])(tile));
    }
    _isTileVisible(tile) {
        return this._currentTiles.has(Object(_tile_based_adapter_tile_id__WEBPACK_IMPORTED_MODULE_19__["getTileId"])(tile));
    }
    _allocatePolygons(response) {
        const polygonPrimitives = new Array(response.polygons.length + response.transparentPolygons.length);
        const memoryChunks = new MemoryChunks(response.polygonPages, this._memoryManager, _primitive_polygon_polygon_attribute_mapping__WEBPACK_IMPORTED_MODULE_10__["POLYGON_ATTRIBUTE_MAPPING"]);
        const transparentPolygonsMemoryChunks = new MemoryChunks(response.transparentPolygonPages, this._memoryManager, _primitive_polygon_transparent_polygon_attribute_mapping__WEBPACK_IMPORTED_MODULE_18__["TRANSPARENT_POLYGON_ATTRIBUTE_MAPPING"]);
        let index = 0;
        for (let i = 0; i < response.polygons.length; i++, index++) {
            const { bufferLocation } = response.polygons[i];
            polygonPrimitives[index] = new _primitive_polygon_renderable_polygon__WEBPACK_IMPORTED_MODULE_23__["default"](new _render_memory_sub_chunk__WEBPACK_IMPORTED_MODULE_2__["default"](memoryChunks[bufferLocation.bufferIndex], bufferLocation), true);
        }
        for (let i = 0; i < response.transparentPolygons.length; i++, index++) {
            const { bufferLocation } = response.transparentPolygons[i];
            polygonPrimitives[index] = new _primitive_polygon_renderable_polygon__WEBPACK_IMPORTED_MODULE_23__["default"](new _render_memory_sub_chunk__WEBPACK_IMPORTED_MODULE_2__["default"](transparentPolygonsMemoryChunks[bufferLocation.bufferIndex], bufferLocation), false);
        }
        memoryChunks.forEach((chunk) => chunk.release());
        transparentPolygonsMemoryChunks.forEach((chunk) => chunk.release());
        return polygonPrimitives;
    }
    _allocateTexturedPolygons(tile, polygonDescriptions, images, texturedPolygonPages) {
        const texturedPolygonRewriter = new _primitive_polygon_textured_polygon_buffer_rewiter__WEBPACK_IMPORTED_MODULE_9__["default"](texturedPolygonPages);
        const worldToPxFactor = WORLD_SIZE / (this._tileSideSizePx * Math.pow(2, tile.zoom));
        const locations = polygonDescriptions.map((parsedPolygon, index) => {
            const image = images[index];
            if (image) {
                const allocatedImage = image;
                const pattern = parsedPolygon.styles[0].pattern;
                const imageScale = pattern.width / allocatedImage.descriptor.width;
                texturedPolygonRewriter.rewriteUV(parsedPolygon.bufferLocation, allocatedImage.bbox, worldToPxFactor * imageScale);
                return parsedPolygon.bufferLocation;
            }
            else {
                return null;
            }
        });
        const memoryChunks = new MemoryChunks(texturedPolygonPages, this._memoryManager, _primitive_polygon_textured_polygon_attribute_mapping__WEBPACK_IMPORTED_MODULE_11__["TEXTURED_POLYGON_ATTRIBUTE_MAPPING"]);
        const texturedPolygonPrimitives = [];
        for (let i = 0; i < locations.length; i++) {
            const location = locations[i];
            const image = images[i];
            if (location && image) {
                const texturedPolygonPrimitive = new _primitive_polygon_renderable_textured_polygon__WEBPACK_IMPORTED_MODULE_24__["default"](new _render_memory_sub_chunk__WEBPACK_IMPORTED_MODULE_2__["default"](memoryChunks[location.bufferIndex], location), image);
                texturedPolygonPrimitives.push(texturedPolygonPrimitive);
            }
        }
        memoryChunks.forEach((chunk) => chunk.release());
        return texturedPolygonPrimitives;
    }
    _allocateMeshes(tileResponse) {
        const memoryChunks = tileResponse.meshPages.map((page) => this._memoryManager.allocate(page.vertexBuffer, page.indexBuffer, _primitive_model_model_buffer_writer__WEBPACK_IMPORTED_MODULE_6__["default"].ATTRIBUTE_MAPPING));
        const meshPrimitives = tileResponse.meshes.map((mesh) => new _primitive_model_renderable_model__WEBPACK_IMPORTED_MODULE_27__["default"](new _render_memory_sub_chunk__WEBPACK_IMPORTED_MODULE_2__["default"](memoryChunks[mesh.bufferLocation.bufferIndex], mesh.bufferLocation)));
        memoryChunks.forEach((chunk) => chunk.release());
        return meshPrimitives;
    }
    _allocatePolylines(response) {
        const polylinePrimitives = new Array(response.polylines.length);
        const memoryChunks = new MemoryChunks(response.polylinePages, this._memoryManager, _primitive_polyline_polyline_attribute_mapping__WEBPACK_IMPORTED_MODULE_15__["POLYLINE_ATTRIBUTE_MAPPING"]);
        let index = 0;
        for (let i = 0; i < response.polylines.length; i++, index++) {
            const { bufferLocation } = response.polylines[i];
            polylinePrimitives[index] = new _primitive_polyline_renderable_polyline__WEBPACK_IMPORTED_MODULE_25__["default"](new _render_memory_sub_chunk__WEBPACK_IMPORTED_MODULE_2__["default"](memoryChunks[bufferLocation.bufferIndex], bufferLocation));
        }
        memoryChunks.forEach((chunk) => chunk.release());
        return polylinePrimitives;
    }
    _allocateTexturedPolylines(tile, parsedPolylines, images) {
        const texturedPolylineWriter = new _primitive_polyline_textured_polyline_buffer_writer__WEBPACK_IMPORTED_MODULE_7__["default"]();
        const worldToPxFactor = WORLD_SIZE / (this._tileSideSizePx * Math.pow(2, tile.zoom));
        const locations = parsedPolylines.map((parsedPolyline, index) => {
            const image = images[index];
            if (image) {
                const style = parsedPolyline.styles[0];
                const width = (style.inline || style.outline).strokeWidth;
                const imageLocation = image.bbox;
                // image size may not match polyline's strokeWidth, so it must be scaled accordingly in
                // both directions, this factor can be passed to the writer in worldToPxFactor updated.
                const pixelRatio = width / (imageLocation.maxY - imageLocation.minY);
                return texturedPolylineWriter.writeTexturedPolyline(parsedPolyline, width, worldToPxFactor * pixelRatio, imageLocation, style.zIndex);
            }
            else {
                return null;
            }
        });
        const pages = texturedPolylineWriter.getBuffers();
        const memoryChunks = new MemoryChunks(pages, this._memoryManager, _primitive_polyline_textured_polyline_buffer_writer__WEBPACK_IMPORTED_MODULE_7__["default"].ATTRIBUTE_MAPPING);
        const texturedPolylinePrimitives = [];
        for (let i = 0; i < locations.length; i++) {
            const location = locations[i];
            const image = images[i];
            if (location && image) {
                const texturedPolylinePrimitive = new _primitive_polyline_renderable_textured_polyline__WEBPACK_IMPORTED_MODULE_26__["default"](new _render_memory_sub_chunk__WEBPACK_IMPORTED_MODULE_2__["default"](memoryChunks[location.bufferIndex], location), image);
                texturedPolylinePrimitives.push(texturedPolylinePrimitive);
            }
        }
        memoryChunks.forEach((chunk) => chunk.release());
        return texturedPolylinePrimitives;
    }
    _allocatePointLabels(response) {
        const memoryChunks = new MemoryChunks(response.pointLabelPages, this._memoryManager, _primitive_label_point_label_attribute_mapping__WEBPACK_IMPORTED_MODULE_13__["POINT_LABEL_ATTRIBUTE_MAPPING"]);
        const backgroundMemoryChunks = new MemoryChunks(response.pointLabelBackgroundPages, this._memoryManager, _primitive_billboard_rectangle_attribute_mapping__WEBPACK_IMPORTED_MODULE_12__["BILLBOARD_RECTANGLE_ATTRIBUTE_MAPPING"]);
        const pointLabels = response.pointLabels.map(({ bufferLocation, backgroundBufferLocation }) => {
            const backgroundPrimitive = backgroundBufferLocation ?
                new _primitive_billboard_rectangle_renderable_billboard_rectangle__WEBPACK_IMPORTED_MODULE_36__["default"](new _render_memory_sub_chunk__WEBPACK_IMPORTED_MODULE_2__["default"](backgroundMemoryChunks[backgroundBufferLocation.bufferIndex], backgroundBufferLocation)) :
                undefined;
            const labelPrimitive = new _primitive_zoom_restricted_label__WEBPACK_IMPORTED_MODULE_37__["ZoomRestrictedLabel"](new _render_memory_sub_chunk__WEBPACK_IMPORTED_MODULE_2__["default"](memoryChunks[bufferLocation.bufferIndex], bufferLocation), this._glyphAtlas, this._computeMinZoom(response.tile, MINZOOM_DELTAS.pointLabels), backgroundPrimitive);
            if (backgroundPrimitive) {
                backgroundPrimitive.release();
            }
            return labelPrimitive;
        });
        backgroundMemoryChunks.forEach((chunk) => chunk.release());
        memoryChunks.forEach((chunk) => chunk.release());
        return pointLabels;
    }
    _allocateCurvedLabels(response) {
        const memoryChunks = new MemoryChunks(response.curvedLabelPages, this._memoryManager, _primitive_label_curved_label_attribute_mapping__WEBPACK_IMPORTED_MODULE_14__["CURVED_LABEL_ATTRIBUTE_MAPPING"]);
        const curvedLabelPrimitives = response.curvedLabels.map(({ bufferLocation }) => new _primitive_zoom_restricted_label__WEBPACK_IMPORTED_MODULE_37__["ZoomRestrictedLabel"](new _render_memory_sub_chunk__WEBPACK_IMPORTED_MODULE_2__["default"](memoryChunks[bufferLocation.bufferIndex], bufferLocation), this._glyphAtlas, this._computeMinZoom(response.tile, MINZOOM_DELTAS.curvedLabels)));
        memoryChunks.forEach((chunk) => chunk.release());
        return curvedLabelPrimitives;
    }
    _allocateIcons(tile, parsedIcons, images) {
        const iconWriter = new _primitive_icon_icon_buffer_writer__WEBPACK_IMPORTED_MODULE_1__["default"]();
        const locations = parsedIcons.map((parsedIcon, index) => {
            const image = images[index];
            if (image) {
                const style = parsedIcon.styles[0];
                const size = image.descriptor;
                const pixelRatio = style.width / size.width;
                return iconWriter.writeIcon(parsedIcon, image.bbox, size, style.offset, pixelRatio);
            }
            else {
                return null;
            }
        });
        const pages = iconWriter.getBuffers();
        const memoryChunks = new MemoryChunks(pages, this._memoryManager, _primitive_icon_icon_buffer_writer__WEBPACK_IMPORTED_MODULE_1__["default"].ATTRIBUTE_MAPPING);
        const iconPrimitives = [];
        for (let i = 0; i < locations.length; i++) {
            const location = locations[i];
            const image = images[i];
            if (location && image) {
                const iconPrimitive = new _primitive_zoom_restricted_icon__WEBPACK_IMPORTED_MODULE_38__["ZoomRestrictedIcon"](new _render_memory_sub_chunk__WEBPACK_IMPORTED_MODULE_2__["default"](memoryChunks[location.bufferIndex], location), image, this._computeMinZoom(tile, MINZOOM_DELTAS.icons));
                iconPrimitives.push(iconPrimitive);
            }
        }
        memoryChunks.forEach((chunk) => chunk.release());
        return iconPrimitives;
    }
    /**
     * Computes a minimum zoom an object should be still displayed on.
     *
     * @param tile Tile the object belongs to.
     * @param delta Tolerance of the visibility to zooming out, default value was empirically chosen.
     * @returns Minimum zoom for the object.
     */
    _computeMinZoom(tile, delta = 1) {
        return tile.zoom - this._zoomShift - this._targetZoomShift - delta;
    }
    _pushPerfLogItem(tile, parseTime) {
        if (this._perfLogItems.length < MAX_PERF_LOG_ITEMS_COUNT) {
            this._perfLogItems.push({ tile, parseTime });
        }
    }
}
/**
 * Helper class for allocation of an array of memory chunks.
 */
class MemoryChunks extends Array {
    constructor(pages, memoryManager, attribMapping) {
        super(pages.length);
        for (let i = 0; i < pages.length; i++) {
            this[i] = memoryManager.allocate(pages[i].vertexBuffer, pages[i].indexBuffer, attribMapping);
        }
    }
}
/**
 * Data managers responsible for specific type of primitives. It just extracts them from TileData and
 * updates appropriate primitive provider.
 */
class TileDataManager {
    constructor(primitiveManager, primitveExtractor) {
        this._primitiveManager = primitiveManager;
        this._primitiveExtractor = primitveExtractor;
    }
    updatePrimitives(toShow, toHide) {
        this._primitiveManager.updateScene(this._primitiveExtractor(toShow), this._primitiveExtractor(toHide));
    }
}
function releasePrimitive(primitive) {
    if (primitive) {
        primitive.release();
    }
}
/**
 * Turns rejection of original promise into null-value resolution. Nulls on appropriate places
 * are required in allocation of textured primitives.
 */
function nullifyRejection(promise) {
    return new Promise((resolve) => promise.then(resolve, () => resolve(null)));
}
/**
 * Splits primitives into two lists: those that have required images allocated and those which images are to be
 * requested. Required images returned in corresponing arrays (requested images as promises).
 */
function splitImageDependantPrimitives(primitives, imageManager, idMapper) {
    const primitivesWithAllocatedImages = [];
    const allocatedImages = [];
    const primitivesWithMissingImages = [];
    const missingImageIds = [];
    for (const primitive of primitives) {
        const id = idMapper(primitive);
        const allocatedImage = imageManager.getImage(id);
        if (allocatedImage) {
            primitivesWithAllocatedImages.push(primitive);
            allocatedImages.push(allocatedImage);
        }
        else {
            primitivesWithMissingImages.push(primitive);
            missingImageIds.push(nullifyRejection(imageManager.requestImage(id)));
        }
    }
    return {
        primitivesWithAllocatedImages,
        allocatedImages,
        primitivesWithMissingImages,
        missingImages: Promise.all(missingImageIds)
    };
}
/**
 * Returns either array of allocated images (if all required images are on the spot) or promises for them (if at least
 * one required image is not yet allocated).
 */
function getImagesIfAllAllocated(primitives, imageManager, idMapper) {
    let isAnyMissing = false;
    const allocatedImages = new Array(primitives.length);
    const missingImages = new Array(primitives.length);
    for (let i = 0; i < primitives.length; i++) {
        const primitive = primitives[i];
        const id = idMapper(primitive);
        const allocatedImage = imageManager.getImage(id);
        if (allocatedImage) {
            allocatedImages[i] = allocatedImage;
        }
        else {
            isAnyMissing = true;
            missingImages[i] = nullifyRejection(imageManager.requestImage(id));
        }
    }
    if (isAnyMissing) {
        for (let i = 0; i < primitives.length; i++) {
            if (allocatedImages[i]) {
                missingImages[i] = Promise.resolve(allocatedImages[i]);
            }
        }
        return { missingImages: Promise.all(missingImages) };
    }
    else {
        return { allocatedImages };
    }
}


/***/ }),
/* 25 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TileBasedAdapter; });
/* harmony import */ var _adapter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(26);
/* harmony import */ var _util_tile_system__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(28);
/* harmony import */ var _util_iterable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3);
/* harmony import */ var _tile_id__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(29);
/* harmony import */ var _util_event_emitter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(14);
/* harmony import */ var _math_vector2__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(23);
/* harmony import */ var _util_worker__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(30);
/* harmony import */ var _util_visible_tile__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(32);
/* harmony import */ var _belt_tiles__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(33);
/* harmony import */ var _util_stat__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(34);










const NO_TILES_TO_HANDLE = [];
const MAX_PERF_LOG_ITEMS_COUNT = 1024;
// To select which tile to load camera zoom is rounded so the shift is 0.5.
const TARGET_ZOOM_SHIFT = 0.25;
const VISIBLE_TILE_PRIORITY = 200;
function* flattenVisibleDataPortions(tiles) {
    for (const tile of tiles) {
        yield* tile.data.visible;
    }
}
function getZoomShift(tileSize) {
    switch (tileSize) {
        case 1 /* X4 */:
            return -1;
        case 2 /* X16 */:
            return -2;
        default:
            return 0;
    }
}
/**
 * Base class for adapters that get their data in tiles. Content of tiles that come into field of view should
 * be requested, as well as content of invisible tiles should be removed, also tiles on different zoom levels can
 * overlap each other. Managing of all these cases and other tile-specific logic is the responsibility of this class.
 */
class TileBasedAdapter extends _adapter__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(engine, camera, tileSize = 0 /* X1 */, preloadedTilesBeltSize = 0, layerName = '') {
        super(engine, camera);
        this._layerName = layerName;
        this._zoomShift = getZoomShift(tileSize);
        this._targetZoomShift = TARGET_ZOOM_SHIFT;
        this._engineRenderListener = () => this._onEngineRenderEvent();
        this.engine.renderer.onRender.addListener(this._engineRenderListener);
        this._currentTiles = new Map();
        this._allTiles = new Map();
        this._readyForRenderTiles = [];
        this.onTileReady = new _util_event_emitter__WEBPACK_IMPORTED_MODULE_4__["EventEmitter"]();
        this.onTileLoadChange = new _util_event_emitter__WEBPACK_IMPORTED_MODULE_4__["EventEmitter"]();
        this._requestedTiles = new Map();
        this._tilesToRefresh = new Set();
        this._beltSize = preloadedTilesBeltSize;
        // Sometimes the adapter isn't destroyed, just the page closes. Listen
        // for that and send measurements to the statface.
        window.addEventListener('beforeunload', this._onBeforeUnloadListener = this._sendStatisticsBeforeDestroy.bind(this));
        this._tileLoadLogs = [];
    }
    destroy() {
        window.removeEventListener('beforeunload', this._onBeforeUnloadListener);
        this._sendStatisticsBeforeDestroy();
        this.engine.renderer.onRender.removeListener(this._engineRenderListener);
        super.destroy();
    }
    getVisibleTilesNumber() {
        return this._currentTiles.size;
    }
    getPendingTilesNumber() {
        let pendingCounter = 0;
        this._requestedTiles.forEach((requestedTile) => {
            if (this._currentTiles.get(Object(_tile_id__WEBPACK_IMPORTED_MODULE_3__["getTileId"])(requestedTile.tileItem))) {
                pendingCounter++;
            }
        });
        return pendingCounter;
    }
    _getTargetZoom() {
        return Math.floor(this.camera.zoom + this._targetZoomShift);
    }
    /**
     * @param tileItem The tile to which the data belongs.
     * @param data Data portion to be shown in tile once it is ready to visualize.
     * @param requestId ID of the request data was requested with. Based on this the data is being displayed, stored for
     * future use or discarded.
     * @param visualize Is this data portion enough to render this tile and replace overlapped ones if any.
     */
    _putTileData(tileItem, data, requestId = _util_worker__WEBPACK_IMPORTED_MODULE_6__["NO_ID"], visualize = true) {
        const tile = this._allTiles.get(Object(_tile_id__WEBPACK_IMPORTED_MODULE_3__["getTileId"])(tileItem));
        if (!tile) {
            // Data recieved late and probably the tile had been destroyed.
            // Destroy data too.
            this._onTileDestroy(tileItem, [data]);
            return;
        }
        // NO_ID passed here means concrete adapter doesn't care to label tile data with a requestId which most likely
        // means adapter keeps its data as a whole, not splitting it into portions and, therefore, doesn't need its data
        // to be maintained separately as visible/actual. In this case the data is always treated like an actual data.
        if (requestId === tile.data.visibleRequestId && requestId !== _util_worker__WEBPACK_IMPORTED_MODULE_6__["NO_ID"]) {
            tile.data.visible.push(data);
            if (tile.isVisible) {
                // The data is currently displayed so the new portion is added to the scene.
                this._updateTileDataPortions([data], []);
            }
        }
        else if (requestId === tile.data.actualRequestId) {
            // The data is actual and either is just being put into the tile or visualizes all `actual` tile data.
            this._putActualTileData(tile, data, visualize);
        }
        else {
            // The data is neither visible nor actual. Destroy data.
            this._onTileDestroy(tileItem, [data]);
        }
    }
    _onCameraUpdate() {
        const camera = this.camera;
        const zoom = this._getTargetZoom();
        const newCurrent = new Set(Object(_util_visible_tile__WEBPACK_IMPORTED_MODULE_7__["computeVisibleTiles"])(camera.getVisibleRegion(), camera.getVisibleRegionBBox(), camera.options.wrapModeX, camera.options.wrapModeY, Math.max(0, zoom + this._zoomShift)));
        // this._currentTiles contains currently visible tiles, newCurrent contains set of tiles visible from updated
        // camera position, compare these two sets and call this._onVisibleTilesChanged() if there is a difference.
        if (newCurrent.size !== this._currentTiles.size ||
            Object(_util_iterable__WEBPACK_IMPORTED_MODULE_2__["oneOfIterable"])(newCurrent, (tile) => !this._currentTiles.has(Object(_tile_id__WEBPACK_IMPORTED_MODULE_3__["getTileId"])(tile)))) {
            this._onVisibleTilesChanged(newCurrent);
        }
        // this checks prevents leaks of tiles when quick zoom-in/zoom-out happens
        for (const tile of this._currentTiles.values()) {
            if (tile.isReadyToVisualize) {
                this._checkTileReplacements(tile);
            }
        }
    }
    _onTilesRequest(requests, requestId = _util_worker__WEBPACK_IMPORTED_MODULE_6__["NO_ID"]) {
        for (const tileRequest of requests) {
            const requestedTileData = {
                info: {
                    priority: tileRequest.priority
                },
                loadTimestamps: {
                    queued: performance.now(),
                    loaded: 0,
                    rendered: 0,
                    ready: 0
                },
                tileItem: tileRequest
            };
            const tileId = Object(_tile_id__WEBPACK_IMPORTED_MODULE_3__["getTileId"])(tileRequest);
            this._requestedTiles.set(tileId, requestedTileData);
            this._readyTilesChange = true;
            const tile = this._allTiles.get(tileId);
            if (tile) {
                tile.data.actualRequestId = requestId;
            }
        }
    }
    _onCancelTileRequests(requests) {
        for (const request of requests) {
            const tileId = Object(_tile_id__WEBPACK_IMPORTED_MODULE_3__["getTileId"])(request.tile);
            if (this._requestedTiles.delete(tileId)) {
                this._readyTilesChange = true;
                this._tilesToRefresh.delete(tileId);
            }
        }
    }
    _onTileError(tileItem) {
        const tileId = Object(_tile_id__WEBPACK_IMPORTED_MODULE_3__["getTileId"])(tileItem);
        if (this._requestedTiles.delete(tileId)) {
            this._readyTilesChange = true;
            this._tilesToRefresh.delete(tileId);
        }
    }
    /**
     * This method is where the whole magic happens, it manages replacement of current set of visible/preloaded tiles
     * with a new one.
     */
    _onVisibleTilesChanged(visibleTiles) {
        this._currentTiles.clear();
        const tilesToRequest = [];
        for (const tileItem of visibleTiles) {
            let tile = this._allTiles.get(Object(_tile_id__WEBPACK_IMPORTED_MODULE_3__["getTileId"])(tileItem));
            if (!tile) {
                tile = new Tile(tileItem);
                this._allTiles.set(tile.id, tile);
                this._currentTiles.set(tile.id, tile);
                tilesToRequest.push(this._createTileRequest(tileItem, this._getTilePriority(tile.tileItem, true)));
            }
            else {
                this._currentTiles.set(tile.id, tile);
            }
        }
        if (tilesToRequest.length > 0) {
            this._requestTiles(tilesToRequest);
        }
        const beltTiles = new Map();
        for (const beltTileItem of Object(_belt_tiles__WEBPACK_IMPORTED_MODULE_8__["calculateBeltTiles"])(visibleTiles, this._beltSize, this.camera.options.wrapModeX === 2 /* REPEAT */, this.camera.options.wrapModeY === 2 /* REPEAT */)) {
            beltTiles.set(Object(_tile_id__WEBPACK_IMPORTED_MODULE_3__["getTileId"])(beltTileItem), beltTileItem);
        }
        const beltTilesToRequest = [];
        for (const beltTileItem of beltTiles.values()) {
            const tileId = Object(_tile_id__WEBPACK_IMPORTED_MODULE_3__["getTileId"])(beltTileItem);
            let tile = this._allTiles.get(tileId);
            if (!tile) {
                tile = new Tile(beltTileItem);
                this._allTiles.set(tileId, tile);
                beltTilesToRequest.push(this._createTileRequest(beltTileItem, this._getTilePriority(beltTileItem, false)));
            }
        }
        if (beltTilesToRequest.length) {
            this._requestTiles(beltTilesToRequest);
        }
        // broke current relationships to set them up again but with new set of visible tiles
        for (const tile of this._allTiles.values()) {
            tile.toBeReplacedBy.clear();
            tile.replacementFor.clear();
        }
        // TODO: optimize this n^2 relationships resolver
        for (const currentTile of this._currentTiles.values()) {
            for (const tile of this._allTiles.values()) {
                if (tile.isReadyToVisualize &&
                    (Object(_util_tile_system__WEBPACK_IMPORTED_MODULE_1__["isParent"])(tile.tileItem, currentTile.tileItem) || Object(_util_tile_system__WEBPACK_IMPORTED_MODULE_1__["isParent"])(currentTile.tileItem, tile.tileItem))) {
                    tile.toBeReplacedBy.add(currentTile);
                    currentTile.replacementFor.add(tile);
                }
            }
        }
        // remove invisible
        const tilesToCancel = [];
        for (const tile of this._allTiles.values()) {
            if (!this._currentTiles.has(tile.id) && tile.toBeReplacedBy.size === 0) {
                if (tile.isVisible) {
                    this._updateTileData(NO_TILES_TO_HANDLE, [tile]);
                }
                if (!beltTiles.get(tile.id)) {
                    this._destroyTile(tile);
                    tilesToCancel.push(tile);
                }
            }
        }
        if (tilesToCancel.length) {
            // issue cancellation also in case there are non processed data enqueued to try to save some efforts
            this._cancelTileRequests(tilesToCancelations(tilesToCancel));
        }
    }
    _refreshCurrentTiles() {
        const tilesToRequest = [];
        for (const tile of this._currentTiles.values()) {
            const tileItem = tile.tileItem;
            const tileRequest = this._createTileRequest(tileItem, this._getTilePriority(tile.tileItem, true));
            tilesToRequest.push(tileRequest);
            this._tilesToRefresh.add(Object(_tile_id__WEBPACK_IMPORTED_MODULE_3__["getTileId"])(tile.tileItem));
        }
        this._cancelTileRequests(tilesToCancelations(this._currentTiles.values()));
        this._requestTiles(tilesToRequest);
    }
    _onTileDataReady(tileItem, url) {
        const tileId = Object(_tile_id__WEBPACK_IMPORTED_MODULE_3__["getTileId"])(tileItem);
        const tileData = this._requestedTiles.get(tileId);
        this._requestedTiles.delete(tileId);
        this._tilesToRefresh.delete(tileId);
        tileData.info.url = url;
        tileData.loadTimestamps.loaded = performance.now();
        if (this._tileLoadLogs.length < MAX_PERF_LOG_ITEMS_COUNT) {
            this._tileLoadLogs.push({
                tileItem,
                processingTime: tileData.loadTimestamps.loaded - tileData.loadTimestamps.queued
            });
        }
        this._readyForRenderTiles.push(tileData);
        if (this._currentTiles.get(tileId)) {
            this._readyTilesChange = true;
        }
    }
    _isTileStillActive(tileItem, requestId = _util_worker__WEBPACK_IMPORTED_MODULE_6__["NO_ID"]) {
        const tile = this._allTiles.get(Object(_tile_id__WEBPACK_IMPORTED_MODULE_3__["getTileId"])(tileItem));
        if (!tile) {
            return false;
        }
        const isRequestActive = tile.data.actualRequestId === requestId || tile.data.visibleRequestId === requestId;
        return isRequestActive;
    }
    _isTileRefreshing(tile) {
        return this._tilesToRefresh.has(Object(_tile_id__WEBPACK_IMPORTED_MODULE_3__["getTileId"])(tile));
    }
    _getTilePriority(tile, isVisible) {
        const center = this._createTileCoordinateSystem().toTileCoordinates(this.camera.center);
        const zoomDiff = Math.ceil(this.camera.zoom) - tile.zoom;
        const distance = _math_vector2__WEBPACK_IMPORTED_MODULE_5__["distance"](tile, {
            x: Math.floor(center.x / Math.pow(2, zoomDiff)),
            y: Math.floor(center.y / Math.pow(2, zoomDiff))
        });
        return (isVisible ? VISIBLE_TILE_PRIORITY : 0) + 1 / (distance + 1);
    }
    _sendStatisticsBeforeDestroy() {
        if (this._tileLoadLogs.length === 0) {
            return;
        }
        const accumulatedTimings = new Map();
        accumulatedTimings.set('average', {
            sum: 0,
            number: 0
        });
        this._tileLoadLogs.forEach((logItem) => {
            accumulatedTimings.get('average').sum += logItem.processingTime;
            accumulatedTimings.get('average').number++;
            const zoom = logItem.tileItem.zoom.toString();
            if (!accumulatedTimings.has(zoom)) {
                accumulatedTimings.set(zoom, {
                    sum: 0,
                    number: 0
                });
            }
            accumulatedTimings.get(zoom).sum += logItem.processingTime;
            accumulatedTimings.get(zoom).number++;
        });
        const result = [];
        for (const item of accumulatedTimings) {
            result.push({
                zoom: item[0],
                time: (item[1].sum / item[1].number)
            });
        }
        Object(_util_stat__WEBPACK_IMPORTED_MODULE_9__["countTileProcessingTime"])(this._layerName, result);
    }
    /**
     * Puts actual data into the tile and optionally visualizes it.
     *
     * @param tile Tile to put data into.
     * @param data Data to be stored in the tile until visualization.
     * @param visualize If `true` replaces `visible` tile data with `actual` tile data and updates the scene.
     */
    _putActualTileData(tile, data, visualize) {
        tile.data.actual.push(data);
        if (visualize) {
            this._visualizeTile(tile);
        }
    }
    /**
     * Visualizes tile `actual` data: replaces tile `visible` data with tile `actual` data, adds it to the scene,
     * removes old visible data from the scene and destroys it, checks tile replacements and updates `visibleRequestId`.
     * @param tile Tile to visualize.
     */
    _visualizeTile(tile) {
        const toDestroy = tile.data.visible;
        tile.data.visible = tile.data.actual;
        tile.data.actual = [];
        tile.data.visibleRequestId = tile.data.actualRequestId;
        if (!tile.isReadyToVisualize) {
            tile.isReadyToVisualize = true;
            this._checkTileReplacements(tile);
        }
        else if (tile.isVisible) {
            this._updateTileDataPortions(tile.data.visible, []);
        }
        if (toDestroy.length > 0) {
            this._updateTileDataPortions([], toDestroy);
            this._onTileDestroy(tile.tileItem, toDestroy);
        }
    }
    _createTileCoordinateSystem() {
        return new _util_tile_system__WEBPACK_IMPORTED_MODULE_1__["default"](this.camera.zoom);
    }
    // We need do detect when tile is rendered to collect perfomance metrics.
    // We expect that tile will be rendered with first render event after
    // tile data is added to scene.
    _onEngineRenderEvent() {
        if (this._readyForRenderTiles.length) {
            this._readyForRenderTiles.forEach((tileData) => {
                if (this._currentTiles.has(Object(_tile_id__WEBPACK_IMPORTED_MODULE_3__["getTileId"])(tileData.tileItem))) {
                    tileData.loadTimestamps.rendered = performance.now();
                    tileData.loadTimestamps.ready = performance.now();
                    this.onTileReady.fire(tileData);
                }
            });
            this._readyForRenderTiles.length = 0;
        }
        if (this._readyTilesChange) {
            this.onTileLoadChange.fire({
                totalTileNumber: this.getVisibleTilesNumber(),
                readyTileNumber: this.getVisibleTilesNumber() - this.getPendingTilesNumber()
            });
            this._readyTilesChange = false;
        }
    }
    /**
     * Shows/hides tiles if they are not shown/hidden yet. It notifies subclasses by calling appropriate
     * abstract method. Even though visible/invisible tiles are not supposed to be shown/hidden again,
     * there are cases where it simplifies tile visualization logic.
     * It is important to have exactly "update", not "add"/"remove" separately, as some business logic may rely on it,
     * e.g. morphing visible data or managing shared resources.
     */
    _updateTileData(toShow, toRemove) {
        const dataToShow = Array.from(flattenVisibleDataPortions(toShow));
        const dataToRemove = Array.from(flattenVisibleDataPortions(toRemove));
        this._updateTileDataPortions(dataToShow, dataToRemove);
        for (const tile of toShow) {
            tile.isVisible = true;
        }
        for (const tile of toRemove) {
            tile.isVisible = false;
        }
    }
    _updateTileDataPortions(toShow, toRemove) {
        this._onTileDataUpdate(toShow, toRemove);
    }
    /**
     * Removes tile if is not removed with calling all appropriate callbacks (abstract methods)
     * to notify descendant classes. Even though removed tile is not supposed to be removed again,
     * allowing this makes much simpler tile management, especially in tile replacements logic where multiple
     * tiles can have links to the same tile (that is to be removed).
     */
    _destroyTile(tile) {
        if (!tile.isRemoved) {
            tile.isRemoved = true;
            this._allTiles.delete(tile.id);
            this._currentTiles.delete(tile.id);
            this._onTileDestroy(tile.tileItem, [...tile.data.actual, ...tile.data.visible]);
        }
    }
    /**
     * Checks tiles that could be replaced by this one, should be called when tile becomes ready to visualize.
     * As overlapping relationships can happen in both directions (children by parents / parent by children) this
     * method goes one step deeper, i.e. it check not only tiles that should be replaced (to remove them),
     * but also all tiles that cover the replaced ones (to show them).
     */
    _checkTileReplacements(tile) {
        const toDestroy = new Set();
        const toShow = new Set();
        const toHide = new Set();
        for (const tileToReplace of tile.replacementFor) {
            if (Object(_util_iterable__WEBPACK_IMPORTED_MODULE_2__["allOfIterable"])(tileToReplace.toBeReplacedBy, (tile) => tile.isReadyToVisualize)) {
                if (tileToReplace.isVisible) {
                    toHide.add(tileToReplace);
                }
                if (!tileToReplace.isRemoved) {
                    toDestroy.add(tileToReplace);
                }
                for (const tileToShow of tileToReplace.toBeReplacedBy) {
                    if (!tileToShow.isVisible) {
                        toShow.add(tileToShow);
                    }
                }
            }
        }
        if (tile.replacementFor.size === 0 && !tile.isVisible) {
            toShow.add(tile);
        }
        if (toShow.size > 0 || toHide.size > 0) {
            this._updateTileData(toShow, toHide);
        }
        for (const tileToDestroy of toDestroy) {
            this._destroyTile(tileToDestroy);
        }
        if (toDestroy.size > 0) {
            this._cancelTileRequests(tilesToCancelations(toDestroy));
        }
    }
}
/**
 * This class is the main unit of the whole process of tile management. It stores visualizable data and links to
 * dependant tiles (for parent/child overlapping cases).
 */
class Tile {
    constructor(tileItem) {
        this.data = {
            actual: [],
            visible: [],
            actualRequestId: _util_worker__WEBPACK_IMPORTED_MODULE_6__["NO_ID"],
            visibleRequestId: _util_worker__WEBPACK_IMPORTED_MODULE_6__["NO_ID"]
        };
        this.tileItem = tileItem;
        this.id = `${tileItem.x}:${tileItem.y}:${tileItem.zoom}`;
        this.isReadyToVisualize = false;
        this.isVisible = false;
        this.isRemoved = false;
        this.toBeReplacedBy = new Set();
        this.replacementFor = new Set();
    }
}
function tilesToCancelations(tiles) {
    return Array.from(tiles, (tile) => ({
        tile: tile.tileItem,
        requestId: tile.data.actualRequestId
    }));
}


/***/ }),
/* 26 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Adapter; });
/* harmony import */ var _util_function__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27);

class Adapter {
    constructor(engine, camera, cameraUpdateDelay = 5) {
        this.engine = engine;
        this.camera = camera;
        this._cameraUpdateListener = Object(_util_function__WEBPACK_IMPORTED_MODULE_0__["debounce"])(this._onCameraUpdate.bind(this), cameraUpdateDelay);
        camera.onUpdate.addListener(this._cameraUpdateListener);
    }
    destroy() {
        this.camera.onUpdate.removeListener(this._cameraUpdateListener);
    }
    /**
     * Camera update handler, by default do nothing.
     */
    _onCameraUpdate() { }
}


/***/ }),
/* 27 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "debounce", function() { return debounce; });
/**
 * Creates new function which execution is "debounced".
 */
function debounce(func, wait) {
    let timeout = 0;
    return (...args) => {
        const later = () => {
            timeout = 0;
            func(...args);
        };
        if (timeout) {
            clearTimeout(timeout);
        }
        timeout = setTimeout(later, wait);
    };
}


/***/ }),
/* 28 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isParent", function() { return isParent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TileCoordinateSystem; });
/* harmony import */ var _math_scalar__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(16);

/**
 * @return `true` if the first param overlaps the second in tile hierarchy.
 */
function isParent(potentialParent, possibleChild) {
    const zoomDiff = possibleChild.zoom - potentialParent.zoom;
    return zoomDiff > 0 &&
        possibleChild.x >> zoomDiff === potentialParent.x &&
        possibleChild.y >> zoomDiff === potentialParent.y;
}
class TileCoordinateSystem {
    constructor(zoom) {
        this._zoom = Math.ceil(Object(_math_scalar__WEBPACK_IMPORTED_MODULE_0__["clamp"])(zoom, 0, 31));
        this._tileSize = 2 / (1 << this._zoom);
    }
    getZoom() {
        return this._zoom;
    }
    /**
     * @return Tile side length in units of the world coordinate system.
     */
    getTileSize() {
        return this._tileSize;
    }
    /**
     * @return Top left corner coordinates of the tile.
     */
    getTileOffset(tile) {
        return {
            x: this.getTileSize() * tile.x - 1,
            y: 1 - this.getTileSize() * tile.y
        };
    }
    toTileCoordinates(worldCoordinates) {
        return {
            x: (worldCoordinates.x + 1) / this._tileSize,
            y: (1 - worldCoordinates.y) / this._tileSize
        };
    }
}


/***/ }),
/* 29 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTileIdByRawValues", function() { return getTileIdByRawValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTileId", function() { return getTileId; });
function getTileIdByRawValues(x, y, zoom) {
    return `${x}:${y}:${zoom}`;
}
function getTileId(tile) {
    return getTileIdByRawValues(tile.x, tile.y, tile.zoom);
}


/***/ }),
/* 30 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NO_ID", function() { return NO_ID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "messageIs", function() { return messageIs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebWorkerCommunicator", function() { return WebWorkerCommunicator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebWorkerClient", function() { return WebWorkerClient; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebWorkerImplementation", function() { return WebWorkerImplementation; });
/* harmony import */ var _event_emitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(14);
/* harmony import */ var _unique_id__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(31);
/**
 * Base interface for webworker messages, both incoming and outgoing ones.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Transferable
 */


const MESSAGE_BATCH_MAX_SIZE = 50;
const FLUSH_TIMEOUT = 50;
// each subsequent message debounces postMessage call, that can lead to infinite delay, this const limits it
const MAX_FLUSH_TIMEOUT = 250;
const NO_ID = -1;
/**
 * Checks message type with type guarding. It gives a little bit more elegant alternative
 * to tagged type unions providing the same type safety.
 *
 * @param message to be checked
 * @param type the value of the "type" property
 * @return {boolean}
 */
function messageIs(message, type) {
    return message.type === type;
}
/**
 * Base class for both sides of a webworker: its implementation (separate js that is run in a worker thread) and
 * a controller for the main thread. They have similar mechanism of sending/receiving messages that is implement here.
 */
class WebWorkerCommunicator {
    constructor(addressee) {
        this._addressee = addressee;
        this._events = new _event_emitter__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this._listeners = new Map();
        this._transferableExtractors = new Map();
        this._messages = [];
        this._transferables = [];
        this._timeoutHandle = 0;
        this._flushMessagesBinded = this._flushMessages.bind(this);
    }
    setTransferableExtractor(type, extractor) {
        this._transferableExtractors.set(type, extractor);
    }
    /**
     * Send a message to the opposite side of the web worker communication channel.
     * Messages are batched by delaying postMessage call to group messages that come during this delay and minimize
     * the number of interprocess communications that badly affect performance.
     *
     * @param message Message to be sent.
     * @param urgency IMMEDIATE forces message to be sent immediately (synchronous call) with no batching delay,
     *                DEFAULT debounces sending for another FLUSH_TIMEOUT.
     */
    sendMessage(message, urgency = 0 /* DEFAULT */) {
        const transferableExtractor = this._transferableExtractors.get(message.type);
        const transferables = transferableExtractor ? transferableExtractor(message) : undefined;
        const isFirstMessageInBatch = (this._messages.length === 0);
        if (isFirstMessageInBatch) {
            this._firstMessageTime = performance.now();
        }
        // Send messages asynchronously packing them into one message.
        // We don't want to abuse the web worker communication channel and
        // send messages asynchronously in short period of time or many messages synchronously.
        this._messages.push(message);
        if (transferables) {
            this._transferables = this._transferables.concat(transferables);
        }
        clearTimeout(this._timeoutHandle);
        if (this._messages.length > MESSAGE_BATCH_MAX_SIZE ||
            urgency === 1 /* IMMEDIATE */ ||
            (!isFirstMessageInBatch && (performance.now() - this._firstMessageTime) > MAX_FLUSH_TIMEOUT)) {
            this._flushMessages();
        }
        else {
            this._timeoutHandle = setTimeout(this._flushMessagesBinded, FLUSH_TIMEOUT);
        }
    }
    /**
     * Sends request message to/from worker as promise, the other side can respond and the promise is resolved.
     * Request/response is synchronized by the requestId field.
     */
    request(request, urgency) {
        return new Promise((resolve, reject) => {
            if (request.requestId === NO_ID) {
                request.requestId = Object(_unique_id__WEBPACK_IMPORTED_MODULE_1__["uniqueId"])();
            }
            const listener = (message) => {
                if (messageIs(message, request.responseType) &&
                    message.requestId === request.requestId) {
                    resolve(message);
                    this._events.removeListener(listener);
                }
                if (messageIs(message, request.errorType) &&
                    message.requestId === request.requestId) {
                    reject();
                    this.off(listener);
                }
            };
            this._events.addListener(listener);
            this.sendMessage(request, urgency);
        });
    }
    /**
     * Responds to provided request.
     */
    respond(request, response, urgency) {
        response.requestId = request.requestId;
        this.sendMessage(response, urgency);
    }
    /**
     * Sets a listener to specific type of incoming messages.
     */
    on(type, listener) {
        const typeSafeListener = (message) => {
            if (messageIs(message, type)) {
                listener(message);
            }
        };
        this._listeners.set(listener, typeSafeListener);
        this._events.addListener(typeSafeListener);
    }
    /**
     * Removes incoming messages listener.
     */
    off(listener) {
        const typeSafeListener = this._listeners.get(listener);
        if (typeSafeListener) {
            this._events.removeListener(typeSafeListener);
        }
    }
    /**
     * Starts listening for incoming messages.
     */
    listen() {
        this._addressee.onmessage = ({ data: messages }) => {
            for (const message of messages) {
                this.onMessage(message);
            }
        };
    }
    /**
     * Handler of incoming messages.
     */
    onMessage(message) {
        this._events.fire(message);
    }
    _flushMessages() {
        this._addressee.postMessage(this._messages, this._transferables);
        this._messages.length = 0;
        this._transferables.length = 0;
    }
}
/**
 * Base class for a webworker controller for the main thread code.
 * It also wraps creation of a native Worker.
 */
class WebWorkerClient extends WebWorkerCommunicator {
    /**
     * @param url URL of webworker's deployed js file
     */
    constructor(url) {
        const worker = new Worker(url);
        super(worker);
        this._worker = worker;
        this.listen();
    }
    destroy() {
        this._worker.terminate();
    }
}
/**
 * Base class for a webworker thread implementation. Concrete class should be the entry point for a webworker js build:
 *     new ConcreteWebWorkerImplementation(<DedicatedWorkerGlobalScope>self).run();
 */
class WebWorkerImplementation extends WebWorkerCommunicator {
    run() {
        this.listen();
    }
}


/***/ }),
/* 31 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "uniqueId", function() { return uniqueId; });
let id = 1;
/**
 * Generates unique id
*/
function uniqueId() {
    return id++;
}


/***/ }),
/* 32 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "computeVisibleTiles", function() { return computeVisibleTiles; });
const TILE_0_0_0 = { x: 0, y: 0, zoom: 0 };
/**
 * Computes set of tiles visible through a camera. Tiles in the set are guaranteed
 * to be unique.
 *
 * FIXME(dmikis) The uniqueness guarantee is broken currently, but code that uses
 *      this function doesn't suffer from that.
 *
 * @param camera The camera.
 * @returns An iterator over visible tile items.
 */
function* computeVisibleTiles(visibleRegion, visibleRegionBBox, wrapModeX, wrapModeY, zoom) {
    if (zoom === 0) {
        // The only tile on zoom 0 encompasses the whole world. Thus there's
        // little to no point computing that camera sees it: we can tell that
        // right away.
        yield TILE_0_0_0;
        return;
    }
    const tileCount = 1 << zoom;
    const tileIdxMask = tileCount - 1;
    // The idea behind the code below is quite simple: determine columns of the
    // tile grid that are visible to the camera, then for each column find
    // range of row indices that are visible.
    // Here's how we approach computing tile indices from world coordinates.
    // First, we transform world coordinates from [-1, 1] range to [0, 2],
    // dealing with inconsistency with Y axis direction in world and tile grid
    // coordinate system. Let's designate such a coordinate as C (for either X
    // or Y). Size of a tile is 2 / tileCount. Thus,
    //
    //      tileIdx = Math.floor(C / (2 / tileCount))
    //              = Math.floor(C * tileCount / 2)
    //
    const { minX, maxX, minY, maxY } = visibleRegionBBox;
    const minTX = Math.floor((minX + 1) * tileCount / 2);
    const maxTX = Math.floor((maxX + 1) * tileCount / 2);
    const columnCount = maxTX - minTX + 1;
    // Arrays of indices of bottommost and topmost tiles correspondingly for
    // each column.
    // FIXME(dmikis) If number of columns is too large, we'll consume a lot of
    //      memory here. There's a method to do without the arrays, but it's a
    //      bit more complicated to implement.
    const minYs = new Array(columnCount);
    const maxYs = new Array(columnCount);
    // Common sense suggests that those indices can't be greater (less) than the
    // index of a tile row intersected by a line y = minY (y = maxY). Note that
    // maxY corresponds to a tile row with lesser index, not other way around.
    minYs.fill(Math.floor((1 - minY) * tileCount / 2));
    maxYs.fill(Math.floor((1 - maxY) * tileCount / 2));
    const visiblePolygonLength = visibleRegion.length;
    let prevX = visibleRegion[visiblePolygonLength - 1].x + 1;
    let prevY = 1 - visibleRegion[visiblePolygonLength - 1].y;
    let prevTX = Math.floor(prevX * tileCount / 2);
    let prevTY = Math.floor(prevY * tileCount / 2);
    // Iterate over edges of visible polygon of the camera to compute index of
    // topmost and bottommost tiles for each column.
    for (let i = 0; i < visiblePolygonLength; ++i) {
        const x = visibleRegion[i].x + 1;
        const y = 1 - visibleRegion[i].y;
        const tx = Math.floor(x * tileCount / 2);
        const ty = Math.floor(y * tileCount / 2);
        // For each edge we compute 4-connected line of tiles on the tile grid.
        // Length of a 4-connected line always equals Manhattan distance between
        // its ends. However, to avoid unnecessary computation, we omit last tile
        // for every edge. But, since the polygon is closed, we'll iterate over
        // all tiles intersected by edges anyway.
        const l = Math.abs(tx - prevTX) + Math.abs(ty - prevTY);
        const lx = x - prevX;
        const ly = y - prevY;
        const dtx = lx > 0 ? 1 : -1;
        const dty = ly > 0 ? 1 : -1;
        const a = 2 * dtx * ly;
        const b = -2 * dtx * lx;
        const c = dtx * tileCount * (lx * prevY - ly * prevX) + a * (~dtx >>> 31);
        for (let i = 0, tx = prevTX, ty = prevTY; i < l; ++i) {
            const intercept = a * tx + b * ty + c;
            // The math here is somewhat cumbersome to avoid divisions, but the
            // essence is that we try to check through which side the edge of
            // visible polygon exits the tile. Depending on that we "move" to
            // next tile in either vertical or horizontal direction.
            if (0 <= intercept && intercept <= -b) {
                tx += dtx;
            }
            else {
                ty += dty;
            }
            const yIdx = tx - minTX;
            if (maxYs[yIdx] < ty) {
                maxYs[yIdx] = ty;
            }
            if (minYs[yIdx] > ty) {
                minYs[yIdx] = ty;
            }
        }
        prevX = x;
        prevY = y;
        prevTX = tx;
        prevTY = ty;
    }
    // If the world is repeated along X axis, we need to "fold" the array of columns,
    // i.e. compute union of row intervals for columns tileCount indices apart.
    if (wrapModeX === 2 /* REPEAT */ && columnCount > tileCount) {
        for (let i = 0; i < tileCount; ++i) {
            for (let j = i + tileCount; j < columnCount; j += tileCount) {
                if (maxYs[i] < maxYs[j]) {
                    maxYs[i] = maxYs[j];
                }
                if (minYs[i] > minYs[j]) {
                    minYs[i] = minYs[j];
                }
            }
        }
    }
    // If the world is repeated along Y axis, we need to wrap indices in minYs
    // and maxYs arrays to [0, tileCount) interval.
    if (wrapModeY === 2 /* REPEAT */) {
        for (let i = 0; i < columnCount && i < tileCount; ++i) {
            const dy = maxYs[i] - minYs[i];
            // If there's more than tileCount rows between maxY and minY, then the
            // world is encompassed somewhere within visible region.
            if (dy > tileCount) {
                minYs[i] = 0;
                maxYs[i] = tileIdxMask;
            }
            else {
                const minY = minYs[i] &= tileIdxMask;
                maxYs[i] = minY + dy;
            }
        }
    }
    else {
        for (let i = 0; i < columnCount && i < tileCount; ++i) {
            minYs[i] = Math.max(minYs[i], 0);
            maxYs[i] = Math.min(maxYs[i], tileIdxMask);
        }
    }
    if (wrapModeX === 2 /* REPEAT */) {
        for (let i = 0; i < columnCount && i < tileCount; ++i) {
            const tx = (i + minTX) & tileIdxMask;
            for (let ty = minYs[i]; ty <= maxYs[i]; ++ty) {
                yield {
                    x: tx,
                    y: ty & tileIdxMask,
                    zoom
                };
            }
        }
    }
    else {
        for (let tx = Math.max(minTX, 0), txEnd = Math.min(maxTX, tileIdxMask); tx <= txEnd; ++tx) {
            const i = tx - minTX;
            for (let ty = minYs[i]; ty <= maxYs[i]; ++ty) {
                yield {
                    x: tx,
                    y: ty & tileIdxMask,
                    zoom
                };
            }
        }
    }
}


/***/ }),
/* 33 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "calculateBeltTiles", function() { return calculateBeltTiles; });
/* harmony import */ var _tile_id__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(29);
/* harmony import */ var _math_vector2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(23);
/* harmony import */ var _math_scalar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(16);



const LEFT_SIDE = {
    direction: _math_vector2__WEBPACK_IMPORTED_MODULE_1__["create"](0, -1),
    normal: _math_vector2__WEBPACK_IMPORTED_MODULE_1__["create"](-1, 0),
    diagonal: _math_vector2__WEBPACK_IMPORTED_MODULE_1__["create"](-1, -1),
    prevSide: () => BOTTOM_SIDE,
    nextSide: () => TOP_SIDE
};
const RIGHT_SIDE = {
    direction: _math_vector2__WEBPACK_IMPORTED_MODULE_1__["create"](0, +1),
    normal: _math_vector2__WEBPACK_IMPORTED_MODULE_1__["create"](+1, 0),
    diagonal: _math_vector2__WEBPACK_IMPORTED_MODULE_1__["create"](+1, +1),
    prevSide: () => TOP_SIDE,
    nextSide: () => BOTTOM_SIDE
};
const TOP_SIDE = {
    direction: _math_vector2__WEBPACK_IMPORTED_MODULE_1__["create"](+1, 0),
    normal: _math_vector2__WEBPACK_IMPORTED_MODULE_1__["create"](0, -1),
    diagonal: _math_vector2__WEBPACK_IMPORTED_MODULE_1__["create"](+1, -1),
    prevSide: () => LEFT_SIDE,
    nextSide: () => RIGHT_SIDE
};
const BOTTOM_SIDE = {
    direction: _math_vector2__WEBPACK_IMPORTED_MODULE_1__["create"](-1, 0),
    normal: _math_vector2__WEBPACK_IMPORTED_MODULE_1__["create"](0, +1),
    diagonal: _math_vector2__WEBPACK_IMPORTED_MODULE_1__["create"](-1, +1),
    prevSide: () => RIGHT_SIDE,
    nextSide: () => LEFT_SIDE
};
/**
 * Adds tile to belt tiles if it doesn't fall out of the world. Cycling coordinates can't fall out,
 * they just got adjusted directly in tile item.
 */
function addTileIfAppropriate(tile, beltTiles, maxCoordinate, isXCycled, isYCycled) {
    tile.x = isXCycled ? Object(_math_scalar__WEBPACK_IMPORTED_MODULE_2__["cycleRestrict"])(tile.x, 0, maxCoordinate) : tile.x;
    tile.y = isYCycled ? Object(_math_scalar__WEBPACK_IMPORTED_MODULE_2__["cycleRestrict"])(tile.y, 0, maxCoordinate) : tile.y;
    if ((0 <= tile.x) && (tile.x < maxCoordinate) &&
        (0 <= tile.y) && (tile.y < maxCoordinate)) {
        beltTiles.set(Object(_tile_id__WEBPACK_IMPORTED_MODULE_0__["getTileId"])(tile), tile);
    }
}
/**
 * The algorithm is implemented as a state machine, this method produces belt tiles and sets appropriate state.
 * How to change this state (determine current tile and its side) is described in four TileSide implementations:
 * left, right, top and bottom.
 */
function move(tiles, state, size, maxCoordinate, isXCycled, isYCycled) {
    // add tiles outward in the direction of the normal
    for (let i = 1; i <= size; i++) {
        addTileIfAppropriate({
            x: state.currentTile.x + i * state.currentTileSide.normal.x,
            y: state.currentTile.y + i * state.currentTileSide.normal.y,
            zoom: state.currentTile.zoom
        }, state.beltTiles, maxCoordinate, isXCycled, isYCycled);
    }
    // check diagonal tile
    const diagonalNeighbour = tiles.get(Object(_tile_id__WEBPACK_IMPORTED_MODULE_0__["getTileIdByRawValues"])(state.currentTile.x + state.currentTileSide.diagonal.x, state.currentTile.y + state.currentTileSide.diagonal.y, state.currentTile.zoom));
    if (diagonalNeighbour) {
        state.currentTile = diagonalNeighbour;
        state.currentTileSide = state.currentTileSide.prevSide();
        return;
    }
    // check neighbour in the same direction
    const neighbour = tiles.get(Object(_tile_id__WEBPACK_IMPORTED_MODULE_0__["getTileIdByRawValues"])(state.currentTile.x + state.currentTileSide.direction.x, state.currentTile.y + state.currentTileSide.direction.y, state.currentTile.zoom));
    if (neighbour) {
        state.currentTile = neighbour;
        return;
    }
    // handle corner tiles
    for (let i = 1; i <= size; i++) {
        for (let j = 1; j <= size; j++) {
            addTileIfAppropriate({
                x: state.currentTile.x + i * state.currentTileSide.diagonal.x,
                y: state.currentTile.y + j * state.currentTileSide.diagonal.y,
                zoom: state.currentTile.zoom
            }, state.beltTiles, maxCoordinate, isXCycled, isYCycled);
        }
    }
    state.currentTileSide = state.currentTileSide.nextSide();
}
/**
 * Calculates tiles that surround provided region (set of tiles), the region must be one or more convex polygons
 * with no holes, otherwise correctness is not guaranteed. Multiple polygons can happen when the camera looks
 * at the edge of the world capturing cycled tiles from different sides.
 * The logic of including tiles in the "belt" is as follows: shortest distance from "outside" to any point
 * in the original region should be not less than tileSize * beltSize.
 *
 * @param tiles Set of tiles that cover a convex polygon.
 * @param beltSize "thickness" (in tiles) of the surrounding area.
 */
function calculateBeltTiles(tiles, beltSize, isXCycled, isYCycled) {
    // the algorithm in simple words:
    //   1. find a tile on an edge of the polygon (e.g. one of the leftmost ones)
    //   2. go around the polygon tile-by-tile adding surrounding tiles outwardly
    const indexedTiles = new Map();
    const beltTiles = new Map();
    // index tiles
    for (const tileItem of tiles) {
        indexedTiles.set(Object(_tile_id__WEBPACK_IMPORTED_MODULE_0__["getTileId"])(tileItem), tileItem);
    }
    // tiles are grouped into one or more convex polygons, process these polygons one by one
    const tilesToProcess = new Map(indexedTiles);
    while (tilesToProcess.size > 0) {
        let leftmostTile = { x: Number.POSITIVE_INFINITY, y: 0, zoom: 0 };
        // find the leftmost tile to start walking from
        for (const tileItem of tilesToProcess.values()) {
            if (tileItem.x < leftmostTile.x) {
                leftmostTile = tileItem;
            }
        }
        // save min/max y value per x coordinate to be able
        // to mark these tiles as processed (remove from tilesToProcess)
        const maxY = [];
        const minY = [];
        const initState = { currentTile: leftmostTile, currentTileSide: LEFT_SIDE, beltTiles };
        const state = Object.assign({}, initState);
        const maxCoordinate = Math.pow(2, leftmostTile.zoom);
        do {
            // move around while we don't reach the init position
            move(tilesToProcess, state, beltSize, maxCoordinate, isXCycled, isYCycled);
            const index = state.currentTile.x - initState.currentTile.x;
            maxY[index] = maxY[index] === undefined ? state.currentTile.y : Math.max(maxY[index], state.currentTile.y);
            minY[index] = minY[index] === undefined ? state.currentTile.y : Math.min(minY[index], state.currentTile.y);
        } while (state.currentTile !== initState.currentTile ||
            state.currentTileSide !== initState.currentTileSide);
        // mark tiles from current polygon as processed
        const zoom = leftmostTile.zoom;
        for (let i = 0; i < maxY.length; i++) {
            const x = leftmostTile.x + i;
            for (let y = minY[i]; y <= maxY[i]; y++) {
                tilesToProcess.delete(Object(_tile_id__WEBPACK_IMPORTED_MODULE_0__["getTileIdByRawValues"])(x, y, zoom));
            }
        }
    }
    // remove belt tiles that overlaps to avoid duplications
    for (const tileId of beltTiles.keys()) {
        if (indexedTiles.has(tileId)) {
            beltTiles.delete(tileId);
        }
    }
    return beltTiles.values();
}


/***/ }),
/* 34 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "countFps", function() { return countFps; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "countTileParseTime", function() { return countTileParseTime; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "countTileProcessingTime", function() { return countTileProcessingTime; });
const PROJECT_ID = 443;
function chooseStatUrl() {
    // FIXME(dmikis) Ideally we should be get this URLs from config.
    const STAT_URLS = {
        ru: 'https://yandex.ru/clck',
        com: 'https://yandex.com/clck',
        tr: 'https://yandex.com.tr/clck'
    };
    const tld = location.hostname.split('.').pop();
    switch (tld) {
        case 'tr':
            return STAT_URLS.tr;
        case 'com':
        case 'fr':
            return STAT_URLS.com;
        default:
            return STAT_URLS.ru;
    }
}
const STAT_URL = chooseStatUrl();
function stringifyVars(vars) {
    return Object.keys(vars).map((key) => `${key}=${vars[key]}`).join(',');
}
function count(pid, cid, path, vars) {
    const url = `${STAT_URL}/counter`;
    const data = `/dtype=stred/pid=${pid}/cid=${cid}` +
        `/path=${path.join('.')}/${vars ? `vars=${stringifyVars(vars)}/` : ''}`;
    if (!(navigator.sendBeacon && navigator.sendBeacon(url, data + '*'))) {
        const image = new Image();
        image.src = url + data + `rnd=${Date.now()}${Math.random() * 100 | 0}/*`;
    }
}
const PERF_COUNTER_ID = 73323;
/**
 * Log user's rendering perf to statface.
 *
 * @param fps FPS
 */
function countFps(fps) {
    const roundedFps = Math.floor(fps / 10) * 10;
    count(PROJECT_ID, PERF_COUNTER_ID, ['fps', `${roundedFps}-${roundedFps + 10}`, (fps * 100).toFixed()]);
}
function encodeTileItem(tileItem) {
    return `${tileItem.x}.${tileItem.y}.${tileItem.zoom}`;
}
function countTileParseTime(layer, minTimeTile, minTime, maxTimeTile, maxTime, medianTimeTile, medianTime) {
    count(PROJECT_ID, PERF_COUNTER_ID, [
        'tile_parse',
        layer
    ], {
        minTime: minTime.toFixed(),
        medianTime: medianTime.toFixed(),
        maxTime: maxTime.toFixed(),
        minTileItem: encodeTileItem(minTimeTile),
        medianTileItem: encodeTileItem(medianTimeTile),
        maxTileItem: encodeTileItem(maxTimeTile)
    });
}
function countTileProcessingTime(layer, items) {
    const varsToLog = {};
    items.forEach((item) => {
        if (item.zoom === 'average') {
            count(PROJECT_ID, PERF_COUNTER_ID, [
                'tile_processing_average',
                layer,
                (Math.ceil(item.time / 250) * 250).toString()
            ]);
        }
        varsToLog[item.zoom] = item.time.toFixed();
    });
    count(PROJECT_ID, PERF_COUNTER_ID, ['tile_processing', layer], varsToLog);
}


/***/ }),
/* 35 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return IconBufferWriter; });
/* harmony import */ var _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _util_buffer_writer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(36);


/**
 * Writer of geometry data of icons.
 */
class IconBufferWriter extends _util_buffer_writer__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor() {
        super(IconBufferWriter.ATTRIBUTE_MAPPING.vertexByteSize);
    }
    /**
     * Writes an icon to buffers.
     *
     * @param icon Icon to be written to buffer.
     * @param location Image location in atlas.
     * @param size Image size in atlas.
     * @param offset Offset of image points in CSS pixels.
     * @param pixelRatio Ratio of image size in CSS pixels to the size in atlas pixels.
     *
     * @returns Location of the icon data in buffers.
     */
    writeIcon(icon, location, size, offset, pixelRatio) {
        const top = offset.y;
        const bottom = offset.y + size.height * pixelRatio;
        const left = offset.x;
        const right = offset.x + size.width * pixelRatio;
        this.writeVertex(icon.position, left, bottom, location.minX, location.minY);
        this.writeVertex(icon.position, left, top, location.minX, location.maxY);
        this.writeVertex(icon.position, right, bottom, location.maxX, location.minY);
        this.writeVertex(icon.position, right, top, location.maxX, location.maxY);
        this.writeIndicesForContinuousStrip(4);
        return this.endMesh();
    }
    /**
     * Writes a vertex to the vertex buffer.
     *
     * @param position Position of the vertex in display coordinates.
     * @param uv UVs of the vertex.
     * @return Index of the written vertex.
     */
    writeVertex(position, displacementX, displacementY, uvX, uvY) {
        const vertexIdx = this.getCurrentVertexIdx();
        this._writeWorldCoordinate(position);
        this._writeHalfWords(displacementX, displacementY);
        this._writeHalfWords(uvX, uvY);
        return vertexIdx;
    }
}
/** Description of how a writer stores vertex data. */
IconBufferWriter.ATTRIBUTE_MAPPING = new _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__["AttributeMapping"]([
    [
        0 /* POSITION_HIGH */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        1 /* POSITION_LOW */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        6 /* DISPLACEMENT */,
        {
            size: 2,
            type: 5122 /* SHORT */,
            normalized: false
        }
    ],
    [
        4 /* UV */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: false
        }
    ]
]);


/***/ }),
/* 36 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WORD_BYTE_SIZE", function() { return WORD_BYTE_SIZE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BufferWriter; });
/* harmony import */ var _gputypes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(38);


const WORD_BYTE_SIZE = 4;
/**
 * Generates triangles of a fan of a given length as if it is continuous and
 * starts with 0.
 *
 * @param count Number of vertices in the fan.
 * @returns Iterator over indices of triangles.
 */
function* generateFan(count) {
    for (let i = 2; i < count; ++i) {
        yield 0;
        yield i - 1;
        yield i;
    }
}
/**
 * Generates triangles of a strip of a given length as if it is continuous and
 * starts with 0.
 *
 * @param count Number of vertices in the fan.
 * @returns Iterator over indices of triangles.
 */
function* generateStrip(count) {
    yield 0;
    yield 1;
    yield 2;
    let offset0 = 1;
    let offset1 = 2;
    for (let i = 3; i < count; ++i) {
        yield i - offset0;
        yield i - offset1;
        yield i;
        const tmp = offset0;
        offset0 = offset1;
        offset1 = tmp;
    }
}
/**
 * Vertex buffer helper class, that supports sequential writing interface and takes over some single-buffer operations.
 * It is an integral part of the buffer writer class and its main purpose is to make the writer's code easier.
 */
class VertexBuffer {
    /**
     * @param byteSize Initial size of the buffer in bytes. As it gets filled by words
     *      the size must be a multiply of 4.
     */
    constructor(byteSize) {
        this._nextWordOffset = 0;
        this._initBuffers(byteSize);
    }
    /**
     * @returns true if there is no free space remaining in buffer.
     */
    get isFull() {
        return this._nextWordOffset >= this._uint32View.length;
    }
    /**
     * @returns The number of words (4 bytes values) already written.
     */
    get occupiedSize() {
        return this._nextWordOffset;
    }
    /**
     * @return Max number of bytes this buffer is able to store. It can be increased by the extend() method.
     */
    get byteSize() {
        return this._uint32View.byteLength;
    }
    /**
     * Extends buffer to the new size. The new size must be not less than current one and it must be a multiply of 4.
     */
    extend(newByteSize) {
        // TODO assert newByteLength is larger than current _arrayBuffer and its is a multiply of the word size.
        const oldUint32View = this._uint32View;
        this._initBuffers(newByteSize);
        this._uint32View.set(oldUint32View);
    }
    /**
     * Appends value as a uint32 number.
     */
    pushUint32(value) {
        this._uint32View[this._nextWordOffset++] = value;
    }
    /**
     * Appends value as a float32 number.
     */
    pushFloat32(value) {
        this._float32View[this._nextWordOffset++] = value;
    }
    /**
     * @returns uint8 view of this buffer. The size of the view matches the amount of written data.
     */
    asUint32Array() {
        return this._uint32View.subarray(0, this.occupiedSize);
    }
    _initBuffers(byteLength) {
        const arrayBuffer = new ArrayBuffer(byteLength);
        this._uint32View = new Uint32Array(arrayBuffer);
        this._float32View = new Float32Array(arrayBuffer);
    }
    /**
     * Moves "tail" data (from the offset specified to the end of the buffer) of one buffer to another. The cursors of
     * buffers will be appropriately updated to reflect data changes.
     */
    static transferDataTail(src, dst, srcWordOffset, dstOffset = 0) {
        const tailLength = src.occupiedSize - srcWordOffset;
        const srcTail = src._uint32View.subarray(srcWordOffset, src.occupiedSize);
        dst._uint32View.set(srcTail, dstOffset);
        dst._nextWordOffset = tailLength;
        src._nextWordOffset = srcWordOffset;
    }
}
/**
 * Index buffer helper class, that supports sequential writing interface and takes over some single-buffer operations.
 * It is an integral part of the buffer writer class and its main purpose is to make the writer's code easier.
 */
class IndexBuffer {
    /**
     * @param size Initial size of the buffer.
     */
    constructor(size) {
        this._nextIndexOffset = 0;
        this._uint16View = new Uint16Array(size);
    }
    /**
     * @returns The number of indices already written.
     */
    get occupiedSize() {
        return this._nextIndexOffset;
    }
    /**
     * @return Max number of indices this buffer is able to store. It can be increased by the extend() method.
     */
    get size() {
        return this._uint16View.length;
    }
    /**
     * Extends buffer to the new size.
     */
    extend(newSize) {
        // TODO assert newByteLength is larger than current _arrayBuffer
        const oldUint16View = this._uint16View;
        this._uint16View = new Uint16Array(newSize);
        this._uint16View.set(oldUint16View);
    }
    /**
     * Appends index to the end of the buffer.
     */
    push(index) {
        this._uint16View[this._nextIndexOffset++] = index;
    }
    /**
     * @returns uint16 view of this buffer. The size of the view matches the amount of written data.
     */
    asUint16Array() {
        return new Uint16Array(this._uint16View.buffer, 0, this.occupiedSize);
    }
    /**
     * Moves "tail" data (from the offset specified to the end of the buffer) of one buffer to another. The offsets of
     * buffers will be appropriately updated to reflect data changes.
     * baseIndex will be deducted from all moved indices.
     */
    static transferDataTail(src, dst, baseIndex, srcOffset, dstOffset = 0) {
        for (let i = srcOffset, j = dstOffset; i < src.occupiedSize; i++, j++) {
            dst._uint16View[j] = src._uint16View[i] - baseIndex;
        }
        dst._nextIndexOffset = src.occupiedSize - srcOffset;
        src._nextIndexOffset = srcOffset;
    }
}
/**
 * Base buffer writer implementation. Can write unsigned short indices and
 * provides facilities for child classes to handle writing vertex data. Defines
 * a concept of current mesh. Basically, it mean that all vertices and indices
 * written to a writer between two `endMesh` calls (or construction of the writer
 * and an `endMesh` call) must be considered belonging to one atomic piece of
 * geometry and should not be spitted between separate buffers.
 */
class BufferWriter {
    /**
     * Creates a new writer and allocates initial amount of memory to store data.
     * Also implicitly "start" a mesh.
     *
     * @param vertexByteSize
     * @param initVertexBufferSize Init size (in vertices) of growing vertex buffers.
     * @param maxVertexBufferSize Max size (in vertices) of vertex buffers.
     * @param initIndexBufferUint16Size Init size (in uint16 number) of growing index buffers.
     */
    constructor(vertexByteSize, initVertexBufferSize = 0x400, maxVertexBufferSize = 0x10000, initIndexBufferUint16Size = 0xc00) {
        this._vertexByteSize = vertexByteSize;
        this._initVertexBufferByteSize = vertexByteSize * initVertexBufferSize;
        this._maxVertexBufferByteSize = vertexByteSize * maxVertexBufferSize;
        this._initIndexBufferUint16Size = initIndexBufferUint16Size;
        this._vertexBuffer = new VertexBuffer(this._initVertexBufferByteSize);
        this._vertexBuffers = [this._vertexBuffer];
        this._indexBuffer = new IndexBuffer(this._initIndexBufferUint16Size);
        this._indexBuffers = [this._indexBuffer];
        this._currentMeshVertexOffset = 0;
        this._currentMeshIndexOffset = 0;
        this._currentMeshBaseIndex = 0;
    }
    /**
     * Writes a bunch of indices to the underlying storage as unsigned short
     * numbers. If current storage doesn't have enough space to accommodate
     * given indices, the writer will automatically resize it. The writer
     * automatically adds base index to the supplied values, so from a user
     * point of view first vertex of a mesh has index 0 and there's no need
     * to take into account it's offset while generating mesh's topology.
     *
     * @param indices Array of indices to write.
     */
    writeIndices(indices) {
        this._ensureEnoughIndexBufferSpace(indices.length);
        const buffer = this._indexBuffer;
        const baseIndex = this._currentMeshBaseIndex;
        for (let i = 0; i < indices.length; ++i) {
            buffer.push(baseIndex + indices[i]);
        }
    }
    /**
     * Generates triangle indices from an array of indices of a triangle strip
     * (as in GL) and writes generated triplets to the managed index buffer.
     * @see OpenGL ES 2.0 Spec, §2.6.1
     *
     * @param indices Indices of the strip.
     */
    writeIndicesForStrip(indices) {
        this._ensureEnoughIndexBufferSpace(3 * (indices.length - 2));
        const buffer = this._indexBuffer;
        const baseIndex = this._currentMeshBaseIndex;
        for (const i of generateStrip(indices.length)) {
            buffer.push(baseIndex + indices[i]);
        }
    }
    /**
     * Generates triangle indices from a continuous triangle strip of a given
     * length and writes generated triplets to managed index buffer.
     * @see OpenGL ES 2.0 Spec, §2.6.1
     *
     * @param indexCount
     * @param baseIndexInMesh
     */
    writeIndicesForContinuousStrip(indexCount, baseIndexInMesh = 0) {
        this._ensureEnoughIndexBufferSpace(3 * (indexCount - 2));
        const buffer = this._indexBuffer;
        const baseIndex = this._currentMeshBaseIndex + baseIndexInMesh;
        for (const i of generateStrip(indexCount)) {
            buffer.push(baseIndex + i);
        }
    }
    /**
     * Generates triangle indices from an array of indices of a triangle fan (as
     * in GL) and writes generated triplets to the managed index buffer.
     * @see OpenGL ES 2.0 Spec, §2.6.1
     *
     * @param indices Indices of the strip.
     */
    writeIndicesForFan(indices) {
        this._ensureEnoughIndexBufferSpace(3 * (indices.length - 2));
        const buffer = this._indexBuffer;
        const baseIndex = this._currentMeshBaseIndex;
        for (const i of generateFan(indices.length)) {
            buffer.push(baseIndex + indices[i]);
        }
    }
    /**
     * Generates triangle indices from a continuous triangle fan of a given length
     * and writes generated triplets to managed index buffer.
     * @see OpenGL ES 2.0 Spec, §2.6.1
     *
     * @param indexCount
     * @param baseIndexInMesh
     */
    writeIndicesForContinuousFan(indexCount, baseIndexInMesh = 0) {
        this._ensureEnoughIndexBufferSpace(3 * (indexCount - 2));
        const buffer = this._indexBuffer;
        const baseIndex = baseIndexInMesh + this._currentMeshBaseIndex;
        for (const i of generateFan(indexCount)) {
            buffer.push(baseIndex + i);
        }
    }
    /**
     * Ends current mesh and implicitly starts a new one.
     *
     * @returns Internal index of vertex and index buffers the mesh was written
     *      to and its memory location in them.
     */
    endMesh() {
        const currentMeshVertexOffset = this._currentMeshVertexOffset;
        const vertexOccupiedSize = this._vertexBuffer.occupiedSize;
        this._currentMeshVertexOffset = vertexOccupiedSize;
        this._currentMeshBaseIndex = (vertexOccupiedSize << 2) / this._vertexByteSize;
        const currentMeshIndexOffset = this._currentMeshIndexOffset;
        const indexOccupiedSize = this._indexBuffer.occupiedSize;
        this._currentMeshIndexOffset = indexOccupiedSize;
        return {
            vertexByteOffset: currentMeshVertexOffset << 2,
            vertexByteLength: vertexOccupiedSize - currentMeshVertexOffset << 2,
            indexByteOffset: currentMeshIndexOffset << 1,
            indexByteLength: indexOccupiedSize - currentMeshIndexOffset << 1,
            // We can't return actual buffer reference since it can change if
            // the buffer gets reallocated.
            bufferIndex: this._vertexBuffers.length - 1
        };
    }
    /**
     * Returns an array of currently owned buffer data. This call's better
     * made when you're done with the writer since if the writer decides to
     * resize any of the buffers some of the references in the returned array
     * may become outdated.
     */
    getBuffers() {
        return Object(_array__WEBPACK_IMPORTED_MODULE_1__["zip"])(this._vertexBuffers, this._indexBuffers, (vertexBuffer, indexBuffer) => ({
            vertexBuffer: vertexBuffer.asUint32Array(),
            indexBuffer: indexBuffer.asUint16Array()
        }));
    }
    /**
     * Returns an offset in the current vertex buffer to the location where next
     * piece of data will be written.
     */
    getCurrentVertexBufferByteOffset() {
        return this._vertexBuffer.occupiedSize << 2;
    }
    /**
     * Returns index of currently written vertex structure in the current vertex
     * buffer.
     */
    getCurrentVertexIdx() {
        return ((this._vertexBuffer.occupiedSize << 2) / this._vertexByteSize | 0) - this._currentMeshBaseIndex;
    }
    /**
     * Writes a floating point value to the current vertex buffer and advances
     * the offset by 4 bytes.
     *
     * @param value The value to be written.
     */
    _writeFloat32(value) {
        this._ensureEnoughVertexBufferSpace();
        this._vertexBuffer.pushFloat32(value);
    }
    /**
     * Writes an unsigned integer value to the current vertex buffer and advances
     * the offset by 4 bytes.
     *
     * @param value The value to be written.
     */
    _writeWord(value) {
        this._ensureEnoughVertexBufferSpace();
        this._vertexBuffer.pushUint32(value);
    }
    /**
     * Writes an unsigned short value to the current vertex buffer and advances
     * the offset by 2 bytes. Passed values will be truncated to 16 bits.
     *
     * @param value The value to be written.
     */
    _writeHalfWords(v1, v2) {
        this._writeWord(v2 << 16 | v1 & 0xffff);
    }
    /**
     * Writes an unsigned byte value to the current vertex buffer and advances
     * the offset by 1 byte. Passed values will be truncated to 8 bits.
     *
     * @param value The value to be written.
     */
    _writeBytes(v1, v2, v3, v4) {
        this._writeWord(v4 << 24 |
            (v3 & 0xff) << 16 |
            (v2 & 0xff) << 8 |
            v1 & 0xff);
    }
    /**
     * Encodes a world coordinate vector as a pair of 32-bit integers (splitting
     * them in turn into to 16-bit ones).
     *
     * @param c The world coordinate.
     */
    _writeWorldCoordinate(c) {
        // To avoid using GPU singed integer conversions we shift and scale world
        // coordinates so they're in [0, 1] range (instead of [-1, 1]) and then
        // encoded as unsigned 32 bit integers split into to 16 bit ones.
        const xUint32 = Object(_gputypes__WEBPACK_IMPORTED_MODULE_0__["floatToUint32"])(0.5 * (c.x + 1));
        const yUint32 = Object(_gputypes__WEBPACK_IMPORTED_MODULE_0__["floatToUint32"])(0.5 * (c.y + 1));
        this._writeHalfWords(xUint32 >>> 16, yUint32 >>> 16);
        this._writeHalfWords(xUint32, yUint32);
    }
    /**
     * Computes new bigger size of a vertex buffer based on its current size. By
     * default just double the current size.
     *
     * @param currentByteSize Current size of the index buffer in bytes.
     * @returns The new size.
     */
    _getNextVertexBufferByteSize(currentByteSize) {
        return currentByteSize << 1;
    }
    /**
     * Computes new bigger size of an index buffer based on its current size. By
     * default just double the current size.
     *
     * @param currentUint16Size Current size of the index buffer in shorts.
     * @returns The new size.
     */
    _getNextIndexBufferUint16Size(currentUint16Size) {
        return currentUint16Size << 1;
    }
    /**
     * Ensures that the managed vertex buffer has enough space to fit in a chunk
     * of data of a given size. Either does nothing, resizes the current vertex
     * buffer or creates entirely new pair of vertex and index buffers.
     *
     * @param valueSize Byte size of the data that needs to be accommodated by
     *      the vertex buffer.
     */
    _ensureEnoughVertexBufferSpace() {
        const vertexBuffer = this._vertexBuffer;
        if (!vertexBuffer.isFull) {
            // We have enough space, so nothing to be done.
            return;
        }
        if (vertexBuffer.byteSize < this._maxVertexBufferByteSize) {
            // If we can just resize the current vertex buffer, do that.
            this._vertexBuffer.extend(this._getNextVertexBufferByteSize(vertexBuffer.byteSize));
            return;
        }
        // If there's no enough space in the current vertex buffer and it's
        // already of maximum size, allocate new vertex and index buffers and
        // copy data of the current mesh to them from the current buffers.
        // Then make those buffer the current ones.
        const currentMeshVertexOffset = this._currentMeshVertexOffset;
        const currentMeshVertexByteSize = (vertexBuffer.occupiedSize - currentMeshVertexOffset) * 4;
        const maxVertexBufferByteSize = this._maxVertexBufferByteSize;
        if (currentMeshVertexByteSize === maxVertexBufferByteSize) {
            throw new Error('Mesh is too big to fit in.');
        }
        let newVertexBufferByteSize = this._initVertexBufferByteSize;
        // Initial vertex buffer size may be too small to accommodate the current
        // mesh, so we find next bigger size that is sufficient.
        while (newVertexBufferByteSize <= currentMeshVertexByteSize) {
            newVertexBufferByteSize = this._getNextVertexBufferByteSize(newVertexBufferByteSize);
        }
        const newVertexBuffer = new VertexBuffer(newVertexBufferByteSize);
        VertexBuffer.transferDataTail(vertexBuffer, newVertexBuffer, currentMeshVertexOffset);
        this._vertexBuffer = newVertexBuffer;
        this._vertexBuffers.push(newVertexBuffer);
        this._currentMeshVertexOffset = 0;
        const indexBuffer = this._indexBuffer;
        const currentMeshIndexOffset = this._currentMeshIndexOffset;
        const currentMeshIndexSize = indexBuffer.occupiedSize - currentMeshIndexOffset;
        let newIndexBufferSize = this._initIndexBufferUint16Size;
        // Initial index buffer size may be too small to accommodate the current
        // mesh, so we find next bigger size that is sufficient.
        while (newIndexBufferSize <= currentMeshIndexSize) {
            newIndexBufferSize = this._getNextIndexBufferUint16Size(newIndexBufferSize);
        }
        const newIndexBuffer = new IndexBuffer(newIndexBufferSize);
        // Since the current mesh's copied to the beginning of the new vertex
        // buffer, it's base index now is 0. If the mesh has any written indices,
        // they're already offset by the old base index.
        IndexBuffer.transferDataTail(indexBuffer, newIndexBuffer, this._currentMeshBaseIndex, currentMeshIndexOffset);
        this._currentMeshBaseIndex = 0;
        this._currentMeshIndexOffset = 0;
        this._indexBuffer = newIndexBuffer;
        this._indexBuffers.push(newIndexBuffer);
    }
    /**
     * Ensures that the managed index buffer has enough space to fit in a given
     * number of indices. Either does nothing or resizes the current index
     * buffer.
     *
     * @param indexCount Number of indices client wants to write to the managed
     *      index buffer.
     */
    _ensureEnoughIndexBufferSpace(indexCount) {
        const buffer = this._indexBuffer;
        const requiredSize = buffer.occupiedSize + indexCount;
        if (requiredSize <= buffer.size) {
            // We have enough space so nothing to be done.
            return;
        }
        let newBufferSize = buffer.size;
        // Let's compute new larger size of the index buffer until we can
        // accommodate incoming data.
        while (requiredSize > newBufferSize) {
            newBufferSize = this._getNextIndexBufferUint16Size(newBufferSize);
        }
        this._indexBuffer.extend(newBufferSize);
    }
}


/***/ }),
/* 37 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floatToUint8", function() { return floatToUint8; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floatToUint16", function() { return floatToUint16; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floatToInt16", function() { return floatToInt16; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floatToUint32", function() { return floatToUint32; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floatToInt32", function() { return floatToInt32; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "int32ToFloat", function() { return int32ToFloat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "uint32ToFloat", function() { return uint32ToFloat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "int16ToFloat", function() { return int16ToFloat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "uint16ToFloat", function() { return uint16ToFloat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "uint8ToFloat", function() { return uint8ToFloat; });
const UINT8_MAX = 0xff;
const UINT16_MAX = 0xffff;
const UINT32_MAX = 0xffffffff;
function floatToUint8(x) {
    return UINT8_MAX * x | 0;
}
function floatToUint16(x) {
    return x * UINT16_MAX | 0;
}
function floatToInt16(x) {
    return (x * UINT16_MAX - 1) / 2 | 0;
}
function floatToUint32(x) {
    return x * UINT32_MAX | 0;
}
function floatToInt32(x) {
    return (x * UINT32_MAX - 1) / 2 | 0;
}
function int32ToFloat(x) {
    return (2 * x + 1) / UINT32_MAX;
}
function uint32ToFloat(x) {
    return x / UINT32_MAX;
}
function int16ToFloat(x) {
    return (2 * x + 1) / UINT16_MAX;
}
function uint16ToFloat(x) {
    return x / UINT16_MAX;
}
function uint8ToFloat(x) {
    return x / UINT8_MAX;
}


/***/ }),
/* 38 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "swap", function() { return swap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reverse", function() { return reverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shuffle", function() { return shuffle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zip", function() { return zip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compare", function() { return compare; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "insertionSort", function() { return insertionSort; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mergeSort", function() { return mergeSort; });
/* harmony import */ var _comparator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(39);

/**
 * Swaps two values in an array.
 *
 * @param array The array.
 * @param i Index of a value to be swapped.
 * @param j Index of a value to be swapped.
 */
function swap(array, i, j) {
    const t = array[i];
    array[i] = array[j];
    array[j] = t;
}
/**
 * Reverses order of elements in a range in an array.
 *
 * @param array The array.
 * @param start The start of the range.
 * @param end The end of the range.
 */
function reverse(array, start = 0, end = array.length) {
    for (let i = start, j = end - 1; i < j; ++i, --j) {
        swap(array, i, j);
    }
}
/**
 * Rotates a range of elements in an array by given amount.
 *
 * @param array The array.
 * @param amount The amount.
 * @param start The start of the range.
 * @param end The end of the range.
 */
function rotate(array, amount = 1, start = 0, end = array.length) {
    reverse(array, start, end);
    reverse(array, start, start + amount);
    reverse(array, start + amount, end);
}
/**
 * Copies a range of elements from a source array to a range in a destination
 * array.
 *
 * @param src The source array.
 * @param dst The destination array.
 * @param srcStart The start of the source range.
 * @param srcStart The start of the source range.
 * @param dstStart The start of the destination range.
 */
function copy(src, dst, srcStart = 0, srcEnd = src.length, dstStart = 0) {
    for (let i = srcStart, j = dstStart; i < srcEnd; ++i, ++j) {
        dst[j] = src[i];
    }
}
/**
 * Shuffles randomly a range of elements in an array.
 *
 * @param array The array.
 * @param start The start of the range.
 * @param end The end of the range.
 */
function shuffle(array, start = 0, end = array.length) {
    for (let i = start, j = i + 1; i < end; ++i, ++j) {
        swap(array, i, j + (Math.random() * (end - j) | 0));
    }
}
function zip(ts, us, zipper = (t, u) => [t, u]) {
    const l = Math.min(ts.length, us.length);
    const vs = new Array(l);
    for (let i = 0; i < l; ++i) {
        vs[i] = zipper(ts[i], us[i]);
    }
    return vs;
}
/**
 * Compares two arrays lexicographically. The order is specified be the comparator parameter.
 *
 * @param comparator Elements comparator with standard signature.
 * @param a The first array to compare.
 * @param b The second array to compare.
 * @returns 0 if all elements and lengths are equal,
 *      negative number if the first element is less then the second (lexicographically),
 *      positive number if the first element is greater then the second,
 *      if all the elements are equal the lengths are being compared.
 */
function compare(comparator, a, b) {
    const length = Math.min(a.length, b.length);
    for (let i = 0; i < length; i++) {
        const result = comparator(a[i], b[i]);
        if (result) {
            return result;
        }
    }
    return a.length - b.length;
}
/**
 * Sorts a range of elements of an array in place with insertion sort.
 *
 * @param array The array to be sorted.
 * @param comparator Comparator for array elements.
 * @param start Index of the first element in the range to be sorted.
 * @param end Index of an element behind the last element in the range to be
 *      sorted.
 */
function insertionSort(array, comparator = _comparator__WEBPACK_IMPORTED_MODULE_0__["DEFAULT_COMPARATOR"], start = 0, end = array.length) {
    for (let i = start; i < end; ++i) {
        for (let j = i; j > start && comparator(array[j - 1], array[j]) > 0; --j) {
            swap(array, j - 1, j);
        }
    }
}
const BLOCK_SIZE = 32;
/**
 * Merges two sorted ranges of an array. Stores the result into another one.
 *
 * @param src The array with the ranges to be merged.
 * @param dst The array the resulting range will be stored to.
 * @param comparator The comparator for array elements.
 * @param start Start of the first range to be merged.
 * @param middle End of the first and simultaneously start of the second range
 *      to be merged.
 * @param end End of the second range to be merged.
 * @param dstOffset Offset of merged range in the result array.
 */
function merge(src, dst, comparator, start, middle, end, dstOffset) {
    let i = dstOffset;
    let j = start;
    let k = middle;
    while (j < middle && k < end) {
        dst[i++] = comparator(src[j], src[k]) > 0 ? src[k++] : src[j++];
    }
    copy(src, dst, j, middle, i);
    copy(src, dst, k, end, i);
}
/**
 * Sorts a range of elements of an array with merge sort.
 *
 * @param array  The array to be sorted.
 * @param comparator Comparator for array elements.
 * @param end Index of an element behind the last element in the range to be
 *      sorted.
 */
function mergeSort(array, comparator = _comparator__WEBPACK_IMPORTED_MODULE_0__["DEFAULT_COMPARATOR"], start = 0, end = array.length) {
    // First and foremost: if the range is smaller than the block size, just
    // perform insertion sort on it.
    if (end - start <= BLOCK_SIZE) {
        insertionSort(array, comparator, start, end);
        return;
    }
    // First we split the given range into subranges of size BLOCK_SIZE and
    // sort every range with insertion sort.
    {
        let s = start;
        let e = s + BLOCK_SIZE;
        while (e < end) {
            insertionSort(array, comparator, s, e);
            s = e;
            e += BLOCK_SIZE;
        }
        insertionSort(array, comparator, s, end);
    }
    // TODO(dmikis): Implement in-place merge. It seems there're reasonably
    //      complex solutions out there.
    const auxArray = new Array(end - start);
    // Then we merge blocks pairs, increase block size by 2 and repeat.
    for (let blockSize = BLOCK_SIZE; blockSize < end - start; blockSize += blockSize) {
        // TODO(dmikis): Before aforementioned todo maybe implement array
        // pingponging to cut down amount of full copies.
        copy(array, auxArray, start, end);
        let i = start;
        let s = 0;
        let m = blockSize;
        let e = m + blockSize;
        while (e < end - start) {
            merge(auxArray, array, comparator, s, m, e, i);
            s = e;
            m = s + blockSize;
            e = m + blockSize;
            i += 2 * blockSize;
        }
        merge(auxArray, array, comparator, s, Math.min(m, end - start), end - start, i);
    }
}


/***/ }),
/* 39 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_COMPARATOR", function() { return DEFAULT_COMPARATOR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NUMERICAL_COMPARATOR", function() { return NUMERICAL_COMPARATOR; });
function DEFAULT_COMPARATOR(a, b) {
    if (a > b) {
        return 1;
    }
    if (a < b) {
        return -1;
    }
    return 0;
}
function NUMERICAL_COMPARATOR(a, b) {
    return a - b;
}


/***/ }),
/* 40 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MemorySubChunk; });
/* harmony import */ var _count_vertices__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(41);

/**
 * Represents a region in a memory chunk. Memory is allocated by big chunks for performance reasons,
 * and we need a mechanism to control those chunk's suballocation to properly free
 * the occupied memory - that is what this class is for.
 */
class MemorySubChunk {
    constructor(chunk, location) {
        this.memoryChunk = chunk;
        this._location = location;
        chunk.retain();
    }
    /**
     * @returns Offset of vertex data of the chunk in bytes.
     */
    get vertexByteOffset() {
        return this.memoryChunk.vertexByteOffset + this._location.vertexByteOffset;
    }
    /**
     * @returns Offset of index data of the chunk in bytes.
     */
    get indexByteOffset() {
        return this.memoryChunk.indexByteOffset + this._location.indexByteOffset;
    }
    /**
     * @returns Number of indexes occupied by this chunk.
     */
    get indexCount() {
        return Object(_count_vertices__WEBPACK_IMPORTED_MODULE_0__["countIndices"])(this._location.indexByteLength, this.memoryChunk.page.indexType);
    }
    /**
     * @returns Number of bytes occupied by this chunk for vertex data.
     */
    get vertexByteLength() {
        return this._location.vertexByteLength;
    }
    /**
     * @returns Number of bytes occupied by this chunk for index data.
     */
    get indexByteLength() {
        return this._location.indexByteLength;
    }
    destroy() {
        this.memoryChunk.release();
    }
}


/***/ }),
/* 41 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "countVertices", function() { return countVertices; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "countIndices", function() { return countIndices; });
/**
 * @returns Integer number of vertices that fit into a region of specified in bytes size.
 */
function countVertices(vertexByteSize, attribMapping) {
    return vertexByteSize / attribMapping.vertexByteSize | 0;
}
/**
 * @returns Integer number of indices that fit into a region of specified in bytes size.
 */
function countIndices(indexByteSize, type) {
    switch (type) {
        case 5123 /* UNSIGNED_SHORT */:
            return indexByteSize >> 1;
        case 5125 /* UNSIGNED_INT */:
            return indexByteSize >> 2;
        default:
            return -1;
    }
}


/***/ }),
/* 42 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AllocatedImage", function() { return AllocatedImage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return IdentifiedImageAtlasManager; });
/* harmony import */ var _util_ref_counted__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(43);

/**
 * Represents an allocated image. Allocated image is a shareable resource that should be resealed
 * when there are no clients use it. As it is not possible to rely on the GC, clients should
 * manually retain their required images and release them when they are not required anymore.
 */
class AllocatedImage extends _util_ref_counted__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(descriptor, bbox, atlasManager) {
        super();
        this.descriptor = descriptor;
        this.bbox = bbox;
        this.atlasManager = atlasManager;
    }
    updateImage(sourceImage, locationRegion, sourceImageRegion) {
        this.atlasManager.atlas.updateImage(this.bbox, sourceImage, locationRegion, sourceImageRegion);
    }
    _destroy() {
        this.atlasManager.removeImage(this.descriptor);
    }
}
/**
 * Manages allocation of images by id.
 */
class IdentifiedImageAtlasManager {
    constructor(imageAtlas) {
        this.atlas = imageAtlas;
        this._locations = new Map();
    }
    get size() {
        return this._locations.size;
    }
    getImage(id, retain = false) {
        const imageLocation = this._locations.get(id);
        if (retain && imageLocation) {
            imageLocation.retain();
        }
        return imageLocation || null;
    }
    allocateImage(descriptor, image) {
        const location = this.atlas.allocateImage(descriptor, image);
        if (location) {
            const image = new AllocatedImage(descriptor, location, this);
            this._locations.set(descriptor.id, image);
            return image;
        }
        return null;
    }
    removeImage(image) {
        const location = this._locations.get(image.id);
        if (location) {
            this.atlas.removeImage(location.bbox);
            this._locations.delete(image.id);
        }
    }
    contains(id) {
        return this._locations.has(id);
    }
    reserveLocation(descriptor) {
        const location = this.atlas.reserveLocation(descriptor);
        if (location) {
            const image = new AllocatedImage(descriptor, location, this);
            this._locations.set(descriptor.id, image);
            return image;
        }
        return null;
    }
}


/***/ }),
/* 43 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ReferenceCounted; });
/**
 * Simple reference counting for shared entities that need explicit destruction.
 */
class ReferenceCounted {
    /**
     * Initializes reference count to 1.
     */
    constructor() {
        this._refCount = 1;
    }
    /**
     * Increments reference count.
     */
    retain() {
        if (this._refCount === 0) {
            throw new Error('Tried to retain a destroyed object.');
        }
        this._refCount++;
    }
    /**
     * Decrements reference count and, if it's reached 0, destroys the object.
     */
    release() {
        if (this._refCount === 0) {
            throw new Error('Tried to release a destroyed object.');
        }
        this._refCount--;
        if (this._refCount === 0) {
            this._destroy();
        }
    }
}


/***/ }),
/* 44 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DfFont; });
/* harmony import */ var _font__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(45);

const UNKNOWN_GLYPH = {
    id: -1,
    width: 0,
    height: 0,
    bearingX: 0,
    bearingY: 0,
    advance: 18
};
/**
 * Font whose glyphs are specified in distance field bitmaps. It's "margin" metric specifies glyph bitmap inner padding,
 * that is required to fit a "blurred" glyph image. This margin should be considered during layouting to draw glyphs of
 * proper sizes.
 */
class DfFont extends _font__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(id, xheight, margin) {
        super(id, xheight, UNKNOWN_GLYPH);
        this.margin = margin;
    }
}


/***/ }),
/* 45 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Font; });
/**
 * Font is just a collection of glyph descriptions.
 */
class Font {
    /**
     * @param id Font id.
     * @param xheight The height of the "x" char in abstract points, in fact is used a the font size.
     * @param unknownGlyphInstance An instance of glyph to be served as a stub when nonexistent glyph
     *     is requested. Requesting nonexistent glyphs normally should not happen.
     *     The stub just allows to avoid tedious null checks in font clients.
     */
    constructor(id, xheight, unknownGlyphInstance) {
        this.id = id;
        this.xheight = xheight;
        this._unknownGlyphInstance = unknownGlyphInstance;
        this._glyphs = new Map();
    }
    /**
     * @return Glyph with specified id or unknown glyph instance.
     */
    getGlyph(glyphId) {
        const glyph = this._glyphs.get(glyphId);
        if (glyph) {
            return glyph;
        }
        else {
            console.warn('Wow-wow-wow, something went wrong, you should not request nonexistent glyphs');
            return this._unknownGlyphInstance;
        }
    }
    /**
     * @returns All stored glyphs.
     */
    getAllGlyphs() {
        return [...this._glyphs.values()];
    }
    /**
     * Adds glyph description.
     */
    addGlyph(glyph) {
        this._glyphs.set(glyph.id, glyph);
    }
    /**
     * Adds glyph descriptions from the iterable.
     */
    addAllGlyphs(glyphs) {
        for (const glyph of glyphs) {
            this.addGlyph(glyph);
        }
    }
}


/***/ }),
/* 46 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ApiImageProvider", function() { return ApiImageProvider; });
/* harmony import */ var _billboard_image_provider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(47);
/* harmony import */ var _util_hd__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(48);
/* harmony import */ var _util_hosts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(49);



/**
 * Image provider that gets images from specific API entry point.
 */
class ApiImageProvider extends _billboard_image_provider__WEBPACK_IMPORTED_MODULE_0__["ImageProvider"] {
    constructor(imageUrlTemplate) {
        super();
        this._imageUrlTemplate = imageUrlTemplate;
    }
    getImageUrl(id) {
        // API can return scaled images that allows us to request images according
        // to user's DPI and render them properly, non-integer numbers are accepted.
        return this._imageUrlTemplate
            .replace('{{hostAlias}}', Object(_util_hosts__WEBPACK_IMPORTED_MODULE_2__["getHostAliasByUid"])(id))
            .replace(/\{\{id\}\}/g, id)
            .replace('{{scale}}', Object(_util_hd__WEBPACK_IMPORTED_MODULE_1__["default"])().toString());
    }
}


/***/ }),
/* 47 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageProvider", function() { return ImageProvider; });
/**
 * Abstract image content provider, concrete implementations should specify the entry point in getImageUrl().
 */
class ImageProvider {
    /**
     * Gets image bitmap via an HTMLImageElement and a canvas.
     */
    getImage(id) {
        return new Promise((resolve, reject) => {
            const imageElement = new Image();
            imageElement.crossOrigin = 'anonymous';
            imageElement.onload = () => resolve(imageElement);
            imageElement.onerror = reject;
            imageElement.src = this.getImageUrl(id);
        });
    }
}


/***/ }),
/* 48 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getDpr; });
/**
 * Gives the device pixel ration if it's greater than 1 and 1 otherwise. This's
 * here purely to be compatible with jsapi which does the same thing for reasons
 * unknows (thanks, kashey).
 *
 * @returns Capped device pixel ratio.
 */
function getDpr() {
    return devicePixelRatio > 1 ? devicePixelRatio : 1;
}


/***/ }),
/* 49 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getHostAliasByUid", function() { return getHostAliasByUid; });
const HOST_ALIASES_N = 4;
function getHostAliasByUid(uid) {
    let sum = 0;
    for (let i = 0; i < uid.length; i++) {
        sum += uid.charCodeAt(i);
    }
    return (sum % HOST_ALIASES_N + 1).toString();
}


/***/ }),
/* 50 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ModelBufferWriter; });
/* harmony import */ var _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _util_buffer_writer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(36);


/**
 * Base class for 3D models buffer writers. It is not supposed to write indices, instead it writes vertices (possibly
 * duplicated) in order that correspond to triangular facets of the mesh.
 */
class ModelBufferWriter extends _util_buffer_writer__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor() {
        super(ModelBufferWriter.ATTRIBUTE_MAPPING.vertexByteSize);
    }
    /**
     * Writes a vertex to the vertex buffer.
     */
    _writeVertex(v, colorRgba8) {
        const vertexIdx = this.getCurrentVertexIdx();
        this._writeWorldCoordinate(v);
        this._writeFloat32(v.z);
        this._writeWord(colorRgba8);
        return vertexIdx;
    }
}
/**
 * Description of how attributes of vertices are packed into a vertex buffer.
 */
ModelBufferWriter.ATTRIBUTE_MAPPING = new _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__["AttributeMapping"]([
    [
        0 /* POSITION_HIGH */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        1 /* POSITION_LOW */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        3 /* HEIGHT */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        7 /* COLOR */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ]
]);


/***/ }),
/* 51 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TexturedPolylineBufferWriter; });
/* harmony import */ var _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _util_buffer_writer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(36);
/* harmony import */ var _textured_polyline_geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(52);
/* harmony import */ var _util_z_index__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(53);




/**
 * Writer of geometry data of polyline hulls.
 */
class TexturedPolylineBufferWriter extends _util_buffer_writer__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor() {
        super(TexturedPolylineBufferWriter.ATTRIBUTE_MAPPING.vertexByteSize);
    }
    /**
     * Generates a hull for a polyline and writes it to the writer.
     *
     * @param polyline The polyline to be written.
     * @param width Thickness of the polyline.
     * @param worldToPxFactor Ratio of world coordinates to pixels.
     * @param imageLocation Image location in atlas.
     * @param zIndex Z-index of the polyline.
     */
    writeTexturedPolyline(polyline, width, worldToPxFactor, imageLocation, zIndex) {
        Object(_textured_polyline_geometry__WEBPACK_IMPORTED_MODULE_2__["default"])(this, polyline.vertices, worldToPxFactor, imageLocation, width, Object(_util_z_index__WEBPACK_IMPORTED_MODULE_3__["intToZIndex"])(zIndex + 1));
        return this.endMesh();
    }
    /**
     * Writes a vertex to the vertex buffer.
     *
     * @param position Position of the vertex in world coordinates.
     * @param displacement Displacement vector, in most cases must be normalized, the width is considered in shaders.
     * @param halfWidth Thickness of the polyline.
     * @param patterWidth Width of the image that is repeated along the polyline.
     * @param patternHalfHeight Image half height multiplied by `sign(s)`, where `s` is a [-1; 1] distance to the
     * analytical polyline along segment's normal.
     * @param length Length of the polyline for current vertex, needed to correctly calculate image uv x coordinate.
     * @param uv UV coordinates of the image.
     * @param zIndex Z-index of the polyline.
     *
     * @return Index of the written vertex.
     */
    writeVertex(position, displacement, halfWidth, patternWidth, patternHalfHeight, length, uv, zIndex) {
        const vertexIdx = this.getCurrentVertexIdx();
        this._writeWorldCoordinate(position);
        this._writeFloat32(displacement.x);
        this._writeFloat32(displacement.y);
        this._writeHalfWords(uv.x, uv.y);
        this._writeFloat32(zIndex);
        this._writeFloat32(halfWidth);
        this._writeHalfWords(patternWidth, length);
        this._writeFloat32(patternHalfHeight);
        return vertexIdx;
    }
}
/** Description of how a writer stores vertex data. */
TexturedPolylineBufferWriter.ATTRIBUTE_MAPPING = new _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__["AttributeMapping"]([
    [
        0 /* POSITION_HIGH */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        1 /* POSITION_LOW */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        6 /* DISPLACEMENT */,
        {
            size: 2,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        4 /* UV */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: false
        }
    ],
    [
        9 /* PRIORITY */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        11 /* AUX */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        12 /* AUX1 */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: false
        }
    ],
    [
        13 /* AUX2 */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ]
]);


/***/ }),
/* 52 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return writeTexturedPolylineGeometry; });
/* harmony import */ var _math_vector2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(23);

/**
 * Writes polyline image geometry (set of triangles that draw up a solid thick polyline) into a buffer writer.
 *
 * @param writer Output buffer writer.
 * @param polyline Polyline to be written.
 * @param worldToPxFactor Ratio of world coordinates to pixels.
 * @param imageLocation Image location in atlas.
 * @param width Thickness of the polyline.
 * @param z Z-index of the polyline.
 */
function writeTexturedPolylineGeometry(writer, polyline, worldToPxFactor, imageLocation, width, z) {
    const hWidth = width / 2;
    const patternWidth = imageLocation.maxX - imageLocation.minX;
    const patternHalfHeight = (imageLocation.maxY - imageLocation.minY) / 2;
    const segment = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["create"](0, 0);
    const dir = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["create"](0, 0);
    const prevDir = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["create"](0, 0);
    const norm = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["create"](0, 0);
    const normInv = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["create"](0, 0);
    const uv = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["create"](imageLocation.minX, 0);
    let prevBottomRight = -1;
    let prevTopRight = -1;
    let length = 0;
    let prevLength = 0;
    for (let i = 1; i < polyline.length; i++) {
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["sub"](polyline[i], polyline[i - 1], segment);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["normalize"](segment, dir);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["rotate90"](dir, norm);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["muln"](norm, -1, normInv);
        // segment is written as a rectangle (two triangles)
        uv.y = imageLocation.minY;
        const topLeft = writer.writeVertex(polyline[i - 1], norm, hWidth, patternWidth, patternHalfHeight, length, uv, z);
        uv.y = imageLocation.maxY;
        const bottomLeft = writer.writeVertex(polyline[i - 1], normInv, hWidth, patternWidth, -patternHalfHeight, length, uv, z);
        // update length of the polyline in pixels
        length += _math_vector2__WEBPACK_IMPORTED_MODULE_0__["length"](segment) / worldToPxFactor;
        uv.y = imageLocation.minY;
        const topRight = writer.writeVertex(polyline[i], norm, hWidth, patternWidth, patternHalfHeight, length, uv, z);
        uv.y = imageLocation.maxY;
        const bottomRight = writer.writeVertex(polyline[i], normInv, hWidth, patternWidth, -patternHalfHeight, length, uv, z);
        // write line join that fills an empty space on corners
        if (1 < i && i < polyline.length) {
            uv.y = (imageLocation.maxY + imageLocation.minY) / 2;
            const joinPointIndex = writer.writeVertex(polyline[i - 1], _math_vector2__WEBPACK_IMPORTED_MODULE_0__["ZERO"], hWidth, patternWidth, 0, prevLength, uv, z);
            // find out where the fracture of segments is located to create correct join with minimum overdraw
            const turnLeft = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["crossZ"](prevDir, dir) > 0;
            if (turnLeft) {
                writer.writeIndices([
                    joinPointIndex, bottomLeft, prevBottomRight
                ]);
            }
            else {
                writer.writeIndices([
                    joinPointIndex, prevTopRight, topLeft
                ]);
            }
        }
        writer.writeIndices([
            topLeft, topRight, bottomLeft,
            topRight, bottomRight, bottomLeft
        ]);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["copy"](dir, prevDir);
        prevBottomRight = bottomRight;
        prevTopRight = topRight;
        prevLength = length;
    }
}


/***/ }),
/* 53 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "intToZIndex", function() { return intToZIndex; });
const MIN_ZINDEX = -1 + Math.pow(2, 1 - 24); // epsilon is added (for normalized 24-bit value) to free up reserved value
function intToZIndex(x) {
    return Math.max(MIN_ZINDEX, x / 0x7fffff);
}


/***/ }),
/* 54 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageManager", function() { return ImageManager; });
/**
 * Manages allocation of requested images. The same images can be requested multiple times from different places,
 * this class takes over duplication of HTTP requests/atlas allocations providing simple async interface for
 * getting allocated images.
 */
class ImageManager {
    constructor(atlas, provider) {
        this._atlas = atlas;
        this._provider = provider;
        this._requests = new Map();
    }
    /**
     * Returns image if it is already allocated. Pay attention that resulted allocated image is "retained",
     * so it must be released once it is passed to a responsible client.
     */
    getImage(id) {
        const image = this._atlas.getImage(id, true);
        if (image) {
            image.retain();
        }
        return image;
    }
    /**
     * Request image from image provider, if it is already allocated no request is made, but it is returned
     * wrapped into a resolved promise. Pay attention that resulted allocated image is "retained", so it must be
     * released once it is passed to a responsible client.
     */
    requestImage(id) {
        const allocatedImage = this._atlas.getImage(id, true);
        if (allocatedImage) {
            return Promise.resolve(allocatedImage);
        }
        else {
            const request = this._requests.get(id);
            if (request) {
                request.then((allocatedImage) => allocatedImage && allocatedImage.retain());
                return request;
            }
            else {
                const request = this._provider
                    .getImage(id)
                    .then((image) => {
                    this._requests.delete(id);
                    const { width, height } = image;
                    const allocatedImage = this._atlas.allocateImage({ id, width, height }, image);
                    if (!allocatedImage) {
                        throw new Error('Couldn\' allocated image');
                    }
                    else {
                        return allocatedImage;
                    }
                }, () => {
                    this._requests.delete(id);
                    throw new Error('Image request failed');
                });
                this._requests.set(id, request);
                return request;
            }
        }
    }
}


/***/ }),
/* 55 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TexturedPolygonBufferRewriter; });
/* harmony import */ var _util_buffer_rewriter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(56);
/* harmony import */ var _textured_polygon_attribute_mapping__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(57);


class TexturedPolygonBufferRewriter extends _util_buffer_rewriter__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(buffers) {
        super(_textured_polygon_attribute_mapping__WEBPACK_IMPORTED_MODULE_1__["TEXTURED_POLYGON_ATTRIBUTE_MAPPING"], buffers);
    }
    /**
     * @param location Location of the polygon in memory.
     * @param imageLocation Location of the pattern in atlas.
     * @param imageScale How world coordinates relate to the image size.
     */
    rewriteUV(location, imageLocation, imageScale) {
        const uvOffset = this._getAttribOffset(4 /* UV */);
        const scaleOffset = this._getAttribOffset(11 /* AUX */);
        this._forEachVertex(location, (writer) => {
            writer.writeHalfWords(uvOffset, imageLocation.minX, imageLocation.minY);
            writer.writeHalfWords(uvOffset + 1, imageLocation.maxX - imageLocation.minX, imageLocation.maxY - imageLocation.minY);
            writer.writeFloat32(scaleOffset, imageScale);
        });
    }
}


/***/ }),
/* 56 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BufferRewriter; });
/* harmony import */ var _buffer_writer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(36);

/**
 * Class that is exposed as an interface for writing to a specific vertex attribute.
 */
class VertexWriter {
    constructor(vertexBuffer) {
        this._vertexBuffer = new Uint32Array(vertexBuffer.buffer, 0, vertexBuffer.length);
        this._vertexBufferFloat32View = new Float32Array(vertexBuffer.buffer, 0, vertexBuffer.length);
    }
    /**
     * Writes float attribute into specific position in buffer.
     *
     * @param attribOffset Offset of an attribute in words (4 bytes), get it from BufferRewriter#_getAttribOffset().
     * @param value Value to be written.
     */
    writeFloat32(attribOffset, value) {
        this._vertexBufferFloat32View[this.vertexOffset + attribOffset] = value;
    }
    /**
     * Writes a word attribute into specific position in buffer.
     *
     * @param attribOffset Offset of an attribute in words (4 bytes), get it from BufferRewriter#_getAttribOffset().
     * @param value Value to be written.
     */
    writeWord(attribOffset, value) {
        this._vertexBuffer[this.vertexOffset + attribOffset] = value;
    }
    /**
     * Writes two half word attribute values into specific position in buffer.
     *
     * @param attribOffset Offset of an attribute in words (4 bytes), get it from BufferRewriter#_getAttribOffset().
     * @param value Value to be written.
     */
    writeHalfWords(attribOffset, v1, v2) {
        this.writeWord(attribOffset, v2 << 16 | v1 & 0xffff);
    }
}
/**
 * Provides some utils for rewriting vertex attribute values, see VertexWriter and tests for some tips of how to do it.
 * TODO: consider supporting of separate buffers for different attributes, that will make this class less useful
 */
class BufferRewriter {
    constructor(attribMapping, buffers) {
        this._attribMapping = attribMapping;
        this._buffers = buffers;
    }
    /**
     * Walks over all vertices exposing VertexWriter for each one by calling the handler argument.
     */
    _forEachVertex(location, handler) {
        const vertexWriter = new VertexWriter(this._buffers[location.bufferIndex].vertexBuffer);
        const vertexByteSize = this._attribMapping.vertexByteSize;
        for (let i = 0; i < location.vertexByteLength; i += vertexByteSize) {
            vertexWriter.vertexOffset = (location.vertexByteOffset + i) / _buffer_writer__WEBPACK_IMPORTED_MODULE_0__["WORD_BYTE_SIZE"];
            handler(vertexWriter);
        }
    }
    /**
     * @returns Offset in words (4 bytes) of specific attribute in a vertex (format is defined by AttributeMapping).
     */
    _getAttribOffset(attrib) {
        const attribPointer = this._attribMapping.get(attrib);
        return attribPointer ? attribPointer.offset / _buffer_writer__WEBPACK_IMPORTED_MODULE_0__["WORD_BYTE_SIZE"] : -1;
    }
}


/***/ }),
/* 57 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEXTURED_POLYGON_ATTRIBUTE_MAPPING", function() { return TEXTURED_POLYGON_ATTRIBUTE_MAPPING; });
/* harmony import */ var _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);

/**
 * Description of how attributes of vertices are packed into a vertex buffer.
 */
const TEXTURED_POLYGON_ATTRIBUTE_MAPPING = new _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__["AttributeMapping"]([
    [
        0 /* POSITION_HIGH */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        1 /* POSITION_LOW */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        4 /* UV */,
        {
            size: 4,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: false
        }
    ],
    [
        11 /* AUX */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        10 /* Z_INDEX */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ]
]);


/***/ }),
/* 58 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "POLYGON_ATTRIBUTE_MAPPING", function() { return POLYGON_ATTRIBUTE_MAPPING; });
/* harmony import */ var _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);

/**
 * Description of how attributes of vertices are packed into a vertex buffer.
 */
const POLYGON_ATTRIBUTE_MAPPING = new _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__["AttributeMapping"]([
    [
        0 /* POSITION_HIGH */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        1 /* POSITION_LOW */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        7 /* COLOR */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        10 /* Z_INDEX */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ]
]);


/***/ }),
/* 59 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BILLBOARD_RECTANGLE_ATTRIBUTE_MAPPING", function() { return BILLBOARD_RECTANGLE_ATTRIBUTE_MAPPING; });
/* harmony import */ var _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);

/** Description of how a writer stores vertex data. */
const BILLBOARD_RECTANGLE_ATTRIBUTE_MAPPING = new _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__["AttributeMapping"]([
    [
        2 /* ID */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        0 /* POSITION_HIGH */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        1 /* POSITION_LOW */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        6 /* DISPLACEMENT */,
        {
            size: 2,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        4 /* UV */,
        {
            size: 2,
            type: 5122 /* SHORT */,
            normalized: true
        }
    ],
    [
        7 /* COLOR */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        11 /* AUX */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ]
]);


/***/ }),
/* 60 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "POINT_LABEL_ATTRIBUTE_MAPPING", function() { return POINT_LABEL_ATTRIBUTE_MAPPING; });
/* harmony import */ var _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);

/** Description of how a writer stores vertex data. */
const POINT_LABEL_ATTRIBUTE_MAPPING = new _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__["AttributeMapping"]([
    [
        2 /* ID */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        0 /* POSITION_HIGH */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        1 /* POSITION_LOW */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        6 /* DISPLACEMENT */,
        {
            size: 2,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        4 /* UV */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: false
        }
    ],
    [
        7 /* COLOR */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        8 /* OUTLINE_COLOR */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        9 /* PRIORITY */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        11 /* AUX */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ]
]);


/***/ }),
/* 61 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CURVED_LABEL_ATTRIBUTE_MAPPING", function() { return CURVED_LABEL_ATTRIBUTE_MAPPING; });
/* harmony import */ var _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);

/** Description of how a writer stores vertex data. */
const CURVED_LABEL_ATTRIBUTE_MAPPING = new _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__["AttributeMapping"]([
    [
        2 /* ID */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        0 /* POSITION_HIGH */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        1 /* POSITION_LOW */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        6 /* DISPLACEMENT */,
        {
            size: 3,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        4 /* UV */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: false
        }
    ],
    [
        7 /* COLOR */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        8 /* OUTLINE_COLOR */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        9 /* PRIORITY */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        12 /* AUX1 */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        13 /* AUX2 */,
        {
            size: 4,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        14 /* AUX3 */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        15 /* AUX4 */,
        {
            size: 4,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        11 /* AUX */,
        {
            size: 2,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ]
]);


/***/ }),
/* 62 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "POLYLINE_ATTRIBUTE_MAPPING", function() { return POLYLINE_ATTRIBUTE_MAPPING; });
/* harmony import */ var _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);

/**
 * Description of how attributes of vertices are packed into a vertex buffer.
 */
const POLYLINE_ATTRIBUTE_MAPPING = new _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__["AttributeMapping"]([
    /** Vertex world position. */
    [
        0 /* POSITION */,
        {
            size: 4,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    /** Normal to polyline segment the vertex belong to. */
    [
        5 /* NORMAL */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    /**
     * "UV" vertex that used to compute stroke and dashes. It's components:
     *
     *   - distance to the analytical polyline along segment's normal;
     *   - distance to the analytical polyline along segment.
     */
    [
        4 /* UV */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: false
        }
    ],
    /**
     * Vector with polyline's half width and dash style. It's components:
     *
     *   - half width;
     *   - length of a dash;
     *   - distance between dashes.
     */
    [
        11 /* AUX */,
        {
            size: 3,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    /**
     * Miter (i.e. how much displacement of the vertex is longer then the
     * normal).
     */
    [
        12 /* AUX1 */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    /**
     * Limit on displacement tangent component.Applied to avoid geometry
     * glitches in over-degenerative cases.
     */
    [
        13 /* AUX2 */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    /**
     * Distance to the first vertex along the polyline.
     */
    [
        14 /* AUX3 */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    /** Polyline's color. */
    [
        7 /* COLOR */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    /** Polyline's Z index. */
    [
        10 /* Z_INDEX */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ]
]);


/***/ }),
/* 63 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TileProviderWorkerClient", function() { return TileProviderWorkerClient; });
/* harmony import */ var _util_worker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30);

class TileProviderWorkerClient extends _util_worker__WEBPACK_IMPORTED_MODULE_0__["WebWorkerClient"] {
}


/***/ }),
/* 64 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TileProviderMessageType", function() { return TileProviderMessageType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "geometryTransferableExtractor", function() { return geometryTransferableExtractor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "meshTransferableExtractor", function() { return meshTransferableExtractor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "labelTransferableExtractor", function() { return labelTransferableExtractor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tileTransferableExtractor", function() { return tileTransferableExtractor; });
/* harmony import */ var _primitive_provider_worker_messages__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(65);

var TileProviderMessageType;
(function (TileProviderMessageType) {
    TileProviderMessageType[TileProviderMessageType["INIT"] = 0] = "INIT";
    TileProviderMessageType[TileProviderMessageType["TILE_URL_UPDATE"] = 1] = "TILE_URL_UPDATE";
    TileProviderMessageType[TileProviderMessageType["TILE_REQUEST_BATCH"] = 2] = "TILE_REQUEST_BATCH";
    TileProviderMessageType[TileProviderMessageType["TILE_REQUEST_CANCEL_BATCH"] = 3] = "TILE_REQUEST_CANCEL_BATCH";
    TileProviderMessageType[TileProviderMessageType["TILE_RESPONSE"] = 4] = "TILE_RESPONSE";
    TileProviderMessageType[TileProviderMessageType["TILE_ERROR"] = 5] = "TILE_ERROR";
    TileProviderMessageType[TileProviderMessageType["GEOMETRY_RESPONSE"] = 6] = "GEOMETRY_RESPONSE";
    TileProviderMessageType[TileProviderMessageType["LABELS_RESPONSE"] = 7] = "LABELS_RESPONSE";
    TileProviderMessageType[TileProviderMessageType["MESH_REQUEST"] = 8] = "MESH_REQUEST";
    TileProviderMessageType[TileProviderMessageType["MESH_REQUEST_CANCEL"] = 9] = "MESH_REQUEST_CANCEL";
    TileProviderMessageType[TileProviderMessageType["MESH_RESPONSE"] = 10] = "MESH_RESPONSE";
    TileProviderMessageType[TileProviderMessageType["MESH_ERROR"] = 11] = "MESH_ERROR";
})(TileProviderMessageType || (TileProviderMessageType = {}));
const geometryTransferableExtractor = function (message, transferables = []) {
    Object(_primitive_provider_worker_messages__WEBPACK_IMPORTED_MODULE_0__["extractTransferables"])(message.polygonPages, transferables);
    Object(_primitive_provider_worker_messages__WEBPACK_IMPORTED_MODULE_0__["extractTransferables"])(message.transparentPolygonPages, transferables);
    Object(_primitive_provider_worker_messages__WEBPACK_IMPORTED_MODULE_0__["extractTransferables"])(message.texturedPolygonPages, transferables);
    Object(_primitive_provider_worker_messages__WEBPACK_IMPORTED_MODULE_0__["extractTransferables"])(message.meshPages, transferables);
    Object(_primitive_provider_worker_messages__WEBPACK_IMPORTED_MODULE_0__["extractTransferables"])(message.polylinePages, transferables);
    return transferables;
};
const meshTransferableExtractor = function (message) {
    const transferables = [];
    Object(_primitive_provider_worker_messages__WEBPACK_IMPORTED_MODULE_0__["extractTransferables"])(message.pages, transferables);
    return transferables;
};
const labelTransferableExtractor = function (message, transferables = []) {
    Object(_primitive_provider_worker_messages__WEBPACK_IMPORTED_MODULE_0__["extractTransferables"])(message.pointLabelPages, transferables);
    Object(_primitive_provider_worker_messages__WEBPACK_IMPORTED_MODULE_0__["extractTransferables"])(message.pointLabelBackgroundPages, transferables);
    Object(_primitive_provider_worker_messages__WEBPACK_IMPORTED_MODULE_0__["extractTransferables"])(message.curvedLabelPages, transferables);
    return transferables;
};
const tileTransferableExtractor = function (message) {
    const transferables = [];
    geometryTransferableExtractor(message, transferables);
    labelTransferableExtractor(message, transferables);
    return transferables;
};


/***/ }),
/* 65 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractTransferables", function() { return extractTransferables; });
/**
 * Extract ArrayBuffers (that are tansferable) from pages.
 */
function extractTransferables(pages, output) {
    for (const page of pages) {
        output.push(page.vertexBuffer.buffer, page.indexBuffer.buffer);
    }
}


/***/ }),
/* 66 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TRANSPARENT_POLYGON_ATTRIBUTE_MAPPING", function() { return TRANSPARENT_POLYGON_ATTRIBUTE_MAPPING; });
/* harmony import */ var _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _polygon_attribute_mapping__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(58);


/**
 * Description of how attributes of vertices are packed into a vertex buffer.
 */
const TRANSPARENT_POLYGON_ATTRIBUTE_MAPPING = new _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__["AttributeMapping"](_polygon_attribute_mapping__WEBPACK_IMPORTED_MODULE_1__["POLYGON_ATTRIBUTE_MAPPING"]);


/***/ }),
/* 67 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return IdleTaskQueue; });
/* harmony import */ var _priority_queue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(68);

const MAX_DEQUEUE_TIMEOUT = 1000; // ms
// TODO: remove this shim when all supported browsers implement it
const SHIMMED_PROCESSING_DURATION_MS = 25;
window.cancelIdleCallback = window.cancelIdleCallback || window.clearTimeout;
window.requestIdleCallback = window.requestIdleCallback || function (handler) {
    const startTime = performance.now();
    return setTimeout(() => {
        handler({
            didTimeout: false,
            timeRemaining: () => Math.max(0, SHIMMED_PROCESSING_DURATION_MS - (performance.now() - startTime))
        });
    });
};
/**
 * It is a task queue. Tasks are dequeued during idle period.
 */
class IdleTaskQueue {
    constructor() {
        this._queue = new _priority_queue__WEBPACK_IMPORTED_MODULE_0__["default"]();
        this._dequeueIdleHandle = 0;
    }
    destroy() {
        cancelIdleCallback(this._dequeueIdleHandle);
    }
    /**
     * Enqueues a task to the queue.
     *
     * @param task The task.
     */
    enqueue(task) {
        this._queue.enqueue(task);
        this._run();
    }
    _dequeue(deadline) {
        const queue = this._queue;
        if (queue.isEmpty()) {
            return;
        }
        if (deadline.didTimeout) {
            queue.dequeue().execute();
        }
        else {
            while (deadline.timeRemaining() && !queue.isEmpty()) {
                queue.dequeue().execute();
            }
        }
        this._dequeueIdleHandle = 0;
        if (!this._queue.isEmpty()) {
            this._run();
        }
    }
    _run() {
        if (!this._dequeueIdleHandle) {
            this._dequeueIdleHandle = requestIdleCallback((deadline) => {
                this._dequeue(deadline);
            }, { timeout: MAX_DEQUEUE_TIMEOUT });
        }
    }
}


/***/ }),
/* 68 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PriorityQueue; });
/* harmony import */ var _binary_heap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(69);

function itemComparator(a, b) {
    return a.priority - b.priority;
}
/**
 * Priority queue based on a heap.
 */
class PriorityQueue {
    /**
     * Constructs new empty priority queue.
     */
    constructor() {
        this._heap = new _binary_heap__WEBPACK_IMPORTED_MODULE_0__["default"](itemComparator);
    }
    /**
     * Adds an item into the queue.
     *
     * @param item The item.
     */
    enqueue(item) {
        this._heap.insert(item);
    }
    /**
     * Removes next item from the queue.
     *
     * @returns The next item or `undefined` if the queue's empty.
     */
    dequeue() {
        return this._heap.pop();
    }
    /**
     * Checks if the queue has no items in it.
     *
     * @returns `true` if there're no items it the queue and `false` otherwise.
     */
    isEmpty() {
        return this._heap.size === 0;
    }
}


/***/ }),
/* 69 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BinaryHeap; });
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _comparator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39);


/**
 * Computes index of the parent of an item.
 *
 * @param idx Index of the item.
 * @returns Index of the parent.
 */
function getParentIdx(idx) {
    return (idx + 1 >> 1) - 1;
}
/**
 * Computes index of the left child of an item.
 *
 * @param idx Index of the item.
 * @returns Index of the child.
 */
function getFirstChildIdx(idx) {
    return (idx + 1 << 1) - 1;
}
class BinaryHeap {
    /**
     * Constructs a new empty heap. Order of items in the heap will be defined
     * by a given comparator.
     *
     * @param comparator The comparator.
     */
    constructor(comparator = _comparator__WEBPACK_IMPORTED_MODULE_1__["DEFAULT_COMPARATOR"]) {
        // TODO(dmikis) Investigate preallocation.
        this._items = [];
        this._comparator = comparator;
    }
    /**
     * Inserts an item into the heap.
     *
     * @param item The item to be inserted.
     */
    insert(item) {
        const items = this._items;
        const comparator = this._comparator;
        // Insert the new item as bottom right-most child of the heap.
        let idx = items.push(item) - 1;
        let parentIdx = getParentIdx(idx);
        // Walk the heap upward and restore heap property on the way.
        while (parentIdx > -1 &&
            comparator(items[idx], items[parentIdx]) > 0) {
            Object(_array__WEBPACK_IMPORTED_MODULE_0__["swap"])(items, idx, parentIdx);
            idx = parentIdx;
            parentIdx = getParentIdx(idx);
        }
    }
    /**
     * Removes "maximum" item from the head.
     *
     * @returns The removed item or `undefined` is the heap's empty.
     */
    pop() {
        const items = this._items;
        if (items.length === 0) {
            return undefined;
        }
        const newSize = items.length - 1;
        // Place max item at the end of the items array.
        Object(_array__WEBPACK_IMPORTED_MODULE_0__["swap"])(items, 0, newSize);
        // Walk downward from the new root to restore heap property.
        let idx = 0;
        let childIdx = 1;
        const comparator = this._comparator;
        while (childIdx < newSize) {
            if (childIdx + 1 < newSize &&
                comparator(items[childIdx], items[childIdx + 1]) < 0) {
                childIdx += 1;
            }
            if (comparator(items[idx], items[childIdx]) > 0) {
                break;
            }
            Object(_array__WEBPACK_IMPORTED_MODULE_0__["swap"])(items, idx, childIdx);
            idx = childIdx;
            childIdx = getFirstChildIdx(childIdx);
        }
        // Remove previously placed at the end previous max item.
        return items.pop();
    }
    /**
     * @returns "Maximum" item in the heap or `undefined` if the head is empty.
     */
    peek() {
        return this._items[0];
    }
    /**
     * @returns Iterator over all items in the heap. Note that order of items
     *      is undefined.
     */
    *[Symbol.iterator]() {
        for (const item of this._items) {
            yield item;
        }
    }
    /**
     * @returns Number of items in the heap.
     */
    get size() {
        return this._items.length;
    }
}


/***/ }),
/* 70 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RenderablePolygon; });
/* harmony import */ var _renderable_primitive__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(71);

/**
 * Allocated in GPU memory polygon.
 */
class RenderablePolygon extends _renderable_primitive__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(memorySubChunk, isOpaque) {
        super(memorySubChunk);
        this.isOpaque = isOpaque;
    }
}


/***/ }),
/* 71 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RenderablePrimitive; });
/* harmony import */ var _util_ref_counted__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(43);

/**
 * Base class for primitive objects that are ready to be fed to the renderer.
 */
class RenderablePrimitive extends _util_ref_counted__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(memorySubChunk) {
        super();
        this.memorySubChunk = memorySubChunk;
    }
    _destroy() {
        this.memorySubChunk.destroy();
    }
}


/***/ }),
/* 72 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RenderableTexturedPolygon; });
/* harmony import */ var _renderable_primitive__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(71);

class RenderableTexturedPolygon extends _renderable_primitive__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(memoryChunk, allocatedImage) {
        super(memoryChunk);
        this._allocatedImage = allocatedImage;
        this.atlas = allocatedImage.atlasManager.atlas;
        allocatedImage.retain();
    }
    _destroy() {
        this._allocatedImage.release();
        super._destroy();
    }
}


/***/ }),
/* 73 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RenderablePolyline; });
/* harmony import */ var _renderable_primitive__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(71);

class RenderablePolyline extends _renderable_primitive__WEBPACK_IMPORTED_MODULE_0__["default"] {
}


/***/ }),
/* 74 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RenderableTexturedPolyline; });
/* harmony import */ var _renderable_polyline__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(73);

class RenderableTexturedPolyline extends _renderable_polyline__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(memoryChunk, allocatedImage) {
        super(memoryChunk);
        this._allocatedImage = allocatedImage;
        this.atlas = allocatedImage.atlasManager.atlas;
        allocatedImage.retain();
    }
    _destroy() {
        this._allocatedImage.release();
        super._destroy();
    }
}


/***/ }),
/* 75 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RenderableModel; });
/* harmony import */ var _renderable_primitive__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(71);

/**
 * A general primitive that is best suitable for storing simple colored 3D models.
 */
class RenderableModel extends _renderable_primitive__WEBPACK_IMPORTED_MODULE_0__["default"] {
}


/***/ }),
/* 76 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "POLYGON_EXTRACTOR", function() { return POLYGON_EXTRACTOR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEXTURED_POLYGON_EXTRACTOR", function() { return TEXTURED_POLYGON_EXTRACTOR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "POLYLINE_EXTRACTOR", function() { return POLYLINE_EXTRACTOR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEXTURED_POLYLINE_EXTRACTOR", function() { return TEXTURED_POLYLINE_EXTRACTOR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "POINT_EXTRACTOR", function() { return POINT_EXTRACTOR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "POINT_LABEL_EXTRACTOR", function() { return POINT_LABEL_EXTRACTOR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CURVED_LABEL_EXTRACTOR", function() { return CURVED_LABEL_EXTRACTOR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MODEL_EXTRACTOR", function() { return MODEL_EXTRACTOR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EXTERNAL_MESH_EXTRACTOR", function() { return EXTERNAL_MESH_EXTRACTOR; });
const POLYGON_EXTRACTOR = (data) => flat(map('polygons', data));
const TEXTURED_POLYGON_EXTRACTOR = (data) => flat(map('texturedPolygons', data));
const POLYLINE_EXTRACTOR = (data) => flat(map('polylines', data));
const TEXTURED_POLYLINE_EXTRACTOR = (data) => flat(map('texturedPolylines', data));
const POINT_EXTRACTOR = (data) => flat(map('points', data));
const POINT_LABEL_EXTRACTOR = (data) => flat(map('pointLabels', data));
const CURVED_LABEL_EXTRACTOR = (data) => flat(map('curvedLabels', data));
const MODEL_EXTRACTOR = (data) => flat(map('models', data));
const EXTERNAL_MESH_EXTRACTOR = (data) => flat(map('externalMeshes', data));
/**
 * Maps list of TileData's into list of specified primitives.
 */
function* map(type, data) {
    for (const portion of data) {
        yield portion[type];
    }
}
/**
 * Flatten two dimensional list of primitives in a single dimensional one.
 */
function* flat(primitives) {
    for (const portion of primitives) {
        if (portion) {
            yield* portion;
        }
    }
}


/***/ }),
/* 77 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RenderablePrimitiveManager; });
/* harmony import */ var _primitive_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(78);

/**
 * Manager of primitives that have a single assiciated renderable primitive. The "management" is pretty straightforward:
 * it directly adds/removes associated primitives into the storage.
 */
class RenderablePrimitiveManager extends _primitive_manager__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(primitivesStorage) {
        super();
        this._primitivesStorage = primitivesStorage;
    }
    updateScene(toShow, toHide) {
        this._primitivesStorage.add(...toShow);
        this._primitivesStorage.delete(...toHide);
    }
    destroyPrimitives(_toDestroy) {
        // no need to destroy anything, RenderablePrimitive are released when removed from primmitive storage
    }
}


/***/ }),
/* 78 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PrimitiveManager; });
/**
 * Often primitives can't be dirrectly added into or removed from scene, there can be some specific (business) logic
 * associated with these operations. This class provides basic methods for such implementations that
 * allows to manage primitives of all types in the same manner.
 */
class PrimitiveManager {
    destroy() { }
}


/***/ }),
/* 79 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PrimitiveSetStorage; });
/* harmony import */ var _util_event_emitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(14);

/**
 * Primitive storage that stores primitive in a set. It acts as a primitive provider as well.
 */
class PrimitiveSetStorage {
    constructor() {
        this._primitiveSet = new Set();
        this.onUpdate = new _util_event_emitter__WEBPACK_IMPORTED_MODULE_0__["VoidEventEmitter"]();
    }
    get primitives() {
        return this._primitiveSet;
    }
    add(...primitives) {
        for (const primitive of primitives) {
            primitive.retain();
            this._primitiveSet.add(primitive);
        }
        if (primitives.length > 0) {
            this.onUpdate.fire();
        }
    }
    delete(...primitives) {
        for (const primitive of primitives) {
            if (this._primitiveSet.delete(primitive)) {
                primitive.release();
            }
        }
        if (primitives.length > 0) {
            this.onUpdate.fire();
        }
    }
    clear() {
        this._primitiveSet.clear();
        this.onUpdate.fire();
    }
}


/***/ }),
/* 80 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PolygonManager; });
/* harmony import */ var _renderable_primitive_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(77);

/**
 * Polygons should be separated by opaqueness and there are two distinct primitive providers
 * for them: opaque and tansparent. That is what this manager takes care of.
 */
class PolygonManager extends _renderable_primitive_manager__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(opaquePolygonStorage, transparentPolygonStorage) {
        super(opaquePolygonStorage);
        this._opaquePolygonStorage = opaquePolygonStorage;
        this._transparentPolygonStorage = transparentPolygonStorage;
    }
    updateScene(toShow, toHide) {
        for (const primitive of toShow) {
            if (primitive.isOpaque) {
                this._opaquePolygonStorage.add(primitive);
            }
            else {
                this._transparentPolygonStorage.add(primitive);
            }
        }
        for (const primitive of toHide) {
            if (primitive.isOpaque) {
                this._opaquePolygonStorage.delete(primitive);
            }
            else {
                this._transparentPolygonStorage.delete(primitive);
            }
        }
    }
}


/***/ }),
/* 81 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DisappearingPrimitiveSetStorage; });
/* harmony import */ var _primitive_set_storage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(79);

/**
 * Simple primitive set storage that distinguish visible/hidden primitives. It also acts as a primitive provider.
 */
class DisappearingPrimitiveSetStorage extends _primitive_set_storage__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super();
        this._visiblePrimitives = new Set();
    }
    get primitives() {
        return this.visiblePrimitives;
    }
    get visiblePrimitives() {
        return this._visiblePrimitives;
    }
    add(...primitives) {
        super.add(...primitives);
        this.show(...primitives);
    }
    delete(...primitives) {
        this.hide(...primitives);
        super.delete(...primitives);
    }
    show(...primitives) {
        for (const primitive of primitives) {
            if (this._primitiveSet.has(primitive)) {
                this._visiblePrimitives.add(primitive);
            }
        }
    }
    hide(...primitives) {
        for (const primitive of primitives) {
            this._visiblePrimitives.delete(primitive);
        }
    }
    _isAllowedToShowPrimitive(primitive) {
        return this._primitiveSet.has(primitive);
    }
}


/***/ }),
/* 82 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DelayedDisappearingPrimitiveSetStorage; });
/* harmony import */ var _util_iterable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _disappearing_primitive_set_storage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(81);


/**
 * Primitive storage that stores primitive in a set. It acts as a primitive provider as well.
 */
class DelayedDisappearingPrimitiveSetStorage extends _disappearing_primitive_set_storage__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor(appearingEffectDuration) {
        super();
        this._appearingEffectDuration = appearingEffectDuration;
        this._scheduledRemoves = new Map();
        this._timeoutIds = new Set();
    }
    get primitives() {
        return this._primitiveSet;
    }
    add(...primitives) {
        // primitives that are scheduled for removing was not removed "physically", that is why
        // they should be filtered out to prevent multiple adding of the same primitive in parent
        const notScheduledForRemovePrimitives = [];
        for (const primitive of primitives) {
            const primitivesToDelete = this._scheduledRemoves.get(primitive);
            if (primitivesToDelete) {
                // if this primitive is scheduled for removing it is deleted from its batch,
                // thus canceling the removing in the callback
                primitivesToDelete.delete(primitive);
                this._scheduledRemoves.delete(primitive);
            }
            else {
                notScheduledForRemovePrimitives.push(primitive);
            }
        }
        super.add(...notScheduledForRemovePrimitives);
        this.show(...notScheduledForRemovePrimitives);
    }
    delete(...primitives) {
        this.hide(...primitives);
        // primitives are batched in a set to be deleted in one setTimeout callback for performance,
        // filter out primitives which removing was already scheduled
        const primitivesToDelete = new Set(Object(_util_iterable__WEBPACK_IMPORTED_MODULE_0__["filterIterable"])(primitives, (primitive) => !this._scheduledRemoves.has(primitive)));
        if (primitivesToDelete.size > 0) {
            const timeoutId = setTimeout(() => {
                // primitivesToDelete contains relevant for removing primitives, it can be updated in the add() method
                // if a primitive is added back, thus, in fact, canceling removing of this specific primitive
                super.delete(...primitivesToDelete);
                for (const primitive of primitivesToDelete) {
                    this._scheduledRemoves.delete(primitive);
                }
                this._timeoutIds.delete(timeoutId);
            }, this._appearingEffectDuration);
            for (const primitive of primitivesToDelete) {
                this._scheduledRemoves.set(primitive, primitivesToDelete);
            }
            this._timeoutIds.add(timeoutId);
        }
    }
    destroy() {
        for (const timeoutId of this._timeoutIds) {
            clearTimeout(timeoutId);
        }
    }
    _isAllowedToShowPrimitive(primitive) {
        return super._isAllowedToShowPrimitive(primitive) && !this._scheduledRemoves.has(primitive);
    }
}


/***/ }),
/* 83 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ZoomFilterablePrimitiveManager; });
/* harmony import */ var _renderable_primitive_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(77);
/* harmony import */ var _util_iterable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);


/**
 * It is required to hide some primitives (that don't scale with zoom, e.g. labels or icons) by "too irrelevant" zoom,
 * to prevent mess of collapsed objects on the screen. This primitive manager is a temporary solution,
 * proper handling of zoom slices will replace it.
 */
// TODO: this manager is a tmp solution, correct handling of zoom slices is going to replace it
class ZoomFilterablePrimitiveManager extends _renderable_primitive_manager__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(primitivesStorage, camera) {
        super(primitivesStorage);
        this._disappearingPrimitivesStorage = primitivesStorage;
        this._camera = camera;
        this._primitives = new Set();
        this._prevZoom = camera.zoom;
        this._zoomUpdateListener = this._onZoomUpdated.bind(this);
        this._camera.onUpdate.addListener(this._zoomUpdateListener);
    }
    updateScene(toShow, toHide) {
        // save primitives to filter them later
        super.updateScene(Object(_util_iterable__WEBPACK_IMPORTED_MODULE_1__["mapIterable"])(toShow, (primitive) => {
            this._primitives.add(primitive);
            return primitive;
        }), Object(_util_iterable__WEBPACK_IMPORTED_MODULE_1__["mapIterable"])(toHide, (primitive) => {
            this._primitives.delete(primitive);
            return primitive;
        }));
        // check if there are added primitives that could be removed by zoom restrictions
        this._updateZoomVisibility();
    }
    _onZoomUpdated() {
        if (this._prevZoom !== this._camera.zoom) {
            this._updateZoomVisibility();
            this._prevZoom = this._camera.zoom;
        }
    }
    _updateZoomVisibility() {
        const zoom = this._camera.zoom;
        this._disappearingPrimitivesStorage.show(...Object(_util_iterable__WEBPACK_IMPORTED_MODULE_1__["filterIterable"])(this._primitives, ({ minZoom }) => zoom >= minZoom));
        this._disappearingPrimitivesStorage.hide(...Object(_util_iterable__WEBPACK_IMPORTED_MODULE_1__["filterIterable"])(this._primitives, ({ minZoom }) => zoom < minZoom));
    }
    destroy() {
        this._camera.onUpdate.removeListener(this._zoomUpdateListener);
    }
}


/***/ }),
/* 84 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ExternalMeshPrimitiveManager; });
/* harmony import */ var _worker_tile_provider_worker_messages__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(64);
/* harmony import */ var _render_memory_sub_chunk__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(40);
/* harmony import */ var _primitive_model_model_buffer_writer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(50);
/* harmony import */ var _primitive_manager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(78);
/* harmony import */ var _primitive_model_renderable_model__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(75);
/* harmony import */ var _util_worker__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(30);






/**
 * External meshes come in polygons (kind of building outlines). This manager controls quering external meshes
 * according to added polygons, as many of them can share the same mesh (usually across multiple tiles).
 */
class ExternalMeshPrimitiveManager extends _primitive_manager__WEBPACK_IMPORTED_MODULE_3__["default"] {
    constructor(primitivesStorage, geometryProvider, memoryManager) {
        super();
        this._primitivesStorage = primitivesStorage;
        this._tileProvider = geometryProvider;
        this._memoryManager = memoryManager;
        this._externalMeshes = new Map();
    }
    updateScene(toShow, toHide) {
        for (const primitive of toShow) {
            this._addPrimitive(primitive);
        }
        for (const primitive of toHide) {
            this._removePrimitive(primitive);
        }
    }
    _addPrimitive(primitive) {
        const id = getFullMeshId(primitive);
        let external = this._externalMeshes.get(id);
        if (!external) {
            external = {
                visiblePolygons: new Set(),
                isVisible: false
            };
            this._externalMeshes.set(id, external);
            this._tileProvider.request({
                type: _worker_tile_provider_worker_messages__WEBPACK_IMPORTED_MODULE_0__["TileProviderMessageType"].MESH_REQUEST,
                responseType: _worker_tile_provider_worker_messages__WEBPACK_IMPORTED_MODULE_0__["TileProviderMessageType"].MESH_RESPONSE,
                errorType: _worker_tile_provider_worker_messages__WEBPACK_IMPORTED_MODULE_0__["TileProviderMessageType"].MESH_ERROR,
                mesh: primitive,
                requestId: _util_worker__WEBPACK_IMPORTED_MODULE_5__["NO_ID"]
            }).then((response) => {
                const external = this._externalMeshes.get(id);
                if (external && !external.isVisible) {
                    const location = response.location;
                    const chunks = response.pages.map((page) => this._memoryManager.allocate(page.vertexBuffer, page.indexBuffer, _primitive_model_model_buffer_writer__WEBPACK_IMPORTED_MODULE_2__["default"].ATTRIBUTE_MAPPING));
                    external.mesh = new _primitive_model_renderable_model__WEBPACK_IMPORTED_MODULE_4__["default"](new _render_memory_sub_chunk__WEBPACK_IMPORTED_MODULE_1__["default"](chunks[location.bufferIndex], location));
                    external.isVisible = true;
                    this._primitivesStorage.add(external.mesh);
                    chunks.forEach((chunk) => chunk.release());
                }
            });
        }
        external.visiblePolygons.add(primitive);
    }
    _removePrimitive(primitive) {
        const id = getFullMeshId(primitive);
        const external = this._externalMeshes.get(id);
        if (external) {
            external.visiblePolygons.delete(primitive);
            // destroy external mesh if there is no visible polygons remaining
            if (external.visiblePolygons.size === 0) {
                this._externalMeshes.delete(id);
                if (external.mesh) {
                    external.mesh.release();
                    this._primitivesStorage.delete(external.mesh);
                    external.isVisible = false;
                }
                else {
                    // if no mesh yet returned cancel request
                    this._tileProvider.sendMessage({
                        type: _worker_tile_provider_worker_messages__WEBPACK_IMPORTED_MODULE_0__["TileProviderMessageType"].MESH_REQUEST_CANCEL,
                        mesh: primitive
                    });
                }
            }
        }
    }
}
function getFullMeshId(mesh) {
    return mesh.objectId + mesh.meshId;
}


/***/ }),
/* 85 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RenderableBillboardRectangle; });
/* harmony import */ var _renderable_primitive__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(71);

class RenderableBillboardRectangle extends _renderable_primitive__WEBPACK_IMPORTED_MODULE_0__["default"] {
}


/***/ }),
/* 86 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZoomRestrictedLabel", function() { return ZoomRestrictedLabel; });
/* harmony import */ var _primitive_label_renderable_label__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(87);

class ZoomRestrictedLabel extends _primitive_label_renderable_label__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(memorySubChunk, atlas, minZoom, background) {
        super(memorySubChunk, atlas, background);
        this.minZoom = minZoom;
    }
}


/***/ }),
/* 87 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RenderableLabel; });
/* harmony import */ var _renderable_primitive__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(71);

/**
 * Allocated in GPU memory label.
 */
class RenderableLabel extends _renderable_primitive__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Constructs a new renderable label.
     *
     * @param memorySubChunk
     * @param atlas
     * @param background
     */
    constructor(memorySubChunk, atlas, background) {
        super(memorySubChunk);
        this.atlas = atlas;
        this.background = background;
        if (background) {
            background.retain();
        }
    }
    _destroy() {
        if (this.background) {
            this.background.release();
        }
        super._destroy();
    }
}


/***/ }),
/* 88 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZoomRestrictedIcon", function() { return ZoomRestrictedIcon; });
/* harmony import */ var _primitive_icon_renderable_icon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(89);

class ZoomRestrictedIcon extends _primitive_icon_renderable_icon__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(memorySubChunk, allocatedImage, minZoom) {
        super(memorySubChunk, allocatedImage);
        this.minZoom = minZoom;
    }
}


/***/ }),
/* 89 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RenderableIcon; });
/* harmony import */ var _image_renderable_image__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(90);

class RenderableIcon extends _image_renderable_image__WEBPACK_IMPORTED_MODULE_0__["default"] {
}


/***/ }),
/* 90 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RenderableImage; });
/* harmony import */ var _textured_renderable_primitive__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(91);

class RenderableImage extends _textured_renderable_primitive__WEBPACK_IMPORTED_MODULE_0__["default"] {
}


/***/ }),
/* 91 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TexturedRenderablePrimitive; });
/* harmony import */ var _renderable_primitive__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(71);

class TexturedRenderablePrimitive extends _renderable_primitive__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(memoryChunk, allocatedImage) {
        super(memoryChunk);
        this._allocatedImage = allocatedImage;
        this.atlas = allocatedImage.atlasManager.atlas;
        this._allocatedImage.retain();
    }
    _destroy() {
        this._allocatedImage.release();
        super._destroy();
    }
}


/***/ }),
/* 92 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TaskQueue; });
/* harmony import */ var _priority_queue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(68);
/* harmony import */ var _util_event_emitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(14);


const DEQUEUE_TIMEOUT = 1; // ms
/**
 * Prioritized task queue.
 */
class TaskQueue {
    /**
     * Constructs an empty task queue.
     */
    constructor() {
        this._queue = new _priority_queue__WEBPACK_IMPORTED_MODULE_0__["default"]();
        this._frozen = false;
        this._dequeueTimeoutHandle = 0;
        this.onEmpty = new _util_event_emitter__WEBPACK_IMPORTED_MODULE_1__["VoidEventEmitter"]();
    }
    /**
     * Destroys the queue. Any remaining tasks won't be executed.
     */
    destroy() {
        clearTimeout(this._dequeueTimeoutHandle);
    }
    /**
     * Enqueues a task to the queue and schedules processing of the queue.
     *
     * @param task The task.
     * @returns Promise that will be fullfilled when the task successfully
     *      finishes or rejected if there's an error.
     */
    enqueue(task) {
        if (!this._frozen) {
            this._setDequeueTimeout();
        }
        return new Promise((resolve, reject) => {
            this._queue.enqueue({
                execute() {
                    try {
                        task.execute();
                        resolve();
                    }
                    catch (error) {
                        reject(error);
                    }
                },
                priority: task.priority
            });
        });
    }
    isEmpty() {
        return this._queue.isEmpty();
    }
    freeze() {
        if (this._dequeueTimeoutHandle) {
            clearTimeout(this._dequeueTimeoutHandle);
            this._dequeueTimeoutHandle = 0;
        }
        this._frozen = true;
    }
    unfreeze() {
        this._frozen = false;
        if (!this._queue.isEmpty()) {
            this._setDequeueTimeout();
        }
    }
    _dequeue() {
        const task = this._queue.dequeue();
        if (task) {
            task.execute();
        }
        if (this._queue.isEmpty()) {
            this._dequeueTimeoutHandle = 0;
            this.onEmpty.fire();
        }
        else {
            this._dequeueTimeoutHandle = setTimeout(() => this._dequeue(), DEQUEUE_TIMEOUT);
        }
    }
    _setDequeueTimeout() {
        if (!this._dequeueTimeoutHandle) {
            this._dequeueTimeoutHandle = setTimeout(() => this._dequeue(), DEQUEUE_TIMEOUT);
        }
    }
}


/***/ }),
/* 93 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MouseDragController", function() { return MouseDragController; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ScrollZoomController", function() { return ScrollZoomController; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CameraMouseController", function() { return CameraMouseController; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderCameraState", function() { return renderCameraState; });
/* harmony import */ var _src_vector_render_engine_util_delegator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(94);
/* harmony import */ var _src_vector_render_engine_math_vector2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(23);


class MouseDragController extends _src_vector_render_engine_util_delegator__WEBPACK_IMPORTED_MODULE_0__["DelegatorBase"] {
    constructor(target) {
        super();
        this._target = target;
        this._pressedButton = -1 /* NONE */;
        this._prevMouseCoords = _src_vector_render_engine_math_vector2__WEBPACK_IMPORTED_MODULE_1__["create"](0, 0);
        target.addEventListener('mousedown', this);
        target.addEventListener('click', this);
        target.addEventListener('contextmenu', this);
    }
    handleEvent(e) {
        switch (e.type) {
            case 'click':
            case 'contextmenu':
                e.preventDefault();
                break;
            case 'mousedown':
                if (this._pressedButton === -1 /* NONE */) {
                    this._pressedButton = e.button;
                    this._prevMouseCoords.x = e.clientX;
                    this._prevMouseCoords.y = e.clientY;
                    document.body.addEventListener('mousemove', this);
                    document.body.addEventListener('mouseup', this);
                }
                e.preventDefault();
                break;
            case 'mousemove':
                if (this._delegate === null) {
                    break;
                }
                const mouseCoords = _src_vector_render_engine_math_vector2__WEBPACK_IMPORTED_MODULE_1__["create"](e.clientX, e.clientY);
                const delta = _src_vector_render_engine_math_vector2__WEBPACK_IMPORTED_MODULE_1__["sub"](mouseCoords, this._prevMouseCoords);
                switch (this._pressedButton) {
                    case 0 /* LEFT */:
                        this._delegate.onLeftButtonDrag(delta);
                        break;
                    case 1 /* MIDDLE */:
                        this._delegate.onMiddleButtonDrag(delta);
                        break;
                    case 2 /* RIGHT */:
                        this._delegate.onRightButtonDrag(delta);
                        break;
                }
                _src_vector_render_engine_math_vector2__WEBPACK_IMPORTED_MODULE_1__["copy"](mouseCoords, this._prevMouseCoords);
                e.preventDefault();
                break;
            case 'mouseup':
                if (this._pressedButton === e.button) {
                    document.body.removeEventListener('mouseup', this);
                    document.body.removeEventListener('mousemove', this);
                    this._pressedButton = -1 /* NONE */;
                }
                e.preventDefault();
                break;
        }
    }
    destroy() {
        this._target.removeEventListener('contextmenu', this);
        this._target.removeEventListener('click', this);
        this._target.removeEventListener('mousedown', this);
    }
}
class ScrollZoomController extends _src_vector_render_engine_util_delegator__WEBPACK_IMPORTED_MODULE_0__["DelegatorBase"] {
    constructor(target) {
        super();
        this._target = target;
        target.addEventListener('wheel', this);
    }
    handleEvent(e) {
        const delegate = this._delegate;
        if (!delegate) {
            return;
        }
        if (e.deltaY < 0) {
            delegate.onScrollIn();
        }
        else {
            delegate.onScrollOut();
        }
        e.preventDefault();
    }
    destroy() {
        this._target.removeEventListener('wheel', this);
    }
}
const ZOOM_STEP = 0.1;
const TILT_AZIMUTH_FACTOR = Math.PI / 1024;
class CameraMouseController {
    constructor(canvas, camera) {
        this._camera = camera;
        this._canvasSize = _src_vector_render_engine_math_vector2__WEBPACK_IMPORTED_MODULE_1__["create"](canvas.width, canvas.height);
        this.dragFactor = 1;
    }
    onLeftButtonDrag(delta) {
        // That's not exact, but good enough for now.
        _src_vector_render_engine_math_vector2__WEBPACK_IMPORTED_MODULE_1__["divv"](delta, this._canvasSize, delta);
        const camera = this._camera;
        _src_vector_render_engine_math_vector2__WEBPACK_IMPORTED_MODULE_1__["muln"](delta, this.dragFactor * camera.screenSize.height * Math.pow(2, -camera.zoom) /
            (Math.tan(0.5 * camera.options.fov) * 64), delta);
        const center = this._camera.center;
        center.x -= delta.x;
        center.y += delta.y;
        this._camera.setDirty();
    }
    onMiddleButtonDrag() { }
    onRightButtonDrag(delta) {
        const camera = this._camera;
        camera.tilt += delta.y * TILT_AZIMUTH_FACTOR;
        camera.azimuth += delta.x * TILT_AZIMUTH_FACTOR;
        this._camera.setDirty();
    }
    onScrollIn() {
        this._camera.zoom += ZOOM_STEP;
        this._camera.setDirty();
    }
    onScrollOut() {
        this._camera.zoom -= ZOOM_STEP;
        this._camera.setDirty();
    }
}
const cameraStateElement = document.querySelector('#camera_state');
const cameraStateText = cameraStateElement && cameraStateElement.firstChild;
function renderCameraState(camera) {
    const { center: { x, y }, zoom, tilt, azimuth } = camera;
    cameraStateText.replaceData(0, cameraStateText.length, `center: (${x.toFixed(8)},${y.toFixed(8)}); zoom: ${zoom.toFixed(4)}; ` +
        `tilt: ${tilt.toFixed(4)}; azimuth: ${azimuth.toFixed(4)}`);
}


/***/ }),
/* 94 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DelegatorBase", function() { return DelegatorBase; });
class DelegatorBase {
    constructor() {
        this._delegate = null;
    }
    setDelegate(delegate) {
        this._delegate = delegate;
    }
}


/***/ }),
/* 95 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ColorIdPointLabelRenderer; });
/* harmony import */ var _shader_point_label_vert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96);
/* harmony import */ var _shader_point_label_vert__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_shader_point_label_vert__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _shader_color_id_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(97);
/* harmony import */ var _shader_color_id_frag__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_shader_color_id_frag__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _color_id_label_renderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(98);
/* harmony import */ var _render_primitives_label_point_label_render_unit__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(104);




/**
 * Point labels renderer for collision resolution.
 */
class ColorIdPointLabelRenderer extends _color_id_label_renderer__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor(context, camera, primitiveProvider) {
        const program = context.createProgram(_shader_point_label_vert__WEBPACK_IMPORTED_MODULE_0___default.a, _shader_color_id_frag__WEBPACK_IMPORTED_MODULE_1___default.a, _render_primitives_label_point_label_render_unit__WEBPACK_IMPORTED_MODULE_3__["PROGRAM_OPTIONS"]);
        super(context, program, primitiveProvider, camera);
    }
}


/***/ }),
/* 96 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec2 vertexId;\n\n// point in the world the label is anchored to\nattribute vec2 vertexPosHigh;\nattribute vec2 vertexPosLow;\n\n// vector of concrete glyph point displacement (top-left, bottom-left, ...) relative to label's center, in px\nattribute vec2 vertexDisplacement;\n\n// coordinates of the glyph vertex in the atlas\nattribute vec2 vertexUV;\n\nattribute float vertexPriority;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\nuniform vec2 pixelSize;\nuniform sampler2D visibility;\nuniform vec2 idHalfPxSize;\nuniform vec2 shift;\nuniform lowp float currentZoom;\n\nvarying vec2 uv;\nvarying lowp vec4 color;\nvarying lowp vec4 outlineColor;\nvarying mediump float scale;\n\nconst vec4 DISCARD_POSITION = vec4(2, 2, 2, 1);\n\nconst float YV_H_1_0 = 1.999969482421875;\nconst float YV_L_1_1 = 0.000030517112463712692;\n\n/**\n * Projects specific point label vertex onto the screen.\n */\nvec4 projectPointLabelVertex_1_2(\n    mat4 viewProjMatrix,\n    vec2 lookAtHigh,\n    vec2 lookAtLow,\n    vec2 posHigh,\n    vec2 posLow,\n    vec2 displacement,\n    vec2 pxSize\n) {\n    vec4 position = viewProjMatrix * vec4(\n        YV_H_1_0 * (posHigh - lookAtHigh) +\n            YV_L_1_1 * (posLow - lookAtLow),\n        0,\n        1\n    );\n    position = vec4(position.xy / position.w, 0.0, 1.0);\n\n    return position + vec4(displacement * pxSize, 0.0, 0.0);\n}\n\n\n\n\nvoid main(void) {\n    vec2 idTexCoordinate = vertexId.xy + idHalfPxSize;\n    float overlapZoom = texture2D(visibility, idTexCoordinate).b;\n    if (currentZoom < overlapZoom) {\n        gl_Position = DISCARD_POSITION;\n    } else {\n        gl_Position = projectPointLabelVertex_1_2(\n            viewProjMatrix,\n            lookAtHigh,\n            lookAtLow,\n            vertexPosHigh,\n            vertexPosLow,\n            vertexDisplacement,\n            pixelSize\n        );\n        gl_Position.xy += shift;\n        gl_Position.z = vertexPriority;\n        color = vec4(vertexId, 0, 1);\n    }\n\n}\n"

/***/ }),
/* 97 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nvarying lowp vec4 color;\n\nvoid main(void) {\n    gl_FragColor = color;\n}\n"

/***/ }),
/* 98 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ColorIdLabelRenderer; });
/* harmony import */ var _colliding_primitive_color_id_renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(99);

/**
 * "color id" renderer for labels, both for point and curved ones.
 */
class ColorIdLabelRenderer extends _colliding_primitive_color_id_renderer__WEBPACK_IMPORTED_MODULE_0__["CollidingPrimitiveColorIdRenderer"] {
    constructor(context, program, primitiveProvider, camera) {
        super(context, program, primitiveProvider);
        this._camera = camera;
    }
    _prepareProgram(program, viewProjMatrix, cameraPositions, state, stabilityShift, visibility, currentZoom) {
        super._prepareProgram(program, viewProjMatrix, cameraPositions, state, stabilityShift, visibility, currentZoom);
        program.setVector2Uniform('pixelSize', this._camera.pixelSize);
    }
}


/***/ }),
/* 99 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CollidingPrimitiveColorIdRenderer", function() { return CollidingPrimitiveColorIdRenderer; });
/* harmony import */ var _render_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);
/* harmony import */ var _math_vector2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(23);
/* harmony import */ var _render_primitives_world_primitive_render_unit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(100);



class CollidingPrimitiveColorIdRenderer extends _render_primitives_world_primitive_render_unit__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor(context, program, primitiveProvider) {
        super(context, new _render_state__WEBPACK_IMPORTED_MODULE_0__["default"](), program, primitiveProvider);
        this._idHalfPxSizeUniform = _math_vector2__WEBPACK_IMPORTED_MODULE_1__["create"](0, 0);
    }
    _getPrimitives() {
        return this.primitiveProvider.visiblePrimitives;
    }
    _prepareProgram(program, viewProjMatrix, cameraPositions, state, stabilityShift, visibility, currentZoom) {
        super._prepareProgram(program, viewProjMatrix, cameraPositions, state, stabilityShift, visibility, currentZoom);
        this._idHalfPxSizeUniform.x = 0.5 / visibility.getWidth();
        this._idHalfPxSizeUniform.y = 0.5 / visibility.getHeight();
        this._context.bindTextureUnit(0);
        this._context.bindTexture(visibility);
        program.setIntScalarUniform('visibility', 0);
        program.setVector2Uniform('idHalfPxSize', this._idHalfPxSizeUniform);
        program.setVector2Uniform('shift', stabilityShift);
        program.setScalarUniform('currentZoom', currentZoom);
    }
    _prepareRenderTarget(target, _viewProjMatrix, _cameraPositions, state, _stabilityShift, _visibility, _currentZoom) {
        this._context.bindRenderState(state);
        this._context.bindRenderTarget(target);
    }
}


/***/ }),
/* 100 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WorldPrimitiveRenderUnit; });
/* harmony import */ var _gl_renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(101);
/* harmony import */ var _memory_count_vertices__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(41);
/* harmony import */ var _primitive_batch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(102);



/**
 * Base class for rendering visible primitives. Being visible in the world means that they all need view-projection
 * matrix and camera positions (multiple positions are used for rendering repeated world). These parameters are
 * predefined as external requirements for render() method.
 */
class WorldPrimitiveRenderUnit extends _gl_renderer__WEBPACK_IMPORTED_MODULE_0__["GlRenderer"] {
    constructor(context, renderState, program, primitiveProvider) {
        super(context, renderState, program);
        this.primitiveProvider = primitiveProvider;
        this.onUpdate = primitiveProvider.onUpdate;
    }
    render(target, viewProjMatrix, cameraPositions, ...args) {
        super.render(target, viewProjMatrix, cameraPositions, ...args);
    }
    _render(_viewProjMatrix, cameraPositions) {
        for (const cameraPosition of cameraPositions) {
            this._program.setVector2Uniform('lookAtHigh', cameraPosition.lookAtHigh);
            this._program.setVector2Uniform('lookAtLow', cameraPosition.lookAtLow);
            for (const memoryBatch of Object(_primitive_batch__WEBPACK_IMPORTED_MODULE_2__["batchPrimitives"])(this._getPrimitives(), this._canBatchAdjacentPrimitives)) {
                this._renderBatch(memoryBatch);
            }
        }
    }
    _getPrimitives() {
        return this.primitiveProvider.primitives;
    }
    _prepareProgram(program, viewProjMatrix, cameraPositions, ...args) {
        super._prepareProgram(program, viewProjMatrix, cameraPositions, ...args);
        program.setMatrix4Uniform('viewProjMatrix', viewProjMatrix);
    }
    _renderBatch(memoryBatch) {
        this._context.bindVao(memoryBatch.page.vao);
        this._context.drawIndexedMesh(memoryBatch.indexByteOffset, Object(_memory_count_vertices__WEBPACK_IMPORTED_MODULE_1__["countIndices"])(memoryBatch.indexByteLength, memoryBatch.page.indexType));
    }
    /**
     * Determines if two adjacent primitives can be rendered in one batch (by a single draw call). They already
     * lay successively in memory, but there could be other reasons that forbid batching, like using different textures.
     * The method should be overridden in subclasses if their primitives have such complex rules of batching.
     */
    _canBatchAdjacentPrimitives(_a, _b) {
        return true;
    }
}


/***/ }),
/* 101 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GlRenderer", function() { return GlRenderer; });
/**
 * Base class for any WebGL renderer, it just defines basic structure of GL-calls allowing to override any part.
 * A specific renderer may need any number of additional arguments to perform rendering, they are provided in
 * additionalParams in the render() method.
 */
class GlRenderer {
    constructor(context, renderState, program) {
        this._context = context;
        this._renderState = renderState;
        this._program = program;
    }
    render(target, ...args) {
        if (this._program) {
            this._prepareProgram(this._program, ...args);
        }
        this._prepareRenderTarget(target, ...args);
        this._render(...args);
    }
    destroy() {
        if (this._program) {
            this._program.destroy();
        }
    }
    /**
     * Binds program and sets required uniforms. Subclasses are supposed to override
     * this method to add their own uniforms.
     */
    _prepareProgram(program, ..._args) {
        this._context.bindProgram(program);
    }
    /**
     * Binds render state and render target, no clear happens here, but this method
     * can be overridden in subclasses to add any setups they need.
     */
    _prepareRenderTarget(target, ..._args) {
        this._context.bindRenderState(this._renderState);
        this._context.bindRenderTarget(target);
    }
}


/***/ }),
/* 102 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchPrimitives", function() { return batchPrimitives; });
/* harmony import */ var _memory_relative_location__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(103);

/**
 * Creates batch from first primitives.
 */
function initBatch(primitive) {
    const subChunk = primitive.memorySubChunk;
    return {
        firstPrimitive: primitive,
        page: subChunk.memoryChunk.page,
        vertexByteOffset: subChunk.vertexByteOffset,
        vertexByteLength: subChunk.vertexByteLength,
        indexByteOffset: subChunk.indexByteOffset,
        indexByteLength: subChunk.indexByteLength
    };
}
/**
 * Batches primitives that can be rendered by a single draw call, that is critical for performance.
 * Performance gain from this method is possible (while it is not strictly required) if primitives
 * are sorted by memory offset and there are no many "holes" between them.
 * Minimal requiremets for batching is location in the same buffer (memory page), additional
 * requirements (such as having shared texture or similar) can be imposed in canBatchPridicate.
 */
function batchPrimitives(primitives, canBatchPridicate) {
    const canBatch = (a, b) => {
        if (
        // minimal requirements for batching is that primitives lay in the same page
        (a.memorySubChunk.memoryChunk.page !== b.memorySubChunk.memoryChunk.page) ||
            // chack external requirements if specified
            (canBatchPridicate && !canBatchPridicate(a, b))) {
            return false;
        }
        else {
            return true;
        }
    };
    return Object(_memory_relative_location__WEBPACK_IMPORTED_MODULE_0__["batchAllocatedObjects"])(primitives, (primitive) => primitive.memorySubChunk, initBatch, canBatch);
}


/***/ }),
/* 103 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "appendToBatch", function() { return appendToBatch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchAllocatedObjects", function() { return batchAllocatedObjects; });
/**
 * Appends portion of memory to batch if they are adjacent.
 *
 * @returns `true` if both params are adjacent and the batch was successfully updated, `false` otherwise.
 */
function appendToBatch(memoryLocation, batch) {
    if (batch.vertexByteOffset + batch.vertexByteLength === memoryLocation.vertexByteOffset &&
        batch.indexByteOffset + batch.indexByteLength === memoryLocation.indexByteOffset) {
        batch.vertexByteLength += memoryLocation.vertexByteLength;
        batch.indexByteLength += memoryLocation.indexByteLength;
        return true;
    }
    return false;
}
/**
 * Combines objects allocated in memory into batches. No sorting is done in this method, the objects are supposed
 * to be sorted by index/vertex offsets to make batching effective. The batch is created by factory since it can
 * contains problem specific information.
 *
 * @param objects List of allocated objects.
 * @param getMemoryLocation Returns memory location of specific object.
 * @param createBatch Initiates batch by the first object.
 * @param canBatch Checks if two objects can be allocated.
 * @returns Iterable list of batches.
 */
function* batchAllocatedObjects(objects, getMemoryLocation, createBatch, canBatch = () => true) {
    const iterator = objects[Symbol.iterator]();
    let primitive = iterator.next().value;
    if (!primitive) {
        return;
    }
    let prev = primitive;
    let batch = createBatch(prev);
    primitive = iterator.next().value;
    while (primitive) {
        const primitiveMemoryLocation = getMemoryLocation(primitive);
        if (!canBatch(prev, primitive, batch) || !appendToBatch(primitiveMemoryLocation, batch)) {
            yield batch;
            batch = createBatch(primitive);
        }
        prev = primitive;
        primitive = iterator.next().value;
    }
    yield batch;
}


/***/ }),
/* 104 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PROGRAM_OPTIONS", function() { return PROGRAM_OPTIONS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PointLabelRenderUnit; });
/* harmony import */ var _shader_point_label_vert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(105);
/* harmony import */ var _shader_point_label_vert__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_shader_point_label_vert__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _shader_df_text_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(106);
/* harmony import */ var _shader_df_text_frag__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_shader_df_text_frag__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _label_render_unit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(107);
/* harmony import */ var _billboard_rectangle_billboard_rectangle_render_unit__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(108);
/* harmony import */ var _util_event_emitter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(14);
/* harmony import */ var _util_iterable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(3);






const PROGRAM_OPTIONS = {
    attribMap: {
        vertexId: 2 /* ID */,
        vertexPosHigh: 0 /* POSITION_HIGH */,
        vertexPosLow: 1 /* POSITION_LOW */,
        vertexDisplacement: 6 /* DISPLACEMENT */,
        vertexUV: 4 /* UV */,
        vertexPriority: 9 /* PRIORITY */,
        vertexColor: 7 /* COLOR */,
        vertexOutlineColor: 8 /* OUTLINE_COLOR */,
        vertexScale: 11 /* AUX */
    }
};
/**
 * Renders backgrounds extracted from point labels.
 */
class BackgroundPrimitiveProvider {
    constructor(labelsProvider) {
        this.onUpdate = new _util_event_emitter__WEBPACK_IMPORTED_MODULE_4__["VoidEventEmitter"]();
        this._labelsProvider = labelsProvider;
    }
    get primitives() {
        return Object(_util_iterable__WEBPACK_IMPORTED_MODULE_5__["mapIterable"])(Object(_util_iterable__WEBPACK_IMPORTED_MODULE_5__["filterIterable"])(this._labelsProvider.primitives, (label) => label.background !== undefined), (label) => label.background);
    }
}
/**
 * Point labels renderer. It uses appropriate program to layout glyphs on GPU.
 */
class PointLabelRenderUnit extends _label_render_unit__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor(context, camera, visibilityProvider, primitiveProvider) {
        const program = context.createProgram(_shader_point_label_vert__WEBPACK_IMPORTED_MODULE_0___default.a, _shader_df_text_frag__WEBPACK_IMPORTED_MODULE_1___default.a, PROGRAM_OPTIONS);
        super(context, program, camera, visibilityProvider, primitiveProvider);
        this._backgroundRenderer = new _billboard_rectangle_billboard_rectangle_render_unit__WEBPACK_IMPORTED_MODULE_3__["default"](context, camera, visibilityProvider, new BackgroundPrimitiveProvider(primitiveProvider));
        this._backgroundRenderer.onUpdate.addListener(() => this.onUpdate.fire());
    }
    render(target, viewProjMatrix, cameraPositions) {
        this._backgroundRenderer.render(target, viewProjMatrix, cameraPositions);
        super.render(target, viewProjMatrix, cameraPositions);
    }
}


/***/ }),
/* 105 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec2 vertexId;\n\n// point in the world the label is anchored to\nattribute vec2 vertexPosHigh;\nattribute vec2 vertexPosLow;\n\n// vector of concrete glyph point displacement (top-left, bottom-left, ...) relative to label's center, in px\nattribute vec2 vertexDisplacement;\n\n// coordinates of the glyph vertex in the atlas\nattribute vec2 vertexUV;\n\nattribute float vertexPriority;\n\nattribute lowp vec4 vertexColor;\nattribute lowp vec4 vertexOutlineColor;\nattribute float vertexScale;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\nuniform vec2 pixelSize;\nuniform sampler2D visibility;\nuniform vec2 idHalfPxSize;\nuniform vec2 shift;\nuniform lowp float currentZoom;\n\nvarying vec2 uv;\nvarying lowp vec4 color;\nvarying lowp vec4 outlineColor;\nvarying mediump float scale;\n\nconst vec4 DISCARD_POSITION = vec4(2, 2, 2, 1);\n\nconst float YV_H_1_0 = 1.999969482421875;\nconst float YV_L_1_1 = 0.000030517112463712692;\n\n/**\n * Projects specific point label vertex onto the screen.\n */\nvec4 projectPointLabelVertex_1_2(\n    mat4 viewProjMatrix,\n    vec2 lookAtHigh,\n    vec2 lookAtLow,\n    vec2 posHigh,\n    vec2 posLow,\n    vec2 displacement,\n    vec2 pxSize\n) {\n    vec4 position = viewProjMatrix * vec4(\n        YV_H_1_0 * (posHigh - lookAtHigh) +\n            YV_L_1_1 * (posLow - lookAtLow),\n        0,\n        1\n    );\n    position = vec4(position.xy / position.w, 0.0, 1.0);\n\n    return position + vec4(displacement * pxSize, 0.0, 0.0);\n}\n\n\n\n\nvoid main(void) {\n    //float visibilityAlpha = texture2D(visibility, vertexId.xy + idHalfPxSize).a;\n    float visibilityAlpha = 1.0;\n    if (visibilityAlpha != 0.0) {\n        gl_Position = projectPointLabelVertex_1_2(\n            viewProjMatrix,\n            lookAtHigh,\n            lookAtLow,\n            vertexPosHigh,\n            vertexPosLow,\n            vertexDisplacement,\n            pixelSize\n        );\n\n        uv = vertexUV;\n        color = vertexColor;\n        outlineColor = vertexOutlineColor;\n        scale = vertexScale;\n\n        color.a *= visibilityAlpha;\n        outlineColor.a *= visibilityAlpha;\n    } else {\n        gl_Position = DISCARD_POSITION;\n    }\n}\n"

/***/ }),
/* 106 */
/***/ (function(module, exports) {

module.exports = "#version 100\n\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform float dpr;\nuniform sampler2D atlas;\nuniform vec2 atlasSize;\n\nvarying vec2 uv;\nvarying lowp vec4 color;\nvarying lowp vec4 outlineColor;\nvarying float scale;\n\nconst float MAX_CORRECTED_GLYPH_SCALE = 0.5;\nconst float GLYPH_BASE_WEIGHT = 0.7;\nconst float GLYPH_BASE_SMOTHNESS = 0.1;\nconst float GLYPH_WEIGHT_SCALE_IMPACT = 0.1;\nconst float GLYPH_SMOOTHNESS_SCALE_IMPACT = 0.06;\nconst float OUTLINE_WEIGHT_SCALE_IMPACT = 0.125;\n\nvoid main(void) {\n    // low scale glyphs (less than 0.5) should be a little bit bolder and smoother\n    float scaleClamped = clamp(scale, 0.0, MAX_CORRECTED_GLYPH_SCALE);\n    // weight is responsible for glyph boldness, the less weight value the bolder the text\n    float weight = GLYPH_BASE_WEIGHT + GLYPH_WEIGHT_SCALE_IMPACT * scaleClamped;\n    // smoothness is how blurred glyphs are, the less smoothness value the less blurring\n    float smoothness = (GLYPH_BASE_SMOTHNESS + GLYPH_SMOOTHNESS_SCALE_IMPACT / scaleClamped) / dpr;\n\n    vec4 resultColor = color;\n    float dist = texture2D(atlas, uv / atlasSize).a;\n    float alpha = smoothstep(weight - smoothness, weight + smoothness, dist);\n\n    if (outlineColor.a != 0.0) {\n        // to render outline the glyph is rendered a little bit bolder with different color at edges\n        weight = weight - OUTLINE_WEIGHT_SCALE_IMPACT / scale;\n        resultColor = mix(outlineColor, color, alpha);\n        alpha = smoothstep(weight - smoothness, weight + smoothness, dist);\n    }\n\n    gl_FragColor = vec4(resultColor.rgb, resultColor.a * alpha);\n}\n"

/***/ }),
/* 107 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LabelRenderUnit; });
/* harmony import */ var _world_primitive_render_unit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(100);
/* harmony import */ var _math_vector2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(23);
/* harmony import */ var _render_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(10);



/**
 * Base renderer that incapsulates all the GL specifics to make labels rendered.
 */
class LabelRenderUnit extends _world_primitive_render_unit__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(context, program, camera, visibilityProvider, primitiveProvider) {
        super(context, new _render_state__WEBPACK_IMPORTED_MODULE_2__["default"](_render_state__WEBPACK_IMPORTED_MODULE_2__["BLEND_OVER_RENDER_STATE"]), program, primitiveProvider);
        this._camera = camera;
        this._visibilityProvider = visibilityProvider;
        this._idHalfPxSizeUniform = _math_vector2__WEBPACK_IMPORTED_MODULE_1__["create"](0, 0);
        this._atlasSizeUniform = _math_vector2__WEBPACK_IMPORTED_MODULE_1__["create"](0, 0);
        context.bindProgram(program);
        program.setIntScalarUniform('visibility', 0);
    }
    _prepareProgram(program, viewProjMatrix, cameraPositions) {
        const visibility = this._visibilityProvider();
        super._prepareProgram(program, viewProjMatrix, cameraPositions);
        this._idHalfPxSizeUniform.x = 0.5 / visibility.getWidth();
        this._idHalfPxSizeUniform.y = 0.5 / visibility.getHeight();
        this._context.bindTextureUnit(0);
        this._context.bindTexture(visibility);
        program.setVector2Uniform('idHalfPxSize', this._idHalfPxSizeUniform);
        program.setVector2Uniform('pixelSize', this._camera.pixelSize);
        program.setScalarUniform('dpr', window.devicePixelRatio);
    }
    _renderBatch(memoryBatch) {
        const atlas = memoryBatch.firstPrimitive.atlas;
        this._atlasSizeUniform.x = atlas.width;
        this._atlasSizeUniform.y = atlas.height;
        this._program.setIntScalarUniform('atlas', 1);
        this._program.setVector2Uniform('atlasSize', this._atlasSizeUniform);
        this._context.bindTextureUnit(1);
        this._context.bindTexture(atlas.texture);
        super._renderBatch(memoryBatch);
    }
    _canBatchAdjacentPrimitives(a, b) {
        return super._canBatchAdjacentPrimitives(a, b) && (a.atlas === b.atlas);
    }
}


/***/ }),
/* 108 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BillboardRectangleRenderUnit; });
/* harmony import */ var _shader_billboard_rectangle_vert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(109);
/* harmony import */ var _shader_billboard_rectangle_vert__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_shader_billboard_rectangle_vert__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _shader_billboard_rectangle_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(110);
/* harmony import */ var _shader_billboard_rectangle_frag__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_shader_billboard_rectangle_frag__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _math_vector2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(23);
/* harmony import */ var _world_primitive_render_unit__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(100);
/* harmony import */ var _render_state__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(10);






const RENDER_STATE = new _render_state__WEBPACK_IMPORTED_MODULE_4__["default"](_render_state__WEBPACK_IMPORTED_MODULE_4__["BLEND_OVER_RENDER_STATE"]);
/**
 * Renderer of billboard rectangles.
 */
class BillboardRectangleRenderUnit extends _world_primitive_render_unit__WEBPACK_IMPORTED_MODULE_3__["default"] {
    constructor(context, camera, visibilityProvider, primitiveProvider) {
        const program = context.createProgram(_shader_billboard_rectangle_vert__WEBPACK_IMPORTED_MODULE_0___default.a, _shader_billboard_rectangle_frag__WEBPACK_IMPORTED_MODULE_1___default.a, {
            attribMap: {
                vertexId: 2 /* ID */,
                vertexPosHigh: 0 /* POSITION_HIGH */,
                vertexPosLow: 1 /* POSITION_LOW */,
                vertexDisplacement: 6 /* DISPLACEMENT */,
                vertexUV: 4 /* UV */,
                vertexColor: 7 /* COLOR */,
                vertexBorderRadii: 11 /* AUX */
            }
        });
        super(context, RENDER_STATE, program, primitiveProvider);
        this._visibilityProvider = visibilityProvider;
        this._camera = camera;
        this._visibilitySizeUniform = _math_vector2__WEBPACK_IMPORTED_MODULE_2__["create"](0, 0);
        context.bindProgram(program);
        program.setIntScalarUniform('visibility', 0);
    }
    _prepareProgram(program, viewProjMatrix, cameraPositions) {
        super._prepareProgram(program, viewProjMatrix, cameraPositions);
        const visibility = this._visibilityProvider();
        this._visibilitySizeUniform.x = visibility.getWidth();
        this._visibilitySizeUniform.y = visibility.getHeight();
        this._context.bindTextureUnit(0);
        this._context.bindTexture(visibility);
        program.setVector2Uniform('visibilitySize', this._visibilitySizeUniform);
        program.setVector2Uniform('pixelSize', this._camera.pixelSize);
    }
}


/***/ }),
/* 109 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec2 vertexId;\nattribute vec2 vertexPosHigh;\nattribute vec2 vertexPosLow;\nattribute vec2 vertexDisplacement;\nattribute vec2 vertexUV;\nattribute vec4 vertexColor;\nattribute vec2 vertexBorderRadii;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\nuniform vec2 pixelSize;\nuniform sampler2D visibility;\nuniform vec2 visibilitySize;\n\nvarying vec2 uv;\nvarying vec4 color;\nvarying vec2 borderRadii;\n\nconst vec4 DISCARD_POSITION = vec4(2, 2, 2, 1);\nconst float YV_H = 1.999969482421875;\nconst float YV_L = 0.000030517112463712692;\nvec2 VISIBILITY_HALF_PX = 0.5 / visibilitySize;\n\nvoid main(void) {\n    float visibilityAlpha = texture2D(visibility, vertexId.xy + VISIBILITY_HALF_PX).a;\n    if (visibilityAlpha == 0.0) {\n        gl_Position = DISCARD_POSITION;\n        return;\n    }\n\n    vec4 position = viewProjMatrix * vec4(\n        YV_H * (vertexPosHigh - lookAtHigh) +\n            YV_L * (vertexPosLow - lookAtLow),\n        0,\n        1\n    );\n    position.xyz /= position.w;\n    position.w = 1.0;\n\n    gl_Position = position + vec4(vertexDisplacement * pixelSize, 0.0, 0.0);\n\n    uv = vertexUV;\n    color = vertexColor;\n    color.a *= visibilityAlpha;\n    borderRadii = vertexBorderRadii;\n}\n"

/***/ }),
/* 110 */
/***/ (function(module, exports) {

module.exports = "#version 100\n\nprecision mediump float;\n#define GLSLIFY 1\n\nvarying vec2 uv;\nvarying vec4 color;\nvarying vec2 borderRadii;\n\nfloat roundedRectangle(const in vec2 uv, const in vec2 radii) {\n    vec2 absUv = abs(uv);\n    vec2 q = absUv + radii - 1.0;\n    return min(q.x, q.y) > 0.0 ? length(q / radii) : max(absUv.x, absUv.y);\n}\n\nvoid main(void) {\n    gl_FragColor = step(roundedRectangle(uv, borderRadii), 1.0) * color;\n}\n"

/***/ }),
/* 111 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ColorIdCurvedLabelRenderer; });
/* harmony import */ var _shader_curved_label_vert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(112);
/* harmony import */ var _shader_curved_label_vert__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_shader_curved_label_vert__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _shader_color_id_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(97);
/* harmony import */ var _shader_color_id_frag__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_shader_color_id_frag__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _render_primitives_label_curved_label_render_unit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(113);
/* harmony import */ var _color_id_label_renderer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(98);




/**
 * Curved labels renderer for collision resolution.
 */
class ColorIdCurvedLabelRenderer extends _color_id_label_renderer__WEBPACK_IMPORTED_MODULE_3__["default"] {
    constructor(context, camera, primitiveProvider) {
        const program = context.createProgram(_shader_curved_label_vert__WEBPACK_IMPORTED_MODULE_0___default.a, _shader_color_id_frag__WEBPACK_IMPORTED_MODULE_1___default.a, _render_primitives_label_curved_label_render_unit__WEBPACK_IMPORTED_MODULE_2__["PROGRAM_OPTIONS"]);
        super(context, program, primitiveProvider, camera);
    }
}


/***/ }),
/* 112 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec2 vertexId;\n\n// point in the world the label is anchored to\nattribute vec2 vertexPosHigh;\nattribute vec2 vertexPosLow;\n\n// vector of concrete glyph point displacement (top-left, bottom-left, ...) relative to glyph's center (two values),\n// and distance of the glyph center to label's center (third value), in px\nattribute vec3 vertexDisplacements;\n\n// coordinates of the glyph vertex in the atlas\nattribute vec2 vertexUV;\n\nattribute float vertexPriority;\n\nattribute lowp vec4 vertexColor;\nattribute lowp vec4 vertexOutlineColor;\nattribute vec2 polylineLength_vertexScale;\n\n// deltas relative to the world point encoded in vertexPosHigh/vertexPosLow encoded via lengths and and angles of\n// corresponding vectors\nattribute vec4 leftPolylineRatios;\nattribute vec4 leftPolylineAngles;\nattribute vec4 rightPolylineRatios;\nattribute vec4 rightPolylineAngles;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\nuniform vec2 pixelSize;\nuniform sampler2D visibility;\nuniform vec2 idHalfPxSize;\nuniform vec2 shift;\nuniform lowp float currentZoom;\n\nvarying vec2 uv;\nvarying lowp vec4 color;\nvarying lowp vec4 outlineColor;\nvarying float scale;\n\nconst vec4 DISCARD_POSITION = vec4(2, 2, 2, 1);\n\nconst float YV_H_1_0 = 1.999969482421875;\nconst float YV_L_1_1 = 0.000030517112463712692;\n\nconst float PI_1_2 = 3.1415927410125732;\n\nconst int MAX_POLYLINE_POINTS_1_3 = 4;\nconst float INFINITY_1_4 = 1000000.0; // large enough for a segment length to consider it infinity\n\n/**\n * Returns world coordinate (plus delta) projected on screen, in pixels.\n */\nvec2 project_1_5(\n    mat4 viewProjMatrix,\n    vec2 lookAtHigh,\n    vec2 lookAtLow,\n    vec2 pixelSize,\n    vec2 pointHigh,\n    vec2 pointLow,\n    vec2 delta\n) {\n    vec4 position = viewProjMatrix * vec4(\n            YV_H_1_0 * (pointHigh - lookAtHigh) + YV_L_1_1 * (pointLow - lookAtLow) + delta,\n            0,\n            1\n        );\n    vec2 projected = position.xy / position.w;\n    return projected / pixelSize;\n}\n\n/**\n * Each point of the polyline is encoded as a vector from the polyline center by its normalized angle and the ratio of\n * its length to the polyline's length.\n */\nvec2 decodePolylineDeltas_1_6(float ratio, float angle, float polylineLength) {\n    // denormalize angle back to radians\n    float a = angle * 2.0 * PI_1_2 - PI_1_2;\n    // length of a vector\n    float len = ratio * polylineLength;\n    // restored point's (x, y) coordinates\n    return vec2(cos(a), sin(a)) * len;\n}\n\n/**\n * Projects specific curved label vertex onto the screen. The label is layouted by centering polyline in\n * the vertexPosHigh/vertexPosLow and other points are used to guide concrete gryph vertex.\n * Number of polyline points is hardcoded to pass them in attributes.\n */\nvec4 projectCurvedLabelVertex_1_7(\n    mat4 viewProjMatrix,\n    vec2 lookAtHigh,\n    vec2 lookAtLow,\n    vec2 pxSize,\n    vec2 posHigh,\n    vec2 posLow,\n    vec2 displacement,\n    float lineDisplacement,\n    float polylineLength,\n    vec4 leftPolylineRatios,\n    vec4 leftPolylineAngles,\n    vec4 rightPolylineRatios,\n    vec4 rightPolylineAngles\n) {\n    vec2 polylineDeltas[MAX_POLYLINE_POINTS_1_3];\n    vec2 position = project_1_5(viewProjMatrix, lookAtHigh, lookAtLow, pxSize, posHigh, posLow, vec2(0, 0));\n    float remainingLength = abs(lineDisplacement);\n    for (int i = 0; i < MAX_POLYLINE_POINTS_1_3; i++) {\n        vec2 projectedPoint;\n\n        // figure out the direction (left/right) at the first step\n        if (i == 0) {\n            projectedPoint = project_1_5(\n                viewProjMatrix,\n                lookAtHigh,\n                lookAtLow,\n                pxSize,\n                posHigh,\n                posLow,\n                decodePolylineDeltas_1_6(rightPolylineRatios[0], rightPolylineAngles[0], polylineLength)\n            );\n            bool isRightPart = lineDisplacement > 0.0;\n            bool isInverted = projectedPoint.x < position.x;\n\n            // the map could be rotated and curved label should change its direction if they got upside down\n            // using center segment to identify this case is an approximation (ideally we should check all segments)\n            if (isRightPart ^^ isInverted) {\n                polylineDeltas[0] = decodePolylineDeltas_1_6(rightPolylineRatios[0], rightPolylineAngles[0], polylineLength);\n                polylineDeltas[1] = decodePolylineDeltas_1_6(rightPolylineRatios[1], rightPolylineAngles[1], polylineLength);\n                polylineDeltas[2] = decodePolylineDeltas_1_6(rightPolylineRatios[2], rightPolylineAngles[2], polylineLength);\n                polylineDeltas[3] = decodePolylineDeltas_1_6(rightPolylineRatios[3], rightPolylineAngles[3], polylineLength);\n            } else {\n                polylineDeltas[0] = decodePolylineDeltas_1_6(leftPolylineRatios[0], leftPolylineAngles[0], polylineLength);\n                polylineDeltas[1] = decodePolylineDeltas_1_6(leftPolylineRatios[1], leftPolylineAngles[1], polylineLength);\n                polylineDeltas[2] = decodePolylineDeltas_1_6(leftPolylineRatios[2], leftPolylineAngles[2], polylineLength);\n                polylineDeltas[3] = decodePolylineDeltas_1_6(leftPolylineRatios[3], leftPolylineAngles[3], polylineLength);\n            }\n\n            // the first right point of the segment already calculated,\n            // recalculate the point if this part of the label goes other direction\n            if (!(isRightPart && !isInverted) && !(!isRightPart && isInverted)) {\n                projectedPoint = project_1_5(viewProjMatrix, lookAtHigh, lookAtLow, pxSize, posHigh, posLow, polylineDeltas[i]);\n            }\n        } else {\n            projectedPoint = project_1_5(viewProjMatrix, lookAtHigh, lookAtLow, pxSize, posHigh, posLow, polylineDeltas[i]);\n        }\n\n        vec2 segment = projectedPoint - position;\n        bool isLast = i == (MAX_POLYLINE_POINTS_1_3 - 1);\n        float segmentLength = (isLast || (polylineDeltas[i + 1] == vec2(0, 0))) ? INFINITY_1_4 : length(segment);\n\n        if (segmentLength > remainingLength) {\n            float signFactor = lineDisplacement > 0.0 ? 1.0 : -1.0;\n            vec2 direction = normalize(segment);\n            vec2 normal = vec2(-direction.y, direction.x);\n\n            position += direction * remainingLength;\n            position += signFactor * direction * displacement.x;\n            position += signFactor * normal * displacement.y;\n\n            break;\n        } else {\n            remainingLength -= segmentLength;\n            position += segment;\n        }\n    }\n\n    return vec4(position * pxSize, 0.0, 1.0);\n}\n\n\n\n\n\n/**\n * Curved labels are layouted here: the label is centered in the vertexPosHigh/vertexPosLow and polyline points\n * are used to guide concrete gryph vertex. Number of polyline points is hardcoded to pass them in attributes.\n */\nvoid main(void) {\n    vec2 idTexCoordinate = vertexId.xy + idHalfPxSize;\n    float overlapZoom = texture2D(visibility, idTexCoordinate).b;\n\n    if (currentZoom < overlapZoom) {\n        gl_Position = DISCARD_POSITION;\n    } else {\n        vec2 vertexDisplacement = vertexDisplacements.xy;\n        float vertexLineDisplacement = vertexDisplacements.z;\n        float polylineLength = polylineLength_vertexScale[0];\n        gl_Position = projectCurvedLabelVertex_1_7(\n            viewProjMatrix,\n            lookAtHigh,\n            lookAtLow,\n            pixelSize,\n            vertexPosHigh,\n            vertexPosLow,\n            vertexDisplacement,\n            vertexLineDisplacement,\n            polylineLength,\n            leftPolylineRatios,\n            leftPolylineAngles,\n            rightPolylineRatios,\n            rightPolylineAngles\n        );\n\n        gl_Position.xy += shift;\n        gl_Position.z = vertexPriority;\n\n        color = vec4(vertexId, 0, 1);\n    }\n}\n"

/***/ }),
/* 113 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PROGRAM_OPTIONS", function() { return PROGRAM_OPTIONS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CurvedLabelRenderUnit; });
/* harmony import */ var _shader_curved_label_vert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(114);
/* harmony import */ var _shader_curved_label_vert__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_shader_curved_label_vert__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _shader_df_text_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(106);
/* harmony import */ var _shader_df_text_frag__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_shader_df_text_frag__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _label_render_unit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(107);



const PROGRAM_OPTIONS = {
    attribMap: {
        vertexId: 2 /* ID */,
        vertexPosHigh: 0 /* POSITION_HIGH */,
        vertexPosLow: 1 /* POSITION_LOW */,
        vertexDisplacements: 6 /* DISPLACEMENT */,
        vertexUV: 4 /* UV */,
        vertexColor: 7 /* COLOR */,
        vertexOutlineColor: 8 /* OUTLINE_COLOR */,
        vertexPriority: 9 /* PRIORITY */,
        leftPolylineRatios: 12 /* AUX1 */,
        leftPolylineAngles: 13 /* AUX2 */,
        rightPolylineRatios: 14 /* AUX3 */,
        rightPolylineAngles: 15 /* AUX4 */,
        polylineLength_vertexScale: 11 /* AUX */
    }
};
/**
 * Curved labels renderer. It uses appropriate program to layout glyphs on GPU.
 */
class CurvedLabelRenderUnit extends _label_render_unit__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor(context, camera, visibilityProvider, primitiveProvider) {
        const program = context.createProgram(_shader_curved_label_vert__WEBPACK_IMPORTED_MODULE_0___default.a, _shader_df_text_frag__WEBPACK_IMPORTED_MODULE_1___default.a, PROGRAM_OPTIONS);
        super(context, program, camera, visibilityProvider, primitiveProvider);
    }
}


/***/ }),
/* 114 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec2 vertexId;\n\n// point in the world the label is anchored to\nattribute vec2 vertexPosHigh;\nattribute vec2 vertexPosLow;\n\n// vector of concrete glyph point displacement (top-left, bottom-left, ...) relative to glyph's center (two values),\n// and distance of the glyph center to label's center (third value), in px\nattribute vec3 vertexDisplacements;\n\n// coordinates of the glyph vertex in the atlas\nattribute vec2 vertexUV;\n\nattribute float vertexPriority;\n\nattribute lowp vec4 vertexColor;\nattribute lowp vec4 vertexOutlineColor;\nattribute vec2 polylineLength_vertexScale;\n\n// deltas relative to the world point encoded in vertexPosHigh/vertexPosLow encoded via lengths and and angles of\n// corresponding vectors\nattribute vec4 leftPolylineRatios;\nattribute vec4 leftPolylineAngles;\nattribute vec4 rightPolylineRatios;\nattribute vec4 rightPolylineAngles;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\nuniform vec2 pixelSize;\nuniform sampler2D visibility;\nuniform vec2 idHalfPxSize;\nuniform vec2 shift;\nuniform lowp float currentZoom;\n\nvarying vec2 uv;\nvarying lowp vec4 color;\nvarying lowp vec4 outlineColor;\nvarying float scale;\n\nconst vec4 DISCARD_POSITION = vec4(2, 2, 2, 1);\n\nconst float YV_H_1_0 = 1.999969482421875;\nconst float YV_L_1_1 = 0.000030517112463712692;\n\nconst float PI_1_2 = 3.1415927410125732;\n\nconst int MAX_POLYLINE_POINTS_1_3 = 4;\nconst float INFINITY_1_4 = 1000000.0; // large enough for a segment length to consider it infinity\n\n/**\n * Returns world coordinate (plus delta) projected on screen, in pixels.\n */\nvec2 project_1_5(\n    mat4 viewProjMatrix,\n    vec2 lookAtHigh,\n    vec2 lookAtLow,\n    vec2 pixelSize,\n    vec2 pointHigh,\n    vec2 pointLow,\n    vec2 delta\n) {\n    vec4 position = viewProjMatrix * vec4(\n            YV_H_1_0 * (pointHigh - lookAtHigh) + YV_L_1_1 * (pointLow - lookAtLow) + delta,\n            0,\n            1\n        );\n    vec2 projected = position.xy / position.w;\n    return projected / pixelSize;\n}\n\n/**\n * Each point of the polyline is encoded as a vector from the polyline center by its normalized angle and the ratio of\n * its length to the polyline's length.\n */\nvec2 decodePolylineDeltas_1_6(float ratio, float angle, float polylineLength) {\n    // denormalize angle back to radians\n    float a = angle * 2.0 * PI_1_2 - PI_1_2;\n    // length of a vector\n    float len = ratio * polylineLength;\n    // restored point's (x, y) coordinates\n    return vec2(cos(a), sin(a)) * len;\n}\n\n/**\n * Projects specific curved label vertex onto the screen. The label is layouted by centering polyline in\n * the vertexPosHigh/vertexPosLow and other points are used to guide concrete gryph vertex.\n * Number of polyline points is hardcoded to pass them in attributes.\n */\nvec4 projectCurvedLabelVertex_1_7(\n    mat4 viewProjMatrix,\n    vec2 lookAtHigh,\n    vec2 lookAtLow,\n    vec2 pxSize,\n    vec2 posHigh,\n    vec2 posLow,\n    vec2 displacement,\n    float lineDisplacement,\n    float polylineLength,\n    vec4 leftPolylineRatios,\n    vec4 leftPolylineAngles,\n    vec4 rightPolylineRatios,\n    vec4 rightPolylineAngles\n) {\n    vec2 polylineDeltas[MAX_POLYLINE_POINTS_1_3];\n    vec2 position = project_1_5(viewProjMatrix, lookAtHigh, lookAtLow, pxSize, posHigh, posLow, vec2(0, 0));\n    float remainingLength = abs(lineDisplacement);\n    for (int i = 0; i < MAX_POLYLINE_POINTS_1_3; i++) {\n        vec2 projectedPoint;\n\n        // figure out the direction (left/right) at the first step\n        if (i == 0) {\n            projectedPoint = project_1_5(\n                viewProjMatrix,\n                lookAtHigh,\n                lookAtLow,\n                pxSize,\n                posHigh,\n                posLow,\n                decodePolylineDeltas_1_6(rightPolylineRatios[0], rightPolylineAngles[0], polylineLength)\n            );\n            bool isRightPart = lineDisplacement > 0.0;\n            bool isInverted = projectedPoint.x < position.x;\n\n            // the map could be rotated and curved label should change its direction if they got upside down\n            // using center segment to identify this case is an approximation (ideally we should check all segments)\n            if (isRightPart ^^ isInverted) {\n                polylineDeltas[0] = decodePolylineDeltas_1_6(rightPolylineRatios[0], rightPolylineAngles[0], polylineLength);\n                polylineDeltas[1] = decodePolylineDeltas_1_6(rightPolylineRatios[1], rightPolylineAngles[1], polylineLength);\n                polylineDeltas[2] = decodePolylineDeltas_1_6(rightPolylineRatios[2], rightPolylineAngles[2], polylineLength);\n                polylineDeltas[3] = decodePolylineDeltas_1_6(rightPolylineRatios[3], rightPolylineAngles[3], polylineLength);\n            } else {\n                polylineDeltas[0] = decodePolylineDeltas_1_6(leftPolylineRatios[0], leftPolylineAngles[0], polylineLength);\n                polylineDeltas[1] = decodePolylineDeltas_1_6(leftPolylineRatios[1], leftPolylineAngles[1], polylineLength);\n                polylineDeltas[2] = decodePolylineDeltas_1_6(leftPolylineRatios[2], leftPolylineAngles[2], polylineLength);\n                polylineDeltas[3] = decodePolylineDeltas_1_6(leftPolylineRatios[3], leftPolylineAngles[3], polylineLength);\n            }\n\n            // the first right point of the segment already calculated,\n            // recalculate the point if this part of the label goes other direction\n            if (!(isRightPart && !isInverted) && !(!isRightPart && isInverted)) {\n                projectedPoint = project_1_5(viewProjMatrix, lookAtHigh, lookAtLow, pxSize, posHigh, posLow, polylineDeltas[i]);\n            }\n        } else {\n            projectedPoint = project_1_5(viewProjMatrix, lookAtHigh, lookAtLow, pxSize, posHigh, posLow, polylineDeltas[i]);\n        }\n\n        vec2 segment = projectedPoint - position;\n        bool isLast = i == (MAX_POLYLINE_POINTS_1_3 - 1);\n        float segmentLength = (isLast || (polylineDeltas[i + 1] == vec2(0, 0))) ? INFINITY_1_4 : length(segment);\n\n        if (segmentLength > remainingLength) {\n            float signFactor = lineDisplacement > 0.0 ? 1.0 : -1.0;\n            vec2 direction = normalize(segment);\n            vec2 normal = vec2(-direction.y, direction.x);\n\n            position += direction * remainingLength;\n            position += signFactor * direction * displacement.x;\n            position += signFactor * normal * displacement.y;\n\n            break;\n        } else {\n            remainingLength -= segmentLength;\n            position += segment;\n        }\n    }\n\n    return vec4(position * pxSize, 0.0, 1.0);\n}\n\n\n\n\nvoid main(void) {\n    //float visibilityAlpha = texture2D(visibility, vertexId.xy + idHalfPxSize).a;\n    float visibilityAlpha = 1.0;\n    if (visibilityAlpha != 0.0) {\n        vec2 vertexDisplacement = vertexDisplacements.xy;\n        float vertexLineDisplacement = vertexDisplacements.z;\n        float polylineLength = polylineLength_vertexScale[0];\n        float vertexScale = polylineLength_vertexScale[1];\n        gl_Position = projectCurvedLabelVertex_1_7(\n            viewProjMatrix,\n            lookAtHigh,\n            lookAtLow,\n            pixelSize,\n            vertexPosHigh,\n            vertexPosLow,\n            vertexDisplacement,\n            vertexLineDisplacement,\n            polylineLength,\n            leftPolylineRatios,\n            leftPolylineAngles,\n            rightPolylineRatios,\n            rightPolylineAngles\n        );\n\n        uv = vertexUV;\n        color = vertexColor;\n        outlineColor = vertexOutlineColor;\n        scale = vertexScale;\n\n        color.a *= visibilityAlpha;\n        outlineColor.a *= visibilityAlpha;\n    } else {\n        gl_Position = DISCARD_POSITION;\n    }\n}\n"

/***/ }),
/* 115 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return IconRenderUnit; });
/* harmony import */ var _shader_icon_vert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(116);
/* harmony import */ var _shader_icon_vert__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_shader_icon_vert__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _shader_icon_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(117);
/* harmony import */ var _shader_icon_frag__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_shader_icon_frag__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _image_image_render_unit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(118);



/**
 * Renderer of icon primitives.
 */
class IconRenderUnit extends _image_image_render_unit__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor(context, camera, primitiveProvider) {
        const program = context.createProgram(_shader_icon_vert__WEBPACK_IMPORTED_MODULE_0___default.a, _shader_icon_frag__WEBPACK_IMPORTED_MODULE_1___default.a, {
            attribMap: {
                vertexPosHigh: 0 /* POSITION_HIGH */,
                vertexPosLow: 1 /* POSITION_LOW */,
                vertexDisplacement: 6 /* DISPLACEMENT */,
                vertexUV: 4 /* UV */
            }
        });
        super(context, primitiveProvider, program);
        this._camera = camera;
    }
    _prepareProgram(program, viewProjMatrix, cameraPositions) {
        super._prepareProgram(program, viewProjMatrix, cameraPositions);
        program.setVector2Uniform('pixelSize', this._camera.pixelSize);
    }
}


/***/ }),
/* 116 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec2 vertexPosHigh;\nattribute vec2 vertexPosLow;\nattribute vec2 vertexDisplacement;\nattribute vec2 vertexUV;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\nuniform vec2 pixelSize;\n\nvarying vec2 uv;\n\nconst float YV_H = 1.999969482421875;\nconst float YV_L = 0.000030517112463712692;\n\nvoid main() {\n    vec4 position = viewProjMatrix * vec4(\n        YV_H * (vertexPosHigh - lookAtHigh) +\n            YV_L * (vertexPosLow - lookAtLow),\n        0,\n        1\n    );\n    position = vec4(position.xy / position.w, 0.0, 1.0);\n\n    gl_Position = position + vec4(vertexDisplacement * pixelSize, 0.0, 0.0);\n\n    uv = vertexUV;\n}\n"

/***/ }),
/* 117 */
/***/ (function(module, exports) {

module.exports = "#version 100\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform sampler2D atlas;\nuniform vec2 atlasSize;\n\nvarying vec2 uv;\n\nvoid main() {\n    gl_FragColor = texture2D(atlas, uv / atlasSize);\n}\n"

/***/ }),
/* 118 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ImageRenderUnit; });
/* harmony import */ var _shader_image_vert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(119);
/* harmony import */ var _shader_image_vert__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_shader_image_vert__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _shader_image_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(120);
/* harmony import */ var _shader_image_frag__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_shader_image_frag__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _math_vector2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(23);
/* harmony import */ var _world_primitive_render_unit__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(100);
/* harmony import */ var _render_state__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(10);






const RENDER_STATE = new _render_state__WEBPACK_IMPORTED_MODULE_4__["default"](_render_state__WEBPACK_IMPORTED_MODULE_4__["BLEND_OVER_RENDER_STATE"]);
function createDefaultProgram(context) {
    return context.createProgram(_shader_image_vert__WEBPACK_IMPORTED_MODULE_0___default.a, _shader_image_frag__WEBPACK_IMPORTED_MODULE_1___default.a, {
        attribMap: {
            vertexPosHigh: 0 /* POSITION_HIGH */,
            vertexPosLow: 1 /* POSITION_LOW */,
            vertexUV: 4 /* UV */
        }
    });
}
/**
 * Renderer of image primitives.
 */
class ImageRenderUnit extends _world_primitive_render_unit__WEBPACK_IMPORTED_MODULE_3__["default"] {
    constructor(context, primitiveProvider, program = createDefaultProgram(context)) {
        super(context, RENDER_STATE, program, primitiveProvider);
        this._atlasSizeUniform = _math_vector2__WEBPACK_IMPORTED_MODULE_2__["create"](0, 0);
        context.bindProgram(program);
        program.setIntScalarUniform('atlas', 0);
    }
    _renderBatch(memoryBatch) {
        const atlas = memoryBatch.firstPrimitive.atlas;
        this._atlasSizeUniform.x = atlas.width;
        this._atlasSizeUniform.y = atlas.height;
        if (atlas.isDirty) {
            atlas.syncTexture();
        }
        this._program.setVector2Uniform('atlasSize', this._atlasSizeUniform);
        this._context.bindTextureUnit(0);
        this._context.bindTexture(atlas.texture);
        super._renderBatch(memoryBatch);
    }
    _canBatchAdjacentPrimitives(a, b) {
        return super._canBatchAdjacentPrimitives(a, b) && (a.atlas === b.atlas);
    }
}


/***/ }),
/* 119 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec2 vertexPosHigh;\nattribute vec2 vertexPosLow;\nattribute vec2 vertexUV;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\n\nvarying vec2 uv;\n\nconst float YV_H = 1.999969482421875;\nconst float YV_L = 0.000030517112463712692;\n\nvoid main() {\n    vec4 position = viewProjMatrix * vec4(\n        YV_H * (vertexPosHigh - lookAtHigh) +\n            YV_L * (vertexPosLow - lookAtLow),\n        0,\n        1\n    );\n\n    gl_Position = position;\n\n    uv = vertexUV;\n}\n"

/***/ }),
/* 120 */
/***/ (function(module, exports) {

module.exports = "#version 100\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform sampler2D atlas;\nuniform vec2 atlasSize;\n\nvarying vec2 uv;\n\nvoid main() {\n    gl_FragColor = texture2D(atlas, uv / atlasSize);\n\n    if (gl_FragColor.a == 0.0) {\n        discard;\n    }\n}\n"

/***/ }),
/* 121 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ModelRenderUnit; });
/* harmony import */ var _shader_model_vert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(122);
/* harmony import */ var _shader_model_vert__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_shader_model_vert__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _shader_model_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(123);
/* harmony import */ var _shader_model_frag__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_shader_model_frag__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _math_vector2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(23);
/* harmony import */ var _overlay_overlay_renderer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(124);
/* harmony import */ var _render_state__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(10);
/* harmony import */ var _world_primitive_render_unit__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(100);






const RENDER_STATE = new _render_state__WEBPACK_IMPORTED_MODULE_4__["default"]({
    depthTest: true
});
/**
 * Renderer of models. It renders models into a texture with depth test and then this texture into the render target.
 * It allows to show only the top facets of semi-transparent objects without exposing their inner structure.
 */
class ModelRenderUnit extends _world_primitive_render_unit__WEBPACK_IMPORTED_MODULE_5__["default"] {
    constructor(context, primitiveProvider) {
        const program = context.createProgram(_shader_model_vert__WEBPACK_IMPORTED_MODULE_0___default.a, _shader_model_frag__WEBPACK_IMPORTED_MODULE_1___default.a, {
            attribMap: {
                vertexPosHigh: 0 /* POSITION_HIGH */,
                vertexPosLow: 1 /* POSITION_LOW */,
                vertexHeight: 3 /* HEIGHT */,
                vertexColor: 7 /* COLOR */
            }
        });
        super(context, RENDER_STATE, program, primitiveProvider);
        this._outputSize = Object(_math_vector2__WEBPACK_IMPORTED_MODULE_2__["createExtent2"])(-1, -1);
        this._overlayRenderer = new _overlay_overlay_renderer__WEBPACK_IMPORTED_MODULE_3__["default"](context);
    }
    render(target, viewProjMatrix, cameraPositions) {
        this._syncOutputBuffer(target);
        super.render(this._outputBuffer, viewProjMatrix, cameraPositions);
        // do not run unnecessary copying if this._outputBuffer was not updated (no models in scene?)
        if (!this._outputBuffer.isClear) {
            // copy into the final target
            this._overlayRenderer.render(target, this._outputTexture);
        }
    }
    destroy() {
        this._overlayRenderer.destroy();
        if (this._outputTexture) {
            this._outputTexture.destroy();
        }
        if (this._outputDepthBuffer) {
            this._outputDepthBuffer.destroy();
        }
        if (this._outputBuffer) {
            this._outputBuffer.destroy();
        }
        super.destroy();
    }
    _syncOutputBuffer(target) {
        // make sure the intermediate texture fits the output target
        if (this._outputSize.width !== target.getWidth() ||
            this._outputSize.height !== target.getHeight()) {
            if (this._outputTexture || this._outputDepthBuffer || this._outputBuffer) {
                this._outputTexture.destroy();
                this._outputDepthBuffer.destroy();
                this._outputBuffer.destroy();
            }
            this._outputSize = { width: target.getWidth(), height: target.getHeight() };
            this._outputTexture = this._context.createEmpty2DTexture(this._outputSize.width, this._outputSize.height, 6408 /* RGBA */, 5121 /* UNSIGNED_BYTE */);
            this._outputDepthBuffer = this._context.createRenderbuffer(this._outputSize.width, this._outputSize.height, 34041 /* DEPTH_STENCIL */);
            this._outputBuffer = this._context.createFramebuffer({
                color: this._outputTexture,
                depthStencil: this._outputDepthBuffer
            });
        }
    }
    /**
     * Overridden _bindRenderTarget() to bind intermediate render target to render models into and
     * later put its content into the final target.
     */
    _prepareRenderTarget(target, viewProjMatrix, cameraPositions) {
        super._prepareRenderTarget(target, viewProjMatrix, cameraPositions);
        this._context.clearCurrentTarget(16384 /* COLOR_BUFFER_BIT */ | 256 /* DEPTH_BUFFER_BIT */);
    }
}


/***/ }),
/* 122 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec3 vertexPosHigh;\nattribute vec3 vertexPosLow;\nattribute float vertexHeight;\nattribute vec4 vertexColor;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\n\nvarying vec4 globalPos;\nvarying vec4 diffuseColor;\n\nconst float YV_H = 1.999969482421875;\nconst float YV_L = 0.000030517112463712692;\n\nvoid main(void) {\n    globalPos = vec4(\n        YV_H * (vertexPosHigh.xy - lookAtHigh) + YV_L * (vertexPosLow.xy - lookAtLow),\n        vertexHeight,\n        1\n    );\n\n    gl_Position = viewProjMatrix * globalPos;\n    diffuseColor = vertexColor;\n}\n"

/***/ }),
/* 123 */
/***/ (function(module, exports) {

module.exports = "#version 100\n\n#extension GL_OES_standard_derivatives : require\n\nprecision mediump float;\n#define GLSLIFY 1\n\nvarying vec4 diffuseColor;\nvarying vec4 globalPos;\n\nconst vec3 LIGHT_DIRECTION = normalize(vec3(0.5, 0.5, 1.0));\nconst float LIGHT_INTENSITY = 0.3;\nconst float AMBIENT_LIGHT_INTENSITY = 1.0 - LIGHT_INTENSITY;\nconst float HORIZONTAL_PLANE_DIFFUSE_INTENSITY =\n    AMBIENT_LIGHT_INTENSITY + 0.5 * LIGHT_INTENSITY * (LIGHT_DIRECTION.z + 1.0);\n\nvoid main(void) {\n    vec3 pos = globalPos.xyz;\n\n    vec3 dxpos = normalize(dFdx(pos));\n    vec3 dypos = normalize(dFdy(pos));\n    vec3 normal = normalize(cross(dxpos, dypos));\n\n    gl_FragColor = vec4(\n        diffuseColor.rgb * (AMBIENT_LIGHT_INTENSITY + 0.5 * LIGHT_INTENSITY * (dot(normal, LIGHT_DIRECTION) + 1.0)) /\n            HORIZONTAL_PLANE_DIFFUSE_INTENSITY,\n        diffuseColor.a\n    );\n}\n"

/***/ }),
/* 124 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return OverlayRenderer; });
/* harmony import */ var _shader_overlay_vert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(125);
/* harmony import */ var _shader_overlay_vert__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_shader_overlay_vert__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _shader_overlay_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(126);
/* harmony import */ var _shader_overlay_frag__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_shader_overlay_frag__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _render_gl_renderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(101);
/* harmony import */ var _render_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(10);





const RENDER_STATE = new _render_state__WEBPACK_IMPORTED_MODULE_3__["default"](_render_state__WEBPACK_IMPORTED_MODULE_3__["BLEND_OVER_RENDER_STATE"]);
/**
 * Renders a texture into a render target with OVER compositing. The texture will completely overlay the target, i.e.
 * it is stretched/shrinked to fit the target width/height, so ideally they should have the same dimensions.
 */
class OverlayRenderer extends _render_gl_renderer__WEBPACK_IMPORTED_MODULE_2__["GlRenderer"] {
    constructor(context) {
        const program = context.createProgram(_shader_overlay_vert__WEBPACK_IMPORTED_MODULE_0___default.a, _shader_overlay_frag__WEBPACK_IMPORTED_MODULE_1___default.a, {
            attribMap: {
                vertexPosition: 0 /* POSITION */,
                vertexUV: 4 /* UV */
            }
        });
        super(context, RENDER_STATE, program);
    }
    _render(texture) {
        this._context.bindTextureUnit(0);
        this._context.bindTexture(texture);
        this._context.bindQuadVao();
        this._context.drawQuad();
    }
}


/***/ }),
/* 125 */
/***/ (function(module, exports) {

module.exports = "#version 100\nprecision mediump float;\n#define GLSLIFY 1\n\nattribute vec2 vertexPosition;\nattribute vec2 vertexUV;\n\nvarying vec2 uv;\n\nvoid main() {\n    gl_Position = vec4(vertexPosition, 0, 1);\n    uv = vertexUV;\n}\n"

/***/ }),
/* 126 */
/***/ (function(module, exports) {

module.exports = "#version 100\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform sampler2D texture;\n\nvarying vec2 uv;\n\nvoid main() {\n    gl_FragColor = texture2D(texture, uv);\n}\n"

/***/ }),
/* 127 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TexturedPolylineRenderUnit; });
/* harmony import */ var _shader_textured_polyline_vert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(128);
/* harmony import */ var _shader_textured_polyline_vert__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_shader_textured_polyline_vert__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _shader_textured_polyline_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(129);
/* harmony import */ var _shader_textured_polyline_frag__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_shader_textured_polyline_frag__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _math_vector2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(23);
/* harmony import */ var _render_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(10);
/* harmony import */ var _base_polyline_render_unit__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(130);





const FILTER_RADIUS = 1.0 / devicePixelRatio;
const RENDER_STATE = new _render_state__WEBPACK_IMPORTED_MODULE_3__["default"](_render_state__WEBPACK_IMPORTED_MODULE_3__["BLEND_OVER_PREMULTIPLIED_ALPHA_RENDER_STATE"], {
    depthTest: true,
    depthMask: false,
    depthFunc: 518 /* GREATER_OR_EQUAL */
});
/**
 * Renderer of polyline primitives.
 */
class TexturedPolylineRenderUnit extends _base_polyline_render_unit__WEBPACK_IMPORTED_MODULE_4__["default"] {
    constructor(context, camera, primitiveProvider) {
        const program = context.createProgram(_shader_textured_polyline_vert__WEBPACK_IMPORTED_MODULE_0___default.a, _shader_textured_polyline_frag__WEBPACK_IMPORTED_MODULE_1___default.a, {
            defines: {
                FILTER_RADIUS: `float(${FILTER_RADIUS})`
            },
            attribMap: {
                vertexPosHigh: 0 /* POSITION_HIGH */,
                vertexPosLow: 1 /* POSITION_LOW */,
                vertexDisplacement: 6 /* DISPLACEMENT */,
                vertexUV: 4 /* UV */,
                vertexZIndex: 9 /* PRIORITY */,
                vertexHalfWidth: 11 /* AUX */,
                vertexPattern: 12 /* AUX1 */,
                vertexPatternHalfHeight: 13 /* AUX2 */
            }
        });
        super(context, RENDER_STATE, program, primitiveProvider, camera);
        this._atlasSizeUniform = _math_vector2__WEBPACK_IMPORTED_MODULE_2__["create"](0, 0);
        context.bindProgram(program);
        program.setIntScalarUniform('atlas', 0);
    }
    _renderBatch(memoryBatch) {
        const atlas = memoryBatch.firstPrimitive.atlas;
        this._atlasSizeUniform.x = atlas.width;
        this._atlasSizeUniform.y = atlas.height;
        if (atlas.isDirty) {
            atlas.syncTexture();
        }
        this._program.setVector2Uniform('atlasSize', this._atlasSizeUniform);
        this._context.bindTextureUnit(0);
        this._context.bindTexture(atlas.texture);
        super._renderBatch(memoryBatch);
    }
    _canBatchAdjacentPrimitives(a, b) {
        return super._canBatchAdjacentPrimitives(a, b) && (a.atlas === b.atlas);
    }
}


/***/ }),
/* 128 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\n#ifndef FILTER_RADIUS\n#   error FILTER_RADIUS must be set\n#endif\n\nattribute vec2 vertexPosHigh;\nattribute vec2 vertexPosLow;\nattribute vec2 vertexDisplacement;\nattribute vec2 vertexUV;\nattribute float vertexHalfWidth;\nattribute vec2 vertexPattern;\nattribute float vertexPatternHalfHeight;\nattribute float vertexZIndex;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\nuniform float worldToPxFactor;\n\nvarying vec2 uv;\nvarying float s;\nvarying float patternLength;\nvarying float len;\nvarying float halfWidth;\nvarying float extHalfWidth;\nvarying float patternHalfHeight;\n\nconst float YV_H = 1.999969482421875;\nconst float YV_L = 0.000030517112463712692;\n\nvoid main(void) {\n    halfWidth = vertexHalfWidth;\n    extHalfWidth = halfWidth + FILTER_RADIUS;\n\n    vec4 position = viewProjMatrix * vec4(\n        YV_H * (vertexPosHigh - lookAtHigh) +\n            YV_L * (vertexPosLow - lookAtLow) +\n                worldToPxFactor * extHalfWidth * vertexDisplacement,\n        0,\n        1\n    );\n\n    position.xy /= position.w;\n    position.z = vertexZIndex;\n    position.w = 1.0;\n\n    gl_Position = position;\n\n    patternLength = vertexPattern[0];\n    len = vertexPattern[1];\n    // Distance to the analytical line along segment's normal\n    s = sign(vertexPatternHalfHeight) * extHalfWidth;\n    // The whole texture is being sampled to the original geometry. For pixels in the extended polyline part the topmost\n    // (bottommost) texels are taken. To make this happen the UV texture coordinates are extended in proportion to the\n    // polyline width extension.\n    patternHalfHeight = abs(vertexPatternHalfHeight);\n    uv = vec2(vertexUV.x, vertexUV.y - vertexPatternHalfHeight * FILTER_RADIUS / halfWidth);\n}\n"

/***/ }),
/* 129 */
/***/ (function(module, exports) {

module.exports = "#version 100\n\n#ifndef FILTER_RADIUS\n#   error FILTER_RADIUS must be set\n#endif\n\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform sampler2D atlas;\nuniform vec2 atlasSize;\n\nvarying vec2 uv;\nvarying float s;\nvarying float patternLength;\nvarying float len;\nvarying float halfWidth;\nvarying float extHalfWidth;\nvarying float patternHalfHeight;\n\nvoid main(void) {\n    lowp float alpha = smoothstep(0.0, FILTER_RADIUS + min(FILTER_RADIUS, extHalfWidth), extHalfWidth - abs(s));\n\n    // Clamp texture U coordinate by 0.5px from both sides to avoid bleeding.\n    vec2 uvAdjusted = vec2(uv.x + clamp(mod(len, patternLength), 0.5, patternLength - 0.5), uv.y);\n    // UV texture coordinates have been extended in proportion to the polyline width extension.\n    // Clamp texture V coordinate to the original geometry minus 0.5px to avoid bleeding.\n    float patternToGeometryFactor = halfWidth / patternHalfHeight;\n    float clampTo = halfWidth - 0.5 * patternToGeometryFactor;\n    if (step(clampTo, abs(s)) == 1.) {\n        float delta = s - clamp(s, -clampTo, clampTo);\n        uvAdjusted.y += delta / patternToGeometryFactor;\n    }\n\n    lowp vec4 color = texture2D(atlas, uvAdjusted / atlasSize);\n    gl_FragColor = color * alpha;\n}\n"

/***/ }),
/* 130 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BasePolylineRenderUnit; });
/* harmony import */ var _world_primitive_render_unit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(100);

/**
 * Base renderer of polyline primitives.
 */
class BasePolylineRenderUnit extends _world_primitive_render_unit__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(context, renderState, program, primitiveProvider, camera) {
        super(context, renderState, program, primitiveProvider);
        this._camera = camera;
    }
    _prepareProgram(program, viewProjMatrix, cameraPositions) {
        super._prepareProgram(program, viewProjMatrix, cameraPositions);
        program.setScalarUniform('worldToPxFactor', this._camera.worldToPxFactor);
    }
}


/***/ }),
/* 131 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_RENDER_STATE_PARAMS", function() { return DEFAULT_RENDER_STATE_PARAMS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PolylineRenderUnit; });
/* harmony import */ var _primitive_polyline_polyline_buffer_writer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(132);
/* harmony import */ var _shader_polyline_vert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(133);
/* harmony import */ var _shader_polyline_vert__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_shader_polyline_vert__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _shader_polyline_frag__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(134);
/* harmony import */ var _shader_polyline_frag__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_shader_polyline_frag__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _base_polyline_render_unit__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(130);
/* harmony import */ var _render_state__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(10);





// Values was chosen by team consensus in VECTOR-197
const FILTER_RADIUS = 1.0 / devicePixelRatio; // px
const DEFAULT_RENDER_STATE_PARAMS = {
    blend: true,
    blendFuncSrcRgb: 1 /* ONE */,
    blendFuncDstRgb: 771 /* ONE_MINUS_SRC_ALPHA */,
    blendFuncSrcAlpha: 1 /* ONE */,
    blendFuncDstAlpha: 771 /* ONE_MINUS_SRC_ALPHA */
};
/**
 * Renderer of polyline primitives. Its default render state is aimed to render opaque polylines.
 */
class PolylineRenderUnit extends _base_polyline_render_unit__WEBPACK_IMPORTED_MODULE_3__["default"] {
    constructor(context, camera, primitiveProvider, renderState = new _render_state__WEBPACK_IMPORTED_MODULE_4__["default"](DEFAULT_RENDER_STATE_PARAMS)) {
        const program = context.createProgram(_shader_polyline_vert__WEBPACK_IMPORTED_MODULE_1___default.a, _shader_polyline_frag__WEBPACK_IMPORTED_MODULE_2___default.a, {
            defines: {
                FILTER_RADIUS: `float(${FILTER_RADIUS})`,
                MAX_HALF_WIDTH: `float(${_primitive_polyline_polyline_buffer_writer__WEBPACK_IMPORTED_MODULE_0__["MAX_HALF_WIDTH"]})`,
                MAX_FILL_GAP: `float(${_primitive_polyline_polyline_buffer_writer__WEBPACK_IMPORTED_MODULE_0__["MAX_FILL_GAP"]})`
            },
            attribMap: {
                vertexPos: 0 /* POSITION */,
                vertexNormalPacked: 5 /* NORMAL */,
                vertexUvPacked: 4 /* UV */,
                vertexWidthFillGap: 11 /* AUX */,
                vertexColor: 7 /* COLOR */,
                vertexMiter: 12 /* AUX1 */,
                vertexVLimit: 13 /* AUX2 */,
                vertexLength: 14 /* AUX3 */
            }
        });
        super(context, renderState, program, primitiveProvider, camera);
    }
}


/***/ }),
/* 132 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAX_HALF_WIDTH", function() { return MAX_HALF_WIDTH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAX_FILL_GAP", function() { return MAX_FILL_GAP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PolylineBufferWriter; });
/* harmony import */ var _math_vector2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(23);
/* harmony import */ var _util_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(11);
/* harmony import */ var _util_buffer_writer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(36);
/* harmony import */ var _polyline_attribute_mapping__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(62);
/* harmony import */ var _util_gputypes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(37);
/* harmony import */ var _util_z_index__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(53);
/* harmony import */ var _math_scalar__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(16);







/**
 * Computes miter of a join between two segments.
 *
 * @param n1 Normal vector of the first segment.
 * @param n2 Normal vector of the second segment.
 * @returns Miter value, i.e. by how match displacement is longer than a normal
 *      one.
 */
function computeMiter(n1, n2) {
    return Math.sqrt(2 / (1 + _math_vector2__WEBPACK_IMPORTED_MODULE_0__["dot"](n1, n2)));
}
const SEGMENT_VERTEX_COUNT = 4;
const SQUARE_CAP_VERTEX_COUNT = 5;
const ROUND_CAP_VERTEX_COUNT = 4;
const FLOAT_MAX = 3.4028234663852886e+38;
const MITER_LIMIT = 4;
const UV_POS_ONE_PACKED = 255; // packed 1
const UV_NEG_ONE_PACKED = 1; // packed -1
const UV_ZERO_PACKED = 128;
/**
 * Packs a component of uv into a unsigned 8-bit value. After packing -1 will
 * become 1 and 1 will become 255. That's need to emulate zero-preserving
 * normalization (we can't rely on WebGL to do it for us :().
 *
 * @param c The component.
 * @returns Packed component.
 */
function packUvComponent(c) {
    // We don't truncate here because buffer writer will do that for us.
    return 128 + (127 * c);
}
/**
 * Half width of the polyline is stored in a normalized attribute. This constant
 * defines half width value of 1 corresponds to.
 */
const MAX_HALF_WIDTH = 255 / 4; // px
/**
 * Same as for polyline half width, but for dash pattern definition.
 */
const MAX_FILL_GAP = 255; // px
class PolylineBufferWriter extends _util_buffer_writer__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor() {
        super(_polyline_attribute_mapping__WEBPACK_IMPORTED_MODULE_3__["POLYLINE_ATTRIBUTE_MAPPING"].vertexByteSize);
        this._displacement = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["create"](0, 0);
        this._prevDisplacement = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["create"](0, 0);
        this._initPolylineState([_math_vector2__WEBPACK_IMPORTED_MODULE_0__["ZERO"], _math_vector2__WEBPACK_IMPORTED_MODULE_0__["ZERO"]], 0, 0, 0, 0, 0 /* MITER */, 0);
    }
    /**
     * Generates a mesh for a polyline with a given style, baking all necessary
     * parameters into attributes.
     *
     * @param polyline The polyline.
     * @param style The polyline style.
     * @returns Location of the written mesh in the managed buffers.
     */
    writePolyline(polyline, style, zIndex) {
        const { vertices } = polyline;
        const lastIdx = vertices.length - 1;
        if (lastIdx < 1) {
            throw new Error('One vertex in not a polyline. It\'s not even a line.');
        }
        this._initPolylineState(vertices, Object(_util_color__WEBPACK_IMPORTED_MODULE_1__["encodeRgba8"])(style.strokeColor), style.strokeWidth, style.dash ? style.dash.fill : 0, style.dash ? style.dash.gap : 0, style.join, Object(_util_z_index__WEBPACK_IMPORTED_MODULE_5__["intToZIndex"])(zIndex));
        this._writeCap(style.startCap, vertices[0], 1);
        for (let i = 1; i < lastIdx; ++i) {
            this._writeSegment(vertices[i - 1], vertices[i], vertices[i + 1]);
            this._writeJoin(vertices[i]);
        }
        this._writeLastSegment(vertices[lastIdx - 1], vertices[lastIdx]);
        this._writeCap(style.endCap, vertices[lastIdx], 1);
        return this.endMesh();
    }
    _initPolylineState(vertices, colorRgba8, width, fill, gap, join, zIndex) {
        this._baseIndex = this._polylineLength = this._lastDirection = 0;
        this._lastSignedMiter = 1;
        const displacement = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["sub"](vertices[1], vertices[0], this._displacement);
        this._segmentLength = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["length"](displacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["divn"](displacement, this._segmentLength, displacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["rotate90"](displacement, displacement);
        this._colorRgba8 = colorRgba8;
        this._halfWidthFillGapPacked =
            Object(_util_gputypes__WEBPACK_IMPORTED_MODULE_4__["floatToUint8"])(Object(_math_scalar__WEBPACK_IMPORTED_MODULE_6__["clamp"])(0.5 * width, 0, MAX_HALF_WIDTH) / MAX_HALF_WIDTH) |
                Object(_util_gputypes__WEBPACK_IMPORTED_MODULE_4__["floatToUint8"])(Object(_math_scalar__WEBPACK_IMPORTED_MODULE_6__["clamp"])(fill, 0, MAX_FILL_GAP) / MAX_FILL_GAP) << 8 |
                Object(_util_gputypes__WEBPACK_IMPORTED_MODULE_4__["floatToUint8"])(Object(_math_scalar__WEBPACK_IMPORTED_MODULE_6__["clamp"])(gap, 0, MAX_FILL_GAP) / MAX_FILL_GAP) << 16;
        this._join = join;
        this._zIndex = zIndex;
    }
    /**
     * Writes a single vertex into managed vertex buffer.
     *
     * @param position Vertex world position.
     * @param normal Normal of segment the vertex belongs to.
     * @param u Normalized distance to the polyline along the normal.
     * @param v Normalized distance to the polyline along the tangent.
     * @param polylineLength Distance to the first vertex along the polyline.
     * @param miter Join miter.
     * @param lengthCorrectionLimit Limit on the vertex displacement along the
     *      polyline.
     */
    _writeVertex(position, normal, uPacked, vPacked, polylineLength, miter, lengthCorrectionLimit) {
        this._writeWorldCoordinate(position);
        this._writeHalfWords(Object(_util_gputypes__WEBPACK_IMPORTED_MODULE_4__["floatToUint16"])(0.5 * (normal.x * Math.SQRT1_2 + 1)), Object(_util_gputypes__WEBPACK_IMPORTED_MODULE_4__["floatToUint16"])(0.5 * (normal.y * Math.SQRT1_2 + 1)));
        this._writeHalfWords(uPacked, vPacked);
        this._writeWord(this._halfWidthFillGapPacked);
        this._writeFloat32(miter);
        this._writeFloat32(lengthCorrectionLimit);
        this._writeFloat32(polylineLength);
        this._writeWord(this._colorRgba8);
        this._writeFloat32(this._zIndex);
    }
    _writeCap(cap, endVertex, displacementSign) {
        switch (cap) {
            case 1 /* ROUND */:
                this._writeRoundCap(endVertex, displacementSign);
                break;
            case 2 /* SQUARE */:
                this._writeSquareCap(endVertex, displacementSign);
                break;
        }
    }
    _writeRoundCap(endVertex, displacementSign) {
        const displacement = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["create"](0, 0);
        const polylineLength = this._polylineLength;
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["muln"](this._displacement, -displacementSign, displacement);
        this._writeVertex(endVertex, displacement, UV_NEG_ONE_PACKED, UV_ZERO_PACKED, polylineLength, 1, FLOAT_MAX);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["rotate90"](this._displacement, displacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["sub"](displacement, this._displacement, displacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["muln"](displacement, displacementSign, displacement);
        this._writeVertex(endVertex, displacement, UV_NEG_ONE_PACKED, UV_POS_ONE_PACKED, polylineLength, 1, FLOAT_MAX);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["muln"](this._displacement, displacementSign, displacement);
        this._writeVertex(endVertex, displacement, UV_POS_ONE_PACKED, UV_ZERO_PACKED, polylineLength, 1, FLOAT_MAX);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["rotate90"](this._displacement, displacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["add"](displacement, this._displacement, displacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["muln"](displacement, displacementSign, displacement);
        this._writeVertex(endVertex, displacement, UV_POS_ONE_PACKED, UV_POS_ONE_PACKED, polylineLength, 1, FLOAT_MAX);
        this.writeIndicesForContinuousStrip(ROUND_CAP_VERTEX_COUNT, this._baseIndex);
        this._baseIndex += ROUND_CAP_VERTEX_COUNT;
    }
    _writeSquareCap(endVertex, displacementSign) {
        const displacement = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["create"](0, 0);
        const polylineLength = this._polylineLength;
        this._writeVertex(endVertex, _math_vector2__WEBPACK_IMPORTED_MODULE_0__["ZERO"], UV_ZERO_PACKED, UV_ZERO_PACKED, polylineLength, 1, 0);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["muln"](this._displacement, -displacementSign, displacement);
        this._writeVertex(endVertex, displacement, UV_POS_ONE_PACKED, UV_ZERO_PACKED, polylineLength, 1, FLOAT_MAX);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["rotate90"](this._displacement, displacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["sub"](displacement, this._displacement, displacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["muln"](displacement, displacementSign, displacement);
        this._writeVertex(endVertex, displacement, UV_POS_ONE_PACKED, UV_ZERO_PACKED, polylineLength, 1, FLOAT_MAX);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["rotate90"](this._displacement, displacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["sub"](displacement, this._displacement, displacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["muln"](displacement, displacementSign, displacement);
        this._writeVertex(endVertex, displacement, UV_POS_ONE_PACKED, UV_ZERO_PACKED, polylineLength, 1, FLOAT_MAX);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["muln"](this._displacement, displacementSign, displacement);
        this._writeVertex(endVertex, this._displacement, UV_POS_ONE_PACKED, UV_ZERO_PACKED, polylineLength, 1, FLOAT_MAX);
        this.writeIndicesForContinuousFan(SQUARE_CAP_VERTEX_COUNT, this._baseIndex);
        this._baseIndex += SQUARE_CAP_VERTEX_COUNT;
    }
    _writeSegment(start, end, nextEnd) {
        const displacement = this._displacement;
        const polylineLength = this._polylineLength;
        const nextSegmentLength = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["distance"](nextEnd, end);
        const nextSegmentNormal = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["sub"](nextEnd, end);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["divn"](nextSegmentNormal, nextSegmentLength, nextSegmentNormal);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["rotate90"](nextSegmentNormal, nextSegmentNormal);
        const direction1 = this._lastDirection;
        const direction2 = Math.sign(_math_vector2__WEBPACK_IMPORTED_MODULE_0__["crossZ"](displacement, nextSegmentNormal));
        const miter1 = this._lastSignedMiter;
        const miter2 = computeMiter(displacement, nextSegmentNormal);
        this._writeVertex(start, displacement, UV_POS_ONE_PACKED, UV_ZERO_PACKED, polylineLength, direction1 === -1 && (this._join !== 0 /* MITER */ || Math.abs(miter1) > MITER_LIMIT) ?
            1 :
            miter1, direction1 === -1 ? -FLOAT_MAX : 0.5 * this._segmentLength);
        this._writeVertex(end, displacement, UV_POS_ONE_PACKED, UV_ZERO_PACKED, polylineLength + this._segmentLength, direction2 === -1 && (this._join !== 0 /* MITER */ || miter2 > MITER_LIMIT) ?
            1 :
            direction2 * miter2, direction2 === -1 ? FLOAT_MAX : -0.5 * this._segmentLength);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["invert"](displacement, displacement);
        this._writeVertex(start, displacement, UV_NEG_ONE_PACKED, UV_ZERO_PACKED, polylineLength, direction1 === 1 && (this._join !== 0 /* MITER */ || Math.abs(miter1) > MITER_LIMIT) ?
            1 :
            miter1, direction1 === 1 ? -FLOAT_MAX : 0.5 * this._segmentLength);
        this._writeVertex(end, displacement, UV_NEG_ONE_PACKED, UV_ZERO_PACKED, polylineLength + this._segmentLength, direction2 === 1 && (this._join !== 0 /* MITER */ || miter2 > MITER_LIMIT) ?
            1 :
            direction2 * miter2, direction2 === 1 ? FLOAT_MAX : -0.5 * this._segmentLength);
        this.writeIndicesForContinuousStrip(SEGMENT_VERTEX_COUNT, this._baseIndex);
        this._baseIndex += SEGMENT_VERTEX_COUNT;
        this._lastSignedMiter = -direction2 * miter2;
        this._lastDirection = direction2;
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["copy"](displacement, this._prevDisplacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["copy"](nextSegmentNormal, displacement);
        this._polylineLength += this._segmentLength;
        this._segmentLength = nextSegmentLength;
    }
    _writeJoin(joinVertex) {
        switch (this._join) {
            case 2 /* BEVEL */:
                this._writeBevelJoin(joinVertex);
                break;
            case 1 /* ROUND */:
                this._writeRoundJoin(joinVertex);
                break;
            case 0 /* MITER */:
                if (Math.abs(this._lastSignedMiter) > MITER_LIMIT) {
                    this._writeBevelJoin(joinVertex);
                }
                break;
        }
    }
    _writeBevelJoin(joinVertex) {
        const lastDirection = this._lastDirection;
        const displacement = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["invert"](this._displacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["add"](displacement, this._prevDisplacement, displacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["muln"](displacement, 0.5 * lastDirection, displacement);
        this._writeVertex(joinVertex, displacement, lastDirection === -1 /* LEFT */ ?
            UV_POS_ONE_PACKED :
            UV_NEG_ONE_PACKED, UV_ZERO_PACKED, this._polylineLength, 1, 1);
        const baseIndex = this._baseIndex;
        this.writeIndices([
            baseIndex - 1,
            baseIndex - 3,
            baseIndex,
            baseIndex,
            lastDirection === -1 /* LEFT */ ? baseIndex + 1 : baseIndex + 3,
            lastDirection === -1 /* LEFT */ ? baseIndex + 3 : baseIndex + 1
        ]);
        this._baseIndex += 1;
    }
    _writeRoundJoin(joinVertex) {
        const polylineLength = this._polylineLength;
        this._writeVertex(joinVertex, _math_vector2__WEBPACK_IMPORTED_MODULE_0__["ZERO"], UV_ZERO_PACKED, UV_ZERO_PACKED, polylineLength, 0, 0);
        const lastDirection = this._lastDirection;
        const middleDisplacement = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["invert"](this._prevDisplacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["add"](this._displacement, middleDisplacement, middleDisplacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["normalize"](middleDisplacement, middleDisplacement);
        const displacement = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["invert"](this._prevDisplacement);
        const miter1 = computeMiter(middleDisplacement, displacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["add"](displacement, middleDisplacement, displacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["normalize"](displacement, displacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["muln"](displacement, -lastDirection * miter1, displacement);
        this._writeVertex(joinVertex, displacement, lastDirection === -1 /* LEFT */ ?
            UV_POS_ONE_PACKED :
            UV_NEG_ONE_PACKED, packUvComponent(Math.sqrt(miter1 * miter1 - 1)), polylineLength, 1, FLOAT_MAX);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["muln"](middleDisplacement, -lastDirection, displacement);
        this._writeVertex(joinVertex, displacement, lastDirection === -1 /* LEFT */ ?
            UV_POS_ONE_PACKED :
            UV_NEG_ONE_PACKED, UV_ZERO_PACKED, polylineLength, 1, FLOAT_MAX);
        const miter2 = computeMiter(middleDisplacement, this._displacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["add"](this._displacement, middleDisplacement, displacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["normalize"](displacement, displacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["muln"](displacement, -lastDirection * miter2, displacement);
        this._writeVertex(joinVertex, displacement, lastDirection === -1 /* LEFT */ ?
            UV_POS_ONE_PACKED :
            UV_NEG_ONE_PACKED, packUvComponent(Math.sqrt(miter2 * miter2 - 1)), polylineLength, 1, FLOAT_MAX);
        const baseIndex = this._baseIndex;
        this.writeIndices([
            baseIndex - 3,
            baseIndex - 1,
            baseIndex,
            baseIndex,
            lastDirection === -1 /* LEFT */ ? baseIndex - 3 : baseIndex - 1,
            baseIndex + 1,
            baseIndex,
            baseIndex + 1,
            baseIndex + 2,
            baseIndex,
            baseIndex + 2,
            baseIndex + 3,
            baseIndex,
            baseIndex + 3,
            lastDirection === -1 /* LEFT */ ? baseIndex + 4 : baseIndex + 6,
            baseIndex,
            baseIndex + 4,
            baseIndex + 6
        ]);
        this._baseIndex += 4;
    }
    _writeLastSegment(start, end) {
        const displacement = this._displacement;
        const lastDirection = this._lastDirection;
        const polylineLength = this._polylineLength;
        const miter = this._lastSignedMiter;
        this._writeVertex(start, displacement, UV_POS_ONE_PACKED, UV_ZERO_PACKED, polylineLength, lastDirection === -1 /* LEFT */ && (this._join !== 0 /* MITER */ || Math.abs(miter) > MITER_LIMIT) ?
            1 :
            miter, lastDirection === -1 /* LEFT */ ? -FLOAT_MAX : this._segmentLength);
        this._writeVertex(end, displacement, UV_POS_ONE_PACKED, UV_ZERO_PACKED, polylineLength + this._segmentLength, 1, FLOAT_MAX);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["invert"](displacement, displacement);
        this._writeVertex(start, displacement, UV_NEG_ONE_PACKED, UV_ZERO_PACKED, polylineLength, lastDirection === 1 /* RIGHT */ && (this._join !== 0 /* MITER */ || Math.abs(miter) > MITER_LIMIT) ?
            1 :
            miter, lastDirection === 1 /* RIGHT */ ? -FLOAT_MAX : this._segmentLength);
        this._writeVertex(end, displacement, UV_NEG_ONE_PACKED, UV_ZERO_PACKED, polylineLength + this._segmentLength, 1, FLOAT_MAX);
        this.writeIndicesForContinuousStrip(SEGMENT_VERTEX_COUNT, this._baseIndex);
        this._baseIndex += SEGMENT_VERTEX_COUNT;
    }
}


/***/ }),
/* 133 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\n#ifndef FILTER_RADIUS\n#   error FILTER_RADIUS must be set\n#endif\n\n#ifndef MAX_HALF_WIDTH\n#   error MAX_HALF_WIDTH must be set\n#endif\n\n#ifndef MAX_FILL_GAP\n#   error MAX_FILL_GAP must be set\n#endif\n\nattribute vec4 vertexPos;\nattribute vec2 vertexNormalPacked;\nattribute vec2 vertexUvPacked;\nattribute vec3 vertexWidthFillGap;\nattribute vec4 vertexColor;\nattribute float vertexMiter;\nattribute float vertexVLimit;\nattribute float vertexLength;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\nuniform float worldToPxFactor;\n\nvarying vec2 uv;\nvarying float len;\nvarying float halfWidth;\nvarying vec3 dash;\nvarying vec4 color;\n\nconst float YV_H = 1.999969482421875;\nconst float YV_L = 0.000030517112463712692;\nconst vec4 YV_HHLL = vec4(YV_H, YV_H, YV_L, YV_L);\n\nconst float SQRT2 = 1.4142135381698608;\n\nvec2 unpackUv(const in vec2 uv) {\n    return (uv - 128.) / 127.;\n}\n\nvoid main(void) {\n    vec2 normal = (2.0 * vertexNormalPacked - 1.0) * SQRT2;\n\n    halfWidth = float(MAX_HALF_WIDTH) * vertexWidthFillGap.x;\n    halfWidth += FILTER_RADIUS;\n\n    float tangentLength = min(\n        sqrt(vertexMiter * vertexMiter - 1.) * halfWidth * worldToPxFactor,\n        abs(vertexVLimit)\n    );\n\n    vec4 lookAt = vec4(lookAtHigh, lookAtLow);\n    vec4 relativeToEyePosition = YV_HHLL * (vertexPos - lookAt);\n\n    gl_Position = viewProjMatrix * vec4(\n        relativeToEyePosition.xy + relativeToEyePosition.zw +\n                worldToPxFactor * halfWidth * normal -\n                    sign(vertexMiter) * tangentLength * vec2(normal.y, -normal.x),\n        0,\n        1\n    );\n\n    uv = unpackUv(vertexUvPacked) * halfWidth;\n    len = (vertexLength + sign(vertexVLimit) * tangentLength) / worldToPxFactor;\n\n    dash.xy = vec2(MAX_FILL_GAP) * vertexWidthFillGap.yz;\n    dash.z = dash.x + dash.y;\n\n    color = vertexColor;\n    color.rgb *= color.a;\n}\n"

/***/ }),
/* 134 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\n#ifndef FILTER_RADIUS\n#   error FILTER_RADIUS must be set\n#endif\n\nvarying highp vec2 uv;\nvarying highp float len;\nvarying highp float halfWidth;\nvarying lowp vec3 dash;\nvarying lowp vec4 color;\n\nvoid main(void) {\n    lowp float alpha =\n        smoothstep(0.0, FILTER_RADIUS + min(FILTER_RADIUS, halfWidth), halfWidth - length(uv));\n\n    if (dash.z > 0.0) {\n        lowp vec3 halfDash = dash * 0.5;\n        lowp float dashPhase = mod(len + halfDash.y, dash.z);\n        lowp float r = min(FILTER_RADIUS, halfDash.y);\n\n        alpha *= smoothstep(-r, r, halfDash.x - abs(dashPhase - halfDash.z));\n    }\n\n    gl_FragColor = color * alpha;\n}\n"

/***/ }),
/* 135 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TexturedPolygonRenderUnit; });
/* harmony import */ var _shader_textured_polygon_vert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(136);
/* harmony import */ var _shader_textured_polygon_vert__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_shader_textured_polygon_vert__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _shader_textured_polygon_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(137);
/* harmony import */ var _shader_textured_polygon_frag__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_shader_textured_polygon_frag__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _math_vector2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(23);
/* harmony import */ var _render_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(10);
/* harmony import */ var _world_primitive_render_unit__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(100);






const RENDER_STATE = new _render_state__WEBPACK_IMPORTED_MODULE_3__["default"](_render_state__WEBPACK_IMPORTED_MODULE_3__["BLEND_OVER_RENDER_STATE"], {
    depthTest: true,
    depthMask: false,
    depthFunc: 518 /* GREATER_OR_EQUAL */
});
/**
 * Renderer of polyline primitives.
 */
class TexturedPolygonRenderUnit extends _world_primitive_render_unit__WEBPACK_IMPORTED_MODULE_4__["default"] {
    constructor(context, primitiveProvider) {
        const program = context.createProgram(_shader_textured_polygon_vert__WEBPACK_IMPORTED_MODULE_0___default.a, _shader_textured_polygon_frag__WEBPACK_IMPORTED_MODULE_1___default.a, {
            attribMap: {
                vertexPosHigh: 0 /* POSITION_HIGH */,
                vertexPosLow: 1 /* POSITION_LOW */,
                vertexUV: 4 /* UV */,
                vertexImageScale: 11 /* AUX */,
                vertexZIndex: 10 /* Z_INDEX */
            }
        });
        super(context, RENDER_STATE, program, primitiveProvider);
        this._atlasSizeUniform = _math_vector2__WEBPACK_IMPORTED_MODULE_2__["create"](0, 0);
        context.bindProgram(program);
        program.setIntScalarUniform('atlas', 0);
    }
    _renderBatch(memoryBatch) {
        const atlas = memoryBatch.firstPrimitive.atlas;
        this._atlasSizeUniform.x = atlas.width;
        this._atlasSizeUniform.y = atlas.height;
        if (atlas.isDirty) {
            atlas.syncTexture();
        }
        this._program.setVector2Uniform('atlasSize', this._atlasSizeUniform);
        this._context.bindTextureUnit(0);
        this._context.bindTexture(atlas.texture);
        super._renderBatch(memoryBatch);
    }
    _canBatchAdjacentPrimitives(a, b) {
        return super._canBatchAdjacentPrimitives(a, b) && (a.atlas === b.atlas);
    }
}


/***/ }),
/* 136 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec2 vertexPosHigh;\nattribute vec2 vertexPosLow;\nattribute vec4 vertexUV;\nattribute float vertexImageScale;\nattribute float vertexZIndex;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\n\nvarying vec2 uvPosition;\nvarying vec2 textureSize;\nvarying vec2 uvDisplacement;\n\nconst float YV_H = 1.999969482421875;\nconst float YV_L = 0.000030517112463712692;\n\nvoid main(void) {\n    uvPosition = vertexUV.xy;\n    textureSize = vertexUV.zw;\n\n    // The same pattern image should match across multiple (usually adjacent) polygons and it should have\n    // stable position realtive to the polygon. Also pattern is repeated at both directions.\n    // To meet these requirements the world is covered (virtually) by a texture of appropriate size (repeated image)\n    // and vertex coordinates are mapped to these texture coordinates (uvDisplacement).\n    // But due to limited precision we've got to work with \"narrow\" floats (as it is done in world position calculation):\n    //   1. calculate how big texture pattern in world coordinates (scaledTextureSize)\n    //   2. find the closest to eye coordinates texture base point (the bottom left point of the pattern)\n    //   3. use vertex position and textureBasePoint vectors to find coordinates in virtual texture\n    //   4. find uv coordinates in real texture using mod operation\n    //\n    // Both textureBasePoint and position are relativelly small vectors so that precision requirements are met,\n    // and correct interpolation of repeated image is possible by using single base point in all vertices.\n\n    vec2 scaledTextureSize = textureSize * vertexImageScale; // texture size in world coordinates\n    vec2 textureBasePoint = mod(YV_H * lookAtHigh, scaledTextureSize) + mod(YV_L * lookAtLow, scaledTextureSize);\n    vec2 position = YV_H * (vertexPosHigh - lookAtHigh) + YV_L * (vertexPosLow - lookAtLow);\n\n    gl_Position = viewProjMatrix * vec4(position, 0, 1);\n    gl_Position.xy /= gl_Position.w;\n    gl_Position.z = vertexZIndex;\n    gl_Position.w = 1.0;\n\n    // convert world coordinates back to teture pixels\n    uvDisplacement = (position + textureBasePoint) / vertexImageScale;\n}\n"

/***/ }),
/* 137 */
/***/ (function(module, exports) {

module.exports = "#version 100\n\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform sampler2D atlas;\nuniform vec2 atlasSize;\n\nvarying vec2 uvPosition;\nvarying vec2 textureSize;\nvarying vec2 uvDisplacement;\n\nvoid main(void) {\n    vec2 uvAdjusted = vec2(\n        uvPosition.x + mod(uvDisplacement.x, textureSize.x),\n        uvPosition.y + mod(uvDisplacement.y, textureSize.y)\n    );\n\n    gl_FragColor = texture2D(atlas, uvAdjusted / atlasSize);\n}\n"

/***/ }),
/* 138 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TransparentPolygonRenderUnit; });
/* harmony import */ var _polygon_render_unit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(139);
/* harmony import */ var _render_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);




/**
 * Renderer of transparent polygon primitives.
 */
class TransparentPolygonRenderUnit extends _polygon_render_unit__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(context, primitiveProvider) {
        super(context, primitiveProvider, new _render_state__WEBPACK_IMPORTED_MODULE_1__["default"](_polygon_render_unit__WEBPACK_IMPORTED_MODULE_0__["DEFAULT_RENDER_STATE_PARAMS"], { depthMask: false }, _render_state__WEBPACK_IMPORTED_MODULE_1__["BLEND_OVER_RENDER_STATE"]));
    }
}


/***/ }),
/* 139 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_RENDER_STATE_PARAMS", function() { return DEFAULT_RENDER_STATE_PARAMS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PolygonRenderUnit; });
/* harmony import */ var _shader_polygon_vert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(140);
/* harmony import */ var _shader_polygon_vert__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_shader_polygon_vert__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _shader_polygon_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(141);
/* harmony import */ var _shader_polygon_frag__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_shader_polygon_frag__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _render_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(10);
/* harmony import */ var _world_primitive_render_unit__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(100);




const DEFAULT_RENDER_STATE_PARAMS = {
    depthTest: true,
    depthFunc: 518 /* GREATER_OR_EQUAL */
};
/**
 * Renderer of polygon primitives.
 */
class PolygonRenderUnit extends _world_primitive_render_unit__WEBPACK_IMPORTED_MODULE_3__["default"] {
    constructor(context, primitiveProvider, renderState = new _render_state__WEBPACK_IMPORTED_MODULE_2__["default"](DEFAULT_RENDER_STATE_PARAMS)) {
        const program = context.createProgram(_shader_polygon_vert__WEBPACK_IMPORTED_MODULE_0___default.a, _shader_polygon_frag__WEBPACK_IMPORTED_MODULE_1___default.a, {
            attribMap: {
                vertexPosHigh: 0 /* POSITION_HIGH */,
                vertexPosLow: 1 /* POSITION_LOW */,
                vertexColor: 7 /* COLOR */,
                vertexZIndex: 10 /* Z_INDEX */
            }
        });
        super(context, renderState, program, primitiveProvider);
    }
}


/***/ }),
/* 140 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec2 vertexPosHigh;\nattribute vec2 vertexPosLow;\nattribute vec4 vertexColor;\nattribute float vertexZIndex;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\n\nvarying vec4 color;\n\nconst float YV_H = 1.999969482421875;\nconst float YV_L = 0.000030517112463712692;\n\nvoid main(void) {\n    vec4 position = viewProjMatrix * vec4(\n        YV_H * (vertexPosHigh - lookAtHigh) +\n            YV_L * (vertexPosLow - lookAtLow),\n        0,\n        1\n    );\n\n    position.xy /= position.w;\n    position.z = vertexZIndex;\n    position.w = 1.0;\n\n    gl_Position = position;\n\n    color = vertexColor;\n}\n"

/***/ }),
/* 141 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nvarying lowp vec4 color;\n\nvoid main(void) {\n    gl_FragColor = color;\n}\n"

/***/ }),
/* 142 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MapEngine; });
/* harmony import */ var _engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(143);
/* harmony import */ var _render_fxaa_render_unit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(176);
/* harmony import */ var _render_background_render_unit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(179);
/* harmony import */ var _render_layer_render_unit__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(181);




/**
 * Ground layer with background that goes right after sub render units. It allows to add other LayerRenderUnits above
 * groundLayer without worrying that they destroy depth information collected on ground and broke background (that has
 * a performance optimisation: it uses depth information from the layers below to prevent extensive pixel overwriting).
 */
class BackgroundedGroundLayer extends _render_layer_render_unit__WEBPACK_IMPORTED_MODULE_3__["default"] {
    constructor(context, depthClearStrategy = 0 /* NO_CLEAR */) {
        super(context, depthClearStrategy);
        this._background = new _render_background_render_unit__WEBPACK_IMPORTED_MODULE_2__["default"](context);
    }
    render(target, ...args) {
        super.render(target, ...args);
        this._background.render(target);
    }
}
class MapEngine extends _engine__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(context, camera, renderLoop) {
        super(context, camera, renderLoop);
        this._destroyables = [];
        const antialiasingLayer = new _render_fxaa_render_unit__WEBPACK_IMPORTED_MODULE_1__["default"](context, this.renderLoop);
        this.backgoundLayer = new _render_layer_render_unit__WEBPACK_IMPORTED_MODULE_3__["default"](context);
        this.groundLayer = new BackgroundedGroundLayer(context);
        this.buildingsLayer = new _render_layer_render_unit__WEBPACK_IMPORTED_MODULE_3__["default"](context);
        this.iconsLayer = new _render_layer_render_unit__WEBPACK_IMPORTED_MODULE_3__["default"](context);
        this.labelsLayer = new _render_layer_render_unit__WEBPACK_IMPORTED_MODULE_3__["default"](context);
        antialiasingLayer.addRenderUnit(this.buildingsLayer);
        this.renderer.addRenderUnit(this.backgoundLayer);
        this.renderer.addRenderUnit(this.groundLayer);
        this.renderer.addRenderUnit(antialiasingLayer);
        this.renderer.addRenderUnit(this.iconsLayer);
        this.renderer.addRenderUnit(this.labelsLayer);
        this._destroyables.push(antialiasingLayer);
        // force initial rendering (no data yet, just background) as the canvas (black) can already be visible to users,
        // renderer is called directly (without scheduling via render loop) as it is pretty much safe to assume
        // that no rendering is scheduled for this frame, and deferred update can potentially cause a single frame blink
        this.renderer.render(this._renderTarget);
    }
    destroy() {
        // destroy in reverse order to prevent potential issues if destroyables own each other
        for (let i = this._destroyables.length - 1; i >= 0; i--) {
            this._destroyables[i].destroy();
        }
        super.destroy();
    }
}


/***/ }),
/* 143 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Engine; });
/* harmony import */ var _util_event_emitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(14);
/* harmony import */ var _render_font_renderable_df_glyph_atlas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(144);
/* harmony import */ var _font_df_font_registry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(146);
/* harmony import */ var _render_billboard_renderable_image_atlas__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(148);
/* harmony import */ var _visibility_visibility_manager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(154);
/* harmony import */ var _util_median_filter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(170);
/* harmony import */ var _util_stat__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(34);
/* harmony import */ var _render_main_render_unit__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(171);
/* harmony import */ var _render_memory_manager__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(173);









class Engine {
    constructor(context, camera, renderLoop) {
        this.context = context;
        this._camera = camera;
        this._renderTarget = context.getDefaultRenderTarget();
        this.renderer = new _render_main_render_unit__WEBPACK_IMPORTED_MODULE_7__["default"](context, camera);
        this.renderLoop = renderLoop;
        this.memoryManager = new _render_memory_manager__WEBPACK_IMPORTED_MODULE_8__["default"](context);
        this._atlases = new Set();
        this.visibilityManager = new _visibility_visibility_manager__WEBPACK_IMPORTED_MODULE_4__["default"](context, camera, renderLoop, this._renderTarget.getWidth(), this._renderTarget.getHeight());
        this.visbilityTextureProvider = () => {
            this.visibilityManager.updateVisibilityIfNeeded();
            return this.visibilityManager.visibilityTexture;
        };
        this._frameTimingsListener = this._onFrameTimesFull.bind(this);
        renderLoop.onFrameTimesFull.addListener(this._frameTimingsListener);
        this._renderListener = this._onRender.bind(this);
        renderLoop.onRender.addListener(this._renderListener);
        this._updateListener = () => this.renderLoop.update();
        this.glyphAtlas = new _render_font_renderable_df_glyph_atlas__WEBPACK_IMPORTED_MODULE_1__["default"](context);
        this.fontRegistry = new _font_df_font_registry__WEBPACK_IMPORTED_MODULE_2__["default"]();
        this.onInternalError = new _util_event_emitter__WEBPACK_IMPORTED_MODULE_0__["VoidEventEmitter"]();
        this._camera.onUpdate.addListener(this._updateListener);
        this.renderer.onUpdate.addListener(this._updateListener);
        this._contextLostListener = () => this.onInternalError.fire();
        this.context.onLoss.addListener(this._contextLostListener);
    }
    setRenderTargetSize(width, height) {
        if (this._renderTarget.getWidth() !== width ||
            this._renderTarget.getHeight() !== height) {
            this._renderTarget.setSize(width, height);
            this.visibilityManager.setTargetSize(width, height);
        }
    }
    createImageAtlas(params) {
        const atlas = new _render_billboard_renderable_image_atlas__WEBPACK_IMPORTED_MODULE_3__["default"](this.context, params);
        atlas.onContentUpdate.addListener(this._updateListener);
        this._atlases.add(atlas);
        return atlas;
    }
    removeImageAtlas(atlas) {
        atlas.destroy();
        atlas.onContentUpdate.removeListener(this._updateListener);
        this._atlases.delete(atlas);
    }
    getCamera() {
        return this._camera;
    }
    destroy() {
        this._camera.onUpdate.removeListener(this._updateListener);
        this.renderer.onUpdate.removeListener(this._updateListener);
        for (const atlas of this._atlases) {
            atlas.onContentUpdate.removeListener(this._updateListener);
            atlas.destroy();
        }
        this.glyphAtlas.destroy();
        this.context.onLoss.removeListener(this._contextLostListener);
    }
    _onRender() {
        this.renderer.render(this._renderTarget);
    }
    _onFrameTimesFull(times) {
        Object(_util_stat__WEBPACK_IMPORTED_MODULE_6__["countFps"])(1e3 * times.length / Object(_util_median_filter__WEBPACK_IMPORTED_MODULE_5__["medianFilter"])(times).reduce((sum, time) => sum + time));
        // For now we acquire frame timing and log them only once a session.
        this.renderLoop.onFrameTimesFull.removeListener(this._frameTimingsListener);
    }
}


/***/ }),
/* 144 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RenderableDfGlyphAtlas; });
/* harmony import */ var _font_df_glyph_atlas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(145);

/**
 * Atlas that manages allocation in GL texture.
 */
class RenderableDfGlyphAtlas extends _font_df_glyph_atlas__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(context) {
        super(0, 0, new Uint8Array(0), new Map());
        this._context = context;
        this.texture = this._createTexture(0, 0);
    }
    destroy() {
        this.texture.destroy();
    }
    /**
     * Updates the whole content of the glyph bitmap atlas, texture also get updated.
     *
     * @param width new bitmap width
     * @param height new bitmap height
     * @param data, length should be strictly equal to width * height
     */
    updateContent(width, height, data, glyphLocations) {
        this.width = width;
        this.height = height;
        this.data = data;
        this._glyphLocations = glyphLocations;
        const texture = this.texture;
        if (!texture || texture.getWidth() !== width || texture.getHeight() !== height) {
            if (this.texture) {
                this.texture.destroy();
            }
            this.texture = this._createTexture(width, height);
        }
        this._context.setTextureData(this.texture, data);
    }
    _createTexture(width, height) {
        return this._context.createEmpty2DTexture(width, height, 6406 /* ALPHA */, 5121 /* UNSIGNED_BYTE */, {
            wrapS: 33071 /* CLAMP_TO_EDGE */,
            wrapT: 33071 /* CLAMP_TO_EDGE */,
            magnificationFilter: 9729 /* LINEAR */,
            minificationFilter: 9729 /* LINEAR */,
            premultipliedAlpha: false
        });
    }
}


/***/ }),
/* 145 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DfGlyphAtlas; });
const UNKNOWN_GLYPH_LOCATION = {
    minX: 0,
    maxX: 0,
    minY: 0,
    maxY: 0
};
/**
 * Abstract glyph atlas interface.
 */
class DfGlyphAtlas {
    constructor(width, height, data, glyphLocations) {
        this.width = width;
        this.height = height;
        this.data = data;
        this._glyphLocations = glyphLocations;
    }
    /**
     * @return Glyph location or fake location pointing to the origin (0, 0).
     */
    getGlyphLocation(fontId, glyphId) {
        const glyphLocation = this._glyphLocations.get(fontId + glyphId);
        if (glyphLocation) {
            return glyphLocation;
        }
        else {
            console.warn('Wow-wow-wow, something went wrong, you should not request nonexistent glyph locations');
            return UNKNOWN_GLYPH_LOCATION;
        }
    }
    /**
     * @return All glyph locations as [glyph id, glyph location] array. Glyph id is font id concatenated with glyph id.
     */
    getAllGlyphLocations() {
        return [...this._glyphLocations.entries()];
    }
}


/***/ }),
/* 146 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DfFontRegistry; });
/* harmony import */ var _font_registry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(147);
/* harmony import */ var _df_font__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(44);


/**
 * Registry that stores distance field fonts.
 */
class DfFontRegistry extends _font_registry__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super(new _df_font__WEBPACK_IMPORTED_MODULE_1__["default"]('UNKNOWN_DF_FONT', 14, 0));
    }
}


/***/ }),
/* 147 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return FontRegistry; });
/**
 * A central storage of all available fonts.
 */
class FontRegistry {
    /**
     * @param unknownFontInstance An instance of specific font type to be served as a stub when nonexistent font
     *     is requested. Requesting nonexistent fonts normally should not happen.
     *     The stub just allows to avoid tedious null checks in registry clients.
     */
    constructor(unknownFontInstance) {
        this._fonts = new Map();
        this._unknownFontInstance = unknownFontInstance;
    }
    /**
     * @return If a font with specified id is in the registry.
     */
    contains(fontId) {
        return this._fonts.has(fontId);
    }
    /**
     * @return Font with specified id or unknown font instance if it is not found.
     */
    get(fontId) {
        const font = this._fonts.get(fontId);
        if (font) {
            return font;
        }
        else {
            console.warn('Wow-wow-wow, something went wrong, you should not request nonexistent fonts');
            return this._unknownFontInstance;
        }
    }
    /**
     * @return All stored fonts.
     */
    getAll() {
        return [...this._fonts.values()];
    }
    /**
     * Adds new for to the registry.
     */
    add(font) {
        this._fonts.set(font.id, font);
    }
}


/***/ }),
/* 148 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RenderableImageAtlas; });
/* harmony import */ var _billboard_image_atlas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(149);

/**
 * Atlas that manages allocation in GL texture.
 */
class RenderableImageAtlas extends _billboard_image_atlas__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(context, params) {
        super();
        const { filter, premultipliedAlpha } = params;
        this._context = context;
        this._filter = filter;
        this._premultipliedAlpha = premultipliedAlpha;
        this.texture = this._createTexture(this.width, this.height, filter, premultipliedAlpha);
        this.isDirty = false;
    }
    /**
     * Updates GL texture with changed data. Should be called after each image added to take effect in shaders.
     */
    syncTexture() {
        this._context.setTextureDataFromDomElement(this.texture, this.canvas);
        this.isDirty = false;
    }
    updateImage(location, sourceImage, locationRegion, sourceImageRegion) {
        super.updateImage(location, sourceImage, locationRegion, sourceImageRegion);
        this.isDirty = true;
    }
    destroy() {
        this.texture.destroy();
    }
    _expand(newWidth, newHeight) {
        super._expand(newWidth, newHeight);
        this.texture.destroy();
        this.texture = this._createTexture(this.width, this.height, this._filter, this._premultipliedAlpha);
        this.isDirty = true;
    }
    _createTexture(width, height, filter, premultipliedAlpha) {
        return this._context.createEmpty2DTexture(width, height, 6408 /* RGBA */, 5121 /* UNSIGNED_BYTE */, {
            minificationFilter: filter,
            magnificationFilter: filter,
            wrapS: 33071 /* CLAMP_TO_EDGE */,
            wrapT: 33071 /* CLAMP_TO_EDGE */,
            premultipliedAlpha
        });
    }
}


/***/ }),
/* 149 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ImageAtlas; });
/* harmony import */ var _math_vector2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(23);
/* harmony import */ var _util_allocator_2d__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(150);
/* harmony import */ var _util_event_emitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(14);



const INIT_ATLAS_WIDTH = 256;
const INIT_ATLAS_HEIGHT = 256;
const MAX_ATLAS_WIDTH = 2048;
const MAX_ATLAS_HEIGHT = 2048;
const EXPAND_FACTOR = 2;
/**
 * Manages allocation of images. It resizes itself (up to a fixed limit) when there is no region
 * of enough size for the next image.
 */
class ImageAtlas {
    constructor(initAtlasWidth = INIT_ATLAS_WIDTH, initAtlasHeight = INIT_ATLAS_HEIGHT) {
        this.onContentUpdate = new _util_event_emitter__WEBPACK_IMPORTED_MODULE_2__["VoidEventEmitter"]();
        this.canvas = document.createElement('canvas');
        this.canvas.width = initAtlasWidth;
        this.canvas.height = initAtlasHeight;
        this._canvasContext = this.canvas.getContext('2d');
        this._allocator = new _util_allocator_2d__WEBPACK_IMPORTED_MODULE_1__["ShelfAllocator2D"](this.width, this.height);
    }
    get width() {
        return this.canvas.width;
    }
    get height() {
        return this.canvas.height;
    }
    /**
     * Allocates image bitmap.
     */
    allocateImage(descriptor, image) {
        const location = this._allocate(descriptor);
        if (location) {
            const region = Object(_math_vector2__WEBPACK_IMPORTED_MODULE_0__["createBBox2"])(0, descriptor.width, 0, descriptor.height);
            this.updateImage(location, image, region, region);
        }
        return location;
    }
    /**
     * Reserves space of appropriate size that can be updated later with updateImage() method.
     */
    reserveLocation(descriptor) {
        return this._allocate(descriptor);
    }
    /**
     * Updates image content in appropriate location. Assumes that there is really such location reserved,
     * no check for this is done.
     *
     * @param location Location in atlas of the image.
     * @param sourceImage Image to update atlas from.
     * @param locationRegion Region (bbox with coordinates relative to the location's bbox) of the location to update.
     * @param sourceImageRegion Region of the image (BBox2 in image's coordinate space) to be copied into atlas.
     */
    updateImage(location, sourceImage, locationRegion = Object(_math_vector2__WEBPACK_IMPORTED_MODULE_0__["createBBox2"])(0, location.maxX - location.minX, 0, location.maxY - location.minY), sourceImageRegion = Object(_math_vector2__WEBPACK_IMPORTED_MODULE_0__["createBBox2"])(0, sourceImage.width, 0, sourceImage.height)) {
        const srcX = sourceImageRegion.minX;
        const srcY = sourceImageRegion.minY;
        const srcW = sourceImageRegion.maxX - sourceImageRegion.minX;
        const srcH = sourceImageRegion.maxY - sourceImageRegion.minY;
        const dstX = location.minX + locationRegion.minX;
        const dstY = location.minY + locationRegion.minY;
        const dstW = locationRegion.maxX - locationRegion.minX;
        const dstH = locationRegion.maxY - locationRegion.minY;
        this._canvasContext.clearRect(dstX, dstY, dstW, dstH);
        this._canvasContext.drawImage(sourceImage, srcX, srcY, srcW, srcH, dstX, dstY, dstW, dstH);
        this.onContentUpdate.fire();
    }
    /**
     * Deallocates image from the atlas.
     */
    removeImage(image) {
        this._allocator.deallocate(image);
    }
    _allocate(descriptor) {
        let location = this._allocator.allocate(descriptor);
        // incremental expand can be inefficient if two or more iterations are needed to allocate an image,
        // but it is expected to be a rare (if any) case, rework if it turns out to be wrong
        while (!location) {
            const expandedWidth = this.width * EXPAND_FACTOR;
            const expandedHeight = this.height * EXPAND_FACTOR;
            if (expandedWidth <= MAX_ATLAS_WIDTH && expandedHeight <= MAX_ATLAS_HEIGHT) {
                this._expand(expandedWidth, expandedHeight);
                location = this._allocator.allocate(descriptor);
            }
            else {
                break;
            }
        }
        return location;
    }
    _expand(newWidth, newHeight) {
        this._allocator.resize(newWidth, newHeight);
        // setting new width/height to canvas will clear it,
        // so current data is saved to be restored immediately after resizing
        const data = this._canvasContext.getImageData(0, 0, this.width, this.height);
        this.canvas.width = newWidth;
        this.canvas.height = newHeight;
        this._canvasContext.putImageData(data, 0, 0);
    }
}


/***/ }),
/* 150 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShelfAllocator2D", function() { return ShelfAllocator2D; });
/* harmony import */ var _allocator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(151);

/**
 * A rectangular region with fixed height. Utility class for shelf allocation defined below.
 */
class Shelf {
    constructor(width, height) {
        this.width = width;
        this.height = height;
        this._allocator = new _allocator__WEBPACK_IMPORTED_MODULE_0__["FreeListAllocator"](this.width);
    }
    allocate(width) {
        return this._allocator.allocate(width);
    }
    deallocate(offset) {
        this._allocator.deallocate(offset);
    }
    isAllocated(offset) {
        return this._allocator.isAllocated(offset);
    }
    canAllocate(width) {
        return this._allocator.maxAllocableSize >= width;
    }
    resize(width) {
        this._allocator.extend(width);
        this.width = width;
    }
}
/**
 * Allocates rectangles in "shelves" (height fixed regions). They are created of necessity when the next object doesnt
 * fit any existing shelf. To optimize space usage it tries to find the best shelf for allocation (min height diff).
 * A shelf when allocated is never deallocated back and exists during all the allocator lifetime.
 */
class ShelfAllocator2D {
    constructor(width, height) {
        this.width = width;
        this.height = height;
        this._shelves = new Map();
        this._shelfAllocator = new _allocator__WEBPACK_IMPORTED_MODULE_0__["ArenaAllocator"](height); // no shelf deallocation, that is why ArenaAllocator is fine
    }
    allocate(object) {
        let bestShelf;
        let bestShelfOffset = -1;
        let bestShelfRatio = -1;
        for (const [offset, shelf] of this._shelves.entries()) {
            const shelfRatio = object.height / shelf.height;
            if (shelfRatio === 1 && shelf.canAllocate(object.width)) {
                bestShelf = shelf;
                bestShelfOffset = offset;
                break;
            }
            else if (shelfRatio < 1 && shelfRatio > bestShelfRatio && shelf.canAllocate(object.width)) {
                bestShelf = shelf;
                bestShelfOffset = offset;
                bestShelfRatio = shelfRatio;
            }
        }
        if (!bestShelf && this._shelfAllocator.maxAllocableSize >= object.height && this.width >= object.width) {
            const offset = this._shelfAllocator.allocate(object.height);
            bestShelf = new Shelf(this.width, object.height);
            bestShelfOffset = offset;
            this._shelves.set(offset, bestShelf);
        }
        if (bestShelf) {
            const left = bestShelf.allocate(object.width);
            const top = bestShelfOffset;
            const location = {
                minX: left,
                maxX: left + object.width,
                minY: top,
                maxY: top + object.height
            };
            return location;
        }
        else {
            return null;
        }
    }
    deallocate(objectLocation) {
        const shelf = this._shelves.get(objectLocation.minY);
        if (shelf) {
            shelf.deallocate(objectLocation.minX);
        }
    }
    isAllocated(objectLocation) {
        const shelf = this._shelves.get(objectLocation.minY);
        return !!shelf && shelf.isAllocated(objectLocation.minX);
    }
    resize(width, height) {
        this._shelfAllocator.extend(height);
        for (const shelf of this._shelves.values()) {
            shelf.resize(width);
        }
        this.width = width;
        this.height = height;
    }
}


/***/ }),
/* 151 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArenaAllocator", function() { return ArenaAllocator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FreeListAllocator", function() { return FreeListAllocator; });
/* harmony import */ var _binary_tree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(152);
/* harmony import */ var _linked_set__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(153);


/**
 * Alignes an offset so it's a multiple of an alignment.
 *
 * @param offset The offset.
 * @param alignment The alignment.
 * @returns Aligned offset.
 */
function align(offset, alignment) {
    return alignment * Math.ceil(offset / alignment);
}
class ArenaAllocator {
    /**
     * Constructs a new empty arena allocator.
     *
     * @param size Size of managed region.
     * @param alignment alignment of offsets.
     */
    constructor(size, alignment = 1) {
        this._size = size;
        this._alignment = alignment;
        this._freeOffset = 0;
        this._allocatedOffsets = new Set();
    }
    get size() {
        return this._size;
    }
    get maxAllocableSize() {
        return this._size - this._freeOffset;
    }
    get isEmpty() {
        return this._allocatedOffsets.size === 0;
    }
    allocate(size) {
        if (this._size >= this._freeOffset + size) {
            const offset = this._freeOffset;
            this._freeOffset = align(offset + size, this._alignment);
            this._allocatedOffsets.add(offset);
            return offset;
        }
        else {
            return -1;
        }
    }
    deallocate(offset) {
        this._allocatedOffsets.delete(offset);
    }
    isAllocated(offset) {
        return offset < this._freeOffset;
    }
    extend(newSize) {
        if (newSize < this._freeOffset) {
            throw new Error('Could not reduce the size because it conflicts with already allocated region.');
        }
        this._size = newSize;
    }
}
/**
 * Allocator optimised for both primary operations: allocation and deallocation. It uses BST for efficient lookup of
 * suitable free region during allocation and two way linked list for fast adjacent free regions merge.
 * Max allocable size is also determined by means of the BST.
 */
class FreeListAllocator {
    constructor(size) {
        this._size = size;
        this._allRegions = new _linked_set__WEBPACK_IMPORTED_MODULE_1__["default"]();
        this._occupiedRegions = new Map();
        this._freeRegions = new _binary_tree__WEBPACK_IMPORTED_MODULE_0__["BinarySearchTree"]((rangeA, rangeB) => rangeA.size - rangeB.size);
        const initRegion = { offset: 0, size };
        this._allRegions.insert(initRegion);
        initRegion._freeNode = this._freeRegions.insert(initRegion);
    }
    get size() {
        return this._size;
    }
    get maxAllocableSize() {
        const max = this._freeRegions.max;
        return max ? max.size : 0;
    }
    get isEmpty() {
        return this._occupiedRegions.size === 0;
    }
    allocate(size) {
        const node = this._findMinSuitable(size);
        if (!node) {
            return -1;
        }
        const range = node.value;
        // current region is not available anymore
        // it is removed from the free regions pool
        this._freeRegions.remove(node);
        // new occupied one is created
        const occupiedRange = { offset: range.offset, size };
        this._occupiedRegions.set(range.offset, occupiedRange);
        this._allRegions.insertAfter(range, occupiedRange);
        this._allRegions.remove(range);
        // dont loose remaining if any
        // it should be returned back to the free regions pool
        if (range.size > size) {
            const remainingRange = { offset: range.offset + size, size: range.size - size };
            remainingRange._freeNode = this._freeRegions.insert(remainingRange);
            this._allRegions.insertAfter(occupiedRange, remainingRange);
        }
        return occupiedRange.offset;
    }
    deallocate(offset) {
        let region = this._occupiedRegions.get(offset);
        if (region) {
            // check if the region can be merged with its previous neighbor
            const prev = this._allRegions.getPrev(region);
            if (prev && prev._freeNode) {
                const embracingRange = { offset: prev.offset, size: prev.size + region.size };
                this._allRegions.insertAfter(prev, embracingRange);
                this._allRegions.remove(region);
                this._allRegions.remove(prev);
                this._freeRegions.remove(prev._freeNode);
                region = embracingRange;
            }
            // check if the region can be merged with its next neighbor
            const next = this._allRegions.getNext(region);
            if (next && next._freeNode) {
                const embracingRange = { offset: region.offset, size: region.size + next.size };
                this._allRegions.insertBefore(next, embracingRange);
                this._allRegions.remove(region);
                this._allRegions.remove(next);
                this._freeRegions.remove(next._freeNode);
                region = embracingRange;
            }
            this._occupiedRegions.delete(offset);
            region._freeNode = this._freeRegions.insert(region);
        }
    }
    isAllocated(offset) {
        return this._occupiedRegions.has(offset);
    }
    extend(newSize) {
        if (newSize < this._size) {
            throw new Error('Size reducing is not allowed in free list allocator');
        }
        const diff = newSize - this._size;
        const last = this._allRegions.end;
        if (last && last._freeNode) {
            this._freeRegions.remove(last._freeNode);
            const region = { offset: last.offset, size: last.size + diff, isFree: true };
            this._allRegions.insertAfter(last, region);
            this._allRegions.remove(last);
            this._freeRegions.insert(region);
        }
        else {
            const region = { offset: this._size, size: diff, isFree: true };
            this._allRegions.insert(region);
            this._freeRegions.insert(region);
        }
        this._size = newSize;
    }
    /**
     * Traverses BST to find the smallest region required size can fit.
     */
    _findMinSuitable(size) {
        let node = this._freeRegions.root;
        let best;
        while (node) {
            if (node.value.size === size) {
                best = node;
                break;
            }
            else if (node.value.size < size) {
                node = node.right;
            }
            else {
                best = node;
                node = node.left;
            }
        }
        return best;
    }
}


/***/ }),
/* 152 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BinarySearchTree", function() { return BinarySearchTree; });
/**
 * Simple implementation of Binary Search Tree.
 */
class BinarySearchTree {
    /**
     * @param comparator To specify the order of items, that can be any complex objects.
     */
    constructor(comparator) {
        this._comparator = comparator;
        this._size = 0;
    }
    /**
     * @returns The root element or `undefined` if the tree is empty.
     */
    get root() {
        return this._root;
    }
    /**
     * @returns The number of items in the tree.
     */
    get size() {
        return this._size;
    }
    /**
     * @returns The smallest element in the tree or `undefined` the the tree is empty.
     */
    get min() {
        if (this._root) {
            return this._min(this._root).value;
        }
        return undefined;
    }
    /**
     * @returns The biggest element in the tree or `undefined` the the tree is empty.
     */
    get max() {
        if (this._root) {
            return this._max(this._root).value;
        }
        return undefined;
    }
    insert(item) {
        this._size++;
        if (!this._root) {
            this._root = { value: item };
            return this._root;
        }
        let node = this._root;
        while (node) {
            if (this._comparator(item, node.value) < 0) {
                if (!node.left) {
                    return node.left = { parent: node, value: item };
                }
                node = node.left;
            }
            else {
                if (!node.right) {
                    return node.right = { parent: node, value: item };
                }
                node = node.right;
            }
        }
        // impossible to get there, throwing is to make TS analizator happy
        throw new Error();
    }
    remove(node) {
        this._size--;
        if (node.left && node.right) {
            const successor = this._min(node.right);
            this._replaceSubtree(node, successor);
            // update links to children of the removed node
            if (node.left) {
                successor.left = node.left;
                node.left.parent = successor;
            }
            if (node.right) {
                successor.right = node.right;
                node.right.parent = successor;
            }
        }
        else if (node.left) {
            this._replaceSubtree(node, node.left);
        }
        else if (node.right) {
            this._replaceSubtree(node, node.right);
        }
        else {
            this._replaceSubtree(node, undefined);
        }
    }
    /**
     * Iterates elements in ascending order.
     */
    *values(node) {
        if (node) {
            yield* this.values(node.left);
            yield node.value;
            yield* this.values(node.right);
        }
    }
    /**
     * Iterates elements in ascending order.
     */
    [Symbol.iterator]() {
        return this.values(this._root);
    }
    _min(from) {
        let node = from;
        while (node.left) {
            node = node.left;
        }
        return node;
    }
    _max(from) {
        let node = from;
        while (node.right) {
            node = node.right;
        }
        return node;
    }
    /**
     * Reorganizes the tree structure so that the replacement node takes replaceable's position, the latter is removed.
     */
    _replaceSubtree(replaceable, replacement) {
        if (replaceable.parent) {
            if (replaceable.parent.left === replaceable) {
                replaceable.parent.left = replacement;
            }
            else if (replaceable.parent.right === replaceable) {
                replaceable.parent.right = replacement;
            }
        }
        else {
            this._root = replacement;
        }
        if (replacement) {
            // remove replacement from its current location
            if (replacement.parent) {
                if (replacement.parent.left === replacement) {
                    replacement.parent.left = undefined;
                }
                else if (replacement.parent.right === replacement) {
                    replacement.parent.right = undefined;
                }
            }
            replacement.parent = replaceable.parent;
        }
    }
}


/***/ }),
/* 153 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LinkedSet; });
/**
 * Set with predictable iteration order. Stores items as a two way linked list thus allowing to insert items in between.
 */
class LinkedSet {
    constructor() {
        this._nodes = new Map();
    }
    get begin() {
        return this._begin && this._begin.value;
    }
    get end() {
        return this._end && this._end.value;
    }
    /**
     * Inserts a new item at the end of the set.
     */
    insert(item) {
        if (!this._nodes.has(item)) {
            const node = { value: item };
            if (this._end) {
                this.insertAfter(this._end.value, item);
            }
            else {
                this._begin = this._end = node;
                this._nodes.set(item, node);
            }
        }
    }
    /**
     * Inserts a new item before the specified one. If the before item is not in the set or
     * the item is already inserted nothing happens.
     */
    insertBefore(before, item) {
        const beforeNode = this._nodes.get(before);
        if (beforeNode && !this._nodes.has(item)) {
            const node = { value: item };
            if (beforeNode.prev) {
                beforeNode.prev.next = node;
                node.prev = beforeNode.prev;
            }
            node.next = beforeNode;
            beforeNode.prev = node;
            this._nodes.set(item, node);
            if (beforeNode === this._begin) {
                this._begin = node;
            }
        }
    }
    /**
     * Inserts a new item after the specified one. If the after item is not in the set or
     * the item is already inserted nothing happens.
     */
    insertAfter(after, item) {
        const afterNode = this._nodes.get(after);
        if (afterNode && !this._nodes.has(item)) {
            const node = { value: item };
            if (afterNode.next) {
                afterNode.next.prev = node;
                node.next = afterNode.next;
            }
            node.prev = afterNode;
            afterNode.next = node;
            this._nodes.set(item, node);
            if (afterNode === this._end) {
                this._end = node;
            }
        }
    }
    /**
     * Removes item from the set.
     */
    remove(item) {
        const node = this._nodes.get(item);
        if (node) {
            if (node === this._begin) {
                this._begin = node.next;
            }
            if (node === this._end) {
                this._end = node.prev;
            }
            if (node.next) {
                node.next.prev = node.prev;
            }
            if (node.prev) {
                node.prev.next = node.next;
            }
            this._nodes.delete(item);
        }
    }
    /**
     * @returns `undefined` if the item is not in the set or it is the first elements.
     */
    getPrev(item) {
        const node = this._nodes.get(item);
        if (node && node.prev) {
            return node.prev.value;
        }
        return undefined;
    }
    /**
     * @returns `undefined` if the item is not in the set or it is the last elements.
     */
    getNext(item) {
        const node = this._nodes.get(item);
        if (node && node.next) {
            return node.next.value;
        }
        return undefined;
    }
    /**
     * Iterates over the set from the fist element to the last (in the order of insertion
     * if the insert method was used only).
     */
    *values() {
        let node = this._begin;
        while (node) {
            yield node.value;
            node = node.next;
        }
    }
    /**
     * Iterates over the set from the fist element to the last (in the order of insertion
     * if the insert method was used only).
     */
    [Symbol.iterator]() {
        return this.values();
    }
}


/***/ }),
/* 154 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return VisibilityManager; });
/* harmony import */ var _render_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);
/* harmony import */ var _util_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(11);
/* harmony import */ var _math_vector2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(23);
/* harmony import */ var _math_vector3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(20);
/* harmony import */ var _math_matrix4__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(19);
/* harmony import */ var _grid_sampler_buffer_writer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(155);
/* harmony import */ var _util_event_emitter__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(14);
/* harmony import */ var _grid_renderer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(156);
/* harmony import */ var _visibility_resolution_steps_reset_removed_primitives__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(157);
/* harmony import */ var _visibility_resolution_steps_fadeout_all__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(158);
/* harmony import */ var _visibility_resolution_steps_fadein_visible__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(162);
/* harmony import */ var _visibility_resolution_steps_fadeout_overlapped__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(165);
/* harmony import */ var _render_util_camera_position__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(168);
/* harmony import */ var _util_hd__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(48);














const FADING_STOPPED = -1;
const DEFAULT_FADE_EFFECT_DURATION = 150;
const ID_COMPONENT_SIZE = 256;
const VISIBILITY_INIT_STATE = new _render_state__WEBPACK_IMPORTED_MODULE_0__["default"]({
    clearColor: _util_color__WEBPACK_IMPORTED_MODULE_1__["create"](0, 0, 0, 0),
    dither: false
});
const EMPTY_GRID_CELL = _util_color__WEBPACK_IMPORTED_MODULE_1__["create"](0, 0, 0, 1);
const DIRECT_PRIORITY_GRID_STATE = new _render_state__WEBPACK_IMPORTED_MODULE_0__["default"]({
    clearColor: EMPTY_GRID_CELL,
    depthTest: true,
    clearDepth: 0,
    // primitives with equal priority are resolved as following: later ones overlap previous
    depthFunc: 518 /* GREATER_OR_EQUAL */,
    dither: false
});
const REVERSE_PRIORITY_GRID_STATE = new _render_state__WEBPACK_IMPORTED_MODULE_0__["default"]({
    clearColor: EMPTY_GRID_CELL,
    depthTest: true,
    clearDepth: 1,
    depthFunc: 513 /* LESS */,
    dither: false
});
// size of minimal recognizable square side in css pixels.
const GRID_PRECISION_PX = 6;
/**
 * Apart from being removed from scene there are other reasons for primitives to be invisible: e.g. they are
 * overlapped by primitives with higher priority. This state is highly dynamic, primitives may be of different types,
 * from different sources and they can have quite non-trivial shapes. So there should be a single point of collision
 * resolution for all primitives in scene, that is what visibility manager is.
 *
 * Visibility of primitives is calculated every frame. To support fade-in/out animation visibility value is a factor
 * the alpha channel of a finally rendered primitive is to be multiplied by (value from 0.0 to 1.0). For instance,
 * if an object is just appeared on the scene, this factor will be changed from 0.0 to 1.0 in fadeEffectDurationMs ms.
 * There are 4 steps the whole process can be roughly summarized into:
 *  1. actualization - reset values for removed from scene primitives
 *  2. fade-out all - even though all primitives are faded out at this step, this step is intended for invisible
 *     primitives to animate them disappearing.
 *  3. fade-in visible - check which primitive are visible and increase its alpha visibility value.
 *  4. fade-out overlapped - find overlaps by comparing corresponding pixels of the scene rendered in direct and
 *     reverse priority orders.
 *
 *  Due to the fact that we use grid with finite precision there are some cases where this approach produces
 *  unpleasant artifacts (blinking). To cope with it stability shift and storing zoom of the first overlap are
 *  introduced, but it works well for non-tilted map only.
 */
class VisibilityManager {
    constructor(context, camera, renderLoop, targetWidth, targetHeight, fadeEffectDuration = DEFAULT_FADE_EFFECT_DURATION) {
        this.onRerenderRequired = new _util_event_emitter__WEBPACK_IMPORTED_MODULE_6__["VoidEventEmitter"]();
        this.fadeEffectDuration = fadeEffectDuration;
        this._context = context;
        this._camera = camera;
        this._renderLoop = renderLoop;
        this._lastRenderTimeInLoop = FADING_STOPPED;
        this._prevTargetSize = { width: 0, height: 0 };
        this._sceneUpdateListener = this._onSceneUpdate.bind(this);
        this._camera.onUpdate.addListener(this._sceneUpdateListener);
        this._beforeRenderListener = this._onBeforeRender.bind(this);
        this._renderLoop.onBeforeRender.addListener(this._beforeRenderListener);
        this._directPriorityGridRenderer = new _grid_renderer__WEBPACK_IMPORTED_MODULE_7__["default"](context, DIRECT_PRIORITY_GRID_STATE);
        this._reversePriorityGridRenderer = new _grid_renderer__WEBPACK_IMPORTED_MODULE_7__["default"](context, REVERSE_PRIORITY_GRID_STATE);
        this._currentVisibilityTexture = context.createEmpty2DTexture(ID_COMPONENT_SIZE, ID_COMPONENT_SIZE, 6408 /* RGBA */, 5121 /* UNSIGNED_BYTE */);
        this._prevVisibilityTexture = context.createEmpty2DTexture(ID_COMPONENT_SIZE, ID_COMPONENT_SIZE, 6408 /* RGBA */, 5121 /* UNSIGNED_BYTE */);
        this._currentVisibilityBuffer = context.createFramebuffer({ color: this._currentVisibilityTexture });
        this._prevVisibilityBuffer = context.createFramebuffer({ color: this._prevVisibilityTexture });
        this._stabilityShift = _math_vector3__WEBPACK_IMPORTED_MODULE_3__["create"](0, 0, 0);
        this._gridHalfPxSizeUniform = _math_vector2__WEBPACK_IMPORTED_MODULE_2__["create"](0, 0);
        this._idHalfPxSizeUniform = _math_vector2__WEBPACK_IMPORTED_MODULE_2__["create"](0.5 / ID_COMPONENT_SIZE, 0.5 / ID_COMPONENT_SIZE);
        this._step1ResetRemoved = new _visibility_resolution_steps_reset_removed_primitives__WEBPACK_IMPORTED_MODULE_8__["default"]();
        this._step2FadeoutAll = new _visibility_resolution_steps_fadeout_all__WEBPACK_IMPORTED_MODULE_9__["default"](context);
        this._step3FadeinVisible = new _visibility_resolution_steps_fadein_visible__WEBPACK_IMPORTED_MODULE_10__["default"](context);
        this._step4FadeoutOverlapped = new _visibility_resolution_steps_fadeout_overlapped__WEBPACK_IMPORTED_MODULE_11__["default"](context);
        this._clearVisibility(this._currentVisibilityBuffer);
        this._primitiveProviders = [];
        this._colorIdRenderers = [];
        this._resetRemovedRenderers = [];
        this.setTargetSize(targetWidth, targetHeight);
    }
    get visibilityTexture() {
        return this._currentVisibilityTexture;
    }
    /**
     * To provide proper precision in collision resolution simplified grid size depends on the render target,
     * that can be changed at run time (e.g. the user resizes browser window). A lot of associated GL resources is be
     * updated in that case.
     */
    setTargetSize(width, height) {
        const gridPrecisionTargetPx = GRID_PRECISION_PX * Object(_util_hd__WEBPACK_IMPORTED_MODULE_13__["default"])();
        const gridWidth = Math.ceil(width / gridPrecisionTargetPx);
        const gridHeight = Math.ceil(height / gridPrecisionTargetPx);
        this._directPriorityGridRenderer.setResolution(gridWidth, gridHeight);
        this._reversePriorityGridRenderer.setResolution(gridWidth, gridHeight);
        if (this._gridSamplerVertexBuffer) {
            this._destroyGridResources();
        }
        const overlapSamplerBufferWriter = new _grid_sampler_buffer_writer__WEBPACK_IMPORTED_MODULE_5__["default"](gridWidth, gridHeight);
        const context = this._context;
        this._gridSamplerVertexBuffer = context.createVertexBuffer(overlapSamplerBufferWriter.data.byteLength);
        this._gridSamplerVao = context.createVao(_grid_sampler_buffer_writer__WEBPACK_IMPORTED_MODULE_5__["ATTRIBUTE_MAPPING"], this._gridSamplerVertexBuffer, null);
        this._numberOfGridSamplers = overlapSamplerBufferWriter.numberOfSamplers;
        this._context.uploadDataToBuffer(this._gridSamplerVertexBuffer, overlapSamplerBufferWriter.data);
        this._prevTargetSize.width = width;
        this._prevTargetSize.height = height;
        this._gridHalfPxSizeUniform.x = 0.5 / gridWidth;
        this._gridHalfPxSizeUniform.y = 0.5 / gridHeight;
    }
    /**
     * Recalculates visibility of all colliding primitives in scene.
     *
     * @param target The target the scene is to be rendered into.
     * @param uniforms Set of precalculated uniforms global for current frame.
     * @returns Updated texture with visibility values for all primitives.
     */
    updateVisibilityIfNeeded() {
        if (!this._isDirty) {
            return;
        }
        this._isDirty = false;
        // Rasterization may be not stable in the sense of the shape of pixels occupied by particular object when this
        // object gets shifted (e.g. the user drags the center of the map) and since collisions are detected by
        // overlapped pixels this fact can lead to blinking (found overlapping in one frame/not found in the next/etc).
        // For those objects (and their positions) that are not distorted by perspective it can be fixed by
        // introducing a shift that takes into account the amount of drag and forces vertices to be displaced in the
        // same position in grid's cell.
        const shift = this._stabilityShift;
        _math_vector2__WEBPACK_IMPORTED_MODULE_2__["copy"](this._camera.center, shift);
        shift.z = 0;
        _math_matrix4__WEBPACK_IMPORTED_MODULE_4__["apply"](this._camera.getViewProjMatrix(), shift, shift);
        // NDC (-1 : 1) are 2 times larger than texture coordinates (0 : 1)
        shift.x %= 4 * this._gridHalfPxSizeUniform.x;
        shift.y %= 4 * this._gridHalfPxSizeUniform.y;
        const prevTexture = this._prevVisibilityTexture;
        const prevFramebuffer = this._prevVisibilityBuffer;
        const currentTexture = this._currentVisibilityTexture;
        const currentFramebuffer = this._currentVisibilityBuffer;
        this._clearVisibility(prevFramebuffer);
        // on this step
        this._step1ResetRemoved.render(prevFramebuffer, this._resetRemovedRenderers, currentTexture, this._idHalfPxSizeUniform);
        // pass zoom as a value between 0.0 and 1.0, as absolute value is not important
        const zoom = this._camera.zoom / this._camera.options.maxZoom;
        const viewProjMatrix = this._camera.getViewProjMatrix();
        const cameraPositions = Object(_render_util_camera_position__WEBPACK_IMPORTED_MODULE_12__["calculateCameraPositions"])(this._camera);
        const directPriorityGrid = this._directPriorityGridRenderer.updateGrid(viewProjMatrix, cameraPositions, this._colorIdRenderers, shift, prevTexture, zoom);
        const reversePriorityGrid = this._reversePriorityGridRenderer.updateGrid(viewProjMatrix, cameraPositions, this._colorIdRenderers, shift, prevTexture, zoom);
        const now = performance.now();
        const lastRendering = this._lastRenderTimeInLoop;
        const isAnimationFinished = (now - this._lastSceneUpdateTime) > this.fadeEffectDuration;
        const wasAnimationActive = lastRendering !== FADING_STOPPED;
        const fadeEffect = isAnimationFinished ?
            1.0 : wasAnimationActive ? (now - lastRendering) / this.fadeEffectDuration : 0;
        const idHalfPx = this._idHalfPxSizeUniform;
        const samplerVao = this._gridSamplerVao;
        const numberOfSamplers = this._numberOfGridSamplers;
        this._clearVisibility(currentFramebuffer);
        this._step2FadeoutAll.render(currentFramebuffer, prevTexture, fadeEffect);
        this._step3FadeinVisible.render(currentFramebuffer, samplerVao, numberOfSamplers, directPriorityGrid, prevTexture, idHalfPx, fadeEffect);
        this._step4FadeoutOverlapped.render(currentFramebuffer, samplerVao, numberOfSamplers, directPriorityGrid, reversePriorityGrid, prevTexture, idHalfPx, fadeEffect, zoom);
        // check if we need one more rendering to finish animation
        if (isAnimationFinished) {
            // no more renderings needed for fade effect, its timestamp is marked with special value
            // to take it into account during next fade effect amount calculation
            this._lastRenderTimeInLoop = FADING_STOPPED;
        }
        else {
            this._renderLoop.update();
            this._lastRenderTimeInLoop = now;
        }
    }
    registerCollidingPrimitives(primitiveProvider, colorIdRenderer, resetRemoveRenderer) {
        this._primitiveProviders.push(primitiveProvider);
        this._colorIdRenderers.push(colorIdRenderer);
        this._resetRemovedRenderers.push(resetRemoveRenderer);
        primitiveProvider.onUpdate.addListener(this._sceneUpdateListener);
    }
    deregisterCollidingPrimitives(primitiveProvider, colorIdRenderer, resetRemoveRenderer) {
        let index = this._primitiveProviders.indexOf(primitiveProvider);
        if (index > -1) {
            this._primitiveProviders.splice(index, 1);
        }
        index = this._colorIdRenderers.indexOf(colorIdRenderer);
        if (index > -1) {
            this._colorIdRenderers.splice(index, 1);
        }
        index = this._resetRemovedRenderers.indexOf(resetRemoveRenderer);
        if (index > -1) {
            this._resetRemovedRenderers.splice(index, 1);
        }
        primitiveProvider.onUpdate.removeListener(this._sceneUpdateListener);
    }
    destroy() {
        this._destroyGridResources();
        this._directPriorityGridRenderer.destroy();
        this._reversePriorityGridRenderer.destroy();
        this._camera.onUpdate.removeListener(this._sceneUpdateListener);
        for (const primitiveProvider of this._primitiveProviders) {
            primitiveProvider.onUpdate.removeListener(this._sceneUpdateListener);
        }
    }
    _onSceneUpdate() {
        this._lastSceneUpdateTime = performance.now();
        this._renderLoop.update();
    }
    _onBeforeRender() {
        this._isDirty = true;
    }
    /**
     * Resets visibility texture to its initial state.
     */
    _clearVisibility(target) {
        this._context.bindRenderState(VISIBILITY_INIT_STATE);
        this._context.bindRenderTarget(target);
        this._context.clearCurrentTarget(16384 /* COLOR_BUFFER_BIT */);
    }
    _destroyGridResources() {
        this._gridSamplerVertexBuffer.destroy();
        this._gridSamplerVao.destroy();
    }
}


/***/ }),
/* 155 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ATTRIBUTE_MAPPING", function() { return ATTRIBUTE_MAPPING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GridSamplerBufferWriter; });
/* harmony import */ var _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _util_buffer_writer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(36);
/* harmony import */ var _util_gputypes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(37);



const ATTRIBUTE_MAPPING = new _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__["AttributeMapping"]([
    [
        0 /* POSITION */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ]
]);
/**
 * Writes sampler positions into vertex buffer as a regular grid with the step equal to the size of a grid cell.
 * The number of vertices (samplers) is equal to "width x height".
 */
class GridSamplerBufferWriter extends _util_buffer_writer__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor(width, height) {
        const numberOfSamplers = width * height;
        super(ATTRIBUTE_MAPPING.vertexByteSize, numberOfSamplers, undefined, 0);
        const colStep = Object(_util_gputypes__WEBPACK_IMPORTED_MODULE_2__["floatToUint16"])(1.0 / width);
        const rowStep = Object(_util_gputypes__WEBPACK_IMPORTED_MODULE_2__["floatToUint16"])(1.0 / height);
        const colHalfStep = colStep / 2;
        const rowHalfStep = rowStep / 2;
        for (let i = 0, col = colHalfStep; i < width; i++, col += colStep) {
            for (let j = 0, row = rowHalfStep; j < height; j++, row += rowStep) {
                this._writeHalfWords(col, row);
            }
        }
        this.data = this.getBuffers()[0].vertexBuffer;
        this.numberOfSamplers = numberOfSamplers;
    }
}


/***/ }),
/* 156 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GridRenderer; });
/* harmony import */ var _render_gl_renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(101);

class GridRenderer extends _render_gl_renderer__WEBPACK_IMPORTED_MODULE_0__["GlRenderer"] {
    constructor(context, renderState) {
        super(context, renderState);
    }
    updateGrid(...args) {
        this.render(this._target, ...args);
        return this._texture;
    }
    _render(viewProjMatrix, cameraPositions, renderers, stabilityShift, prevVisibility, currentZoom) {
        for (const renderer of renderers) {
            renderer.render(this._target, viewProjMatrix, cameraPositions, this._renderState, stabilityShift, prevVisibility, currentZoom);
        }
    }
    /**
     * Updates resolution of the grid.
     */
    setResolution(width, height) {
        this._destroyResources();
        this._depthBuffer = this._context.createRenderbuffer(width, height, 34041 /* DEPTH_STENCIL */);
        this._texture = this._context.createEmpty2DTexture(width, height, 6408 /* RGBA */, 5121 /* UNSIGNED_BYTE */);
        this._target = this._context.createFramebuffer({ color: this._texture, depthStencil: this._depthBuffer });
    }
    destroy() {
        this._destroyResources();
    }
    _prepareRenderTarget(target, ...args) {
        super._prepareRenderTarget(target, ...args);
        this._context.clearCurrentTarget(16384 /* COLOR_BUFFER_BIT */ | 256 /* DEPTH_BUFFER_BIT */);
    }
    _destroyResources() {
        if (this._target) {
            this._target.destroy();
            this._texture.destroy();
            this._depthBuffer.destroy();
        }
    }
}


/***/ }),
/* 157 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ResetRemovedPrimitives; });
/**
 * One of the steps of primitives visibility resolution process. Basically it does nothing, just call appropriate
 * methods of CollidingPrimitiveRenderer's, but it expects that these renderers will copy visibility value of actual
 * primitives only, thus removed primitive's values will be reset (overlap zoom cleared and all that). It is important
 * for reusing these ids for future primitives.
 */
class ResetRemovedPrimitives {
    render(target, renderers, prevVisibility, idHalfPxSizeUniform) {
        for (const renderer of renderers) {
            renderer.render(target, prevVisibility, idHalfPxSizeUniform);
        }
    }
}


/***/ }),
/* 158 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return FadeoutAll; });
/* harmony import */ var _shaders_fadeout_all_vert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(159);
/* harmony import */ var _shaders_fadeout_all_vert__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_shaders_fadeout_all_vert__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _shaders_fadeout_all_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(160);
/* harmony import */ var _shaders_fadeout_all_frag__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_shaders_fadeout_all_frag__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _render_gl_renderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(101);
/* harmony import */ var _render_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(10);
/* harmony import */ var _id_sampler_buffer_writer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(161);





const STATE = new _render_state__WEBPACK_IMPORTED_MODULE_3__["default"]({
    dither: false
});
/**
 * One of the steps of primitives visibility resolution process. It samples all visibility values and subtract
 * delta (fadeoutAmount) from them, these new values are stored into current visibility texture.
 */
class FadeoutAll extends _render_gl_renderer__WEBPACK_IMPORTED_MODULE_2__["GlRenderer"] {
    constructor(context) {
        const program = context.createProgram(_shaders_fadeout_all_vert__WEBPACK_IMPORTED_MODULE_0___default.a, _shaders_fadeout_all_frag__WEBPACK_IMPORTED_MODULE_1___default.a, {
            attribMap: {
                position: 0 /* POSITION */
            }
        });
        super(context, STATE, program);
        const idSamplerBufferWriter = new _id_sampler_buffer_writer__WEBPACK_IMPORTED_MODULE_4__["default"]();
        this._idSamplerVertexBuffer = this._context.createVertexBuffer(idSamplerBufferWriter.vertexData.byteLength);
        this._idSamplerIndexBuffer = this._context.createIndexBuffer(idSamplerBufferWriter.indexData.byteLength);
        this._idSamplerVao = this._context.createVao(_id_sampler_buffer_writer__WEBPACK_IMPORTED_MODULE_4__["ATTRIBUTE_MAPPING"], this._idSamplerVertexBuffer, this._idSamplerIndexBuffer);
        this._context.uploadDataToBuffer(this._idSamplerVertexBuffer, idSamplerBufferWriter.vertexData);
        this._context.uploadDataToBuffer(this._idSamplerIndexBuffer, idSamplerBufferWriter.indexData);
        context.bindProgram(program);
        program.setIntScalarUniform('prevVisibility', 0);
    }
    _prepareProgram(program, prevVisibility, fadeoutAmount) {
        super._prepareProgram(program, prevVisibility, fadeoutAmount);
        this._context.bindTextureUnit(0);
        this._context.bindTexture(prevVisibility);
        program.setScalarUniform('fadeoutAmount', fadeoutAmount);
    }
    _render() {
        this._context.bindVao(this._idSamplerVao);
        this._context.drawIndexedMesh(0, 6, 4 /* TRIANGLES */);
    }
}


/***/ }),
/* 159 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec4 position;\n\nvarying vec2 idTexCoordinates;\n\nvoid main() {\n    gl_Position = vec4(position.xy, 0, 1);\n    idTexCoordinates = position.zw;\n}\n"

/***/ }),
/* 160 */
/***/ (function(module, exports) {

module.exports = "#version 100\n\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform sampler2D prevVisibility;\nuniform float fadeoutAmount;\n\nvarying vec2 idTexCoordinates;\n\nvoid main() {\n    vec4 visibilityValue = texture2D(prevVisibility, idTexCoordinates);\n    visibilityValue.a = clamp(visibilityValue.a - fadeoutAmount, 0.0, 1.0);\n\n    gl_FragColor = visibilityValue;\n}\n"

/***/ }),
/* 161 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ATTRIBUTE_MAPPING", function() { return ATTRIBUTE_MAPPING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return IdSamplerBufferWriter; });
/* harmony import */ var _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _util_buffer_writer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(36);


const ATTRIBUTE_MAPPING = new _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__["AttributeMapping"]([
    [
        0 /* POSITION */,
        {
            size: 4,
            type: 5120 /* BYTE */,
            normalized: false
        }
    ]
]);
/**
 * Write vertices of two triangles that fully cover visibility texture, its values can be sampled in fragment shaders.
 */
class IdSamplerBufferWriter extends _util_buffer_writer__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor() {
        super(ATTRIBUTE_MAPPING.vertexByteSize, 4, 4, 6);
        // window x, window y, texture x, texture y
        this._writeBytes(-1, -1, 0, 0);
        this._writeBytes(-1, 1, 0, 1);
        this._writeBytes(1, 1, 1, 1);
        this._writeBytes(1, -1, 1, 0);
        this.writeIndicesForFan([0, 1, 2, 3]);
        this.vertexData = this.getBuffers()[0].vertexBuffer;
        this.indexData = this.getBuffers()[0].indexBuffer;
    }
}


/***/ }),
/* 162 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return FadeinVisible; });
/* harmony import */ var _render_gl_renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(101);
/* harmony import */ var _shaders_fadein_visible_vert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(163);
/* harmony import */ var _shaders_fadein_visible_vert__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_shaders_fadein_visible_vert__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _shaders_fadein_visible_frag__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(164);
/* harmony import */ var _shaders_fadein_visible_frag__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_shaders_fadein_visible_frag__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _render_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(10);




const STATE = new _render_state__WEBPACK_IMPORTED_MODULE_3__["default"]({
    dither: false
});
/**
 * One of the steps of primitives visibility resolution process. It samples all pixels of the scene (rendered in direct
 * priority order into simplified grid) and adds delta (fadeinAmount) to alpha visibility of primitive with
 * id in this pixel. Those primitives are considered visible.
 */
class FadeinVisible extends _render_gl_renderer__WEBPACK_IMPORTED_MODULE_0__["GlRenderer"] {
    constructor(context) {
        const program = context.createProgram(_shaders_fadein_visible_vert__WEBPACK_IMPORTED_MODULE_1___default.a, _shaders_fadein_visible_frag__WEBPACK_IMPORTED_MODULE_2___default.a, {
            attribMap: {
                position: 0 /* POSITION */
            }
        });
        super(context, STATE, program);
        context.bindProgram(program);
        program.setIntScalarUniform('directPriorityGrid', 0);
        program.setIntScalarUniform('prevVisibility', 1);
    }
    _prepareProgram(program, data, samplers, directPriorityGrid, prevVisibility, idHalfPxSize, fadeinAmount) {
        super._prepareProgram(program, data, samplers, directPriorityGrid, prevVisibility, idHalfPxSize, fadeinAmount);
        this._context.bindTextureUnit(0);
        this._context.bindTexture(directPriorityGrid);
        this._context.bindTextureUnit(1);
        this._context.bindTexture(prevVisibility);
        program.setVector2Uniform('idHalfPxSize', idHalfPxSize);
        program.setScalarUniform('fadeinAmount', fadeinAmount);
    }
    _render(data, numberOfSamplers) {
        this._context.bindVao(data);
        this._context.drawMesh(0, numberOfSamplers, 0 /* POINTS */);
    }
}


/***/ }),
/* 163 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec2 position;\n\nuniform sampler2D directPriorityGrid;\nuniform sampler2D prevVisibility;\nuniform vec2 idHalfPxSize;\nuniform float fadeinAmount;\n\nvarying lowp vec4 visibilityValue;\n\nconst vec2 NO_ID = vec2(0, 0);\nconst vec4 DISCARD_POSITION = vec4(2, 2, 2, 1);\n\nvoid main() {\n    vec2 primitiveId = texture2D(directPriorityGrid, position).rg;\n\n    if (primitiveId != NO_ID) {\n        vec2 idTexCoordinates = primitiveId + idHalfPxSize;\n        vec4 idWindowCoordinates = vec4(idTexCoordinates * 2.0 - 1.0, 0, 1);\n        gl_Position = idWindowCoordinates;\n        gl_PointSize = 1.0;\n\n        visibilityValue = texture2D(prevVisibility, idTexCoordinates);\n        visibilityValue.a = clamp(visibilityValue.a + fadeinAmount, 0.0, 1.0);\n    } else {\n        gl_Position = DISCARD_POSITION;\n    }\n}\n"

/***/ }),
/* 164 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nvarying lowp vec4 visibilityValue;\n\nvoid main() {\n    gl_FragColor = visibilityValue;\n}\n"

/***/ }),
/* 165 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return FadeoutOverlapped; });
/* harmony import */ var _render_gl_renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(101);
/* harmony import */ var _shaders_fadeout_overlapped_vert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(166);
/* harmony import */ var _shaders_fadeout_overlapped_vert__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_shaders_fadeout_overlapped_vert__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _shaders_fadeout_overlapped_frag__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(167);
/* harmony import */ var _shaders_fadeout_overlapped_frag__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_shaders_fadeout_overlapped_frag__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _render_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(10);




const STATE = new _render_state__WEBPACK_IMPORTED_MODULE_3__["default"]({ dither: false });
class FadeoutOverlapped extends _render_gl_renderer__WEBPACK_IMPORTED_MODULE_0__["GlRenderer"] {
    constructor(context) {
        const program = context.createProgram(_shaders_fadeout_overlapped_vert__WEBPACK_IMPORTED_MODULE_1___default.a, _shaders_fadeout_overlapped_frag__WEBPACK_IMPORTED_MODULE_2___default.a, {
            attribMap: {
                position: 0 /* POSITION */
            }
        });
        super(context, STATE, program);
        context.bindProgram(program);
        program.setIntScalarUniform('directPriorityGrid', 0);
        program.setIntScalarUniform('reversePriorityGrid', 1);
        program.setIntScalarUniform('prevVisibility', 2);
    }
    _prepareProgram(program, data, samplers, directPriority, reversePriority, prevVisibility, idHalfPxSize, fadeoutAmount, currentZoom) {
        super._prepareProgram(program, data, samplers, directPriority, reversePriority, prevVisibility, idHalfPxSize, fadeoutAmount, currentZoom);
        this._context.bindTextureUnit(0);
        this._context.bindTexture(directPriority);
        this._context.bindTextureUnit(1);
        this._context.bindTexture(reversePriority);
        this._context.bindTextureUnit(2);
        this._context.bindTexture(prevVisibility);
        program.setVector2Uniform('idHalfPxSize', idHalfPxSize);
        program.setScalarUniform('fadeoutAmount', fadeoutAmount);
        program.setScalarUniform('currentZoom', currentZoom);
    }
    _render(data, numberOfSamplers) {
        this._context.bindVao(data);
        this._context.drawMesh(0, numberOfSamplers, 0 /* POINTS */);
    }
}


/***/ }),
/* 166 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec2 position;\n\nuniform sampler2D directPriorityGrid;\nuniform sampler2D reversePriorityGrid;\nuniform sampler2D prevVisibility;\nuniform vec2 idHalfPxSize;\nuniform float fadeoutAmount;\nuniform float currentZoom;\n\nvarying vec4 visibilityValue;\n\nconst vec2 NO_ID = vec2(0, 0);\nconst vec4 DISCARD_POSITION = vec4(2, 2, 2, 1);\n\nvoid main() {\n    vec2 primitiveIdReversePriority = texture2D(reversePriorityGrid, position).rg;\n\n    if (\n        primitiveIdReversePriority != NO_ID &&\n        primitiveIdReversePriority != texture2D(directPriorityGrid, position).rg\n    ) {\n        vec2 idTexCoordinates = primitiveIdReversePriority + idHalfPxSize;\n        vec4 idWindowCoordinates = vec4(idTexCoordinates * 2.0 - 1.0, 0, 1);\n\n        gl_Position = idWindowCoordinates;\n        gl_PointSize = 1.0;\n\n        visibilityValue = texture2D(prevVisibility, idTexCoordinates);\n        visibilityValue.b = currentZoom;\n        visibilityValue.a = clamp(visibilityValue.a - fadeoutAmount, 0.0, 1.0);\n    } else {\n        gl_Position = DISCARD_POSITION;\n    }\n}\n"

/***/ }),
/* 167 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nvarying lowp vec4 visibilityValue;\n\nvoid main() {\n    gl_FragColor = visibilityValue;\n}\n"

/***/ }),
/* 168 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "calculateCameraPositions", function() { return calculateCameraPositions; });
/* harmony import */ var _math_vector2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(23);
/* harmony import */ var _util_gputypes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(37);
/* harmony import */ var _util_cartesian_grid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(169);
/* harmony import */ var _util_array__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(38);




// Maps world coordinates to corresponding points on the cartesian grid.
const WORLD_MIN_COORDINATE = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["create"](-1, -1);
const GRID_WORLD_RATIO = 0.5;
const GRID_COORDINATES_CONVERTER = (point) => {
    const gridCoordinates = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["copy"](point);
    _math_vector2__WEBPACK_IMPORTED_MODULE_0__["sub"](gridCoordinates, WORLD_MIN_COORDINATE, gridCoordinates);
    _math_vector2__WEBPACK_IMPORTED_MODULE_0__["muln"](gridCoordinates, GRID_WORLD_RATIO, gridCoordinates);
    return gridCoordinates;
};
const CAMERA_POSITION_UINT32_CONVERTER = (component) => 0.5 * (component + 1) * 0xffffffff;
const HIGH_COMPONENT_EXTRACTOR = (component) => Object(_util_gputypes__WEBPACK_IMPORTED_MODULE_1__["uint16ToFloat"])(Math.trunc(component / 0x10000));
const LOW_COMPONENT_EXTRACTOR = (component) => Object(_util_gputypes__WEBPACK_IMPORTED_MODULE_1__["uint16ToFloat"])(component & 0xffff);
const REGION_COMPARATOR = (a, b) => a.x - b.x || a.y - b.y;
const tmpCameraPosition = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["create"](0, 0);
/**
 * If there are multiple worlds visible (large monitors/low zoom) primitives are rendered in multiple passes from
 * different positions (if the wrap mode of corresponding direction is REPEAT) to get correct final picture.
 * This method calculates camera positions and prepare them to be passed to the render() method.
 */
const cachedRegion = [];
const cachedPositions = [];
function calculateCameraPositions(camera) {
    const visibleRegion = camera.getVisibleRegion();
    if (_util_array__WEBPACK_IMPORTED_MODULE_3__["compare"](REGION_COMPARATOR, cachedRegion, visibleRegion) === 0) {
        return cachedPositions;
    }
    const positions = [];
    for (const worldPosition of Object(_util_cartesian_grid__WEBPACK_IMPORTED_MODULE_2__["computeSquaresCoveredByConvexPolygon"])(visibleRegion.map(GRID_COORDINATES_CONVERTER))) {
        if ((camera.options.wrapModeX === 2 /* REPEAT */ || worldPosition.x === 0) &&
            (camera.options.wrapModeY === 2 /* REPEAT */ || worldPosition.y === 0)) {
            // 2.0 converts covered square position to the world's center coordinates
            // -1.0 reverses the position of the camera to shot the world from
            _math_vector2__WEBPACK_IMPORTED_MODULE_0__["muln"](worldPosition, -1.0 * 2.0, tmpCameraPosition);
            _math_vector2__WEBPACK_IMPORTED_MODULE_0__["add"](camera.center, tmpCameraPosition, tmpCameraPosition);
            _math_vector2__WEBPACK_IMPORTED_MODULE_0__["convert"](tmpCameraPosition, CAMERA_POSITION_UINT32_CONVERTER, tmpCameraPosition);
            positions.push({
                lookAtHigh: _math_vector2__WEBPACK_IMPORTED_MODULE_0__["convert"](tmpCameraPosition, HIGH_COMPONENT_EXTRACTOR),
                lookAtLow: _math_vector2__WEBPACK_IMPORTED_MODULE_0__["convert"](tmpCameraPosition, LOW_COMPONENT_EXTRACTOR)
            });
        }
    }
    _util_array__WEBPACK_IMPORTED_MODULE_3__["copy"](positions, cachedPositions);
    cachedPositions.length = positions.length;
    cachedRegion.length = visibleRegion.length;
    for (let i = 0; i < visibleRegion.length; i++) {
        cachedRegion[i] = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["copy"](visibleRegion[i], cachedRegion[i]);
    }
    return positions;
}


/***/ }),
/* 169 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "computeSquaresCoveredByConvexPolygon", function() { return computeSquaresCoveredByConvexPolygon; });
/* harmony import */ var _math_vector2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(23);


/**
 * Container of indexed min/max values with a single update method.
 */
class ExtremumStorage {
    constructor(length) {
        this._mins = new Array(length);
        this._maxs = new Array(length);
        this._mins.fill(Number.POSITIVE_INFINITY);
        this._maxs.fill(Number.NEGATIVE_INFINITY);
    }
    updateValue(index, value) {
        this._mins[index] = Math.min(this._mins[index], value);
        this._maxs[index] = Math.max(this._maxs[index], value);
    }
    *values() {
        const item = { min: 0, max: 0, index: -1 };
        for (let i = 0; i < this._mins.length; i++) {
            item.min = this._mins[i];
            item.max = this._maxs[i];
            item.index = i;
            yield item;
        }
    }
}
/**
 * Squares that are ony touched by a line (with no significant crossing an edge) should not be considered "covered".
 * It happens when a point matches the max coordinate (integer) and this case is handled here.
 */
function floorToCellCoordinate(value, maxValue) {
    return Number.isInteger(value) && maxValue === value ? value - 1 : Math.floor(value);
}
/**
 * Calculates squares covered (at least partially) by a convex polygon.
 *
 * @param points Convex polygon point coordinates (on the grid).
 * @returns List of unit square coordinates.
 */
function computeSquaresCoveredByConvexPolygon(points) {
    const result = [];
    const bbox = Object(_math_vector2__WEBPACK_IMPORTED_MODULE_0__["computeBBoxForPoints"])(points);
    const minX = Math.floor(bbox.minX);
    const xLength = Math.ceil(bbox.maxX) - minX;
    const extremums = new ExtremumStorage(xLength);
    for (let i = points.length - 1, j = 0; j < points.length; i = j++) {
        let p1 = points[i];
        let p2 = points[j];
        // go from left to right always to not handle the opposite case
        if (p1.x > p2.x) {
            const tmp = p1;
            p1 = p2;
            p2 = tmp;
        }
        // calculate from/to interval so that only "internal" integer x-es are captured
        const fromX = Math.floor(p1.x + 1);
        const toX = Math.ceil(p2.x - 1);
        const slope = (p1.y - p2.y) / (p1.x - p2.x);
        // handle terminal points separately from the "internal" ones
        extremums.updateValue(floorToCellCoordinate(p1.x, bbox.maxX) - minX, floorToCellCoordinate(p1.y, bbox.maxY));
        extremums.updateValue(floorToCellCoordinate(p2.x, bbox.maxX) - minX, floorToCellCoordinate(p2.y, bbox.maxY));
        for (let x = fromX; x <= toX; x++) {
            const yIntercept = (isFinite(slope) ? slope * (x - p1.x) : 0) + p1.y;
            const nextX = x - minX;
            const prevX = nextX - 1;
            const y = Math.floor(yIntercept);
            // check if we hit exactly the intersection of two integer coordinates
            if (Number.isInteger(yIntercept)) {
                if (yIntercept === bbox.maxY) {
                    extremums.updateValue(prevX, y - 1);
                    extremums.updateValue(nextX, y - 1);
                }
                else if (slope > 0) {
                    // two diagonal squares intersected by a line with positive slope
                    extremums.updateValue(prevX, y - 1);
                    extremums.updateValue(nextX, y);
                }
                else if (slope < 0) {
                    // two diagonal squares intersected by a line with negative slope
                    extremums.updateValue(prevX, y);
                    extremums.updateValue(nextX, y - 1);
                }
            }
            else {
                extremums.updateValue(prevX, y);
                extremums.updateValue(nextX, y);
            }
        }
    }
    for (const { min, max, index } of extremums.values()) {
        const x = minX + index;
        for (let y = min; y <= max; y++) {
            result.push(_math_vector2__WEBPACK_IMPORTED_MODULE_0__["create"](x, y));
        }
    }
    return result;
}


/***/ }),
/* 170 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "medianFilter", function() { return medianFilter; });
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _comparator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39);


/**
 * Filters an array of values with median filter.
 *
 * @param values Values to be filtered.
 * @param windowRadius How many values around a sample get into filter window.
 * @returns Array of filtered values.
 */
function medianFilter(values, windowRadius = 3) {
    const window = new Array(2 * windowRadius + 1);
    window.fill(values[0]);
    const length = values.length;
    const result = new Array(length);
    const first = values[0];
    for (let i = 0; i < windowRadius; ++i) {
        window.fill(first, 0, windowRadius - i + 1);
        Object(_array__WEBPACK_IMPORTED_MODULE_0__["copy"])(values, window, 0, i + windowRadius + 1, windowRadius - i + 1);
        window.sort(_comparator__WEBPACK_IMPORTED_MODULE_1__["NUMERICAL_COMPARATOR"]);
        result[i] = window[windowRadius];
    }
    for (let i = windowRadius; i < length - windowRadius; ++i) {
        Object(_array__WEBPACK_IMPORTED_MODULE_0__["copy"])(values, window, i - windowRadius, i + windowRadius + 1);
        window.sort(_comparator__WEBPACK_IMPORTED_MODULE_1__["NUMERICAL_COMPARATOR"]);
        result[i] = window[windowRadius];
    }
    const last = values[values.length - 1];
    for (let i = length - windowRadius; i < length; ++i) {
        Object(_array__WEBPACK_IMPORTED_MODULE_0__["copy"])(values, window, i - windowRadius, length);
        window.fill(last, values.length - i + windowRadius);
        window.sort(_comparator__WEBPACK_IMPORTED_MODULE_1__["NUMERICAL_COMPARATOR"]);
        result[i] = window[windowRadius];
    }
    return result;
}


/***/ }),
/* 171 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MainRenderUnit; });
/* harmony import */ var _list_render_unit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(172);
/* harmony import */ var _util_event_emitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(14);
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(10);
/* harmony import */ var _util_camera_position__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(168);




const FINAL_RENDER_STATE = new _state__WEBPACK_IMPORTED_MODULE_2__["default"]({
    clearDepth: 0,
    depthTest: true,
    depthFunc: 518 /* GREATER_OR_EQUAL */
});
/**
 * Root scene renderer. It generates final canvas image composing it from independent layers (LayerRenderUnit).
 */
class MainRenderUnit extends _list_render_unit__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(context, camera) {
        super();
        this._context = context;
        this._camera = camera;
        this.onRender = new _util_event_emitter__WEBPACK_IMPORTED_MODULE_1__["VoidEventEmitter"]();
    }
    render(target) {
        const viewProjMatix = this._camera.getViewProjMatrix();
        const cameraPositions = Object(_util_camera_position__WEBPACK_IMPORTED_MODULE_3__["calculateCameraPositions"])(this._camera);
        this._context.bindRenderTarget(target);
        this._context.bindRenderState(FINAL_RENDER_STATE);
        this._context.clearCurrentTarget(17664 /* ALL */);
        for (const renderer of this._subRenderUnits) {
            renderer.render(target, viewProjMatix, cameraPositions);
        }
        this.onRender.fire();
    }
}


/***/ }),
/* 172 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ListRenderUnit; });
/* harmony import */ var _util_event_emitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(14);

class NoBaseRenderUnitError extends Error {
    constructor() {
        super('Base render unit is not in the list');
    }
}
/**
 * Simple implementation of CompositeRenderUnit that just runs sub units in the order of addition.
 */
class ListRenderUnit {
    constructor() {
        this.onUpdate = new _util_event_emitter__WEBPACK_IMPORTED_MODULE_0__["VoidEventEmitter"]();
        this._subRenderUnits = [];
        this._subRenderUnitUpdateListener = this._onSubRenderUnitUpdate.bind(this);
    }
    /**
     * Adds RenderUnit to the end of the list.
     */
    addRenderUnit(subRenderUnit) {
        this._subRenderUnits.push(subRenderUnit);
        subRenderUnit.onUpdate.addListener(this._subRenderUnitUpdateListener);
    }
    /**
     * Removes RenderUnit from the list.
     */
    removeRenderUnit(subRenderUnit) {
        const index = this._subRenderUnits.indexOf(subRenderUnit);
        if (index !== -1) {
            this._subRenderUnits.splice(index, 1);
            subRenderUnit.onUpdate.removeListener(this._subRenderUnitUpdateListener);
            this.onUpdate.fire();
        }
    }
    /**
     * Adds RenderUnit above the base one. "Above" means that its render() method will be called after the base's one.
     */
    addRenderUnitAbove(base, subRenderUnit) {
        const baseIndex = this._subRenderUnits.indexOf(base);
        if (baseIndex !== -1) {
            this._subRenderUnits.splice(baseIndex + 1, 0, subRenderUnit);
            subRenderUnit.onUpdate.addListener(this._subRenderUnitUpdateListener);
        }
        else {
            throw new NoBaseRenderUnitError();
        }
    }
    /**
     * Adds RenderUnit below the base one. "Below" means that its render() method will be called before the base's one.
     */
    addRenderUnitBelow(base, subRenderUnit) {
        const baseIndex = this._subRenderUnits.indexOf(base);
        if (baseIndex !== -1) {
            this._subRenderUnits.splice(baseIndex, 0, subRenderUnit);
            subRenderUnit.onUpdate.addListener(this._subRenderUnitUpdateListener);
        }
        else {
            throw new NoBaseRenderUnitError();
        }
    }
    render(target, ...args) {
        for (const renderer of this._subRenderUnits) {
            renderer.render(target, ...args);
        }
    }
    _onSubRenderUnitUpdate() {
        this.onUpdate.fire();
    }
}


/***/ }),
/* 173 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MemoryManager; });
/* harmony import */ var _page__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(174);
/* harmony import */ var _count_vertices__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(41);
/* harmony import */ var _util_allocator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(151);



const MAX_VERTEX_COUNT = 0x10000;
// FIXME(dmikis) Let's use oversized index buffer til we sort out indices allocation
// both in writers and the manager.
const PAGE_INDEX_BUFFER_BYTE_SIZE = 0x100000;
/**
 * Memory page with the following peculiarity: once allocation is failed it gets closed for any subsequent
 * allocations. It allow to keep related primitives closer in memory.
 */
class SinglePassMemoryPage extends _page__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(vertexBuffer, indexBuffer, vao, indexType) {
        super(vertexBuffer, indexBuffer, vao, indexType, new _util_allocator__WEBPACK_IMPORTED_MODULE_2__["ArenaAllocator"](vertexBuffer.getSize()), new _util_allocator__WEBPACK_IMPORTED_MODULE_2__["ArenaAllocator"](indexBuffer.getSize()));
        this._failedAllocation = false;
    }
    allocate(vertexByteLength, indexByteLength) {
        if (this._failedAllocation) {
            return null;
        }
        const chunk = super.allocate(vertexByteLength, indexByteLength);
        this._failedAllocation = (chunk === null);
        return chunk;
    }
}
/**
 * Manager that controls GL memory allocations and pagination.[]
 */
class MemoryManager {
    /**
     * Creates a new memory manager that will allocate memory in a given context.
     *
     * @param context The context.
     */
    constructor(context) {
        this._context = context;
        this._pages = new Map();
        this._emptyPagesClearTimeout = 0;
    }
    /**
     * Allocates memory for a given data in the manager and uploads given data.
     *
     * @param vertexData Buffer with vertices that needs to be allocated.
     * @param indexData Buffer with indices that needs to be allocated.
     * @param attributeMapping Mapping of vertex attributes.
     * @returns Descriptor of the allocated memory region.
     */
    allocate(vertexData, indexData, attributeMapping) {
        const context = this._context;
        let pageSet = this._pages.get(attributeMapping);
        // If there's no pages for the given attribute mapping, create a new set.
        if (!pageSet) {
            pageSet = new Set();
            this._pages.set(attributeMapping, pageSet);
        }
        // Try to allocate data in the existing pages.
        for (const page of pageSet) {
            const memoryChunk = page.allocate(vertexData.byteLength, indexData.byteLength);
            if (memoryChunk) {
                // Success! Now we just upload the data.
                this._updatePage(page, memoryChunk, vertexData, indexData);
                return memoryChunk;
            }
        }
        // We've failed to allocate the data in any of existing pages. No worries
        // though, we just create a new one:)
        const vertexBuffer = context.createVertexBuffer(
        // some buffer writers don't use indices and MAX_VERTEX_COUNT restriction is not applied in such cases
        Math.max(MAX_VERTEX_COUNT * attributeMapping.vertexByteSize, vertexData.byteLength));
        const indexBuffer = context.createIndexBuffer(PAGE_INDEX_BUFFER_BYTE_SIZE);
        const vao = context.createVao(attributeMapping, vertexBuffer, indexBuffer);
        const page = new SinglePassMemoryPage(vertexBuffer, indexBuffer, vao, 5123 /* UNSIGNED_SHORT */);
        page.setDelegate(this);
        pageSet.add(page);
        // Here we assume we always can allocate data in an empty page.
        const memoryChunk = page.allocate(vertexData.byteLength, indexData.byteLength);
        this._updatePage(page, memoryChunk, vertexData, indexData);
        return memoryChunk;
    }
    onPageEmpty() {
        if (!this._emptyPagesClearTimeout) {
            this._emptyPagesClearTimeout = setTimeout(() => {
                this._clearEmptyPages();
                this._emptyPagesClearTimeout = 0;
            });
        }
    }
    /**
     * Destroys the manager and all its memory pages. All memory chunks that were
     * allocated in the manager become invalid.
     */
    destroy() {
        if (this._emptyPagesClearTimeout) {
            clearTimeout(this._emptyPagesClearTimeout);
        }
        for (const [, pageSet] of this._pages) {
            for (const page of pageSet) {
                page.destroy();
            }
        }
    }
    _updatePage(page, memoryChunk, vertexData, indexData) {
        const context = this._context;
        // Let's ensure that we won't break any bound VAOs.
        context.bindVao(null);
        context.uploadDataToBuffer(page.vertexBuffer, vertexData, memoryChunk.vertexByteOffset);
        // Shift indices.
        const baseIndex = Object(_count_vertices__WEBPACK_IMPORTED_MODULE_1__["countVertices"])(memoryChunk.vertexByteOffset, page.vao.attributeMapping);
        for (let i = 0; i < indexData.length; ++i) {
            indexData[i] += baseIndex;
        }
        context.uploadDataToBuffer(page.indexBuffer, indexData, memoryChunk.indexByteOffset);
    }
    _clearEmptyPages() {
        for (const pageSet of this._pages.values()) {
            for (const page of pageSet) {
                if (page.isEmpty()) {
                    pageSet.delete(page);
                    page.setDelegate(null);
                    page.destroy();
                }
            }
        }
    }
}


/***/ }),
/* 174 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MemoryPage; });
/* harmony import */ var _chunk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(175);
/* harmony import */ var _util_delegator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(94);


/**
 * A "page" of GPU memory. Comprises vertex and index buffers of a fixed size.
 */
class MemoryPage extends _util_delegator__WEBPACK_IMPORTED_MODULE_1__["DelegatorBase"] {
    /**
     * Creates a new page to manage given vertex and index buffers.
     *
     * @param vertexBuffer The vertex buffer the page will manage.
     * @param indexBuffer The index buffer the page will manager.
     * @param vao The VAO of the page.
     * @param indexType Type of elements of indexBuffer.
     * @param vertexAllocator Allocator of vertex data, logic of allocation directly impacts the lifecycle of the page.
     * @param indexAllocator Allocator of index data, logic of allocation directly impacts the lifecycle of the page.
     */
    constructor(vertexBuffer, indexBuffer, vao, indexType, vertexAllocator, indexAllocator) {
        super();
        this.vertexBuffer = vertexBuffer;
        this.indexBuffer = indexBuffer;
        this.vao = vao;
        this.indexType = indexType;
        this._vertexAllocator = vertexAllocator;
        this._indexAllocator = indexAllocator;
    }
    /**
     * Allocates and writes vertex and index data to the page. Offsets indices
     * in an index array to appropriately take into account offset of the vertex
     * data.
     *
     * @param vertexByteLength required number of bytes in vertex buffer
     * @param indexByteLength required number of bytes in index buffer
     * @returns memory chunk allocated or `null` if allocation's failed
     */
    allocate(vertexByteLength, indexByteLength) {
        if (this._vertexAllocator.maxAllocableSize >= vertexByteLength &&
            this._indexAllocator.maxAllocableSize >= indexByteLength) {
            return new _chunk__WEBPACK_IMPORTED_MODULE_0__["default"](this, {
                vertexByteOffset: this._vertexAllocator.allocate(vertexByteLength),
                vertexByteLength: vertexByteLength,
                indexByteOffset: this._indexAllocator.allocate(indexByteLength),
                indexByteLength: indexByteLength
            });
        }
        else {
            return null;
        }
    }
    /**
     * Frees a previously allocated memory chunk.
     *
     * @param chunk The chunk to be freed.
     */
    free(chunk) {
        this._vertexAllocator.deallocate(chunk.vertexByteOffset);
        this._indexAllocator.deallocate(chunk.indexByteOffset);
        if (this.isEmpty() && this._delegate) {
            this._delegate.onPageEmpty(this);
        }
    }
    /**
     * Returns `true` if the page does not contain any previously allocated data
     * and `false` otherwise.
     */
    isEmpty() {
        return this._vertexAllocator.isEmpty && this._indexAllocator.isEmpty;
    }
    /**
     * Destroys the page and all its resources.
     */
    destroy() {
        this.vertexBuffer.destroy();
        this.indexBuffer.destroy();
        this.vao.destroy();
    }
}


/***/ }),
/* 175 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MemoryChunk; });
/* harmony import */ var _util_ref_counted__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(43);

/** Handler to a allocated memory chunk. */
class MemoryChunk extends _util_ref_counted__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Creates a new handler to a memory chunk with given offsets allocated in
     * a given memory page.
     *
     * @param page The page the chunk was allocated in.
     * @param vertexOffset The offset of chunk's vertex data.
     * @param indexOffset The offset of chunk's index data.
     */
    constructor(page, location) {
        super();
        this.page = page;
        this._location = location;
    }
    /**
     * Returns offset of vertex data of the chunk in bytes.
     */
    get vertexByteOffset() {
        return this._location.vertexByteOffset;
    }
    /**
     * Returns offset of index data of the chunk in bytes.
     */
    get indexByteOffset() {
        return this._location.indexByteOffset;
    }
    _destroy() {
        this.page.free(this);
    }
}


/***/ }),
/* 176 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return FxaaRenderUnit; });
/* harmony import */ var _math_vector2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(23);
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/* harmony import */ var _shaders_fxaa_frag__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(177);
/* harmony import */ var _shaders_fxaa_frag__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_shaders_fxaa_frag__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _shaders_quad_vert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(178);
/* harmony import */ var _shaders_quad_vert__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_shaders_quad_vert__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _util_hd__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(48);
/* harmony import */ var _gl_renderer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(101);
/* harmony import */ var _list_render_unit__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(172);








const STATE = new _state__WEBPACK_IMPORTED_MODULE_1__["default"](_state__WEBPACK_IMPORTED_MODULE_1__["BLEND_OVER_RENDER_STATE"]);
/**
 * Renderer of FXAA postprocessing pass.
 */
class FxaaRenderUnit extends _gl_renderer__WEBPACK_IMPORTED_MODULE_5__["GlRenderer"] {
    constructor(context, renderLoop) {
        super(context, STATE, context.createProgram(_shaders_quad_vert__WEBPACK_IMPORTED_MODULE_3___default.a, _shaders_fxaa_frag__WEBPACK_IMPORTED_MODULE_2___default.a, {
            attribMap: {
                vertexPosition: 0 /* POSITION */
            }
        }));
        this._renderers = new _list_render_unit__WEBPACK_IMPORTED_MODULE_6__["default"]();
        this._renderLoop = renderLoop;
        this.onUpdate = this._renderers.onUpdate;
        this._pixelSize = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["create"](0, 0);
    }
    addRenderUnit(unit) {
        this._renderers.addRenderUnit(unit);
    }
    removeRenderUnit(unit) {
        this._renderers.removeRenderUnit(unit);
    }
    render(target, ...args) {
        // skip antialiasing if these is action in the scene
        if (this._renderLoop.isActive) {
            this._renderers.render(target, ...args);
            // schedule at least one more rendering to not leave static (stopped) scene in non-antialiased state
            this._renderLoop.update();
            return;
        }
        if (!this._intermediateRendereBuffer) {
            this._initIntermediateRenderTargets(target.getWidth(), target.getHeight());
        }
        else if (this._intermediateRendereBuffer.getWidth() !== target.getWidth() ||
            this._intermediateRendereBuffer.getHeight() !== target.getHeight()) {
            this._destroyInternalRenderTargets();
            this._initIntermediateRenderTargets(target.getWidth(), target.getHeight());
        }
        this._context.bindRenderTarget(this._intermediateRendereBuffer);
        this._context.clearCurrentTarget(17664 /* ALL */);
        this._renderers.render(this._intermediateRendereBuffer, ...args);
        // do not run antialiasing on empty this._intermediateRendereBuffer
        if (!this._intermediateRendereBuffer.isClear) {
            this._updateFrameUniformState(target);
            super.render(target, ...args);
        }
    }
    destroy() {
        if (this._intermediateRendereBuffer) {
            this._destroyInternalRenderTargets();
        }
    }
    _render() {
        this._context.bindQuadVao();
        this._context.drawQuad();
    }
    _prepareProgram(program, ...args) {
        super._prepareProgram(program, ...args);
        this._context.bindTextureUnit(0);
        this._context.bindTexture(this._intermediateColorBuffer);
        program.setIntScalarUniform('texture', 0);
        program.setVector2Uniform('pixelSize', this._pixelSize);
        program.setScalarUniform('dpr', Object(_util_hd__WEBPACK_IMPORTED_MODULE_4__["default"])());
    }
    _updateFrameUniformState(target) {
        this._pixelSize.x = 1 / target.getWidth();
        this._pixelSize.y = 1 / target.getHeight();
    }
    _initIntermediateRenderTargets(width, height) {
        const context = this._context;
        const intermediateColorBuffer = this._intermediateColorBuffer =
            context.createEmpty2DTexture(width, height, 6408 /* RGBA */, 5121 /* UNSIGNED_BYTE */);
        const intermediateDepthStencilBuffer = this._intermediateDepthStencilBuffer =
            context.createRenderbuffer(width, height, 34041 /* DEPTH_STENCIL */);
        this._intermediateRendereBuffer = context.createFramebuffer({
            color: intermediateColorBuffer,
            depthStencil: intermediateDepthStencilBuffer
        });
    }
    _destroyInternalRenderTargets() {
        this._intermediateRendereBuffer.destroy();
        this._intermediateColorBuffer.destroy();
        this._intermediateDepthStencilBuffer.destroy();
    }
}


/***/ }),
/* 177 */
/***/ (function(module, exports) {

module.exports = "#version 100\n\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform vec2 pixelSize;\nuniform sampler2D texture;\nuniform float dpr;\n\nconst float FXAA_QUALITY_SUBPIX = 0.75;\nconst float FXAA_QUALITY_EDGE_THRESHOLD = 0.063;\nconst float FXAA_QUALITY_EDGE_THRESHOLD_MIN = 0.0625;\nconst float EPSILON = 0.0001;\n\nfloat luma(vec4 rgba) {\n    return dot(rgba.xyz, vec3(0.299, 0.587, 0.114));\n}\n\nvec4 fxaa(\n    vec2 pos,\n    sampler2D tex,\n    vec2 fxaaQualityRcpFrame,\n    // This used to be the FXAA_QUALITY_SUBPIX define.\n    // Choose the amount of sub-pixel aliasing removal.\n    // This can effect sharpness.\n    //   1.00 - upper limit (softer)\n    //   0.75 - default amount of filtering\n    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)\n    //   0.25 - almost off\n    //   0.00 - completely off\n    float fxaaQualitySubpix,\n    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.\n    // The minimum amount of local contrast required to apply algorithm.\n    //   0.333 - too little (faster)\n    //   0.250 - low quality\n    //   0.166 - default\n    //   0.125 - high quality\n    //   0.063 - overkill (slower)\n    float fxaaQualityEdgeThreshold,\n    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.\n    // Trims the algorithm from processing darks.\n    //   0.0833 - upper limit (default, the start of visible unfiltered edges)\n    //   0.0625 - high quality (faster)\n    //   0.0312 - visible limit (slower)\n    float fxaaQualityEdgeThresholdMin\n) {\n    vec2 posM;\n    posM.x = pos.x;\n    posM.y = pos.y;\n    vec4 rgbyM = texture2D(tex, posM);\n    float lumaM = luma(rgbyM);\n\n    float lumaS = luma(texture2D(tex, posM + vec2( 0, 1) * fxaaQualityRcpFrame.xy));\n    float lumaE = luma(texture2D(tex, posM + vec2( 1, 0) * fxaaQualityRcpFrame.xy));\n    float lumaN = luma(texture2D(tex, posM + vec2( 0,-1) * fxaaQualityRcpFrame.xy));\n    float lumaW = luma(texture2D(tex, posM + vec2(-1, 0) * fxaaQualityRcpFrame.xy));\n\n    float maxSM = max(lumaS, lumaM);\n    float minSM = min(lumaS, lumaM);\n    float maxESM = max(lumaE, maxSM);\n    float minESM = min(lumaE, minSM);\n    float maxWN = max(lumaN, lumaW);\n    float minWN = min(lumaN, lumaW);\n    float rangeMax = max(maxWN, maxESM);\n    float rangeMin = min(minWN, minESM);\n    float rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\n    float range = rangeMax - rangeMin;\n    float rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\n    bool earlyExit = range < rangeMaxClamped;\n\n    if (earlyExit)\n        return rgbyM;\n\n    float lumaNW = luma(texture2D(tex, posM + vec2(-1,-1) * fxaaQualityRcpFrame.xy));\n    float lumaSE = luma(texture2D(tex, posM + vec2( 1, 1) * fxaaQualityRcpFrame.xy));\n    float lumaNE = luma(texture2D(tex, posM + vec2( 1,-1) * fxaaQualityRcpFrame.xy));\n    float lumaSW = luma(texture2D(tex, posM + vec2(-1, 1) * fxaaQualityRcpFrame.xy));\n\n    float lumaNS = lumaN + lumaS;\n    float lumaWE = lumaW + lumaE;\n    float subpixRcpRange = 1.0/range;\n    float subpixNSWE = lumaNS + lumaWE;\n    float edgeHorz1 = (-2.0 * lumaM) + lumaNS;\n    float edgeVert1 = (-2.0 * lumaM) + lumaWE;\n\n    float lumaNESE = lumaNE + lumaSE;\n    float lumaNWNE = lumaNW + lumaNE;\n    float edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\n    float edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\n\n    float lumaNWSW = lumaNW + lumaSW;\n    float lumaSWSE = lumaSW + lumaSE;\n    float edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\n    float edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\n    float edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\n    float edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\n    float edgeHorz = abs(edgeHorz3) + edgeHorz4;\n    float edgeVert = abs(edgeVert3) + edgeVert4;\n\n    float subpixNWSWNESE = lumaNWSW + lumaNESE;\n    float lengthSign = fxaaQualityRcpFrame.x;\n    bool horzSpan = edgeHorz >= edgeVert;\n    float subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\n\n    if (horzSpan) {\n        lengthSign = fxaaQualityRcpFrame.y;\n    } else {\n        lumaN = lumaW;\n        lumaS = lumaE;\n    }\n    float subpixB = (subpixA * (1.0/12.0)) - lumaM;\n\n    float gradientN = lumaN - lumaM;\n    float gradientS = lumaS - lumaM;\n    float lumaNN = lumaN + lumaM;\n    float lumaSS = lumaS + lumaM;\n    bool pairN = abs(gradientN) >= abs(gradientS);\n    float gradient = max(abs(gradientN), abs(gradientS));\n    if (pairN) {\n        lengthSign = -lengthSign;\n    } else {\n        lumaNN = lumaSS;\n    }\n    float subpixC = clamp(abs(subpixB) * subpixRcpRange, 0.0, 1.0);\n\n    vec2 posB = posM;\n    vec2 offNP;\n\n    vec2 offHM;\n    if (horzSpan) {\n        offNP = vec2(fxaaQualityRcpFrame.x, 0.0);\n        offHM = vec2(0.0, lengthSign);\n    } else {\n        offNP = vec2(0.0, fxaaQualityRcpFrame.y);\n        offHM = vec2(lengthSign, 0.0);\n    }\n\n    vec2 posN = posB - offNP * 2.;\n    vec2 posP = posB + offNP * 2.;\n\n    float subpixD = ((-2.0)*subpixC) + 3.0;\n    float lumaEndN = luma(\n        mix(\n            texture2D(tex, posN),\n            texture2D(tex, posN + offHM),\n            0.5\n        )\n    );\n    float subpixE = subpixC * subpixC;\n    float lumaEndP = luma(\n        mix(\n            texture2D(tex, posP),\n            texture2D(tex, posP + offHM),\n            0.5\n        )\n    );\n\n    float gradientScaled = gradient * 0.25;\n    float lumaMM = lumaM - lumaNN * 0.5;\n    float subpixF = subpixD * subpixE;\n    bool lumaMLTZero = lumaMM < 0.0;\n\n    lumaEndN -= lumaNN * 0.5;\n    lumaEndP -= lumaNN * 0.5;\n    bool doneN = abs(lumaEndN) >= gradientScaled;\n    bool doneP = abs(lumaEndP) >= gradientScaled;\n    if (!doneN) {\n        posN -= offNP * 3.0;\n    }\n    bool doneNP = (!doneN) || (!doneP);\n    if (!doneP) {\n        posP += offNP * 3.0;\n    }\n\n    if (doneNP) {\n        if (!doneN) {\n            lumaEndN = luma(\n                mix(\n                    texture2D(tex, posN),\n                    texture2D(tex, posN + offHM),\n                    0.5\n                )\n            );\n            lumaEndN = lumaEndN - lumaNN * 0.5;\n        }\n        if (!doneP) {\n            lumaEndP = luma(\n                mix(\n                    texture2D(tex, posP.xy),\n                    texture2D(tex, posP.xy + offHM),\n                    0.5\n                )\n            );\n            lumaEndP = lumaEndP - lumaNN * 0.5;\n        }\n        doneN = abs(lumaEndN) >= gradientScaled;\n        doneP = abs(lumaEndP) >= gradientScaled;\n        if (!doneN) {\n            posN -= offNP * 12.0;\n        }\n        if (!doneP) {\n            posP += offNP * 12.0;\n        }\n    }\n    float dstN = posM.x - posN.x;\n    float dstP = posP.x - posM.x;\n    if (!horzSpan) {\n        dstN = posM.y - posN.y;\n        dstP = posP.y - posM.y;\n    }\n    bool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\n    float spanLength = (dstP + dstN);\n    bool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\n    float spanLengthRcp = 1.0/spanLength;\n    bool directionN = dstN < dstP;\n    float dst = min(dstN, dstP);\n    bool goodSpan = directionN ? goodSpanN : goodSpanP;\n    float subpixG = subpixF * subpixF;\n    float pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\n    float subpixH = subpixG * fxaaQualitySubpix;\n    float pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\n    float pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\n    vec4 color;\n    float factor = pixelOffsetSubpix;\n    if (horzSpan) {\n        color = mix(\n            texture2D(tex, posM),\n            texture2D(tex, posM + vec2(0.0, lengthSign)),\n            factor\n        );\n    } else {\n        color = mix(\n            texture2D(tex, posM),\n            texture2D(tex, posM + vec2(lengthSign, 0.0)),\n            factor\n        );\n    }\n\n    return color;\n}\n\nvoid main() {\n    vec2 pos = gl_FragCoord.xy * pixelSize;\n    vec4 color = fxaa(\n        pos,\n        texture,\n        pixelSize,\n        FXAA_QUALITY_SUBPIX,\n        FXAA_QUALITY_EDGE_THRESHOLD,\n        FXAA_QUALITY_EDGE_THRESHOLD_MIN\n    );\n\n    // If color.a is less than one, then the color has been blended with a black background before.\n    // An original color of transparent objects is vec4(color.xyz / color.a, color.a).\n    // We have to blend an original color with background pattern.\n    // color.a can be too close to zero. Check it.\n    if (color.a > EPSILON) {\n        color.xyz /= color.a;\n    }\n    gl_FragColor = color;\n}\n"

/***/ }),
/* 178 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec2 vertexPosition;\nattribute vec2 vertexUv;\n\nuniform float zIndex;\n\n#ifndef YV_LEAST_16b_P\n#   ifdef GL_FRAGMENT_PRECISION_HIGH\n#       define YV_LEAST_16b_P highp\n#   else\n#       define YV_LEAST_16b_P mediump\n#   endif\n#endif\n\nvarying YV_LEAST_16b_P vec2 uv;\n\nvoid main(void) {\n    gl_Position = vec4(vertexPosition, zIndex, 1);\n    uv = vertexUv;\n}\n"

/***/ }),
/* 179 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BackgroundRenderUnit; });
/* harmony import */ var _gl_renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(101);
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/* harmony import */ var _util_event_emitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(14);
/* harmony import */ var _shaders_quad_vert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(178);
/* harmony import */ var _shaders_quad_vert__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_shaders_quad_vert__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _shaders_background_frag__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(180);
/* harmony import */ var _shaders_background_frag__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_shaders_background_frag__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _util_hd__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(48);






const STATE = new _state__WEBPACK_IMPORTED_MODULE_1__["default"]({
    depthTest: true,
    depthFunc: 518 /* GREATER_OR_EQUAL */
});
/**
 * Fills map's canvas with background pattern on regions that have no data yet.
 */
class BackgroundRenderUnit extends _gl_renderer__WEBPACK_IMPORTED_MODULE_0__["GlRenderer"] {
    constructor(context) {
        const program = context.createProgram(_shaders_quad_vert__WEBPACK_IMPORTED_MODULE_3___default.a, _shaders_background_frag__WEBPACK_IMPORTED_MODULE_4___default.a, {
            attribMap: {
                vertexPosition: 0 /* POSITION */,
                vertexUv: 4 /* UV */
            }
        });
        super(context, STATE, program);
        context.bindProgram(program);
        program.setScalarUniform('zIndex', -1);
        this.onUpdate = new _util_event_emitter__WEBPACK_IMPORTED_MODULE_2__["VoidEventEmitter"]();
    }
    _render() {
        this._context.bindQuadVao();
        this._context.drawQuad();
    }
    _prepareProgram(program) {
        super._prepareProgram(program);
        program.setScalarUniform('dpr', Object(_util_hd__WEBPACK_IMPORTED_MODULE_5__["default"])());
    }
}


/***/ }),
/* 180 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nvoid main() {\n    // Background color should match main map layer color.\n    gl_FragColor = vec4(0.98, 0.97, 0.94, 1);\n}\n"

/***/ }),
/* 181 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LayerRenderUnit; });
/* harmony import */ var _list_render_unit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(172);
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);


const DEPTH_CLEAR_STATE = new _state__WEBPACK_IMPORTED_MODULE_1__["default"]({
    depthTest: true,
    clearDepth: 0
});
class LayerRenderUnit extends _list_render_unit__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(context, depthClearStrategy = 0 /* NO_CLEAR */) {
        super();
        this._depthClearStrategy = depthClearStrategy;
        this._context = context;
    }
    render(target, ...args) {
        if (this._depthClearStrategy === 1 /* BEFORE_RENDER */) {
            this._context.bindRenderState(DEPTH_CLEAR_STATE);
            this._context.bindRenderTarget(target);
            this._context.clearCurrentTarget(256 /* DEPTH_BUFFER_BIT */);
        }
        super.render(target, ...args);
    }
}


/***/ }),
/* 182 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CollidingPrimitivesResetRemovedRenderer", function() { return CollidingPrimitivesResetRemovedRenderer; });
/* harmony import */ var _render_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);
/* harmony import */ var _render_memory_count_vertices__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(41);
/* harmony import */ var _shaders_reset_removed_vert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(183);
/* harmony import */ var _shaders_reset_removed_vert__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_shaders_reset_removed_vert__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _shaders_reset_removed_frag__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(184);
/* harmony import */ var _shaders_reset_removed_frag__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_shaders_reset_removed_frag__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _render_gl_renderer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(101);
/* harmony import */ var _render_primitives_primitive_batch__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(102);






class CollidingPrimitivesResetRemovedRenderer extends _render_gl_renderer__WEBPACK_IMPORTED_MODULE_4__["GlRenderer"] {
    constructor(context, primitiveProvider) {
        const program = context.createProgram(_shaders_reset_removed_vert__WEBPACK_IMPORTED_MODULE_2___default.a, _shaders_reset_removed_frag__WEBPACK_IMPORTED_MODULE_3___default.a, {
            attribMap: {
                vertexId: 2 /* ID */
            }
        });
        super(context, new _render_state__WEBPACK_IMPORTED_MODULE_0__["default"](), program);
        this._primitiveProvider = primitiveProvider;
        context.bindProgram(program);
        program.setIntScalarUniform('prevVisibility', 0);
    }
    _render() {
        const primitives = this._primitiveProvider.primitives;
        for (const memoryBatch of Object(_render_primitives_primitive_batch__WEBPACK_IMPORTED_MODULE_5__["batchPrimitives"])(primitives)) {
            this._context.bindVao(memoryBatch.page.vao);
            this._context.drawIndexedMesh(memoryBatch.indexByteOffset, Object(_render_memory_count_vertices__WEBPACK_IMPORTED_MODULE_1__["countIndices"])(memoryBatch.indexByteLength, memoryBatch.page.indexType), 0 /* POINTS */);
        }
    }
    _prepareProgram(program, prevVisibility, idHalfPxSize) {
        super._prepareProgram(program, prevVisibility, idHalfPxSize);
        this._context.bindTextureUnit(0);
        this._context.bindTexture(prevVisibility);
        program.setVector2Uniform('idHalfPxSize', idHalfPxSize);
    }
}


/***/ }),
/* 183 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec2 vertexId;\n\nuniform sampler2D prevVisibility;\nuniform vec2 idHalfPxSize;\n\nvarying lowp vec4 visibilityValue;\n\nvoid main() {\n    vec2 idTexCoordinates = vertexId + idHalfPxSize;\n    vec4 idWindowCoordinates = vec4(idTexCoordinates * 2.0 - 1.0, 0, 1);\n    gl_Position = idWindowCoordinates;\n    gl_PointSize = 1.0;\n\n    visibilityValue = texture2D(prevVisibility, idTexCoordinates);\n}\n"

/***/ }),
/* 184 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nvarying lowp vec4 visibilityValue;\n\nvoid main() {\n    gl_FragColor = visibilityValue;\n}\n"

/***/ }),
/* 185 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RenderLoop; });
/* harmony import */ var _util_event_emitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(14);

const MAX_FRAME_TIME_COUNT = 100;
class RenderLoop {
    /**
     * Create a new render loop, but doesn't schedule any animation frames.
     */
    constructor() {
        this.onFrameTimesFull = new _util_event_emitter__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.onBeforeRender = new _util_event_emitter__WEBPACK_IMPORTED_MODULE_0__["VoidEventEmitter"]();
        this.onRender = new _util_event_emitter__WEBPACK_IMPORTED_MODULE_0__["VoidEventEmitter"]();
        this._isRunning = this._updateIsRequested = false;
        this._lastFrameTime = 0;
        this._frameTimes = new Array(MAX_FRAME_TIME_COUNT);
        this._frameTimes.fill(0);
        this._nextFrameTimeIdx = 0;
    }
    /**
     * @returns Whether the loop is running a chain of consecutive animation
     *      frames or not.
     */
    get isActive() {
        return this._isRunning;
    }
    /**
     * Starts a chain of consecutive animation frames.
     */
    start() {
        this._isRunning = true;
        this._requestFrame();
    }
    /**
     * Stops previously started chain of consecutive animation frames. If an
     * update was requested before stopping, one more animation frame will be
     * fired.
     */
    stop() {
        if (this._isRunning) {
            this._isRunning = false;
            if (!this._updateIsRequested) {
                this._cancelFrame();
            }
        }
    }
    /**
     * Schedules a single
     */
    update() {
        this._updateIsRequested = true;
        this._requestFrame();
    }
    /**
     * Stops all the rendering activities.
     */
    destroy() {
        this._cancelFrame();
    }
    _renderFrame(time) {
        this._rafId = 0;
        this._updateIsRequested = false;
        this.onBeforeRender.fire();
        this.onRender.fire();
        if (this._lastFrameTime > 0) {
            const nextFrameTimeIdx = this._nextFrameTimeIdx;
            this._frameTimes[nextFrameTimeIdx] = time - this._lastFrameTime;
            this._nextFrameTimeIdx = (nextFrameTimeIdx + 1) % MAX_FRAME_TIME_COUNT;
            // Next time index being 0 means that the array is full and it's
            // time to notify listeners about that before we start to rewrite
            // values.
            if (this._nextFrameTimeIdx === 0) {
                this.onFrameTimesFull.fire(this._frameTimes);
            }
        }
        if (this._isRunning) {
            this._lastFrameTime = time;
            this._requestFrame();
        }
        else {
            // If we don't schedule next frame immediately there's no way to
            // tell that it will be consecutive to the current one. Hence there's
            // no point in recording a time delta in it.
            this._lastFrameTime = 0;
        }
    }
    _requestFrame() {
        if (!this._rafId) {
            this._rafId = requestAnimationFrame(((time) => this._renderFrame(time)));
        }
    }
    _cancelFrame() {
        cancelAnimationFrame(this._rafId);
        this._rafId = 0;
    }
}


/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vdG9vbHMvc3RhbmQvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9jb250ZXh0LnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvYXR0cmliX21hcHBpbmcudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvaXRlcmFibGUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvcG93X29mXzIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9nbC9idWZmZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9nbC9mcmFtZWJ1ZmZlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL2dsL3Byb2dyYW0udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9nbC9yZW5kZXJidWZmZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9jYXBhYmlsaXRpZXMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9zdGF0ZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9jb2xvci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL2dsL3RleHR1cmUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9nbC92YW8udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvZXZlbnRfZW1pdHRlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvY2FtZXJhLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9tYXRoL3NjYWxhci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9yYWRfZGVnLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL29wdGlvbnMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL21hdGgvbWF0cml4NC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvbWF0aC92ZWN0b3IzLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9tYXRoL21hdHJpeDMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvZnV6enlfZXF1YWwudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL21hdGgvdmVjdG9yMi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdmVjdG9yX2FwaS9hZGFwdGVyLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9hZGFwdGVycy90aWxlX2Jhc2VkX2FkYXB0ZXIvYWRhcHRlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvYWRhcHRlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9mdW5jdGlvbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdGlsZV9iYXNlZF9hZGFwdGVyL3V0aWwvdGlsZV9zeXN0ZW0udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2FkYXB0ZXJzL3RpbGVfYmFzZWRfYWRhcHRlci90aWxlX2lkLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL3dvcmtlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC91bmlxdWVfaWQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2FkYXB0ZXJzL3RpbGVfYmFzZWRfYWRhcHRlci91dGlsL3Zpc2libGVfdGlsZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdGlsZV9iYXNlZF9hZGFwdGVyL2JlbHRfdGlsZXMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvc3RhdC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL2ljb24vaWNvbl9idWZmZXJfd3JpdGVyLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL2J1ZmZlcl93cml0ZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvZ3B1dHlwZXMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvYXJyYXkudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvY29tcGFyYXRvci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL21lbW9yeS9zdWJfY2h1bmsudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9tZW1vcnkvY291bnRfdmVydGljZXMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2JpbGxib2FyZC9pZGVudGlmaWVkX2ltYWdlX2F0bGFzX21hbmFnZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvcmVmX2NvdW50ZWQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2ZvbnQvZGZfZm9udC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvZm9udC9mb250LnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9hZGFwdGVycy92ZWN0b3JfYXBpL2FwaV9pbWFnZV9wcm92aWRlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYmlsbGJvYXJkL2ltYWdlX3Byb3ZpZGVyLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL2hkLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9hZGFwdGVycy92ZWN0b3JfYXBpL3V0aWwvaG9zdHMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3ByaW1pdGl2ZS9tb2RlbC9tb2RlbF9idWZmZXJfd3JpdGVyLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9wcmltaXRpdmUvcG9seWxpbmUvdGV4dHVyZWRfcG9seWxpbmVfYnVmZmVyX3dyaXRlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL3BvbHlsaW5lL3RleHR1cmVkX3BvbHlsaW5lX2dlb21ldHJ5LnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL3pfaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2JpbGxib2FyZC9pbWFnZV9tYW5hZ2VyLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9wcmltaXRpdmUvcG9seWdvbi90ZXh0dXJlZF9wb2x5Z29uX2J1ZmZlcl9yZXdpdGVyLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL2J1ZmZlcl9yZXdyaXRlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL3BvbHlnb24vdGV4dHVyZWRfcG9seWdvbl9hdHRyaWJ1dGVfbWFwcGluZy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL3BvbHlnb24vcG9seWdvbl9hdHRyaWJ1dGVfbWFwcGluZy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL2JpbGxib2FyZF9yZWN0YW5nbGUvYXR0cmlidXRlX21hcHBpbmcudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3ByaW1pdGl2ZS9sYWJlbC9wb2ludF9sYWJlbF9hdHRyaWJ1dGVfbWFwcGluZy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL2xhYmVsL2N1cnZlZF9sYWJlbF9hdHRyaWJ1dGVfbWFwcGluZy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL3BvbHlsaW5lL3BvbHlsaW5lX2F0dHJpYnV0ZV9tYXBwaW5nLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9hZGFwdGVycy92ZWN0b3JfYXBpL3dvcmtlci90aWxlX3Byb3ZpZGVyX3dvcmtlcl9jbGllbnQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2FkYXB0ZXJzL3ZlY3Rvcl9hcGkvd29ya2VyL3RpbGVfcHJvdmlkZXJfd29ya2VyX21lc3NhZ2VzLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9hZGFwdGVycy92ZWN0b3JfYXBpL3dvcmtlci9wcmltaXRpdmVfcHJvdmlkZXJfd29ya2VyX21lc3NhZ2VzLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9wcmltaXRpdmUvcG9seWdvbi90cmFuc3BhcmVudF9wb2x5Z29uX2F0dHJpYnV0ZV9tYXBwaW5nLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL2lkbGVfdGFza19xdWV1ZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9wcmlvcml0eV9xdWV1ZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9iaW5hcnlfaGVhcC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL3BvbHlnb24vcmVuZGVyYWJsZV9wb2x5Z29uLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9wcmltaXRpdmUvcmVuZGVyYWJsZV9wcmltaXRpdmUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3ByaW1pdGl2ZS9wb2x5Z29uL3JlbmRlcmFibGVfdGV4dHVyZWRfcG9seWdvbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL3BvbHlsaW5lL3JlbmRlcmFibGVfcG9seWxpbmUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3ByaW1pdGl2ZS9wb2x5bGluZS9yZW5kZXJhYmxlX3RleHR1cmVkX3BvbHlsaW5lLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9wcmltaXRpdmUvbW9kZWwvcmVuZGVyYWJsZV9tb2RlbC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdmVjdG9yX2FwaS90aWxlX2RhdGEudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2FkYXB0ZXJzL3ZlY3Rvcl9hcGkvcHJpbWl0aXZlX21hbmFnZXIvcmVuZGVyYWJsZV9wcmltaXRpdmVfbWFuYWdlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdmVjdG9yX2FwaS9wcmltaXRpdmVfbWFuYWdlci9wcmltaXRpdmVfbWFuYWdlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvcHJpbWl0aXZlX3NldF9zdG9yYWdlLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9hZGFwdGVycy92ZWN0b3JfYXBpL3ByaW1pdGl2ZV9tYW5hZ2VyL3BvbHlnb25fbWFuYWdlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvZGlzYXBwZWFyaW5nX3ByaW1pdGl2ZV9zZXRfc3RvcmFnZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvZGVsYXllZF9kaXNhcHBlYXJpbmdfcHJpbWl0aXZlX3NldF9zdG9yYWdlLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9hZGFwdGVycy92ZWN0b3JfYXBpL3ByaW1pdGl2ZV9tYW5hZ2VyL3pvb21fZmlsdGVyYWJsZV9wcmltaXRpdmVfbWFuYWdlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdmVjdG9yX2FwaS9wcmltaXRpdmVfbWFuYWdlci9leHRlcm5hbF9tZXNoX21hbmFnZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3ByaW1pdGl2ZS9iaWxsYm9hcmRfcmVjdGFuZ2xlL3JlbmRlcmFibGVfYmlsbGJvYXJkX3JlY3RhbmdsZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdmVjdG9yX2FwaS9wcmltaXRpdmUvem9vbV9yZXN0cmljdGVkX2xhYmVsLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9wcmltaXRpdmUvbGFiZWwvcmVuZGVyYWJsZV9sYWJlbC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdmVjdG9yX2FwaS9wcmltaXRpdmUvem9vbV9yZXN0cmljdGVkX2ljb24udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3ByaW1pdGl2ZS9pY29uL3JlbmRlcmFibGVfaWNvbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL2ltYWdlL3JlbmRlcmFibGVfaW1hZ2UudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3ByaW1pdGl2ZS90ZXh0dXJlZF9yZW5kZXJhYmxlX3ByaW1pdGl2ZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC90YXNrX3F1ZXVlLnRzIiwid2VicGFjazovLy8uL3Rvb2xzL3N0YW5kL2NhbWVyYV9zdHVmZi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9kZWxlZ2F0b3IudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3Zpc2liaWxpdHkvcHJpbWl0aXZlcy9sYWJlbC9jb2xvcl9pZF9wb2ludF9sYWJlbF9yZW5kZXJlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdmlzaWJpbGl0eS9wcmltaXRpdmVzL2xhYmVsL3NoYWRlci9wb2ludF9sYWJlbC52ZXJ0Iiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS92aXNpYmlsaXR5L3ByaW1pdGl2ZXMvbGFiZWwvc2hhZGVyL2NvbG9yX2lkLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3Zpc2liaWxpdHkvcHJpbWl0aXZlcy9sYWJlbC9jb2xvcl9pZF9sYWJlbF9yZW5kZXJlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdmlzaWJpbGl0eS9wcmltaXRpdmVzL2NvbGxpZGluZ19wcmltaXRpdmVfY29sb3JfaWRfcmVuZGVyZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL3dvcmxkX3ByaW1pdGl2ZV9yZW5kZXJfdW5pdC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL2dsX3JlbmRlcmVyLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9wcmltaXRpdmVfYmF0Y2gudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9tZW1vcnkvcmVsYXRpdmVfbG9jYXRpb24udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL2xhYmVsL3BvaW50X2xhYmVsX3JlbmRlcl91bml0LnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9sYWJlbC9zaGFkZXIvcG9pbnRfbGFiZWwudmVydCIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvbGFiZWwvc2hhZGVyL2RmX3RleHQuZnJhZyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvbGFiZWwvbGFiZWxfcmVuZGVyX3VuaXQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL2JpbGxib2FyZF9yZWN0YW5nbGUvYmlsbGJvYXJkX3JlY3RhbmdsZV9yZW5kZXJfdW5pdC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvYmlsbGJvYXJkX3JlY3RhbmdsZS9zaGFkZXIvYmlsbGJvYXJkX3JlY3RhbmdsZS52ZXJ0Iiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9iaWxsYm9hcmRfcmVjdGFuZ2xlL3NoYWRlci9iaWxsYm9hcmRfcmVjdGFuZ2xlLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3Zpc2liaWxpdHkvcHJpbWl0aXZlcy9sYWJlbC9jb2xvcl9pZF9jdXJ2ZWRfbGFiZWxfcmVuZGVyZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3Zpc2liaWxpdHkvcHJpbWl0aXZlcy9sYWJlbC9zaGFkZXIvY3VydmVkX2xhYmVsLnZlcnQiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL2xhYmVsL2N1cnZlZF9sYWJlbF9yZW5kZXJfdW5pdC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvbGFiZWwvc2hhZGVyL2N1cnZlZF9sYWJlbC52ZXJ0Iiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9pY29uL2ljb25fcmVuZGVyX3VuaXQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL2ljb24vc2hhZGVyL2ljb24udmVydCIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvaWNvbi9zaGFkZXIvaWNvbi5mcmFnIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9pbWFnZS9pbWFnZV9yZW5kZXJfdW5pdC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvaW1hZ2Uvc2hhZGVyL2ltYWdlLnZlcnQiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL2ltYWdlL3NoYWRlci9pbWFnZS5mcmFnIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9tb2RlbC9tb2RlbF9yZW5kZXJfdW5pdC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvbW9kZWwvc2hhZGVyL21vZGVsLnZlcnQiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL21vZGVsL3NoYWRlci9tb2RlbC5mcmFnIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9vdmVybGF5L292ZXJsYXlfcmVuZGVyZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL292ZXJsYXkvc2hhZGVyL292ZXJsYXkudmVydCIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvb3ZlcmxheS9zaGFkZXIvb3ZlcmxheS5mcmFnIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9wb2x5bGluZS90ZXh0dXJlZF9wb2x5bGluZV9yZW5kZXJfdW5pdC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvcG9seWxpbmUvc2hhZGVyL3RleHR1cmVkX3BvbHlsaW5lLnZlcnQiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL3BvbHlsaW5lL3NoYWRlci90ZXh0dXJlZF9wb2x5bGluZS5mcmFnIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9wb2x5bGluZS9iYXNlX3BvbHlsaW5lX3JlbmRlcl91bml0LnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9wb2x5bGluZS9wb2x5bGluZV9yZW5kZXJfdW5pdC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL3BvbHlsaW5lL3BvbHlsaW5lX2J1ZmZlcl93cml0ZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL3BvbHlsaW5lL3NoYWRlci9wb2x5bGluZS52ZXJ0Iiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9wb2x5bGluZS9zaGFkZXIvcG9seWxpbmUuZnJhZyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvcG9seWdvbi90ZXh0dXJlZF9wb2x5Z29uX3JlbmRlcl91bml0LnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9wb2x5Z29uL3NoYWRlci90ZXh0dXJlZF9wb2x5Z29uLnZlcnQiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL3BvbHlnb24vc2hhZGVyL3RleHR1cmVkX3BvbHlnb24uZnJhZyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvcG9seWdvbi90cmFuc3BhcmVudF9wb2x5Z29uX3JlbmRlcl91bml0LnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9wb2x5Z29uL3BvbHlnb25fcmVuZGVyX3VuaXQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL3BvbHlnb24vc2hhZGVyL3BvbHlnb24udmVydCIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvcG9seWdvbi9zaGFkZXIvcG9seWdvbi5mcmFnIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9tYXBfZW5naW5lLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9lbmdpbmUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9mb250L3JlbmRlcmFibGVfZGZfZ2x5cGhfYXRsYXMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2ZvbnQvZGZfZ2x5cGhfYXRsYXMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2ZvbnQvZGZfZm9udF9yZWdpc3RyeS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvZm9udC9mb250X3JlZ2lzdHJ5LnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvYmlsbGJvYXJkL3JlbmRlcmFibGVfaW1hZ2VfYXRsYXMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2JpbGxib2FyZC9pbWFnZV9hdGxhcy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9hbGxvY2F0b3JfMmQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvYWxsb2NhdG9yLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL2JpbmFyeV90cmVlLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL2xpbmtlZF9zZXQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3Zpc2liaWxpdHkvdmlzaWJpbGl0eV9tYW5hZ2VyLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS92aXNpYmlsaXR5L2dyaWRfc2FtcGxlcl9idWZmZXJfd3JpdGVyLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS92aXNpYmlsaXR5L2dyaWRfcmVuZGVyZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3Zpc2liaWxpdHkvdmlzaWJpbGl0eV9yZXNvbHV0aW9uX3N0ZXBzL3Jlc2V0X3JlbW92ZWRfcHJpbWl0aXZlcy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdmlzaWJpbGl0eS92aXNpYmlsaXR5X3Jlc29sdXRpb25fc3RlcHMvZmFkZW91dF9hbGwudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3Zpc2liaWxpdHkvdmlzaWJpbGl0eV9yZXNvbHV0aW9uX3N0ZXBzL3NoYWRlcnMvZmFkZW91dF9hbGwudmVydCIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdmlzaWJpbGl0eS92aXNpYmlsaXR5X3Jlc29sdXRpb25fc3RlcHMvc2hhZGVycy9mYWRlb3V0X2FsbC5mcmFnIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS92aXNpYmlsaXR5L2lkX3NhbXBsZXJfYnVmZmVyX3dyaXRlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdmlzaWJpbGl0eS92aXNpYmlsaXR5X3Jlc29sdXRpb25fc3RlcHMvZmFkZWluX3Zpc2libGUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3Zpc2liaWxpdHkvdmlzaWJpbGl0eV9yZXNvbHV0aW9uX3N0ZXBzL3NoYWRlcnMvZmFkZWluX3Zpc2libGUudmVydCIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdmlzaWJpbGl0eS92aXNpYmlsaXR5X3Jlc29sdXRpb25fc3RlcHMvc2hhZGVycy9mYWRlaW5fdmlzaWJsZS5mcmFnIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS92aXNpYmlsaXR5L3Zpc2liaWxpdHlfcmVzb2x1dGlvbl9zdGVwcy9mYWRlb3V0X292ZXJsYXBwZWQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3Zpc2liaWxpdHkvdmlzaWJpbGl0eV9yZXNvbHV0aW9uX3N0ZXBzL3NoYWRlcnMvZmFkZW91dF9vdmVybGFwcGVkLnZlcnQiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3Zpc2liaWxpdHkvdmlzaWJpbGl0eV9yZXNvbHV0aW9uX3N0ZXBzL3NoYWRlcnMvZmFkZW91dF9vdmVybGFwcGVkLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci91dGlsL2NhbWVyYV9wb3NpdGlvbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9jYXJ0ZXNpYW5fZ3JpZC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9tZWRpYW5fZmlsdGVyLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvbWFpbl9yZW5kZXJfdW5pdC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL2xpc3RfcmVuZGVyX3VuaXQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9tZW1vcnkvbWFuYWdlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL21lbW9yeS9wYWdlLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvbWVtb3J5L2NodW5rLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvZnhhYV9yZW5kZXJfdW5pdC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3NoYWRlcnMvZnhhYS5mcmFnIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvc2hhZGVycy9xdWFkLnZlcnQiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9iYWNrZ3JvdW5kX3JlbmRlcl91bml0LnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvc2hhZGVycy9iYWNrZ3JvdW5kLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9sYXllcl9yZW5kZXJfdW5pdC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdmlzaWJpbGl0eS9wcmltaXRpdmVzL2NvbGxpZGluZ19wcmltaXRpdmVfcmVzZXRfcmVtb3ZlZF9yZW5kZXJlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdmlzaWJpbGl0eS9wcmltaXRpdmVzL3NoYWRlcnMvcmVzZXRfcmVtb3ZlZC52ZXJ0Iiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS92aXNpYmlsaXR5L3ByaW1pdGl2ZXMvc2hhZGVycy9yZXNldF9yZW1vdmVkLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlcl9sb29wLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtEQUEwQyxnQ0FBZ0M7QUFDMUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnRUFBd0Qsa0JBQWtCO0FBQzFFO0FBQ0EseURBQWlELGNBQWM7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUF5QyxpQ0FBaUM7QUFDMUUsd0hBQWdILG1CQUFtQixFQUFFO0FBQ3JJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7OztBQUdBO0FBQ0E7Ozs7Ozs7O0FDbEZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBb0U7QUFDVDtBQUMrQjtBQUMyQjtBQUNZO0FBQ0U7QUFDakI7QUFDRTtBQUNoQjtBQUNHO0FBQzBCO0FBQ2pCO0FBQ2M7QUFDTTtBQUN2QjtBQUMzQztBQUNOO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLCtDQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsZUFBZTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsOENBQVc7QUFDOUM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvREFBYztBQUMzQjtBQUNBLFlBQVksZ0RBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtEQUFNO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ255QkE7QUFBQTtBQUFBO0FBQUE7QUFBK0M7QUFDTjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxrRUFBVyxrQkFBa0IseUJBQXlCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDREQUFLO0FBQ25DO0FBQ0E7QUFDQSxrQ0FBa0MsbUJBQW1CO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7Ozs7Ozs7O0FDMURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsNEJBQTRCLGNBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0Esd0RBQXdELHFCQUFxQjtBQUM3RTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDeEdBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTs7Ozs7Ozs7QUNwQkE7QUFBQTtBQUFBO0FBQ2U7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDcERBO0FBQUE7QUFBQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDM0RBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCw2QkFBNkI7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBOzs7Ozs7OztBQ2pFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2U7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN2RkE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ2U7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDeENBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDcENBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFxRDtBQUNaO0FBQ0c7QUFDTDtBQUNJO0FBQ0o7QUFDQTtBQUNpQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDZEQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksb0RBQVc7QUFDZixJQUFJLG9EQUFXO0FBQ2YsSUFBSSxvREFBVztBQUNmLElBQUksb0RBQVc7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw2REFBTztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMERBQUs7QUFDeEI7QUFDQSxtQkFBbUIsa0VBQWE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2U7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNkRBQWM7QUFDckM7QUFDQSw0QkFBNEIsb0VBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixrREFBUyxDQUFDLHNEQUFhO0FBQ3REO0FBQ0EsWUFBWSxvREFBVztBQUN2QixZQUFZLG9EQUFXO0FBQ3ZCLFlBQVksb0RBQVc7QUFDdkIsWUFBWSxvREFBVztBQUN2QjtBQUNBO0FBQ0EsWUFBWSxrRUFBeUI7QUFDckMsMEJBQTBCLG9EQUFXO0FBQ3JDO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwwREFBSztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtFQUFhO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrREFBUyxDQUFDLHNEQUFhO0FBQ25DLFlBQVksb0RBQVcsc0RBQXNELG9EQUFXLEVBQUUscURBQVksQ0FBQyx3REFBZTtBQUN0SCxtQkFBbUIsTUFBTTtBQUN6QjtBQUNBLFlBQVkseURBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMERBQUsscUJBQXFCLCtEQUFVO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxvREFBVztBQUNsRCxRQUFRLGtEQUFTLENBQUMsd0RBQWU7QUFDakMsUUFBUSxxREFBWTtBQUNwQixRQUFRLHFEQUFZO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpREFBUTtBQUNwQiwwQkFBMEIsb0RBQVc7QUFDckMsOEJBQThCLG9EQUFXO0FBQ3pDLHlCQUF5QjtBQUN6QiwyQkFBMkIsT0FBTztBQUNsQyxnQkFBZ0Isa0RBQVM7QUFDekIsZ0JBQWdCLHFEQUFZO0FBQzVCLGdCQUFnQixxREFBWTtBQUM1QixxQkFBcUIscUVBQTRCLENBQUMsZ0RBQU87QUFDekQ7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrRUFBeUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzVUQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7Ozs7Ozs7O0FDaERBO0FBQUE7QUFBQTtBQUFBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBOzs7Ozs7OztBQ05BO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2U7QUFDZiwyQkFBMkI7QUFDM0I7Ozs7Ozs7O0FDVkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBcUM7QUFDckM7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asa0JBQWtCLDRDQUFXO0FBQzdCLElBQUksa0RBQWlCO0FBQ3JCLGtCQUFrQiw4Q0FBYTtBQUMvQixJQUFJLGtEQUFpQjtBQUNyQixrQkFBa0IsOENBQWE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDRDQUFXO0FBQ25DLHdCQUF3Qiw0Q0FBVztBQUNuQyx3QkFBd0IsNENBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywyQkFBMkIsK0NBQWM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzFRQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQXFDO0FBQ3dDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVk7QUFDWjtBQUNPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDJDQUEyQyxtRUFBaUI7QUFDbkUsWUFBWSxpRUFBbUI7QUFDL0IsUUFBUSxpRUFBbUI7QUFDM0IsUUFBUSxpRUFBbUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNB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QUFtQjtBQUMvQixRQUFRLGlFQUFtQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sNkNBQTZDLHFDQUFxQztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QyxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDJEQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsaUJBQWlCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDL0tBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTs7Ozs7Ozs7QUNOQTtBQUFBO0FBQUEsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHVFQUFnQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDakZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBMkM7QUFDYjtBQUN2QjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsV0FBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsV0FBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHNCQUFzQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2U7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsb0JBQW9CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0RBQUc7QUFDbEI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsK0RBQWE7QUFDckMsd0JBQXdCLCtEQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzNlQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBOzs7Ozs7OztBQ2hDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCx3Q0FBd0MsWUFBWTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzNFQTtBQUFBO0FBQUE7QUFBK0Q7QUFDL0Q7QUFDTywyQ0FBMkMsdUVBQWdCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMzR0E7QUFBQTtBQUFBO0FBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNPLHVDQUF1Qyx1RUFBZ0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSwyRUFBWTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUM3Q0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN0Q0E7QUFBQTtBQUFBO0FBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1RkFBcUI7QUFDaEM7Ozs7Ozs7O0FDcENBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUM1Q0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUErRDtBQUNOO0FBQ1A7QUFDZ0Q7QUFDbkM7QUFDTTtBQUM5RDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsb0VBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0VBQVcsQ0FBQyxxRUFBYztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2UsbUNBQW1DLDBEQUFlO0FBQ2pFO0FBQ0EsOENBQThDLCtEQUFzQixFQUFFLDJEQUFvQjtBQUMxRjtBQUNBLHVDQUF1Qyw0RkFBNEI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUM3Q0EsNkVBQTZFLGlGQUFpRiw4QkFBOEIscUpBQXFKLDZFQUE2RSxtQ0FBbUMsb0NBQW9DLHlDQUF5Qyw4QkFBOEIsNEJBQTRCLHlCQUF5Qiw4QkFBOEIseUJBQXlCLCtCQUErQiw0QkFBNEIscUJBQXFCLGlDQUFpQyxvQkFBb0IsMEJBQTBCLGlDQUFpQyw4QkFBOEIsbURBQW1ELDZDQUE2QyxpREFBaUQsaVFBQWlRLHNLQUFzSywwREFBMEQsZ0VBQWdFLEdBQUcsMkJBQTJCLG9GQUFvRixrQ0FBa0MsbUNBQW1DLDZQQUE2UCwwQkFBMEIsOEJBQThCLDRDQUE0Qyw4QkFBOEIsdUNBQXVDLDRDQUE0QyxPQUFPLE9BQU8seUNBQXlDLE9BQU8sR0FBRyxHOzs7Ozs7QUNBbHZFLDBEQUEwRCx5Q0FBeUMsMEJBQTBCLHlCQUF5QixvQkFBb0IsMEJBQTBCLGlDQUFpQyxzQkFBc0IsZ0RBQWdELHNDQUFzQyx5Q0FBeUMsOENBQThDLG1EQUFtRCxrREFBa0QscUJBQXFCLDRKQUE0Siw4S0FBOEssK0xBQStMLGlDQUFpQyxzREFBc0QsK0VBQStFLG9DQUFvQyxzS0FBc0ssd0RBQXdELDZFQUE2RSxPQUFPLG9FQUFvRSxHQUFHLEc7Ozs7Ozs7QUNBOW1EO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBc0U7QUFDeEI7QUFDK0I7QUFDN0U7QUFDQTtBQUNBO0FBQ2UsOEJBQThCLG9FQUF3QjtBQUNyRTtBQUNBLDJCQUEyQixxREFBVyxDQUFDLHFFQUF1QjtBQUM5RDtBQUNBO0FBQ0Esb0NBQW9DLG9EQUFXO0FBQy9DLGlDQUFpQyxvREFBVztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN4Q0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQXNFO0FBQ0U7QUFDMUI7QUFDd0I7QUFDdEI7QUFDZ0I7QUFDaEUseUJBQXlCLHFEQUFXLENBQUMscUVBQXVCO0FBQzVEO0FBQ0E7QUFDQTtBQUNlLDJDQUEyQyxvRUFBd0I7QUFDbEY7QUFDQSw4Q0FBOEMsdUVBQXFCLEVBQUUsdUVBQXVCO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msb0RBQVc7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3hDQSw2RUFBNkUsK0JBQStCLDhCQUE4QixvQ0FBb0MsMEJBQTBCLDZCQUE2QixtQ0FBbUMsNEJBQTRCLHlCQUF5Qiw4QkFBOEIseUJBQXlCLCtCQUErQiw4QkFBOEIsb0JBQW9CLHFCQUFxQiwyQkFBMkIsbURBQW1ELHVDQUF1Qyw2Q0FBNkMsaURBQWlELHFCQUFxQix3RkFBd0YsbUNBQW1DLHlDQUF5QyxpQkFBaUIsT0FBTyw0S0FBNEssaUNBQWlDLHVCQUF1QixnRkFBZ0Ysc0JBQXNCLDBCQUEwQixpQ0FBaUMsc0NBQXNDLEdBQUcsRzs7Ozs7O0FDQTV5QywwREFBMEQsdUNBQXVDLHFCQUFxQiwyQkFBMkIsbUVBQW1FLDJCQUEyQixtQ0FBbUMsNkVBQTZFLEdBQUcscUJBQXFCLDBFQUEwRSxHQUFHLEc7Ozs7Ozs7QUNBcGM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFpRTtBQUNOO0FBQ2lDO0FBQ3RCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNlLHlDQUF5QyxnRUFBNkI7QUFDckY7QUFDQSw4Q0FBOEMsZ0VBQXVCLEVBQUUsNERBQXFCLEVBQUUsaUdBQWU7QUFDN0c7QUFDQTtBQUNBOzs7Ozs7O0FDWkEsNkVBQTZFLGlGQUFpRiw4QkFBOEIseU9BQXlPLDZFQUE2RSxtQ0FBbUMsb0NBQW9DLHlDQUF5Qyw0Q0FBNEMsbUxBQW1MLG9DQUFvQyxxQ0FBcUMscUNBQXFDLDRCQUE0Qix5QkFBeUIsOEJBQThCLHlCQUF5QiwrQkFBK0IsNEJBQTRCLHFCQUFxQixpQ0FBaUMsb0JBQW9CLDBCQUEwQixpQ0FBaUMsc0JBQXNCLG1EQUFtRCw2Q0FBNkMsaURBQWlELDRDQUE0QywwQ0FBMEMsdUNBQXVDLDhUQUE4VCxxTEFBcUwsZ0RBQWdELG1DQUFtQyxHQUFHLDhQQUE4UCx3RkFBd0Ysb0VBQW9FLG9GQUFvRixHQUFHLHdvQkFBd29CLG1EQUFtRCw4R0FBOEcsb0RBQW9ELHFCQUFxQiw2QkFBNkIsT0FBTyw4QkFBOEIsNkZBQTZGLDJVQUEyVSx3REFBd0QsOERBQThELG9SQUFvUiwrSEFBK0gsK0hBQStILCtIQUErSCwrSEFBK0gsZUFBZSxPQUFPLDZIQUE2SCw2SEFBNkgsNkhBQTZILDZIQUE2SCxlQUFlLG1QQUFtUCxrSUFBa0ksZUFBZSxXQUFXLE9BQU8sOEhBQThILFdBQVcscURBQXFELDJEQUEyRCxtSEFBbUgsa0RBQWtELHFFQUFxRSxrREFBa0QsNERBQTRELHdEQUF3RCxrRUFBa0UsK0RBQStELHNCQUFzQixXQUFXLE9BQU8sK0NBQStDLGtDQUFrQyxXQUFXLE9BQU8saURBQWlELEdBQUcsd1FBQXdRLHdEQUF3RCxtRUFBbUUsd0NBQXdDLHlDQUF5QyxPQUFPLE9BQU8sMkRBQTJELCtEQUErRCwrREFBK0Qsc2NBQXNjLG9DQUFvQyx5Q0FBeUMseUNBQXlDLE9BQU8sR0FBRyxHOzs7Ozs7O0FDQXAzUDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQWlFO0FBQ1I7QUFDUDtBQUMzQztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2Usb0NBQW9DLDBEQUFlO0FBQ2xFO0FBQ0EsOENBQThDLGdFQUF1QixFQUFFLDJEQUFvQjtBQUMzRjtBQUNBO0FBQ0E7Ozs7Ozs7QUM1QkEsNkVBQTZFLGlGQUFpRiw4QkFBOEIseU9BQXlPLDZFQUE2RSxtQ0FBbUMsb0NBQW9DLHlDQUF5Qyw0Q0FBNEMsbUxBQW1MLG9DQUFvQyxxQ0FBcUMscUNBQXFDLDRCQUE0Qix5QkFBeUIsOEJBQThCLHlCQUF5QiwrQkFBK0IsNEJBQTRCLHFCQUFxQixpQ0FBaUMsb0JBQW9CLDBCQUEwQixpQ0FBaUMsc0JBQXNCLG1EQUFtRCw2Q0FBNkMsaURBQWlELDRDQUE0QywwQ0FBMEMsdUNBQXVDLDhUQUE4VCxxTEFBcUwsZ0RBQWdELG1DQUFtQyxHQUFHLDhQQUE4UCx3RkFBd0Ysb0VBQW9FLG9GQUFvRixHQUFHLHdvQkFBd29CLG1EQUFtRCw4R0FBOEcsb0RBQW9ELHFCQUFxQiw2QkFBNkIsT0FBTyw4QkFBOEIsNkZBQTZGLDJVQUEyVSx3REFBd0QsOERBQThELG9SQUFvUiwrSEFBK0gsK0hBQStILCtIQUErSCwrSEFBK0gsZUFBZSxPQUFPLDZIQUE2SCw2SEFBNkgsNkhBQTZILDZIQUE2SCxlQUFlLG1QQUFtUCxrSUFBa0ksZUFBZSxXQUFXLE9BQU8sOEhBQThILFdBQVcscURBQXFELDJEQUEyRCxtSEFBbUgsa0RBQWtELHFFQUFxRSxrREFBa0QsNERBQTRELHdEQUF3RCxrRUFBa0UsK0RBQStELHNCQUFzQixXQUFXLE9BQU8sK0NBQStDLGtDQUFrQyxXQUFXLE9BQU8saURBQWlELEdBQUcsMkJBQTJCLG9GQUFvRixrQ0FBa0MsbUNBQW1DLDJEQUEyRCwrREFBK0QsK0RBQStELDREQUE0RCxzY0FBc2MsMEJBQTBCLDhCQUE4Qiw0Q0FBNEMsOEJBQThCLHVDQUF1Qyw0Q0FBNEMsT0FBTyxPQUFPLHlDQUF5QyxPQUFPLEdBQUcsRzs7Ozs7OztBQ0F4eFA7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBa0Q7QUFDRTtBQUNLO0FBQ3pEO0FBQ0E7QUFDQTtBQUNlLDZCQUE2QixnRUFBZTtBQUMzRDtBQUNBLDhDQUE4Qyx3REFBZ0IsRUFBRSx3REFBa0I7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN2QkEsa0ZBQWtGLDhCQUE4QixvQ0FBb0MsMEJBQTBCLDRCQUE0Qix5QkFBeUIsOEJBQThCLHlCQUF5QixvQkFBb0IseUNBQXlDLDZDQUE2QyxpQkFBaUIsMEtBQTBLLDBEQUEwRCxnRkFBZ0Ysc0JBQXNCLEdBQUcsRzs7Ozs7O0FDQWx1Qix3REFBd0QsK0NBQStDLHlCQUF5QixvQkFBb0IsaUJBQWlCLHNEQUFzRCxHQUFHLEc7Ozs7Ozs7QUNBOU47QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQW9EO0FBQ0U7QUFDUjtBQUN3QjtBQUN0QjtBQUNnQjtBQUNoRSx5QkFBeUIscURBQVcsQ0FBQyxxRUFBdUI7QUFDNUQ7QUFDQSxpQ0FBaUMseURBQWlCLEVBQUUseURBQW1CO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDZSw4QkFBOEIsb0VBQXdCO0FBQ3JFO0FBQ0E7QUFDQSxpQ0FBaUMsb0RBQVc7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN6Q0Esa0ZBQWtGLDhCQUE4QiwwQkFBMEIsNEJBQTRCLHlCQUF5Qiw4QkFBOEIsb0JBQW9CLHlDQUF5Qyw2Q0FBNkMsaUJBQWlCLDBLQUEwSywrQkFBK0Isc0JBQXNCLEdBQUcsRzs7Ozs7O0FDQTFqQix3REFBd0QsK0NBQStDLHlCQUF5QixvQkFBb0IsaUJBQWlCLHNEQUFzRCxvQ0FBb0Msa0JBQWtCLE9BQU8sR0FBRyxHOzs7Ozs7O0FDQTNSO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQW9EO0FBQ0U7QUFDQTtBQUNJO0FBQ1Y7QUFDc0I7QUFDdEUseUJBQXlCLHFEQUFXO0FBQ3BDO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ2UsOEJBQThCLG9FQUF3QjtBQUNyRTtBQUNBLDhDQUE4Qyx5REFBaUIsRUFBRSx5REFBbUI7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsMkJBQTJCLG1FQUFhO0FBQ3hDLG9DQUFvQyxpRUFBZTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzNFQSxrRkFBa0YsOEJBQThCLCtCQUErQiw2QkFBNkIsNEJBQTRCLHlCQUF5Qiw4QkFBOEIsMkJBQTJCLDRCQUE0Qix5Q0FBeUMsNkNBQTZDLHFCQUFxQix5SkFBeUosaURBQWlELGlDQUFpQyxHQUFHLEc7Ozs7OztBQ0Evb0IsOEdBQThHLGlEQUFpRCx5QkFBeUIsZ0VBQWdFLG9DQUFvQyw4REFBOEQsb0lBQW9JLHFCQUFxQiwrQkFBK0IsMENBQTBDLHdDQUF3QyxtREFBbUQsb09BQW9PLEdBQUcsRzs7Ozs7OztBQ0E5M0I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUF3RDtBQUNFO0FBQ0Q7QUFDVDtBQUNnQjtBQUNoRSx5QkFBeUIscURBQVcsQ0FBQyxxRUFBdUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDZSw4QkFBOEIsOERBQVU7QUFDdkQ7QUFDQSw4Q0FBOEMsMkRBQW1CLEVBQUUsMkRBQXFCO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzFCQSx3REFBd0QscURBQXFELDBCQUEwQixvQkFBb0IsaUJBQWlCLCtDQUErQyxvQkFBb0IsR0FBRyxHOzs7Ozs7QUNBbFAsd0RBQXdELGlEQUFpRCxvQkFBb0IsaUJBQWlCLDRDQUE0QyxHQUFHLEc7Ozs7Ozs7QUNBN0w7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQTJFO0FBQ0U7QUFDL0I7QUFDbUQ7QUFDaEM7QUFDakU7QUFDQSx5QkFBeUIscURBQVcsQ0FBQyx5RkFBMkM7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNlLHlDQUF5QyxrRUFBc0I7QUFDOUU7QUFDQSw4Q0FBOEMscUVBQTRCLEVBQUUscUVBQThCO0FBQzFHO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsaUNBQWlDLG9EQUFXO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDbkRBLHdKQUF3Siw4QkFBOEIsb0NBQW9DLDBCQUEwQixrQ0FBa0MsK0JBQStCLDBDQUEwQywrQkFBK0IsNEJBQTRCLHlCQUF5Qiw4QkFBOEIsZ0NBQWdDLG9CQUFvQixrQkFBa0IsOEJBQThCLG9CQUFvQiwwQkFBMEIsNkJBQTZCLGtDQUFrQyx5Q0FBeUMsNkNBQTZDLHFCQUFxQixrQ0FBa0MsK0NBQStDLG1QQUFtUCxrQ0FBa0MsZ0NBQWdDLHVCQUF1QiwrQkFBK0IseUNBQXlDLDZCQUE2QixzSEFBc0gsMlVBQTJVLDhGQUE4RixHQUFHLEc7Ozs7OztBQ0FqekQsZ0lBQWdJLCtDQUErQyx5QkFBeUIsb0JBQW9CLGtCQUFrQiw4QkFBOEIsb0JBQW9CLDBCQUEwQiw2QkFBNkIsa0NBQWtDLHFCQUFxQixrSEFBa0gscUxBQXFMLGdRQUFnUSxnRUFBZ0Usd0NBQXdDLHdEQUF3RCwwREFBMEQsT0FBTyxtRUFBbUUsbUNBQW1DLEdBQUcsRzs7Ozs7OztBQ0EvdkM7QUFBQTtBQUFBO0FBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNlLHFDQUFxQyxvRUFBd0I7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2JBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQWtHO0FBQ3hDO0FBQ0U7QUFDSztBQUNqQjtBQUNoRDtBQUNBLDZDQUE2QztBQUN0QztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlLGlDQUFpQyxrRUFBc0I7QUFDdEUsc0VBQXNFLHFEQUFXO0FBQ2pGLDhDQUE4Qyw0REFBb0IsRUFBRSw0REFBc0I7QUFDMUY7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RCx5Q0FBeUMseUZBQWMsQ0FBQztBQUN4RCx1Q0FBdUMsdUZBQVksQ0FBQztBQUNwRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOzs7Ozs7OztBQ3RDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQTJDO0FBQ0k7QUFDSztBQUNzQjtBQUNSO0FBQ2pCO0FBQ1A7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGlEQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5Qiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLCtCQUErQjtBQUN0QztBQUNBO0FBQ0E7QUFDTyx5QkFBeUI7QUFDakIsbUNBQW1DLDJEQUFZO0FBQzlEO0FBQ0EsY0FBYyxzRkFBMEI7QUFDeEMsNkJBQTZCLG9EQUFXO0FBQ3hDLGlDQUFpQyxvREFBVztBQUM1QyxpQ0FBaUMsa0RBQVMsRUFBRSxrREFBUztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQywrREFBVyx1SEFBdUgsaUVBQVc7QUFDdkw7QUFDQSx1QkFBdUIsYUFBYTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpREFBUTtBQUNyQyw4QkFBOEIsb0RBQVc7QUFDekMsUUFBUSxrREFBUztBQUNqQixRQUFRLHNEQUFhO0FBQ3JCO0FBQ0E7QUFDQSxZQUFZLG1FQUFZLENBQUMsMERBQUs7QUFDOUIsZ0JBQWdCLG1FQUFZLENBQUMsMERBQUs7QUFDbEMsZ0JBQWdCLG1FQUFZLENBQUMsMERBQUs7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixvRUFBYSx1Q0FBdUMsb0VBQWE7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsb0RBQVc7QUFDeEM7QUFDQSxRQUFRLGtEQUFTO0FBQ2pCO0FBQ0EsUUFBUSxzREFBYTtBQUNyQixRQUFRLGlEQUFRO0FBQ2hCLFFBQVEsa0RBQVM7QUFDakI7QUFDQSxRQUFRLGtEQUFTO0FBQ2pCO0FBQ0EsUUFBUSxzREFBYTtBQUNyQixRQUFRLGlEQUFRO0FBQ2hCLFFBQVEsa0RBQVM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixvREFBVztBQUN4QztBQUNBLHFDQUFxQyxrREFBUztBQUM5QyxRQUFRLGtEQUFTO0FBQ2pCO0FBQ0EsUUFBUSxzREFBYTtBQUNyQixRQUFRLGlEQUFRO0FBQ2hCLFFBQVEsa0RBQVM7QUFDakI7QUFDQSxRQUFRLHNEQUFhO0FBQ3JCLFFBQVEsaURBQVE7QUFDaEIsUUFBUSxrREFBUztBQUNqQjtBQUNBLFFBQVEsa0RBQVM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msc0RBQWE7QUFDL0Msa0NBQWtDLGlEQUFRO0FBQzFDLFFBQVEsa0RBQVM7QUFDakIsUUFBUSxzREFBYTtBQUNyQjtBQUNBLHFDQUFxQyxvREFBVztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvREFBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQVM7QUFDakIsUUFBUSxrREFBUztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG9EQUFXO0FBQ3hDLFFBQVEsaURBQVE7QUFDaEIsUUFBUSxrREFBUztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxrREFBUztBQUMvQztBQUNBLG1DQUFtQyxvREFBVztBQUM5QyxRQUFRLGlEQUFRO0FBQ2hCLFFBQVEsdURBQWM7QUFDdEIsNkJBQTZCLG9EQUFXO0FBQ3hDO0FBQ0EsUUFBUSxpREFBUTtBQUNoQixRQUFRLHVEQUFjO0FBQ3RCLFFBQVEsa0RBQVM7QUFDakI7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBUztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaURBQVE7QUFDaEIsUUFBUSx1REFBYztBQUN0QixRQUFRLGtEQUFTO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9EQUFXO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN4U0EsZ1NBQWdTLG9DQUFvQyxnQ0FBZ0Msb0NBQW9DLDZCQUE2Qiw4QkFBOEIsK0JBQStCLCtCQUErQiw0QkFBNEIseUJBQXlCLDhCQUE4QixnQ0FBZ0Msb0JBQW9CLG9CQUFvQiwwQkFBMEIsb0JBQW9CLHFCQUFxQix5Q0FBeUMsNkNBQTZDLG9EQUFvRCwyQ0FBMkMscUNBQXFDLGdDQUFnQyxHQUFHLHFCQUFxQiw2REFBNkQsaUVBQWlFLGlDQUFpQyxrSkFBa0osa0RBQWtELGtFQUFrRSxzUkFBc1Isa0RBQWtELGtGQUFrRiw2REFBNkQsK0JBQStCLDRCQUE0QiwyQkFBMkIsR0FBRyxHOzs7Ozs7QUNBdDhELGlKQUFpSiwwQkFBMEIsZ0NBQWdDLHlCQUF5QiwwQkFBMEIscUJBQXFCLHlIQUF5SCwyQkFBMkIsMENBQTBDLCtEQUErRCx3REFBd0QsaUZBQWlGLE9BQU8scUNBQXFDLEdBQUcsRzs7Ozs7OztBQ0F4c0I7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQXlFO0FBQ0U7QUFDN0I7QUFDRTtBQUNnQjtBQUNNO0FBQ3RFLHlCQUF5QixxREFBVyxDQUFDLHFFQUF1QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ2Usd0NBQXdDLG9FQUF3QjtBQUMvRTtBQUNBLDhDQUE4QyxvRUFBMkIsRUFBRSxvRUFBNkI7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxpQ0FBaUMsb0RBQVc7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUM3Q0Esa0ZBQWtGLDhCQUE4QiwwQkFBMEIsbUNBQW1DLCtCQUErQiw0QkFBNEIseUJBQXlCLDhCQUE4Qiw0QkFBNEIsMkJBQTJCLDhCQUE4Qix5Q0FBeUMsNkNBQTZDLHFCQUFxQiwrQkFBK0IsZ0NBQWdDLHlxQ0FBeXFDLHdKQUF3Siw4RkFBOEYsNERBQTRELHNDQUFzQyxtQ0FBbUMsMEJBQTBCLGtJQUFrSSxHQUFHLEc7Ozs7OztBQ0FqdUUsMERBQTBELCtDQUErQyx5QkFBeUIsNEJBQTRCLDJCQUEyQiw4QkFBOEIscUJBQXFCLGdLQUFnSyxnRUFBZ0UsR0FBRyxHOzs7Ozs7O0FDQS9jO0FBQUE7QUFBQTtBQUFBO0FBQXdEO0FBQ1I7QUFDb0I7QUFDSjtBQUNoRTtBQUNBO0FBQ0E7QUFDZSwyQ0FBMkMsNERBQW1CO0FBQzdFO0FBQ0EsOENBQThDLHFEQUFXLENBQUMsZ0ZBQTJCLEdBQUcsbUJBQW1CLEVBQUUscUVBQXVCO0FBQ3BJO0FBQ0E7Ozs7Ozs7O0FDWEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQXdEO0FBQ0U7QUFDVjtBQUNzQjtBQUMvRDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlLGdDQUFnQyxvRUFBd0I7QUFDdkUsOERBQThELHFEQUFXO0FBQ3pFLDhDQUE4QywyREFBbUIsRUFBRSwyREFBcUI7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7Ozs7OztBQ3ZCQSxrRkFBa0YsOEJBQThCLDZCQUE2QiwrQkFBK0IsNEJBQTRCLHlCQUF5Qiw4QkFBOEIsdUJBQXVCLHlDQUF5Qyw2Q0FBNkMscUJBQXFCLDBLQUEwSyxrQ0FBa0MsZ0NBQWdDLHVCQUF1QiwrQkFBK0IsNEJBQTRCLEdBQUcsRzs7Ozs7O0FDQWxzQiw2RUFBNkUscUJBQXFCLDJCQUEyQixHQUFHLEc7Ozs7Ozs7QUNBaEk7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQThCO0FBQ3lCO0FBQ1k7QUFDVjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGlFQUFlO0FBQ3JEO0FBQ0E7QUFDQSwrQkFBK0Isc0VBQW9CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlLHdCQUF3QiwrQ0FBTTtBQUM3QztBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsZ0VBQWM7QUFDcEQsa0NBQWtDLGlFQUFlO0FBQ2pEO0FBQ0Esa0NBQWtDLGlFQUFlO0FBQ2pELDhCQUE4QixpRUFBZTtBQUM3QywrQkFBK0IsaUVBQWU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxRQUFRO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDaERBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBd0Q7QUFDcUI7QUFDeEI7QUFDd0I7QUFDYjtBQUNaO0FBQ2I7QUFDZ0I7QUFDSDtBQUNyQztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdFQUFjO0FBQzFDO0FBQ0EsaUNBQWlDLDhEQUFhO0FBQzlDO0FBQ0EscUNBQXFDLHNFQUFpQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsOEVBQXNCO0FBQ3BELGdDQUFnQyw4REFBYztBQUM5QyxtQ0FBbUMsb0VBQWdCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdGQUFvQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwyREFBUSxzQkFBc0Isd0VBQVk7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDM0VBO0FBQUE7QUFBQTtBQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDZSxxQ0FBcUMsNERBQVk7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7Ozs7Ozs7O0FDM0NBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDbkNBO0FBQUE7QUFBQTtBQUFBO0FBQTJDO0FBQ1o7QUFDL0I7QUFDQTtBQUNBO0FBQ2UsNkJBQTZCLHNEQUFZO0FBQ3hEO0FBQ0Esa0JBQWtCLGdEQUFNO0FBQ3hCO0FBQ0E7Ozs7Ozs7O0FDVEE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUM1Q0E7QUFBQTtBQUFBO0FBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNlLG1DQUFtQyw4REFBVTtBQUM1RDtBQUNBO0FBQ0EsZUFBZSw2QkFBNkI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7Ozs7Ozs7O0FDM0NBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBOEM7QUFDVTtBQUNDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQSxtQ0FBbUMsb0VBQWdCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG1FQUFnQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpRUFBVztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxpRUFBVywwRkFBMEYsaUVBQVc7QUFDeEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2xHQTtBQUFBO0FBQUE7QUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNERBQWlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHlEQUFjLFNBQVM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDL0ZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBaUQ7QUFDWjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLCtCQUErQixtREFBUztBQUN4QztBQUNBLGdDQUFnQyw2REFBZ0I7QUFDaEQsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNqTEE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7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d0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzlCQTtBQUFBO0FBQUE7QUFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQSw0QkFBNEIsb0VBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDbkVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBZ0M7QUFDaUI7QUFDSztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDZDQUFVO0FBQzdDO0FBQ0EsNkRBQTZELDhEQUFjLDhCQUE4Qiw4REFBYztBQUN2SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2U7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTs7Ozs7OztBQy9CQSw2RUFBNkUscUNBQXFDLDRCQUE0QixzQ0FBc0MsaUJBQWlCLHNEQUFzRCwwRUFBMEUsd0NBQXdDLHlCQUF5QixzRUFBc0UsR0FBRyxHOzs7Ozs7QUNBL2MsdUZBQXVGLGlCQUFpQixxQ0FBcUMsR0FBRyxHOzs7Ozs7O0FDQWhKO0FBQUE7QUFBQTtBQUFzRTtBQUN0RTtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsZ0VBQVk7QUFDaEQsa0NBQWtDLG9FQUFnQjtBQUNsRCw0QkFBNEIsb0VBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiaW5kZXgudHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMCk7XG4iLCJpbXBvcnQgQ29udGV4dCBmcm9tICcuLi8uLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL2NvbnRleHQnO1xyXG5pbXBvcnQgQ2FtZXJhIGZyb20gJy4uLy4uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9jYW1lcmEnO1xyXG5pbXBvcnQgVmVjdG9yQXBpQWRhcHRlciBmcm9tICcuLi8uLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdmVjdG9yX2FwaS9hZGFwdGVyJztcclxuaW1wb3J0IHsgQ2FtZXJhTW91c2VDb250cm9sbGVyLCBNb3VzZURyYWdDb250cm9sbGVyLCBTY3JvbGxab29tQ29udHJvbGxlciwgcmVuZGVyQ2FtZXJhU3RhdGUgfSBmcm9tICcuL2NhbWVyYV9zdHVmZic7XHJcbmltcG9ydCBDb2xvcklkUG9pbnRMYWJlbFJlbmRlcmVyIGZyb20gJy4uLy4uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS92aXNpYmlsaXR5L3ByaW1pdGl2ZXMvbGFiZWwvY29sb3JfaWRfcG9pbnRfbGFiZWxfcmVuZGVyZXInO1xyXG5pbXBvcnQgQ29sb3JJZEN1cnZlZExhYmVsUmVuZGVyZXIgZnJvbSAnLi4vLi4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3Zpc2liaWxpdHkvcHJpbWl0aXZlcy9sYWJlbC9jb2xvcl9pZF9jdXJ2ZWRfbGFiZWxfcmVuZGVyZXInO1xyXG5pbXBvcnQgUG9pbnRMYWJlbFJlbmRlclVuaXQgZnJvbSAnLi4vLi4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL2xhYmVsL3BvaW50X2xhYmVsX3JlbmRlcl91bml0JztcclxuaW1wb3J0IEN1cnZlZExhYmVsUmVuZGVyVW5pdCBmcm9tICcuLi8uLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvbGFiZWwvY3VydmVkX2xhYmVsX3JlbmRlcl91bml0JztcclxuaW1wb3J0IEljb25SZW5kZXJVbml0IGZyb20gJy4uLy4uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9pY29uL2ljb25fcmVuZGVyX3VuaXQnO1xyXG5pbXBvcnQgTW9kZWxSZW5kZXJVbml0IGZyb20gJy4uLy4uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9tb2RlbC9tb2RlbF9yZW5kZXJfdW5pdCc7XHJcbmltcG9ydCBUZXh0dXJlZFBvbHlsaW5lUmVuZGVyVW5pdCBmcm9tICcuLi8uLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvcG9seWxpbmUvdGV4dHVyZWRfcG9seWxpbmVfcmVuZGVyX3VuaXQnO1xyXG5pbXBvcnQgUG9seWxpbmVSZW5kZXJVbml0IGZyb20gJy4uLy4uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9wb2x5bGluZS9wb2x5bGluZV9yZW5kZXJfdW5pdCc7XHJcbmltcG9ydCBUZXh0dXJlZFBvbHlnb25SZW5kZXJVbml0IGZyb20gJy4uLy4uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9wb2x5Z29uL3RleHR1cmVkX3BvbHlnb25fcmVuZGVyX3VuaXQnO1xyXG5pbXBvcnQgVHJhbnNwYXJlbnRQb2x5Z29uUmVuZGVyVW5pdCBmcm9tICcuLi8uLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvcG9seWdvbi90cmFuc3BhcmVudF9wb2x5Z29uX3JlbmRlcl91bml0JztcclxuaW1wb3J0IFBvbHlnb25SZW5kZXJVbml0IGZyb20gJy4uLy4uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9wb2x5Z29uL3BvbHlnb25fcmVuZGVyX3VuaXQnO1xyXG5pbXBvcnQgTWFwRW5naW5lIGZyb20gJy4uLy4uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9tYXBfZW5naW5lJztcclxuaW1wb3J0IGdldERwciBmcm9tICcuLi8uLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9oZCc7XHJcbmltcG9ydCB7IENvbGxpZGluZ1ByaW1pdGl2ZXNSZXNldFJlbW92ZWRSZW5kZXJlciB9IGZyb20gJy4uLy4uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS92aXNpYmlsaXR5L3ByaW1pdGl2ZXMvY29sbGlkaW5nX3ByaW1pdGl2ZV9yZXNldF9yZW1vdmVkX3JlbmRlcmVyJztcclxuaW1wb3J0IFJlbmRlckxvb3AgZnJvbSAnLi4vLi4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlcl9sb29wJztcclxuLy8gaW1wb3J0IEltYWdlUmVuZGVyVW5pdCBmcm9tICcuLi8uLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvaW1hZ2UvaW1hZ2VfcmVuZGVyX3VuaXQnO1xyXG4vLyBpbXBvcnQgUmFzdGVyVGlsZXNBZGFwdGVyIGZyb20gJy4uLy4uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9hZGFwdGVycy9yYXN0ZXJfdGlsZXMvYWRhcHRlcic7XHJcbi8vIGltcG9ydCB7VGlsZUl0ZW19IGZyb20gJy4uLy4uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9hZGFwdGVycy90aWxlX2Jhc2VkX2FkYXB0ZXIvdXRpbC90aWxlX3N5c3RlbSc7XHJcbmNvbnN0IEdMX0NPTlRFWFRfQVRUUklCUyA9IHtcclxuICAgIGFscGhhOiBmYWxzZSxcclxuICAgIGRlcHRoOiB0cnVlLFxyXG4gICAgc3RlbmNpbDogZmFsc2UsXHJcbiAgICBhbnRpYWxpYXM6IGZhbHNlLFxyXG4gICAgZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdDogdHJ1ZVxyXG59O1xyXG5jb25zdCBjYW1lcmEgPSBuZXcgQ2FtZXJhKHtcclxuICAgIHdyYXBNb2RlWDogMiAvKiBSRVBFQVQgKi8sXHJcbiAgICB3cmFwTW9kZVk6IDAgLyogTk9ORSAqL1xyXG59KTtcclxuY2FtZXJhLm9uVXBkYXRlLmFkZExpc3RlbmVyKCgpID0+IHJlbmRlckNhbWVyYVN0YXRlKGNhbWVyYSkpO1xyXG5jYW1lcmEuY2VudGVyLnggPSAwLjIwODk4NDM3O1xyXG5jYW1lcmEuY2VudGVyLnkgPSAwLjM3MzA0Njg3O1xyXG5jYW1lcmEuem9vbSA9IDE0O1xyXG5jb25zdCBjYW52YXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjY2FudmFzJyk7XHJcbntcclxuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgY29uc3QgZHByID0gZ2V0RHByKCk7XHJcbiAgICBjYW52YXMud2lkdGggPSBkcHIgKiB3aWR0aDtcclxuICAgIGNhbnZhcy5oZWlnaHQgPSBkcHIgKiBoZWlnaHQ7XHJcbiAgICBjYW1lcmEuc2NyZWVuU2l6ZS53aWR0aCA9IHdpZHRoO1xyXG4gICAgY2FtZXJhLnNjcmVlblNpemUuaGVpZ2h0ID0gaGVpZ2h0O1xyXG59XHJcbmNvbnN0IGNhbWVyYU1vdXNlQ29udHJvbGxlciA9IG5ldyBDYW1lcmFNb3VzZUNvbnRyb2xsZXIoY2FudmFzLCBjYW1lcmEpO1xyXG5jb25zdCBtb3VzZURyYWdDb250cm9sbGVyID0gbmV3IE1vdXNlRHJhZ0NvbnRyb2xsZXIoY2FudmFzKTtcclxubW91c2VEcmFnQ29udHJvbGxlci5zZXREZWxlZ2F0ZShjYW1lcmFNb3VzZUNvbnRyb2xsZXIpO1xyXG5jb25zdCBzY3JvbGxab29tQ29udHJvbGxlciA9IG5ldyBTY3JvbGxab29tQ29udHJvbGxlcihjYW52YXMpO1xyXG5zY3JvbGxab29tQ29udHJvbGxlci5zZXREZWxlZ2F0ZShjYW1lcmFNb3VzZUNvbnRyb2xsZXIpO1xyXG5jb25zdCBjb250ZXh0ID0gQ29udGV4dC5jcmVhdGVGcm9tQ2FudmFzKGNhbnZhcywgR0xfQ09OVEVYVF9BVFRSSUJTKTtcclxuY29uc3QgZW5naW5lID0gbmV3IE1hcEVuZ2luZShjb250ZXh0LCBjYW1lcmEsIG5ldyBSZW5kZXJMb29wKCkpO1xyXG5jb25zdCB2ZWN0b3JBZGFwdGVyID0gbmV3IFZlY3RvckFwaUFkYXB0ZXIoZW5naW5lLCBjYW1lcmEsICcuL3RpbGVfcHJvdmlkZXJfd29ya2VyLmpzP3dvcmtlcicsIFxyXG4vLyAnL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9hZGFwdGVycy92ZWN0b3JfYXBpL3dvcmtlci90aWxlX3Byb3ZpZGVyX3dvcmtlci5qcz93b3JrZXInLFxyXG4nbWFwJywgXHJcbi8vIHtcclxuLy8gICAgIHRpbGVVcmxUZW1wbGF0ZTogJ2h0dHBzOi8vdmVjLXJkcjAxZS50c3QubWFwcy55YW5kZXgucnUvdm1hcDIvdGlsZXM/bD12bWFwMiZsYW5nPXJ1X1JVJng9e3t4fX0meT17e3l9fSZ6PXt7en19JnptaW49e3t6bWlufX0mem1heD17e3ptYXh9fScsXHJcbi8vICAgICBpbWFnZVVybFRlbXBsYXRlOiAnaHR0cHM6Ly92ZWMtcmRyMDFlLnRzdC5tYXBzLnlhbmRleC5ydS9yZXNvdXJjZXM/aWQ9e3tpZH19JnNjYWxlPXt7c2NhbGV9fScsXHJcbi8vICAgICBtZXNoVXJsVGVtcGxhdGU6ICdodHRwczovL3ZlYy1yZHIwMWUudHN0Lm1hcHMueWFuZGV4LnJ1L21lc2hlcz9pZD17e2lkfX0nLFxyXG4vLyAgICAgZ2x5cGhSYW5nZVVybFRlbXBsYXRlOiAnaHR0cHM6Ly92ZWMtcmRyMDFlLnRzdC5tYXBzLnlhbmRleC5ydS9nbHlwaHM/bGFuZz1ydV9SVSZmb250X2lkPXt7Zm9udElkfX0mcmFuZ2U9e3tyYW5nZX19J1xyXG4vLyB9XHJcbntcclxuICAgIHRpbGVVcmxUZW1wbGF0ZTogJ2h0dHBzOi8vdmVjMHt7aG9zdEFsaWFzfX0ubWFwcy55YW5kZXgubmV0L3ZtYXAyL3RpbGVzP2w9dm1hcDImbGFuZz1SVV9ydSZ4PXt7eH19Jnk9e3t5fX0mej17e3p9fSZ6bWluPXt7em1pbn19JnptYXg9e3t6bWF4fX0nLFxyXG4gICAgaW1hZ2VVcmxUZW1wbGF0ZTogJ2h0dHBzOi8vdmVjMHt7aG9zdEFsaWFzfX0ubWFwcy55YW5kZXgubmV0L3Jlc291cmNlcz9pZD17e2lkfX0mc2NhbGU9e3tzY2FsZX19JyxcclxuICAgIG1lc2hVcmxUZW1wbGF0ZTogJ2h0dHBzOi8vdmVjMHt7aG9zdEFsaWFzfX0ubWFwcy55YW5kZXgubmV0L3ZtYXAyL21lc2hlcz9pZD17e2lkfX0nLFxyXG4gICAgZ2x5cGhSYW5nZVVybFRlbXBsYXRlOiAnaHR0cHM6Ly92ZWMwe3tob3N0QWxpYXN9fS5tYXBzLnlhbmRleC5uZXQvZ2x5cGhzP2xhbmc9UlVfcnUmZm9udF9pZD17e2ZvbnRJZH19JnJhbmdlPXt7cmFuZ2V9fSdcclxufSwgMSAvKiBYNCAqLyk7XHJcbi8vIGNsYXNzIFRyYWZmaWNMYXllckFkYXB0ZXIgZXh0ZW5kcyBSYXN0ZXJUaWxlc0FkYXB0ZXIge1xyXG4vLyAgICAgcHVibGljIF9nZXRJbWFnZVVybCh0aWxlOiBUaWxlSXRlbSk6IHN0cmluZyB7XHJcbi8vICAgICAgICAgcmV0dXJuIGBodHRwczovL2pnby5tYXBzLnlhbmRleC5uZXQvMS4xL3RpbGVzP3RyZiZsPXRyZix0cmZlJmxhbmc9cnVfVUEmeD0ke3RpbGUueH0meT0ke3RpbGUueX0mej0ke3RpbGUuem9vbX0mc2NhbGU9JHt3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpb30mdG09JHtNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKX1gXHJcbi8vICAgICAgICAgLy8gcmV0dXJuIGBodHRwczovL3NhdDAzLm1hcHMueWFuZGV4Lm5ldC90aWxlcz9sPXNhdCZ2PTMuNDE5LjAmeD0ke3RpbGUueH0meT0ke3RpbGUueX0mej0ke3RpbGUuem9vbX0mc2NhbGU9JHt3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpb30mbGFuZz1ydV9VQWBcclxuLy8gICAgIH1cclxuLy8gfVxyXG4vLyBjb25zdCB0cmFmZmljQWRhcHRlciA9IG5ldyBUcmFmZmljTGF5ZXJBZGFwdGVyKFxyXG4vLyAgICAgZW5naW5lLFxyXG4vLyAgICAgY2FtZXJhLFxyXG4vLyAgICAge3dpZHRoOiAyNTYgKiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbywgaGVpZ2h0OiAyNTYgKiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpb31cclxuLy8gKTtcclxuZW5naW5lLmdyb3VuZExheWVyLmFkZFJlbmRlclVuaXQobmV3IFBvbHlnb25SZW5kZXJVbml0KGNvbnRleHQsIHZlY3RvckFkYXB0ZXIub3BhcXVlUG9seWdvbnNQcm92aWRlcikpO1xyXG5lbmdpbmUuZ3JvdW5kTGF5ZXIuYWRkUmVuZGVyVW5pdChuZXcgVHJhbnNwYXJlbnRQb2x5Z29uUmVuZGVyVW5pdChjb250ZXh0LCB2ZWN0b3JBZGFwdGVyLnRyYW5zcGFyZW50UG9seWdvbnNQcm92aWRlcikpO1xyXG5lbmdpbmUuZ3JvdW5kTGF5ZXIuYWRkUmVuZGVyVW5pdChuZXcgVGV4dHVyZWRQb2x5Z29uUmVuZGVyVW5pdChjb250ZXh0LCB2ZWN0b3JBZGFwdGVyLnRleHR1cmVkUG9seWdvbnNQcm92aWRlcikpO1xyXG5lbmdpbmUuZ3JvdW5kTGF5ZXIuYWRkUmVuZGVyVW5pdChuZXcgUG9seWxpbmVSZW5kZXJVbml0KGNvbnRleHQsIGNhbWVyYSwgdmVjdG9yQWRhcHRlci5wb2x5bGluZXNQcm92aWRlcikpO1xyXG5lbmdpbmUuZ3JvdW5kTGF5ZXIuYWRkUmVuZGVyVW5pdChuZXcgVGV4dHVyZWRQb2x5bGluZVJlbmRlclVuaXQoY29udGV4dCwgY2FtZXJhLCB2ZWN0b3JBZGFwdGVyLnRleHR1cmVkUG9seWxpbmVzUHJvdmlkZXIpKTtcclxuZW5naW5lLmJ1aWxkaW5nc0xheWVyLmFkZFJlbmRlclVuaXQobmV3IE1vZGVsUmVuZGVyVW5pdChjb250ZXh0LCB2ZWN0b3JBZGFwdGVyLm1vZGVsc1Byb3ZpZGVyKSk7XHJcbi8vIGVuZ2luZS5pY29uc0xheWVyLmFkZFJlbmRlclVuaXQobmV3IEltYWdlUmVuZGVyVW5pdChjb250ZXh0LCB0cmFmZmljQWRhcHRlci5pbWFnZXNQcm92aWRlcikpO1xyXG5lbmdpbmUuaWNvbnNMYXllci5hZGRSZW5kZXJVbml0KG5ldyBJY29uUmVuZGVyVW5pdChjb250ZXh0LCBjYW1lcmEsIHZlY3RvckFkYXB0ZXIuaWNvbnNQcm92aWRlcikpO1xyXG5lbmdpbmUubGFiZWxzTGF5ZXIuYWRkUmVuZGVyVW5pdChuZXcgQ3VydmVkTGFiZWxSZW5kZXJVbml0KGNvbnRleHQsIGNhbWVyYSwgZW5naW5lLnZpc2JpbGl0eVRleHR1cmVQcm92aWRlciwgdmVjdG9yQWRhcHRlci5jdXJ2ZWRMYWJlbHNQcm92aWRlcikpO1xyXG5lbmdpbmUubGFiZWxzTGF5ZXIuYWRkUmVuZGVyVW5pdChuZXcgUG9pbnRMYWJlbFJlbmRlclVuaXQoY29udGV4dCwgY2FtZXJhLCBlbmdpbmUudmlzYmlsaXR5VGV4dHVyZVByb3ZpZGVyLCB2ZWN0b3JBZGFwdGVyLnBvaW50TGFiZWxzUHJvdmlkZXIpKTtcclxuZW5naW5lLnZpc2liaWxpdHlNYW5hZ2VyLnJlZ2lzdGVyQ29sbGlkaW5nUHJpbWl0aXZlcyh2ZWN0b3JBZGFwdGVyLmN1cnZlZExhYmVsc1Byb3ZpZGVyLCBuZXcgQ29sb3JJZEN1cnZlZExhYmVsUmVuZGVyZXIoY29udGV4dCwgY2FtZXJhLCB2ZWN0b3JBZGFwdGVyLmN1cnZlZExhYmVsc1Byb3ZpZGVyKSwgbmV3IENvbGxpZGluZ1ByaW1pdGl2ZXNSZXNldFJlbW92ZWRSZW5kZXJlcihjb250ZXh0LCB2ZWN0b3JBZGFwdGVyLmN1cnZlZExhYmVsc1Byb3ZpZGVyKSk7XHJcbmVuZ2luZS52aXNpYmlsaXR5TWFuYWdlci5yZWdpc3RlckNvbGxpZGluZ1ByaW1pdGl2ZXModmVjdG9yQWRhcHRlci5wb2ludExhYmVsc1Byb3ZpZGVyLCBuZXcgQ29sb3JJZFBvaW50TGFiZWxSZW5kZXJlcihjb250ZXh0LCBjYW1lcmEsIHZlY3RvckFkYXB0ZXIucG9pbnRMYWJlbHNQcm92aWRlciksIG5ldyBDb2xsaWRpbmdQcmltaXRpdmVzUmVzZXRSZW1vdmVkUmVuZGVyZXIoY29udGV4dCwgdmVjdG9yQWRhcHRlci5wb2ludExhYmVsc1Byb3ZpZGVyKSk7XHJcbmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwbHVzJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XHJcbiAgICBjYW1lcmEuem9vbSArPSAwLjE7XHJcbn0pO1xyXG5kb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWludXMnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcclxuICAgIGNhbWVyYS56b29tIC09IDAuMTtcclxufSk7XHJcbi8vIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4vLyAgICAgY29uc29sZS5sb2coJ1NldHRpbmcgbmV3IHRpbGUgdXJsIHRlbXBsYXRlJyk7XHJcbi8vICAgICB2ZWN0b3JBZGFwdGVyLnNldFRpbGVVcmxUZW1wbGF0ZSgnaHR0cHM6Ly92ZWMtcmRyMDFlLnRzdC5tYXBzLnlhbmRleC5ydS92bWFwMi90aWxlcz9sPXZtYXAyJmxhbmc9cnVfUlUmeD17e3h9fSZ5PXt7eX19Jno9e3t6fX0mem1pbj17e3ptaW59fSZ6bWF4PXt7em1heH19Jyk7XHJcbi8vIH0sIDQwMDApO1xyXG4iLCJpbXBvcnQgeyBBdHRyaWJ1dGVNYXBwaW5nIH0gZnJvbSAnLi9hdHRyaWJfbWFwcGluZyc7XHJcbmltcG9ydCBCdWZmZXIgZnJvbSAnLi9nbC9idWZmZXInO1xyXG5pbXBvcnQgRnJhbWVidWZmZXIgZnJvbSAnLi9nbC9mcmFtZWJ1ZmZlcic7XHJcbmltcG9ydCBQcm9ncmFtIGZyb20gJy4vZ2wvcHJvZ3JhbSc7XHJcbmltcG9ydCBSZW5kZXJidWZmZXIgZnJvbSAnLi9nbC9yZW5kZXJidWZmZXInO1xyXG5pbXBvcnQgUmVuZGVyQ29udGV4dENhcGFiaWxpdGllc01hbmFnZXIgZnJvbSAnLi9jYXBhYmlsaXRpZXMnO1xyXG5pbXBvcnQgUmVuZGVyU3RhdGUgZnJvbSAnLi9zdGF0ZSc7XHJcbmltcG9ydCBUZXh0dXJlLCB7IERFRkFVTFRfVEVYVFVSRV9QQVJBTVMgfSBmcm9tICcuL2dsL3RleHR1cmUnO1xyXG5pbXBvcnQgVmVydGV4QXJyYXlPYmplY3QgZnJvbSAnLi9nbC92YW8nO1xyXG5pbXBvcnQgKiBhcyBjb2xvciBmcm9tICcuLi91dGlsL2NvbG9yJztcclxuaW1wb3J0IHsgVm9pZEV2ZW50RW1pdHRlciB9IGZyb20gJy4uL3V0aWwvZXZlbnRfZW1pdHRlcic7XHJcbmNvbnN0IFFVQURfVkVSVEVYX0RBVEEgPSBuZXcgRmxvYXQzMkFycmF5KFtcclxuICAgIC8vIHRzbGludDpkaXNhYmxlXHJcbiAgICAvLyB4ICAgeSAgdSAgdlxyXG4gICAgLTEsIC0xLCAwLCAwLFxyXG4gICAgMSwgMSwgMSwgMSxcclxuICAgIC0xLCAxLCAwLCAxLFxyXG4gICAgLTEsIC0xLCAwLCAwLFxyXG4gICAgMSwgLTEsIDEsIDAsXHJcbiAgICAxLCAxLCAxLCAxXHJcbiAgICAvLyB0c2xpbnQ6ZW5hYmxlXHJcbl0pO1xyXG5jb25zdCBRVUFEX0FUVFJJQl9NQVBQSU5HID0gbmV3IEF0dHJpYnV0ZU1hcHBpbmcoW1xyXG4gICAgW1xyXG4gICAgICAgIDAgLyogUE9TSVRJT04gKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTI2IC8qIEZMT0FUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgNCAvKiBVViAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDIsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjYgLyogRkxPQVQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgXVxyXG5dKTtcclxuLyoqXHJcbiAqIERlZmF1bHQgcmVuZGVyIHRhcmdldCBvZiBhIFdlYkdMIGNvbnRleHQsIHdoaWNoIGlzIGNhbnZhcyBlbGVtZW50IG9mIHRoZVxyXG4gKiBjb250ZXh0LlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIERlZmF1bHRSZW5kZXJUYXJnZXQge1xyXG4gICAgY29uc3RydWN0b3IoZ2wpIHtcclxuICAgICAgICB0aGlzLmlzQ2xlYXIgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9nbCA9IGdsO1xyXG4gICAgfVxyXG4gICAgYmluZCgpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xyXG4gICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XHJcbiAgICB9XHJcbiAgICBzZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICBjb25zdCBjYW52YXMgPSB0aGlzLl9nbC5jYW52YXM7XHJcbiAgICAgICAgY2FudmFzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcclxuICAgIH1cclxuICAgIGdldFdpZHRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9nbC5kcmF3aW5nQnVmZmVyV2lkdGg7XHJcbiAgICB9XHJcbiAgICBnZXRIZWlnaHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dsLmRyYXdpbmdCdWZmZXJIZWlnaHQ7XHJcbiAgICB9XHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIC8vIFdlIGNhbid0IGRlc3Ryb3kgZGVmYXVsdCByZW5kZXIgdGFyZ2V0LCBzbyBkbyBub3RoaW5nLlxyXG4gICAgICAgIC8vIFRPRE8oZG1pa2lzKSBUaHJvdyBhbiBleGNlcHRpb24/XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFdyYXBwZXIgYXJvdW5kIFdlYkdMIGNvbnRleHQuIFNlcnZlcyB0byBsb2NhbGl6ZSBhbGwgR0wgY2FsbHMgdG8gbWluaW11bSBzZXRcclxuICogb2Ygb2JqZWN0cy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbmRlckNvbnRleHQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHdyYXBwZXIgZm9yIGEgZ2l2ZW4gV2ViR0wgY29udGV4dC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZ2wgVGhlIGNvbnRleHQgdG8gYmUgd3JhcHBlZC5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZ2wpIHtcclxuICAgICAgICB0aGlzLl9nbCA9IGdsO1xyXG4gICAgICAgIHRoaXMub25Mb3NzID0gbmV3IFZvaWRFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0TG9zdExpc3RlbmVyID0gKGUpID0+IHtcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB0aGlzLm9uTG9zcy5maXJlKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBnbC5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0bG9zdCcsIHRoaXMuX2NvbnRleHRMb3N0TGlzdGVuZXIpO1xyXG4gICAgICAgIHRoaXMuX2NhcGFiaWxpdGllcyA9IG5ldyBSZW5kZXJDb250ZXh0Q2FwYWJpbGl0aWVzTWFuYWdlcihnbCk7XHJcbiAgICAgICAgY29uc3QgdmFvRXh0ID0gZ2wuZ2V0RXh0ZW5zaW9uKCdPRVNfdmVydGV4X2FycmF5X29iamVjdCcpO1xyXG4gICAgICAgIGlmICghdmFvRXh0KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT0VTX3ZlcnRleF9hcnJheV9vYmplY3QgaXMgcmVxdWlyZWQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3Zhb0V4dCA9IHZhb0V4dDtcclxuICAgICAgICBpZiAoIWdsLmdldEV4dGVuc2lvbignT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzJykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMgaXMgcmVxdWlyZWQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGRlZmF1bHRSZW5kZXJUYXJnZXQgPSB0aGlzLl9ib3VuZFJlbmRlclRhcmdldCA9XHJcbiAgICAgICAgICAgIHRoaXMuX2RlZmF1bHRSZW5kZXJUYXJnZXQgPVxyXG4gICAgICAgICAgICAgICAgbmV3IERlZmF1bHRSZW5kZXJUYXJnZXQoZ2wpO1xyXG4gICAgICAgIGNvbnN0IGJvdW5kU3RhdGUgPSB0aGlzLl9ib3VuZFJlbmRlclN0YXRlID0gbmV3IFJlbmRlclN0YXRlKCk7XHJcbiAgICAgICAgdGhpcy5fdW5wYWNrUHJlbXVsdGlwbHlBbHBoYSA9IGZhbHNlO1xyXG4gICAgICAgIC8vIERlZmF1bHQgdmlld3BvcnQgYW5kIHNjaXNzb3IgcmVjdGFuZ2xlIHNpemVzIGFyZSBlcXVhbCB0byB0aGUgc2l6ZSBvZlxyXG4gICAgICAgIC8vIHRoZSBjYW52YXMgb2YgdGhlIFdlYkdMIGNvbnRleHQuIEJ1dCB3ZSBoYXZlIG5vIHdheSBvZiBrbm93aW5nIHRoZW0gaW5cclxuICAgICAgICAvLyBSZW5kZXJTdGF0ZSdzIGNvbnN0cnVjdG9yLiBTbyB3ZSdyZSBmaXhpbmcgdGhlbSBoZXJlLlxyXG4gICAgICAgIGJvdW5kU3RhdGUuc2Npc3NvcldpZHRoID0gYm91bmRTdGF0ZS52aWV3cG9ydFdpZHRoID1cclxuICAgICAgICAgICAgZGVmYXVsdFJlbmRlclRhcmdldC5nZXRXaWR0aCgpO1xyXG4gICAgICAgIGJvdW5kU3RhdGUuc2Npc3NvckhlaWdodCA9IGJvdW5kU3RhdGUudmlld3BvcnRIZWlnaHQgPVxyXG4gICAgICAgICAgICBkZWZhdWx0UmVuZGVyVGFyZ2V0LmdldEhlaWdodCgpO1xyXG4gICAgICAgIGNvbnN0IHF1YWRCdWZmZXIgPSB0aGlzLl9xdWFkVmVydGV4QnVmZmVyID1cclxuICAgICAgICAgICAgbmV3IEJ1ZmZlcihnbCwgZ2wuQVJSQVlfQlVGRkVSLCBnbC5TVEFUSUNfRFJBVyk7XHJcbiAgICAgICAgcXVhZEJ1ZmZlci5iaW5kKCk7XHJcbiAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIFFVQURfVkVSVEVYX0RBVEEsIGdsLlNUQVRJQ19EUkFXKTtcclxuICAgICAgICB0aGlzLl9xdWFkVmFvID0gdGhpcy5jcmVhdGVWYW8oUVVBRF9BVFRSSUJfTUFQUElORywgcXVhZEJ1ZmZlciwgbnVsbCk7XHJcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIG51bGwpO1xyXG4gICAgICAgIHRoaXMuX2JvdW5kUHJvZ3JhbSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fYm91bmRWYW8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2JvdW5kVGV4dHVyZXMgPSBuZXcgQXJyYXkodGhpcy5fY2FwYWJpbGl0aWVzLmdldE1heENvbWJpbmVkVGV4dHVyZUltYWdlVW5pdHMoKSk7XHJcbiAgICAgICAgdGhpcy5fYm91bmRUZXh0dXJlcy5maWxsKG51bGwpO1xyXG4gICAgICAgIHRoaXMuX2JvdW5kVGV4dHVyZVVuaXQgPSAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIG9iamVjdCB0byByZXF1ZXN0IGNhcGFiaWxpdGllcyBvZiB0aGUgY29udGV4dCBzdWNoIGFzIG1heGltdW1cclxuICAgICAqIHRleHR1cmUgc2l6ZSBvciBtYXhpbXVtIG51bWJlciBvZiB1bmlmb3JtIHZlY3RvcnMgYWxsb3dlZCBpbiBzaGFkZXJzLlxyXG4gICAgICovXHJcbiAgICBnZXRDYXBhYmlsaXRpZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhcGFiaWxpdGllcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBmcmFtZWJ1ZmZlciB3aXRoIGdpdmVuIGF0dGFjaG1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBkZXNjcmlwdG9yIE9iamVjdCBjb250YWluaW5nIGZyYW1lYnVmZmVyIGF0dGFjaG1lbnRzLlxyXG4gICAgICogQHJldHVybnMgQ3JlYXRlZCBmcmFtZWJ1ZmZlciBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIGNyZWF0ZUZyYW1lYnVmZmVyKHsgY29sb3IsIGRlcHRoLCBzdGVuY2lsLCBkZXB0aFN0ZW5jaWwgfSkge1xyXG4gICAgICAgIC8vIFRPRE8gVW5jb21tZW50IGFuZCBwdXQgdW5kZXIgZGVidWcgZmxhZyAod2hlbiBpbXBsZW1lbnRlZClcclxuICAgICAgICAvLyBpZiAoZGVwdGhTdGVuY2lsICYmIChkZXB0aCB8fCBzdGVuY2lsKSkge1xyXG4gICAgICAgIC8vICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgLy8gICAgICAgICAnRnJhbWVidWZmZXIgY2FuXFwndCBoYXZlIERFUFRIX1NURU5DSUwgYW5kIERFUFRIIG9yIFNURU5DSUwgJyArXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgJ2F0dGFjaG1lbnQgc2ltdWx0YW5lb3VzbHkuJ1xyXG4gICAgICAgIC8vICAgICApO1xyXG4gICAgICAgIC8vIH1cclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xyXG4gICAgICAgIGxldCB3aWR0aCA9IDA7XHJcbiAgICAgICAgbGV0IGhlaWdodCA9IDA7XHJcbiAgICAgICAgaWYgKGNvbG9yKSB7XHJcbiAgICAgICAgICAgIHdpZHRoID0gY29sb3IuZ2V0V2lkdGgoKTtcclxuICAgICAgICAgICAgaGVpZ2h0ID0gY29sb3IuZ2V0SGVpZ2h0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGRlcHRoKSB7XHJcbiAgICAgICAgICAgIHdpZHRoID0gZGVwdGguZ2V0V2lkdGgoKTtcclxuICAgICAgICAgICAgaGVpZ2h0ID0gZGVwdGguZ2V0SGVpZ2h0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHN0ZW5jaWwpIHtcclxuICAgICAgICAgICAgd2lkdGggPSBzdGVuY2lsLmdldFdpZHRoKCk7XHJcbiAgICAgICAgICAgIGhlaWdodCA9IHN0ZW5jaWwuZ2V0SGVpZ2h0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGRlcHRoU3RlbmNpbCkge1xyXG4gICAgICAgICAgICB3aWR0aCA9IGRlcHRoU3RlbmNpbC5nZXRXaWR0aCgpO1xyXG4gICAgICAgICAgICBoZWlnaHQgPSBkZXB0aFN0ZW5jaWwuZ2V0SGVpZ2h0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGZyYW1lYnVmZmVyID0gbmV3IEZyYW1lYnVmZmVyKGdsLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLmJpbmRSZW5kZXJUYXJnZXQoZnJhbWVidWZmZXIpO1xyXG4gICAgICAgIGlmIChjb2xvcikge1xyXG4gICAgICAgICAgICBjb2xvci5hdHRhY2hUb0ZyYW1lYnVmZmVyKGdsLkNPTE9SX0FUVEFDSE1FTlQwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRlcHRoKSB7XHJcbiAgICAgICAgICAgIGRlcHRoLmF0dGFjaFRvRnJhbWVidWZmZXIoZ2wuREVQVEhfQVRUQUNITUVOVCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdGVuY2lsKSB7XHJcbiAgICAgICAgICAgIHN0ZW5jaWwuYXR0YWNoVG9GcmFtZWJ1ZmZlcihnbC5TVEVOQ0lMX0FUVEFDSE1FTlQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGVwdGhTdGVuY2lsKSB7XHJcbiAgICAgICAgICAgIGRlcHRoU3RlbmNpbC5hdHRhY2hUb0ZyYW1lYnVmZmVyKGdsLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRPRE8gVW5jb21tZW50IGFuZCBwdXQgdW5kZXIgZGVidWcgZmxhZyAod2hlbiBpbXBsZW1lbnRlZClcclxuICAgICAgICAvLyBzd2l0Y2ggKGdsLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMoZ2wuRlJBTUVCVUZGRVIpKSB7XHJcbiAgICAgICAgLy8gICAgIGNhc2UgZ2wuRlJBTUVCVUZGRVJfSU5DT01QTEVURV9BVFRBQ0hNRU5UOlxyXG4gICAgICAgIC8vICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGcmFtZWJ1ZmZlciBhdHRhY2htZW50cyBhcmUgbm90IHJlbmRlcmFibGUnKTtcclxuICAgICAgICAvLyAgICAgY2FzZSBnbC5GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0RJTUVOU0lPTlM6XHJcbiAgICAgICAgLy8gICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZyYW1lYnVmZmVyIGF0dGFjaG1lbnRzIGFyZSBub3Qgc2FtZSBzaXplJyk7XHJcbiAgICAgICAgLy8gICAgIGNhc2UgZ2wuRlJBTUVCVUZGRVJfSU5DT01QTEVURV9NSVNTSU5HX0FUVEFDSE1FTlQ6XHJcbiAgICAgICAgLy8gICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZyYW1lYnVmZmVyIGhhcyBubyBhdHRhY2htZW50cycpO1xyXG4gICAgICAgIC8vICAgICBjYXNlIGdsLkZSQU1FQlVGRkVSX1VOU1VQUE9SVEVEOlxyXG4gICAgICAgIC8vICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGcmFtZWJ1ZmZlciBoYXMgdW5zdXBwb3J0ZWQgYXR0YWNobWVudCcpO1xyXG4gICAgICAgIC8vIH1cclxuICAgICAgICByZXR1cm4gZnJhbWVidWZmZXI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFsbG9jYXRlcyBhIG5ldyByZW5kZXJidWZmZXIgd2l0aCBnaXZlbiBzaXplIGFuZCBmb3JtYXQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHdpZHRoIFdpZHRoIG9mIHRoZSByZW5kZXJidWZmZXIuXHJcbiAgICAgKiBAcGFyYW0gaGVpZ2h0IEhlaWdodCBvZiB0aGUgcmVuZGVyYnVmZmVyLlxyXG4gICAgICogQHBhcmFtIGZvcm1hdCBGb3JtYXQgb2YgdGhlIHJlbmRlcmJ1ZmZlci5cclxuICAgICAqIEByZXR1cm4gVGhlIGFsbG9jYXRlZCByZW5kZXJidWZmZXIuXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBjcmVhdGVSZW5kZXJidWZmZXIod2lkdGgsIGhlaWdodCwgZm9ybWF0KSB7XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcclxuICAgICAgICBjb25zdCByZW5kZXJidWZmZXIgPSBuZXcgUmVuZGVyYnVmZmVyKGdsLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICByZW5kZXJidWZmZXIuYmluZCgpO1xyXG4gICAgICAgIGdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoZ2wuUkVOREVSQlVGRkVSLCBmb3JtYXQsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIHJldHVybiByZW5kZXJidWZmZXI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFsbG9jYXRlcyBhIG5ldyB0ZXh0dXJlIHdpdGggZ2l2ZW4gc2l6ZSwgZm9ybWF0LCB0eXBlIGFuZCBwYXJhbWV0ZXJzIGFuZFxyXG4gICAgICogZmlsbHMgaXQgd2l0aCB6ZXJvZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHdpZHRoIFdpZHRoIG9mIHRoZSB0ZXh0dXJlLlxyXG4gICAgICogQHBhcmFtIGhlaWdodCBIZWlnaHQgb2YgdGhlIHRleHR1cmUuXHJcbiAgICAgKiBAcGFyYW0gZm9ybWF0IFBpeGVsIGZvcm1hdCBvZiB0aGUgdGV4dHVyZS5cclxuICAgICAqIEBwYXJhbSB0eXBlIFBpeGVsIHR5cGUgb2YgdGhlIHRleHR1cmUuXHJcbiAgICAgKiBAcGFyYW0gcGFyYW1zIFBhcmFtZXRlcnMgb2YgdGhlIHRleHR1cmUuXHJcbiAgICAgKiBAcmV0dXJucyBOZXdseSBhbGxvY2F0ZWQgdGV4dHVyZS5cclxuICAgICAqL1xyXG4gICAgY3JlYXRlRW1wdHkyRFRleHR1cmUod2lkdGgsIGhlaWdodCwgZm9ybWF0LCB0eXBlLCBwYXJhbXMgPSBERUZBVUxUX1RFWFRVUkVfUEFSQU1TKSB7XHJcbiAgICAgICAgY29uc3QgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKHRoaXMuX2dsLCB3aWR0aCwgaGVpZ2h0LCBmb3JtYXQsIHR5cGUsIHBhcmFtcyk7XHJcbiAgICAgICAgcmV0dXJuIHRleHR1cmU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgc2hhZGVyIHByb2dyYW0uIFVzZXMgY2FjaGUsIGkuZS4gaWYgYSBwcm9ncmFtIHdpdGggc2FtZVxyXG4gICAgICogc291cmNlIHN0cmluZyBhbmQgb3B0aW9ucyBpcyBhbHJlYWR5IGNyZWF0ZWQsIHJldHVybnMgaXQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZlcnRleFNoYWRlclNvdXJjZSBTb3VyY2UgY29kZSBvZiB2ZXJ0ZXggc2hhZGVyIG9mIHRoZSBwcm9ncmFtLlxyXG4gICAgICogQHBhcmFtIGZyYWdtZW50U2hhZGVyU291cmNlIFNvdXJjZSBjb2RlIG9mIGZyYWdtZW50IHNoYWRlciBvZiB0aGUgcHJvZ3JhbS5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMuXHJcbiAgICAgKiBAcmV0dXJucyBOZXdseSBjcmVhdGVkIHByb2dyYW0gb3Igb25lIGZyb20gdGhlIGNhY2hlLlxyXG4gICAgICovXHJcbiAgICBjcmVhdGVQcm9ncmFtKHZlcnRleFNoYWRlclNvdXJjZSwgZnJhZ21lbnRTaGFkZXJTb3VyY2UsIG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb2dyYW0odGhpcy5fZ2wsIHZlcnRleFNoYWRlclNvdXJjZSwgZnJhZ21lbnRTaGFkZXJTb3VyY2UsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlVmVydGV4QnVmZmVyKHNpemUsIHVzYWdlID0gMzUwNDQgLyogU1RBVElDX0RSQVcgKi8pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY3JlYXRlQnVmZmVyKHRoaXMuX2dsLkFSUkFZX0JVRkZFUiwgc2l6ZSwgdXNhZ2UpO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlSW5kZXhCdWZmZXIoc2l6ZSwgdXNhZ2UgPSAzNTA0NCAvKiBTVEFUSUNfRFJBVyAqLykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVCdWZmZXIodGhpcy5fZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHNpemUsIHVzYWdlKTtcclxuICAgIH1cclxuICAgIC8vIFRPRE86IGNoZWNrIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMjQxOTUgdG8gdXBkYXRlIG5hcnJvd2VkIGRhdGEgdHlwZSBhY2NvcmRpbmdcclxuICAgIHVwbG9hZERhdGFUb0J1ZmZlcihidWZmZXIsIGRhdGEsIG9mZnNldCA9IDApIHtcclxuICAgICAgICBidWZmZXIuYmluZCgpO1xyXG4gICAgICAgIHRoaXMuX2dsLmJ1ZmZlclN1YkRhdGEoYnVmZmVyLmdldFRhcmdldCgpLCBvZmZzZXQsIGRhdGEpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHZlcnRleCBhcnJheSBvYmplY3QgaW4gdGhlIGNvbnRleHQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGF0dHJpYnV0ZU1hcHBpbmcgTWFwcGluZyBvZiB2ZXJ0ZXggYXR0cmJpdXRlcyBmb3IgdGhlIFZBTy5cclxuICAgICAqIEBwYXJhbSB2ZXJ0ZXhCdWZmZXIgVmVydGV4IGJ1ZmZlciB0byBiZSBib3VuZCB0byB0aGUgVkFPLlxyXG4gICAgICogQHBhcmFtIGluZGV4QnVmZmVyIEluZGV4IGJ1ZmZlciB0byBiZSBib3VuZCB0byB0aGUgVkFPLlxyXG4gICAgICogQHJldHVybnMgVGhlIG5ldyBWQU8uXHJcbiAgICAgKi9cclxuICAgIGNyZWF0ZVZhbyhhdHRyaWJ1dGVNYXBwaW5nLCB2ZXJ0ZXhCdWZmZXIsIGluZGV4QnVmZmVyKSB7XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcclxuICAgICAgICBjb25zdCB2YW8gPSBuZXcgVmVydGV4QXJyYXlPYmplY3QoZ2wsIHRoaXMuX3Zhb0V4dCwgYXR0cmlidXRlTWFwcGluZyk7XHJcbiAgICAgICAgdmFvLmJpbmQoKTtcclxuICAgICAgICBpZiAoaW5kZXhCdWZmZXIpIHtcclxuICAgICAgICAgICAgaW5kZXhCdWZmZXIuYmluZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZlcnRleEJ1ZmZlci5iaW5kKCk7XHJcbiAgICAgICAgY29uc3QgdmVydGV4Qnl0ZVNpemUgPSBhdHRyaWJ1dGVNYXBwaW5nLnZlcnRleEJ5dGVTaXplO1xyXG4gICAgICAgIGZvciAoY29uc3QgW2lkeCwgcG9pbnRlcl0gb2YgYXR0cmlidXRlTWFwcGluZykge1xyXG4gICAgICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShpZHgpO1xyXG4gICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGlkeCwgcG9pbnRlci5zaXplLCBwb2ludGVyLnR5cGUsIHBvaW50ZXIubm9ybWFsaXplZCwgdmVydGV4Qnl0ZVNpemUsIHBvaW50ZXIub2Zmc2V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fdmFvRXh0LmJpbmRWZXJ0ZXhBcnJheU9FUyhudWxsKTtcclxuICAgICAgICByZXR1cm4gdmFvO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIG5ldyBjb250ZW50IG9mIHRleHR1cmUsIHByb3ZpZGVkIGRhdGEgbXVzdCBiZSBvZiBsZW5ndGggZXF1YWwgdG8gXCJ3aWR0aCAqIGhlaWdodFwiIGFuZCBpdHMgdHlwZVxyXG4gICAgICogbXVzdCBjb3JyZXNwb25kIHRvIHRleHR1cmUncyB0eXBlIHtAc2VlIFBpeGVsVHlwZX0uXHJcbiAgICAgKi9cclxuICAgIHNldFRleHR1cmVEYXRhKHRleHR1cmUsIGRhdGEpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xyXG4gICAgICAgIGNvbnN0IHdpZHRoID0gdGV4dHVyZS5nZXRXaWR0aCgpO1xyXG4gICAgICAgIGNvbnN0IGhlaWdodCA9IHRleHR1cmUuZ2V0SGVpZ2h0KCk7XHJcbiAgICAgICAgY29uc3QgZm9ybWF0ID0gdGV4dHVyZS5nZXRGb3JtYXQoKTtcclxuICAgICAgICBjb25zdCB0eXBlID0gdGV4dHVyZS5nZXRUeXBlKCk7XHJcbiAgICAgICAgY29uc3QgcGFyYW1zID0gdGV4dHVyZS5nZXRQYXJhbXMoKTtcclxuICAgICAgICB0aGlzLl9zZXRUZXh0dXJlRGF0YVVucGFja1BhcmFtcyhwYXJhbXMpO1xyXG4gICAgICAgIHRoaXMuYmluZFRleHR1cmUodGV4dHVyZSk7XHJcbiAgICAgICAgZ2wudGV4U3ViSW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCAwLCAwLCB3aWR0aCwgaGVpZ2h0LCBmb3JtYXQsIHR5cGUsIGRhdGEpO1xyXG4gICAgICAgIHRoaXMuX29uVGV4dHVyZURhdGFVcGRhdGVkKHRleHR1cmUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIG5ldyB0ZXh0dXJlIGNvbnRlbnQgZnJvbSBjYW52YXMgZWxlbWVudC5cclxuICAgICAqL1xyXG4gICAgc2V0VGV4dHVyZURhdGFGcm9tRG9tRWxlbWVudCh0ZXh0dXJlLCBlbGVtZW50KSB7XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcclxuICAgICAgICBjb25zdCBmb3JtYXQgPSB0ZXh0dXJlLmdldEZvcm1hdCgpO1xyXG4gICAgICAgIGNvbnN0IHR5cGUgPSB0ZXh0dXJlLmdldFR5cGUoKTtcclxuICAgICAgICBjb25zdCBwYXJhbXMgPSB0ZXh0dXJlLmdldFBhcmFtcygpO1xyXG4gICAgICAgIHRoaXMuX3NldFRleHR1cmVEYXRhVW5wYWNrUGFyYW1zKHBhcmFtcyk7XHJcbiAgICAgICAgdGhpcy5iaW5kVGV4dHVyZSh0ZXh0dXJlKTtcclxuICAgICAgICBnbC50ZXhTdWJJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIDAsIDAsIGZvcm1hdCwgdHlwZSwgZWxlbWVudCk7XHJcbiAgICAgICAgdGhpcy5fb25UZXh0dXJlRGF0YVVwZGF0ZWQodGV4dHVyZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgZGVmYXVsdCByZW5kZXIgdGFyZ2V0IGFzc29jaWF0ZWQgd2l0aCBjYW52YXMgb24gd2hpY2ggdGhlIFdlYkdMXHJcbiAgICAgKiBjb250ZXh0IG9wZXJhdGVzLlxyXG4gICAgICovXHJcbiAgICBnZXREZWZhdWx0UmVuZGVyVGFyZ2V0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0UmVuZGVyVGFyZ2V0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhcnMgY3VycmVudGx5IGJvdW5kIHJlbmRlciB0YXJnZXQgYWNjb3JkaW5nIHRvIGEgbWFzay5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbWFzayBCaXR3aXNlIE9SIG9mIG1hcmtzLCBpLmUuXHJcbiAgICAgKiAgICAgIGBDbGVhck1hc2suQ09MT1JfQlVGRkVSX0JJVCB8IENsZWFyTWFzay5ERVBUSF9CVUZGRVJfQklUYC5cclxuICAgICAqL1xyXG4gICAgY2xlYXJDdXJyZW50VGFyZ2V0KG1hc2spIHtcclxuICAgICAgICBpZiAobWFzaykge1xyXG4gICAgICAgICAgICB0aGlzLl9nbC5jbGVhcihtYXNrKTtcclxuICAgICAgICAgICAgdGhpcy5fYm91bmRSZW5kZXJUYXJnZXQuaXNDbGVhciA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBCaW5kcyBhIHJlbmRlciB0YXJnZXQgdG8gdGhlIFdlYkdMIGNvbnRleHQgaWYgaXQncyBub3QgYWxyZWFkeSBib3VuZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSByZW5kZXIgdGFyZ2V0IHRvIGJlIGJvdW5kLlxyXG4gICAgICovXHJcbiAgICBiaW5kUmVuZGVyVGFyZ2V0KHRhcmdldCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9ib3VuZFJlbmRlclRhcmdldCAhPT0gdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHRhcmdldC5iaW5kKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2JvdW5kUmVuZGVyVGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUYXJnZXQgc2l6ZSBjb3VsZCBjaGFuZ2UgZXZlbiBpZiB0YXJnZXQgaXMgYWxyZWFkeSBib3VuZC5cclxuICAgICAgICAvLyBWRUNUT1ItMTkwXHJcbiAgICAgICAgdGhpcy5fc2V0Vmlld3BvcnRTdGF0ZShuZXcgUmVuZGVyU3RhdGUoe1xyXG4gICAgICAgICAgICB2aWV3cG9ydFdpZHRoOiB0YXJnZXQuZ2V0V2lkdGgoKSxcclxuICAgICAgICAgICAgdmlld3BvcnRIZWlnaHQ6IHRhcmdldC5nZXRIZWlnaHQoKVxyXG4gICAgICAgIH0pKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQmluZHMgYSByZW5kZXIgc3RhdGUgdG8gdGhlIFdlYkdMIGNvbnRleHQgd2l0aCBtaW5pbXVtIGFtb3VudCBvZiBhY3R1YWxcclxuICAgICAqIHN0YXRlIHN3aXRjaGluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3RhdGUgVGhlIHN0YXRlIHRvIGJlIGJvdW5kLlxyXG4gICAgICovXHJcbiAgICBiaW5kUmVuZGVyU3RhdGUoc3RhdGUpIHtcclxuICAgICAgICB0aGlzLl9zZXRDb2xvckJ1ZmZlclN0YXRlKHN0YXRlKTtcclxuICAgICAgICB0aGlzLl9zZXRCbGVuZFN0YXRlKHN0YXRlKTtcclxuICAgICAgICB0aGlzLl9zZXRDdWxsRmFjZVN0YXRlKHN0YXRlKTtcclxuICAgICAgICB0aGlzLl9zZXRGcm9udEZhY2VTdGF0ZShzdGF0ZSk7XHJcbiAgICAgICAgdGhpcy5fc2V0RGVwdGhUZXN0U3RhdGUoc3RhdGUpO1xyXG4gICAgICAgIHRoaXMuX3NldERpdGhlclN0YXRlKHN0YXRlKTtcclxuICAgICAgICB0aGlzLl9zZXREcmF3QnVmZmVyc1N0YXRlKHN0YXRlKTtcclxuICAgICAgICB0aGlzLl9zZXRQb2x5Z29uT2Zmc2V0U3RhdGUoc3RhdGUpO1xyXG4gICAgICAgIHRoaXMuX3NldEFscGhhVG9Db3ZlcmFnZVN0YXRlKHN0YXRlKTtcclxuICAgICAgICB0aGlzLl9zZXRTYW1wbGVDb3ZlcmFnZVN0YXRlKHN0YXRlKTtcclxuICAgICAgICB0aGlzLl9zZXRTdGVuY2lsVGVzdFN0YXRlKHN0YXRlKTtcclxuICAgICAgICB0aGlzLl9zZXRTY2lzc29yVGVzdFN0YXRlKHN0YXRlKTtcclxuICAgICAgICB0aGlzLl9zZXRWaWV3cG9ydFN0YXRlKHN0YXRlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQmluZHMgYSBwcm9ncmFtIHRvIHRoZSBXZWJHTCBjb250ZXh0IGlmIGl0J3Mgbm90IGFscmVhZHkgYm91bmQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHByb2dyYW0gVGhlIHByb2dyYW0gdG8gYmUgYm91bmQuXHJcbiAgICAgKi9cclxuICAgIGJpbmRQcm9ncmFtKHByb2dyYW0pIHtcclxuICAgICAgICBpZiAodGhpcy5fYm91bmRQcm9ncmFtICE9PSBwcm9ncmFtKSB7XHJcbiAgICAgICAgICAgIHByb2dyYW0uYmluZCgpO1xyXG4gICAgICAgICAgICB0aGlzLl9ib3VuZFByb2dyYW0gPSBwcm9ncmFtO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQmluZHMgYSB2ZXJ0ZXggYXJyYXkgb2JqZWN0IHRvIHRoZSBjb250ZXh0IGlmIGl0J3Mgbm90IGFscmVhZHkgYm91bmQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZhbyBUaGUgdmVydGV4IGFycmF5IG9iamVjdCB0byBiaW5kLiBQYXNzaW5nIGBudWxsYCB3aWxsIHVuYmluZFxyXG4gICAgICogICAgICBhbnkgY3VycmVudGx5IGJvdW5kIFZBTy5cclxuICAgICAqL1xyXG4gICAgYmluZFZhbyh2YW8pIHtcclxuICAgICAgICBpZiAodGhpcy5fYm91bmRWYW8gIT09IHZhbykge1xyXG4gICAgICAgICAgICBpZiAodmFvKSB7XHJcbiAgICAgICAgICAgICAgICB2YW8uYmluZCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdmFvRXh0LmJpbmRWZXJ0ZXhBcnJheU9FUyhudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9ib3VuZFZhbyA9IHZhbztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBiaW5kUXVhZFZhbygpIHtcclxuICAgICAgICB0aGlzLmJpbmRWYW8odGhpcy5fcXVhZFZhbyk7XHJcbiAgICB9XHJcbiAgICBiaW5kVGV4dHVyZVVuaXQodW5pdCkge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XHJcbiAgICAgICAgaWYgKHRoaXMuX2JvdW5kVGV4dHVyZVVuaXQgIT09IHVuaXQpIHtcclxuICAgICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHVuaXQpO1xyXG4gICAgICAgICAgICB0aGlzLl9ib3VuZFRleHR1cmVVbml0ID0gdW5pdDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBiaW5kVGV4dHVyZSh0ZXh0dXJlKSB7XHJcbiAgICAgICAgY29uc3QgYm91bmRVbml0ID0gdGhpcy5fYm91bmRUZXh0dXJlVW5pdDtcclxuICAgICAgICBpZiAodGhpcy5fYm91bmRUZXh0dXJlc1tib3VuZFVuaXRdICE9PSB0ZXh0dXJlKSB7XHJcbiAgICAgICAgICAgIHRleHR1cmUuYmluZCgpO1xyXG4gICAgICAgICAgICB0aGlzLl9ib3VuZFRleHR1cmVzW2JvdW5kVW5pdF0gPSB0ZXh0dXJlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRHJhd3MgYSBxdWFkIHRvIGN1cnJlbnRseSBib3VuZCByZW5kZXIgdGFyZ2V0IHdpdGggY3VycmVudGx5IGJvdW5kIHJlbmRlclxyXG4gICAgICogc3RhdGUsIHByb2dyYW0gYW5kIHVuaWZvcm0gc3RhdGUuXHJcbiAgICAgKi9cclxuICAgIGRyYXdRdWFkKCkge1xyXG4gICAgICAgIHRoaXMuZHJhd01lc2goMCwgNiwgNCAvKiBUUklBTkdMRVMgKi8pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3cyBhIG1lc2ggZnJvbSBjdXJyZW50bHkgYm91bmQgdG8gQVJSQVlfQlVGRkVSIGJ1ZmZlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IEluZGV4IG9mIHRoZSB2ZXJ0ZXggdG8gc3RhcnQgZHJhd2luZyBmcm9tLlxyXG4gICAgICogQHBhcmFtIGNvdW50IE51bWJlciBvZiB2ZXJ0aWNlcyB0byBwcm9jZXNzLlxyXG4gICAgICogQHBhcmFtIHByaW1pdGl2ZVR5cGVcclxuICAgICAqL1xyXG4gICAgZHJhd01lc2gob2Zmc2V0LCBjb3VudCwgcHJpbWl0aXZlVHlwZSA9IDQgLyogVFJJQU5HTEVTICovKSB7XHJcbiAgICAgICAgdGhpcy5fZ2wuZHJhd0FycmF5cyhwcmltaXRpdmVUeXBlLCBvZmZzZXQsIGNvdW50KTtcclxuICAgICAgICB0aGlzLl9ib3VuZFJlbmRlclRhcmdldC5pc0NsZWFyID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERyYXdzIGEgbWVzaCB0byBjdXJyZW50bHkgYm91bmQgcmVuZGVyIHRhcmdldCB3aXRoIGN1cnJlbnRseSBib3VuZCByZW5kZXJcclxuICAgICAqIHN0YXRlLCBwcm9ncmFtIGFuZCB1bmlmb3JtIHN0YXRlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvZmZzZXQgT2Zmc2V0IG9mIGluZGljZXMgb2YgdGhlIG1lc2ggaW4gY3VycmVudGx5IGJvdW5kIG1lbW9yeSBwYWdlLlxyXG4gICAgICogQHBhcmFtIGluZGV4Q291bnQgTnVtYmVyIG9mIGluZGljZXMgaW4gdGhlIG1lc2guXHJcbiAgICAgKi9cclxuICAgIGRyYXdJbmRleGVkTWVzaChvZmZzZXQsIGluZGV4Q291bnQsIHByaW1pdGl2ZVR5cGUgPSA0IC8qIFRSSUFOR0xFUyAqLykge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XHJcbiAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKHByaW1pdGl2ZVR5cGUsIGluZGV4Q291bnQsIGdsLlVOU0lHTkVEX1NIT1JULCBvZmZzZXQpO1xyXG4gICAgICAgIHRoaXMuX2JvdW5kUmVuZGVyVGFyZ2V0LmlzQ2xlYXIgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGVzdHJveXMgdGhlIGNvbnRleHQgYW5kIHJlc291cmNlcyBvd25lZCBieSBpdC4gTm90ZSB0aGF0IHJlc291cmNlcyB0aGF0XHJcbiAgICAgKiB3ZXJlIGNyZWF0ZWQgd2l0aCBgY3JlYXRlKmAgbWV0aG9kIG9mIHRoZSBjb250ZXh0IGFyZW4ndCBleGFjdGx5IGJlbG9uZ1xyXG4gICAgICogdG8gdGhlIGNvbnRleHQsIGVudGl0aWVzIHRoYXQgY3JlYXRlZCB0aGVtIGhhdmUgdG8gZGVzdHJveSB0aGVtLlxyXG4gICAgICovXHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMuX3F1YWRWYW8uZGVzdHJveSgpO1xyXG4gICAgICAgIHRoaXMuX3F1YWRWZXJ0ZXhCdWZmZXIuZGVzdHJveSgpO1xyXG4gICAgICAgIHRoaXMuX2dsLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRsb3N0JywgdGhpcy5fY29udGV4dExvc3RMaXN0ZW5lcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgY29udGV4dCBmcm9tIGEgY2FudmFzLlxyXG4gICAgICpcclxuICAgICAqIEB0aHJvd3MgQW4gZXJyb3IgaWYgZmFpbHMgdG8gY3JlYXRlIGB3ZWJnbGAgY29udGV4dCBmb3IgdGhlIGNhbnZhcy5cclxuICAgICAqIEBwYXJhbSBjYW52YXMgVGhlIGNhbnZhcy5cclxuICAgICAqIEBwYXJhbSBhdHRyaWJzIEF0dHJpYnV0ZXMgb2YgdGhlIGNvbnRleHQuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVhdGVGcm9tQ2FudmFzKGNhbnZhcywgYXR0cmlicykge1xyXG4gICAgICAgIGNvbnN0IGdsID0gY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJywgYXR0cmlicyk7XHJcbiAgICAgICAgaWYgKCFnbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgR0wgY29udGV4dCBmcm9tIGNhbnZhcy4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSZW5kZXJDb250ZXh0KGdsKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRW5hYmxlcyBvciBkaXNhYmxlcyBhIFdlYkdMIGNhcGFiaWxpdHkuXHJcbiAgICAgKiBAc2VlIGh0dHBzOi8vd3d3Lmtocm9ub3Mub3JnL3JlZ2lzdHJ5L09wZW5HTC1SZWZwYWdlcy9lczIuMC94aHRtbC9nbEVuYWJsZS54bWxcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY2FwYWJpbGl0eSBUaGUgY2FwYWJpbGl0eSB0byBiZSBlbmFibGVkIG9mIGRpc2FibGVkLlxyXG4gICAgICogQHBhcmFtIGVuYWJsZWQgTmV3IHN0YXRlIG9mIHRoZSBjYXBhYmlsaXR5O1xyXG4gICAgICovXHJcbiAgICBfc2V0Q2FwYWJpbGl0eUVuYWJsZWQoY2FwYWJpbGl0eSwgZW5hYmxlZCkge1xyXG4gICAgICAgIGlmIChlbmFibGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsLmVuYWJsZShjYXBhYmlsaXR5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsLmRpc2FibGUoY2FwYWJpbGl0eSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIG5ldyBjbGVhciBjb2xvciBhbmQgY29sb3IgbWFzayBmcm9tIGEgc3RhdGUgaWYgdGhleSdyZSBkaWZmZXJlbnQgZnJvbVxyXG4gICAgICogY3VycmVudGx5IHNldCBvbmVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzdGF0ZSBUaGUgc3RhdGUgdGhhdCBjb250YWlucyBuZXcgY2xlYXIgY29sb3IgYW5kIGNvbG9yIG1hc2tzLlxyXG4gICAgICovXHJcbiAgICBfc2V0Q29sb3JCdWZmZXJTdGF0ZShzdGF0ZSkge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XHJcbiAgICAgICAgY29uc3QgYm91bmRTdGF0ZSA9IHRoaXMuX2JvdW5kUmVuZGVyU3RhdGU7XHJcbiAgICAgICAgY29uc3QgbmV3Q2xlYXJDb2xvciA9IHN0YXRlLmNsZWFyQ29sb3I7XHJcbiAgICAgICAgaWYgKCFjb2xvci5hcmVFcXVhbChib3VuZFN0YXRlLmNsZWFyQ29sb3IsIG5ld0NsZWFyQ29sb3IpKSB7XHJcbiAgICAgICAgICAgIGdsLmNsZWFyQ29sb3IobmV3Q2xlYXJDb2xvci5yLCBuZXdDbGVhckNvbG9yLmcsIG5ld0NsZWFyQ29sb3IuYiwgbmV3Q2xlYXJDb2xvci5hKTtcclxuICAgICAgICAgICAgY29sb3IuY29weShuZXdDbGVhckNvbG9yLCBib3VuZFN0YXRlLmNsZWFyQ29sb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYm91bmRTdGF0ZS5jb2xvck1hc2tSICE9PSBzdGF0ZS5jb2xvck1hc2tSIHx8XHJcbiAgICAgICAgICAgIGJvdW5kU3RhdGUuY29sb3JNYXNrRyAhPT0gc3RhdGUuY29sb3JNYXNrRyB8fFxyXG4gICAgICAgICAgICBib3VuZFN0YXRlLmNvbG9yTWFza0IgIT09IHN0YXRlLmNvbG9yTWFza0IgfHxcclxuICAgICAgICAgICAgYm91bmRTdGF0ZS5jb2xvck1hc2tBbHBoYSAhPT0gc3RhdGUuY29sb3JNYXNrQWxwaGEpIHtcclxuICAgICAgICAgICAgdGhpcy5fZ2wuY29sb3JNYXNrKHN0YXRlLmNvbG9yTWFza1IsIHN0YXRlLmNvbG9yTWFza0csIHN0YXRlLmNvbG9yTWFza0IsIHN0YXRlLmNvbG9yTWFza0FscGhhKTtcclxuICAgICAgICAgICAgYm91bmRTdGF0ZS5jb2xvck1hc2tSID0gc3RhdGUuY29sb3JNYXNrUjtcclxuICAgICAgICAgICAgYm91bmRTdGF0ZS5jb2xvck1hc2tHID0gc3RhdGUuY29sb3JNYXNrRztcclxuICAgICAgICAgICAgYm91bmRTdGF0ZS5jb2xvck1hc2tCID0gc3RhdGUuY29sb3JNYXNrQjtcclxuICAgICAgICAgICAgYm91bmRTdGF0ZS5jb2xvck1hc2tBbHBoYSA9IHN0YXRlLmNvbG9yTWFza0FscGhhO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBibGVuZCBzdGF0ZSBhbmQgcGFyYW1zLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzdGF0ZSBUaGUgc3RhdGUgdGhhdCBjb250YWlucyBuZXcgYmxlbmQgcGFyYW1zLlxyXG4gICAgICovXHJcbiAgICBfc2V0QmxlbmRTdGF0ZShzdGF0ZSkge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XHJcbiAgICAgICAgY29uc3QgYm91bmRTdGF0ZSA9IHRoaXMuX2JvdW5kUmVuZGVyU3RhdGU7XHJcbiAgICAgICAgaWYgKGJvdW5kU3RhdGUuYmxlbmQgIT09IHN0YXRlLmJsZW5kKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldENhcGFiaWxpdHlFbmFibGVkKGdsLkJMRU5ELCBzdGF0ZS5ibGVuZCk7XHJcbiAgICAgICAgICAgIGJvdW5kU3RhdGUuYmxlbmQgPSBzdGF0ZS5ibGVuZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0YXRlLmJsZW5kKSB7XHJcbiAgICAgICAgICAgIGlmIChib3VuZFN0YXRlLmJsZW5kRXF1YXRpb25SZ2IgIT09IHN0YXRlLmJsZW5kRXF1YXRpb25SZ2IgfHxcclxuICAgICAgICAgICAgICAgIGJvdW5kU3RhdGUuYmxlbmRFcXVhdGlvbkFscGhhICE9PSBzdGF0ZS5ibGVuZEVxdWF0aW9uQWxwaGEpIHtcclxuICAgICAgICAgICAgICAgIGdsLmJsZW5kRXF1YXRpb25TZXBhcmF0ZShzdGF0ZS5ibGVuZEVxdWF0aW9uUmdiLCBzdGF0ZS5ibGVuZEVxdWF0aW9uQWxwaGEpO1xyXG4gICAgICAgICAgICAgICAgYm91bmRTdGF0ZS5ibGVuZEVxdWF0aW9uUmdiID0gc3RhdGUuYmxlbmRFcXVhdGlvblJnYjtcclxuICAgICAgICAgICAgICAgIGJvdW5kU3RhdGUuYmxlbmRFcXVhdGlvbkFscGhhID0gc3RhdGUuYmxlbmRFcXVhdGlvbkFscGhhO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChib3VuZFN0YXRlLmJsZW5kRnVuY0RzdFJnYiAhPT0gc3RhdGUuYmxlbmRGdW5jRHN0UmdiIHx8XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLmJsZW5kRnVuY1NyY1JnYiAhPT0gc3RhdGUuYmxlbmRGdW5jU3JjUmdiIHx8XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLmJsZW5kRnVuY0RzdEFscGhhICE9PSBzdGF0ZS5ibGVuZEZ1bmNEc3RBbHBoYSB8fFxyXG4gICAgICAgICAgICAgICAgYm91bmRTdGF0ZS5ibGVuZEZ1bmNTcmNBbHBoYSAhPT0gc3RhdGUuYmxlbmRGdW5jU3JjQWxwaGEpIHtcclxuICAgICAgICAgICAgICAgIGdsLmJsZW5kRnVuY1NlcGFyYXRlKHN0YXRlLmJsZW5kRnVuY1NyY1JnYiwgc3RhdGUuYmxlbmRGdW5jRHN0UmdiLCBzdGF0ZS5ibGVuZEZ1bmNTcmNBbHBoYSwgc3RhdGUuYmxlbmRGdW5jRHN0QWxwaGEpO1xyXG4gICAgICAgICAgICAgICAgYm91bmRTdGF0ZS5ibGVuZEZ1bmNTcmNSZ2IgPSBzdGF0ZS5ibGVuZEZ1bmNTcmNSZ2I7XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLmJsZW5kRnVuY0RzdFJnYiA9IHN0YXRlLmJsZW5kRnVuY0RzdFJnYjtcclxuICAgICAgICAgICAgICAgIGJvdW5kU3RhdGUuYmxlbmRGdW5jU3JjQWxwaGEgPSBzdGF0ZS5ibGVuZEZ1bmNTcmNBbHBoYTtcclxuICAgICAgICAgICAgICAgIGJvdW5kU3RhdGUuYmxlbmRGdW5jRHN0QWxwaGEgPSBzdGF0ZS5ibGVuZEZ1bmNEc3RBbHBoYTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBjdWxsIGZhY2Ugc3RhdGUgYW5kIHBhcmFtcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3RhdGUgVGhlIHN0YXRlIHRoYXQgY29udGFpbnMgbmV3IGN1bGwgZmFjZSBzdGF0ZSBhbmQgbW9kZS5cclxuICAgICAqL1xyXG4gICAgX3NldEN1bGxGYWNlU3RhdGUoc3RhdGUpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xyXG4gICAgICAgIGNvbnN0IGJvdW5kU3RhdGUgPSB0aGlzLl9ib3VuZFJlbmRlclN0YXRlO1xyXG4gICAgICAgIGlmIChib3VuZFN0YXRlLmN1bGxGYWNlICE9PSBzdGF0ZS5jdWxsRmFjZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zZXRDYXBhYmlsaXR5RW5hYmxlZChnbC5DVUxMX0ZBQ0UsIHN0YXRlLmN1bGxGYWNlKTtcclxuICAgICAgICAgICAgYm91bmRTdGF0ZS5jdWxsRmFjZSA9IHN0YXRlLmN1bGxGYWNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RhdGUuY3VsbEZhY2UgJiZcclxuICAgICAgICAgICAgYm91bmRTdGF0ZS5jdWxsRmFjZU1vZGUgIT09IHN0YXRlLmN1bGxGYWNlTW9kZSkge1xyXG4gICAgICAgICAgICBnbC5jdWxsRmFjZShzdGF0ZS5jdWxsRmFjZU1vZGUpO1xyXG4gICAgICAgICAgICBib3VuZFN0YXRlLmN1bGxGYWNlTW9kZSA9IHN0YXRlLmN1bGxGYWNlTW9kZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgZnJvbnQgZmFjZSBtb2RlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzdGF0ZSBUaGUgc3RhdGUgdGhhdCBjb250YWlucyBuZXcgZnJvbnQgZmFjZSBtb2RlLlxyXG4gICAgICovXHJcbiAgICBfc2V0RnJvbnRGYWNlU3RhdGUoc3RhdGUpIHtcclxuICAgICAgICBjb25zdCBib3VuZFN0YXRlID0gdGhpcy5fYm91bmRSZW5kZXJTdGF0ZTtcclxuICAgICAgICBpZiAoYm91bmRTdGF0ZS5mcm9udEZhY2VNb2RlICE9PSBzdGF0ZS5mcm9udEZhY2VNb2RlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsLmZyb250RmFjZShzdGF0ZS5mcm9udEZhY2VNb2RlKTtcclxuICAgICAgICAgICAgYm91bmRTdGF0ZS5mcm9udEZhY2VNb2RlID0gc3RhdGUuZnJvbnRGYWNlTW9kZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgZGVwdGggdGVzdCBzdGF0ZSBhbmQgcGFyYW1zLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzdGF0ZSBUaGUgc3RhdGUgdGhhdCBjb250YWlucyBuZXcgZGVwdGggdGVzdCBzdGF0ZSBhbmQgcGFyYW1zLlxyXG4gICAgICovXHJcbiAgICBfc2V0RGVwdGhUZXN0U3RhdGUoc3RhdGUpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xyXG4gICAgICAgIGNvbnN0IGJvdW5kU3RhdGUgPSB0aGlzLl9ib3VuZFJlbmRlclN0YXRlO1xyXG4gICAgICAgIGlmIChib3VuZFN0YXRlLmRlcHRoVGVzdCAhPT0gc3RhdGUuZGVwdGhUZXN0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldENhcGFiaWxpdHlFbmFibGVkKGdsLkRFUFRIX1RFU1QsIHN0YXRlLmRlcHRoVGVzdCk7XHJcbiAgICAgICAgICAgIGJvdW5kU3RhdGUuZGVwdGhUZXN0ID0gc3RhdGUuZGVwdGhUZXN0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RhdGUuZGVwdGhUZXN0KSB7XHJcbiAgICAgICAgICAgIGlmIChib3VuZFN0YXRlLmNsZWFyRGVwdGggIT09IHN0YXRlLmNsZWFyRGVwdGgpIHtcclxuICAgICAgICAgICAgICAgIGdsLmNsZWFyRGVwdGgoc3RhdGUuY2xlYXJEZXB0aCk7XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLmNsZWFyRGVwdGggPSBzdGF0ZS5jbGVhckRlcHRoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChib3VuZFN0YXRlLmRlcHRoTWFzayAhPT0gc3RhdGUuZGVwdGhNYXNrKSB7XHJcbiAgICAgICAgICAgICAgICBnbC5kZXB0aE1hc2soc3RhdGUuZGVwdGhNYXNrKTtcclxuICAgICAgICAgICAgICAgIGJvdW5kU3RhdGUuZGVwdGhNYXNrID0gc3RhdGUuZGVwdGhNYXNrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChib3VuZFN0YXRlLmRlcHRoRnVuYyAhPT0gc3RhdGUuZGVwdGhGdW5jKSB7XHJcbiAgICAgICAgICAgICAgICBnbC5kZXB0aEZ1bmMoc3RhdGUuZGVwdGhGdW5jKTtcclxuICAgICAgICAgICAgICAgIGJvdW5kU3RhdGUuZGVwdGhGdW5jID0gc3RhdGUuZGVwdGhGdW5jO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChib3VuZFN0YXRlLmRlcHRoUmFuZ2VOZWFyICE9PSBzdGF0ZS5kZXB0aFJhbmdlTmVhciB8fFxyXG4gICAgICAgICAgICAgICAgYm91bmRTdGF0ZS5kZXB0aFJhbmdlRmFyICE9PSBzdGF0ZS5kZXB0aFJhbmdlRmFyKSB7XHJcbiAgICAgICAgICAgICAgICBnbC5kZXB0aFJhbmdlKHN0YXRlLmRlcHRoUmFuZ2VOZWFyLCBzdGF0ZS5kZXB0aFJhbmdlRmFyKTtcclxuICAgICAgICAgICAgICAgIGJvdW5kU3RhdGUuZGVwdGhSYW5nZU5lYXIgPSBzdGF0ZS5kZXB0aFJhbmdlTmVhcjtcclxuICAgICAgICAgICAgICAgIGJvdW5kU3RhdGUuZGVwdGhSYW5nZUZhciA9IHN0YXRlLmRlcHRoUmFuZ2VGYXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgZGl0aGVyIHN0YXRlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzdGF0ZSBUaGUgc3RhdGUgdGhhdCBjb250YWlucyBuZXcgZGl0aGVyIHN0YXRlLlxyXG4gICAgICovXHJcbiAgICBfc2V0RGl0aGVyU3RhdGUoc3RhdGUpIHtcclxuICAgICAgICBjb25zdCBib3VuZFN0YXRlID0gdGhpcy5fYm91bmRSZW5kZXJTdGF0ZTtcclxuICAgICAgICBpZiAoYm91bmRTdGF0ZS5kaXRoZXIgIT09IHN0YXRlLmRpdGhlcikge1xyXG4gICAgICAgICAgICB0aGlzLl9zZXRDYXBhYmlsaXR5RW5hYmxlZCh0aGlzLl9nbC5ESVRIRVIsIHN0YXRlLmRpdGhlcik7XHJcbiAgICAgICAgICAgIGJvdW5kU3RhdGUuZGl0aGVyID0gc3RhdGUuZGl0aGVyO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBkcmF3IGJ1ZmZlcnMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHN0YXRlIFRoZSBzdGF0ZSB0aGF0IGNvbnRhaW5zIGFycmF5IG9mIGRyYXcgYnVmZmVycy5cclxuICAgICAqL1xyXG4gICAgX3NldERyYXdCdWZmZXJzU3RhdGUoc3RhdGUpIHtcclxuICAgICAgICBjb25zdCBib3VuZERyYXdCdWZmZXJzID0gdGhpcy5fYm91bmRSZW5kZXJTdGF0ZS5kcmF3QnVmZmVycztcclxuICAgICAgICBpZiAoYm91bmREcmF3QnVmZmVycy5sZW5ndGggIT09IHN0YXRlLmRyYXdCdWZmZXJzLmxlbmd0aCB8fFxyXG4gICAgICAgICAgICBib3VuZERyYXdCdWZmZXJzXHJcbiAgICAgICAgICAgICAgICAuc29tZSgoYXR0YWNobWVudCwgaSkgPT4gYXR0YWNobWVudCAhPT0gc3RhdGUuZHJhd0J1ZmZlcnNbaV0pKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2JvdW5kUmVuZGVyU3RhdGUuZHJhd0J1ZmZlcnMgPSBzdGF0ZS5kcmF3QnVmZmVycy5zbGljZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBwb2x5Z29uIG9mZnNldCBzdGF0ZSBhbmQgcGFyYW1zLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzdGF0ZSBUaGUgc3RhdGUgdGhhdCBjb250YWlucyBuZXcgcG9seWdvbiBvZmZzZXQgc3RhdGUgYW5kIHBhcmFtcy5cclxuICAgICAqL1xyXG4gICAgX3NldFBvbHlnb25PZmZzZXRTdGF0ZShzdGF0ZSkge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XHJcbiAgICAgICAgY29uc3QgYm91bmRTdGF0ZSA9IHRoaXMuX2JvdW5kUmVuZGVyU3RhdGU7XHJcbiAgICAgICAgaWYgKGJvdW5kU3RhdGUucG9seWdvbk9mZnNldCAhPT0gc3RhdGUucG9seWdvbk9mZnNldCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zZXRDYXBhYmlsaXR5RW5hYmxlZChnbC5QT0xZR09OX09GRlNFVF9GSUxMLCBzdGF0ZS5wb2x5Z29uT2Zmc2V0KTtcclxuICAgICAgICAgICAgYm91bmRTdGF0ZS5wb2x5Z29uT2Zmc2V0ID0gc3RhdGUucG9seWdvbk9mZnNldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0YXRlLnBvbHlnb25PZmZzZXQgJiZcclxuICAgICAgICAgICAgKGJvdW5kU3RhdGUucG9seWdvbk9mZnNldEZhY3RvciAhPT0gc3RhdGUucG9seWdvbk9mZnNldEZhY3RvciB8fFxyXG4gICAgICAgICAgICAgICAgYm91bmRTdGF0ZS5wb2x5Z29uT2Zmc2V0VW5pdHMgIT09IHN0YXRlLnBvbHlnb25PZmZzZXRVbml0cykpIHtcclxuICAgICAgICAgICAgZ2wucG9seWdvbk9mZnNldChzdGF0ZS5wb2x5Z29uT2Zmc2V0RmFjdG9yLCBzdGF0ZS5wb2x5Z29uT2Zmc2V0VW5pdHMpO1xyXG4gICAgICAgICAgICBib3VuZFN0YXRlLnBvbHlnb25PZmZzZXRGYWN0b3IgPSBzdGF0ZS5wb2x5Z29uT2Zmc2V0RmFjdG9yO1xyXG4gICAgICAgICAgICBib3VuZFN0YXRlLnBvbHlnb25PZmZzZXRVbml0cyA9IHN0YXRlLnBvbHlnb25PZmZzZXRVbml0cztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgYWxwaGEtdG8tY292ZXJhZ2Ugc3RhdGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHN0YXRlIFRoZSBzdGF0ZSB0aGF0IGNvbnRhaW5zIG5ldyBhbHBoYS10by1jb3ZlcmFnZSBzdGF0ZS5cclxuICAgICAqL1xyXG4gICAgX3NldEFscGhhVG9Db3ZlcmFnZVN0YXRlKHN0YXRlKSB7XHJcbiAgICAgICAgY29uc3QgYm91bmRTdGF0ZSA9IHRoaXMuX2JvdW5kUmVuZGVyU3RhdGU7XHJcbiAgICAgICAgaWYgKGJvdW5kU3RhdGUuc2FtcGxlQWxwaGFUb0NvdmVyYWdlICE9PSBzdGF0ZS5zYW1wbGVBbHBoYVRvQ292ZXJhZ2UpIHtcclxuICAgICAgICAgICAgdGhpcy5fc2V0Q2FwYWJpbGl0eUVuYWJsZWQodGhpcy5fZ2wuU0FNUExFX0FMUEhBX1RPX0NPVkVSQUdFLCBzdGF0ZS5zYW1wbGVBbHBoYVRvQ292ZXJhZ2UpO1xyXG4gICAgICAgICAgICBib3VuZFN0YXRlLnNhbXBsZUFscGhhVG9Db3ZlcmFnZSA9IHN0YXRlLnNhbXBsZUFscGhhVG9Db3ZlcmFnZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgc2FtcGxlIGNvdmVyYWdlIHN0YXRlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzdGF0ZSBUaGUgc3RhdGUgdGhhdCBjb250YWlucyBuZXcgc2FtcGxlIGNvdmVyYWdlIHN0YXRlIGFuZCBwYXJhbXMuXHJcbiAgICAgKi9cclxuICAgIF9zZXRTYW1wbGVDb3ZlcmFnZVN0YXRlKHN0YXRlKSB7XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcclxuICAgICAgICBjb25zdCBib3VuZFN0YXRlID0gdGhpcy5fYm91bmRSZW5kZXJTdGF0ZTtcclxuICAgICAgICBpZiAoYm91bmRTdGF0ZS5zYW1wbGVDb3ZlcmFnZSAhPT0gc3RhdGUuc2FtcGxlQ292ZXJhZ2UpIHtcclxuICAgICAgICAgICAgdGhpcy5fc2V0Q2FwYWJpbGl0eUVuYWJsZWQoZ2wuU0FNUExFX0NPVkVSQUdFLCBzdGF0ZS5zYW1wbGVDb3ZlcmFnZSk7XHJcbiAgICAgICAgICAgIGJvdW5kU3RhdGUuc2FtcGxlQ292ZXJhZ2UgPSBzdGF0ZS5zYW1wbGVDb3ZlcmFnZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0YXRlLnNhbXBsZUNvdmVyYWdlICYmXHJcbiAgICAgICAgICAgIChib3VuZFN0YXRlLnNhbXBsZUNvdmVyYWdlVmFsdWUgIT09IHN0YXRlLnNhbXBsZUNvdmVyYWdlVmFsdWUgfHxcclxuICAgICAgICAgICAgICAgIGJvdW5kU3RhdGUuc2FtcGxlQ292ZXJhZ2VJbnZlcnQgIT09IHN0YXRlLnNhbXBsZUNvdmVyYWdlSW52ZXJ0KSkge1xyXG4gICAgICAgICAgICBnbC5zYW1wbGVDb3ZlcmFnZShzdGF0ZS5zYW1wbGVDb3ZlcmFnZVZhbHVlLCBzdGF0ZS5zYW1wbGVDb3ZlcmFnZUludmVydCk7XHJcbiAgICAgICAgICAgIGJvdW5kU3RhdGUuc2FtcGxlQ292ZXJhZ2VWYWx1ZSA9IHN0YXRlLnNhbXBsZUNvdmVyYWdlVmFsdWU7XHJcbiAgICAgICAgICAgIGJvdW5kU3RhdGUuc2FtcGxlQ292ZXJhZ2VJbnZlcnQgPSBzdGF0ZS5zYW1wbGVDb3ZlcmFnZUludmVydDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgc3RlbmNpbCB0ZXN0IHN0YXRlIGFuZCBwYXJhbXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHN0YXRlIFRoZSBzdGF0ZSB0aGF0IGNvbnRhaW5zIG5ldyBzdGVuY2lsIHRlc3Qgc3RhdGUgYW5kIHBhcmFtcy5cclxuICAgICAqL1xyXG4gICAgX3NldFN0ZW5jaWxUZXN0U3RhdGUoc3RhdGUpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xyXG4gICAgICAgIGNvbnN0IGJvdW5kU3RhdGUgPSB0aGlzLl9ib3VuZFJlbmRlclN0YXRlO1xyXG4gICAgICAgIGlmIChib3VuZFN0YXRlLnN0ZW5jaWxUZXN0ICE9PSBzdGF0ZS5zdGVuY2lsVGVzdCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zZXRDYXBhYmlsaXR5RW5hYmxlZChnbC5TVEVOQ0lMX1RFU1QsIHN0YXRlLnN0ZW5jaWxUZXN0KTtcclxuICAgICAgICAgICAgYm91bmRTdGF0ZS5zdGVuY2lsVGVzdCA9IHN0YXRlLnN0ZW5jaWxUZXN0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RhdGUuc3RlbmNpbFRlc3QpIHtcclxuICAgICAgICAgICAgaWYgKGJvdW5kU3RhdGUuY2xlYXJTdGVuY2lsICE9PSBzdGF0ZS5jbGVhclN0ZW5jaWwpIHtcclxuICAgICAgICAgICAgICAgIGdsLmNsZWFyU3RlbmNpbChzdGF0ZS5jbGVhclN0ZW5jaWwpO1xyXG4gICAgICAgICAgICAgICAgYm91bmRTdGF0ZS5jbGVhclN0ZW5jaWwgPSBzdGF0ZS5jbGVhclN0ZW5jaWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGJvdW5kU3RhdGUuc3RlbmNpbFdyaXRlTWFzayAhPT0gc3RhdGUuc3RlbmNpbFdyaXRlTWFzaykge1xyXG4gICAgICAgICAgICAgICAgZ2wuc3RlbmNpbE1hc2soc3RhdGUuc3RlbmNpbFdyaXRlTWFzayk7XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLnN0ZW5jaWxXcml0ZU1hc2sgPSBzdGF0ZS5zdGVuY2lsV3JpdGVNYXNrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHJlZk9yTWFza0lzRGlmZmVyZW50ID0gKGJvdW5kU3RhdGUuc3RlbmNpbE1hc2sgIT09IHN0YXRlLnN0ZW5jaWxNYXNrIHx8XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLnN0ZW5jaWxSZWZlcmVuY2UgIT09IHN0YXRlLnN0ZW5jaWxSZWZlcmVuY2UpO1xyXG4gICAgICAgICAgICBpZiAocmVmT3JNYXNrSXNEaWZmZXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIGJvdW5kU3RhdGUuc3RlbmNpbE1hc2sgPSBzdGF0ZS5zdGVuY2lsTWFzaztcclxuICAgICAgICAgICAgICAgIGJvdW5kU3RhdGUuc3RlbmNpbFJlZmVyZW5jZSA9IHN0YXRlLnN0ZW5jaWxSZWZlcmVuY2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGJvdW5kU3RhdGUuc3RlbmNpbEZyb250RnVuYyAhPT0gc3RhdGUuc3RlbmNpbEZyb250RnVuYyB8fFxyXG4gICAgICAgICAgICAgICAgcmVmT3JNYXNrSXNEaWZmZXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIGdsLnN0ZW5jaWxGdW5jU2VwYXJhdGUoZ2wuRlJPTlQsIHN0YXRlLnN0ZW5jaWxGcm9udEZ1bmMsIHN0YXRlLnN0ZW5jaWxSZWZlcmVuY2UsIHN0YXRlLnN0ZW5jaWxNYXNrKTtcclxuICAgICAgICAgICAgICAgIGJvdW5kU3RhdGUuc3RlbmNpbEZyb250RnVuYyA9IHN0YXRlLnN0ZW5jaWxGcm9udEZ1bmM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGJvdW5kU3RhdGUuc3RlbmNpbEJhY2tGdW5jICE9PSBzdGF0ZS5zdGVuY2lsQmFja0Z1bmMgfHxcclxuICAgICAgICAgICAgICAgIHJlZk9yTWFza0lzRGlmZmVyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBnbC5zdGVuY2lsRnVuY1NlcGFyYXRlKGdsLkJBQ0ssIHN0YXRlLnN0ZW5jaWxCYWNrRnVuYywgc3RhdGUuc3RlbmNpbFJlZmVyZW5jZSwgc3RhdGUuc3RlbmNpbE1hc2spO1xyXG4gICAgICAgICAgICAgICAgYm91bmRTdGF0ZS5zdGVuY2lsQmFja0Z1bmMgPSBzdGF0ZS5zdGVuY2lsQmFja0Z1bmM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGJvdW5kU3RhdGUuc3RlbmNpbEZyb250RmFpbE9wICE9PSBzdGF0ZS5zdGVuY2lsRnJvbnRGYWlsT3AgfHxcclxuICAgICAgICAgICAgICAgIGJvdW5kU3RhdGUuc3RlbmNpbEZyb250RGVwdGhGYWlsT3AgIT09IHN0YXRlLnN0ZW5jaWxGcm9udERlcHRoRmFpbE9wIHx8XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLnN0ZW5jaWxGcm9udERlcHRoUGFzc09wICE9PSBzdGF0ZS5zdGVuY2lsRnJvbnREZXB0aFBhc3NPcCkge1xyXG4gICAgICAgICAgICAgICAgZ2wuc3RlbmNpbE9wU2VwYXJhdGUoZ2wuRlJPTlQsIHN0YXRlLnN0ZW5jaWxGcm9udEZhaWxPcCwgc3RhdGUuc3RlbmNpbEZyb250RGVwdGhGYWlsT3AsIHN0YXRlLnN0ZW5jaWxGcm9udERlcHRoUGFzc09wKTtcclxuICAgICAgICAgICAgICAgIGJvdW5kU3RhdGUuc3RlbmNpbEZyb250RmFpbE9wID0gc3RhdGUuc3RlbmNpbEZyb250RmFpbE9wO1xyXG4gICAgICAgICAgICAgICAgYm91bmRTdGF0ZS5zdGVuY2lsRnJvbnREZXB0aEZhaWxPcCA9IHN0YXRlLnN0ZW5jaWxGcm9udERlcHRoRmFpbE9wO1xyXG4gICAgICAgICAgICAgICAgYm91bmRTdGF0ZS5zdGVuY2lsRnJvbnREZXB0aFBhc3NPcCA9IHN0YXRlLnN0ZW5jaWxGcm9udERlcHRoUGFzc09wO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChib3VuZFN0YXRlLnN0ZW5jaWxCYWNrRmFpbE9wICE9PSBzdGF0ZS5zdGVuY2lsQmFja0ZhaWxPcCB8fFxyXG4gICAgICAgICAgICAgICAgYm91bmRTdGF0ZS5zdGVuY2lsQmFja0RlcHRoRmFpbE9wICE9PSBzdGF0ZS5zdGVuY2lsQmFja0RlcHRoRmFpbE9wIHx8XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLnN0ZW5jaWxCYWNrRGVwdGhQYXNzT3AgIT09IHN0YXRlLnN0ZW5jaWxCYWNrRGVwdGhQYXNzT3ApIHtcclxuICAgICAgICAgICAgICAgIGdsLnN0ZW5jaWxPcFNlcGFyYXRlKGdsLkJBQ0ssIHN0YXRlLnN0ZW5jaWxCYWNrRmFpbE9wLCBzdGF0ZS5zdGVuY2lsQmFja0RlcHRoRmFpbE9wLCBzdGF0ZS5zdGVuY2lsQmFja0RlcHRoUGFzc09wKTtcclxuICAgICAgICAgICAgICAgIGJvdW5kU3RhdGUuc3RlbmNpbEJhY2tGYWlsT3AgPSBzdGF0ZS5zdGVuY2lsQmFja0ZhaWxPcDtcclxuICAgICAgICAgICAgICAgIGJvdW5kU3RhdGUuc3RlbmNpbEJhY2tEZXB0aEZhaWxPcCA9IHN0YXRlLnN0ZW5jaWxCYWNrRGVwdGhGYWlsT3A7XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLnN0ZW5jaWxCYWNrRGVwdGhQYXNzT3AgPSBzdGF0ZS5zdGVuY2lsQmFja0RlcHRoUGFzc09wO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHNjaXNzb3IgdGVzdCBzdGF0ZSBhbmQgc2Npc3NvciByZWN0YW5nbGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHN0YXRlIFRoZSBzdGF0ZSB0aGF0IGNvbnRhaW5zIG5ldyBzY2lzc29yIHRlc3Qgc3RhdGUgYW5kIHNjaXNzb3JcclxuICAgICAqICAgICAgcmVjdGFuZ2xlLlxyXG4gICAgICovXHJcbiAgICBfc2V0U2Npc3NvclRlc3RTdGF0ZShzdGF0ZSkge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XHJcbiAgICAgICAgY29uc3QgYm91bmRTdGF0ZSA9IHRoaXMuX2JvdW5kUmVuZGVyU3RhdGU7XHJcbiAgICAgICAgaWYgKGJvdW5kU3RhdGUuc2Npc3NvclRlc3QgIT09IHN0YXRlLnNjaXNzb3JUZXN0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldENhcGFiaWxpdHlFbmFibGVkKGdsLlNDSVNTT1JfVEVTVCwgc3RhdGUuc2Npc3NvclRlc3QpO1xyXG4gICAgICAgICAgICBib3VuZFN0YXRlLnNjaXNzb3JUZXN0ID0gc3RhdGUuc2Npc3NvclRlc3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdGF0ZS5zY2lzc29yVGVzdCAmJlxyXG4gICAgICAgICAgICBzdGF0ZS5zY2lzc29yV2lkdGggPj0gMCAmJlxyXG4gICAgICAgICAgICBzdGF0ZS5zY2lzc29ySGVpZ2h0ID49IDAgJiZcclxuICAgICAgICAgICAgKGJvdW5kU3RhdGUuc2Npc3NvclggIT09IHN0YXRlLnNjaXNzb3JYIHx8XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLnNjaXNzb3JZICE9PSBzdGF0ZS5zY2lzc29yWSB8fFxyXG4gICAgICAgICAgICAgICAgYm91bmRTdGF0ZS5zY2lzc29yV2lkdGggIT09IHN0YXRlLnNjaXNzb3JXaWR0aCB8fFxyXG4gICAgICAgICAgICAgICAgYm91bmRTdGF0ZS5zY2lzc29ySGVpZ2h0ICE9PSBzdGF0ZS5zY2lzc29ySGVpZ2h0KSkge1xyXG4gICAgICAgICAgICBnbC5zY2lzc29yKHN0YXRlLnNjaXNzb3JYLCBzdGF0ZS5zY2lzc29yWSwgc3RhdGUuc2Npc3NvcldpZHRoLCBzdGF0ZS5zY2lzc29ySGVpZ2h0KTtcclxuICAgICAgICAgICAgYm91bmRTdGF0ZS5zY2lzc29yWCA9IHN0YXRlLnNjaXNzb3JYO1xyXG4gICAgICAgICAgICBib3VuZFN0YXRlLnNjaXNzb3JZID0gc3RhdGUuc2Npc3Nvclk7XHJcbiAgICAgICAgICAgIGJvdW5kU3RhdGUuc2Npc3NvcldpZHRoID0gc3RhdGUuc2Npc3NvcldpZHRoO1xyXG4gICAgICAgICAgICBib3VuZFN0YXRlLnNjaXNzb3JIZWlnaHQgPSBzdGF0ZS5zY2lzc29ySGVpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB2aWV3cG9ydC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3RhdGUgVGhlIHN0YXRlIHRoYXQgY29udGFpbnMgbmV3IHZpZXdwb3J0LlxyXG4gICAgICovXHJcbiAgICBfc2V0Vmlld3BvcnRTdGF0ZShzdGF0ZSkge1xyXG4gICAgICAgIGNvbnN0IGJvdW5kU3RhdGUgPSB0aGlzLl9ib3VuZFJlbmRlclN0YXRlO1xyXG4gICAgICAgIGlmIChzdGF0ZS52aWV3cG9ydFdpZHRoID49IDAgJiZcclxuICAgICAgICAgICAgc3RhdGUudmlld3BvcnRIZWlnaHQgPj0gMCAmJlxyXG4gICAgICAgICAgICAoYm91bmRTdGF0ZS52aWV3cG9ydFggIT09IHN0YXRlLnZpZXdwb3J0WCB8fFxyXG4gICAgICAgICAgICAgICAgYm91bmRTdGF0ZS52aWV3cG9ydFkgIT09IHN0YXRlLnZpZXdwb3J0WSB8fFxyXG4gICAgICAgICAgICAgICAgYm91bmRTdGF0ZS52aWV3cG9ydFdpZHRoICE9PSBzdGF0ZS52aWV3cG9ydFdpZHRoIHx8XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLnZpZXdwb3J0SGVpZ2h0ICE9PSBzdGF0ZS52aWV3cG9ydEhlaWdodCkpIHtcclxuICAgICAgICAgICAgdGhpcy5fZ2wudmlld3BvcnQoc3RhdGUudmlld3BvcnRYLCBzdGF0ZS52aWV3cG9ydFksIHN0YXRlLnZpZXdwb3J0V2lkdGgsIHN0YXRlLnZpZXdwb3J0SGVpZ2h0KTtcclxuICAgICAgICAgICAgYm91bmRTdGF0ZS52aWV3cG9ydFggPSBzdGF0ZS52aWV3cG9ydFg7XHJcbiAgICAgICAgICAgIGJvdW5kU3RhdGUudmlld3BvcnRZID0gc3RhdGUudmlld3BvcnRZO1xyXG4gICAgICAgICAgICBib3VuZFN0YXRlLnZpZXdwb3J0V2lkdGggPSBzdGF0ZS52aWV3cG9ydFdpZHRoO1xyXG4gICAgICAgICAgICBib3VuZFN0YXRlLnZpZXdwb3J0SGVpZ2h0ID0gc3RhdGUudmlld3BvcnRIZWlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRleHR1cmUgZGF0YSB1bnBhY2sgcGFyYW1zLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwYXJhbXMgVGV4dHVyZSBwYXJhbXMgdG8gYmUgc2V0LlxyXG4gICAgICovXHJcbiAgICBfc2V0VGV4dHVyZURhdGFVbnBhY2tQYXJhbXMocGFyYW1zKSB7XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcclxuICAgICAgICBpZiAodGhpcy5fdW5wYWNrUHJlbXVsdGlwbHlBbHBoYSAhPT0gcGFyYW1zLnByZW11bHRpcGxpZWRBbHBoYSkge1xyXG4gICAgICAgICAgICBnbC5waXhlbFN0b3JlaSgzNzQ0MSAvKiBVTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wgKi8sICtwYXJhbXMucHJlbXVsdGlwbGllZEFscGhhKTtcclxuICAgICAgICAgICAgdGhpcy5fdW5wYWNrUHJlbXVsdGlwbHlBbHBoYSA9IHBhcmFtcy5wcmVtdWx0aXBsaWVkQWxwaGE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX29uVGV4dHVyZURhdGFVcGRhdGVkKHRleHR1cmUpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xyXG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHRleHR1cmUuZ2V0UGFyYW1zKCk7XHJcbiAgICAgICAgaWYgKHBhcmFtcy5taW5pZmljYXRpb25GaWx0ZXIgPj0gOTk4NCAvKiBORUFSRVNUX01JUE1BUF9ORUFSRVNUICovKSB7XHJcbiAgICAgICAgICAgIGdsLmdlbmVyYXRlTWlwbWFwKGdsLlRFWFRVUkVfMkQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyB6ZXJvZWQgYnVmZmVyIHdpdGggYSBnaXZlbiBzaXplIGFuZCBhIHRhcmdldC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgb2YgdGhlIG5ldyBidWZmZXIsIGBBUlJBWV9CVUZGRVJgIG9yXHJcbiAgICAgKiAgICAgIGBFTEVNRU5UX0FSUkFZX0JVRkZFUmAuXHJcbiAgICAgKiBAcGFyYW0gc2l6ZSBUaGUgc2l6ZSBvZiB0aGUgYnVmZmVyLlxyXG4gICAgICogQHBhcmFtIHVzYWdlIFVzYWdlIG9mIHRoZSBidWZmZXIuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgYnVmZmVyLlxyXG4gICAgICovXHJcbiAgICBfY3JlYXRlQnVmZmVyKHRhcmdldCwgc2l6ZSwgdXNhZ2UgPSB0aGlzLl9nbC5TVEFUSUNfRFJBVykge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XHJcbiAgICAgICAgY29uc3QgYnVmZmVyID0gbmV3IEJ1ZmZlcihnbCwgdGFyZ2V0LCBzaXplKTtcclxuICAgICAgICAvLyBUT0RPKGRtaWtpcykgYSBjbGV2ZXJlciB3YXkgbm90IHRvIGJyZWFrIGN1cnJlbnRseSBib3VuZCBWQU87XHJcbiAgICAgICAgdGhpcy5iaW5kVmFvKG51bGwpO1xyXG4gICAgICAgIGJ1ZmZlci5iaW5kKCk7XHJcbiAgICAgICAgZ2wuYnVmZmVyRGF0YSh0YXJnZXQsIHNpemUsIHVzYWdlKTtcclxuICAgICAgICByZXR1cm4gYnVmZmVyO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IG1hcEl0ZXJhYmxlIH0gZnJvbSAnLi4vdXRpbC9pdGVyYWJsZSc7XHJcbmltcG9ydCB7IGFsaWduIH0gZnJvbSAnLi4vdXRpbC9wb3dfb2ZfMic7XHJcbi8qKlxyXG4gKiBHaXZlcyBzaXplIG9mIGEgR0wgdHlwZS5cclxuICpcclxuICogQHBhcmFtIHR5cGUgVGhlIHR5cGUuXHJcbiAqIEByZXR1cm5zIFNpemUgb2YgdGhlIHR5cGUgaW4gYnl0ZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRUeXBlU2l6ZSh0eXBlKSB7XHJcbiAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICBjYXNlIDUxMjAgLyogQllURSAqLzpcclxuICAgICAgICBjYXNlIDUxMjEgLyogVU5TSUdORURfQllURSAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgY2FzZSA1MTIyIC8qIFNIT1JUICovOlxyXG4gICAgICAgIGNhc2UgNTEyMyAvKiBVTlNJR05FRF9TSE9SVCAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIDI7XHJcbiAgICAgICAgY2FzZSA1MTI0IC8qIElOVCAqLzpcclxuICAgICAgICBjYXNlIDUxMjUgLyogVU5TSUdORURfSU5UICovOlxyXG4gICAgICAgIGNhc2UgNTEyNiAvKiBGTE9BVCAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIDQ7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIERlc2NyaXB0aW9uIG9mIGhvdyBwYXJ0aWN1bGFyIGF0dHJpYnV0ZXMgb2YgYSB2ZXJ0ZXggYXJlIHBhY2tlZCBpbnRvIGEgdmVydGV4XHJcbiAqIGJ1ZmZlci5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBBdHRyaWJ1dGVNYXBwaW5nIGV4dGVuZHMgTWFwIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBhdHRyaWJ1dGUgbWFwcGluZyB3aXRoIGEgc2V0IG9mIGF0dHJpYnV0ZXMgb2YgZ2l2ZW4gdHlwZXMgYW5kXHJcbiAgICAgKiBzaXplcy4gQXV0b21hdGljYWxseSBjb21wdXRlcyBvZmZzZXRzIG9mIHRoZSBhdHRyaWJ1dGVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtYXBwaW5nIFRoZSBtYXBwaW5nIGZyb20gYXR0cmlidXRlIElEcyB0byB0eXBlcyBhbmQgc2l6ZXMuXHJcbiAgICAgKiBAcGFyYW0gYWxpZ25tZW50IERlc2lyZWQgYWxpZ25tZW50IG9mIGF0dHJpYnV0ZXMgaW4gdGhlIHZlcnRleCBkYXRhXHJcbiAgICAgKiAgICAgIHN0cnVjdHVyZS4gTXVzdCBiZSBhIHBvd2VyIG9mIDIuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG1hcHBpbmcsIGFsaWdubWVudCA9IDQgLyogQUxJR05fNF9CWVRFUyAqLykge1xyXG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xyXG4gICAgICAgIHN1cGVyKG1hcEl0ZXJhYmxlKG1hcHBpbmcsIChbaWR4LCB7IHR5cGUsIHNpemUsIG5vcm1hbGl6ZWQgfV0pID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcG9pbnRlciA9IFtcclxuICAgICAgICAgICAgICAgIGlkeCxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlLFxyXG4gICAgICAgICAgICAgICAgICAgIHNpemUsXHJcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZCxcclxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgY29uc3QgYXR0cmlidXRlU2l6ZSA9IHNpemUgKiBnZXRUeXBlU2l6ZSh0eXBlKTtcclxuICAgICAgICAgICAgY29uc3QgbmV3T2Zmc2V0ID0gYWxpZ24ob2Zmc2V0ICsgYXR0cmlidXRlU2l6ZSwgLWFsaWdubWVudCk7XHJcbiAgICAgICAgICAgIC8vIFRPRE8oZG1pa2lzKSBDaGVjayB0aGlzIGluIGRlYnVnIG1vZGUuXHJcbiAgICAgICAgICAgIC8vIGlmIChuZXdPZmZzZXQgLSBvZmZzZXQgPiBhdHRyaWJ1dGVTaXplKSB7XHJcbiAgICAgICAgICAgIC8vICAgIGNvbnNvbGUud2FybihgJHtuZXdPZmZzZXQgLSBvZmZzZXR9IGJ5dGUgcGFkZGluZydzIGluc2VydGVkYCk7XHJcbiAgICAgICAgICAgIC8vIH1cclxuICAgICAgICAgICAgb2Zmc2V0ID0gbmV3T2Zmc2V0O1xyXG4gICAgICAgICAgICByZXR1cm4gcG9pbnRlcjtcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhCeXRlU2l6ZSA9IG9mZnNldDtcclxuICAgIH1cclxufVxyXG4iLCIvKipcclxuICogU2VhcmNoZXMgZm9yIHRoZSBmaXJzdCBjb2xsZWN0aW9uIGl0ZW0gc2F0aXNmeWluZyBhIHByZWRpY2F0ZS5cclxuICpcclxuICogQHBhcmFtIGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24uXHJcbiAqIEBwYXJhbSBwcmVkaWNhdGUgVGhlIHByZWRpY2F0ZS5cclxuICogQHJldHVybnMgVGhlIGZpcnN0IGl0ZW0gc2F0aXNmeWluZyB0aGUgcHJlZGljYXRlIG9yIGB1bmRlZmluZWRgIGlmIG5vbmUgZm91bmQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZmluZEluSXRlcmFibGUoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XHJcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgY29sbGVjdGlvbikge1xyXG4gICAgICAgIGlmIChwcmVkaWNhdGUoaXRlbSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGl0ZW07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuO1xyXG59XHJcbi8qKlxyXG4gKiBUcmFuc2Zvcm1zIGEgY29sbGVjdGlvbiB0byBhbm90aGVyIG9uZS5cclxuICpcclxuICogQHBhcmFtIGNvbGxlY3Rpb24gVGhlIHNvdXJjZSBjb2xsZWN0aW9uLlxyXG4gKiBAcGFyYW0gbWFwcGVyIEEgZnVuY3Rpb24gcHJvZHVjaW5nIGl0ZW1zIGZvciBkZXN0aW5hdGlvbiBjb2xsZWN0aW9uLlxyXG4gKiBAcmV0dXJucyBDb2xsZWN0aW9uIG9mIHByb2R1Y2VkIGl0ZW1zLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uKiBtYXBJdGVyYWJsZShjb2xsZWN0aW9uLCBtYXBwZXIpIHtcclxuICAgIGZvciAoY29uc3QgaXRlbSBvZiBjb2xsZWN0aW9uKSB7XHJcbiAgICAgICAgeWllbGQgbWFwcGVyKGl0ZW0pO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDaG9vc2VzIGl0ZW1zIG9mIGEgY29sbGVjdGlvbiBzYXRpc2Z5aW5nIGEgcHJlZGljYXRlLlxyXG4gKlxyXG4gKiBAcGFyYW0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbi5cclxuICogQHBhcmFtIHByZWRpY2F0ZSBUaGUgcHJlZGljYXRlLlxyXG4gKiBAcmV0dXJucyBDb2xsZWN0aW9uIG9mIGNob3NlbiBpdGVtcy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiogZmlsdGVySXRlcmFibGUoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XHJcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgY29sbGVjdGlvbikge1xyXG4gICAgICAgIGlmIChwcmVkaWNhdGUoaXRlbSkpIHtcclxuICAgICAgICAgICAgeWllbGQgaXRlbTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFRyYXZlcnNlcyBhIGNvbGxlY3Rpb24gZnJvbSBsZWZ0IHRvIHJpZ2h0IHJlY29tcHV0aW5nIGFuIGFjY3VtdWxhdG9yIG9uIGV2ZXJ5XHJcbiAqIGl0ZXJhdGlvbi5cclxuICpcclxuICogQHBhcmFtIGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24uXHJcbiAqIEBwYXJhbSByZWR1Y2VyIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGNvbXB1dGUgbmV4dCB2YWx1ZSBvZiB0aGUgYWNjdW11bGF0b3IuXHJcbiAqIEBwYXJhbSBpbml0aWFsXHJcbiAqIEByZXR1cm5zIFZhbHVlIG9mIHRoZSBhY2N1bXVsYXRvci5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiByZWR1Y2VJdGVyYWJsZShjb2xsZWN0aW9uLCByZWR1Y2VyLCBpbml0aWFsKSB7XHJcbiAgICBsZXQgcmVzdWx0ID0gaW5pdGlhbDtcclxuICAgIGZvciAoY29uc3QgaXRlbSBvZiBjb2xsZWN0aW9uKSB7XHJcbiAgICAgICAgcmVzdWx0ID0gcmVkdWNlcihyZXN1bHQsIGl0ZW0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG4vKipcclxuICogQ2hlY2tzIGlmIHRoZXJlJ3MgYXQgbGVhc3Qgb25lIGl0ZW0gaW4gYSBjb2xsZWN0aW9uIHNhdGlzZnlpbmcgYSBwcmVkaWNhdGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uLlxyXG4gKiBAcGFyYW0gcHJlZGljYXRlIFRoZSBwcmVkaWNhdGUuXHJcbiAqIEByZXR1cm5zIGB0cnVlYCBpZiBmb3IgYXQgbGVhc3Qgb25lIGl0ZW0gaW4gdGhlIGNvbGxlY3Rpb24gdGhlIHByZWRpY2F0ZSByZXR1cm5zXHJcbiAqICAgICAgYHRydWVgIGFuZCBgZmFsc2VgIG90aGVyd2lzZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBvbmVPZkl0ZXJhYmxlKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xyXG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGNvbGxlY3Rpb24pIHtcclxuICAgICAgICBpZiAocHJlZGljYXRlKGl0ZW0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG4vKipcclxuICogQ2hlY2tzIGlmIGFsbCBpdGVtcyBvZiBhIGNvbGxlY3Rpb24gc2F0aXNmeSBhIHByZWRpY2F0ZS5cclxuICpcclxuICogQHBhcmFtIGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24uXHJcbiAqIEBwYXJhbSBwcmVkaWNhdGUgVGhlIHByZWRpY2F0ZS5cclxuICogQHJldHVybnMgYGZhbHNlYCBpZiBmb3IgYXQgbGVhc3Qgb25lIGl0ZW0gaW4gdGhlIGNvbGxlY3Rpb24gdGhlIHByZWRpY2F0ZSByZXR1cm5zXHJcbiAqICAgICAgYGZhbHNlYCBhbmQgYHRydWVgIG90aGVyd2lzZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBhbGxPZkl0ZXJhYmxlKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xyXG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGNvbGxlY3Rpb24pIHtcclxuICAgICAgICBpZiAoIXByZWRpY2F0ZShpdGVtKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgYW4gaXRlcmF0b3IgZm9yIFtzdGFydEluZGV4LCBzdGFydEluZGV4K2xlbmd0aCkgcmFuZ2UuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24qIHJhbmdlSXRlcmFibGUobGVuZ3RoLCBzdGFydEluZGV4ID0gMCkge1xyXG4gICAgY29uc3QgZW5kSW5kZXggPSBzdGFydEluZGV4ICsgbGVuZ3RoO1xyXG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXg7IGkgPCBlbmRJbmRleDsgaSsrKSB7XHJcbiAgICAgICAgeWllbGQgaTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgZnVuY3Rpb24qIHppcEl0ZXJhYmxlcyh0cywgdXMsIHppcHBlciA9ICh0LCB1KSA9PiBbdCwgdV0pIHtcclxuICAgIGNvbnN0IHRJdGVyYXRvciA9IHRzW1N5bWJvbC5pdGVyYXRvcl0oKTtcclxuICAgIGNvbnN0IHVJdGVyYXRvciA9IHVzW1N5bWJvbC5pdGVyYXRvcl0oKTtcclxuICAgIGZvciAobGV0IHQgPSB0SXRlcmF0b3IubmV4dCgpLCB1ID0gdUl0ZXJhdG9yLm5leHQoKTsgISh0LmRvbmUgfHwgdS5kb25lKTsgdCA9IHRJdGVyYXRvci5uZXh0KCksIHUgPSB1SXRlcmF0b3IubmV4dCgpKSB7XHJcbiAgICAgICAgeWllbGQgemlwcGVyKHQudmFsdWUsIHUudmFsdWUpO1xyXG4gICAgfVxyXG59XHJcbiIsIi8qKlxyXG4gKiBDaGVja3MgaWYgYSBudW1iZXIgaXMgYSBwb3dlciBvZiAyLlxyXG4gKlxyXG4gKiBAcGFyYW0geCBUaGUgbnVtYmVyIHRvIGNoZWNrLlxyXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG51bWJlciBpcyBhbiBpbnRlZ2VyIHBvd2VyIG9mIDIgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzUG93T2YyKHgpIHtcclxuICAgIHJldHVybiB4ID4gMCAmJiAhKHggJiAoeCAtIDEpKTtcclxufVxyXG4vKipcclxuICogQWxpZ25zIGFuIG9mZnNldCBieSBhbiBhbGlnbm1lbnQgZ2l2ZW4gYnkgYSBtYXNrLlxyXG4gKlxyXG4gKiBAcGFyYW0gb2Zmc2V0IFRoZSBvZmZzZXQuXHJcbiAqIEBwYXJhbSBhbGlnbm1lbnRNYXNrIFRoZSBhbGlnbm1lbnQgbWFzayDigJQgYSBiaXQgZmllbGQgdGhhdCBoYXMgYGxvZzIoYWxpZ25tZW50KWBcclxuICogICAgICBvZiBsZWFzdCBzaWduaWZpY2FudCBiaXRzIHVuc2V0IGFuZCBvdGhlciBzZXQsIGUuZy4gaWYgYGFsaWdubWVudGAgaXMgNFxyXG4gKiAgICAgIHRoZW4gdGhlIGBhbGlnbm1lbnRNYXNrYCB3aWxsIGJlIGAweGZmZmZmZmNgXHJcbiAqIEByZXR1cm5zIEFsaWduZWQgb2Zmc2V0LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGFsaWduKG9mZnNldCwgYWxpZ25tZW50TWFzaykge1xyXG4gICAgcmV0dXJuIChvZmZzZXQgLSAxICYgYWxpZ25tZW50TWFzaykgLSBhbGlnbm1lbnRNYXNrO1xyXG59XHJcbiIsIi8qKiBXcmFwcGVyIGFyb3VuZCBXZWJHTEJ1ZmZlciBvYmplY3QuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJ1ZmZlciB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgZW1wdHkgYnVmZmVyIGluIGEgV2ViR0wgY29udGV4dC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZ2wgVGhlIGNvbnRleHQgdGhlIGJ1ZmZlciB3aWxsIGJlIGNyZWF0ZWQgaW4uXHJcbiAgICAgKiBAcGFyYW0gdGFyZ2V0IEJpbmRpbmcgdGFyZ2V0IG9mIHRoZSBidWZmZXIuIFNpbmNlIGluIFdlYkdMIG9uY2UgeW91J3ZlXHJcbiAgICAgKiAgICAgIGJvdW5kIGEgYnVmZmVyIHRvIGEgZ2l2ZW4gdGFyZ2V0IHlvdSBjYW4ndCBiaW5kIGl0IGFueSBvdGhlciBvbmUsXHJcbiAgICAgKiAgICAgIHdlIFwidGllXCIgdGhlIGJ1ZmZlciBhbmQgaXQncyBiaW5kaW5nIHBvaW50IHRvZ2V0aGVyLlxyXG4gICAgICogQHBhcmFtIHNpemUgU2l6ZSBvZiB0aGUgYnVmZmVyLiBXZSBkb24ndCBkbyBhY3R1YWwgYWxsb2NhdGlvbiBpbiB0aGVcclxuICAgICAqICAgICAgd3JhcHBlciwgaXQncyBjb250ZXh0J3MgcmVzcG9uc2liaWxpdHkuIEJ1dCBpdCdzIGNvbnZlbmllbnQgdG8gYmVcclxuICAgICAqICAgICAgYWJsZSB0byBnZXQgdGhlIHNpemUgZnJvbSB0aGUgd3JhcHBlciBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGdsLCB0YXJnZXQsIHNpemUpIHtcclxuICAgICAgICB0aGlzLl9nbCA9IGdsO1xyXG4gICAgICAgIHRoaXMuX3RhcmdldCA9IHRhcmdldDtcclxuICAgICAgICB0aGlzLl9oYW5kbGUgPSBnbC5jcmVhdGVCdWZmZXIoKTtcclxuICAgICAgICB0aGlzLl9zaXplID0gc2l6ZTtcclxuICAgIH1cclxuICAgIC8qKiBCaW5kcyB0aGUgYnVmZmVyIHRvIHRoZSBjb250ZXh0IHRvIGl0cyBiaW5kaW5nIHRhcmdldC4gKi9cclxuICAgIGJpbmQoKSB7XHJcbiAgICAgICAgdGhpcy5fZ2wuYmluZEJ1ZmZlcih0aGlzLl90YXJnZXQsIHRoaXMuX2hhbmRsZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBidWZmZXIgaXMgY3VycmVudGx5IGJvdW5kIHRvIHRoZSBjb250ZXh0IHRvIGl0c1xyXG4gICAgICogYmluZGluZyB0YXJnZXQgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxyXG4gICAgICovXHJcbiAgICBpc0JvdW5kKCkge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XHJcbiAgICAgICAgY29uc3QgaGFuZGxlID0gdGhpcy5faGFuZGxlO1xyXG4gICAgICAgIHN3aXRjaCAodGhpcy5fdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIGNhc2UgZ2wuQVJSQVlfQlVGRkVSOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdsLmdldFBhcmFtZXRlcihnbC5BUlJBWV9CVUZGRVJfQklORElORykgPT09IGhhbmRsZTtcclxuICAgICAgICAgICAgY2FzZSBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBnbC5nZXRQYXJhbWV0ZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVJfQklORElORykgPT09IGhhbmRsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqIFJldHVybnMgYmluZGluZyB0YXJnZXQgb2YgdGhlIGJ1ZmZlci4gKi9cclxuICAgIGdldFRhcmdldCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdGFyZ2V0O1xyXG4gICAgfVxyXG4gICAgLyoqIFJldHVybnMgc2l6ZSBvZiB0aGUgYnVmZmVyLiAqL1xyXG4gICAgZ2V0U2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGVzdHJveXMgdGhlIGJ1ZmZlci5cclxuICAgICAqL1xyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLl9nbC5kZWxldGVCdWZmZXIodGhpcy5faGFuZGxlKTtcclxuICAgIH1cclxufVxyXG4iLCIvKiogV3JhcHBlciBhcm91bmQgV2ViR0xGcmFtZWJ1ZmZlciBvYmplY3QuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZyYW1lYnVmZmVyIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBmcmFtZWJ1ZmZlciBpbiBhIFdlYkdMIGNvbnRleHQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGdsIFRoZSBjb250ZXh0IHRoZSBmcmFtZWJ1ZmZlciB3aWxsIGJlIGNyZWF0ZWQgaW4uXHJcbiAgICAgKiBAcGFyYW0gd2lkdGggV2lkdGggb2YgdGhlIGZyYW1lYnVmZmVyLlxyXG4gICAgICogQHBhcmFtIGhlaWdodCBIZWlnaHQgb2YgdGhlIGZyYW1lYnVmZmVyLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihnbCwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIHRoaXMuaXNDbGVhciA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2dsID0gZ2w7XHJcbiAgICAgICAgdGhpcy5faGFuZGxlID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcclxuICAgICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQmluZHMgdGhlIGZyYW1lYnVmZmVyIHRvIHRoZSBXZWJHTCBjb250ZXh0LlxyXG4gICAgICovXHJcbiAgICBiaW5kKCkge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XHJcbiAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLl9oYW5kbGUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgdGhlIGZyYW1lYnVmZmVyIGlzIGJvdW5kIHRvIHRoZSBXZWJHTCBjb250ZXh0LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgZnJhbWVidWZmZXIgaXMgY3VycmVudGx5IGJvdW5kIHRvIHRoZSBXZWJHTCBjb250ZXh0XHJcbiAgICAgKiAgICAgIGFuZCBgZmFsc2VgIG90aGVyd2lzZS5cclxuICAgICAqL1xyXG4gICAgaXNCb3VuZCgpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xyXG4gICAgICAgIHJldHVybiBnbC5nZXRQYXJhbWV0ZXIoZ2wuRlJBTUVCVUZGRVJfQklORElORykgPT09IHRoaXMuX2hhbmRsZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB3aWR0aCBvZiB0aGUgZnJhbWVidWZmZXIuXHJcbiAgICAgKi9cclxuICAgIGdldFdpZHRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl93aWR0aDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBoZWlnaHQgb2YgdGhlIGZyYW1lYnVmZmVyLlxyXG4gICAgICovXHJcbiAgICBnZXRIZWlnaHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlaWdodDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgY29udGVudCBvZiB0aGUgY29sb3IgYXR0YWNobWVudCBhcyBhbiBSR0JBIGJpdG1hcC5cclxuICAgICAqL1xyXG4gICAgcmVhZFBpeGVscygpIHtcclxuICAgICAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5nZXRXaWR0aCgpICogdGhpcy5nZXRIZWlnaHQoKSAqIDQpO1xyXG4gICAgICAgIHRoaXMuX2dsLnJlYWRQaXhlbHMoMCwgMCwgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCwgNjQwOCAvKiBSR0JBICovLCA1MTIxIC8qIFVOU0lHTkVEX0JZVEUgKi8sIGRhdGEpO1xyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXN0cm95cyB0aGUgZnJhbWVidWZmZXIuXHJcbiAgICAgKi9cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5fZ2wuZGVsZXRlRnJhbWVidWZmZXIodGhpcy5faGFuZGxlKTtcclxuICAgIH1cclxufVxyXG4iLCIvKipcclxuICogSW5zZXJ0cyBnaXZlbiBwYXJhbWV0ZXJzIGFzIHByZXByb2Nlc3NvciBkZWZpbmUgZGlyZWN0aXZlcyBpbnRvIHNoYWRlciBzb3VyY2UuXHJcbiAqXHJcbiAqIEBwYXJhbSBzb3VyY2UgU2hhZGVyIHNvdXJjZS5cclxuICogQHBhcmFtIGRlZmluZXMgRGljdGlvbmFyeSB3aXRoIHBhcmFtZXRlcnMgdG8gZGVmaW5lIHdpdGggcHJlcHJvY2Vzc29yIGRpcmVjdGl2ZXMuXHJcbiAqIEByZXR1cm5zIFNoYWRlciBzb3VyY2Ugd2l0aCBwcmVwcm9jZXNzb3IgZGlyZWN0aXZlcyBpbnNlcnRlZC5cclxuICovXHJcbmZ1bmN0aW9uIGluc2VydERlZmluZXMoc291cmNlLCBkZWZpbmVzKSB7XHJcbiAgICBjb25zdCBkZWZpbmVzU3RyaW5nID0gT2JqZWN0LmtleXMoZGVmaW5lcylcclxuICAgICAgICAubWFwKChkZWZpbmVOYW1lKSA9PiAnI2RlZmluZSAnICsgZGVmaW5lTmFtZSArICcgJyArXHJcbiAgICAgICAgZGVmaW5lc1tkZWZpbmVOYW1lXSlcclxuICAgICAgICAuam9pbignXFxuJyk7XHJcbiAgICBjb25zdCB2ZXJzaW9uSWR4ID0gc291cmNlLmluZGV4T2YoJyN2ZXJzaW9uJyk7XHJcbiAgICBpZiAodmVyc2lvbklkeCA9PT0gLTEpIHtcclxuICAgICAgICByZXR1cm4gZGVmaW5lc1N0cmluZyArICdcXG4nICsgc291cmNlO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbmV4dExpbmVJZHggPSBzb3VyY2UuaW5kZXhPZignXFxuJywgdmVyc2lvbklkeCkgKyAxO1xyXG4gICAgcmV0dXJuIHNvdXJjZS5zbGljZSgwLCBuZXh0TGluZUlkeCkgKyBkZWZpbmVzU3RyaW5nICsgJ1xcbicgK1xyXG4gICAgICAgIHNvdXJjZS5zbGljZShuZXh0TGluZUlkeCk7XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgc2hhZGVyIG9mIGEgZ2l2ZW4gdHlwZSBvdXQgb2YgYSBnaXZlbiBzb3VyY2Ugc3RyaW5nLlxyXG4gKlxyXG4gKiBAcGFyYW0gZ2wgV2ViR0wgY29udGV4dCB0aGUgc2hhZGVyIHdpbGwgYmUgY3JlYXRlZCBpbi5cclxuICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgb2YgdGhlIHNoYWRlciwgVkVSVEVYX1NIQURFUiBvciBGUkFHTUVOVF9TSEFERVIuXHJcbiAqIEBwYXJhbSBzb3VyY2UgVGhlIHNvdXJjZSBzdHJpbmcuXHJcbiAqIEB0aHJvd3MgQW4gZXJyb3IgaWYgY29tcGlsYXRpb24gb2YgdGhlIHNoYWRlciBmYWlscy5cclxuICogQHJldHVybnMgVGhlIHNoYWRlciBXZWJHTCBoYW5kbGUuXHJcbiAqL1xyXG5mdW5jdGlvbiBjb21waWxlU2hhZGVyKGdsLCB0eXBlLCBzb3VyY2UpIHtcclxuICAgIGNvbnN0IHNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcih0eXBlKTtcclxuICAgIGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNvdXJjZSk7XHJcbiAgICBnbC5jb21waWxlU2hhZGVyKHNoYWRlcik7XHJcbiAgICAvLyBUT0RPIFVuY29tbWVudCBhbmQgcHV0IHVuZGVyIGRlYnVnIGZsYWcgKHdoZW4gaW1wbGVtZW50ZWQpXHJcbiAgICBpZiAoIWdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGNvbXBpbGUgc2hhZGVyOlxcbicgKyBnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcikpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNoYWRlcjtcclxufVxyXG4vKiogV3JhcHBlciBhcm91bmQgV2ViR0xQcm9ncmFtIG9iamVjdHMuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByb2dyYW0ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IHByb2dyYW0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGdsIFdlYkdMIGNvbnRleHQgdGhlIHByb2dyYW0gd2lsbCBiZSBjcmVhdGVkIGluLlxyXG4gICAgICogQHBhcmFtIHZlcnRleFNoYWRlclNvdXJjZSBTb3VyY2UgY29kZSBvZiB2ZXJ0ZXggc2hhZGVyIG9mIHRoZSBwcm9ncmFtLlxyXG4gICAgICogQHBhcmFtIGZyYWdtZW50U2hhZGVyU291cmNlIFNvdXJjZSBjb2RlIG9mIGZyYWdtZW50IHNoYWRlciBvZiB0aGUgcHJvZ3JhbS5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMuXHJcbiAgICAgKiBAdGhyb3dzIEFuIGVycm9yIGlmIHNoYWRlciBjb21waWxhdGlvbiBvciBwcm9ncmFtIGxpbmtpbmcgZmFpbHMuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGdsLCB2ZXJ0ZXhTaGFkZXJTb3VyY2UsIGZyYWdtZW50U2hhZGVyU291cmNlLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5fZ2wgPSBnbDtcclxuICAgICAgICBjb25zdCBoYW5kbGUgPSB0aGlzLl9oYW5kbGUgPSBnbC5jcmVhdGVQcm9ncmFtKCk7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5kZWZpbmVzKSB7XHJcbiAgICAgICAgICAgIHZlcnRleFNoYWRlclNvdXJjZSA9IGluc2VydERlZmluZXModmVydGV4U2hhZGVyU291cmNlLCBvcHRpb25zLmRlZmluZXMpO1xyXG4gICAgICAgICAgICBmcmFnbWVudFNoYWRlclNvdXJjZSA9IGluc2VydERlZmluZXMoZnJhZ21lbnRTaGFkZXJTb3VyY2UsIG9wdGlvbnMuZGVmaW5lcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHZlcnRleFNoYWRlciA9IGNvbXBpbGVTaGFkZXIoZ2wsIGdsLlZFUlRFWF9TSEFERVIsIHZlcnRleFNoYWRlclNvdXJjZSk7XHJcbiAgICAgICAgY29uc3QgZnJhZ21lbnRTaGFkZXIgPSBjb21waWxlU2hhZGVyKGdsLCBnbC5GUkFHTUVOVF9TSEFERVIsIGZyYWdtZW50U2hhZGVyU291cmNlKTtcclxuICAgICAgICBnbC5hdHRhY2hTaGFkZXIoaGFuZGxlLCB2ZXJ0ZXhTaGFkZXIpO1xyXG4gICAgICAgIGdsLmF0dGFjaFNoYWRlcihoYW5kbGUsIGZyYWdtZW50U2hhZGVyKTtcclxuICAgICAgICBnbC5kZWxldGVTaGFkZXIodmVydGV4U2hhZGVyKTtcclxuICAgICAgICBnbC5kZWxldGVTaGFkZXIoZnJhZ21lbnRTaGFkZXIpO1xyXG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYXR0cmliTWFwKSB7XHJcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG9wdGlvbnMuYXR0cmliTWFwKVxyXG4gICAgICAgICAgICAgICAgLmZvckVhY2goKGF0dHJpYnV0ZU5hbWUpID0+IGdsLmJpbmRBdHRyaWJMb2NhdGlvbihoYW5kbGUsIG9wdGlvbnMuYXR0cmliTWFwW2F0dHJpYnV0ZU5hbWVdLCBhdHRyaWJ1dGVOYW1lKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdsLmxpbmtQcm9ncmFtKGhhbmRsZSk7XHJcbiAgICAgICAgLy8gVE9ETyBVbmNvbW1lbnQgYW5kIHB1dCB1bmRlciBkZWJ1ZyBmbGFnICh3aGVuIGltcGxlbWVudGVkKVxyXG4gICAgICAgIGlmICghZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihoYW5kbGUsIGdsLkxJTktfU1RBVFVTKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBsaW5rIHByb2dyYW06XFxuJHtnbC5nZXRQcm9ncmFtSW5mb0xvZyhoYW5kbGUpfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl91bmlmb3JtQ2FjaGUgPSBuZXcgTWFwKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEJpbmRzIHRoZSBwcm9ncmFtIHRvIHRoZSBXZWJHTCBjb250ZXh0LlxyXG4gICAgICovXHJcbiAgICBiaW5kKCkge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XHJcbiAgICAgICAgY29uc3QgaGFuZGxlID0gdGhpcy5faGFuZGxlO1xyXG4gICAgICAgIC8vIFRPRE8gVW5jb21tZW50IGFuZCBwdXQgdW5kZXIgZGVidWcgZmxhZyAod2hlbiBpbXBsZW1lbnRlZClcclxuICAgICAgICAvLyBnbC52YWxpZGF0ZVByb2dyYW0oaGFuZGxlKTtcclxuICAgICAgICAvLyBpZiAoIWdsLmdldFByb2dyYW1QYXJhbWV0ZXIoaGFuZGxlLCBnbC5WQUxJREFURV9TVEFUVVMpKSB7XHJcbiAgICAgICAgLy8gICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAvLyAgICAgICAgICdGYWlsZWQgdG8gdmFsaWRhdGUgcHJvZ3JhbTpcXG4nICsgZ2wuZ2V0UHJvZ3JhbUluZm9Mb2coaGFuZGxlKVxyXG4gICAgICAgIC8vICAgICApO1xyXG4gICAgICAgIC8vIH1cclxuICAgICAgICBnbC51c2VQcm9ncmFtKGhhbmRsZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyBpZiB0aGUgcHJvZ3JhbSBpcyBib3VuZCB0byB0aGUgV2ViR0wgY29udGV4dC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHByb2dyYW0gaWYgY3VycmVudGx5IGJvdW5kIHRvIHRoZSBXZWJHTCBjb250ZXh0IGFuZFxyXG4gICAgICogICAgICBgZmFsc2VgIG90aGVyd2lzZS5cclxuICAgICAqL1xyXG4gICAgaXNCb3VuZCgpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xyXG4gICAgICAgIHJldHVybiBnbC5nZXRQYXJhbWV0ZXIoZ2wuQ1VSUkVOVF9QUk9HUkFNKSA9PT0gdGhpcy5faGFuZGxlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIGFuIGludGVnZXIgc2NhbGFyIHZhbHVlIHRvIGEgdW5pZm9ybS4gSWYgdGhlcmUncyBubyB1bmlmb3JtIHdpdGhcclxuICAgICAqIGdpdmVuIG5hbWUgaW4gdGhlIHByb2dyYW0sIHNpbGVudGx5IGRvZXMgbm90aGluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdW5pZm9ybU5hbWUgTmFtZSBvZiB0aGUgdW5pZm9ybS5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgc2NhbGFyIHZhbHVlLlxyXG4gICAgICovXHJcbiAgICBzZXRJbnRTY2FsYXJVbmlmb3JtKHVuaWZvcm1OYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IGxvY2F0aW9uID0gdGhpcy5fZ2V0VW5pZm9ybUxvY2F0aW9uKHVuaWZvcm1OYW1lKTtcclxuICAgICAgICBpZiAobG9jYXRpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5fZ2wudW5pZm9ybTFpKGxvY2F0aW9uLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIGEgc2NhbGFyIHZhbHVlIHRvIGEgdW5pZm9ybS4gSWYgdGhlcmUncyBubyB1bmlmb3JtIHdpdGhcclxuICAgICAqIGdpdmVuIG5hbWUgaW4gdGhlIHByb2dyYW0sIHNpbGVudGx5IGRvZXMgbm90aGluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdW5pZm9ybU5hbWUgTmFtZSBvZiB0aGUgdW5pZm9ybS5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgc2NhbGFyIHZhbHVlLlxyXG4gICAgICovXHJcbiAgICBzZXRTY2FsYXJVbmlmb3JtKHVuaWZvcm1OYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IGxvY2F0aW9uID0gdGhpcy5fZ2V0VW5pZm9ybUxvY2F0aW9uKHVuaWZvcm1OYW1lKTtcclxuICAgICAgICBpZiAobG9jYXRpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5fZ2wudW5pZm9ybTFmKGxvY2F0aW9uLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIGEgMkQgdmVjdG9yIHRvIGEgdW5pZm9ybS4gSWYgdGhlcmUncyBubyB1bmlmb3JtIHdpdGggZ2l2ZW4gbmFtZSBpblxyXG4gICAgICogdGhlIHByb2dyYW0sIHNpbGVudGx5IGRvZXMgbm90aGluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdW5pZm9ybU5hbWUgTmFtZSBvZiB0aGUgdW5pZm9ybS5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmVjdG9yLlxyXG4gICAgICovXHJcbiAgICBzZXRWZWN0b3IyVW5pZm9ybSh1bmlmb3JtTmFtZSwgdmFsdWUpIHtcclxuICAgICAgICBjb25zdCBsb2NhdGlvbiA9IHRoaXMuX2dldFVuaWZvcm1Mb2NhdGlvbih1bmlmb3JtTmFtZSk7XHJcbiAgICAgICAgaWYgKGxvY2F0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsLnVuaWZvcm0yZihsb2NhdGlvbiwgdmFsdWUueCwgdmFsdWUueSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIGEgM0QgdmVjdG9yIHRvIGEgdW5pZm9ybS4gSWYgdGhlcmUncyBubyB1bmlmb3JtIHdpdGggZ2l2ZW4gbmFtZSBpblxyXG4gICAgICogdGhlIHByb2dyYW0sIHNpbGVudGx5IGRvZXMgbm90aGluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdW5pZm9ybU5hbWUgTmFtZSBvZiB0aGUgdW5pZm9ybS5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmVjdG9yLlxyXG4gICAgICovXHJcbiAgICBzZXRWZWN0b3IzVW5pZm9ybSh1bmlmb3JtTmFtZSwgdmFsdWUpIHtcclxuICAgICAgICBjb25zdCBsb2NhdGlvbiA9IHRoaXMuX2dldFVuaWZvcm1Mb2NhdGlvbih1bmlmb3JtTmFtZSk7XHJcbiAgICAgICAgaWYgKGxvY2F0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsLnVuaWZvcm0zZihsb2NhdGlvbiwgdmFsdWUueCwgdmFsdWUueSwgdmFsdWUueik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIGEgNEQgdmVjdG9yIHRvIGEgdW5pZm9ybS4gSWYgdGhlcmUncyBubyB1bmlmb3JtIHdpdGggZ2l2ZW4gbmFtZSBpblxyXG4gICAgICogdGhlIHByb2dyYW0sIHNpbGVudGx5IGRvZXMgbm90aGluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdW5pZm9ybU5hbWUgTmFtZSBvZiB0aGUgdW5pZm9ybS5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmVjdG9yLlxyXG4gICAgICovXHJcbiAgICBzZXRWZWN0b3I0VW5pZm9ybSh1bmlmb3JtTmFtZSwgdmFsdWUpIHtcclxuICAgICAgICBjb25zdCBsb2NhdGlvbiA9IHRoaXMuX2dldFVuaWZvcm1Mb2NhdGlvbih1bmlmb3JtTmFtZSk7XHJcbiAgICAgICAgaWYgKGxvY2F0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsLnVuaWZvcm00Zihsb2NhdGlvbiwgdmFsdWUueCwgdmFsdWUueSwgdmFsdWUueiwgdmFsdWUudyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIGEgY29sb3IgdG8gYSB1bmlmb3JtLiBJZiB0aGVyZSdzIG5vIHVuaWZvcm0gd2l0aCBnaXZlbiBuYW1lIGluIHRoZVxyXG4gICAgICogcHJvZ3JhbSwgc2lsZW50bHkgZG9lcyBub3RoaW5nLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB1bmlmb3JtTmFtZSBOYW1lIG9mIHRoZSB1bmlmb3JtLlxyXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSBjb2xvci5cclxuICAgICAqL1xyXG4gICAgc2V0Q29sb3JVbmlmb3JtKHVuaWZvcm1OYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IGxvY2F0aW9uID0gdGhpcy5fZ2V0VW5pZm9ybUxvY2F0aW9uKHVuaWZvcm1OYW1lKTtcclxuICAgICAgICBpZiAobG9jYXRpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5fZ2wudW5pZm9ybTRmKGxvY2F0aW9uLCB2YWx1ZS5yLCB2YWx1ZS5nLCB2YWx1ZS5iLCB2YWx1ZS5hKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgYSAzeDMgbWF0cml4IHRvIGEgdW5pZm9ybS4gSWYgdGhlcmUncyBubyB1bmlmb3JtIHdpdGggZ2l2ZW4gbmFtZSBpblxyXG4gICAgICogdGhlIHByb2dyYW0sIHNpbGVudGx5IGRvZXMgbm90aGluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdW5pZm9ybU5hbWUgTmFtZSBvZiB0aGUgdW5pZm9ybS5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgbWF0cml4LlxyXG4gICAgICovXHJcbiAgICBzZXRNYXRyaXgzVW5pZm9ybSh1bmlmb3JtTmFtZSwgdmFsdWUpIHtcclxuICAgICAgICBjb25zdCBsb2NhdGlvbiA9IHRoaXMuX2dldFVuaWZvcm1Mb2NhdGlvbih1bmlmb3JtTmFtZSk7XHJcbiAgICAgICAgaWYgKGxvY2F0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsLnVuaWZvcm1NYXRyaXgzZnYobG9jYXRpb24sIGZhbHNlLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIGEgNHg0IG1hdHJpeCB0byBhIHVuaWZvcm0uIElmIHRoZXJlJ3Mgbm8gdW5pZm9ybSB3aXRoIGdpdmVuIG5hbWUgaW5cclxuICAgICAqIHRoZSBwcm9ncmFtLCBzaWxlbnRseSBkb2VzIG5vdGhpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHVuaWZvcm1OYW1lIE5hbWUgb2YgdGhlIHVuaWZvcm0uXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIG1hdHJpeC5cclxuICAgICAqL1xyXG4gICAgc2V0TWF0cml4NFVuaWZvcm0odW5pZm9ybU5hbWUsIHZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgbG9jYXRpb24gPSB0aGlzLl9nZXRVbmlmb3JtTG9jYXRpb24odW5pZm9ybU5hbWUpO1xyXG4gICAgICAgIGlmIChsb2NhdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLl9nbC51bmlmb3JtTWF0cml4NGZ2KGxvY2F0aW9uLCBmYWxzZSwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGVzdHJveXMgdGhlIHByb2dyYW0uXHJcbiAgICAgKi9cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5fZ2wuZGVsZXRlUHJvZ3JhbSh0aGlzLl9oYW5kbGUpO1xyXG4gICAgfVxyXG4gICAgX2dldFVuaWZvcm1Mb2NhdGlvbihuYW1lKSB7XHJcbiAgICAgICAgY29uc3QgY2FjaGUgPSB0aGlzLl91bmlmb3JtQ2FjaGU7XHJcbiAgICAgICAgbGV0IGxvY2F0aW9uID0gY2FjaGUuZ2V0KG5hbWUpO1xyXG4gICAgICAgIGlmICghbG9jYXRpb24pIHtcclxuICAgICAgICAgICAgbG9jYXRpb24gPSB0aGlzLl9nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5faGFuZGxlLCBuYW1lKTtcclxuICAgICAgICAgICAgaWYgKCFsb2NhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETyBVbmNvbW1lbnQgYW5kIHB1dCB1bmRlciBkZWJ1ZyBmbGFnICh3aGVuIGltcGxlbWVudGVkKVxyXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKGBVbmlmb3JtICR7bmFtZX0gZG9lc24ndCBleGlzdCBpbiBwcm9ncmFtLmApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FjaGUuc2V0KG5hbWUsIGxvY2F0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGxvY2F0aW9uO1xyXG4gICAgfVxyXG59XHJcbiIsIi8qKiBXcmFwcGVyIGFyb3VuZCBXZWJHTFJlbmRlcmJ1ZmZlciBvYmplY3RzLiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW5kZXJidWZmZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHJlbmRlcmJ1ZmZlciBpbiBhIFdlYkdMIGNvbnRleHQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGdsIFRoZSBjb250ZXh0IHRoZSByZW5kZXJidWZmZXIgd2lsbCBiZSBjcmVhdGVkIGluLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihnbCwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIHRoaXMuX2dsID0gZ2w7XHJcbiAgICAgICAgdGhpcy5faGFuZGxlID0gZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XHJcbiAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEJpbmRzIHRoZSByZW5kZXJidWZmZXIgdG8gdGhlIFdlYkdMIGNvbnRleHQuXHJcbiAgICAgKi9cclxuICAgIGJpbmQoKSB7XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcclxuICAgICAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgdGhpcy5faGFuZGxlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIHRoZSByZW5kZXJidWZmZXIgaXMgYm91bmQgdG8gdGhlIFdlYkdMIGNvbnRleHQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSByZW5kZXJidWZmZXIgaXMgY3VycmVudGx5IGJvdW5kIHRvIHRoZSBXZWJHTCBjb250ZXh0XHJcbiAgICAgKiAgICAgIGFuZCBgZmFsc2VgIG90aGVyd2lzZS5cclxuICAgICAqL1xyXG4gICAgaXNCb3VuZCgpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xyXG4gICAgICAgIHJldHVybiBnbC5nZXRQYXJhbWV0ZXIoZ2wuUkVOREVSQlVGRkVSX0JJTkRJTkcpID09PSB0aGlzLl9oYW5kbGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEF0dGFjaGVzIHRoZSByZW5kZXJidWZmZXIgdG8gYSBjdXJyZW50bHkgYm91bmQgdG8gdGhlIFdlYkdMIGNvbnRleHRcclxuICAgICAqIGZyYW1lYnVmZmVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhdHRhY2htZW50UG9pbnQgQXR0YWNobWVudCBwb2ludCB0aGUgcmVuZGVyYnVmZmVyIHdpbGwgYmUgYXR0YWNoZWRcclxuICAgICAqICAgICAgdG8uXHJcbiAgICAgKi9cclxuICAgIGF0dGFjaFRvRnJhbWVidWZmZXIoYXR0YWNobWVudFBvaW50KSB7XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcclxuICAgICAgICBnbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgYXR0YWNobWVudFBvaW50LCBnbC5SRU5ERVJCVUZGRVIsIHRoaXMuX2hhbmRsZSk7XHJcbiAgICB9XHJcbiAgICBnZXRXaWR0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fd2lkdGg7XHJcbiAgICB9XHJcbiAgICBnZXRIZWlnaHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlaWdodDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGVzdHJveXMgdGhlIHJlbmRlcmJ1ZmZlci5cclxuICAgICAqL1xyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLl9nbC5kZWxldGVSZW5kZXJidWZmZXIodGhpcy5faGFuZGxlKTtcclxuICAgIH1cclxufVxyXG4iLCIvLyB0c2xpbnQ6ZGlzYWJsZVxyXG4vKlxyXG4gICAgVGhpcyBpcyBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBieSAvdG9vbHMvZ2xfZ2VuL2dlbl9jYXBhYmlsaXRpZXMuanMgc2NyaXB0LlxyXG4gICAgSW5zdGVhZCBvZiBtb2RpZnlpbmcgaXQgZWRpdCB0aGUgc2NyaXB0IGFuZCByZWdlbmVyYXRlIHRoaXMgZmlsZS5cclxuKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVuZGVyQ29udGV4dENhcGFiaWxpdGllc01hbmFnZXIge1xyXG4gICAgY29uc3RydWN0b3IoZ2wpIHtcclxuICAgICAgICB0aGlzLl9nbCA9IGdsO1xyXG4gICAgICAgIHRoaXMuX3BhcmFtVmFsdWVzID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG4gICAgZ2V0QWxpYXNlZExpbmVXaWR0aFJhbmdlKCkgeyByZXR1cm4gdGhpcy5fZ2V0UGFyYW0oMzM5MDIgLyogQUxJQVNFRF9MSU5FX1dJRFRIX1JBTkdFICovKTsgfVxyXG4gICAgZ2V0QWxpYXNlZFBvaW50U2l6ZVJhbmdlKCkgeyByZXR1cm4gdGhpcy5fZ2V0UGFyYW0oMzM5MDEgLyogQUxJQVNFRF9QT0lOVF9TSVpFX1JBTkdFICovKTsgfVxyXG4gICAgZ2V0TWF4Q29tYmluZWRUZXh0dXJlSW1hZ2VVbml0cygpIHsgcmV0dXJuIHRoaXMuX2dldFBhcmFtKDM1NjYxIC8qIE1BWF9DT01CSU5FRF9URVhUVVJFX0lNQUdFX1VOSVRTICovKTsgfVxyXG4gICAgZ2V0TWF4Q3ViZU1hcFRleHR1cmVTaXplKCkgeyByZXR1cm4gdGhpcy5fZ2V0UGFyYW0oMzQwNzYgLyogTUFYX0NVQkVfTUFQX1RFWFRVUkVfU0laRSAqLyk7IH1cclxuICAgIGdldE1heEZyYWdtZW50VW5pZm9ybVZlY3RvcnMoKSB7IHJldHVybiB0aGlzLl9nZXRQYXJhbSgzNjM0OSAvKiBNQVhfRlJBR01FTlRfVU5JRk9STV9WRUNUT1JTICovKTsgfVxyXG4gICAgZ2V0TWF4UmVuZGVyYnVmZmVyU2l6ZSgpIHsgcmV0dXJuIHRoaXMuX2dldFBhcmFtKDM0MDI0IC8qIE1BWF9SRU5ERVJCVUZGRVJfU0laRSAqLyk7IH1cclxuICAgIGdldE1heFRleHR1cmVJbWFnZVVuaXRzKCkgeyByZXR1cm4gdGhpcy5fZ2V0UGFyYW0oMzQ5MzAgLyogTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMgKi8pOyB9XHJcbiAgICBnZXRNYXhUZXh0dXJlU2l6ZSgpIHsgcmV0dXJuIHRoaXMuX2dldFBhcmFtKDMzNzkgLyogTUFYX1RFWFRVUkVfU0laRSAqLyk7IH1cclxuICAgIGdldE1heFZhcnlpbmdWZWN0b3JzKCkgeyByZXR1cm4gdGhpcy5fZ2V0UGFyYW0oMzYzNDggLyogTUFYX1ZBUllJTkdfVkVDVE9SUyAqLyk7IH1cclxuICAgIGdldE1heFZlcnRleEF0dHJpYnMoKSB7IHJldHVybiB0aGlzLl9nZXRQYXJhbSgzNDkyMSAvKiBNQVhfVkVSVEVYX0FUVFJJQlMgKi8pOyB9XHJcbiAgICBnZXRNYXhWZXJ0ZXhUZXh0dXJlSW1hZ2VVbml0cygpIHsgcmV0dXJuIHRoaXMuX2dldFBhcmFtKDM1NjYwIC8qIE1BWF9WRVJURVhfVEVYVFVSRV9JTUFHRV9VTklUUyAqLyk7IH1cclxuICAgIGdldE1heFZlcnRleFVuaWZvcm1WZWN0b3JzKCkgeyByZXR1cm4gdGhpcy5fZ2V0UGFyYW0oMzYzNDcgLyogTUFYX1ZFUlRFWF9VTklGT1JNX1ZFQ1RPUlMgKi8pOyB9XHJcbiAgICBnZXRNYXhWaWV3cG9ydERpbXMoKSB7IHJldHVybiB0aGlzLl9nZXRQYXJhbSgzMzg2IC8qIE1BWF9WSUVXUE9SVF9ESU1TICovKTsgfVxyXG4gICAgZ2V0UmVuZGVyZXIoKSB7IHJldHVybiB0aGlzLl9nZXRQYXJhbSg3OTM3IC8qIFJFTkRFUkVSICovKTsgfVxyXG4gICAgZ2V0U3VicGl4ZWxCaXRzKCkgeyByZXR1cm4gdGhpcy5fZ2V0UGFyYW0oMzQwOCAvKiBTVUJQSVhFTF9CSVRTICovKTsgfVxyXG4gICAgZ2V0VmVuZG9yKCkgeyByZXR1cm4gdGhpcy5fZ2V0UGFyYW0oNzkzNiAvKiBWRU5ET1IgKi8pOyB9XHJcbiAgICBnZXRWZXJzaW9uKCkgeyByZXR1cm4gdGhpcy5fZ2V0UGFyYW0oNzkzOCAvKiBWRVJTSU9OICovKTsgfVxyXG4gICAgLyoqIENhbGxpbmcgdGhpcyBtZXRob2Qgdy9vIGBXRUJHTF9kZWJ1Z19yZW5kZXJlcl9pbmZvYCBlbmFibGVkIHdpbGwgcmV0dXJuIGBudWxsYCEgKi9cclxuICAgIGdldFVubWFza2VkVmVuZG9yKCkgeyByZXR1cm4gdGhpcy5fZ2V0UGFyYW0oMzc0NDUgLyogVU5NQVNLRURfVkVORE9SICovKTsgfVxyXG4gICAgLyoqIENhbGxpbmcgdGhpcyBtZXRob2Qgdy9vIGBXRUJHTF9kZWJ1Z19yZW5kZXJlcl9pbmZvYCBlbmFibGVkIHdpbGwgcmV0dXJuIGBudWxsYCEgKi9cclxuICAgIGdldFVubWFza2VkUmVuZGVyZXIoKSB7IHJldHVybiB0aGlzLl9nZXRQYXJhbSgzNzQ0NiAvKiBVTk1BU0tFRF9SRU5ERVJFUiAqLyk7IH1cclxuICAgIF9nZXRQYXJhbShwYXJhbSkge1xyXG4gICAgICAgIGNvbnN0IHBhcmFtVmFsdWVzID0gdGhpcy5fcGFyYW1WYWx1ZXM7XHJcbiAgICAgICAgbGV0IHBhcmFtVmFsdWUgPSBwYXJhbVZhbHVlcy5nZXQocGFyYW0pO1xyXG4gICAgICAgIGlmICghcGFyYW1WYWx1ZSkge1xyXG4gICAgICAgICAgICBwYXJhbVZhbHVlID0gdGhpcy5fZ2wuZ2V0UGFyYW1ldGVyKHBhcmFtKTtcclxuICAgICAgICAgICAgcGFyYW1WYWx1ZXMuc2V0KHBhcmFtLCBwYXJhbVZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhcmFtVmFsdWU7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0ICogYXMgY29sb3IgZnJvbSAnLi4vdXRpbC9jb2xvcic7XHJcbi8qKlxyXG4gKiBQcmVzZXQgb2YgcmVuZGVyIHN0YXRlIGZvciBPVkVSIGNvbXBvc2l0aW5nLFxyXG4gKiBAc2VlIFQuIFBvcnRlciBhbmQgVC4gRHVmZiwgXCJDb21wb3NpdGluZyBEaWdpdGFsIEltYWdlc1wiLCBQcm9jZWVkaW5ncyBvZlxyXG4gKiAgICAgIFNJR0dSQVBIJzg0LCAxOCAoMTk4NCkuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgQkxFTkRfT1ZFUl9SRU5ERVJfU1RBVEUgPSB7XHJcbiAgICBibGVuZDogdHJ1ZSxcclxuICAgIGJsZW5kRnVuY1NyY1JnYjogNzcwIC8qIFNSQ19BTFBIQSAqLyxcclxuICAgIGJsZW5kRnVuY0RzdFJnYjogNzcxIC8qIE9ORV9NSU5VU19TUkNfQUxQSEEgKi8sXHJcbiAgICBibGVuZEZ1bmNTcmNBbHBoYTogMSAvKiBPTkUgKi8sXHJcbiAgICBibGVuZEZ1bmNEc3RBbHBoYTogNzcxIC8qIE9ORV9NSU5VU19TUkNfQUxQSEEgKi9cclxufTtcclxuZXhwb3J0IGNvbnN0IEJMRU5EX09WRVJfUFJFTVVMVElQTElFRF9BTFBIQV9SRU5ERVJfU1RBVEUgPSB7XHJcbiAgICBibGVuZDogdHJ1ZSxcclxuICAgIGJsZW5kRnVuY1NyY1JnYjogMSAvKiBPTkUgKi8sXHJcbiAgICBibGVuZEZ1bmNEc3RSZ2I6IDc3MSAvKiBPTkVfTUlOVVNfU1JDX0FMUEhBICovLFxyXG4gICAgYmxlbmRGdW5jU3JjQWxwaGE6IDEgLyogT05FICovLFxyXG4gICAgYmxlbmRGdW5jRHN0QWxwaGE6IDc3MSAvKiBPTkVfTUlOVVNfU1JDX0FMUEhBICovXHJcbn07XHJcbi8qKlxyXG4gKiBTdGF0ZSBvZiB0aGUgV2ViR0wgcmVuZGVyaW5nIHBpcGVsaW5lLiBEb2Vzbid0IGluY2x1ZGUgb2JqZWN0IGJpbmRpbmdzIHNpbmNlXHJcbiAqIHRoZSBjb250ZXh0IGhhbmRsZXMgdGhlbS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbmRlclN0YXRlIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyByZW5kZXIgc3RhdGUgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzdGF0ZSBPYmplY3Qgd2l0aCBzdGF0ZSBwcm9wZXJ0aWVzIHRoYXQgdmFsdWVzIGRpZmZlciBmcm9tIGRlZmF1bHRcclxuICAgICAqICAgICAgb25lcy5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoLi4uc3RhdGUpIHtcclxuICAgICAgICB0aGlzLmNsZWFyQ29sb3IgPSBjb2xvci5jcmVhdGUoMCwgMCwgMCwgMCk7XHJcbiAgICAgICAgdGhpcy5jbGVhckRlcHRoID0gMTtcclxuICAgICAgICB0aGlzLmNsZWFyU3RlbmNpbCA9IDA7XHJcbiAgICAgICAgdGhpcy5jb2xvck1hc2tSID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmNvbG9yTWFza0cgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuY29sb3JNYXNrQiA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5jb2xvck1hc2tBbHBoYSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5ibGVuZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuYmxlbmRFcXVhdGlvblJnYiA9IDMyNzc0IC8qIEFERCAqLztcclxuICAgICAgICB0aGlzLmJsZW5kRXF1YXRpb25BbHBoYSA9IDMyNzc0IC8qIEFERCAqLztcclxuICAgICAgICB0aGlzLmJsZW5kRnVuY1NyY1JnYiA9IDEgLyogT05FICovO1xyXG4gICAgICAgIHRoaXMuYmxlbmRGdW5jRHN0UmdiID0gMCAvKiBaRVJPICovO1xyXG4gICAgICAgIHRoaXMuYmxlbmRGdW5jU3JjQWxwaGEgPSAxIC8qIE9ORSAqLztcclxuICAgICAgICB0aGlzLmJsZW5kRnVuY0RzdEFscGhhID0gMCAvKiBaRVJPICovO1xyXG4gICAgICAgIHRoaXMuY3VsbEZhY2UgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmN1bGxGYWNlTW9kZSA9IDEwMjkgLyogQkFDSyAqLztcclxuICAgICAgICB0aGlzLmZyb250RmFjZU1vZGUgPSAyMzA1IC8qIENPVU5URVJDTE9DS1dJU0UgKi87XHJcbiAgICAgICAgdGhpcy5kZXB0aFRlc3QgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmRlcHRoRnVuYyA9IDUxMyAvKiBMRVNTICovO1xyXG4gICAgICAgIHRoaXMuZGVwdGhSYW5nZU5lYXIgPSAwO1xyXG4gICAgICAgIHRoaXMuZGVwdGhSYW5nZUZhciA9IDE7XHJcbiAgICAgICAgdGhpcy5kZXB0aE1hc2sgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuZGl0aGVyID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmRyYXdCdWZmZXJzID0gWzM2MDY0IC8qIENPTE9SX0FUVEFDSE1FTlQwICovXTtcclxuICAgICAgICB0aGlzLnBvbHlnb25PZmZzZXQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnBvbHlnb25PZmZzZXRGYWN0b3IgPSAwO1xyXG4gICAgICAgIHRoaXMucG9seWdvbk9mZnNldFVuaXRzID0gMDtcclxuICAgICAgICB0aGlzLnNhbXBsZUFscGhhVG9Db3ZlcmFnZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuc2FtcGxlQ292ZXJhZ2UgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnNhbXBsZUNvdmVyYWdlVmFsdWUgPSAxO1xyXG4gICAgICAgIHRoaXMuc2FtcGxlQ292ZXJhZ2VJbnZlcnQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnNjaXNzb3JUZXN0ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5zY2lzc29yWCA9IDA7XHJcbiAgICAgICAgdGhpcy5zY2lzc29yWSA9IDA7XHJcbiAgICAgICAgLy8gQWN0dWFsIGRlZmF1bHRzIGFyZW4ndCBrbm93biBoZXJlIHNpbmNlIHRoZXkgZGVwZW5kIHVwb24gY29udGV4dC4gLTEnc1xyXG4gICAgICAgIC8vIGFzIFwiZG8gbm90IGNoYW5nZVwiIHZhbHVlcy5cclxuICAgICAgICB0aGlzLnNjaXNzb3JXaWR0aCA9IC0xO1xyXG4gICAgICAgIHRoaXMuc2Npc3NvckhlaWdodCA9IC0xO1xyXG4gICAgICAgIHRoaXMuc3RlbmNpbFRlc3QgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnN0ZW5jaWxSZWZlcmVuY2UgPSAwO1xyXG4gICAgICAgIHRoaXMuc3RlbmNpbE1hc2sgPSAweGZmO1xyXG4gICAgICAgIHRoaXMuc3RlbmNpbFdyaXRlTWFzayA9IDB4ZmY7XHJcbiAgICAgICAgdGhpcy5zdGVuY2lsRnJvbnRGdW5jID0gNTE5IC8qIEFMV0FZUyAqLztcclxuICAgICAgICB0aGlzLnN0ZW5jaWxGcm9udEZhaWxPcCA9IDc2ODAgLyogS0VFUCAqLztcclxuICAgICAgICB0aGlzLnN0ZW5jaWxGcm9udERlcHRoRmFpbE9wID0gNzY4MCAvKiBLRUVQICovO1xyXG4gICAgICAgIHRoaXMuc3RlbmNpbEZyb250RGVwdGhQYXNzT3AgPSA3NjgwIC8qIEtFRVAgKi87XHJcbiAgICAgICAgdGhpcy5zdGVuY2lsQmFja0Z1bmMgPSA1MTkgLyogQUxXQVlTICovO1xyXG4gICAgICAgIHRoaXMuc3RlbmNpbEJhY2tGYWlsT3AgPSA3NjgwIC8qIEtFRVAgKi87XHJcbiAgICAgICAgdGhpcy5zdGVuY2lsQmFja0RlcHRoRmFpbE9wID0gNzY4MCAvKiBLRUVQICovO1xyXG4gICAgICAgIHRoaXMuc3RlbmNpbEJhY2tEZXB0aFBhc3NPcCA9IDc2ODAgLyogS0VFUCAqLztcclxuICAgICAgICB0aGlzLnZpZXdwb3J0WCA9IDA7XHJcbiAgICAgICAgdGhpcy52aWV3cG9ydFkgPSAwO1xyXG4gICAgICAgIC8vIEFjdHVhbCBkZWZhdWx0cyBhcmVuJ3Qga25vd24gaGVyZSBzaW5jZSB0aGV5IGRlcGVuZCB1cG9uIGNvbnRleHQuIC0xJ3NcclxuICAgICAgICAvLyBhcyBcImRvIG5vdCBjaGFuZ2VcIiB2YWx1ZXMuXHJcbiAgICAgICAgdGhpcy52aWV3cG9ydFdpZHRoID0gLTE7XHJcbiAgICAgICAgdGhpcy52aWV3cG9ydEhlaWdodCA9IC0xO1xyXG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgLi4uc3RhdGUpO1xyXG4gICAgfVxyXG59XHJcbiIsImV4cG9ydCBjb25zdCBPUEFRVUVfQkxBQ0sgPSBjcmVhdGUoMCwgMCwgMCwgMSk7XHJcbmV4cG9ydCBjb25zdCBUUkFOU1BBUkVOVF9CTEFDSyA9IGNyZWF0ZSgwLCAwLCAwLCAwKTtcclxuLyoqXHJcbiAqIEBwYXJhbSByIFJlZCBjb21wb25lbnQgYXMgYSBub3JtYWxpemVkIHZhbHVlIFswLi4xXVxyXG4gKiBAcGFyYW0gZyBHcmVlbiBjb21wb25lbnQgYXMgYSBub3JtYWxpemVkIHZhbHVlIFswLi4xXVxyXG4gKiBAcGFyYW0gYiBCbHVlIGNvbXBvbmVudCBhcyBhIG5vcm1hbGl6ZWQgdmFsdWUgWzAuLjFdXHJcbiAqIEBwYXJhbSBhIEFscGhhIGNvbXBvbmVudCBhcyBhIG5vcm1hbGl6ZWQgdmFsdWUgWzAuLjFdXHJcbiAqXHJcbiAqIEByZXR1cm5zIEEgY29sb3Igd2l0aCBnaXZlbiB2YWx1ZXMgYXNzaWduZWQgdG8gY29tcG9uZW50cy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUociwgZywgYiwgYSA9IDEpIHtcclxuICAgIHJldHVybiB7IHIsIGcsIGIsIGEgfTtcclxufVxyXG4vKipcclxuICogQ29waWVzIGEgY29sb3IgdG8gYW5vdGhlciBvbmUuXHJcbiAqXHJcbiAqIEBwYXJhbSBzcmMgVGhlIHNvdXJjZSBjb2xvci5cclxuICogQHBhcmFtIGRzdCBUaGUgY29sb3IgdGhlIHNvdXJjZSBjb2xvciB3aWxsIGJlIGNvcGllZCB0by5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29weShzcmMsIGRzdCA9IGNyZWF0ZSgwLCAwLCAwLCAwKSkge1xyXG4gICAgZHN0LnIgPSBzcmMucjtcclxuICAgIGRzdC5nID0gc3JjLmc7XHJcbiAgICBkc3QuYiA9IHNyYy5iO1xyXG4gICAgZHN0LmEgPSBzcmMuYTtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGFyZUVxdWFsKGMxLCBjMikge1xyXG4gICAgcmV0dXJuIGMxLnIgPT09IGMyLnIgJiYgYzEuZyA9PT0gYzIuZyAmJiBjMS5iID09PSBjMi5iICYmIGMxLmEgPT09IGMyLmE7XHJcbn1cclxuLyoqXHJcbiAqIERlY29kZXMgYSBjb2xvciByZXByZXNlbnRlZCBhcyBmb3VyIDgtYml0IGNoYW5uZWxzIGVuY29kZWQgaW50byBhIDMyLWJpdFxyXG4gKiBudW1iZXIgaW4gQUJHUiBvcmRlciAoZnJvbSBNU0IgdG8gTFNCKS5cclxuICpcclxuICogQHBhcmFtIGNvbG9yIENvbG9yIGVuY29kZWQgaW50byB1bnNpZ25lZCAzMi1iaXQgaW50ZWdlci5cclxuICogQHJldHVybnMgRGVjb2RlZCBjb2xvci5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVBYmdyOChjb2xvcikge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByOiAoY29sb3IgPj4+IDI0KSAvIDB4ZmYsXHJcbiAgICAgICAgZzogKGNvbG9yID4+PiAxNiAmIDB4ZmYpIC8gMHhmZixcclxuICAgICAgICBiOiAoY29sb3IgPj4+IDggJiAweGZmKSAvIDB4ZmYsXHJcbiAgICAgICAgYTogKGNvbG9yICYgMHhmZikgLyAweGZmXHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBFbmNvZGVzIGEgY29sb3IgY29tcG9uZW50cyBpbnRvIGZvdXIgOCBiaXQgbnVtYmVycyBwYWNrZWQgaW50byAzMi1iaXQgb25lLlxyXG4gKlxyXG4gKiBAcGFyYW0gYyBUaGUgY29sb3IgdG8gYmUgZW5jb2RlZC5cclxuICogQHJldHVybnMgVGhlIGNvbG9yIGFzIDMyLWJpdCBpbnRlZ2VyLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZVJnYmE4KGMpIHtcclxuICAgIHJldHVybiAoYy5yICogMHhmZiB8XHJcbiAgICAgICAgKGMuZyAqIDB4ZmYgPDwgOCkgfFxyXG4gICAgICAgIChjLmIgKiAweGZmIDw8IDE2KSB8XHJcbiAgICAgICAgKGMuYSAqIDB4ZmYgPDwgMjQpKTtcclxufVxyXG4vKipcclxuICogQ2hlY2tzIGlmIGEgY29sb3IgaXMgY29tcGxldGVseSBvcGFxdWUuXHJcbiAqXHJcbiAqIEBwYXJhbSBjb2xvciBUaGUgY29sb3IgdG8gYmUgY2hlY2tlZC5cclxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBjb2xvciBpcyBvcGFxdWUgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzT3BhcXVlKGNvbG9yKSB7XHJcbiAgICByZXR1cm4gY29sb3IuYSA9PT0gMTtcclxufVxyXG4iLCIvKipcclxuICogT3VyIGRlZmF1bHRzIGZvciB0ZXh0dXJlcyBhcmUgZGlmZmVyZW50IGZyb20gb25lcyBpbiBXZWJHTCBmb3IgdHdvIHJlYXNvbnM6XHJcbiAqIDEuIGRlZmF1bHQgbWluaWZpY2F0aW9uIGZpbHRlciBpbiBXZWJHTCBpcyBORUFSRVNUX01JUE1BUF9MSU5FQVIgd2hpY2ggcmVxdWlyZXNcclxuICogICAgdGV4dHVyZSB0byBoYXZlIGFsbCBtaXAgbGV2ZWxzIHNwZWNpZmllZDtcclxuICogMi4gZGVmYXVsdCB3cmFwIG1vZGVzIGFyZSBSRVBFQVQgd2hpY2ggaXNuJ3Qgc3VwcG9ydGVkIGZvciBOUE9UIHRleHR1cmVzLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IERFRkFVTFRfVEVYVFVSRV9QQVJBTVMgPSB7XHJcbiAgICB3cmFwUzogMzMwNzEgLyogQ0xBTVBfVE9fRURHRSAqLyxcclxuICAgIHdyYXBUOiAzMzA3MSAvKiBDTEFNUF9UT19FREdFICovLFxyXG4gICAgbWFnbmlmaWNhdGlvbkZpbHRlcjogOTcyOCAvKiBORUFSRVNUICovLFxyXG4gICAgbWluaWZpY2F0aW9uRmlsdGVyOiA5NzI4IC8qIE5FQVJFU1QgKi8sXHJcbiAgICBwcmVtdWx0aXBsaWVkQWxwaGE6IGZhbHNlXHJcbn07XHJcbi8qKiBXcmFwcGVyIGFyb3VuZCBXZWJHTFRleHR1cmUgb2JqZWN0cy4gRm9yIG5vdyBvbmx5IHdvcmtzIHdpdGggMkQgdGV4dHVyZXMuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRleHR1cmUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHRleHR1cmUgaW4gYSBXZWJHTCBjb250ZXh0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBnbCBUaGUgY29udGV4dCB0aGUgdGV4dHVyZSB3aWxsIGJlIGNyZWF0ZWQgaW4uXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGdsLCB3aWR0aCwgaGVpZ2h0LCBmb3JtYXQsIHR5cGUsIHBhcmFtcyA9IERFRkFVTFRfVEVYVFVSRV9QQVJBTVMpIHtcclxuICAgICAgICB0aGlzLl9nbCA9IGdsO1xyXG4gICAgICAgIHRoaXMuX2Zvcm1hdCA9IGZvcm1hdDtcclxuICAgICAgICB0aGlzLl90eXBlID0gdHlwZTtcclxuICAgICAgICB0aGlzLl9wYXJhbXMgPSBwYXJhbXM7XHJcbiAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5faGFuZGxlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xyXG4gICAgICAgIHRoaXMuYmluZCgpO1xyXG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIHBhcmFtcy53cmFwUyk7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgcGFyYW1zLndyYXBUKTtcclxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgcGFyYW1zLm1hZ25pZmljYXRpb25GaWx0ZXIpO1xyXG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBwYXJhbXMubWluaWZpY2F0aW9uRmlsdGVyKTtcclxuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGZvcm1hdCwgd2lkdGgsIGhlaWdodCwgMCwgZm9ybWF0LCB0eXBlLCBudWxsKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQmluZHMgdGhlIHRleHR1cmUgdG8gdGhlIFdlYkdMIGNvbnRleHQgYXMgYSAyRCB0ZXh0dXJlLlxyXG4gICAgICovXHJcbiAgICBiaW5kKCkge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XHJcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy5faGFuZGxlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIHRoZSB0ZXh0dXJlIGlzIGJvdW5kIHRvIHRoZSBXZWJHTCBjb250ZXh0LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdGV4dHVyZSBpcyBjdXJyZW50bHkgYm91bmQgdG8gdGhlIFdlYkdMIGNvbnRleHRcclxuICAgICAqICAgICAgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxyXG4gICAgICovXHJcbiAgICBpc0JvdW5kKCkge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XHJcbiAgICAgICAgcmV0dXJuIGdsLmdldFBhcmFtZXRlcihnbC5URVhUVVJFX0JJTkRJTkdfMkQpID09PSB0aGlzLl9oYW5kbGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEF0dGFjaGVzIHRoZSB0ZXh0dXJlIHRvIGEgY3VycmVudGx5IGJvdW5kIHRvIHRoZSBXZWJHTCBjb250ZXh0IGZyYW1lYnVmZmVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhdHRhY2htZW50UG9pbnQgQXR0YWNobWVudCBwb2ludCB0aGUgdGV4dHVyZSB3aWxsIGJlIGF0dGFjaGVkIHRvLlxyXG4gICAgICovXHJcbiAgICBhdHRhY2hUb0ZyYW1lYnVmZmVyKGF0dGFjaG1lbnRQb2ludCkge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XHJcbiAgICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGF0dGFjaG1lbnRQb2ludCwgZ2wuVEVYVFVSRV8yRCwgdGhpcy5faGFuZGxlLCAwKTtcclxuICAgIH1cclxuICAgIC8qKiBSZXR1cm5zIHdpZHRoIG9mIHRoZSB0ZXh0dXJlLiAqL1xyXG4gICAgZ2V0V2lkdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dpZHRoO1xyXG4gICAgfVxyXG4gICAgLyoqIFJldHVybnMgaGVpZ2h0IG9mIHRoZSB0ZXh0dXJlLiAqL1xyXG4gICAgZ2V0SGVpZ2h0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XHJcbiAgICB9XHJcbiAgICAvKiogUmV0dXJucyBwaXhlbCBmb3JtYXQgb2YgdGhlIHRleHR1cmUuICovXHJcbiAgICBnZXRGb3JtYXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Zvcm1hdDtcclxuICAgIH1cclxuICAgIC8qKiBSZXR1cm4gcGl4ZWwgdHlwZSBvZiB0aGUgdGV4dHVyZS4gKi9cclxuICAgIGdldFR5cGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGU7XHJcbiAgICB9XHJcbiAgICAvKiogUmV0dXJuIHBhcmFtcyBvZiB0aGUgdGV4dHVyZS4gKi9cclxuICAgIGdldFBhcmFtcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcGFyYW1zO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXN0cm95cyB0aGUgdGV4dHVyZS5cclxuICAgICAqL1xyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLl9nbC5kZWxldGVUZXh0dXJlKHRoaXMuX2hhbmRsZSk7XHJcbiAgICB9XHJcbn1cclxuIiwiLyoqXHJcbiAqIFdyYXBwZXIgYXJvdW5kIHZlcnRleCBhcnJheSAoVkFPKSBvYmplY3QgZnJvbSBgT0VTX3ZlcnRleF9hcnJheV9vYmplY3RgXHJcbiAqIGV4dGVuc2lvbi5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZlcnRleEFycmF5T2JqZWN0IHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBuZXcgVkFPIGluIGEgZ2l2ZW4gV2ViR0wgY29udGV4dC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZ2wgVGhlIGNvbnRleHQuXHJcbiAgICAgKiBAcGFyYW0gdmFvRXh0IEluc3RhbmNlIG9mIGBPRVNfdmVydGV4X2FycmF5X29iamVjdGAgZXh0ZW5zaW9uLlxyXG4gICAgICogQHBhcmFtIGF0dHJpYnV0ZU1hcHBpbmcgTWFwcGluZyBvZiBhdHRyaWJ1dGVzLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihnbCwgdmFvRXh0LCBhdHRyaWJ1dGVNYXBwaW5nKSB7XHJcbiAgICAgICAgdGhpcy5fZ2wgPSBnbDtcclxuICAgICAgICB0aGlzLl92YW9FeHQgPSB2YW9FeHQ7XHJcbiAgICAgICAgdGhpcy5faGFuZGxlID0gdmFvRXh0LmNyZWF0ZVZlcnRleEFycmF5T0VTKCk7XHJcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVNYXBwaW5nID0gYXR0cmlidXRlTWFwcGluZztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQmluZHMgdGhlIFZBTyB0byB0aGUgY29udGV4dC5cclxuICAgICAqL1xyXG4gICAgYmluZCgpIHtcclxuICAgICAgICB0aGlzLl92YW9FeHQuYmluZFZlcnRleEFycmF5T0VTKHRoaXMuX2hhbmRsZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyBpZiB0aGUgVkFPIGlzIGN1cnJlbnRseSBib3VuZCB0byB0aGUgY29udGV4dC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIFZBTyBpcyBjdXJyZW50bHkgYm91bmQgdG8gdGhlIFdlYkdMIGNvbnRleHQgYW5kXHJcbiAgICAgKiAgICAgIGBmYWxzZWAgb3RoZXJ3aXNlLlxyXG4gICAgICovXHJcbiAgICBpc0JvdW5kKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9nbC5nZXRQYXJhbWV0ZXIodGhpcy5fdmFvRXh0LlZFUlRFWF9BUlJBWV9CSU5ESU5HX09FUykgPT09XHJcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGVzdHJveXMgdGhlIFZBTy5cclxuICAgICAqL1xyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLl92YW9FeHQuZGVsZXRlVmVydGV4QXJyYXlPRVModGhpcy5faGFuZGxlKTtcclxuICAgIH1cclxufVxyXG4iLCIvKipcclxuICogU2ltcGxlIHB1Yi9zdWIgaW1wbGVtZW50YXRpb24uIFRoZSBlbWl0dGVyIGlzIHN1cHBvc2VkIHRvIGVtaXQgb25seSBvbmUgdHlwZSBvZiBldmVudCxcclxuICogaWYgc29tZW9uZSBoYXMgdG8gZW1pdCBldmVudHMgb2YgZGlmZmVyZW50IHR5cGVzLCBtdWx0aXBsZSBlbWl0dGVycyBzaG91bGQgYmUgY3JlYXRlZC5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBFdmVudEVtaXR0ZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gbmV3IFNldCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGxpc3RlbmVyLlxyXG4gICAgICovXHJcbiAgICBhZGRMaXN0ZW5lcihsaXN0ZW5lcikge1xyXG4gICAgICAgIHRoaXMuX2xpc3RlbmVycy5hZGQobGlzdGVuZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGxpc3RlbmVyLlxyXG4gICAgICovXHJcbiAgICByZW1vdmVMaXN0ZW5lcihsaXN0ZW5lcikge1xyXG4gICAgICAgIHRoaXMuX2xpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxscyBhbGwgdGhlIGFkZGVkIGxpc3RlbmVycywgdGhlIG9yZGVyIChlLmcuIG9mIGFkZGluZykgaXMgbm90IGd1YXJhbnRlZWQuXHJcbiAgICAgKi9cclxuICAgIGZpcmUoZGF0YSkge1xyXG4gICAgICAgIHRoaXMuX2xpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lcikgPT4ge1xyXG4gICAgICAgICAgICBsaXN0ZW5lcihkYXRhKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogRXZlbnQgZW1pdHRlciB3aXRoIG5vIHBheWxvYWQgZW1pdHRlZC5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBWb2lkRXZlbnRFbWl0dGVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcclxuICAgIGZpcmUoKSB7XHJcbiAgICAgICAgc3VwZXIuZmlyZSh1bmRlZmluZWQpO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IGNsYW1wLCBjeWNsZVJlc3RyaWN0IH0gZnJvbSAnLi9tYXRoL3NjYWxhcic7XHJcbmltcG9ydCB7IGRlZzJyYWQgfSBmcm9tICcuL3V0aWwvcmFkX2RlZyc7XHJcbmltcG9ydCBnZXRGdWxsT3B0aW9ucyBmcm9tICcuL3V0aWwvb3B0aW9ucyc7XHJcbmltcG9ydCAqIGFzIG1hdDQgZnJvbSAnLi9tYXRoL21hdHJpeDQnO1xyXG5pbXBvcnQgeyBzbW9vdGhTdGVwIH0gZnJvbSAnLi9tYXRoL3NjYWxhcic7XHJcbmltcG9ydCAqIGFzIHZlYzIgZnJvbSAnLi9tYXRoL3ZlY3RvcjInO1xyXG5pbXBvcnQgKiBhcyB2ZWMzIGZyb20gJy4vbWF0aC92ZWN0b3IzJztcclxuaW1wb3J0IHsgVm9pZEV2ZW50RW1pdHRlciB9IGZyb20gJy4vdXRpbC9ldmVudF9lbWl0dGVyJztcclxuLy8gVE9ETyhkbWlraXMpIFdlIHdhbnQgdG8gY29uc3RyYWludCBjb29yZGluYXRlcyBzbyB2aXNpYmxlIHJlZ2lvbiBkb2Vzbid0IGV4dGVuZFxyXG4vLyAgICAgIG91dCBvZiB3b3JsZCBib3VuZGFyaWVzLiBIb3dldmVyLCBpbiBjdXJyZW50IGltcGxlbWVudGF0aW9uIGl0IGRvZXNuJ3RcclxuLy8gICAgICB3b3JrIHByb3Blcmx5IGZvciBhc3BlY3QgcmF0aW9zID4xIG9uIHpvb20gMCBzaW5jZSB2aXNpYmxlIHJlZ2lvbiBpc1xyXG4vLyAgICAgIGxhcmdlciB0aGF0IHRoZSB3b3JsZCBpdHNlbGYgKHNvIHRoZXJlJ3Mgbm8gd2F5IHRvIHNxdWVlemUgaXQgaW4pLiBGb3JcclxuLy8gICAgICB0aGUgY3VycmVudCBjYXNlIChpLmUuIGN5Y2xlZCBpbiBob3Jpem9udGFsIGRpcmVjdGlvbikgaXQgaXMgbm90IGEgcHJvYmxlbS5cclxuY29uc3QgTUFYX1RJTFQgPSBkZWcycmFkKDQwKTtcclxuLyoqXHJcbiAqIElmIGEgY2FtZXJhIGhhcyB6b29tIGxlc3MgdGhhbiBvZiBlcXVhbCB0byBgTk9fVElMVF9NQVhfWk9PTWAsIHRpbHQgd29uJ3QgYmVcclxuICogYWxsb3dlZC5cclxuICovXHJcbmNvbnN0IE5PX1RJTFRfTUFYX1pPT00gPSAxO1xyXG4vKipcclxuICogSWYgYSBjYW1lcmEgaGFzIHpvb20gZ3JlYXRlciB0aGFuIG9mIGVxdWFsIHRvIGBGVUxMX1RJTFRfTUlOX1pPT01gLCB0aWx0IHdpbGxcclxuICogYmUgYWxsb3dlZCB1cCB0byBgTUFYX1RJTFRgLlxyXG4gKi9cclxuY29uc3QgRlVMTF9USUxUX01JTl9aT09NID0gTk9fVElMVF9NQVhfWk9PTSArIDE7XHJcbmNvbnN0IEZSVVNUVU1fRElSRUNUSU9OUyA9IFtcclxuICAgIC8vIHRzbGludDpkaXNhYmxlXHJcbiAgICB2ZWMzLmNyZWF0ZSgtMSwgMSwgLTEpLFxyXG4gICAgdmVjMy5jcmVhdGUoMSwgMSwgLTEpLFxyXG4gICAgdmVjMy5jcmVhdGUoMSwgLTEsIC0xKSxcclxuICAgIHZlYzMuY3JlYXRlKC0xLCAtMSwgLTEpXHJcbiAgICAvLyB0c2xpbnQ6ZW5hYmxlXHJcbl07XHJcbi8qKlxyXG4gKiBIb3cgYmlnIHRoZSB3b3JsZCBzb3VsZCBiZSBvbiBhIHNjcmVlbiBpZiB6b29tIGlzIDAsIGluIGRldmljZSBpbmRlcGVuZGVudCBwaXhlbHNcclxuICovXHJcbmNvbnN0IFpPT01fMF9XT1JMRF9DU1NfUElYRUxfU0laRSA9IDI1NjtcclxuY29uc3QgREVGQVVMVF9PUFRJT05TID0ge1xyXG4gICAgd3JhcE1vZGVYOiAxIC8qIENMQU1QX1RPX0VER0UgKi8sXHJcbiAgICB3cmFwTW9kZVk6IDEgLyogQ0xBTVBfVE9fRURHRSAqLyxcclxuICAgIG1pblpvb206IDAsXHJcbiAgICBtYXhab29tOiAyNCxcclxuICAgIGZvdjogZGVnMnJhZCgzMClcclxufTtcclxuLyoqXHJcbiAqIFJlc3RyaWN0cyBhIG5ldyB2YWx1ZSBmb3IgYSBjZW50ZXIncyBjb29yZGluYXRlIGFjY29yZGluZyB0byBnaXZlbiB3cmFwIG1vZGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB3cmFwTW9kZSBUaGUgd3JhcCBtb2RlLlxyXG4gKiBAcGFyYW0gbmV3Q29vcmRpbmF0ZSBUaGUgbmV3IHZhbHVlLlxyXG4gKiBAcGFyYW0gb2xkQ29vcmRpbmF0ZSBDdXJyZW50IHZhbHVlIG9mIHRoZSBjb29yZGluYXRlLlxyXG4gKiBAcGFyYW0gYmJveE1pbiBNaW5pbXVtIGNvcnJlc3BvbmRpbmcgY29vcmRpbmF0ZSBvZiBib3VuZGluZyBib3ggb2YgdGhlXHJcbiAqICAgICAgdmlzaWJsZSBxdWFkcmlsYXRlcmFsLlxyXG4gKiBAcGFyYW0gYmJveE1heCBNYXhpbXVtIGNvcnJlc3BvbmRpbmcgY29vcmRpbmF0ZSBvZiBib3VuZGluZyBib3ggb2YgdGhlXHJcbiAqICAgICAgdmlzaWJsZSBxdWFkcmlsYXRlcmFsLlxyXG4gKiBAcmV0dXJucyBSZXN0cmljdGVkIHZhbHVlIGZvciB0aGUgY29vcmRpbmF0ZS5cclxuICovXHJcbmZ1bmN0aW9uIHJlc3RyaWN0Q29vcmRpbmF0ZSh3cmFwTW9kZSwgbmV3Q29vcmRpbmF0ZSkge1xyXG4gICAgc3dpdGNoICh3cmFwTW9kZSkge1xyXG4gICAgICAgIGNhc2UgMCAvKiBOT05FICovOlxyXG4gICAgICAgICAgICByZXR1cm4gbmV3Q29vcmRpbmF0ZTtcclxuICAgICAgICBjYXNlIDEgLyogQ0xBTVBfVE9fRURHRSAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIGNsYW1wKG5ld0Nvb3JkaW5hdGUsIC0xLCAxKTtcclxuICAgICAgICBjYXNlIDIgLyogUkVQRUFUICovOlxyXG4gICAgICAgICAgICByZXR1cm4gY3ljbGVSZXN0cmljdChuZXdDb29yZGluYXRlLCAtMSwgMSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENhbWVyYSByZXByZXNlbnRzIHVzZXIncyBwb2ludCBvZiB2aWV3IGluIHRoZSB3b3JsZCBzcGFjZSwgYXMgYSByZWFsIGNhbWVyYSBpdCBoYXMgcmVzdHJpY3RlZCBmaWVsZCBvZiB2aWV3LFxyXG4gKiBpdCBjYW4gbW92ZSBhbmQgcm90YXRlICh3aXRoIG9yIHdpdGhvdXQgYW5pbWF0aW9uKS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENhbWVyYSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgY2FtZXJhLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBnZXRGdWxsT3B0aW9ucyhERUZBVUxUX09QVElPTlMsIG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuY2VudGVyID0gbmV3IENhbWVyYS5fQ2VudGVyKHRoaXMpO1xyXG4gICAgICAgIHRoaXMub25VcGRhdGUgPSBuZXcgVm9pZEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIGNvbnN0IHNjcmVlblNpemUgPSBuZXcgQ2FtZXJhLl9TY3JlZW5TaXplKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuc2NyZWVuU2l6ZSA9IHNjcmVlblNpemU7XHJcbiAgICAgICAgdGhpcy5fZGlzdGFuY2VUb0NlbnRlciA9IDE7XHJcbiAgICAgICAgdGhpcy5fem9vbSA9IHRoaXMub3B0aW9ucy5taW5ab29tO1xyXG4gICAgICAgIHRoaXMuX3RpbHQgPSB0aGlzLl9hemltdXRoID0gMDtcclxuICAgICAgICB0aGlzLl9kaXJ0eUJpdHMgPSAtMSAvKiBBTEwgKi87XHJcbiAgICAgICAgdGhpcy5fdmlld1Byb2pNYXRyaXggPSBtYXQ0LmNvcHkobWF0NC5JREVOVElUWSk7XHJcbiAgICAgICAgdGhpcy5fdmlzaWJsZVF1YWRyaWxhdGVyYWwgPSBbXHJcbiAgICAgICAgICAgIHZlYzMuY3JlYXRlKDAsIDAsIDApLFxyXG4gICAgICAgICAgICB2ZWMzLmNyZWF0ZSgwLCAwLCAwKSxcclxuICAgICAgICAgICAgdmVjMy5jcmVhdGUoMCwgMCwgMCksXHJcbiAgICAgICAgICAgIHZlYzMuY3JlYXRlKDAsIDAsIDApXHJcbiAgICAgICAgXTtcclxuICAgICAgICB0aGlzLl92aXNpYmxlUXVhZHJpbGF0ZXJhbEJCb3ggPVxyXG4gICAgICAgICAgICB2ZWMyLmNvbXB1dGVCQm94Rm9yUG9pbnRzKHRoaXMuX3Zpc2libGVRdWFkcmlsYXRlcmFsKTtcclxuICAgICAgICB0aGlzLl9waXhlbFNpemUgPSB2ZWMyLmNyZWF0ZSgwLCAwKTtcclxuICAgIH1cclxuICAgIGdldCBhc3BlY3RSYXRpbygpIHtcclxuICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHRoaXMuc2NyZWVuU2l6ZTtcclxuICAgICAgICBpZiAoaGVpZ2h0ICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB3aWR0aCAvIGhlaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHdoZW4gaGVpZ2h0ID09IDAgd2UgY2Fubm90IGNvbXB1dGUgdmlld1Byb2ogbWF0cml4IG9yIHZpc2libGUgcmVnaW9uLCAxIGFsbG93cyB0byBoYW5kbGUgdGhpcyBjYXNlIHdpdGhcclxuICAgICAgICAgICAgLy8gbm8gZXhjZXB0aW9ucyB0aHJvd24sIGJ1dCB0ZWNobmljYWxseSBpdCBpcyBub3QgY29ycmVjdCBhbmQgc2hvdWxkIGJlIHJlY29uc2lkZXJlZCBpZiBhbnkgaXNzdWUgaXMgZm91bmRcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0IHpvb20oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3pvb207XHJcbiAgICB9XHJcbiAgICBnZXQgd29ybGRUb1B4RmFjdG9yKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl93b3JsZFRvUHhGYWN0b3I7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgbmV3IHpvb20gdG8gdGhlIGNhbWVyYSB3aXRoIHJlc3BlY3QgdG8gcHJvdmlkZWQgbGltaXRzIGluIHRoZSBvcHRpb25zLlxyXG4gICAgICovXHJcbiAgICBzZXQgem9vbShuZXdab29tKSB7XHJcbiAgICAgICAgbmV3Wm9vbSA9IGNsYW1wKG5ld1pvb20sIHRoaXMub3B0aW9ucy5taW5ab29tLCB0aGlzLm9wdGlvbnMubWF4Wm9vbSk7XHJcbiAgICAgICAgaWYgKG5ld1pvb20gIT09IHRoaXMuX3pvb20pIHtcclxuICAgICAgICAgICAgdGhpcy5fem9vbSA9IG5ld1pvb207XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbXB1dGVEaXN0YW5jZVRvQ2VudGVyKCk7XHJcbiAgICAgICAgICAgIC8vIENvbnN0cmFpbnRzIG9uIHRpbHQgbWF5IGhhdmUgY2hhbmdlZCwgd2UgbmVlZCB0byByZWNvbXB1dGUgaXQuXHJcbiAgICAgICAgICAgIHRoaXMuX3RpbHQgPSB0aGlzLl9jb25zdHJhaW5UaWx0KHRoaXMuX3RpbHQpO1xyXG4gICAgICAgICAgICB0aGlzLl93b3JsZFRvUHhGYWN0b3IgPSAyLjAgLyAoWk9PTV8wX1dPUkxEX0NTU19QSVhFTF9TSVpFICogTWF0aC5wb3coMiwgbmV3Wm9vbSkpO1xyXG4gICAgICAgICAgICB0aGlzLl9zZXREaXJ0eUJpdHMoMSAvKiBWSUVXX1BST0pfTUFUUklYICovIHwgMiAvKiBWSVNJQkxFX1FVQURSSUxBVEVSQUwgKi8pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCB0aWx0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90aWx0O1xyXG4gICAgfVxyXG4gICAgc2V0IHRpbHQobmV3VGlsdCkge1xyXG4gICAgICAgIG5ld1RpbHQgPSB0aGlzLl9jb25zdHJhaW5UaWx0KG5ld1RpbHQpO1xyXG4gICAgICAgIGlmICh0aGlzLl90aWx0ICE9PSBuZXdUaWx0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RpbHQgPSBuZXdUaWx0O1xyXG4gICAgICAgICAgICB0aGlzLl9zZXREaXJ0eUJpdHMoMSAvKiBWSUVXX1BST0pfTUFUUklYICovIHwgMiAvKiBWSVNJQkxFX1FVQURSSUxBVEVSQUwgKi8pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCBhemltdXRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hemltdXRoO1xyXG4gICAgfVxyXG4gICAgc2V0IGF6aW11dGgobmV3QXppbXV0aCkge1xyXG4gICAgICAgIG5ld0F6aW11dGggPSBjeWNsZVJlc3RyaWN0KG5ld0F6aW11dGgsIDAsIDIgKiBNYXRoLlBJKTtcclxuICAgICAgICBpZiAodGhpcy5fYXppbXV0aCAhPT0gbmV3QXppbXV0aCkge1xyXG4gICAgICAgICAgICB0aGlzLl9hemltdXRoID0gbmV3QXppbXV0aDtcclxuICAgICAgICAgICAgdGhpcy5fc2V0RGlydHlCaXRzKDEgLyogVklFV19QUk9KX01BVFJJWCAqLyB8IDIgLyogVklTSUJMRV9RVUFEUklMQVRFUkFMICovKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNpemUgb2YgYSBwaXhlbCBpbiBOREMuXHJcbiAgICAgKi9cclxuICAgIGdldCBwaXhlbFNpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BpeGVsU2l6ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSW52YWxpZGF0ZSBhbGwgaW50ZXJuYWxseSBjYWNoZWQgdmFsdWVzIChlLmcuIHZpZXcgbWF0cml4KS5cclxuICAgICAqL1xyXG4gICAgc2V0RGlydHkoKSB7XHJcbiAgICAgICAgdGhpcy5fc2V0RGlydHlCaXRzKC0xIC8qIEFMTCAqLyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlY29tcHV0ZXMgKGlmIG5lZWRlZCkgdGhlIHZpZXcgcHJvamVjdGlvbiBtYXRyaXguXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVGhlIHZpZXctcHJvamVjdGlvbiBtYXRyaXguXHJcbiAgICAgKi9cclxuICAgIGdldFZpZXdQcm9qTWF0cml4KCkge1xyXG4gICAgICAgIGNvbnN0IHZpZXdQcm9qTWF0cml4ID0gdGhpcy5fdmlld1Byb2pNYXRyaXg7XHJcbiAgICAgICAgaWYgKHRoaXMuX2RpcnR5Qml0cyAmIDEgLyogVklFV19QUk9KX01BVFJJWCAqLykge1xyXG4gICAgICAgICAgICBtYXQ0LmNvcHkobWF0NC5JREVOVElUWSwgdmlld1Byb2pNYXRyaXgpO1xyXG4gICAgICAgICAgICBtYXQ0Lmxvb2tBdCh2aWV3UHJvak1hdHJpeCwgdGhpcy5fY29tcHV0ZUNlbnRlclRvQ2FtZXJhVmVjdG9yKCksIHZlYzMuT1JJR0lOLCB2ZWMzLnJvdGF0ZVoodmVjMy5QT1NJVElWRV9ZLCB0aGlzLl9hemltdXRoKSwgdmlld1Byb2pNYXRyaXgpO1xyXG4gICAgICAgICAgICBjb25zdCB7IGZvdiB9ID0gdGhpcy5vcHRpb25zO1xyXG4gICAgICAgICAgICBjb25zdCB0YW5GYWN0b3JzID0gTWF0aC50YW4odGhpcy5fdGlsdCkgKiBNYXRoLnRhbigwLjUgKiBmb3YpO1xyXG4gICAgICAgICAgICBtYXQ0LnBlcnNwZWN0aXZlKHZpZXdQcm9qTWF0cml4LCBmb3YsIHRoaXMuYXNwZWN0UmF0aW8sIE1hdGgubWluKHRoaXMuX2Rpc3RhbmNlVG9DZW50ZXIgKiAwLjAxLCB0aGlzLl9kaXN0YW5jZVRvQ2VudGVyIC8gKDEgKyB0YW5GYWN0b3JzKSksIHRoaXMuX2Rpc3RhbmNlVG9DZW50ZXIgLyAoMSAtIHRhbkZhY3RvcnMpLCB2aWV3UHJvak1hdHJpeCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2RpcnR5Qml0cyAmPSB+MSAvKiBWSUVXX1BST0pfTUFUUklYICovO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmlld1Byb2pNYXRyaXg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlY29tcHV0ZXMgKGlmIG5lZWRlZCkgYW5kIHJldHVybnMgcXVhZHJpbGF0ZXJhbCBjdXQgb24gdGhlIHdvcmxkIHBsYW5lXHJcbiAgICAgKiBieSBmcnVzdHVtIG9mIHRoZSBjYW1lcmEuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiBUaGUgcXVhZHJpbGF0ZXJhbCBlbmNsb3NpbmcgdmlzaWJsZSBwYXJ0IG9mIHRoZSB3b3JsZCBwbGFuZS5cclxuICAgICAqL1xyXG4gICAgZ2V0VmlzaWJsZVJlZ2lvbigpIHtcclxuICAgICAgICB0aGlzLl9jb21wdXRlVmlzaWJsZVF1YWRyaWxhdGVyYWwoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaWJsZVF1YWRyaWxhdGVyYWw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlY29tcHV0ZXMgKGlmIG5lZWRlZCkgYW5kIHJldHVybnMgYm91bmRpbmcgYm94IG9mIHRoZSB2aXNpYmxlIHJlZ2lvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIEJvdW5kaW5nIGJveCBvZiB0aGUgdmlzaWJsZSBxdWFkcmlsYXRlcmFsLlxyXG4gICAgICovXHJcbiAgICBnZXRWaXNpYmxlUmVnaW9uQkJveCgpIHtcclxuICAgICAgICB0aGlzLl9jb21wdXRlVmlzaWJsZVF1YWRyaWxhdGVyYWwoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaWJsZVF1YWRyaWxhdGVyYWxCQm94O1xyXG4gICAgfVxyXG4gICAgX2NvbnN0cmFpblRpbHQodGlsdCkge1xyXG4gICAgICAgIHJldHVybiBjbGFtcCh0aWx0LCAwLCBNQVhfVElMVCAqIHNtb290aFN0ZXAoTk9fVElMVF9NQVhfWk9PTSwgRlVMTF9USUxUX01JTl9aT09NLCB0aGlzLl96b29tKSk7XHJcbiAgICB9XHJcbiAgICBfc2V0RGlydHlCaXRzKGJpdHMpIHtcclxuICAgICAgICBpZiAoYml0cyBeIChiaXRzICYgdGhpcy5fZGlydHlCaXRzKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9kaXJ0eUJpdHMgfD0gYml0cztcclxuICAgICAgICAgICAgdGhpcy5vblVwZGF0ZS5maXJlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2NvbXB1dGVEaXN0YW5jZVRvQ2VudGVyKCkge1xyXG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlVG9DZW50ZXIgPVxyXG4gICAgICAgICAgICB0aGlzLnNjcmVlblNpemUuaGVpZ2h0ICogTWF0aC5wb3coMiwgLXRoaXMuX3pvb20pIC9cclxuICAgICAgICAgICAgICAgIChNYXRoLnRhbigwLjUgKiB0aGlzLm9wdGlvbnMuZm92KSAqIFpPT01fMF9XT1JMRF9DU1NfUElYRUxfU0laRSk7XHJcbiAgICB9XHJcbiAgICBfY29tcHV0ZUNlbnRlclRvQ2FtZXJhVmVjdG9yKGRzdCA9IHZlYzMuY3JlYXRlKDAsIDAsIDApKSB7XHJcbiAgICAgICAgdmVjMy5tdWxuKHZlYzMuUE9TSVRJVkVfWiwgdGhpcy5fZGlzdGFuY2VUb0NlbnRlciwgZHN0KTtcclxuICAgICAgICB2ZWMzLnJvdGF0ZVgoZHN0LCB0aGlzLl90aWx0LCBkc3QpO1xyXG4gICAgICAgIHZlYzMucm90YXRlWihkc3QsIHRoaXMuX2F6aW11dGgsIGRzdCk7XHJcbiAgICAgICAgcmV0dXJuIGRzdDtcclxuICAgIH1cclxuICAgIF9jb21wdXRlVmlzaWJsZVF1YWRyaWxhdGVyYWwoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2RpcnR5Qml0cyAmIDIgLyogVklTSUJMRV9RVUFEUklMQVRFUkFMICovKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZpc2libGVRdWFkcmlsYXRlcmFsID0gdGhpcy5fdmlzaWJsZVF1YWRyaWxhdGVyYWw7XHJcbiAgICAgICAgICAgIGNvbnN0IGhhbGZGb3ZUYW4gPSBNYXRoLnRhbigwLjUgKiB0aGlzLm9wdGlvbnMuZm92KTtcclxuICAgICAgICAgICAgY29uc3Qgb3JpZ2luID0gdGhpcy5fY29tcHV0ZUNlbnRlclRvQ2FtZXJhVmVjdG9yKCk7XHJcbiAgICAgICAgICAgIHZlYzIuYWRkKG9yaWdpbiwgdGhpcy5jZW50ZXIsIG9yaWdpbik7XHJcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlID0gdmVjMy5jcmVhdGUoaGFsZkZvdlRhbiAqIHRoaXMuYXNwZWN0UmF0aW8sIGhhbGZGb3ZUYW4sIDEpO1xyXG4gICAgICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSB2ZWMzLmNyZWF0ZSgwLCAwLCAwKTtcclxuICAgICAgICAgICAgY29uc3QgcmF5ID0geyBvcmlnaW4sIGRpcmVjdGlvbiB9O1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgdmVjMy5tdWx2KEZSVVNUVU1fRElSRUNUSU9OU1tpXSwgc2NhbGUsIGRpcmVjdGlvbik7XHJcbiAgICAgICAgICAgICAgICB2ZWMzLnJvdGF0ZVgoZGlyZWN0aW9uLCB0aGlzLl90aWx0LCBkaXJlY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgdmVjMy5yb3RhdGVaKGRpcmVjdGlvbiwgdGhpcy5fYXppbXV0aCwgZGlyZWN0aW9uKTtcclxuICAgICAgICAgICAgICAgIGlmICghdmVjMy5nZXRQbGFuZVJheUludGVyc2VjdGlvbih2ZWMzLlhZLCByYXksIHZpc2libGVRdWFkcmlsYXRlcmFsW2ldKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVmlzaWJsZSBxdWFkcmlsYXRlcmFsIGlzIHVuYm91bmRlZCwgZW5naW5lIGNhblxcJ3QgaGFuZGxlIHRoYXQgY2FzZSAoeWV0KScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZlYzIuY29tcHV0ZUJCb3hGb3JQb2ludHModmlzaWJsZVF1YWRyaWxhdGVyYWwsIHRoaXMuX3Zpc2libGVRdWFkcmlsYXRlcmFsQkJveCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2RpcnR5Qml0cyAmPSB+MiAvKiBWSVNJQkxFX1FVQURSSUxBVEVSQUwgKi87XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiBhIGNlbnRlciB2ZWN0b3Igb2YgYSBjYW1lcmEuIFRha2VzIGludG8gYWNjb3VudCB3cmFwcGluZ1xyXG4gKiBtb2RlcyBhbmQgdXBkYXRlcyBjYW1lcmEncyBkaXJ0eSBmbGFncy5cclxuICovXHJcbkNhbWVyYS5fQ2VudGVyID0gY2xhc3Mge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIG5ldyBjZW50ZXIgdmVjdG9yIGZvciBhIGNhbWVyYS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY2FtZXJhIFRoZSBjYW1lcmEuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGNhbWVyYSkge1xyXG4gICAgICAgIHRoaXMuX2NhbWVyYSA9IGNhbWVyYTtcclxuICAgICAgICB0aGlzLl94ID0gdGhpcy5feSA9IDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFZhbHVlcyBvZiBhYnNjaXNzYSBvZiB0aGUgY2VudGVyIHZlY3Rvci5cclxuICAgICAqL1xyXG4gICAgZ2V0IHgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3g7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFByb3Blcmx5IGNsYW1wcyBvciB3cmFwcyBuZXcgYWJzY2lzc2EgdmFsdWUgYW5kIHNldHMgaXQgdG8gdGhlIHZlY3Rvci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbmV3WCBUaGUgbmV3XHJcbiAgICAgKi9cclxuICAgIHNldCB4KG5ld1gpIHtcclxuICAgICAgICBjb25zdCBjYW1lcmEgPSB0aGlzLl9jYW1lcmE7XHJcbiAgICAgICAgbmV3WCA9IHJlc3RyaWN0Q29vcmRpbmF0ZShjYW1lcmEub3B0aW9ucy53cmFwTW9kZVgsIG5ld1gpO1xyXG4gICAgICAgIGlmICh0aGlzLl94ICE9PSBuZXdYKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3ggPSBuZXdYO1xyXG4gICAgICAgICAgICBjYW1lcmEuX3NldERpcnR5Qml0cygyIC8qIFZJU0lCTEVfUVVBRFJJTEFURVJBTCAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBWYWx1ZXMgb2Ygb3JkaW5hdGUgb2YgdGhlIGNlbnRlciB2ZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIGdldCB5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl95O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQcm9wZXJseSBjbGFtcHMgb3Igd3JhcHMgbmV3IG9yZGluYXRlIHZhbHVlIGFuZCBzZXRzIGl0IHRvIHRoZSB2ZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIHNldCB5KG5ld1kpIHtcclxuICAgICAgICBjb25zdCBjYW1lcmEgPSB0aGlzLl9jYW1lcmE7XHJcbiAgICAgICAgbmV3WSA9IHJlc3RyaWN0Q29vcmRpbmF0ZShjYW1lcmEub3B0aW9ucy53cmFwTW9kZVksIG5ld1kpO1xyXG4gICAgICAgIGlmICh0aGlzLl95ICE9PSBuZXdZKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3kgPSBuZXdZO1xyXG4gICAgICAgICAgICBjYW1lcmEuX3NldERpcnR5Qml0cygyIC8qIFZJU0lCTEVfUVVBRFJJTEFURVJBTCAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5DYW1lcmEuX1NjcmVlblNpemUgPSBjbGFzcyB7XHJcbiAgICBjb25zdHJ1Y3RvcihjYW1lcmEpIHtcclxuICAgICAgICB0aGlzLl9jYW1lcmEgPSBjYW1lcmE7XHJcbiAgICAgICAgdGhpcy5fd2lkdGggPSB0aGlzLl9oZWlnaHQgPSAwO1xyXG4gICAgfVxyXG4gICAgZ2V0IHdpZHRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl93aWR0aDtcclxuICAgIH1cclxuICAgIHNldCB3aWR0aChuZXdXaWR0aCkge1xyXG4gICAgICAgIGlmICh0aGlzLl93aWR0aCAhPT0gbmV3V2lkdGgpIHtcclxuICAgICAgICAgICAgdGhpcy5fd2lkdGggPSBuZXdXaWR0aDtcclxuICAgICAgICAgICAgY29uc3QgY2FtZXJhID0gdGhpcy5fY2FtZXJhO1xyXG4gICAgICAgICAgICBjYW1lcmEuX3NldERpcnR5Qml0cygxIC8qIFZJRVdfUFJPSl9NQVRSSVggKi8gfCAyIC8qIFZJU0lCTEVfUVVBRFJJTEFURVJBTCAqLyk7XHJcbiAgICAgICAgICAgIGNhbWVyYS5fcGl4ZWxTaXplLnggPSAyLjAgLyB0aGlzLl93aWR0aDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgaGVpZ2h0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XHJcbiAgICB9XHJcbiAgICBzZXQgaGVpZ2h0KG5ld0hlaWdodCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9oZWlnaHQgIT09IG5ld0hlaWdodCkge1xyXG4gICAgICAgICAgICB0aGlzLl9oZWlnaHQgPSBuZXdIZWlnaHQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGNhbWVyYSA9IHRoaXMuX2NhbWVyYTtcclxuICAgICAgICAgICAgY2FtZXJhLl9jb21wdXRlRGlzdGFuY2VUb0NlbnRlcigpO1xyXG4gICAgICAgICAgICBjYW1lcmEuX3NldERpcnR5Qml0cygxIC8qIFZJRVdfUFJPSl9NQVRSSVggKi8gfCAyIC8qIFZJU0lCTEVfUVVBRFJJTEFURVJBTCAqLyk7XHJcbiAgICAgICAgICAgIGNhbWVyYS5fcGl4ZWxTaXplLnkgPSAyLjAgLyB0aGlzLl9oZWlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG4iLCIvKipcclxuICogQ2xhbXBzIGEgdmFsdWUgdG8gYSBnaXZlbiByYW5nZS5cclxuICpcclxuICogQHBhcmFtIHggVGhlIHZhbHVlLlxyXG4gKiBAcGFyYW0gbWluIFN0YXJ0IG9mIHRoZSByYW5nZS5cclxuICogQHBhcmFtIG1heCBFbmQgb2YgdGhlIHJhbmdlLlxyXG4gKiBAcmV0dXJucyBDbGFtcGVkIHZhbHVlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNsYW1wKHgsIG1pbiwgbWF4KSB7XHJcbiAgICByZXR1cm4gbWluIDwgeCA/IHggPCBtYXggPyB4IDogbWF4IDogbWluO1xyXG59XHJcbi8qKlxyXG4gKiBSZXN0cmljdHMgYSB2YWx1ZSB0byBhIGdpdmVuIGN5Y2xlZCByYW5nZSwgaS5lLiBlbmRzIG9mIHRoZSByYW5nZSBhcmVcclxuICogZXF1aXZhbGVudC4gRS5nLiBsaWtlIGFuZ2xlcyBjYW4gYmUgcmVzdHJpY3RlZCB0byBhbnkgcmFuZ2Ugb2Ygc2l6ZSBgMiAqIFBJYC5cclxuICpcclxuICogQHBhcmFtIHggVGhlIHZhbHVlLlxyXG4gKiBAcGFyYW0gbWluIFN0YXJ0IG9mIHRoZSByYW5nZS5cclxuICogQHBhcmFtIG1heCBFbmQgb2YgdGhlIHJhbmdlLlxyXG4gKiBAcmV0dXJucyBSZXN0cmljdGVkIHZhbHVlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGN5Y2xlUmVzdHJpY3QoeCwgbWluLCBtYXgpIHtcclxuICAgIGNvbnN0IGQgPSBtYXggLSBtaW47XHJcbiAgICBjb25zdCBzID0gKHggLSBtaW4pIC8gKG1heCAtIG1pbik7XHJcbiAgICByZXR1cm4gbWluICsgZCAqIChzIC0gTWF0aC5mbG9vcihzKSk7XHJcbn1cclxuLyoqXHJcbiAqIExpbmVhciBpbnRlcnBvbGF0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0gbWluIFZhbHVlIHRoYXQgY29ycmVzcG9uZCB0byAwJSBwcm9ncmVzcy5cclxuICogQHBhcmFtIG1heCBWYWx1ZSB0aGF0IGNvcnJlc3BvbmQgdG8gMTAwJSBwcm9ncmVzcy5cclxuICogQHBhcmFtIHByb2dyZXNzIEluIDAuLjEuMCByYW5nZSB0aGF0IG1hcHMgdG8gMC4uMTAwJSBwcm9ncmVzcy4gSXQgaXMgYWxsb3dlZCB0byBwYXNzIGEgdmFsdWVcclxuICogICAgICBvdXRzaWRlIG9mIHRoaXMgcmFuZ2UsIHRoYXQgbWVhbnMgcHJvZ3Jlc3MgZ3JlYXRlciB0aGVuIDEwMCUgb3IgbmVnYXRpdmUgcHJvZ3Jlc3MuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbWl4KG1pbiwgbWF4LCBwcm9ncmVzcykge1xyXG4gICAgcmV0dXJuICgxIC0gcHJvZ3Jlc3MpICogbWluICsgcHJvZ3Jlc3MgKiBtYXg7XHJcbn1cclxuLyoqXHJcbiAqIEEgc3RlcCBmdW5jdGlvbiB3aXRoIGEgc21vb3RoIHRyYW5zaXRpb24gYmV0d2VlbiBnaXZlbiBlZGdlcy4gQ29tcGxldGVseVxyXG4gKiBhbmFsb2dvdXMgdG8gYHNtb290aHN0ZXBgIGluIEdMU0wgKEdMU0wgRVMgMS4wIMKnOC4zKS5cclxuICpcclxuICogQHBhcmFtIGVkZ2UxIFRoZSBzbWFsbGVyIGVkZ2UuXHJcbiAqIEBwYXJhbSBlZGdlMlxyXG4gKiBAcGFyYW0geCBgMGAgaWYgYHggPCBlZGdlMWAsIGAxYCBpZiBgeCA+IGVkZ2UyYCBhbmQgYW4gaW50ZXJwb2xhdGVkIHZhbHVlIGZvclxyXG4gKiAgICAgIGBlZGdlMSA8IHggPCBlZGdlMmAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc21vb3RoU3RlcChlZGdlMSwgZWRnZTIsIHgpIHtcclxuICAgIGNvbnN0IGZhY3RvciA9IGNsYW1wKCh4IC0gZWRnZTEpIC8gKGVkZ2UyIC0gZWRnZTEpLCAwLCAxKTtcclxuICAgIHJldHVybiBmYWN0b3IgKiBmYWN0b3IgKiAoMyAtIDIgKiBmYWN0b3IpO1xyXG59XHJcbiIsImNvbnN0IERFR19UT19SQUQgPSBNYXRoLlBJIC8gMTgwO1xyXG5leHBvcnQgZnVuY3Rpb24gZGVnMnJhZCh4KSB7XHJcbiAgICByZXR1cm4geCAqIERFR19UT19SQUQ7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIHJhZDJkZWcoeCkge1xyXG4gICAgcmV0dXJuIHggLyBERUdfVE9fUkFEO1xyXG59XHJcbiIsIi8qKlxyXG4gKiBSZXNvbHZlcyBvcHRpb25zLlxyXG4gKlxyXG4gKiBAcGFyYW0gZGVmYXVsdE9wdGlvbnMgT2JqZWN0IHdpdGggZGVmYXVsdCB2YWx1ZXMuXHJcbiAqIEBwYXJhbSBvcHRpb25zIE9iamVjdCB3aXRoIGN1c3RvbSB2YWx1ZXMgZm9yIG9wdGlvbnMuIExhdGVyIG9iamVjdHMgXCJvdmVycmlkZVwiXHJcbiAqICAgICAgZm9ybWVyIG9uZXMuXHJcbiAqIEByZXR1cm5zIE5ldyBvYmplY3QgY29udGFpbmluZyByZXNvbHZlZCBvcHRpb25zLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0RnVsbE9wdGlvbnMoZGVmYXVsdE9wdGlvbnMsIC4uLm9wdGlvbnMpIHtcclxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgLi4ub3B0aW9ucyk7XHJcbn1cclxuIiwiaW1wb3J0ICogYXMgdmVjdG9yMyBmcm9tICcuL3ZlY3RvcjMnO1xyXG4vLyBUT0RPKGRtaWtpcykgUm9NYXRyaXg0P1xyXG5leHBvcnQgY29uc3QgSURFTlRJVFkgPSBbXHJcbiAgICAxLCAwLCAwLCAwLFxyXG4gICAgMCwgMSwgMCwgMCxcclxuICAgIDAsIDAsIDEsIDAsXHJcbiAgICAwLCAwLCAwLCAxXHJcbl07XHJcbmV4cG9ydCBjb25zdCBaRVJPID0gW1xyXG4gICAgMCwgMCwgMCwgMCxcclxuICAgIDAsIDAsIDAsIDAsXHJcbiAgICAwLCAwLCAwLCAwLFxyXG4gICAgMCwgMCwgMCwgMFxyXG5dO1xyXG5jb25zdCBNQVRSSVhfU0laRSA9IDE2O1xyXG4vKipcclxuICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIG5ldyAqKnVuaW5pdGlhbGl6ZWQqKiBtYXRyaXguXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKCkge1xyXG4gICAgcmV0dXJuIG5ldyBBcnJheShNQVRSSVhfU0laRSk7XHJcbn1cclxuLyoqXHJcbiAqIFplcm9lcyBhIG1hdHJpeC5cclxuICpcclxuICogQHBhcmFtIGRzdCBUaGUgbWF0cml4LlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB6ZXJvKGRzdCA9IGNyZWF0ZSgpKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1BVFJJWF9TSVpFOyArK2kpIHtcclxuICAgICAgICBkc3RbaV0gPSAwO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogQ29waWVzIGEgbWF0cml4IHRvIGFub3RoZXIgb25lLlxyXG4gKlxyXG4gKiBAcGFyYW0gc3JjIFRoZSBtYXRyaXggdG8gYmUgY29waWVkLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSBtYXRyaXggdGhlIGBzcmNgIHdpbGwgYmUgY29waWVkIHRvLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb3B5KHNyYywgZHN0ID0gY3JlYXRlKCkpIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTUFUUklYX1NJWkU7ICsraSkge1xyXG4gICAgICAgIGRzdFtpXSA9IHNyY1tpXTtcclxuICAgIH1cclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIEFwcGxpZXMgYSByb3RhdGlvbiBhcm91bmQgdGhlIFggYXhpcyBieSBhIGdpdmVuIGFuZ2xlIHRvIGEgZ2l2ZW4gbWF0cml4LlxyXG4gKiBQb3NpdGl2ZSBkaXJlY3Rpb24gaXMgZnJvbSBwb3NpdGl2ZSBZIHRvIHBvc2l0aXZlIFouXHJcbiAqXHJcbiAqIEBwYXJhbSBzcmMgVGhlIG1hdHJpeCB0byBiZSBtdWx0aXBsaWVkIGJ5IHRoZSByb3RhdGlvbiBtYXRyaXguXHJcbiAqIEBwYXJhbSBhbmdsZSBUaGUgYW5nbGUgb2Ygcm90YXRpb24uXHJcbiAqIEBwYXJhbSBkc3QgVGhlIG1hdHJpeCB0aGUgcHJvZHVjdCB3aWxsIGJlIHN0b3JlZCB0by4gQ2FuIGJlIHRoZSBzYW1lIGFzIGBzcmNgLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVYKHNyYywgYW5nbGUsIGRzdCA9IGNyZWF0ZSgpKSB7XHJcbiAgICBjb25zdCBhbmdsZUNvcyA9IE1hdGguY29zKGFuZ2xlKTtcclxuICAgIGNvbnN0IGFuZ2xlU2luID0gTWF0aC5zaW4oYW5nbGUpO1xyXG4gICAgLy8gVGhlIHJvdGF0aW9uIG1hdHJpeDpcclxuICAgIC8vXHJcbiAgICAvLyAxICAgMCAgICAwIDBcclxuICAgIC8vIDAgY29zIC1zaW4gMFxyXG4gICAgLy8gMCBzaW4gIGNvcyAwXHJcbiAgICAvLyAwICAgMCAgICAwIDFcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTUFUUklYX1NJWkU7IGkgKz0gNCkge1xyXG4gICAgICAgIGRzdFtpXSA9IHNyY1tpXTtcclxuICAgICAgICBjb25zdCBtMWkgPSBzcmNbaSArIDFdO1xyXG4gICAgICAgIGNvbnN0IG0yaSA9IHNyY1tpICsgMl07XHJcbiAgICAgICAgZHN0W2kgKyAxXSA9IG0xaSAqIGFuZ2xlQ29zIC0gbTJpICogYW5nbGVTaW47XHJcbiAgICAgICAgZHN0W2kgKyAyXSA9IG0xaSAqIGFuZ2xlU2luICsgbTJpICogYW5nbGVDb3M7XHJcbiAgICAgICAgZHN0W2kgKyAzXSA9IHNyY1tpICsgM107XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbi8qKlxyXG4gKiBBcHBsaWVzIGEgcm90YXRpb24gYXJvdW5kIHRoZSBZIGF4aXMgYnkgYSBnaXZlbiBhbmdsZSB0byBhIGdpdmVuIG1hdHJpeC5cclxuICogUG9zaXRpdmUgZGlyZWN0aW9uIGlzIGZyb20gcG9zaXRpdmUgWCB0byBwb3NpdGl2ZSBaLlxyXG4gKlxyXG4gKiBAcGFyYW0gc3JjIFRoZSBtYXRyaXggdG8gYmUgbXVsdGlwbGllZCBieSB0aGUgcm90YXRpb24gbWF0cml4LlxyXG4gKiBAcGFyYW0gYW5nbGUgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSBtYXRyaXggdGhlIHByb2R1Y3Qgd2lsbCBiZSBzdG9yZWQgdG8uIENhbiBiZSB0aGUgc2FtZSBhcyBgc3JjYC5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWShzcmMsIGFuZ2xlLCBkc3QgPSBjcmVhdGUoKSkge1xyXG4gICAgY29uc3QgYW5nbGVDb3MgPSBNYXRoLmNvcyhhbmdsZSk7XHJcbiAgICBjb25zdCBhbmdsZVNpbiA9IE1hdGguc2luKGFuZ2xlKTtcclxuICAgIC8vIFRoZSByb3RhdGlvbiBtYXRyaXg6XHJcbiAgICAvL1xyXG4gICAgLy8gY29zIDAgLXNpbiAwXHJcbiAgICAvLyAwICAgMSAgICAwIDBcclxuICAgIC8vIHNpbiAwICBjb3MgMFxyXG4gICAgLy8gMCAgICAwICAgMCAxXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1BVFJJWF9TSVpFOyBpICs9IDQpIHtcclxuICAgICAgICBjb25zdCBtMGkgPSBzcmNbaV07XHJcbiAgICAgICAgY29uc3QgbTJpID0gc3JjW2kgKyAyXTtcclxuICAgICAgICBkc3RbaV0gPSBtMGkgKiBhbmdsZUNvcyAtIG0yaSAqIGFuZ2xlU2luO1xyXG4gICAgICAgIGRzdFtpICsgMV0gPSBzcmNbaSArIDFdO1xyXG4gICAgICAgIGRzdFtpICsgMl0gPSBtMGkgKiBhbmdsZVNpbiArIG0yaSAqIGFuZ2xlQ29zO1xyXG4gICAgICAgIGRzdFtpICsgM10gPSBzcmNbaSArIDNdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogQXBwbGllcyBhIHJvdGF0aW9uIGFyb3VuZCB0aGUgWCBheGlzIGJ5IGEgZ2l2ZW4gYW5nbGUgdG8gYSBnaXZlbiBtYXRyaXguXHJcbiAqIFBvc2l0aXZlIGRpcmVjdGlvbiBpcyBmcm9tIHBvc2l0aXZlIFggdG8gcG9zaXRpdmUgWS5cclxuICpcclxuICogQHBhcmFtIHNyYyBUaGUgbWF0cml4IHRvIGJlIG11bHRpcGxpZWQgYnkgdGhlIHJvdGF0aW9uIG1hdHJpeC5cclxuICogQHBhcmFtIGFuZ2xlIFRoZSBhbmdsZSBvZiByb3RhdGlvbi5cclxuICogQHBhcmFtIGRzdCBUaGUgbWF0cml4IHRoZSBwcm9kdWN0IHdpbGwgYmUgc3RvcmVkIHRvLiBDYW4gYmUgdGhlIHNhbWUgYXMgYHNyY2AuXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVooc3JjLCBhbmdsZSwgZHN0ID0gY3JlYXRlKCkpIHtcclxuICAgIGNvbnN0IGFuZ2xlQ29zID0gTWF0aC5jb3MoYW5nbGUpO1xyXG4gICAgY29uc3QgYW5nbGVTaW4gPSBNYXRoLnNpbihhbmdsZSk7XHJcbiAgICAvLyBUaGUgcm90YXRpb24gbWF0cml4OlxyXG4gICAgLy8gY29zIC1zaW4gMCAwXHJcbiAgICAvLyBzaW4gIGNvcyAwIDBcclxuICAgIC8vICAgMCAgICAwIDEgMFxyXG4gICAgLy8gICAwICAgIDAgMCAxXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1BVFJJWF9TSVpFOyBpICs9IDQpIHtcclxuICAgICAgICBjb25zdCBtMGkgPSBzcmNbaV07XHJcbiAgICAgICAgY29uc3QgbTFpID0gc3JjW2kgKyAxXTtcclxuICAgICAgICBkc3RbaV0gPSBtMGkgKiBhbmdsZUNvcyAtIG0xaSAqIGFuZ2xlU2luO1xyXG4gICAgICAgIGRzdFtpICsgMV0gPSBtMGkgKiBhbmdsZVNpbiArIG0xaSAqIGFuZ2xlQ29zO1xyXG4gICAgICAgIGRzdFtpICsgMl0gPSBzcmNbaSArIDJdO1xyXG4gICAgICAgIGRzdFtpICsgM10gPSBzcmNbaSArIDNdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogQXBwbGllcyBhIHRyYW5zbGF0aW9uIGJ5IGEgZ2l2ZW4gdmVjdG9yIHRvIGEgZ2l2ZW4gbWF0cml4LlxyXG4gKlxyXG4gKiBAcGFyYW0gc3JjIFRoZSBtYXRyaXggdG8gYmUgbXVsdGlwbGllZCBieSB0aGUgdHJhbnNsYXRpb24gbWF0cml4LlxyXG4gKiBAcGFyYW0gdHJhbnNsYXRpb24gVGhlIHRyYW5zbGF0aW9uIHZlY3Rvci5cclxuICogQHBhcmFtIGRzdCBUaGUgbWF0cml4IHRoZSBwcm9kdWN0IHdpbGwgYmUgc3RvcmVkIHRvLiBDYW4gYmUgdGhlIHNhbWUgYXMgYHNyY2AuXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zbGF0ZShzcmMsIHRyYW5zbGF0aW9uLCBkc3QgPSBjcmVhdGUoKSkge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNQVRSSVhfU0laRTsgaSArPSA0KSB7XHJcbiAgICAgICAgY29uc3QgbTRpID0gZHN0W2kgKyAzXSA9IHNyY1tpICsgM107XHJcbiAgICAgICAgZHN0W2ldID0gc3JjW2ldICsgbTRpICogdHJhbnNsYXRpb24ueDtcclxuICAgICAgICBkc3RbaSArIDFdID0gc3JjW2kgKyAxXSArIG00aSAqIHRyYW5zbGF0aW9uLnk7XHJcbiAgICAgICAgZHN0W2kgKyAyXSA9IHNyY1tpICsgMl0gKyBtNGkgKiB0cmFuc2xhdGlvbi56O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogQXBwbGllcyBhIHNjYWxlIG1hdHJpeCBieSBnaXZlbiBmYWN0b3JzIChwYWNrZWQgaW50byBhIHZlY3RvcikgdG8gYSBnaXZlblxyXG4gKiBtYXRyaXguXHJcbiAqXHJcbiAqIEBwYXJhbSBzcmMgVGhlIG1hdHJpeCB0byBiZSBtdWx0aXBsaWVkIGJ5IHRoZSBzY2FsZSBtYXRyaXguXHJcbiAqIEBwYXJhbSBmYWN0b3IgVGhlIHZlY3RvciB0aGUgc2NhbGUgZmFjdG9ycyBwYWNrZWQgaW50by5cclxuICogQHBhcmFtIGRzdCBUaGUgbWF0cml4IHRoZSBwcm9kdWN0IHdpbGwgYmUgc3RvcmVkIHRvLiBDYW4gYmUgdGhlIHNhbWUgYXMgYHNyY2AuXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKHNyYywgZmFjdG9yLCBkc3QgPSBjcmVhdGUoKSkge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNQVRSSVhfU0laRTsgaSArPSA0KSB7XHJcbiAgICAgICAgZHN0W2ldID0gc3JjW2ldICogZmFjdG9yLng7XHJcbiAgICAgICAgZHN0W2kgKyAxXSA9IHNyY1tpICsgMV0gKiBmYWN0b3IueTtcclxuICAgICAgICBkc3RbaSArIDJdID0gc3JjW2kgKyAyXSAqIGZhY3Rvci56O1xyXG4gICAgICAgIGRzdFtpICsgM10gPSBzcmNbaSArIDNdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vLyBUaGUgbWF0cml4OlxyXG4vLyB4QXhpcy54IHlBeGlzLnggekF4aXMueCAtZXllLnhcclxuLy8geEF4aXMueSB5QXhpcy55IHpBeGlzLnkgLWV5ZS55XHJcbi8vIHhBeGlzLnogeUF4aXMueiB6QXhpcy56IC1leWUuelxyXG4vLyAgICAgICAwICAgICAgIDAgICAgICAgMCAxXHJcbi8vIHdoZXJlIHhBeGlzLCB5QXhpcyBhbmQgekF4aXMg4oCUIGF4ZXMgb2YgdGhlIGV5ZSBjb29yZGluYXRlIHN5c3RlbSwgZXllIOKAlFxyXG4vLyBvcmlnaW4gb2YgdGhlIGV5ZSBjb29yZGluYXRlIHN5c3RlbS5cclxuY29uc3QgbG9va0F0TWF0cml4ID0gY29weShJREVOVElUWSk7XHJcbi8qKlxyXG4gKiBBcHBsaWVzIGEgbWF0cml4IG9mIHRyYW5zZm9ybWF0aW9uIGludG8gYSBjb29yZGluYXRlIHN5c3RlbSBvZiBhIGNhbWVyYVxyXG4gKiBkZWZpbmVkIGJ5IGl0cyBwb3NpdGlvbiwgYSBwb2ludCBpdCdzIGxvb2tpbmcgYXQgYW5kIGFuIHVwIGRpcmVjdGlvbiB2ZWN0b3IuXHJcbiAqXHJcbiAqIEBwYXJhbSBzcmMgVGhlIG1hdHJpeCB0byBiZSBtdWx0aXBsaWVkIGJ5IHRoZSBzY2FsZSBtYXRyaXguXHJcbiAqIEBwYXJhbSBleWUgVGhlIHBvc2l0aW9uIG9mIHRoZSBjYW1lcmEuXHJcbiAqIEBwYXJhbSBjZW50ZXIgVGhlIHBvaW50IHRoZSBjYW1lcmEncyBsb29raW5nIGF0LlxyXG4gKiBAcGFyYW0gdXAgVGhlIHVwIHZlY3Rvci5cclxuICogQHBhcmFtIGRzdCBUaGUgbWF0cml4IHRoZSBwcm9kdWN0IHdpbGwgYmUgc3RvcmVkIHRvLiBDYW4gYmUgdGhlIHNhbWUgYXMgYHNyY2AuXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGxvb2tBdChzcmMsIGV5ZSwgY2VudGVyLCB1cCwgZHN0ID0gY3JlYXRlKCkpIHtcclxuICAgIGNvbnN0IHpBeGlzID0gdmVjdG9yMy5zdWIoZXllLCBjZW50ZXIpO1xyXG4gICAgdmVjdG9yMy5ub3JtYWxpemUoekF4aXMsIHpBeGlzKTtcclxuICAgIGNvbnN0IHhBeGlzID0gdmVjdG9yMy5jcm9zcyh1cCwgekF4aXMpO1xyXG4gICAgdmVjdG9yMy5ub3JtYWxpemUoeEF4aXMsIHhBeGlzKTtcclxuICAgIGNvbnN0IHlBeGlzID0gdmVjdG9yMy5jcm9zcyh6QXhpcywgeEF4aXMpO1xyXG4gICAgbG9va0F0TWF0cml4WzBdID0geEF4aXMueDtcclxuICAgIGxvb2tBdE1hdHJpeFsxXSA9IHlBeGlzLng7XHJcbiAgICBsb29rQXRNYXRyaXhbMl0gPSB6QXhpcy54O1xyXG4gICAgbG9va0F0TWF0cml4WzRdID0geEF4aXMueTtcclxuICAgIGxvb2tBdE1hdHJpeFs1XSA9IHlBeGlzLnk7XHJcbiAgICBsb29rQXRNYXRyaXhbNl0gPSB6QXhpcy55O1xyXG4gICAgbG9va0F0TWF0cml4WzhdID0geEF4aXMuejtcclxuICAgIGxvb2tBdE1hdHJpeFs5XSA9IHlBeGlzLno7XHJcbiAgICBsb29rQXRNYXRyaXhbMTBdID0gekF4aXMuejtcclxuICAgIGxvb2tBdE1hdHJpeFsxMl0gPSAtdmVjdG9yMy5kb3QoeEF4aXMsIGV5ZSk7XHJcbiAgICBsb29rQXRNYXRyaXhbMTNdID0gLXZlY3RvcjMuZG90KHlBeGlzLCBleWUpO1xyXG4gICAgbG9va0F0TWF0cml4WzE0XSA9IC12ZWN0b3IzLmRvdCh6QXhpcywgZXllKTtcclxuICAgIHJldHVybiBtdWwoc3JjLCBsb29rQXRNYXRyaXgsIGRzdCk7XHJcbn1cclxuLyoqXHJcbiAqIEFwcGxpZXMgYSBwZXJzcGVjdGl2ZSBtYXRyaXggdG8gYSBnaXZlbiBvbmUuXHJcbiAqXHJcbiAqIEBwYXJhbSBzcmMgVGhlIG1hdHJpeCB0byBiZSBtdWx0aXBsaWVkIGJ5IHRoZSBwZXJzcGVjdGl2ZSBtYXRyaXguXHJcbiAqIEBwYXJhbSBmb3YgVmVydGljYWwgZmllbGQgb2YgdmlldyBhbmdsZS5cclxuICogQHBhcmFtIGFzcGVjdFJhdGlvIFNjcmVlbiBhc3BlY3QgcmF0aW8uXHJcbiAqIEBwYXJhbSB6TmVhciBaLWNvb3JkaW5hdGUgb2YgbmVhciBjbGlwcGluZyBwbGFuZS5cclxuICogQHBhcmFtIHpGYXIgWi1jb29yZGluYXRlIG9mIGZhciBjbGlwcGluZyBwbGFuZS5cclxuICogQHBhcmFtIGRzdCBUaGUgbWF0cml4IHRoZSBwcm9kdWN0IHdpbGwgYmUgc3RvcmVkIHRvLiBDYW4gYmUgdGhlIHNhbWUgYXMgYHNyY2AuXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHBlcnNwZWN0aXZlKHNyYywgZm92LCBhc3BlY3QsIHpOZWFyLCB6RmFyLCBkc3QgPSBjcmVhdGUoKSkge1xyXG4gICAgY29uc3QgcDExID0gMSAvIE1hdGgudGFuKDAuNSAqIGZvdik7XHJcbiAgICBjb25zdCBwMDAgPSBwMTEgLyBhc3BlY3Q7XHJcbiAgICBjb25zdCBwMjIgPSAoek5lYXIgKyB6RmFyKSAvICh6TmVhciAtIHpGYXIpO1xyXG4gICAgY29uc3QgcDMyID0gMiAqIHpOZWFyICogekZhciAvICh6TmVhciAtIHpGYXIpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNQVRSSVhfU0laRTsgaSArPSA0KSB7XHJcbiAgICAgICAgZHN0W2ldID0gc3JjW2ldICogcDAwO1xyXG4gICAgICAgIGRzdFtpICsgMV0gPSBzcmNbaSArIDFdICogcDExO1xyXG4gICAgICAgIGNvbnN0IG0yaSA9IHNyY1tpICsgMl07XHJcbiAgICAgICAgY29uc3QgbTNpID0gc3JjW2kgKyAzXTtcclxuICAgICAgICBkc3RbaSArIDJdID0gbTJpICogcDIyICsgbTNpICogcDMyO1xyXG4gICAgICAgIGRzdFtpICsgM10gPSAtbTJpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogTXVsdGlwbGllcyBhIG1hdHJpeCBieSBhbm90aGVyIG9uZSwgaS5lLiBgZHN0ID0gbSAqIHNyY2AuXHJcbiAqXHJcbiAqIEBwYXJhbSBzcmMgVGhlIHJpZ2h0IG1hdHJpeC5cclxuICogQHBhcmFtIG0gVGhlIGxlZnQgbWF0cml4LlxyXG4gKiBAcGFyYW0gZHN0IFRoZSBtYXRyaXggdGhlIHByb2R1Y3Qgd2lsbCBiZSBzdG9yZWQgdG8uIENhbiBiZSB0aGUgc2FtZSBhcyBgc3JjYC5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbXVsKHNyYywgbSwgZHN0ID0gY3JlYXRlKCkpIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTUFUUklYX1NJWkU7IGkgKz0gNCkge1xyXG4gICAgICAgIGNvbnN0IG0waSA9IHNyY1tpXTtcclxuICAgICAgICBjb25zdCBtMWkgPSBzcmNbaSArIDFdO1xyXG4gICAgICAgIGNvbnN0IG0yaSA9IHNyY1tpICsgMl07XHJcbiAgICAgICAgY29uc3QgbTNpID0gc3JjW2kgKyAzXTtcclxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDQ7ICsraikge1xyXG4gICAgICAgICAgICBkc3RbaSArIGpdID0gbTBpICogbVtqXSArIG0xaSAqIG1bNCArIGpdICsgbTJpICogbVs4ICsgal0gK1xyXG4gICAgICAgICAgICAgICAgbTNpICogbVsxMiArIGpdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIEFwcGxpZXMgYSBtYXRyaXggdG8gYSB2ZWN0b3IuXHJcbiAqXHJcbiAqIEBwYXJhbSBtIFRoZSBtYXRyaXguXHJcbiAqIEBwYXJhbSB2IFRoZSB2ZWN0b3IuXHJcbiAqIEByZXR1cm5zIE5vcm1hbGl6ZWQgcHJvZHVjdCBvZiBtdWx0aXBseWluZyB0aGUgdmVjdG9yIGJ5IHRoZSBtYXRyaXguXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYXBwbHkobSwgdiwgZHN0ID0gdmVjdG9yMy5jcmVhdGUoMCwgMCwgMCkpIHtcclxuICAgIGNvbnN0IHcgPSBtWzNdICogdi54ICsgbVs3XSAqIHYueSArIG1bMTFdICogdi56ICsgbVsxNV07XHJcbiAgICBjb25zdCB4ID0gKG1bMF0gKiB2LnggKyBtWzRdICogdi55ICsgbVs4XSAqIHYueiArIG1bMTJdKSAvIHc7XHJcbiAgICBjb25zdCB5ID0gKG1bMV0gKiB2LnggKyBtWzVdICogdi55ICsgbVs5XSAqIHYueiArIG1bMTNdKSAvIHc7XHJcbiAgICBjb25zdCB6ID0gKG1bMl0gKiB2LnggKyBtWzZdICogdi55ICsgbVsxMF0gKiB2LnogKyBtWzE0XSkgLyB3O1xyXG4gICAgZHN0LnggPSB4O1xyXG4gICAgZHN0LnkgPSB5O1xyXG4gICAgZHN0LnogPSB6O1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4iLCJpbXBvcnQgKiBhcyBtYXRyaXgzIGZyb20gJy4vbWF0cml4Myc7XHJcbmltcG9ydCBhcmVGdXp6eUVxdWFsU2NhbGFyLCB7IERFRkFVTFRfVE9MRVJBTkNFIH0gZnJvbSAnLi4vdXRpbC9mdXp6eV9lcXVhbCc7XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IHZlY3RvciBhbmQgaW5pdGlhbGl6ZXMgaXQgd2l0aCBnaXZlbiBjb21wb25lbnRzLlxyXG4gKlxyXG4gKiBAcGFyYW0geCBYIGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yLlxyXG4gKiBAcGFyYW0geSBZIGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yLlxyXG4gKiBAcGFyYW0geiBaIGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yLlxyXG4gKiBAcmV0dXJucyBUaGUgdmVjdG9yLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSh4LCB5LCB6KSB7XHJcbiAgICByZXR1cm4geyB4LCB5LCB6IH07XHJcbn1cclxuZXhwb3J0IGNvbnN0IE9SSUdJTiA9IGNyZWF0ZSgwLCAwLCAwKTtcclxuZXhwb3J0IGNvbnN0IFBPU0lUSVZFX1ggPSBjcmVhdGUoMSwgMCwgMCk7XHJcbmV4cG9ydCBjb25zdCBORUdBVElWRV9YID0gY3JlYXRlKC0xLCAwLCAwKTtcclxuZXhwb3J0IGNvbnN0IFBPU0lUSVZFX1kgPSBjcmVhdGUoMCwgMSwgMCk7XHJcbmV4cG9ydCBjb25zdCBORUdBVElWRV9ZID0gY3JlYXRlKDAsIC0xLCAwKTtcclxuZXhwb3J0IGNvbnN0IFBPU0lUSVZFX1ogPSBjcmVhdGUoMCwgMCwgMSk7XHJcbmV4cG9ydCBjb25zdCBORUdBVElWRV9aID0gY3JlYXRlKDAsIDAsIC0xKTtcclxuLyoqXHJcbiAqIENvcGllcyBhIHZlY3RvciB0byBhbm90aGVyIG9uZS5cclxuICpcclxuICogQHBhcmFtIHNyYyBUaGUgc291cmNlIHZlY3Rvci5cclxuICogQHBhcmFtIGRzdCBUaGUgdmVjdG9yIHRoZSBzb3VyY2UgdmVjdG9yIHdpbGwgYmUgY29waWVkIHRvLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb3B5KHNyYywgZHN0ID0gY3JlYXRlKDAsIDAsIDApKSB7XHJcbiAgICBkc3QueCA9IHNyYy54O1xyXG4gICAgZHN0LnkgPSBzcmMueTtcclxuICAgIGRzdC56ID0gc3JjLno7XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgdHdvIHZlY3RvcnMgYXJlIHN0cmljdGx5IGVxdWFsIGNvbXBvbmVudC13aXNlLlxyXG4gKlxyXG4gKiBAcGFyYW0gdjEgVGhlIGZpcnN0IHZlY3Rvci5cclxuICogQHBhcmFtIHYyIFRoZSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsIGFuZCBgZmFsc2VgIG90aGVyd2lzZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBhcmVFcXVhbCh2MSwgdjIpIHtcclxuICAgIHJldHVybiB2MS54ID09PSB2Mi54ICYmIHYxLnkgPT09IHYyLnkgJiYgdjEueiA9PT0gdjIuejtcclxufVxyXG4vKipcclxuICogQ2hlY2tzIGlmIGNvcnJlc3BvbmRpbmcgY29tcG9uZW50cyBvZiB0d28gdmVjdG9ycyBhcmUgYWxsIHdpdGhpbiBnaXZlblxyXG4gKiB0b2xlcmFuY2UgZnJvbSBlYWNoIG90aGVyLlxyXG4gKlxyXG4gKiBAcGFyYW0gdjEgVGhlIGZpcnN0IHZlY3Rvci5cclxuICogQHBhcmFtIHYyIFRoZSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBAcGFyYW0gdG9sZXJhbmNlIFRoZSB0b2xlcmFuY2UuXHJcbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmVjdG9ycyBhcmUgXCJmdXp6eVwiIGVxdWFsIGFuZCBgZmFsc2VgIG90aGVyd2lzZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBhcmVGdXp6eUVxdWFsKHYxLCB2MiwgdG9sZXJhbmNlID0gREVGQVVMVF9UT0xFUkFOQ0UpIHtcclxuICAgIHJldHVybiAoYXJlRnV6enlFcXVhbFNjYWxhcih2MS54LCB2Mi54LCB0b2xlcmFuY2UpICYmXHJcbiAgICAgICAgYXJlRnV6enlFcXVhbFNjYWxhcih2MS55LCB2Mi55LCB0b2xlcmFuY2UpICYmXHJcbiAgICAgICAgYXJlRnV6enlFcXVhbFNjYWxhcih2MS56LCB2Mi56LCB0b2xlcmFuY2UpKTtcclxufVxyXG4vKipcclxuICogQ2hlY2tzIGlmIHR3byB2ZWN0b3JzIGFyZSBjb2xsaW5lYXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB2MSBUaGUgZmlyc3QgdmVjdG9yLlxyXG4gKiBAcGFyYW0gdjIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmVjdG9ycyBhcmUgY29sbGluZWFyIGFuZCBgZmFsc2VgIG90aGVyd2lzZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBhcmVDb2xsaW5lYXIodjEsIHYyKSB7XHJcbiAgICBjb25zdCBsYW1iZGFYID0gdjEueCAvIHYyLng7XHJcbiAgICBjb25zdCBsYW1iZGFZID0gdjEueSAvIHYyLnk7XHJcbiAgICBjb25zdCBsYW1iZGFaID0gdjEueiAvIHYyLno7XHJcbiAgICByZXR1cm4gbGFtYmRhWCA9PT0gbGFtYmRhWSAmJiBsYW1iZGFZID09PSBsYW1iZGFaO1xyXG59XHJcbi8qKlxyXG4gKiBBZGRzIHR3byB2ZWN0b3IgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGludG8gYSB0aGlyZCBvbmUsIGkuZS4gYGRzdCA9IGEgKyBiYC5cclxuICpcclxuICogQHBhcmFtIGEgVGhlIGZpcnN0IHZlY3Rvci5cclxuICogQHBhcmFtIGIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBkc3QgVGhlIHZlY3RvciB0aGUgcmVzdWx0IHdpbGwgYmUgc3RvcmVkIHRvLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBhZGQoYSwgYiwgZHN0ID0gY3JlYXRlKDAsIDAsIDApKSB7XHJcbiAgICBkc3QueCA9IGEueCArIGIueDtcclxuICAgIGRzdC55ID0gYS55ICsgYi55O1xyXG4gICAgZHN0LnogPSBhLnogKyBiLno7XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbi8qKlxyXG4gKiBTdWJ0cmFjdHMgYSB2ZWN0b3IgZnJvbSBhbm90aGVyIG9uZSBhbmQgc3RvcmVzIHRoZSByZXN1bHQgdG8gYSB0aGlyZCBvbmUsIGkuZS5cclxuICogYGRzdCA9IGEgLSBiYC5cclxuICpcclxuICogQHBhcmFtIGEgVGhlIG1pbnVlbmQgdmVjdG9yLlxyXG4gKiBAcGFyYW0gYiBUaGUgc3VidHJhaGVuZCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBkc3QgVGhlIHZlY3RvciB0aGUgcmVzdWx0IHdpbGwgYmUgc3RvcmVkIHRvLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHN1YihhLCBiLCBkc3QgPSBjcmVhdGUoMCwgMCwgMCkpIHtcclxuICAgIGRzdC54ID0gYS54IC0gYi54O1xyXG4gICAgZHN0LnkgPSBhLnkgLSBiLnk7XHJcbiAgICBkc3QueiA9IGEueiAtIGIuejtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIE11bHRpcGxpZXMgdHdvIHZlY3RvcnMgY29tcG9uZW50LXdpc2UgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGludG8gYSB0aGlyZCBvbmUuXHJcbiAqXHJcbiAqIEBwYXJhbSBhIFRoZSBmaXJzdCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSB2ZWN0b3IgdGhlIHJlc3VsdCB3aWxsIGJlIHN0b3JlZCB0by5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbXVsdihhLCBiLCBkc3QgPSBjcmVhdGUoMCwgMCwgMCkpIHtcclxuICAgIGRzdC54ID0gYS54ICogYi54O1xyXG4gICAgZHN0LnkgPSBhLnkgKiBiLnk7XHJcbiAgICBkc3QueiA9IGEueiAqIGIuejtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIE11bHRpcGxpZXMgYSB2ZWN0b3IgYnkgYSBzY2FsYXIgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGludG8gYSB0aGlyZCB2ZWN0b3IuXHJcbiAqXHJcbiAqIEBwYXJhbSBhIFRoZSB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBuIFRoZSBzY2FsYXIuXHJcbiAqIEBwYXJhbSBkc3QgVGhlIHZlY3RvciB0aGUgcmVzdWx0IHdpbGwgYmUgc3RvcmVkIHRvLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBtdWxuKGEsIG4sIGRzdCA9IGNyZWF0ZSgwLCAwLCAwKSkge1xyXG4gICAgZHN0LnggPSBhLnggKiBuO1xyXG4gICAgZHN0LnkgPSBhLnkgKiBuO1xyXG4gICAgZHN0LnogPSBhLnogKiBuO1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogRGl2aWRlcyBhIHZlY3RvciBieSBhbm90aGVyIG9uZSBjb21wb25lbnQgd2lzZSBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW50byBhXHJcbiAqIHRoaXJkIG9uZS5cclxuICpcclxuICogQHBhcmFtIGEgVGhlIGRpdmlkZW5kIHZlY3Rvci5cclxuICogQHBhcmFtIGIgVGhlIGRpdmlzb3IgdmVjdG9yLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSB2ZWN0b3IgdGhlIHJlc3VsdCB3aWxsIGJlIHN0b3JlZCB0by5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZGl2dihhLCBiLCBkc3QgPSBjcmVhdGUoMCwgMCwgMCkpIHtcclxuICAgIGRzdC54ID0gYS54IC8gYi54O1xyXG4gICAgZHN0LnkgPSBhLnkgLyBiLnk7XHJcbiAgICBkc3QueiA9IGEueiAvIGIuejtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIERpdmlkZXMgYSB2ZWN0b3IgYnkgYSBzY2FsYXIgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGludG8gYSB0aGlyZCB2ZWN0b3IuXHJcbiAqXHJcbiAqIEBwYXJhbSBhIFRoZSBkaXZpZGVuZCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBuIFRoZSBzY2FsYXIuXHJcbiAqIEBwYXJhbSBkc3QgVGhlIHZlY3RvciB0aGUgcmVzdWx0IHdpbGwgYmUgc3RvcmVkIHRvLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBkaXZuKGEsIG4sIGRzdCA9IGNyZWF0ZSgwLCAwLCAwKSkge1xyXG4gICAgZHN0LnggPSBhLnggLyBuO1xyXG4gICAgZHN0LnkgPSBhLnkgLyBuO1xyXG4gICAgZHN0LnogPSBhLnogLyBuO1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogQ29tcHV0ZXMgbGVuZ3RoIG9mIGEgdmVjdG9yLlxyXG4gKlxyXG4gKiBAcGFyYW0gdiBUaGUgdmVjdG9yLlxyXG4gKiBAcmV0dXJucyBUaGUgbGVuZ3RoLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGxlbmd0aCh2KSB7XHJcbiAgICByZXR1cm4gTWF0aC5oeXBvdCh2LngsIHYueSwgdi56KTtcclxufVxyXG4vKipcclxuICogQ29tcHV0ZXMgZGlzdGFuY2UgYmV0d2VlbiBlbmRzIG9mIHR3byB2ZWN0b3JzLlxyXG4gKlxyXG4gKiBAcGFyYW0gYSBUaGUgZmlyc3QgdmVjdG9yLlxyXG4gKiBAcGFyYW0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cclxuICogQHJldHVybnMgVGhlIGRpc3RhbmNlLCBpLmUuIGBsZW5ndGgoc3ViKGEsIGIpKWAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZGlzdGFuY2UoYSwgYikge1xyXG4gICAgcmV0dXJuIE1hdGguaHlwb3QoYS54IC0gYi54LCBhLnkgLSBiLnksIGEueiAtIGIueik7XHJcbn1cclxuLyoqXHJcbiAqIERpdmlkZXMgYSB2ZWN0b3IgYnkgaXRzIGxlbmd0aCAodGh1cyBtYWtpbmcgaXQgYSB1bml0IHZlY3RvcikgYW5kIHN0b3JlcyB0aGVcclxuICogcmVzdWx0IHRvIGFub3RoZXIgb25lLlxyXG4gKlxyXG4gKiBAcGFyYW0gdiBUaGUgdmVjdG9yIHRvIGJlIG5vcm1hbGl6ZWQuXHJcbiAqIEBwYXJhbSBkc3QgVGhlIHZlY3RvciB0aGUgcmVzdWx0IHdpbGwgYmUgc3RvcmVkIHRvLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUodiwgZHN0ID0gY3JlYXRlKDAsIDAsIDApKSB7XHJcbiAgICByZXR1cm4gZGl2bih2LCBsZW5ndGgodiksIGRzdCk7XHJcbn1cclxuLyoqXHJcbiAqIENvbXB1dGVzIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWN0b3JzLlxyXG4gKlxyXG4gKiBAcGFyYW0gYSBUaGUgZmlyc3QgdmVjdG9yLlxyXG4gKiBAcGFyYW0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cclxuICogQHJldHVybnMgVGhlIGRvdCBwcm9kdWN0LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRvdChhLCBiKSB7XHJcbiAgICByZXR1cm4gYS54ICogYi54ICsgYS55ICogYi55ICsgYS56ICogYi56O1xyXG59XHJcbi8qKlxyXG4gKiBDb21wdXRlcyBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWN0b3JzIGFuZCBzdG9yZXMgaXQgdG8gYSB0aGlyZCBvbmUuXHJcbiAqXHJcbiAqIEBwYXJhbSBhIFRoZSBmaXJzdCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSB2ZWN0b3IgdGhlIHJlc3VsdCB3aWxsIGJlIHN0b3JlZCB0by5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY3Jvc3MoYSwgYiwgZHN0ID0gY3JlYXRlKDAsIDAsIDApKSB7XHJcbiAgICAvLyBXcml0ZSBjb21wb25lbnRzIHRvIGEgc2VwYXJhdGUgdmFyaWFibGVzIHNvIHdlIGRvbid0IHByb2R1Y2UgaW5jb3JyZWN0XHJcbiAgICAvLyByZXN1bHRzIGluIGNhc2VzIHdoZW4gYSA9PSBkc3Qgb3IgYiA9PSBkc3QuXHJcbiAgICBjb25zdCB4ID0gYS55ICogYi56IC0gYS56ICogYi55O1xyXG4gICAgY29uc3QgeSA9IGEueiAqIGIueCAtIGEueCAqIGIuejtcclxuICAgIGNvbnN0IHogPSBhLnggKiBiLnkgLSBhLnkgKiBiLng7XHJcbiAgICBkc3QueCA9IHg7XHJcbiAgICBkc3QueSA9IHk7XHJcbiAgICBkc3QueiA9IHo7XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbi8qKlxyXG4gKiBSb3RhdGVzIHZlY3RvciBhYm91dCB0aGUgWCBheGlzLlxyXG4gKlxyXG4gKiBAcGFyYW0gdiBUaGUgdmVjdG9yIHRvIGJlIHJvdGF0ZWQuXHJcbiAqIEBwYXJhbSBhbmdsZSBUaGUgYW5nbGUgb2Ygcm90YXRpb24gKGluIHJhZGlhbnMpLCBwb3NpdGl2ZSB2YWx1ZXMgcm90YXRlcyBmcm9tICtZIHRvICtaXHJcbiAqIEBwYXJhbSBkc3QgVGhlIHZlY3RvciB0aGUgcmVzdWx0IHdpbGwgYmUgc3RvcmVkIHRvLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVgodiwgYW5nbGUsIGRzdCA9IGNyZWF0ZSgwLCAwLCAwKSkge1xyXG4gICAgY29uc3QgY29zID0gTWF0aC5jb3MoYW5nbGUpO1xyXG4gICAgY29uc3Qgc2luID0gTWF0aC5zaW4oYW5nbGUpO1xyXG4gICAgY29uc3QgeSA9IHYueTtcclxuICAgIGRzdC54ID0gdi54O1xyXG4gICAgZHN0LnkgPSB5ICogY29zIC0gdi56ICogc2luO1xyXG4gICAgZHN0LnogPSB5ICogc2luICsgdi56ICogY29zO1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogUm90YXRlcyB2ZWN0b3IgYWJvdXQgdGhlIFkgYXhpcy5cclxuICpcclxuICogQHBhcmFtIHYgVGhlIHZlY3RvciB0byBiZSByb3RhdGVkLlxyXG4gKiBAcGFyYW0gYW5nbGUgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uIChpbiByYWRpYW5zKSwgcG9zaXRpdmUgdmFsdWVzIHJvdGF0ZXMgZnJvbSArWCB0byArWlxyXG4gKiBAcGFyYW0gZHN0IFRoZSB2ZWN0b3IgdGhlIHJlc3VsdCB3aWxsIGJlIHN0b3JlZCB0by5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVZKHYsIGFuZ2xlLCBkc3QgPSBjcmVhdGUoMCwgMCwgMCkpIHtcclxuICAgIGNvbnN0IGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcclxuICAgIGNvbnN0IHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcclxuICAgIC8vIGhhbmRsZSB0aGUgY2FzZSB3aGVuIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gYXJlIHRoZSBzYW1lIG9iamVjdDogcmVsYXRlZCBjb21wb25lbnRzIGNhbiBicmVhayBlYWNoIG90aGVyXHJcbiAgICB2ID0gKHYgPT09IGRzdCkgPyBjb3B5KHYpIDogdjtcclxuICAgIGRzdC54ID0gdi54ICogY29zICsgdi56ICogc2luO1xyXG4gICAgZHN0LnkgPSB2Lnk7XHJcbiAgICBkc3QueiA9IC12LnggKiBzaW4gKyB2LnogKiBjb3M7XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbi8qKlxyXG4gKiBSb3RhdGVzIHZlY3RvciBhYm91dCB0aGUgWiBheGlzLlxyXG4gKlxyXG4gKiBAcGFyYW0gdiBUaGUgdmVjdG9yIHRvIGJlIHJvdGF0ZWQuXHJcbiAqIEBwYXJhbSBhbmdsZSBUaGUgYW5nbGUgb2Ygcm90YXRpb24gKGluIHJhZGlhbnMpLCBwb3NpdGl2ZSB2YWx1ZXMgcm90YXRlcyBmcm9tICtYIHRvICtZXHJcbiAqIEBwYXJhbSBkc3QgVGhlIHZlY3RvciB0aGUgcmVzdWx0IHdpbGwgYmUgc3RvcmVkIHRvLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVoodiwgYW5nbGUsIGRzdCA9IGNyZWF0ZSgwLCAwLCAwKSkge1xyXG4gICAgY29uc3QgY29zID0gTWF0aC5jb3MoYW5nbGUpO1xyXG4gICAgY29uc3Qgc2luID0gTWF0aC5zaW4oYW5nbGUpO1xyXG4gICAgLy8gaGFuZGxlIHRoZSBjYXNlIHdoZW4gc291cmNlIGFuZCBkZXN0aW5hdGlvbiBhcmUgdGhlIHNhbWUgb2JqZWN0OiByZWxhdGVkIGNvbXBvbmVudHMgY2FuIGJyZWFrIGVhY2ggb3RoZXJcclxuICAgIHYgPSAodiA9PT0gZHN0KSA/IGNvcHkodikgOiB2O1xyXG4gICAgZHN0LnggPSB2LnggKiBjb3MgLSB2LnkgKiBzaW47XHJcbiAgICBkc3QueSA9IHYueCAqIHNpbiArIHYueSAqIGNvcztcclxuICAgIGRzdC56ID0gdi56O1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG5leHBvcnQgY29uc3QgWF9BWElTID0ge1xyXG4gICAgb3JpZ2luOiBPUklHSU4sXHJcbiAgICB0YW5nZW50OiBQT1NJVElWRV9YXHJcbn07XHJcbmV4cG9ydCBjb25zdCBZX0FYSVMgPSB7XHJcbiAgICBvcmlnaW46IE9SSUdJTixcclxuICAgIHRhbmdlbnQ6IFBPU0lUSVZFX1lcclxufTtcclxuZXhwb3J0IGNvbnN0IFpfQVhJUyA9IHtcclxuICAgIG9yaWdpbjogT1JJR0lOLFxyXG4gICAgdGFuZ2VudDogUE9TSVRJVkVfWlxyXG59O1xyXG5leHBvcnQgY29uc3QgWFkgPSB7XHJcbiAgICBub3JtYWw6IFBPU0lUSVZFX1osXHJcbiAgICBkaXN0YW5jZTogMFxyXG59O1xyXG5leHBvcnQgY29uc3QgWVogPSB7XHJcbiAgICBub3JtYWw6IFBPU0lUSVZFX1gsXHJcbiAgICBkaXN0YW5jZTogMFxyXG59O1xyXG5leHBvcnQgY29uc3QgWlggPSB7XHJcbiAgICBub3JtYWw6IFBPU0lUSVZFX1ksXHJcbiAgICBkaXN0YW5jZTogMFxyXG59O1xyXG4vKipcclxuICogQ29tcHV0ZXMgaW50ZXJzZWN0aW9uIG9mIGEgcGxhbmUgYW5kIGEgbGluZS5cclxuICpcclxuICogQHBhcmFtIHAgVGhlIHBsYW5lLlxyXG4gKiBAcGFyYW0gbCBUaGUgbGluZS5cclxuICogQHJldHVybnMgVGhlIHBvaW50IG9yIGBudWxsYCBpZiB0aGUgbGluZSBpcyBwYXJhbGxlbCB0byB0aGUgcGxhbmUuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGxhbmVMaW5lSW50ZXJzZWN0aW9uKHAsIGwpIHtcclxuICAgIGNvbnN0IGRvdExQID0gZG90KGwudGFuZ2VudCwgcC5ub3JtYWwpO1xyXG4gICAgLy8gSWYgcGxhbmUgbm9ybWFsIGFuZCBsaW5lIHRhbmdlbnQgdmVjdG9yIGFyZSBwZXJwZW5kaWN1bGFyIGludGVyc2VjdGlvbiBpc1xyXG4gICAgLy8gZWl0aGVyIGFuIGVtcHR5IHNldCBvciB0aGUgbGluZSBpdHNlbGYuXHJcbiAgICBpZiAoZG90TFAgPT09IDApIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGNvbnN0IGludGVyc2VjdGlvbiA9IGNvcHkobC50YW5nZW50KTtcclxuICAgIG11bG4oaW50ZXJzZWN0aW9uLCAocC5kaXN0YW5jZSAtIGRvdChwLm5vcm1hbCwgbC5vcmlnaW4pKSAvIGRvdExQLCBpbnRlcnNlY3Rpb24pO1xyXG4gICAgYWRkKGludGVyc2VjdGlvbiwgbC5vcmlnaW4sIGludGVyc2VjdGlvbik7XHJcbiAgICByZXR1cm4gaW50ZXJzZWN0aW9uO1xyXG59XHJcbi8qKlxyXG4gKiBDb21wdXRlcyBhbiBpbnRlcnNlY3Rpb24gb2YgYSBwbGFuZSBhbmQgYSByYXkgYW5kIHN0b3JlcyBpdCBpbnRvIGEgZ2l2ZW5cclxuICogdmVjdG9yLlxyXG4gKlxyXG4gKiBAcGFyYW0gcGxhbmUgVGhlIHBsYW5lLlxyXG4gKiBAcGFyYW0gcmF5IFRoZSByYXkuXHJcbiAqIEBwYXJhbSBkc3QgVGhlIHZlY3RvciB0aGUgaW50ZXJzZWN0aW9uIHBvaW50IHdpbGwgYmUgc3RvcmVkIHRvLiBJZiB0aGVyZSdzIG5vXHJcbiAqICAgICAgaW50ZXJzZWN0aW9uLCB0aGlzIHZlY3RvciB3aWxsIGJlIGxlZnQgdW5tb2RpZmllZC5cclxuICogQHJldHVybnMgVGhlIGBkc3RgIG9yIGBudWxsYCBpZiB0aGUgcmF5IGRvZXNuJ3QgaGF2ZSBhIGNvbW1vbiBwb2ludCB3aXRoIHRoZVxyXG4gKiAgICAgIHBsYW5lLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFBsYW5lUmF5SW50ZXJzZWN0aW9uKHBsYW5lLCByYXksIGRzdCA9IGNyZWF0ZSgwLCAwLCAwKSkge1xyXG4gICAgY29uc3QgZG90UlAgPSBkb3QocmF5LmRpcmVjdGlvbiwgcGxhbmUubm9ybWFsKTtcclxuICAgIGlmIChkb3RSUCA9PT0gMCkge1xyXG4gICAgICAgIC8vIFRoZSBwbGFuZSBub3JtYWwgYW5kIHRoZSByYXkgZGlyZWN0aW9uIHZlY3RvciBhcmUgcGVycGVuZGljdWxhciwgc29cclxuICAgICAgICAvLyBpbnRlcnNlY3Rpb24gaXMgZWl0aGVyIGFuIGVtcHR5IHNldCBvciB0aGUgcmF5IGl0c2VsZi5cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGNvbnN0IGxhbWJkYSA9IChwbGFuZS5kaXN0YW5jZSAtIGRvdChwbGFuZS5ub3JtYWwsIHJheS5vcmlnaW4pKSAvIGRvdFJQO1xyXG4gICAgaWYgKGxhbWJkYSA8IDApIHtcclxuICAgICAgICAvLyBUaGUgaW50ZXJzZWN0aW9uIHBvaW50IGlzIG9uIGEgbGluZSB0aGF0IGNvbnRhaW5zIHRoZSByYXksIGJ1dCBub3Qgb25cclxuICAgICAgICAvLyB0aGUgcmF5IGl0c2VsZi5cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGNvcHkocmF5LmRpcmVjdGlvbiwgZHN0KTtcclxuICAgIG11bG4oZHN0LCBsYW1iZGEsIGRzdCk7XHJcbiAgICBhZGQoZHN0LCByYXkub3JpZ2luLCBkc3QpO1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogQ29tcHV0ZXMgaW50ZXJzZWN0aW9uIG9mIHR3byBwbGFuZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSBwMSBUaGUgZmlyc3QgcGxhbmUuXHJcbiAqIEBwYXJhbSBwMiBUaGUgc2Vjb25kIHBsYW5lLlxyXG4gKiBAcmV0dXJucyBUaGUgbGluZSBvciBgbnVsbGAgaWYgdGhlIHBsYW5lcyBhcmUgcGFyYWxsZWwgdG8gZWFjaCBvdGhlci5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRQbGFuZVBsYW5lSW50ZXJzZWN0aW9uKHAxLCBwMikge1xyXG4gICAgY29uc3QgbjEgPSBwMS5ub3JtYWw7XHJcbiAgICBjb25zdCBuMiA9IHAyLm5vcm1hbDtcclxuICAgIGlmIChhcmVDb2xsaW5lYXIobjEsIG4yKSkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgY29uc3QgdGFuZ2VudCA9IGNyb3NzKG4xLCBuMik7XHJcbiAgICBub3JtYWxpemUodGFuZ2VudCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHRhbmdlbnQsXHJcbiAgICAgICAgb3JpZ2luOiBtYXRyaXgzLnNvbHZlKG1hdHJpeDMuZnJvbVJvd3MobjEsIG4yLCB0YW5nZW50KSwgY3JlYXRlKHAxLmRpc3RhbmNlLCBwMi5kaXN0YW5jZSwgMCkpXHJcbiAgICB9O1xyXG59XHJcbiIsImltcG9ydCAqIGFzIHZlY3RvcjMgZnJvbSAnLi92ZWN0b3IzJztcclxuY29uc3QgTUFUUklYX1NJWkUgPSA5O1xyXG4vKipcclxuICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIG5ldyAqKnVuaW5pdGlhbGl6ZWQqKiBtYXRyaXguXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKCkge1xyXG4gICAgcmV0dXJuIG5ldyBBcnJheShNQVRSSVhfU0laRSk7XHJcbn1cclxuLyoqXHJcbiAqIFplcm9lcyBhIG1hdHJpeC5cclxuICpcclxuICogQHBhcmFtIGRzdCBUaGUgbWF0cml4LlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB6ZXJvKGRzdCA9IGNyZWF0ZSgpKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1BVFJJWF9TSVpFOyArK2kpIHtcclxuICAgICAgICBkc3RbaV0gPSAwO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogQ29waWVzIHRocmVlIHZlY3RvcnMgdG8gYSBtYXRyaXggYXMgcm93cy5cclxuICpcclxuICogQHBhcmFtIHIwIFRoZSBmaXJzdCByb3cuXHJcbiAqIEBwYXJhbSByMSBUaGUgc2Vjb25kIHJvdy5cclxuICogQHBhcmFtIHIyIFRoZSB0aGlyZCByb3cuXHJcbiAqIEBwYXJhbSBkc3QgVGhlIG1hdHJpeCB0aGUgcm93cyB3aWxsIGJlIHdyaXR0ZW4gdG8uXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGZyb21Sb3dzKHIwLCByMSwgcjIsIGRzdCA9IGNyZWF0ZSgpKSB7XHJcbiAgICBkc3RbMF0gPSByMC54O1xyXG4gICAgZHN0WzFdID0gcjEueDtcclxuICAgIGRzdFsyXSA9IHIyLng7XHJcbiAgICBkc3RbM10gPSByMC55O1xyXG4gICAgZHN0WzRdID0gcjEueTtcclxuICAgIGRzdFs1XSA9IHIyLnk7XHJcbiAgICBkc3RbNl0gPSByMC56O1xyXG4gICAgZHN0WzddID0gcjEuejtcclxuICAgIGRzdFs4XSA9IHIyLno7XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFycmF5IG9mIGNvbHVtbnMgb2YgYSBtYXRyaXguXHJcbiAqXHJcbiAqIEBwYXJhbSBtIFRoZSBtYXRyaXguXHJcbiAqIEBwYXJhbSBkc3QgVGhlIGFycmF5IGNvbHVtbnMgb2YgdGhlIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gdG8uXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbHVtbnMobSwgZHN0ID0gW1xyXG4gICAgdmVjdG9yMy5jcmVhdGUoMCwgMCwgMCksXHJcbiAgICB2ZWN0b3IzLmNyZWF0ZSgwLCAwLCAwKSxcclxuICAgIHZlY3RvcjMuY3JlYXRlKDAsIDAsIDApXHJcbl0pIHtcclxuICAgIGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IDM7ICsraSwgaiArPSAzKSB7XHJcbiAgICAgICAgZHN0W2ldLnggPSBtW2pdO1xyXG4gICAgICAgIGRzdFtpXS55ID0gbVtqICsgMV07XHJcbiAgICAgICAgZHN0W2ldLnogPSBtW2ogKyAyXTtcclxuICAgIH1cclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIENvcGllcyB0aHJlZSB2ZWN0b3JzIHRvIGEgbWF0cml4IGFzIGNvbHVtbnMuXHJcbiAqXHJcbiAqIEBwYXJhbSBjMCBUaGUgZmlyc3QgY29sdW1uLlxyXG4gKiBAcGFyYW0gYzEgVGhlIHNlY29uZCBjb2x1bW4uXHJcbiAqIEBwYXJhbSBjMiBUaGUgdGhpcmQgY29sdW1uLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSBtYXRyaXggdGhlIGNvbHVtbnMgd2lsbCBiZSB3cml0dGVuIHRvLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBmcm9tQ29sdW1ucyhjMCwgYzEsIGMyLCBkc3QgPSBjcmVhdGUoKSkge1xyXG4gICAgZHN0WzBdID0gYzAueDtcclxuICAgIGRzdFsxXSA9IGMwLnk7XHJcbiAgICBkc3RbMl0gPSBjMC56O1xyXG4gICAgZHN0WzNdID0gYzEueDtcclxuICAgIGRzdFs0XSA9IGMxLnk7XHJcbiAgICBkc3RbNV0gPSBjMS56O1xyXG4gICAgZHN0WzZdID0gYzIueDtcclxuICAgIGRzdFs3XSA9IGMyLnk7XHJcbiAgICBkc3RbOF0gPSBjMi56O1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogQ29tcHV0ZXMgZGV0ZXJtaW5hbnQgb2YgYSBtYXRyaXguXHJcbiAqXHJcbiAqIEBwYXJhbSBtIFRoZSBtYXRyaXguXHJcbiAqIEByZXR1cm5zIFRoZSBkZXRlcm1pbmFudC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBkZXRlcm1pbmFudChtKSB7XHJcbiAgICByZXR1cm4gbVswXSAqIChtWzRdICogbVs4XSAtIG1bN10gKiBtWzVdKSArXHJcbiAgICAgICAgbVszXSAqIChtWzFdICogbVs4XSAtIG1bN10gKiBtWzJdKSArXHJcbiAgICAgICAgbVs2XSAqIChtWzFdICogbVs1XSAtIG1bNF0gKiBtWzJdKTtcclxufVxyXG5jb25zdCBzdGF0aWNNYXRyaXhDb2x1bW5zID0gW1xyXG4gICAgLy8gTm90IHVzaW5nIHZlY3RvcjMuY3JlYXRlIGhlcmUgZHVlIHRvIGNpcmN1bGFyIGRlcGVuZGVuY3kuXHJcbiAgICB7IHg6IDAsIHk6IDAsIHo6IDAgfSxcclxuICAgIHsgeDogMCwgeTogMCwgejogMCB9LFxyXG4gICAgeyB4OiAwLCB5OiAwLCB6OiAwIH1cclxuXTtcclxuY29uc3Qgc3RhdGljTWF0cml4ID0gY3JlYXRlKCk7XHJcbi8qKlxyXG4gKiBTb2x2ZXMgYSBzeXN0ZW0gb2YgbGluZWFyIGVxdWF0aW9ucyByZXByZXNlbnRlZCB3aXRoIGEgbWF0cml4IGFuZCBhIHZlY3RvcixcclxuICogaS5lLjpcclxuICpcclxuICogYGBgXHJcbiAqIG0gKiAoeCwgeSAseileVCA9IHZcclxuICogYGBgXHJcbiAqXHJcbiAqIFVzZXMgQ3JhbWVyJ3MgcnVsZS5cclxuICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DcmFtZXInc19ydWxlXHJcbiAqXHJcbiAqIEBwYXJhbSBtIFRoZSBtYXRyaXggb2YgdGhlIHN5c3RlbS5cclxuICogQHBhcmFtIHYgVGhlIHZlY3RvciBvZiB0aGUgc3lzdGVtLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSB2ZWN0b3Igc29sdXRpb24gb2YgdGhlIHN5c3RlbSB3aWxsIGJlIHdyaXR0ZW4gdG8uXHJcbiAqIEByZXR1cm4gYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc29sdmUobSwgdiwgZHN0ID0gdmVjdG9yMy5jcmVhdGUoMCwgMCwgMCkpIHtcclxuICAgIGNvbnN0IHJldkRldCA9IDEgLyBkZXRlcm1pbmFudChtKTtcclxuICAgIGNvbnN0IFtjMCwgYzEsIGMyXSA9IGNvbHVtbnMobSwgc3RhdGljTWF0cml4Q29sdW1ucyk7XHJcbiAgICBkc3QueCA9IHJldkRldCAqIGRldGVybWluYW50KGZyb21Db2x1bW5zKHYsIGMxLCBjMiwgc3RhdGljTWF0cml4KSk7XHJcbiAgICBkc3QueSA9IHJldkRldCAqIGRldGVybWluYW50KGZyb21Db2x1bW5zKGMwLCB2LCBjMiwgc3RhdGljTWF0cml4KSk7XHJcbiAgICBkc3QueiA9IHJldkRldCAqIGRldGVybWluYW50KGZyb21Db2x1bW5zKGMwLCBjMSwgdiwgc3RhdGljTWF0cml4KSk7XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbiIsImV4cG9ydCBjb25zdCBERUZBVUxUX1RPTEVSQU5DRSA9IDFlLTY7XHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgdHdvIGZsb2F0aW5nIHBvaW50IG51bWJlciBhcmUgd2l0aGluIGEgdG9sZXJhbmNlIGZyb20gZWFjaCBvdGhlci5cclxuICpcclxuICogQHBhcmFtIGEgVGhlIGZpcnN0IG51bWJlci5cclxuICogQHBhcmFtIGIgVGhlIHNlY29uZCBudW1iZXIuXHJcbiAqIEBwYXJhbSB0b2xlcmFuY2UgVGhlIHRvbGVyYW5jZS5cclxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBudW1iZXIgYXJlIHdpdGhpbiB0aGUgdG9sZXJhbmNlIGFuZCBgZmFsc2VgIG90aGVyd2lzZS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFyZUZ1enp5RXF1YWwoYSwgYiwgdG9sZXJhbmNlID0gREVGQVVMVF9UT0xFUkFOQ0UpIHtcclxuICAgIGNvbnN0IGQgPSBhIC0gYjtcclxuICAgIHJldHVybiAtdG9sZXJhbmNlIDwgZCAmJiBkIDwgdG9sZXJhbmNlO1xyXG59XHJcbiIsImltcG9ydCBhcmVGdXp6eUVxdWFsU2NhbGFyLCB7IERFRkFVTFRfVE9MRVJBTkNFIH0gZnJvbSAnLi4vdXRpbC9mdXp6eV9lcXVhbCc7XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IHZlY3RvciBhbmQgaW5pdGlhbGl6ZXMgaXQgd2l0aCBnaXZlbiBjb21wb25lbnRzLlxyXG4gKlxyXG4gKiBAcGFyYW0geCBYIGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yLlxyXG4gKiBAcGFyYW0geSBZIGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yLlxyXG4gKiBAcmV0dXJucyBUaGUgdmVjdG9yLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSh4LCB5KSB7XHJcbiAgICByZXR1cm4geyB4LCB5IH07XHJcbn1cclxuZXhwb3J0IGNvbnN0IFpFUk8gPSBjcmVhdGUoMCwgMCk7XHJcbmV4cG9ydCBjb25zdCBPUklHSU4gPSBaRVJPO1xyXG5leHBvcnQgY29uc3QgUE9TSVRJVkVfWCA9IGNyZWF0ZSgxLCAwKTtcclxuZXhwb3J0IGNvbnN0IE5FR0FUSVZFX1ggPSBjcmVhdGUoLTEsIDApO1xyXG5leHBvcnQgY29uc3QgUE9TSVRJVkVfWSA9IGNyZWF0ZSgwLCAxKTtcclxuZXhwb3J0IGNvbnN0IE5FR0FUSVZFX1kgPSBjcmVhdGUoMCwgLTEpO1xyXG4vKipcclxuICogQ29waWVzIGEgdmVjdG9yIHRvIGFub3RoZXIgb25lLlxyXG4gKlxyXG4gKiBAcGFyYW0gc3JjIFRoZSBzb3VyY2UgdmVjdG9yLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSB2ZWN0b3IgdGhlIHNvdXJjZSB2ZWN0b3Igd2lsbCBiZSBjb3BpZWQgdG8uXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvcHkoc3JjLCBkc3QgPSBjcmVhdGUoMCwgMCkpIHtcclxuICAgIGRzdC54ID0gc3JjLng7XHJcbiAgICBkc3QueSA9IHNyYy55O1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogQ2hlY2tzIGlmIHR3byB2ZWN0b3JzIGFyZSBzdHJpY3RseSBlcXVhbCBjb21wb25lbnQtd2lzZS5cclxuICpcclxuICogQHBhcmFtIHYxIFRoZSBmaXJzdCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSB2MiBUaGUgc2Vjb25kIHZlY3Rvci5cclxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYXJlRXF1YWwodjEsIHYyKSB7XHJcbiAgICByZXR1cm4gdjEueCA9PT0gdjIueCAmJiB2MS55ID09PSB2Mi55O1xyXG59XHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgdHdvIHZlY3RvcnMgYXJlIGNvbGxpbmVhci5cclxuICpcclxuICogQHBhcmFtIHYxIFRoZSBmaXJzdCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSB2MiBUaGUgc2Vjb25kIHZlY3Rvci5cclxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB2ZWN0b3JzIGFyZSBjb2xsaW5lYXIgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGFyZUNvbGxpbmVhcih2MSwgdjIpIHtcclxuICAgIHJldHVybiB2MS54IC8gdjIueCA9PT0gdjEueSAvIHYyLnk7XHJcbn1cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBjb3JyZXNwb25kaW5nIGNvbXBvbmVudHMgb2YgdHdvIHZlY3RvcnMgYXJlIGFsbCB3aXRoaW4gZ2l2ZW5cclxuICogdG9sZXJhbmNlIGZyb20gZWFjaCBvdGhlci5cclxuICpcclxuICogQHBhcmFtIHYxIFRoZSBmaXJzdCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSB2MiBUaGUgc2Vjb25kIHZlY3Rvci5cclxuICogQHBhcmFtIHRvbGVyYW5jZSBUaGUgdG9sZXJhbmNlLlxyXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZlY3RvcnMgYXJlIFwiZnV6enlcIiBlcXVhbCBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYXJlRnV6enlFcXVhbCh2MSwgdjIsIHRvbGVyYW5jZSA9IERFRkFVTFRfVE9MRVJBTkNFKSB7XHJcbiAgICByZXR1cm4gKGFyZUZ1enp5RXF1YWxTY2FsYXIodjEueCwgdjIueCwgdG9sZXJhbmNlKSAmJlxyXG4gICAgICAgIGFyZUZ1enp5RXF1YWxTY2FsYXIodjEueSwgdjIueSwgdG9sZXJhbmNlKSk7XHJcbn1cclxuLyoqXHJcbiAqIEFkZHMgdHdvIHZlY3RvciBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW50byBhIHRoaXJkIG9uZSwgaS5lLiBgZHN0ID0gYSArIGJgLlxyXG4gKlxyXG4gKiBAcGFyYW0gYSBUaGUgZmlyc3QgdmVjdG9yLlxyXG4gKiBAcGFyYW0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cclxuICogQHBhcmFtIGRzdCBUaGUgdmVjdG9yIHRoZSByZXN1bHQgd2lsbCBiZSBzdG9yZWQgdG8uXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGFkZChhLCBiLCBkc3QgPSBjcmVhdGUoMCwgMCkpIHtcclxuICAgIGRzdC54ID0gYS54ICsgYi54O1xyXG4gICAgZHN0LnkgPSBhLnkgKyBiLnk7XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbi8qKlxyXG4gKiBTdWJ0cmFjdHMgYSB2ZWN0b3IgZnJvbSBhbm90aGVyIG9uZSBhbmQgc3RvcmVzIHRoZSByZXN1bHQgdG8gYSB0aGlyZCBvbmUsIGkuZS5cclxuICogYGRzdCA9IGEgLSBiYC5cclxuICpcclxuICogQHBhcmFtIGEgVGhlIG1pbnVlbmQgdmVjdG9yLlxyXG4gKiBAcGFyYW0gYiBUaGUgc3VidHJhaGVuZCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBkc3QgVGhlIHZlY3RvciB0aGUgcmVzdWx0IHdpbGwgYmUgc3RvcmVkIHRvLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzdWIoYSwgYiwgZHN0ID0gY3JlYXRlKDAsIDApKSB7XHJcbiAgICBkc3QueCA9IGEueCAtIGIueDtcclxuICAgIGRzdC55ID0gYS55IC0gYi55O1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogTXVsdGlwbGllcyB0d28gdmVjdG9ycyBjb21wb25lbnQtd2lzZSBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW50byBhIHRoaXJkIG9uZS5cclxuICpcclxuICogQHBhcmFtIGEgVGhlIGZpcnN0IHZlY3Rvci5cclxuICogQHBhcmFtIGIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBkc3QgVGhlIHZlY3RvciB0aGUgcmVzdWx0IHdpbGwgYmUgc3RvcmVkIHRvLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBtdWx2KGEsIGIsIGRzdCA9IGNyZWF0ZSgwLCAwKSkge1xyXG4gICAgZHN0LnggPSBhLnggKiBiLng7XHJcbiAgICBkc3QueSA9IGEueSAqIGIueTtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIE11bHRpcGxpZXMgYSB2ZWN0b3IgYnkgYSBzY2FsYXIgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGludG8gYSB0aGlyZCB2ZWN0b3IuXHJcbiAqXHJcbiAqIEBwYXJhbSBhIFRoZSB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBuIFRoZSBzY2FsYXIuXHJcbiAqIEBwYXJhbSBkc3QgVGhlIHZlY3RvciB0aGUgcmVzdWx0IHdpbGwgYmUgc3RvcmVkIHRvLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBtdWxuKGEsIG4sIGRzdCA9IGNyZWF0ZSgwLCAwKSkge1xyXG4gICAgZHN0LnggPSBhLnggKiBuO1xyXG4gICAgZHN0LnkgPSBhLnkgKiBuO1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogRGl2aWRlcyBhIHZlY3RvciBieSBhbm90aGVyIG9uZSBjb21wb25lbnQgd2lzZSBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW50byBhXHJcbiAqIHRoaXJkIG9uZS5cclxuICpcclxuICogQHBhcmFtIGEgVGhlIGRpdmlkZW5kIHZlY3Rvci5cclxuICogQHBhcmFtIGIgVGhlIGRpdmlzb3IgdmVjdG9yLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSB2ZWN0b3IgdGhlIHJlc3VsdCB3aWxsIGJlIHN0b3JlZCB0by5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZGl2dihhLCBiLCBkc3QgPSBjcmVhdGUoMCwgMCkpIHtcclxuICAgIGRzdC54ID0gYS54IC8gYi54O1xyXG4gICAgZHN0LnkgPSBhLnkgLyBiLnk7XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbi8qKlxyXG4gKiBEaXZpZGVzIGEgdmVjdG9yIGJ5IGEgc2NhbGFyIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbnRvIGEgdGhpcmQgdmVjdG9yLlxyXG4gKlxyXG4gKiBAcGFyYW0gYSBUaGUgZGl2aWRlbmQgdmVjdG9yLlxyXG4gKiBAcGFyYW0gbiBUaGUgc2NhbGFyLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSB2ZWN0b3IgdGhlIHJlc3VsdCB3aWxsIGJlIHN0b3JlZCB0by5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZGl2bihhLCBuLCBkc3QgPSBjcmVhdGUoMCwgMCkpIHtcclxuICAgIGRzdC54ID0gYS54IC8gbjtcclxuICAgIGRzdC55ID0gYS55IC8gbjtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIHJlbWluZGVyIGFmdGVyIGRpdmlzaW9uIG9mIGEncyBjb21wb25lbnRzIGJ5IG4gYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGludG8gYSB0aGlyZCB2ZWN0b3IuXHJcbiAqXHJcbiAqIEBwYXJhbSBhIFRoZSBkaXZpZGVuZCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBuIFRoZSBzY2FsYXIuXHJcbiAqIEBwYXJhbSBkc3QgVGhlIHZlY3RvciB0aGUgcmVzdWx0IHdpbGwgYmUgc3RvcmVkIHRvLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBtb2QoYSwgbiwgZHN0ID0gY3JlYXRlKDAsIDApKSB7XHJcbiAgICBkc3QueCA9IGEueCAlIG47XHJcbiAgICBkc3QueSA9IGEueSAlIG47XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbi8qKlxyXG4gKiBMaW5lYXJseSBpbnRlcnBvbGF0ZXMgYmV0d2VlbiB0d28gdmVjdG9ycywgaS5lLiBjb21wdXRlc1xyXG4gKiBgKDEgLSBmYWN0b3IpICogYSArIGZhY3RvciAqIGJgLCBhbmQgd3JpdGVzIHRoZSByZXN1bHQgaW50byBhIHRoaXJkIHZlY3Rvci5cclxuICpcclxuICogQHBhcmFtIGEgVGhlIGZpcnN0IHZlY3Rvci5cclxuICogQHBhcmFtIGIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBmYWN0b3IgVGhlIGludGVycG9sYXRpb24gZmFjdG9yLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSB2ZWN0b3IgdGhlIHJlc3VsdCB3aWxsIGJlIHdyaXR0ZW4gdG8uXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG1peChhLCBiLCBmYWN0b3IsIGRzdCA9IGNyZWF0ZSgwLCAwKSkge1xyXG4gICAgZHN0LnggPSAoMSAtIGZhY3RvcikgKiBhLnggKyBmYWN0b3IgKiBiLng7XHJcbiAgICBkc3QueSA9ICgxIC0gZmFjdG9yKSAqIGEueSArIGZhY3RvciAqIGIueTtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIFJvdGF0ZXMgYSB2ZWN0b3IgYnkgYSBnaXZlbiBhbmdsZSBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW50byBhIHNlY29uZCB2ZWN0b3IuXHJcbiAqIFBvc2l0aXZlIGRpcmVjdGlvbiBpcyBmcm9tICtYIHRvICtZLlxyXG4gKlxyXG4gKiBAcGFyYW0gdiBUaGUgdmVjdG9yIHRvIHJvdGF0ZS5cclxuICogQHBhcmFtIGFuZ2xlIFRoZSBhbmdsZSBvZiByb3RhdGlvbi5cclxuICogQHBhcmFtIGRzdCBUaGUgdmVjdG9yIHRoZSByZXN1bHQgd2lsbCBiZSBzdG9yZWQgdG8uXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZSh2LCBhbmdsZSwgZHN0ID0gY3JlYXRlKDAsIDApKSB7XHJcbiAgICBjb25zdCB4ID0gdi54O1xyXG4gICAgY29uc3QgeSA9IHYueTtcclxuICAgIGNvbnN0IGFuZ2xlQ29zID0gTWF0aC5jb3MoYW5nbGUpO1xyXG4gICAgY29uc3QgYW5nbGVTaW4gPSBNYXRoLnNpbihhbmdsZSk7XHJcbiAgICBkc3QueCA9IGFuZ2xlQ29zICogeCAtIGFuZ2xlU2luICogeTtcclxuICAgIGRzdC55ID0gYW5nbGVTaW4gKiB4ICsgYW5nbGVDb3MgKiB5O1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogUm90YXRlcyBhIHZlY3RvciBieSA0NSBkZWdyZWVzIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbnRvIGEgc2Vjb25kIHZlY3Rvci5cclxuICogQW5hbG9nb3VzIHRvIGByb3RhdGUodiwgTWF0aC5QSSAvIDQsIGRzdClgLCBidXQgZmFzdGVyLlxyXG4gKlxyXG4gKiBAcGFyYW0gdiBUaGUgdmVjdG9yIHRvIHJvdGF0ZS5cclxuICogQHBhcmFtIGRzdCBUaGUgdmVjdG9yIHRoZSByZXN1bHQgd2lsbCBiZSBzdG9yZWQgdG8uXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZTQ1KHYsIGRzdCA9IGNyZWF0ZSgwLCAwKSkge1xyXG4gICAgY29uc3QgeSA9IHYueTtcclxuICAgIGNvbnN0IHMgPSBNYXRoLlNRUlQxXzI7XHJcbiAgICBkc3QueSA9IHMgKiB2LnggKyBzICogdi55O1xyXG4gICAgZHN0LnggPSBzICogdi54IC0gcyAqIHk7XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbi8qKlxyXG4gKiBSb3RhdGVzIGEgdmVjdG9yIGJ5IDkwIGRlZ3JlZXMgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGludG8gYSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBBbmFsb2dvdXMgdG8gYHJvdGF0ZSh2LCBNYXRoLlBJIC8gMiwgZHN0KWAsIGJ1dCBmYXN0ZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB2IFRoZSB2ZWN0b3IgdG8gcm90YXRlLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSB2ZWN0b3IgdGhlIHJlc3VsdCB3aWxsIGJlIHN0b3JlZCB0by5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlOTAodiwgZHN0ID0gY3JlYXRlKDAsIDApKSB7XHJcbiAgICBjb25zdCB5ID0gdi55O1xyXG4gICAgZHN0LnkgPSB2Lng7XHJcbiAgICBkc3QueCA9IC15O1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogUm90YXRlcyBhIHZlY3RvciBieSAtOTAgZGVncmVlcyBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW50byBhIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEFuYWxvZ291cyB0byBgcm90YXRlKHYsIC1NYXRoLlBJIC8gMiwgZHN0KWAsIGJ1dCBmYXN0ZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB2IFRoZSB2ZWN0b3IgdG8gcm90YXRlLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSB2ZWN0b3IgdGhlIHJlc3VsdCB3aWxsIGJlIHN0b3JlZCB0by5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlTmVnOTAodiwgZHN0ID0gY3JlYXRlKDAsIDApKSB7XHJcbiAgICBjb25zdCB5ID0gdi55O1xyXG4gICAgZHN0LnkgPSAtdi54O1xyXG4gICAgZHN0LnggPSB5O1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogSW52ZXJ0cyBzaWducyBvZiBjb21wb25lbnRzIG9mIGEgdmVjdG9yIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbnRvIGEgc2Vjb25kXHJcbiAqIHZlY3Rvci4gQW5hbG9nb3VzIHRvIGByb3RhdGUodiwgTWF0aC5QSSwgZHN0KWAgKG9yIGByb3RhdGUodiwgLU1hdGguUEksIGRzdClgLFxyXG4gKiB3aGljaCBpcyB0aGUgc2FtZSksIGJ1dCBmYXN0ZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB2IFRoZSB2ZWN0b3IgdG8gaW52ZXJ0LlxyXG4gKiBAcGFyYW0gZHN0IFRoZSB2ZWN0b3IgdGhlIHJlc3VsdCB3aWxsIGJlIHN0b3JlZCB0by5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJ0KHYsIGRzdCA9IGNyZWF0ZSgwLCAwKSkge1xyXG4gICAgZHN0LnggPSAtdi54O1xyXG4gICAgZHN0LnkgPSAtdi55O1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogQ29tcHV0ZXMgbGVuZ3RoIG9mIGEgdmVjdG9yLlxyXG4gKlxyXG4gKiBAcGFyYW0gdiBUaGUgdmVjdG9yLlxyXG4gKiBAcmV0dXJucyBUaGUgbGVuZ3RoLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGxlbmd0aCh2KSB7XHJcbiAgICByZXR1cm4gTWF0aC5oeXBvdCh2LngsIHYueSk7XHJcbn1cclxuLyoqXHJcbiAqIENvbXB1dGVzIGRpc3RhbmNlIGJldHdlZW4gZW5kcyBvZiB0d28gdmVjdG9ycy5cclxuICpcclxuICogQHBhcmFtIGEgVGhlIGZpcnN0IHZlY3Rvci5cclxuICogQHBhcmFtIGIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEByZXR1cm5zIFRoZSBkaXN0YW5jZSwgaS5lLiBgbGVuZ3RoKHN1YihhLCBiKSlgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRpc3RhbmNlKGEsIGIpIHtcclxuICAgIHJldHVybiBNYXRoLmh5cG90KGEueCAtIGIueCwgYS55IC0gYi55KTtcclxufVxyXG4vKipcclxuICogRGl2aWRlcyBhIHZlY3RvciBieSBpdHMgbGVuZ3RoICh0aHVzIG1ha2luZyBpdCBhIHVuaXQgdmVjdG9yKSBhbmQgc3RvcmVzIHRoZVxyXG4gKiByZXN1bHQgdG8gYW5vdGhlciBvbmUuXHJcbiAqXHJcbiAqIEBwYXJhbSB2IFRoZSB2ZWN0b3IgdG8gYmUgbm9ybWFsaXplZC5cclxuICogQHBhcmFtIGRzdCBUaGUgdmVjdG9yIHRoZSByZXN1bHQgd2lsbCBiZSBzdG9yZWQgdG8uXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZSh2LCBkc3QgPSBjcmVhdGUoMCwgMCkpIHtcclxuICAgIHJldHVybiBkaXZuKHYsIGxlbmd0aCh2KSwgZHN0KTtcclxufVxyXG4vKipcclxuICogQ29udmVydHMgZWFjaCBjb21wb25lbnQgb2YgdmVjdG9yLlxyXG4gKlxyXG4gKiBAcGFyYW0gdiBUaGUgdmVjdG9yIHRvIGJlIGNvbnZlcnRlZC5cclxuICogQHBhcmFtIGNvbnZlcnRlciBUaGUgY29tcG9uZW50IGNvbnZlcnRlci5cclxuICogQHBhcmFtIGRzdCBUaGUgdmVjdG9yIHRoZSByZXN1bHQgd2lsbCBiZSBzdG9yZWQgdG8uXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnQodiwgY29udmVydGVyLCBkc3QgPSBjcmVhdGUoMCwgMCkpIHtcclxuICAgIGRzdC54ID0gY29udmVydGVyKHYueCk7XHJcbiAgICBkc3QueSA9IGNvbnZlcnRlcih2LnkpO1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogQ29tcHV0ZXMgZG90IHByb2R1Y3Qgb2YgdHdvIHZlY3RvcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSBhIFRoZSBmaXJzdCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBAcmV0dXJucyBUaGUgZG90IHByb2R1Y3QuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZG90KGEsIGIpIHtcclxuICAgIHJldHVybiBhLnggKiBiLnggKyBhLnkgKiBiLnk7XHJcbn1cclxuLyoqXHJcbiAqIENvbXB1dGVzIFotY29tcG9uZW50IG9mIGEgY3Jvc3MgcHJvZHVjdCBvZiB0d28gdmVjdG9ycy5cclxuICpcclxuICogQHBhcmFtIGEgVGhlIGZpcnN0IHZlY3Rvci5cclxuICogQHBhcmFtIGIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEByZXR1cm5zIFotY29tcG9uZW50IG9mIHRoZSBjcm9zcyBwcm9kdWN0LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNyb3NzWihhLCBiKSB7XHJcbiAgICByZXR1cm4gYS54ICogYi55IC0gYS55ICogYi54O1xyXG59XHJcbmV4cG9ydCBjb25zdCBFTVBUWSA9IHtcclxuICAgIG1pblg6IDAsXHJcbiAgICBtYXhYOiAwLFxyXG4gICAgbWluWTogMCxcclxuICAgIG1heFk6IDBcclxufTtcclxuZXhwb3J0IGNvbnN0IFVOSVRfQkJPWCA9IHtcclxuICAgIG1pblg6IC0xLFxyXG4gICAgbWF4WDogMSxcclxuICAgIG1pblk6IC0xLFxyXG4gICAgbWF4WTogMVxyXG59O1xyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBiYm94IGFuZCBpbml0aWFsaXplcyBpdCB3aXRoIGdpdmVuIGNvbXBvbmVudHMuXHJcbiAqXHJcbiAqIEBwYXJhbSBtaW5YIExlZnQgYm9yZGVyIG9mIHRoZSBiYm94LlxyXG4gKiBAcGFyYW0gbWF4WCBSaWdodCBib3JkZXIgb2YgdGhlIGJib3guXHJcbiAqIEBwYXJhbSBtaW5ZIExvd2VyIGJvcmRlciBvZiB0aGUgYmJveC5cclxuICogQHBhcmFtIG1heFkgVXBwZXIgYm9yZGVyIG9mIHRoZSBiYm94LlxyXG4gKiBAcmV0dXJucyBUaGUgYmJveC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVCQm94MihtaW5YLCBtYXhYLCBtaW5ZLCBtYXhZKSB7XHJcbiAgICByZXR1cm4geyBtaW5YLCBtYXhYLCBtaW5ZLCBtYXhZIH07XHJcbn1cclxuLyoqXHJcbiAqIENvcGllcyBhIGJib3ggdG8gYW5vdGhlciBvbmUuXHJcbiAqXHJcbiAqIEBwYXJhbSBzcmMgVGhlIHNvdXJjZSBiYm94LlxyXG4gKiBAcGFyYW0gZHN0IFRoZSBiYm94IHRoZSBzb3VyY2UgYmJveCB3aWxsIGJlIGNvcGllZCB0by5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29weUJCb3gyKHNyYywgZHN0ID0gY3JlYXRlQkJveDIoMCwgMCwgMCwgMCkpIHtcclxuICAgIGRzdC5taW5YID0gc3JjLm1pblg7XHJcbiAgICBkc3QubWF4WCA9IHNyYy5tYXhYO1xyXG4gICAgZHN0Lm1pblkgPSBzcmMubWluWTtcclxuICAgIGRzdC5tYXhZID0gc3JjLm1heFk7XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgdHdvIGJvdW5kaW5nIGJveGVzIG92ZXJsYXAuXHJcbiAqXHJcbiAqIEBwYXJhbSBiYm94MSBBIGJvdW5kaW5nIGJveC5cclxuICogQHBhcmFtIGJib3gyIEFub3RoZXIgYm91bmRpbmcgYm94LlxyXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgZ2l2ZW4gYm91bmRpbmcgYm94ZXMgZG8gb3ZlcmxhcCBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYmJveGVzT3ZlcmxhcChiYm94MSwgYmJveDIpIHtcclxuICAgIGxldCBsZWZ0QkJveDtcclxuICAgIGxldCByaWdodEJCb3g7XHJcbiAgICBpZiAoYmJveDEubWluWCA8IGJib3gyLm1pblgpIHtcclxuICAgICAgICBsZWZ0QkJveCA9IGJib3gxO1xyXG4gICAgICAgIHJpZ2h0QkJveCA9IGJib3gyO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbGVmdEJCb3ggPSBiYm94MjtcclxuICAgICAgICByaWdodEJCb3ggPSBiYm94MTtcclxuICAgIH1cclxuICAgIGxldCB0b3BCQm94O1xyXG4gICAgbGV0IGJvdHRvbUJCb3g7XHJcbiAgICBpZiAoYmJveDEubWF4WSA+IGJib3gyLm1heFkpIHtcclxuICAgICAgICB0b3BCQm94ID0gYmJveDE7XHJcbiAgICAgICAgYm90dG9tQkJveCA9IGJib3gyO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdG9wQkJveCA9IGJib3gyO1xyXG4gICAgICAgIGJvdHRvbUJCb3ggPSBiYm94MTtcclxuICAgIH1cclxuICAgIHJldHVybiByaWdodEJCb3gubWluWCA8IGxlZnRCQm94Lm1heFggJiYgYm90dG9tQkJveC5tYXhZID4gdG9wQkJveC5taW5ZO1xyXG59XHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYSAyRCBwb2ludCBsaWVzIGluc2lkZSBhIGJvdW5kaW5nIGJveCBvciBvbiBpdHMgYm9yZGVyLlxyXG4gKlxyXG4gKiBAcGFyYW0gcG9pbnQgVGhlIHBvaW50LlxyXG4gKiBAcGFyYW0gYmJveCBUaGUgYm91bmRpbmcgYm94LlxyXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHBvaW50IGlzIGluc2lkZSBvZiB0aGUgYm94IGFuZCBgZmFsc2VgIG90aGVyd2lzZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBwb2ludElzSW5CQm94KHBvaW50LCBiYm94KSB7XHJcbiAgICByZXR1cm4gYmJveC5taW5YIDw9IHBvaW50LnggJiYgcG9pbnQueCA8PSBiYm94Lm1heFggJiZcclxuICAgICAgICBiYm94Lm1pblkgPD0gcG9pbnQueSAmJiBwb2ludC55IDw9IGJib3gubWF4WTtcclxufVxyXG4vKipcclxuICogQ29tcHV0ZXMgYm91bmRpbmcgYm94IG9mIGFuIGFycmF5IG9mIHBvaW50cyBhbmQgc3RvcmVzIGl0IHRvIGEgZ2l2ZW4gb2JqZWN0LlxyXG4gKlxyXG4gKiBAcGFyYW0gcG9pbnRzIFRoZSBhcnJheSBvZiBwb2ludHMuXHJcbiAqIEBwYXJhbSBkc3QgVGhlIGJib3ggdGhlIHJlc3VsdCB3aWxsIGJlIHdyaXR0ZW4gdG8uIExlZnQgdW5tb2RpZmllZCBpZiB0aGUgYXJyYXlcclxuICogICAgICBvZiBwb2ludHMgaXMgZW1wdHkuXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVCQm94Rm9yUG9pbnRzKHBvaW50cywgZHN0ID0geyBtaW5YOiAwLCBtYXhYOiAwLCBtaW5ZOiAwLCBtYXhZOiAwIH0pIHtcclxuICAgIGlmIChwb2ludHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGRzdDtcclxuICAgIH1cclxuICAgIGRzdC5taW5YID0gZHN0Lm1heFggPSBwb2ludHNbMF0ueDtcclxuICAgIGRzdC5taW5ZID0gZHN0Lm1heFkgPSBwb2ludHNbMF0ueTtcclxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcG9pbnRzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBwb2ludHNbaV07XHJcbiAgICAgICAgaWYgKHggPCBkc3QubWluWCkge1xyXG4gICAgICAgICAgICBkc3QubWluWCA9IHg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh4ID4gZHN0Lm1heFgpIHtcclxuICAgICAgICAgICAgZHN0Lm1heFggPSB4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoeSA8IGRzdC5taW5ZKSB7XHJcbiAgICAgICAgICAgIGRzdC5taW5ZID0geTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHkgPiBkc3QubWF4WSkge1xyXG4gICAgICAgICAgICBkc3QubWF4WSA9IHk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG5leHBvcnQgY29uc3QgWF9BWElTID0ge1xyXG4gICAgb3JpZ2luOiBPUklHSU4sXHJcbiAgICB0YW5nZW50OiBQT1NJVElWRV9YXHJcbn07XHJcbmV4cG9ydCBjb25zdCBZX0FYSVMgPSB7XHJcbiAgICBvcmlnaW46IE9SSUdJTixcclxuICAgIHRhbmdlbnQ6IFBPU0lUSVZFX1lcclxufTtcclxuZXhwb3J0IGZ1bmN0aW9uIGdldExpbmVGcm9tUG9pbnRzKHAxLCBwMiwgZHN0ID0ge1xyXG4gICAgb3JpZ2luOiBjcmVhdGUoMCwgMCksXHJcbiAgICB0YW5nZW50OiBjcmVhdGUoMCwgMClcclxufSkge1xyXG4gICAgY29weShwMSwgZHN0Lm9yaWdpbik7XHJcbiAgICBzdWIocDIsIHAxLCBkc3QudGFuZ2VudCk7XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbi8qKlxyXG4gKiBDb21wdXRlcyBzaWduZWQgZGlzdGFuY2UgZnJvbSBhIHBvaW50IHRvIGEgbGluZS5cclxuICpcclxuICogQHBhcmFtIHAgVGhlIHBvaW50LlxyXG4gKiBAcGFyYW0gbDEgU3RhcnQgcG9pbnQgb2YgdGhlIGxpbmUuXHJcbiAqIEBwYXJhbSBsMiBFbmQgcG9pbnQgb2YgdGhlIGxpbmUuXHJcbiAqIEByZXR1cm5zIERpc3RhbmNlIGZyb20gdGhlIHBvaW50IHRvIHRoZSBsaW5lLiBJdCdsbCBiZSBncmVhdGVyIHRoYW4gMCBpZiB0aGVcclxuICogICAgICBwb2ludCBsaWVzIHRvIHRoZSBsZWZ0IG9mIHRoZSBsaW5lIGFuZCBsZXNzIHRoYW4gMCBvdGhlcndpc2UuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2lnbmVkRGlzdGFuY2VUb0xpbmUocCwgbCkge1xyXG4gICAgY29uc3QgdGFuZ2VudCA9IGwudGFuZ2VudDtcclxuICAgIHJldHVybiBkb3Qoc3ViKHAsIGwub3JpZ2luKSwgY3JlYXRlKC10YW5nZW50LnksIHRhbmdlbnQueCkpIC8gbGVuZ3RoKHRhbmdlbnQpO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IGV4dGVudCBhbmQgaW5pdGlhbGl6ZXMgaXQgd2l0aCBnaXZlbiBjb21wb25lbnRzLlxyXG4gKlxyXG4gKiBAcGFyYW0gd2lkdGggV2lkdGggb2YgdGhlIGV4dGVudC5cclxuICogQHBhcmFtIEhlaWdodCBIZWlnaHQgb2YgdGhlIGV4dGVudC5cclxuICogQHJldHVybnMgVGhlIGV4dGVudC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFeHRlbnQyKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgIHJldHVybiB7IHdpZHRoLCBoZWlnaHQgfTtcclxufVxyXG4vKipcclxuICogQ29waWVzIGFuIGV4dGVudCB0byBhbm90aGVyIG9uZS5cclxuICpcclxuICogQHBhcmFtIHNyYyBUaGUgc291cmNlIGJib3guXHJcbiAqIEBwYXJhbSBkc3QgVGhlIGV4dGVudCB0aGUgc291cmNlIGV4dGVudCB3aWxsIGJlIGNvcGllZCB0by5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29weUV4dGVudDIoc3JjLCBkc3QgPSBjcmVhdGVFeHRlbnQyKDAsIDApKSB7XHJcbiAgICBkc3Qud2lkdGggPSBzcmMud2lkdGg7XHJcbiAgICBkc3QuaGVpZ2h0ID0gc3JjLmhlaWdodDtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuIiwiaW1wb3J0IFRpbGVCYXNlZEFkYXB0ZXIgZnJvbSAnLi4vdGlsZV9iYXNlZF9hZGFwdGVyL2FkYXB0ZXInO1xyXG5pbXBvcnQgSWNvbkJ1ZmZlcldyaXRlciBmcm9tICcuLi8uLi9wcmltaXRpdmUvaWNvbi9pY29uX2J1ZmZlcl93cml0ZXInO1xyXG5pbXBvcnQgTWVtb3J5U3ViQ2h1bmsgZnJvbSAnLi4vLi4vcmVuZGVyL21lbW9yeS9zdWJfY2h1bmsnO1xyXG5pbXBvcnQgSWRlbnRpZmllZEltYWdlQXRsYXNNYW5hZ2VyIGZyb20gJy4uLy4uL2JpbGxib2FyZC9pZGVudGlmaWVkX2ltYWdlX2F0bGFzX21hbmFnZXInO1xyXG5pbXBvcnQgRGZGb250IGZyb20gJy4uLy4uL2ZvbnQvZGZfZm9udCc7XHJcbmltcG9ydCB7IEFwaUltYWdlUHJvdmlkZXIgfSBmcm9tICcuL2FwaV9pbWFnZV9wcm92aWRlcic7XHJcbmltcG9ydCBNb2RlbEJ1ZmZlcldyaXRlciBmcm9tICcuLi8uLi9wcmltaXRpdmUvbW9kZWwvbW9kZWxfYnVmZmVyX3dyaXRlcic7XHJcbmltcG9ydCBUZXh0dXJlZFBvbHlsaW5lQnVmZmVyV3JpdGVyIGZyb20gJy4uLy4uL3ByaW1pdGl2ZS9wb2x5bGluZS90ZXh0dXJlZF9wb2x5bGluZV9idWZmZXJfd3JpdGVyJztcclxuaW1wb3J0IHsgSW1hZ2VNYW5hZ2VyIH0gZnJvbSAnLi4vLi4vYmlsbGJvYXJkL2ltYWdlX21hbmFnZXInO1xyXG5pbXBvcnQgVGV4dHVyZWRQb2x5Z29uQnVmZmVyUmV3cml0ZXIgZnJvbSAnLi4vLi4vcHJpbWl0aXZlL3BvbHlnb24vdGV4dHVyZWRfcG9seWdvbl9idWZmZXJfcmV3aXRlcic7XHJcbmltcG9ydCB7IFBPTFlHT05fQVRUUklCVVRFX01BUFBJTkcgfSBmcm9tICcuLi8uLi9wcmltaXRpdmUvcG9seWdvbi9wb2x5Z29uX2F0dHJpYnV0ZV9tYXBwaW5nJztcclxuaW1wb3J0IHsgVEVYVFVSRURfUE9MWUdPTl9BVFRSSUJVVEVfTUFQUElORyB9IGZyb20gJy4uLy4uL3ByaW1pdGl2ZS9wb2x5Z29uL3RleHR1cmVkX3BvbHlnb25fYXR0cmlidXRlX21hcHBpbmcnO1xyXG5pbXBvcnQgeyBCSUxMQk9BUkRfUkVDVEFOR0xFX0FUVFJJQlVURV9NQVBQSU5HIH0gZnJvbSAnLi4vLi4vcHJpbWl0aXZlL2JpbGxib2FyZF9yZWN0YW5nbGUvYXR0cmlidXRlX21hcHBpbmcnO1xyXG5pbXBvcnQgeyBQT0lOVF9MQUJFTF9BVFRSSUJVVEVfTUFQUElORyB9IGZyb20gJy4uLy4uL3ByaW1pdGl2ZS9sYWJlbC9wb2ludF9sYWJlbF9hdHRyaWJ1dGVfbWFwcGluZyc7XHJcbmltcG9ydCB7IENVUlZFRF9MQUJFTF9BVFRSSUJVVEVfTUFQUElORyB9IGZyb20gJy4uLy4uL3ByaW1pdGl2ZS9sYWJlbC9jdXJ2ZWRfbGFiZWxfYXR0cmlidXRlX21hcHBpbmcnO1xyXG5pbXBvcnQgeyBQT0xZTElORV9BVFRSSUJVVEVfTUFQUElORyB9IGZyb20gJy4uLy4uL3ByaW1pdGl2ZS9wb2x5bGluZS9wb2x5bGluZV9hdHRyaWJ1dGVfbWFwcGluZyc7XHJcbmltcG9ydCB7IFRpbGVQcm92aWRlcldvcmtlckNsaWVudCB9IGZyb20gJy4vd29ya2VyL3RpbGVfcHJvdmlkZXJfd29ya2VyX2NsaWVudCc7XHJcbmltcG9ydCB7IFRpbGVQcm92aWRlck1lc3NhZ2VUeXBlIH0gZnJvbSAnLi93b3JrZXIvdGlsZV9wcm92aWRlcl93b3JrZXJfbWVzc2FnZXMnO1xyXG5pbXBvcnQgeyBUUkFOU1BBUkVOVF9QT0xZR09OX0FUVFJJQlVURV9NQVBQSU5HIH0gZnJvbSAnLi4vLi4vcHJpbWl0aXZlL3BvbHlnb24vdHJhbnNwYXJlbnRfcG9seWdvbl9hdHRyaWJ1dGVfbWFwcGluZyc7XHJcbmltcG9ydCB7IGdldFRpbGVJZCB9IGZyb20gJy4uL3RpbGVfYmFzZWRfYWRhcHRlci90aWxlX2lkJztcclxuaW1wb3J0IElkbGVUYXNrUXVldWUgZnJvbSAnLi4vLi4vdXRpbC9pZGxlX3Rhc2tfcXVldWUnO1xyXG5pbXBvcnQgeyBjb3VudFRpbGVQYXJzZVRpbWUgfSBmcm9tICcuLi8uLi91dGlsL3N0YXQnO1xyXG5pbXBvcnQgeyB1bmlxdWVJZCB9IGZyb20gJy4uLy4uL3V0aWwvdW5pcXVlX2lkJztcclxuaW1wb3J0IFJlbmRlcmFibGVQb2x5Z29uIGZyb20gJy4uLy4uL3ByaW1pdGl2ZS9wb2x5Z29uL3JlbmRlcmFibGVfcG9seWdvbic7XHJcbmltcG9ydCBSZW5kZXJhYmxlVGV4dHVyZWRQb2x5Z29uIGZyb20gJy4uLy4uL3ByaW1pdGl2ZS9wb2x5Z29uL3JlbmRlcmFibGVfdGV4dHVyZWRfcG9seWdvbic7XHJcbmltcG9ydCBSZW5kZXJhYmxlUG9seWxpbmUgZnJvbSAnLi4vLi4vcHJpbWl0aXZlL3BvbHlsaW5lL3JlbmRlcmFibGVfcG9seWxpbmUnO1xyXG5pbXBvcnQgUmVuZGVyYWJsZVRleHR1cmVkUG9seWxpbmUgZnJvbSAnLi4vLi4vcHJpbWl0aXZlL3BvbHlsaW5lL3JlbmRlcmFibGVfdGV4dHVyZWRfcG9seWxpbmUnO1xyXG5pbXBvcnQgUmVuZGVyYWJsZU1vZGVsIGZyb20gJy4uLy4uL3ByaW1pdGl2ZS9tb2RlbC9yZW5kZXJhYmxlX21vZGVsJztcclxuaW1wb3J0IHsgUE9MWUdPTl9FWFRSQUNUT1IsIFRFWFRVUkVEX1BPTFlHT05fRVhUUkFDVE9SLCBQT0xZTElORV9FWFRSQUNUT1IsIFRFWFRVUkVEX1BPTFlMSU5FX0VYVFJBQ1RPUiwgUE9JTlRfRVhUUkFDVE9SLCBQT0lOVF9MQUJFTF9FWFRSQUNUT1IsIENVUlZFRF9MQUJFTF9FWFRSQUNUT1IsIE1PREVMX0VYVFJBQ1RPUiwgRVhURVJOQUxfTUVTSF9FWFRSQUNUT1IgfSBmcm9tICcuL3RpbGVfZGF0YSc7XHJcbmltcG9ydCBSZW5kZXJhYmxlUHJpbWl0aXZlTWFuYWdlciBmcm9tICcuL3ByaW1pdGl2ZV9tYW5hZ2VyL3JlbmRlcmFibGVfcHJpbWl0aXZlX21hbmFnZXInO1xyXG5pbXBvcnQgUHJpbWl0aXZlU2V0U3RvcmFnZSBmcm9tICcuLi8uLi9yZW5kZXIvcHJpbWl0aXZlcy9wcmltaXRpdmVfc2V0X3N0b3JhZ2UnO1xyXG5pbXBvcnQgUG9seWdvbk1hbmFnZXIgZnJvbSAnLi9wcmltaXRpdmVfbWFuYWdlci9wb2x5Z29uX21hbmFnZXInO1xyXG5pbXBvcnQgRGlzYXBwZWFyaW5nUHJpbWl0aXZlU2V0U3RvcmFnZSBmcm9tICcuLi8uLi9yZW5kZXIvcHJpbWl0aXZlcy9kaXNhcHBlYXJpbmdfcHJpbWl0aXZlX3NldF9zdG9yYWdlJztcclxuaW1wb3J0IERlbGF5ZWREaXNhcHBlYXJpbmdQcmltaXRpdmVTZXRTdG9yYWdlIGZyb20gJy4uLy4uL3JlbmRlci9wcmltaXRpdmVzL2RlbGF5ZWRfZGlzYXBwZWFyaW5nX3ByaW1pdGl2ZV9zZXRfc3RvcmFnZSc7XHJcbmltcG9ydCBab29tRmlsdGVyYWJsZVByaW1pdGl2ZU1hbmFnZXIgZnJvbSAnLi9wcmltaXRpdmVfbWFuYWdlci96b29tX2ZpbHRlcmFibGVfcHJpbWl0aXZlX21hbmFnZXInO1xyXG5pbXBvcnQgRXh0ZXJuYWxNZXNoUHJpbWl0aXZlTWFuYWdlciBmcm9tICcuL3ByaW1pdGl2ZV9tYW5hZ2VyL2V4dGVybmFsX21lc2hfbWFuYWdlcic7XHJcbmltcG9ydCBSZW5kZXJhYmxlQmlsbGJvYXJkUmVjdGFuZ2xlIGZyb20gJy4uLy4uL3ByaW1pdGl2ZS9iaWxsYm9hcmRfcmVjdGFuZ2xlL3JlbmRlcmFibGVfYmlsbGJvYXJkX3JlY3RhbmdsZSc7XHJcbmltcG9ydCB7IFpvb21SZXN0cmljdGVkTGFiZWwgfSBmcm9tICcuL3ByaW1pdGl2ZS96b29tX3Jlc3RyaWN0ZWRfbGFiZWwnO1xyXG5pbXBvcnQgeyBab29tUmVzdHJpY3RlZEljb24gfSBmcm9tICcuL3ByaW1pdGl2ZS96b29tX3Jlc3RyaWN0ZWRfaWNvbic7XHJcbmltcG9ydCBQcmlvcml0eVF1ZXVlIGZyb20gJy4uLy4uL3V0aWwvdGFza19xdWV1ZSc7XHJcbmNvbnN0IFdPUkxEX1NJWkUgPSAyLjA7XHJcbmNvbnN0IE5PUk1BTF9USUxFX1NJREVfU0laRV9QWCA9IDI1NjsgLy8gdGlsZXMgb2Ygbm9ybWFsIHNpemUgYXJlIG9wdGltaXplZCBmb3IgZGlzcGxheWluZyBpbiBhIDI1NngyNTYgY3NzIHB4IHNxdWFyZVxyXG5mdW5jdGlvbiBnZXRUaWxlU2lkZVNpemVQeCh0aWxlU2l6ZSkge1xyXG4gICAgc3dpdGNoICh0aWxlU2l6ZSkge1xyXG4gICAgICAgIGNhc2UgMSAvKiBYNCAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIE5PUk1BTF9USUxFX1NJREVfU0laRV9QWCAqIDI7XHJcbiAgICAgICAgY2FzZSAyIC8qIFgxNiAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIE5PUk1BTF9USUxFX1NJREVfU0laRV9QWCAqIDQ7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIE5PUk1BTF9USUxFX1NJREVfU0laRV9QWDtcclxuICAgIH1cclxufVxyXG5jb25zdCBNQVhfUEVSRl9MT0dfSVRFTVNfQ09VTlQgPSAxMDI0O1xyXG5jb25zdCBRVUVVRV9UQVNLX1BSSU9SSVRJRVMgPSB7XHJcbiAgICBmaXJzdFRpbGVQb3J0aW9uOiAyMCxcclxuICAgIHNlY29uZFRpbGVQb3J0aW9uOiAxMFxyXG59O1xyXG5jb25zdCBERUZBVUxUX0lETEVfVEFTS19QUklPUklUWSA9IDA7XHJcbi8vIFRoZSB2YWx1ZXMgYXJlIGNob3NlbiBlbXBpcmljYWxseTogaHR0cHM6Ly9zdC55YW5kZXgtdGVhbS5ydS9WRUNUT1ItMzAwIzViZTViNjM4NTIzMjExMDAxYjliZDk0MVxyXG5jb25zdCBNSU5aT09NX0RFTFRBUyA9IHtcclxuICAgIHBvaW50TGFiZWxzOiAxLFxyXG4gICAgY3VydmVkTGFiZWxzOiAxLFxyXG4gICAgaWNvbnM6IDAuNzVcclxufTtcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmVjdG9yQXBpQWRhcHRlciBleHRlbmRzIFRpbGVCYXNlZEFkYXB0ZXIge1xyXG4gICAgY29uc3RydWN0b3IoZW5naW5lLCBjYW1lcmEsIHRpbGVQcm92aWRlcldvcmtlclVybCwgbGF5ZXJOYW1lLCB7IGltYWdlVXJsVGVtcGxhdGUsIHRpbGVVcmxUZW1wbGF0ZSwgbWVzaFVybFRlbXBsYXRlLCBnbHlwaFJhbmdlVXJsVGVtcGxhdGUgfSwgdGlsZVNpemUgPSAwIC8qIFgxICovLCBwcmVsb2FkZWRUaWxlc0JlbHRTaXplID0gMCkge1xyXG4gICAgICAgIHN1cGVyKGVuZ2luZSwgY2FtZXJhLCB0aWxlU2l6ZSwgcHJlbG9hZGVkVGlsZXNCZWx0U2l6ZSwgbGF5ZXJOYW1lKTtcclxuICAgICAgICB0aGlzLl90aWxlU2lkZVNpemVQeCA9IGdldFRpbGVTaWRlU2l6ZVB4KHRpbGVTaXplKTtcclxuICAgICAgICB0aGlzLl9wZXJmTG9nSXRlbXMgPSBbXTtcclxuICAgICAgICB0aGlzLl9kZXN0cm95YWJsZXMgPSBbXTtcclxuICAgICAgICB0aGlzLl90aWxlUHJvdmlkZXIgPSBuZXcgVGlsZVByb3ZpZGVyV29ya2VyQ2xpZW50KHRpbGVQcm92aWRlcldvcmtlclVybCk7XHJcbiAgICAgICAgdGhpcy5fdGlsZVByb3ZpZGVyLnNlbmRNZXNzYWdlKHtcclxuICAgICAgICAgICAgdHlwZTogVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGUuSU5JVCxcclxuICAgICAgICAgICAgdGlsZVVybFRlbXBsYXRlLFxyXG4gICAgICAgICAgICBtZXNoVXJsVGVtcGxhdGUsXHJcbiAgICAgICAgICAgIGdseXBoUmFuZ2VVcmxUZW1wbGF0ZVxyXG4gICAgICAgIH0sIDEgLyogSU1NRURJQVRFICovKTtcclxuICAgICAgICB0aGlzLl9tZW1vcnlNYW5hZ2VyID0gZW5naW5lLm1lbW9yeU1hbmFnZXI7XHJcbiAgICAgICAgdGhpcy5fZ2x5cGhBdGxhcyA9IGVuZ2luZS5nbHlwaEF0bGFzO1xyXG4gICAgICAgIHRoaXMuX2ZvbnRSZWdpc3RyeSA9IGVuZ2luZS5mb250UmVnaXN0cnk7XHJcbiAgICAgICAgdGhpcy5faW1hZ2VNYW5hZ2VyTmVhcmVzdCA9IG5ldyBJbWFnZU1hbmFnZXIobmV3IElkZW50aWZpZWRJbWFnZUF0bGFzTWFuYWdlcihlbmdpbmUuY3JlYXRlSW1hZ2VBdGxhcyh7XHJcbiAgICAgICAgICAgIGZpbHRlcjogOTcyOCAvKiBORUFSRVNUICovLFxyXG4gICAgICAgICAgICBwcmVtdWx0aXBsaWVkQWxwaGE6IGZhbHNlXHJcbiAgICAgICAgfSkpLCBuZXcgQXBpSW1hZ2VQcm92aWRlcihpbWFnZVVybFRlbXBsYXRlKSk7XHJcbiAgICAgICAgdGhpcy5faW1hZ2VNYW5hZ2VyTGluZWFyID0gbmV3IEltYWdlTWFuYWdlcihuZXcgSWRlbnRpZmllZEltYWdlQXRsYXNNYW5hZ2VyKGVuZ2luZS5jcmVhdGVJbWFnZUF0bGFzKHtcclxuICAgICAgICAgICAgZmlsdGVyOiA5NzI5IC8qIExJTkVBUiAqLyxcclxuICAgICAgICAgICAgcHJlbXVsdGlwbGllZEFscGhhOiB0cnVlXHJcbiAgICAgICAgfSkpLCBuZXcgQXBpSW1hZ2VQcm92aWRlcihpbWFnZVVybFRlbXBsYXRlKSk7XHJcbiAgICAgICAgY29uc3QgZmFkZUVmZmVjdCA9IGVuZ2luZS52aXNpYmlsaXR5TWFuYWdlci5mYWRlRWZmZWN0RHVyYXRpb247XHJcbiAgICAgICAgY29uc3Qgb3BhcXVlUG9seWdvbnNQcm92aWRlciA9IHRoaXMub3BhcXVlUG9seWdvbnNQcm92aWRlciA9IG5ldyBQcmltaXRpdmVTZXRTdG9yYWdlKCk7XHJcbiAgICAgICAgY29uc3QgdHJhbnNwYXJlbnRQb2x5Z29uc1Byb3ZpZGVyID0gdGhpcy50cmFuc3BhcmVudFBvbHlnb25zUHJvdmlkZXIgPSBuZXcgUHJpbWl0aXZlU2V0U3RvcmFnZSgpO1xyXG4gICAgICAgIGNvbnN0IHRleHR1cmVkUG9seWdvbnNQcm92aWRlciA9IHRoaXMudGV4dHVyZWRQb2x5Z29uc1Byb3ZpZGVyID0gbmV3IFByaW1pdGl2ZVNldFN0b3JhZ2UoKTtcclxuICAgICAgICBjb25zdCBwb2x5bGluZXNQcm92aWRlciA9IHRoaXMucG9seWxpbmVzUHJvdmlkZXIgPSBuZXcgUHJpbWl0aXZlU2V0U3RvcmFnZSgpO1xyXG4gICAgICAgIGNvbnN0IHRleHR1cmVkUG9seWxpbmVzUHJvdmlkZXIgPSB0aGlzLnRleHR1cmVkUG9seWxpbmVzUHJvdmlkZXIgPSBuZXcgUHJpbWl0aXZlU2V0U3RvcmFnZSgpO1xyXG4gICAgICAgIGNvbnN0IGljb25zUHJvdmlkZXIgPSB0aGlzLmljb25zUHJvdmlkZXIgPSBuZXcgRGlzYXBwZWFyaW5nUHJpbWl0aXZlU2V0U3RvcmFnZSgpO1xyXG4gICAgICAgIGNvbnN0IHBvaW50TGFiZWxzUHJvdmlkZXIgPSB0aGlzLnBvaW50TGFiZWxzUHJvdmlkZXIgPSBuZXcgRGVsYXllZERpc2FwcGVhcmluZ1ByaW1pdGl2ZVNldFN0b3JhZ2UoZmFkZUVmZmVjdCk7XHJcbiAgICAgICAgY29uc3QgY3VydmVkTGFiZWxzUHJvdmlkZXIgPSB0aGlzLmN1cnZlZExhYmVsc1Byb3ZpZGVyID0gbmV3IERlbGF5ZWREaXNhcHBlYXJpbmdQcmltaXRpdmVTZXRTdG9yYWdlKGZhZGVFZmZlY3QpO1xyXG4gICAgICAgIGNvbnN0IG1vZGVsc1Byb3ZpZGVyID0gdGhpcy5tb2RlbHNQcm92aWRlciA9IG5ldyBQcmltaXRpdmVTZXRTdG9yYWdlKCk7XHJcbiAgICAgICAgdGhpcy5fZGVzdHJveWFibGVzLnB1c2gocG9pbnRMYWJlbHNQcm92aWRlciwgY3VydmVkTGFiZWxzUHJvdmlkZXIpO1xyXG4gICAgICAgIHRoaXMuX3RpbGVEYXRhTWFuYWdlcnMgPSBbXHJcbiAgICAgICAgICAgIG5ldyBUaWxlRGF0YU1hbmFnZXIobmV3IFBvbHlnb25NYW5hZ2VyKG9wYXF1ZVBvbHlnb25zUHJvdmlkZXIsIHRyYW5zcGFyZW50UG9seWdvbnNQcm92aWRlciksIFBPTFlHT05fRVhUUkFDVE9SKSxcclxuICAgICAgICAgICAgbmV3IFRpbGVEYXRhTWFuYWdlcihuZXcgUmVuZGVyYWJsZVByaW1pdGl2ZU1hbmFnZXIodGV4dHVyZWRQb2x5Z29uc1Byb3ZpZGVyKSwgVEVYVFVSRURfUE9MWUdPTl9FWFRSQUNUT1IpLFxyXG4gICAgICAgICAgICBuZXcgVGlsZURhdGFNYW5hZ2VyKG5ldyBSZW5kZXJhYmxlUHJpbWl0aXZlTWFuYWdlcihwb2x5bGluZXNQcm92aWRlciksIFBPTFlMSU5FX0VYVFJBQ1RPUiksXHJcbiAgICAgICAgICAgIG5ldyBUaWxlRGF0YU1hbmFnZXIobmV3IFJlbmRlcmFibGVQcmltaXRpdmVNYW5hZ2VyKHRleHR1cmVkUG9seWxpbmVzUHJvdmlkZXIpLCBURVhUVVJFRF9QT0xZTElORV9FWFRSQUNUT1IpLFxyXG4gICAgICAgICAgICBuZXcgVGlsZURhdGFNYW5hZ2VyKG5ldyBab29tRmlsdGVyYWJsZVByaW1pdGl2ZU1hbmFnZXIoaWNvbnNQcm92aWRlciwgY2FtZXJhKSwgUE9JTlRfRVhUUkFDVE9SKSxcclxuICAgICAgICAgICAgbmV3IFRpbGVEYXRhTWFuYWdlcihuZXcgWm9vbUZpbHRlcmFibGVQcmltaXRpdmVNYW5hZ2VyKHBvaW50TGFiZWxzUHJvdmlkZXIsIGNhbWVyYSksIFBPSU5UX0xBQkVMX0VYVFJBQ1RPUiksXHJcbiAgICAgICAgICAgIG5ldyBUaWxlRGF0YU1hbmFnZXIobmV3IFpvb21GaWx0ZXJhYmxlUHJpbWl0aXZlTWFuYWdlcihjdXJ2ZWRMYWJlbHNQcm92aWRlciwgY2FtZXJhKSwgQ1VSVkVEX0xBQkVMX0VYVFJBQ1RPUiksXHJcbiAgICAgICAgICAgIG5ldyBUaWxlRGF0YU1hbmFnZXIobmV3IFJlbmRlcmFibGVQcmltaXRpdmVNYW5hZ2VyKG1vZGVsc1Byb3ZpZGVyKSwgTU9ERUxfRVhUUkFDVE9SKSxcclxuICAgICAgICAgICAgbmV3IFRpbGVEYXRhTWFuYWdlcihuZXcgRXh0ZXJuYWxNZXNoUHJpbWl0aXZlTWFuYWdlcihtb2RlbHNQcm92aWRlciwgdGhpcy5fdGlsZVByb3ZpZGVyLCB0aGlzLmVuZ2luZS5tZW1vcnlNYW5hZ2VyKSwgRVhURVJOQUxfTUVTSF9FWFRSQUNUT1IpXHJcbiAgICAgICAgXTtcclxuICAgICAgICB0aGlzLl9yZXF1ZXN0ZWRUaWxlc1N0YXRlID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuX3Rhc2tRdWV1ZSA9IG5ldyBQcmlvcml0eVF1ZXVlKCk7XHJcbiAgICAgICAgdGhpcy5fbWlub3JUYXNrUXVldWUgPSBuZXcgSWRsZVRhc2tRdWV1ZSgpO1xyXG4gICAgICAgIHRoaXMuX3RpbGVQcm92aWRlci5vbihUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZS5USUxFX1JFU1BPTlNFLCAocmVzcG9uc2UpID0+IHRoaXMuX29uVGlsZVByb3ZpZGVyUmVzcG9uc2UocmVzcG9uc2UpKTtcclxuICAgICAgICB0aGlzLl90aWxlUHJvdmlkZXIub24oVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGUuVElMRV9FUlJPUiwgKHJlc3BvbnNlKSA9PiB0aGlzLl9vblRpbGVFcnJvcihyZXNwb25zZS50aWxlKSk7XHJcbiAgICAgICAgdGhpcy5fb25DYW1lcmFVcGRhdGUoKTtcclxuICAgIH1cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5fdGlsZVByb3ZpZGVyLmRlc3Ryb3koKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGRlc3Ryb3lhYmxlIG9mIHRoaXMuX2Rlc3Ryb3lhYmxlcykge1xyXG4gICAgICAgICAgICBkZXN0cm95YWJsZS5kZXN0cm95KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcclxuICAgIH1cclxuICAgIHNldFRpbGVVcmxUZW1wbGF0ZSh0aWxlVXJsVGVtcGxhdGUpIHtcclxuICAgICAgICB0aGlzLl90aWxlUHJvdmlkZXIuc2VuZE1lc3NhZ2Uoe1xyXG4gICAgICAgICAgICB0eXBlOiBUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZS5USUxFX1VSTF9VUERBVEUsXHJcbiAgICAgICAgICAgIHRpbGVVcmxUZW1wbGF0ZVxyXG4gICAgICAgIH0sIDEgLyogSU1NRURJQVRFICovKTtcclxuICAgICAgICB0aGlzLl9yZWZyZXNoQ3VycmVudFRpbGVzKCk7XHJcbiAgICB9XHJcbiAgICBfY3JlYXRlVGlsZVJlcXVlc3QodGlsZUl0ZW0sIHByaW9yaXR5KSB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0Wm9vbSA9IHRoaXMuX2dldFRhcmdldFpvb20oKTtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgdGlsZUl0ZW0sIHsgcHJpb3JpdHksIGlzVmlzaWJsZTogdGhpcy5faXNUaWxlVmlzaWJsZSh0aWxlSXRlbSksIHpvb21NaW46IHRhcmdldFpvb20sIHpvb21NYXg6IHRhcmdldFpvb20gfSk7XHJcbiAgICB9XHJcbiAgICBfcmVxdWVzdFRpbGVzKHJlcXVlc3RzKSB7XHJcbiAgICAgICAgY29uc3QgcmVxdWVzdElkID0gdW5pcXVlSWQoKTtcclxuICAgICAgICB0aGlzLl9vblRpbGVzUmVxdWVzdChyZXF1ZXN0cywgcmVxdWVzdElkKTtcclxuICAgICAgICBmb3IgKGNvbnN0IHJlcXVlc3Qgb2YgcmVxdWVzdHMpIHtcclxuICAgICAgICAgICAgY29uc3QgcmVxdWVzdGVkVGlsZURhdGEgPSB7XHJcbiAgICAgICAgICAgICAgICBpc0dlb21ldHJ5UmVhZHk6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgYXJlTGFiZWxzUmVhZHk6IGZhbHNlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RlZFRpbGVzU3RhdGUuc2V0KGdldFRpbGVJZChyZXF1ZXN0KSwgcmVxdWVzdGVkVGlsZURhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xyXG4gICAgICAgICAgICB0eXBlOiBUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZS5USUxFX1JFUVVFU1RfQkFUQ0gsXHJcbiAgICAgICAgICAgIHJlc3BvbnNlVHlwZTogVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGUuVElMRV9SRVNQT05TRSxcclxuICAgICAgICAgICAgZXJyb3JUeXBlOiBUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZS5USUxFX0VSUk9SLFxyXG4gICAgICAgICAgICByZXF1ZXN0SWQsXHJcbiAgICAgICAgICAgIHJlcXVlc3RzXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLl90aWxlUHJvdmlkZXIuc2VuZE1lc3NhZ2UocmVxdWVzdCwgMSAvKiBJTU1FRElBVEUgKi8pO1xyXG4gICAgfVxyXG4gICAgX2NhbmNlbFRpbGVSZXF1ZXN0cyhyZXF1ZXN0cykge1xyXG4gICAgICAgIGZvciAoY29uc3QgcmVxdWVzdCBvZiByZXF1ZXN0cykge1xyXG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0ZWRUaWxlc1N0YXRlLmRlbGV0ZShnZXRUaWxlSWQocmVxdWVzdC50aWxlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX29uQ2FuY2VsVGlsZVJlcXVlc3RzKHJlcXVlc3RzKTtcclxuICAgICAgICB0aGlzLl90aWxlUHJvdmlkZXIuc2VuZE1lc3NhZ2Uoe1xyXG4gICAgICAgICAgICB0eXBlOiBUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZS5USUxFX1JFUVVFU1RfQ0FOQ0VMX0JBVENILFxyXG4gICAgICAgICAgICByZXF1ZXN0c1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX29uVGlsZURhdGFVcGRhdGUoZGF0YVRvU2hvdywgZGF0YVRvSGlkZSkge1xyXG4gICAgICAgIGZvciAoY29uc3QgcHJpbWl0aXZlTWFuYWdlciBvZiB0aGlzLl90aWxlRGF0YU1hbmFnZXJzKSB7XHJcbiAgICAgICAgICAgIHByaW1pdGl2ZU1hbmFnZXIudXBkYXRlUHJpbWl0aXZlcyhkYXRhVG9TaG93LCBkYXRhVG9IaWRlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfb25UaWxlRGVzdHJveShfdGlsZUl0ZW0sIGRhdGEpIHtcclxuICAgICAgICAvLyByZWxlYXNlIHByaW1pdGl2ZXMgdGhhdCB3ZSd2ZSBjcmVhdGVkIGluIGFsbG9jYXRvcnNcclxuICAgICAgICBmb3IgKGNvbnN0IHBvcnRpb24gb2YgZGF0YSkge1xyXG4gICAgICAgICAgICAocG9ydGlvbi5wb2x5Z29ucyB8fCBbXSkuZm9yRWFjaChyZWxlYXNlUHJpbWl0aXZlKTtcclxuICAgICAgICAgICAgKHBvcnRpb24udGV4dHVyZWRQb2x5Z29ucyB8fCBbXSkuZm9yRWFjaChyZWxlYXNlUHJpbWl0aXZlKTtcclxuICAgICAgICAgICAgKHBvcnRpb24ucG9seWxpbmVzIHx8IFtdKS5mb3JFYWNoKHJlbGVhc2VQcmltaXRpdmUpO1xyXG4gICAgICAgICAgICAocG9ydGlvbi50ZXh0dXJlZFBvbHlsaW5lcyB8fCBbXSkuZm9yRWFjaChyZWxlYXNlUHJpbWl0aXZlKTtcclxuICAgICAgICAgICAgKHBvcnRpb24ucG9pbnRzIHx8IFtdKS5mb3JFYWNoKHJlbGVhc2VQcmltaXRpdmUpO1xyXG4gICAgICAgICAgICAocG9ydGlvbi5wb2ludExhYmVscyB8fCBbXSkuZm9yRWFjaChyZWxlYXNlUHJpbWl0aXZlKTtcclxuICAgICAgICAgICAgKHBvcnRpb24uY3VydmVkTGFiZWxzIHx8IFtdKS5mb3JFYWNoKHJlbGVhc2VQcmltaXRpdmUpO1xyXG4gICAgICAgICAgICAocG9ydGlvbi5tb2RlbHMgfHwgW10pLmZvckVhY2gocmVsZWFzZVByaW1pdGl2ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3NlbmRTdGF0aXN0aWNzQmVmb3JlRGVzdHJveSgpIHtcclxuICAgICAgICBzdXBlci5fc2VuZFN0YXRpc3RpY3NCZWZvcmVEZXN0cm95KCk7XHJcbiAgICAgICAgaWYgKHRoaXMuX3BlcmZMb2dJdGVtcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpdGVtcyA9IHRoaXMuX3BlcmZMb2dJdGVtcztcclxuICAgICAgICBpdGVtcy5zb3J0KChhLCBiKSA9PiBhLnBhcnNlVGltZSAtIGIucGFyc2VUaW1lKTtcclxuICAgICAgICBjb25zdCBtaW4gPSBpdGVtc1swXTtcclxuICAgICAgICBjb25zdCBtYXggPSBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXTtcclxuICAgICAgICBjb25zdCBtZWRpYW4gPSBpdGVtc1tNYXRoLmZsb29yKGl0ZW1zLmxlbmd0aCAvIDIpXTtcclxuICAgICAgICBjb3VudFRpbGVQYXJzZVRpbWUodGhpcy5fbGF5ZXJOYW1lLCBtaW4udGlsZSwgbWluLnBhcnNlVGltZSwgbWF4LnRpbGUsIG1heC5wYXJzZVRpbWUsIG1lZGlhbi50aWxlLCBtZWRpYW4ucGFyc2VUaW1lKTtcclxuICAgIH1cclxuICAgIF9vblRpbGVQcm92aWRlclJlc3BvbnNlKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgdGhpcy5fcHVzaFBlcmZMb2dJdGVtKHJlc3BvbnNlLnRpbGUsIHJlc3BvbnNlLnBhcnNlVGltZSk7XHJcbiAgICAgICAgY29uc3QgdGlsZSA9IHJlc3BvbnNlLnRpbGU7XHJcbiAgICAgICAgY29uc3QgdGFza1ByaW9yaXR5ID0gUVVFVUVfVEFTS19QUklPUklUSUVTLmZpcnN0VGlsZVBvcnRpb24gK1xyXG4gICAgICAgICAgICB0aGlzLl9nZXRUaWxlUHJpb3JpdHkodGlsZSwgdGhpcy5faXNUaWxlVmlzaWJsZSh0aWxlKSk7XHJcbiAgICAgICAgdGhpcy5fdGFza1F1ZXVlLmVucXVldWUoe1xyXG4gICAgICAgICAgICBwcmlvcml0eTogdGFza1ByaW9yaXR5LFxyXG4gICAgICAgICAgICBleGVjdXRlOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBhdGxhcyBtdXN0IGJlIHVwZGF0ZWQgbm90d2l0aHN0YW5kaW5nIHRoZSB0aWxlIGlzIGFjdGl2ZSBvciBub3RcclxuICAgICAgICAgICAgICAgIC8vIGFzIHRoZXNlIG5ldyBnbHlwaHMgd2lsbCBiZSB1c2VkIGluIG5leHQgdGlsZXNcclxuICAgICAgICAgICAgICAgIGNvbnN0IGF0bGFzID0gcmVzcG9uc2UuZ2x5cGhBdGxhc1RvVXBkYXRlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGF0bGFzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ2x5cGhBdGxhcy51cGRhdGVDb250ZW50KGF0bGFzLndpZHRoLCBhdGxhcy5oZWlnaHQsIGF0bGFzLmRhdGEsIG5ldyBNYXAoYXRsYXMuZ2x5cGhMb2NhdGlvbnMpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2lzdHJ5ID0gcmVzcG9uc2UuZm9udFJlZ2lzdHJ5VG9VcGRhdGU7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVnaXN0cnkpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGZvbnREYXRhIG9mIHJlZ2lzdHJ5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmb250O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fZm9udFJlZ2lzdHJ5LmNvbnRhaW5zKGZvbnREYXRhLmlkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udCA9IHRoaXMuX2ZvbnRSZWdpc3RyeS5nZXQoZm9udERhdGEuaWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udCA9IG5ldyBEZkZvbnQoZm9udERhdGEuaWQsIGZvbnREYXRhLnhoZWlnaHQsIGZvbnREYXRhLm1hcmdpbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9mb250UmVnaXN0cnkuYWRkKGZvbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbnQuYWRkQWxsR2x5cGhzKGZvbnREYXRhLmdseXBocyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdElkID0gcmVzcG9uc2UucmVxdWVzdElkO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pc1RpbGVTdGlsbEFjdGl2ZSh0aWxlLCByZXF1ZXN0SWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gSWYgdGlsZSBpcyBiZWluZyByZWZyZXNoZWQgZG9uJ3QgdmlzdWFsaXplIGFueSBwb3J0aW9ucyB1bnRpbCBhbGwgb2YgdGhlbSBhcmUgbG9hZGVkIHRvIGF2b2lkIGEgYmxpbmtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGlzUmVmcmVzaGluZyA9IHRoaXMuX2lzVGlsZVJlZnJlc2hpbmcodGlsZSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpY29uc1NwbGl0dGVkID0gc3BsaXRJbWFnZURlcGVuZGFudFByaW1pdGl2ZXMocmVzcG9uc2UucG9pbnRzLCB0aGlzLl9pbWFnZU1hbmFnZXJOZWFyZXN0LCAocG9pbnQpID0+IHBvaW50LnN0eWxlc1swXS5pbWFnZUlkKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRleHR1cmVkUG9seWxpbmVzU3BsaXR0ZWQgPSBzcGxpdEltYWdlRGVwZW5kYW50UHJpbWl0aXZlcyhyZXNwb25zZS50ZXh0dXJlZFBvbHlsaW5lcywgdGhpcy5faW1hZ2VNYW5hZ2VyTGluZWFyLCAocG9seWxpbmUpID0+IHBvbHlsaW5lLnN0eWxlc1swXS5pbmxpbmUucGF0dGVybi5pbWFnZUlkKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRleHR1cmVkUG9seWdvbnNJbWFnZXMgPSBnZXRJbWFnZXNJZkFsbEFsbG9jYXRlZChyZXNwb25zZS50ZXh0dXJlZFBvbHlnb25zLCB0aGlzLl9pbWFnZU1hbmFnZXJOZWFyZXN0LCAocG9seWdvbikgPT4gcG9seWdvbi5zdHlsZXNbMF0ucGF0dGVybi5pbWFnZUlkKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Rhc2tRdWV1ZS5lbnF1ZXVlKHtcclxuICAgICAgICAgICAgICAgICAgICBwcmlvcml0eTogUVVFVUVfVEFTS19QUklPUklUSUVTLnNlY29uZFRpbGVQb3J0aW9uICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ2V0VGlsZVByaW9yaXR5KHRpbGUsIHRoaXMuX2lzVGlsZVZpc2libGUodGlsZSkpLFxyXG4gICAgICAgICAgICAgICAgICAgIGV4ZWN1dGU6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzVGlsZVN0aWxsQWN0aXZlKHRpbGUsIHJlc3BvbnNlLnJlcXVlc3RJZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3B1dFRpbGVEYXRhKHRpbGUsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uczogdGhpcy5fYWxsb2NhdGVQb2x5Z29ucyhyZXNwb25zZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWxzOiB0aGlzLl9hbGxvY2F0ZU1lc2hlcyhyZXNwb25zZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZXJuYWxNZXNoZXM6IHJlc3BvbnNlLmV4dGVybmFsTWVzaGVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlsaW5lczogdGhpcy5fYWxsb2NhdGVQb2x5bGluZXMocmVzcG9uc2UpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50TGFiZWxzOiB0aGlzLl9hbGxvY2F0ZVBvaW50TGFiZWxzKHJlc3BvbnNlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJ2ZWRMYWJlbHM6IHRoaXMuX2FsbG9jYXRlQ3VydmVkTGFiZWxzKHJlc3BvbnNlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHM6IHRoaXMuX2FsbG9jYXRlSWNvbnModGlsZSwgaWNvbnNTcGxpdHRlZC5wcmltaXRpdmVzV2l0aEFsbG9jYXRlZEltYWdlcywgaWNvbnNTcGxpdHRlZC5hbGxvY2F0ZWRJbWFnZXMpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmVkUG9seWxpbmVzOiB0aGlzLl9hbGxvY2F0ZVRleHR1cmVkUG9seWxpbmVzKHRpbGUsIHRleHR1cmVkUG9seWxpbmVzU3BsaXR0ZWQucHJpbWl0aXZlc1dpdGhBbGxvY2F0ZWRJbWFnZXMsIHRleHR1cmVkUG9seWxpbmVzU3BsaXR0ZWQuYWxsb2NhdGVkSW1hZ2VzKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlZFBvbHlnb25zOiAhdGV4dHVyZWRQb2x5Z29uc0ltYWdlcy5hbGxvY2F0ZWRJbWFnZXMgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FsbG9jYXRlVGV4dHVyZWRQb2x5Z29ucyh0aWxlLCByZXNwb25zZS50ZXh0dXJlZFBvbHlnb25zLCB0ZXh0dXJlZFBvbHlnb25zSW1hZ2VzLmFsbG9jYXRlZEltYWdlcywgcmVzcG9uc2UudGV4dHVyZWRQb2x5Z29uUGFnZXMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCByZXF1ZXN0SWQsICFpc1JlZnJlc2hpbmcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWNvbnNTcGxpdHRlZC5hbGxvY2F0ZWRJbWFnZXMuZm9yRWFjaChyZWxlYXNlUHJpbWl0aXZlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmVkUG9seWxpbmVzU3BsaXR0ZWQuYWxsb2NhdGVkSW1hZ2VzLmZvckVhY2gocmVsZWFzZVByaW1pdGl2ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGV4dHVyZWRQb2x5Z29uc0ltYWdlcy5hbGxvY2F0ZWRJbWFnZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlZFBvbHlnb25zSW1hZ2VzLmFsbG9jYXRlZEltYWdlcy5mb3JFYWNoKHJlbGVhc2VQcmltaXRpdmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdGVkVGlsZURhdGEgPSB0aGlzLl9yZXF1ZXN0ZWRUaWxlc1N0YXRlLmdldChnZXRUaWxlSWQodGlsZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcXVlc3RlZFRpbGVEYXRhICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiB0aGUgZGF0YSBpcyBzeW5jZWQgb24gdGhlc2UgdHdvIHByb3BlcnRpZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICBhbmQgdGhpcyBjb2RlIGRvZXNuJ3QgbWFrZSBtdWNoIHNlbnNlIGZvciBub3csXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgYnV0IGl0IGlzIGxlZnQgXCJhcyBpc1wiIHNpbmNlIGl0IGlzIG5vdCBjbGVhclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgIGhvdyBpdCB3aWxsIGJlIGNoYW5nZWQgaW4gbmVhcmVzdCBmdXR1cmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0ZWRUaWxlRGF0YS5pc0dlb21ldHJ5UmVhZHkgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RlZFRpbGVEYXRhLmFyZUxhYmVsc1JlYWR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vblRpbGVEYXRhUmVhZHkodGlsZSwgcmVzcG9uc2UudXJsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHV0RGF0YVByb21pc2VzID0gW107XHJcbiAgICAgICAgICAgICAgICBwdXREYXRhUHJvbWlzZXMucHVzaChpY29uc1NwbGl0dGVkLm1pc3NpbmdJbWFnZXMudGhlbigoaW1hZ2VzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25NaXNzaW5nSWNvbkltYWdlc1JlYWR5KHJlc3BvbnNlLCBpY29uc1NwbGl0dGVkLCBpbWFnZXMpO1xyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgcHV0RGF0YVByb21pc2VzLnB1c2godGV4dHVyZWRQb2x5bGluZXNTcGxpdHRlZC5taXNzaW5nSW1hZ2VzLnRoZW4oKGltYWdlcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29uTWlzc2luZ1BvbHlsaW5lSW1hZ2VzUmVhZHkocmVzcG9uc2UsIHRleHR1cmVkUG9seWxpbmVzU3BsaXR0ZWQsIGltYWdlcyk7XHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGV4dHVyZWRQb2x5Z29uc0ltYWdlcy5taXNzaW5nSW1hZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHV0RGF0YVByb21pc2VzLnB1c2godGV4dHVyZWRQb2x5Z29uc0ltYWdlcy5taXNzaW5nSW1hZ2VzLnRoZW4oKGltYWdlcykgPT4gdGhpcy5fb25NaXNzaW5nUG9seWdvbkltYWdlc1JlYWR5KHJlc3BvbnNlLCBpbWFnZXMpKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNSZWZyZXNoaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiBhbGwgdGhlIHBvcnRpb25zIGFyZSBsb2FkZWQsIHB1dCBlbXB0eSBkYXRhIHRvIHZpc3VhemxpemUgaXRcclxuICAgICAgICAgICAgICAgICAgICBQcm9taXNlLmFsbChwdXREYXRhUHJvbWlzZXMpLnRoZW4oKCkgPT4gdGhpcy5fcHV0VGlsZURhdGEodGlsZSwge30sIHJlcXVlc3RJZCwgdHJ1ZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfb25NaXNzaW5nSWNvbkltYWdlc1JlYWR5KHJlc3BvbnNlLCBpY29uc1NwbGl0dGVkLCBpbWFnZXMpIHtcclxuICAgICAgICBjb25zdCB0aWxlID0gcmVzcG9uc2UudGlsZTtcclxuICAgICAgICB0aGlzLl9taW5vclRhc2tRdWV1ZS5lbnF1ZXVlKHtcclxuICAgICAgICAgICAgcHJpb3JpdHk6IERFRkFVTFRfSURMRV9UQVNLX1BSSU9SSVRZICtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2dldFRpbGVQcmlvcml0eSh0aWxlLCB0aGlzLl9pc1RpbGVWaXNpYmxlKHRpbGUpKSxcclxuICAgICAgICAgICAgZXhlY3V0ZTogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzVGlsZVN0aWxsQWN0aXZlKHRpbGUsIHJlc3BvbnNlLnJlcXVlc3RJZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb2ludHMgPSB0aGlzLl9hbGxvY2F0ZUljb25zKHRpbGUsIGljb25zU3BsaXR0ZWQucHJpbWl0aXZlc1dpdGhNaXNzaW5nSW1hZ2VzLCBpbWFnZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3B1dFRpbGVEYXRhKHRpbGUsIHsgcG9pbnRzIH0sIHJlc3BvbnNlLnJlcXVlc3RJZCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaW1hZ2VzLmZvckVhY2gocmVsZWFzZVByaW1pdGl2ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIF9vbk1pc3NpbmdQb2x5bGluZUltYWdlc1JlYWR5KHJlc3BvbnNlLCB0ZXh0dXJlZFBvbHlsaW5lc1NwbGl0dGVkLCBpbWFnZXMpIHtcclxuICAgICAgICBjb25zdCB0aWxlID0gcmVzcG9uc2UudGlsZTtcclxuICAgICAgICB0aGlzLl9taW5vclRhc2tRdWV1ZS5lbnF1ZXVlKHtcclxuICAgICAgICAgICAgcHJpb3JpdHk6IERFRkFVTFRfSURMRV9UQVNLX1BSSU9SSVRZICsgdGhpcy5fZ2V0VGlsZVByaW9yaXR5KHRpbGUsIHRoaXMuX2lzVGlsZVZpc2libGUodGlsZSkpLFxyXG4gICAgICAgICAgICBleGVjdXRlOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNUaWxlU3RpbGxBY3RpdmUodGlsZSwgcmVzcG9uc2UucmVxdWVzdElkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHR1cmVkUG9seWxpbmVzID0gdGhpcy5fYWxsb2NhdGVUZXh0dXJlZFBvbHlsaW5lcyh0aWxlLCB0ZXh0dXJlZFBvbHlsaW5lc1NwbGl0dGVkLnByaW1pdGl2ZXNXaXRoTWlzc2luZ0ltYWdlcywgaW1hZ2VzKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wdXRUaWxlRGF0YSh0aWxlLCB7IHRleHR1cmVkUG9seWxpbmVzIH0sIHJlc3BvbnNlLnJlcXVlc3RJZCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaW1hZ2VzLmZvckVhY2gocmVsZWFzZVByaW1pdGl2ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIF9vbk1pc3NpbmdQb2x5Z29uSW1hZ2VzUmVhZHkocmVzcG9uc2UsIGltYWdlcykge1xyXG4gICAgICAgIGNvbnN0IHRpbGUgPSByZXNwb25zZS50aWxlO1xyXG4gICAgICAgIHRoaXMuX21pbm9yVGFza1F1ZXVlLmVucXVldWUoe1xyXG4gICAgICAgICAgICBwcmlvcml0eTogREVGQVVMVF9JRExFX1RBU0tfUFJJT1JJVFkgK1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZ2V0VGlsZVByaW9yaXR5KHRpbGUsIHRoaXMuX2lzVGlsZVZpc2libGUodGlsZSkpLFxyXG4gICAgICAgICAgICBleGVjdXRlOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNUaWxlU3RpbGxBY3RpdmUodGlsZSwgcmVzcG9uc2UucmVxdWVzdElkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHR1cmVkUG9seWdvbnMgPSB0aGlzLl9hbGxvY2F0ZVRleHR1cmVkUG9seWdvbnModGlsZSwgcmVzcG9uc2UudGV4dHVyZWRQb2x5Z29ucywgaW1hZ2VzLCByZXNwb25zZS50ZXh0dXJlZFBvbHlnb25QYWdlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHV0VGlsZURhdGEodGlsZSwgeyB0ZXh0dXJlZFBvbHlnb25zIH0sIHJlc3BvbnNlLnJlcXVlc3RJZCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaW1hZ2VzLmZvckVhY2gocmVsZWFzZVByaW1pdGl2ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIF9vblRpbGVFcnJvcih0aWxlKSB7XHJcbiAgICAgICAgc3VwZXIuX29uVGlsZUVycm9yKHRpbGUpO1xyXG4gICAgICAgIHRoaXMuX3JlcXVlc3RlZFRpbGVzU3RhdGUuZGVsZXRlKGdldFRpbGVJZCh0aWxlKSk7XHJcbiAgICB9XHJcbiAgICBfaXNUaWxlVmlzaWJsZSh0aWxlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRUaWxlcy5oYXMoZ2V0VGlsZUlkKHRpbGUpKTtcclxuICAgIH1cclxuICAgIF9hbGxvY2F0ZVBvbHlnb25zKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgY29uc3QgcG9seWdvblByaW1pdGl2ZXMgPSBuZXcgQXJyYXkocmVzcG9uc2UucG9seWdvbnMubGVuZ3RoICsgcmVzcG9uc2UudHJhbnNwYXJlbnRQb2x5Z29ucy5sZW5ndGgpO1xyXG4gICAgICAgIGNvbnN0IG1lbW9yeUNodW5rcyA9IG5ldyBNZW1vcnlDaHVua3MocmVzcG9uc2UucG9seWdvblBhZ2VzLCB0aGlzLl9tZW1vcnlNYW5hZ2VyLCBQT0xZR09OX0FUVFJJQlVURV9NQVBQSU5HKTtcclxuICAgICAgICBjb25zdCB0cmFuc3BhcmVudFBvbHlnb25zTWVtb3J5Q2h1bmtzID0gbmV3IE1lbW9yeUNodW5rcyhyZXNwb25zZS50cmFuc3BhcmVudFBvbHlnb25QYWdlcywgdGhpcy5fbWVtb3J5TWFuYWdlciwgVFJBTlNQQVJFTlRfUE9MWUdPTl9BVFRSSUJVVEVfTUFQUElORyk7XHJcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3BvbnNlLnBvbHlnb25zLmxlbmd0aDsgaSsrLCBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgYnVmZmVyTG9jYXRpb24gfSA9IHJlc3BvbnNlLnBvbHlnb25zW2ldO1xyXG4gICAgICAgICAgICBwb2x5Z29uUHJpbWl0aXZlc1tpbmRleF0gPSBuZXcgUmVuZGVyYWJsZVBvbHlnb24obmV3IE1lbW9yeVN1YkNodW5rKG1lbW9yeUNodW5rc1tidWZmZXJMb2NhdGlvbi5idWZmZXJJbmRleF0sIGJ1ZmZlckxvY2F0aW9uKSwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzcG9uc2UudHJhbnNwYXJlbnRQb2x5Z29ucy5sZW5ndGg7IGkrKywgaW5kZXgrKykge1xyXG4gICAgICAgICAgICBjb25zdCB7IGJ1ZmZlckxvY2F0aW9uIH0gPSByZXNwb25zZS50cmFuc3BhcmVudFBvbHlnb25zW2ldO1xyXG4gICAgICAgICAgICBwb2x5Z29uUHJpbWl0aXZlc1tpbmRleF0gPSBuZXcgUmVuZGVyYWJsZVBvbHlnb24obmV3IE1lbW9yeVN1YkNodW5rKHRyYW5zcGFyZW50UG9seWdvbnNNZW1vcnlDaHVua3NbYnVmZmVyTG9jYXRpb24uYnVmZmVySW5kZXhdLCBidWZmZXJMb2NhdGlvbiksIGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbWVtb3J5Q2h1bmtzLmZvckVhY2goKGNodW5rKSA9PiBjaHVuay5yZWxlYXNlKCkpO1xyXG4gICAgICAgIHRyYW5zcGFyZW50UG9seWdvbnNNZW1vcnlDaHVua3MuZm9yRWFjaCgoY2h1bmspID0+IGNodW5rLnJlbGVhc2UoKSk7XHJcbiAgICAgICAgcmV0dXJuIHBvbHlnb25QcmltaXRpdmVzO1xyXG4gICAgfVxyXG4gICAgX2FsbG9jYXRlVGV4dHVyZWRQb2x5Z29ucyh0aWxlLCBwb2x5Z29uRGVzY3JpcHRpb25zLCBpbWFnZXMsIHRleHR1cmVkUG9seWdvblBhZ2VzKSB7XHJcbiAgICAgICAgY29uc3QgdGV4dHVyZWRQb2x5Z29uUmV3cml0ZXIgPSBuZXcgVGV4dHVyZWRQb2x5Z29uQnVmZmVyUmV3cml0ZXIodGV4dHVyZWRQb2x5Z29uUGFnZXMpO1xyXG4gICAgICAgIGNvbnN0IHdvcmxkVG9QeEZhY3RvciA9IFdPUkxEX1NJWkUgLyAodGhpcy5fdGlsZVNpZGVTaXplUHggKiBNYXRoLnBvdygyLCB0aWxlLnpvb20pKTtcclxuICAgICAgICBjb25zdCBsb2NhdGlvbnMgPSBwb2x5Z29uRGVzY3JpcHRpb25zLm1hcCgocGFyc2VkUG9seWdvbiwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaW1hZ2UgPSBpbWFnZXNbaW5kZXhdO1xyXG4gICAgICAgICAgICBpZiAoaW1hZ2UpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFsbG9jYXRlZEltYWdlID0gaW1hZ2U7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXR0ZXJuID0gcGFyc2VkUG9seWdvbi5zdHlsZXNbMF0ucGF0dGVybjtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGltYWdlU2NhbGUgPSBwYXR0ZXJuLndpZHRoIC8gYWxsb2NhdGVkSW1hZ2UuZGVzY3JpcHRvci53aWR0aDtcclxuICAgICAgICAgICAgICAgIHRleHR1cmVkUG9seWdvblJld3JpdGVyLnJld3JpdGVVVihwYXJzZWRQb2x5Z29uLmJ1ZmZlckxvY2F0aW9uLCBhbGxvY2F0ZWRJbWFnZS5iYm94LCB3b3JsZFRvUHhGYWN0b3IgKiBpbWFnZVNjYWxlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZWRQb2x5Z29uLmJ1ZmZlckxvY2F0aW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBtZW1vcnlDaHVua3MgPSBuZXcgTWVtb3J5Q2h1bmtzKHRleHR1cmVkUG9seWdvblBhZ2VzLCB0aGlzLl9tZW1vcnlNYW5hZ2VyLCBURVhUVVJFRF9QT0xZR09OX0FUVFJJQlVURV9NQVBQSU5HKTtcclxuICAgICAgICBjb25zdCB0ZXh0dXJlZFBvbHlnb25QcmltaXRpdmVzID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NhdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgbG9jYXRpb24gPSBsb2NhdGlvbnNbaV07XHJcbiAgICAgICAgICAgIGNvbnN0IGltYWdlID0gaW1hZ2VzW2ldO1xyXG4gICAgICAgICAgICBpZiAobG9jYXRpb24gJiYgaW1hZ2UpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRleHR1cmVkUG9seWdvblByaW1pdGl2ZSA9IG5ldyBSZW5kZXJhYmxlVGV4dHVyZWRQb2x5Z29uKG5ldyBNZW1vcnlTdWJDaHVuayhtZW1vcnlDaHVua3NbbG9jYXRpb24uYnVmZmVySW5kZXhdLCBsb2NhdGlvbiksIGltYWdlKTtcclxuICAgICAgICAgICAgICAgIHRleHR1cmVkUG9seWdvblByaW1pdGl2ZXMucHVzaCh0ZXh0dXJlZFBvbHlnb25QcmltaXRpdmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1lbW9yeUNodW5rcy5mb3JFYWNoKChjaHVuaykgPT4gY2h1bmsucmVsZWFzZSgpKTtcclxuICAgICAgICByZXR1cm4gdGV4dHVyZWRQb2x5Z29uUHJpbWl0aXZlcztcclxuICAgIH1cclxuICAgIF9hbGxvY2F0ZU1lc2hlcyh0aWxlUmVzcG9uc2UpIHtcclxuICAgICAgICBjb25zdCBtZW1vcnlDaHVua3MgPSB0aWxlUmVzcG9uc2UubWVzaFBhZ2VzLm1hcCgocGFnZSkgPT4gdGhpcy5fbWVtb3J5TWFuYWdlci5hbGxvY2F0ZShwYWdlLnZlcnRleEJ1ZmZlciwgcGFnZS5pbmRleEJ1ZmZlciwgTW9kZWxCdWZmZXJXcml0ZXIuQVRUUklCVVRFX01BUFBJTkcpKTtcclxuICAgICAgICBjb25zdCBtZXNoUHJpbWl0aXZlcyA9IHRpbGVSZXNwb25zZS5tZXNoZXMubWFwKChtZXNoKSA9PiBuZXcgUmVuZGVyYWJsZU1vZGVsKG5ldyBNZW1vcnlTdWJDaHVuayhtZW1vcnlDaHVua3NbbWVzaC5idWZmZXJMb2NhdGlvbi5idWZmZXJJbmRleF0sIG1lc2guYnVmZmVyTG9jYXRpb24pKSk7XHJcbiAgICAgICAgbWVtb3J5Q2h1bmtzLmZvckVhY2goKGNodW5rKSA9PiBjaHVuay5yZWxlYXNlKCkpO1xyXG4gICAgICAgIHJldHVybiBtZXNoUHJpbWl0aXZlcztcclxuICAgIH1cclxuICAgIF9hbGxvY2F0ZVBvbHlsaW5lcyhyZXNwb25zZSkge1xyXG4gICAgICAgIGNvbnN0IHBvbHlsaW5lUHJpbWl0aXZlcyA9IG5ldyBBcnJheShyZXNwb25zZS5wb2x5bGluZXMubGVuZ3RoKTtcclxuICAgICAgICBjb25zdCBtZW1vcnlDaHVua3MgPSBuZXcgTWVtb3J5Q2h1bmtzKHJlc3BvbnNlLnBvbHlsaW5lUGFnZXMsIHRoaXMuX21lbW9yeU1hbmFnZXIsIFBPTFlMSU5FX0FUVFJJQlVURV9NQVBQSU5HKTtcclxuICAgICAgICBsZXQgaW5kZXggPSAwO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzcG9uc2UucG9seWxpbmVzLmxlbmd0aDsgaSsrLCBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgYnVmZmVyTG9jYXRpb24gfSA9IHJlc3BvbnNlLnBvbHlsaW5lc1tpXTtcclxuICAgICAgICAgICAgcG9seWxpbmVQcmltaXRpdmVzW2luZGV4XSA9IG5ldyBSZW5kZXJhYmxlUG9seWxpbmUobmV3IE1lbW9yeVN1YkNodW5rKG1lbW9yeUNodW5rc1tidWZmZXJMb2NhdGlvbi5idWZmZXJJbmRleF0sIGJ1ZmZlckxvY2F0aW9uKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1lbW9yeUNodW5rcy5mb3JFYWNoKChjaHVuaykgPT4gY2h1bmsucmVsZWFzZSgpKTtcclxuICAgICAgICByZXR1cm4gcG9seWxpbmVQcmltaXRpdmVzO1xyXG4gICAgfVxyXG4gICAgX2FsbG9jYXRlVGV4dHVyZWRQb2x5bGluZXModGlsZSwgcGFyc2VkUG9seWxpbmVzLCBpbWFnZXMpIHtcclxuICAgICAgICBjb25zdCB0ZXh0dXJlZFBvbHlsaW5lV3JpdGVyID0gbmV3IFRleHR1cmVkUG9seWxpbmVCdWZmZXJXcml0ZXIoKTtcclxuICAgICAgICBjb25zdCB3b3JsZFRvUHhGYWN0b3IgPSBXT1JMRF9TSVpFIC8gKHRoaXMuX3RpbGVTaWRlU2l6ZVB4ICogTWF0aC5wb3coMiwgdGlsZS56b29tKSk7XHJcbiAgICAgICAgY29uc3QgbG9jYXRpb25zID0gcGFyc2VkUG9seWxpbmVzLm1hcCgocGFyc2VkUG9seWxpbmUsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGltYWdlID0gaW1hZ2VzW2luZGV4XTtcclxuICAgICAgICAgICAgaWYgKGltYWdlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdHlsZSA9IHBhcnNlZFBvbHlsaW5lLnN0eWxlc1swXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gKHN0eWxlLmlubGluZSB8fCBzdHlsZS5vdXRsaW5lKS5zdHJva2VXaWR0aDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGltYWdlTG9jYXRpb24gPSBpbWFnZS5iYm94O1xyXG4gICAgICAgICAgICAgICAgLy8gaW1hZ2Ugc2l6ZSBtYXkgbm90IG1hdGNoIHBvbHlsaW5lJ3Mgc3Ryb2tlV2lkdGgsIHNvIGl0IG11c3QgYmUgc2NhbGVkIGFjY29yZGluZ2x5IGluXHJcbiAgICAgICAgICAgICAgICAvLyBib3RoIGRpcmVjdGlvbnMsIHRoaXMgZmFjdG9yIGNhbiBiZSBwYXNzZWQgdG8gdGhlIHdyaXRlciBpbiB3b3JsZFRvUHhGYWN0b3IgdXBkYXRlZC5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHBpeGVsUmF0aW8gPSB3aWR0aCAvIChpbWFnZUxvY2F0aW9uLm1heFkgLSBpbWFnZUxvY2F0aW9uLm1pblkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRleHR1cmVkUG9seWxpbmVXcml0ZXIud3JpdGVUZXh0dXJlZFBvbHlsaW5lKHBhcnNlZFBvbHlsaW5lLCB3aWR0aCwgd29ybGRUb1B4RmFjdG9yICogcGl4ZWxSYXRpbywgaW1hZ2VMb2NhdGlvbiwgc3R5bGUuekluZGV4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgcGFnZXMgPSB0ZXh0dXJlZFBvbHlsaW5lV3JpdGVyLmdldEJ1ZmZlcnMoKTtcclxuICAgICAgICBjb25zdCBtZW1vcnlDaHVua3MgPSBuZXcgTWVtb3J5Q2h1bmtzKHBhZ2VzLCB0aGlzLl9tZW1vcnlNYW5hZ2VyLCBUZXh0dXJlZFBvbHlsaW5lQnVmZmVyV3JpdGVyLkFUVFJJQlVURV9NQVBQSU5HKTtcclxuICAgICAgICBjb25zdCB0ZXh0dXJlZFBvbHlsaW5lUHJpbWl0aXZlcyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jYXRpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0gbG9jYXRpb25zW2ldO1xyXG4gICAgICAgICAgICBjb25zdCBpbWFnZSA9IGltYWdlc1tpXTtcclxuICAgICAgICAgICAgaWYgKGxvY2F0aW9uICYmIGltYWdlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0dXJlZFBvbHlsaW5lUHJpbWl0aXZlID0gbmV3IFJlbmRlcmFibGVUZXh0dXJlZFBvbHlsaW5lKG5ldyBNZW1vcnlTdWJDaHVuayhtZW1vcnlDaHVua3NbbG9jYXRpb24uYnVmZmVySW5kZXhdLCBsb2NhdGlvbiksIGltYWdlKTtcclxuICAgICAgICAgICAgICAgIHRleHR1cmVkUG9seWxpbmVQcmltaXRpdmVzLnB1c2godGV4dHVyZWRQb2x5bGluZVByaW1pdGl2ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbWVtb3J5Q2h1bmtzLmZvckVhY2goKGNodW5rKSA9PiBjaHVuay5yZWxlYXNlKCkpO1xyXG4gICAgICAgIHJldHVybiB0ZXh0dXJlZFBvbHlsaW5lUHJpbWl0aXZlcztcclxuICAgIH1cclxuICAgIF9hbGxvY2F0ZVBvaW50TGFiZWxzKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgY29uc3QgbWVtb3J5Q2h1bmtzID0gbmV3IE1lbW9yeUNodW5rcyhyZXNwb25zZS5wb2ludExhYmVsUGFnZXMsIHRoaXMuX21lbW9yeU1hbmFnZXIsIFBPSU5UX0xBQkVMX0FUVFJJQlVURV9NQVBQSU5HKTtcclxuICAgICAgICBjb25zdCBiYWNrZ3JvdW5kTWVtb3J5Q2h1bmtzID0gbmV3IE1lbW9yeUNodW5rcyhyZXNwb25zZS5wb2ludExhYmVsQmFja2dyb3VuZFBhZ2VzLCB0aGlzLl9tZW1vcnlNYW5hZ2VyLCBCSUxMQk9BUkRfUkVDVEFOR0xFX0FUVFJJQlVURV9NQVBQSU5HKTtcclxuICAgICAgICBjb25zdCBwb2ludExhYmVscyA9IHJlc3BvbnNlLnBvaW50TGFiZWxzLm1hcCgoeyBidWZmZXJMb2NhdGlvbiwgYmFja2dyb3VuZEJ1ZmZlckxvY2F0aW9uIH0pID0+IHtcclxuICAgICAgICAgICAgY29uc3QgYmFja2dyb3VuZFByaW1pdGl2ZSA9IGJhY2tncm91bmRCdWZmZXJMb2NhdGlvbiA/XHJcbiAgICAgICAgICAgICAgICBuZXcgUmVuZGVyYWJsZUJpbGxib2FyZFJlY3RhbmdsZShuZXcgTWVtb3J5U3ViQ2h1bmsoYmFja2dyb3VuZE1lbW9yeUNodW5rc1tiYWNrZ3JvdW5kQnVmZmVyTG9jYXRpb24uYnVmZmVySW5kZXhdLCBiYWNrZ3JvdW5kQnVmZmVyTG9jYXRpb24pKSA6XHJcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsUHJpbWl0aXZlID0gbmV3IFpvb21SZXN0cmljdGVkTGFiZWwobmV3IE1lbW9yeVN1YkNodW5rKG1lbW9yeUNodW5rc1tidWZmZXJMb2NhdGlvbi5idWZmZXJJbmRleF0sIGJ1ZmZlckxvY2F0aW9uKSwgdGhpcy5fZ2x5cGhBdGxhcywgdGhpcy5fY29tcHV0ZU1pblpvb20ocmVzcG9uc2UudGlsZSwgTUlOWk9PTV9ERUxUQVMucG9pbnRMYWJlbHMpLCBiYWNrZ3JvdW5kUHJpbWl0aXZlKTtcclxuICAgICAgICAgICAgaWYgKGJhY2tncm91bmRQcmltaXRpdmUpIHtcclxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRQcmltaXRpdmUucmVsZWFzZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBsYWJlbFByaW1pdGl2ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBiYWNrZ3JvdW5kTWVtb3J5Q2h1bmtzLmZvckVhY2goKGNodW5rKSA9PiBjaHVuay5yZWxlYXNlKCkpO1xyXG4gICAgICAgIG1lbW9yeUNodW5rcy5mb3JFYWNoKChjaHVuaykgPT4gY2h1bmsucmVsZWFzZSgpKTtcclxuICAgICAgICByZXR1cm4gcG9pbnRMYWJlbHM7XHJcbiAgICB9XHJcbiAgICBfYWxsb2NhdGVDdXJ2ZWRMYWJlbHMocmVzcG9uc2UpIHtcclxuICAgICAgICBjb25zdCBtZW1vcnlDaHVua3MgPSBuZXcgTWVtb3J5Q2h1bmtzKHJlc3BvbnNlLmN1cnZlZExhYmVsUGFnZXMsIHRoaXMuX21lbW9yeU1hbmFnZXIsIENVUlZFRF9MQUJFTF9BVFRSSUJVVEVfTUFQUElORyk7XHJcbiAgICAgICAgY29uc3QgY3VydmVkTGFiZWxQcmltaXRpdmVzID0gcmVzcG9uc2UuY3VydmVkTGFiZWxzLm1hcCgoeyBidWZmZXJMb2NhdGlvbiB9KSA9PiBuZXcgWm9vbVJlc3RyaWN0ZWRMYWJlbChuZXcgTWVtb3J5U3ViQ2h1bmsobWVtb3J5Q2h1bmtzW2J1ZmZlckxvY2F0aW9uLmJ1ZmZlckluZGV4XSwgYnVmZmVyTG9jYXRpb24pLCB0aGlzLl9nbHlwaEF0bGFzLCB0aGlzLl9jb21wdXRlTWluWm9vbShyZXNwb25zZS50aWxlLCBNSU5aT09NX0RFTFRBUy5jdXJ2ZWRMYWJlbHMpKSk7XHJcbiAgICAgICAgbWVtb3J5Q2h1bmtzLmZvckVhY2goKGNodW5rKSA9PiBjaHVuay5yZWxlYXNlKCkpO1xyXG4gICAgICAgIHJldHVybiBjdXJ2ZWRMYWJlbFByaW1pdGl2ZXM7XHJcbiAgICB9XHJcbiAgICBfYWxsb2NhdGVJY29ucyh0aWxlLCBwYXJzZWRJY29ucywgaW1hZ2VzKSB7XHJcbiAgICAgICAgY29uc3QgaWNvbldyaXRlciA9IG5ldyBJY29uQnVmZmVyV3JpdGVyKCk7XHJcbiAgICAgICAgY29uc3QgbG9jYXRpb25zID0gcGFyc2VkSWNvbnMubWFwKChwYXJzZWRJY29uLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBpbWFnZSA9IGltYWdlc1tpbmRleF07XHJcbiAgICAgICAgICAgIGlmIChpbWFnZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3R5bGUgPSBwYXJzZWRJY29uLnN0eWxlc1swXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNpemUgPSBpbWFnZS5kZXNjcmlwdG9yO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGl4ZWxSYXRpbyA9IHN0eWxlLndpZHRoIC8gc2l6ZS53aWR0aDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpY29uV3JpdGVyLndyaXRlSWNvbihwYXJzZWRJY29uLCBpbWFnZS5iYm94LCBzaXplLCBzdHlsZS5vZmZzZXQsIHBpeGVsUmF0aW8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBwYWdlcyA9IGljb25Xcml0ZXIuZ2V0QnVmZmVycygpO1xyXG4gICAgICAgIGNvbnN0IG1lbW9yeUNodW5rcyA9IG5ldyBNZW1vcnlDaHVua3MocGFnZXMsIHRoaXMuX21lbW9yeU1hbmFnZXIsIEljb25CdWZmZXJXcml0ZXIuQVRUUklCVVRFX01BUFBJTkcpO1xyXG4gICAgICAgIGNvbnN0IGljb25QcmltaXRpdmVzID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NhdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgbG9jYXRpb24gPSBsb2NhdGlvbnNbaV07XHJcbiAgICAgICAgICAgIGNvbnN0IGltYWdlID0gaW1hZ2VzW2ldO1xyXG4gICAgICAgICAgICBpZiAobG9jYXRpb24gJiYgaW1hZ2UpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGljb25QcmltaXRpdmUgPSBuZXcgWm9vbVJlc3RyaWN0ZWRJY29uKG5ldyBNZW1vcnlTdWJDaHVuayhtZW1vcnlDaHVua3NbbG9jYXRpb24uYnVmZmVySW5kZXhdLCBsb2NhdGlvbiksIGltYWdlLCB0aGlzLl9jb21wdXRlTWluWm9vbSh0aWxlLCBNSU5aT09NX0RFTFRBUy5pY29ucykpO1xyXG4gICAgICAgICAgICAgICAgaWNvblByaW1pdGl2ZXMucHVzaChpY29uUHJpbWl0aXZlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBtZW1vcnlDaHVua3MuZm9yRWFjaCgoY2h1bmspID0+IGNodW5rLnJlbGVhc2UoKSk7XHJcbiAgICAgICAgcmV0dXJuIGljb25QcmltaXRpdmVzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlcyBhIG1pbmltdW0gem9vbSBhbiBvYmplY3Qgc2hvdWxkIGJlIHN0aWxsIGRpc3BsYXllZCBvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdGlsZSBUaWxlIHRoZSBvYmplY3QgYmVsb25ncyB0by5cclxuICAgICAqIEBwYXJhbSBkZWx0YSBUb2xlcmFuY2Ugb2YgdGhlIHZpc2liaWxpdHkgdG8gem9vbWluZyBvdXQsIGRlZmF1bHQgdmFsdWUgd2FzIGVtcGlyaWNhbGx5IGNob3Nlbi5cclxuICAgICAqIEByZXR1cm5zIE1pbmltdW0gem9vbSBmb3IgdGhlIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgX2NvbXB1dGVNaW5ab29tKHRpbGUsIGRlbHRhID0gMSkge1xyXG4gICAgICAgIHJldHVybiB0aWxlLnpvb20gLSB0aGlzLl96b29tU2hpZnQgLSB0aGlzLl90YXJnZXRab29tU2hpZnQgLSBkZWx0YTtcclxuICAgIH1cclxuICAgIF9wdXNoUGVyZkxvZ0l0ZW0odGlsZSwgcGFyc2VUaW1lKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3BlcmZMb2dJdGVtcy5sZW5ndGggPCBNQVhfUEVSRl9MT0dfSVRFTVNfQ09VTlQpIHtcclxuICAgICAgICAgICAgdGhpcy5fcGVyZkxvZ0l0ZW1zLnB1c2goeyB0aWxlLCBwYXJzZVRpbWUgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBIZWxwZXIgY2xhc3MgZm9yIGFsbG9jYXRpb24gb2YgYW4gYXJyYXkgb2YgbWVtb3J5IGNodW5rcy5cclxuICovXHJcbmNsYXNzIE1lbW9yeUNodW5rcyBleHRlbmRzIEFycmF5IHtcclxuICAgIGNvbnN0cnVjdG9yKHBhZ2VzLCBtZW1vcnlNYW5hZ2VyLCBhdHRyaWJNYXBwaW5nKSB7XHJcbiAgICAgICAgc3VwZXIocGFnZXMubGVuZ3RoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZ2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXNbaV0gPSBtZW1vcnlNYW5hZ2VyLmFsbG9jYXRlKHBhZ2VzW2ldLnZlcnRleEJ1ZmZlciwgcGFnZXNbaV0uaW5kZXhCdWZmZXIsIGF0dHJpYk1hcHBpbmcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogRGF0YSBtYW5hZ2VycyByZXNwb25zaWJsZSBmb3Igc3BlY2lmaWMgdHlwZSBvZiBwcmltaXRpdmVzLiBJdCBqdXN0IGV4dHJhY3RzIHRoZW0gZnJvbSBUaWxlRGF0YSBhbmRcclxuICogdXBkYXRlcyBhcHByb3ByaWF0ZSBwcmltaXRpdmUgcHJvdmlkZXIuXHJcbiAqL1xyXG5jbGFzcyBUaWxlRGF0YU1hbmFnZXIge1xyXG4gICAgY29uc3RydWN0b3IocHJpbWl0aXZlTWFuYWdlciwgcHJpbWl0dmVFeHRyYWN0b3IpIHtcclxuICAgICAgICB0aGlzLl9wcmltaXRpdmVNYW5hZ2VyID0gcHJpbWl0aXZlTWFuYWdlcjtcclxuICAgICAgICB0aGlzLl9wcmltaXRpdmVFeHRyYWN0b3IgPSBwcmltaXR2ZUV4dHJhY3RvcjtcclxuICAgIH1cclxuICAgIHVwZGF0ZVByaW1pdGl2ZXModG9TaG93LCB0b0hpZGUpIHtcclxuICAgICAgICB0aGlzLl9wcmltaXRpdmVNYW5hZ2VyLnVwZGF0ZVNjZW5lKHRoaXMuX3ByaW1pdGl2ZUV4dHJhY3Rvcih0b1Nob3cpLCB0aGlzLl9wcmltaXRpdmVFeHRyYWN0b3IodG9IaWRlKSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcmVsZWFzZVByaW1pdGl2ZShwcmltaXRpdmUpIHtcclxuICAgIGlmIChwcmltaXRpdmUpIHtcclxuICAgICAgICBwcmltaXRpdmUucmVsZWFzZSgpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUdXJucyByZWplY3Rpb24gb2Ygb3JpZ2luYWwgcHJvbWlzZSBpbnRvIG51bGwtdmFsdWUgcmVzb2x1dGlvbi4gTnVsbHMgb24gYXBwcm9wcmlhdGUgcGxhY2VzXHJcbiAqIGFyZSByZXF1aXJlZCBpbiBhbGxvY2F0aW9uIG9mIHRleHR1cmVkIHByaW1pdGl2ZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBudWxsaWZ5UmVqZWN0aW9uKHByb21pc2UpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gcHJvbWlzZS50aGVuKHJlc29sdmUsICgpID0+IHJlc29sdmUobnVsbCkpKTtcclxufVxyXG4vKipcclxuICogU3BsaXRzIHByaW1pdGl2ZXMgaW50byB0d28gbGlzdHM6IHRob3NlIHRoYXQgaGF2ZSByZXF1aXJlZCBpbWFnZXMgYWxsb2NhdGVkIGFuZCB0aG9zZSB3aGljaCBpbWFnZXMgYXJlIHRvIGJlXHJcbiAqIHJlcXVlc3RlZC4gUmVxdWlyZWQgaW1hZ2VzIHJldHVybmVkIGluIGNvcnJlc3BvbmluZyBhcnJheXMgKHJlcXVlc3RlZCBpbWFnZXMgYXMgcHJvbWlzZXMpLlxyXG4gKi9cclxuZnVuY3Rpb24gc3BsaXRJbWFnZURlcGVuZGFudFByaW1pdGl2ZXMocHJpbWl0aXZlcywgaW1hZ2VNYW5hZ2VyLCBpZE1hcHBlcikge1xyXG4gICAgY29uc3QgcHJpbWl0aXZlc1dpdGhBbGxvY2F0ZWRJbWFnZXMgPSBbXTtcclxuICAgIGNvbnN0IGFsbG9jYXRlZEltYWdlcyA9IFtdO1xyXG4gICAgY29uc3QgcHJpbWl0aXZlc1dpdGhNaXNzaW5nSW1hZ2VzID0gW107XHJcbiAgICBjb25zdCBtaXNzaW5nSW1hZ2VJZHMgPSBbXTtcclxuICAgIGZvciAoY29uc3QgcHJpbWl0aXZlIG9mIHByaW1pdGl2ZXMpIHtcclxuICAgICAgICBjb25zdCBpZCA9IGlkTWFwcGVyKHByaW1pdGl2ZSk7XHJcbiAgICAgICAgY29uc3QgYWxsb2NhdGVkSW1hZ2UgPSBpbWFnZU1hbmFnZXIuZ2V0SW1hZ2UoaWQpO1xyXG4gICAgICAgIGlmIChhbGxvY2F0ZWRJbWFnZSkge1xyXG4gICAgICAgICAgICBwcmltaXRpdmVzV2l0aEFsbG9jYXRlZEltYWdlcy5wdXNoKHByaW1pdGl2ZSk7XHJcbiAgICAgICAgICAgIGFsbG9jYXRlZEltYWdlcy5wdXNoKGFsbG9jYXRlZEltYWdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHByaW1pdGl2ZXNXaXRoTWlzc2luZ0ltYWdlcy5wdXNoKHByaW1pdGl2ZSk7XHJcbiAgICAgICAgICAgIG1pc3NpbmdJbWFnZUlkcy5wdXNoKG51bGxpZnlSZWplY3Rpb24oaW1hZ2VNYW5hZ2VyLnJlcXVlc3RJbWFnZShpZCkpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHByaW1pdGl2ZXNXaXRoQWxsb2NhdGVkSW1hZ2VzLFxyXG4gICAgICAgIGFsbG9jYXRlZEltYWdlcyxcclxuICAgICAgICBwcmltaXRpdmVzV2l0aE1pc3NpbmdJbWFnZXMsXHJcbiAgICAgICAgbWlzc2luZ0ltYWdlczogUHJvbWlzZS5hbGwobWlzc2luZ0ltYWdlSWRzKVxyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBlaXRoZXIgYXJyYXkgb2YgYWxsb2NhdGVkIGltYWdlcyAoaWYgYWxsIHJlcXVpcmVkIGltYWdlcyBhcmUgb24gdGhlIHNwb3QpIG9yIHByb21pc2VzIGZvciB0aGVtIChpZiBhdCBsZWFzdFxyXG4gKiBvbmUgcmVxdWlyZWQgaW1hZ2UgaXMgbm90IHlldCBhbGxvY2F0ZWQpLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0SW1hZ2VzSWZBbGxBbGxvY2F0ZWQocHJpbWl0aXZlcywgaW1hZ2VNYW5hZ2VyLCBpZE1hcHBlcikge1xyXG4gICAgbGV0IGlzQW55TWlzc2luZyA9IGZhbHNlO1xyXG4gICAgY29uc3QgYWxsb2NhdGVkSW1hZ2VzID0gbmV3IEFycmF5KHByaW1pdGl2ZXMubGVuZ3RoKTtcclxuICAgIGNvbnN0IG1pc3NpbmdJbWFnZXMgPSBuZXcgQXJyYXkocHJpbWl0aXZlcy5sZW5ndGgpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmltaXRpdmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgcHJpbWl0aXZlID0gcHJpbWl0aXZlc1tpXTtcclxuICAgICAgICBjb25zdCBpZCA9IGlkTWFwcGVyKHByaW1pdGl2ZSk7XHJcbiAgICAgICAgY29uc3QgYWxsb2NhdGVkSW1hZ2UgPSBpbWFnZU1hbmFnZXIuZ2V0SW1hZ2UoaWQpO1xyXG4gICAgICAgIGlmIChhbGxvY2F0ZWRJbWFnZSkge1xyXG4gICAgICAgICAgICBhbGxvY2F0ZWRJbWFnZXNbaV0gPSBhbGxvY2F0ZWRJbWFnZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlzQW55TWlzc2luZyA9IHRydWU7XHJcbiAgICAgICAgICAgIG1pc3NpbmdJbWFnZXNbaV0gPSBudWxsaWZ5UmVqZWN0aW9uKGltYWdlTWFuYWdlci5yZXF1ZXN0SW1hZ2UoaWQpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoaXNBbnlNaXNzaW5nKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmltaXRpdmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChhbGxvY2F0ZWRJbWFnZXNbaV0pIHtcclxuICAgICAgICAgICAgICAgIG1pc3NpbmdJbWFnZXNbaV0gPSBQcm9taXNlLnJlc29sdmUoYWxsb2NhdGVkSW1hZ2VzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyBtaXNzaW5nSW1hZ2VzOiBQcm9taXNlLmFsbChtaXNzaW5nSW1hZ2VzKSB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHsgYWxsb2NhdGVkSW1hZ2VzIH07XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IEFkYXB0ZXIgZnJvbSAnLi4vYWRhcHRlcic7XHJcbmltcG9ydCBUaWxlQ29vcmRpbmF0ZVN5c3RlbSwgeyBpc1BhcmVudCB9IGZyb20gJy4vdXRpbC90aWxlX3N5c3RlbSc7XHJcbmltcG9ydCB7IGFsbE9mSXRlcmFibGUsIG9uZU9mSXRlcmFibGUgfSBmcm9tICcuLi8uLi91dGlsL2l0ZXJhYmxlJztcclxuaW1wb3J0IHsgZ2V0VGlsZUlkIH0gZnJvbSAnLi90aWxlX2lkJztcclxuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnLi4vLi4vdXRpbC9ldmVudF9lbWl0dGVyJztcclxuaW1wb3J0ICogYXMgdmVjMiBmcm9tICcuLi8uLi9tYXRoL3ZlY3RvcjInO1xyXG5pbXBvcnQgeyBOT19JRCB9IGZyb20gJy4uLy4uL3V0aWwvd29ya2VyJztcclxuaW1wb3J0IHsgY29tcHV0ZVZpc2libGVUaWxlcyB9IGZyb20gJy4vdXRpbC92aXNpYmxlX3RpbGUnO1xyXG5pbXBvcnQgeyBjYWxjdWxhdGVCZWx0VGlsZXMgfSBmcm9tICcuL2JlbHRfdGlsZXMnO1xyXG5pbXBvcnQgeyBjb3VudFRpbGVQcm9jZXNzaW5nVGltZSB9IGZyb20gJy4uLy4uL3V0aWwvc3RhdCc7XHJcbmNvbnN0IE5PX1RJTEVTX1RPX0hBTkRMRSA9IFtdO1xyXG5jb25zdCBNQVhfUEVSRl9MT0dfSVRFTVNfQ09VTlQgPSAxMDI0O1xyXG4vLyBUbyBzZWxlY3Qgd2hpY2ggdGlsZSB0byBsb2FkIGNhbWVyYSB6b29tIGlzIHJvdW5kZWQgc28gdGhlIHNoaWZ0IGlzIDAuNS5cclxuY29uc3QgVEFSR0VUX1pPT01fU0hJRlQgPSAwLjI1O1xyXG5jb25zdCBWSVNJQkxFX1RJTEVfUFJJT1JJVFkgPSAyMDA7XHJcbmZ1bmN0aW9uKiBmbGF0dGVuVmlzaWJsZURhdGFQb3J0aW9ucyh0aWxlcykge1xyXG4gICAgZm9yIChjb25zdCB0aWxlIG9mIHRpbGVzKSB7XHJcbiAgICAgICAgeWllbGQqIHRpbGUuZGF0YS52aXNpYmxlO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldFpvb21TaGlmdCh0aWxlU2l6ZSkge1xyXG4gICAgc3dpdGNoICh0aWxlU2l6ZSkge1xyXG4gICAgICAgIGNhc2UgMSAvKiBYNCAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIGNhc2UgMiAvKiBYMTYgKi86XHJcbiAgICAgICAgICAgIHJldHVybiAtMjtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQmFzZSBjbGFzcyBmb3IgYWRhcHRlcnMgdGhhdCBnZXQgdGhlaXIgZGF0YSBpbiB0aWxlcy4gQ29udGVudCBvZiB0aWxlcyB0aGF0IGNvbWUgaW50byBmaWVsZCBvZiB2aWV3IHNob3VsZFxyXG4gKiBiZSByZXF1ZXN0ZWQsIGFzIHdlbGwgYXMgY29udGVudCBvZiBpbnZpc2libGUgdGlsZXMgc2hvdWxkIGJlIHJlbW92ZWQsIGFsc28gdGlsZXMgb24gZGlmZmVyZW50IHpvb20gbGV2ZWxzIGNhblxyXG4gKiBvdmVybGFwIGVhY2ggb3RoZXIuIE1hbmFnaW5nIG9mIGFsbCB0aGVzZSBjYXNlcyBhbmQgb3RoZXIgdGlsZS1zcGVjaWZpYyBsb2dpYyBpcyB0aGUgcmVzcG9uc2liaWxpdHkgb2YgdGhpcyBjbGFzcy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRpbGVCYXNlZEFkYXB0ZXIgZXh0ZW5kcyBBZGFwdGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGVuZ2luZSwgY2FtZXJhLCB0aWxlU2l6ZSA9IDAgLyogWDEgKi8sIHByZWxvYWRlZFRpbGVzQmVsdFNpemUgPSAwLCBsYXllck5hbWUgPSAnJykge1xyXG4gICAgICAgIHN1cGVyKGVuZ2luZSwgY2FtZXJhKTtcclxuICAgICAgICB0aGlzLl9sYXllck5hbWUgPSBsYXllck5hbWU7XHJcbiAgICAgICAgdGhpcy5fem9vbVNoaWZ0ID0gZ2V0Wm9vbVNoaWZ0KHRpbGVTaXplKTtcclxuICAgICAgICB0aGlzLl90YXJnZXRab29tU2hpZnQgPSBUQVJHRVRfWk9PTV9TSElGVDtcclxuICAgICAgICB0aGlzLl9lbmdpbmVSZW5kZXJMaXN0ZW5lciA9ICgpID0+IHRoaXMuX29uRW5naW5lUmVuZGVyRXZlbnQoKTtcclxuICAgICAgICB0aGlzLmVuZ2luZS5yZW5kZXJlci5vblJlbmRlci5hZGRMaXN0ZW5lcih0aGlzLl9lbmdpbmVSZW5kZXJMaXN0ZW5lcik7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudFRpbGVzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuX2FsbFRpbGVzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuX3JlYWR5Rm9yUmVuZGVyVGlsZXMgPSBbXTtcclxuICAgICAgICB0aGlzLm9uVGlsZVJlYWR5ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMub25UaWxlTG9hZENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLl9yZXF1ZXN0ZWRUaWxlcyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLl90aWxlc1RvUmVmcmVzaCA9IG5ldyBTZXQoKTtcclxuICAgICAgICB0aGlzLl9iZWx0U2l6ZSA9IHByZWxvYWRlZFRpbGVzQmVsdFNpemU7XHJcbiAgICAgICAgLy8gU29tZXRpbWVzIHRoZSBhZGFwdGVyIGlzbid0IGRlc3Ryb3llZCwganVzdCB0aGUgcGFnZSBjbG9zZXMuIExpc3RlblxyXG4gICAgICAgIC8vIGZvciB0aGF0IGFuZCBzZW5kIG1lYXN1cmVtZW50cyB0byB0aGUgc3RhdGZhY2UuXHJcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIHRoaXMuX29uQmVmb3JlVW5sb2FkTGlzdGVuZXIgPSB0aGlzLl9zZW5kU3RhdGlzdGljc0JlZm9yZURlc3Ryb3kuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgdGhpcy5fdGlsZUxvYWRMb2dzID0gW107XHJcbiAgICB9XHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCB0aGlzLl9vbkJlZm9yZVVubG9hZExpc3RlbmVyKTtcclxuICAgICAgICB0aGlzLl9zZW5kU3RhdGlzdGljc0JlZm9yZURlc3Ryb3koKTtcclxuICAgICAgICB0aGlzLmVuZ2luZS5yZW5kZXJlci5vblJlbmRlci5yZW1vdmVMaXN0ZW5lcih0aGlzLl9lbmdpbmVSZW5kZXJMaXN0ZW5lcik7XHJcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xyXG4gICAgfVxyXG4gICAgZ2V0VmlzaWJsZVRpbGVzTnVtYmVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50VGlsZXMuc2l6ZTtcclxuICAgIH1cclxuICAgIGdldFBlbmRpbmdUaWxlc051bWJlcigpIHtcclxuICAgICAgICBsZXQgcGVuZGluZ0NvdW50ZXIgPSAwO1xyXG4gICAgICAgIHRoaXMuX3JlcXVlc3RlZFRpbGVzLmZvckVhY2goKHJlcXVlc3RlZFRpbGUpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRUaWxlcy5nZXQoZ2V0VGlsZUlkKHJlcXVlc3RlZFRpbGUudGlsZUl0ZW0pKSkge1xyXG4gICAgICAgICAgICAgICAgcGVuZGluZ0NvdW50ZXIrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBwZW5kaW5nQ291bnRlcjtcclxuICAgIH1cclxuICAgIF9nZXRUYXJnZXRab29tKCkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHRoaXMuY2FtZXJhLnpvb20gKyB0aGlzLl90YXJnZXRab29tU2hpZnQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gdGlsZUl0ZW0gVGhlIHRpbGUgdG8gd2hpY2ggdGhlIGRhdGEgYmVsb25ncy5cclxuICAgICAqIEBwYXJhbSBkYXRhIERhdGEgcG9ydGlvbiB0byBiZSBzaG93biBpbiB0aWxlIG9uY2UgaXQgaXMgcmVhZHkgdG8gdmlzdWFsaXplLlxyXG4gICAgICogQHBhcmFtIHJlcXVlc3RJZCBJRCBvZiB0aGUgcmVxdWVzdCBkYXRhIHdhcyByZXF1ZXN0ZWQgd2l0aC4gQmFzZWQgb24gdGhpcyB0aGUgZGF0YSBpcyBiZWluZyBkaXNwbGF5ZWQsIHN0b3JlZCBmb3JcclxuICAgICAqIGZ1dHVyZSB1c2Ugb3IgZGlzY2FyZGVkLlxyXG4gICAgICogQHBhcmFtIHZpc3VhbGl6ZSBJcyB0aGlzIGRhdGEgcG9ydGlvbiBlbm91Z2ggdG8gcmVuZGVyIHRoaXMgdGlsZSBhbmQgcmVwbGFjZSBvdmVybGFwcGVkIG9uZXMgaWYgYW55LlxyXG4gICAgICovXHJcbiAgICBfcHV0VGlsZURhdGEodGlsZUl0ZW0sIGRhdGEsIHJlcXVlc3RJZCA9IE5PX0lELCB2aXN1YWxpemUgPSB0cnVlKSB7XHJcbiAgICAgICAgY29uc3QgdGlsZSA9IHRoaXMuX2FsbFRpbGVzLmdldChnZXRUaWxlSWQodGlsZUl0ZW0pKTtcclxuICAgICAgICBpZiAoIXRpbGUpIHtcclxuICAgICAgICAgICAgLy8gRGF0YSByZWNpZXZlZCBsYXRlIGFuZCBwcm9iYWJseSB0aGUgdGlsZSBoYWQgYmVlbiBkZXN0cm95ZWQuXHJcbiAgICAgICAgICAgIC8vIERlc3Ryb3kgZGF0YSB0b28uXHJcbiAgICAgICAgICAgIHRoaXMuX29uVGlsZURlc3Ryb3kodGlsZUl0ZW0sIFtkYXRhXSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTk9fSUQgcGFzc2VkIGhlcmUgbWVhbnMgY29uY3JldGUgYWRhcHRlciBkb2Vzbid0IGNhcmUgdG8gbGFiZWwgdGlsZSBkYXRhIHdpdGggYSByZXF1ZXN0SWQgd2hpY2ggbW9zdCBsaWtlbHlcclxuICAgICAgICAvLyBtZWFucyBhZGFwdGVyIGtlZXBzIGl0cyBkYXRhIGFzIGEgd2hvbGUsIG5vdCBzcGxpdHRpbmcgaXQgaW50byBwb3J0aW9ucyBhbmQsIHRoZXJlZm9yZSwgZG9lc24ndCBuZWVkIGl0cyBkYXRhXHJcbiAgICAgICAgLy8gdG8gYmUgbWFpbnRhaW5lZCBzZXBhcmF0ZWx5IGFzIHZpc2libGUvYWN0dWFsLiBJbiB0aGlzIGNhc2UgdGhlIGRhdGEgaXMgYWx3YXlzIHRyZWF0ZWQgbGlrZSBhbiBhY3R1YWwgZGF0YS5cclxuICAgICAgICBpZiAocmVxdWVzdElkID09PSB0aWxlLmRhdGEudmlzaWJsZVJlcXVlc3RJZCAmJiByZXF1ZXN0SWQgIT09IE5PX0lEKSB7XHJcbiAgICAgICAgICAgIHRpbGUuZGF0YS52aXNpYmxlLnB1c2goZGF0YSk7XHJcbiAgICAgICAgICAgIGlmICh0aWxlLmlzVmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlIGRhdGEgaXMgY3VycmVudGx5IGRpc3BsYXllZCBzbyB0aGUgbmV3IHBvcnRpb24gaXMgYWRkZWQgdG8gdGhlIHNjZW5lLlxyXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlVGlsZURhdGFQb3J0aW9ucyhbZGF0YV0sIFtdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChyZXF1ZXN0SWQgPT09IHRpbGUuZGF0YS5hY3R1YWxSZXF1ZXN0SWQpIHtcclxuICAgICAgICAgICAgLy8gVGhlIGRhdGEgaXMgYWN0dWFsIGFuZCBlaXRoZXIgaXMganVzdCBiZWluZyBwdXQgaW50byB0aGUgdGlsZSBvciB2aXN1YWxpemVzIGFsbCBgYWN0dWFsYCB0aWxlIGRhdGEuXHJcbiAgICAgICAgICAgIHRoaXMuX3B1dEFjdHVhbFRpbGVEYXRhKHRpbGUsIGRhdGEsIHZpc3VhbGl6ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBUaGUgZGF0YSBpcyBuZWl0aGVyIHZpc2libGUgbm9yIGFjdHVhbC4gRGVzdHJveSBkYXRhLlxyXG4gICAgICAgICAgICB0aGlzLl9vblRpbGVEZXN0cm95KHRpbGVJdGVtLCBbZGF0YV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9vbkNhbWVyYVVwZGF0ZSgpIHtcclxuICAgICAgICBjb25zdCBjYW1lcmEgPSB0aGlzLmNhbWVyYTtcclxuICAgICAgICBjb25zdCB6b29tID0gdGhpcy5fZ2V0VGFyZ2V0Wm9vbSgpO1xyXG4gICAgICAgIGNvbnN0IG5ld0N1cnJlbnQgPSBuZXcgU2V0KGNvbXB1dGVWaXNpYmxlVGlsZXMoY2FtZXJhLmdldFZpc2libGVSZWdpb24oKSwgY2FtZXJhLmdldFZpc2libGVSZWdpb25CQm94KCksIGNhbWVyYS5vcHRpb25zLndyYXBNb2RlWCwgY2FtZXJhLm9wdGlvbnMud3JhcE1vZGVZLCBNYXRoLm1heCgwLCB6b29tICsgdGhpcy5fem9vbVNoaWZ0KSkpO1xyXG4gICAgICAgIC8vIHRoaXMuX2N1cnJlbnRUaWxlcyBjb250YWlucyBjdXJyZW50bHkgdmlzaWJsZSB0aWxlcywgbmV3Q3VycmVudCBjb250YWlucyBzZXQgb2YgdGlsZXMgdmlzaWJsZSBmcm9tIHVwZGF0ZWRcclxuICAgICAgICAvLyBjYW1lcmEgcG9zaXRpb24sIGNvbXBhcmUgdGhlc2UgdHdvIHNldHMgYW5kIGNhbGwgdGhpcy5fb25WaXNpYmxlVGlsZXNDaGFuZ2VkKCkgaWYgdGhlcmUgaXMgYSBkaWZmZXJlbmNlLlxyXG4gICAgICAgIGlmIChuZXdDdXJyZW50LnNpemUgIT09IHRoaXMuX2N1cnJlbnRUaWxlcy5zaXplIHx8XHJcbiAgICAgICAgICAgIG9uZU9mSXRlcmFibGUobmV3Q3VycmVudCwgKHRpbGUpID0+ICF0aGlzLl9jdXJyZW50VGlsZXMuaGFzKGdldFRpbGVJZCh0aWxlKSkpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX29uVmlzaWJsZVRpbGVzQ2hhbmdlZChuZXdDdXJyZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdGhpcyBjaGVja3MgcHJldmVudHMgbGVha3Mgb2YgdGlsZXMgd2hlbiBxdWljayB6b29tLWluL3pvb20tb3V0IGhhcHBlbnNcclxuICAgICAgICBmb3IgKGNvbnN0IHRpbGUgb2YgdGhpcy5fY3VycmVudFRpbGVzLnZhbHVlcygpKSB7XHJcbiAgICAgICAgICAgIGlmICh0aWxlLmlzUmVhZHlUb1Zpc3VhbGl6ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tUaWxlUmVwbGFjZW1lbnRzKHRpbGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX29uVGlsZXNSZXF1ZXN0KHJlcXVlc3RzLCByZXF1ZXN0SWQgPSBOT19JRCkge1xyXG4gICAgICAgIGZvciAoY29uc3QgdGlsZVJlcXVlc3Qgb2YgcmVxdWVzdHMpIHtcclxuICAgICAgICAgICAgY29uc3QgcmVxdWVzdGVkVGlsZURhdGEgPSB7XHJcbiAgICAgICAgICAgICAgICBpbmZvOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHk6IHRpbGVSZXF1ZXN0LnByaW9yaXR5XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgbG9hZFRpbWVzdGFtcHM6IHtcclxuICAgICAgICAgICAgICAgICAgICBxdWV1ZWQ6IHBlcmZvcm1hbmNlLm5vdygpLFxyXG4gICAgICAgICAgICAgICAgICAgIGxvYWRlZDogMCxcclxuICAgICAgICAgICAgICAgICAgICByZW5kZXJlZDogMCxcclxuICAgICAgICAgICAgICAgICAgICByZWFkeTogMFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHRpbGVJdGVtOiB0aWxlUmVxdWVzdFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCB0aWxlSWQgPSBnZXRUaWxlSWQodGlsZVJlcXVlc3QpO1xyXG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0ZWRUaWxlcy5zZXQodGlsZUlkLCByZXF1ZXN0ZWRUaWxlRGF0YSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlYWR5VGlsZXNDaGFuZ2UgPSB0cnVlO1xyXG4gICAgICAgICAgICBjb25zdCB0aWxlID0gdGhpcy5fYWxsVGlsZXMuZ2V0KHRpbGVJZCk7XHJcbiAgICAgICAgICAgIGlmICh0aWxlKSB7XHJcbiAgICAgICAgICAgICAgICB0aWxlLmRhdGEuYWN0dWFsUmVxdWVzdElkID0gcmVxdWVzdElkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX29uQ2FuY2VsVGlsZVJlcXVlc3RzKHJlcXVlc3RzKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCByZXF1ZXN0IG9mIHJlcXVlc3RzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRpbGVJZCA9IGdldFRpbGVJZChyZXF1ZXN0LnRpbGUpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fcmVxdWVzdGVkVGlsZXMuZGVsZXRlKHRpbGVJZCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlYWR5VGlsZXNDaGFuZ2UgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdGlsZXNUb1JlZnJlc2guZGVsZXRlKHRpbGVJZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfb25UaWxlRXJyb3IodGlsZUl0ZW0pIHtcclxuICAgICAgICBjb25zdCB0aWxlSWQgPSBnZXRUaWxlSWQodGlsZUl0ZW0pO1xyXG4gICAgICAgIGlmICh0aGlzLl9yZXF1ZXN0ZWRUaWxlcy5kZWxldGUodGlsZUlkKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZWFkeVRpbGVzQ2hhbmdlID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5fdGlsZXNUb1JlZnJlc2guZGVsZXRlKHRpbGVJZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyB3aGVyZSB0aGUgd2hvbGUgbWFnaWMgaGFwcGVucywgaXQgbWFuYWdlcyByZXBsYWNlbWVudCBvZiBjdXJyZW50IHNldCBvZiB2aXNpYmxlL3ByZWxvYWRlZCB0aWxlc1xyXG4gICAgICogd2l0aCBhIG5ldyBvbmUuXHJcbiAgICAgKi9cclxuICAgIF9vblZpc2libGVUaWxlc0NoYW5nZWQodmlzaWJsZVRpbGVzKSB7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudFRpbGVzLmNsZWFyKCk7XHJcbiAgICAgICAgY29uc3QgdGlsZXNUb1JlcXVlc3QgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IHRpbGVJdGVtIG9mIHZpc2libGVUaWxlcykge1xyXG4gICAgICAgICAgICBsZXQgdGlsZSA9IHRoaXMuX2FsbFRpbGVzLmdldChnZXRUaWxlSWQodGlsZUl0ZW0pKTtcclxuICAgICAgICAgICAgaWYgKCF0aWxlKSB7XHJcbiAgICAgICAgICAgICAgICB0aWxlID0gbmV3IFRpbGUodGlsZUl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWxsVGlsZXMuc2V0KHRpbGUuaWQsIHRpbGUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudFRpbGVzLnNldCh0aWxlLmlkLCB0aWxlKTtcclxuICAgICAgICAgICAgICAgIHRpbGVzVG9SZXF1ZXN0LnB1c2godGhpcy5fY3JlYXRlVGlsZVJlcXVlc3QodGlsZUl0ZW0sIHRoaXMuX2dldFRpbGVQcmlvcml0eSh0aWxlLnRpbGVJdGVtLCB0cnVlKSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudFRpbGVzLnNldCh0aWxlLmlkLCB0aWxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGlsZXNUb1JlcXVlc3QubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0VGlsZXModGlsZXNUb1JlcXVlc3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBiZWx0VGlsZXMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgZm9yIChjb25zdCBiZWx0VGlsZUl0ZW0gb2YgY2FsY3VsYXRlQmVsdFRpbGVzKHZpc2libGVUaWxlcywgdGhpcy5fYmVsdFNpemUsIHRoaXMuY2FtZXJhLm9wdGlvbnMud3JhcE1vZGVYID09PSAyIC8qIFJFUEVBVCAqLywgdGhpcy5jYW1lcmEub3B0aW9ucy53cmFwTW9kZVkgPT09IDIgLyogUkVQRUFUICovKSkge1xyXG4gICAgICAgICAgICBiZWx0VGlsZXMuc2V0KGdldFRpbGVJZChiZWx0VGlsZUl0ZW0pLCBiZWx0VGlsZUl0ZW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBiZWx0VGlsZXNUb1JlcXVlc3QgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IGJlbHRUaWxlSXRlbSBvZiBiZWx0VGlsZXMudmFsdWVzKCkpIHtcclxuICAgICAgICAgICAgY29uc3QgdGlsZUlkID0gZ2V0VGlsZUlkKGJlbHRUaWxlSXRlbSk7XHJcbiAgICAgICAgICAgIGxldCB0aWxlID0gdGhpcy5fYWxsVGlsZXMuZ2V0KHRpbGVJZCk7XHJcbiAgICAgICAgICAgIGlmICghdGlsZSkge1xyXG4gICAgICAgICAgICAgICAgdGlsZSA9IG5ldyBUaWxlKGJlbHRUaWxlSXRlbSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hbGxUaWxlcy5zZXQodGlsZUlkLCB0aWxlKTtcclxuICAgICAgICAgICAgICAgIGJlbHRUaWxlc1RvUmVxdWVzdC5wdXNoKHRoaXMuX2NyZWF0ZVRpbGVSZXF1ZXN0KGJlbHRUaWxlSXRlbSwgdGhpcy5fZ2V0VGlsZVByaW9yaXR5KGJlbHRUaWxlSXRlbSwgZmFsc2UpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGJlbHRUaWxlc1RvUmVxdWVzdC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdFRpbGVzKGJlbHRUaWxlc1RvUmVxdWVzdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGJyb2tlIGN1cnJlbnQgcmVsYXRpb25zaGlwcyB0byBzZXQgdGhlbSB1cCBhZ2FpbiBidXQgd2l0aCBuZXcgc2V0IG9mIHZpc2libGUgdGlsZXNcclxuICAgICAgICBmb3IgKGNvbnN0IHRpbGUgb2YgdGhpcy5fYWxsVGlsZXMudmFsdWVzKCkpIHtcclxuICAgICAgICAgICAgdGlsZS50b0JlUmVwbGFjZWRCeS5jbGVhcigpO1xyXG4gICAgICAgICAgICB0aWxlLnJlcGxhY2VtZW50Rm9yLmNsZWFyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRPRE86IG9wdGltaXplIHRoaXMgbl4yIHJlbGF0aW9uc2hpcHMgcmVzb2x2ZXJcclxuICAgICAgICBmb3IgKGNvbnN0IGN1cnJlbnRUaWxlIG9mIHRoaXMuX2N1cnJlbnRUaWxlcy52YWx1ZXMoKSkge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRpbGUgb2YgdGhpcy5fYWxsVGlsZXMudmFsdWVzKCkpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aWxlLmlzUmVhZHlUb1Zpc3VhbGl6ZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIChpc1BhcmVudCh0aWxlLnRpbGVJdGVtLCBjdXJyZW50VGlsZS50aWxlSXRlbSkgfHwgaXNQYXJlbnQoY3VycmVudFRpbGUudGlsZUl0ZW0sIHRpbGUudGlsZUl0ZW0pKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRpbGUudG9CZVJlcGxhY2VkQnkuYWRkKGN1cnJlbnRUaWxlKTtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VGlsZS5yZXBsYWNlbWVudEZvci5hZGQodGlsZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcmVtb3ZlIGludmlzaWJsZVxyXG4gICAgICAgIGNvbnN0IHRpbGVzVG9DYW5jZWwgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IHRpbGUgb2YgdGhpcy5fYWxsVGlsZXMudmFsdWVzKCkpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9jdXJyZW50VGlsZXMuaGFzKHRpbGUuaWQpICYmIHRpbGUudG9CZVJlcGxhY2VkQnkuc2l6ZSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRpbGUuaXNWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlVGlsZURhdGEoTk9fVElMRVNfVE9fSEFORExFLCBbdGlsZV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFiZWx0VGlsZXMuZ2V0KHRpbGUuaWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVzdHJveVRpbGUodGlsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGlsZXNUb0NhbmNlbC5wdXNoKHRpbGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aWxlc1RvQ2FuY2VsLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAvLyBpc3N1ZSBjYW5jZWxsYXRpb24gYWxzbyBpbiBjYXNlIHRoZXJlIGFyZSBub24gcHJvY2Vzc2VkIGRhdGEgZW5xdWV1ZWQgdG8gdHJ5IHRvIHNhdmUgc29tZSBlZmZvcnRzXHJcbiAgICAgICAgICAgIHRoaXMuX2NhbmNlbFRpbGVSZXF1ZXN0cyh0aWxlc1RvQ2FuY2VsYXRpb25zKHRpbGVzVG9DYW5jZWwpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfcmVmcmVzaEN1cnJlbnRUaWxlcygpIHtcclxuICAgICAgICBjb25zdCB0aWxlc1RvUmVxdWVzdCA9IFtdO1xyXG4gICAgICAgIGZvciAoY29uc3QgdGlsZSBvZiB0aGlzLl9jdXJyZW50VGlsZXMudmFsdWVzKCkpIHtcclxuICAgICAgICAgICAgY29uc3QgdGlsZUl0ZW0gPSB0aWxlLnRpbGVJdGVtO1xyXG4gICAgICAgICAgICBjb25zdCB0aWxlUmVxdWVzdCA9IHRoaXMuX2NyZWF0ZVRpbGVSZXF1ZXN0KHRpbGVJdGVtLCB0aGlzLl9nZXRUaWxlUHJpb3JpdHkodGlsZS50aWxlSXRlbSwgdHJ1ZSkpO1xyXG4gICAgICAgICAgICB0aWxlc1RvUmVxdWVzdC5wdXNoKHRpbGVSZXF1ZXN0KTtcclxuICAgICAgICAgICAgdGhpcy5fdGlsZXNUb1JlZnJlc2guYWRkKGdldFRpbGVJZCh0aWxlLnRpbGVJdGVtKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2NhbmNlbFRpbGVSZXF1ZXN0cyh0aWxlc1RvQ2FuY2VsYXRpb25zKHRoaXMuX2N1cnJlbnRUaWxlcy52YWx1ZXMoKSkpO1xyXG4gICAgICAgIHRoaXMuX3JlcXVlc3RUaWxlcyh0aWxlc1RvUmVxdWVzdCk7XHJcbiAgICB9XHJcbiAgICBfb25UaWxlRGF0YVJlYWR5KHRpbGVJdGVtLCB1cmwpIHtcclxuICAgICAgICBjb25zdCB0aWxlSWQgPSBnZXRUaWxlSWQodGlsZUl0ZW0pO1xyXG4gICAgICAgIGNvbnN0IHRpbGVEYXRhID0gdGhpcy5fcmVxdWVzdGVkVGlsZXMuZ2V0KHRpbGVJZCk7XHJcbiAgICAgICAgdGhpcy5fcmVxdWVzdGVkVGlsZXMuZGVsZXRlKHRpbGVJZCk7XHJcbiAgICAgICAgdGhpcy5fdGlsZXNUb1JlZnJlc2guZGVsZXRlKHRpbGVJZCk7XHJcbiAgICAgICAgdGlsZURhdGEuaW5mby51cmwgPSB1cmw7XHJcbiAgICAgICAgdGlsZURhdGEubG9hZFRpbWVzdGFtcHMubG9hZGVkID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAgICAgaWYgKHRoaXMuX3RpbGVMb2FkTG9ncy5sZW5ndGggPCBNQVhfUEVSRl9MT0dfSVRFTVNfQ09VTlQpIHtcclxuICAgICAgICAgICAgdGhpcy5fdGlsZUxvYWRMb2dzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgdGlsZUl0ZW0sXHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzaW5nVGltZTogdGlsZURhdGEubG9hZFRpbWVzdGFtcHMubG9hZGVkIC0gdGlsZURhdGEubG9hZFRpbWVzdGFtcHMucXVldWVkXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9yZWFkeUZvclJlbmRlclRpbGVzLnB1c2godGlsZURhdGEpO1xyXG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50VGlsZXMuZ2V0KHRpbGVJZCkpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVhZHlUaWxlc0NoYW5nZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2lzVGlsZVN0aWxsQWN0aXZlKHRpbGVJdGVtLCByZXF1ZXN0SWQgPSBOT19JRCkge1xyXG4gICAgICAgIGNvbnN0IHRpbGUgPSB0aGlzLl9hbGxUaWxlcy5nZXQoZ2V0VGlsZUlkKHRpbGVJdGVtKSk7XHJcbiAgICAgICAgaWYgKCF0aWxlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaXNSZXF1ZXN0QWN0aXZlID0gdGlsZS5kYXRhLmFjdHVhbFJlcXVlc3RJZCA9PT0gcmVxdWVzdElkIHx8IHRpbGUuZGF0YS52aXNpYmxlUmVxdWVzdElkID09PSByZXF1ZXN0SWQ7XHJcbiAgICAgICAgcmV0dXJuIGlzUmVxdWVzdEFjdGl2ZTtcclxuICAgIH1cclxuICAgIF9pc1RpbGVSZWZyZXNoaW5nKHRpbGUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdGlsZXNUb1JlZnJlc2guaGFzKGdldFRpbGVJZCh0aWxlKSk7XHJcbiAgICB9XHJcbiAgICBfZ2V0VGlsZVByaW9yaXR5KHRpbGUsIGlzVmlzaWJsZSkge1xyXG4gICAgICAgIGNvbnN0IGNlbnRlciA9IHRoaXMuX2NyZWF0ZVRpbGVDb29yZGluYXRlU3lzdGVtKCkudG9UaWxlQ29vcmRpbmF0ZXModGhpcy5jYW1lcmEuY2VudGVyKTtcclxuICAgICAgICBjb25zdCB6b29tRGlmZiA9IE1hdGguY2VpbCh0aGlzLmNhbWVyYS56b29tKSAtIHRpbGUuem9vbTtcclxuICAgICAgICBjb25zdCBkaXN0YW5jZSA9IHZlYzIuZGlzdGFuY2UodGlsZSwge1xyXG4gICAgICAgICAgICB4OiBNYXRoLmZsb29yKGNlbnRlci54IC8gTWF0aC5wb3coMiwgem9vbURpZmYpKSxcclxuICAgICAgICAgICAgeTogTWF0aC5mbG9vcihjZW50ZXIueSAvIE1hdGgucG93KDIsIHpvb21EaWZmKSlcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gKGlzVmlzaWJsZSA/IFZJU0lCTEVfVElMRV9QUklPUklUWSA6IDApICsgMSAvIChkaXN0YW5jZSArIDEpO1xyXG4gICAgfVxyXG4gICAgX3NlbmRTdGF0aXN0aWNzQmVmb3JlRGVzdHJveSgpIHtcclxuICAgICAgICBpZiAodGhpcy5fdGlsZUxvYWRMb2dzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGFjY3VtdWxhdGVkVGltaW5ncyA9IG5ldyBNYXAoKTtcclxuICAgICAgICBhY2N1bXVsYXRlZFRpbWluZ3Muc2V0KCdhdmVyYWdlJywge1xyXG4gICAgICAgICAgICBzdW06IDAsXHJcbiAgICAgICAgICAgIG51bWJlcjogMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX3RpbGVMb2FkTG9ncy5mb3JFYWNoKChsb2dJdGVtKSA9PiB7XHJcbiAgICAgICAgICAgIGFjY3VtdWxhdGVkVGltaW5ncy5nZXQoJ2F2ZXJhZ2UnKS5zdW0gKz0gbG9nSXRlbS5wcm9jZXNzaW5nVGltZTtcclxuICAgICAgICAgICAgYWNjdW11bGF0ZWRUaW1pbmdzLmdldCgnYXZlcmFnZScpLm51bWJlcisrO1xyXG4gICAgICAgICAgICBjb25zdCB6b29tID0gbG9nSXRlbS50aWxlSXRlbS56b29tLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGlmICghYWNjdW11bGF0ZWRUaW1pbmdzLmhhcyh6b29tKSkge1xyXG4gICAgICAgICAgICAgICAgYWNjdW11bGF0ZWRUaW1pbmdzLnNldCh6b29tLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VtOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIG51bWJlcjogMFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYWNjdW11bGF0ZWRUaW1pbmdzLmdldCh6b29tKS5zdW0gKz0gbG9nSXRlbS5wcm9jZXNzaW5nVGltZTtcclxuICAgICAgICAgICAgYWNjdW11bGF0ZWRUaW1pbmdzLmdldCh6b29tKS5udW1iZXIrKztcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgYWNjdW11bGF0ZWRUaW1pbmdzKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHpvb206IGl0ZW1bMF0sXHJcbiAgICAgICAgICAgICAgICB0aW1lOiAoaXRlbVsxXS5zdW0gLyBpdGVtWzFdLm51bWJlcilcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvdW50VGlsZVByb2Nlc3NpbmdUaW1lKHRoaXMuX2xheWVyTmFtZSwgcmVzdWx0KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUHV0cyBhY3R1YWwgZGF0YSBpbnRvIHRoZSB0aWxlIGFuZCBvcHRpb25hbGx5IHZpc3VhbGl6ZXMgaXQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRpbGUgVGlsZSB0byBwdXQgZGF0YSBpbnRvLlxyXG4gICAgICogQHBhcmFtIGRhdGEgRGF0YSB0byBiZSBzdG9yZWQgaW4gdGhlIHRpbGUgdW50aWwgdmlzdWFsaXphdGlvbi5cclxuICAgICAqIEBwYXJhbSB2aXN1YWxpemUgSWYgYHRydWVgIHJlcGxhY2VzIGB2aXNpYmxlYCB0aWxlIGRhdGEgd2l0aCBgYWN0dWFsYCB0aWxlIGRhdGEgYW5kIHVwZGF0ZXMgdGhlIHNjZW5lLlxyXG4gICAgICovXHJcbiAgICBfcHV0QWN0dWFsVGlsZURhdGEodGlsZSwgZGF0YSwgdmlzdWFsaXplKSB7XHJcbiAgICAgICAgdGlsZS5kYXRhLmFjdHVhbC5wdXNoKGRhdGEpO1xyXG4gICAgICAgIGlmICh2aXN1YWxpemUpIHtcclxuICAgICAgICAgICAgdGhpcy5fdmlzdWFsaXplVGlsZSh0aWxlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFZpc3VhbGl6ZXMgdGlsZSBgYWN0dWFsYCBkYXRhOiByZXBsYWNlcyB0aWxlIGB2aXNpYmxlYCBkYXRhIHdpdGggdGlsZSBgYWN0dWFsYCBkYXRhLCBhZGRzIGl0IHRvIHRoZSBzY2VuZSxcclxuICAgICAqIHJlbW92ZXMgb2xkIHZpc2libGUgZGF0YSBmcm9tIHRoZSBzY2VuZSBhbmQgZGVzdHJveXMgaXQsIGNoZWNrcyB0aWxlIHJlcGxhY2VtZW50cyBhbmQgdXBkYXRlcyBgdmlzaWJsZVJlcXVlc3RJZGAuXHJcbiAgICAgKiBAcGFyYW0gdGlsZSBUaWxlIHRvIHZpc3VhbGl6ZS5cclxuICAgICAqL1xyXG4gICAgX3Zpc3VhbGl6ZVRpbGUodGlsZSkge1xyXG4gICAgICAgIGNvbnN0IHRvRGVzdHJveSA9IHRpbGUuZGF0YS52aXNpYmxlO1xyXG4gICAgICAgIHRpbGUuZGF0YS52aXNpYmxlID0gdGlsZS5kYXRhLmFjdHVhbDtcclxuICAgICAgICB0aWxlLmRhdGEuYWN0dWFsID0gW107XHJcbiAgICAgICAgdGlsZS5kYXRhLnZpc2libGVSZXF1ZXN0SWQgPSB0aWxlLmRhdGEuYWN0dWFsUmVxdWVzdElkO1xyXG4gICAgICAgIGlmICghdGlsZS5pc1JlYWR5VG9WaXN1YWxpemUpIHtcclxuICAgICAgICAgICAgdGlsZS5pc1JlYWR5VG9WaXN1YWxpemUgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLl9jaGVja1RpbGVSZXBsYWNlbWVudHModGlsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRpbGUuaXNWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVRpbGVEYXRhUG9ydGlvbnModGlsZS5kYXRhLnZpc2libGUsIFtdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRvRGVzdHJveS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVRpbGVEYXRhUG9ydGlvbnMoW10sIHRvRGVzdHJveSk7XHJcbiAgICAgICAgICAgIHRoaXMuX29uVGlsZURlc3Ryb3kodGlsZS50aWxlSXRlbSwgdG9EZXN0cm95KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfY3JlYXRlVGlsZUNvb3JkaW5hdGVTeXN0ZW0oKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUaWxlQ29vcmRpbmF0ZVN5c3RlbSh0aGlzLmNhbWVyYS56b29tKTtcclxuICAgIH1cclxuICAgIC8vIFdlIG5lZWQgZG8gZGV0ZWN0IHdoZW4gdGlsZSBpcyByZW5kZXJlZCB0byBjb2xsZWN0IHBlcmZvbWFuY2UgbWV0cmljcy5cclxuICAgIC8vIFdlIGV4cGVjdCB0aGF0IHRpbGUgd2lsbCBiZSByZW5kZXJlZCB3aXRoIGZpcnN0IHJlbmRlciBldmVudCBhZnRlclxyXG4gICAgLy8gdGlsZSBkYXRhIGlzIGFkZGVkIHRvIHNjZW5lLlxyXG4gICAgX29uRW5naW5lUmVuZGVyRXZlbnQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3JlYWR5Rm9yUmVuZGVyVGlsZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlYWR5Rm9yUmVuZGVyVGlsZXMuZm9yRWFjaCgodGlsZURhdGEpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50VGlsZXMuaGFzKGdldFRpbGVJZCh0aWxlRGF0YS50aWxlSXRlbSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGlsZURhdGEubG9hZFRpbWVzdGFtcHMucmVuZGVyZWQgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgICAgICAgICAgICAgICB0aWxlRGF0YS5sb2FkVGltZXN0YW1wcy5yZWFkeSA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25UaWxlUmVhZHkuZmlyZSh0aWxlRGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLl9yZWFkeUZvclJlbmRlclRpbGVzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9yZWFkeVRpbGVzQ2hhbmdlKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25UaWxlTG9hZENoYW5nZS5maXJlKHtcclxuICAgICAgICAgICAgICAgIHRvdGFsVGlsZU51bWJlcjogdGhpcy5nZXRWaXNpYmxlVGlsZXNOdW1iZXIoKSxcclxuICAgICAgICAgICAgICAgIHJlYWR5VGlsZU51bWJlcjogdGhpcy5nZXRWaXNpYmxlVGlsZXNOdW1iZXIoKSAtIHRoaXMuZ2V0UGVuZGluZ1RpbGVzTnVtYmVyKClcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlYWR5VGlsZXNDaGFuZ2UgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNob3dzL2hpZGVzIHRpbGVzIGlmIHRoZXkgYXJlIG5vdCBzaG93bi9oaWRkZW4geWV0LiBJdCBub3RpZmllcyBzdWJjbGFzc2VzIGJ5IGNhbGxpbmcgYXBwcm9wcmlhdGVcclxuICAgICAqIGFic3RyYWN0IG1ldGhvZC4gRXZlbiB0aG91Z2ggdmlzaWJsZS9pbnZpc2libGUgdGlsZXMgYXJlIG5vdCBzdXBwb3NlZCB0byBiZSBzaG93bi9oaWRkZW4gYWdhaW4sXHJcbiAgICAgKiB0aGVyZSBhcmUgY2FzZXMgd2hlcmUgaXQgc2ltcGxpZmllcyB0aWxlIHZpc3VhbGl6YXRpb24gbG9naWMuXHJcbiAgICAgKiBJdCBpcyBpbXBvcnRhbnQgdG8gaGF2ZSBleGFjdGx5IFwidXBkYXRlXCIsIG5vdCBcImFkZFwiL1wicmVtb3ZlXCIgc2VwYXJhdGVseSwgYXMgc29tZSBidXNpbmVzcyBsb2dpYyBtYXkgcmVseSBvbiBpdCxcclxuICAgICAqIGUuZy4gbW9ycGhpbmcgdmlzaWJsZSBkYXRhIG9yIG1hbmFnaW5nIHNoYXJlZCByZXNvdXJjZXMuXHJcbiAgICAgKi9cclxuICAgIF91cGRhdGVUaWxlRGF0YSh0b1Nob3csIHRvUmVtb3ZlKSB7XHJcbiAgICAgICAgY29uc3QgZGF0YVRvU2hvdyA9IEFycmF5LmZyb20oZmxhdHRlblZpc2libGVEYXRhUG9ydGlvbnModG9TaG93KSk7XHJcbiAgICAgICAgY29uc3QgZGF0YVRvUmVtb3ZlID0gQXJyYXkuZnJvbShmbGF0dGVuVmlzaWJsZURhdGFQb3J0aW9ucyh0b1JlbW92ZSkpO1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZVRpbGVEYXRhUG9ydGlvbnMoZGF0YVRvU2hvdywgZGF0YVRvUmVtb3ZlKTtcclxuICAgICAgICBmb3IgKGNvbnN0IHRpbGUgb2YgdG9TaG93KSB7XHJcbiAgICAgICAgICAgIHRpbGUuaXNWaXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChjb25zdCB0aWxlIG9mIHRvUmVtb3ZlKSB7XHJcbiAgICAgICAgICAgIHRpbGUuaXNWaXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3VwZGF0ZVRpbGVEYXRhUG9ydGlvbnModG9TaG93LCB0b1JlbW92ZSkge1xyXG4gICAgICAgIHRoaXMuX29uVGlsZURhdGFVcGRhdGUodG9TaG93LCB0b1JlbW92ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgdGlsZSBpZiBpcyBub3QgcmVtb3ZlZCB3aXRoIGNhbGxpbmcgYWxsIGFwcHJvcHJpYXRlIGNhbGxiYWNrcyAoYWJzdHJhY3QgbWV0aG9kcylcclxuICAgICAqIHRvIG5vdGlmeSBkZXNjZW5kYW50IGNsYXNzZXMuIEV2ZW4gdGhvdWdoIHJlbW92ZWQgdGlsZSBpcyBub3Qgc3VwcG9zZWQgdG8gYmUgcmVtb3ZlZCBhZ2FpbixcclxuICAgICAqIGFsbG93aW5nIHRoaXMgbWFrZXMgbXVjaCBzaW1wbGVyIHRpbGUgbWFuYWdlbWVudCwgZXNwZWNpYWxseSBpbiB0aWxlIHJlcGxhY2VtZW50cyBsb2dpYyB3aGVyZSBtdWx0aXBsZVxyXG4gICAgICogdGlsZXMgY2FuIGhhdmUgbGlua3MgdG8gdGhlIHNhbWUgdGlsZSAodGhhdCBpcyB0byBiZSByZW1vdmVkKS5cclxuICAgICAqL1xyXG4gICAgX2Rlc3Ryb3lUaWxlKHRpbGUpIHtcclxuICAgICAgICBpZiAoIXRpbGUuaXNSZW1vdmVkKSB7XHJcbiAgICAgICAgICAgIHRpbGUuaXNSZW1vdmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5fYWxsVGlsZXMuZGVsZXRlKHRpbGUuaWQpO1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50VGlsZXMuZGVsZXRlKHRpbGUuaWQpO1xyXG4gICAgICAgICAgICB0aGlzLl9vblRpbGVEZXN0cm95KHRpbGUudGlsZUl0ZW0sIFsuLi50aWxlLmRhdGEuYWN0dWFsLCAuLi50aWxlLmRhdGEudmlzaWJsZV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIHRpbGVzIHRoYXQgY291bGQgYmUgcmVwbGFjZWQgYnkgdGhpcyBvbmUsIHNob3VsZCBiZSBjYWxsZWQgd2hlbiB0aWxlIGJlY29tZXMgcmVhZHkgdG8gdmlzdWFsaXplLlxyXG4gICAgICogQXMgb3ZlcmxhcHBpbmcgcmVsYXRpb25zaGlwcyBjYW4gaGFwcGVuIGluIGJvdGggZGlyZWN0aW9ucyAoY2hpbGRyZW4gYnkgcGFyZW50cyAvIHBhcmVudCBieSBjaGlsZHJlbikgdGhpc1xyXG4gICAgICogbWV0aG9kIGdvZXMgb25lIHN0ZXAgZGVlcGVyLCBpLmUuIGl0IGNoZWNrIG5vdCBvbmx5IHRpbGVzIHRoYXQgc2hvdWxkIGJlIHJlcGxhY2VkICh0byByZW1vdmUgdGhlbSksXHJcbiAgICAgKiBidXQgYWxzbyBhbGwgdGlsZXMgdGhhdCBjb3ZlciB0aGUgcmVwbGFjZWQgb25lcyAodG8gc2hvdyB0aGVtKS5cclxuICAgICAqL1xyXG4gICAgX2NoZWNrVGlsZVJlcGxhY2VtZW50cyh0aWxlKSB7XHJcbiAgICAgICAgY29uc3QgdG9EZXN0cm95ID0gbmV3IFNldCgpO1xyXG4gICAgICAgIGNvbnN0IHRvU2hvdyA9IG5ldyBTZXQoKTtcclxuICAgICAgICBjb25zdCB0b0hpZGUgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgZm9yIChjb25zdCB0aWxlVG9SZXBsYWNlIG9mIHRpbGUucmVwbGFjZW1lbnRGb3IpIHtcclxuICAgICAgICAgICAgaWYgKGFsbE9mSXRlcmFibGUodGlsZVRvUmVwbGFjZS50b0JlUmVwbGFjZWRCeSwgKHRpbGUpID0+IHRpbGUuaXNSZWFkeVRvVmlzdWFsaXplKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRpbGVUb1JlcGxhY2UuaXNWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9IaWRlLmFkZCh0aWxlVG9SZXBsYWNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghdGlsZVRvUmVwbGFjZS5pc1JlbW92ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0b0Rlc3Ryb3kuYWRkKHRpbGVUb1JlcGxhY2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB0aWxlVG9TaG93IG9mIHRpbGVUb1JlcGxhY2UudG9CZVJlcGxhY2VkQnkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRpbGVUb1Nob3cuaXNWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvU2hvdy5hZGQodGlsZVRvU2hvdyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aWxlLnJlcGxhY2VtZW50Rm9yLnNpemUgPT09IDAgJiYgIXRpbGUuaXNWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgIHRvU2hvdy5hZGQodGlsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0b1Nob3cuc2l6ZSA+IDAgfHwgdG9IaWRlLnNpemUgPiAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVRpbGVEYXRhKHRvU2hvdywgdG9IaWRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChjb25zdCB0aWxlVG9EZXN0cm95IG9mIHRvRGVzdHJveSkge1xyXG4gICAgICAgICAgICB0aGlzLl9kZXN0cm95VGlsZSh0aWxlVG9EZXN0cm95KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRvRGVzdHJveS5zaXplID4gMCkge1xyXG4gICAgICAgICAgICB0aGlzLl9jYW5jZWxUaWxlUmVxdWVzdHModGlsZXNUb0NhbmNlbGF0aW9ucyh0b0Rlc3Ryb3kpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFRoaXMgY2xhc3MgaXMgdGhlIG1haW4gdW5pdCBvZiB0aGUgd2hvbGUgcHJvY2VzcyBvZiB0aWxlIG1hbmFnZW1lbnQuIEl0IHN0b3JlcyB2aXN1YWxpemFibGUgZGF0YSBhbmQgbGlua3MgdG9cclxuICogZGVwZW5kYW50IHRpbGVzIChmb3IgcGFyZW50L2NoaWxkIG92ZXJsYXBwaW5nIGNhc2VzKS5cclxuICovXHJcbmNsYXNzIFRpbGUge1xyXG4gICAgY29uc3RydWN0b3IodGlsZUl0ZW0pIHtcclxuICAgICAgICB0aGlzLmRhdGEgPSB7XHJcbiAgICAgICAgICAgIGFjdHVhbDogW10sXHJcbiAgICAgICAgICAgIHZpc2libGU6IFtdLFxyXG4gICAgICAgICAgICBhY3R1YWxSZXF1ZXN0SWQ6IE5PX0lELFxyXG4gICAgICAgICAgICB2aXNpYmxlUmVxdWVzdElkOiBOT19JRFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy50aWxlSXRlbSA9IHRpbGVJdGVtO1xyXG4gICAgICAgIHRoaXMuaWQgPSBgJHt0aWxlSXRlbS54fToke3RpbGVJdGVtLnl9OiR7dGlsZUl0ZW0uem9vbX1gO1xyXG4gICAgICAgIHRoaXMuaXNSZWFkeVRvVmlzdWFsaXplID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pc1Zpc2libGUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmlzUmVtb3ZlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMudG9CZVJlcGxhY2VkQnkgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgdGhpcy5yZXBsYWNlbWVudEZvciA9IG5ldyBTZXQoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiB0aWxlc1RvQ2FuY2VsYXRpb25zKHRpbGVzKSB7XHJcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aWxlcywgKHRpbGUpID0+ICh7XHJcbiAgICAgICAgdGlsZTogdGlsZS50aWxlSXRlbSxcclxuICAgICAgICByZXF1ZXN0SWQ6IHRpbGUuZGF0YS5hY3R1YWxSZXF1ZXN0SWRcclxuICAgIH0pKTtcclxufVxyXG4iLCJpbXBvcnQgeyBkZWJvdW5jZSB9IGZyb20gJy4uL3V0aWwvZnVuY3Rpb24nO1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBZGFwdGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGVuZ2luZSwgY2FtZXJhLCBjYW1lcmFVcGRhdGVEZWxheSA9IDUpIHtcclxuICAgICAgICB0aGlzLmVuZ2luZSA9IGVuZ2luZTtcclxuICAgICAgICB0aGlzLmNhbWVyYSA9IGNhbWVyYTtcclxuICAgICAgICB0aGlzLl9jYW1lcmFVcGRhdGVMaXN0ZW5lciA9IGRlYm91bmNlKHRoaXMuX29uQ2FtZXJhVXBkYXRlLmJpbmQodGhpcyksIGNhbWVyYVVwZGF0ZURlbGF5KTtcclxuICAgICAgICBjYW1lcmEub25VcGRhdGUuYWRkTGlzdGVuZXIodGhpcy5fY2FtZXJhVXBkYXRlTGlzdGVuZXIpO1xyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLmNhbWVyYS5vblVwZGF0ZS5yZW1vdmVMaXN0ZW5lcih0aGlzLl9jYW1lcmFVcGRhdGVMaXN0ZW5lcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbWVyYSB1cGRhdGUgaGFuZGxlciwgYnkgZGVmYXVsdCBkbyBub3RoaW5nLlxyXG4gICAgICovXHJcbiAgICBfb25DYW1lcmFVcGRhdGUoKSB7IH1cclxufVxyXG4iLCIvKipcclxuICogQ3JlYXRlcyBuZXcgZnVuY3Rpb24gd2hpY2ggZXhlY3V0aW9uIGlzIFwiZGVib3VuY2VkXCIuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCkge1xyXG4gICAgbGV0IHRpbWVvdXQgPSAwO1xyXG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XHJcbiAgICAgICAgY29uc3QgbGF0ZXIgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRpbWVvdXQgPSAwO1xyXG4gICAgICAgICAgICBmdW5jKC4uLmFyZ3MpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHRpbWVvdXQpIHtcclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XHJcbiAgICB9O1xyXG59XHJcbiIsImltcG9ydCB7IGNsYW1wIH0gZnJvbSAnLi4vLi4vLi4vbWF0aC9zY2FsYXInO1xyXG4vKipcclxuICogQHJldHVybiBgdHJ1ZWAgaWYgdGhlIGZpcnN0IHBhcmFtIG92ZXJsYXBzIHRoZSBzZWNvbmQgaW4gdGlsZSBoaWVyYXJjaHkuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNQYXJlbnQocG90ZW50aWFsUGFyZW50LCBwb3NzaWJsZUNoaWxkKSB7XHJcbiAgICBjb25zdCB6b29tRGlmZiA9IHBvc3NpYmxlQ2hpbGQuem9vbSAtIHBvdGVudGlhbFBhcmVudC56b29tO1xyXG4gICAgcmV0dXJuIHpvb21EaWZmID4gMCAmJlxyXG4gICAgICAgIHBvc3NpYmxlQ2hpbGQueCA+PiB6b29tRGlmZiA9PT0gcG90ZW50aWFsUGFyZW50LnggJiZcclxuICAgICAgICBwb3NzaWJsZUNoaWxkLnkgPj4gem9vbURpZmYgPT09IHBvdGVudGlhbFBhcmVudC55O1xyXG59XHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRpbGVDb29yZGluYXRlU3lzdGVtIHtcclxuICAgIGNvbnN0cnVjdG9yKHpvb20pIHtcclxuICAgICAgICB0aGlzLl96b29tID0gTWF0aC5jZWlsKGNsYW1wKHpvb20sIDAsIDMxKSk7XHJcbiAgICAgICAgdGhpcy5fdGlsZVNpemUgPSAyIC8gKDEgPDwgdGhpcy5fem9vbSk7XHJcbiAgICB9XHJcbiAgICBnZXRab29tKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl96b29tO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIFRpbGUgc2lkZSBsZW5ndGggaW4gdW5pdHMgb2YgdGhlIHdvcmxkIGNvb3JkaW5hdGUgc3lzdGVtLlxyXG4gICAgICovXHJcbiAgICBnZXRUaWxlU2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdGlsZVNpemU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gVG9wIGxlZnQgY29ybmVyIGNvb3JkaW5hdGVzIG9mIHRoZSB0aWxlLlxyXG4gICAgICovXHJcbiAgICBnZXRUaWxlT2Zmc2V0KHRpbGUpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB4OiB0aGlzLmdldFRpbGVTaXplKCkgKiB0aWxlLnggLSAxLFxyXG4gICAgICAgICAgICB5OiAxIC0gdGhpcy5nZXRUaWxlU2l6ZSgpICogdGlsZS55XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHRvVGlsZUNvb3JkaW5hdGVzKHdvcmxkQ29vcmRpbmF0ZXMpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB4OiAod29ybGRDb29yZGluYXRlcy54ICsgMSkgLyB0aGlzLl90aWxlU2l6ZSxcclxuICAgICAgICAgICAgeTogKDEgLSB3b3JsZENvb3JkaW5hdGVzLnkpIC8gdGhpcy5fdGlsZVNpemVcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbiIsImV4cG9ydCBmdW5jdGlvbiBnZXRUaWxlSWRCeVJhd1ZhbHVlcyh4LCB5LCB6b29tKSB7XHJcbiAgICByZXR1cm4gYCR7eH06JHt5fToke3pvb219YDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0VGlsZUlkKHRpbGUpIHtcclxuICAgIHJldHVybiBnZXRUaWxlSWRCeVJhd1ZhbHVlcyh0aWxlLngsIHRpbGUueSwgdGlsZS56b29tKTtcclxufVxyXG4iLCIvKipcclxuICogQmFzZSBpbnRlcmZhY2UgZm9yIHdlYndvcmtlciBtZXNzYWdlcywgYm90aCBpbmNvbWluZyBhbmQgb3V0Z29pbmcgb25lcy5cclxuICpcclxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVHJhbnNmZXJhYmxlXHJcbiAqL1xyXG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICcuL2V2ZW50X2VtaXR0ZXInO1xyXG5pbXBvcnQgeyB1bmlxdWVJZCB9IGZyb20gJy4vdW5pcXVlX2lkJztcclxuY29uc3QgTUVTU0FHRV9CQVRDSF9NQVhfU0laRSA9IDUwO1xyXG5jb25zdCBGTFVTSF9USU1FT1VUID0gNTA7XHJcbi8vIGVhY2ggc3Vic2VxdWVudCBtZXNzYWdlIGRlYm91bmNlcyBwb3N0TWVzc2FnZSBjYWxsLCB0aGF0IGNhbiBsZWFkIHRvIGluZmluaXRlIGRlbGF5LCB0aGlzIGNvbnN0IGxpbWl0cyBpdFxyXG5jb25zdCBNQVhfRkxVU0hfVElNRU9VVCA9IDI1MDtcclxuZXhwb3J0IGNvbnN0IE5PX0lEID0gLTE7XHJcbi8qKlxyXG4gKiBDaGVja3MgbWVzc2FnZSB0eXBlIHdpdGggdHlwZSBndWFyZGluZy4gSXQgZ2l2ZXMgYSBsaXR0bGUgYml0IG1vcmUgZWxlZ2FudCBhbHRlcm5hdGl2ZVxyXG4gKiB0byB0YWdnZWQgdHlwZSB1bmlvbnMgcHJvdmlkaW5nIHRoZSBzYW1lIHR5cGUgc2FmZXR5LlxyXG4gKlxyXG4gKiBAcGFyYW0gbWVzc2FnZSB0byBiZSBjaGVja2VkXHJcbiAqIEBwYXJhbSB0eXBlIHRoZSB2YWx1ZSBvZiB0aGUgXCJ0eXBlXCIgcHJvcGVydHlcclxuICogQHJldHVybiB7Ym9vbGVhbn1cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBtZXNzYWdlSXMobWVzc2FnZSwgdHlwZSkge1xyXG4gICAgcmV0dXJuIG1lc3NhZ2UudHlwZSA9PT0gdHlwZTtcclxufVxyXG4vKipcclxuICogQmFzZSBjbGFzcyBmb3IgYm90aCBzaWRlcyBvZiBhIHdlYndvcmtlcjogaXRzIGltcGxlbWVudGF0aW9uIChzZXBhcmF0ZSBqcyB0aGF0IGlzIHJ1biBpbiBhIHdvcmtlciB0aHJlYWQpIGFuZFxyXG4gKiBhIGNvbnRyb2xsZXIgZm9yIHRoZSBtYWluIHRocmVhZC4gVGhleSBoYXZlIHNpbWlsYXIgbWVjaGFuaXNtIG9mIHNlbmRpbmcvcmVjZWl2aW5nIG1lc3NhZ2VzIHRoYXQgaXMgaW1wbGVtZW50IGhlcmUuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgV2ViV29ya2VyQ29tbXVuaWNhdG9yIHtcclxuICAgIGNvbnN0cnVjdG9yKGFkZHJlc3NlZSkge1xyXG4gICAgICAgIHRoaXMuX2FkZHJlc3NlZSA9IGFkZHJlc3NlZTtcclxuICAgICAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuX3RyYW5zZmVyYWJsZUV4dHJhY3RvcnMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5fbWVzc2FnZXMgPSBbXTtcclxuICAgICAgICB0aGlzLl90cmFuc2ZlcmFibGVzID0gW107XHJcbiAgICAgICAgdGhpcy5fdGltZW91dEhhbmRsZSA9IDA7XHJcbiAgICAgICAgdGhpcy5fZmx1c2hNZXNzYWdlc0JpbmRlZCA9IHRoaXMuX2ZsdXNoTWVzc2FnZXMuYmluZCh0aGlzKTtcclxuICAgIH1cclxuICAgIHNldFRyYW5zZmVyYWJsZUV4dHJhY3Rvcih0eXBlLCBleHRyYWN0b3IpIHtcclxuICAgICAgICB0aGlzLl90cmFuc2ZlcmFibGVFeHRyYWN0b3JzLnNldCh0eXBlLCBleHRyYWN0b3IpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZW5kIGEgbWVzc2FnZSB0byB0aGUgb3Bwb3NpdGUgc2lkZSBvZiB0aGUgd2ViIHdvcmtlciBjb21tdW5pY2F0aW9uIGNoYW5uZWwuXHJcbiAgICAgKiBNZXNzYWdlcyBhcmUgYmF0Y2hlZCBieSBkZWxheWluZyBwb3N0TWVzc2FnZSBjYWxsIHRvIGdyb3VwIG1lc3NhZ2VzIHRoYXQgY29tZSBkdXJpbmcgdGhpcyBkZWxheSBhbmQgbWluaW1pemVcclxuICAgICAqIHRoZSBudW1iZXIgb2YgaW50ZXJwcm9jZXNzIGNvbW11bmljYXRpb25zIHRoYXQgYmFkbHkgYWZmZWN0IHBlcmZvcm1hbmNlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtZXNzYWdlIE1lc3NhZ2UgdG8gYmUgc2VudC5cclxuICAgICAqIEBwYXJhbSB1cmdlbmN5IElNTUVESUFURSBmb3JjZXMgbWVzc2FnZSB0byBiZSBzZW50IGltbWVkaWF0ZWx5IChzeW5jaHJvbm91cyBjYWxsKSB3aXRoIG5vIGJhdGNoaW5nIGRlbGF5LFxyXG4gICAgICogICAgICAgICAgICAgICAgREVGQVVMVCBkZWJvdW5jZXMgc2VuZGluZyBmb3IgYW5vdGhlciBGTFVTSF9USU1FT1VULlxyXG4gICAgICovXHJcbiAgICBzZW5kTWVzc2FnZShtZXNzYWdlLCB1cmdlbmN5ID0gMCAvKiBERUZBVUxUICovKSB7XHJcbiAgICAgICAgY29uc3QgdHJhbnNmZXJhYmxlRXh0cmFjdG9yID0gdGhpcy5fdHJhbnNmZXJhYmxlRXh0cmFjdG9ycy5nZXQobWVzc2FnZS50eXBlKTtcclxuICAgICAgICBjb25zdCB0cmFuc2ZlcmFibGVzID0gdHJhbnNmZXJhYmxlRXh0cmFjdG9yID8gdHJhbnNmZXJhYmxlRXh0cmFjdG9yKG1lc3NhZ2UpIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIGNvbnN0IGlzRmlyc3RNZXNzYWdlSW5CYXRjaCA9ICh0aGlzLl9tZXNzYWdlcy5sZW5ndGggPT09IDApO1xyXG4gICAgICAgIGlmIChpc0ZpcnN0TWVzc2FnZUluQmF0Y2gpIHtcclxuICAgICAgICAgICAgdGhpcy5fZmlyc3RNZXNzYWdlVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTZW5kIG1lc3NhZ2VzIGFzeW5jaHJvbm91c2x5IHBhY2tpbmcgdGhlbSBpbnRvIG9uZSBtZXNzYWdlLlxyXG4gICAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gYWJ1c2UgdGhlIHdlYiB3b3JrZXIgY29tbXVuaWNhdGlvbiBjaGFubmVsIGFuZFxyXG4gICAgICAgIC8vIHNlbmQgbWVzc2FnZXMgYXN5bmNocm9ub3VzbHkgaW4gc2hvcnQgcGVyaW9kIG9mIHRpbWUgb3IgbWFueSBtZXNzYWdlcyBzeW5jaHJvbm91c2x5LlxyXG4gICAgICAgIHRoaXMuX21lc3NhZ2VzLnB1c2gobWVzc2FnZSk7XHJcbiAgICAgICAgaWYgKHRyYW5zZmVyYWJsZXMpIHtcclxuICAgICAgICAgICAgdGhpcy5fdHJhbnNmZXJhYmxlcyA9IHRoaXMuX3RyYW5zZmVyYWJsZXMuY29uY2F0KHRyYW5zZmVyYWJsZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dEhhbmRsZSk7XHJcbiAgICAgICAgaWYgKHRoaXMuX21lc3NhZ2VzLmxlbmd0aCA+IE1FU1NBR0VfQkFUQ0hfTUFYX1NJWkUgfHxcclxuICAgICAgICAgICAgdXJnZW5jeSA9PT0gMSAvKiBJTU1FRElBVEUgKi8gfHxcclxuICAgICAgICAgICAgKCFpc0ZpcnN0TWVzc2FnZUluQmF0Y2ggJiYgKHBlcmZvcm1hbmNlLm5vdygpIC0gdGhpcy5fZmlyc3RNZXNzYWdlVGltZSkgPiBNQVhfRkxVU0hfVElNRU9VVCkpIHtcclxuICAgICAgICAgICAgdGhpcy5fZmx1c2hNZXNzYWdlcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fdGltZW91dEhhbmRsZSA9IHNldFRpbWVvdXQodGhpcy5fZmx1c2hNZXNzYWdlc0JpbmRlZCwgRkxVU0hfVElNRU9VVCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZW5kcyByZXF1ZXN0IG1lc3NhZ2UgdG8vZnJvbSB3b3JrZXIgYXMgcHJvbWlzZSwgdGhlIG90aGVyIHNpZGUgY2FuIHJlc3BvbmQgYW5kIHRoZSBwcm9taXNlIGlzIHJlc29sdmVkLlxyXG4gICAgICogUmVxdWVzdC9yZXNwb25zZSBpcyBzeW5jaHJvbml6ZWQgYnkgdGhlIHJlcXVlc3RJZCBmaWVsZC5cclxuICAgICAqL1xyXG4gICAgcmVxdWVzdChyZXF1ZXN0LCB1cmdlbmN5KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgaWYgKHJlcXVlc3QucmVxdWVzdElkID09PSBOT19JRCkge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5yZXF1ZXN0SWQgPSB1bmlxdWVJZCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVyID0gKG1lc3NhZ2UpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlSXMobWVzc2FnZSwgcmVxdWVzdC5yZXNwb25zZVR5cGUpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yZXF1ZXN0SWQgPT09IHJlcXVlc3QucmVxdWVzdElkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShtZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIobGlzdGVuZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2VJcyhtZXNzYWdlLCByZXF1ZXN0LmVycm9yVHlwZSkgJiZcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnJlcXVlc3RJZCA9PT0gcmVxdWVzdC5yZXF1ZXN0SWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9mZihsaXN0ZW5lcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cy5hZGRMaXN0ZW5lcihsaXN0ZW5lcik7XHJcbiAgICAgICAgICAgIHRoaXMuc2VuZE1lc3NhZ2UocmVxdWVzdCwgdXJnZW5jeSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlc3BvbmRzIHRvIHByb3ZpZGVkIHJlcXVlc3QuXHJcbiAgICAgKi9cclxuICAgIHJlc3BvbmQocmVxdWVzdCwgcmVzcG9uc2UsIHVyZ2VuY3kpIHtcclxuICAgICAgICByZXNwb25zZS5yZXF1ZXN0SWQgPSByZXF1ZXN0LnJlcXVlc3RJZDtcclxuICAgICAgICB0aGlzLnNlbmRNZXNzYWdlKHJlc3BvbnNlLCB1cmdlbmN5KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBhIGxpc3RlbmVyIHRvIHNwZWNpZmljIHR5cGUgb2YgaW5jb21pbmcgbWVzc2FnZXMuXHJcbiAgICAgKi9cclxuICAgIG9uKHR5cGUsIGxpc3RlbmVyKSB7XHJcbiAgICAgICAgY29uc3QgdHlwZVNhZmVMaXN0ZW5lciA9IChtZXNzYWdlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlSXMobWVzc2FnZSwgdHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIGxpc3RlbmVyKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLl9saXN0ZW5lcnMuc2V0KGxpc3RlbmVyLCB0eXBlU2FmZUxpc3RlbmVyKTtcclxuICAgICAgICB0aGlzLl9ldmVudHMuYWRkTGlzdGVuZXIodHlwZVNhZmVMaXN0ZW5lcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgaW5jb21pbmcgbWVzc2FnZXMgbGlzdGVuZXIuXHJcbiAgICAgKi9cclxuICAgIG9mZihsaXN0ZW5lcikge1xyXG4gICAgICAgIGNvbnN0IHR5cGVTYWZlTGlzdGVuZXIgPSB0aGlzLl9saXN0ZW5lcnMuZ2V0KGxpc3RlbmVyKTtcclxuICAgICAgICBpZiAodHlwZVNhZmVMaXN0ZW5lcikge1xyXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIodHlwZVNhZmVMaXN0ZW5lcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydHMgbGlzdGVuaW5nIGZvciBpbmNvbWluZyBtZXNzYWdlcy5cclxuICAgICAqL1xyXG4gICAgbGlzdGVuKCkge1xyXG4gICAgICAgIHRoaXMuX2FkZHJlc3NlZS5vbm1lc3NhZ2UgPSAoeyBkYXRhOiBtZXNzYWdlcyB9KSA9PiB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBtZXNzYWdlcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbk1lc3NhZ2UobWVzc2FnZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGVyIG9mIGluY29taW5nIG1lc3NhZ2VzLlxyXG4gICAgICovXHJcbiAgICBvbk1lc3NhZ2UobWVzc2FnZSkge1xyXG4gICAgICAgIHRoaXMuX2V2ZW50cy5maXJlKG1lc3NhZ2UpO1xyXG4gICAgfVxyXG4gICAgX2ZsdXNoTWVzc2FnZXMoKSB7XHJcbiAgICAgICAgdGhpcy5fYWRkcmVzc2VlLnBvc3RNZXNzYWdlKHRoaXMuX21lc3NhZ2VzLCB0aGlzLl90cmFuc2ZlcmFibGVzKTtcclxuICAgICAgICB0aGlzLl9tZXNzYWdlcy5sZW5ndGggPSAwO1xyXG4gICAgICAgIHRoaXMuX3RyYW5zZmVyYWJsZXMubGVuZ3RoID0gMDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQmFzZSBjbGFzcyBmb3IgYSB3ZWJ3b3JrZXIgY29udHJvbGxlciBmb3IgdGhlIG1haW4gdGhyZWFkIGNvZGUuXHJcbiAqIEl0IGFsc28gd3JhcHMgY3JlYXRpb24gb2YgYSBuYXRpdmUgV29ya2VyLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFdlYldvcmtlckNsaWVudCBleHRlbmRzIFdlYldvcmtlckNvbW11bmljYXRvciB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB1cmwgVVJMIG9mIHdlYndvcmtlcidzIGRlcGxveWVkIGpzIGZpbGVcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IodXJsKSB7XHJcbiAgICAgICAgY29uc3Qgd29ya2VyID0gbmV3IFdvcmtlcih1cmwpO1xyXG4gICAgICAgIHN1cGVyKHdvcmtlcik7XHJcbiAgICAgICAgdGhpcy5fd29ya2VyID0gd29ya2VyO1xyXG4gICAgICAgIHRoaXMubGlzdGVuKCk7XHJcbiAgICB9XHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMuX3dvcmtlci50ZXJtaW5hdGUoKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQmFzZSBjbGFzcyBmb3IgYSB3ZWJ3b3JrZXIgdGhyZWFkIGltcGxlbWVudGF0aW9uLiBDb25jcmV0ZSBjbGFzcyBzaG91bGQgYmUgdGhlIGVudHJ5IHBvaW50IGZvciBhIHdlYndvcmtlciBqcyBidWlsZDpcclxuICogICAgIG5ldyBDb25jcmV0ZVdlYldvcmtlckltcGxlbWVudGF0aW9uKDxEZWRpY2F0ZWRXb3JrZXJHbG9iYWxTY29wZT5zZWxmKS5ydW4oKTtcclxuICovXHJcbmV4cG9ydCBjbGFzcyBXZWJXb3JrZXJJbXBsZW1lbnRhdGlvbiBleHRlbmRzIFdlYldvcmtlckNvbW11bmljYXRvciB7XHJcbiAgICBydW4oKSB7XHJcbiAgICAgICAgdGhpcy5saXN0ZW4oKTtcclxuICAgIH1cclxufVxyXG4iLCJsZXQgaWQgPSAxO1xyXG4vKipcclxuICogR2VuZXJhdGVzIHVuaXF1ZSBpZFxyXG4qL1xyXG5leHBvcnQgZnVuY3Rpb24gdW5pcXVlSWQoKSB7XHJcbiAgICByZXR1cm4gaWQrKztcclxufVxyXG4iLCJjb25zdCBUSUxFXzBfMF8wID0geyB4OiAwLCB5OiAwLCB6b29tOiAwIH07XHJcbi8qKlxyXG4gKiBDb21wdXRlcyBzZXQgb2YgdGlsZXMgdmlzaWJsZSB0aHJvdWdoIGEgY2FtZXJhLiBUaWxlcyBpbiB0aGUgc2V0IGFyZSBndWFyYW50ZWVkXHJcbiAqIHRvIGJlIHVuaXF1ZS5cclxuICpcclxuICogRklYTUUoZG1pa2lzKSBUaGUgdW5pcXVlbmVzcyBndWFyYW50ZWUgaXMgYnJva2VuIGN1cnJlbnRseSwgYnV0IGNvZGUgdGhhdCB1c2VzXHJcbiAqICAgICAgdGhpcyBmdW5jdGlvbiBkb2Vzbid0IHN1ZmZlciBmcm9tIHRoYXQuXHJcbiAqXHJcbiAqIEBwYXJhbSBjYW1lcmEgVGhlIGNhbWVyYS5cclxuICogQHJldHVybnMgQW4gaXRlcmF0b3Igb3ZlciB2aXNpYmxlIHRpbGUgaXRlbXMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24qIGNvbXB1dGVWaXNpYmxlVGlsZXModmlzaWJsZVJlZ2lvbiwgdmlzaWJsZVJlZ2lvbkJCb3gsIHdyYXBNb2RlWCwgd3JhcE1vZGVZLCB6b29tKSB7XHJcbiAgICBpZiAoem9vbSA9PT0gMCkge1xyXG4gICAgICAgIC8vIFRoZSBvbmx5IHRpbGUgb24gem9vbSAwIGVuY29tcGFzc2VzIHRoZSB3aG9sZSB3b3JsZC4gVGh1cyB0aGVyZSdzXHJcbiAgICAgICAgLy8gbGl0dGxlIHRvIG5vIHBvaW50IGNvbXB1dGluZyB0aGF0IGNhbWVyYSBzZWVzIGl0OiB3ZSBjYW4gdGVsbCB0aGF0XHJcbiAgICAgICAgLy8gcmlnaHQgYXdheS5cclxuICAgICAgICB5aWVsZCBUSUxFXzBfMF8wO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IHRpbGVDb3VudCA9IDEgPDwgem9vbTtcclxuICAgIGNvbnN0IHRpbGVJZHhNYXNrID0gdGlsZUNvdW50IC0gMTtcclxuICAgIC8vIFRoZSBpZGVhIGJlaGluZCB0aGUgY29kZSBiZWxvdyBpcyBxdWl0ZSBzaW1wbGU6IGRldGVybWluZSBjb2x1bW5zIG9mIHRoZVxyXG4gICAgLy8gdGlsZSBncmlkIHRoYXQgYXJlIHZpc2libGUgdG8gdGhlIGNhbWVyYSwgdGhlbiBmb3IgZWFjaCBjb2x1bW4gZmluZFxyXG4gICAgLy8gcmFuZ2Ugb2Ygcm93IGluZGljZXMgdGhhdCBhcmUgdmlzaWJsZS5cclxuICAgIC8vIEhlcmUncyBob3cgd2UgYXBwcm9hY2ggY29tcHV0aW5nIHRpbGUgaW5kaWNlcyBmcm9tIHdvcmxkIGNvb3JkaW5hdGVzLlxyXG4gICAgLy8gRmlyc3QsIHdlIHRyYW5zZm9ybSB3b3JsZCBjb29yZGluYXRlcyBmcm9tIFstMSwgMV0gcmFuZ2UgdG8gWzAsIDJdLFxyXG4gICAgLy8gZGVhbGluZyB3aXRoIGluY29uc2lzdGVuY3kgd2l0aCBZIGF4aXMgZGlyZWN0aW9uIGluIHdvcmxkIGFuZCB0aWxlIGdyaWRcclxuICAgIC8vIGNvb3JkaW5hdGUgc3lzdGVtLiBMZXQncyBkZXNpZ25hdGUgc3VjaCBhIGNvb3JkaW5hdGUgYXMgQyAoZm9yIGVpdGhlciBYXHJcbiAgICAvLyBvciBZKS4gU2l6ZSBvZiBhIHRpbGUgaXMgMiAvIHRpbGVDb3VudC4gVGh1cyxcclxuICAgIC8vXHJcbiAgICAvLyAgICAgIHRpbGVJZHggPSBNYXRoLmZsb29yKEMgLyAoMiAvIHRpbGVDb3VudCkpXHJcbiAgICAvLyAgICAgICAgICAgICAgPSBNYXRoLmZsb29yKEMgKiB0aWxlQ291bnQgLyAyKVxyXG4gICAgLy9cclxuICAgIGNvbnN0IHsgbWluWCwgbWF4WCwgbWluWSwgbWF4WSB9ID0gdmlzaWJsZVJlZ2lvbkJCb3g7XHJcbiAgICBjb25zdCBtaW5UWCA9IE1hdGguZmxvb3IoKG1pblggKyAxKSAqIHRpbGVDb3VudCAvIDIpO1xyXG4gICAgY29uc3QgbWF4VFggPSBNYXRoLmZsb29yKChtYXhYICsgMSkgKiB0aWxlQ291bnQgLyAyKTtcclxuICAgIGNvbnN0IGNvbHVtbkNvdW50ID0gbWF4VFggLSBtaW5UWCArIDE7XHJcbiAgICAvLyBBcnJheXMgb2YgaW5kaWNlcyBvZiBib3R0b21tb3N0IGFuZCB0b3Btb3N0IHRpbGVzIGNvcnJlc3BvbmRpbmdseSBmb3JcclxuICAgIC8vIGVhY2ggY29sdW1uLlxyXG4gICAgLy8gRklYTUUoZG1pa2lzKSBJZiBudW1iZXIgb2YgY29sdW1ucyBpcyB0b28gbGFyZ2UsIHdlJ2xsIGNvbnN1bWUgYSBsb3Qgb2ZcclxuICAgIC8vICAgICAgbWVtb3J5IGhlcmUuIFRoZXJlJ3MgYSBtZXRob2QgdG8gZG8gd2l0aG91dCB0aGUgYXJyYXlzLCBidXQgaXQncyBhXHJcbiAgICAvLyAgICAgIGJpdCBtb3JlIGNvbXBsaWNhdGVkIHRvIGltcGxlbWVudC5cclxuICAgIGNvbnN0IG1pbllzID0gbmV3IEFycmF5KGNvbHVtbkNvdW50KTtcclxuICAgIGNvbnN0IG1heFlzID0gbmV3IEFycmF5KGNvbHVtbkNvdW50KTtcclxuICAgIC8vIENvbW1vbiBzZW5zZSBzdWdnZXN0cyB0aGF0IHRob3NlIGluZGljZXMgY2FuJ3QgYmUgZ3JlYXRlciAobGVzcykgdGhhbiB0aGVcclxuICAgIC8vIGluZGV4IG9mIGEgdGlsZSByb3cgaW50ZXJzZWN0ZWQgYnkgYSBsaW5lIHkgPSBtaW5ZICh5ID0gbWF4WSkuIE5vdGUgdGhhdFxyXG4gICAgLy8gbWF4WSBjb3JyZXNwb25kcyB0byBhIHRpbGUgcm93IHdpdGggbGVzc2VyIGluZGV4LCBub3Qgb3RoZXIgd2F5IGFyb3VuZC5cclxuICAgIG1pbllzLmZpbGwoTWF0aC5mbG9vcigoMSAtIG1pblkpICogdGlsZUNvdW50IC8gMikpO1xyXG4gICAgbWF4WXMuZmlsbChNYXRoLmZsb29yKCgxIC0gbWF4WSkgKiB0aWxlQ291bnQgLyAyKSk7XHJcbiAgICBjb25zdCB2aXNpYmxlUG9seWdvbkxlbmd0aCA9IHZpc2libGVSZWdpb24ubGVuZ3RoO1xyXG4gICAgbGV0IHByZXZYID0gdmlzaWJsZVJlZ2lvblt2aXNpYmxlUG9seWdvbkxlbmd0aCAtIDFdLnggKyAxO1xyXG4gICAgbGV0IHByZXZZID0gMSAtIHZpc2libGVSZWdpb25bdmlzaWJsZVBvbHlnb25MZW5ndGggLSAxXS55O1xyXG4gICAgbGV0IHByZXZUWCA9IE1hdGguZmxvb3IocHJldlggKiB0aWxlQ291bnQgLyAyKTtcclxuICAgIGxldCBwcmV2VFkgPSBNYXRoLmZsb29yKHByZXZZICogdGlsZUNvdW50IC8gMik7XHJcbiAgICAvLyBJdGVyYXRlIG92ZXIgZWRnZXMgb2YgdmlzaWJsZSBwb2x5Z29uIG9mIHRoZSBjYW1lcmEgdG8gY29tcHV0ZSBpbmRleCBvZlxyXG4gICAgLy8gdG9wbW9zdCBhbmQgYm90dG9tbW9zdCB0aWxlcyBmb3IgZWFjaCBjb2x1bW4uXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZpc2libGVQb2x5Z29uTGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBjb25zdCB4ID0gdmlzaWJsZVJlZ2lvbltpXS54ICsgMTtcclxuICAgICAgICBjb25zdCB5ID0gMSAtIHZpc2libGVSZWdpb25baV0ueTtcclxuICAgICAgICBjb25zdCB0eCA9IE1hdGguZmxvb3IoeCAqIHRpbGVDb3VudCAvIDIpO1xyXG4gICAgICAgIGNvbnN0IHR5ID0gTWF0aC5mbG9vcih5ICogdGlsZUNvdW50IC8gMik7XHJcbiAgICAgICAgLy8gRm9yIGVhY2ggZWRnZSB3ZSBjb21wdXRlIDQtY29ubmVjdGVkIGxpbmUgb2YgdGlsZXMgb24gdGhlIHRpbGUgZ3JpZC5cclxuICAgICAgICAvLyBMZW5ndGggb2YgYSA0LWNvbm5lY3RlZCBsaW5lIGFsd2F5cyBlcXVhbHMgTWFuaGF0dGFuIGRpc3RhbmNlIGJldHdlZW5cclxuICAgICAgICAvLyBpdHMgZW5kcy4gSG93ZXZlciwgdG8gYXZvaWQgdW5uZWNlc3NhcnkgY29tcHV0YXRpb24sIHdlIG9taXQgbGFzdCB0aWxlXHJcbiAgICAgICAgLy8gZm9yIGV2ZXJ5IGVkZ2UuIEJ1dCwgc2luY2UgdGhlIHBvbHlnb24gaXMgY2xvc2VkLCB3ZSdsbCBpdGVyYXRlIG92ZXJcclxuICAgICAgICAvLyBhbGwgdGlsZXMgaW50ZXJzZWN0ZWQgYnkgZWRnZXMgYW55d2F5LlxyXG4gICAgICAgIGNvbnN0IGwgPSBNYXRoLmFicyh0eCAtIHByZXZUWCkgKyBNYXRoLmFicyh0eSAtIHByZXZUWSk7XHJcbiAgICAgICAgY29uc3QgbHggPSB4IC0gcHJldlg7XHJcbiAgICAgICAgY29uc3QgbHkgPSB5IC0gcHJldlk7XHJcbiAgICAgICAgY29uc3QgZHR4ID0gbHggPiAwID8gMSA6IC0xO1xyXG4gICAgICAgIGNvbnN0IGR0eSA9IGx5ID4gMCA/IDEgOiAtMTtcclxuICAgICAgICBjb25zdCBhID0gMiAqIGR0eCAqIGx5O1xyXG4gICAgICAgIGNvbnN0IGIgPSAtMiAqIGR0eCAqIGx4O1xyXG4gICAgICAgIGNvbnN0IGMgPSBkdHggKiB0aWxlQ291bnQgKiAobHggKiBwcmV2WSAtIGx5ICogcHJldlgpICsgYSAqICh+ZHR4ID4+PiAzMSk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHR4ID0gcHJldlRYLCB0eSA9IHByZXZUWTsgaSA8IGw7ICsraSkge1xyXG4gICAgICAgICAgICBjb25zdCBpbnRlcmNlcHQgPSBhICogdHggKyBiICogdHkgKyBjO1xyXG4gICAgICAgICAgICAvLyBUaGUgbWF0aCBoZXJlIGlzIHNvbWV3aGF0IGN1bWJlcnNvbWUgdG8gYXZvaWQgZGl2aXNpb25zLCBidXQgdGhlXHJcbiAgICAgICAgICAgIC8vIGVzc2VuY2UgaXMgdGhhdCB3ZSB0cnkgdG8gY2hlY2sgdGhyb3VnaCB3aGljaCBzaWRlIHRoZSBlZGdlIG9mXHJcbiAgICAgICAgICAgIC8vIHZpc2libGUgcG9seWdvbiBleGl0cyB0aGUgdGlsZS4gRGVwZW5kaW5nIG9uIHRoYXQgd2UgXCJtb3ZlXCIgdG9cclxuICAgICAgICAgICAgLy8gbmV4dCB0aWxlIGluIGVpdGhlciB2ZXJ0aWNhbCBvciBob3Jpem9udGFsIGRpcmVjdGlvbi5cclxuICAgICAgICAgICAgaWYgKDAgPD0gaW50ZXJjZXB0ICYmIGludGVyY2VwdCA8PSAtYikge1xyXG4gICAgICAgICAgICAgICAgdHggKz0gZHR4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdHkgKz0gZHR5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHlJZHggPSB0eCAtIG1pblRYO1xyXG4gICAgICAgICAgICBpZiAobWF4WXNbeUlkeF0gPCB0eSkge1xyXG4gICAgICAgICAgICAgICAgbWF4WXNbeUlkeF0gPSB0eTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobWluWXNbeUlkeF0gPiB0eSkge1xyXG4gICAgICAgICAgICAgICAgbWluWXNbeUlkeF0gPSB0eTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBwcmV2WCA9IHg7XHJcbiAgICAgICAgcHJldlkgPSB5O1xyXG4gICAgICAgIHByZXZUWCA9IHR4O1xyXG4gICAgICAgIHByZXZUWSA9IHR5O1xyXG4gICAgfVxyXG4gICAgLy8gSWYgdGhlIHdvcmxkIGlzIHJlcGVhdGVkIGFsb25nIFggYXhpcywgd2UgbmVlZCB0byBcImZvbGRcIiB0aGUgYXJyYXkgb2YgY29sdW1ucyxcclxuICAgIC8vIGkuZS4gY29tcHV0ZSB1bmlvbiBvZiByb3cgaW50ZXJ2YWxzIGZvciBjb2x1bW5zIHRpbGVDb3VudCBpbmRpY2VzIGFwYXJ0LlxyXG4gICAgaWYgKHdyYXBNb2RlWCA9PT0gMiAvKiBSRVBFQVQgKi8gJiYgY29sdW1uQ291bnQgPiB0aWxlQ291bnQpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRpbGVDb3VudDsgKytpKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgdGlsZUNvdW50OyBqIDwgY29sdW1uQ291bnQ7IGogKz0gdGlsZUNvdW50KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobWF4WXNbaV0gPCBtYXhZc1tqXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1heFlzW2ldID0gbWF4WXNbal07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobWluWXNbaV0gPiBtaW5Zc1tqXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbllzW2ldID0gbWluWXNbal07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBJZiB0aGUgd29ybGQgaXMgcmVwZWF0ZWQgYWxvbmcgWSBheGlzLCB3ZSBuZWVkIHRvIHdyYXAgaW5kaWNlcyBpbiBtaW5Zc1xyXG4gICAgLy8gYW5kIG1heFlzIGFycmF5cyB0byBbMCwgdGlsZUNvdW50KSBpbnRlcnZhbC5cclxuICAgIGlmICh3cmFwTW9kZVkgPT09IDIgLyogUkVQRUFUICovKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2x1bW5Db3VudCAmJiBpIDwgdGlsZUNvdW50OyArK2kpIHtcclxuICAgICAgICAgICAgY29uc3QgZHkgPSBtYXhZc1tpXSAtIG1pbllzW2ldO1xyXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSdzIG1vcmUgdGhhbiB0aWxlQ291bnQgcm93cyBiZXR3ZWVuIG1heFkgYW5kIG1pblksIHRoZW4gdGhlXHJcbiAgICAgICAgICAgIC8vIHdvcmxkIGlzIGVuY29tcGFzc2VkIHNvbWV3aGVyZSB3aXRoaW4gdmlzaWJsZSByZWdpb24uXHJcbiAgICAgICAgICAgIGlmIChkeSA+IHRpbGVDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgbWluWXNbaV0gPSAwO1xyXG4gICAgICAgICAgICAgICAgbWF4WXNbaV0gPSB0aWxlSWR4TWFzaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1pblkgPSBtaW5Zc1tpXSAmPSB0aWxlSWR4TWFzaztcclxuICAgICAgICAgICAgICAgIG1heFlzW2ldID0gbWluWSArIGR5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2x1bW5Db3VudCAmJiBpIDwgdGlsZUNvdW50OyArK2kpIHtcclxuICAgICAgICAgICAgbWluWXNbaV0gPSBNYXRoLm1heChtaW5Zc1tpXSwgMCk7XHJcbiAgICAgICAgICAgIG1heFlzW2ldID0gTWF0aC5taW4obWF4WXNbaV0sIHRpbGVJZHhNYXNrKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAod3JhcE1vZGVYID09PSAyIC8qIFJFUEVBVCAqLykge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sdW1uQ291bnQgJiYgaSA8IHRpbGVDb3VudDsgKytpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHR4ID0gKGkgKyBtaW5UWCkgJiB0aWxlSWR4TWFzaztcclxuICAgICAgICAgICAgZm9yIChsZXQgdHkgPSBtaW5Zc1tpXTsgdHkgPD0gbWF4WXNbaV07ICsrdHkpIHtcclxuICAgICAgICAgICAgICAgIHlpZWxkIHtcclxuICAgICAgICAgICAgICAgICAgICB4OiB0eCxcclxuICAgICAgICAgICAgICAgICAgICB5OiB0eSAmIHRpbGVJZHhNYXNrLFxyXG4gICAgICAgICAgICAgICAgICAgIHpvb21cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBmb3IgKGxldCB0eCA9IE1hdGgubWF4KG1pblRYLCAwKSwgdHhFbmQgPSBNYXRoLm1pbihtYXhUWCwgdGlsZUlkeE1hc2spOyB0eCA8PSB0eEVuZDsgKyt0eCkge1xyXG4gICAgICAgICAgICBjb25zdCBpID0gdHggLSBtaW5UWDtcclxuICAgICAgICAgICAgZm9yIChsZXQgdHkgPSBtaW5Zc1tpXTsgdHkgPD0gbWF4WXNbaV07ICsrdHkpIHtcclxuICAgICAgICAgICAgICAgIHlpZWxkIHtcclxuICAgICAgICAgICAgICAgICAgICB4OiB0eCxcclxuICAgICAgICAgICAgICAgICAgICB5OiB0eSAmIHRpbGVJZHhNYXNrLFxyXG4gICAgICAgICAgICAgICAgICAgIHpvb21cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgZ2V0VGlsZUlkLCBnZXRUaWxlSWRCeVJhd1ZhbHVlcyB9IGZyb20gJy4vdGlsZV9pZCc7XHJcbmltcG9ydCAqIGFzIHZlYzIgZnJvbSAnLi4vLi4vbWF0aC92ZWN0b3IyJztcclxuaW1wb3J0IHsgY3ljbGVSZXN0cmljdCB9IGZyb20gJy4uLy4uL21hdGgvc2NhbGFyJztcclxuY29uc3QgTEVGVF9TSURFID0ge1xyXG4gICAgZGlyZWN0aW9uOiB2ZWMyLmNyZWF0ZSgwLCAtMSksXHJcbiAgICBub3JtYWw6IHZlYzIuY3JlYXRlKC0xLCAwKSxcclxuICAgIGRpYWdvbmFsOiB2ZWMyLmNyZWF0ZSgtMSwgLTEpLFxyXG4gICAgcHJldlNpZGU6ICgpID0+IEJPVFRPTV9TSURFLFxyXG4gICAgbmV4dFNpZGU6ICgpID0+IFRPUF9TSURFXHJcbn07XHJcbmNvbnN0IFJJR0hUX1NJREUgPSB7XHJcbiAgICBkaXJlY3Rpb246IHZlYzIuY3JlYXRlKDAsICsxKSxcclxuICAgIG5vcm1hbDogdmVjMi5jcmVhdGUoKzEsIDApLFxyXG4gICAgZGlhZ29uYWw6IHZlYzIuY3JlYXRlKCsxLCArMSksXHJcbiAgICBwcmV2U2lkZTogKCkgPT4gVE9QX1NJREUsXHJcbiAgICBuZXh0U2lkZTogKCkgPT4gQk9UVE9NX1NJREVcclxufTtcclxuY29uc3QgVE9QX1NJREUgPSB7XHJcbiAgICBkaXJlY3Rpb246IHZlYzIuY3JlYXRlKCsxLCAwKSxcclxuICAgIG5vcm1hbDogdmVjMi5jcmVhdGUoMCwgLTEpLFxyXG4gICAgZGlhZ29uYWw6IHZlYzIuY3JlYXRlKCsxLCAtMSksXHJcbiAgICBwcmV2U2lkZTogKCkgPT4gTEVGVF9TSURFLFxyXG4gICAgbmV4dFNpZGU6ICgpID0+IFJJR0hUX1NJREVcclxufTtcclxuY29uc3QgQk9UVE9NX1NJREUgPSB7XHJcbiAgICBkaXJlY3Rpb246IHZlYzIuY3JlYXRlKC0xLCAwKSxcclxuICAgIG5vcm1hbDogdmVjMi5jcmVhdGUoMCwgKzEpLFxyXG4gICAgZGlhZ29uYWw6IHZlYzIuY3JlYXRlKC0xLCArMSksXHJcbiAgICBwcmV2U2lkZTogKCkgPT4gUklHSFRfU0lERSxcclxuICAgIG5leHRTaWRlOiAoKSA9PiBMRUZUX1NJREVcclxufTtcclxuLyoqXHJcbiAqIEFkZHMgdGlsZSB0byBiZWx0IHRpbGVzIGlmIGl0IGRvZXNuJ3QgZmFsbCBvdXQgb2YgdGhlIHdvcmxkLiBDeWNsaW5nIGNvb3JkaW5hdGVzIGNhbid0IGZhbGwgb3V0LFxyXG4gKiB0aGV5IGp1c3QgZ290IGFkanVzdGVkIGRpcmVjdGx5IGluIHRpbGUgaXRlbS5cclxuICovXHJcbmZ1bmN0aW9uIGFkZFRpbGVJZkFwcHJvcHJpYXRlKHRpbGUsIGJlbHRUaWxlcywgbWF4Q29vcmRpbmF0ZSwgaXNYQ3ljbGVkLCBpc1lDeWNsZWQpIHtcclxuICAgIHRpbGUueCA9IGlzWEN5Y2xlZCA/IGN5Y2xlUmVzdHJpY3QodGlsZS54LCAwLCBtYXhDb29yZGluYXRlKSA6IHRpbGUueDtcclxuICAgIHRpbGUueSA9IGlzWUN5Y2xlZCA/IGN5Y2xlUmVzdHJpY3QodGlsZS55LCAwLCBtYXhDb29yZGluYXRlKSA6IHRpbGUueTtcclxuICAgIGlmICgoMCA8PSB0aWxlLngpICYmICh0aWxlLnggPCBtYXhDb29yZGluYXRlKSAmJlxyXG4gICAgICAgICgwIDw9IHRpbGUueSkgJiYgKHRpbGUueSA8IG1heENvb3JkaW5hdGUpKSB7XHJcbiAgICAgICAgYmVsdFRpbGVzLnNldChnZXRUaWxlSWQodGlsZSksIHRpbGUpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUaGUgYWxnb3JpdGhtIGlzIGltcGxlbWVudGVkIGFzIGEgc3RhdGUgbWFjaGluZSwgdGhpcyBtZXRob2QgcHJvZHVjZXMgYmVsdCB0aWxlcyBhbmQgc2V0cyBhcHByb3ByaWF0ZSBzdGF0ZS5cclxuICogSG93IHRvIGNoYW5nZSB0aGlzIHN0YXRlIChkZXRlcm1pbmUgY3VycmVudCB0aWxlIGFuZCBpdHMgc2lkZSkgaXMgZGVzY3JpYmVkIGluIGZvdXIgVGlsZVNpZGUgaW1wbGVtZW50YXRpb25zOlxyXG4gKiBsZWZ0LCByaWdodCwgdG9wIGFuZCBib3R0b20uXHJcbiAqL1xyXG5mdW5jdGlvbiBtb3ZlKHRpbGVzLCBzdGF0ZSwgc2l6ZSwgbWF4Q29vcmRpbmF0ZSwgaXNYQ3ljbGVkLCBpc1lDeWNsZWQpIHtcclxuICAgIC8vIGFkZCB0aWxlcyBvdXR3YXJkIGluIHRoZSBkaXJlY3Rpb24gb2YgdGhlIG5vcm1hbFxyXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gc2l6ZTsgaSsrKSB7XHJcbiAgICAgICAgYWRkVGlsZUlmQXBwcm9wcmlhdGUoe1xyXG4gICAgICAgICAgICB4OiBzdGF0ZS5jdXJyZW50VGlsZS54ICsgaSAqIHN0YXRlLmN1cnJlbnRUaWxlU2lkZS5ub3JtYWwueCxcclxuICAgICAgICAgICAgeTogc3RhdGUuY3VycmVudFRpbGUueSArIGkgKiBzdGF0ZS5jdXJyZW50VGlsZVNpZGUubm9ybWFsLnksXHJcbiAgICAgICAgICAgIHpvb206IHN0YXRlLmN1cnJlbnRUaWxlLnpvb21cclxuICAgICAgICB9LCBzdGF0ZS5iZWx0VGlsZXMsIG1heENvb3JkaW5hdGUsIGlzWEN5Y2xlZCwgaXNZQ3ljbGVkKTtcclxuICAgIH1cclxuICAgIC8vIGNoZWNrIGRpYWdvbmFsIHRpbGVcclxuICAgIGNvbnN0IGRpYWdvbmFsTmVpZ2hib3VyID0gdGlsZXMuZ2V0KGdldFRpbGVJZEJ5UmF3VmFsdWVzKHN0YXRlLmN1cnJlbnRUaWxlLnggKyBzdGF0ZS5jdXJyZW50VGlsZVNpZGUuZGlhZ29uYWwueCwgc3RhdGUuY3VycmVudFRpbGUueSArIHN0YXRlLmN1cnJlbnRUaWxlU2lkZS5kaWFnb25hbC55LCBzdGF0ZS5jdXJyZW50VGlsZS56b29tKSk7XHJcbiAgICBpZiAoZGlhZ29uYWxOZWlnaGJvdXIpIHtcclxuICAgICAgICBzdGF0ZS5jdXJyZW50VGlsZSA9IGRpYWdvbmFsTmVpZ2hib3VyO1xyXG4gICAgICAgIHN0YXRlLmN1cnJlbnRUaWxlU2lkZSA9IHN0YXRlLmN1cnJlbnRUaWxlU2lkZS5wcmV2U2lkZSgpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIC8vIGNoZWNrIG5laWdoYm91ciBpbiB0aGUgc2FtZSBkaXJlY3Rpb25cclxuICAgIGNvbnN0IG5laWdoYm91ciA9IHRpbGVzLmdldChnZXRUaWxlSWRCeVJhd1ZhbHVlcyhzdGF0ZS5jdXJyZW50VGlsZS54ICsgc3RhdGUuY3VycmVudFRpbGVTaWRlLmRpcmVjdGlvbi54LCBzdGF0ZS5jdXJyZW50VGlsZS55ICsgc3RhdGUuY3VycmVudFRpbGVTaWRlLmRpcmVjdGlvbi55LCBzdGF0ZS5jdXJyZW50VGlsZS56b29tKSk7XHJcbiAgICBpZiAobmVpZ2hib3VyKSB7XHJcbiAgICAgICAgc3RhdGUuY3VycmVudFRpbGUgPSBuZWlnaGJvdXI7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgLy8gaGFuZGxlIGNvcm5lciB0aWxlc1xyXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gc2l6ZTsgaSsrKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDE7IGogPD0gc2l6ZTsgaisrKSB7XHJcbiAgICAgICAgICAgIGFkZFRpbGVJZkFwcHJvcHJpYXRlKHtcclxuICAgICAgICAgICAgICAgIHg6IHN0YXRlLmN1cnJlbnRUaWxlLnggKyBpICogc3RhdGUuY3VycmVudFRpbGVTaWRlLmRpYWdvbmFsLngsXHJcbiAgICAgICAgICAgICAgICB5OiBzdGF0ZS5jdXJyZW50VGlsZS55ICsgaiAqIHN0YXRlLmN1cnJlbnRUaWxlU2lkZS5kaWFnb25hbC55LFxyXG4gICAgICAgICAgICAgICAgem9vbTogc3RhdGUuY3VycmVudFRpbGUuem9vbVxyXG4gICAgICAgICAgICB9LCBzdGF0ZS5iZWx0VGlsZXMsIG1heENvb3JkaW5hdGUsIGlzWEN5Y2xlZCwgaXNZQ3ljbGVkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0ZS5jdXJyZW50VGlsZVNpZGUgPSBzdGF0ZS5jdXJyZW50VGlsZVNpZGUubmV4dFNpZGUoKTtcclxufVxyXG4vKipcclxuICogQ2FsY3VsYXRlcyB0aWxlcyB0aGF0IHN1cnJvdW5kIHByb3ZpZGVkIHJlZ2lvbiAoc2V0IG9mIHRpbGVzKSwgdGhlIHJlZ2lvbiBtdXN0IGJlIG9uZSBvciBtb3JlIGNvbnZleCBwb2x5Z29uc1xyXG4gKiB3aXRoIG5vIGhvbGVzLCBvdGhlcndpc2UgY29ycmVjdG5lc3MgaXMgbm90IGd1YXJhbnRlZWQuIE11bHRpcGxlIHBvbHlnb25zIGNhbiBoYXBwZW4gd2hlbiB0aGUgY2FtZXJhIGxvb2tzXHJcbiAqIGF0IHRoZSBlZGdlIG9mIHRoZSB3b3JsZCBjYXB0dXJpbmcgY3ljbGVkIHRpbGVzIGZyb20gZGlmZmVyZW50IHNpZGVzLlxyXG4gKiBUaGUgbG9naWMgb2YgaW5jbHVkaW5nIHRpbGVzIGluIHRoZSBcImJlbHRcIiBpcyBhcyBmb2xsb3dzOiBzaG9ydGVzdCBkaXN0YW5jZSBmcm9tIFwib3V0c2lkZVwiIHRvIGFueSBwb2ludFxyXG4gKiBpbiB0aGUgb3JpZ2luYWwgcmVnaW9uIHNob3VsZCBiZSBub3QgbGVzcyB0aGFuIHRpbGVTaXplICogYmVsdFNpemUuXHJcbiAqXHJcbiAqIEBwYXJhbSB0aWxlcyBTZXQgb2YgdGlsZXMgdGhhdCBjb3ZlciBhIGNvbnZleCBwb2x5Z29uLlxyXG4gKiBAcGFyYW0gYmVsdFNpemUgXCJ0aGlja25lc3NcIiAoaW4gdGlsZXMpIG9mIHRoZSBzdXJyb3VuZGluZyBhcmVhLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZUJlbHRUaWxlcyh0aWxlcywgYmVsdFNpemUsIGlzWEN5Y2xlZCwgaXNZQ3ljbGVkKSB7XHJcbiAgICAvLyB0aGUgYWxnb3JpdGhtIGluIHNpbXBsZSB3b3JkczpcclxuICAgIC8vICAgMS4gZmluZCBhIHRpbGUgb24gYW4gZWRnZSBvZiB0aGUgcG9seWdvbiAoZS5nLiBvbmUgb2YgdGhlIGxlZnRtb3N0IG9uZXMpXHJcbiAgICAvLyAgIDIuIGdvIGFyb3VuZCB0aGUgcG9seWdvbiB0aWxlLWJ5LXRpbGUgYWRkaW5nIHN1cnJvdW5kaW5nIHRpbGVzIG91dHdhcmRseVxyXG4gICAgY29uc3QgaW5kZXhlZFRpbGVzID0gbmV3IE1hcCgpO1xyXG4gICAgY29uc3QgYmVsdFRpbGVzID0gbmV3IE1hcCgpO1xyXG4gICAgLy8gaW5kZXggdGlsZXNcclxuICAgIGZvciAoY29uc3QgdGlsZUl0ZW0gb2YgdGlsZXMpIHtcclxuICAgICAgICBpbmRleGVkVGlsZXMuc2V0KGdldFRpbGVJZCh0aWxlSXRlbSksIHRpbGVJdGVtKTtcclxuICAgIH1cclxuICAgIC8vIHRpbGVzIGFyZSBncm91cGVkIGludG8gb25lIG9yIG1vcmUgY29udmV4IHBvbHlnb25zLCBwcm9jZXNzIHRoZXNlIHBvbHlnb25zIG9uZSBieSBvbmVcclxuICAgIGNvbnN0IHRpbGVzVG9Qcm9jZXNzID0gbmV3IE1hcChpbmRleGVkVGlsZXMpO1xyXG4gICAgd2hpbGUgKHRpbGVzVG9Qcm9jZXNzLnNpemUgPiAwKSB7XHJcbiAgICAgICAgbGV0IGxlZnRtb3N0VGlsZSA9IHsgeDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCB5OiAwLCB6b29tOiAwIH07XHJcbiAgICAgICAgLy8gZmluZCB0aGUgbGVmdG1vc3QgdGlsZSB0byBzdGFydCB3YWxraW5nIGZyb21cclxuICAgICAgICBmb3IgKGNvbnN0IHRpbGVJdGVtIG9mIHRpbGVzVG9Qcm9jZXNzLnZhbHVlcygpKSB7XHJcbiAgICAgICAgICAgIGlmICh0aWxlSXRlbS54IDwgbGVmdG1vc3RUaWxlLngpIHtcclxuICAgICAgICAgICAgICAgIGxlZnRtb3N0VGlsZSA9IHRpbGVJdGVtO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHNhdmUgbWluL21heCB5IHZhbHVlIHBlciB4IGNvb3JkaW5hdGUgdG8gYmUgYWJsZVxyXG4gICAgICAgIC8vIHRvIG1hcmsgdGhlc2UgdGlsZXMgYXMgcHJvY2Vzc2VkIChyZW1vdmUgZnJvbSB0aWxlc1RvUHJvY2VzcylcclxuICAgICAgICBjb25zdCBtYXhZID0gW107XHJcbiAgICAgICAgY29uc3QgbWluWSA9IFtdO1xyXG4gICAgICAgIGNvbnN0IGluaXRTdGF0ZSA9IHsgY3VycmVudFRpbGU6IGxlZnRtb3N0VGlsZSwgY3VycmVudFRpbGVTaWRlOiBMRUZUX1NJREUsIGJlbHRUaWxlcyB9O1xyXG4gICAgICAgIGNvbnN0IHN0YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgaW5pdFN0YXRlKTtcclxuICAgICAgICBjb25zdCBtYXhDb29yZGluYXRlID0gTWF0aC5wb3coMiwgbGVmdG1vc3RUaWxlLnpvb20pO1xyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgLy8gbW92ZSBhcm91bmQgd2hpbGUgd2UgZG9uJ3QgcmVhY2ggdGhlIGluaXQgcG9zaXRpb25cclxuICAgICAgICAgICAgbW92ZSh0aWxlc1RvUHJvY2Vzcywgc3RhdGUsIGJlbHRTaXplLCBtYXhDb29yZGluYXRlLCBpc1hDeWNsZWQsIGlzWUN5Y2xlZCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gc3RhdGUuY3VycmVudFRpbGUueCAtIGluaXRTdGF0ZS5jdXJyZW50VGlsZS54O1xyXG4gICAgICAgICAgICBtYXhZW2luZGV4XSA9IG1heFlbaW5kZXhdID09PSB1bmRlZmluZWQgPyBzdGF0ZS5jdXJyZW50VGlsZS55IDogTWF0aC5tYXgobWF4WVtpbmRleF0sIHN0YXRlLmN1cnJlbnRUaWxlLnkpO1xyXG4gICAgICAgICAgICBtaW5ZW2luZGV4XSA9IG1pbllbaW5kZXhdID09PSB1bmRlZmluZWQgPyBzdGF0ZS5jdXJyZW50VGlsZS55IDogTWF0aC5taW4obWluWVtpbmRleF0sIHN0YXRlLmN1cnJlbnRUaWxlLnkpO1xyXG4gICAgICAgIH0gd2hpbGUgKHN0YXRlLmN1cnJlbnRUaWxlICE9PSBpbml0U3RhdGUuY3VycmVudFRpbGUgfHxcclxuICAgICAgICAgICAgc3RhdGUuY3VycmVudFRpbGVTaWRlICE9PSBpbml0U3RhdGUuY3VycmVudFRpbGVTaWRlKTtcclxuICAgICAgICAvLyBtYXJrIHRpbGVzIGZyb20gY3VycmVudCBwb2x5Z29uIGFzIHByb2Nlc3NlZFxyXG4gICAgICAgIGNvbnN0IHpvb20gPSBsZWZ0bW9zdFRpbGUuem9vbTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heFkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgeCA9IGxlZnRtb3N0VGlsZS54ICsgaTtcclxuICAgICAgICAgICAgZm9yIChsZXQgeSA9IG1pbllbaV07IHkgPD0gbWF4WVtpXTsgeSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aWxlc1RvUHJvY2Vzcy5kZWxldGUoZ2V0VGlsZUlkQnlSYXdWYWx1ZXMoeCwgeSwgem9vbSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gcmVtb3ZlIGJlbHQgdGlsZXMgdGhhdCBvdmVybGFwcyB0byBhdm9pZCBkdXBsaWNhdGlvbnNcclxuICAgIGZvciAoY29uc3QgdGlsZUlkIG9mIGJlbHRUaWxlcy5rZXlzKCkpIHtcclxuICAgICAgICBpZiAoaW5kZXhlZFRpbGVzLmhhcyh0aWxlSWQpKSB7XHJcbiAgICAgICAgICAgIGJlbHRUaWxlcy5kZWxldGUodGlsZUlkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYmVsdFRpbGVzLnZhbHVlcygpO1xyXG59XHJcbiIsImNvbnN0IFBST0pFQ1RfSUQgPSA0NDM7XHJcbmZ1bmN0aW9uIGNob29zZVN0YXRVcmwoKSB7XHJcbiAgICAvLyBGSVhNRShkbWlraXMpIElkZWFsbHkgd2Ugc2hvdWxkIGJlIGdldCB0aGlzIFVSTHMgZnJvbSBjb25maWcuXHJcbiAgICBjb25zdCBTVEFUX1VSTFMgPSB7XHJcbiAgICAgICAgcnU6ICdodHRwczovL3lhbmRleC5ydS9jbGNrJyxcclxuICAgICAgICBjb206ICdodHRwczovL3lhbmRleC5jb20vY2xjaycsXHJcbiAgICAgICAgdHI6ICdodHRwczovL3lhbmRleC5jb20udHIvY2xjaydcclxuICAgIH07XHJcbiAgICBjb25zdCB0bGQgPSBsb2NhdGlvbi5ob3N0bmFtZS5zcGxpdCgnLicpLnBvcCgpO1xyXG4gICAgc3dpdGNoICh0bGQpIHtcclxuICAgICAgICBjYXNlICd0cic6XHJcbiAgICAgICAgICAgIHJldHVybiBTVEFUX1VSTFMudHI7XHJcbiAgICAgICAgY2FzZSAnY29tJzpcclxuICAgICAgICBjYXNlICdmcic6XHJcbiAgICAgICAgICAgIHJldHVybiBTVEFUX1VSTFMuY29tO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiBTVEFUX1VSTFMucnU7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgU1RBVF9VUkwgPSBjaG9vc2VTdGF0VXJsKCk7XHJcbmZ1bmN0aW9uIHN0cmluZ2lmeVZhcnModmFycykge1xyXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHZhcnMpLm1hcCgoa2V5KSA9PiBgJHtrZXl9PSR7dmFyc1trZXldfWApLmpvaW4oJywnKTtcclxufVxyXG5mdW5jdGlvbiBjb3VudChwaWQsIGNpZCwgcGF0aCwgdmFycykge1xyXG4gICAgY29uc3QgdXJsID0gYCR7U1RBVF9VUkx9L2NvdW50ZXJgO1xyXG4gICAgY29uc3QgZGF0YSA9IGAvZHR5cGU9c3RyZWQvcGlkPSR7cGlkfS9jaWQ9JHtjaWR9YCArXHJcbiAgICAgICAgYC9wYXRoPSR7cGF0aC5qb2luKCcuJyl9LyR7dmFycyA/IGB2YXJzPSR7c3RyaW5naWZ5VmFycyh2YXJzKX0vYCA6ICcnfWA7XHJcbiAgICBpZiAoIShuYXZpZ2F0b3Iuc2VuZEJlYWNvbiAmJiBuYXZpZ2F0b3Iuc2VuZEJlYWNvbih1cmwsIGRhdGEgKyAnKicpKSkge1xyXG4gICAgICAgIGNvbnN0IGltYWdlID0gbmV3IEltYWdlKCk7XHJcbiAgICAgICAgaW1hZ2Uuc3JjID0gdXJsICsgZGF0YSArIGBybmQ9JHtEYXRlLm5vdygpfSR7TWF0aC5yYW5kb20oKSAqIDEwMCB8IDB9LypgO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IFBFUkZfQ09VTlRFUl9JRCA9IDczMzIzO1xyXG4vKipcclxuICogTG9nIHVzZXIncyByZW5kZXJpbmcgcGVyZiB0byBzdGF0ZmFjZS5cclxuICpcclxuICogQHBhcmFtIGZwcyBGUFNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb3VudEZwcyhmcHMpIHtcclxuICAgIGNvbnN0IHJvdW5kZWRGcHMgPSBNYXRoLmZsb29yKGZwcyAvIDEwKSAqIDEwO1xyXG4gICAgY291bnQoUFJPSkVDVF9JRCwgUEVSRl9DT1VOVEVSX0lELCBbJ2ZwcycsIGAke3JvdW5kZWRGcHN9LSR7cm91bmRlZEZwcyArIDEwfWAsIChmcHMgKiAxMDApLnRvRml4ZWQoKV0pO1xyXG59XHJcbmZ1bmN0aW9uIGVuY29kZVRpbGVJdGVtKHRpbGVJdGVtKSB7XHJcbiAgICByZXR1cm4gYCR7dGlsZUl0ZW0ueH0uJHt0aWxlSXRlbS55fS4ke3RpbGVJdGVtLnpvb219YDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gY291bnRUaWxlUGFyc2VUaW1lKGxheWVyLCBtaW5UaW1lVGlsZSwgbWluVGltZSwgbWF4VGltZVRpbGUsIG1heFRpbWUsIG1lZGlhblRpbWVUaWxlLCBtZWRpYW5UaW1lKSB7XHJcbiAgICBjb3VudChQUk9KRUNUX0lELCBQRVJGX0NPVU5URVJfSUQsIFtcclxuICAgICAgICAndGlsZV9wYXJzZScsXHJcbiAgICAgICAgbGF5ZXJcclxuICAgIF0sIHtcclxuICAgICAgICBtaW5UaW1lOiBtaW5UaW1lLnRvRml4ZWQoKSxcclxuICAgICAgICBtZWRpYW5UaW1lOiBtZWRpYW5UaW1lLnRvRml4ZWQoKSxcclxuICAgICAgICBtYXhUaW1lOiBtYXhUaW1lLnRvRml4ZWQoKSxcclxuICAgICAgICBtaW5UaWxlSXRlbTogZW5jb2RlVGlsZUl0ZW0obWluVGltZVRpbGUpLFxyXG4gICAgICAgIG1lZGlhblRpbGVJdGVtOiBlbmNvZGVUaWxlSXRlbShtZWRpYW5UaW1lVGlsZSksXHJcbiAgICAgICAgbWF4VGlsZUl0ZW06IGVuY29kZVRpbGVJdGVtKG1heFRpbWVUaWxlKVxyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGNvdW50VGlsZVByb2Nlc3NpbmdUaW1lKGxheWVyLCBpdGVtcykge1xyXG4gICAgY29uc3QgdmFyc1RvTG9nID0ge307XHJcbiAgICBpdGVtcy5mb3JFYWNoKChpdGVtKSA9PiB7XHJcbiAgICAgICAgaWYgKGl0ZW0uem9vbSA9PT0gJ2F2ZXJhZ2UnKSB7XHJcbiAgICAgICAgICAgIGNvdW50KFBST0pFQ1RfSUQsIFBFUkZfQ09VTlRFUl9JRCwgW1xyXG4gICAgICAgICAgICAgICAgJ3RpbGVfcHJvY2Vzc2luZ19hdmVyYWdlJyxcclxuICAgICAgICAgICAgICAgIGxheWVyLFxyXG4gICAgICAgICAgICAgICAgKE1hdGguY2VpbChpdGVtLnRpbWUgLyAyNTApICogMjUwKS50b1N0cmluZygpXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXJzVG9Mb2dbaXRlbS56b29tXSA9IGl0ZW0udGltZS50b0ZpeGVkKCk7XHJcbiAgICB9KTtcclxuICAgIGNvdW50KFBST0pFQ1RfSUQsIFBFUkZfQ09VTlRFUl9JRCwgWyd0aWxlX3Byb2Nlc3NpbmcnLCBsYXllcl0sIHZhcnNUb0xvZyk7XHJcbn1cclxuIiwiaW1wb3J0IHsgQXR0cmlidXRlTWFwcGluZyB9IGZyb20gJy4uLy4uL3JlbmRlci9hdHRyaWJfbWFwcGluZyc7XHJcbmltcG9ydCBCdWZmZXJXcml0ZXIgZnJvbSAnLi4vLi4vdXRpbC9idWZmZXJfd3JpdGVyJztcclxuLyoqXHJcbiAqIFdyaXRlciBvZiBnZW9tZXRyeSBkYXRhIG9mIGljb25zLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSWNvbkJ1ZmZlcldyaXRlciBleHRlbmRzIEJ1ZmZlcldyaXRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcihJY29uQnVmZmVyV3JpdGVyLkFUVFJJQlVURV9NQVBQSU5HLnZlcnRleEJ5dGVTaXplKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGFuIGljb24gdG8gYnVmZmVycy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaWNvbiBJY29uIHRvIGJlIHdyaXR0ZW4gdG8gYnVmZmVyLlxyXG4gICAgICogQHBhcmFtIGxvY2F0aW9uIEltYWdlIGxvY2F0aW9uIGluIGF0bGFzLlxyXG4gICAgICogQHBhcmFtIHNpemUgSW1hZ2Ugc2l6ZSBpbiBhdGxhcy5cclxuICAgICAqIEBwYXJhbSBvZmZzZXQgT2Zmc2V0IG9mIGltYWdlIHBvaW50cyBpbiBDU1MgcGl4ZWxzLlxyXG4gICAgICogQHBhcmFtIHBpeGVsUmF0aW8gUmF0aW8gb2YgaW1hZ2Ugc2l6ZSBpbiBDU1MgcGl4ZWxzIHRvIHRoZSBzaXplIGluIGF0bGFzIHBpeGVscy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBMb2NhdGlvbiBvZiB0aGUgaWNvbiBkYXRhIGluIGJ1ZmZlcnMuXHJcbiAgICAgKi9cclxuICAgIHdyaXRlSWNvbihpY29uLCBsb2NhdGlvbiwgc2l6ZSwgb2Zmc2V0LCBwaXhlbFJhdGlvKSB7XHJcbiAgICAgICAgY29uc3QgdG9wID0gb2Zmc2V0Lnk7XHJcbiAgICAgICAgY29uc3QgYm90dG9tID0gb2Zmc2V0LnkgKyBzaXplLmhlaWdodCAqIHBpeGVsUmF0aW87XHJcbiAgICAgICAgY29uc3QgbGVmdCA9IG9mZnNldC54O1xyXG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gb2Zmc2V0LnggKyBzaXplLndpZHRoICogcGl4ZWxSYXRpbztcclxuICAgICAgICB0aGlzLndyaXRlVmVydGV4KGljb24ucG9zaXRpb24sIGxlZnQsIGJvdHRvbSwgbG9jYXRpb24ubWluWCwgbG9jYXRpb24ubWluWSk7XHJcbiAgICAgICAgdGhpcy53cml0ZVZlcnRleChpY29uLnBvc2l0aW9uLCBsZWZ0LCB0b3AsIGxvY2F0aW9uLm1pblgsIGxvY2F0aW9uLm1heFkpO1xyXG4gICAgICAgIHRoaXMud3JpdGVWZXJ0ZXgoaWNvbi5wb3NpdGlvbiwgcmlnaHQsIGJvdHRvbSwgbG9jYXRpb24ubWF4WCwgbG9jYXRpb24ubWluWSk7XHJcbiAgICAgICAgdGhpcy53cml0ZVZlcnRleChpY29uLnBvc2l0aW9uLCByaWdodCwgdG9wLCBsb2NhdGlvbi5tYXhYLCBsb2NhdGlvbi5tYXhZKTtcclxuICAgICAgICB0aGlzLndyaXRlSW5kaWNlc0ZvckNvbnRpbnVvdXNTdHJpcCg0KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5lbmRNZXNoKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIHZlcnRleCB0byB0aGUgdmVydGV4IGJ1ZmZlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcG9zaXRpb24gUG9zaXRpb24gb2YgdGhlIHZlcnRleCBpbiBkaXNwbGF5IGNvb3JkaW5hdGVzLlxyXG4gICAgICogQHBhcmFtIHV2IFVWcyBvZiB0aGUgdmVydGV4LlxyXG4gICAgICogQHJldHVybiBJbmRleCBvZiB0aGUgd3JpdHRlbiB2ZXJ0ZXguXHJcbiAgICAgKi9cclxuICAgIHdyaXRlVmVydGV4KHBvc2l0aW9uLCBkaXNwbGFjZW1lbnRYLCBkaXNwbGFjZW1lbnRZLCB1dlgsIHV2WSkge1xyXG4gICAgICAgIGNvbnN0IHZlcnRleElkeCA9IHRoaXMuZ2V0Q3VycmVudFZlcnRleElkeCgpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlV29ybGRDb29yZGluYXRlKHBvc2l0aW9uKTtcclxuICAgICAgICB0aGlzLl93cml0ZUhhbGZXb3JkcyhkaXNwbGFjZW1lbnRYLCBkaXNwbGFjZW1lbnRZKTtcclxuICAgICAgICB0aGlzLl93cml0ZUhhbGZXb3Jkcyh1dlgsIHV2WSk7XHJcbiAgICAgICAgcmV0dXJuIHZlcnRleElkeDtcclxuICAgIH1cclxufVxyXG4vKiogRGVzY3JpcHRpb24gb2YgaG93IGEgd3JpdGVyIHN0b3JlcyB2ZXJ0ZXggZGF0YS4gKi9cclxuSWNvbkJ1ZmZlcldyaXRlci5BVFRSSUJVVEVfTUFQUElORyA9IG5ldyBBdHRyaWJ1dGVNYXBwaW5nKFtcclxuICAgIFtcclxuICAgICAgICAwIC8qIFBPU0lUSU9OX0hJR0ggKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIzIC8qIFVOU0lHTkVEX1NIT1JUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICAxIC8qIFBPU0lUSU9OX0xPVyAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDIsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjMgLyogVU5TSUdORURfU0hPUlQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDYgLyogRElTUExBQ0VNRU5UICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMixcclxuICAgICAgICAgICAgdHlwZTogNTEyMiAvKiBTSE9SVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDQgLyogVVYgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIzIC8qIFVOU0lHTkVEX1NIT1JUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgIF1cclxuXSk7XHJcbiIsImltcG9ydCB7IGZsb2F0VG9VaW50MzIgfSBmcm9tICcuL2dwdXR5cGVzJztcclxuaW1wb3J0IHsgemlwIH0gZnJvbSAnLi9hcnJheSc7XHJcbmV4cG9ydCBjb25zdCBXT1JEX0JZVEVfU0laRSA9IDQ7XHJcbi8qKlxyXG4gKiBHZW5lcmF0ZXMgdHJpYW5nbGVzIG9mIGEgZmFuIG9mIGEgZ2l2ZW4gbGVuZ3RoIGFzIGlmIGl0IGlzIGNvbnRpbnVvdXMgYW5kXHJcbiAqIHN0YXJ0cyB3aXRoIDAuXHJcbiAqXHJcbiAqIEBwYXJhbSBjb3VudCBOdW1iZXIgb2YgdmVydGljZXMgaW4gdGhlIGZhbi5cclxuICogQHJldHVybnMgSXRlcmF0b3Igb3ZlciBpbmRpY2VzIG9mIHRyaWFuZ2xlcy5cclxuICovXHJcbmZ1bmN0aW9uKiBnZW5lcmF0ZUZhbihjb3VudCkge1xyXG4gICAgZm9yIChsZXQgaSA9IDI7IGkgPCBjb3VudDsgKytpKSB7XHJcbiAgICAgICAgeWllbGQgMDtcclxuICAgICAgICB5aWVsZCBpIC0gMTtcclxuICAgICAgICB5aWVsZCBpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBHZW5lcmF0ZXMgdHJpYW5nbGVzIG9mIGEgc3RyaXAgb2YgYSBnaXZlbiBsZW5ndGggYXMgaWYgaXQgaXMgY29udGludW91cyBhbmRcclxuICogc3RhcnRzIHdpdGggMC5cclxuICpcclxuICogQHBhcmFtIGNvdW50IE51bWJlciBvZiB2ZXJ0aWNlcyBpbiB0aGUgZmFuLlxyXG4gKiBAcmV0dXJucyBJdGVyYXRvciBvdmVyIGluZGljZXMgb2YgdHJpYW5nbGVzLlxyXG4gKi9cclxuZnVuY3Rpb24qIGdlbmVyYXRlU3RyaXAoY291bnQpIHtcclxuICAgIHlpZWxkIDA7XHJcbiAgICB5aWVsZCAxO1xyXG4gICAgeWllbGQgMjtcclxuICAgIGxldCBvZmZzZXQwID0gMTtcclxuICAgIGxldCBvZmZzZXQxID0gMjtcclxuICAgIGZvciAobGV0IGkgPSAzOyBpIDwgY291bnQ7ICsraSkge1xyXG4gICAgICAgIHlpZWxkIGkgLSBvZmZzZXQwO1xyXG4gICAgICAgIHlpZWxkIGkgLSBvZmZzZXQxO1xyXG4gICAgICAgIHlpZWxkIGk7XHJcbiAgICAgICAgY29uc3QgdG1wID0gb2Zmc2V0MDtcclxuICAgICAgICBvZmZzZXQwID0gb2Zmc2V0MTtcclxuICAgICAgICBvZmZzZXQxID0gdG1wO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBWZXJ0ZXggYnVmZmVyIGhlbHBlciBjbGFzcywgdGhhdCBzdXBwb3J0cyBzZXF1ZW50aWFsIHdyaXRpbmcgaW50ZXJmYWNlIGFuZCB0YWtlcyBvdmVyIHNvbWUgc2luZ2xlLWJ1ZmZlciBvcGVyYXRpb25zLlxyXG4gKiBJdCBpcyBhbiBpbnRlZ3JhbCBwYXJ0IG9mIHRoZSBidWZmZXIgd3JpdGVyIGNsYXNzIGFuZCBpdHMgbWFpbiBwdXJwb3NlIGlzIHRvIG1ha2UgdGhlIHdyaXRlcidzIGNvZGUgZWFzaWVyLlxyXG4gKi9cclxuY2xhc3MgVmVydGV4QnVmZmVyIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGJ5dGVTaXplIEluaXRpYWwgc2l6ZSBvZiB0aGUgYnVmZmVyIGluIGJ5dGVzLiBBcyBpdCBnZXRzIGZpbGxlZCBieSB3b3Jkc1xyXG4gICAgICogICAgICB0aGUgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbHkgb2YgNC5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoYnl0ZVNpemUpIHtcclxuICAgICAgICB0aGlzLl9uZXh0V29yZE9mZnNldCA9IDA7XHJcbiAgICAgICAgdGhpcy5faW5pdEJ1ZmZlcnMoYnl0ZVNpemUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZXJlIGlzIG5vIGZyZWUgc3BhY2UgcmVtYWluaW5nIGluIGJ1ZmZlci5cclxuICAgICAqL1xyXG4gICAgZ2V0IGlzRnVsbCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbmV4dFdvcmRPZmZzZXQgPj0gdGhpcy5fdWludDMyVmlldy5sZW5ndGg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2Ygd29yZHMgKDQgYnl0ZXMgdmFsdWVzKSBhbHJlYWR5IHdyaXR0ZW4uXHJcbiAgICAgKi9cclxuICAgIGdldCBvY2N1cGllZFNpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX25leHRXb3JkT2Zmc2V0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIE1heCBudW1iZXIgb2YgYnl0ZXMgdGhpcyBidWZmZXIgaXMgYWJsZSB0byBzdG9yZS4gSXQgY2FuIGJlIGluY3JlYXNlZCBieSB0aGUgZXh0ZW5kKCkgbWV0aG9kLlxyXG4gICAgICovXHJcbiAgICBnZXQgYnl0ZVNpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VpbnQzMlZpZXcuYnl0ZUxlbmd0aDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRXh0ZW5kcyBidWZmZXIgdG8gdGhlIG5ldyBzaXplLiBUaGUgbmV3IHNpemUgbXVzdCBiZSBub3QgbGVzcyB0aGFuIGN1cnJlbnQgb25lIGFuZCBpdCBtdXN0IGJlIGEgbXVsdGlwbHkgb2YgNC5cclxuICAgICAqL1xyXG4gICAgZXh0ZW5kKG5ld0J5dGVTaXplKSB7XHJcbiAgICAgICAgLy8gVE9ETyBhc3NlcnQgbmV3Qnl0ZUxlbmd0aCBpcyBsYXJnZXIgdGhhbiBjdXJyZW50IF9hcnJheUJ1ZmZlciBhbmQgaXRzIGlzIGEgbXVsdGlwbHkgb2YgdGhlIHdvcmQgc2l6ZS5cclxuICAgICAgICBjb25zdCBvbGRVaW50MzJWaWV3ID0gdGhpcy5fdWludDMyVmlldztcclxuICAgICAgICB0aGlzLl9pbml0QnVmZmVycyhuZXdCeXRlU2l6ZSk7XHJcbiAgICAgICAgdGhpcy5fdWludDMyVmlldy5zZXQob2xkVWludDMyVmlldyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFwcGVuZHMgdmFsdWUgYXMgYSB1aW50MzIgbnVtYmVyLlxyXG4gICAgICovXHJcbiAgICBwdXNoVWludDMyKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fdWludDMyVmlld1t0aGlzLl9uZXh0V29yZE9mZnNldCsrXSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBlbmRzIHZhbHVlIGFzIGEgZmxvYXQzMiBudW1iZXIuXHJcbiAgICAgKi9cclxuICAgIHB1c2hGbG9hdDMyKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fZmxvYXQzMlZpZXdbdGhpcy5fbmV4dFdvcmRPZmZzZXQrK10gPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgdWludDggdmlldyBvZiB0aGlzIGJ1ZmZlci4gVGhlIHNpemUgb2YgdGhlIHZpZXcgbWF0Y2hlcyB0aGUgYW1vdW50IG9mIHdyaXR0ZW4gZGF0YS5cclxuICAgICAqL1xyXG4gICAgYXNVaW50MzJBcnJheSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdWludDMyVmlldy5zdWJhcnJheSgwLCB0aGlzLm9jY3VwaWVkU2l6ZSk7XHJcbiAgICB9XHJcbiAgICBfaW5pdEJ1ZmZlcnMoYnl0ZUxlbmd0aCkge1xyXG4gICAgICAgIGNvbnN0IGFycmF5QnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ5dGVMZW5ndGgpO1xyXG4gICAgICAgIHRoaXMuX3VpbnQzMlZpZXcgPSBuZXcgVWludDMyQXJyYXkoYXJyYXlCdWZmZXIpO1xyXG4gICAgICAgIHRoaXMuX2Zsb2F0MzJWaWV3ID0gbmV3IEZsb2F0MzJBcnJheShhcnJheUJ1ZmZlcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE1vdmVzIFwidGFpbFwiIGRhdGEgKGZyb20gdGhlIG9mZnNldCBzcGVjaWZpZWQgdG8gdGhlIGVuZCBvZiB0aGUgYnVmZmVyKSBvZiBvbmUgYnVmZmVyIHRvIGFub3RoZXIuIFRoZSBjdXJzb3JzIG9mXHJcbiAgICAgKiBidWZmZXJzIHdpbGwgYmUgYXBwcm9wcmlhdGVseSB1cGRhdGVkIHRvIHJlZmxlY3QgZGF0YSBjaGFuZ2VzLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdHJhbnNmZXJEYXRhVGFpbChzcmMsIGRzdCwgc3JjV29yZE9mZnNldCwgZHN0T2Zmc2V0ID0gMCkge1xyXG4gICAgICAgIGNvbnN0IHRhaWxMZW5ndGggPSBzcmMub2NjdXBpZWRTaXplIC0gc3JjV29yZE9mZnNldDtcclxuICAgICAgICBjb25zdCBzcmNUYWlsID0gc3JjLl91aW50MzJWaWV3LnN1YmFycmF5KHNyY1dvcmRPZmZzZXQsIHNyYy5vY2N1cGllZFNpemUpO1xyXG4gICAgICAgIGRzdC5fdWludDMyVmlldy5zZXQoc3JjVGFpbCwgZHN0T2Zmc2V0KTtcclxuICAgICAgICBkc3QuX25leHRXb3JkT2Zmc2V0ID0gdGFpbExlbmd0aDtcclxuICAgICAgICBzcmMuX25leHRXb3JkT2Zmc2V0ID0gc3JjV29yZE9mZnNldDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogSW5kZXggYnVmZmVyIGhlbHBlciBjbGFzcywgdGhhdCBzdXBwb3J0cyBzZXF1ZW50aWFsIHdyaXRpbmcgaW50ZXJmYWNlIGFuZCB0YWtlcyBvdmVyIHNvbWUgc2luZ2xlLWJ1ZmZlciBvcGVyYXRpb25zLlxyXG4gKiBJdCBpcyBhbiBpbnRlZ3JhbCBwYXJ0IG9mIHRoZSBidWZmZXIgd3JpdGVyIGNsYXNzIGFuZCBpdHMgbWFpbiBwdXJwb3NlIGlzIHRvIG1ha2UgdGhlIHdyaXRlcidzIGNvZGUgZWFzaWVyLlxyXG4gKi9cclxuY2xhc3MgSW5kZXhCdWZmZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gc2l6ZSBJbml0aWFsIHNpemUgb2YgdGhlIGJ1ZmZlci5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3Ioc2l6ZSkge1xyXG4gICAgICAgIHRoaXMuX25leHRJbmRleE9mZnNldCA9IDA7XHJcbiAgICAgICAgdGhpcy5fdWludDE2VmlldyA9IG5ldyBVaW50MTZBcnJheShzaXplKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVGhlIG51bWJlciBvZiBpbmRpY2VzIGFscmVhZHkgd3JpdHRlbi5cclxuICAgICAqL1xyXG4gICAgZ2V0IG9jY3VwaWVkU2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbmV4dEluZGV4T2Zmc2V0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIE1heCBudW1iZXIgb2YgaW5kaWNlcyB0aGlzIGJ1ZmZlciBpcyBhYmxlIHRvIHN0b3JlLiBJdCBjYW4gYmUgaW5jcmVhc2VkIGJ5IHRoZSBleHRlbmQoKSBtZXRob2QuXHJcbiAgICAgKi9cclxuICAgIGdldCBzaXplKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl91aW50MTZWaWV3Lmxlbmd0aDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRXh0ZW5kcyBidWZmZXIgdG8gdGhlIG5ldyBzaXplLlxyXG4gICAgICovXHJcbiAgICBleHRlbmQobmV3U2l6ZSkge1xyXG4gICAgICAgIC8vIFRPRE8gYXNzZXJ0IG5ld0J5dGVMZW5ndGggaXMgbGFyZ2VyIHRoYW4gY3VycmVudCBfYXJyYXlCdWZmZXJcclxuICAgICAgICBjb25zdCBvbGRVaW50MTZWaWV3ID0gdGhpcy5fdWludDE2VmlldztcclxuICAgICAgICB0aGlzLl91aW50MTZWaWV3ID0gbmV3IFVpbnQxNkFycmF5KG5ld1NpemUpO1xyXG4gICAgICAgIHRoaXMuX3VpbnQxNlZpZXcuc2V0KG9sZFVpbnQxNlZpZXcpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBlbmRzIGluZGV4IHRvIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlci5cclxuICAgICAqL1xyXG4gICAgcHVzaChpbmRleCkge1xyXG4gICAgICAgIHRoaXMuX3VpbnQxNlZpZXdbdGhpcy5fbmV4dEluZGV4T2Zmc2V0KytdID0gaW5kZXg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIHVpbnQxNiB2aWV3IG9mIHRoaXMgYnVmZmVyLiBUaGUgc2l6ZSBvZiB0aGUgdmlldyBtYXRjaGVzIHRoZSBhbW91bnQgb2Ygd3JpdHRlbiBkYXRhLlxyXG4gICAgICovXHJcbiAgICBhc1VpbnQxNkFycmF5KCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVWludDE2QXJyYXkodGhpcy5fdWludDE2Vmlldy5idWZmZXIsIDAsIHRoaXMub2NjdXBpZWRTaXplKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTW92ZXMgXCJ0YWlsXCIgZGF0YSAoZnJvbSB0aGUgb2Zmc2V0IHNwZWNpZmllZCB0byB0aGUgZW5kIG9mIHRoZSBidWZmZXIpIG9mIG9uZSBidWZmZXIgdG8gYW5vdGhlci4gVGhlIG9mZnNldHMgb2ZcclxuICAgICAqIGJ1ZmZlcnMgd2lsbCBiZSBhcHByb3ByaWF0ZWx5IHVwZGF0ZWQgdG8gcmVmbGVjdCBkYXRhIGNoYW5nZXMuXHJcbiAgICAgKiBiYXNlSW5kZXggd2lsbCBiZSBkZWR1Y3RlZCBmcm9tIGFsbCBtb3ZlZCBpbmRpY2VzLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdHJhbnNmZXJEYXRhVGFpbChzcmMsIGRzdCwgYmFzZUluZGV4LCBzcmNPZmZzZXQsIGRzdE9mZnNldCA9IDApIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gc3JjT2Zmc2V0LCBqID0gZHN0T2Zmc2V0OyBpIDwgc3JjLm9jY3VwaWVkU2l6ZTsgaSsrLCBqKyspIHtcclxuICAgICAgICAgICAgZHN0Ll91aW50MTZWaWV3W2pdID0gc3JjLl91aW50MTZWaWV3W2ldIC0gYmFzZUluZGV4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBkc3QuX25leHRJbmRleE9mZnNldCA9IHNyYy5vY2N1cGllZFNpemUgLSBzcmNPZmZzZXQ7XHJcbiAgICAgICAgc3JjLl9uZXh0SW5kZXhPZmZzZXQgPSBzcmNPZmZzZXQ7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEJhc2UgYnVmZmVyIHdyaXRlciBpbXBsZW1lbnRhdGlvbi4gQ2FuIHdyaXRlIHVuc2lnbmVkIHNob3J0IGluZGljZXMgYW5kXHJcbiAqIHByb3ZpZGVzIGZhY2lsaXRpZXMgZm9yIGNoaWxkIGNsYXNzZXMgdG8gaGFuZGxlIHdyaXRpbmcgdmVydGV4IGRhdGEuIERlZmluZXNcclxuICogYSBjb25jZXB0IG9mIGN1cnJlbnQgbWVzaC4gQmFzaWNhbGx5LCBpdCBtZWFuIHRoYXQgYWxsIHZlcnRpY2VzIGFuZCBpbmRpY2VzXHJcbiAqIHdyaXR0ZW4gdG8gYSB3cml0ZXIgYmV0d2VlbiB0d28gYGVuZE1lc2hgIGNhbGxzIChvciBjb25zdHJ1Y3Rpb24gb2YgdGhlIHdyaXRlclxyXG4gKiBhbmQgYW4gYGVuZE1lc2hgIGNhbGwpIG11c3QgYmUgY29uc2lkZXJlZCBiZWxvbmdpbmcgdG8gb25lIGF0b21pYyBwaWVjZSBvZlxyXG4gKiBnZW9tZXRyeSBhbmQgc2hvdWxkIG5vdCBiZSBzcGl0dGVkIGJldHdlZW4gc2VwYXJhdGUgYnVmZmVycy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJ1ZmZlcldyaXRlciB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgd3JpdGVyIGFuZCBhbGxvY2F0ZXMgaW5pdGlhbCBhbW91bnQgb2YgbWVtb3J5IHRvIHN0b3JlIGRhdGEuXHJcbiAgICAgKiBBbHNvIGltcGxpY2l0bHkgXCJzdGFydFwiIGEgbWVzaC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmVydGV4Qnl0ZVNpemVcclxuICAgICAqIEBwYXJhbSBpbml0VmVydGV4QnVmZmVyU2l6ZSBJbml0IHNpemUgKGluIHZlcnRpY2VzKSBvZiBncm93aW5nIHZlcnRleCBidWZmZXJzLlxyXG4gICAgICogQHBhcmFtIG1heFZlcnRleEJ1ZmZlclNpemUgTWF4IHNpemUgKGluIHZlcnRpY2VzKSBvZiB2ZXJ0ZXggYnVmZmVycy5cclxuICAgICAqIEBwYXJhbSBpbml0SW5kZXhCdWZmZXJVaW50MTZTaXplIEluaXQgc2l6ZSAoaW4gdWludDE2IG51bWJlcikgb2YgZ3Jvd2luZyBpbmRleCBidWZmZXJzLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcih2ZXJ0ZXhCeXRlU2l6ZSwgaW5pdFZlcnRleEJ1ZmZlclNpemUgPSAweDQwMCwgbWF4VmVydGV4QnVmZmVyU2l6ZSA9IDB4MTAwMDAsIGluaXRJbmRleEJ1ZmZlclVpbnQxNlNpemUgPSAweGMwMCkge1xyXG4gICAgICAgIHRoaXMuX3ZlcnRleEJ5dGVTaXplID0gdmVydGV4Qnl0ZVNpemU7XHJcbiAgICAgICAgdGhpcy5faW5pdFZlcnRleEJ1ZmZlckJ5dGVTaXplID0gdmVydGV4Qnl0ZVNpemUgKiBpbml0VmVydGV4QnVmZmVyU2l6ZTtcclxuICAgICAgICB0aGlzLl9tYXhWZXJ0ZXhCdWZmZXJCeXRlU2l6ZSA9IHZlcnRleEJ5dGVTaXplICogbWF4VmVydGV4QnVmZmVyU2l6ZTtcclxuICAgICAgICB0aGlzLl9pbml0SW5kZXhCdWZmZXJVaW50MTZTaXplID0gaW5pdEluZGV4QnVmZmVyVWludDE2U2l6ZTtcclxuICAgICAgICB0aGlzLl92ZXJ0ZXhCdWZmZXIgPSBuZXcgVmVydGV4QnVmZmVyKHRoaXMuX2luaXRWZXJ0ZXhCdWZmZXJCeXRlU2l6ZSk7XHJcbiAgICAgICAgdGhpcy5fdmVydGV4QnVmZmVycyA9IFt0aGlzLl92ZXJ0ZXhCdWZmZXJdO1xyXG4gICAgICAgIHRoaXMuX2luZGV4QnVmZmVyID0gbmV3IEluZGV4QnVmZmVyKHRoaXMuX2luaXRJbmRleEJ1ZmZlclVpbnQxNlNpemUpO1xyXG4gICAgICAgIHRoaXMuX2luZGV4QnVmZmVycyA9IFt0aGlzLl9pbmRleEJ1ZmZlcl07XHJcbiAgICAgICAgdGhpcy5fY3VycmVudE1lc2hWZXJ0ZXhPZmZzZXQgPSAwO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRNZXNoSW5kZXhPZmZzZXQgPSAwO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRNZXNoQmFzZUluZGV4ID0gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGEgYnVuY2ggb2YgaW5kaWNlcyB0byB0aGUgdW5kZXJseWluZyBzdG9yYWdlIGFzIHVuc2lnbmVkIHNob3J0XHJcbiAgICAgKiBudW1iZXJzLiBJZiBjdXJyZW50IHN0b3JhZ2UgZG9lc24ndCBoYXZlIGVub3VnaCBzcGFjZSB0byBhY2NvbW1vZGF0ZVxyXG4gICAgICogZ2l2ZW4gaW5kaWNlcywgdGhlIHdyaXRlciB3aWxsIGF1dG9tYXRpY2FsbHkgcmVzaXplIGl0LiBUaGUgd3JpdGVyXHJcbiAgICAgKiBhdXRvbWF0aWNhbGx5IGFkZHMgYmFzZSBpbmRleCB0byB0aGUgc3VwcGxpZWQgdmFsdWVzLCBzbyBmcm9tIGEgdXNlclxyXG4gICAgICogcG9pbnQgb2YgdmlldyBmaXJzdCB2ZXJ0ZXggb2YgYSBtZXNoIGhhcyBpbmRleCAwIGFuZCB0aGVyZSdzIG5vIG5lZWRcclxuICAgICAqIHRvIHRha2UgaW50byBhY2NvdW50IGl0J3Mgb2Zmc2V0IHdoaWxlIGdlbmVyYXRpbmcgbWVzaCdzIHRvcG9sb2d5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpbmRpY2VzIEFycmF5IG9mIGluZGljZXMgdG8gd3JpdGUuXHJcbiAgICAgKi9cclxuICAgIHdyaXRlSW5kaWNlcyhpbmRpY2VzKSB7XHJcbiAgICAgICAgdGhpcy5fZW5zdXJlRW5vdWdoSW5kZXhCdWZmZXJTcGFjZShpbmRpY2VzLmxlbmd0aCk7XHJcbiAgICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5faW5kZXhCdWZmZXI7XHJcbiAgICAgICAgY29uc3QgYmFzZUluZGV4ID0gdGhpcy5fY3VycmVudE1lc2hCYXNlSW5kZXg7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoKGJhc2VJbmRleCArIGluZGljZXNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJhdGVzIHRyaWFuZ2xlIGluZGljZXMgZnJvbSBhbiBhcnJheSBvZiBpbmRpY2VzIG9mIGEgdHJpYW5nbGUgc3RyaXBcclxuICAgICAqIChhcyBpbiBHTCkgYW5kIHdyaXRlcyBnZW5lcmF0ZWQgdHJpcGxldHMgdG8gdGhlIG1hbmFnZWQgaW5kZXggYnVmZmVyLlxyXG4gICAgICogQHNlZSBPcGVuR0wgRVMgMi4wIFNwZWMsIMKnMi42LjFcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaW5kaWNlcyBJbmRpY2VzIG9mIHRoZSBzdHJpcC5cclxuICAgICAqL1xyXG4gICAgd3JpdGVJbmRpY2VzRm9yU3RyaXAoaW5kaWNlcykge1xyXG4gICAgICAgIHRoaXMuX2Vuc3VyZUVub3VnaEluZGV4QnVmZmVyU3BhY2UoMyAqIChpbmRpY2VzLmxlbmd0aCAtIDIpKTtcclxuICAgICAgICBjb25zdCBidWZmZXIgPSB0aGlzLl9pbmRleEJ1ZmZlcjtcclxuICAgICAgICBjb25zdCBiYXNlSW5kZXggPSB0aGlzLl9jdXJyZW50TWVzaEJhc2VJbmRleDtcclxuICAgICAgICBmb3IgKGNvbnN0IGkgb2YgZ2VuZXJhdGVTdHJpcChpbmRpY2VzLmxlbmd0aCkpIHtcclxuICAgICAgICAgICAgYnVmZmVyLnB1c2goYmFzZUluZGV4ICsgaW5kaWNlc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZXMgdHJpYW5nbGUgaW5kaWNlcyBmcm9tIGEgY29udGludW91cyB0cmlhbmdsZSBzdHJpcCBvZiBhIGdpdmVuXHJcbiAgICAgKiBsZW5ndGggYW5kIHdyaXRlcyBnZW5lcmF0ZWQgdHJpcGxldHMgdG8gbWFuYWdlZCBpbmRleCBidWZmZXIuXHJcbiAgICAgKiBAc2VlIE9wZW5HTCBFUyAyLjAgU3BlYywgwqcyLjYuMVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpbmRleENvdW50XHJcbiAgICAgKiBAcGFyYW0gYmFzZUluZGV4SW5NZXNoXHJcbiAgICAgKi9cclxuICAgIHdyaXRlSW5kaWNlc0ZvckNvbnRpbnVvdXNTdHJpcChpbmRleENvdW50LCBiYXNlSW5kZXhJbk1lc2ggPSAwKSB7XHJcbiAgICAgICAgdGhpcy5fZW5zdXJlRW5vdWdoSW5kZXhCdWZmZXJTcGFjZSgzICogKGluZGV4Q291bnQgLSAyKSk7XHJcbiAgICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5faW5kZXhCdWZmZXI7XHJcbiAgICAgICAgY29uc3QgYmFzZUluZGV4ID0gdGhpcy5fY3VycmVudE1lc2hCYXNlSW5kZXggKyBiYXNlSW5kZXhJbk1lc2g7XHJcbiAgICAgICAgZm9yIChjb25zdCBpIG9mIGdlbmVyYXRlU3RyaXAoaW5kZXhDb3VudCkpIHtcclxuICAgICAgICAgICAgYnVmZmVyLnB1c2goYmFzZUluZGV4ICsgaSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZXMgdHJpYW5nbGUgaW5kaWNlcyBmcm9tIGFuIGFycmF5IG9mIGluZGljZXMgb2YgYSB0cmlhbmdsZSBmYW4gKGFzXHJcbiAgICAgKiBpbiBHTCkgYW5kIHdyaXRlcyBnZW5lcmF0ZWQgdHJpcGxldHMgdG8gdGhlIG1hbmFnZWQgaW5kZXggYnVmZmVyLlxyXG4gICAgICogQHNlZSBPcGVuR0wgRVMgMi4wIFNwZWMsIMKnMi42LjFcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaW5kaWNlcyBJbmRpY2VzIG9mIHRoZSBzdHJpcC5cclxuICAgICAqL1xyXG4gICAgd3JpdGVJbmRpY2VzRm9yRmFuKGluZGljZXMpIHtcclxuICAgICAgICB0aGlzLl9lbnN1cmVFbm91Z2hJbmRleEJ1ZmZlclNwYWNlKDMgKiAoaW5kaWNlcy5sZW5ndGggLSAyKSk7XHJcbiAgICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5faW5kZXhCdWZmZXI7XHJcbiAgICAgICAgY29uc3QgYmFzZUluZGV4ID0gdGhpcy5fY3VycmVudE1lc2hCYXNlSW5kZXg7XHJcbiAgICAgICAgZm9yIChjb25zdCBpIG9mIGdlbmVyYXRlRmFuKGluZGljZXMubGVuZ3RoKSkge1xyXG4gICAgICAgICAgICBidWZmZXIucHVzaChiYXNlSW5kZXggKyBpbmRpY2VzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlcyB0cmlhbmdsZSBpbmRpY2VzIGZyb20gYSBjb250aW51b3VzIHRyaWFuZ2xlIGZhbiBvZiBhIGdpdmVuIGxlbmd0aFxyXG4gICAgICogYW5kIHdyaXRlcyBnZW5lcmF0ZWQgdHJpcGxldHMgdG8gbWFuYWdlZCBpbmRleCBidWZmZXIuXHJcbiAgICAgKiBAc2VlIE9wZW5HTCBFUyAyLjAgU3BlYywgwqcyLjYuMVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpbmRleENvdW50XHJcbiAgICAgKiBAcGFyYW0gYmFzZUluZGV4SW5NZXNoXHJcbiAgICAgKi9cclxuICAgIHdyaXRlSW5kaWNlc0ZvckNvbnRpbnVvdXNGYW4oaW5kZXhDb3VudCwgYmFzZUluZGV4SW5NZXNoID0gMCkge1xyXG4gICAgICAgIHRoaXMuX2Vuc3VyZUVub3VnaEluZGV4QnVmZmVyU3BhY2UoMyAqIChpbmRleENvdW50IC0gMikpO1xyXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuX2luZGV4QnVmZmVyO1xyXG4gICAgICAgIGNvbnN0IGJhc2VJbmRleCA9IGJhc2VJbmRleEluTWVzaCArIHRoaXMuX2N1cnJlbnRNZXNoQmFzZUluZGV4O1xyXG4gICAgICAgIGZvciAoY29uc3QgaSBvZiBnZW5lcmF0ZUZhbihpbmRleENvdW50KSkge1xyXG4gICAgICAgICAgICBidWZmZXIucHVzaChiYXNlSW5kZXggKyBpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVuZHMgY3VycmVudCBtZXNoIGFuZCBpbXBsaWNpdGx5IHN0YXJ0cyBhIG5ldyBvbmUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgSW50ZXJuYWwgaW5kZXggb2YgdmVydGV4IGFuZCBpbmRleCBidWZmZXJzIHRoZSBtZXNoIHdhcyB3cml0dGVuXHJcbiAgICAgKiAgICAgIHRvIGFuZCBpdHMgbWVtb3J5IGxvY2F0aW9uIGluIHRoZW0uXHJcbiAgICAgKi9cclxuICAgIGVuZE1lc2goKSB7XHJcbiAgICAgICAgY29uc3QgY3VycmVudE1lc2hWZXJ0ZXhPZmZzZXQgPSB0aGlzLl9jdXJyZW50TWVzaFZlcnRleE9mZnNldDtcclxuICAgICAgICBjb25zdCB2ZXJ0ZXhPY2N1cGllZFNpemUgPSB0aGlzLl92ZXJ0ZXhCdWZmZXIub2NjdXBpZWRTaXplO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRNZXNoVmVydGV4T2Zmc2V0ID0gdmVydGV4T2NjdXBpZWRTaXplO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRNZXNoQmFzZUluZGV4ID0gKHZlcnRleE9jY3VwaWVkU2l6ZSA8PCAyKSAvIHRoaXMuX3ZlcnRleEJ5dGVTaXplO1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRNZXNoSW5kZXhPZmZzZXQgPSB0aGlzLl9jdXJyZW50TWVzaEluZGV4T2Zmc2V0O1xyXG4gICAgICAgIGNvbnN0IGluZGV4T2NjdXBpZWRTaXplID0gdGhpcy5faW5kZXhCdWZmZXIub2NjdXBpZWRTaXplO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRNZXNoSW5kZXhPZmZzZXQgPSBpbmRleE9jY3VwaWVkU2l6ZTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCeXRlT2Zmc2V0OiBjdXJyZW50TWVzaFZlcnRleE9mZnNldCA8PCAyLFxyXG4gICAgICAgICAgICB2ZXJ0ZXhCeXRlTGVuZ3RoOiB2ZXJ0ZXhPY2N1cGllZFNpemUgLSBjdXJyZW50TWVzaFZlcnRleE9mZnNldCA8PCAyLFxyXG4gICAgICAgICAgICBpbmRleEJ5dGVPZmZzZXQ6IGN1cnJlbnRNZXNoSW5kZXhPZmZzZXQgPDwgMSxcclxuICAgICAgICAgICAgaW5kZXhCeXRlTGVuZ3RoOiBpbmRleE9jY3VwaWVkU2l6ZSAtIGN1cnJlbnRNZXNoSW5kZXhPZmZzZXQgPDwgMSxcclxuICAgICAgICAgICAgLy8gV2UgY2FuJ3QgcmV0dXJuIGFjdHVhbCBidWZmZXIgcmVmZXJlbmNlIHNpbmNlIGl0IGNhbiBjaGFuZ2UgaWZcclxuICAgICAgICAgICAgLy8gdGhlIGJ1ZmZlciBnZXRzIHJlYWxsb2NhdGVkLlxyXG4gICAgICAgICAgICBidWZmZXJJbmRleDogdGhpcy5fdmVydGV4QnVmZmVycy5sZW5ndGggLSAxXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBjdXJyZW50bHkgb3duZWQgYnVmZmVyIGRhdGEuIFRoaXMgY2FsbCdzIGJldHRlclxyXG4gICAgICogbWFkZSB3aGVuIHlvdSdyZSBkb25lIHdpdGggdGhlIHdyaXRlciBzaW5jZSBpZiB0aGUgd3JpdGVyIGRlY2lkZXMgdG9cclxuICAgICAqIHJlc2l6ZSBhbnkgb2YgdGhlIGJ1ZmZlcnMgc29tZSBvZiB0aGUgcmVmZXJlbmNlcyBpbiB0aGUgcmV0dXJuZWQgYXJyYXlcclxuICAgICAqIG1heSBiZWNvbWUgb3V0ZGF0ZWQuXHJcbiAgICAgKi9cclxuICAgIGdldEJ1ZmZlcnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHppcCh0aGlzLl92ZXJ0ZXhCdWZmZXJzLCB0aGlzLl9pbmRleEJ1ZmZlcnMsICh2ZXJ0ZXhCdWZmZXIsIGluZGV4QnVmZmVyKSA9PiAoe1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXI6IHZlcnRleEJ1ZmZlci5hc1VpbnQzMkFycmF5KCksXHJcbiAgICAgICAgICAgIGluZGV4QnVmZmVyOiBpbmRleEJ1ZmZlci5hc1VpbnQxNkFycmF5KClcclxuICAgICAgICB9KSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYW4gb2Zmc2V0IGluIHRoZSBjdXJyZW50IHZlcnRleCBidWZmZXIgdG8gdGhlIGxvY2F0aW9uIHdoZXJlIG5leHRcclxuICAgICAqIHBpZWNlIG9mIGRhdGEgd2lsbCBiZSB3cml0dGVuLlxyXG4gICAgICovXHJcbiAgICBnZXRDdXJyZW50VmVydGV4QnVmZmVyQnl0ZU9mZnNldCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdmVydGV4QnVmZmVyLm9jY3VwaWVkU2l6ZSA8PCAyO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGluZGV4IG9mIGN1cnJlbnRseSB3cml0dGVuIHZlcnRleCBzdHJ1Y3R1cmUgaW4gdGhlIGN1cnJlbnQgdmVydGV4XHJcbiAgICAgKiBidWZmZXIuXHJcbiAgICAgKi9cclxuICAgIGdldEN1cnJlbnRWZXJ0ZXhJZHgoKSB7XHJcbiAgICAgICAgcmV0dXJuICgodGhpcy5fdmVydGV4QnVmZmVyLm9jY3VwaWVkU2l6ZSA8PCAyKSAvIHRoaXMuX3ZlcnRleEJ5dGVTaXplIHwgMCkgLSB0aGlzLl9jdXJyZW50TWVzaEJhc2VJbmRleDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGEgZmxvYXRpbmcgcG9pbnQgdmFsdWUgdG8gdGhlIGN1cnJlbnQgdmVydGV4IGJ1ZmZlciBhbmQgYWR2YW5jZXNcclxuICAgICAqIHRoZSBvZmZzZXQgYnkgNCBieXRlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIHdyaXR0ZW4uXHJcbiAgICAgKi9cclxuICAgIF93cml0ZUZsb2F0MzIodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9lbnN1cmVFbm91Z2hWZXJ0ZXhCdWZmZXJTcGFjZSgpO1xyXG4gICAgICAgIHRoaXMuX3ZlcnRleEJ1ZmZlci5wdXNoRmxvYXQzMih2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhbiB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlIHRvIHRoZSBjdXJyZW50IHZlcnRleCBidWZmZXIgYW5kIGFkdmFuY2VzXHJcbiAgICAgKiB0aGUgb2Zmc2V0IGJ5IDQgYnl0ZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBiZSB3cml0dGVuLlxyXG4gICAgICovXHJcbiAgICBfd3JpdGVXb3JkKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fZW5zdXJlRW5vdWdoVmVydGV4QnVmZmVyU3BhY2UoKTtcclxuICAgICAgICB0aGlzLl92ZXJ0ZXhCdWZmZXIucHVzaFVpbnQzMih2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhbiB1bnNpZ25lZCBzaG9ydCB2YWx1ZSB0byB0aGUgY3VycmVudCB2ZXJ0ZXggYnVmZmVyIGFuZCBhZHZhbmNlc1xyXG4gICAgICogdGhlIG9mZnNldCBieSAyIGJ5dGVzLiBQYXNzZWQgdmFsdWVzIHdpbGwgYmUgdHJ1bmNhdGVkIHRvIDE2IGJpdHMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBiZSB3cml0dGVuLlxyXG4gICAgICovXHJcbiAgICBfd3JpdGVIYWxmV29yZHModjEsIHYyKSB7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVXb3JkKHYyIDw8IDE2IHwgdjEgJiAweGZmZmYpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYW4gdW5zaWduZWQgYnl0ZSB2YWx1ZSB0byB0aGUgY3VycmVudCB2ZXJ0ZXggYnVmZmVyIGFuZCBhZHZhbmNlc1xyXG4gICAgICogdGhlIG9mZnNldCBieSAxIGJ5dGUuIFBhc3NlZCB2YWx1ZXMgd2lsbCBiZSB0cnVuY2F0ZWQgdG8gOCBiaXRzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgd3JpdHRlbi5cclxuICAgICAqL1xyXG4gICAgX3dyaXRlQnl0ZXModjEsIHYyLCB2MywgdjQpIHtcclxuICAgICAgICB0aGlzLl93cml0ZVdvcmQodjQgPDwgMjQgfFxyXG4gICAgICAgICAgICAodjMgJiAweGZmKSA8PCAxNiB8XHJcbiAgICAgICAgICAgICh2MiAmIDB4ZmYpIDw8IDggfFxyXG4gICAgICAgICAgICB2MSAmIDB4ZmYpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmNvZGVzIGEgd29ybGQgY29vcmRpbmF0ZSB2ZWN0b3IgYXMgYSBwYWlyIG9mIDMyLWJpdCBpbnRlZ2VycyAoc3BsaXR0aW5nXHJcbiAgICAgKiB0aGVtIGluIHR1cm4gaW50byB0byAxNi1iaXQgb25lcykuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGMgVGhlIHdvcmxkIGNvb3JkaW5hdGUuXHJcbiAgICAgKi9cclxuICAgIF93cml0ZVdvcmxkQ29vcmRpbmF0ZShjKSB7XHJcbiAgICAgICAgLy8gVG8gYXZvaWQgdXNpbmcgR1BVIHNpbmdlZCBpbnRlZ2VyIGNvbnZlcnNpb25zIHdlIHNoaWZ0IGFuZCBzY2FsZSB3b3JsZFxyXG4gICAgICAgIC8vIGNvb3JkaW5hdGVzIHNvIHRoZXkncmUgaW4gWzAsIDFdIHJhbmdlIChpbnN0ZWFkIG9mIFstMSwgMV0pIGFuZCB0aGVuXHJcbiAgICAgICAgLy8gZW5jb2RlZCBhcyB1bnNpZ25lZCAzMiBiaXQgaW50ZWdlcnMgc3BsaXQgaW50byB0byAxNiBiaXQgb25lcy5cclxuICAgICAgICBjb25zdCB4VWludDMyID0gZmxvYXRUb1VpbnQzMigwLjUgKiAoYy54ICsgMSkpO1xyXG4gICAgICAgIGNvbnN0IHlVaW50MzIgPSBmbG9hdFRvVWludDMyKDAuNSAqIChjLnkgKyAxKSk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVIYWxmV29yZHMoeFVpbnQzMiA+Pj4gMTYsIHlVaW50MzIgPj4+IDE2KTtcclxuICAgICAgICB0aGlzLl93cml0ZUhhbGZXb3Jkcyh4VWludDMyLCB5VWludDMyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgbmV3IGJpZ2dlciBzaXplIG9mIGEgdmVydGV4IGJ1ZmZlciBiYXNlZCBvbiBpdHMgY3VycmVudCBzaXplLiBCeVxyXG4gICAgICogZGVmYXVsdCBqdXN0IGRvdWJsZSB0aGUgY3VycmVudCBzaXplLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjdXJyZW50Qnl0ZVNpemUgQ3VycmVudCBzaXplIG9mIHRoZSBpbmRleCBidWZmZXIgaW4gYnl0ZXMuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgbmV3IHNpemUuXHJcbiAgICAgKi9cclxuICAgIF9nZXROZXh0VmVydGV4QnVmZmVyQnl0ZVNpemUoY3VycmVudEJ5dGVTaXplKSB7XHJcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRCeXRlU2l6ZSA8PCAxO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlcyBuZXcgYmlnZ2VyIHNpemUgb2YgYW4gaW5kZXggYnVmZmVyIGJhc2VkIG9uIGl0cyBjdXJyZW50IHNpemUuIEJ5XHJcbiAgICAgKiBkZWZhdWx0IGp1c3QgZG91YmxlIHRoZSBjdXJyZW50IHNpemUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGN1cnJlbnRVaW50MTZTaXplIEN1cnJlbnQgc2l6ZSBvZiB0aGUgaW5kZXggYnVmZmVyIGluIHNob3J0cy5cclxuICAgICAqIEByZXR1cm5zIFRoZSBuZXcgc2l6ZS5cclxuICAgICAqL1xyXG4gICAgX2dldE5leHRJbmRleEJ1ZmZlclVpbnQxNlNpemUoY3VycmVudFVpbnQxNlNpemUpIHtcclxuICAgICAgICByZXR1cm4gY3VycmVudFVpbnQxNlNpemUgPDwgMTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRW5zdXJlcyB0aGF0IHRoZSBtYW5hZ2VkIHZlcnRleCBidWZmZXIgaGFzIGVub3VnaCBzcGFjZSB0byBmaXQgaW4gYSBjaHVua1xyXG4gICAgICogb2YgZGF0YSBvZiBhIGdpdmVuIHNpemUuIEVpdGhlciBkb2VzIG5vdGhpbmcsIHJlc2l6ZXMgdGhlIGN1cnJlbnQgdmVydGV4XHJcbiAgICAgKiBidWZmZXIgb3IgY3JlYXRlcyBlbnRpcmVseSBuZXcgcGFpciBvZiB2ZXJ0ZXggYW5kIGluZGV4IGJ1ZmZlcnMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZhbHVlU2l6ZSBCeXRlIHNpemUgb2YgdGhlIGRhdGEgdGhhdCBuZWVkcyB0byBiZSBhY2NvbW1vZGF0ZWQgYnlcclxuICAgICAqICAgICAgdGhlIHZlcnRleCBidWZmZXIuXHJcbiAgICAgKi9cclxuICAgIF9lbnN1cmVFbm91Z2hWZXJ0ZXhCdWZmZXJTcGFjZSgpIHtcclxuICAgICAgICBjb25zdCB2ZXJ0ZXhCdWZmZXIgPSB0aGlzLl92ZXJ0ZXhCdWZmZXI7XHJcbiAgICAgICAgaWYgKCF2ZXJ0ZXhCdWZmZXIuaXNGdWxsKSB7XHJcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgZW5vdWdoIHNwYWNlLCBzbyBub3RoaW5nIHRvIGJlIGRvbmUuXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZlcnRleEJ1ZmZlci5ieXRlU2l6ZSA8IHRoaXMuX21heFZlcnRleEJ1ZmZlckJ5dGVTaXplKSB7XHJcbiAgICAgICAgICAgIC8vIElmIHdlIGNhbiBqdXN0IHJlc2l6ZSB0aGUgY3VycmVudCB2ZXJ0ZXggYnVmZmVyLCBkbyB0aGF0LlxyXG4gICAgICAgICAgICB0aGlzLl92ZXJ0ZXhCdWZmZXIuZXh0ZW5kKHRoaXMuX2dldE5leHRWZXJ0ZXhCdWZmZXJCeXRlU2l6ZSh2ZXJ0ZXhCdWZmZXIuYnl0ZVNpemUpKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIGVub3VnaCBzcGFjZSBpbiB0aGUgY3VycmVudCB2ZXJ0ZXggYnVmZmVyIGFuZCBpdCdzXHJcbiAgICAgICAgLy8gYWxyZWFkeSBvZiBtYXhpbXVtIHNpemUsIGFsbG9jYXRlIG5ldyB2ZXJ0ZXggYW5kIGluZGV4IGJ1ZmZlcnMgYW5kXHJcbiAgICAgICAgLy8gY29weSBkYXRhIG9mIHRoZSBjdXJyZW50IG1lc2ggdG8gdGhlbSBmcm9tIHRoZSBjdXJyZW50IGJ1ZmZlcnMuXHJcbiAgICAgICAgLy8gVGhlbiBtYWtlIHRob3NlIGJ1ZmZlciB0aGUgY3VycmVudCBvbmVzLlxyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRNZXNoVmVydGV4T2Zmc2V0ID0gdGhpcy5fY3VycmVudE1lc2hWZXJ0ZXhPZmZzZXQ7XHJcbiAgICAgICAgY29uc3QgY3VycmVudE1lc2hWZXJ0ZXhCeXRlU2l6ZSA9ICh2ZXJ0ZXhCdWZmZXIub2NjdXBpZWRTaXplIC0gY3VycmVudE1lc2hWZXJ0ZXhPZmZzZXQpICogNDtcclxuICAgICAgICBjb25zdCBtYXhWZXJ0ZXhCdWZmZXJCeXRlU2l6ZSA9IHRoaXMuX21heFZlcnRleEJ1ZmZlckJ5dGVTaXplO1xyXG4gICAgICAgIGlmIChjdXJyZW50TWVzaFZlcnRleEJ5dGVTaXplID09PSBtYXhWZXJ0ZXhCdWZmZXJCeXRlU2l6ZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01lc2ggaXMgdG9vIGJpZyB0byBmaXQgaW4uJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBuZXdWZXJ0ZXhCdWZmZXJCeXRlU2l6ZSA9IHRoaXMuX2luaXRWZXJ0ZXhCdWZmZXJCeXRlU2l6ZTtcclxuICAgICAgICAvLyBJbml0aWFsIHZlcnRleCBidWZmZXIgc2l6ZSBtYXkgYmUgdG9vIHNtYWxsIHRvIGFjY29tbW9kYXRlIHRoZSBjdXJyZW50XHJcbiAgICAgICAgLy8gbWVzaCwgc28gd2UgZmluZCBuZXh0IGJpZ2dlciBzaXplIHRoYXQgaXMgc3VmZmljaWVudC5cclxuICAgICAgICB3aGlsZSAobmV3VmVydGV4QnVmZmVyQnl0ZVNpemUgPD0gY3VycmVudE1lc2hWZXJ0ZXhCeXRlU2l6ZSkge1xyXG4gICAgICAgICAgICBuZXdWZXJ0ZXhCdWZmZXJCeXRlU2l6ZSA9IHRoaXMuX2dldE5leHRWZXJ0ZXhCdWZmZXJCeXRlU2l6ZShuZXdWZXJ0ZXhCdWZmZXJCeXRlU2l6ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG5ld1ZlcnRleEJ1ZmZlciA9IG5ldyBWZXJ0ZXhCdWZmZXIobmV3VmVydGV4QnVmZmVyQnl0ZVNpemUpO1xyXG4gICAgICAgIFZlcnRleEJ1ZmZlci50cmFuc2ZlckRhdGFUYWlsKHZlcnRleEJ1ZmZlciwgbmV3VmVydGV4QnVmZmVyLCBjdXJyZW50TWVzaFZlcnRleE9mZnNldCk7XHJcbiAgICAgICAgdGhpcy5fdmVydGV4QnVmZmVyID0gbmV3VmVydGV4QnVmZmVyO1xyXG4gICAgICAgIHRoaXMuX3ZlcnRleEJ1ZmZlcnMucHVzaChuZXdWZXJ0ZXhCdWZmZXIpO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRNZXNoVmVydGV4T2Zmc2V0ID0gMDtcclxuICAgICAgICBjb25zdCBpbmRleEJ1ZmZlciA9IHRoaXMuX2luZGV4QnVmZmVyO1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRNZXNoSW5kZXhPZmZzZXQgPSB0aGlzLl9jdXJyZW50TWVzaEluZGV4T2Zmc2V0O1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRNZXNoSW5kZXhTaXplID0gaW5kZXhCdWZmZXIub2NjdXBpZWRTaXplIC0gY3VycmVudE1lc2hJbmRleE9mZnNldDtcclxuICAgICAgICBsZXQgbmV3SW5kZXhCdWZmZXJTaXplID0gdGhpcy5faW5pdEluZGV4QnVmZmVyVWludDE2U2l6ZTtcclxuICAgICAgICAvLyBJbml0aWFsIGluZGV4IGJ1ZmZlciBzaXplIG1heSBiZSB0b28gc21hbGwgdG8gYWNjb21tb2RhdGUgdGhlIGN1cnJlbnRcclxuICAgICAgICAvLyBtZXNoLCBzbyB3ZSBmaW5kIG5leHQgYmlnZ2VyIHNpemUgdGhhdCBpcyBzdWZmaWNpZW50LlxyXG4gICAgICAgIHdoaWxlIChuZXdJbmRleEJ1ZmZlclNpemUgPD0gY3VycmVudE1lc2hJbmRleFNpemUpIHtcclxuICAgICAgICAgICAgbmV3SW5kZXhCdWZmZXJTaXplID0gdGhpcy5fZ2V0TmV4dEluZGV4QnVmZmVyVWludDE2U2l6ZShuZXdJbmRleEJ1ZmZlclNpemUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBuZXdJbmRleEJ1ZmZlciA9IG5ldyBJbmRleEJ1ZmZlcihuZXdJbmRleEJ1ZmZlclNpemUpO1xyXG4gICAgICAgIC8vIFNpbmNlIHRoZSBjdXJyZW50IG1lc2gncyBjb3BpZWQgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgbmV3IHZlcnRleFxyXG4gICAgICAgIC8vIGJ1ZmZlciwgaXQncyBiYXNlIGluZGV4IG5vdyBpcyAwLiBJZiB0aGUgbWVzaCBoYXMgYW55IHdyaXR0ZW4gaW5kaWNlcyxcclxuICAgICAgICAvLyB0aGV5J3JlIGFscmVhZHkgb2Zmc2V0IGJ5IHRoZSBvbGQgYmFzZSBpbmRleC5cclxuICAgICAgICBJbmRleEJ1ZmZlci50cmFuc2ZlckRhdGFUYWlsKGluZGV4QnVmZmVyLCBuZXdJbmRleEJ1ZmZlciwgdGhpcy5fY3VycmVudE1lc2hCYXNlSW5kZXgsIGN1cnJlbnRNZXNoSW5kZXhPZmZzZXQpO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRNZXNoQmFzZUluZGV4ID0gMDtcclxuICAgICAgICB0aGlzLl9jdXJyZW50TWVzaEluZGV4T2Zmc2V0ID0gMDtcclxuICAgICAgICB0aGlzLl9pbmRleEJ1ZmZlciA9IG5ld0luZGV4QnVmZmVyO1xyXG4gICAgICAgIHRoaXMuX2luZGV4QnVmZmVycy5wdXNoKG5ld0luZGV4QnVmZmVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRW5zdXJlcyB0aGF0IHRoZSBtYW5hZ2VkIGluZGV4IGJ1ZmZlciBoYXMgZW5vdWdoIHNwYWNlIHRvIGZpdCBpbiBhIGdpdmVuXHJcbiAgICAgKiBudW1iZXIgb2YgaW5kaWNlcy4gRWl0aGVyIGRvZXMgbm90aGluZyBvciByZXNpemVzIHRoZSBjdXJyZW50IGluZGV4XHJcbiAgICAgKiBidWZmZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGluZGV4Q291bnQgTnVtYmVyIG9mIGluZGljZXMgY2xpZW50IHdhbnRzIHRvIHdyaXRlIHRvIHRoZSBtYW5hZ2VkXHJcbiAgICAgKiAgICAgIGluZGV4IGJ1ZmZlci5cclxuICAgICAqL1xyXG4gICAgX2Vuc3VyZUVub3VnaEluZGV4QnVmZmVyU3BhY2UoaW5kZXhDb3VudCkge1xyXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuX2luZGV4QnVmZmVyO1xyXG4gICAgICAgIGNvbnN0IHJlcXVpcmVkU2l6ZSA9IGJ1ZmZlci5vY2N1cGllZFNpemUgKyBpbmRleENvdW50O1xyXG4gICAgICAgIGlmIChyZXF1aXJlZFNpemUgPD0gYnVmZmVyLnNpemUpIHtcclxuICAgICAgICAgICAgLy8gV2UgaGF2ZSBlbm91Z2ggc3BhY2Ugc28gbm90aGluZyB0byBiZSBkb25lLlxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBuZXdCdWZmZXJTaXplID0gYnVmZmVyLnNpemU7XHJcbiAgICAgICAgLy8gTGV0J3MgY29tcHV0ZSBuZXcgbGFyZ2VyIHNpemUgb2YgdGhlIGluZGV4IGJ1ZmZlciB1bnRpbCB3ZSBjYW5cclxuICAgICAgICAvLyBhY2NvbW1vZGF0ZSBpbmNvbWluZyBkYXRhLlxyXG4gICAgICAgIHdoaWxlIChyZXF1aXJlZFNpemUgPiBuZXdCdWZmZXJTaXplKSB7XHJcbiAgICAgICAgICAgIG5ld0J1ZmZlclNpemUgPSB0aGlzLl9nZXROZXh0SW5kZXhCdWZmZXJVaW50MTZTaXplKG5ld0J1ZmZlclNpemUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9pbmRleEJ1ZmZlci5leHRlbmQobmV3QnVmZmVyU2l6ZSk7XHJcbiAgICB9XHJcbn1cclxuIiwiY29uc3QgVUlOVDhfTUFYID0gMHhmZjtcclxuY29uc3QgVUlOVDE2X01BWCA9IDB4ZmZmZjtcclxuY29uc3QgVUlOVDMyX01BWCA9IDB4ZmZmZmZmZmY7XHJcbmV4cG9ydCBmdW5jdGlvbiBmbG9hdFRvVWludDgoeCkge1xyXG4gICAgcmV0dXJuIFVJTlQ4X01BWCAqIHggfCAwO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBmbG9hdFRvVWludDE2KHgpIHtcclxuICAgIHJldHVybiB4ICogVUlOVDE2X01BWCB8IDA7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGZsb2F0VG9JbnQxNih4KSB7XHJcbiAgICByZXR1cm4gKHggKiBVSU5UMTZfTUFYIC0gMSkgLyAyIHwgMDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gZmxvYXRUb1VpbnQzMih4KSB7XHJcbiAgICByZXR1cm4geCAqIFVJTlQzMl9NQVggfCAwO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBmbG9hdFRvSW50MzIoeCkge1xyXG4gICAgcmV0dXJuICh4ICogVUlOVDMyX01BWCAtIDEpIC8gMiB8IDA7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGludDMyVG9GbG9hdCh4KSB7XHJcbiAgICByZXR1cm4gKDIgKiB4ICsgMSkgLyBVSU5UMzJfTUFYO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiB1aW50MzJUb0Zsb2F0KHgpIHtcclxuICAgIHJldHVybiB4IC8gVUlOVDMyX01BWDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gaW50MTZUb0Zsb2F0KHgpIHtcclxuICAgIHJldHVybiAoMiAqIHggKyAxKSAvIFVJTlQxNl9NQVg7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIHVpbnQxNlRvRmxvYXQoeCkge1xyXG4gICAgcmV0dXJuIHggLyBVSU5UMTZfTUFYO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiB1aW50OFRvRmxvYXQoeCkge1xyXG4gICAgcmV0dXJuIHggLyBVSU5UOF9NQVg7XHJcbn1cclxuIiwiaW1wb3J0IHsgREVGQVVMVF9DT01QQVJBVE9SIH0gZnJvbSAnLi9jb21wYXJhdG9yJztcclxuLyoqXHJcbiAqIFN3YXBzIHR3byB2YWx1ZXMgaW4gYW4gYXJyYXkuXHJcbiAqXHJcbiAqIEBwYXJhbSBhcnJheSBUaGUgYXJyYXkuXHJcbiAqIEBwYXJhbSBpIEluZGV4IG9mIGEgdmFsdWUgdG8gYmUgc3dhcHBlZC5cclxuICogQHBhcmFtIGogSW5kZXggb2YgYSB2YWx1ZSB0byBiZSBzd2FwcGVkLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHN3YXAoYXJyYXksIGksIGopIHtcclxuICAgIGNvbnN0IHQgPSBhcnJheVtpXTtcclxuICAgIGFycmF5W2ldID0gYXJyYXlbal07XHJcbiAgICBhcnJheVtqXSA9IHQ7XHJcbn1cclxuLyoqXHJcbiAqIFJldmVyc2VzIG9yZGVyIG9mIGVsZW1lbnRzIGluIGEgcmFuZ2UgaW4gYW4gYXJyYXkuXHJcbiAqXHJcbiAqIEBwYXJhbSBhcnJheSBUaGUgYXJyYXkuXHJcbiAqIEBwYXJhbSBzdGFydCBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxyXG4gKiBAcGFyYW0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHJldmVyc2UoYXJyYXksIHN0YXJ0ID0gMCwgZW5kID0gYXJyYXkubGVuZ3RoKSB7XHJcbiAgICBmb3IgKGxldCBpID0gc3RhcnQsIGogPSBlbmQgLSAxOyBpIDwgajsgKytpLCAtLWopIHtcclxuICAgICAgICBzd2FwKGFycmF5LCBpLCBqKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUm90YXRlcyBhIHJhbmdlIG9mIGVsZW1lbnRzIGluIGFuIGFycmF5IGJ5IGdpdmVuIGFtb3VudC5cclxuICpcclxuICogQHBhcmFtIGFycmF5IFRoZSBhcnJheS5cclxuICogQHBhcmFtIGFtb3VudCBUaGUgYW1vdW50LlxyXG4gKiBAcGFyYW0gc3RhcnQgVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cclxuICogQHBhcmFtIGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiByb3RhdGUoYXJyYXksIGFtb3VudCA9IDEsIHN0YXJ0ID0gMCwgZW5kID0gYXJyYXkubGVuZ3RoKSB7XHJcbiAgICByZXZlcnNlKGFycmF5LCBzdGFydCwgZW5kKTtcclxuICAgIHJldmVyc2UoYXJyYXksIHN0YXJ0LCBzdGFydCArIGFtb3VudCk7XHJcbiAgICByZXZlcnNlKGFycmF5LCBzdGFydCArIGFtb3VudCwgZW5kKTtcclxufVxyXG4vKipcclxuICogQ29waWVzIGEgcmFuZ2Ugb2YgZWxlbWVudHMgZnJvbSBhIHNvdXJjZSBhcnJheSB0byBhIHJhbmdlIGluIGEgZGVzdGluYXRpb25cclxuICogYXJyYXkuXHJcbiAqXHJcbiAqIEBwYXJhbSBzcmMgVGhlIHNvdXJjZSBhcnJheS5cclxuICogQHBhcmFtIGRzdCBUaGUgZGVzdGluYXRpb24gYXJyYXkuXHJcbiAqIEBwYXJhbSBzcmNTdGFydCBUaGUgc3RhcnQgb2YgdGhlIHNvdXJjZSByYW5nZS5cclxuICogQHBhcmFtIHNyY1N0YXJ0IFRoZSBzdGFydCBvZiB0aGUgc291cmNlIHJhbmdlLlxyXG4gKiBAcGFyYW0gZHN0U3RhcnQgVGhlIHN0YXJ0IG9mIHRoZSBkZXN0aW5hdGlvbiByYW5nZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb3B5KHNyYywgZHN0LCBzcmNTdGFydCA9IDAsIHNyY0VuZCA9IHNyYy5sZW5ndGgsIGRzdFN0YXJ0ID0gMCkge1xyXG4gICAgZm9yIChsZXQgaSA9IHNyY1N0YXJ0LCBqID0gZHN0U3RhcnQ7IGkgPCBzcmNFbmQ7ICsraSwgKytqKSB7XHJcbiAgICAgICAgZHN0W2pdID0gc3JjW2ldO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBTaHVmZmxlcyByYW5kb21seSBhIHJhbmdlIG9mIGVsZW1lbnRzIGluIGFuIGFycmF5LlxyXG4gKlxyXG4gKiBAcGFyYW0gYXJyYXkgVGhlIGFycmF5LlxyXG4gKiBAcGFyYW0gc3RhcnQgVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cclxuICogQHBhcmFtIGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzaHVmZmxlKGFycmF5LCBzdGFydCA9IDAsIGVuZCA9IGFycmF5Lmxlbmd0aCkge1xyXG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0LCBqID0gaSArIDE7IGkgPCBlbmQ7ICsraSwgKytqKSB7XHJcbiAgICAgICAgc3dhcChhcnJheSwgaSwgaiArIChNYXRoLnJhbmRvbSgpICogKGVuZCAtIGopIHwgMCkpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiB6aXAodHMsIHVzLCB6aXBwZXIgPSAodCwgdSkgPT4gW3QsIHVdKSB7XHJcbiAgICBjb25zdCBsID0gTWF0aC5taW4odHMubGVuZ3RoLCB1cy5sZW5ndGgpO1xyXG4gICAgY29uc3QgdnMgPSBuZXcgQXJyYXkobCk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7ICsraSkge1xyXG4gICAgICAgIHZzW2ldID0gemlwcGVyKHRzW2ldLCB1c1tpXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdnM7XHJcbn1cclxuLyoqXHJcbiAqIENvbXBhcmVzIHR3byBhcnJheXMgbGV4aWNvZ3JhcGhpY2FsbHkuIFRoZSBvcmRlciBpcyBzcGVjaWZpZWQgYmUgdGhlIGNvbXBhcmF0b3IgcGFyYW1ldGVyLlxyXG4gKlxyXG4gKiBAcGFyYW0gY29tcGFyYXRvciBFbGVtZW50cyBjb21wYXJhdG9yIHdpdGggc3RhbmRhcmQgc2lnbmF0dXJlLlxyXG4gKiBAcGFyYW0gYSBUaGUgZmlyc3QgYXJyYXkgdG8gY29tcGFyZS5cclxuICogQHBhcmFtIGIgVGhlIHNlY29uZCBhcnJheSB0byBjb21wYXJlLlxyXG4gKiBAcmV0dXJucyAwIGlmIGFsbCBlbGVtZW50cyBhbmQgbGVuZ3RocyBhcmUgZXF1YWwsXHJcbiAqICAgICAgbmVnYXRpdmUgbnVtYmVyIGlmIHRoZSBmaXJzdCBlbGVtZW50IGlzIGxlc3MgdGhlbiB0aGUgc2Vjb25kIChsZXhpY29ncmFwaGljYWxseSksXHJcbiAqICAgICAgcG9zaXRpdmUgbnVtYmVyIGlmIHRoZSBmaXJzdCBlbGVtZW50IGlzIGdyZWF0ZXIgdGhlbiB0aGUgc2Vjb25kLFxyXG4gKiAgICAgIGlmIGFsbCB0aGUgZWxlbWVudHMgYXJlIGVxdWFsIHRoZSBsZW5ndGhzIGFyZSBiZWluZyBjb21wYXJlZC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb21wYXJlKGNvbXBhcmF0b3IsIGEsIGIpIHtcclxuICAgIGNvbnN0IGxlbmd0aCA9IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aCk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gY29tcGFyYXRvcihhW2ldLCBiW2ldKTtcclxuICAgICAgICBpZiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGEubGVuZ3RoIC0gYi5sZW5ndGg7XHJcbn1cclxuLyoqXHJcbiAqIFNvcnRzIGEgcmFuZ2Ugb2YgZWxlbWVudHMgb2YgYW4gYXJyYXkgaW4gcGxhY2Ugd2l0aCBpbnNlcnRpb24gc29ydC5cclxuICpcclxuICogQHBhcmFtIGFycmF5IFRoZSBhcnJheSB0byBiZSBzb3J0ZWQuXHJcbiAqIEBwYXJhbSBjb21wYXJhdG9yIENvbXBhcmF0b3IgZm9yIGFycmF5IGVsZW1lbnRzLlxyXG4gKiBAcGFyYW0gc3RhcnQgSW5kZXggb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhlIHJhbmdlIHRvIGJlIHNvcnRlZC5cclxuICogQHBhcmFtIGVuZCBJbmRleCBvZiBhbiBlbGVtZW50IGJlaGluZCB0aGUgbGFzdCBlbGVtZW50IGluIHRoZSByYW5nZSB0byBiZVxyXG4gKiAgICAgIHNvcnRlZC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpbnNlcnRpb25Tb3J0KGFycmF5LCBjb21wYXJhdG9yID0gREVGQVVMVF9DT01QQVJBVE9SLCBzdGFydCA9IDAsIGVuZCA9IGFycmF5Lmxlbmd0aCkge1xyXG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcclxuICAgICAgICBmb3IgKGxldCBqID0gaTsgaiA+IHN0YXJ0ICYmIGNvbXBhcmF0b3IoYXJyYXlbaiAtIDFdLCBhcnJheVtqXSkgPiAwOyAtLWopIHtcclxuICAgICAgICAgICAgc3dhcChhcnJheSwgaiAtIDEsIGopO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5jb25zdCBCTE9DS19TSVpFID0gMzI7XHJcbi8qKlxyXG4gKiBNZXJnZXMgdHdvIHNvcnRlZCByYW5nZXMgb2YgYW4gYXJyYXkuIFN0b3JlcyB0aGUgcmVzdWx0IGludG8gYW5vdGhlciBvbmUuXHJcbiAqXHJcbiAqIEBwYXJhbSBzcmMgVGhlIGFycmF5IHdpdGggdGhlIHJhbmdlcyB0byBiZSBtZXJnZWQuXHJcbiAqIEBwYXJhbSBkc3QgVGhlIGFycmF5IHRoZSByZXN1bHRpbmcgcmFuZ2Ugd2lsbCBiZSBzdG9yZWQgdG8uXHJcbiAqIEBwYXJhbSBjb21wYXJhdG9yIFRoZSBjb21wYXJhdG9yIGZvciBhcnJheSBlbGVtZW50cy5cclxuICogQHBhcmFtIHN0YXJ0IFN0YXJ0IG9mIHRoZSBmaXJzdCByYW5nZSB0byBiZSBtZXJnZWQuXHJcbiAqIEBwYXJhbSBtaWRkbGUgRW5kIG9mIHRoZSBmaXJzdCBhbmQgc2ltdWx0YW5lb3VzbHkgc3RhcnQgb2YgdGhlIHNlY29uZCByYW5nZVxyXG4gKiAgICAgIHRvIGJlIG1lcmdlZC5cclxuICogQHBhcmFtIGVuZCBFbmQgb2YgdGhlIHNlY29uZCByYW5nZSB0byBiZSBtZXJnZWQuXHJcbiAqIEBwYXJhbSBkc3RPZmZzZXQgT2Zmc2V0IG9mIG1lcmdlZCByYW5nZSBpbiB0aGUgcmVzdWx0IGFycmF5LlxyXG4gKi9cclxuZnVuY3Rpb24gbWVyZ2Uoc3JjLCBkc3QsIGNvbXBhcmF0b3IsIHN0YXJ0LCBtaWRkbGUsIGVuZCwgZHN0T2Zmc2V0KSB7XHJcbiAgICBsZXQgaSA9IGRzdE9mZnNldDtcclxuICAgIGxldCBqID0gc3RhcnQ7XHJcbiAgICBsZXQgayA9IG1pZGRsZTtcclxuICAgIHdoaWxlIChqIDwgbWlkZGxlICYmIGsgPCBlbmQpIHtcclxuICAgICAgICBkc3RbaSsrXSA9IGNvbXBhcmF0b3Ioc3JjW2pdLCBzcmNba10pID4gMCA/IHNyY1trKytdIDogc3JjW2orK107XHJcbiAgICB9XHJcbiAgICBjb3B5KHNyYywgZHN0LCBqLCBtaWRkbGUsIGkpO1xyXG4gICAgY29weShzcmMsIGRzdCwgaywgZW5kLCBpKTtcclxufVxyXG4vKipcclxuICogU29ydHMgYSByYW5nZSBvZiBlbGVtZW50cyBvZiBhbiBhcnJheSB3aXRoIG1lcmdlIHNvcnQuXHJcbiAqXHJcbiAqIEBwYXJhbSBhcnJheSAgVGhlIGFycmF5IHRvIGJlIHNvcnRlZC5cclxuICogQHBhcmFtIGNvbXBhcmF0b3IgQ29tcGFyYXRvciBmb3IgYXJyYXkgZWxlbWVudHMuXHJcbiAqIEBwYXJhbSBlbmQgSW5kZXggb2YgYW4gZWxlbWVudCBiZWhpbmQgdGhlIGxhc3QgZWxlbWVudCBpbiB0aGUgcmFuZ2UgdG8gYmVcclxuICogICAgICBzb3J0ZWQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VTb3J0KGFycmF5LCBjb21wYXJhdG9yID0gREVGQVVMVF9DT01QQVJBVE9SLCBzdGFydCA9IDAsIGVuZCA9IGFycmF5Lmxlbmd0aCkge1xyXG4gICAgLy8gRmlyc3QgYW5kIGZvcmVtb3N0OiBpZiB0aGUgcmFuZ2UgaXMgc21hbGxlciB0aGFuIHRoZSBibG9jayBzaXplLCBqdXN0XHJcbiAgICAvLyBwZXJmb3JtIGluc2VydGlvbiBzb3J0IG9uIGl0LlxyXG4gICAgaWYgKGVuZCAtIHN0YXJ0IDw9IEJMT0NLX1NJWkUpIHtcclxuICAgICAgICBpbnNlcnRpb25Tb3J0KGFycmF5LCBjb21wYXJhdG9yLCBzdGFydCwgZW5kKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAvLyBGaXJzdCB3ZSBzcGxpdCB0aGUgZ2l2ZW4gcmFuZ2UgaW50byBzdWJyYW5nZXMgb2Ygc2l6ZSBCTE9DS19TSVpFIGFuZFxyXG4gICAgLy8gc29ydCBldmVyeSByYW5nZSB3aXRoIGluc2VydGlvbiBzb3J0LlxyXG4gICAge1xyXG4gICAgICAgIGxldCBzID0gc3RhcnQ7XHJcbiAgICAgICAgbGV0IGUgPSBzICsgQkxPQ0tfU0laRTtcclxuICAgICAgICB3aGlsZSAoZSA8IGVuZCkge1xyXG4gICAgICAgICAgICBpbnNlcnRpb25Tb3J0KGFycmF5LCBjb21wYXJhdG9yLCBzLCBlKTtcclxuICAgICAgICAgICAgcyA9IGU7XHJcbiAgICAgICAgICAgIGUgKz0gQkxPQ0tfU0laRTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaW5zZXJ0aW9uU29ydChhcnJheSwgY29tcGFyYXRvciwgcywgZW5kKTtcclxuICAgIH1cclxuICAgIC8vIFRPRE8oZG1pa2lzKTogSW1wbGVtZW50IGluLXBsYWNlIG1lcmdlLiBJdCBzZWVtcyB0aGVyZSdyZSByZWFzb25hYmx5XHJcbiAgICAvLyAgICAgIGNvbXBsZXggc29sdXRpb25zIG91dCB0aGVyZS5cclxuICAgIGNvbnN0IGF1eEFycmF5ID0gbmV3IEFycmF5KGVuZCAtIHN0YXJ0KTtcclxuICAgIC8vIFRoZW4gd2UgbWVyZ2UgYmxvY2tzIHBhaXJzLCBpbmNyZWFzZSBibG9jayBzaXplIGJ5IDIgYW5kIHJlcGVhdC5cclxuICAgIGZvciAobGV0IGJsb2NrU2l6ZSA9IEJMT0NLX1NJWkU7IGJsb2NrU2l6ZSA8IGVuZCAtIHN0YXJ0OyBibG9ja1NpemUgKz0gYmxvY2tTaXplKSB7XHJcbiAgICAgICAgLy8gVE9ETyhkbWlraXMpOiBCZWZvcmUgYWZvcmVtZW50aW9uZWQgdG9kbyBtYXliZSBpbXBsZW1lbnQgYXJyYXlcclxuICAgICAgICAvLyBwaW5ncG9uZ2luZyB0byBjdXQgZG93biBhbW91bnQgb2YgZnVsbCBjb3BpZXMuXHJcbiAgICAgICAgY29weShhcnJheSwgYXV4QXJyYXksIHN0YXJ0LCBlbmQpO1xyXG4gICAgICAgIGxldCBpID0gc3RhcnQ7XHJcbiAgICAgICAgbGV0IHMgPSAwO1xyXG4gICAgICAgIGxldCBtID0gYmxvY2tTaXplO1xyXG4gICAgICAgIGxldCBlID0gbSArIGJsb2NrU2l6ZTtcclxuICAgICAgICB3aGlsZSAoZSA8IGVuZCAtIHN0YXJ0KSB7XHJcbiAgICAgICAgICAgIG1lcmdlKGF1eEFycmF5LCBhcnJheSwgY29tcGFyYXRvciwgcywgbSwgZSwgaSk7XHJcbiAgICAgICAgICAgIHMgPSBlO1xyXG4gICAgICAgICAgICBtID0gcyArIGJsb2NrU2l6ZTtcclxuICAgICAgICAgICAgZSA9IG0gKyBibG9ja1NpemU7XHJcbiAgICAgICAgICAgIGkgKz0gMiAqIGJsb2NrU2l6ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbWVyZ2UoYXV4QXJyYXksIGFycmF5LCBjb21wYXJhdG9yLCBzLCBNYXRoLm1pbihtLCBlbmQgLSBzdGFydCksIGVuZCAtIHN0YXJ0LCBpKTtcclxuICAgIH1cclxufVxyXG4iLCJleHBvcnQgZnVuY3Rpb24gREVGQVVMVF9DT01QQVJBVE9SKGEsIGIpIHtcclxuICAgIGlmIChhID4gYikge1xyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgfVxyXG4gICAgaWYgKGEgPCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIDA7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIE5VTUVSSUNBTF9DT01QQVJBVE9SKGEsIGIpIHtcclxuICAgIHJldHVybiBhIC0gYjtcclxufVxyXG4iLCJpbXBvcnQgeyBjb3VudEluZGljZXMgfSBmcm9tICcuL2NvdW50X3ZlcnRpY2VzJztcclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSByZWdpb24gaW4gYSBtZW1vcnkgY2h1bmsuIE1lbW9yeSBpcyBhbGxvY2F0ZWQgYnkgYmlnIGNodW5rcyBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucyxcclxuICogYW5kIHdlIG5lZWQgYSBtZWNoYW5pc20gdG8gY29udHJvbCB0aG9zZSBjaHVuaydzIHN1YmFsbG9jYXRpb24gdG8gcHJvcGVybHkgZnJlZVxyXG4gKiB0aGUgb2NjdXBpZWQgbWVtb3J5IC0gdGhhdCBpcyB3aGF0IHRoaXMgY2xhc3MgaXMgZm9yLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWVtb3J5U3ViQ2h1bmsge1xyXG4gICAgY29uc3RydWN0b3IoY2h1bmssIGxvY2F0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5tZW1vcnlDaHVuayA9IGNodW5rO1xyXG4gICAgICAgIHRoaXMuX2xvY2F0aW9uID0gbG9jYXRpb247XHJcbiAgICAgICAgY2h1bmsucmV0YWluKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIE9mZnNldCBvZiB2ZXJ0ZXggZGF0YSBvZiB0aGUgY2h1bmsgaW4gYnl0ZXMuXHJcbiAgICAgKi9cclxuICAgIGdldCB2ZXJ0ZXhCeXRlT2Zmc2V0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1lbW9yeUNodW5rLnZlcnRleEJ5dGVPZmZzZXQgKyB0aGlzLl9sb2NhdGlvbi52ZXJ0ZXhCeXRlT2Zmc2V0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBPZmZzZXQgb2YgaW5kZXggZGF0YSBvZiB0aGUgY2h1bmsgaW4gYnl0ZXMuXHJcbiAgICAgKi9cclxuICAgIGdldCBpbmRleEJ5dGVPZmZzZXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWVtb3J5Q2h1bmsuaW5kZXhCeXRlT2Zmc2V0ICsgdGhpcy5fbG9jYXRpb24uaW5kZXhCeXRlT2Zmc2V0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBOdW1iZXIgb2YgaW5kZXhlcyBvY2N1cGllZCBieSB0aGlzIGNodW5rLlxyXG4gICAgICovXHJcbiAgICBnZXQgaW5kZXhDb3VudCgpIHtcclxuICAgICAgICByZXR1cm4gY291bnRJbmRpY2VzKHRoaXMuX2xvY2F0aW9uLmluZGV4Qnl0ZUxlbmd0aCwgdGhpcy5tZW1vcnlDaHVuay5wYWdlLmluZGV4VHlwZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIE51bWJlciBvZiBieXRlcyBvY2N1cGllZCBieSB0aGlzIGNodW5rIGZvciB2ZXJ0ZXggZGF0YS5cclxuICAgICAqL1xyXG4gICAgZ2V0IHZlcnRleEJ5dGVMZW5ndGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2F0aW9uLnZlcnRleEJ5dGVMZW5ndGg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIE51bWJlciBvZiBieXRlcyBvY2N1cGllZCBieSB0aGlzIGNodW5rIGZvciBpbmRleCBkYXRhLlxyXG4gICAgICovXHJcbiAgICBnZXQgaW5kZXhCeXRlTGVuZ3RoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhdGlvbi5pbmRleEJ5dGVMZW5ndGg7XHJcbiAgICB9XHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMubWVtb3J5Q2h1bmsucmVsZWFzZSgpO1xyXG4gICAgfVxyXG59XHJcbiIsIi8qKlxyXG4gKiBAcmV0dXJucyBJbnRlZ2VyIG51bWJlciBvZiB2ZXJ0aWNlcyB0aGF0IGZpdCBpbnRvIGEgcmVnaW9uIG9mIHNwZWNpZmllZCBpbiBieXRlcyBzaXplLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvdW50VmVydGljZXModmVydGV4Qnl0ZVNpemUsIGF0dHJpYk1hcHBpbmcpIHtcclxuICAgIHJldHVybiB2ZXJ0ZXhCeXRlU2l6ZSAvIGF0dHJpYk1hcHBpbmcudmVydGV4Qnl0ZVNpemUgfCAwO1xyXG59XHJcbi8qKlxyXG4gKiBAcmV0dXJucyBJbnRlZ2VyIG51bWJlciBvZiBpbmRpY2VzIHRoYXQgZml0IGludG8gYSByZWdpb24gb2Ygc3BlY2lmaWVkIGluIGJ5dGVzIHNpemUuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY291bnRJbmRpY2VzKGluZGV4Qnl0ZVNpemUsIHR5cGUpIHtcclxuICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgIGNhc2UgNTEyMyAvKiBVTlNJR05FRF9TSE9SVCAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIGluZGV4Qnl0ZVNpemUgPj4gMTtcclxuICAgICAgICBjYXNlIDUxMjUgLyogVU5TSUdORURfSU5UICovOlxyXG4gICAgICAgICAgICByZXR1cm4gaW5kZXhCeXRlU2l6ZSA+PiAyO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgUmVmZXJlbmNlQ291bnRlZCBmcm9tICcuLi91dGlsL3JlZl9jb3VudGVkJztcclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYW4gYWxsb2NhdGVkIGltYWdlLiBBbGxvY2F0ZWQgaW1hZ2UgaXMgYSBzaGFyZWFibGUgcmVzb3VyY2UgdGhhdCBzaG91bGQgYmUgcmVzZWFsZWRcclxuICogd2hlbiB0aGVyZSBhcmUgbm8gY2xpZW50cyB1c2UgaXQuIEFzIGl0IGlzIG5vdCBwb3NzaWJsZSB0byByZWx5IG9uIHRoZSBHQywgY2xpZW50cyBzaG91bGRcclxuICogbWFudWFsbHkgcmV0YWluIHRoZWlyIHJlcXVpcmVkIGltYWdlcyBhbmQgcmVsZWFzZSB0aGVtIHdoZW4gdGhleSBhcmUgbm90IHJlcXVpcmVkIGFueW1vcmUuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQWxsb2NhdGVkSW1hZ2UgZXh0ZW5kcyBSZWZlcmVuY2VDb3VudGVkIHtcclxuICAgIGNvbnN0cnVjdG9yKGRlc2NyaXB0b3IsIGJib3gsIGF0bGFzTWFuYWdlcikge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5kZXNjcmlwdG9yID0gZGVzY3JpcHRvcjtcclxuICAgICAgICB0aGlzLmJib3ggPSBiYm94O1xyXG4gICAgICAgIHRoaXMuYXRsYXNNYW5hZ2VyID0gYXRsYXNNYW5hZ2VyO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlSW1hZ2Uoc291cmNlSW1hZ2UsIGxvY2F0aW9uUmVnaW9uLCBzb3VyY2VJbWFnZVJlZ2lvbikge1xyXG4gICAgICAgIHRoaXMuYXRsYXNNYW5hZ2VyLmF0bGFzLnVwZGF0ZUltYWdlKHRoaXMuYmJveCwgc291cmNlSW1hZ2UsIGxvY2F0aW9uUmVnaW9uLCBzb3VyY2VJbWFnZVJlZ2lvbik7XHJcbiAgICB9XHJcbiAgICBfZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLmF0bGFzTWFuYWdlci5yZW1vdmVJbWFnZSh0aGlzLmRlc2NyaXB0b3IpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBNYW5hZ2VzIGFsbG9jYXRpb24gb2YgaW1hZ2VzIGJ5IGlkLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSWRlbnRpZmllZEltYWdlQXRsYXNNYW5hZ2VyIHtcclxuICAgIGNvbnN0cnVjdG9yKGltYWdlQXRsYXMpIHtcclxuICAgICAgICB0aGlzLmF0bGFzID0gaW1hZ2VBdGxhcztcclxuICAgICAgICB0aGlzLl9sb2NhdGlvbnMgPSBuZXcgTWFwKCk7XHJcbiAgICB9XHJcbiAgICBnZXQgc2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYXRpb25zLnNpemU7XHJcbiAgICB9XHJcbiAgICBnZXRJbWFnZShpZCwgcmV0YWluID0gZmFsc2UpIHtcclxuICAgICAgICBjb25zdCBpbWFnZUxvY2F0aW9uID0gdGhpcy5fbG9jYXRpb25zLmdldChpZCk7XHJcbiAgICAgICAgaWYgKHJldGFpbiAmJiBpbWFnZUxvY2F0aW9uKSB7XHJcbiAgICAgICAgICAgIGltYWdlTG9jYXRpb24ucmV0YWluKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpbWFnZUxvY2F0aW9uIHx8IG51bGw7XHJcbiAgICB9XHJcbiAgICBhbGxvY2F0ZUltYWdlKGRlc2NyaXB0b3IsIGltYWdlKSB7XHJcbiAgICAgICAgY29uc3QgbG9jYXRpb24gPSB0aGlzLmF0bGFzLmFsbG9jYXRlSW1hZ2UoZGVzY3JpcHRvciwgaW1hZ2UpO1xyXG4gICAgICAgIGlmIChsb2NhdGlvbikge1xyXG4gICAgICAgICAgICBjb25zdCBpbWFnZSA9IG5ldyBBbGxvY2F0ZWRJbWFnZShkZXNjcmlwdG9yLCBsb2NhdGlvbiwgdGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvY2F0aW9ucy5zZXQoZGVzY3JpcHRvci5pZCwgaW1hZ2UpO1xyXG4gICAgICAgICAgICByZXR1cm4gaW1hZ2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlSW1hZ2UoaW1hZ2UpIHtcclxuICAgICAgICBjb25zdCBsb2NhdGlvbiA9IHRoaXMuX2xvY2F0aW9ucy5nZXQoaW1hZ2UuaWQpO1xyXG4gICAgICAgIGlmIChsb2NhdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLmF0bGFzLnJlbW92ZUltYWdlKGxvY2F0aW9uLmJib3gpO1xyXG4gICAgICAgICAgICB0aGlzLl9sb2NhdGlvbnMuZGVsZXRlKGltYWdlLmlkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb250YWlucyhpZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhdGlvbnMuaGFzKGlkKTtcclxuICAgIH1cclxuICAgIHJlc2VydmVMb2NhdGlvbihkZXNjcmlwdG9yKSB7XHJcbiAgICAgICAgY29uc3QgbG9jYXRpb24gPSB0aGlzLmF0bGFzLnJlc2VydmVMb2NhdGlvbihkZXNjcmlwdG9yKTtcclxuICAgICAgICBpZiAobG9jYXRpb24pIHtcclxuICAgICAgICAgICAgY29uc3QgaW1hZ2UgPSBuZXcgQWxsb2NhdGVkSW1hZ2UoZGVzY3JpcHRvciwgbG9jYXRpb24sIHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLl9sb2NhdGlvbnMuc2V0KGRlc2NyaXB0b3IuaWQsIGltYWdlKTtcclxuICAgICAgICAgICAgcmV0dXJuIGltYWdlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxufVxyXG4iLCIvKipcclxuICogU2ltcGxlIHJlZmVyZW5jZSBjb3VudGluZyBmb3Igc2hhcmVkIGVudGl0aWVzIHRoYXQgbmVlZCBleHBsaWNpdCBkZXN0cnVjdGlvbi5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlZmVyZW5jZUNvdW50ZWQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplcyByZWZlcmVuY2UgY291bnQgdG8gMS5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5fcmVmQ291bnQgPSAxO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbmNyZW1lbnRzIHJlZmVyZW5jZSBjb3VudC5cclxuICAgICAqL1xyXG4gICAgcmV0YWluKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9yZWZDb3VudCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyaWVkIHRvIHJldGFpbiBhIGRlc3Ryb3llZCBvYmplY3QuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3JlZkNvdW50Kys7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERlY3JlbWVudHMgcmVmZXJlbmNlIGNvdW50IGFuZCwgaWYgaXQncyByZWFjaGVkIDAsIGRlc3Ryb3lzIHRoZSBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIHJlbGVhc2UoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3JlZkNvdW50ID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVHJpZWQgdG8gcmVsZWFzZSBhIGRlc3Ryb3llZCBvYmplY3QuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3JlZkNvdW50LS07XHJcbiAgICAgICAgaWYgKHRoaXMuX3JlZkNvdW50ID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3koKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IEZvbnQgZnJvbSAnLi9mb250JztcclxuY29uc3QgVU5LTk9XTl9HTFlQSCA9IHtcclxuICAgIGlkOiAtMSxcclxuICAgIHdpZHRoOiAwLFxyXG4gICAgaGVpZ2h0OiAwLFxyXG4gICAgYmVhcmluZ1g6IDAsXHJcbiAgICBiZWFyaW5nWTogMCxcclxuICAgIGFkdmFuY2U6IDE4XHJcbn07XHJcbi8qKlxyXG4gKiBGb250IHdob3NlIGdseXBocyBhcmUgc3BlY2lmaWVkIGluIGRpc3RhbmNlIGZpZWxkIGJpdG1hcHMuIEl0J3MgXCJtYXJnaW5cIiBtZXRyaWMgc3BlY2lmaWVzIGdseXBoIGJpdG1hcCBpbm5lciBwYWRkaW5nLFxyXG4gKiB0aGF0IGlzIHJlcXVpcmVkIHRvIGZpdCBhIFwiYmx1cnJlZFwiIGdseXBoIGltYWdlLiBUaGlzIG1hcmdpbiBzaG91bGQgYmUgY29uc2lkZXJlZCBkdXJpbmcgbGF5b3V0aW5nIHRvIGRyYXcgZ2x5cGhzIG9mXHJcbiAqIHByb3BlciBzaXplcy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERmRm9udCBleHRlbmRzIEZvbnQge1xyXG4gICAgY29uc3RydWN0b3IoaWQsIHhoZWlnaHQsIG1hcmdpbikge1xyXG4gICAgICAgIHN1cGVyKGlkLCB4aGVpZ2h0LCBVTktOT1dOX0dMWVBIKTtcclxuICAgICAgICB0aGlzLm1hcmdpbiA9IG1hcmdpbjtcclxuICAgIH1cclxufVxyXG4iLCIvKipcclxuICogRm9udCBpcyBqdXN0IGEgY29sbGVjdGlvbiBvZiBnbHlwaCBkZXNjcmlwdGlvbnMuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGb250IHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGlkIEZvbnQgaWQuXHJcbiAgICAgKiBAcGFyYW0geGhlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSBcInhcIiBjaGFyIGluIGFic3RyYWN0IHBvaW50cywgaW4gZmFjdCBpcyB1c2VkIGEgdGhlIGZvbnQgc2l6ZS5cclxuICAgICAqIEBwYXJhbSB1bmtub3duR2x5cGhJbnN0YW5jZSBBbiBpbnN0YW5jZSBvZiBnbHlwaCB0byBiZSBzZXJ2ZWQgYXMgYSBzdHViIHdoZW4gbm9uZXhpc3RlbnQgZ2x5cGhcclxuICAgICAqICAgICBpcyByZXF1ZXN0ZWQuIFJlcXVlc3Rpbmcgbm9uZXhpc3RlbnQgZ2x5cGhzIG5vcm1hbGx5IHNob3VsZCBub3QgaGFwcGVuLlxyXG4gICAgICogICAgIFRoZSBzdHViIGp1c3QgYWxsb3dzIHRvIGF2b2lkIHRlZGlvdXMgbnVsbCBjaGVja3MgaW4gZm9udCBjbGllbnRzLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihpZCwgeGhlaWdodCwgdW5rbm93bkdseXBoSW5zdGFuY2UpIHtcclxuICAgICAgICB0aGlzLmlkID0gaWQ7XHJcbiAgICAgICAgdGhpcy54aGVpZ2h0ID0geGhlaWdodDtcclxuICAgICAgICB0aGlzLl91bmtub3duR2x5cGhJbnN0YW5jZSA9IHVua25vd25HbHlwaEluc3RhbmNlO1xyXG4gICAgICAgIHRoaXMuX2dseXBocyA9IG5ldyBNYXAoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiBHbHlwaCB3aXRoIHNwZWNpZmllZCBpZCBvciB1bmtub3duIGdseXBoIGluc3RhbmNlLlxyXG4gICAgICovXHJcbiAgICBnZXRHbHlwaChnbHlwaElkKSB7XHJcbiAgICAgICAgY29uc3QgZ2x5cGggPSB0aGlzLl9nbHlwaHMuZ2V0KGdseXBoSWQpO1xyXG4gICAgICAgIGlmIChnbHlwaCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2x5cGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1dvdy13b3ctd293LCBzb21ldGhpbmcgd2VudCB3cm9uZywgeW91IHNob3VsZCBub3QgcmVxdWVzdCBub25leGlzdGVudCBnbHlwaHMnKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Vua25vd25HbHlwaEluc3RhbmNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgQWxsIHN0b3JlZCBnbHlwaHMuXHJcbiAgICAgKi9cclxuICAgIGdldEFsbEdseXBocygpIHtcclxuICAgICAgICByZXR1cm4gWy4uLnRoaXMuX2dseXBocy52YWx1ZXMoKV07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgZ2x5cGggZGVzY3JpcHRpb24uXHJcbiAgICAgKi9cclxuICAgIGFkZEdseXBoKGdseXBoKSB7XHJcbiAgICAgICAgdGhpcy5fZ2x5cGhzLnNldChnbHlwaC5pZCwgZ2x5cGgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGdseXBoIGRlc2NyaXB0aW9ucyBmcm9tIHRoZSBpdGVyYWJsZS5cclxuICAgICAqL1xyXG4gICAgYWRkQWxsR2x5cGhzKGdseXBocykge1xyXG4gICAgICAgIGZvciAoY29uc3QgZ2x5cGggb2YgZ2x5cGhzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkR2x5cGgoZ2x5cGgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBJbWFnZVByb3ZpZGVyIH0gZnJvbSAnLi4vLi4vYmlsbGJvYXJkL2ltYWdlX3Byb3ZpZGVyJztcclxuaW1wb3J0IGdldERwciBmcm9tICcuLi8uLi91dGlsL2hkJztcclxuaW1wb3J0IHsgZ2V0SG9zdEFsaWFzQnlVaWQgfSBmcm9tICcuL3V0aWwvaG9zdHMnO1xyXG4vKipcclxuICogSW1hZ2UgcHJvdmlkZXIgdGhhdCBnZXRzIGltYWdlcyBmcm9tIHNwZWNpZmljIEFQSSBlbnRyeSBwb2ludC5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBBcGlJbWFnZVByb3ZpZGVyIGV4dGVuZHMgSW1hZ2VQcm92aWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihpbWFnZVVybFRlbXBsYXRlKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl9pbWFnZVVybFRlbXBsYXRlID0gaW1hZ2VVcmxUZW1wbGF0ZTtcclxuICAgIH1cclxuICAgIGdldEltYWdlVXJsKGlkKSB7XHJcbiAgICAgICAgLy8gQVBJIGNhbiByZXR1cm4gc2NhbGVkIGltYWdlcyB0aGF0IGFsbG93cyB1cyB0byByZXF1ZXN0IGltYWdlcyBhY2NvcmRpbmdcclxuICAgICAgICAvLyB0byB1c2VyJ3MgRFBJIGFuZCByZW5kZXIgdGhlbSBwcm9wZXJseSwgbm9uLWludGVnZXIgbnVtYmVycyBhcmUgYWNjZXB0ZWQuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ltYWdlVXJsVGVtcGxhdGVcclxuICAgICAgICAgICAgLnJlcGxhY2UoJ3t7aG9zdEFsaWFzfX0nLCBnZXRIb3N0QWxpYXNCeVVpZChpZCkpXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHtcXHtpZFxcfVxcfS9nLCBpZClcclxuICAgICAgICAgICAgLnJlcGxhY2UoJ3t7c2NhbGV9fScsIGdldERwcigpLnRvU3RyaW5nKCkpO1xyXG4gICAgfVxyXG59XHJcbiIsIi8qKlxyXG4gKiBBYnN0cmFjdCBpbWFnZSBjb250ZW50IHByb3ZpZGVyLCBjb25jcmV0ZSBpbXBsZW1lbnRhdGlvbnMgc2hvdWxkIHNwZWNpZnkgdGhlIGVudHJ5IHBvaW50IGluIGdldEltYWdlVXJsKCkuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgSW1hZ2VQcm92aWRlciB7XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgaW1hZ2UgYml0bWFwIHZpYSBhbiBIVE1MSW1hZ2VFbGVtZW50IGFuZCBhIGNhbnZhcy5cclxuICAgICAqL1xyXG4gICAgZ2V0SW1hZ2UoaWQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBpbWFnZUVsZW1lbnQgPSBuZXcgSW1hZ2UoKTtcclxuICAgICAgICAgICAgaW1hZ2VFbGVtZW50LmNyb3NzT3JpZ2luID0gJ2Fub255bW91cyc7XHJcbiAgICAgICAgICAgIGltYWdlRWxlbWVudC5vbmxvYWQgPSAoKSA9PiByZXNvbHZlKGltYWdlRWxlbWVudCk7XHJcbiAgICAgICAgICAgIGltYWdlRWxlbWVudC5vbmVycm9yID0gcmVqZWN0O1xyXG4gICAgICAgICAgICBpbWFnZUVsZW1lbnQuc3JjID0gdGhpcy5nZXRJbWFnZVVybChpZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuIiwiLyoqXHJcbiAqIEdpdmVzIHRoZSBkZXZpY2UgcGl4ZWwgcmF0aW9uIGlmIGl0J3MgZ3JlYXRlciB0aGFuIDEgYW5kIDEgb3RoZXJ3aXNlLiBUaGlzJ3NcclxuICogaGVyZSBwdXJlbHkgdG8gYmUgY29tcGF0aWJsZSB3aXRoIGpzYXBpIHdoaWNoIGRvZXMgdGhlIHNhbWUgdGhpbmcgZm9yIHJlYXNvbnNcclxuICogdW5rbm93cyAodGhhbmtzLCBrYXNoZXkpLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBDYXBwZWQgZGV2aWNlIHBpeGVsIHJhdGlvLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0RHByKCkge1xyXG4gICAgcmV0dXJuIGRldmljZVBpeGVsUmF0aW8gPiAxID8gZGV2aWNlUGl4ZWxSYXRpbyA6IDE7XHJcbn1cclxuIiwiY29uc3QgSE9TVF9BTElBU0VTX04gPSA0O1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0SG9zdEFsaWFzQnlVaWQodWlkKSB7XHJcbiAgICBsZXQgc3VtID0gMDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdWlkLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgc3VtICs9IHVpZC5jaGFyQ29kZUF0KGkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIChzdW0gJSBIT1NUX0FMSUFTRVNfTiArIDEpLnRvU3RyaW5nKCk7XHJcbn1cclxuIiwiaW1wb3J0IHsgQXR0cmlidXRlTWFwcGluZyB9IGZyb20gJy4uLy4uL3JlbmRlci9hdHRyaWJfbWFwcGluZyc7XHJcbmltcG9ydCBCdWZmZXJXcml0ZXIgZnJvbSAnLi4vLi4vdXRpbC9idWZmZXJfd3JpdGVyJztcclxuLyoqXHJcbiAqIEJhc2UgY2xhc3MgZm9yIDNEIG1vZGVscyBidWZmZXIgd3JpdGVycy4gSXQgaXMgbm90IHN1cHBvc2VkIHRvIHdyaXRlIGluZGljZXMsIGluc3RlYWQgaXQgd3JpdGVzIHZlcnRpY2VzIChwb3NzaWJseVxyXG4gKiBkdXBsaWNhdGVkKSBpbiBvcmRlciB0aGF0IGNvcnJlc3BvbmQgdG8gdHJpYW5ndWxhciBmYWNldHMgb2YgdGhlIG1lc2guXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb2RlbEJ1ZmZlcldyaXRlciBleHRlbmRzIEJ1ZmZlcldyaXRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcihNb2RlbEJ1ZmZlcldyaXRlci5BVFRSSUJVVEVfTUFQUElORy52ZXJ0ZXhCeXRlU2l6ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIHZlcnRleCB0byB0aGUgdmVydGV4IGJ1ZmZlci5cclxuICAgICAqL1xyXG4gICAgX3dyaXRlVmVydGV4KHYsIGNvbG9yUmdiYTgpIHtcclxuICAgICAgICBjb25zdCB2ZXJ0ZXhJZHggPSB0aGlzLmdldEN1cnJlbnRWZXJ0ZXhJZHgoKTtcclxuICAgICAgICB0aGlzLl93cml0ZVdvcmxkQ29vcmRpbmF0ZSh2KTtcclxuICAgICAgICB0aGlzLl93cml0ZUZsb2F0MzIodi56KTtcclxuICAgICAgICB0aGlzLl93cml0ZVdvcmQoY29sb3JSZ2JhOCk7XHJcbiAgICAgICAgcmV0dXJuIHZlcnRleElkeDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogRGVzY3JpcHRpb24gb2YgaG93IGF0dHJpYnV0ZXMgb2YgdmVydGljZXMgYXJlIHBhY2tlZCBpbnRvIGEgdmVydGV4IGJ1ZmZlci5cclxuICovXHJcbk1vZGVsQnVmZmVyV3JpdGVyLkFUVFJJQlVURV9NQVBQSU5HID0gbmV3IEF0dHJpYnV0ZU1hcHBpbmcoW1xyXG4gICAgW1xyXG4gICAgICAgIDAgLyogUE9TSVRJT05fSElHSCAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDIsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjMgLyogVU5TSUdORURfU0hPUlQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDEgLyogUE9TSVRJT05fTE9XICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMixcclxuICAgICAgICAgICAgdHlwZTogNTEyMyAvKiBVTlNJR05FRF9TSE9SVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgMyAvKiBIRUlHSFQgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAxLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTI2IC8qIEZMT0FUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgNyAvKiBDT0xPUiAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDQsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjEgLyogVU5TSUdORURfQllURSAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF1cclxuXSk7XHJcbiIsImltcG9ydCB7IEF0dHJpYnV0ZU1hcHBpbmcgfSBmcm9tICcuLi8uLi9yZW5kZXIvYXR0cmliX21hcHBpbmcnO1xyXG5pbXBvcnQgQnVmZmVyV3JpdGVyIGZyb20gJy4uLy4uL3V0aWwvYnVmZmVyX3dyaXRlcic7XHJcbmltcG9ydCB3cml0ZVRleHR1cmVkUG9seWxpbmVHZW9tZXRyeSBmcm9tICcuL3RleHR1cmVkX3BvbHlsaW5lX2dlb21ldHJ5JztcclxuaW1wb3J0IHsgaW50VG9aSW5kZXggfSBmcm9tICcuLi8uLi91dGlsL3pfaW5kZXgnO1xyXG4vKipcclxuICogV3JpdGVyIG9mIGdlb21ldHJ5IGRhdGEgb2YgcG9seWxpbmUgaHVsbHMuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXh0dXJlZFBvbHlsaW5lQnVmZmVyV3JpdGVyIGV4dGVuZHMgQnVmZmVyV3JpdGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKFRleHR1cmVkUG9seWxpbmVCdWZmZXJXcml0ZXIuQVRUUklCVVRFX01BUFBJTkcudmVydGV4Qnl0ZVNpemUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZXMgYSBodWxsIGZvciBhIHBvbHlsaW5lIGFuZCB3cml0ZXMgaXQgdG8gdGhlIHdyaXRlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcG9seWxpbmUgVGhlIHBvbHlsaW5lIHRvIGJlIHdyaXR0ZW4uXHJcbiAgICAgKiBAcGFyYW0gd2lkdGggVGhpY2tuZXNzIG9mIHRoZSBwb2x5bGluZS5cclxuICAgICAqIEBwYXJhbSB3b3JsZFRvUHhGYWN0b3IgUmF0aW8gb2Ygd29ybGQgY29vcmRpbmF0ZXMgdG8gcGl4ZWxzLlxyXG4gICAgICogQHBhcmFtIGltYWdlTG9jYXRpb24gSW1hZ2UgbG9jYXRpb24gaW4gYXRsYXMuXHJcbiAgICAgKiBAcGFyYW0gekluZGV4IFotaW5kZXggb2YgdGhlIHBvbHlsaW5lLlxyXG4gICAgICovXHJcbiAgICB3cml0ZVRleHR1cmVkUG9seWxpbmUocG9seWxpbmUsIHdpZHRoLCB3b3JsZFRvUHhGYWN0b3IsIGltYWdlTG9jYXRpb24sIHpJbmRleCkge1xyXG4gICAgICAgIHdyaXRlVGV4dHVyZWRQb2x5bGluZUdlb21ldHJ5KHRoaXMsIHBvbHlsaW5lLnZlcnRpY2VzLCB3b3JsZFRvUHhGYWN0b3IsIGltYWdlTG9jYXRpb24sIHdpZHRoLCBpbnRUb1pJbmRleCh6SW5kZXggKyAxKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kTWVzaCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYSB2ZXJ0ZXggdG8gdGhlIHZlcnRleCBidWZmZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBvc2l0aW9uIFBvc2l0aW9uIG9mIHRoZSB2ZXJ0ZXggaW4gd29ybGQgY29vcmRpbmF0ZXMuXHJcbiAgICAgKiBAcGFyYW0gZGlzcGxhY2VtZW50IERpc3BsYWNlbWVudCB2ZWN0b3IsIGluIG1vc3QgY2FzZXMgbXVzdCBiZSBub3JtYWxpemVkLCB0aGUgd2lkdGggaXMgY29uc2lkZXJlZCBpbiBzaGFkZXJzLlxyXG4gICAgICogQHBhcmFtIGhhbGZXaWR0aCBUaGlja25lc3Mgb2YgdGhlIHBvbHlsaW5lLlxyXG4gICAgICogQHBhcmFtIHBhdHRlcldpZHRoIFdpZHRoIG9mIHRoZSBpbWFnZSB0aGF0IGlzIHJlcGVhdGVkIGFsb25nIHRoZSBwb2x5bGluZS5cclxuICAgICAqIEBwYXJhbSBwYXR0ZXJuSGFsZkhlaWdodCBJbWFnZSBoYWxmIGhlaWdodCBtdWx0aXBsaWVkIGJ5IGBzaWduKHMpYCwgd2hlcmUgYHNgIGlzIGEgWy0xOyAxXSBkaXN0YW5jZSB0byB0aGVcclxuICAgICAqIGFuYWx5dGljYWwgcG9seWxpbmUgYWxvbmcgc2VnbWVudCdzIG5vcm1hbC5cclxuICAgICAqIEBwYXJhbSBsZW5ndGggTGVuZ3RoIG9mIHRoZSBwb2x5bGluZSBmb3IgY3VycmVudCB2ZXJ0ZXgsIG5lZWRlZCB0byBjb3JyZWN0bHkgY2FsY3VsYXRlIGltYWdlIHV2IHggY29vcmRpbmF0ZS5cclxuICAgICAqIEBwYXJhbSB1diBVViBjb29yZGluYXRlcyBvZiB0aGUgaW1hZ2UuXHJcbiAgICAgKiBAcGFyYW0gekluZGV4IFotaW5kZXggb2YgdGhlIHBvbHlsaW5lLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4gSW5kZXggb2YgdGhlIHdyaXR0ZW4gdmVydGV4LlxyXG4gICAgICovXHJcbiAgICB3cml0ZVZlcnRleChwb3NpdGlvbiwgZGlzcGxhY2VtZW50LCBoYWxmV2lkdGgsIHBhdHRlcm5XaWR0aCwgcGF0dGVybkhhbGZIZWlnaHQsIGxlbmd0aCwgdXYsIHpJbmRleCkge1xyXG4gICAgICAgIGNvbnN0IHZlcnRleElkeCA9IHRoaXMuZ2V0Q3VycmVudFZlcnRleElkeCgpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlV29ybGRDb29yZGluYXRlKHBvc2l0aW9uKTtcclxuICAgICAgICB0aGlzLl93cml0ZUZsb2F0MzIoZGlzcGxhY2VtZW50LngpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlRmxvYXQzMihkaXNwbGFjZW1lbnQueSk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVIYWxmV29yZHModXYueCwgdXYueSk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVGbG9hdDMyKHpJbmRleCk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVGbG9hdDMyKGhhbGZXaWR0aCk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVIYWxmV29yZHMocGF0dGVybldpZHRoLCBsZW5ndGgpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlRmxvYXQzMihwYXR0ZXJuSGFsZkhlaWdodCk7XHJcbiAgICAgICAgcmV0dXJuIHZlcnRleElkeDtcclxuICAgIH1cclxufVxyXG4vKiogRGVzY3JpcHRpb24gb2YgaG93IGEgd3JpdGVyIHN0b3JlcyB2ZXJ0ZXggZGF0YS4gKi9cclxuVGV4dHVyZWRQb2x5bGluZUJ1ZmZlcldyaXRlci5BVFRSSUJVVEVfTUFQUElORyA9IG5ldyBBdHRyaWJ1dGVNYXBwaW5nKFtcclxuICAgIFtcclxuICAgICAgICAwIC8qIFBPU0lUSU9OX0hJR0ggKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIzIC8qIFVOU0lHTkVEX1NIT1JUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICAxIC8qIFBPU0lUSU9OX0xPVyAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDIsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjMgLyogVU5TSUdORURfU0hPUlQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDYgLyogRElTUExBQ0VNRU5UICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMixcclxuICAgICAgICAgICAgdHlwZTogNTEyNiAvKiBGTE9BVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDQgLyogVVYgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIzIC8qIFVOU0lHTkVEX1NIT1JUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgOSAvKiBQUklPUklUWSAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDEsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjYgLyogRkxPQVQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICAxMSAvKiBBVVggKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAxLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTI2IC8qIEZMT0FUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgMTIgLyogQVVYMSAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDIsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjMgLyogVU5TSUdORURfU0hPUlQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICAxMyAvKiBBVVgyICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMSxcclxuICAgICAgICAgICAgdHlwZTogNTEyNiAvKiBGTE9BVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICBdXHJcbl0pO1xyXG4iLCJpbXBvcnQgKiBhcyB2ZWMyIGZyb20gJy4uLy4uL21hdGgvdmVjdG9yMic7XHJcbi8qKlxyXG4gKiBXcml0ZXMgcG9seWxpbmUgaW1hZ2UgZ2VvbWV0cnkgKHNldCBvZiB0cmlhbmdsZXMgdGhhdCBkcmF3IHVwIGEgc29saWQgdGhpY2sgcG9seWxpbmUpIGludG8gYSBidWZmZXIgd3JpdGVyLlxyXG4gKlxyXG4gKiBAcGFyYW0gd3JpdGVyIE91dHB1dCBidWZmZXIgd3JpdGVyLlxyXG4gKiBAcGFyYW0gcG9seWxpbmUgUG9seWxpbmUgdG8gYmUgd3JpdHRlbi5cclxuICogQHBhcmFtIHdvcmxkVG9QeEZhY3RvciBSYXRpbyBvZiB3b3JsZCBjb29yZGluYXRlcyB0byBwaXhlbHMuXHJcbiAqIEBwYXJhbSBpbWFnZUxvY2F0aW9uIEltYWdlIGxvY2F0aW9uIGluIGF0bGFzLlxyXG4gKiBAcGFyYW0gd2lkdGggVGhpY2tuZXNzIG9mIHRoZSBwb2x5bGluZS5cclxuICogQHBhcmFtIHogWi1pbmRleCBvZiB0aGUgcG9seWxpbmUuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB3cml0ZVRleHR1cmVkUG9seWxpbmVHZW9tZXRyeSh3cml0ZXIsIHBvbHlsaW5lLCB3b3JsZFRvUHhGYWN0b3IsIGltYWdlTG9jYXRpb24sIHdpZHRoLCB6KSB7XHJcbiAgICBjb25zdCBoV2lkdGggPSB3aWR0aCAvIDI7XHJcbiAgICBjb25zdCBwYXR0ZXJuV2lkdGggPSBpbWFnZUxvY2F0aW9uLm1heFggLSBpbWFnZUxvY2F0aW9uLm1pblg7XHJcbiAgICBjb25zdCBwYXR0ZXJuSGFsZkhlaWdodCA9IChpbWFnZUxvY2F0aW9uLm1heFkgLSBpbWFnZUxvY2F0aW9uLm1pblkpIC8gMjtcclxuICAgIGNvbnN0IHNlZ21lbnQgPSB2ZWMyLmNyZWF0ZSgwLCAwKTtcclxuICAgIGNvbnN0IGRpciA9IHZlYzIuY3JlYXRlKDAsIDApO1xyXG4gICAgY29uc3QgcHJldkRpciA9IHZlYzIuY3JlYXRlKDAsIDApO1xyXG4gICAgY29uc3Qgbm9ybSA9IHZlYzIuY3JlYXRlKDAsIDApO1xyXG4gICAgY29uc3Qgbm9ybUludiA9IHZlYzIuY3JlYXRlKDAsIDApO1xyXG4gICAgY29uc3QgdXYgPSB2ZWMyLmNyZWF0ZShpbWFnZUxvY2F0aW9uLm1pblgsIDApO1xyXG4gICAgbGV0IHByZXZCb3R0b21SaWdodCA9IC0xO1xyXG4gICAgbGV0IHByZXZUb3BSaWdodCA9IC0xO1xyXG4gICAgbGV0IGxlbmd0aCA9IDA7XHJcbiAgICBsZXQgcHJldkxlbmd0aCA9IDA7XHJcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHBvbHlsaW5lLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmVjMi5zdWIocG9seWxpbmVbaV0sIHBvbHlsaW5lW2kgLSAxXSwgc2VnbWVudCk7XHJcbiAgICAgICAgdmVjMi5ub3JtYWxpemUoc2VnbWVudCwgZGlyKTtcclxuICAgICAgICB2ZWMyLnJvdGF0ZTkwKGRpciwgbm9ybSk7XHJcbiAgICAgICAgdmVjMi5tdWxuKG5vcm0sIC0xLCBub3JtSW52KTtcclxuICAgICAgICAvLyBzZWdtZW50IGlzIHdyaXR0ZW4gYXMgYSByZWN0YW5nbGUgKHR3byB0cmlhbmdsZXMpXHJcbiAgICAgICAgdXYueSA9IGltYWdlTG9jYXRpb24ubWluWTtcclxuICAgICAgICBjb25zdCB0b3BMZWZ0ID0gd3JpdGVyLndyaXRlVmVydGV4KHBvbHlsaW5lW2kgLSAxXSwgbm9ybSwgaFdpZHRoLCBwYXR0ZXJuV2lkdGgsIHBhdHRlcm5IYWxmSGVpZ2h0LCBsZW5ndGgsIHV2LCB6KTtcclxuICAgICAgICB1di55ID0gaW1hZ2VMb2NhdGlvbi5tYXhZO1xyXG4gICAgICAgIGNvbnN0IGJvdHRvbUxlZnQgPSB3cml0ZXIud3JpdGVWZXJ0ZXgocG9seWxpbmVbaSAtIDFdLCBub3JtSW52LCBoV2lkdGgsIHBhdHRlcm5XaWR0aCwgLXBhdHRlcm5IYWxmSGVpZ2h0LCBsZW5ndGgsIHV2LCB6KTtcclxuICAgICAgICAvLyB1cGRhdGUgbGVuZ3RoIG9mIHRoZSBwb2x5bGluZSBpbiBwaXhlbHNcclxuICAgICAgICBsZW5ndGggKz0gdmVjMi5sZW5ndGgoc2VnbWVudCkgLyB3b3JsZFRvUHhGYWN0b3I7XHJcbiAgICAgICAgdXYueSA9IGltYWdlTG9jYXRpb24ubWluWTtcclxuICAgICAgICBjb25zdCB0b3BSaWdodCA9IHdyaXRlci53cml0ZVZlcnRleChwb2x5bGluZVtpXSwgbm9ybSwgaFdpZHRoLCBwYXR0ZXJuV2lkdGgsIHBhdHRlcm5IYWxmSGVpZ2h0LCBsZW5ndGgsIHV2LCB6KTtcclxuICAgICAgICB1di55ID0gaW1hZ2VMb2NhdGlvbi5tYXhZO1xyXG4gICAgICAgIGNvbnN0IGJvdHRvbVJpZ2h0ID0gd3JpdGVyLndyaXRlVmVydGV4KHBvbHlsaW5lW2ldLCBub3JtSW52LCBoV2lkdGgsIHBhdHRlcm5XaWR0aCwgLXBhdHRlcm5IYWxmSGVpZ2h0LCBsZW5ndGgsIHV2LCB6KTtcclxuICAgICAgICAvLyB3cml0ZSBsaW5lIGpvaW4gdGhhdCBmaWxscyBhbiBlbXB0eSBzcGFjZSBvbiBjb3JuZXJzXHJcbiAgICAgICAgaWYgKDEgPCBpICYmIGkgPCBwb2x5bGluZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdXYueSA9IChpbWFnZUxvY2F0aW9uLm1heFkgKyBpbWFnZUxvY2F0aW9uLm1pblkpIC8gMjtcclxuICAgICAgICAgICAgY29uc3Qgam9pblBvaW50SW5kZXggPSB3cml0ZXIud3JpdGVWZXJ0ZXgocG9seWxpbmVbaSAtIDFdLCB2ZWMyLlpFUk8sIGhXaWR0aCwgcGF0dGVybldpZHRoLCAwLCBwcmV2TGVuZ3RoLCB1diwgeik7XHJcbiAgICAgICAgICAgIC8vIGZpbmQgb3V0IHdoZXJlIHRoZSBmcmFjdHVyZSBvZiBzZWdtZW50cyBpcyBsb2NhdGVkIHRvIGNyZWF0ZSBjb3JyZWN0IGpvaW4gd2l0aCBtaW5pbXVtIG92ZXJkcmF3XHJcbiAgICAgICAgICAgIGNvbnN0IHR1cm5MZWZ0ID0gdmVjMi5jcm9zc1oocHJldkRpciwgZGlyKSA+IDA7XHJcbiAgICAgICAgICAgIGlmICh0dXJuTGVmdCkge1xyXG4gICAgICAgICAgICAgICAgd3JpdGVyLndyaXRlSW5kaWNlcyhbXHJcbiAgICAgICAgICAgICAgICAgICAgam9pblBvaW50SW5kZXgsIGJvdHRvbUxlZnQsIHByZXZCb3R0b21SaWdodFxyXG4gICAgICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB3cml0ZXIud3JpdGVJbmRpY2VzKFtcclxuICAgICAgICAgICAgICAgICAgICBqb2luUG9pbnRJbmRleCwgcHJldlRvcFJpZ2h0LCB0b3BMZWZ0XHJcbiAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB3cml0ZXIud3JpdGVJbmRpY2VzKFtcclxuICAgICAgICAgICAgdG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsXHJcbiAgICAgICAgICAgIHRvcFJpZ2h0LCBib3R0b21SaWdodCwgYm90dG9tTGVmdFxyXG4gICAgICAgIF0pO1xyXG4gICAgICAgIHZlYzIuY29weShkaXIsIHByZXZEaXIpO1xyXG4gICAgICAgIHByZXZCb3R0b21SaWdodCA9IGJvdHRvbVJpZ2h0O1xyXG4gICAgICAgIHByZXZUb3BSaWdodCA9IHRvcFJpZ2h0O1xyXG4gICAgICAgIHByZXZMZW5ndGggPSBsZW5ndGg7XHJcbiAgICB9XHJcbn1cclxuIiwiY29uc3QgTUlOX1pJTkRFWCA9IC0xICsgTWF0aC5wb3coMiwgMSAtIDI0KTsgLy8gZXBzaWxvbiBpcyBhZGRlZCAoZm9yIG5vcm1hbGl6ZWQgMjQtYml0IHZhbHVlKSB0byBmcmVlIHVwIHJlc2VydmVkIHZhbHVlXHJcbmV4cG9ydCBmdW5jdGlvbiBpbnRUb1pJbmRleCh4KSB7XHJcbiAgICByZXR1cm4gTWF0aC5tYXgoTUlOX1pJTkRFWCwgeCAvIDB4N2ZmZmZmKTtcclxufVxyXG4iLCIvKipcclxuICogTWFuYWdlcyBhbGxvY2F0aW9uIG9mIHJlcXVlc3RlZCBpbWFnZXMuIFRoZSBzYW1lIGltYWdlcyBjYW4gYmUgcmVxdWVzdGVkIG11bHRpcGxlIHRpbWVzIGZyb20gZGlmZmVyZW50IHBsYWNlcyxcclxuICogdGhpcyBjbGFzcyB0YWtlcyBvdmVyIGR1cGxpY2F0aW9uIG9mIEhUVFAgcmVxdWVzdHMvYXRsYXMgYWxsb2NhdGlvbnMgcHJvdmlkaW5nIHNpbXBsZSBhc3luYyBpbnRlcmZhY2UgZm9yXHJcbiAqIGdldHRpbmcgYWxsb2NhdGVkIGltYWdlcy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBJbWFnZU1hbmFnZXIge1xyXG4gICAgY29uc3RydWN0b3IoYXRsYXMsIHByb3ZpZGVyKSB7XHJcbiAgICAgICAgdGhpcy5fYXRsYXMgPSBhdGxhcztcclxuICAgICAgICB0aGlzLl9wcm92aWRlciA9IHByb3ZpZGVyO1xyXG4gICAgICAgIHRoaXMuX3JlcXVlc3RzID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGltYWdlIGlmIGl0IGlzIGFscmVhZHkgYWxsb2NhdGVkLiBQYXkgYXR0ZW50aW9uIHRoYXQgcmVzdWx0ZWQgYWxsb2NhdGVkIGltYWdlIGlzIFwicmV0YWluZWRcIixcclxuICAgICAqIHNvIGl0IG11c3QgYmUgcmVsZWFzZWQgb25jZSBpdCBpcyBwYXNzZWQgdG8gYSByZXNwb25zaWJsZSBjbGllbnQuXHJcbiAgICAgKi9cclxuICAgIGdldEltYWdlKGlkKSB7XHJcbiAgICAgICAgY29uc3QgaW1hZ2UgPSB0aGlzLl9hdGxhcy5nZXRJbWFnZShpZCwgdHJ1ZSk7XHJcbiAgICAgICAgaWYgKGltYWdlKSB7XHJcbiAgICAgICAgICAgIGltYWdlLnJldGFpbigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaW1hZ2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlcXVlc3QgaW1hZ2UgZnJvbSBpbWFnZSBwcm92aWRlciwgaWYgaXQgaXMgYWxyZWFkeSBhbGxvY2F0ZWQgbm8gcmVxdWVzdCBpcyBtYWRlLCBidXQgaXQgaXMgcmV0dXJuZWRcclxuICAgICAqIHdyYXBwZWQgaW50byBhIHJlc29sdmVkIHByb21pc2UuIFBheSBhdHRlbnRpb24gdGhhdCByZXN1bHRlZCBhbGxvY2F0ZWQgaW1hZ2UgaXMgXCJyZXRhaW5lZFwiLCBzbyBpdCBtdXN0IGJlXHJcbiAgICAgKiByZWxlYXNlZCBvbmNlIGl0IGlzIHBhc3NlZCB0byBhIHJlc3BvbnNpYmxlIGNsaWVudC5cclxuICAgICAqL1xyXG4gICAgcmVxdWVzdEltYWdlKGlkKSB7XHJcbiAgICAgICAgY29uc3QgYWxsb2NhdGVkSW1hZ2UgPSB0aGlzLl9hdGxhcy5nZXRJbWFnZShpZCwgdHJ1ZSk7XHJcbiAgICAgICAgaWYgKGFsbG9jYXRlZEltYWdlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoYWxsb2NhdGVkSW1hZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuX3JlcXVlc3RzLmdldChpZCk7XHJcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0KSB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnRoZW4oKGFsbG9jYXRlZEltYWdlKSA9PiBhbGxvY2F0ZWRJbWFnZSAmJiBhbGxvY2F0ZWRJbWFnZS5yZXRhaW4oKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxdWVzdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLl9wcm92aWRlclxyXG4gICAgICAgICAgICAgICAgICAgIC5nZXRJbWFnZShpZClcclxuICAgICAgICAgICAgICAgICAgICAudGhlbigoaW1hZ2UpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXF1ZXN0cy5kZWxldGUoaWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gaW1hZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWxsb2NhdGVkSW1hZ2UgPSB0aGlzLl9hdGxhcy5hbGxvY2F0ZUltYWdlKHsgaWQsIHdpZHRoLCBoZWlnaHQgfSwgaW1hZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghYWxsb2NhdGVkSW1hZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZG5cXCcgYWxsb2NhdGVkIGltYWdlJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWxsb2NhdGVkSW1hZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RzLmRlbGV0ZShpZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSByZXF1ZXN0IGZhaWxlZCcpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXF1ZXN0cy5zZXQoaWQsIHJlcXVlc3QpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IEJ1ZmZlclJld3JpdGVyIGZyb20gJy4uLy4uL3V0aWwvYnVmZmVyX3Jld3JpdGVyJztcclxuaW1wb3J0IHsgVEVYVFVSRURfUE9MWUdPTl9BVFRSSUJVVEVfTUFQUElORyB9IGZyb20gJy4vdGV4dHVyZWRfcG9seWdvbl9hdHRyaWJ1dGVfbWFwcGluZyc7XHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRleHR1cmVkUG9seWdvbkJ1ZmZlclJld3JpdGVyIGV4dGVuZHMgQnVmZmVyUmV3cml0ZXIge1xyXG4gICAgY29uc3RydWN0b3IoYnVmZmVycykge1xyXG4gICAgICAgIHN1cGVyKFRFWFRVUkVEX1BPTFlHT05fQVRUUklCVVRFX01BUFBJTkcsIGJ1ZmZlcnMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gbG9jYXRpb24gTG9jYXRpb24gb2YgdGhlIHBvbHlnb24gaW4gbWVtb3J5LlxyXG4gICAgICogQHBhcmFtIGltYWdlTG9jYXRpb24gTG9jYXRpb24gb2YgdGhlIHBhdHRlcm4gaW4gYXRsYXMuXHJcbiAgICAgKiBAcGFyYW0gaW1hZ2VTY2FsZSBIb3cgd29ybGQgY29vcmRpbmF0ZXMgcmVsYXRlIHRvIHRoZSBpbWFnZSBzaXplLlxyXG4gICAgICovXHJcbiAgICByZXdyaXRlVVYobG9jYXRpb24sIGltYWdlTG9jYXRpb24sIGltYWdlU2NhbGUpIHtcclxuICAgICAgICBjb25zdCB1dk9mZnNldCA9IHRoaXMuX2dldEF0dHJpYk9mZnNldCg0IC8qIFVWICovKTtcclxuICAgICAgICBjb25zdCBzY2FsZU9mZnNldCA9IHRoaXMuX2dldEF0dHJpYk9mZnNldCgxMSAvKiBBVVggKi8pO1xyXG4gICAgICAgIHRoaXMuX2ZvckVhY2hWZXJ0ZXgobG9jYXRpb24sICh3cml0ZXIpID0+IHtcclxuICAgICAgICAgICAgd3JpdGVyLndyaXRlSGFsZldvcmRzKHV2T2Zmc2V0LCBpbWFnZUxvY2F0aW9uLm1pblgsIGltYWdlTG9jYXRpb24ubWluWSk7XHJcbiAgICAgICAgICAgIHdyaXRlci53cml0ZUhhbGZXb3Jkcyh1dk9mZnNldCArIDEsIGltYWdlTG9jYXRpb24ubWF4WCAtIGltYWdlTG9jYXRpb24ubWluWCwgaW1hZ2VMb2NhdGlvbi5tYXhZIC0gaW1hZ2VMb2NhdGlvbi5taW5ZKTtcclxuICAgICAgICAgICAgd3JpdGVyLndyaXRlRmxvYXQzMihzY2FsZU9mZnNldCwgaW1hZ2VTY2FsZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgV09SRF9CWVRFX1NJWkUgfSBmcm9tICcuL2J1ZmZlcl93cml0ZXInO1xyXG4vKipcclxuICogQ2xhc3MgdGhhdCBpcyBleHBvc2VkIGFzIGFuIGludGVyZmFjZSBmb3Igd3JpdGluZyB0byBhIHNwZWNpZmljIHZlcnRleCBhdHRyaWJ1dGUuXHJcbiAqL1xyXG5jbGFzcyBWZXJ0ZXhXcml0ZXIge1xyXG4gICAgY29uc3RydWN0b3IodmVydGV4QnVmZmVyKSB7XHJcbiAgICAgICAgdGhpcy5fdmVydGV4QnVmZmVyID0gbmV3IFVpbnQzMkFycmF5KHZlcnRleEJ1ZmZlci5idWZmZXIsIDAsIHZlcnRleEJ1ZmZlci5sZW5ndGgpO1xyXG4gICAgICAgIHRoaXMuX3ZlcnRleEJ1ZmZlckZsb2F0MzJWaWV3ID0gbmV3IEZsb2F0MzJBcnJheSh2ZXJ0ZXhCdWZmZXIuYnVmZmVyLCAwLCB2ZXJ0ZXhCdWZmZXIubGVuZ3RoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGZsb2F0IGF0dHJpYnV0ZSBpbnRvIHNwZWNpZmljIHBvc2l0aW9uIGluIGJ1ZmZlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYXR0cmliT2Zmc2V0IE9mZnNldCBvZiBhbiBhdHRyaWJ1dGUgaW4gd29yZHMgKDQgYnl0ZXMpLCBnZXQgaXQgZnJvbSBCdWZmZXJSZXdyaXRlciNfZ2V0QXR0cmliT2Zmc2V0KCkuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgVmFsdWUgdG8gYmUgd3JpdHRlbi5cclxuICAgICAqL1xyXG4gICAgd3JpdGVGbG9hdDMyKGF0dHJpYk9mZnNldCwgdmFsdWUpIHtcclxuICAgICAgICB0aGlzLl92ZXJ0ZXhCdWZmZXJGbG9hdDMyVmlld1t0aGlzLnZlcnRleE9mZnNldCArIGF0dHJpYk9mZnNldF0gPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGEgd29yZCBhdHRyaWJ1dGUgaW50byBzcGVjaWZpYyBwb3NpdGlvbiBpbiBidWZmZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGF0dHJpYk9mZnNldCBPZmZzZXQgb2YgYW4gYXR0cmlidXRlIGluIHdvcmRzICg0IGJ5dGVzKSwgZ2V0IGl0IGZyb20gQnVmZmVyUmV3cml0ZXIjX2dldEF0dHJpYk9mZnNldCgpLlxyXG4gICAgICogQHBhcmFtIHZhbHVlIFZhbHVlIHRvIGJlIHdyaXR0ZW4uXHJcbiAgICAgKi9cclxuICAgIHdyaXRlV29yZChhdHRyaWJPZmZzZXQsIHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fdmVydGV4QnVmZmVyW3RoaXMudmVydGV4T2Zmc2V0ICsgYXR0cmliT2Zmc2V0XSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgdHdvIGhhbGYgd29yZCBhdHRyaWJ1dGUgdmFsdWVzIGludG8gc3BlY2lmaWMgcG9zaXRpb24gaW4gYnVmZmVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhdHRyaWJPZmZzZXQgT2Zmc2V0IG9mIGFuIGF0dHJpYnV0ZSBpbiB3b3JkcyAoNCBieXRlcyksIGdldCBpdCBmcm9tIEJ1ZmZlclJld3JpdGVyI19nZXRBdHRyaWJPZmZzZXQoKS5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSBWYWx1ZSB0byBiZSB3cml0dGVuLlxyXG4gICAgICovXHJcbiAgICB3cml0ZUhhbGZXb3JkcyhhdHRyaWJPZmZzZXQsIHYxLCB2Mikge1xyXG4gICAgICAgIHRoaXMud3JpdGVXb3JkKGF0dHJpYk9mZnNldCwgdjIgPDwgMTYgfCB2MSAmIDB4ZmZmZik7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFByb3ZpZGVzIHNvbWUgdXRpbHMgZm9yIHJld3JpdGluZyB2ZXJ0ZXggYXR0cmlidXRlIHZhbHVlcywgc2VlIFZlcnRleFdyaXRlciBhbmQgdGVzdHMgZm9yIHNvbWUgdGlwcyBvZiBob3cgdG8gZG8gaXQuXHJcbiAqIFRPRE86IGNvbnNpZGVyIHN1cHBvcnRpbmcgb2Ygc2VwYXJhdGUgYnVmZmVycyBmb3IgZGlmZmVyZW50IGF0dHJpYnV0ZXMsIHRoYXQgd2lsbCBtYWtlIHRoaXMgY2xhc3MgbGVzcyB1c2VmdWxcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJ1ZmZlclJld3JpdGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGF0dHJpYk1hcHBpbmcsIGJ1ZmZlcnMpIHtcclxuICAgICAgICB0aGlzLl9hdHRyaWJNYXBwaW5nID0gYXR0cmliTWFwcGluZztcclxuICAgICAgICB0aGlzLl9idWZmZXJzID0gYnVmZmVycztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogV2Fsa3Mgb3ZlciBhbGwgdmVydGljZXMgZXhwb3NpbmcgVmVydGV4V3JpdGVyIGZvciBlYWNoIG9uZSBieSBjYWxsaW5nIHRoZSBoYW5kbGVyIGFyZ3VtZW50LlxyXG4gICAgICovXHJcbiAgICBfZm9yRWFjaFZlcnRleChsb2NhdGlvbiwgaGFuZGxlcikge1xyXG4gICAgICAgIGNvbnN0IHZlcnRleFdyaXRlciA9IG5ldyBWZXJ0ZXhXcml0ZXIodGhpcy5fYnVmZmVyc1tsb2NhdGlvbi5idWZmZXJJbmRleF0udmVydGV4QnVmZmVyKTtcclxuICAgICAgICBjb25zdCB2ZXJ0ZXhCeXRlU2l6ZSA9IHRoaXMuX2F0dHJpYk1hcHBpbmcudmVydGV4Qnl0ZVNpemU7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NhdGlvbi52ZXJ0ZXhCeXRlTGVuZ3RoOyBpICs9IHZlcnRleEJ5dGVTaXplKSB7XHJcbiAgICAgICAgICAgIHZlcnRleFdyaXRlci52ZXJ0ZXhPZmZzZXQgPSAobG9jYXRpb24udmVydGV4Qnl0ZU9mZnNldCArIGkpIC8gV09SRF9CWVRFX1NJWkU7XHJcbiAgICAgICAgICAgIGhhbmRsZXIodmVydGV4V3JpdGVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIE9mZnNldCBpbiB3b3JkcyAoNCBieXRlcykgb2Ygc3BlY2lmaWMgYXR0cmlidXRlIGluIGEgdmVydGV4IChmb3JtYXQgaXMgZGVmaW5lZCBieSBBdHRyaWJ1dGVNYXBwaW5nKS5cclxuICAgICAqL1xyXG4gICAgX2dldEF0dHJpYk9mZnNldChhdHRyaWIpIHtcclxuICAgICAgICBjb25zdCBhdHRyaWJQb2ludGVyID0gdGhpcy5fYXR0cmliTWFwcGluZy5nZXQoYXR0cmliKTtcclxuICAgICAgICByZXR1cm4gYXR0cmliUG9pbnRlciA/IGF0dHJpYlBvaW50ZXIub2Zmc2V0IC8gV09SRF9CWVRFX1NJWkUgOiAtMTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBBdHRyaWJ1dGVNYXBwaW5nIH0gZnJvbSAnLi4vLi4vcmVuZGVyL2F0dHJpYl9tYXBwaW5nJztcclxuLyoqXHJcbiAqIERlc2NyaXB0aW9uIG9mIGhvdyBhdHRyaWJ1dGVzIG9mIHZlcnRpY2VzIGFyZSBwYWNrZWQgaW50byBhIHZlcnRleCBidWZmZXIuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgVEVYVFVSRURfUE9MWUdPTl9BVFRSSUJVVEVfTUFQUElORyA9IG5ldyBBdHRyaWJ1dGVNYXBwaW5nKFtcclxuICAgIFtcclxuICAgICAgICAwIC8qIFBPU0lUSU9OX0hJR0ggKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIzIC8qIFVOU0lHTkVEX1NIT1JUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICAxIC8qIFBPU0lUSU9OX0xPVyAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDIsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjMgLyogVU5TSUdORURfU0hPUlQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDQgLyogVVYgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiA0LFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIzIC8qIFVOU0lHTkVEX1NIT1JUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgMTEgLyogQVVYICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMSxcclxuICAgICAgICAgICAgdHlwZTogNTEyNiAvKiBGTE9BVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDEwIC8qIFpfSU5ERVggKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAxLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTI2IC8qIEZMT0FUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgIF1cclxuXSk7XHJcbiIsImltcG9ydCB7IEF0dHJpYnV0ZU1hcHBpbmcgfSBmcm9tICcuLi8uLi9yZW5kZXIvYXR0cmliX21hcHBpbmcnO1xyXG4vKipcclxuICogRGVzY3JpcHRpb24gb2YgaG93IGF0dHJpYnV0ZXMgb2YgdmVydGljZXMgYXJlIHBhY2tlZCBpbnRvIGEgdmVydGV4IGJ1ZmZlci5cclxuICovXHJcbmV4cG9ydCBjb25zdCBQT0xZR09OX0FUVFJJQlVURV9NQVBQSU5HID0gbmV3IEF0dHJpYnV0ZU1hcHBpbmcoW1xyXG4gICAgW1xyXG4gICAgICAgIDAgLyogUE9TSVRJT05fSElHSCAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDIsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjMgLyogVU5TSUdORURfU0hPUlQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDEgLyogUE9TSVRJT05fTE9XICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMixcclxuICAgICAgICAgICAgdHlwZTogNTEyMyAvKiBVTlNJR05FRF9TSE9SVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgNyAvKiBDT0xPUiAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDQsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjEgLyogVU5TSUdORURfQllURSAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgMTAgLyogWl9JTkRFWCAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDEsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjYgLyogRkxPQVQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgXVxyXG5dKTtcclxuIiwiaW1wb3J0IHsgQXR0cmlidXRlTWFwcGluZyB9IGZyb20gJy4uLy4uL3JlbmRlci9hdHRyaWJfbWFwcGluZyc7XHJcbi8qKiBEZXNjcmlwdGlvbiBvZiBob3cgYSB3cml0ZXIgc3RvcmVzIHZlcnRleCBkYXRhLiAqL1xyXG5leHBvcnQgY29uc3QgQklMTEJPQVJEX1JFQ1RBTkdMRV9BVFRSSUJVVEVfTUFQUElORyA9IG5ldyBBdHRyaWJ1dGVNYXBwaW5nKFtcclxuICAgIFtcclxuICAgICAgICAyIC8qIElEICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogNCxcclxuICAgICAgICAgICAgdHlwZTogNTEyMSAvKiBVTlNJR05FRF9CWVRFICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICAwIC8qIFBPU0lUSU9OX0hJR0ggKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIzIC8qIFVOU0lHTkVEX1NIT1JUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICAxIC8qIFBPU0lUSU9OX0xPVyAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDIsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjMgLyogVU5TSUdORURfU0hPUlQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDYgLyogRElTUExBQ0VNRU5UICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMixcclxuICAgICAgICAgICAgdHlwZTogNTEyNiAvKiBGTE9BVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDQgLyogVVYgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIyIC8qIFNIT1JUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICA3IC8qIENPTE9SICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogNCxcclxuICAgICAgICAgICAgdHlwZTogNTEyMSAvKiBVTlNJR05FRF9CWVRFICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICAxMSAvKiBBVVggKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIzIC8qIFVOU0lHTkVEX1NIT1JUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXVxyXG5dKTtcclxuIiwiaW1wb3J0IHsgQXR0cmlidXRlTWFwcGluZyB9IGZyb20gJy4uLy4uL3JlbmRlci9hdHRyaWJfbWFwcGluZyc7XHJcbi8qKiBEZXNjcmlwdGlvbiBvZiBob3cgYSB3cml0ZXIgc3RvcmVzIHZlcnRleCBkYXRhLiAqL1xyXG5leHBvcnQgY29uc3QgUE9JTlRfTEFCRUxfQVRUUklCVVRFX01BUFBJTkcgPSBuZXcgQXR0cmlidXRlTWFwcGluZyhbXHJcbiAgICBbXHJcbiAgICAgICAgMiAvKiBJRCAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDQsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjEgLyogVU5TSUdORURfQllURSAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgMCAvKiBQT1NJVElPTl9ISUdIICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMixcclxuICAgICAgICAgICAgdHlwZTogNTEyMyAvKiBVTlNJR05FRF9TSE9SVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgMSAvKiBQT1NJVElPTl9MT1cgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIzIC8qIFVOU0lHTkVEX1NIT1JUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICA2IC8qIERJU1BMQUNFTUVOVCAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDIsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjYgLyogRkxPQVQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICA0IC8qIFVWICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMixcclxuICAgICAgICAgICAgdHlwZTogNTEyMyAvKiBVTlNJR05FRF9TSE9SVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDcgLyogQ09MT1IgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiA0LFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIxIC8qIFVOU0lHTkVEX0JZVEUgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDggLyogT1VUTElORV9DT0xPUiAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDQsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjEgLyogVU5TSUdORURfQllURSAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgOSAvKiBQUklPUklUWSAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDEsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjYgLyogRkxPQVQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICAxMSAvKiBBVVggKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAxLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTI2IC8qIEZMT0FUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgIF1cclxuXSk7XHJcbiIsImltcG9ydCB7IEF0dHJpYnV0ZU1hcHBpbmcgfSBmcm9tICcuLi8uLi9yZW5kZXIvYXR0cmliX21hcHBpbmcnO1xyXG4vKiogRGVzY3JpcHRpb24gb2YgaG93IGEgd3JpdGVyIHN0b3JlcyB2ZXJ0ZXggZGF0YS4gKi9cclxuZXhwb3J0IGNvbnN0IENVUlZFRF9MQUJFTF9BVFRSSUJVVEVfTUFQUElORyA9IG5ldyBBdHRyaWJ1dGVNYXBwaW5nKFtcclxuICAgIFtcclxuICAgICAgICAyIC8qIElEICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogNCxcclxuICAgICAgICAgICAgdHlwZTogNTEyMSAvKiBVTlNJR05FRF9CWVRFICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICAwIC8qIFBPU0lUSU9OX0hJR0ggKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIzIC8qIFVOU0lHTkVEX1NIT1JUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICAxIC8qIFBPU0lUSU9OX0xPVyAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDIsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjMgLyogVU5TSUdORURfU0hPUlQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDYgLyogRElTUExBQ0VNRU5UICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMyxcclxuICAgICAgICAgICAgdHlwZTogNTEyNiAvKiBGTE9BVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDQgLyogVVYgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIzIC8qIFVOU0lHTkVEX1NIT1JUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgNyAvKiBDT0xPUiAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDQsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjEgLyogVU5TSUdORURfQllURSAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgOCAvKiBPVVRMSU5FX0NPTE9SICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogNCxcclxuICAgICAgICAgICAgdHlwZTogNTEyMSAvKiBVTlNJR05FRF9CWVRFICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICA5IC8qIFBSSU9SSVRZICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMSxcclxuICAgICAgICAgICAgdHlwZTogNTEyNiAvKiBGTE9BVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDEyIC8qIEFVWDEgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiA0LFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIxIC8qIFVOU0lHTkVEX0JZVEUgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDEzIC8qIEFVWDIgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiA0LFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIzIC8qIFVOU0lHTkVEX1NIT1JUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICAxNCAvKiBBVVgzICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogNCxcclxuICAgICAgICAgICAgdHlwZTogNTEyMSAvKiBVTlNJR05FRF9CWVRFICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICAxNSAvKiBBVVg0ICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogNCxcclxuICAgICAgICAgICAgdHlwZTogNTEyMyAvKiBVTlNJR05FRF9TSE9SVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgMTEgLyogQVVYICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMixcclxuICAgICAgICAgICAgdHlwZTogNTEyNiAvKiBGTE9BVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICBdXHJcbl0pO1xyXG4iLCJpbXBvcnQgeyBBdHRyaWJ1dGVNYXBwaW5nIH0gZnJvbSAnLi4vLi4vcmVuZGVyL2F0dHJpYl9tYXBwaW5nJztcclxuLyoqXHJcbiAqIERlc2NyaXB0aW9uIG9mIGhvdyBhdHRyaWJ1dGVzIG9mIHZlcnRpY2VzIGFyZSBwYWNrZWQgaW50byBhIHZlcnRleCBidWZmZXIuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgUE9MWUxJTkVfQVRUUklCVVRFX01BUFBJTkcgPSBuZXcgQXR0cmlidXRlTWFwcGluZyhbXHJcbiAgICAvKiogVmVydGV4IHdvcmxkIHBvc2l0aW9uLiAqL1xyXG4gICAgW1xyXG4gICAgICAgIDAgLyogUE9TSVRJT04gKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiA0LFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIzIC8qIFVOU0lHTkVEX1NIT1JUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIC8qKiBOb3JtYWwgdG8gcG9seWxpbmUgc2VnbWVudCB0aGUgdmVydGV4IGJlbG9uZyB0by4gKi9cclxuICAgIFtcclxuICAgICAgICA1IC8qIE5PUk1BTCAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDIsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjMgLyogVU5TSUdORURfU0hPUlQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgLyoqXHJcbiAgICAgKiBcIlVWXCIgdmVydGV4IHRoYXQgdXNlZCB0byBjb21wdXRlIHN0cm9rZSBhbmQgZGFzaGVzLiBJdCdzIGNvbXBvbmVudHM6XHJcbiAgICAgKlxyXG4gICAgICogICAtIGRpc3RhbmNlIHRvIHRoZSBhbmFseXRpY2FsIHBvbHlsaW5lIGFsb25nIHNlZ21lbnQncyBub3JtYWw7XHJcbiAgICAgKiAgIC0gZGlzdGFuY2UgdG8gdGhlIGFuYWx5dGljYWwgcG9seWxpbmUgYWxvbmcgc2VnbWVudC5cclxuICAgICAqL1xyXG4gICAgW1xyXG4gICAgICAgIDQgLyogVVYgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIzIC8qIFVOU0lHTkVEX1NIT1JUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICAvKipcclxuICAgICAqIFZlY3RvciB3aXRoIHBvbHlsaW5lJ3MgaGFsZiB3aWR0aCBhbmQgZGFzaCBzdHlsZS4gSXQncyBjb21wb25lbnRzOlxyXG4gICAgICpcclxuICAgICAqICAgLSBoYWxmIHdpZHRoO1xyXG4gICAgICogICAtIGxlbmd0aCBvZiBhIGRhc2g7XHJcbiAgICAgKiAgIC0gZGlzdGFuY2UgYmV0d2VlbiBkYXNoZXMuXHJcbiAgICAgKi9cclxuICAgIFtcclxuICAgICAgICAxMSAvKiBBVVggKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAzLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIxIC8qIFVOU0lHTkVEX0JZVEUgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgLyoqXHJcbiAgICAgKiBNaXRlciAoaS5lLiBob3cgbXVjaCBkaXNwbGFjZW1lbnQgb2YgdGhlIHZlcnRleCBpcyBsb25nZXIgdGhlbiB0aGVcclxuICAgICAqIG5vcm1hbCkuXHJcbiAgICAgKi9cclxuICAgIFtcclxuICAgICAgICAxMiAvKiBBVVgxICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMSxcclxuICAgICAgICAgICAgdHlwZTogNTEyNiAvKiBGTE9BVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgLyoqXHJcbiAgICAgKiBMaW1pdCBvbiBkaXNwbGFjZW1lbnQgdGFuZ2VudCBjb21wb25lbnQuQXBwbGllZCB0byBhdm9pZCBnZW9tZXRyeVxyXG4gICAgICogZ2xpdGNoZXMgaW4gb3Zlci1kZWdlbmVyYXRpdmUgY2FzZXMuXHJcbiAgICAgKi9cclxuICAgIFtcclxuICAgICAgICAxMyAvKiBBVVgyICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMSxcclxuICAgICAgICAgICAgdHlwZTogNTEyNiAvKiBGTE9BVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgLyoqXHJcbiAgICAgKiBEaXN0YW5jZSB0byB0aGUgZmlyc3QgdmVydGV4IGFsb25nIHRoZSBwb2x5bGluZS5cclxuICAgICAqL1xyXG4gICAgW1xyXG4gICAgICAgIDE0IC8qIEFVWDMgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAxLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTI2IC8qIEZMT0FUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICAvKiogUG9seWxpbmUncyBjb2xvci4gKi9cclxuICAgIFtcclxuICAgICAgICA3IC8qIENPTE9SICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogNCxcclxuICAgICAgICAgICAgdHlwZTogNTEyMSAvKiBVTlNJR05FRF9CWVRFICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIC8qKiBQb2x5bGluZSdzIFogaW5kZXguICovXHJcbiAgICBbXHJcbiAgICAgICAgMTAgLyogWl9JTkRFWCAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDEsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjYgLyogRkxPQVQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgXVxyXG5dKTtcclxuIiwiaW1wb3J0IHsgV2ViV29ya2VyQ2xpZW50IH0gZnJvbSAnLi4vLi4vLi4vdXRpbC93b3JrZXInO1xyXG5leHBvcnQgY2xhc3MgVGlsZVByb3ZpZGVyV29ya2VyQ2xpZW50IGV4dGVuZHMgV2ViV29ya2VyQ2xpZW50IHtcclxufVxyXG4iLCJpbXBvcnQgeyBleHRyYWN0VHJhbnNmZXJhYmxlcyB9IGZyb20gJy4vcHJpbWl0aXZlX3Byb3ZpZGVyX3dvcmtlcl9tZXNzYWdlcyc7XHJcbmV4cG9ydCB2YXIgVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGU7XHJcbihmdW5jdGlvbiAoVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGUpIHtcclxuICAgIFRpbGVQcm92aWRlck1lc3NhZ2VUeXBlW1RpbGVQcm92aWRlck1lc3NhZ2VUeXBlW1wiSU5JVFwiXSA9IDBdID0gXCJJTklUXCI7XHJcbiAgICBUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZVtUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZVtcIlRJTEVfVVJMX1VQREFURVwiXSA9IDFdID0gXCJUSUxFX1VSTF9VUERBVEVcIjtcclxuICAgIFRpbGVQcm92aWRlck1lc3NhZ2VUeXBlW1RpbGVQcm92aWRlck1lc3NhZ2VUeXBlW1wiVElMRV9SRVFVRVNUX0JBVENIXCJdID0gMl0gPSBcIlRJTEVfUkVRVUVTVF9CQVRDSFwiO1xyXG4gICAgVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGVbVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGVbXCJUSUxFX1JFUVVFU1RfQ0FOQ0VMX0JBVENIXCJdID0gM10gPSBcIlRJTEVfUkVRVUVTVF9DQU5DRUxfQkFUQ0hcIjtcclxuICAgIFRpbGVQcm92aWRlck1lc3NhZ2VUeXBlW1RpbGVQcm92aWRlck1lc3NhZ2VUeXBlW1wiVElMRV9SRVNQT05TRVwiXSA9IDRdID0gXCJUSUxFX1JFU1BPTlNFXCI7XHJcbiAgICBUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZVtUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZVtcIlRJTEVfRVJST1JcIl0gPSA1XSA9IFwiVElMRV9FUlJPUlwiO1xyXG4gICAgVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGVbVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGVbXCJHRU9NRVRSWV9SRVNQT05TRVwiXSA9IDZdID0gXCJHRU9NRVRSWV9SRVNQT05TRVwiO1xyXG4gICAgVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGVbVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGVbXCJMQUJFTFNfUkVTUE9OU0VcIl0gPSA3XSA9IFwiTEFCRUxTX1JFU1BPTlNFXCI7XHJcbiAgICBUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZVtUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZVtcIk1FU0hfUkVRVUVTVFwiXSA9IDhdID0gXCJNRVNIX1JFUVVFU1RcIjtcclxuICAgIFRpbGVQcm92aWRlck1lc3NhZ2VUeXBlW1RpbGVQcm92aWRlck1lc3NhZ2VUeXBlW1wiTUVTSF9SRVFVRVNUX0NBTkNFTFwiXSA9IDldID0gXCJNRVNIX1JFUVVFU1RfQ0FOQ0VMXCI7XHJcbiAgICBUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZVtUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZVtcIk1FU0hfUkVTUE9OU0VcIl0gPSAxMF0gPSBcIk1FU0hfUkVTUE9OU0VcIjtcclxuICAgIFRpbGVQcm92aWRlck1lc3NhZ2VUeXBlW1RpbGVQcm92aWRlck1lc3NhZ2VUeXBlW1wiTUVTSF9FUlJPUlwiXSA9IDExXSA9IFwiTUVTSF9FUlJPUlwiO1xyXG59KShUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZSB8fCAoVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGUgPSB7fSkpO1xyXG5leHBvcnQgY29uc3QgZ2VvbWV0cnlUcmFuc2ZlcmFibGVFeHRyYWN0b3IgPSBmdW5jdGlvbiAobWVzc2FnZSwgdHJhbnNmZXJhYmxlcyA9IFtdKSB7XHJcbiAgICBleHRyYWN0VHJhbnNmZXJhYmxlcyhtZXNzYWdlLnBvbHlnb25QYWdlcywgdHJhbnNmZXJhYmxlcyk7XHJcbiAgICBleHRyYWN0VHJhbnNmZXJhYmxlcyhtZXNzYWdlLnRyYW5zcGFyZW50UG9seWdvblBhZ2VzLCB0cmFuc2ZlcmFibGVzKTtcclxuICAgIGV4dHJhY3RUcmFuc2ZlcmFibGVzKG1lc3NhZ2UudGV4dHVyZWRQb2x5Z29uUGFnZXMsIHRyYW5zZmVyYWJsZXMpO1xyXG4gICAgZXh0cmFjdFRyYW5zZmVyYWJsZXMobWVzc2FnZS5tZXNoUGFnZXMsIHRyYW5zZmVyYWJsZXMpO1xyXG4gICAgZXh0cmFjdFRyYW5zZmVyYWJsZXMobWVzc2FnZS5wb2x5bGluZVBhZ2VzLCB0cmFuc2ZlcmFibGVzKTtcclxuICAgIHJldHVybiB0cmFuc2ZlcmFibGVzO1xyXG59O1xyXG5leHBvcnQgY29uc3QgbWVzaFRyYW5zZmVyYWJsZUV4dHJhY3RvciA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XHJcbiAgICBjb25zdCB0cmFuc2ZlcmFibGVzID0gW107XHJcbiAgICBleHRyYWN0VHJhbnNmZXJhYmxlcyhtZXNzYWdlLnBhZ2VzLCB0cmFuc2ZlcmFibGVzKTtcclxuICAgIHJldHVybiB0cmFuc2ZlcmFibGVzO1xyXG59O1xyXG5leHBvcnQgY29uc3QgbGFiZWxUcmFuc2ZlcmFibGVFeHRyYWN0b3IgPSBmdW5jdGlvbiAobWVzc2FnZSwgdHJhbnNmZXJhYmxlcyA9IFtdKSB7XHJcbiAgICBleHRyYWN0VHJhbnNmZXJhYmxlcyhtZXNzYWdlLnBvaW50TGFiZWxQYWdlcywgdHJhbnNmZXJhYmxlcyk7XHJcbiAgICBleHRyYWN0VHJhbnNmZXJhYmxlcyhtZXNzYWdlLnBvaW50TGFiZWxCYWNrZ3JvdW5kUGFnZXMsIHRyYW5zZmVyYWJsZXMpO1xyXG4gICAgZXh0cmFjdFRyYW5zZmVyYWJsZXMobWVzc2FnZS5jdXJ2ZWRMYWJlbFBhZ2VzLCB0cmFuc2ZlcmFibGVzKTtcclxuICAgIHJldHVybiB0cmFuc2ZlcmFibGVzO1xyXG59O1xyXG5leHBvcnQgY29uc3QgdGlsZVRyYW5zZmVyYWJsZUV4dHJhY3RvciA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XHJcbiAgICBjb25zdCB0cmFuc2ZlcmFibGVzID0gW107XHJcbiAgICBnZW9tZXRyeVRyYW5zZmVyYWJsZUV4dHJhY3RvcihtZXNzYWdlLCB0cmFuc2ZlcmFibGVzKTtcclxuICAgIGxhYmVsVHJhbnNmZXJhYmxlRXh0cmFjdG9yKG1lc3NhZ2UsIHRyYW5zZmVyYWJsZXMpO1xyXG4gICAgcmV0dXJuIHRyYW5zZmVyYWJsZXM7XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBFeHRyYWN0IEFycmF5QnVmZmVycyAodGhhdCBhcmUgdGFuc2ZlcmFibGUpIGZyb20gcGFnZXMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFRyYW5zZmVyYWJsZXMocGFnZXMsIG91dHB1dCkge1xyXG4gICAgZm9yIChjb25zdCBwYWdlIG9mIHBhZ2VzKSB7XHJcbiAgICAgICAgb3V0cHV0LnB1c2gocGFnZS52ZXJ0ZXhCdWZmZXIuYnVmZmVyLCBwYWdlLmluZGV4QnVmZmVyLmJ1ZmZlcik7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgQXR0cmlidXRlTWFwcGluZyB9IGZyb20gJy4uLy4uL3JlbmRlci9hdHRyaWJfbWFwcGluZyc7XHJcbmltcG9ydCB7IFBPTFlHT05fQVRUUklCVVRFX01BUFBJTkcgfSBmcm9tICcuL3BvbHlnb25fYXR0cmlidXRlX21hcHBpbmcnO1xyXG4vKipcclxuICogRGVzY3JpcHRpb24gb2YgaG93IGF0dHJpYnV0ZXMgb2YgdmVydGljZXMgYXJlIHBhY2tlZCBpbnRvIGEgdmVydGV4IGJ1ZmZlci5cclxuICovXHJcbmV4cG9ydCBjb25zdCBUUkFOU1BBUkVOVF9QT0xZR09OX0FUVFJJQlVURV9NQVBQSU5HID0gbmV3IEF0dHJpYnV0ZU1hcHBpbmcoUE9MWUdPTl9BVFRSSUJVVEVfTUFQUElORyk7XHJcbiIsImltcG9ydCBQcmlvcml0eVF1ZXVlIGZyb20gJy4vcHJpb3JpdHlfcXVldWUnO1xyXG5jb25zdCBNQVhfREVRVUVVRV9USU1FT1VUID0gMTAwMDsgLy8gbXNcclxuLy8gVE9ETzogcmVtb3ZlIHRoaXMgc2hpbSB3aGVuIGFsbCBzdXBwb3J0ZWQgYnJvd3NlcnMgaW1wbGVtZW50IGl0XHJcbmNvbnN0IFNISU1NRURfUFJPQ0VTU0lOR19EVVJBVElPTl9NUyA9IDI1O1xyXG53aW5kb3cuY2FuY2VsSWRsZUNhbGxiYWNrID0gd2luZG93LmNhbmNlbElkbGVDYWxsYmFjayB8fCB3aW5kb3cuY2xlYXJUaW1lb3V0O1xyXG53aW5kb3cucmVxdWVzdElkbGVDYWxsYmFjayA9IHdpbmRvdy5yZXF1ZXN0SWRsZUNhbGxiYWNrIHx8IGZ1bmN0aW9uIChoYW5kbGVyKSB7XHJcbiAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgIHJldHVybiBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICBoYW5kbGVyKHtcclxuICAgICAgICAgICAgZGlkVGltZW91dDogZmFsc2UsXHJcbiAgICAgICAgICAgIHRpbWVSZW1haW5pbmc6ICgpID0+IE1hdGgubWF4KDAsIFNISU1NRURfUFJPQ0VTU0lOR19EVVJBVElPTl9NUyAtIChwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZSkpXHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufTtcclxuLyoqXHJcbiAqIEl0IGlzIGEgdGFzayBxdWV1ZS4gVGFza3MgYXJlIGRlcXVldWVkIGR1cmluZyBpZGxlIHBlcmlvZC5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElkbGVUYXNrUXVldWUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5fcXVldWUgPSBuZXcgUHJpb3JpdHlRdWV1ZSgpO1xyXG4gICAgICAgIHRoaXMuX2RlcXVldWVJZGxlSGFuZGxlID0gMDtcclxuICAgIH1cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgY2FuY2VsSWRsZUNhbGxiYWNrKHRoaXMuX2RlcXVldWVJZGxlSGFuZGxlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRW5xdWV1ZXMgYSB0YXNrIHRvIHRoZSBxdWV1ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdGFzayBUaGUgdGFzay5cclxuICAgICAqL1xyXG4gICAgZW5xdWV1ZSh0YXNrKSB7XHJcbiAgICAgICAgdGhpcy5fcXVldWUuZW5xdWV1ZSh0YXNrKTtcclxuICAgICAgICB0aGlzLl9ydW4oKTtcclxuICAgIH1cclxuICAgIF9kZXF1ZXVlKGRlYWRsaW5lKSB7XHJcbiAgICAgICAgY29uc3QgcXVldWUgPSB0aGlzLl9xdWV1ZTtcclxuICAgICAgICBpZiAocXVldWUuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRlYWRsaW5lLmRpZFRpbWVvdXQpIHtcclxuICAgICAgICAgICAgcXVldWUuZGVxdWV1ZSgpLmV4ZWN1dGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHdoaWxlIChkZWFkbGluZS50aW1lUmVtYWluaW5nKCkgJiYgIXF1ZXVlLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgcXVldWUuZGVxdWV1ZSgpLmV4ZWN1dGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9kZXF1ZXVlSWRsZUhhbmRsZSA9IDA7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9xdWV1ZS5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgdGhpcy5fcnVuKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3J1bigpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2RlcXVldWVJZGxlSGFuZGxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RlcXVldWVJZGxlSGFuZGxlID0gcmVxdWVzdElkbGVDYWxsYmFjaygoZGVhZGxpbmUpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2RlcXVldWUoZGVhZGxpbmUpO1xyXG4gICAgICAgICAgICB9LCB7IHRpbWVvdXQ6IE1BWF9ERVFVRVVFX1RJTUVPVVQgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCBCaW5hcnlIZWFwIGZyb20gJy4vYmluYXJ5X2hlYXAnO1xyXG5mdW5jdGlvbiBpdGVtQ29tcGFyYXRvcihhLCBiKSB7XHJcbiAgICByZXR1cm4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHk7XHJcbn1cclxuLyoqXHJcbiAqIFByaW9yaXR5IHF1ZXVlIGJhc2VkIG9uIGEgaGVhcC5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByaW9yaXR5UXVldWUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb25zdHJ1Y3RzIG5ldyBlbXB0eSBwcmlvcml0eSBxdWV1ZS5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5faGVhcCA9IG5ldyBCaW5hcnlIZWFwKGl0ZW1Db21wYXJhdG9yKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhbiBpdGVtIGludG8gdGhlIHF1ZXVlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpdGVtIFRoZSBpdGVtLlxyXG4gICAgICovXHJcbiAgICBlbnF1ZXVlKGl0ZW0pIHtcclxuICAgICAgICB0aGlzLl9oZWFwLmluc2VydChpdGVtKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBuZXh0IGl0ZW0gZnJvbSB0aGUgcXVldWUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVGhlIG5leHQgaXRlbSBvciBgdW5kZWZpbmVkYCBpZiB0aGUgcXVldWUncyBlbXB0eS5cclxuICAgICAqL1xyXG4gICAgZGVxdWV1ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faGVhcC5wb3AoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIHRoZSBxdWV1ZSBoYXMgbm8gaXRlbXMgaW4gaXQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZXJlJ3JlIG5vIGl0ZW1zIGl0IHRoZSBxdWV1ZSBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXHJcbiAgICAgKi9cclxuICAgIGlzRW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlYXAuc2l6ZSA9PT0gMDtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBzd2FwIH0gZnJvbSAnLi9hcnJheSc7XHJcbmltcG9ydCB7IERFRkFVTFRfQ09NUEFSQVRPUiB9IGZyb20gJy4vY29tcGFyYXRvcic7XHJcbi8qKlxyXG4gKiBDb21wdXRlcyBpbmRleCBvZiB0aGUgcGFyZW50IG9mIGFuIGl0ZW0uXHJcbiAqXHJcbiAqIEBwYXJhbSBpZHggSW5kZXggb2YgdGhlIGl0ZW0uXHJcbiAqIEByZXR1cm5zIEluZGV4IG9mIHRoZSBwYXJlbnQuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRQYXJlbnRJZHgoaWR4KSB7XHJcbiAgICByZXR1cm4gKGlkeCArIDEgPj4gMSkgLSAxO1xyXG59XHJcbi8qKlxyXG4gKiBDb21wdXRlcyBpbmRleCBvZiB0aGUgbGVmdCBjaGlsZCBvZiBhbiBpdGVtLlxyXG4gKlxyXG4gKiBAcGFyYW0gaWR4IEluZGV4IG9mIHRoZSBpdGVtLlxyXG4gKiBAcmV0dXJucyBJbmRleCBvZiB0aGUgY2hpbGQuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRGaXJzdENoaWxkSWR4KGlkeCkge1xyXG4gICAgcmV0dXJuIChpZHggKyAxIDw8IDEpIC0gMTtcclxufVxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCaW5hcnlIZWFwIHtcclxuICAgIC8qKlxyXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBlbXB0eSBoZWFwLiBPcmRlciBvZiBpdGVtcyBpbiB0aGUgaGVhcCB3aWxsIGJlIGRlZmluZWRcclxuICAgICAqIGJ5IGEgZ2l2ZW4gY29tcGFyYXRvci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY29tcGFyYXRvciBUaGUgY29tcGFyYXRvci5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoY29tcGFyYXRvciA9IERFRkFVTFRfQ09NUEFSQVRPUikge1xyXG4gICAgICAgIC8vIFRPRE8oZG1pa2lzKSBJbnZlc3RpZ2F0ZSBwcmVhbGxvY2F0aW9uLlxyXG4gICAgICAgIHRoaXMuX2l0ZW1zID0gW107XHJcbiAgICAgICAgdGhpcy5fY29tcGFyYXRvciA9IGNvbXBhcmF0b3I7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEluc2VydHMgYW4gaXRlbSBpbnRvIHRoZSBoZWFwLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpdGVtIFRoZSBpdGVtIHRvIGJlIGluc2VydGVkLlxyXG4gICAgICovXHJcbiAgICBpbnNlcnQoaXRlbSkge1xyXG4gICAgICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5faXRlbXM7XHJcbiAgICAgICAgY29uc3QgY29tcGFyYXRvciA9IHRoaXMuX2NvbXBhcmF0b3I7XHJcbiAgICAgICAgLy8gSW5zZXJ0IHRoZSBuZXcgaXRlbSBhcyBib3R0b20gcmlnaHQtbW9zdCBjaGlsZCBvZiB0aGUgaGVhcC5cclxuICAgICAgICBsZXQgaWR4ID0gaXRlbXMucHVzaChpdGVtKSAtIDE7XHJcbiAgICAgICAgbGV0IHBhcmVudElkeCA9IGdldFBhcmVudElkeChpZHgpO1xyXG4gICAgICAgIC8vIFdhbGsgdGhlIGhlYXAgdXB3YXJkIGFuZCByZXN0b3JlIGhlYXAgcHJvcGVydHkgb24gdGhlIHdheS5cclxuICAgICAgICB3aGlsZSAocGFyZW50SWR4ID4gLTEgJiZcclxuICAgICAgICAgICAgY29tcGFyYXRvcihpdGVtc1tpZHhdLCBpdGVtc1twYXJlbnRJZHhdKSA+IDApIHtcclxuICAgICAgICAgICAgc3dhcChpdGVtcywgaWR4LCBwYXJlbnRJZHgpO1xyXG4gICAgICAgICAgICBpZHggPSBwYXJlbnRJZHg7XHJcbiAgICAgICAgICAgIHBhcmVudElkeCA9IGdldFBhcmVudElkeChpZHgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBcIm1heGltdW1cIiBpdGVtIGZyb20gdGhlIGhlYWQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVGhlIHJlbW92ZWQgaXRlbSBvciBgdW5kZWZpbmVkYCBpcyB0aGUgaGVhcCdzIGVtcHR5LlxyXG4gICAgICovXHJcbiAgICBwb3AoKSB7XHJcbiAgICAgICAgY29uc3QgaXRlbXMgPSB0aGlzLl9pdGVtcztcclxuICAgICAgICBpZiAoaXRlbXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG5ld1NpemUgPSBpdGVtcy5sZW5ndGggLSAxO1xyXG4gICAgICAgIC8vIFBsYWNlIG1heCBpdGVtIGF0IHRoZSBlbmQgb2YgdGhlIGl0ZW1zIGFycmF5LlxyXG4gICAgICAgIHN3YXAoaXRlbXMsIDAsIG5ld1NpemUpO1xyXG4gICAgICAgIC8vIFdhbGsgZG93bndhcmQgZnJvbSB0aGUgbmV3IHJvb3QgdG8gcmVzdG9yZSBoZWFwIHByb3BlcnR5LlxyXG4gICAgICAgIGxldCBpZHggPSAwO1xyXG4gICAgICAgIGxldCBjaGlsZElkeCA9IDE7XHJcbiAgICAgICAgY29uc3QgY29tcGFyYXRvciA9IHRoaXMuX2NvbXBhcmF0b3I7XHJcbiAgICAgICAgd2hpbGUgKGNoaWxkSWR4IDwgbmV3U2l6ZSkge1xyXG4gICAgICAgICAgICBpZiAoY2hpbGRJZHggKyAxIDwgbmV3U2l6ZSAmJlxyXG4gICAgICAgICAgICAgICAgY29tcGFyYXRvcihpdGVtc1tjaGlsZElkeF0sIGl0ZW1zW2NoaWxkSWR4ICsgMV0pIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgY2hpbGRJZHggKz0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY29tcGFyYXRvcihpdGVtc1tpZHhdLCBpdGVtc1tjaGlsZElkeF0pID4gMCkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3dhcChpdGVtcywgaWR4LCBjaGlsZElkeCk7XHJcbiAgICAgICAgICAgIGlkeCA9IGNoaWxkSWR4O1xyXG4gICAgICAgICAgICBjaGlsZElkeCA9IGdldEZpcnN0Q2hpbGRJZHgoY2hpbGRJZHgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSZW1vdmUgcHJldmlvdXNseSBwbGFjZWQgYXQgdGhlIGVuZCBwcmV2aW91cyBtYXggaXRlbS5cclxuICAgICAgICByZXR1cm4gaXRlbXMucG9wKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFwiTWF4aW11bVwiIGl0ZW0gaW4gdGhlIGhlYXAgb3IgYHVuZGVmaW5lZGAgaWYgdGhlIGhlYWQgaXMgZW1wdHkuXHJcbiAgICAgKi9cclxuICAgIHBlZWsoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1zWzBdO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBJdGVyYXRvciBvdmVyIGFsbCBpdGVtcyBpbiB0aGUgaGVhcC4gTm90ZSB0aGF0IG9yZGVyIG9mIGl0ZW1zXHJcbiAgICAgKiAgICAgIGlzIHVuZGVmaW5lZC5cclxuICAgICAqL1xyXG4gICAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xyXG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLl9pdGVtcykge1xyXG4gICAgICAgICAgICB5aWVsZCBpdGVtO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgTnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBoZWFwLlxyXG4gICAgICovXHJcbiAgICBnZXQgc2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faXRlbXMubGVuZ3RoO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCBSZW5kZXJhYmxlUHJpbWl0aXZlIGZyb20gJy4uL3JlbmRlcmFibGVfcHJpbWl0aXZlJztcclxuLyoqXHJcbiAqIEFsbG9jYXRlZCBpbiBHUFUgbWVtb3J5IHBvbHlnb24uXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW5kZXJhYmxlUG9seWdvbiBleHRlbmRzIFJlbmRlcmFibGVQcmltaXRpdmUge1xyXG4gICAgY29uc3RydWN0b3IobWVtb3J5U3ViQ2h1bmssIGlzT3BhcXVlKSB7XHJcbiAgICAgICAgc3VwZXIobWVtb3J5U3ViQ2h1bmspO1xyXG4gICAgICAgIHRoaXMuaXNPcGFxdWUgPSBpc09wYXF1ZTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgUmVmZXJlbmNlQ291bnRlZCBmcm9tICcuLi91dGlsL3JlZl9jb3VudGVkJztcclxuLyoqXHJcbiAqIEJhc2UgY2xhc3MgZm9yIHByaW1pdGl2ZSBvYmplY3RzIHRoYXQgYXJlIHJlYWR5IHRvIGJlIGZlZCB0byB0aGUgcmVuZGVyZXIuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW5kZXJhYmxlUHJpbWl0aXZlIGV4dGVuZHMgUmVmZXJlbmNlQ291bnRlZCB7XHJcbiAgICBjb25zdHJ1Y3RvcihtZW1vcnlTdWJDaHVuaykge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5tZW1vcnlTdWJDaHVuayA9IG1lbW9yeVN1YkNodW5rO1xyXG4gICAgfVxyXG4gICAgX2Rlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5tZW1vcnlTdWJDaHVuay5kZXN0cm95KCk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IFJlbmRlcmFibGVQcmltaXRpdmUgZnJvbSAnLi4vcmVuZGVyYWJsZV9wcmltaXRpdmUnO1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW5kZXJhYmxlVGV4dHVyZWRQb2x5Z29uIGV4dGVuZHMgUmVuZGVyYWJsZVByaW1pdGl2ZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihtZW1vcnlDaHVuaywgYWxsb2NhdGVkSW1hZ2UpIHtcclxuICAgICAgICBzdXBlcihtZW1vcnlDaHVuayk7XHJcbiAgICAgICAgdGhpcy5fYWxsb2NhdGVkSW1hZ2UgPSBhbGxvY2F0ZWRJbWFnZTtcclxuICAgICAgICB0aGlzLmF0bGFzID0gYWxsb2NhdGVkSW1hZ2UuYXRsYXNNYW5hZ2VyLmF0bGFzO1xyXG4gICAgICAgIGFsbG9jYXRlZEltYWdlLnJldGFpbigpO1xyXG4gICAgfVxyXG4gICAgX2Rlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5fYWxsb2NhdGVkSW1hZ2UucmVsZWFzZSgpO1xyXG4gICAgICAgIHN1cGVyLl9kZXN0cm95KCk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IFJlbmRlcmFibGVQcmltaXRpdmUgZnJvbSAnLi4vcmVuZGVyYWJsZV9wcmltaXRpdmUnO1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW5kZXJhYmxlUG9seWxpbmUgZXh0ZW5kcyBSZW5kZXJhYmxlUHJpbWl0aXZlIHtcclxufVxyXG4iLCJpbXBvcnQgUmVuZGVyYWJsZVBvbHlsaW5lIGZyb20gJy4vcmVuZGVyYWJsZV9wb2x5bGluZSc7XHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbmRlcmFibGVUZXh0dXJlZFBvbHlsaW5lIGV4dGVuZHMgUmVuZGVyYWJsZVBvbHlsaW5lIHtcclxuICAgIGNvbnN0cnVjdG9yKG1lbW9yeUNodW5rLCBhbGxvY2F0ZWRJbWFnZSkge1xyXG4gICAgICAgIHN1cGVyKG1lbW9yeUNodW5rKTtcclxuICAgICAgICB0aGlzLl9hbGxvY2F0ZWRJbWFnZSA9IGFsbG9jYXRlZEltYWdlO1xyXG4gICAgICAgIHRoaXMuYXRsYXMgPSBhbGxvY2F0ZWRJbWFnZS5hdGxhc01hbmFnZXIuYXRsYXM7XHJcbiAgICAgICAgYWxsb2NhdGVkSW1hZ2UucmV0YWluKCk7XHJcbiAgICB9XHJcbiAgICBfZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLl9hbGxvY2F0ZWRJbWFnZS5yZWxlYXNlKCk7XHJcbiAgICAgICAgc3VwZXIuX2Rlc3Ryb3koKTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgUmVuZGVyYWJsZVByaW1pdGl2ZSBmcm9tICcuLi9yZW5kZXJhYmxlX3ByaW1pdGl2ZSc7XHJcbi8qKlxyXG4gKiBBIGdlbmVyYWwgcHJpbWl0aXZlIHRoYXQgaXMgYmVzdCBzdWl0YWJsZSBmb3Igc3RvcmluZyBzaW1wbGUgY29sb3JlZCAzRCBtb2RlbHMuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW5kZXJhYmxlTW9kZWwgZXh0ZW5kcyBSZW5kZXJhYmxlUHJpbWl0aXZlIHtcclxufVxyXG4iLCJleHBvcnQgY29uc3QgUE9MWUdPTl9FWFRSQUNUT1IgPSAoZGF0YSkgPT4gZmxhdChtYXAoJ3BvbHlnb25zJywgZGF0YSkpO1xyXG5leHBvcnQgY29uc3QgVEVYVFVSRURfUE9MWUdPTl9FWFRSQUNUT1IgPSAoZGF0YSkgPT4gZmxhdChtYXAoJ3RleHR1cmVkUG9seWdvbnMnLCBkYXRhKSk7XHJcbmV4cG9ydCBjb25zdCBQT0xZTElORV9FWFRSQUNUT1IgPSAoZGF0YSkgPT4gZmxhdChtYXAoJ3BvbHlsaW5lcycsIGRhdGEpKTtcclxuZXhwb3J0IGNvbnN0IFRFWFRVUkVEX1BPTFlMSU5FX0VYVFJBQ1RPUiA9IChkYXRhKSA9PiBmbGF0KG1hcCgndGV4dHVyZWRQb2x5bGluZXMnLCBkYXRhKSk7XHJcbmV4cG9ydCBjb25zdCBQT0lOVF9FWFRSQUNUT1IgPSAoZGF0YSkgPT4gZmxhdChtYXAoJ3BvaW50cycsIGRhdGEpKTtcclxuZXhwb3J0IGNvbnN0IFBPSU5UX0xBQkVMX0VYVFJBQ1RPUiA9IChkYXRhKSA9PiBmbGF0KG1hcCgncG9pbnRMYWJlbHMnLCBkYXRhKSk7XHJcbmV4cG9ydCBjb25zdCBDVVJWRURfTEFCRUxfRVhUUkFDVE9SID0gKGRhdGEpID0+IGZsYXQobWFwKCdjdXJ2ZWRMYWJlbHMnLCBkYXRhKSk7XHJcbmV4cG9ydCBjb25zdCBNT0RFTF9FWFRSQUNUT1IgPSAoZGF0YSkgPT4gZmxhdChtYXAoJ21vZGVscycsIGRhdGEpKTtcclxuZXhwb3J0IGNvbnN0IEVYVEVSTkFMX01FU0hfRVhUUkFDVE9SID0gKGRhdGEpID0+IGZsYXQobWFwKCdleHRlcm5hbE1lc2hlcycsIGRhdGEpKTtcclxuLyoqXHJcbiAqIE1hcHMgbGlzdCBvZiBUaWxlRGF0YSdzIGludG8gbGlzdCBvZiBzcGVjaWZpZWQgcHJpbWl0aXZlcy5cclxuICovXHJcbmZ1bmN0aW9uKiBtYXAodHlwZSwgZGF0YSkge1xyXG4gICAgZm9yIChjb25zdCBwb3J0aW9uIG9mIGRhdGEpIHtcclxuICAgICAgICB5aWVsZCBwb3J0aW9uW3R5cGVdO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBGbGF0dGVuIHR3byBkaW1lbnNpb25hbCBsaXN0IG9mIHByaW1pdGl2ZXMgaW4gYSBzaW5nbGUgZGltZW5zaW9uYWwgb25lLlxyXG4gKi9cclxuZnVuY3Rpb24qIGZsYXQocHJpbWl0aXZlcykge1xyXG4gICAgZm9yIChjb25zdCBwb3J0aW9uIG9mIHByaW1pdGl2ZXMpIHtcclxuICAgICAgICBpZiAocG9ydGlvbikge1xyXG4gICAgICAgICAgICB5aWVsZCogcG9ydGlvbjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IFByaW1pdGl2ZU1hbmFnZXIgZnJvbSAnLi9wcmltaXRpdmVfbWFuYWdlcic7XHJcbi8qKlxyXG4gKiBNYW5hZ2VyIG9mIHByaW1pdGl2ZXMgdGhhdCBoYXZlIGEgc2luZ2xlIGFzc2ljaWF0ZWQgcmVuZGVyYWJsZSBwcmltaXRpdmUuIFRoZSBcIm1hbmFnZW1lbnRcIiBpcyBwcmV0dHkgc3RyYWlnaHRmb3J3YXJkOlxyXG4gKiBpdCBkaXJlY3RseSBhZGRzL3JlbW92ZXMgYXNzb2NpYXRlZCBwcmltaXRpdmVzIGludG8gdGhlIHN0b3JhZ2UuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW5kZXJhYmxlUHJpbWl0aXZlTWFuYWdlciBleHRlbmRzIFByaW1pdGl2ZU1hbmFnZXIge1xyXG4gICAgY29uc3RydWN0b3IocHJpbWl0aXZlc1N0b3JhZ2UpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX3ByaW1pdGl2ZXNTdG9yYWdlID0gcHJpbWl0aXZlc1N0b3JhZ2U7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVTY2VuZSh0b1Nob3csIHRvSGlkZSkge1xyXG4gICAgICAgIHRoaXMuX3ByaW1pdGl2ZXNTdG9yYWdlLmFkZCguLi50b1Nob3cpO1xyXG4gICAgICAgIHRoaXMuX3ByaW1pdGl2ZXNTdG9yYWdlLmRlbGV0ZSguLi50b0hpZGUpO1xyXG4gICAgfVxyXG4gICAgZGVzdHJveVByaW1pdGl2ZXMoX3RvRGVzdHJveSkge1xyXG4gICAgICAgIC8vIG5vIG5lZWQgdG8gZGVzdHJveSBhbnl0aGluZywgUmVuZGVyYWJsZVByaW1pdGl2ZSBhcmUgcmVsZWFzZWQgd2hlbiByZW1vdmVkIGZyb20gcHJpbW1pdGl2ZSBzdG9yYWdlXHJcbiAgICB9XHJcbn1cclxuIiwiLyoqXHJcbiAqIE9mdGVuIHByaW1pdGl2ZXMgY2FuJ3QgYmUgZGlycmVjdGx5IGFkZGVkIGludG8gb3IgcmVtb3ZlZCBmcm9tIHNjZW5lLCB0aGVyZSBjYW4gYmUgc29tZSBzcGVjaWZpYyAoYnVzaW5lc3MpIGxvZ2ljXHJcbiAqIGFzc29jaWF0ZWQgd2l0aCB0aGVzZSBvcGVyYXRpb25zLiBUaGlzIGNsYXNzIHByb3ZpZGVzIGJhc2ljIG1ldGhvZHMgZm9yIHN1Y2ggaW1wbGVtZW50YXRpb25zIHRoYXRcclxuICogYWxsb3dzIHRvIG1hbmFnZSBwcmltaXRpdmVzIG9mIGFsbCB0eXBlcyBpbiB0aGUgc2FtZSBtYW5uZXIuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcmltaXRpdmVNYW5hZ2VyIHtcclxuICAgIGRlc3Ryb3koKSB7IH1cclxufVxyXG4iLCJpbXBvcnQgeyBWb2lkRXZlbnRFbWl0dGVyIH0gZnJvbSAnLi4vLi4vdXRpbC9ldmVudF9lbWl0dGVyJztcclxuLyoqXHJcbiAqIFByaW1pdGl2ZSBzdG9yYWdlIHRoYXQgc3RvcmVzIHByaW1pdGl2ZSBpbiBhIHNldC4gSXQgYWN0cyBhcyBhIHByaW1pdGl2ZSBwcm92aWRlciBhcyB3ZWxsLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJpbWl0aXZlU2V0U3RvcmFnZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLl9wcmltaXRpdmVTZXQgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgdGhpcy5vblVwZGF0ZSA9IG5ldyBWb2lkRXZlbnRFbWl0dGVyKCk7XHJcbiAgICB9XHJcbiAgICBnZXQgcHJpbWl0aXZlcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcHJpbWl0aXZlU2V0O1xyXG4gICAgfVxyXG4gICAgYWRkKC4uLnByaW1pdGl2ZXMpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IHByaW1pdGl2ZSBvZiBwcmltaXRpdmVzKSB7XHJcbiAgICAgICAgICAgIHByaW1pdGl2ZS5yZXRhaW4oKTtcclxuICAgICAgICAgICAgdGhpcy5fcHJpbWl0aXZlU2V0LmFkZChwcmltaXRpdmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocHJpbWl0aXZlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25VcGRhdGUuZmlyZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGRlbGV0ZSguLi5wcmltaXRpdmVzKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBwcmltaXRpdmUgb2YgcHJpbWl0aXZlcykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fcHJpbWl0aXZlU2V0LmRlbGV0ZShwcmltaXRpdmUpKSB7XHJcbiAgICAgICAgICAgICAgICBwcmltaXRpdmUucmVsZWFzZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcmltaXRpdmVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5vblVwZGF0ZS5maXJlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2xlYXIoKSB7XHJcbiAgICAgICAgdGhpcy5fcHJpbWl0aXZlU2V0LmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5vblVwZGF0ZS5maXJlKCk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IFJlbmRlcmFibGVQcmltaXRpdmVNYW5hZ2VyIGZyb20gJy4vcmVuZGVyYWJsZV9wcmltaXRpdmVfbWFuYWdlcic7XHJcbi8qKlxyXG4gKiBQb2x5Z29ucyBzaG91bGQgYmUgc2VwYXJhdGVkIGJ5IG9wYXF1ZW5lc3MgYW5kIHRoZXJlIGFyZSB0d28gZGlzdGluY3QgcHJpbWl0aXZlIHByb3ZpZGVyc1xyXG4gKiBmb3IgdGhlbTogb3BhcXVlIGFuZCB0YW5zcGFyZW50LiBUaGF0IGlzIHdoYXQgdGhpcyBtYW5hZ2VyIHRha2VzIGNhcmUgb2YuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb2x5Z29uTWFuYWdlciBleHRlbmRzIFJlbmRlcmFibGVQcmltaXRpdmVNYW5hZ2VyIHtcclxuICAgIGNvbnN0cnVjdG9yKG9wYXF1ZVBvbHlnb25TdG9yYWdlLCB0cmFuc3BhcmVudFBvbHlnb25TdG9yYWdlKSB7XHJcbiAgICAgICAgc3VwZXIob3BhcXVlUG9seWdvblN0b3JhZ2UpO1xyXG4gICAgICAgIHRoaXMuX29wYXF1ZVBvbHlnb25TdG9yYWdlID0gb3BhcXVlUG9seWdvblN0b3JhZ2U7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNwYXJlbnRQb2x5Z29uU3RvcmFnZSA9IHRyYW5zcGFyZW50UG9seWdvblN0b3JhZ2U7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVTY2VuZSh0b1Nob3csIHRvSGlkZSkge1xyXG4gICAgICAgIGZvciAoY29uc3QgcHJpbWl0aXZlIG9mIHRvU2hvdykge1xyXG4gICAgICAgICAgICBpZiAocHJpbWl0aXZlLmlzT3BhcXVlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9vcGFxdWVQb2x5Z29uU3RvcmFnZS5hZGQocHJpbWl0aXZlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zcGFyZW50UG9seWdvblN0b3JhZ2UuYWRkKHByaW1pdGl2ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChjb25zdCBwcmltaXRpdmUgb2YgdG9IaWRlKSB7XHJcbiAgICAgICAgICAgIGlmIChwcmltaXRpdmUuaXNPcGFxdWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX29wYXF1ZVBvbHlnb25TdG9yYWdlLmRlbGV0ZShwcmltaXRpdmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNwYXJlbnRQb2x5Z29uU3RvcmFnZS5kZWxldGUocHJpbWl0aXZlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgUHJpbWl0aXZlU2V0U3RvcmFnZSBmcm9tICcuL3ByaW1pdGl2ZV9zZXRfc3RvcmFnZSc7XHJcbi8qKlxyXG4gKiBTaW1wbGUgcHJpbWl0aXZlIHNldCBzdG9yYWdlIHRoYXQgZGlzdGluZ3Vpc2ggdmlzaWJsZS9oaWRkZW4gcHJpbWl0aXZlcy4gSXQgYWxzbyBhY3RzIGFzIGEgcHJpbWl0aXZlIHByb3ZpZGVyLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGlzYXBwZWFyaW5nUHJpbWl0aXZlU2V0U3RvcmFnZSBleHRlbmRzIFByaW1pdGl2ZVNldFN0b3JhZ2Uge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl92aXNpYmxlUHJpbWl0aXZlcyA9IG5ldyBTZXQoKTtcclxuICAgIH1cclxuICAgIGdldCBwcmltaXRpdmVzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZpc2libGVQcmltaXRpdmVzO1xyXG4gICAgfVxyXG4gICAgZ2V0IHZpc2libGVQcmltaXRpdmVzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpYmxlUHJpbWl0aXZlcztcclxuICAgIH1cclxuICAgIGFkZCguLi5wcmltaXRpdmVzKSB7XHJcbiAgICAgICAgc3VwZXIuYWRkKC4uLnByaW1pdGl2ZXMpO1xyXG4gICAgICAgIHRoaXMuc2hvdyguLi5wcmltaXRpdmVzKTtcclxuICAgIH1cclxuICAgIGRlbGV0ZSguLi5wcmltaXRpdmVzKSB7XHJcbiAgICAgICAgdGhpcy5oaWRlKC4uLnByaW1pdGl2ZXMpO1xyXG4gICAgICAgIHN1cGVyLmRlbGV0ZSguLi5wcmltaXRpdmVzKTtcclxuICAgIH1cclxuICAgIHNob3coLi4ucHJpbWl0aXZlcykge1xyXG4gICAgICAgIGZvciAoY29uc3QgcHJpbWl0aXZlIG9mIHByaW1pdGl2ZXMpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3ByaW1pdGl2ZVNldC5oYXMocHJpbWl0aXZlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdmlzaWJsZVByaW1pdGl2ZXMuYWRkKHByaW1pdGl2ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBoaWRlKC4uLnByaW1pdGl2ZXMpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IHByaW1pdGl2ZSBvZiBwcmltaXRpdmVzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Zpc2libGVQcmltaXRpdmVzLmRlbGV0ZShwcmltaXRpdmUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9pc0FsbG93ZWRUb1Nob3dQcmltaXRpdmUocHJpbWl0aXZlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaW1pdGl2ZVNldC5oYXMocHJpbWl0aXZlKTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBmaWx0ZXJJdGVyYWJsZSB9IGZyb20gJy4uLy4uL3V0aWwvaXRlcmFibGUnO1xyXG5pbXBvcnQgRGlzYXBwZWFyaW5nUHJpbWl0aXZlU2V0U3RvcmFnZSBmcm9tICcuL2Rpc2FwcGVhcmluZ19wcmltaXRpdmVfc2V0X3N0b3JhZ2UnO1xyXG4vKipcclxuICogUHJpbWl0aXZlIHN0b3JhZ2UgdGhhdCBzdG9yZXMgcHJpbWl0aXZlIGluIGEgc2V0LiBJdCBhY3RzIGFzIGEgcHJpbWl0aXZlIHByb3ZpZGVyIGFzIHdlbGwuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZWxheWVkRGlzYXBwZWFyaW5nUHJpbWl0aXZlU2V0U3RvcmFnZSBleHRlbmRzIERpc2FwcGVhcmluZ1ByaW1pdGl2ZVNldFN0b3JhZ2Uge1xyXG4gICAgY29uc3RydWN0b3IoYXBwZWFyaW5nRWZmZWN0RHVyYXRpb24pIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX2FwcGVhcmluZ0VmZmVjdER1cmF0aW9uID0gYXBwZWFyaW5nRWZmZWN0RHVyYXRpb247XHJcbiAgICAgICAgdGhpcy5fc2NoZWR1bGVkUmVtb3ZlcyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLl90aW1lb3V0SWRzID0gbmV3IFNldCgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHByaW1pdGl2ZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaW1pdGl2ZVNldDtcclxuICAgIH1cclxuICAgIGFkZCguLi5wcmltaXRpdmVzKSB7XHJcbiAgICAgICAgLy8gcHJpbWl0aXZlcyB0aGF0IGFyZSBzY2hlZHVsZWQgZm9yIHJlbW92aW5nIHdhcyBub3QgcmVtb3ZlZCBcInBoeXNpY2FsbHlcIiwgdGhhdCBpcyB3aHlcclxuICAgICAgICAvLyB0aGV5IHNob3VsZCBiZSBmaWx0ZXJlZCBvdXQgdG8gcHJldmVudCBtdWx0aXBsZSBhZGRpbmcgb2YgdGhlIHNhbWUgcHJpbWl0aXZlIGluIHBhcmVudFxyXG4gICAgICAgIGNvbnN0IG5vdFNjaGVkdWxlZEZvclJlbW92ZVByaW1pdGl2ZXMgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IHByaW1pdGl2ZSBvZiBwcmltaXRpdmVzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByaW1pdGl2ZXNUb0RlbGV0ZSA9IHRoaXMuX3NjaGVkdWxlZFJlbW92ZXMuZ2V0KHByaW1pdGl2ZSk7XHJcbiAgICAgICAgICAgIGlmIChwcmltaXRpdmVzVG9EZWxldGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgcHJpbWl0aXZlIGlzIHNjaGVkdWxlZCBmb3IgcmVtb3ZpbmcgaXQgaXMgZGVsZXRlZCBmcm9tIGl0cyBiYXRjaCxcclxuICAgICAgICAgICAgICAgIC8vIHRodXMgY2FuY2VsaW5nIHRoZSByZW1vdmluZyBpbiB0aGUgY2FsbGJhY2tcclxuICAgICAgICAgICAgICAgIHByaW1pdGl2ZXNUb0RlbGV0ZS5kZWxldGUocHJpbWl0aXZlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NjaGVkdWxlZFJlbW92ZXMuZGVsZXRlKHByaW1pdGl2ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBub3RTY2hlZHVsZWRGb3JSZW1vdmVQcmltaXRpdmVzLnB1c2gocHJpbWl0aXZlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBzdXBlci5hZGQoLi4ubm90U2NoZWR1bGVkRm9yUmVtb3ZlUHJpbWl0aXZlcyk7XHJcbiAgICAgICAgdGhpcy5zaG93KC4uLm5vdFNjaGVkdWxlZEZvclJlbW92ZVByaW1pdGl2ZXMpO1xyXG4gICAgfVxyXG4gICAgZGVsZXRlKC4uLnByaW1pdGl2ZXMpIHtcclxuICAgICAgICB0aGlzLmhpZGUoLi4ucHJpbWl0aXZlcyk7XHJcbiAgICAgICAgLy8gcHJpbWl0aXZlcyBhcmUgYmF0Y2hlZCBpbiBhIHNldCB0byBiZSBkZWxldGVkIGluIG9uZSBzZXRUaW1lb3V0IGNhbGxiYWNrIGZvciBwZXJmb3JtYW5jZSxcclxuICAgICAgICAvLyBmaWx0ZXIgb3V0IHByaW1pdGl2ZXMgd2hpY2ggcmVtb3Zpbmcgd2FzIGFscmVhZHkgc2NoZWR1bGVkXHJcbiAgICAgICAgY29uc3QgcHJpbWl0aXZlc1RvRGVsZXRlID0gbmV3IFNldChmaWx0ZXJJdGVyYWJsZShwcmltaXRpdmVzLCAocHJpbWl0aXZlKSA9PiAhdGhpcy5fc2NoZWR1bGVkUmVtb3Zlcy5oYXMocHJpbWl0aXZlKSkpO1xyXG4gICAgICAgIGlmIChwcmltaXRpdmVzVG9EZWxldGUuc2l6ZSA+IDApIHtcclxuICAgICAgICAgICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBwcmltaXRpdmVzVG9EZWxldGUgY29udGFpbnMgcmVsZXZhbnQgZm9yIHJlbW92aW5nIHByaW1pdGl2ZXMsIGl0IGNhbiBiZSB1cGRhdGVkIGluIHRoZSBhZGQoKSBtZXRob2RcclxuICAgICAgICAgICAgICAgIC8vIGlmIGEgcHJpbWl0aXZlIGlzIGFkZGVkIGJhY2ssIHRodXMsIGluIGZhY3QsIGNhbmNlbGluZyByZW1vdmluZyBvZiB0aGlzIHNwZWNpZmljIHByaW1pdGl2ZVxyXG4gICAgICAgICAgICAgICAgc3VwZXIuZGVsZXRlKC4uLnByaW1pdGl2ZXNUb0RlbGV0ZSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHByaW1pdGl2ZSBvZiBwcmltaXRpdmVzVG9EZWxldGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zY2hlZHVsZWRSZW1vdmVzLmRlbGV0ZShwcmltaXRpdmUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fdGltZW91dElkcy5kZWxldGUodGltZW91dElkKTtcclxuICAgICAgICAgICAgfSwgdGhpcy5fYXBwZWFyaW5nRWZmZWN0RHVyYXRpb24pO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByaW1pdGl2ZSBvZiBwcmltaXRpdmVzVG9EZWxldGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NjaGVkdWxlZFJlbW92ZXMuc2V0KHByaW1pdGl2ZSwgcHJpbWl0aXZlc1RvRGVsZXRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl90aW1lb3V0SWRzLmFkZCh0aW1lb3V0SWQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCB0aW1lb3V0SWQgb2YgdGhpcy5fdGltZW91dElkcykge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfaXNBbGxvd2VkVG9TaG93UHJpbWl0aXZlKHByaW1pdGl2ZSkge1xyXG4gICAgICAgIHJldHVybiBzdXBlci5faXNBbGxvd2VkVG9TaG93UHJpbWl0aXZlKHByaW1pdGl2ZSkgJiYgIXRoaXMuX3NjaGVkdWxlZFJlbW92ZXMuaGFzKHByaW1pdGl2ZSk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IFJlbmRlcmFibGVQcmltaXRpdmVNYW5hZ2VyIGZyb20gJy4vcmVuZGVyYWJsZV9wcmltaXRpdmVfbWFuYWdlcic7XHJcbmltcG9ydCB7IG1hcEl0ZXJhYmxlLCBmaWx0ZXJJdGVyYWJsZSB9IGZyb20gJy4uLy4uLy4uL3V0aWwvaXRlcmFibGUnO1xyXG4vKipcclxuICogSXQgaXMgcmVxdWlyZWQgdG8gaGlkZSBzb21lIHByaW1pdGl2ZXMgKHRoYXQgZG9uJ3Qgc2NhbGUgd2l0aCB6b29tLCBlLmcuIGxhYmVscyBvciBpY29ucykgYnkgXCJ0b28gaXJyZWxldmFudFwiIHpvb20sXHJcbiAqIHRvIHByZXZlbnQgbWVzcyBvZiBjb2xsYXBzZWQgb2JqZWN0cyBvbiB0aGUgc2NyZWVuLiBUaGlzIHByaW1pdGl2ZSBtYW5hZ2VyIGlzIGEgdGVtcG9yYXJ5IHNvbHV0aW9uLFxyXG4gKiBwcm9wZXIgaGFuZGxpbmcgb2Ygem9vbSBzbGljZXMgd2lsbCByZXBsYWNlIGl0LlxyXG4gKi9cclxuLy8gVE9ETzogdGhpcyBtYW5hZ2VyIGlzIGEgdG1wIHNvbHV0aW9uLCBjb3JyZWN0IGhhbmRsaW5nIG9mIHpvb20gc2xpY2VzIGlzIGdvaW5nIHRvIHJlcGxhY2UgaXRcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgWm9vbUZpbHRlcmFibGVQcmltaXRpdmVNYW5hZ2VyIGV4dGVuZHMgUmVuZGVyYWJsZVByaW1pdGl2ZU1hbmFnZXIge1xyXG4gICAgY29uc3RydWN0b3IocHJpbWl0aXZlc1N0b3JhZ2UsIGNhbWVyYSkge1xyXG4gICAgICAgIHN1cGVyKHByaW1pdGl2ZXNTdG9yYWdlKTtcclxuICAgICAgICB0aGlzLl9kaXNhcHBlYXJpbmdQcmltaXRpdmVzU3RvcmFnZSA9IHByaW1pdGl2ZXNTdG9yYWdlO1xyXG4gICAgICAgIHRoaXMuX2NhbWVyYSA9IGNhbWVyYTtcclxuICAgICAgICB0aGlzLl9wcmltaXRpdmVzID0gbmV3IFNldCgpO1xyXG4gICAgICAgIHRoaXMuX3ByZXZab29tID0gY2FtZXJhLnpvb207XHJcbiAgICAgICAgdGhpcy5fem9vbVVwZGF0ZUxpc3RlbmVyID0gdGhpcy5fb25ab29tVXBkYXRlZC5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX2NhbWVyYS5vblVwZGF0ZS5hZGRMaXN0ZW5lcih0aGlzLl96b29tVXBkYXRlTGlzdGVuZXIpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlU2NlbmUodG9TaG93LCB0b0hpZGUpIHtcclxuICAgICAgICAvLyBzYXZlIHByaW1pdGl2ZXMgdG8gZmlsdGVyIHRoZW0gbGF0ZXJcclxuICAgICAgICBzdXBlci51cGRhdGVTY2VuZShtYXBJdGVyYWJsZSh0b1Nob3csIChwcmltaXRpdmUpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fcHJpbWl0aXZlcy5hZGQocHJpbWl0aXZlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByaW1pdGl2ZTtcclxuICAgICAgICB9KSwgbWFwSXRlcmFibGUodG9IaWRlLCAocHJpbWl0aXZlKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX3ByaW1pdGl2ZXMuZGVsZXRlKHByaW1pdGl2ZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBwcmltaXRpdmU7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBhZGRlZCBwcmltaXRpdmVzIHRoYXQgY291bGQgYmUgcmVtb3ZlZCBieSB6b29tIHJlc3RyaWN0aW9uc1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZVpvb21WaXNpYmlsaXR5KCk7XHJcbiAgICB9XHJcbiAgICBfb25ab29tVXBkYXRlZCgpIHtcclxuICAgICAgICBpZiAodGhpcy5fcHJldlpvb20gIT09IHRoaXMuX2NhbWVyYS56b29tKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVpvb21WaXNpYmlsaXR5KCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3ByZXZab29tID0gdGhpcy5fY2FtZXJhLnpvb207XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3VwZGF0ZVpvb21WaXNpYmlsaXR5KCkge1xyXG4gICAgICAgIGNvbnN0IHpvb20gPSB0aGlzLl9jYW1lcmEuem9vbTtcclxuICAgICAgICB0aGlzLl9kaXNhcHBlYXJpbmdQcmltaXRpdmVzU3RvcmFnZS5zaG93KC4uLmZpbHRlckl0ZXJhYmxlKHRoaXMuX3ByaW1pdGl2ZXMsICh7IG1pblpvb20gfSkgPT4gem9vbSA+PSBtaW5ab29tKSk7XHJcbiAgICAgICAgdGhpcy5fZGlzYXBwZWFyaW5nUHJpbWl0aXZlc1N0b3JhZ2UuaGlkZSguLi5maWx0ZXJJdGVyYWJsZSh0aGlzLl9wcmltaXRpdmVzLCAoeyBtaW5ab29tIH0pID0+IHpvb20gPCBtaW5ab29tKSk7XHJcbiAgICB9XHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMuX2NhbWVyYS5vblVwZGF0ZS5yZW1vdmVMaXN0ZW5lcih0aGlzLl96b29tVXBkYXRlTGlzdGVuZXIpO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IFRpbGVQcm92aWRlck1lc3NhZ2VUeXBlIH0gZnJvbSAnLi4vd29ya2VyL3RpbGVfcHJvdmlkZXJfd29ya2VyX21lc3NhZ2VzJztcclxuaW1wb3J0IE1lbW9yeVN1YkNodW5rIGZyb20gJy4uLy4uLy4uL3JlbmRlci9tZW1vcnkvc3ViX2NodW5rJztcclxuaW1wb3J0IE1vZGVsQnVmZmVyV3JpdGVyIGZyb20gJy4uLy4uLy4uL3ByaW1pdGl2ZS9tb2RlbC9tb2RlbF9idWZmZXJfd3JpdGVyJztcclxuaW1wb3J0IFByaW1pdGl2ZU1hbmFnZXIgZnJvbSAnLi9wcmltaXRpdmVfbWFuYWdlcic7XHJcbmltcG9ydCBSZW5kZXJhYmxlTW9kZWwgZnJvbSAnLi4vLi4vLi4vcHJpbWl0aXZlL21vZGVsL3JlbmRlcmFibGVfbW9kZWwnO1xyXG5pbXBvcnQgeyBOT19JRCB9IGZyb20gJy4uLy4uLy4uL3V0aWwvd29ya2VyJztcclxuLyoqXHJcbiAqIEV4dGVybmFsIG1lc2hlcyBjb21lIGluIHBvbHlnb25zIChraW5kIG9mIGJ1aWxkaW5nIG91dGxpbmVzKS4gVGhpcyBtYW5hZ2VyIGNvbnRyb2xzIHF1ZXJpbmcgZXh0ZXJuYWwgbWVzaGVzXHJcbiAqIGFjY29yZGluZyB0byBhZGRlZCBwb2x5Z29ucywgYXMgbWFueSBvZiB0aGVtIGNhbiBzaGFyZSB0aGUgc2FtZSBtZXNoICh1c3VhbGx5IGFjcm9zcyBtdWx0aXBsZSB0aWxlcykuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFeHRlcm5hbE1lc2hQcmltaXRpdmVNYW5hZ2VyIGV4dGVuZHMgUHJpbWl0aXZlTWFuYWdlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihwcmltaXRpdmVzU3RvcmFnZSwgZ2VvbWV0cnlQcm92aWRlciwgbWVtb3J5TWFuYWdlcikge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fcHJpbWl0aXZlc1N0b3JhZ2UgPSBwcmltaXRpdmVzU3RvcmFnZTtcclxuICAgICAgICB0aGlzLl90aWxlUHJvdmlkZXIgPSBnZW9tZXRyeVByb3ZpZGVyO1xyXG4gICAgICAgIHRoaXMuX21lbW9yeU1hbmFnZXIgPSBtZW1vcnlNYW5hZ2VyO1xyXG4gICAgICAgIHRoaXMuX2V4dGVybmFsTWVzaGVzID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlU2NlbmUodG9TaG93LCB0b0hpZGUpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IHByaW1pdGl2ZSBvZiB0b1Nob3cpIHtcclxuICAgICAgICAgICAgdGhpcy5fYWRkUHJpbWl0aXZlKHByaW1pdGl2ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3QgcHJpbWl0aXZlIG9mIHRvSGlkZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVQcmltaXRpdmUocHJpbWl0aXZlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfYWRkUHJpbWl0aXZlKHByaW1pdGl2ZSkge1xyXG4gICAgICAgIGNvbnN0IGlkID0gZ2V0RnVsbE1lc2hJZChwcmltaXRpdmUpO1xyXG4gICAgICAgIGxldCBleHRlcm5hbCA9IHRoaXMuX2V4dGVybmFsTWVzaGVzLmdldChpZCk7XHJcbiAgICAgICAgaWYgKCFleHRlcm5hbCkge1xyXG4gICAgICAgICAgICBleHRlcm5hbCA9IHtcclxuICAgICAgICAgICAgICAgIHZpc2libGVQb2x5Z29uczogbmV3IFNldCgpLFxyXG4gICAgICAgICAgICAgICAgaXNWaXNpYmxlOiBmYWxzZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLl9leHRlcm5hbE1lc2hlcy5zZXQoaWQsIGV4dGVybmFsKTtcclxuICAgICAgICAgICAgdGhpcy5fdGlsZVByb3ZpZGVyLnJlcXVlc3Qoe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGUuTUVTSF9SRVFVRVNULFxyXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiBUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZS5NRVNIX1JFU1BPTlNFLFxyXG4gICAgICAgICAgICAgICAgZXJyb3JUeXBlOiBUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZS5NRVNIX0VSUk9SLFxyXG4gICAgICAgICAgICAgICAgbWVzaDogcHJpbWl0aXZlLFxyXG4gICAgICAgICAgICAgICAgcmVxdWVzdElkOiBOT19JRFxyXG4gICAgICAgICAgICB9KS50aGVuKChyZXNwb25zZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZXh0ZXJuYWwgPSB0aGlzLl9leHRlcm5hbE1lc2hlcy5nZXQoaWQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGV4dGVybmFsICYmICFleHRlcm5hbC5pc1Zpc2libGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2NhdGlvbiA9IHJlc3BvbnNlLmxvY2F0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rcyA9IHJlc3BvbnNlLnBhZ2VzLm1hcCgocGFnZSkgPT4gdGhpcy5fbWVtb3J5TWFuYWdlci5hbGxvY2F0ZShwYWdlLnZlcnRleEJ1ZmZlciwgcGFnZS5pbmRleEJ1ZmZlciwgTW9kZWxCdWZmZXJXcml0ZXIuQVRUUklCVVRFX01BUFBJTkcpKTtcclxuICAgICAgICAgICAgICAgICAgICBleHRlcm5hbC5tZXNoID0gbmV3IFJlbmRlcmFibGVNb2RlbChuZXcgTWVtb3J5U3ViQ2h1bmsoY2h1bmtzW2xvY2F0aW9uLmJ1ZmZlckluZGV4XSwgbG9jYXRpb24pKTtcclxuICAgICAgICAgICAgICAgICAgICBleHRlcm5hbC5pc1Zpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ByaW1pdGl2ZXNTdG9yYWdlLmFkZChleHRlcm5hbC5tZXNoKTtcclxuICAgICAgICAgICAgICAgICAgICBjaHVua3MuZm9yRWFjaCgoY2h1bmspID0+IGNodW5rLnJlbGVhc2UoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBleHRlcm5hbC52aXNpYmxlUG9seWdvbnMuYWRkKHByaW1pdGl2ZSk7XHJcbiAgICB9XHJcbiAgICBfcmVtb3ZlUHJpbWl0aXZlKHByaW1pdGl2ZSkge1xyXG4gICAgICAgIGNvbnN0IGlkID0gZ2V0RnVsbE1lc2hJZChwcmltaXRpdmUpO1xyXG4gICAgICAgIGNvbnN0IGV4dGVybmFsID0gdGhpcy5fZXh0ZXJuYWxNZXNoZXMuZ2V0KGlkKTtcclxuICAgICAgICBpZiAoZXh0ZXJuYWwpIHtcclxuICAgICAgICAgICAgZXh0ZXJuYWwudmlzaWJsZVBvbHlnb25zLmRlbGV0ZShwcmltaXRpdmUpO1xyXG4gICAgICAgICAgICAvLyBkZXN0cm95IGV4dGVybmFsIG1lc2ggaWYgdGhlcmUgaXMgbm8gdmlzaWJsZSBwb2x5Z29ucyByZW1haW5pbmdcclxuICAgICAgICAgICAgaWYgKGV4dGVybmFsLnZpc2libGVQb2x5Z29ucy5zaXplID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9leHRlcm5hbE1lc2hlcy5kZWxldGUoaWQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGV4dGVybmFsLm1lc2gpIHtcclxuICAgICAgICAgICAgICAgICAgICBleHRlcm5hbC5tZXNoLnJlbGVhc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcmltaXRpdmVzU3RvcmFnZS5kZWxldGUoZXh0ZXJuYWwubWVzaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXh0ZXJuYWwuaXNWaXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBubyBtZXNoIHlldCByZXR1cm5lZCBjYW5jZWwgcmVxdWVzdFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RpbGVQcm92aWRlci5zZW5kTWVzc2FnZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFRpbGVQcm92aWRlck1lc3NhZ2VUeXBlLk1FU0hfUkVRVUVTVF9DQU5DRUwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc2g6IHByaW1pdGl2ZVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldEZ1bGxNZXNoSWQobWVzaCkge1xyXG4gICAgcmV0dXJuIG1lc2gub2JqZWN0SWQgKyBtZXNoLm1lc2hJZDtcclxufVxyXG4iLCJpbXBvcnQgUmVuZGVyYWJsZVByaW1pdGl2ZSBmcm9tICcuLi9yZW5kZXJhYmxlX3ByaW1pdGl2ZSc7XHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbmRlcmFibGVCaWxsYm9hcmRSZWN0YW5nbGUgZXh0ZW5kcyBSZW5kZXJhYmxlUHJpbWl0aXZlIHtcclxufVxyXG4iLCJpbXBvcnQgUmVuZGVyYWJsZUxhYmVsIGZyb20gJy4uLy4uLy4uL3ByaW1pdGl2ZS9sYWJlbC9yZW5kZXJhYmxlX2xhYmVsJztcclxuZXhwb3J0IGNsYXNzIFpvb21SZXN0cmljdGVkTGFiZWwgZXh0ZW5kcyBSZW5kZXJhYmxlTGFiZWwge1xyXG4gICAgY29uc3RydWN0b3IobWVtb3J5U3ViQ2h1bmssIGF0bGFzLCBtaW5ab29tLCBiYWNrZ3JvdW5kKSB7XHJcbiAgICAgICAgc3VwZXIobWVtb3J5U3ViQ2h1bmssIGF0bGFzLCBiYWNrZ3JvdW5kKTtcclxuICAgICAgICB0aGlzLm1pblpvb20gPSBtaW5ab29tO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCBSZW5kZXJhYmxlUHJpbWl0aXZlIGZyb20gJy4uL3JlbmRlcmFibGVfcHJpbWl0aXZlJztcclxuLyoqXHJcbiAqIEFsbG9jYXRlZCBpbiBHUFUgbWVtb3J5IGxhYmVsLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVuZGVyYWJsZUxhYmVsIGV4dGVuZHMgUmVuZGVyYWJsZVByaW1pdGl2ZSB7XHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgcmVuZGVyYWJsZSBsYWJlbC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbWVtb3J5U3ViQ2h1bmtcclxuICAgICAqIEBwYXJhbSBhdGxhc1xyXG4gICAgICogQHBhcmFtIGJhY2tncm91bmRcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IobWVtb3J5U3ViQ2h1bmssIGF0bGFzLCBiYWNrZ3JvdW5kKSB7XHJcbiAgICAgICAgc3VwZXIobWVtb3J5U3ViQ2h1bmspO1xyXG4gICAgICAgIHRoaXMuYXRsYXMgPSBhdGxhcztcclxuICAgICAgICB0aGlzLmJhY2tncm91bmQgPSBiYWNrZ3JvdW5kO1xyXG4gICAgICAgIGlmIChiYWNrZ3JvdW5kKSB7XHJcbiAgICAgICAgICAgIGJhY2tncm91bmQucmV0YWluKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2Rlc3Ryb3koKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuYmFja2dyb3VuZCkge1xyXG4gICAgICAgICAgICB0aGlzLmJhY2tncm91bmQucmVsZWFzZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdXBlci5fZGVzdHJveSgpO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCBSZW5kZXJhYmxlSWNvbiBmcm9tICcuLi8uLi8uLi9wcmltaXRpdmUvaWNvbi9yZW5kZXJhYmxlX2ljb24nO1xyXG5leHBvcnQgY2xhc3MgWm9vbVJlc3RyaWN0ZWRJY29uIGV4dGVuZHMgUmVuZGVyYWJsZUljb24ge1xyXG4gICAgY29uc3RydWN0b3IobWVtb3J5U3ViQ2h1bmssIGFsbG9jYXRlZEltYWdlLCBtaW5ab29tKSB7XHJcbiAgICAgICAgc3VwZXIobWVtb3J5U3ViQ2h1bmssIGFsbG9jYXRlZEltYWdlKTtcclxuICAgICAgICB0aGlzLm1pblpvb20gPSBtaW5ab29tO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCBSZW5kZXJhYmxlSW1hZ2UgZnJvbSAnLi4vaW1hZ2UvcmVuZGVyYWJsZV9pbWFnZSc7XHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbmRlcmFibGVJY29uIGV4dGVuZHMgUmVuZGVyYWJsZUltYWdlIHtcclxufVxyXG4iLCJpbXBvcnQgVGV4dHVyZWRSZW5kZXJhYmxlUHJpbWl0aXZlIGZyb20gJy4uL3RleHR1cmVkX3JlbmRlcmFibGVfcHJpbWl0aXZlJztcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVuZGVyYWJsZUltYWdlIGV4dGVuZHMgVGV4dHVyZWRSZW5kZXJhYmxlUHJpbWl0aXZlIHtcclxufVxyXG4iLCJpbXBvcnQgUmVuZGVyYWJsZVByaW1pdGl2ZSBmcm9tICcuL3JlbmRlcmFibGVfcHJpbWl0aXZlJztcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGV4dHVyZWRSZW5kZXJhYmxlUHJpbWl0aXZlIGV4dGVuZHMgUmVuZGVyYWJsZVByaW1pdGl2ZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihtZW1vcnlDaHVuaywgYWxsb2NhdGVkSW1hZ2UpIHtcclxuICAgICAgICBzdXBlcihtZW1vcnlDaHVuayk7XHJcbiAgICAgICAgdGhpcy5fYWxsb2NhdGVkSW1hZ2UgPSBhbGxvY2F0ZWRJbWFnZTtcclxuICAgICAgICB0aGlzLmF0bGFzID0gYWxsb2NhdGVkSW1hZ2UuYXRsYXNNYW5hZ2VyLmF0bGFzO1xyXG4gICAgICAgIHRoaXMuX2FsbG9jYXRlZEltYWdlLnJldGFpbigpO1xyXG4gICAgfVxyXG4gICAgX2Rlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5fYWxsb2NhdGVkSW1hZ2UucmVsZWFzZSgpO1xyXG4gICAgICAgIHN1cGVyLl9kZXN0cm95KCk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IFByaW9yaXR5UWV1ZXVlIGZyb20gJy4vcHJpb3JpdHlfcXVldWUnO1xyXG5pbXBvcnQgeyBWb2lkRXZlbnRFbWl0dGVyIH0gZnJvbSAnLi4vdXRpbC9ldmVudF9lbWl0dGVyJztcclxuY29uc3QgREVRVUVVRV9USU1FT1VUID0gMTsgLy8gbXNcclxuLyoqXHJcbiAqIFByaW9yaXRpemVkIHRhc2sgcXVldWUuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUYXNrUXVldWUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb25zdHJ1Y3RzIGFuIGVtcHR5IHRhc2sgcXVldWUuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuX3F1ZXVlID0gbmV3IFByaW9yaXR5UWV1ZXVlKCk7XHJcbiAgICAgICAgdGhpcy5fZnJvemVuID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fZGVxdWV1ZVRpbWVvdXRIYW5kbGUgPSAwO1xyXG4gICAgICAgIHRoaXMub25FbXB0eSA9IG5ldyBWb2lkRXZlbnRFbWl0dGVyKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERlc3Ryb3lzIHRoZSBxdWV1ZS4gQW55IHJlbWFpbmluZyB0YXNrcyB3b24ndCBiZSBleGVjdXRlZC5cclxuICAgICAqL1xyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fZGVxdWV1ZVRpbWVvdXRIYW5kbGUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFbnF1ZXVlcyBhIHRhc2sgdG8gdGhlIHF1ZXVlIGFuZCBzY2hlZHVsZXMgcHJvY2Vzc2luZyBvZiB0aGUgcXVldWUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRhc2sgVGhlIHRhc2suXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHRoYXQgd2lsbCBiZSBmdWxsZmlsbGVkIHdoZW4gdGhlIHRhc2sgc3VjY2Vzc2Z1bGx5XHJcbiAgICAgKiAgICAgIGZpbmlzaGVzIG9yIHJlamVjdGVkIGlmIHRoZXJlJ3MgYW4gZXJyb3IuXHJcbiAgICAgKi9cclxuICAgIGVucXVldWUodGFzaykge1xyXG4gICAgICAgIGlmICghdGhpcy5fZnJvemVuKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldERlcXVldWVUaW1lb3V0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX3F1ZXVlLmVucXVldWUoe1xyXG4gICAgICAgICAgICAgICAgZXhlY3V0ZSgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrLmV4ZWN1dGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgcHJpb3JpdHk6IHRhc2sucHJpb3JpdHlcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpc0VtcHR5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9xdWV1ZS5pc0VtcHR5KCk7XHJcbiAgICB9XHJcbiAgICBmcmVlemUoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2RlcXVldWVUaW1lb3V0SGFuZGxlKSB7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9kZXF1ZXVlVGltZW91dEhhbmRsZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2RlcXVldWVUaW1lb3V0SGFuZGxlID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZnJvemVuID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHVuZnJlZXplKCkge1xyXG4gICAgICAgIHRoaXMuX2Zyb3plbiA9IGZhbHNlO1xyXG4gICAgICAgIGlmICghdGhpcy5fcXVldWUuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldERlcXVldWVUaW1lb3V0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2RlcXVldWUoKSB7XHJcbiAgICAgICAgY29uc3QgdGFzayA9IHRoaXMuX3F1ZXVlLmRlcXVldWUoKTtcclxuICAgICAgICBpZiAodGFzaykge1xyXG4gICAgICAgICAgICB0YXNrLmV4ZWN1dGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX3F1ZXVlLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9kZXF1ZXVlVGltZW91dEhhbmRsZSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMub25FbXB0eS5maXJlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9kZXF1ZXVlVGltZW91dEhhbmRsZSA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5fZGVxdWV1ZSgpLCBERVFVRVVFX1RJTUVPVVQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9zZXREZXF1ZXVlVGltZW91dCgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2RlcXVldWVUaW1lb3V0SGFuZGxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RlcXVldWVUaW1lb3V0SGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLl9kZXF1ZXVlKCksIERFUVVFVUVfVElNRU9VVCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IERlbGVnYXRvckJhc2UgfSBmcm9tICcuLi8uLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9kZWxlZ2F0b3InO1xyXG5pbXBvcnQgKiBhcyB2ZWMyIGZyb20gJy4uLy4uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9tYXRoL3ZlY3RvcjInO1xyXG5leHBvcnQgY2xhc3MgTW91c2VEcmFnQ29udHJvbGxlciBleHRlbmRzIERlbGVnYXRvckJhc2Uge1xyXG4gICAgY29uc3RydWN0b3IodGFyZ2V0KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgdGhpcy5fcHJlc3NlZEJ1dHRvbiA9IC0xIC8qIE5PTkUgKi87XHJcbiAgICAgICAgdGhpcy5fcHJldk1vdXNlQ29vcmRzID0gdmVjMi5jcmVhdGUoMCwgMCk7XHJcbiAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMpO1xyXG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMpO1xyXG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHRoaXMpO1xyXG4gICAgfVxyXG4gICAgaGFuZGxlRXZlbnQoZSkge1xyXG4gICAgICAgIHN3aXRjaCAoZS50eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ2NsaWNrJzpcclxuICAgICAgICAgICAgY2FzZSAnY29udGV4dG1lbnUnOlxyXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ21vdXNlZG93bic6XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcHJlc3NlZEJ1dHRvbiA9PT0gLTEgLyogTk9ORSAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ByZXNzZWRCdXR0b24gPSBlLmJ1dHRvbjtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcmV2TW91c2VDb29yZHMueCA9IGUuY2xpZW50WDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcmV2TW91c2VDb29yZHMueSA9IGUuY2xpZW50WTtcclxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ21vdXNlbW92ZSc6XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZGVsZWdhdGUgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IG1vdXNlQ29vcmRzID0gdmVjMi5jcmVhdGUoZS5jbGllbnRYLCBlLmNsaWVudFkpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGVsdGEgPSB2ZWMyLnN1Yihtb3VzZUNvb3JkcywgdGhpcy5fcHJldk1vdXNlQ29vcmRzKTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fcHJlc3NlZEJ1dHRvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMCAvKiBMRUZUICovOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWxlZ2F0ZS5vbkxlZnRCdXR0b25EcmFnKGRlbHRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxIC8qIE1JRERMRSAqLzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVsZWdhdGUub25NaWRkbGVCdXR0b25EcmFnKGRlbHRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyIC8qIFJJR0hUICovOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWxlZ2F0ZS5vblJpZ2h0QnV0dG9uRHJhZyhkZWx0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmVjMi5jb3B5KG1vdXNlQ29vcmRzLCB0aGlzLl9wcmV2TW91c2VDb29yZHMpO1xyXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ21vdXNldXAnOlxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3ByZXNzZWRCdXR0b24gPT09IGUuYnV0dG9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcmVzc2VkQnV0dG9uID0gLTEgLyogTk9ORSAqLztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5fdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgdGhpcyk7XHJcbiAgICAgICAgdGhpcy5fdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcyk7XHJcbiAgICAgICAgdGhpcy5fdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBTY3JvbGxab29tQ29udHJvbGxlciBleHRlbmRzIERlbGVnYXRvckJhc2Uge1xyXG4gICAgY29uc3RydWN0b3IodGFyZ2V0KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3doZWVsJywgdGhpcyk7XHJcbiAgICB9XHJcbiAgICBoYW5kbGVFdmVudChlKSB7XHJcbiAgICAgICAgY29uc3QgZGVsZWdhdGUgPSB0aGlzLl9kZWxlZ2F0ZTtcclxuICAgICAgICBpZiAoIWRlbGVnYXRlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGUuZGVsdGFZIDwgMCkge1xyXG4gICAgICAgICAgICBkZWxlZ2F0ZS5vblNjcm9sbEluKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkZWxlZ2F0ZS5vblNjcm9sbE91dCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICB9XHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMuX3RhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCd3aGVlbCcsIHRoaXMpO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IFpPT01fU1RFUCA9IDAuMTtcclxuY29uc3QgVElMVF9BWklNVVRIX0ZBQ1RPUiA9IE1hdGguUEkgLyAxMDI0O1xyXG5leHBvcnQgY2xhc3MgQ2FtZXJhTW91c2VDb250cm9sbGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGNhbnZhcywgY2FtZXJhKSB7XHJcbiAgICAgICAgdGhpcy5fY2FtZXJhID0gY2FtZXJhO1xyXG4gICAgICAgIHRoaXMuX2NhbnZhc1NpemUgPSB2ZWMyLmNyZWF0ZShjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuZHJhZ0ZhY3RvciA9IDE7XHJcbiAgICB9XHJcbiAgICBvbkxlZnRCdXR0b25EcmFnKGRlbHRhKSB7XHJcbiAgICAgICAgLy8gVGhhdCdzIG5vdCBleGFjdCwgYnV0IGdvb2QgZW5vdWdoIGZvciBub3cuXHJcbiAgICAgICAgdmVjMi5kaXZ2KGRlbHRhLCB0aGlzLl9jYW52YXNTaXplLCBkZWx0YSk7XHJcbiAgICAgICAgY29uc3QgY2FtZXJhID0gdGhpcy5fY2FtZXJhO1xyXG4gICAgICAgIHZlYzIubXVsbihkZWx0YSwgdGhpcy5kcmFnRmFjdG9yICogY2FtZXJhLnNjcmVlblNpemUuaGVpZ2h0ICogTWF0aC5wb3coMiwgLWNhbWVyYS56b29tKSAvXHJcbiAgICAgICAgICAgIChNYXRoLnRhbigwLjUgKiBjYW1lcmEub3B0aW9ucy5mb3YpICogNjQpLCBkZWx0YSk7XHJcbiAgICAgICAgY29uc3QgY2VudGVyID0gdGhpcy5fY2FtZXJhLmNlbnRlcjtcclxuICAgICAgICBjZW50ZXIueCAtPSBkZWx0YS54O1xyXG4gICAgICAgIGNlbnRlci55ICs9IGRlbHRhLnk7XHJcbiAgICAgICAgdGhpcy5fY2FtZXJhLnNldERpcnR5KCk7XHJcbiAgICB9XHJcbiAgICBvbk1pZGRsZUJ1dHRvbkRyYWcoKSB7IH1cclxuICAgIG9uUmlnaHRCdXR0b25EcmFnKGRlbHRhKSB7XHJcbiAgICAgICAgY29uc3QgY2FtZXJhID0gdGhpcy5fY2FtZXJhO1xyXG4gICAgICAgIGNhbWVyYS50aWx0ICs9IGRlbHRhLnkgKiBUSUxUX0FaSU1VVEhfRkFDVE9SO1xyXG4gICAgICAgIGNhbWVyYS5hemltdXRoICs9IGRlbHRhLnggKiBUSUxUX0FaSU1VVEhfRkFDVE9SO1xyXG4gICAgICAgIHRoaXMuX2NhbWVyYS5zZXREaXJ0eSgpO1xyXG4gICAgfVxyXG4gICAgb25TY3JvbGxJbigpIHtcclxuICAgICAgICB0aGlzLl9jYW1lcmEuem9vbSArPSBaT09NX1NURVA7XHJcbiAgICAgICAgdGhpcy5fY2FtZXJhLnNldERpcnR5KCk7XHJcbiAgICB9XHJcbiAgICBvblNjcm9sbE91dCgpIHtcclxuICAgICAgICB0aGlzLl9jYW1lcmEuem9vbSAtPSBaT09NX1NURVA7XHJcbiAgICAgICAgdGhpcy5fY2FtZXJhLnNldERpcnR5KCk7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgY2FtZXJhU3RhdGVFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2NhbWVyYV9zdGF0ZScpO1xyXG5jb25zdCBjYW1lcmFTdGF0ZVRleHQgPSBjYW1lcmFTdGF0ZUVsZW1lbnQgJiYgY2FtZXJhU3RhdGVFbGVtZW50LmZpcnN0Q2hpbGQ7XHJcbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJDYW1lcmFTdGF0ZShjYW1lcmEpIHtcclxuICAgIGNvbnN0IHsgY2VudGVyOiB7IHgsIHkgfSwgem9vbSwgdGlsdCwgYXppbXV0aCB9ID0gY2FtZXJhO1xyXG4gICAgY2FtZXJhU3RhdGVUZXh0LnJlcGxhY2VEYXRhKDAsIGNhbWVyYVN0YXRlVGV4dC5sZW5ndGgsIGBjZW50ZXI6ICgke3gudG9GaXhlZCg4KX0sJHt5LnRvRml4ZWQoOCl9KTsgem9vbTogJHt6b29tLnRvRml4ZWQoNCl9OyBgICtcclxuICAgICAgICBgdGlsdDogJHt0aWx0LnRvRml4ZWQoNCl9OyBhemltdXRoOiAke2F6aW11dGgudG9GaXhlZCg0KX1gKTtcclxufVxyXG4iLCJleHBvcnQgY2xhc3MgRGVsZWdhdG9yQmFzZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLl9kZWxlZ2F0ZSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBzZXREZWxlZ2F0ZShkZWxlZ2F0ZSkge1xyXG4gICAgICAgIHRoaXMuX2RlbGVnYXRlID0gZGVsZWdhdGU7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHBvaW50TGFiZWxWZXJ0ZXhTaGFkZXIgZnJvbSAnLi9zaGFkZXIvcG9pbnRfbGFiZWwudmVydCc7XHJcbmltcG9ydCBjb2xvcklkRnJhZ21lbnRTaGFkZXIgZnJvbSAnLi9zaGFkZXIvY29sb3JfaWQuZnJhZyc7XHJcbmltcG9ydCBDb2xsaWRpbmdMYWJlbENvbG9ySWRSZW5kZXJlciBmcm9tICcuL2NvbG9yX2lkX2xhYmVsX3JlbmRlcmVyJztcclxuaW1wb3J0IHsgUFJPR1JBTV9PUFRJT05TIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyL3ByaW1pdGl2ZXMvbGFiZWwvcG9pbnRfbGFiZWxfcmVuZGVyX3VuaXQnO1xyXG4vKipcclxuICogUG9pbnQgbGFiZWxzIHJlbmRlcmVyIGZvciBjb2xsaXNpb24gcmVzb2x1dGlvbi5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbG9ySWRQb2ludExhYmVsUmVuZGVyZXIgZXh0ZW5kcyBDb2xsaWRpbmdMYWJlbENvbG9ySWRSZW5kZXJlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBjYW1lcmEsIHByaW1pdGl2ZVByb3ZpZGVyKSB7XHJcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IGNvbnRleHQuY3JlYXRlUHJvZ3JhbShwb2ludExhYmVsVmVydGV4U2hhZGVyLCBjb2xvcklkRnJhZ21lbnRTaGFkZXIsIFBST0dSQU1fT1BUSU9OUyk7XHJcbiAgICAgICAgc3VwZXIoY29udGV4dCwgcHJvZ3JhbSwgcHJpbWl0aXZlUHJvdmlkZXIsIGNhbWVyYSk7XHJcbiAgICB9XHJcbn1cclxuIiwibW9kdWxlLmV4cG9ydHMgPSBcIiN2ZXJzaW9uIDEwMFxcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxuYXR0cmlidXRlIHZlYzIgdmVydGV4SWQ7XFxuXFxuLy8gcG9pbnQgaW4gdGhlIHdvcmxkIHRoZSBsYWJlbCBpcyBhbmNob3JlZCB0b1xcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleFBvc0hpZ2g7XFxuYXR0cmlidXRlIHZlYzIgdmVydGV4UG9zTG93O1xcblxcbi8vIHZlY3RvciBvZiBjb25jcmV0ZSBnbHlwaCBwb2ludCBkaXNwbGFjZW1lbnQgKHRvcC1sZWZ0LCBib3R0b20tbGVmdCwgLi4uKSByZWxhdGl2ZSB0byBsYWJlbCdzIGNlbnRlciwgaW4gcHhcXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhEaXNwbGFjZW1lbnQ7XFxuXFxuLy8gY29vcmRpbmF0ZXMgb2YgdGhlIGdseXBoIHZlcnRleCBpbiB0aGUgYXRsYXNcXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhVVjtcXG5cXG5hdHRyaWJ1dGUgZmxvYXQgdmVydGV4UHJpb3JpdHk7XFxuXFxudW5pZm9ybSB2ZWMyIGxvb2tBdEhpZ2g7XFxudW5pZm9ybSB2ZWMyIGxvb2tBdExvdztcXG51bmlmb3JtIG1hdDQgdmlld1Byb2pNYXRyaXg7XFxudW5pZm9ybSB2ZWMyIHBpeGVsU2l6ZTtcXG51bmlmb3JtIHNhbXBsZXIyRCB2aXNpYmlsaXR5O1xcbnVuaWZvcm0gdmVjMiBpZEhhbGZQeFNpemU7XFxudW5pZm9ybSB2ZWMyIHNoaWZ0O1xcbnVuaWZvcm0gbG93cCBmbG9hdCBjdXJyZW50Wm9vbTtcXG5cXG52YXJ5aW5nIHZlYzIgdXY7XFxudmFyeWluZyBsb3dwIHZlYzQgY29sb3I7XFxudmFyeWluZyBsb3dwIHZlYzQgb3V0bGluZUNvbG9yO1xcbnZhcnlpbmcgbWVkaXVtcCBmbG9hdCBzY2FsZTtcXG5cXG5jb25zdCB2ZWM0IERJU0NBUkRfUE9TSVRJT04gPSB2ZWM0KDIsIDIsIDIsIDEpO1xcblxcbmNvbnN0IGZsb2F0IFlWX0hfMV8wID0gMS45OTk5Njk0ODI0MjE4NzU7XFxuY29uc3QgZmxvYXQgWVZfTF8xXzEgPSAwLjAwMDAzMDUxNzExMjQ2MzcxMjY5MjtcXG5cXG4vKipcXG4gKiBQcm9qZWN0cyBzcGVjaWZpYyBwb2ludCBsYWJlbCB2ZXJ0ZXggb250byB0aGUgc2NyZWVuLlxcbiAqL1xcbnZlYzQgcHJvamVjdFBvaW50TGFiZWxWZXJ0ZXhfMV8yKFxcbiAgICBtYXQ0IHZpZXdQcm9qTWF0cml4LFxcbiAgICB2ZWMyIGxvb2tBdEhpZ2gsXFxuICAgIHZlYzIgbG9va0F0TG93LFxcbiAgICB2ZWMyIHBvc0hpZ2gsXFxuICAgIHZlYzIgcG9zTG93LFxcbiAgICB2ZWMyIGRpc3BsYWNlbWVudCxcXG4gICAgdmVjMiBweFNpemVcXG4pIHtcXG4gICAgdmVjNCBwb3NpdGlvbiA9IHZpZXdQcm9qTWF0cml4ICogdmVjNChcXG4gICAgICAgIFlWX0hfMV8wICogKHBvc0hpZ2ggLSBsb29rQXRIaWdoKSArXFxuICAgICAgICAgICAgWVZfTF8xXzEgKiAocG9zTG93IC0gbG9va0F0TG93KSxcXG4gICAgICAgIDAsXFxuICAgICAgICAxXFxuICAgICk7XFxuICAgIHBvc2l0aW9uID0gdmVjNChwb3NpdGlvbi54eSAvIHBvc2l0aW9uLncsIDAuMCwgMS4wKTtcXG5cXG4gICAgcmV0dXJuIHBvc2l0aW9uICsgdmVjNChkaXNwbGFjZW1lbnQgKiBweFNpemUsIDAuMCwgMC4wKTtcXG59XFxuXFxuXFxuXFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gICAgdmVjMiBpZFRleENvb3JkaW5hdGUgPSB2ZXJ0ZXhJZC54eSArIGlkSGFsZlB4U2l6ZTtcXG4gICAgZmxvYXQgb3ZlcmxhcFpvb20gPSB0ZXh0dXJlMkQodmlzaWJpbGl0eSwgaWRUZXhDb29yZGluYXRlKS5iO1xcbiAgICBpZiAoY3VycmVudFpvb20gPCBvdmVybGFwWm9vbSkge1xcbiAgICAgICAgZ2xfUG9zaXRpb24gPSBESVNDQVJEX1BPU0lUSU9OO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0UG9pbnRMYWJlbFZlcnRleF8xXzIoXFxuICAgICAgICAgICAgdmlld1Byb2pNYXRyaXgsXFxuICAgICAgICAgICAgbG9va0F0SGlnaCxcXG4gICAgICAgICAgICBsb29rQXRMb3csXFxuICAgICAgICAgICAgdmVydGV4UG9zSGlnaCxcXG4gICAgICAgICAgICB2ZXJ0ZXhQb3NMb3csXFxuICAgICAgICAgICAgdmVydGV4RGlzcGxhY2VtZW50LFxcbiAgICAgICAgICAgIHBpeGVsU2l6ZVxcbiAgICAgICAgKTtcXG4gICAgICAgIGdsX1Bvc2l0aW9uLnh5ICs9IHNoaWZ0O1xcbiAgICAgICAgZ2xfUG9zaXRpb24ueiA9IHZlcnRleFByaW9yaXR5O1xcbiAgICAgICAgY29sb3IgPSB2ZWM0KHZlcnRleElkLCAwLCAxKTtcXG4gICAgfVxcblxcbn1cXG5cIiIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbnZhcnlpbmcgbG93cCB2ZWM0IGNvbG9yO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbn1cXG5cIiIsImltcG9ydCB7IENvbGxpZGluZ1ByaW1pdGl2ZUNvbG9ySWRSZW5kZXJlciB9IGZyb20gJy4uL2NvbGxpZGluZ19wcmltaXRpdmVfY29sb3JfaWRfcmVuZGVyZXInO1xyXG4vKipcclxuICogXCJjb2xvciBpZFwiIHJlbmRlcmVyIGZvciBsYWJlbHMsIGJvdGggZm9yIHBvaW50IGFuZCBjdXJ2ZWQgb25lcy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbG9ySWRMYWJlbFJlbmRlcmVyIGV4dGVuZHMgQ29sbGlkaW5nUHJpbWl0aXZlQ29sb3JJZFJlbmRlcmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIHByb2dyYW0sIHByaW1pdGl2ZVByb3ZpZGVyLCBjYW1lcmEpIHtcclxuICAgICAgICBzdXBlcihjb250ZXh0LCBwcm9ncmFtLCBwcmltaXRpdmVQcm92aWRlcik7XHJcbiAgICAgICAgdGhpcy5fY2FtZXJhID0gY2FtZXJhO1xyXG4gICAgfVxyXG4gICAgX3ByZXBhcmVQcm9ncmFtKHByb2dyYW0sIHZpZXdQcm9qTWF0cml4LCBjYW1lcmFQb3NpdGlvbnMsIHN0YXRlLCBzdGFiaWxpdHlTaGlmdCwgdmlzaWJpbGl0eSwgY3VycmVudFpvb20pIHtcclxuICAgICAgICBzdXBlci5fcHJlcGFyZVByb2dyYW0ocHJvZ3JhbSwgdmlld1Byb2pNYXRyaXgsIGNhbWVyYVBvc2l0aW9ucywgc3RhdGUsIHN0YWJpbGl0eVNoaWZ0LCB2aXNpYmlsaXR5LCBjdXJyZW50Wm9vbSk7XHJcbiAgICAgICAgcHJvZ3JhbS5zZXRWZWN0b3IyVW5pZm9ybSgncGl4ZWxTaXplJywgdGhpcy5fY2FtZXJhLnBpeGVsU2l6ZSk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IFJlbmRlclN0YXRlIGZyb20gJy4uLy4uL3JlbmRlci9zdGF0ZSc7XHJcbmltcG9ydCAqIGFzIHZlYzIgZnJvbSAnLi4vLi4vbWF0aC92ZWN0b3IyJztcclxuaW1wb3J0IFdvcmxkUHJpbWl0aXZlUmVuZGVyVW5pdCBmcm9tICcuLi8uLi9yZW5kZXIvcHJpbWl0aXZlcy93b3JsZF9wcmltaXRpdmVfcmVuZGVyX3VuaXQnO1xyXG5leHBvcnQgY2xhc3MgQ29sbGlkaW5nUHJpbWl0aXZlQ29sb3JJZFJlbmRlcmVyIGV4dGVuZHMgV29ybGRQcmltaXRpdmVSZW5kZXJVbml0IHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIHByb2dyYW0sIHByaW1pdGl2ZVByb3ZpZGVyKSB7XHJcbiAgICAgICAgc3VwZXIoY29udGV4dCwgbmV3IFJlbmRlclN0YXRlKCksIHByb2dyYW0sIHByaW1pdGl2ZVByb3ZpZGVyKTtcclxuICAgICAgICB0aGlzLl9pZEhhbGZQeFNpemVVbmlmb3JtID0gdmVjMi5jcmVhdGUoMCwgMCk7XHJcbiAgICB9XHJcbiAgICBfZ2V0UHJpbWl0aXZlcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wcmltaXRpdmVQcm92aWRlci52aXNpYmxlUHJpbWl0aXZlcztcclxuICAgIH1cclxuICAgIF9wcmVwYXJlUHJvZ3JhbShwcm9ncmFtLCB2aWV3UHJvak1hdHJpeCwgY2FtZXJhUG9zaXRpb25zLCBzdGF0ZSwgc3RhYmlsaXR5U2hpZnQsIHZpc2liaWxpdHksIGN1cnJlbnRab29tKSB7XHJcbiAgICAgICAgc3VwZXIuX3ByZXBhcmVQcm9ncmFtKHByb2dyYW0sIHZpZXdQcm9qTWF0cml4LCBjYW1lcmFQb3NpdGlvbnMsIHN0YXRlLCBzdGFiaWxpdHlTaGlmdCwgdmlzaWJpbGl0eSwgY3VycmVudFpvb20pO1xyXG4gICAgICAgIHRoaXMuX2lkSGFsZlB4U2l6ZVVuaWZvcm0ueCA9IDAuNSAvIHZpc2liaWxpdHkuZ2V0V2lkdGgoKTtcclxuICAgICAgICB0aGlzLl9pZEhhbGZQeFNpemVVbmlmb3JtLnkgPSAwLjUgLyB2aXNpYmlsaXR5LmdldEhlaWdodCgpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFRleHR1cmVVbml0KDApO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFRleHR1cmUodmlzaWJpbGl0eSk7XHJcbiAgICAgICAgcHJvZ3JhbS5zZXRJbnRTY2FsYXJVbmlmb3JtKCd2aXNpYmlsaXR5JywgMCk7XHJcbiAgICAgICAgcHJvZ3JhbS5zZXRWZWN0b3IyVW5pZm9ybSgnaWRIYWxmUHhTaXplJywgdGhpcy5faWRIYWxmUHhTaXplVW5pZm9ybSk7XHJcbiAgICAgICAgcHJvZ3JhbS5zZXRWZWN0b3IyVW5pZm9ybSgnc2hpZnQnLCBzdGFiaWxpdHlTaGlmdCk7XHJcbiAgICAgICAgcHJvZ3JhbS5zZXRTY2FsYXJVbmlmb3JtKCdjdXJyZW50Wm9vbScsIGN1cnJlbnRab29tKTtcclxuICAgIH1cclxuICAgIF9wcmVwYXJlUmVuZGVyVGFyZ2V0KHRhcmdldCwgX3ZpZXdQcm9qTWF0cml4LCBfY2FtZXJhUG9zaXRpb25zLCBzdGF0ZSwgX3N0YWJpbGl0eVNoaWZ0LCBfdmlzaWJpbGl0eSwgX2N1cnJlbnRab29tKSB7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kUmVuZGVyU3RhdGUoc3RhdGUpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFJlbmRlclRhcmdldCh0YXJnZXQpO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IEdsUmVuZGVyZXIgfSBmcm9tICcuLi9nbF9yZW5kZXJlcic7XHJcbmltcG9ydCB7IGNvdW50SW5kaWNlcyB9IGZyb20gJy4uL21lbW9yeS9jb3VudF92ZXJ0aWNlcyc7XHJcbmltcG9ydCB7IGJhdGNoUHJpbWl0aXZlcyB9IGZyb20gJy4vcHJpbWl0aXZlX2JhdGNoJztcclxuLyoqXHJcbiAqIEJhc2UgY2xhc3MgZm9yIHJlbmRlcmluZyB2aXNpYmxlIHByaW1pdGl2ZXMuIEJlaW5nIHZpc2libGUgaW4gdGhlIHdvcmxkIG1lYW5zIHRoYXQgdGhleSBhbGwgbmVlZCB2aWV3LXByb2plY3Rpb25cclxuICogbWF0cml4IGFuZCBjYW1lcmEgcG9zaXRpb25zIChtdWx0aXBsZSBwb3NpdGlvbnMgYXJlIHVzZWQgZm9yIHJlbmRlcmluZyByZXBlYXRlZCB3b3JsZCkuIFRoZXNlIHBhcmFtZXRlcnMgYXJlXHJcbiAqIHByZWRlZmluZWQgYXMgZXh0ZXJuYWwgcmVxdWlyZW1lbnRzIGZvciByZW5kZXIoKSBtZXRob2QuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXb3JsZFByaW1pdGl2ZVJlbmRlclVuaXQgZXh0ZW5kcyBHbFJlbmRlcmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIHJlbmRlclN0YXRlLCBwcm9ncmFtLCBwcmltaXRpdmVQcm92aWRlcikge1xyXG4gICAgICAgIHN1cGVyKGNvbnRleHQsIHJlbmRlclN0YXRlLCBwcm9ncmFtKTtcclxuICAgICAgICB0aGlzLnByaW1pdGl2ZVByb3ZpZGVyID0gcHJpbWl0aXZlUHJvdmlkZXI7XHJcbiAgICAgICAgdGhpcy5vblVwZGF0ZSA9IHByaW1pdGl2ZVByb3ZpZGVyLm9uVXBkYXRlO1xyXG4gICAgfVxyXG4gICAgcmVuZGVyKHRhcmdldCwgdmlld1Byb2pNYXRyaXgsIGNhbWVyYVBvc2l0aW9ucywgLi4uYXJncykge1xyXG4gICAgICAgIHN1cGVyLnJlbmRlcih0YXJnZXQsIHZpZXdQcm9qTWF0cml4LCBjYW1lcmFQb3NpdGlvbnMsIC4uLmFyZ3MpO1xyXG4gICAgfVxyXG4gICAgX3JlbmRlcihfdmlld1Byb2pNYXRyaXgsIGNhbWVyYVBvc2l0aW9ucykge1xyXG4gICAgICAgIGZvciAoY29uc3QgY2FtZXJhUG9zaXRpb24gb2YgY2FtZXJhUG9zaXRpb25zKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Byb2dyYW0uc2V0VmVjdG9yMlVuaWZvcm0oJ2xvb2tBdEhpZ2gnLCBjYW1lcmFQb3NpdGlvbi5sb29rQXRIaWdoKTtcclxuICAgICAgICAgICAgdGhpcy5fcHJvZ3JhbS5zZXRWZWN0b3IyVW5pZm9ybSgnbG9va0F0TG93JywgY2FtZXJhUG9zaXRpb24ubG9va0F0TG93KTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBtZW1vcnlCYXRjaCBvZiBiYXRjaFByaW1pdGl2ZXModGhpcy5fZ2V0UHJpbWl0aXZlcygpLCB0aGlzLl9jYW5CYXRjaEFkamFjZW50UHJpbWl0aXZlcykpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlckJhdGNoKG1lbW9yeUJhdGNoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9nZXRQcmltaXRpdmVzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnByaW1pdGl2ZVByb3ZpZGVyLnByaW1pdGl2ZXM7XHJcbiAgICB9XHJcbiAgICBfcHJlcGFyZVByb2dyYW0ocHJvZ3JhbSwgdmlld1Byb2pNYXRyaXgsIGNhbWVyYVBvc2l0aW9ucywgLi4uYXJncykge1xyXG4gICAgICAgIHN1cGVyLl9wcmVwYXJlUHJvZ3JhbShwcm9ncmFtLCB2aWV3UHJvak1hdHJpeCwgY2FtZXJhUG9zaXRpb25zLCAuLi5hcmdzKTtcclxuICAgICAgICBwcm9ncmFtLnNldE1hdHJpeDRVbmlmb3JtKCd2aWV3UHJvak1hdHJpeCcsIHZpZXdQcm9qTWF0cml4KTtcclxuICAgIH1cclxuICAgIF9yZW5kZXJCYXRjaChtZW1vcnlCYXRjaCkge1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFZhbyhtZW1vcnlCYXRjaC5wYWdlLnZhbyk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5kcmF3SW5kZXhlZE1lc2gobWVtb3J5QmF0Y2guaW5kZXhCeXRlT2Zmc2V0LCBjb3VudEluZGljZXMobWVtb3J5QmF0Y2guaW5kZXhCeXRlTGVuZ3RoLCBtZW1vcnlCYXRjaC5wYWdlLmluZGV4VHlwZSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXRlcm1pbmVzIGlmIHR3byBhZGphY2VudCBwcmltaXRpdmVzIGNhbiBiZSByZW5kZXJlZCBpbiBvbmUgYmF0Y2ggKGJ5IGEgc2luZ2xlIGRyYXcgY2FsbCkuIFRoZXkgYWxyZWFkeVxyXG4gICAgICogbGF5IHN1Y2Nlc3NpdmVseSBpbiBtZW1vcnksIGJ1dCB0aGVyZSBjb3VsZCBiZSBvdGhlciByZWFzb25zIHRoYXQgZm9yYmlkIGJhdGNoaW5nLCBsaWtlIHVzaW5nIGRpZmZlcmVudCB0ZXh0dXJlcy5cclxuICAgICAqIFRoZSBtZXRob2Qgc2hvdWxkIGJlIG92ZXJyaWRkZW4gaW4gc3ViY2xhc3NlcyBpZiB0aGVpciBwcmltaXRpdmVzIGhhdmUgc3VjaCBjb21wbGV4IHJ1bGVzIG9mIGJhdGNoaW5nLlxyXG4gICAgICovXHJcbiAgICBfY2FuQmF0Y2hBZGphY2VudFByaW1pdGl2ZXMoX2EsIF9iKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbn1cclxuIiwiLyoqXHJcbiAqIEJhc2UgY2xhc3MgZm9yIGFueSBXZWJHTCByZW5kZXJlciwgaXQganVzdCBkZWZpbmVzIGJhc2ljIHN0cnVjdHVyZSBvZiBHTC1jYWxscyBhbGxvd2luZyB0byBvdmVycmlkZSBhbnkgcGFydC5cclxuICogQSBzcGVjaWZpYyByZW5kZXJlciBtYXkgbmVlZCBhbnkgbnVtYmVyIG9mIGFkZGl0aW9uYWwgYXJndW1lbnRzIHRvIHBlcmZvcm0gcmVuZGVyaW5nLCB0aGV5IGFyZSBwcm92aWRlZCBpblxyXG4gKiBhZGRpdGlvbmFsUGFyYW1zIGluIHRoZSByZW5kZXIoKSBtZXRob2QuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgR2xSZW5kZXJlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCByZW5kZXJTdGF0ZSwgcHJvZ3JhbSkge1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgICAgIHRoaXMuX3JlbmRlclN0YXRlID0gcmVuZGVyU3RhdGU7XHJcbiAgICAgICAgdGhpcy5fcHJvZ3JhbSA9IHByb2dyYW07XHJcbiAgICB9XHJcbiAgICByZW5kZXIodGFyZ2V0LCAuLi5hcmdzKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3Byb2dyYW0pIHtcclxuICAgICAgICAgICAgdGhpcy5fcHJlcGFyZVByb2dyYW0odGhpcy5fcHJvZ3JhbSwgLi4uYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3ByZXBhcmVSZW5kZXJUYXJnZXQodGFyZ2V0LCAuLi5hcmdzKTtcclxuICAgICAgICB0aGlzLl9yZW5kZXIoLi4uYXJncyk7XHJcbiAgICB9XHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9wcm9ncmFtKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Byb2dyYW0uZGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQmluZHMgcHJvZ3JhbSBhbmQgc2V0cyByZXF1aXJlZCB1bmlmb3Jtcy4gU3ViY2xhc3NlcyBhcmUgc3VwcG9zZWQgdG8gb3ZlcnJpZGVcclxuICAgICAqIHRoaXMgbWV0aG9kIHRvIGFkZCB0aGVpciBvd24gdW5pZm9ybXMuXHJcbiAgICAgKi9cclxuICAgIF9wcmVwYXJlUHJvZ3JhbShwcm9ncmFtLCAuLi5fYXJncykge1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFByb2dyYW0ocHJvZ3JhbSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEJpbmRzIHJlbmRlciBzdGF0ZSBhbmQgcmVuZGVyIHRhcmdldCwgbm8gY2xlYXIgaGFwcGVucyBoZXJlLCBidXQgdGhpcyBtZXRob2RcclxuICAgICAqIGNhbiBiZSBvdmVycmlkZGVuIGluIHN1YmNsYXNzZXMgdG8gYWRkIGFueSBzZXR1cHMgdGhleSBuZWVkLlxyXG4gICAgICovXHJcbiAgICBfcHJlcGFyZVJlbmRlclRhcmdldCh0YXJnZXQsIC4uLl9hcmdzKSB7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kUmVuZGVyU3RhdGUodGhpcy5fcmVuZGVyU3RhdGUpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFJlbmRlclRhcmdldCh0YXJnZXQpO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IGJhdGNoQWxsb2NhdGVkT2JqZWN0cyB9IGZyb20gJy4uL21lbW9yeS9yZWxhdGl2ZV9sb2NhdGlvbic7XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGJhdGNoIGZyb20gZmlyc3QgcHJpbWl0aXZlcy5cclxuICovXHJcbmZ1bmN0aW9uIGluaXRCYXRjaChwcmltaXRpdmUpIHtcclxuICAgIGNvbnN0IHN1YkNodW5rID0gcHJpbWl0aXZlLm1lbW9yeVN1YkNodW5rO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBmaXJzdFByaW1pdGl2ZTogcHJpbWl0aXZlLFxyXG4gICAgICAgIHBhZ2U6IHN1YkNodW5rLm1lbW9yeUNodW5rLnBhZ2UsXHJcbiAgICAgICAgdmVydGV4Qnl0ZU9mZnNldDogc3ViQ2h1bmsudmVydGV4Qnl0ZU9mZnNldCxcclxuICAgICAgICB2ZXJ0ZXhCeXRlTGVuZ3RoOiBzdWJDaHVuay52ZXJ0ZXhCeXRlTGVuZ3RoLFxyXG4gICAgICAgIGluZGV4Qnl0ZU9mZnNldDogc3ViQ2h1bmsuaW5kZXhCeXRlT2Zmc2V0LFxyXG4gICAgICAgIGluZGV4Qnl0ZUxlbmd0aDogc3ViQ2h1bmsuaW5kZXhCeXRlTGVuZ3RoXHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBCYXRjaGVzIHByaW1pdGl2ZXMgdGhhdCBjYW4gYmUgcmVuZGVyZWQgYnkgYSBzaW5nbGUgZHJhdyBjYWxsLCB0aGF0IGlzIGNyaXRpY2FsIGZvciBwZXJmb3JtYW5jZS5cclxuICogUGVyZm9ybWFuY2UgZ2FpbiBmcm9tIHRoaXMgbWV0aG9kIGlzIHBvc3NpYmxlICh3aGlsZSBpdCBpcyBub3Qgc3RyaWN0bHkgcmVxdWlyZWQpIGlmIHByaW1pdGl2ZXNcclxuICogYXJlIHNvcnRlZCBieSBtZW1vcnkgb2Zmc2V0IGFuZCB0aGVyZSBhcmUgbm8gbWFueSBcImhvbGVzXCIgYmV0d2VlbiB0aGVtLlxyXG4gKiBNaW5pbWFsIHJlcXVpcmVtZXRzIGZvciBiYXRjaGluZyBpcyBsb2NhdGlvbiBpbiB0aGUgc2FtZSBidWZmZXIgKG1lbW9yeSBwYWdlKSwgYWRkaXRpb25hbFxyXG4gKiByZXF1aXJlbWVudHMgKHN1Y2ggYXMgaGF2aW5nIHNoYXJlZCB0ZXh0dXJlIG9yIHNpbWlsYXIpIGNhbiBiZSBpbXBvc2VkIGluIGNhbkJhdGNoUHJpZGljYXRlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGJhdGNoUHJpbWl0aXZlcyhwcmltaXRpdmVzLCBjYW5CYXRjaFByaWRpY2F0ZSkge1xyXG4gICAgY29uc3QgY2FuQmF0Y2ggPSAoYSwgYikgPT4ge1xyXG4gICAgICAgIGlmIChcclxuICAgICAgICAvLyBtaW5pbWFsIHJlcXVpcmVtZW50cyBmb3IgYmF0Y2hpbmcgaXMgdGhhdCBwcmltaXRpdmVzIGxheSBpbiB0aGUgc2FtZSBwYWdlXHJcbiAgICAgICAgKGEubWVtb3J5U3ViQ2h1bmsubWVtb3J5Q2h1bmsucGFnZSAhPT0gYi5tZW1vcnlTdWJDaHVuay5tZW1vcnlDaHVuay5wYWdlKSB8fFxyXG4gICAgICAgICAgICAvLyBjaGFjayBleHRlcm5hbCByZXF1aXJlbWVudHMgaWYgc3BlY2lmaWVkXHJcbiAgICAgICAgICAgIChjYW5CYXRjaFByaWRpY2F0ZSAmJiAhY2FuQmF0Y2hQcmlkaWNhdGUoYSwgYikpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gYmF0Y2hBbGxvY2F0ZWRPYmplY3RzKHByaW1pdGl2ZXMsIChwcmltaXRpdmUpID0+IHByaW1pdGl2ZS5tZW1vcnlTdWJDaHVuaywgaW5pdEJhdGNoLCBjYW5CYXRjaCk7XHJcbn1cclxuIiwiLyoqXHJcbiAqIEFwcGVuZHMgcG9ydGlvbiBvZiBtZW1vcnkgdG8gYmF0Y2ggaWYgdGhleSBhcmUgYWRqYWNlbnQuXHJcbiAqXHJcbiAqIEByZXR1cm5zIGB0cnVlYCBpZiBib3RoIHBhcmFtcyBhcmUgYWRqYWNlbnQgYW5kIHRoZSBiYXRjaCB3YXMgc3VjY2Vzc2Z1bGx5IHVwZGF0ZWQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGFwcGVuZFRvQmF0Y2gobWVtb3J5TG9jYXRpb24sIGJhdGNoKSB7XHJcbiAgICBpZiAoYmF0Y2gudmVydGV4Qnl0ZU9mZnNldCArIGJhdGNoLnZlcnRleEJ5dGVMZW5ndGggPT09IG1lbW9yeUxvY2F0aW9uLnZlcnRleEJ5dGVPZmZzZXQgJiZcclxuICAgICAgICBiYXRjaC5pbmRleEJ5dGVPZmZzZXQgKyBiYXRjaC5pbmRleEJ5dGVMZW5ndGggPT09IG1lbW9yeUxvY2F0aW9uLmluZGV4Qnl0ZU9mZnNldCkge1xyXG4gICAgICAgIGJhdGNoLnZlcnRleEJ5dGVMZW5ndGggKz0gbWVtb3J5TG9jYXRpb24udmVydGV4Qnl0ZUxlbmd0aDtcclxuICAgICAgICBiYXRjaC5pbmRleEJ5dGVMZW5ndGggKz0gbWVtb3J5TG9jYXRpb24uaW5kZXhCeXRlTGVuZ3RoO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbi8qKlxyXG4gKiBDb21iaW5lcyBvYmplY3RzIGFsbG9jYXRlZCBpbiBtZW1vcnkgaW50byBiYXRjaGVzLiBObyBzb3J0aW5nIGlzIGRvbmUgaW4gdGhpcyBtZXRob2QsIHRoZSBvYmplY3RzIGFyZSBzdXBwb3NlZFxyXG4gKiB0byBiZSBzb3J0ZWQgYnkgaW5kZXgvdmVydGV4IG9mZnNldHMgdG8gbWFrZSBiYXRjaGluZyBlZmZlY3RpdmUuIFRoZSBiYXRjaCBpcyBjcmVhdGVkIGJ5IGZhY3Rvcnkgc2luY2UgaXQgY2FuXHJcbiAqIGNvbnRhaW5zIHByb2JsZW0gc3BlY2lmaWMgaW5mb3JtYXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSBvYmplY3RzIExpc3Qgb2YgYWxsb2NhdGVkIG9iamVjdHMuXHJcbiAqIEBwYXJhbSBnZXRNZW1vcnlMb2NhdGlvbiBSZXR1cm5zIG1lbW9yeSBsb2NhdGlvbiBvZiBzcGVjaWZpYyBvYmplY3QuXHJcbiAqIEBwYXJhbSBjcmVhdGVCYXRjaCBJbml0aWF0ZXMgYmF0Y2ggYnkgdGhlIGZpcnN0IG9iamVjdC5cclxuICogQHBhcmFtIGNhbkJhdGNoIENoZWNrcyBpZiB0d28gb2JqZWN0cyBjYW4gYmUgYWxsb2NhdGVkLlxyXG4gKiBAcmV0dXJucyBJdGVyYWJsZSBsaXN0IG9mIGJhdGNoZXMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24qIGJhdGNoQWxsb2NhdGVkT2JqZWN0cyhvYmplY3RzLCBnZXRNZW1vcnlMb2NhdGlvbiwgY3JlYXRlQmF0Y2gsIGNhbkJhdGNoID0gKCkgPT4gdHJ1ZSkge1xyXG4gICAgY29uc3QgaXRlcmF0b3IgPSBvYmplY3RzW1N5bWJvbC5pdGVyYXRvcl0oKTtcclxuICAgIGxldCBwcmltaXRpdmUgPSBpdGVyYXRvci5uZXh0KCkudmFsdWU7XHJcbiAgICBpZiAoIXByaW1pdGl2ZSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGxldCBwcmV2ID0gcHJpbWl0aXZlO1xyXG4gICAgbGV0IGJhdGNoID0gY3JlYXRlQmF0Y2gocHJldik7XHJcbiAgICBwcmltaXRpdmUgPSBpdGVyYXRvci5uZXh0KCkudmFsdWU7XHJcbiAgICB3aGlsZSAocHJpbWl0aXZlKSB7XHJcbiAgICAgICAgY29uc3QgcHJpbWl0aXZlTWVtb3J5TG9jYXRpb24gPSBnZXRNZW1vcnlMb2NhdGlvbihwcmltaXRpdmUpO1xyXG4gICAgICAgIGlmICghY2FuQmF0Y2gocHJldiwgcHJpbWl0aXZlLCBiYXRjaCkgfHwgIWFwcGVuZFRvQmF0Y2gocHJpbWl0aXZlTWVtb3J5TG9jYXRpb24sIGJhdGNoKSkge1xyXG4gICAgICAgICAgICB5aWVsZCBiYXRjaDtcclxuICAgICAgICAgICAgYmF0Y2ggPSBjcmVhdGVCYXRjaChwcmltaXRpdmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwcmV2ID0gcHJpbWl0aXZlO1xyXG4gICAgICAgIHByaW1pdGl2ZSA9IGl0ZXJhdG9yLm5leHQoKS52YWx1ZTtcclxuICAgIH1cclxuICAgIHlpZWxkIGJhdGNoO1xyXG59XHJcbiIsImltcG9ydCBwb2ludExhYmVsVmVydGV4U2hhZGVyIGZyb20gJy4vc2hhZGVyL3BvaW50X2xhYmVsLnZlcnQnO1xyXG5pbXBvcnQgZGZUZXh0RnJhZ21lbnRTaGFkZXIgZnJvbSAnLi9zaGFkZXIvZGZfdGV4dC5mcmFnJztcclxuaW1wb3J0IExhYmVsUmVuZGVyVW5pdCBmcm9tICcuL2xhYmVsX3JlbmRlcl91bml0JztcclxuaW1wb3J0IEJpbGxib2FyZFJlY3RhbmdsZVJlbmRlclVuaXQgZnJvbSAnLi4vYmlsbGJvYXJkX3JlY3RhbmdsZS9iaWxsYm9hcmRfcmVjdGFuZ2xlX3JlbmRlcl91bml0JztcclxuaW1wb3J0IHsgVm9pZEV2ZW50RW1pdHRlciB9IGZyb20gJy4uLy4uLy4uL3V0aWwvZXZlbnRfZW1pdHRlcic7XHJcbmltcG9ydCB7IG1hcEl0ZXJhYmxlLCBmaWx0ZXJJdGVyYWJsZSB9IGZyb20gJy4uLy4uLy4uL3V0aWwvaXRlcmFibGUnO1xyXG5leHBvcnQgY29uc3QgUFJPR1JBTV9PUFRJT05TID0ge1xyXG4gICAgYXR0cmliTWFwOiB7XHJcbiAgICAgICAgdmVydGV4SWQ6IDIgLyogSUQgKi8sXHJcbiAgICAgICAgdmVydGV4UG9zSGlnaDogMCAvKiBQT1NJVElPTl9ISUdIICovLFxyXG4gICAgICAgIHZlcnRleFBvc0xvdzogMSAvKiBQT1NJVElPTl9MT1cgKi8sXHJcbiAgICAgICAgdmVydGV4RGlzcGxhY2VtZW50OiA2IC8qIERJU1BMQUNFTUVOVCAqLyxcclxuICAgICAgICB2ZXJ0ZXhVVjogNCAvKiBVViAqLyxcclxuICAgICAgICB2ZXJ0ZXhQcmlvcml0eTogOSAvKiBQUklPUklUWSAqLyxcclxuICAgICAgICB2ZXJ0ZXhDb2xvcjogNyAvKiBDT0xPUiAqLyxcclxuICAgICAgICB2ZXJ0ZXhPdXRsaW5lQ29sb3I6IDggLyogT1VUTElORV9DT0xPUiAqLyxcclxuICAgICAgICB2ZXJ0ZXhTY2FsZTogMTEgLyogQVVYICovXHJcbiAgICB9XHJcbn07XHJcbi8qKlxyXG4gKiBSZW5kZXJzIGJhY2tncm91bmRzIGV4dHJhY3RlZCBmcm9tIHBvaW50IGxhYmVscy5cclxuICovXHJcbmNsYXNzIEJhY2tncm91bmRQcmltaXRpdmVQcm92aWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihsYWJlbHNQcm92aWRlcikge1xyXG4gICAgICAgIHRoaXMub25VcGRhdGUgPSBuZXcgVm9pZEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMuX2xhYmVsc1Byb3ZpZGVyID0gbGFiZWxzUHJvdmlkZXI7XHJcbiAgICB9XHJcbiAgICBnZXQgcHJpbWl0aXZlcygpIHtcclxuICAgICAgICByZXR1cm4gbWFwSXRlcmFibGUoZmlsdGVySXRlcmFibGUodGhpcy5fbGFiZWxzUHJvdmlkZXIucHJpbWl0aXZlcywgKGxhYmVsKSA9PiBsYWJlbC5iYWNrZ3JvdW5kICE9PSB1bmRlZmluZWQpLCAobGFiZWwpID0+IGxhYmVsLmJhY2tncm91bmQpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBQb2ludCBsYWJlbHMgcmVuZGVyZXIuIEl0IHVzZXMgYXBwcm9wcmlhdGUgcHJvZ3JhbSB0byBsYXlvdXQgZ2x5cGhzIG9uIEdQVS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvaW50TGFiZWxSZW5kZXJVbml0IGV4dGVuZHMgTGFiZWxSZW5kZXJVbml0IHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIGNhbWVyYSwgdmlzaWJpbGl0eVByb3ZpZGVyLCBwcmltaXRpdmVQcm92aWRlcikge1xyXG4gICAgICAgIGNvbnN0IHByb2dyYW0gPSBjb250ZXh0LmNyZWF0ZVByb2dyYW0ocG9pbnRMYWJlbFZlcnRleFNoYWRlciwgZGZUZXh0RnJhZ21lbnRTaGFkZXIsIFBST0dSQU1fT1BUSU9OUyk7XHJcbiAgICAgICAgc3VwZXIoY29udGV4dCwgcHJvZ3JhbSwgY2FtZXJhLCB2aXNpYmlsaXR5UHJvdmlkZXIsIHByaW1pdGl2ZVByb3ZpZGVyKTtcclxuICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kUmVuZGVyZXIgPSBuZXcgQmlsbGJvYXJkUmVjdGFuZ2xlUmVuZGVyVW5pdChjb250ZXh0LCBjYW1lcmEsIHZpc2liaWxpdHlQcm92aWRlciwgbmV3IEJhY2tncm91bmRQcmltaXRpdmVQcm92aWRlcihwcmltaXRpdmVQcm92aWRlcikpO1xyXG4gICAgICAgIHRoaXMuX2JhY2tncm91bmRSZW5kZXJlci5vblVwZGF0ZS5hZGRMaXN0ZW5lcigoKSA9PiB0aGlzLm9uVXBkYXRlLmZpcmUoKSk7XHJcbiAgICB9XHJcbiAgICByZW5kZXIodGFyZ2V0LCB2aWV3UHJvak1hdHJpeCwgY2FtZXJhUG9zaXRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5fYmFja2dyb3VuZFJlbmRlcmVyLnJlbmRlcih0YXJnZXQsIHZpZXdQcm9qTWF0cml4LCBjYW1lcmFQb3NpdGlvbnMpO1xyXG4gICAgICAgIHN1cGVyLnJlbmRlcih0YXJnZXQsIHZpZXdQcm9qTWF0cml4LCBjYW1lcmFQb3NpdGlvbnMpO1xyXG4gICAgfVxyXG59XHJcbiIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleElkO1xcblxcbi8vIHBvaW50IGluIHRoZSB3b3JsZCB0aGUgbGFiZWwgaXMgYW5jaG9yZWQgdG9cXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhQb3NIaWdoO1xcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleFBvc0xvdztcXG5cXG4vLyB2ZWN0b3Igb2YgY29uY3JldGUgZ2x5cGggcG9pbnQgZGlzcGxhY2VtZW50ICh0b3AtbGVmdCwgYm90dG9tLWxlZnQsIC4uLikgcmVsYXRpdmUgdG8gbGFiZWwncyBjZW50ZXIsIGluIHB4XFxuYXR0cmlidXRlIHZlYzIgdmVydGV4RGlzcGxhY2VtZW50O1xcblxcbi8vIGNvb3JkaW5hdGVzIG9mIHRoZSBnbHlwaCB2ZXJ0ZXggaW4gdGhlIGF0bGFzXFxuYXR0cmlidXRlIHZlYzIgdmVydGV4VVY7XFxuXFxuYXR0cmlidXRlIGZsb2F0IHZlcnRleFByaW9yaXR5O1xcblxcbmF0dHJpYnV0ZSBsb3dwIHZlYzQgdmVydGV4Q29sb3I7XFxuYXR0cmlidXRlIGxvd3AgdmVjNCB2ZXJ0ZXhPdXRsaW5lQ29sb3I7XFxuYXR0cmlidXRlIGZsb2F0IHZlcnRleFNjYWxlO1xcblxcbnVuaWZvcm0gdmVjMiBsb29rQXRIaWdoO1xcbnVuaWZvcm0gdmVjMiBsb29rQXRMb3c7XFxudW5pZm9ybSBtYXQ0IHZpZXdQcm9qTWF0cml4O1xcbnVuaWZvcm0gdmVjMiBwaXhlbFNpemU7XFxudW5pZm9ybSBzYW1wbGVyMkQgdmlzaWJpbGl0eTtcXG51bmlmb3JtIHZlYzIgaWRIYWxmUHhTaXplO1xcbnVuaWZvcm0gdmVjMiBzaGlmdDtcXG51bmlmb3JtIGxvd3AgZmxvYXQgY3VycmVudFpvb207XFxuXFxudmFyeWluZyB2ZWMyIHV2O1xcbnZhcnlpbmcgbG93cCB2ZWM0IGNvbG9yO1xcbnZhcnlpbmcgbG93cCB2ZWM0IG91dGxpbmVDb2xvcjtcXG52YXJ5aW5nIG1lZGl1bXAgZmxvYXQgc2NhbGU7XFxuXFxuY29uc3QgdmVjNCBESVNDQVJEX1BPU0lUSU9OID0gdmVjNCgyLCAyLCAyLCAxKTtcXG5cXG5jb25zdCBmbG9hdCBZVl9IXzFfMCA9IDEuOTk5OTY5NDgyNDIxODc1O1xcbmNvbnN0IGZsb2F0IFlWX0xfMV8xID0gMC4wMDAwMzA1MTcxMTI0NjM3MTI2OTI7XFxuXFxuLyoqXFxuICogUHJvamVjdHMgc3BlY2lmaWMgcG9pbnQgbGFiZWwgdmVydGV4IG9udG8gdGhlIHNjcmVlbi5cXG4gKi9cXG52ZWM0IHByb2plY3RQb2ludExhYmVsVmVydGV4XzFfMihcXG4gICAgbWF0NCB2aWV3UHJvak1hdHJpeCxcXG4gICAgdmVjMiBsb29rQXRIaWdoLFxcbiAgICB2ZWMyIGxvb2tBdExvdyxcXG4gICAgdmVjMiBwb3NIaWdoLFxcbiAgICB2ZWMyIHBvc0xvdyxcXG4gICAgdmVjMiBkaXNwbGFjZW1lbnQsXFxuICAgIHZlYzIgcHhTaXplXFxuKSB7XFxuICAgIHZlYzQgcG9zaXRpb24gPSB2aWV3UHJvak1hdHJpeCAqIHZlYzQoXFxuICAgICAgICBZVl9IXzFfMCAqIChwb3NIaWdoIC0gbG9va0F0SGlnaCkgK1xcbiAgICAgICAgICAgIFlWX0xfMV8xICogKHBvc0xvdyAtIGxvb2tBdExvdyksXFxuICAgICAgICAwLFxcbiAgICAgICAgMVxcbiAgICApO1xcbiAgICBwb3NpdGlvbiA9IHZlYzQocG9zaXRpb24ueHkgLyBwb3NpdGlvbi53LCAwLjAsIDEuMCk7XFxuXFxuICAgIHJldHVybiBwb3NpdGlvbiArIHZlYzQoZGlzcGxhY2VtZW50ICogcHhTaXplLCAwLjAsIDAuMCk7XFxufVxcblxcblxcblxcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIC8vZmxvYXQgdmlzaWJpbGl0eUFscGhhID0gdGV4dHVyZTJEKHZpc2liaWxpdHksIHZlcnRleElkLnh5ICsgaWRIYWxmUHhTaXplKS5hO1xcbiAgICBmbG9hdCB2aXNpYmlsaXR5QWxwaGEgPSAxLjA7XFxuICAgIGlmICh2aXNpYmlsaXR5QWxwaGEgIT0gMC4wKSB7XFxuICAgICAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3RQb2ludExhYmVsVmVydGV4XzFfMihcXG4gICAgICAgICAgICB2aWV3UHJvak1hdHJpeCxcXG4gICAgICAgICAgICBsb29rQXRIaWdoLFxcbiAgICAgICAgICAgIGxvb2tBdExvdyxcXG4gICAgICAgICAgICB2ZXJ0ZXhQb3NIaWdoLFxcbiAgICAgICAgICAgIHZlcnRleFBvc0xvdyxcXG4gICAgICAgICAgICB2ZXJ0ZXhEaXNwbGFjZW1lbnQsXFxuICAgICAgICAgICAgcGl4ZWxTaXplXFxuICAgICAgICApO1xcblxcbiAgICAgICAgdXYgPSB2ZXJ0ZXhVVjtcXG4gICAgICAgIGNvbG9yID0gdmVydGV4Q29sb3I7XFxuICAgICAgICBvdXRsaW5lQ29sb3IgPSB2ZXJ0ZXhPdXRsaW5lQ29sb3I7XFxuICAgICAgICBzY2FsZSA9IHZlcnRleFNjYWxlO1xcblxcbiAgICAgICAgY29sb3IuYSAqPSB2aXNpYmlsaXR5QWxwaGE7XFxuICAgICAgICBvdXRsaW5lQ29sb3IuYSAqPSB2aXNpYmlsaXR5QWxwaGE7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICBnbF9Qb3NpdGlvbiA9IERJU0NBUkRfUE9TSVRJT047XFxuICAgIH1cXG59XFxuXCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiI3ZlcnNpb24gMTAwXFxuXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG51bmlmb3JtIGZsb2F0IGRwcjtcXG51bmlmb3JtIHNhbXBsZXIyRCBhdGxhcztcXG51bmlmb3JtIHZlYzIgYXRsYXNTaXplO1xcblxcbnZhcnlpbmcgdmVjMiB1djtcXG52YXJ5aW5nIGxvd3AgdmVjNCBjb2xvcjtcXG52YXJ5aW5nIGxvd3AgdmVjNCBvdXRsaW5lQ29sb3I7XFxudmFyeWluZyBmbG9hdCBzY2FsZTtcXG5cXG5jb25zdCBmbG9hdCBNQVhfQ09SUkVDVEVEX0dMWVBIX1NDQUxFID0gMC41O1xcbmNvbnN0IGZsb2F0IEdMWVBIX0JBU0VfV0VJR0hUID0gMC43O1xcbmNvbnN0IGZsb2F0IEdMWVBIX0JBU0VfU01PVEhORVNTID0gMC4xO1xcbmNvbnN0IGZsb2F0IEdMWVBIX1dFSUdIVF9TQ0FMRV9JTVBBQ1QgPSAwLjE7XFxuY29uc3QgZmxvYXQgR0xZUEhfU01PT1RITkVTU19TQ0FMRV9JTVBBQ1QgPSAwLjA2O1xcbmNvbnN0IGZsb2F0IE9VVExJTkVfV0VJR0hUX1NDQUxFX0lNUEFDVCA9IDAuMTI1O1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIC8vIGxvdyBzY2FsZSBnbHlwaHMgKGxlc3MgdGhhbiAwLjUpIHNob3VsZCBiZSBhIGxpdHRsZSBiaXQgYm9sZGVyIGFuZCBzbW9vdGhlclxcbiAgICBmbG9hdCBzY2FsZUNsYW1wZWQgPSBjbGFtcChzY2FsZSwgMC4wLCBNQVhfQ09SUkVDVEVEX0dMWVBIX1NDQUxFKTtcXG4gICAgLy8gd2VpZ2h0IGlzIHJlc3BvbnNpYmxlIGZvciBnbHlwaCBib2xkbmVzcywgdGhlIGxlc3Mgd2VpZ2h0IHZhbHVlIHRoZSBib2xkZXIgdGhlIHRleHRcXG4gICAgZmxvYXQgd2VpZ2h0ID0gR0xZUEhfQkFTRV9XRUlHSFQgKyBHTFlQSF9XRUlHSFRfU0NBTEVfSU1QQUNUICogc2NhbGVDbGFtcGVkO1xcbiAgICAvLyBzbW9vdGhuZXNzIGlzIGhvdyBibHVycmVkIGdseXBocyBhcmUsIHRoZSBsZXNzIHNtb290aG5lc3MgdmFsdWUgdGhlIGxlc3MgYmx1cnJpbmdcXG4gICAgZmxvYXQgc21vb3RobmVzcyA9IChHTFlQSF9CQVNFX1NNT1RITkVTUyArIEdMWVBIX1NNT09USE5FU1NfU0NBTEVfSU1QQUNUIC8gc2NhbGVDbGFtcGVkKSAvIGRwcjtcXG5cXG4gICAgdmVjNCByZXN1bHRDb2xvciA9IGNvbG9yO1xcbiAgICBmbG9hdCBkaXN0ID0gdGV4dHVyZTJEKGF0bGFzLCB1diAvIGF0bGFzU2l6ZSkuYTtcXG4gICAgZmxvYXQgYWxwaGEgPSBzbW9vdGhzdGVwKHdlaWdodCAtIHNtb290aG5lc3MsIHdlaWdodCArIHNtb290aG5lc3MsIGRpc3QpO1xcblxcbiAgICBpZiAob3V0bGluZUNvbG9yLmEgIT0gMC4wKSB7XFxuICAgICAgICAvLyB0byByZW5kZXIgb3V0bGluZSB0aGUgZ2x5cGggaXMgcmVuZGVyZWQgYSBsaXR0bGUgYml0IGJvbGRlciB3aXRoIGRpZmZlcmVudCBjb2xvciBhdCBlZGdlc1xcbiAgICAgICAgd2VpZ2h0ID0gd2VpZ2h0IC0gT1VUTElORV9XRUlHSFRfU0NBTEVfSU1QQUNUIC8gc2NhbGU7XFxuICAgICAgICByZXN1bHRDb2xvciA9IG1peChvdXRsaW5lQ29sb3IsIGNvbG9yLCBhbHBoYSk7XFxuICAgICAgICBhbHBoYSA9IHNtb290aHN0ZXAod2VpZ2h0IC0gc21vb3RobmVzcywgd2VpZ2h0ICsgc21vb3RobmVzcywgZGlzdCk7XFxuICAgIH1cXG5cXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChyZXN1bHRDb2xvci5yZ2IsIHJlc3VsdENvbG9yLmEgKiBhbHBoYSk7XFxufVxcblwiIiwiaW1wb3J0IFdvcmxkUHJpbWl0aXZlUmVuZGVyVW5pdCBmcm9tICcuLi93b3JsZF9wcmltaXRpdmVfcmVuZGVyX3VuaXQnO1xyXG5pbXBvcnQgKiBhcyB2ZWMyIGZyb20gJy4uLy4uLy4uL21hdGgvdmVjdG9yMic7XHJcbmltcG9ydCBSZW5kZXJTdGF0ZSwgeyBCTEVORF9PVkVSX1JFTkRFUl9TVEFURSB9IGZyb20gJy4uLy4uLy4uL3JlbmRlci9zdGF0ZSc7XHJcbi8qKlxyXG4gKiBCYXNlIHJlbmRlcmVyIHRoYXQgaW5jYXBzdWxhdGVzIGFsbCB0aGUgR0wgc3BlY2lmaWNzIHRvIG1ha2UgbGFiZWxzIHJlbmRlcmVkLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGFiZWxSZW5kZXJVbml0IGV4dGVuZHMgV29ybGRQcmltaXRpdmVSZW5kZXJVbml0IHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIHByb2dyYW0sIGNhbWVyYSwgdmlzaWJpbGl0eVByb3ZpZGVyLCBwcmltaXRpdmVQcm92aWRlcikge1xyXG4gICAgICAgIHN1cGVyKGNvbnRleHQsIG5ldyBSZW5kZXJTdGF0ZShCTEVORF9PVkVSX1JFTkRFUl9TVEFURSksIHByb2dyYW0sIHByaW1pdGl2ZVByb3ZpZGVyKTtcclxuICAgICAgICB0aGlzLl9jYW1lcmEgPSBjYW1lcmE7XHJcbiAgICAgICAgdGhpcy5fdmlzaWJpbGl0eVByb3ZpZGVyID0gdmlzaWJpbGl0eVByb3ZpZGVyO1xyXG4gICAgICAgIHRoaXMuX2lkSGFsZlB4U2l6ZVVuaWZvcm0gPSB2ZWMyLmNyZWF0ZSgwLCAwKTtcclxuICAgICAgICB0aGlzLl9hdGxhc1NpemVVbmlmb3JtID0gdmVjMi5jcmVhdGUoMCwgMCk7XHJcbiAgICAgICAgY29udGV4dC5iaW5kUHJvZ3JhbShwcm9ncmFtKTtcclxuICAgICAgICBwcm9ncmFtLnNldEludFNjYWxhclVuaWZvcm0oJ3Zpc2liaWxpdHknLCAwKTtcclxuICAgIH1cclxuICAgIF9wcmVwYXJlUHJvZ3JhbShwcm9ncmFtLCB2aWV3UHJvak1hdHJpeCwgY2FtZXJhUG9zaXRpb25zKSB7XHJcbiAgICAgICAgY29uc3QgdmlzaWJpbGl0eSA9IHRoaXMuX3Zpc2liaWxpdHlQcm92aWRlcigpO1xyXG4gICAgICAgIHN1cGVyLl9wcmVwYXJlUHJvZ3JhbShwcm9ncmFtLCB2aWV3UHJvak1hdHJpeCwgY2FtZXJhUG9zaXRpb25zKTtcclxuICAgICAgICB0aGlzLl9pZEhhbGZQeFNpemVVbmlmb3JtLnggPSAwLjUgLyB2aXNpYmlsaXR5LmdldFdpZHRoKCk7XHJcbiAgICAgICAgdGhpcy5faWRIYWxmUHhTaXplVW5pZm9ybS55ID0gMC41IC8gdmlzaWJpbGl0eS5nZXRIZWlnaHQoKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRUZXh0dXJlVW5pdCgwKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRUZXh0dXJlKHZpc2liaWxpdHkpO1xyXG4gICAgICAgIHByb2dyYW0uc2V0VmVjdG9yMlVuaWZvcm0oJ2lkSGFsZlB4U2l6ZScsIHRoaXMuX2lkSGFsZlB4U2l6ZVVuaWZvcm0pO1xyXG4gICAgICAgIHByb2dyYW0uc2V0VmVjdG9yMlVuaWZvcm0oJ3BpeGVsU2l6ZScsIHRoaXMuX2NhbWVyYS5waXhlbFNpemUpO1xyXG4gICAgICAgIHByb2dyYW0uc2V0U2NhbGFyVW5pZm9ybSgnZHByJywgd2luZG93LmRldmljZVBpeGVsUmF0aW8pO1xyXG4gICAgfVxyXG4gICAgX3JlbmRlckJhdGNoKG1lbW9yeUJhdGNoKSB7XHJcbiAgICAgICAgY29uc3QgYXRsYXMgPSBtZW1vcnlCYXRjaC5maXJzdFByaW1pdGl2ZS5hdGxhcztcclxuICAgICAgICB0aGlzLl9hdGxhc1NpemVVbmlmb3JtLnggPSBhdGxhcy53aWR0aDtcclxuICAgICAgICB0aGlzLl9hdGxhc1NpemVVbmlmb3JtLnkgPSBhdGxhcy5oZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5fcHJvZ3JhbS5zZXRJbnRTY2FsYXJVbmlmb3JtKCdhdGxhcycsIDEpO1xyXG4gICAgICAgIHRoaXMuX3Byb2dyYW0uc2V0VmVjdG9yMlVuaWZvcm0oJ2F0bGFzU2l6ZScsIHRoaXMuX2F0bGFzU2l6ZVVuaWZvcm0pO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFRleHR1cmVVbml0KDEpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFRleHR1cmUoYXRsYXMudGV4dHVyZSk7XHJcbiAgICAgICAgc3VwZXIuX3JlbmRlckJhdGNoKG1lbW9yeUJhdGNoKTtcclxuICAgIH1cclxuICAgIF9jYW5CYXRjaEFkamFjZW50UHJpbWl0aXZlcyhhLCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIHN1cGVyLl9jYW5CYXRjaEFkamFjZW50UHJpbWl0aXZlcyhhLCBiKSAmJiAoYS5hdGxhcyA9PT0gYi5hdGxhcyk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHJlY3RhbmdsZVZlcnRleFNoYWRlciBmcm9tICcuL3NoYWRlci9iaWxsYm9hcmRfcmVjdGFuZ2xlLnZlcnQnO1xyXG5pbXBvcnQgcmVjdGFuZ2xlRnJhZ21lbnRTaGFkZXIgZnJvbSAnLi9zaGFkZXIvYmlsbGJvYXJkX3JlY3RhbmdsZS5mcmFnJztcclxuaW1wb3J0ICogYXMgdmVjMiBmcm9tICcuLi8uLi8uLi9tYXRoL3ZlY3RvcjInO1xyXG5pbXBvcnQgV29ybGRQcmltaXRpdmVSZW5kZXJVbml0IGZyb20gJy4uL3dvcmxkX3ByaW1pdGl2ZV9yZW5kZXJfdW5pdCc7XHJcbmltcG9ydCBSZW5kZXJTdGF0ZSBmcm9tICcuLi8uLi8uLi9yZW5kZXIvc3RhdGUnO1xyXG5pbXBvcnQgeyBCTEVORF9PVkVSX1JFTkRFUl9TVEFURSB9IGZyb20gJy4uLy4uLy4uL3JlbmRlci9zdGF0ZSc7XHJcbmNvbnN0IFJFTkRFUl9TVEFURSA9IG5ldyBSZW5kZXJTdGF0ZShCTEVORF9PVkVSX1JFTkRFUl9TVEFURSk7XHJcbi8qKlxyXG4gKiBSZW5kZXJlciBvZiBiaWxsYm9hcmQgcmVjdGFuZ2xlcy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJpbGxib2FyZFJlY3RhbmdsZVJlbmRlclVuaXQgZXh0ZW5kcyBXb3JsZFByaW1pdGl2ZVJlbmRlclVuaXQge1xyXG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgY2FtZXJhLCB2aXNpYmlsaXR5UHJvdmlkZXIsIHByaW1pdGl2ZVByb3ZpZGVyKSB7XHJcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IGNvbnRleHQuY3JlYXRlUHJvZ3JhbShyZWN0YW5nbGVWZXJ0ZXhTaGFkZXIsIHJlY3RhbmdsZUZyYWdtZW50U2hhZGVyLCB7XHJcbiAgICAgICAgICAgIGF0dHJpYk1hcDoge1xyXG4gICAgICAgICAgICAgICAgdmVydGV4SWQ6IDIgLyogSUQgKi8sXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhQb3NIaWdoOiAwIC8qIFBPU0lUSU9OX0hJR0ggKi8sXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhQb3NMb3c6IDEgLyogUE9TSVRJT05fTE9XICovLFxyXG4gICAgICAgICAgICAgICAgdmVydGV4RGlzcGxhY2VtZW50OiA2IC8qIERJU1BMQUNFTUVOVCAqLyxcclxuICAgICAgICAgICAgICAgIHZlcnRleFVWOiA0IC8qIFVWICovLFxyXG4gICAgICAgICAgICAgICAgdmVydGV4Q29sb3I6IDcgLyogQ09MT1IgKi8sXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhCb3JkZXJSYWRpaTogMTEgLyogQVVYICovXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBzdXBlcihjb250ZXh0LCBSRU5ERVJfU1RBVEUsIHByb2dyYW0sIHByaW1pdGl2ZVByb3ZpZGVyKTtcclxuICAgICAgICB0aGlzLl92aXNpYmlsaXR5UHJvdmlkZXIgPSB2aXNpYmlsaXR5UHJvdmlkZXI7XHJcbiAgICAgICAgdGhpcy5fY2FtZXJhID0gY2FtZXJhO1xyXG4gICAgICAgIHRoaXMuX3Zpc2liaWxpdHlTaXplVW5pZm9ybSA9IHZlYzIuY3JlYXRlKDAsIDApO1xyXG4gICAgICAgIGNvbnRleHQuYmluZFByb2dyYW0ocHJvZ3JhbSk7XHJcbiAgICAgICAgcHJvZ3JhbS5zZXRJbnRTY2FsYXJVbmlmb3JtKCd2aXNpYmlsaXR5JywgMCk7XHJcbiAgICB9XHJcbiAgICBfcHJlcGFyZVByb2dyYW0ocHJvZ3JhbSwgdmlld1Byb2pNYXRyaXgsIGNhbWVyYVBvc2l0aW9ucykge1xyXG4gICAgICAgIHN1cGVyLl9wcmVwYXJlUHJvZ3JhbShwcm9ncmFtLCB2aWV3UHJvak1hdHJpeCwgY2FtZXJhUG9zaXRpb25zKTtcclxuICAgICAgICBjb25zdCB2aXNpYmlsaXR5ID0gdGhpcy5fdmlzaWJpbGl0eVByb3ZpZGVyKCk7XHJcbiAgICAgICAgdGhpcy5fdmlzaWJpbGl0eVNpemVVbmlmb3JtLnggPSB2aXNpYmlsaXR5LmdldFdpZHRoKCk7XHJcbiAgICAgICAgdGhpcy5fdmlzaWJpbGl0eVNpemVVbmlmb3JtLnkgPSB2aXNpYmlsaXR5LmdldEhlaWdodCgpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFRleHR1cmVVbml0KDApO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFRleHR1cmUodmlzaWJpbGl0eSk7XHJcbiAgICAgICAgcHJvZ3JhbS5zZXRWZWN0b3IyVW5pZm9ybSgndmlzaWJpbGl0eVNpemUnLCB0aGlzLl92aXNpYmlsaXR5U2l6ZVVuaWZvcm0pO1xyXG4gICAgICAgIHByb2dyYW0uc2V0VmVjdG9yMlVuaWZvcm0oJ3BpeGVsU2l6ZScsIHRoaXMuX2NhbWVyYS5waXhlbFNpemUpO1xyXG4gICAgfVxyXG59XHJcbiIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleElkO1xcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleFBvc0hpZ2g7XFxuYXR0cmlidXRlIHZlYzIgdmVydGV4UG9zTG93O1xcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleERpc3BsYWNlbWVudDtcXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhVVjtcXG5hdHRyaWJ1dGUgdmVjNCB2ZXJ0ZXhDb2xvcjtcXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhCb3JkZXJSYWRpaTtcXG5cXG51bmlmb3JtIHZlYzIgbG9va0F0SGlnaDtcXG51bmlmb3JtIHZlYzIgbG9va0F0TG93O1xcbnVuaWZvcm0gbWF0NCB2aWV3UHJvak1hdHJpeDtcXG51bmlmb3JtIHZlYzIgcGl4ZWxTaXplO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHZpc2liaWxpdHk7XFxudW5pZm9ybSB2ZWMyIHZpc2liaWxpdHlTaXplO1xcblxcbnZhcnlpbmcgdmVjMiB1djtcXG52YXJ5aW5nIHZlYzQgY29sb3I7XFxudmFyeWluZyB2ZWMyIGJvcmRlclJhZGlpO1xcblxcbmNvbnN0IHZlYzQgRElTQ0FSRF9QT1NJVElPTiA9IHZlYzQoMiwgMiwgMiwgMSk7XFxuY29uc3QgZmxvYXQgWVZfSCA9IDEuOTk5OTY5NDgyNDIxODc1O1xcbmNvbnN0IGZsb2F0IFlWX0wgPSAwLjAwMDAzMDUxNzExMjQ2MzcxMjY5MjtcXG52ZWMyIFZJU0lCSUxJVFlfSEFMRl9QWCA9IDAuNSAvIHZpc2liaWxpdHlTaXplO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIGZsb2F0IHZpc2liaWxpdHlBbHBoYSA9IHRleHR1cmUyRCh2aXNpYmlsaXR5LCB2ZXJ0ZXhJZC54eSArIFZJU0lCSUxJVFlfSEFMRl9QWCkuYTtcXG4gICAgaWYgKHZpc2liaWxpdHlBbHBoYSA9PSAwLjApIHtcXG4gICAgICAgIGdsX1Bvc2l0aW9uID0gRElTQ0FSRF9QT1NJVElPTjtcXG4gICAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICB2ZWM0IHBvc2l0aW9uID0gdmlld1Byb2pNYXRyaXggKiB2ZWM0KFxcbiAgICAgICAgWVZfSCAqICh2ZXJ0ZXhQb3NIaWdoIC0gbG9va0F0SGlnaCkgK1xcbiAgICAgICAgICAgIFlWX0wgKiAodmVydGV4UG9zTG93IC0gbG9va0F0TG93KSxcXG4gICAgICAgIDAsXFxuICAgICAgICAxXFxuICAgICk7XFxuICAgIHBvc2l0aW9uLnh5eiAvPSBwb3NpdGlvbi53O1xcbiAgICBwb3NpdGlvbi53ID0gMS4wO1xcblxcbiAgICBnbF9Qb3NpdGlvbiA9IHBvc2l0aW9uICsgdmVjNCh2ZXJ0ZXhEaXNwbGFjZW1lbnQgKiBwaXhlbFNpemUsIDAuMCwgMC4wKTtcXG5cXG4gICAgdXYgPSB2ZXJ0ZXhVVjtcXG4gICAgY29sb3IgPSB2ZXJ0ZXhDb2xvcjtcXG4gICAgY29sb3IuYSAqPSB2aXNpYmlsaXR5QWxwaGE7XFxuICAgIGJvcmRlclJhZGlpID0gdmVydGV4Qm9yZGVyUmFkaWk7XFxufVxcblwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIiN2ZXJzaW9uIDEwMFxcblxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxudmFyeWluZyB2ZWMyIHV2O1xcbnZhcnlpbmcgdmVjNCBjb2xvcjtcXG52YXJ5aW5nIHZlYzIgYm9yZGVyUmFkaWk7XFxuXFxuZmxvYXQgcm91bmRlZFJlY3RhbmdsZShjb25zdCBpbiB2ZWMyIHV2LCBjb25zdCBpbiB2ZWMyIHJhZGlpKSB7XFxuICAgIHZlYzIgYWJzVXYgPSBhYnModXYpO1xcbiAgICB2ZWMyIHEgPSBhYnNVdiArIHJhZGlpIC0gMS4wO1xcbiAgICByZXR1cm4gbWluKHEueCwgcS55KSA+IDAuMCA/IGxlbmd0aChxIC8gcmFkaWkpIDogbWF4KGFic1V2LngsIGFic1V2LnkpO1xcbn1cXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgICBnbF9GcmFnQ29sb3IgPSBzdGVwKHJvdW5kZWRSZWN0YW5nbGUodXYsIGJvcmRlclJhZGlpKSwgMS4wKSAqIGNvbG9yO1xcbn1cXG5cIiIsImltcG9ydCBjdXJ2ZWRMYWJlbFZlcnRleFNoYWRlciBmcm9tICcuL3NoYWRlci9jdXJ2ZWRfbGFiZWwudmVydCc7XHJcbmltcG9ydCBjb2xvcklkRnJhZ21lbnRTaGFkZXIgZnJvbSAnLi9zaGFkZXIvY29sb3JfaWQuZnJhZyc7XHJcbmltcG9ydCB7IFBST0dSQU1fT1BUSU9OUyB9IGZyb20gJy4uLy4uLy4uL3JlbmRlci9wcmltaXRpdmVzL2xhYmVsL2N1cnZlZF9sYWJlbF9yZW5kZXJfdW5pdCc7XHJcbmltcG9ydCBDb2xsaWRpbmdMYWJlbENvbG9ySWRSZW5kZXJlciBmcm9tICcuL2NvbG9yX2lkX2xhYmVsX3JlbmRlcmVyJztcclxuLyoqXHJcbiAqIEN1cnZlZCBsYWJlbHMgcmVuZGVyZXIgZm9yIGNvbGxpc2lvbiByZXNvbHV0aW9uLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29sb3JJZEN1cnZlZExhYmVsUmVuZGVyZXIgZXh0ZW5kcyBDb2xsaWRpbmdMYWJlbENvbG9ySWRSZW5kZXJlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBjYW1lcmEsIHByaW1pdGl2ZVByb3ZpZGVyKSB7XHJcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IGNvbnRleHQuY3JlYXRlUHJvZ3JhbShjdXJ2ZWRMYWJlbFZlcnRleFNoYWRlciwgY29sb3JJZEZyYWdtZW50U2hhZGVyLCBQUk9HUkFNX09QVElPTlMpO1xyXG4gICAgICAgIHN1cGVyKGNvbnRleHQsIHByb2dyYW0sIHByaW1pdGl2ZVByb3ZpZGVyLCBjYW1lcmEpO1xyXG4gICAgfVxyXG59XHJcbiIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleElkO1xcblxcbi8vIHBvaW50IGluIHRoZSB3b3JsZCB0aGUgbGFiZWwgaXMgYW5jaG9yZWQgdG9cXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhQb3NIaWdoO1xcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleFBvc0xvdztcXG5cXG4vLyB2ZWN0b3Igb2YgY29uY3JldGUgZ2x5cGggcG9pbnQgZGlzcGxhY2VtZW50ICh0b3AtbGVmdCwgYm90dG9tLWxlZnQsIC4uLikgcmVsYXRpdmUgdG8gZ2x5cGgncyBjZW50ZXIgKHR3byB2YWx1ZXMpLFxcbi8vIGFuZCBkaXN0YW5jZSBvZiB0aGUgZ2x5cGggY2VudGVyIHRvIGxhYmVsJ3MgY2VudGVyICh0aGlyZCB2YWx1ZSksIGluIHB4XFxuYXR0cmlidXRlIHZlYzMgdmVydGV4RGlzcGxhY2VtZW50cztcXG5cXG4vLyBjb29yZGluYXRlcyBvZiB0aGUgZ2x5cGggdmVydGV4IGluIHRoZSBhdGxhc1xcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleFVWO1xcblxcbmF0dHJpYnV0ZSBmbG9hdCB2ZXJ0ZXhQcmlvcml0eTtcXG5cXG5hdHRyaWJ1dGUgbG93cCB2ZWM0IHZlcnRleENvbG9yO1xcbmF0dHJpYnV0ZSBsb3dwIHZlYzQgdmVydGV4T3V0bGluZUNvbG9yO1xcbmF0dHJpYnV0ZSB2ZWMyIHBvbHlsaW5lTGVuZ3RoX3ZlcnRleFNjYWxlO1xcblxcbi8vIGRlbHRhcyByZWxhdGl2ZSB0byB0aGUgd29ybGQgcG9pbnQgZW5jb2RlZCBpbiB2ZXJ0ZXhQb3NIaWdoL3ZlcnRleFBvc0xvdyBlbmNvZGVkIHZpYSBsZW5ndGhzIGFuZCBhbmQgYW5nbGVzIG9mXFxuLy8gY29ycmVzcG9uZGluZyB2ZWN0b3JzXFxuYXR0cmlidXRlIHZlYzQgbGVmdFBvbHlsaW5lUmF0aW9zO1xcbmF0dHJpYnV0ZSB2ZWM0IGxlZnRQb2x5bGluZUFuZ2xlcztcXG5hdHRyaWJ1dGUgdmVjNCByaWdodFBvbHlsaW5lUmF0aW9zO1xcbmF0dHJpYnV0ZSB2ZWM0IHJpZ2h0UG9seWxpbmVBbmdsZXM7XFxuXFxudW5pZm9ybSB2ZWMyIGxvb2tBdEhpZ2g7XFxudW5pZm9ybSB2ZWMyIGxvb2tBdExvdztcXG51bmlmb3JtIG1hdDQgdmlld1Byb2pNYXRyaXg7XFxudW5pZm9ybSB2ZWMyIHBpeGVsU2l6ZTtcXG51bmlmb3JtIHNhbXBsZXIyRCB2aXNpYmlsaXR5O1xcbnVuaWZvcm0gdmVjMiBpZEhhbGZQeFNpemU7XFxudW5pZm9ybSB2ZWMyIHNoaWZ0O1xcbnVuaWZvcm0gbG93cCBmbG9hdCBjdXJyZW50Wm9vbTtcXG5cXG52YXJ5aW5nIHZlYzIgdXY7XFxudmFyeWluZyBsb3dwIHZlYzQgY29sb3I7XFxudmFyeWluZyBsb3dwIHZlYzQgb3V0bGluZUNvbG9yO1xcbnZhcnlpbmcgZmxvYXQgc2NhbGU7XFxuXFxuY29uc3QgdmVjNCBESVNDQVJEX1BPU0lUSU9OID0gdmVjNCgyLCAyLCAyLCAxKTtcXG5cXG5jb25zdCBmbG9hdCBZVl9IXzFfMCA9IDEuOTk5OTY5NDgyNDIxODc1O1xcbmNvbnN0IGZsb2F0IFlWX0xfMV8xID0gMC4wMDAwMzA1MTcxMTI0NjM3MTI2OTI7XFxuXFxuY29uc3QgZmxvYXQgUElfMV8yID0gMy4xNDE1OTI3NDEwMTI1NzMyO1xcblxcbmNvbnN0IGludCBNQVhfUE9MWUxJTkVfUE9JTlRTXzFfMyA9IDQ7XFxuY29uc3QgZmxvYXQgSU5GSU5JVFlfMV80ID0gMTAwMDAwMC4wOyAvLyBsYXJnZSBlbm91Z2ggZm9yIGEgc2VnbWVudCBsZW5ndGggdG8gY29uc2lkZXIgaXQgaW5maW5pdHlcXG5cXG4vKipcXG4gKiBSZXR1cm5zIHdvcmxkIGNvb3JkaW5hdGUgKHBsdXMgZGVsdGEpIHByb2plY3RlZCBvbiBzY3JlZW4sIGluIHBpeGVscy5cXG4gKi9cXG52ZWMyIHByb2plY3RfMV81KFxcbiAgICBtYXQ0IHZpZXdQcm9qTWF0cml4LFxcbiAgICB2ZWMyIGxvb2tBdEhpZ2gsXFxuICAgIHZlYzIgbG9va0F0TG93LFxcbiAgICB2ZWMyIHBpeGVsU2l6ZSxcXG4gICAgdmVjMiBwb2ludEhpZ2gsXFxuICAgIHZlYzIgcG9pbnRMb3csXFxuICAgIHZlYzIgZGVsdGFcXG4pIHtcXG4gICAgdmVjNCBwb3NpdGlvbiA9IHZpZXdQcm9qTWF0cml4ICogdmVjNChcXG4gICAgICAgICAgICBZVl9IXzFfMCAqIChwb2ludEhpZ2ggLSBsb29rQXRIaWdoKSArIFlWX0xfMV8xICogKHBvaW50TG93IC0gbG9va0F0TG93KSArIGRlbHRhLFxcbiAgICAgICAgICAgIDAsXFxuICAgICAgICAgICAgMVxcbiAgICAgICAgKTtcXG4gICAgdmVjMiBwcm9qZWN0ZWQgPSBwb3NpdGlvbi54eSAvIHBvc2l0aW9uLnc7XFxuICAgIHJldHVybiBwcm9qZWN0ZWQgLyBwaXhlbFNpemU7XFxufVxcblxcbi8qKlxcbiAqIEVhY2ggcG9pbnQgb2YgdGhlIHBvbHlsaW5lIGlzIGVuY29kZWQgYXMgYSB2ZWN0b3IgZnJvbSB0aGUgcG9seWxpbmUgY2VudGVyIGJ5IGl0cyBub3JtYWxpemVkIGFuZ2xlIGFuZCB0aGUgcmF0aW8gb2ZcXG4gKiBpdHMgbGVuZ3RoIHRvIHRoZSBwb2x5bGluZSdzIGxlbmd0aC5cXG4gKi9cXG52ZWMyIGRlY29kZVBvbHlsaW5lRGVsdGFzXzFfNihmbG9hdCByYXRpbywgZmxvYXQgYW5nbGUsIGZsb2F0IHBvbHlsaW5lTGVuZ3RoKSB7XFxuICAgIC8vIGRlbm9ybWFsaXplIGFuZ2xlIGJhY2sgdG8gcmFkaWFuc1xcbiAgICBmbG9hdCBhID0gYW5nbGUgKiAyLjAgKiBQSV8xXzIgLSBQSV8xXzI7XFxuICAgIC8vIGxlbmd0aCBvZiBhIHZlY3RvclxcbiAgICBmbG9hdCBsZW4gPSByYXRpbyAqIHBvbHlsaW5lTGVuZ3RoO1xcbiAgICAvLyByZXN0b3JlZCBwb2ludCdzICh4LCB5KSBjb29yZGluYXRlc1xcbiAgICByZXR1cm4gdmVjMihjb3MoYSksIHNpbihhKSkgKiBsZW47XFxufVxcblxcbi8qKlxcbiAqIFByb2plY3RzIHNwZWNpZmljIGN1cnZlZCBsYWJlbCB2ZXJ0ZXggb250byB0aGUgc2NyZWVuLiBUaGUgbGFiZWwgaXMgbGF5b3V0ZWQgYnkgY2VudGVyaW5nIHBvbHlsaW5lIGluXFxuICogdGhlIHZlcnRleFBvc0hpZ2gvdmVydGV4UG9zTG93IGFuZCBvdGhlciBwb2ludHMgYXJlIHVzZWQgdG8gZ3VpZGUgY29uY3JldGUgZ3J5cGggdmVydGV4LlxcbiAqIE51bWJlciBvZiBwb2x5bGluZSBwb2ludHMgaXMgaGFyZGNvZGVkIHRvIHBhc3MgdGhlbSBpbiBhdHRyaWJ1dGVzLlxcbiAqL1xcbnZlYzQgcHJvamVjdEN1cnZlZExhYmVsVmVydGV4XzFfNyhcXG4gICAgbWF0NCB2aWV3UHJvak1hdHJpeCxcXG4gICAgdmVjMiBsb29rQXRIaWdoLFxcbiAgICB2ZWMyIGxvb2tBdExvdyxcXG4gICAgdmVjMiBweFNpemUsXFxuICAgIHZlYzIgcG9zSGlnaCxcXG4gICAgdmVjMiBwb3NMb3csXFxuICAgIHZlYzIgZGlzcGxhY2VtZW50LFxcbiAgICBmbG9hdCBsaW5lRGlzcGxhY2VtZW50LFxcbiAgICBmbG9hdCBwb2x5bGluZUxlbmd0aCxcXG4gICAgdmVjNCBsZWZ0UG9seWxpbmVSYXRpb3MsXFxuICAgIHZlYzQgbGVmdFBvbHlsaW5lQW5nbGVzLFxcbiAgICB2ZWM0IHJpZ2h0UG9seWxpbmVSYXRpb3MsXFxuICAgIHZlYzQgcmlnaHRQb2x5bGluZUFuZ2xlc1xcbikge1xcbiAgICB2ZWMyIHBvbHlsaW5lRGVsdGFzW01BWF9QT0xZTElORV9QT0lOVFNfMV8zXTtcXG4gICAgdmVjMiBwb3NpdGlvbiA9IHByb2plY3RfMV81KHZpZXdQcm9qTWF0cml4LCBsb29rQXRIaWdoLCBsb29rQXRMb3csIHB4U2l6ZSwgcG9zSGlnaCwgcG9zTG93LCB2ZWMyKDAsIDApKTtcXG4gICAgZmxvYXQgcmVtYWluaW5nTGVuZ3RoID0gYWJzKGxpbmVEaXNwbGFjZW1lbnQpO1xcbiAgICBmb3IgKGludCBpID0gMDsgaSA8IE1BWF9QT0xZTElORV9QT0lOVFNfMV8zOyBpKyspIHtcXG4gICAgICAgIHZlYzIgcHJvamVjdGVkUG9pbnQ7XFxuXFxuICAgICAgICAvLyBmaWd1cmUgb3V0IHRoZSBkaXJlY3Rpb24gKGxlZnQvcmlnaHQpIGF0IHRoZSBmaXJzdCBzdGVwXFxuICAgICAgICBpZiAoaSA9PSAwKSB7XFxuICAgICAgICAgICAgcHJvamVjdGVkUG9pbnQgPSBwcm9qZWN0XzFfNShcXG4gICAgICAgICAgICAgICAgdmlld1Byb2pNYXRyaXgsXFxuICAgICAgICAgICAgICAgIGxvb2tBdEhpZ2gsXFxuICAgICAgICAgICAgICAgIGxvb2tBdExvdyxcXG4gICAgICAgICAgICAgICAgcHhTaXplLFxcbiAgICAgICAgICAgICAgICBwb3NIaWdoLFxcbiAgICAgICAgICAgICAgICBwb3NMb3csXFxuICAgICAgICAgICAgICAgIGRlY29kZVBvbHlsaW5lRGVsdGFzXzFfNihyaWdodFBvbHlsaW5lUmF0aW9zWzBdLCByaWdodFBvbHlsaW5lQW5nbGVzWzBdLCBwb2x5bGluZUxlbmd0aClcXG4gICAgICAgICAgICApO1xcbiAgICAgICAgICAgIGJvb2wgaXNSaWdodFBhcnQgPSBsaW5lRGlzcGxhY2VtZW50ID4gMC4wO1xcbiAgICAgICAgICAgIGJvb2wgaXNJbnZlcnRlZCA9IHByb2plY3RlZFBvaW50LnggPCBwb3NpdGlvbi54O1xcblxcbiAgICAgICAgICAgIC8vIHRoZSBtYXAgY291bGQgYmUgcm90YXRlZCBhbmQgY3VydmVkIGxhYmVsIHNob3VsZCBjaGFuZ2UgaXRzIGRpcmVjdGlvbiBpZiB0aGV5IGdvdCB1cHNpZGUgZG93blxcbiAgICAgICAgICAgIC8vIHVzaW5nIGNlbnRlciBzZWdtZW50IHRvIGlkZW50aWZ5IHRoaXMgY2FzZSBpcyBhbiBhcHByb3hpbWF0aW9uIChpZGVhbGx5IHdlIHNob3VsZCBjaGVjayBhbGwgc2VnbWVudHMpXFxuICAgICAgICAgICAgaWYgKGlzUmlnaHRQYXJ0IF5eIGlzSW52ZXJ0ZWQpIHtcXG4gICAgICAgICAgICAgICAgcG9seWxpbmVEZWx0YXNbMF0gPSBkZWNvZGVQb2x5bGluZURlbHRhc18xXzYocmlnaHRQb2x5bGluZVJhdGlvc1swXSwgcmlnaHRQb2x5bGluZUFuZ2xlc1swXSwgcG9seWxpbmVMZW5ndGgpO1xcbiAgICAgICAgICAgICAgICBwb2x5bGluZURlbHRhc1sxXSA9IGRlY29kZVBvbHlsaW5lRGVsdGFzXzFfNihyaWdodFBvbHlsaW5lUmF0aW9zWzFdLCByaWdodFBvbHlsaW5lQW5nbGVzWzFdLCBwb2x5bGluZUxlbmd0aCk7XFxuICAgICAgICAgICAgICAgIHBvbHlsaW5lRGVsdGFzWzJdID0gZGVjb2RlUG9seWxpbmVEZWx0YXNfMV82KHJpZ2h0UG9seWxpbmVSYXRpb3NbMl0sIHJpZ2h0UG9seWxpbmVBbmdsZXNbMl0sIHBvbHlsaW5lTGVuZ3RoKTtcXG4gICAgICAgICAgICAgICAgcG9seWxpbmVEZWx0YXNbM10gPSBkZWNvZGVQb2x5bGluZURlbHRhc18xXzYocmlnaHRQb2x5bGluZVJhdGlvc1szXSwgcmlnaHRQb2x5bGluZUFuZ2xlc1szXSwgcG9seWxpbmVMZW5ndGgpO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHBvbHlsaW5lRGVsdGFzWzBdID0gZGVjb2RlUG9seWxpbmVEZWx0YXNfMV82KGxlZnRQb2x5bGluZVJhdGlvc1swXSwgbGVmdFBvbHlsaW5lQW5nbGVzWzBdLCBwb2x5bGluZUxlbmd0aCk7XFxuICAgICAgICAgICAgICAgIHBvbHlsaW5lRGVsdGFzWzFdID0gZGVjb2RlUG9seWxpbmVEZWx0YXNfMV82KGxlZnRQb2x5bGluZVJhdGlvc1sxXSwgbGVmdFBvbHlsaW5lQW5nbGVzWzFdLCBwb2x5bGluZUxlbmd0aCk7XFxuICAgICAgICAgICAgICAgIHBvbHlsaW5lRGVsdGFzWzJdID0gZGVjb2RlUG9seWxpbmVEZWx0YXNfMV82KGxlZnRQb2x5bGluZVJhdGlvc1syXSwgbGVmdFBvbHlsaW5lQW5nbGVzWzJdLCBwb2x5bGluZUxlbmd0aCk7XFxuICAgICAgICAgICAgICAgIHBvbHlsaW5lRGVsdGFzWzNdID0gZGVjb2RlUG9seWxpbmVEZWx0YXNfMV82KGxlZnRQb2x5bGluZVJhdGlvc1szXSwgbGVmdFBvbHlsaW5lQW5nbGVzWzNdLCBwb2x5bGluZUxlbmd0aCk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIC8vIHRoZSBmaXJzdCByaWdodCBwb2ludCBvZiB0aGUgc2VnbWVudCBhbHJlYWR5IGNhbGN1bGF0ZWQsXFxuICAgICAgICAgICAgLy8gcmVjYWxjdWxhdGUgdGhlIHBvaW50IGlmIHRoaXMgcGFydCBvZiB0aGUgbGFiZWwgZ29lcyBvdGhlciBkaXJlY3Rpb25cXG4gICAgICAgICAgICBpZiAoIShpc1JpZ2h0UGFydCAmJiAhaXNJbnZlcnRlZCkgJiYgISghaXNSaWdodFBhcnQgJiYgaXNJbnZlcnRlZCkpIHtcXG4gICAgICAgICAgICAgICAgcHJvamVjdGVkUG9pbnQgPSBwcm9qZWN0XzFfNSh2aWV3UHJvak1hdHJpeCwgbG9va0F0SGlnaCwgbG9va0F0TG93LCBweFNpemUsIHBvc0hpZ2gsIHBvc0xvdywgcG9seWxpbmVEZWx0YXNbaV0pO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgcHJvamVjdGVkUG9pbnQgPSBwcm9qZWN0XzFfNSh2aWV3UHJvak1hdHJpeCwgbG9va0F0SGlnaCwgbG9va0F0TG93LCBweFNpemUsIHBvc0hpZ2gsIHBvc0xvdywgcG9seWxpbmVEZWx0YXNbaV0pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdmVjMiBzZWdtZW50ID0gcHJvamVjdGVkUG9pbnQgLSBwb3NpdGlvbjtcXG4gICAgICAgIGJvb2wgaXNMYXN0ID0gaSA9PSAoTUFYX1BPTFlMSU5FX1BPSU5UU18xXzMgLSAxKTtcXG4gICAgICAgIGZsb2F0IHNlZ21lbnRMZW5ndGggPSAoaXNMYXN0IHx8IChwb2x5bGluZURlbHRhc1tpICsgMV0gPT0gdmVjMigwLCAwKSkpID8gSU5GSU5JVFlfMV80IDogbGVuZ3RoKHNlZ21lbnQpO1xcblxcbiAgICAgICAgaWYgKHNlZ21lbnRMZW5ndGggPiByZW1haW5pbmdMZW5ndGgpIHtcXG4gICAgICAgICAgICBmbG9hdCBzaWduRmFjdG9yID0gbGluZURpc3BsYWNlbWVudCA+IDAuMCA/IDEuMCA6IC0xLjA7XFxuICAgICAgICAgICAgdmVjMiBkaXJlY3Rpb24gPSBub3JtYWxpemUoc2VnbWVudCk7XFxuICAgICAgICAgICAgdmVjMiBub3JtYWwgPSB2ZWMyKC1kaXJlY3Rpb24ueSwgZGlyZWN0aW9uLngpO1xcblxcbiAgICAgICAgICAgIHBvc2l0aW9uICs9IGRpcmVjdGlvbiAqIHJlbWFpbmluZ0xlbmd0aDtcXG4gICAgICAgICAgICBwb3NpdGlvbiArPSBzaWduRmFjdG9yICogZGlyZWN0aW9uICogZGlzcGxhY2VtZW50Lng7XFxuICAgICAgICAgICAgcG9zaXRpb24gKz0gc2lnbkZhY3RvciAqIG5vcm1hbCAqIGRpc3BsYWNlbWVudC55O1xcblxcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICByZW1haW5pbmdMZW5ndGggLT0gc2VnbWVudExlbmd0aDtcXG4gICAgICAgICAgICBwb3NpdGlvbiArPSBzZWdtZW50O1xcbiAgICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHJldHVybiB2ZWM0KHBvc2l0aW9uICogcHhTaXplLCAwLjAsIDEuMCk7XFxufVxcblxcblxcblxcblxcblxcbi8qKlxcbiAqIEN1cnZlZCBsYWJlbHMgYXJlIGxheW91dGVkIGhlcmU6IHRoZSBsYWJlbCBpcyBjZW50ZXJlZCBpbiB0aGUgdmVydGV4UG9zSGlnaC92ZXJ0ZXhQb3NMb3cgYW5kIHBvbHlsaW5lIHBvaW50c1xcbiAqIGFyZSB1c2VkIHRvIGd1aWRlIGNvbmNyZXRlIGdyeXBoIHZlcnRleC4gTnVtYmVyIG9mIHBvbHlsaW5lIHBvaW50cyBpcyBoYXJkY29kZWQgdG8gcGFzcyB0aGVtIGluIGF0dHJpYnV0ZXMuXFxuICovXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gICAgdmVjMiBpZFRleENvb3JkaW5hdGUgPSB2ZXJ0ZXhJZC54eSArIGlkSGFsZlB4U2l6ZTtcXG4gICAgZmxvYXQgb3ZlcmxhcFpvb20gPSB0ZXh0dXJlMkQodmlzaWJpbGl0eSwgaWRUZXhDb29yZGluYXRlKS5iO1xcblxcbiAgICBpZiAoY3VycmVudFpvb20gPCBvdmVybGFwWm9vbSkge1xcbiAgICAgICAgZ2xfUG9zaXRpb24gPSBESVNDQVJEX1BPU0lUSU9OO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgdmVjMiB2ZXJ0ZXhEaXNwbGFjZW1lbnQgPSB2ZXJ0ZXhEaXNwbGFjZW1lbnRzLnh5O1xcbiAgICAgICAgZmxvYXQgdmVydGV4TGluZURpc3BsYWNlbWVudCA9IHZlcnRleERpc3BsYWNlbWVudHMuejtcXG4gICAgICAgIGZsb2F0IHBvbHlsaW5lTGVuZ3RoID0gcG9seWxpbmVMZW5ndGhfdmVydGV4U2NhbGVbMF07XFxuICAgICAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3RDdXJ2ZWRMYWJlbFZlcnRleF8xXzcoXFxuICAgICAgICAgICAgdmlld1Byb2pNYXRyaXgsXFxuICAgICAgICAgICAgbG9va0F0SGlnaCxcXG4gICAgICAgICAgICBsb29rQXRMb3csXFxuICAgICAgICAgICAgcGl4ZWxTaXplLFxcbiAgICAgICAgICAgIHZlcnRleFBvc0hpZ2gsXFxuICAgICAgICAgICAgdmVydGV4UG9zTG93LFxcbiAgICAgICAgICAgIHZlcnRleERpc3BsYWNlbWVudCxcXG4gICAgICAgICAgICB2ZXJ0ZXhMaW5lRGlzcGxhY2VtZW50LFxcbiAgICAgICAgICAgIHBvbHlsaW5lTGVuZ3RoLFxcbiAgICAgICAgICAgIGxlZnRQb2x5bGluZVJhdGlvcyxcXG4gICAgICAgICAgICBsZWZ0UG9seWxpbmVBbmdsZXMsXFxuICAgICAgICAgICAgcmlnaHRQb2x5bGluZVJhdGlvcyxcXG4gICAgICAgICAgICByaWdodFBvbHlsaW5lQW5nbGVzXFxuICAgICAgICApO1xcblxcbiAgICAgICAgZ2xfUG9zaXRpb24ueHkgKz0gc2hpZnQ7XFxuICAgICAgICBnbF9Qb3NpdGlvbi56ID0gdmVydGV4UHJpb3JpdHk7XFxuXFxuICAgICAgICBjb2xvciA9IHZlYzQodmVydGV4SWQsIDAsIDEpO1xcbiAgICB9XFxufVxcblwiIiwiaW1wb3J0IGN1cnZlZExhYmVsVmVydGV4U2hhZGVyIGZyb20gJy4vc2hhZGVyL2N1cnZlZF9sYWJlbC52ZXJ0JztcclxuaW1wb3J0IGRmVGV4dEZyYWdtZW50U2hhZGVyIGZyb20gJy4vc2hhZGVyL2RmX3RleHQuZnJhZyc7XHJcbmltcG9ydCBMYWJlbFJlbmRlclVuaXQgZnJvbSAnLi9sYWJlbF9yZW5kZXJfdW5pdCc7XHJcbmV4cG9ydCBjb25zdCBQUk9HUkFNX09QVElPTlMgPSB7XHJcbiAgICBhdHRyaWJNYXA6IHtcclxuICAgICAgICB2ZXJ0ZXhJZDogMiAvKiBJRCAqLyxcclxuICAgICAgICB2ZXJ0ZXhQb3NIaWdoOiAwIC8qIFBPU0lUSU9OX0hJR0ggKi8sXHJcbiAgICAgICAgdmVydGV4UG9zTG93OiAxIC8qIFBPU0lUSU9OX0xPVyAqLyxcclxuICAgICAgICB2ZXJ0ZXhEaXNwbGFjZW1lbnRzOiA2IC8qIERJU1BMQUNFTUVOVCAqLyxcclxuICAgICAgICB2ZXJ0ZXhVVjogNCAvKiBVViAqLyxcclxuICAgICAgICB2ZXJ0ZXhDb2xvcjogNyAvKiBDT0xPUiAqLyxcclxuICAgICAgICB2ZXJ0ZXhPdXRsaW5lQ29sb3I6IDggLyogT1VUTElORV9DT0xPUiAqLyxcclxuICAgICAgICB2ZXJ0ZXhQcmlvcml0eTogOSAvKiBQUklPUklUWSAqLyxcclxuICAgICAgICBsZWZ0UG9seWxpbmVSYXRpb3M6IDEyIC8qIEFVWDEgKi8sXHJcbiAgICAgICAgbGVmdFBvbHlsaW5lQW5nbGVzOiAxMyAvKiBBVVgyICovLFxyXG4gICAgICAgIHJpZ2h0UG9seWxpbmVSYXRpb3M6IDE0IC8qIEFVWDMgKi8sXHJcbiAgICAgICAgcmlnaHRQb2x5bGluZUFuZ2xlczogMTUgLyogQVVYNCAqLyxcclxuICAgICAgICBwb2x5bGluZUxlbmd0aF92ZXJ0ZXhTY2FsZTogMTEgLyogQVVYICovXHJcbiAgICB9XHJcbn07XHJcbi8qKlxyXG4gKiBDdXJ2ZWQgbGFiZWxzIHJlbmRlcmVyLiBJdCB1c2VzIGFwcHJvcHJpYXRlIHByb2dyYW0gdG8gbGF5b3V0IGdseXBocyBvbiBHUFUuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDdXJ2ZWRMYWJlbFJlbmRlclVuaXQgZXh0ZW5kcyBMYWJlbFJlbmRlclVuaXQge1xyXG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgY2FtZXJhLCB2aXNpYmlsaXR5UHJvdmlkZXIsIHByaW1pdGl2ZVByb3ZpZGVyKSB7XHJcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IGNvbnRleHQuY3JlYXRlUHJvZ3JhbShjdXJ2ZWRMYWJlbFZlcnRleFNoYWRlciwgZGZUZXh0RnJhZ21lbnRTaGFkZXIsIFBST0dSQU1fT1BUSU9OUyk7XHJcbiAgICAgICAgc3VwZXIoY29udGV4dCwgcHJvZ3JhbSwgY2FtZXJhLCB2aXNpYmlsaXR5UHJvdmlkZXIsIHByaW1pdGl2ZVByb3ZpZGVyKTtcclxuICAgIH1cclxufVxyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiI3ZlcnNpb24gMTAwXFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhJZDtcXG5cXG4vLyBwb2ludCBpbiB0aGUgd29ybGQgdGhlIGxhYmVsIGlzIGFuY2hvcmVkIHRvXFxuYXR0cmlidXRlIHZlYzIgdmVydGV4UG9zSGlnaDtcXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhQb3NMb3c7XFxuXFxuLy8gdmVjdG9yIG9mIGNvbmNyZXRlIGdseXBoIHBvaW50IGRpc3BsYWNlbWVudCAodG9wLWxlZnQsIGJvdHRvbS1sZWZ0LCAuLi4pIHJlbGF0aXZlIHRvIGdseXBoJ3MgY2VudGVyICh0d28gdmFsdWVzKSxcXG4vLyBhbmQgZGlzdGFuY2Ugb2YgdGhlIGdseXBoIGNlbnRlciB0byBsYWJlbCdzIGNlbnRlciAodGhpcmQgdmFsdWUpLCBpbiBweFxcbmF0dHJpYnV0ZSB2ZWMzIHZlcnRleERpc3BsYWNlbWVudHM7XFxuXFxuLy8gY29vcmRpbmF0ZXMgb2YgdGhlIGdseXBoIHZlcnRleCBpbiB0aGUgYXRsYXNcXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhVVjtcXG5cXG5hdHRyaWJ1dGUgZmxvYXQgdmVydGV4UHJpb3JpdHk7XFxuXFxuYXR0cmlidXRlIGxvd3AgdmVjNCB2ZXJ0ZXhDb2xvcjtcXG5hdHRyaWJ1dGUgbG93cCB2ZWM0IHZlcnRleE91dGxpbmVDb2xvcjtcXG5hdHRyaWJ1dGUgdmVjMiBwb2x5bGluZUxlbmd0aF92ZXJ0ZXhTY2FsZTtcXG5cXG4vLyBkZWx0YXMgcmVsYXRpdmUgdG8gdGhlIHdvcmxkIHBvaW50IGVuY29kZWQgaW4gdmVydGV4UG9zSGlnaC92ZXJ0ZXhQb3NMb3cgZW5jb2RlZCB2aWEgbGVuZ3RocyBhbmQgYW5kIGFuZ2xlcyBvZlxcbi8vIGNvcnJlc3BvbmRpbmcgdmVjdG9yc1xcbmF0dHJpYnV0ZSB2ZWM0IGxlZnRQb2x5bGluZVJhdGlvcztcXG5hdHRyaWJ1dGUgdmVjNCBsZWZ0UG9seWxpbmVBbmdsZXM7XFxuYXR0cmlidXRlIHZlYzQgcmlnaHRQb2x5bGluZVJhdGlvcztcXG5hdHRyaWJ1dGUgdmVjNCByaWdodFBvbHlsaW5lQW5nbGVzO1xcblxcbnVuaWZvcm0gdmVjMiBsb29rQXRIaWdoO1xcbnVuaWZvcm0gdmVjMiBsb29rQXRMb3c7XFxudW5pZm9ybSBtYXQ0IHZpZXdQcm9qTWF0cml4O1xcbnVuaWZvcm0gdmVjMiBwaXhlbFNpemU7XFxudW5pZm9ybSBzYW1wbGVyMkQgdmlzaWJpbGl0eTtcXG51bmlmb3JtIHZlYzIgaWRIYWxmUHhTaXplO1xcbnVuaWZvcm0gdmVjMiBzaGlmdDtcXG51bmlmb3JtIGxvd3AgZmxvYXQgY3VycmVudFpvb207XFxuXFxudmFyeWluZyB2ZWMyIHV2O1xcbnZhcnlpbmcgbG93cCB2ZWM0IGNvbG9yO1xcbnZhcnlpbmcgbG93cCB2ZWM0IG91dGxpbmVDb2xvcjtcXG52YXJ5aW5nIGZsb2F0IHNjYWxlO1xcblxcbmNvbnN0IHZlYzQgRElTQ0FSRF9QT1NJVElPTiA9IHZlYzQoMiwgMiwgMiwgMSk7XFxuXFxuY29uc3QgZmxvYXQgWVZfSF8xXzAgPSAxLjk5OTk2OTQ4MjQyMTg3NTtcXG5jb25zdCBmbG9hdCBZVl9MXzFfMSA9IDAuMDAwMDMwNTE3MTEyNDYzNzEyNjkyO1xcblxcbmNvbnN0IGZsb2F0IFBJXzFfMiA9IDMuMTQxNTkyNzQxMDEyNTczMjtcXG5cXG5jb25zdCBpbnQgTUFYX1BPTFlMSU5FX1BPSU5UU18xXzMgPSA0O1xcbmNvbnN0IGZsb2F0IElORklOSVRZXzFfNCA9IDEwMDAwMDAuMDsgLy8gbGFyZ2UgZW5vdWdoIGZvciBhIHNlZ21lbnQgbGVuZ3RoIHRvIGNvbnNpZGVyIGl0IGluZmluaXR5XFxuXFxuLyoqXFxuICogUmV0dXJucyB3b3JsZCBjb29yZGluYXRlIChwbHVzIGRlbHRhKSBwcm9qZWN0ZWQgb24gc2NyZWVuLCBpbiBwaXhlbHMuXFxuICovXFxudmVjMiBwcm9qZWN0XzFfNShcXG4gICAgbWF0NCB2aWV3UHJvak1hdHJpeCxcXG4gICAgdmVjMiBsb29rQXRIaWdoLFxcbiAgICB2ZWMyIGxvb2tBdExvdyxcXG4gICAgdmVjMiBwaXhlbFNpemUsXFxuICAgIHZlYzIgcG9pbnRIaWdoLFxcbiAgICB2ZWMyIHBvaW50TG93LFxcbiAgICB2ZWMyIGRlbHRhXFxuKSB7XFxuICAgIHZlYzQgcG9zaXRpb24gPSB2aWV3UHJvak1hdHJpeCAqIHZlYzQoXFxuICAgICAgICAgICAgWVZfSF8xXzAgKiAocG9pbnRIaWdoIC0gbG9va0F0SGlnaCkgKyBZVl9MXzFfMSAqIChwb2ludExvdyAtIGxvb2tBdExvdykgKyBkZWx0YSxcXG4gICAgICAgICAgICAwLFxcbiAgICAgICAgICAgIDFcXG4gICAgICAgICk7XFxuICAgIHZlYzIgcHJvamVjdGVkID0gcG9zaXRpb24ueHkgLyBwb3NpdGlvbi53O1xcbiAgICByZXR1cm4gcHJvamVjdGVkIC8gcGl4ZWxTaXplO1xcbn1cXG5cXG4vKipcXG4gKiBFYWNoIHBvaW50IG9mIHRoZSBwb2x5bGluZSBpcyBlbmNvZGVkIGFzIGEgdmVjdG9yIGZyb20gdGhlIHBvbHlsaW5lIGNlbnRlciBieSBpdHMgbm9ybWFsaXplZCBhbmdsZSBhbmQgdGhlIHJhdGlvIG9mXFxuICogaXRzIGxlbmd0aCB0byB0aGUgcG9seWxpbmUncyBsZW5ndGguXFxuICovXFxudmVjMiBkZWNvZGVQb2x5bGluZURlbHRhc18xXzYoZmxvYXQgcmF0aW8sIGZsb2F0IGFuZ2xlLCBmbG9hdCBwb2x5bGluZUxlbmd0aCkge1xcbiAgICAvLyBkZW5vcm1hbGl6ZSBhbmdsZSBiYWNrIHRvIHJhZGlhbnNcXG4gICAgZmxvYXQgYSA9IGFuZ2xlICogMi4wICogUElfMV8yIC0gUElfMV8yO1xcbiAgICAvLyBsZW5ndGggb2YgYSB2ZWN0b3JcXG4gICAgZmxvYXQgbGVuID0gcmF0aW8gKiBwb2x5bGluZUxlbmd0aDtcXG4gICAgLy8gcmVzdG9yZWQgcG9pbnQncyAoeCwgeSkgY29vcmRpbmF0ZXNcXG4gICAgcmV0dXJuIHZlYzIoY29zKGEpLCBzaW4oYSkpICogbGVuO1xcbn1cXG5cXG4vKipcXG4gKiBQcm9qZWN0cyBzcGVjaWZpYyBjdXJ2ZWQgbGFiZWwgdmVydGV4IG9udG8gdGhlIHNjcmVlbi4gVGhlIGxhYmVsIGlzIGxheW91dGVkIGJ5IGNlbnRlcmluZyBwb2x5bGluZSBpblxcbiAqIHRoZSB2ZXJ0ZXhQb3NIaWdoL3ZlcnRleFBvc0xvdyBhbmQgb3RoZXIgcG9pbnRzIGFyZSB1c2VkIHRvIGd1aWRlIGNvbmNyZXRlIGdyeXBoIHZlcnRleC5cXG4gKiBOdW1iZXIgb2YgcG9seWxpbmUgcG9pbnRzIGlzIGhhcmRjb2RlZCB0byBwYXNzIHRoZW0gaW4gYXR0cmlidXRlcy5cXG4gKi9cXG52ZWM0IHByb2plY3RDdXJ2ZWRMYWJlbFZlcnRleF8xXzcoXFxuICAgIG1hdDQgdmlld1Byb2pNYXRyaXgsXFxuICAgIHZlYzIgbG9va0F0SGlnaCxcXG4gICAgdmVjMiBsb29rQXRMb3csXFxuICAgIHZlYzIgcHhTaXplLFxcbiAgICB2ZWMyIHBvc0hpZ2gsXFxuICAgIHZlYzIgcG9zTG93LFxcbiAgICB2ZWMyIGRpc3BsYWNlbWVudCxcXG4gICAgZmxvYXQgbGluZURpc3BsYWNlbWVudCxcXG4gICAgZmxvYXQgcG9seWxpbmVMZW5ndGgsXFxuICAgIHZlYzQgbGVmdFBvbHlsaW5lUmF0aW9zLFxcbiAgICB2ZWM0IGxlZnRQb2x5bGluZUFuZ2xlcyxcXG4gICAgdmVjNCByaWdodFBvbHlsaW5lUmF0aW9zLFxcbiAgICB2ZWM0IHJpZ2h0UG9seWxpbmVBbmdsZXNcXG4pIHtcXG4gICAgdmVjMiBwb2x5bGluZURlbHRhc1tNQVhfUE9MWUxJTkVfUE9JTlRTXzFfM107XFxuICAgIHZlYzIgcG9zaXRpb24gPSBwcm9qZWN0XzFfNSh2aWV3UHJvak1hdHJpeCwgbG9va0F0SGlnaCwgbG9va0F0TG93LCBweFNpemUsIHBvc0hpZ2gsIHBvc0xvdywgdmVjMigwLCAwKSk7XFxuICAgIGZsb2F0IHJlbWFpbmluZ0xlbmd0aCA9IGFicyhsaW5lRGlzcGxhY2VtZW50KTtcXG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCBNQVhfUE9MWUxJTkVfUE9JTlRTXzFfMzsgaSsrKSB7XFxuICAgICAgICB2ZWMyIHByb2plY3RlZFBvaW50O1xcblxcbiAgICAgICAgLy8gZmlndXJlIG91dCB0aGUgZGlyZWN0aW9uIChsZWZ0L3JpZ2h0KSBhdCB0aGUgZmlyc3Qgc3RlcFxcbiAgICAgICAgaWYgKGkgPT0gMCkge1xcbiAgICAgICAgICAgIHByb2plY3RlZFBvaW50ID0gcHJvamVjdF8xXzUoXFxuICAgICAgICAgICAgICAgIHZpZXdQcm9qTWF0cml4LFxcbiAgICAgICAgICAgICAgICBsb29rQXRIaWdoLFxcbiAgICAgICAgICAgICAgICBsb29rQXRMb3csXFxuICAgICAgICAgICAgICAgIHB4U2l6ZSxcXG4gICAgICAgICAgICAgICAgcG9zSGlnaCxcXG4gICAgICAgICAgICAgICAgcG9zTG93LFxcbiAgICAgICAgICAgICAgICBkZWNvZGVQb2x5bGluZURlbHRhc18xXzYocmlnaHRQb2x5bGluZVJhdGlvc1swXSwgcmlnaHRQb2x5bGluZUFuZ2xlc1swXSwgcG9seWxpbmVMZW5ndGgpXFxuICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICBib29sIGlzUmlnaHRQYXJ0ID0gbGluZURpc3BsYWNlbWVudCA+IDAuMDtcXG4gICAgICAgICAgICBib29sIGlzSW52ZXJ0ZWQgPSBwcm9qZWN0ZWRQb2ludC54IDwgcG9zaXRpb24ueDtcXG5cXG4gICAgICAgICAgICAvLyB0aGUgbWFwIGNvdWxkIGJlIHJvdGF0ZWQgYW5kIGN1cnZlZCBsYWJlbCBzaG91bGQgY2hhbmdlIGl0cyBkaXJlY3Rpb24gaWYgdGhleSBnb3QgdXBzaWRlIGRvd25cXG4gICAgICAgICAgICAvLyB1c2luZyBjZW50ZXIgc2VnbWVudCB0byBpZGVudGlmeSB0aGlzIGNhc2UgaXMgYW4gYXBwcm94aW1hdGlvbiAoaWRlYWxseSB3ZSBzaG91bGQgY2hlY2sgYWxsIHNlZ21lbnRzKVxcbiAgICAgICAgICAgIGlmIChpc1JpZ2h0UGFydCBeXiBpc0ludmVydGVkKSB7XFxuICAgICAgICAgICAgICAgIHBvbHlsaW5lRGVsdGFzWzBdID0gZGVjb2RlUG9seWxpbmVEZWx0YXNfMV82KHJpZ2h0UG9seWxpbmVSYXRpb3NbMF0sIHJpZ2h0UG9seWxpbmVBbmdsZXNbMF0sIHBvbHlsaW5lTGVuZ3RoKTtcXG4gICAgICAgICAgICAgICAgcG9seWxpbmVEZWx0YXNbMV0gPSBkZWNvZGVQb2x5bGluZURlbHRhc18xXzYocmlnaHRQb2x5bGluZVJhdGlvc1sxXSwgcmlnaHRQb2x5bGluZUFuZ2xlc1sxXSwgcG9seWxpbmVMZW5ndGgpO1xcbiAgICAgICAgICAgICAgICBwb2x5bGluZURlbHRhc1syXSA9IGRlY29kZVBvbHlsaW5lRGVsdGFzXzFfNihyaWdodFBvbHlsaW5lUmF0aW9zWzJdLCByaWdodFBvbHlsaW5lQW5nbGVzWzJdLCBwb2x5bGluZUxlbmd0aCk7XFxuICAgICAgICAgICAgICAgIHBvbHlsaW5lRGVsdGFzWzNdID0gZGVjb2RlUG9seWxpbmVEZWx0YXNfMV82KHJpZ2h0UG9seWxpbmVSYXRpb3NbM10sIHJpZ2h0UG9seWxpbmVBbmdsZXNbM10sIHBvbHlsaW5lTGVuZ3RoKTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBwb2x5bGluZURlbHRhc1swXSA9IGRlY29kZVBvbHlsaW5lRGVsdGFzXzFfNihsZWZ0UG9seWxpbmVSYXRpb3NbMF0sIGxlZnRQb2x5bGluZUFuZ2xlc1swXSwgcG9seWxpbmVMZW5ndGgpO1xcbiAgICAgICAgICAgICAgICBwb2x5bGluZURlbHRhc1sxXSA9IGRlY29kZVBvbHlsaW5lRGVsdGFzXzFfNihsZWZ0UG9seWxpbmVSYXRpb3NbMV0sIGxlZnRQb2x5bGluZUFuZ2xlc1sxXSwgcG9seWxpbmVMZW5ndGgpO1xcbiAgICAgICAgICAgICAgICBwb2x5bGluZURlbHRhc1syXSA9IGRlY29kZVBvbHlsaW5lRGVsdGFzXzFfNihsZWZ0UG9seWxpbmVSYXRpb3NbMl0sIGxlZnRQb2x5bGluZUFuZ2xlc1syXSwgcG9seWxpbmVMZW5ndGgpO1xcbiAgICAgICAgICAgICAgICBwb2x5bGluZURlbHRhc1szXSA9IGRlY29kZVBvbHlsaW5lRGVsdGFzXzFfNihsZWZ0UG9seWxpbmVSYXRpb3NbM10sIGxlZnRQb2x5bGluZUFuZ2xlc1szXSwgcG9seWxpbmVMZW5ndGgpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAvLyB0aGUgZmlyc3QgcmlnaHQgcG9pbnQgb2YgdGhlIHNlZ21lbnQgYWxyZWFkeSBjYWxjdWxhdGVkLFxcbiAgICAgICAgICAgIC8vIHJlY2FsY3VsYXRlIHRoZSBwb2ludCBpZiB0aGlzIHBhcnQgb2YgdGhlIGxhYmVsIGdvZXMgb3RoZXIgZGlyZWN0aW9uXFxuICAgICAgICAgICAgaWYgKCEoaXNSaWdodFBhcnQgJiYgIWlzSW52ZXJ0ZWQpICYmICEoIWlzUmlnaHRQYXJ0ICYmIGlzSW52ZXJ0ZWQpKSB7XFxuICAgICAgICAgICAgICAgIHByb2plY3RlZFBvaW50ID0gcHJvamVjdF8xXzUodmlld1Byb2pNYXRyaXgsIGxvb2tBdEhpZ2gsIGxvb2tBdExvdywgcHhTaXplLCBwb3NIaWdoLCBwb3NMb3csIHBvbHlsaW5lRGVsdGFzW2ldKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHByb2plY3RlZFBvaW50ID0gcHJvamVjdF8xXzUodmlld1Byb2pNYXRyaXgsIGxvb2tBdEhpZ2gsIGxvb2tBdExvdywgcHhTaXplLCBwb3NIaWdoLCBwb3NMb3csIHBvbHlsaW5lRGVsdGFzW2ldKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZlYzIgc2VnbWVudCA9IHByb2plY3RlZFBvaW50IC0gcG9zaXRpb247XFxuICAgICAgICBib29sIGlzTGFzdCA9IGkgPT0gKE1BWF9QT0xZTElORV9QT0lOVFNfMV8zIC0gMSk7XFxuICAgICAgICBmbG9hdCBzZWdtZW50TGVuZ3RoID0gKGlzTGFzdCB8fCAocG9seWxpbmVEZWx0YXNbaSArIDFdID09IHZlYzIoMCwgMCkpKSA/IElORklOSVRZXzFfNCA6IGxlbmd0aChzZWdtZW50KTtcXG5cXG4gICAgICAgIGlmIChzZWdtZW50TGVuZ3RoID4gcmVtYWluaW5nTGVuZ3RoKSB7XFxuICAgICAgICAgICAgZmxvYXQgc2lnbkZhY3RvciA9IGxpbmVEaXNwbGFjZW1lbnQgPiAwLjAgPyAxLjAgOiAtMS4wO1xcbiAgICAgICAgICAgIHZlYzIgZGlyZWN0aW9uID0gbm9ybWFsaXplKHNlZ21lbnQpO1xcbiAgICAgICAgICAgIHZlYzIgbm9ybWFsID0gdmVjMigtZGlyZWN0aW9uLnksIGRpcmVjdGlvbi54KTtcXG5cXG4gICAgICAgICAgICBwb3NpdGlvbiArPSBkaXJlY3Rpb24gKiByZW1haW5pbmdMZW5ndGg7XFxuICAgICAgICAgICAgcG9zaXRpb24gKz0gc2lnbkZhY3RvciAqIGRpcmVjdGlvbiAqIGRpc3BsYWNlbWVudC54O1xcbiAgICAgICAgICAgIHBvc2l0aW9uICs9IHNpZ25GYWN0b3IgKiBub3JtYWwgKiBkaXNwbGFjZW1lbnQueTtcXG5cXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgcmVtYWluaW5nTGVuZ3RoIC09IHNlZ21lbnRMZW5ndGg7XFxuICAgICAgICAgICAgcG9zaXRpb24gKz0gc2VnbWVudDtcXG4gICAgICAgIH1cXG4gICAgfVxcblxcbiAgICByZXR1cm4gdmVjNChwb3NpdGlvbiAqIHB4U2l6ZSwgMC4wLCAxLjApO1xcbn1cXG5cXG5cXG5cXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgICAvL2Zsb2F0IHZpc2liaWxpdHlBbHBoYSA9IHRleHR1cmUyRCh2aXNpYmlsaXR5LCB2ZXJ0ZXhJZC54eSArIGlkSGFsZlB4U2l6ZSkuYTtcXG4gICAgZmxvYXQgdmlzaWJpbGl0eUFscGhhID0gMS4wO1xcbiAgICBpZiAodmlzaWJpbGl0eUFscGhhICE9IDAuMCkge1xcbiAgICAgICAgdmVjMiB2ZXJ0ZXhEaXNwbGFjZW1lbnQgPSB2ZXJ0ZXhEaXNwbGFjZW1lbnRzLnh5O1xcbiAgICAgICAgZmxvYXQgdmVydGV4TGluZURpc3BsYWNlbWVudCA9IHZlcnRleERpc3BsYWNlbWVudHMuejtcXG4gICAgICAgIGZsb2F0IHBvbHlsaW5lTGVuZ3RoID0gcG9seWxpbmVMZW5ndGhfdmVydGV4U2NhbGVbMF07XFxuICAgICAgICBmbG9hdCB2ZXJ0ZXhTY2FsZSA9IHBvbHlsaW5lTGVuZ3RoX3ZlcnRleFNjYWxlWzFdO1xcbiAgICAgICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0Q3VydmVkTGFiZWxWZXJ0ZXhfMV83KFxcbiAgICAgICAgICAgIHZpZXdQcm9qTWF0cml4LFxcbiAgICAgICAgICAgIGxvb2tBdEhpZ2gsXFxuICAgICAgICAgICAgbG9va0F0TG93LFxcbiAgICAgICAgICAgIHBpeGVsU2l6ZSxcXG4gICAgICAgICAgICB2ZXJ0ZXhQb3NIaWdoLFxcbiAgICAgICAgICAgIHZlcnRleFBvc0xvdyxcXG4gICAgICAgICAgICB2ZXJ0ZXhEaXNwbGFjZW1lbnQsXFxuICAgICAgICAgICAgdmVydGV4TGluZURpc3BsYWNlbWVudCxcXG4gICAgICAgICAgICBwb2x5bGluZUxlbmd0aCxcXG4gICAgICAgICAgICBsZWZ0UG9seWxpbmVSYXRpb3MsXFxuICAgICAgICAgICAgbGVmdFBvbHlsaW5lQW5nbGVzLFxcbiAgICAgICAgICAgIHJpZ2h0UG9seWxpbmVSYXRpb3MsXFxuICAgICAgICAgICAgcmlnaHRQb2x5bGluZUFuZ2xlc1xcbiAgICAgICAgKTtcXG5cXG4gICAgICAgIHV2ID0gdmVydGV4VVY7XFxuICAgICAgICBjb2xvciA9IHZlcnRleENvbG9yO1xcbiAgICAgICAgb3V0bGluZUNvbG9yID0gdmVydGV4T3V0bGluZUNvbG9yO1xcbiAgICAgICAgc2NhbGUgPSB2ZXJ0ZXhTY2FsZTtcXG5cXG4gICAgICAgIGNvbG9yLmEgKj0gdmlzaWJpbGl0eUFscGhhO1xcbiAgICAgICAgb3V0bGluZUNvbG9yLmEgKj0gdmlzaWJpbGl0eUFscGhhO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgZ2xfUG9zaXRpb24gPSBESVNDQVJEX1BPU0lUSU9OO1xcbiAgICB9XFxufVxcblwiIiwiaW1wb3J0IGljb25WZXJ0ZXhTaGFkZXIgZnJvbSAnLi9zaGFkZXIvaWNvbi52ZXJ0JztcclxuaW1wb3J0IGljb25GcmFnbWVudFNoYWRlciBmcm9tICcuL3NoYWRlci9pY29uLmZyYWcnO1xyXG5pbXBvcnQgSW1hZ2VSZW5kZXJVbml0IGZyb20gJy4uL2ltYWdlL2ltYWdlX3JlbmRlcl91bml0JztcclxuLyoqXHJcbiAqIFJlbmRlcmVyIG9mIGljb24gcHJpbWl0aXZlcy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEljb25SZW5kZXJVbml0IGV4dGVuZHMgSW1hZ2VSZW5kZXJVbml0IHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIGNhbWVyYSwgcHJpbWl0aXZlUHJvdmlkZXIpIHtcclxuICAgICAgICBjb25zdCBwcm9ncmFtID0gY29udGV4dC5jcmVhdGVQcm9ncmFtKGljb25WZXJ0ZXhTaGFkZXIsIGljb25GcmFnbWVudFNoYWRlciwge1xyXG4gICAgICAgICAgICBhdHRyaWJNYXA6IHtcclxuICAgICAgICAgICAgICAgIHZlcnRleFBvc0hpZ2g6IDAgLyogUE9TSVRJT05fSElHSCAqLyxcclxuICAgICAgICAgICAgICAgIHZlcnRleFBvc0xvdzogMSAvKiBQT1NJVElPTl9MT1cgKi8sXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhEaXNwbGFjZW1lbnQ6IDYgLyogRElTUExBQ0VNRU5UICovLFxyXG4gICAgICAgICAgICAgICAgdmVydGV4VVY6IDQgLyogVVYgKi9cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHN1cGVyKGNvbnRleHQsIHByaW1pdGl2ZVByb3ZpZGVyLCBwcm9ncmFtKTtcclxuICAgICAgICB0aGlzLl9jYW1lcmEgPSBjYW1lcmE7XHJcbiAgICB9XHJcbiAgICBfcHJlcGFyZVByb2dyYW0ocHJvZ3JhbSwgdmlld1Byb2pNYXRyaXgsIGNhbWVyYVBvc2l0aW9ucykge1xyXG4gICAgICAgIHN1cGVyLl9wcmVwYXJlUHJvZ3JhbShwcm9ncmFtLCB2aWV3UHJvak1hdHJpeCwgY2FtZXJhUG9zaXRpb25zKTtcclxuICAgICAgICBwcm9ncmFtLnNldFZlY3RvcjJVbmlmb3JtKCdwaXhlbFNpemUnLCB0aGlzLl9jYW1lcmEucGl4ZWxTaXplKTtcclxuICAgIH1cclxufVxyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiI3ZlcnNpb24gMTAwXFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhQb3NIaWdoO1xcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleFBvc0xvdztcXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhEaXNwbGFjZW1lbnQ7XFxuYXR0cmlidXRlIHZlYzIgdmVydGV4VVY7XFxuXFxudW5pZm9ybSB2ZWMyIGxvb2tBdEhpZ2g7XFxudW5pZm9ybSB2ZWMyIGxvb2tBdExvdztcXG51bmlmb3JtIG1hdDQgdmlld1Byb2pNYXRyaXg7XFxudW5pZm9ybSB2ZWMyIHBpeGVsU2l6ZTtcXG5cXG52YXJ5aW5nIHZlYzIgdXY7XFxuXFxuY29uc3QgZmxvYXQgWVZfSCA9IDEuOTk5OTY5NDgyNDIxODc1O1xcbmNvbnN0IGZsb2F0IFlWX0wgPSAwLjAwMDAzMDUxNzExMjQ2MzcxMjY5MjtcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIHZlYzQgcG9zaXRpb24gPSB2aWV3UHJvak1hdHJpeCAqIHZlYzQoXFxuICAgICAgICBZVl9IICogKHZlcnRleFBvc0hpZ2ggLSBsb29rQXRIaWdoKSArXFxuICAgICAgICAgICAgWVZfTCAqICh2ZXJ0ZXhQb3NMb3cgLSBsb29rQXRMb3cpLFxcbiAgICAgICAgMCxcXG4gICAgICAgIDFcXG4gICAgKTtcXG4gICAgcG9zaXRpb24gPSB2ZWM0KHBvc2l0aW9uLnh5IC8gcG9zaXRpb24udywgMC4wLCAxLjApO1xcblxcbiAgICBnbF9Qb3NpdGlvbiA9IHBvc2l0aW9uICsgdmVjNCh2ZXJ0ZXhEaXNwbGFjZW1lbnQgKiBwaXhlbFNpemUsIDAuMCwgMC4wKTtcXG5cXG4gICAgdXYgPSB2ZXJ0ZXhVVjtcXG59XFxuXCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiI3ZlcnNpb24gMTAwXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCBhdGxhcztcXG51bmlmb3JtIHZlYzIgYXRsYXNTaXplO1xcblxcbnZhcnlpbmcgdmVjMiB1djtcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRChhdGxhcywgdXYgLyBhdGxhc1NpemUpO1xcbn1cXG5cIiIsImltcG9ydCBpbWFnZVZlcnRleFNoYWRlciBmcm9tICcuL3NoYWRlci9pbWFnZS52ZXJ0JztcclxuaW1wb3J0IGltYWdlRnJhZ21lbnRTaGFkZXIgZnJvbSAnLi9zaGFkZXIvaW1hZ2UuZnJhZyc7XHJcbmltcG9ydCAqIGFzIHZlYzIgZnJvbSAnLi4vLi4vLi4vbWF0aC92ZWN0b3IyJztcclxuaW1wb3J0IFdvcmxkUHJpbWl0aXZlUmVuZGVyVW5pdCBmcm9tICcuLi93b3JsZF9wcmltaXRpdmVfcmVuZGVyX3VuaXQnO1xyXG5pbXBvcnQgUmVuZGVyU3RhdGUgZnJvbSAnLi4vLi4vLi4vcmVuZGVyL3N0YXRlJztcclxuaW1wb3J0IHsgQkxFTkRfT1ZFUl9SRU5ERVJfU1RBVEUgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXIvc3RhdGUnO1xyXG5jb25zdCBSRU5ERVJfU1RBVEUgPSBuZXcgUmVuZGVyU3RhdGUoQkxFTkRfT1ZFUl9SRU5ERVJfU1RBVEUpO1xyXG5mdW5jdGlvbiBjcmVhdGVEZWZhdWx0UHJvZ3JhbShjb250ZXh0KSB7XHJcbiAgICByZXR1cm4gY29udGV4dC5jcmVhdGVQcm9ncmFtKGltYWdlVmVydGV4U2hhZGVyLCBpbWFnZUZyYWdtZW50U2hhZGVyLCB7XHJcbiAgICAgICAgYXR0cmliTWFwOiB7XHJcbiAgICAgICAgICAgIHZlcnRleFBvc0hpZ2g6IDAgLyogUE9TSVRJT05fSElHSCAqLyxcclxuICAgICAgICAgICAgdmVydGV4UG9zTG93OiAxIC8qIFBPU0lUSU9OX0xPVyAqLyxcclxuICAgICAgICAgICAgdmVydGV4VVY6IDQgLyogVVYgKi9cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG4vKipcclxuICogUmVuZGVyZXIgb2YgaW1hZ2UgcHJpbWl0aXZlcy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEltYWdlUmVuZGVyVW5pdCBleHRlbmRzIFdvcmxkUHJpbWl0aXZlUmVuZGVyVW5pdCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBwcmltaXRpdmVQcm92aWRlciwgcHJvZ3JhbSA9IGNyZWF0ZURlZmF1bHRQcm9ncmFtKGNvbnRleHQpKSB7XHJcbiAgICAgICAgc3VwZXIoY29udGV4dCwgUkVOREVSX1NUQVRFLCBwcm9ncmFtLCBwcmltaXRpdmVQcm92aWRlcik7XHJcbiAgICAgICAgdGhpcy5fYXRsYXNTaXplVW5pZm9ybSA9IHZlYzIuY3JlYXRlKDAsIDApO1xyXG4gICAgICAgIGNvbnRleHQuYmluZFByb2dyYW0ocHJvZ3JhbSk7XHJcbiAgICAgICAgcHJvZ3JhbS5zZXRJbnRTY2FsYXJVbmlmb3JtKCdhdGxhcycsIDApO1xyXG4gICAgfVxyXG4gICAgX3JlbmRlckJhdGNoKG1lbW9yeUJhdGNoKSB7XHJcbiAgICAgICAgY29uc3QgYXRsYXMgPSBtZW1vcnlCYXRjaC5maXJzdFByaW1pdGl2ZS5hdGxhcztcclxuICAgICAgICB0aGlzLl9hdGxhc1NpemVVbmlmb3JtLnggPSBhdGxhcy53aWR0aDtcclxuICAgICAgICB0aGlzLl9hdGxhc1NpemVVbmlmb3JtLnkgPSBhdGxhcy5oZWlnaHQ7XHJcbiAgICAgICAgaWYgKGF0bGFzLmlzRGlydHkpIHtcclxuICAgICAgICAgICAgYXRsYXMuc3luY1RleHR1cmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcHJvZ3JhbS5zZXRWZWN0b3IyVW5pZm9ybSgnYXRsYXNTaXplJywgdGhpcy5fYXRsYXNTaXplVW5pZm9ybSk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kVGV4dHVyZVVuaXQoMCk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kVGV4dHVyZShhdGxhcy50ZXh0dXJlKTtcclxuICAgICAgICBzdXBlci5fcmVuZGVyQmF0Y2gobWVtb3J5QmF0Y2gpO1xyXG4gICAgfVxyXG4gICAgX2NhbkJhdGNoQWRqYWNlbnRQcmltaXRpdmVzKGEsIGIpIHtcclxuICAgICAgICByZXR1cm4gc3VwZXIuX2NhbkJhdGNoQWRqYWNlbnRQcmltaXRpdmVzKGEsIGIpICYmIChhLmF0bGFzID09PSBiLmF0bGFzKTtcclxuICAgIH1cclxufVxyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiI3ZlcnNpb24gMTAwXFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhQb3NIaWdoO1xcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleFBvc0xvdztcXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhVVjtcXG5cXG51bmlmb3JtIHZlYzIgbG9va0F0SGlnaDtcXG51bmlmb3JtIHZlYzIgbG9va0F0TG93O1xcbnVuaWZvcm0gbWF0NCB2aWV3UHJvak1hdHJpeDtcXG5cXG52YXJ5aW5nIHZlYzIgdXY7XFxuXFxuY29uc3QgZmxvYXQgWVZfSCA9IDEuOTk5OTY5NDgyNDIxODc1O1xcbmNvbnN0IGZsb2F0IFlWX0wgPSAwLjAwMDAzMDUxNzExMjQ2MzcxMjY5MjtcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIHZlYzQgcG9zaXRpb24gPSB2aWV3UHJvak1hdHJpeCAqIHZlYzQoXFxuICAgICAgICBZVl9IICogKHZlcnRleFBvc0hpZ2ggLSBsb29rQXRIaWdoKSArXFxuICAgICAgICAgICAgWVZfTCAqICh2ZXJ0ZXhQb3NMb3cgLSBsb29rQXRMb3cpLFxcbiAgICAgICAgMCxcXG4gICAgICAgIDFcXG4gICAgKTtcXG5cXG4gICAgZ2xfUG9zaXRpb24gPSBwb3NpdGlvbjtcXG5cXG4gICAgdXYgPSB2ZXJ0ZXhVVjtcXG59XFxuXCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiI3ZlcnNpb24gMTAwXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCBhdGxhcztcXG51bmlmb3JtIHZlYzIgYXRsYXNTaXplO1xcblxcbnZhcnlpbmcgdmVjMiB1djtcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRChhdGxhcywgdXYgLyBhdGxhc1NpemUpO1xcblxcbiAgICBpZiAoZ2xfRnJhZ0NvbG9yLmEgPT0gMC4wKSB7XFxuICAgICAgICBkaXNjYXJkO1xcbiAgICB9XFxufVxcblwiIiwiaW1wb3J0IG1vZGVsVmVydGV4U2hhZGVyIGZyb20gJy4vc2hhZGVyL21vZGVsLnZlcnQnO1xyXG5pbXBvcnQgbW9kZWxGcmFnbWVudFNoYWRlciBmcm9tICcuL3NoYWRlci9tb2RlbC5mcmFnJztcclxuaW1wb3J0IHsgY3JlYXRlRXh0ZW50MiB9IGZyb20gJy4uLy4uLy4uL21hdGgvdmVjdG9yMic7XHJcbmltcG9ydCBPdmVybGF5UmVuZGVyZXIgZnJvbSAnLi4vb3ZlcmxheS9vdmVybGF5X3JlbmRlcmVyJztcclxuaW1wb3J0IFJlbmRlclN0YXRlIGZyb20gJy4uLy4uLy4uL3JlbmRlci9zdGF0ZSc7XHJcbmltcG9ydCBXb3JsZFByaW1pdGl2ZVJlbmRlclVuaXQgZnJvbSAnLi4vd29ybGRfcHJpbWl0aXZlX3JlbmRlcl91bml0JztcclxuY29uc3QgUkVOREVSX1NUQVRFID0gbmV3IFJlbmRlclN0YXRlKHtcclxuICAgIGRlcHRoVGVzdDogdHJ1ZVxyXG59KTtcclxuLyoqXHJcbiAqIFJlbmRlcmVyIG9mIG1vZGVscy4gSXQgcmVuZGVycyBtb2RlbHMgaW50byBhIHRleHR1cmUgd2l0aCBkZXB0aCB0ZXN0IGFuZCB0aGVuIHRoaXMgdGV4dHVyZSBpbnRvIHRoZSByZW5kZXIgdGFyZ2V0LlxyXG4gKiBJdCBhbGxvd3MgdG8gc2hvdyBvbmx5IHRoZSB0b3AgZmFjZXRzIG9mIHNlbWktdHJhbnNwYXJlbnQgb2JqZWN0cyB3aXRob3V0IGV4cG9zaW5nIHRoZWlyIGlubmVyIHN0cnVjdHVyZS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vZGVsUmVuZGVyVW5pdCBleHRlbmRzIFdvcmxkUHJpbWl0aXZlUmVuZGVyVW5pdCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBwcmltaXRpdmVQcm92aWRlcikge1xyXG4gICAgICAgIGNvbnN0IHByb2dyYW0gPSBjb250ZXh0LmNyZWF0ZVByb2dyYW0obW9kZWxWZXJ0ZXhTaGFkZXIsIG1vZGVsRnJhZ21lbnRTaGFkZXIsIHtcclxuICAgICAgICAgICAgYXR0cmliTWFwOiB7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhQb3NIaWdoOiAwIC8qIFBPU0lUSU9OX0hJR0ggKi8sXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhQb3NMb3c6IDEgLyogUE9TSVRJT05fTE9XICovLFxyXG4gICAgICAgICAgICAgICAgdmVydGV4SGVpZ2h0OiAzIC8qIEhFSUdIVCAqLyxcclxuICAgICAgICAgICAgICAgIHZlcnRleENvbG9yOiA3IC8qIENPTE9SICovXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBzdXBlcihjb250ZXh0LCBSRU5ERVJfU1RBVEUsIHByb2dyYW0sIHByaW1pdGl2ZVByb3ZpZGVyKTtcclxuICAgICAgICB0aGlzLl9vdXRwdXRTaXplID0gY3JlYXRlRXh0ZW50MigtMSwgLTEpO1xyXG4gICAgICAgIHRoaXMuX292ZXJsYXlSZW5kZXJlciA9IG5ldyBPdmVybGF5UmVuZGVyZXIoY29udGV4dCk7XHJcbiAgICB9XHJcbiAgICByZW5kZXIodGFyZ2V0LCB2aWV3UHJvak1hdHJpeCwgY2FtZXJhUG9zaXRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5fc3luY091dHB1dEJ1ZmZlcih0YXJnZXQpO1xyXG4gICAgICAgIHN1cGVyLnJlbmRlcih0aGlzLl9vdXRwdXRCdWZmZXIsIHZpZXdQcm9qTWF0cml4LCBjYW1lcmFQb3NpdGlvbnMpO1xyXG4gICAgICAgIC8vIGRvIG5vdCBydW4gdW5uZWNlc3NhcnkgY29weWluZyBpZiB0aGlzLl9vdXRwdXRCdWZmZXIgd2FzIG5vdCB1cGRhdGVkIChubyBtb2RlbHMgaW4gc2NlbmU/KVxyXG4gICAgICAgIGlmICghdGhpcy5fb3V0cHV0QnVmZmVyLmlzQ2xlYXIpIHtcclxuICAgICAgICAgICAgLy8gY29weSBpbnRvIHRoZSBmaW5hbCB0YXJnZXRcclxuICAgICAgICAgICAgdGhpcy5fb3ZlcmxheVJlbmRlcmVyLnJlbmRlcih0YXJnZXQsIHRoaXMuX291dHB1dFRleHR1cmUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5fb3ZlcmxheVJlbmRlcmVyLmRlc3Ryb3koKTtcclxuICAgICAgICBpZiAodGhpcy5fb3V0cHV0VGV4dHVyZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9vdXRwdXRUZXh0dXJlLmRlc3Ryb3koKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX291dHB1dERlcHRoQnVmZmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX291dHB1dERlcHRoQnVmZmVyLmRlc3Ryb3koKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX291dHB1dEJ1ZmZlcikge1xyXG4gICAgICAgICAgICB0aGlzLl9vdXRwdXRCdWZmZXIuZGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdXBlci5kZXN0cm95KCk7XHJcbiAgICB9XHJcbiAgICBfc3luY091dHB1dEJ1ZmZlcih0YXJnZXQpIHtcclxuICAgICAgICAvLyBtYWtlIHN1cmUgdGhlIGludGVybWVkaWF0ZSB0ZXh0dXJlIGZpdHMgdGhlIG91dHB1dCB0YXJnZXRcclxuICAgICAgICBpZiAodGhpcy5fb3V0cHV0U2l6ZS53aWR0aCAhPT0gdGFyZ2V0LmdldFdpZHRoKCkgfHxcclxuICAgICAgICAgICAgdGhpcy5fb3V0cHV0U2l6ZS5oZWlnaHQgIT09IHRhcmdldC5nZXRIZWlnaHQoKSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fb3V0cHV0VGV4dHVyZSB8fCB0aGlzLl9vdXRwdXREZXB0aEJ1ZmZlciB8fCB0aGlzLl9vdXRwdXRCdWZmZXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX291dHB1dFRleHR1cmUuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fb3V0cHV0RGVwdGhCdWZmZXIuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fb3V0cHV0QnVmZmVyLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9vdXRwdXRTaXplID0geyB3aWR0aDogdGFyZ2V0LmdldFdpZHRoKCksIGhlaWdodDogdGFyZ2V0LmdldEhlaWdodCgpIH07XHJcbiAgICAgICAgICAgIHRoaXMuX291dHB1dFRleHR1cmUgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUVtcHR5MkRUZXh0dXJlKHRoaXMuX291dHB1dFNpemUud2lkdGgsIHRoaXMuX291dHB1dFNpemUuaGVpZ2h0LCA2NDA4IC8qIFJHQkEgKi8sIDUxMjEgLyogVU5TSUdORURfQllURSAqLyk7XHJcbiAgICAgICAgICAgIHRoaXMuX291dHB1dERlcHRoQnVmZmVyID0gdGhpcy5fY29udGV4dC5jcmVhdGVSZW5kZXJidWZmZXIodGhpcy5fb3V0cHV0U2l6ZS53aWR0aCwgdGhpcy5fb3V0cHV0U2l6ZS5oZWlnaHQsIDM0MDQxIC8qIERFUFRIX1NURU5DSUwgKi8pO1xyXG4gICAgICAgICAgICB0aGlzLl9vdXRwdXRCdWZmZXIgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUZyYW1lYnVmZmVyKHtcclxuICAgICAgICAgICAgICAgIGNvbG9yOiB0aGlzLl9vdXRwdXRUZXh0dXJlLFxyXG4gICAgICAgICAgICAgICAgZGVwdGhTdGVuY2lsOiB0aGlzLl9vdXRwdXREZXB0aEJ1ZmZlclxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE92ZXJyaWRkZW4gX2JpbmRSZW5kZXJUYXJnZXQoKSB0byBiaW5kIGludGVybWVkaWF0ZSByZW5kZXIgdGFyZ2V0IHRvIHJlbmRlciBtb2RlbHMgaW50byBhbmRcclxuICAgICAqIGxhdGVyIHB1dCBpdHMgY29udGVudCBpbnRvIHRoZSBmaW5hbCB0YXJnZXQuXHJcbiAgICAgKi9cclxuICAgIF9wcmVwYXJlUmVuZGVyVGFyZ2V0KHRhcmdldCwgdmlld1Byb2pNYXRyaXgsIGNhbWVyYVBvc2l0aW9ucykge1xyXG4gICAgICAgIHN1cGVyLl9wcmVwYXJlUmVuZGVyVGFyZ2V0KHRhcmdldCwgdmlld1Byb2pNYXRyaXgsIGNhbWVyYVBvc2l0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5jbGVhckN1cnJlbnRUYXJnZXQoMTYzODQgLyogQ09MT1JfQlVGRkVSX0JJVCAqLyB8IDI1NiAvKiBERVBUSF9CVUZGRVJfQklUICovKTtcclxuICAgIH1cclxufVxyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiI3ZlcnNpb24gMTAwXFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG5hdHRyaWJ1dGUgdmVjMyB2ZXJ0ZXhQb3NIaWdoO1xcbmF0dHJpYnV0ZSB2ZWMzIHZlcnRleFBvc0xvdztcXG5hdHRyaWJ1dGUgZmxvYXQgdmVydGV4SGVpZ2h0O1xcbmF0dHJpYnV0ZSB2ZWM0IHZlcnRleENvbG9yO1xcblxcbnVuaWZvcm0gdmVjMiBsb29rQXRIaWdoO1xcbnVuaWZvcm0gdmVjMiBsb29rQXRMb3c7XFxudW5pZm9ybSBtYXQ0IHZpZXdQcm9qTWF0cml4O1xcblxcbnZhcnlpbmcgdmVjNCBnbG9iYWxQb3M7XFxudmFyeWluZyB2ZWM0IGRpZmZ1c2VDb2xvcjtcXG5cXG5jb25zdCBmbG9hdCBZVl9IID0gMS45OTk5Njk0ODI0MjE4NzU7XFxuY29uc3QgZmxvYXQgWVZfTCA9IDAuMDAwMDMwNTE3MTEyNDYzNzEyNjkyO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIGdsb2JhbFBvcyA9IHZlYzQoXFxuICAgICAgICBZVl9IICogKHZlcnRleFBvc0hpZ2gueHkgLSBsb29rQXRIaWdoKSArIFlWX0wgKiAodmVydGV4UG9zTG93Lnh5IC0gbG9va0F0TG93KSxcXG4gICAgICAgIHZlcnRleEhlaWdodCxcXG4gICAgICAgIDFcXG4gICAgKTtcXG5cXG4gICAgZ2xfUG9zaXRpb24gPSB2aWV3UHJvak1hdHJpeCAqIGdsb2JhbFBvcztcXG4gICAgZGlmZnVzZUNvbG9yID0gdmVydGV4Q29sb3I7XFxufVxcblwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIiN2ZXJzaW9uIDEwMFxcblxcbiNleHRlbnNpb24gR0xfT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzIDogcmVxdWlyZVxcblxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxudmFyeWluZyB2ZWM0IGRpZmZ1c2VDb2xvcjtcXG52YXJ5aW5nIHZlYzQgZ2xvYmFsUG9zO1xcblxcbmNvbnN0IHZlYzMgTElHSFRfRElSRUNUSU9OID0gbm9ybWFsaXplKHZlYzMoMC41LCAwLjUsIDEuMCkpO1xcbmNvbnN0IGZsb2F0IExJR0hUX0lOVEVOU0lUWSA9IDAuMztcXG5jb25zdCBmbG9hdCBBTUJJRU5UX0xJR0hUX0lOVEVOU0lUWSA9IDEuMCAtIExJR0hUX0lOVEVOU0lUWTtcXG5jb25zdCBmbG9hdCBIT1JJWk9OVEFMX1BMQU5FX0RJRkZVU0VfSU5URU5TSVRZID1cXG4gICAgQU1CSUVOVF9MSUdIVF9JTlRFTlNJVFkgKyAwLjUgKiBMSUdIVF9JTlRFTlNJVFkgKiAoTElHSFRfRElSRUNUSU9OLnogKyAxLjApO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIHZlYzMgcG9zID0gZ2xvYmFsUG9zLnh5ejtcXG5cXG4gICAgdmVjMyBkeHBvcyA9IG5vcm1hbGl6ZShkRmR4KHBvcykpO1xcbiAgICB2ZWMzIGR5cG9zID0gbm9ybWFsaXplKGRGZHkocG9zKSk7XFxuICAgIHZlYzMgbm9ybWFsID0gbm9ybWFsaXplKGNyb3NzKGR4cG9zLCBkeXBvcykpO1xcblxcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KFxcbiAgICAgICAgZGlmZnVzZUNvbG9yLnJnYiAqIChBTUJJRU5UX0xJR0hUX0lOVEVOU0lUWSArIDAuNSAqIExJR0hUX0lOVEVOU0lUWSAqIChkb3Qobm9ybWFsLCBMSUdIVF9ESVJFQ1RJT04pICsgMS4wKSkgL1xcbiAgICAgICAgICAgIEhPUklaT05UQUxfUExBTkVfRElGRlVTRV9JTlRFTlNJVFksXFxuICAgICAgICBkaWZmdXNlQ29sb3IuYVxcbiAgICApO1xcbn1cXG5cIiIsImltcG9ydCBvdmVybGF5VmVydGV4U2hhZGVyIGZyb20gJy4vc2hhZGVyL292ZXJsYXkudmVydCc7XHJcbmltcG9ydCBvdmVybGF5RnJhZ21lbnRTaGFkZXIgZnJvbSAnLi9zaGFkZXIvb3ZlcmxheS5mcmFnJztcclxuaW1wb3J0IHsgR2xSZW5kZXJlciB9IGZyb20gJy4uLy4uLy4uL3JlbmRlci9nbF9yZW5kZXJlcic7XHJcbmltcG9ydCBSZW5kZXJTdGF0ZSBmcm9tICcuLi8uLi8uLi9yZW5kZXIvc3RhdGUnO1xyXG5pbXBvcnQgeyBCTEVORF9PVkVSX1JFTkRFUl9TVEFURSB9IGZyb20gJy4uLy4uLy4uL3JlbmRlci9zdGF0ZSc7XHJcbmNvbnN0IFJFTkRFUl9TVEFURSA9IG5ldyBSZW5kZXJTdGF0ZShCTEVORF9PVkVSX1JFTkRFUl9TVEFURSk7XHJcbi8qKlxyXG4gKiBSZW5kZXJzIGEgdGV4dHVyZSBpbnRvIGEgcmVuZGVyIHRhcmdldCB3aXRoIE9WRVIgY29tcG9zaXRpbmcuIFRoZSB0ZXh0dXJlIHdpbGwgY29tcGxldGVseSBvdmVybGF5IHRoZSB0YXJnZXQsIGkuZS5cclxuICogaXQgaXMgc3RyZXRjaGVkL3Nocmlua2VkIHRvIGZpdCB0aGUgdGFyZ2V0IHdpZHRoL2hlaWdodCwgc28gaWRlYWxseSB0aGV5IHNob3VsZCBoYXZlIHRoZSBzYW1lIGRpbWVuc2lvbnMuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBPdmVybGF5UmVuZGVyZXIgZXh0ZW5kcyBHbFJlbmRlcmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcclxuICAgICAgICBjb25zdCBwcm9ncmFtID0gY29udGV4dC5jcmVhdGVQcm9ncmFtKG92ZXJsYXlWZXJ0ZXhTaGFkZXIsIG92ZXJsYXlGcmFnbWVudFNoYWRlciwge1xyXG4gICAgICAgICAgICBhdHRyaWJNYXA6IHtcclxuICAgICAgICAgICAgICAgIHZlcnRleFBvc2l0aW9uOiAwIC8qIFBPU0lUSU9OICovLFxyXG4gICAgICAgICAgICAgICAgdmVydGV4VVY6IDQgLyogVVYgKi9cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHN1cGVyKGNvbnRleHQsIFJFTkRFUl9TVEFURSwgcHJvZ3JhbSk7XHJcbiAgICB9XHJcbiAgICBfcmVuZGVyKHRleHR1cmUpIHtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRUZXh0dXJlVW5pdCgwKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRUZXh0dXJlKHRleHR1cmUpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFF1YWRWYW8oKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmRyYXdRdWFkKCk7XHJcbiAgICB9XHJcbn1cclxuIiwibW9kdWxlLmV4cG9ydHMgPSBcIiN2ZXJzaW9uIDEwMFxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxuYXR0cmlidXRlIHZlYzIgdmVydGV4UG9zaXRpb247XFxuYXR0cmlidXRlIHZlYzIgdmVydGV4VVY7XFxuXFxudmFyeWluZyB2ZWMyIHV2O1xcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgZ2xfUG9zaXRpb24gPSB2ZWM0KHZlcnRleFBvc2l0aW9uLCAwLCAxKTtcXG4gICAgdXYgPSB2ZXJ0ZXhVVjtcXG59XFxuXCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiI3ZlcnNpb24gMTAwXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCB0ZXh0dXJlO1xcblxcbnZhcnlpbmcgdmVjMiB1djtcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh0ZXh0dXJlLCB1dik7XFxufVxcblwiIiwiaW1wb3J0IHRleHR1cmVkUG9seWxpbmVWZXJ0ZXhTaGFkZXIgZnJvbSAnLi9zaGFkZXIvdGV4dHVyZWRfcG9seWxpbmUudmVydCc7XHJcbmltcG9ydCB0ZXh0dXJlZFBvbHlsaW5lRnJhZ21lbnRTaGFkZXIgZnJvbSAnLi9zaGFkZXIvdGV4dHVyZWRfcG9seWxpbmUuZnJhZyc7XHJcbmltcG9ydCAqIGFzIHZlYzIgZnJvbSAnLi4vLi4vLi4vbWF0aC92ZWN0b3IyJztcclxuaW1wb3J0IFJlbmRlclN0YXRlLCB7IEJMRU5EX09WRVJfUFJFTVVMVElQTElFRF9BTFBIQV9SRU5ERVJfU1RBVEUgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXIvc3RhdGUnO1xyXG5pbXBvcnQgQmFzZVBvbHlsaW5lUmVuZGVyVW5pdCBmcm9tICcuL2Jhc2VfcG9seWxpbmVfcmVuZGVyX3VuaXQnO1xyXG5jb25zdCBGSUxURVJfUkFESVVTID0gMS4wIC8gZGV2aWNlUGl4ZWxSYXRpbztcclxuY29uc3QgUkVOREVSX1NUQVRFID0gbmV3IFJlbmRlclN0YXRlKEJMRU5EX09WRVJfUFJFTVVMVElQTElFRF9BTFBIQV9SRU5ERVJfU1RBVEUsIHtcclxuICAgIGRlcHRoVGVzdDogdHJ1ZSxcclxuICAgIGRlcHRoTWFzazogZmFsc2UsXHJcbiAgICBkZXB0aEZ1bmM6IDUxOCAvKiBHUkVBVEVSX09SX0VRVUFMICovXHJcbn0pO1xyXG4vKipcclxuICogUmVuZGVyZXIgb2YgcG9seWxpbmUgcHJpbWl0aXZlcy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRleHR1cmVkUG9seWxpbmVSZW5kZXJVbml0IGV4dGVuZHMgQmFzZVBvbHlsaW5lUmVuZGVyVW5pdCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBjYW1lcmEsIHByaW1pdGl2ZVByb3ZpZGVyKSB7XHJcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IGNvbnRleHQuY3JlYXRlUHJvZ3JhbSh0ZXh0dXJlZFBvbHlsaW5lVmVydGV4U2hhZGVyLCB0ZXh0dXJlZFBvbHlsaW5lRnJhZ21lbnRTaGFkZXIsIHtcclxuICAgICAgICAgICAgZGVmaW5lczoge1xyXG4gICAgICAgICAgICAgICAgRklMVEVSX1JBRElVUzogYGZsb2F0KCR7RklMVEVSX1JBRElVU30pYFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhdHRyaWJNYXA6IHtcclxuICAgICAgICAgICAgICAgIHZlcnRleFBvc0hpZ2g6IDAgLyogUE9TSVRJT05fSElHSCAqLyxcclxuICAgICAgICAgICAgICAgIHZlcnRleFBvc0xvdzogMSAvKiBQT1NJVElPTl9MT1cgKi8sXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhEaXNwbGFjZW1lbnQ6IDYgLyogRElTUExBQ0VNRU5UICovLFxyXG4gICAgICAgICAgICAgICAgdmVydGV4VVY6IDQgLyogVVYgKi8sXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhaSW5kZXg6IDkgLyogUFJJT1JJVFkgKi8sXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhIYWxmV2lkdGg6IDExIC8qIEFVWCAqLyxcclxuICAgICAgICAgICAgICAgIHZlcnRleFBhdHRlcm46IDEyIC8qIEFVWDEgKi8sXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhQYXR0ZXJuSGFsZkhlaWdodDogMTMgLyogQVVYMiAqL1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc3VwZXIoY29udGV4dCwgUkVOREVSX1NUQVRFLCBwcm9ncmFtLCBwcmltaXRpdmVQcm92aWRlciwgY2FtZXJhKTtcclxuICAgICAgICB0aGlzLl9hdGxhc1NpemVVbmlmb3JtID0gdmVjMi5jcmVhdGUoMCwgMCk7XHJcbiAgICAgICAgY29udGV4dC5iaW5kUHJvZ3JhbShwcm9ncmFtKTtcclxuICAgICAgICBwcm9ncmFtLnNldEludFNjYWxhclVuaWZvcm0oJ2F0bGFzJywgMCk7XHJcbiAgICB9XHJcbiAgICBfcmVuZGVyQmF0Y2gobWVtb3J5QmF0Y2gpIHtcclxuICAgICAgICBjb25zdCBhdGxhcyA9IG1lbW9yeUJhdGNoLmZpcnN0UHJpbWl0aXZlLmF0bGFzO1xyXG4gICAgICAgIHRoaXMuX2F0bGFzU2l6ZVVuaWZvcm0ueCA9IGF0bGFzLndpZHRoO1xyXG4gICAgICAgIHRoaXMuX2F0bGFzU2l6ZVVuaWZvcm0ueSA9IGF0bGFzLmhlaWdodDtcclxuICAgICAgICBpZiAoYXRsYXMuaXNEaXJ0eSkge1xyXG4gICAgICAgICAgICBhdGxhcy5zeW5jVGV4dHVyZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9wcm9ncmFtLnNldFZlY3RvcjJVbmlmb3JtKCdhdGxhc1NpemUnLCB0aGlzLl9hdGxhc1NpemVVbmlmb3JtKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRUZXh0dXJlVW5pdCgwKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRUZXh0dXJlKGF0bGFzLnRleHR1cmUpO1xyXG4gICAgICAgIHN1cGVyLl9yZW5kZXJCYXRjaChtZW1vcnlCYXRjaCk7XHJcbiAgICB9XHJcbiAgICBfY2FuQmF0Y2hBZGphY2VudFByaW1pdGl2ZXMoYSwgYikge1xyXG4gICAgICAgIHJldHVybiBzdXBlci5fY2FuQmF0Y2hBZGphY2VudFByaW1pdGl2ZXMoYSwgYikgJiYgKGEuYXRsYXMgPT09IGIuYXRsYXMpO1xyXG4gICAgfVxyXG59XHJcbiIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbiNpZm5kZWYgRklMVEVSX1JBRElVU1xcbiMgICBlcnJvciBGSUxURVJfUkFESVVTIG11c3QgYmUgc2V0XFxuI2VuZGlmXFxuXFxuYXR0cmlidXRlIHZlYzIgdmVydGV4UG9zSGlnaDtcXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhQb3NMb3c7XFxuYXR0cmlidXRlIHZlYzIgdmVydGV4RGlzcGxhY2VtZW50O1xcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleFVWO1xcbmF0dHJpYnV0ZSBmbG9hdCB2ZXJ0ZXhIYWxmV2lkdGg7XFxuYXR0cmlidXRlIHZlYzIgdmVydGV4UGF0dGVybjtcXG5hdHRyaWJ1dGUgZmxvYXQgdmVydGV4UGF0dGVybkhhbGZIZWlnaHQ7XFxuYXR0cmlidXRlIGZsb2F0IHZlcnRleFpJbmRleDtcXG5cXG51bmlmb3JtIHZlYzIgbG9va0F0SGlnaDtcXG51bmlmb3JtIHZlYzIgbG9va0F0TG93O1xcbnVuaWZvcm0gbWF0NCB2aWV3UHJvak1hdHJpeDtcXG51bmlmb3JtIGZsb2F0IHdvcmxkVG9QeEZhY3RvcjtcXG5cXG52YXJ5aW5nIHZlYzIgdXY7XFxudmFyeWluZyBmbG9hdCBzO1xcbnZhcnlpbmcgZmxvYXQgcGF0dGVybkxlbmd0aDtcXG52YXJ5aW5nIGZsb2F0IGxlbjtcXG52YXJ5aW5nIGZsb2F0IGhhbGZXaWR0aDtcXG52YXJ5aW5nIGZsb2F0IGV4dEhhbGZXaWR0aDtcXG52YXJ5aW5nIGZsb2F0IHBhdHRlcm5IYWxmSGVpZ2h0O1xcblxcbmNvbnN0IGZsb2F0IFlWX0ggPSAxLjk5OTk2OTQ4MjQyMTg3NTtcXG5jb25zdCBmbG9hdCBZVl9MID0gMC4wMDAwMzA1MTcxMTI0NjM3MTI2OTI7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gICAgaGFsZldpZHRoID0gdmVydGV4SGFsZldpZHRoO1xcbiAgICBleHRIYWxmV2lkdGggPSBoYWxmV2lkdGggKyBGSUxURVJfUkFESVVTO1xcblxcbiAgICB2ZWM0IHBvc2l0aW9uID0gdmlld1Byb2pNYXRyaXggKiB2ZWM0KFxcbiAgICAgICAgWVZfSCAqICh2ZXJ0ZXhQb3NIaWdoIC0gbG9va0F0SGlnaCkgK1xcbiAgICAgICAgICAgIFlWX0wgKiAodmVydGV4UG9zTG93IC0gbG9va0F0TG93KSArXFxuICAgICAgICAgICAgICAgIHdvcmxkVG9QeEZhY3RvciAqIGV4dEhhbGZXaWR0aCAqIHZlcnRleERpc3BsYWNlbWVudCxcXG4gICAgICAgIDAsXFxuICAgICAgICAxXFxuICAgICk7XFxuXFxuICAgIHBvc2l0aW9uLnh5IC89IHBvc2l0aW9uLnc7XFxuICAgIHBvc2l0aW9uLnogPSB2ZXJ0ZXhaSW5kZXg7XFxuICAgIHBvc2l0aW9uLncgPSAxLjA7XFxuXFxuICAgIGdsX1Bvc2l0aW9uID0gcG9zaXRpb247XFxuXFxuICAgIHBhdHRlcm5MZW5ndGggPSB2ZXJ0ZXhQYXR0ZXJuWzBdO1xcbiAgICBsZW4gPSB2ZXJ0ZXhQYXR0ZXJuWzFdO1xcbiAgICAvLyBEaXN0YW5jZSB0byB0aGUgYW5hbHl0aWNhbCBsaW5lIGFsb25nIHNlZ21lbnQncyBub3JtYWxcXG4gICAgcyA9IHNpZ24odmVydGV4UGF0dGVybkhhbGZIZWlnaHQpICogZXh0SGFsZldpZHRoO1xcbiAgICAvLyBUaGUgd2hvbGUgdGV4dHVyZSBpcyBiZWluZyBzYW1wbGVkIHRvIHRoZSBvcmlnaW5hbCBnZW9tZXRyeS4gRm9yIHBpeGVscyBpbiB0aGUgZXh0ZW5kZWQgcG9seWxpbmUgcGFydCB0aGUgdG9wbW9zdFxcbiAgICAvLyAoYm90dG9tbW9zdCkgdGV4ZWxzIGFyZSB0YWtlbi4gVG8gbWFrZSB0aGlzIGhhcHBlbiB0aGUgVVYgdGV4dHVyZSBjb29yZGluYXRlcyBhcmUgZXh0ZW5kZWQgaW4gcHJvcG9ydGlvbiB0byB0aGVcXG4gICAgLy8gcG9seWxpbmUgd2lkdGggZXh0ZW5zaW9uLlxcbiAgICBwYXR0ZXJuSGFsZkhlaWdodCA9IGFicyh2ZXJ0ZXhQYXR0ZXJuSGFsZkhlaWdodCk7XFxuICAgIHV2ID0gdmVjMih2ZXJ0ZXhVVi54LCB2ZXJ0ZXhVVi55IC0gdmVydGV4UGF0dGVybkhhbGZIZWlnaHQgKiBGSUxURVJfUkFESVVTIC8gaGFsZldpZHRoKTtcXG59XFxuXCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiI3ZlcnNpb24gMTAwXFxuXFxuI2lmbmRlZiBGSUxURVJfUkFESVVTXFxuIyAgIGVycm9yIEZJTFRFUl9SQURJVVMgbXVzdCBiZSBzZXRcXG4jZW5kaWZcXG5cXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbnVuaWZvcm0gc2FtcGxlcjJEIGF0bGFzO1xcbnVuaWZvcm0gdmVjMiBhdGxhc1NpemU7XFxuXFxudmFyeWluZyB2ZWMyIHV2O1xcbnZhcnlpbmcgZmxvYXQgcztcXG52YXJ5aW5nIGZsb2F0IHBhdHRlcm5MZW5ndGg7XFxudmFyeWluZyBmbG9hdCBsZW47XFxudmFyeWluZyBmbG9hdCBoYWxmV2lkdGg7XFxudmFyeWluZyBmbG9hdCBleHRIYWxmV2lkdGg7XFxudmFyeWluZyBmbG9hdCBwYXR0ZXJuSGFsZkhlaWdodDtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgICBsb3dwIGZsb2F0IGFscGhhID0gc21vb3Roc3RlcCgwLjAsIEZJTFRFUl9SQURJVVMgKyBtaW4oRklMVEVSX1JBRElVUywgZXh0SGFsZldpZHRoKSwgZXh0SGFsZldpZHRoIC0gYWJzKHMpKTtcXG5cXG4gICAgLy8gQ2xhbXAgdGV4dHVyZSBVIGNvb3JkaW5hdGUgYnkgMC41cHggZnJvbSBib3RoIHNpZGVzIHRvIGF2b2lkIGJsZWVkaW5nLlxcbiAgICB2ZWMyIHV2QWRqdXN0ZWQgPSB2ZWMyKHV2LnggKyBjbGFtcChtb2QobGVuLCBwYXR0ZXJuTGVuZ3RoKSwgMC41LCBwYXR0ZXJuTGVuZ3RoIC0gMC41KSwgdXYueSk7XFxuICAgIC8vIFVWIHRleHR1cmUgY29vcmRpbmF0ZXMgaGF2ZSBiZWVuIGV4dGVuZGVkIGluIHByb3BvcnRpb24gdG8gdGhlIHBvbHlsaW5lIHdpZHRoIGV4dGVuc2lvbi5cXG4gICAgLy8gQ2xhbXAgdGV4dHVyZSBWIGNvb3JkaW5hdGUgdG8gdGhlIG9yaWdpbmFsIGdlb21ldHJ5IG1pbnVzIDAuNXB4IHRvIGF2b2lkIGJsZWVkaW5nLlxcbiAgICBmbG9hdCBwYXR0ZXJuVG9HZW9tZXRyeUZhY3RvciA9IGhhbGZXaWR0aCAvIHBhdHRlcm5IYWxmSGVpZ2h0O1xcbiAgICBmbG9hdCBjbGFtcFRvID0gaGFsZldpZHRoIC0gMC41ICogcGF0dGVyblRvR2VvbWV0cnlGYWN0b3I7XFxuICAgIGlmIChzdGVwKGNsYW1wVG8sIGFicyhzKSkgPT0gMS4pIHtcXG4gICAgICAgIGZsb2F0IGRlbHRhID0gcyAtIGNsYW1wKHMsIC1jbGFtcFRvLCBjbGFtcFRvKTtcXG4gICAgICAgIHV2QWRqdXN0ZWQueSArPSBkZWx0YSAvIHBhdHRlcm5Ub0dlb21ldHJ5RmFjdG9yO1xcbiAgICB9XFxuXFxuICAgIGxvd3AgdmVjNCBjb2xvciA9IHRleHR1cmUyRChhdGxhcywgdXZBZGp1c3RlZCAvIGF0bGFzU2l6ZSk7XFxuICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yICogYWxwaGE7XFxufVxcblwiIiwiaW1wb3J0IFdvcmxkUHJpbWl0aXZlUmVuZGVyVW5pdCBmcm9tICcuLi93b3JsZF9wcmltaXRpdmVfcmVuZGVyX3VuaXQnO1xyXG4vKipcclxuICogQmFzZSByZW5kZXJlciBvZiBwb2x5bGluZSBwcmltaXRpdmVzLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFzZVBvbHlsaW5lUmVuZGVyVW5pdCBleHRlbmRzIFdvcmxkUHJpbWl0aXZlUmVuZGVyVW5pdCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCByZW5kZXJTdGF0ZSwgcHJvZ3JhbSwgcHJpbWl0aXZlUHJvdmlkZXIsIGNhbWVyYSkge1xyXG4gICAgICAgIHN1cGVyKGNvbnRleHQsIHJlbmRlclN0YXRlLCBwcm9ncmFtLCBwcmltaXRpdmVQcm92aWRlcik7XHJcbiAgICAgICAgdGhpcy5fY2FtZXJhID0gY2FtZXJhO1xyXG4gICAgfVxyXG4gICAgX3ByZXBhcmVQcm9ncmFtKHByb2dyYW0sIHZpZXdQcm9qTWF0cml4LCBjYW1lcmFQb3NpdGlvbnMpIHtcclxuICAgICAgICBzdXBlci5fcHJlcGFyZVByb2dyYW0ocHJvZ3JhbSwgdmlld1Byb2pNYXRyaXgsIGNhbWVyYVBvc2l0aW9ucyk7XHJcbiAgICAgICAgcHJvZ3JhbS5zZXRTY2FsYXJVbmlmb3JtKCd3b3JsZFRvUHhGYWN0b3InLCB0aGlzLl9jYW1lcmEud29ybGRUb1B4RmFjdG9yKTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBNQVhfSEFMRl9XSURUSCwgTUFYX0ZJTExfR0FQIH0gZnJvbSAnLi4vLi4vLi4vcHJpbWl0aXZlL3BvbHlsaW5lL3BvbHlsaW5lX2J1ZmZlcl93cml0ZXInO1xyXG5pbXBvcnQgcG9seWxpbmVWZXJ0ZXhTaGFkZXIgZnJvbSAnLi9zaGFkZXIvcG9seWxpbmUudmVydCc7XHJcbmltcG9ydCBwb2x5bGluZUZyYWdtZW50U2hhZGVyIGZyb20gJy4vc2hhZGVyL3BvbHlsaW5lLmZyYWcnO1xyXG5pbXBvcnQgQmFzZVBvbHlsaW5lUmVuZGVyVW5pdCBmcm9tICcuL2Jhc2VfcG9seWxpbmVfcmVuZGVyX3VuaXQnO1xyXG5pbXBvcnQgUmVuZGVyU3RhdGUgZnJvbSAnLi4vLi4vLi4vcmVuZGVyL3N0YXRlJztcclxuLy8gVmFsdWVzIHdhcyBjaG9zZW4gYnkgdGVhbSBjb25zZW5zdXMgaW4gVkVDVE9SLTE5N1xyXG5jb25zdCBGSUxURVJfUkFESVVTID0gMS4wIC8gZGV2aWNlUGl4ZWxSYXRpbzsgLy8gcHhcclxuZXhwb3J0IGNvbnN0IERFRkFVTFRfUkVOREVSX1NUQVRFX1BBUkFNUyA9IHtcclxuICAgIGJsZW5kOiB0cnVlLFxyXG4gICAgYmxlbmRGdW5jU3JjUmdiOiAxIC8qIE9ORSAqLyxcclxuICAgIGJsZW5kRnVuY0RzdFJnYjogNzcxIC8qIE9ORV9NSU5VU19TUkNfQUxQSEEgKi8sXHJcbiAgICBibGVuZEZ1bmNTcmNBbHBoYTogMSAvKiBPTkUgKi8sXHJcbiAgICBibGVuZEZ1bmNEc3RBbHBoYTogNzcxIC8qIE9ORV9NSU5VU19TUkNfQUxQSEEgKi9cclxufTtcclxuLyoqXHJcbiAqIFJlbmRlcmVyIG9mIHBvbHlsaW5lIHByaW1pdGl2ZXMuIEl0cyBkZWZhdWx0IHJlbmRlciBzdGF0ZSBpcyBhaW1lZCB0byByZW5kZXIgb3BhcXVlIHBvbHlsaW5lcy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvbHlsaW5lUmVuZGVyVW5pdCBleHRlbmRzIEJhc2VQb2x5bGluZVJlbmRlclVuaXQge1xyXG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgY2FtZXJhLCBwcmltaXRpdmVQcm92aWRlciwgcmVuZGVyU3RhdGUgPSBuZXcgUmVuZGVyU3RhdGUoREVGQVVMVF9SRU5ERVJfU1RBVEVfUEFSQU1TKSkge1xyXG4gICAgICAgIGNvbnN0IHByb2dyYW0gPSBjb250ZXh0LmNyZWF0ZVByb2dyYW0ocG9seWxpbmVWZXJ0ZXhTaGFkZXIsIHBvbHlsaW5lRnJhZ21lbnRTaGFkZXIsIHtcclxuICAgICAgICAgICAgZGVmaW5lczoge1xyXG4gICAgICAgICAgICAgICAgRklMVEVSX1JBRElVUzogYGZsb2F0KCR7RklMVEVSX1JBRElVU30pYCxcclxuICAgICAgICAgICAgICAgIE1BWF9IQUxGX1dJRFRIOiBgZmxvYXQoJHtNQVhfSEFMRl9XSURUSH0pYCxcclxuICAgICAgICAgICAgICAgIE1BWF9GSUxMX0dBUDogYGZsb2F0KCR7TUFYX0ZJTExfR0FQfSlgXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGF0dHJpYk1hcDoge1xyXG4gICAgICAgICAgICAgICAgdmVydGV4UG9zOiAwIC8qIFBPU0lUSU9OICovLFxyXG4gICAgICAgICAgICAgICAgdmVydGV4Tm9ybWFsUGFja2VkOiA1IC8qIE5PUk1BTCAqLyxcclxuICAgICAgICAgICAgICAgIHZlcnRleFV2UGFja2VkOiA0IC8qIFVWICovLFxyXG4gICAgICAgICAgICAgICAgdmVydGV4V2lkdGhGaWxsR2FwOiAxMSAvKiBBVVggKi8sXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhDb2xvcjogNyAvKiBDT0xPUiAqLyxcclxuICAgICAgICAgICAgICAgIHZlcnRleE1pdGVyOiAxMiAvKiBBVVgxICovLFxyXG4gICAgICAgICAgICAgICAgdmVydGV4VkxpbWl0OiAxMyAvKiBBVVgyICovLFxyXG4gICAgICAgICAgICAgICAgdmVydGV4TGVuZ3RoOiAxNCAvKiBBVVgzICovXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBzdXBlcihjb250ZXh0LCByZW5kZXJTdGF0ZSwgcHJvZ3JhbSwgcHJpbWl0aXZlUHJvdmlkZXIsIGNhbWVyYSk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0ICogYXMgdmVjMiBmcm9tICcuLi8uLi9tYXRoL3ZlY3RvcjInO1xyXG5pbXBvcnQgeyBlbmNvZGVSZ2JhOCB9IGZyb20gJy4uLy4uL3V0aWwvY29sb3InO1xyXG5pbXBvcnQgQnVmZmVyV3JpdGVyIGZyb20gJy4uLy4uL3V0aWwvYnVmZmVyX3dyaXRlcic7XHJcbmltcG9ydCB7IFBPTFlMSU5FX0FUVFJJQlVURV9NQVBQSU5HIH0gZnJvbSAnLi9wb2x5bGluZV9hdHRyaWJ1dGVfbWFwcGluZyc7XHJcbmltcG9ydCB7IGZsb2F0VG9VaW50OCwgZmxvYXRUb1VpbnQxNiB9IGZyb20gJy4uLy4uL3V0aWwvZ3B1dHlwZXMnO1xyXG5pbXBvcnQgeyBpbnRUb1pJbmRleCB9IGZyb20gJy4uLy4uL3V0aWwvel9pbmRleCc7XHJcbmltcG9ydCB7IGNsYW1wIH0gZnJvbSAnLi4vLi4vbWF0aC9zY2FsYXInO1xyXG4vKipcclxuICogQ29tcHV0ZXMgbWl0ZXIgb2YgYSBqb2luIGJldHdlZW4gdHdvIHNlZ21lbnRzLlxyXG4gKlxyXG4gKiBAcGFyYW0gbjEgTm9ybWFsIHZlY3RvciBvZiB0aGUgZmlyc3Qgc2VnbWVudC5cclxuICogQHBhcmFtIG4yIE5vcm1hbCB2ZWN0b3Igb2YgdGhlIHNlY29uZCBzZWdtZW50LlxyXG4gKiBAcmV0dXJucyBNaXRlciB2YWx1ZSwgaS5lLiBieSBob3cgbWF0Y2ggZGlzcGxhY2VtZW50IGlzIGxvbmdlciB0aGFuIGEgbm9ybWFsXHJcbiAqICAgICAgb25lLlxyXG4gKi9cclxuZnVuY3Rpb24gY29tcHV0ZU1pdGVyKG4xLCBuMikge1xyXG4gICAgcmV0dXJuIE1hdGguc3FydCgyIC8gKDEgKyB2ZWMyLmRvdChuMSwgbjIpKSk7XHJcbn1cclxuY29uc3QgU0VHTUVOVF9WRVJURVhfQ09VTlQgPSA0O1xyXG5jb25zdCBTUVVBUkVfQ0FQX1ZFUlRFWF9DT1VOVCA9IDU7XHJcbmNvbnN0IFJPVU5EX0NBUF9WRVJURVhfQ09VTlQgPSA0O1xyXG5jb25zdCBGTE9BVF9NQVggPSAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4O1xyXG5jb25zdCBNSVRFUl9MSU1JVCA9IDQ7XHJcbmNvbnN0IFVWX1BPU19PTkVfUEFDS0VEID0gMjU1OyAvLyBwYWNrZWQgMVxyXG5jb25zdCBVVl9ORUdfT05FX1BBQ0tFRCA9IDE7IC8vIHBhY2tlZCAtMVxyXG5jb25zdCBVVl9aRVJPX1BBQ0tFRCA9IDEyODtcclxuLyoqXHJcbiAqIFBhY2tzIGEgY29tcG9uZW50IG9mIHV2IGludG8gYSB1bnNpZ25lZCA4LWJpdCB2YWx1ZS4gQWZ0ZXIgcGFja2luZyAtMSB3aWxsXHJcbiAqIGJlY29tZSAxIGFuZCAxIHdpbGwgYmVjb21lIDI1NS4gVGhhdCdzIG5lZWQgdG8gZW11bGF0ZSB6ZXJvLXByZXNlcnZpbmdcclxuICogbm9ybWFsaXphdGlvbiAod2UgY2FuJ3QgcmVseSBvbiBXZWJHTCB0byBkbyBpdCBmb3IgdXMgOigpLlxyXG4gKlxyXG4gKiBAcGFyYW0gYyBUaGUgY29tcG9uZW50LlxyXG4gKiBAcmV0dXJucyBQYWNrZWQgY29tcG9uZW50LlxyXG4gKi9cclxuZnVuY3Rpb24gcGFja1V2Q29tcG9uZW50KGMpIHtcclxuICAgIC8vIFdlIGRvbid0IHRydW5jYXRlIGhlcmUgYmVjYXVzZSBidWZmZXIgd3JpdGVyIHdpbGwgZG8gdGhhdCBmb3IgdXMuXHJcbiAgICByZXR1cm4gMTI4ICsgKDEyNyAqIGMpO1xyXG59XHJcbi8qKlxyXG4gKiBIYWxmIHdpZHRoIG9mIHRoZSBwb2x5bGluZSBpcyBzdG9yZWQgaW4gYSBub3JtYWxpemVkIGF0dHJpYnV0ZS4gVGhpcyBjb25zdGFudFxyXG4gKiBkZWZpbmVzIGhhbGYgd2lkdGggdmFsdWUgb2YgMSBjb3JyZXNwb25kcyB0by5cclxuICovXHJcbmV4cG9ydCBjb25zdCBNQVhfSEFMRl9XSURUSCA9IDI1NSAvIDQ7IC8vIHB4XHJcbi8qKlxyXG4gKiBTYW1lIGFzIGZvciBwb2x5bGluZSBoYWxmIHdpZHRoLCBidXQgZm9yIGRhc2ggcGF0dGVybiBkZWZpbml0aW9uLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IE1BWF9GSUxMX0dBUCA9IDI1NTsgLy8gcHhcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9seWxpbmVCdWZmZXJXcml0ZXIgZXh0ZW5kcyBCdWZmZXJXcml0ZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoUE9MWUxJTkVfQVRUUklCVVRFX01BUFBJTkcudmVydGV4Qnl0ZVNpemUpO1xyXG4gICAgICAgIHRoaXMuX2Rpc3BsYWNlbWVudCA9IHZlYzIuY3JlYXRlKDAsIDApO1xyXG4gICAgICAgIHRoaXMuX3ByZXZEaXNwbGFjZW1lbnQgPSB2ZWMyLmNyZWF0ZSgwLCAwKTtcclxuICAgICAgICB0aGlzLl9pbml0UG9seWxpbmVTdGF0ZShbdmVjMi5aRVJPLCB2ZWMyLlpFUk9dLCAwLCAwLCAwLCAwLCAwIC8qIE1JVEVSICovLCAwKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJhdGVzIGEgbWVzaCBmb3IgYSBwb2x5bGluZSB3aXRoIGEgZ2l2ZW4gc3R5bGUsIGJha2luZyBhbGwgbmVjZXNzYXJ5XHJcbiAgICAgKiBwYXJhbWV0ZXJzIGludG8gYXR0cmlidXRlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcG9seWxpbmUgVGhlIHBvbHlsaW5lLlxyXG4gICAgICogQHBhcmFtIHN0eWxlIFRoZSBwb2x5bGluZSBzdHlsZS5cclxuICAgICAqIEByZXR1cm5zIExvY2F0aW9uIG9mIHRoZSB3cml0dGVuIG1lc2ggaW4gdGhlIG1hbmFnZWQgYnVmZmVycy5cclxuICAgICAqL1xyXG4gICAgd3JpdGVQb2x5bGluZShwb2x5bGluZSwgc3R5bGUsIHpJbmRleCkge1xyXG4gICAgICAgIGNvbnN0IHsgdmVydGljZXMgfSA9IHBvbHlsaW5lO1xyXG4gICAgICAgIGNvbnN0IGxhc3RJZHggPSB2ZXJ0aWNlcy5sZW5ndGggLSAxO1xyXG4gICAgICAgIGlmIChsYXN0SWR4IDwgMSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09uZSB2ZXJ0ZXggaW4gbm90IGEgcG9seWxpbmUuIEl0XFwncyBub3QgZXZlbiBhIGxpbmUuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2luaXRQb2x5bGluZVN0YXRlKHZlcnRpY2VzLCBlbmNvZGVSZ2JhOChzdHlsZS5zdHJva2VDb2xvciksIHN0eWxlLnN0cm9rZVdpZHRoLCBzdHlsZS5kYXNoID8gc3R5bGUuZGFzaC5maWxsIDogMCwgc3R5bGUuZGFzaCA/IHN0eWxlLmRhc2guZ2FwIDogMCwgc3R5bGUuam9pbiwgaW50VG9aSW5kZXgoekluZGV4KSk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVDYXAoc3R5bGUuc3RhcnRDYXAsIHZlcnRpY2VzWzBdLCAxKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxhc3RJZHg7ICsraSkge1xyXG4gICAgICAgICAgICB0aGlzLl93cml0ZVNlZ21lbnQodmVydGljZXNbaSAtIDFdLCB2ZXJ0aWNlc1tpXSwgdmVydGljZXNbaSArIDFdKTtcclxuICAgICAgICAgICAgdGhpcy5fd3JpdGVKb2luKHZlcnRpY2VzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fd3JpdGVMYXN0U2VnbWVudCh2ZXJ0aWNlc1tsYXN0SWR4IC0gMV0sIHZlcnRpY2VzW2xhc3RJZHhdKTtcclxuICAgICAgICB0aGlzLl93cml0ZUNhcChzdHlsZS5lbmRDYXAsIHZlcnRpY2VzW2xhc3RJZHhdLCAxKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5lbmRNZXNoKCk7XHJcbiAgICB9XHJcbiAgICBfaW5pdFBvbHlsaW5lU3RhdGUodmVydGljZXMsIGNvbG9yUmdiYTgsIHdpZHRoLCBmaWxsLCBnYXAsIGpvaW4sIHpJbmRleCkge1xyXG4gICAgICAgIHRoaXMuX2Jhc2VJbmRleCA9IHRoaXMuX3BvbHlsaW5lTGVuZ3RoID0gdGhpcy5fbGFzdERpcmVjdGlvbiA9IDA7XHJcbiAgICAgICAgdGhpcy5fbGFzdFNpZ25lZE1pdGVyID0gMTtcclxuICAgICAgICBjb25zdCBkaXNwbGFjZW1lbnQgPSB2ZWMyLnN1Yih2ZXJ0aWNlc1sxXSwgdmVydGljZXNbMF0sIHRoaXMuX2Rpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdGhpcy5fc2VnbWVudExlbmd0aCA9IHZlYzIubGVuZ3RoKGRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdmVjMi5kaXZuKGRpc3BsYWNlbWVudCwgdGhpcy5fc2VnbWVudExlbmd0aCwgZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB2ZWMyLnJvdGF0ZTkwKGRpc3BsYWNlbWVudCwgZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB0aGlzLl9jb2xvclJnYmE4ID0gY29sb3JSZ2JhODtcclxuICAgICAgICB0aGlzLl9oYWxmV2lkdGhGaWxsR2FwUGFja2VkID1cclxuICAgICAgICAgICAgZmxvYXRUb1VpbnQ4KGNsYW1wKDAuNSAqIHdpZHRoLCAwLCBNQVhfSEFMRl9XSURUSCkgLyBNQVhfSEFMRl9XSURUSCkgfFxyXG4gICAgICAgICAgICAgICAgZmxvYXRUb1VpbnQ4KGNsYW1wKGZpbGwsIDAsIE1BWF9GSUxMX0dBUCkgLyBNQVhfRklMTF9HQVApIDw8IDggfFxyXG4gICAgICAgICAgICAgICAgZmxvYXRUb1VpbnQ4KGNsYW1wKGdhcCwgMCwgTUFYX0ZJTExfR0FQKSAvIE1BWF9GSUxMX0dBUCkgPDwgMTY7XHJcbiAgICAgICAgdGhpcy5fam9pbiA9IGpvaW47XHJcbiAgICAgICAgdGhpcy5fekluZGV4ID0gekluZGV4O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYSBzaW5nbGUgdmVydGV4IGludG8gbWFuYWdlZCB2ZXJ0ZXggYnVmZmVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwb3NpdGlvbiBWZXJ0ZXggd29ybGQgcG9zaXRpb24uXHJcbiAgICAgKiBAcGFyYW0gbm9ybWFsIE5vcm1hbCBvZiBzZWdtZW50IHRoZSB2ZXJ0ZXggYmVsb25ncyB0by5cclxuICAgICAqIEBwYXJhbSB1IE5vcm1hbGl6ZWQgZGlzdGFuY2UgdG8gdGhlIHBvbHlsaW5lIGFsb25nIHRoZSBub3JtYWwuXHJcbiAgICAgKiBAcGFyYW0gdiBOb3JtYWxpemVkIGRpc3RhbmNlIHRvIHRoZSBwb2x5bGluZSBhbG9uZyB0aGUgdGFuZ2VudC5cclxuICAgICAqIEBwYXJhbSBwb2x5bGluZUxlbmd0aCBEaXN0YW5jZSB0byB0aGUgZmlyc3QgdmVydGV4IGFsb25nIHRoZSBwb2x5bGluZS5cclxuICAgICAqIEBwYXJhbSBtaXRlciBKb2luIG1pdGVyLlxyXG4gICAgICogQHBhcmFtIGxlbmd0aENvcnJlY3Rpb25MaW1pdCBMaW1pdCBvbiB0aGUgdmVydGV4IGRpc3BsYWNlbWVudCBhbG9uZyB0aGVcclxuICAgICAqICAgICAgcG9seWxpbmUuXHJcbiAgICAgKi9cclxuICAgIF93cml0ZVZlcnRleChwb3NpdGlvbiwgbm9ybWFsLCB1UGFja2VkLCB2UGFja2VkLCBwb2x5bGluZUxlbmd0aCwgbWl0ZXIsIGxlbmd0aENvcnJlY3Rpb25MaW1pdCkge1xyXG4gICAgICAgIHRoaXMuX3dyaXRlV29ybGRDb29yZGluYXRlKHBvc2l0aW9uKTtcclxuICAgICAgICB0aGlzLl93cml0ZUhhbGZXb3JkcyhmbG9hdFRvVWludDE2KDAuNSAqIChub3JtYWwueCAqIE1hdGguU1FSVDFfMiArIDEpKSwgZmxvYXRUb1VpbnQxNigwLjUgKiAobm9ybWFsLnkgKiBNYXRoLlNRUlQxXzIgKyAxKSkpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlSGFsZldvcmRzKHVQYWNrZWQsIHZQYWNrZWQpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlV29yZCh0aGlzLl9oYWxmV2lkdGhGaWxsR2FwUGFja2VkKTtcclxuICAgICAgICB0aGlzLl93cml0ZUZsb2F0MzIobWl0ZXIpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlRmxvYXQzMihsZW5ndGhDb3JyZWN0aW9uTGltaXQpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlRmxvYXQzMihwb2x5bGluZUxlbmd0aCk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVXb3JkKHRoaXMuX2NvbG9yUmdiYTgpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlRmxvYXQzMih0aGlzLl96SW5kZXgpO1xyXG4gICAgfVxyXG4gICAgX3dyaXRlQ2FwKGNhcCwgZW5kVmVydGV4LCBkaXNwbGFjZW1lbnRTaWduKSB7XHJcbiAgICAgICAgc3dpdGNoIChjYXApIHtcclxuICAgICAgICAgICAgY2FzZSAxIC8qIFJPVU5EICovOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5fd3JpdGVSb3VuZENhcChlbmRWZXJ0ZXgsIGRpc3BsYWNlbWVudFNpZ24pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMiAvKiBTUVVBUkUgKi86XHJcbiAgICAgICAgICAgICAgICB0aGlzLl93cml0ZVNxdWFyZUNhcChlbmRWZXJ0ZXgsIGRpc3BsYWNlbWVudFNpZ24pO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3dyaXRlUm91bmRDYXAoZW5kVmVydGV4LCBkaXNwbGFjZW1lbnRTaWduKSB7XHJcbiAgICAgICAgY29uc3QgZGlzcGxhY2VtZW50ID0gdmVjMi5jcmVhdGUoMCwgMCk7XHJcbiAgICAgICAgY29uc3QgcG9seWxpbmVMZW5ndGggPSB0aGlzLl9wb2x5bGluZUxlbmd0aDtcclxuICAgICAgICB2ZWMyLm11bG4odGhpcy5fZGlzcGxhY2VtZW50LCAtZGlzcGxhY2VtZW50U2lnbiwgZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB0aGlzLl93cml0ZVZlcnRleChlbmRWZXJ0ZXgsIGRpc3BsYWNlbWVudCwgVVZfTkVHX09ORV9QQUNLRUQsIFVWX1pFUk9fUEFDS0VELCBwb2x5bGluZUxlbmd0aCwgMSwgRkxPQVRfTUFYKTtcclxuICAgICAgICB2ZWMyLnJvdGF0ZTkwKHRoaXMuX2Rpc3BsYWNlbWVudCwgZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB2ZWMyLnN1YihkaXNwbGFjZW1lbnQsIHRoaXMuX2Rpc3BsYWNlbWVudCwgZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB2ZWMyLm11bG4oZGlzcGxhY2VtZW50LCBkaXNwbGFjZW1lbnRTaWduLCBkaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlVmVydGV4KGVuZFZlcnRleCwgZGlzcGxhY2VtZW50LCBVVl9ORUdfT05FX1BBQ0tFRCwgVVZfUE9TX09ORV9QQUNLRUQsIHBvbHlsaW5lTGVuZ3RoLCAxLCBGTE9BVF9NQVgpO1xyXG4gICAgICAgIHZlYzIubXVsbih0aGlzLl9kaXNwbGFjZW1lbnQsIGRpc3BsYWNlbWVudFNpZ24sIGRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVWZXJ0ZXgoZW5kVmVydGV4LCBkaXNwbGFjZW1lbnQsIFVWX1BPU19PTkVfUEFDS0VELCBVVl9aRVJPX1BBQ0tFRCwgcG9seWxpbmVMZW5ndGgsIDEsIEZMT0FUX01BWCk7XHJcbiAgICAgICAgdmVjMi5yb3RhdGU5MCh0aGlzLl9kaXNwbGFjZW1lbnQsIGRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdmVjMi5hZGQoZGlzcGxhY2VtZW50LCB0aGlzLl9kaXNwbGFjZW1lbnQsIGRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdmVjMi5tdWxuKGRpc3BsYWNlbWVudCwgZGlzcGxhY2VtZW50U2lnbiwgZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB0aGlzLl93cml0ZVZlcnRleChlbmRWZXJ0ZXgsIGRpc3BsYWNlbWVudCwgVVZfUE9TX09ORV9QQUNLRUQsIFVWX1BPU19PTkVfUEFDS0VELCBwb2x5bGluZUxlbmd0aCwgMSwgRkxPQVRfTUFYKTtcclxuICAgICAgICB0aGlzLndyaXRlSW5kaWNlc0ZvckNvbnRpbnVvdXNTdHJpcChST1VORF9DQVBfVkVSVEVYX0NPVU5ULCB0aGlzLl9iYXNlSW5kZXgpO1xyXG4gICAgICAgIHRoaXMuX2Jhc2VJbmRleCArPSBST1VORF9DQVBfVkVSVEVYX0NPVU5UO1xyXG4gICAgfVxyXG4gICAgX3dyaXRlU3F1YXJlQ2FwKGVuZFZlcnRleCwgZGlzcGxhY2VtZW50U2lnbikge1xyXG4gICAgICAgIGNvbnN0IGRpc3BsYWNlbWVudCA9IHZlYzIuY3JlYXRlKDAsIDApO1xyXG4gICAgICAgIGNvbnN0IHBvbHlsaW5lTGVuZ3RoID0gdGhpcy5fcG9seWxpbmVMZW5ndGg7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVWZXJ0ZXgoZW5kVmVydGV4LCB2ZWMyLlpFUk8sIFVWX1pFUk9fUEFDS0VELCBVVl9aRVJPX1BBQ0tFRCwgcG9seWxpbmVMZW5ndGgsIDEsIDApO1xyXG4gICAgICAgIHZlYzIubXVsbih0aGlzLl9kaXNwbGFjZW1lbnQsIC1kaXNwbGFjZW1lbnRTaWduLCBkaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlVmVydGV4KGVuZFZlcnRleCwgZGlzcGxhY2VtZW50LCBVVl9QT1NfT05FX1BBQ0tFRCwgVVZfWkVST19QQUNLRUQsIHBvbHlsaW5lTGVuZ3RoLCAxLCBGTE9BVF9NQVgpO1xyXG4gICAgICAgIHZlYzIucm90YXRlOTAodGhpcy5fZGlzcGxhY2VtZW50LCBkaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHZlYzIuc3ViKGRpc3BsYWNlbWVudCwgdGhpcy5fZGlzcGxhY2VtZW50LCBkaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHZlYzIubXVsbihkaXNwbGFjZW1lbnQsIGRpc3BsYWNlbWVudFNpZ24sIGRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVWZXJ0ZXgoZW5kVmVydGV4LCBkaXNwbGFjZW1lbnQsIFVWX1BPU19PTkVfUEFDS0VELCBVVl9aRVJPX1BBQ0tFRCwgcG9seWxpbmVMZW5ndGgsIDEsIEZMT0FUX01BWCk7XHJcbiAgICAgICAgdmVjMi5yb3RhdGU5MCh0aGlzLl9kaXNwbGFjZW1lbnQsIGRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdmVjMi5zdWIoZGlzcGxhY2VtZW50LCB0aGlzLl9kaXNwbGFjZW1lbnQsIGRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdmVjMi5tdWxuKGRpc3BsYWNlbWVudCwgZGlzcGxhY2VtZW50U2lnbiwgZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB0aGlzLl93cml0ZVZlcnRleChlbmRWZXJ0ZXgsIGRpc3BsYWNlbWVudCwgVVZfUE9TX09ORV9QQUNLRUQsIFVWX1pFUk9fUEFDS0VELCBwb2x5bGluZUxlbmd0aCwgMSwgRkxPQVRfTUFYKTtcclxuICAgICAgICB2ZWMyLm11bG4odGhpcy5fZGlzcGxhY2VtZW50LCBkaXNwbGFjZW1lbnRTaWduLCBkaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlVmVydGV4KGVuZFZlcnRleCwgdGhpcy5fZGlzcGxhY2VtZW50LCBVVl9QT1NfT05FX1BBQ0tFRCwgVVZfWkVST19QQUNLRUQsIHBvbHlsaW5lTGVuZ3RoLCAxLCBGTE9BVF9NQVgpO1xyXG4gICAgICAgIHRoaXMud3JpdGVJbmRpY2VzRm9yQ29udGludW91c0ZhbihTUVVBUkVfQ0FQX1ZFUlRFWF9DT1VOVCwgdGhpcy5fYmFzZUluZGV4KTtcclxuICAgICAgICB0aGlzLl9iYXNlSW5kZXggKz0gU1FVQVJFX0NBUF9WRVJURVhfQ09VTlQ7XHJcbiAgICB9XHJcbiAgICBfd3JpdGVTZWdtZW50KHN0YXJ0LCBlbmQsIG5leHRFbmQpIHtcclxuICAgICAgICBjb25zdCBkaXNwbGFjZW1lbnQgPSB0aGlzLl9kaXNwbGFjZW1lbnQ7XHJcbiAgICAgICAgY29uc3QgcG9seWxpbmVMZW5ndGggPSB0aGlzLl9wb2x5bGluZUxlbmd0aDtcclxuICAgICAgICBjb25zdCBuZXh0U2VnbWVudExlbmd0aCA9IHZlYzIuZGlzdGFuY2UobmV4dEVuZCwgZW5kKTtcclxuICAgICAgICBjb25zdCBuZXh0U2VnbWVudE5vcm1hbCA9IHZlYzIuc3ViKG5leHRFbmQsIGVuZCk7XHJcbiAgICAgICAgdmVjMi5kaXZuKG5leHRTZWdtZW50Tm9ybWFsLCBuZXh0U2VnbWVudExlbmd0aCwgbmV4dFNlZ21lbnROb3JtYWwpO1xyXG4gICAgICAgIHZlYzIucm90YXRlOTAobmV4dFNlZ21lbnROb3JtYWwsIG5leHRTZWdtZW50Tm9ybWFsKTtcclxuICAgICAgICBjb25zdCBkaXJlY3Rpb24xID0gdGhpcy5fbGFzdERpcmVjdGlvbjtcclxuICAgICAgICBjb25zdCBkaXJlY3Rpb24yID0gTWF0aC5zaWduKHZlYzIuY3Jvc3NaKGRpc3BsYWNlbWVudCwgbmV4dFNlZ21lbnROb3JtYWwpKTtcclxuICAgICAgICBjb25zdCBtaXRlcjEgPSB0aGlzLl9sYXN0U2lnbmVkTWl0ZXI7XHJcbiAgICAgICAgY29uc3QgbWl0ZXIyID0gY29tcHV0ZU1pdGVyKGRpc3BsYWNlbWVudCwgbmV4dFNlZ21lbnROb3JtYWwpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlVmVydGV4KHN0YXJ0LCBkaXNwbGFjZW1lbnQsIFVWX1BPU19PTkVfUEFDS0VELCBVVl9aRVJPX1BBQ0tFRCwgcG9seWxpbmVMZW5ndGgsIGRpcmVjdGlvbjEgPT09IC0xICYmICh0aGlzLl9qb2luICE9PSAwIC8qIE1JVEVSICovIHx8IE1hdGguYWJzKG1pdGVyMSkgPiBNSVRFUl9MSU1JVCkgP1xyXG4gICAgICAgICAgICAxIDpcclxuICAgICAgICAgICAgbWl0ZXIxLCBkaXJlY3Rpb24xID09PSAtMSA/IC1GTE9BVF9NQVggOiAwLjUgKiB0aGlzLl9zZWdtZW50TGVuZ3RoKTtcclxuICAgICAgICB0aGlzLl93cml0ZVZlcnRleChlbmQsIGRpc3BsYWNlbWVudCwgVVZfUE9TX09ORV9QQUNLRUQsIFVWX1pFUk9fUEFDS0VELCBwb2x5bGluZUxlbmd0aCArIHRoaXMuX3NlZ21lbnRMZW5ndGgsIGRpcmVjdGlvbjIgPT09IC0xICYmICh0aGlzLl9qb2luICE9PSAwIC8qIE1JVEVSICovIHx8IG1pdGVyMiA+IE1JVEVSX0xJTUlUKSA/XHJcbiAgICAgICAgICAgIDEgOlxyXG4gICAgICAgICAgICBkaXJlY3Rpb24yICogbWl0ZXIyLCBkaXJlY3Rpb24yID09PSAtMSA/IEZMT0FUX01BWCA6IC0wLjUgKiB0aGlzLl9zZWdtZW50TGVuZ3RoKTtcclxuICAgICAgICB2ZWMyLmludmVydChkaXNwbGFjZW1lbnQsIGRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVWZXJ0ZXgoc3RhcnQsIGRpc3BsYWNlbWVudCwgVVZfTkVHX09ORV9QQUNLRUQsIFVWX1pFUk9fUEFDS0VELCBwb2x5bGluZUxlbmd0aCwgZGlyZWN0aW9uMSA9PT0gMSAmJiAodGhpcy5fam9pbiAhPT0gMCAvKiBNSVRFUiAqLyB8fCBNYXRoLmFicyhtaXRlcjEpID4gTUlURVJfTElNSVQpID9cclxuICAgICAgICAgICAgMSA6XHJcbiAgICAgICAgICAgIG1pdGVyMSwgZGlyZWN0aW9uMSA9PT0gMSA/IC1GTE9BVF9NQVggOiAwLjUgKiB0aGlzLl9zZWdtZW50TGVuZ3RoKTtcclxuICAgICAgICB0aGlzLl93cml0ZVZlcnRleChlbmQsIGRpc3BsYWNlbWVudCwgVVZfTkVHX09ORV9QQUNLRUQsIFVWX1pFUk9fUEFDS0VELCBwb2x5bGluZUxlbmd0aCArIHRoaXMuX3NlZ21lbnRMZW5ndGgsIGRpcmVjdGlvbjIgPT09IDEgJiYgKHRoaXMuX2pvaW4gIT09IDAgLyogTUlURVIgKi8gfHwgbWl0ZXIyID4gTUlURVJfTElNSVQpID9cclxuICAgICAgICAgICAgMSA6XHJcbiAgICAgICAgICAgIGRpcmVjdGlvbjIgKiBtaXRlcjIsIGRpcmVjdGlvbjIgPT09IDEgPyBGTE9BVF9NQVggOiAtMC41ICogdGhpcy5fc2VnbWVudExlbmd0aCk7XHJcbiAgICAgICAgdGhpcy53cml0ZUluZGljZXNGb3JDb250aW51b3VzU3RyaXAoU0VHTUVOVF9WRVJURVhfQ09VTlQsIHRoaXMuX2Jhc2VJbmRleCk7XHJcbiAgICAgICAgdGhpcy5fYmFzZUluZGV4ICs9IFNFR01FTlRfVkVSVEVYX0NPVU5UO1xyXG4gICAgICAgIHRoaXMuX2xhc3RTaWduZWRNaXRlciA9IC1kaXJlY3Rpb24yICogbWl0ZXIyO1xyXG4gICAgICAgIHRoaXMuX2xhc3REaXJlY3Rpb24gPSBkaXJlY3Rpb24yO1xyXG4gICAgICAgIHZlYzIuY29weShkaXNwbGFjZW1lbnQsIHRoaXMuX3ByZXZEaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHZlYzIuY29weShuZXh0U2VnbWVudE5vcm1hbCwgZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB0aGlzLl9wb2x5bGluZUxlbmd0aCArPSB0aGlzLl9zZWdtZW50TGVuZ3RoO1xyXG4gICAgICAgIHRoaXMuX3NlZ21lbnRMZW5ndGggPSBuZXh0U2VnbWVudExlbmd0aDtcclxuICAgIH1cclxuICAgIF93cml0ZUpvaW4oam9pblZlcnRleCkge1xyXG4gICAgICAgIHN3aXRjaCAodGhpcy5fam9pbikge1xyXG4gICAgICAgICAgICBjYXNlIDIgLyogQkVWRUwgKi86XHJcbiAgICAgICAgICAgICAgICB0aGlzLl93cml0ZUJldmVsSm9pbihqb2luVmVydGV4KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDEgLyogUk9VTkQgKi86XHJcbiAgICAgICAgICAgICAgICB0aGlzLl93cml0ZVJvdW5kSm9pbihqb2luVmVydGV4KTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDAgLyogTUlURVIgKi86XHJcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5fbGFzdFNpZ25lZE1pdGVyKSA+IE1JVEVSX0xJTUlUKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fd3JpdGVCZXZlbEpvaW4oam9pblZlcnRleCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfd3JpdGVCZXZlbEpvaW4oam9pblZlcnRleCkge1xyXG4gICAgICAgIGNvbnN0IGxhc3REaXJlY3Rpb24gPSB0aGlzLl9sYXN0RGlyZWN0aW9uO1xyXG4gICAgICAgIGNvbnN0IGRpc3BsYWNlbWVudCA9IHZlYzIuaW52ZXJ0KHRoaXMuX2Rpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdmVjMi5hZGQoZGlzcGxhY2VtZW50LCB0aGlzLl9wcmV2RGlzcGxhY2VtZW50LCBkaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHZlYzIubXVsbihkaXNwbGFjZW1lbnQsIDAuNSAqIGxhc3REaXJlY3Rpb24sIGRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVWZXJ0ZXgoam9pblZlcnRleCwgZGlzcGxhY2VtZW50LCBsYXN0RGlyZWN0aW9uID09PSAtMSAvKiBMRUZUICovID9cclxuICAgICAgICAgICAgVVZfUE9TX09ORV9QQUNLRUQgOlxyXG4gICAgICAgICAgICBVVl9ORUdfT05FX1BBQ0tFRCwgVVZfWkVST19QQUNLRUQsIHRoaXMuX3BvbHlsaW5lTGVuZ3RoLCAxLCAxKTtcclxuICAgICAgICBjb25zdCBiYXNlSW5kZXggPSB0aGlzLl9iYXNlSW5kZXg7XHJcbiAgICAgICAgdGhpcy53cml0ZUluZGljZXMoW1xyXG4gICAgICAgICAgICBiYXNlSW5kZXggLSAxLFxyXG4gICAgICAgICAgICBiYXNlSW5kZXggLSAzLFxyXG4gICAgICAgICAgICBiYXNlSW5kZXgsXHJcbiAgICAgICAgICAgIGJhc2VJbmRleCxcclxuICAgICAgICAgICAgbGFzdERpcmVjdGlvbiA9PT0gLTEgLyogTEVGVCAqLyA/IGJhc2VJbmRleCArIDEgOiBiYXNlSW5kZXggKyAzLFxyXG4gICAgICAgICAgICBsYXN0RGlyZWN0aW9uID09PSAtMSAvKiBMRUZUICovID8gYmFzZUluZGV4ICsgMyA6IGJhc2VJbmRleCArIDFcclxuICAgICAgICBdKTtcclxuICAgICAgICB0aGlzLl9iYXNlSW5kZXggKz0gMTtcclxuICAgIH1cclxuICAgIF93cml0ZVJvdW5kSm9pbihqb2luVmVydGV4KSB7XHJcbiAgICAgICAgY29uc3QgcG9seWxpbmVMZW5ndGggPSB0aGlzLl9wb2x5bGluZUxlbmd0aDtcclxuICAgICAgICB0aGlzLl93cml0ZVZlcnRleChqb2luVmVydGV4LCB2ZWMyLlpFUk8sIFVWX1pFUk9fUEFDS0VELCBVVl9aRVJPX1BBQ0tFRCwgcG9seWxpbmVMZW5ndGgsIDAsIDApO1xyXG4gICAgICAgIGNvbnN0IGxhc3REaXJlY3Rpb24gPSB0aGlzLl9sYXN0RGlyZWN0aW9uO1xyXG4gICAgICAgIGNvbnN0IG1pZGRsZURpc3BsYWNlbWVudCA9IHZlYzIuaW52ZXJ0KHRoaXMuX3ByZXZEaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHZlYzIuYWRkKHRoaXMuX2Rpc3BsYWNlbWVudCwgbWlkZGxlRGlzcGxhY2VtZW50LCBtaWRkbGVEaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHZlYzIubm9ybWFsaXplKG1pZGRsZURpc3BsYWNlbWVudCwgbWlkZGxlRGlzcGxhY2VtZW50KTtcclxuICAgICAgICBjb25zdCBkaXNwbGFjZW1lbnQgPSB2ZWMyLmludmVydCh0aGlzLl9wcmV2RGlzcGxhY2VtZW50KTtcclxuICAgICAgICBjb25zdCBtaXRlcjEgPSBjb21wdXRlTWl0ZXIobWlkZGxlRGlzcGxhY2VtZW50LCBkaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHZlYzIuYWRkKGRpc3BsYWNlbWVudCwgbWlkZGxlRGlzcGxhY2VtZW50LCBkaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHZlYzIubm9ybWFsaXplKGRpc3BsYWNlbWVudCwgZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB2ZWMyLm11bG4oZGlzcGxhY2VtZW50LCAtbGFzdERpcmVjdGlvbiAqIG1pdGVyMSwgZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB0aGlzLl93cml0ZVZlcnRleChqb2luVmVydGV4LCBkaXNwbGFjZW1lbnQsIGxhc3REaXJlY3Rpb24gPT09IC0xIC8qIExFRlQgKi8gP1xyXG4gICAgICAgICAgICBVVl9QT1NfT05FX1BBQ0tFRCA6XHJcbiAgICAgICAgICAgIFVWX05FR19PTkVfUEFDS0VELCBwYWNrVXZDb21wb25lbnQoTWF0aC5zcXJ0KG1pdGVyMSAqIG1pdGVyMSAtIDEpKSwgcG9seWxpbmVMZW5ndGgsIDEsIEZMT0FUX01BWCk7XHJcbiAgICAgICAgdmVjMi5tdWxuKG1pZGRsZURpc3BsYWNlbWVudCwgLWxhc3REaXJlY3Rpb24sIGRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVWZXJ0ZXgoam9pblZlcnRleCwgZGlzcGxhY2VtZW50LCBsYXN0RGlyZWN0aW9uID09PSAtMSAvKiBMRUZUICovID9cclxuICAgICAgICAgICAgVVZfUE9TX09ORV9QQUNLRUQgOlxyXG4gICAgICAgICAgICBVVl9ORUdfT05FX1BBQ0tFRCwgVVZfWkVST19QQUNLRUQsIHBvbHlsaW5lTGVuZ3RoLCAxLCBGTE9BVF9NQVgpO1xyXG4gICAgICAgIGNvbnN0IG1pdGVyMiA9IGNvbXB1dGVNaXRlcihtaWRkbGVEaXNwbGFjZW1lbnQsIHRoaXMuX2Rpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdmVjMi5hZGQodGhpcy5fZGlzcGxhY2VtZW50LCBtaWRkbGVEaXNwbGFjZW1lbnQsIGRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdmVjMi5ub3JtYWxpemUoZGlzcGxhY2VtZW50LCBkaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHZlYzIubXVsbihkaXNwbGFjZW1lbnQsIC1sYXN0RGlyZWN0aW9uICogbWl0ZXIyLCBkaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlVmVydGV4KGpvaW5WZXJ0ZXgsIGRpc3BsYWNlbWVudCwgbGFzdERpcmVjdGlvbiA9PT0gLTEgLyogTEVGVCAqLyA/XHJcbiAgICAgICAgICAgIFVWX1BPU19PTkVfUEFDS0VEIDpcclxuICAgICAgICAgICAgVVZfTkVHX09ORV9QQUNLRUQsIHBhY2tVdkNvbXBvbmVudChNYXRoLnNxcnQobWl0ZXIyICogbWl0ZXIyIC0gMSkpLCBwb2x5bGluZUxlbmd0aCwgMSwgRkxPQVRfTUFYKTtcclxuICAgICAgICBjb25zdCBiYXNlSW5kZXggPSB0aGlzLl9iYXNlSW5kZXg7XHJcbiAgICAgICAgdGhpcy53cml0ZUluZGljZXMoW1xyXG4gICAgICAgICAgICBiYXNlSW5kZXggLSAzLFxyXG4gICAgICAgICAgICBiYXNlSW5kZXggLSAxLFxyXG4gICAgICAgICAgICBiYXNlSW5kZXgsXHJcbiAgICAgICAgICAgIGJhc2VJbmRleCxcclxuICAgICAgICAgICAgbGFzdERpcmVjdGlvbiA9PT0gLTEgLyogTEVGVCAqLyA/IGJhc2VJbmRleCAtIDMgOiBiYXNlSW5kZXggLSAxLFxyXG4gICAgICAgICAgICBiYXNlSW5kZXggKyAxLFxyXG4gICAgICAgICAgICBiYXNlSW5kZXgsXHJcbiAgICAgICAgICAgIGJhc2VJbmRleCArIDEsXHJcbiAgICAgICAgICAgIGJhc2VJbmRleCArIDIsXHJcbiAgICAgICAgICAgIGJhc2VJbmRleCxcclxuICAgICAgICAgICAgYmFzZUluZGV4ICsgMixcclxuICAgICAgICAgICAgYmFzZUluZGV4ICsgMyxcclxuICAgICAgICAgICAgYmFzZUluZGV4LFxyXG4gICAgICAgICAgICBiYXNlSW5kZXggKyAzLFxyXG4gICAgICAgICAgICBsYXN0RGlyZWN0aW9uID09PSAtMSAvKiBMRUZUICovID8gYmFzZUluZGV4ICsgNCA6IGJhc2VJbmRleCArIDYsXHJcbiAgICAgICAgICAgIGJhc2VJbmRleCxcclxuICAgICAgICAgICAgYmFzZUluZGV4ICsgNCxcclxuICAgICAgICAgICAgYmFzZUluZGV4ICsgNlxyXG4gICAgICAgIF0pO1xyXG4gICAgICAgIHRoaXMuX2Jhc2VJbmRleCArPSA0O1xyXG4gICAgfVxyXG4gICAgX3dyaXRlTGFzdFNlZ21lbnQoc3RhcnQsIGVuZCkge1xyXG4gICAgICAgIGNvbnN0IGRpc3BsYWNlbWVudCA9IHRoaXMuX2Rpc3BsYWNlbWVudDtcclxuICAgICAgICBjb25zdCBsYXN0RGlyZWN0aW9uID0gdGhpcy5fbGFzdERpcmVjdGlvbjtcclxuICAgICAgICBjb25zdCBwb2x5bGluZUxlbmd0aCA9IHRoaXMuX3BvbHlsaW5lTGVuZ3RoO1xyXG4gICAgICAgIGNvbnN0IG1pdGVyID0gdGhpcy5fbGFzdFNpZ25lZE1pdGVyO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlVmVydGV4KHN0YXJ0LCBkaXNwbGFjZW1lbnQsIFVWX1BPU19PTkVfUEFDS0VELCBVVl9aRVJPX1BBQ0tFRCwgcG9seWxpbmVMZW5ndGgsIGxhc3REaXJlY3Rpb24gPT09IC0xIC8qIExFRlQgKi8gJiYgKHRoaXMuX2pvaW4gIT09IDAgLyogTUlURVIgKi8gfHwgTWF0aC5hYnMobWl0ZXIpID4gTUlURVJfTElNSVQpID9cclxuICAgICAgICAgICAgMSA6XHJcbiAgICAgICAgICAgIG1pdGVyLCBsYXN0RGlyZWN0aW9uID09PSAtMSAvKiBMRUZUICovID8gLUZMT0FUX01BWCA6IHRoaXMuX3NlZ21lbnRMZW5ndGgpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlVmVydGV4KGVuZCwgZGlzcGxhY2VtZW50LCBVVl9QT1NfT05FX1BBQ0tFRCwgVVZfWkVST19QQUNLRUQsIHBvbHlsaW5lTGVuZ3RoICsgdGhpcy5fc2VnbWVudExlbmd0aCwgMSwgRkxPQVRfTUFYKTtcclxuICAgICAgICB2ZWMyLmludmVydChkaXNwbGFjZW1lbnQsIGRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVWZXJ0ZXgoc3RhcnQsIGRpc3BsYWNlbWVudCwgVVZfTkVHX09ORV9QQUNLRUQsIFVWX1pFUk9fUEFDS0VELCBwb2x5bGluZUxlbmd0aCwgbGFzdERpcmVjdGlvbiA9PT0gMSAvKiBSSUdIVCAqLyAmJiAodGhpcy5fam9pbiAhPT0gMCAvKiBNSVRFUiAqLyB8fCBNYXRoLmFicyhtaXRlcikgPiBNSVRFUl9MSU1JVCkgP1xyXG4gICAgICAgICAgICAxIDpcclxuICAgICAgICAgICAgbWl0ZXIsIGxhc3REaXJlY3Rpb24gPT09IDEgLyogUklHSFQgKi8gPyAtRkxPQVRfTUFYIDogdGhpcy5fc2VnbWVudExlbmd0aCk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVWZXJ0ZXgoZW5kLCBkaXNwbGFjZW1lbnQsIFVWX05FR19PTkVfUEFDS0VELCBVVl9aRVJPX1BBQ0tFRCwgcG9seWxpbmVMZW5ndGggKyB0aGlzLl9zZWdtZW50TGVuZ3RoLCAxLCBGTE9BVF9NQVgpO1xyXG4gICAgICAgIHRoaXMud3JpdGVJbmRpY2VzRm9yQ29udGludW91c1N0cmlwKFNFR01FTlRfVkVSVEVYX0NPVU5ULCB0aGlzLl9iYXNlSW5kZXgpO1xyXG4gICAgICAgIHRoaXMuX2Jhc2VJbmRleCArPSBTRUdNRU5UX1ZFUlRFWF9DT1VOVDtcclxuICAgIH1cclxufVxyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiI3ZlcnNpb24gMTAwXFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG4jaWZuZGVmIEZJTFRFUl9SQURJVVNcXG4jICAgZXJyb3IgRklMVEVSX1JBRElVUyBtdXN0IGJlIHNldFxcbiNlbmRpZlxcblxcbiNpZm5kZWYgTUFYX0hBTEZfV0lEVEhcXG4jICAgZXJyb3IgTUFYX0hBTEZfV0lEVEggbXVzdCBiZSBzZXRcXG4jZW5kaWZcXG5cXG4jaWZuZGVmIE1BWF9GSUxMX0dBUFxcbiMgICBlcnJvciBNQVhfRklMTF9HQVAgbXVzdCBiZSBzZXRcXG4jZW5kaWZcXG5cXG5hdHRyaWJ1dGUgdmVjNCB2ZXJ0ZXhQb3M7XFxuYXR0cmlidXRlIHZlYzIgdmVydGV4Tm9ybWFsUGFja2VkO1xcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleFV2UGFja2VkO1xcbmF0dHJpYnV0ZSB2ZWMzIHZlcnRleFdpZHRoRmlsbEdhcDtcXG5hdHRyaWJ1dGUgdmVjNCB2ZXJ0ZXhDb2xvcjtcXG5hdHRyaWJ1dGUgZmxvYXQgdmVydGV4TWl0ZXI7XFxuYXR0cmlidXRlIGZsb2F0IHZlcnRleFZMaW1pdDtcXG5hdHRyaWJ1dGUgZmxvYXQgdmVydGV4TGVuZ3RoO1xcblxcbnVuaWZvcm0gdmVjMiBsb29rQXRIaWdoO1xcbnVuaWZvcm0gdmVjMiBsb29rQXRMb3c7XFxudW5pZm9ybSBtYXQ0IHZpZXdQcm9qTWF0cml4O1xcbnVuaWZvcm0gZmxvYXQgd29ybGRUb1B4RmFjdG9yO1xcblxcbnZhcnlpbmcgdmVjMiB1djtcXG52YXJ5aW5nIGZsb2F0IGxlbjtcXG52YXJ5aW5nIGZsb2F0IGhhbGZXaWR0aDtcXG52YXJ5aW5nIHZlYzMgZGFzaDtcXG52YXJ5aW5nIHZlYzQgY29sb3I7XFxuXFxuY29uc3QgZmxvYXQgWVZfSCA9IDEuOTk5OTY5NDgyNDIxODc1O1xcbmNvbnN0IGZsb2F0IFlWX0wgPSAwLjAwMDAzMDUxNzExMjQ2MzcxMjY5MjtcXG5jb25zdCB2ZWM0IFlWX0hITEwgPSB2ZWM0KFlWX0gsIFlWX0gsIFlWX0wsIFlWX0wpO1xcblxcbmNvbnN0IGZsb2F0IFNRUlQyID0gMS40MTQyMTM1MzgxNjk4NjA4O1xcblxcbnZlYzIgdW5wYWNrVXYoY29uc3QgaW4gdmVjMiB1dikge1xcbiAgICByZXR1cm4gKHV2IC0gMTI4LikgLyAxMjcuO1xcbn1cXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgICB2ZWMyIG5vcm1hbCA9ICgyLjAgKiB2ZXJ0ZXhOb3JtYWxQYWNrZWQgLSAxLjApICogU1FSVDI7XFxuXFxuICAgIGhhbGZXaWR0aCA9IGZsb2F0KE1BWF9IQUxGX1dJRFRIKSAqIHZlcnRleFdpZHRoRmlsbEdhcC54O1xcbiAgICBoYWxmV2lkdGggKz0gRklMVEVSX1JBRElVUztcXG5cXG4gICAgZmxvYXQgdGFuZ2VudExlbmd0aCA9IG1pbihcXG4gICAgICAgIHNxcnQodmVydGV4TWl0ZXIgKiB2ZXJ0ZXhNaXRlciAtIDEuKSAqIGhhbGZXaWR0aCAqIHdvcmxkVG9QeEZhY3RvcixcXG4gICAgICAgIGFicyh2ZXJ0ZXhWTGltaXQpXFxuICAgICk7XFxuXFxuICAgIHZlYzQgbG9va0F0ID0gdmVjNChsb29rQXRIaWdoLCBsb29rQXRMb3cpO1xcbiAgICB2ZWM0IHJlbGF0aXZlVG9FeWVQb3NpdGlvbiA9IFlWX0hITEwgKiAodmVydGV4UG9zIC0gbG9va0F0KTtcXG5cXG4gICAgZ2xfUG9zaXRpb24gPSB2aWV3UHJvak1hdHJpeCAqIHZlYzQoXFxuICAgICAgICByZWxhdGl2ZVRvRXllUG9zaXRpb24ueHkgKyByZWxhdGl2ZVRvRXllUG9zaXRpb24uencgK1xcbiAgICAgICAgICAgICAgICB3b3JsZFRvUHhGYWN0b3IgKiBoYWxmV2lkdGggKiBub3JtYWwgLVxcbiAgICAgICAgICAgICAgICAgICAgc2lnbih2ZXJ0ZXhNaXRlcikgKiB0YW5nZW50TGVuZ3RoICogdmVjMihub3JtYWwueSwgLW5vcm1hbC54KSxcXG4gICAgICAgIDAsXFxuICAgICAgICAxXFxuICAgICk7XFxuXFxuICAgIHV2ID0gdW5wYWNrVXYodmVydGV4VXZQYWNrZWQpICogaGFsZldpZHRoO1xcbiAgICBsZW4gPSAodmVydGV4TGVuZ3RoICsgc2lnbih2ZXJ0ZXhWTGltaXQpICogdGFuZ2VudExlbmd0aCkgLyB3b3JsZFRvUHhGYWN0b3I7XFxuXFxuICAgIGRhc2gueHkgPSB2ZWMyKE1BWF9GSUxMX0dBUCkgKiB2ZXJ0ZXhXaWR0aEZpbGxHYXAueXo7XFxuICAgIGRhc2gueiA9IGRhc2gueCArIGRhc2gueTtcXG5cXG4gICAgY29sb3IgPSB2ZXJ0ZXhDb2xvcjtcXG4gICAgY29sb3IucmdiICo9IGNvbG9yLmE7XFxufVxcblwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIiN2ZXJzaW9uIDEwMFxcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxuI2lmbmRlZiBGSUxURVJfUkFESVVTXFxuIyAgIGVycm9yIEZJTFRFUl9SQURJVVMgbXVzdCBiZSBzZXRcXG4jZW5kaWZcXG5cXG52YXJ5aW5nIGhpZ2hwIHZlYzIgdXY7XFxudmFyeWluZyBoaWdocCBmbG9hdCBsZW47XFxudmFyeWluZyBoaWdocCBmbG9hdCBoYWxmV2lkdGg7XFxudmFyeWluZyBsb3dwIHZlYzMgZGFzaDtcXG52YXJ5aW5nIGxvd3AgdmVjNCBjb2xvcjtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgICBsb3dwIGZsb2F0IGFscGhhID1cXG4gICAgICAgIHNtb290aHN0ZXAoMC4wLCBGSUxURVJfUkFESVVTICsgbWluKEZJTFRFUl9SQURJVVMsIGhhbGZXaWR0aCksIGhhbGZXaWR0aCAtIGxlbmd0aCh1dikpO1xcblxcbiAgICBpZiAoZGFzaC56ID4gMC4wKSB7XFxuICAgICAgICBsb3dwIHZlYzMgaGFsZkRhc2ggPSBkYXNoICogMC41O1xcbiAgICAgICAgbG93cCBmbG9hdCBkYXNoUGhhc2UgPSBtb2QobGVuICsgaGFsZkRhc2gueSwgZGFzaC56KTtcXG4gICAgICAgIGxvd3AgZmxvYXQgciA9IG1pbihGSUxURVJfUkFESVVTLCBoYWxmRGFzaC55KTtcXG5cXG4gICAgICAgIGFscGhhICo9IHNtb290aHN0ZXAoLXIsIHIsIGhhbGZEYXNoLnggLSBhYnMoZGFzaFBoYXNlIC0gaGFsZkRhc2gueikpO1xcbiAgICB9XFxuXFxuICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yICogYWxwaGE7XFxufVxcblwiIiwiaW1wb3J0IHRleHR1cmVkUG9seWdvblZlcnRleFNoYWRlciBmcm9tICcuL3NoYWRlci90ZXh0dXJlZF9wb2x5Z29uLnZlcnQnO1xyXG5pbXBvcnQgdGV4dHVyZWRQb2x5Z29uRnJhZ21lbnRTaGFkZXIgZnJvbSAnLi9zaGFkZXIvdGV4dHVyZWRfcG9seWdvbi5mcmFnJztcclxuaW1wb3J0ICogYXMgdmVjMiBmcm9tICcuLi8uLi8uLi9tYXRoL3ZlY3RvcjInO1xyXG5pbXBvcnQgUmVuZGVyU3RhdGUgZnJvbSAnLi4vLi4vLi4vcmVuZGVyL3N0YXRlJztcclxuaW1wb3J0IHsgQkxFTkRfT1ZFUl9SRU5ERVJfU1RBVEUgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXIvc3RhdGUnO1xyXG5pbXBvcnQgV29ybGRQcmltaXRpdmVSZW5kZXJVbml0IGZyb20gJy4uL3dvcmxkX3ByaW1pdGl2ZV9yZW5kZXJfdW5pdCc7XHJcbmNvbnN0IFJFTkRFUl9TVEFURSA9IG5ldyBSZW5kZXJTdGF0ZShCTEVORF9PVkVSX1JFTkRFUl9TVEFURSwge1xyXG4gICAgZGVwdGhUZXN0OiB0cnVlLFxyXG4gICAgZGVwdGhNYXNrOiBmYWxzZSxcclxuICAgIGRlcHRoRnVuYzogNTE4IC8qIEdSRUFURVJfT1JfRVFVQUwgKi9cclxufSk7XHJcbi8qKlxyXG4gKiBSZW5kZXJlciBvZiBwb2x5bGluZSBwcmltaXRpdmVzLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGV4dHVyZWRQb2x5Z29uUmVuZGVyVW5pdCBleHRlbmRzIFdvcmxkUHJpbWl0aXZlUmVuZGVyVW5pdCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBwcmltaXRpdmVQcm92aWRlcikge1xyXG4gICAgICAgIGNvbnN0IHByb2dyYW0gPSBjb250ZXh0LmNyZWF0ZVByb2dyYW0odGV4dHVyZWRQb2x5Z29uVmVydGV4U2hhZGVyLCB0ZXh0dXJlZFBvbHlnb25GcmFnbWVudFNoYWRlciwge1xyXG4gICAgICAgICAgICBhdHRyaWJNYXA6IHtcclxuICAgICAgICAgICAgICAgIHZlcnRleFBvc0hpZ2g6IDAgLyogUE9TSVRJT05fSElHSCAqLyxcclxuICAgICAgICAgICAgICAgIHZlcnRleFBvc0xvdzogMSAvKiBQT1NJVElPTl9MT1cgKi8sXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhVVjogNCAvKiBVViAqLyxcclxuICAgICAgICAgICAgICAgIHZlcnRleEltYWdlU2NhbGU6IDExIC8qIEFVWCAqLyxcclxuICAgICAgICAgICAgICAgIHZlcnRleFpJbmRleDogMTAgLyogWl9JTkRFWCAqL1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc3VwZXIoY29udGV4dCwgUkVOREVSX1NUQVRFLCBwcm9ncmFtLCBwcmltaXRpdmVQcm92aWRlcik7XHJcbiAgICAgICAgdGhpcy5fYXRsYXNTaXplVW5pZm9ybSA9IHZlYzIuY3JlYXRlKDAsIDApO1xyXG4gICAgICAgIGNvbnRleHQuYmluZFByb2dyYW0ocHJvZ3JhbSk7XHJcbiAgICAgICAgcHJvZ3JhbS5zZXRJbnRTY2FsYXJVbmlmb3JtKCdhdGxhcycsIDApO1xyXG4gICAgfVxyXG4gICAgX3JlbmRlckJhdGNoKG1lbW9yeUJhdGNoKSB7XHJcbiAgICAgICAgY29uc3QgYXRsYXMgPSBtZW1vcnlCYXRjaC5maXJzdFByaW1pdGl2ZS5hdGxhcztcclxuICAgICAgICB0aGlzLl9hdGxhc1NpemVVbmlmb3JtLnggPSBhdGxhcy53aWR0aDtcclxuICAgICAgICB0aGlzLl9hdGxhc1NpemVVbmlmb3JtLnkgPSBhdGxhcy5oZWlnaHQ7XHJcbiAgICAgICAgaWYgKGF0bGFzLmlzRGlydHkpIHtcclxuICAgICAgICAgICAgYXRsYXMuc3luY1RleHR1cmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcHJvZ3JhbS5zZXRWZWN0b3IyVW5pZm9ybSgnYXRsYXNTaXplJywgdGhpcy5fYXRsYXNTaXplVW5pZm9ybSk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kVGV4dHVyZVVuaXQoMCk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kVGV4dHVyZShhdGxhcy50ZXh0dXJlKTtcclxuICAgICAgICBzdXBlci5fcmVuZGVyQmF0Y2gobWVtb3J5QmF0Y2gpO1xyXG4gICAgfVxyXG4gICAgX2NhbkJhdGNoQWRqYWNlbnRQcmltaXRpdmVzKGEsIGIpIHtcclxuICAgICAgICByZXR1cm4gc3VwZXIuX2NhbkJhdGNoQWRqYWNlbnRQcmltaXRpdmVzKGEsIGIpICYmIChhLmF0bGFzID09PSBiLmF0bGFzKTtcclxuICAgIH1cclxufVxyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiI3ZlcnNpb24gMTAwXFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhQb3NIaWdoO1xcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleFBvc0xvdztcXG5hdHRyaWJ1dGUgdmVjNCB2ZXJ0ZXhVVjtcXG5hdHRyaWJ1dGUgZmxvYXQgdmVydGV4SW1hZ2VTY2FsZTtcXG5hdHRyaWJ1dGUgZmxvYXQgdmVydGV4WkluZGV4O1xcblxcbnVuaWZvcm0gdmVjMiBsb29rQXRIaWdoO1xcbnVuaWZvcm0gdmVjMiBsb29rQXRMb3c7XFxudW5pZm9ybSBtYXQ0IHZpZXdQcm9qTWF0cml4O1xcblxcbnZhcnlpbmcgdmVjMiB1dlBvc2l0aW9uO1xcbnZhcnlpbmcgdmVjMiB0ZXh0dXJlU2l6ZTtcXG52YXJ5aW5nIHZlYzIgdXZEaXNwbGFjZW1lbnQ7XFxuXFxuY29uc3QgZmxvYXQgWVZfSCA9IDEuOTk5OTY5NDgyNDIxODc1O1xcbmNvbnN0IGZsb2F0IFlWX0wgPSAwLjAwMDAzMDUxNzExMjQ2MzcxMjY5MjtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgICB1dlBvc2l0aW9uID0gdmVydGV4VVYueHk7XFxuICAgIHRleHR1cmVTaXplID0gdmVydGV4VVYuenc7XFxuXFxuICAgIC8vIFRoZSBzYW1lIHBhdHRlcm4gaW1hZ2Ugc2hvdWxkIG1hdGNoIGFjcm9zcyBtdWx0aXBsZSAodXN1YWxseSBhZGphY2VudCkgcG9seWdvbnMgYW5kIGl0IHNob3VsZCBoYXZlXFxuICAgIC8vIHN0YWJsZSBwb3NpdGlvbiByZWFsdGl2ZSB0byB0aGUgcG9seWdvbi4gQWxzbyBwYXR0ZXJuIGlzIHJlcGVhdGVkIGF0IGJvdGggZGlyZWN0aW9ucy5cXG4gICAgLy8gVG8gbWVldCB0aGVzZSByZXF1aXJlbWVudHMgdGhlIHdvcmxkIGlzIGNvdmVyZWQgKHZpcnR1YWxseSkgYnkgYSB0ZXh0dXJlIG9mIGFwcHJvcHJpYXRlIHNpemUgKHJlcGVhdGVkIGltYWdlKVxcbiAgICAvLyBhbmQgdmVydGV4IGNvb3JkaW5hdGVzIGFyZSBtYXBwZWQgdG8gdGhlc2UgdGV4dHVyZSBjb29yZGluYXRlcyAodXZEaXNwbGFjZW1lbnQpLlxcbiAgICAvLyBCdXQgZHVlIHRvIGxpbWl0ZWQgcHJlY2lzaW9uIHdlJ3ZlIGdvdCB0byB3b3JrIHdpdGggXFxcIm5hcnJvd1xcXCIgZmxvYXRzIChhcyBpdCBpcyBkb25lIGluIHdvcmxkIHBvc2l0aW9uIGNhbGN1bGF0aW9uKTpcXG4gICAgLy8gICAxLiBjYWxjdWxhdGUgaG93IGJpZyB0ZXh0dXJlIHBhdHRlcm4gaW4gd29ybGQgY29vcmRpbmF0ZXMgKHNjYWxlZFRleHR1cmVTaXplKVxcbiAgICAvLyAgIDIuIGZpbmQgdGhlIGNsb3Nlc3QgdG8gZXllIGNvb3JkaW5hdGVzIHRleHR1cmUgYmFzZSBwb2ludCAodGhlIGJvdHRvbSBsZWZ0IHBvaW50IG9mIHRoZSBwYXR0ZXJuKVxcbiAgICAvLyAgIDMuIHVzZSB2ZXJ0ZXggcG9zaXRpb24gYW5kIHRleHR1cmVCYXNlUG9pbnQgdmVjdG9ycyB0byBmaW5kIGNvb3JkaW5hdGVzIGluIHZpcnR1YWwgdGV4dHVyZVxcbiAgICAvLyAgIDQuIGZpbmQgdXYgY29vcmRpbmF0ZXMgaW4gcmVhbCB0ZXh0dXJlIHVzaW5nIG1vZCBvcGVyYXRpb25cXG4gICAgLy9cXG4gICAgLy8gQm90aCB0ZXh0dXJlQmFzZVBvaW50IGFuZCBwb3NpdGlvbiBhcmUgcmVsYXRpdmVsbHkgc21hbGwgdmVjdG9ycyBzbyB0aGF0IHByZWNpc2lvbiByZXF1aXJlbWVudHMgYXJlIG1ldCxcXG4gICAgLy8gYW5kIGNvcnJlY3QgaW50ZXJwb2xhdGlvbiBvZiByZXBlYXRlZCBpbWFnZSBpcyBwb3NzaWJsZSBieSB1c2luZyBzaW5nbGUgYmFzZSBwb2ludCBpbiBhbGwgdmVydGljZXMuXFxuXFxuICAgIHZlYzIgc2NhbGVkVGV4dHVyZVNpemUgPSB0ZXh0dXJlU2l6ZSAqIHZlcnRleEltYWdlU2NhbGU7IC8vIHRleHR1cmUgc2l6ZSBpbiB3b3JsZCBjb29yZGluYXRlc1xcbiAgICB2ZWMyIHRleHR1cmVCYXNlUG9pbnQgPSBtb2QoWVZfSCAqIGxvb2tBdEhpZ2gsIHNjYWxlZFRleHR1cmVTaXplKSArIG1vZChZVl9MICogbG9va0F0TG93LCBzY2FsZWRUZXh0dXJlU2l6ZSk7XFxuICAgIHZlYzIgcG9zaXRpb24gPSBZVl9IICogKHZlcnRleFBvc0hpZ2ggLSBsb29rQXRIaWdoKSArIFlWX0wgKiAodmVydGV4UG9zTG93IC0gbG9va0F0TG93KTtcXG5cXG4gICAgZ2xfUG9zaXRpb24gPSB2aWV3UHJvak1hdHJpeCAqIHZlYzQocG9zaXRpb24sIDAsIDEpO1xcbiAgICBnbF9Qb3NpdGlvbi54eSAvPSBnbF9Qb3NpdGlvbi53O1xcbiAgICBnbF9Qb3NpdGlvbi56ID0gdmVydGV4WkluZGV4O1xcbiAgICBnbF9Qb3NpdGlvbi53ID0gMS4wO1xcblxcbiAgICAvLyBjb252ZXJ0IHdvcmxkIGNvb3JkaW5hdGVzIGJhY2sgdG8gdGV0dXJlIHBpeGVsc1xcbiAgICB1dkRpc3BsYWNlbWVudCA9IChwb3NpdGlvbiArIHRleHR1cmVCYXNlUG9pbnQpIC8gdmVydGV4SW1hZ2VTY2FsZTtcXG59XFxuXCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiI3ZlcnNpb24gMTAwXFxuXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCBhdGxhcztcXG51bmlmb3JtIHZlYzIgYXRsYXNTaXplO1xcblxcbnZhcnlpbmcgdmVjMiB1dlBvc2l0aW9uO1xcbnZhcnlpbmcgdmVjMiB0ZXh0dXJlU2l6ZTtcXG52YXJ5aW5nIHZlYzIgdXZEaXNwbGFjZW1lbnQ7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gICAgdmVjMiB1dkFkanVzdGVkID0gdmVjMihcXG4gICAgICAgIHV2UG9zaXRpb24ueCArIG1vZCh1dkRpc3BsYWNlbWVudC54LCB0ZXh0dXJlU2l6ZS54KSxcXG4gICAgICAgIHV2UG9zaXRpb24ueSArIG1vZCh1dkRpc3BsYWNlbWVudC55LCB0ZXh0dXJlU2l6ZS55KVxcbiAgICApO1xcblxcbiAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQoYXRsYXMsIHV2QWRqdXN0ZWQgLyBhdGxhc1NpemUpO1xcbn1cXG5cIiIsImltcG9ydCBQb2x5Z29uUmVuZGVyZXJVbml0IGZyb20gJy4vcG9seWdvbl9yZW5kZXJfdW5pdCc7XHJcbmltcG9ydCBSZW5kZXJTdGF0ZSBmcm9tICcuLi8uLi8uLi9yZW5kZXIvc3RhdGUnO1xyXG5pbXBvcnQgeyBERUZBVUxUX1JFTkRFUl9TVEFURV9QQVJBTVMgfSBmcm9tICcuL3BvbHlnb25fcmVuZGVyX3VuaXQnO1xyXG5pbXBvcnQgeyBCTEVORF9PVkVSX1JFTkRFUl9TVEFURSB9IGZyb20gJy4uLy4uLy4uL3JlbmRlci9zdGF0ZSc7XHJcbi8qKlxyXG4gKiBSZW5kZXJlciBvZiB0cmFuc3BhcmVudCBwb2x5Z29uIHByaW1pdGl2ZXMuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUcmFuc3BhcmVudFBvbHlnb25SZW5kZXJVbml0IGV4dGVuZHMgUG9seWdvblJlbmRlcmVyVW5pdCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBwcmltaXRpdmVQcm92aWRlcikge1xyXG4gICAgICAgIHN1cGVyKGNvbnRleHQsIHByaW1pdGl2ZVByb3ZpZGVyLCBuZXcgUmVuZGVyU3RhdGUoREVGQVVMVF9SRU5ERVJfU1RBVEVfUEFSQU1TLCB7IGRlcHRoTWFzazogZmFsc2UgfSwgQkxFTkRfT1ZFUl9SRU5ERVJfU1RBVEUpKTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgcG9seWdvblZlcnRleFNoYWRlciBmcm9tICcuL3NoYWRlci9wb2x5Z29uLnZlcnQnO1xyXG5pbXBvcnQgcG9seWdvbkZyYWdtZW50U2hhZGVyIGZyb20gJy4vc2hhZGVyL3BvbHlnb24uZnJhZyc7XHJcbmltcG9ydCBSZW5kZXJTdGF0ZSBmcm9tICcuLi8uLi8uLi9yZW5kZXIvc3RhdGUnO1xyXG5pbXBvcnQgV29ybGRQcmltaXRpdmVSZW5kZXJVbml0IGZyb20gJy4uL3dvcmxkX3ByaW1pdGl2ZV9yZW5kZXJfdW5pdCc7XHJcbmV4cG9ydCBjb25zdCBERUZBVUxUX1JFTkRFUl9TVEFURV9QQVJBTVMgPSB7XHJcbiAgICBkZXB0aFRlc3Q6IHRydWUsXHJcbiAgICBkZXB0aEZ1bmM6IDUxOCAvKiBHUkVBVEVSX09SX0VRVUFMICovXHJcbn07XHJcbi8qKlxyXG4gKiBSZW5kZXJlciBvZiBwb2x5Z29uIHByaW1pdGl2ZXMuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb2x5Z29uUmVuZGVyVW5pdCBleHRlbmRzIFdvcmxkUHJpbWl0aXZlUmVuZGVyVW5pdCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBwcmltaXRpdmVQcm92aWRlciwgcmVuZGVyU3RhdGUgPSBuZXcgUmVuZGVyU3RhdGUoREVGQVVMVF9SRU5ERVJfU1RBVEVfUEFSQU1TKSkge1xyXG4gICAgICAgIGNvbnN0IHByb2dyYW0gPSBjb250ZXh0LmNyZWF0ZVByb2dyYW0ocG9seWdvblZlcnRleFNoYWRlciwgcG9seWdvbkZyYWdtZW50U2hhZGVyLCB7XHJcbiAgICAgICAgICAgIGF0dHJpYk1hcDoge1xyXG4gICAgICAgICAgICAgICAgdmVydGV4UG9zSGlnaDogMCAvKiBQT1NJVElPTl9ISUdIICovLFxyXG4gICAgICAgICAgICAgICAgdmVydGV4UG9zTG93OiAxIC8qIFBPU0lUSU9OX0xPVyAqLyxcclxuICAgICAgICAgICAgICAgIHZlcnRleENvbG9yOiA3IC8qIENPTE9SICovLFxyXG4gICAgICAgICAgICAgICAgdmVydGV4WkluZGV4OiAxMCAvKiBaX0lOREVYICovXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBzdXBlcihjb250ZXh0LCByZW5kZXJTdGF0ZSwgcHJvZ3JhbSwgcHJpbWl0aXZlUHJvdmlkZXIpO1xyXG4gICAgfVxyXG59XHJcbiIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleFBvc0hpZ2g7XFxuYXR0cmlidXRlIHZlYzIgdmVydGV4UG9zTG93O1xcbmF0dHJpYnV0ZSB2ZWM0IHZlcnRleENvbG9yO1xcbmF0dHJpYnV0ZSBmbG9hdCB2ZXJ0ZXhaSW5kZXg7XFxuXFxudW5pZm9ybSB2ZWMyIGxvb2tBdEhpZ2g7XFxudW5pZm9ybSB2ZWMyIGxvb2tBdExvdztcXG51bmlmb3JtIG1hdDQgdmlld1Byb2pNYXRyaXg7XFxuXFxudmFyeWluZyB2ZWM0IGNvbG9yO1xcblxcbmNvbnN0IGZsb2F0IFlWX0ggPSAxLjk5OTk2OTQ4MjQyMTg3NTtcXG5jb25zdCBmbG9hdCBZVl9MID0gMC4wMDAwMzA1MTcxMTI0NjM3MTI2OTI7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gICAgdmVjNCBwb3NpdGlvbiA9IHZpZXdQcm9qTWF0cml4ICogdmVjNChcXG4gICAgICAgIFlWX0ggKiAodmVydGV4UG9zSGlnaCAtIGxvb2tBdEhpZ2gpICtcXG4gICAgICAgICAgICBZVl9MICogKHZlcnRleFBvc0xvdyAtIGxvb2tBdExvdyksXFxuICAgICAgICAwLFxcbiAgICAgICAgMVxcbiAgICApO1xcblxcbiAgICBwb3NpdGlvbi54eSAvPSBwb3NpdGlvbi53O1xcbiAgICBwb3NpdGlvbi56ID0gdmVydGV4WkluZGV4O1xcbiAgICBwb3NpdGlvbi53ID0gMS4wO1xcblxcbiAgICBnbF9Qb3NpdGlvbiA9IHBvc2l0aW9uO1xcblxcbiAgICBjb2xvciA9IHZlcnRleENvbG9yO1xcbn1cXG5cIiIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbnZhcnlpbmcgbG93cCB2ZWM0IGNvbG9yO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbn1cXG5cIiIsImltcG9ydCBFbmdpbmUgZnJvbSAnLi9lbmdpbmUnO1xyXG5pbXBvcnQgRnhhYVJlbmRlclVuaXQgZnJvbSAnLi9yZW5kZXIvZnhhYV9yZW5kZXJfdW5pdCc7XHJcbmltcG9ydCBCYWNrZ3JvdW5kUmVuZGVyVW5pdCBmcm9tICcuL3JlbmRlci9iYWNrZ3JvdW5kX3JlbmRlcl91bml0JztcclxuaW1wb3J0IExheWVyUmVuZGVyVW5pdCBmcm9tICcuL3JlbmRlci9sYXllcl9yZW5kZXJfdW5pdCc7XHJcbi8qKlxyXG4gKiBHcm91bmQgbGF5ZXIgd2l0aCBiYWNrZ3JvdW5kIHRoYXQgZ29lcyByaWdodCBhZnRlciBzdWIgcmVuZGVyIHVuaXRzLiBJdCBhbGxvd3MgdG8gYWRkIG90aGVyIExheWVyUmVuZGVyVW5pdHMgYWJvdmVcclxuICogZ3JvdW5kTGF5ZXIgd2l0aG91dCB3b3JyeWluZyB0aGF0IHRoZXkgZGVzdHJveSBkZXB0aCBpbmZvcm1hdGlvbiBjb2xsZWN0ZWQgb24gZ3JvdW5kIGFuZCBicm9rZSBiYWNrZ3JvdW5kICh0aGF0IGhhc1xyXG4gKiBhIHBlcmZvcm1hbmNlIG9wdGltaXNhdGlvbjogaXQgdXNlcyBkZXB0aCBpbmZvcm1hdGlvbiBmcm9tIHRoZSBsYXllcnMgYmVsb3cgdG8gcHJldmVudCBleHRlbnNpdmUgcGl4ZWwgb3ZlcndyaXRpbmcpLlxyXG4gKi9cclxuY2xhc3MgQmFja2dyb3VuZGVkR3JvdW5kTGF5ZXIgZXh0ZW5kcyBMYXllclJlbmRlclVuaXQge1xyXG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgZGVwdGhDbGVhclN0cmF0ZWd5ID0gMCAvKiBOT19DTEVBUiAqLykge1xyXG4gICAgICAgIHN1cGVyKGNvbnRleHQsIGRlcHRoQ2xlYXJTdHJhdGVneSk7XHJcbiAgICAgICAgdGhpcy5fYmFja2dyb3VuZCA9IG5ldyBCYWNrZ3JvdW5kUmVuZGVyVW5pdChjb250ZXh0KTtcclxuICAgIH1cclxuICAgIHJlbmRlcih0YXJnZXQsIC4uLmFyZ3MpIHtcclxuICAgICAgICBzdXBlci5yZW5kZXIodGFyZ2V0LCAuLi5hcmdzKTtcclxuICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kLnJlbmRlcih0YXJnZXQpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hcEVuZ2luZSBleHRlbmRzIEVuZ2luZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBjYW1lcmEsIHJlbmRlckxvb3ApIHtcclxuICAgICAgICBzdXBlcihjb250ZXh0LCBjYW1lcmEsIHJlbmRlckxvb3ApO1xyXG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lhYmxlcyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IGFudGlhbGlhc2luZ0xheWVyID0gbmV3IEZ4YWFSZW5kZXJVbml0KGNvbnRleHQsIHRoaXMucmVuZGVyTG9vcCk7XHJcbiAgICAgICAgdGhpcy5iYWNrZ291bmRMYXllciA9IG5ldyBMYXllclJlbmRlclVuaXQoY29udGV4dCk7XHJcbiAgICAgICAgdGhpcy5ncm91bmRMYXllciA9IG5ldyBCYWNrZ3JvdW5kZWRHcm91bmRMYXllcihjb250ZXh0KTtcclxuICAgICAgICB0aGlzLmJ1aWxkaW5nc0xheWVyID0gbmV3IExheWVyUmVuZGVyVW5pdChjb250ZXh0KTtcclxuICAgICAgICB0aGlzLmljb25zTGF5ZXIgPSBuZXcgTGF5ZXJSZW5kZXJVbml0KGNvbnRleHQpO1xyXG4gICAgICAgIHRoaXMubGFiZWxzTGF5ZXIgPSBuZXcgTGF5ZXJSZW5kZXJVbml0KGNvbnRleHQpO1xyXG4gICAgICAgIGFudGlhbGlhc2luZ0xheWVyLmFkZFJlbmRlclVuaXQodGhpcy5idWlsZGluZ3NMYXllcik7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRSZW5kZXJVbml0KHRoaXMuYmFja2dvdW5kTGF5ZXIpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIuYWRkUmVuZGVyVW5pdCh0aGlzLmdyb3VuZExheWVyKTtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZFJlbmRlclVuaXQoYW50aWFsaWFzaW5nTGF5ZXIpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIuYWRkUmVuZGVyVW5pdCh0aGlzLmljb25zTGF5ZXIpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIuYWRkUmVuZGVyVW5pdCh0aGlzLmxhYmVsc0xheWVyKTtcclxuICAgICAgICB0aGlzLl9kZXN0cm95YWJsZXMucHVzaChhbnRpYWxpYXNpbmdMYXllcik7XHJcbiAgICAgICAgLy8gZm9yY2UgaW5pdGlhbCByZW5kZXJpbmcgKG5vIGRhdGEgeWV0LCBqdXN0IGJhY2tncm91bmQpIGFzIHRoZSBjYW52YXMgKGJsYWNrKSBjYW4gYWxyZWFkeSBiZSB2aXNpYmxlIHRvIHVzZXJzLFxyXG4gICAgICAgIC8vIHJlbmRlcmVyIGlzIGNhbGxlZCBkaXJlY3RseSAod2l0aG91dCBzY2hlZHVsaW5nIHZpYSByZW5kZXIgbG9vcCkgYXMgaXQgaXMgcHJldHR5IG11Y2ggc2FmZSB0byBhc3N1bWVcclxuICAgICAgICAvLyB0aGF0IG5vIHJlbmRlcmluZyBpcyBzY2hlZHVsZWQgZm9yIHRoaXMgZnJhbWUsIGFuZCBkZWZlcnJlZCB1cGRhdGUgY2FuIHBvdGVudGlhbGx5IGNhdXNlIGEgc2luZ2xlIGZyYW1lIGJsaW5rXHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5fcmVuZGVyVGFyZ2V0KTtcclxuICAgIH1cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgLy8gZGVzdHJveSBpbiByZXZlcnNlIG9yZGVyIHRvIHByZXZlbnQgcG90ZW50aWFsIGlzc3VlcyBpZiBkZXN0cm95YWJsZXMgb3duIGVhY2ggb3RoZXJcclxuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5fZGVzdHJveWFibGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3lhYmxlc1tpXS5kZXN0cm95KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBWb2lkRXZlbnRFbWl0dGVyIH0gZnJvbSAnLi91dGlsL2V2ZW50X2VtaXR0ZXInO1xyXG5pbXBvcnQgUmVuZGVyYWJsZURmR2x5cGhBdGxhcyBmcm9tICcuL3JlbmRlci9mb250L3JlbmRlcmFibGVfZGZfZ2x5cGhfYXRsYXMnO1xyXG5pbXBvcnQgRGZGb250UmVnaXN0cnkgZnJvbSAnLi9mb250L2RmX2ZvbnRfcmVnaXN0cnknO1xyXG5pbXBvcnQgUmVuZGVyYWJsZUltYWdlQXRsYXMgZnJvbSAnLi9yZW5kZXIvYmlsbGJvYXJkL3JlbmRlcmFibGVfaW1hZ2VfYXRsYXMnO1xyXG5pbXBvcnQgVmlzaWJpbGl0eU1hbmFnZXIgZnJvbSAnLi92aXNpYmlsaXR5L3Zpc2liaWxpdHlfbWFuYWdlcic7XHJcbmltcG9ydCB7IG1lZGlhbkZpbHRlciB9IGZyb20gJy4vdXRpbC9tZWRpYW5fZmlsdGVyJztcclxuaW1wb3J0IHsgY291bnRGcHMgfSBmcm9tICcuL3V0aWwvc3RhdCc7XHJcbmltcG9ydCBNYWluUmVuZGVyVW5pdCBmcm9tICcuL3JlbmRlci9tYWluX3JlbmRlcl91bml0JztcclxuaW1wb3J0IE1lbW9yeU1hbmFnZXIgZnJvbSAnLi9yZW5kZXIvbWVtb3J5L21hbmFnZXInO1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbmdpbmUge1xyXG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgY2FtZXJhLCByZW5kZXJMb29wKSB7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcclxuICAgICAgICB0aGlzLl9jYW1lcmEgPSBjYW1lcmE7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyVGFyZ2V0ID0gY29udGV4dC5nZXREZWZhdWx0UmVuZGVyVGFyZ2V0KCk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IG5ldyBNYWluUmVuZGVyVW5pdChjb250ZXh0LCBjYW1lcmEpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyTG9vcCA9IHJlbmRlckxvb3A7XHJcbiAgICAgICAgdGhpcy5tZW1vcnlNYW5hZ2VyID0gbmV3IE1lbW9yeU1hbmFnZXIoY29udGV4dCk7XHJcbiAgICAgICAgdGhpcy5fYXRsYXNlcyA9IG5ldyBTZXQoKTtcclxuICAgICAgICB0aGlzLnZpc2liaWxpdHlNYW5hZ2VyID0gbmV3IFZpc2liaWxpdHlNYW5hZ2VyKGNvbnRleHQsIGNhbWVyYSwgcmVuZGVyTG9vcCwgdGhpcy5fcmVuZGVyVGFyZ2V0LmdldFdpZHRoKCksIHRoaXMuX3JlbmRlclRhcmdldC5nZXRIZWlnaHQoKSk7XHJcbiAgICAgICAgdGhpcy52aXNiaWxpdHlUZXh0dXJlUHJvdmlkZXIgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMudmlzaWJpbGl0eU1hbmFnZXIudXBkYXRlVmlzaWJpbGl0eUlmTmVlZGVkKCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZpc2liaWxpdHlNYW5hZ2VyLnZpc2liaWxpdHlUZXh0dXJlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5fZnJhbWVUaW1pbmdzTGlzdGVuZXIgPSB0aGlzLl9vbkZyYW1lVGltZXNGdWxsLmJpbmQodGhpcyk7XHJcbiAgICAgICAgcmVuZGVyTG9vcC5vbkZyYW1lVGltZXNGdWxsLmFkZExpc3RlbmVyKHRoaXMuX2ZyYW1lVGltaW5nc0xpc3RlbmVyKTtcclxuICAgICAgICB0aGlzLl9yZW5kZXJMaXN0ZW5lciA9IHRoaXMuX29uUmVuZGVyLmJpbmQodGhpcyk7XHJcbiAgICAgICAgcmVuZGVyTG9vcC5vblJlbmRlci5hZGRMaXN0ZW5lcih0aGlzLl9yZW5kZXJMaXN0ZW5lcik7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlTGlzdGVuZXIgPSAoKSA9PiB0aGlzLnJlbmRlckxvb3AudXBkYXRlKCk7XHJcbiAgICAgICAgdGhpcy5nbHlwaEF0bGFzID0gbmV3IFJlbmRlcmFibGVEZkdseXBoQXRsYXMoY29udGV4dCk7XHJcbiAgICAgICAgdGhpcy5mb250UmVnaXN0cnkgPSBuZXcgRGZGb250UmVnaXN0cnkoKTtcclxuICAgICAgICB0aGlzLm9uSW50ZXJuYWxFcnJvciA9IG5ldyBWb2lkRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5fY2FtZXJhLm9uVXBkYXRlLmFkZExpc3RlbmVyKHRoaXMuX3VwZGF0ZUxpc3RlbmVyKTtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyLm9uVXBkYXRlLmFkZExpc3RlbmVyKHRoaXMuX3VwZGF0ZUxpc3RlbmVyKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0TG9zdExpc3RlbmVyID0gKCkgPT4gdGhpcy5vbkludGVybmFsRXJyb3IuZmlyZSgpO1xyXG4gICAgICAgIHRoaXMuY29udGV4dC5vbkxvc3MuYWRkTGlzdGVuZXIodGhpcy5fY29udGV4dExvc3RMaXN0ZW5lcik7XHJcbiAgICB9XHJcbiAgICBzZXRSZW5kZXJUYXJnZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICBpZiAodGhpcy5fcmVuZGVyVGFyZ2V0LmdldFdpZHRoKCkgIT09IHdpZHRoIHx8XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlclRhcmdldC5nZXRIZWlnaHQoKSAhPT0gaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlclRhcmdldC5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgICAgICB0aGlzLnZpc2liaWxpdHlNYW5hZ2VyLnNldFRhcmdldFNpemUod2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY3JlYXRlSW1hZ2VBdGxhcyhwYXJhbXMpIHtcclxuICAgICAgICBjb25zdCBhdGxhcyA9IG5ldyBSZW5kZXJhYmxlSW1hZ2VBdGxhcyh0aGlzLmNvbnRleHQsIHBhcmFtcyk7XHJcbiAgICAgICAgYXRsYXMub25Db250ZW50VXBkYXRlLmFkZExpc3RlbmVyKHRoaXMuX3VwZGF0ZUxpc3RlbmVyKTtcclxuICAgICAgICB0aGlzLl9hdGxhc2VzLmFkZChhdGxhcyk7XHJcbiAgICAgICAgcmV0dXJuIGF0bGFzO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlSW1hZ2VBdGxhcyhhdGxhcykge1xyXG4gICAgICAgIGF0bGFzLmRlc3Ryb3koKTtcclxuICAgICAgICBhdGxhcy5vbkNvbnRlbnRVcGRhdGUucmVtb3ZlTGlzdGVuZXIodGhpcy5fdXBkYXRlTGlzdGVuZXIpO1xyXG4gICAgICAgIHRoaXMuX2F0bGFzZXMuZGVsZXRlKGF0bGFzKTtcclxuICAgIH1cclxuICAgIGdldENhbWVyYSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY2FtZXJhO1xyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLl9jYW1lcmEub25VcGRhdGUucmVtb3ZlTGlzdGVuZXIodGhpcy5fdXBkYXRlTGlzdGVuZXIpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIub25VcGRhdGUucmVtb3ZlTGlzdGVuZXIodGhpcy5fdXBkYXRlTGlzdGVuZXIpO1xyXG4gICAgICAgIGZvciAoY29uc3QgYXRsYXMgb2YgdGhpcy5fYXRsYXNlcykge1xyXG4gICAgICAgICAgICBhdGxhcy5vbkNvbnRlbnRVcGRhdGUucmVtb3ZlTGlzdGVuZXIodGhpcy5fdXBkYXRlTGlzdGVuZXIpO1xyXG4gICAgICAgICAgICBhdGxhcy5kZXN0cm95KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZ2x5cGhBdGxhcy5kZXN0cm95KCk7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0Lm9uTG9zcy5yZW1vdmVMaXN0ZW5lcih0aGlzLl9jb250ZXh0TG9zdExpc3RlbmVyKTtcclxuICAgIH1cclxuICAgIF9vblJlbmRlcigpIHtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbmRlcih0aGlzLl9yZW5kZXJUYXJnZXQpO1xyXG4gICAgfVxyXG4gICAgX29uRnJhbWVUaW1lc0Z1bGwodGltZXMpIHtcclxuICAgICAgICBjb3VudEZwcygxZTMgKiB0aW1lcy5sZW5ndGggLyBtZWRpYW5GaWx0ZXIodGltZXMpLnJlZHVjZSgoc3VtLCB0aW1lKSA9PiBzdW0gKyB0aW1lKSk7XHJcbiAgICAgICAgLy8gRm9yIG5vdyB3ZSBhY3F1aXJlIGZyYW1lIHRpbWluZyBhbmQgbG9nIHRoZW0gb25seSBvbmNlIGEgc2Vzc2lvbi5cclxuICAgICAgICB0aGlzLnJlbmRlckxvb3Aub25GcmFtZVRpbWVzRnVsbC5yZW1vdmVMaXN0ZW5lcih0aGlzLl9mcmFtZVRpbWluZ3NMaXN0ZW5lcik7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IERmR2x5cGhBdGxhcyBmcm9tICcuLi8uLi9mb250L2RmX2dseXBoX2F0bGFzJztcclxuLyoqXHJcbiAqIEF0bGFzIHRoYXQgbWFuYWdlcyBhbGxvY2F0aW9uIGluIEdMIHRleHR1cmUuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW5kZXJhYmxlRGZHbHlwaEF0bGFzIGV4dGVuZHMgRGZHbHlwaEF0bGFzIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcclxuICAgICAgICBzdXBlcigwLCAwLCBuZXcgVWludDhBcnJheSgwKSwgbmV3IE1hcCgpKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcclxuICAgICAgICB0aGlzLnRleHR1cmUgPSB0aGlzLl9jcmVhdGVUZXh0dXJlKDAsIDApO1xyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLnRleHR1cmUuZGVzdHJveSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSB3aG9sZSBjb250ZW50IG9mIHRoZSBnbHlwaCBiaXRtYXAgYXRsYXMsIHRleHR1cmUgYWxzbyBnZXQgdXBkYXRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gd2lkdGggbmV3IGJpdG1hcCB3aWR0aFxyXG4gICAgICogQHBhcmFtIGhlaWdodCBuZXcgYml0bWFwIGhlaWdodFxyXG4gICAgICogQHBhcmFtIGRhdGEsIGxlbmd0aCBzaG91bGQgYmUgc3RyaWN0bHkgZXF1YWwgdG8gd2lkdGggKiBoZWlnaHRcclxuICAgICAqL1xyXG4gICAgdXBkYXRlQ29udGVudCh3aWR0aCwgaGVpZ2h0LCBkYXRhLCBnbHlwaExvY2F0aW9ucykge1xyXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgIHRoaXMuX2dseXBoTG9jYXRpb25zID0gZ2x5cGhMb2NhdGlvbnM7XHJcbiAgICAgICAgY29uc3QgdGV4dHVyZSA9IHRoaXMudGV4dHVyZTtcclxuICAgICAgICBpZiAoIXRleHR1cmUgfHwgdGV4dHVyZS5nZXRXaWR0aCgpICE9PSB3aWR0aCB8fCB0ZXh0dXJlLmdldEhlaWdodCgpICE9PSBoZWlnaHQpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudGV4dHVyZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0dXJlLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnRleHR1cmUgPSB0aGlzLl9jcmVhdGVUZXh0dXJlKHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9jb250ZXh0LnNldFRleHR1cmVEYXRhKHRoaXMudGV4dHVyZSwgZGF0YSk7XHJcbiAgICB9XHJcbiAgICBfY3JlYXRlVGV4dHVyZSh3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuY3JlYXRlRW1wdHkyRFRleHR1cmUod2lkdGgsIGhlaWdodCwgNjQwNiAvKiBBTFBIQSAqLywgNTEyMSAvKiBVTlNJR05FRF9CWVRFICovLCB7XHJcbiAgICAgICAgICAgIHdyYXBTOiAzMzA3MSAvKiBDTEFNUF9UT19FREdFICovLFxyXG4gICAgICAgICAgICB3cmFwVDogMzMwNzEgLyogQ0xBTVBfVE9fRURHRSAqLyxcclxuICAgICAgICAgICAgbWFnbmlmaWNhdGlvbkZpbHRlcjogOTcyOSAvKiBMSU5FQVIgKi8sXHJcbiAgICAgICAgICAgIG1pbmlmaWNhdGlvbkZpbHRlcjogOTcyOSAvKiBMSU5FQVIgKi8sXHJcbiAgICAgICAgICAgIHByZW11bHRpcGxpZWRBbHBoYTogZmFsc2VcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG4iLCJjb25zdCBVTktOT1dOX0dMWVBIX0xPQ0FUSU9OID0ge1xyXG4gICAgbWluWDogMCxcclxuICAgIG1heFg6IDAsXHJcbiAgICBtaW5ZOiAwLFxyXG4gICAgbWF4WTogMFxyXG59O1xyXG4vKipcclxuICogQWJzdHJhY3QgZ2x5cGggYXRsYXMgaW50ZXJmYWNlLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGZHbHlwaEF0bGFzIHtcclxuICAgIGNvbnN0cnVjdG9yKHdpZHRoLCBoZWlnaHQsIGRhdGEsIGdseXBoTG9jYXRpb25zKSB7XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgdGhpcy5fZ2x5cGhMb2NhdGlvbnMgPSBnbHlwaExvY2F0aW9ucztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiBHbHlwaCBsb2NhdGlvbiBvciBmYWtlIGxvY2F0aW9uIHBvaW50aW5nIHRvIHRoZSBvcmlnaW4gKDAsIDApLlxyXG4gICAgICovXHJcbiAgICBnZXRHbHlwaExvY2F0aW9uKGZvbnRJZCwgZ2x5cGhJZCkge1xyXG4gICAgICAgIGNvbnN0IGdseXBoTG9jYXRpb24gPSB0aGlzLl9nbHlwaExvY2F0aW9ucy5nZXQoZm9udElkICsgZ2x5cGhJZCk7XHJcbiAgICAgICAgaWYgKGdseXBoTG9jYXRpb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdseXBoTG9jYXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1dvdy13b3ctd293LCBzb21ldGhpbmcgd2VudCB3cm9uZywgeW91IHNob3VsZCBub3QgcmVxdWVzdCBub25leGlzdGVudCBnbHlwaCBsb2NhdGlvbnMnKTtcclxuICAgICAgICAgICAgcmV0dXJuIFVOS05PV05fR0xZUEhfTE9DQVRJT047XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIEFsbCBnbHlwaCBsb2NhdGlvbnMgYXMgW2dseXBoIGlkLCBnbHlwaCBsb2NhdGlvbl0gYXJyYXkuIEdseXBoIGlkIGlzIGZvbnQgaWQgY29uY2F0ZW5hdGVkIHdpdGggZ2x5cGggaWQuXHJcbiAgICAgKi9cclxuICAgIGdldEFsbEdseXBoTG9jYXRpb25zKCkge1xyXG4gICAgICAgIHJldHVybiBbLi4udGhpcy5fZ2x5cGhMb2NhdGlvbnMuZW50cmllcygpXTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgRm9udFJlZ2lzdHJ5IGZyb20gJy4vZm9udF9yZWdpc3RyeSc7XHJcbmltcG9ydCBEZkZvbnQgZnJvbSAnLi9kZl9mb250JztcclxuLyoqXHJcbiAqIFJlZ2lzdHJ5IHRoYXQgc3RvcmVzIGRpc3RhbmNlIGZpZWxkIGZvbnRzLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGZGb250UmVnaXN0cnkgZXh0ZW5kcyBGb250UmVnaXN0cnkge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIobmV3IERmRm9udCgnVU5LTk9XTl9ERl9GT05UJywgMTQsIDApKTtcclxuICAgIH1cclxufVxyXG4iLCIvKipcclxuICogQSBjZW50cmFsIHN0b3JhZ2Ugb2YgYWxsIGF2YWlsYWJsZSBmb250cy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZvbnRSZWdpc3RyeSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB1bmtub3duRm9udEluc3RhbmNlIEFuIGluc3RhbmNlIG9mIHNwZWNpZmljIGZvbnQgdHlwZSB0byBiZSBzZXJ2ZWQgYXMgYSBzdHViIHdoZW4gbm9uZXhpc3RlbnQgZm9udFxyXG4gICAgICogICAgIGlzIHJlcXVlc3RlZC4gUmVxdWVzdGluZyBub25leGlzdGVudCBmb250cyBub3JtYWxseSBzaG91bGQgbm90IGhhcHBlbi5cclxuICAgICAqICAgICBUaGUgc3R1YiBqdXN0IGFsbG93cyB0byBhdm9pZCB0ZWRpb3VzIG51bGwgY2hlY2tzIGluIHJlZ2lzdHJ5IGNsaWVudHMuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHVua25vd25Gb250SW5zdGFuY2UpIHtcclxuICAgICAgICB0aGlzLl9mb250cyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLl91bmtub3duRm9udEluc3RhbmNlID0gdW5rbm93bkZvbnRJbnN0YW5jZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiBJZiBhIGZvbnQgd2l0aCBzcGVjaWZpZWQgaWQgaXMgaW4gdGhlIHJlZ2lzdHJ5LlxyXG4gICAgICovXHJcbiAgICBjb250YWlucyhmb250SWQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZm9udHMuaGFzKGZvbnRJZCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gRm9udCB3aXRoIHNwZWNpZmllZCBpZCBvciB1bmtub3duIGZvbnQgaW5zdGFuY2UgaWYgaXQgaXMgbm90IGZvdW5kLlxyXG4gICAgICovXHJcbiAgICBnZXQoZm9udElkKSB7XHJcbiAgICAgICAgY29uc3QgZm9udCA9IHRoaXMuX2ZvbnRzLmdldChmb250SWQpO1xyXG4gICAgICAgIGlmIChmb250KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmb250O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdXb3ctd293LXdvdywgc29tZXRoaW5nIHdlbnQgd3JvbmcsIHlvdSBzaG91bGQgbm90IHJlcXVlc3Qgbm9uZXhpc3RlbnQgZm9udHMnKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Vua25vd25Gb250SW5zdGFuY2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIEFsbCBzdG9yZWQgZm9udHMuXHJcbiAgICAgKi9cclxuICAgIGdldEFsbCgpIHtcclxuICAgICAgICByZXR1cm4gWy4uLnRoaXMuX2ZvbnRzLnZhbHVlcygpXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBuZXcgZm9yIHRvIHRoZSByZWdpc3RyeS5cclxuICAgICAqL1xyXG4gICAgYWRkKGZvbnQpIHtcclxuICAgICAgICB0aGlzLl9mb250cy5zZXQoZm9udC5pZCwgZm9udCk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IEltYWdlQXRsYXMgZnJvbSAnLi4vLi4vYmlsbGJvYXJkL2ltYWdlX2F0bGFzJztcclxuLyoqXHJcbiAqIEF0bGFzIHRoYXQgbWFuYWdlcyBhbGxvY2F0aW9uIGluIEdMIHRleHR1cmUuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW5kZXJhYmxlSW1hZ2VBdGxhcyBleHRlbmRzIEltYWdlQXRsYXMge1xyXG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgcGFyYW1zKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICBjb25zdCB7IGZpbHRlciwgcHJlbXVsdGlwbGllZEFscGhhIH0gPSBwYXJhbXM7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XHJcbiAgICAgICAgdGhpcy5fZmlsdGVyID0gZmlsdGVyO1xyXG4gICAgICAgIHRoaXMuX3ByZW11bHRpcGxpZWRBbHBoYSA9IHByZW11bHRpcGxpZWRBbHBoYTtcclxuICAgICAgICB0aGlzLnRleHR1cmUgPSB0aGlzLl9jcmVhdGVUZXh0dXJlKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCBmaWx0ZXIsIHByZW11bHRpcGxpZWRBbHBoYSk7XHJcbiAgICAgICAgdGhpcy5pc0RpcnR5ID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgR0wgdGV4dHVyZSB3aXRoIGNoYW5nZWQgZGF0YS4gU2hvdWxkIGJlIGNhbGxlZCBhZnRlciBlYWNoIGltYWdlIGFkZGVkIHRvIHRha2UgZWZmZWN0IGluIHNoYWRlcnMuXHJcbiAgICAgKi9cclxuICAgIHN5bmNUZXh0dXJlKCkge1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuc2V0VGV4dHVyZURhdGFGcm9tRG9tRWxlbWVudCh0aGlzLnRleHR1cmUsIHRoaXMuY2FudmFzKTtcclxuICAgICAgICB0aGlzLmlzRGlydHkgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIHVwZGF0ZUltYWdlKGxvY2F0aW9uLCBzb3VyY2VJbWFnZSwgbG9jYXRpb25SZWdpb24sIHNvdXJjZUltYWdlUmVnaW9uKSB7XHJcbiAgICAgICAgc3VwZXIudXBkYXRlSW1hZ2UobG9jYXRpb24sIHNvdXJjZUltYWdlLCBsb2NhdGlvblJlZ2lvbiwgc291cmNlSW1hZ2VSZWdpb24pO1xyXG4gICAgICAgIHRoaXMuaXNEaXJ0eSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMudGV4dHVyZS5kZXN0cm95KCk7XHJcbiAgICB9XHJcbiAgICBfZXhwYW5kKG5ld1dpZHRoLCBuZXdIZWlnaHQpIHtcclxuICAgICAgICBzdXBlci5fZXhwYW5kKG5ld1dpZHRoLCBuZXdIZWlnaHQpO1xyXG4gICAgICAgIHRoaXMudGV4dHVyZS5kZXN0cm95KCk7XHJcbiAgICAgICAgdGhpcy50ZXh0dXJlID0gdGhpcy5fY3JlYXRlVGV4dHVyZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcy5fZmlsdGVyLCB0aGlzLl9wcmVtdWx0aXBsaWVkQWxwaGEpO1xyXG4gICAgICAgIHRoaXMuaXNEaXJ0eSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBfY3JlYXRlVGV4dHVyZSh3aWR0aCwgaGVpZ2h0LCBmaWx0ZXIsIHByZW11bHRpcGxpZWRBbHBoYSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0LmNyZWF0ZUVtcHR5MkRUZXh0dXJlKHdpZHRoLCBoZWlnaHQsIDY0MDggLyogUkdCQSAqLywgNTEyMSAvKiBVTlNJR05FRF9CWVRFICovLCB7XHJcbiAgICAgICAgICAgIG1pbmlmaWNhdGlvbkZpbHRlcjogZmlsdGVyLFxyXG4gICAgICAgICAgICBtYWduaWZpY2F0aW9uRmlsdGVyOiBmaWx0ZXIsXHJcbiAgICAgICAgICAgIHdyYXBTOiAzMzA3MSAvKiBDTEFNUF9UT19FREdFICovLFxyXG4gICAgICAgICAgICB3cmFwVDogMzMwNzEgLyogQ0xBTVBfVE9fRURHRSAqLyxcclxuICAgICAgICAgICAgcHJlbXVsdGlwbGllZEFscGhhXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgY3JlYXRlQkJveDIgfSBmcm9tICcuLi9tYXRoL3ZlY3RvcjInO1xyXG5pbXBvcnQgeyBTaGVsZkFsbG9jYXRvcjJEIH0gZnJvbSAnLi4vdXRpbC9hbGxvY2F0b3JfMmQnO1xyXG5pbXBvcnQgeyBWb2lkRXZlbnRFbWl0dGVyIH0gZnJvbSAnLi4vdXRpbC9ldmVudF9lbWl0dGVyJztcclxuY29uc3QgSU5JVF9BVExBU19XSURUSCA9IDI1NjtcclxuY29uc3QgSU5JVF9BVExBU19IRUlHSFQgPSAyNTY7XHJcbmNvbnN0IE1BWF9BVExBU19XSURUSCA9IDIwNDg7XHJcbmNvbnN0IE1BWF9BVExBU19IRUlHSFQgPSAyMDQ4O1xyXG5jb25zdCBFWFBBTkRfRkFDVE9SID0gMjtcclxuLyoqXHJcbiAqIE1hbmFnZXMgYWxsb2NhdGlvbiBvZiBpbWFnZXMuIEl0IHJlc2l6ZXMgaXRzZWxmICh1cCB0byBhIGZpeGVkIGxpbWl0KSB3aGVuIHRoZXJlIGlzIG5vIHJlZ2lvblxyXG4gKiBvZiBlbm91Z2ggc2l6ZSBmb3IgdGhlIG5leHQgaW1hZ2UuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbWFnZUF0bGFzIHtcclxuICAgIGNvbnN0cnVjdG9yKGluaXRBdGxhc1dpZHRoID0gSU5JVF9BVExBU19XSURUSCwgaW5pdEF0bGFzSGVpZ2h0ID0gSU5JVF9BVExBU19IRUlHSFQpIHtcclxuICAgICAgICB0aGlzLm9uQ29udGVudFVwZGF0ZSA9IG5ldyBWb2lkRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IGluaXRBdGxhc1dpZHRoO1xyXG4gICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IGluaXRBdGxhc0hlaWdodDtcclxuICAgICAgICB0aGlzLl9jYW52YXNDb250ZXh0ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgICAgICB0aGlzLl9hbGxvY2F0b3IgPSBuZXcgU2hlbGZBbGxvY2F0b3IyRCh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcbiAgICB9XHJcbiAgICBnZXQgd2lkdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzLndpZHRoO1xyXG4gICAgfVxyXG4gICAgZ2V0IGhlaWdodCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jYW52YXMuaGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBbGxvY2F0ZXMgaW1hZ2UgYml0bWFwLlxyXG4gICAgICovXHJcbiAgICBhbGxvY2F0ZUltYWdlKGRlc2NyaXB0b3IsIGltYWdlKSB7XHJcbiAgICAgICAgY29uc3QgbG9jYXRpb24gPSB0aGlzLl9hbGxvY2F0ZShkZXNjcmlwdG9yKTtcclxuICAgICAgICBpZiAobG9jYXRpb24pIHtcclxuICAgICAgICAgICAgY29uc3QgcmVnaW9uID0gY3JlYXRlQkJveDIoMCwgZGVzY3JpcHRvci53aWR0aCwgMCwgZGVzY3JpcHRvci5oZWlnaHQpO1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUltYWdlKGxvY2F0aW9uLCBpbWFnZSwgcmVnaW9uLCByZWdpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbG9jYXRpb247XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlc2VydmVzIHNwYWNlIG9mIGFwcHJvcHJpYXRlIHNpemUgdGhhdCBjYW4gYmUgdXBkYXRlZCBsYXRlciB3aXRoIHVwZGF0ZUltYWdlKCkgbWV0aG9kLlxyXG4gICAgICovXHJcbiAgICByZXNlcnZlTG9jYXRpb24oZGVzY3JpcHRvcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hbGxvY2F0ZShkZXNjcmlwdG9yKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyBpbWFnZSBjb250ZW50IGluIGFwcHJvcHJpYXRlIGxvY2F0aW9uLiBBc3N1bWVzIHRoYXQgdGhlcmUgaXMgcmVhbGx5IHN1Y2ggbG9jYXRpb24gcmVzZXJ2ZWQsXHJcbiAgICAgKiBubyBjaGVjayBmb3IgdGhpcyBpcyBkb25lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsb2NhdGlvbiBMb2NhdGlvbiBpbiBhdGxhcyBvZiB0aGUgaW1hZ2UuXHJcbiAgICAgKiBAcGFyYW0gc291cmNlSW1hZ2UgSW1hZ2UgdG8gdXBkYXRlIGF0bGFzIGZyb20uXHJcbiAgICAgKiBAcGFyYW0gbG9jYXRpb25SZWdpb24gUmVnaW9uIChiYm94IHdpdGggY29vcmRpbmF0ZXMgcmVsYXRpdmUgdG8gdGhlIGxvY2F0aW9uJ3MgYmJveCkgb2YgdGhlIGxvY2F0aW9uIHRvIHVwZGF0ZS5cclxuICAgICAqIEBwYXJhbSBzb3VyY2VJbWFnZVJlZ2lvbiBSZWdpb24gb2YgdGhlIGltYWdlIChCQm94MiBpbiBpbWFnZSdzIGNvb3JkaW5hdGUgc3BhY2UpIHRvIGJlIGNvcGllZCBpbnRvIGF0bGFzLlxyXG4gICAgICovXHJcbiAgICB1cGRhdGVJbWFnZShsb2NhdGlvbiwgc291cmNlSW1hZ2UsIGxvY2F0aW9uUmVnaW9uID0gY3JlYXRlQkJveDIoMCwgbG9jYXRpb24ubWF4WCAtIGxvY2F0aW9uLm1pblgsIDAsIGxvY2F0aW9uLm1heFkgLSBsb2NhdGlvbi5taW5ZKSwgc291cmNlSW1hZ2VSZWdpb24gPSBjcmVhdGVCQm94MigwLCBzb3VyY2VJbWFnZS53aWR0aCwgMCwgc291cmNlSW1hZ2UuaGVpZ2h0KSkge1xyXG4gICAgICAgIGNvbnN0IHNyY1ggPSBzb3VyY2VJbWFnZVJlZ2lvbi5taW5YO1xyXG4gICAgICAgIGNvbnN0IHNyY1kgPSBzb3VyY2VJbWFnZVJlZ2lvbi5taW5ZO1xyXG4gICAgICAgIGNvbnN0IHNyY1cgPSBzb3VyY2VJbWFnZVJlZ2lvbi5tYXhYIC0gc291cmNlSW1hZ2VSZWdpb24ubWluWDtcclxuICAgICAgICBjb25zdCBzcmNIID0gc291cmNlSW1hZ2VSZWdpb24ubWF4WSAtIHNvdXJjZUltYWdlUmVnaW9uLm1pblk7XHJcbiAgICAgICAgY29uc3QgZHN0WCA9IGxvY2F0aW9uLm1pblggKyBsb2NhdGlvblJlZ2lvbi5taW5YO1xyXG4gICAgICAgIGNvbnN0IGRzdFkgPSBsb2NhdGlvbi5taW5ZICsgbG9jYXRpb25SZWdpb24ubWluWTtcclxuICAgICAgICBjb25zdCBkc3RXID0gbG9jYXRpb25SZWdpb24ubWF4WCAtIGxvY2F0aW9uUmVnaW9uLm1pblg7XHJcbiAgICAgICAgY29uc3QgZHN0SCA9IGxvY2F0aW9uUmVnaW9uLm1heFkgLSBsb2NhdGlvblJlZ2lvbi5taW5ZO1xyXG4gICAgICAgIHRoaXMuX2NhbnZhc0NvbnRleHQuY2xlYXJSZWN0KGRzdFgsIGRzdFksIGRzdFcsIGRzdEgpO1xyXG4gICAgICAgIHRoaXMuX2NhbnZhc0NvbnRleHQuZHJhd0ltYWdlKHNvdXJjZUltYWdlLCBzcmNYLCBzcmNZLCBzcmNXLCBzcmNILCBkc3RYLCBkc3RZLCBkc3RXLCBkc3RIKTtcclxuICAgICAgICB0aGlzLm9uQ29udGVudFVwZGF0ZS5maXJlKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERlYWxsb2NhdGVzIGltYWdlIGZyb20gdGhlIGF0bGFzLlxyXG4gICAgICovXHJcbiAgICByZW1vdmVJbWFnZShpbWFnZSkge1xyXG4gICAgICAgIHRoaXMuX2FsbG9jYXRvci5kZWFsbG9jYXRlKGltYWdlKTtcclxuICAgIH1cclxuICAgIF9hbGxvY2F0ZShkZXNjcmlwdG9yKSB7XHJcbiAgICAgICAgbGV0IGxvY2F0aW9uID0gdGhpcy5fYWxsb2NhdG9yLmFsbG9jYXRlKGRlc2NyaXB0b3IpO1xyXG4gICAgICAgIC8vIGluY3JlbWVudGFsIGV4cGFuZCBjYW4gYmUgaW5lZmZpY2llbnQgaWYgdHdvIG9yIG1vcmUgaXRlcmF0aW9ucyBhcmUgbmVlZGVkIHRvIGFsbG9jYXRlIGFuIGltYWdlLFxyXG4gICAgICAgIC8vIGJ1dCBpdCBpcyBleHBlY3RlZCB0byBiZSBhIHJhcmUgKGlmIGFueSkgY2FzZSwgcmV3b3JrIGlmIGl0IHR1cm5zIG91dCB0byBiZSB3cm9uZ1xyXG4gICAgICAgIHdoaWxlICghbG9jYXRpb24pIHtcclxuICAgICAgICAgICAgY29uc3QgZXhwYW5kZWRXaWR0aCA9IHRoaXMud2lkdGggKiBFWFBBTkRfRkFDVE9SO1xyXG4gICAgICAgICAgICBjb25zdCBleHBhbmRlZEhlaWdodCA9IHRoaXMuaGVpZ2h0ICogRVhQQU5EX0ZBQ1RPUjtcclxuICAgICAgICAgICAgaWYgKGV4cGFuZGVkV2lkdGggPD0gTUFYX0FUTEFTX1dJRFRIICYmIGV4cGFuZGVkSGVpZ2h0IDw9IE1BWF9BVExBU19IRUlHSFQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2V4cGFuZChleHBhbmRlZFdpZHRoLCBleHBhbmRlZEhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICBsb2NhdGlvbiA9IHRoaXMuX2FsbG9jYXRvci5hbGxvY2F0ZShkZXNjcmlwdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBsb2NhdGlvbjtcclxuICAgIH1cclxuICAgIF9leHBhbmQobmV3V2lkdGgsIG5ld0hlaWdodCkge1xyXG4gICAgICAgIHRoaXMuX2FsbG9jYXRvci5yZXNpemUobmV3V2lkdGgsIG5ld0hlaWdodCk7XHJcbiAgICAgICAgLy8gc2V0dGluZyBuZXcgd2lkdGgvaGVpZ2h0IHRvIGNhbnZhcyB3aWxsIGNsZWFyIGl0LFxyXG4gICAgICAgIC8vIHNvIGN1cnJlbnQgZGF0YSBpcyBzYXZlZCB0byBiZSByZXN0b3JlZCBpbW1lZGlhdGVseSBhZnRlciByZXNpemluZ1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9jYW52YXNDb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5jYW52YXMud2lkdGggPSBuZXdXaWR0aDtcclxuICAgICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSBuZXdIZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5fY2FudmFzQ29udGV4dC5wdXRJbWFnZURhdGEoZGF0YSwgMCwgMCk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgQXJlbmFBbGxvY2F0b3IsIEZyZWVMaXN0QWxsb2NhdG9yIH0gZnJvbSAnLi9hbGxvY2F0b3InO1xyXG4vKipcclxuICogQSByZWN0YW5ndWxhciByZWdpb24gd2l0aCBmaXhlZCBoZWlnaHQuIFV0aWxpdHkgY2xhc3MgZm9yIHNoZWxmIGFsbG9jYXRpb24gZGVmaW5lZCBiZWxvdy5cclxuICovXHJcbmNsYXNzIFNoZWxmIHtcclxuICAgIGNvbnN0cnVjdG9yKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5fYWxsb2NhdG9yID0gbmV3IEZyZWVMaXN0QWxsb2NhdG9yKHRoaXMud2lkdGgpO1xyXG4gICAgfVxyXG4gICAgYWxsb2NhdGUod2lkdGgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWxsb2NhdG9yLmFsbG9jYXRlKHdpZHRoKTtcclxuICAgIH1cclxuICAgIGRlYWxsb2NhdGUob2Zmc2V0KSB7XHJcbiAgICAgICAgdGhpcy5fYWxsb2NhdG9yLmRlYWxsb2NhdGUob2Zmc2V0KTtcclxuICAgIH1cclxuICAgIGlzQWxsb2NhdGVkKG9mZnNldCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hbGxvY2F0b3IuaXNBbGxvY2F0ZWQob2Zmc2V0KTtcclxuICAgIH1cclxuICAgIGNhbkFsbG9jYXRlKHdpZHRoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FsbG9jYXRvci5tYXhBbGxvY2FibGVTaXplID49IHdpZHRoO1xyXG4gICAgfVxyXG4gICAgcmVzaXplKHdpZHRoKSB7XHJcbiAgICAgICAgdGhpcy5fYWxsb2NhdG9yLmV4dGVuZCh3aWR0aCk7XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBbGxvY2F0ZXMgcmVjdGFuZ2xlcyBpbiBcInNoZWx2ZXNcIiAoaGVpZ2h0IGZpeGVkIHJlZ2lvbnMpLiBUaGV5IGFyZSBjcmVhdGVkIG9mIG5lY2Vzc2l0eSB3aGVuIHRoZSBuZXh0IG9iamVjdCBkb2VzbnRcclxuICogZml0IGFueSBleGlzdGluZyBzaGVsZi4gVG8gb3B0aW1pemUgc3BhY2UgdXNhZ2UgaXQgdHJpZXMgdG8gZmluZCB0aGUgYmVzdCBzaGVsZiBmb3IgYWxsb2NhdGlvbiAobWluIGhlaWdodCBkaWZmKS5cclxuICogQSBzaGVsZiB3aGVuIGFsbG9jYXRlZCBpcyBuZXZlciBkZWFsbG9jYXRlZCBiYWNrIGFuZCBleGlzdHMgZHVyaW5nIGFsbCB0aGUgYWxsb2NhdG9yIGxpZmV0aW1lLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFNoZWxmQWxsb2NhdG9yMkQge1xyXG4gICAgY29uc3RydWN0b3Iod2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICB0aGlzLl9zaGVsdmVzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuX3NoZWxmQWxsb2NhdG9yID0gbmV3IEFyZW5hQWxsb2NhdG9yKGhlaWdodCk7IC8vIG5vIHNoZWxmIGRlYWxsb2NhdGlvbiwgdGhhdCBpcyB3aHkgQXJlbmFBbGxvY2F0b3IgaXMgZmluZVxyXG4gICAgfVxyXG4gICAgYWxsb2NhdGUob2JqZWN0KSB7XHJcbiAgICAgICAgbGV0IGJlc3RTaGVsZjtcclxuICAgICAgICBsZXQgYmVzdFNoZWxmT2Zmc2V0ID0gLTE7XHJcbiAgICAgICAgbGV0IGJlc3RTaGVsZlJhdGlvID0gLTE7XHJcbiAgICAgICAgZm9yIChjb25zdCBbb2Zmc2V0LCBzaGVsZl0gb2YgdGhpcy5fc2hlbHZlcy5lbnRyaWVzKCkpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2hlbGZSYXRpbyA9IG9iamVjdC5oZWlnaHQgLyBzaGVsZi5oZWlnaHQ7XHJcbiAgICAgICAgICAgIGlmIChzaGVsZlJhdGlvID09PSAxICYmIHNoZWxmLmNhbkFsbG9jYXRlKG9iamVjdC53aWR0aCkpIHtcclxuICAgICAgICAgICAgICAgIGJlc3RTaGVsZiA9IHNoZWxmO1xyXG4gICAgICAgICAgICAgICAgYmVzdFNoZWxmT2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc2hlbGZSYXRpbyA8IDEgJiYgc2hlbGZSYXRpbyA+IGJlc3RTaGVsZlJhdGlvICYmIHNoZWxmLmNhbkFsbG9jYXRlKG9iamVjdC53aWR0aCkpIHtcclxuICAgICAgICAgICAgICAgIGJlc3RTaGVsZiA9IHNoZWxmO1xyXG4gICAgICAgICAgICAgICAgYmVzdFNoZWxmT2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgYmVzdFNoZWxmUmF0aW8gPSBzaGVsZlJhdGlvO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghYmVzdFNoZWxmICYmIHRoaXMuX3NoZWxmQWxsb2NhdG9yLm1heEFsbG9jYWJsZVNpemUgPj0gb2JqZWN0LmhlaWdodCAmJiB0aGlzLndpZHRoID49IG9iamVjdC53aWR0aCkge1xyXG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLl9zaGVsZkFsbG9jYXRvci5hbGxvY2F0ZShvYmplY3QuaGVpZ2h0KTtcclxuICAgICAgICAgICAgYmVzdFNoZWxmID0gbmV3IFNoZWxmKHRoaXMud2lkdGgsIG9iamVjdC5oZWlnaHQpO1xyXG4gICAgICAgICAgICBiZXN0U2hlbGZPZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgIHRoaXMuX3NoZWx2ZXMuc2V0KG9mZnNldCwgYmVzdFNoZWxmKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGJlc3RTaGVsZikge1xyXG4gICAgICAgICAgICBjb25zdCBsZWZ0ID0gYmVzdFNoZWxmLmFsbG9jYXRlKG9iamVjdC53aWR0aCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRvcCA9IGJlc3RTaGVsZk9mZnNldDtcclxuICAgICAgICAgICAgY29uc3QgbG9jYXRpb24gPSB7XHJcbiAgICAgICAgICAgICAgICBtaW5YOiBsZWZ0LFxyXG4gICAgICAgICAgICAgICAgbWF4WDogbGVmdCArIG9iamVjdC53aWR0aCxcclxuICAgICAgICAgICAgICAgIG1pblk6IHRvcCxcclxuICAgICAgICAgICAgICAgIG1heFk6IHRvcCArIG9iamVjdC5oZWlnaHRcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIGxvY2F0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZGVhbGxvY2F0ZShvYmplY3RMb2NhdGlvbikge1xyXG4gICAgICAgIGNvbnN0IHNoZWxmID0gdGhpcy5fc2hlbHZlcy5nZXQob2JqZWN0TG9jYXRpb24ubWluWSk7XHJcbiAgICAgICAgaWYgKHNoZWxmKSB7XHJcbiAgICAgICAgICAgIHNoZWxmLmRlYWxsb2NhdGUob2JqZWN0TG9jYXRpb24ubWluWCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaXNBbGxvY2F0ZWQob2JqZWN0TG9jYXRpb24pIHtcclxuICAgICAgICBjb25zdCBzaGVsZiA9IHRoaXMuX3NoZWx2ZXMuZ2V0KG9iamVjdExvY2F0aW9uLm1pblkpO1xyXG4gICAgICAgIHJldHVybiAhIXNoZWxmICYmIHNoZWxmLmlzQWxsb2NhdGVkKG9iamVjdExvY2F0aW9uLm1pblgpO1xyXG4gICAgfVxyXG4gICAgcmVzaXplKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICB0aGlzLl9zaGVsZkFsbG9jYXRvci5leHRlbmQoaGVpZ2h0KTtcclxuICAgICAgICBmb3IgKGNvbnN0IHNoZWxmIG9mIHRoaXMuX3NoZWx2ZXMudmFsdWVzKCkpIHtcclxuICAgICAgICAgICAgc2hlbGYucmVzaXplKHdpZHRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IEJpbmFyeVNlYXJjaFRyZWUgfSBmcm9tICcuL2JpbmFyeV90cmVlJztcclxuaW1wb3J0IExpbmtlZFNldCBmcm9tICcuL2xpbmtlZF9zZXQnO1xyXG4vKipcclxuICogQWxpZ25lcyBhbiBvZmZzZXQgc28gaXQncyBhIG11bHRpcGxlIG9mIGFuIGFsaWdubWVudC5cclxuICpcclxuICogQHBhcmFtIG9mZnNldCBUaGUgb2Zmc2V0LlxyXG4gKiBAcGFyYW0gYWxpZ25tZW50IFRoZSBhbGlnbm1lbnQuXHJcbiAqIEByZXR1cm5zIEFsaWduZWQgb2Zmc2V0LlxyXG4gKi9cclxuZnVuY3Rpb24gYWxpZ24ob2Zmc2V0LCBhbGlnbm1lbnQpIHtcclxuICAgIHJldHVybiBhbGlnbm1lbnQgKiBNYXRoLmNlaWwob2Zmc2V0IC8gYWxpZ25tZW50KTtcclxufVxyXG5leHBvcnQgY2xhc3MgQXJlbmFBbGxvY2F0b3Ige1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGVtcHR5IGFyZW5hIGFsbG9jYXRvci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc2l6ZSBTaXplIG9mIG1hbmFnZWQgcmVnaW9uLlxyXG4gICAgICogQHBhcmFtIGFsaWdubWVudCBhbGlnbm1lbnQgb2Ygb2Zmc2V0cy5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3Ioc2l6ZSwgYWxpZ25tZW50ID0gMSkge1xyXG4gICAgICAgIHRoaXMuX3NpemUgPSBzaXplO1xyXG4gICAgICAgIHRoaXMuX2FsaWdubWVudCA9IGFsaWdubWVudDtcclxuICAgICAgICB0aGlzLl9mcmVlT2Zmc2V0ID0gMDtcclxuICAgICAgICB0aGlzLl9hbGxvY2F0ZWRPZmZzZXRzID0gbmV3IFNldCgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHNpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpemU7XHJcbiAgICB9XHJcbiAgICBnZXQgbWF4QWxsb2NhYmxlU2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZSAtIHRoaXMuX2ZyZWVPZmZzZXQ7XHJcbiAgICB9XHJcbiAgICBnZXQgaXNFbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWxsb2NhdGVkT2Zmc2V0cy5zaXplID09PSAwO1xyXG4gICAgfVxyXG4gICAgYWxsb2NhdGUoc2l6ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9zaXplID49IHRoaXMuX2ZyZWVPZmZzZXQgKyBzaXplKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuX2ZyZWVPZmZzZXQ7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZyZWVPZmZzZXQgPSBhbGlnbihvZmZzZXQgKyBzaXplLCB0aGlzLl9hbGlnbm1lbnQpO1xyXG4gICAgICAgICAgICB0aGlzLl9hbGxvY2F0ZWRPZmZzZXRzLmFkZChvZmZzZXQpO1xyXG4gICAgICAgICAgICByZXR1cm4gb2Zmc2V0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGRlYWxsb2NhdGUob2Zmc2V0KSB7XHJcbiAgICAgICAgdGhpcy5fYWxsb2NhdGVkT2Zmc2V0cy5kZWxldGUob2Zmc2V0KTtcclxuICAgIH1cclxuICAgIGlzQWxsb2NhdGVkKG9mZnNldCkge1xyXG4gICAgICAgIHJldHVybiBvZmZzZXQgPCB0aGlzLl9mcmVlT2Zmc2V0O1xyXG4gICAgfVxyXG4gICAgZXh0ZW5kKG5ld1NpemUpIHtcclxuICAgICAgICBpZiAobmV3U2l6ZSA8IHRoaXMuX2ZyZWVPZmZzZXQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgcmVkdWNlIHRoZSBzaXplIGJlY2F1c2UgaXQgY29uZmxpY3RzIHdpdGggYWxyZWFkeSBhbGxvY2F0ZWQgcmVnaW9uLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9zaXplID0gbmV3U2l6ZTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQWxsb2NhdG9yIG9wdGltaXNlZCBmb3IgYm90aCBwcmltYXJ5IG9wZXJhdGlvbnM6IGFsbG9jYXRpb24gYW5kIGRlYWxsb2NhdGlvbi4gSXQgdXNlcyBCU1QgZm9yIGVmZmljaWVudCBsb29rdXAgb2ZcclxuICogc3VpdGFibGUgZnJlZSByZWdpb24gZHVyaW5nIGFsbG9jYXRpb24gYW5kIHR3byB3YXkgbGlua2VkIGxpc3QgZm9yIGZhc3QgYWRqYWNlbnQgZnJlZSByZWdpb25zIG1lcmdlLlxyXG4gKiBNYXggYWxsb2NhYmxlIHNpemUgaXMgYWxzbyBkZXRlcm1pbmVkIGJ5IG1lYW5zIG9mIHRoZSBCU1QuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgRnJlZUxpc3RBbGxvY2F0b3Ige1xyXG4gICAgY29uc3RydWN0b3Ioc2l6ZSkge1xyXG4gICAgICAgIHRoaXMuX3NpemUgPSBzaXplO1xyXG4gICAgICAgIHRoaXMuX2FsbFJlZ2lvbnMgPSBuZXcgTGlua2VkU2V0KCk7XHJcbiAgICAgICAgdGhpcy5fb2NjdXBpZWRSZWdpb25zID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuX2ZyZWVSZWdpb25zID0gbmV3IEJpbmFyeVNlYXJjaFRyZWUoKHJhbmdlQSwgcmFuZ2VCKSA9PiByYW5nZUEuc2l6ZSAtIHJhbmdlQi5zaXplKTtcclxuICAgICAgICBjb25zdCBpbml0UmVnaW9uID0geyBvZmZzZXQ6IDAsIHNpemUgfTtcclxuICAgICAgICB0aGlzLl9hbGxSZWdpb25zLmluc2VydChpbml0UmVnaW9uKTtcclxuICAgICAgICBpbml0UmVnaW9uLl9mcmVlTm9kZSA9IHRoaXMuX2ZyZWVSZWdpb25zLmluc2VydChpbml0UmVnaW9uKTtcclxuICAgIH1cclxuICAgIGdldCBzaXplKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zaXplO1xyXG4gICAgfVxyXG4gICAgZ2V0IG1heEFsbG9jYWJsZVNpemUoKSB7XHJcbiAgICAgICAgY29uc3QgbWF4ID0gdGhpcy5fZnJlZVJlZ2lvbnMubWF4O1xyXG4gICAgICAgIHJldHVybiBtYXggPyBtYXguc2l6ZSA6IDA7XHJcbiAgICB9XHJcbiAgICBnZXQgaXNFbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fb2NjdXBpZWRSZWdpb25zLnNpemUgPT09IDA7XHJcbiAgICB9XHJcbiAgICBhbGxvY2F0ZShzaXplKSB7XHJcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuX2ZpbmRNaW5TdWl0YWJsZShzaXplKTtcclxuICAgICAgICBpZiAoIW5vZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByYW5nZSA9IG5vZGUudmFsdWU7XHJcbiAgICAgICAgLy8gY3VycmVudCByZWdpb24gaXMgbm90IGF2YWlsYWJsZSBhbnltb3JlXHJcbiAgICAgICAgLy8gaXQgaXMgcmVtb3ZlZCBmcm9tIHRoZSBmcmVlIHJlZ2lvbnMgcG9vbFxyXG4gICAgICAgIHRoaXMuX2ZyZWVSZWdpb25zLnJlbW92ZShub2RlKTtcclxuICAgICAgICAvLyBuZXcgb2NjdXBpZWQgb25lIGlzIGNyZWF0ZWRcclxuICAgICAgICBjb25zdCBvY2N1cGllZFJhbmdlID0geyBvZmZzZXQ6IHJhbmdlLm9mZnNldCwgc2l6ZSB9O1xyXG4gICAgICAgIHRoaXMuX29jY3VwaWVkUmVnaW9ucy5zZXQocmFuZ2Uub2Zmc2V0LCBvY2N1cGllZFJhbmdlKTtcclxuICAgICAgICB0aGlzLl9hbGxSZWdpb25zLmluc2VydEFmdGVyKHJhbmdlLCBvY2N1cGllZFJhbmdlKTtcclxuICAgICAgICB0aGlzLl9hbGxSZWdpb25zLnJlbW92ZShyYW5nZSk7XHJcbiAgICAgICAgLy8gZG9udCBsb29zZSByZW1haW5pbmcgaWYgYW55XHJcbiAgICAgICAgLy8gaXQgc2hvdWxkIGJlIHJldHVybmVkIGJhY2sgdG8gdGhlIGZyZWUgcmVnaW9ucyBwb29sXHJcbiAgICAgICAgaWYgKHJhbmdlLnNpemUgPiBzaXplKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlbWFpbmluZ1JhbmdlID0geyBvZmZzZXQ6IHJhbmdlLm9mZnNldCArIHNpemUsIHNpemU6IHJhbmdlLnNpemUgLSBzaXplIH07XHJcbiAgICAgICAgICAgIHJlbWFpbmluZ1JhbmdlLl9mcmVlTm9kZSA9IHRoaXMuX2ZyZWVSZWdpb25zLmluc2VydChyZW1haW5pbmdSYW5nZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2FsbFJlZ2lvbnMuaW5zZXJ0QWZ0ZXIob2NjdXBpZWRSYW5nZSwgcmVtYWluaW5nUmFuZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb2NjdXBpZWRSYW5nZS5vZmZzZXQ7XHJcbiAgICB9XHJcbiAgICBkZWFsbG9jYXRlKG9mZnNldCkge1xyXG4gICAgICAgIGxldCByZWdpb24gPSB0aGlzLl9vY2N1cGllZFJlZ2lvbnMuZ2V0KG9mZnNldCk7XHJcbiAgICAgICAgaWYgKHJlZ2lvbikge1xyXG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgcmVnaW9uIGNhbiBiZSBtZXJnZWQgd2l0aCBpdHMgcHJldmlvdXMgbmVpZ2hib3JcclxuICAgICAgICAgICAgY29uc3QgcHJldiA9IHRoaXMuX2FsbFJlZ2lvbnMuZ2V0UHJldihyZWdpb24pO1xyXG4gICAgICAgICAgICBpZiAocHJldiAmJiBwcmV2Ll9mcmVlTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZW1icmFjaW5nUmFuZ2UgPSB7IG9mZnNldDogcHJldi5vZmZzZXQsIHNpemU6IHByZXYuc2l6ZSArIHJlZ2lvbi5zaXplIH07XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hbGxSZWdpb25zLmluc2VydEFmdGVyKHByZXYsIGVtYnJhY2luZ1JhbmdlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FsbFJlZ2lvbnMucmVtb3ZlKHJlZ2lvbik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hbGxSZWdpb25zLnJlbW92ZShwcmV2KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ZyZWVSZWdpb25zLnJlbW92ZShwcmV2Ll9mcmVlTm9kZSk7XHJcbiAgICAgICAgICAgICAgICByZWdpb24gPSBlbWJyYWNpbmdSYW5nZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgcmVnaW9uIGNhbiBiZSBtZXJnZWQgd2l0aCBpdHMgbmV4dCBuZWlnaGJvclxyXG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gdGhpcy5fYWxsUmVnaW9ucy5nZXROZXh0KHJlZ2lvbik7XHJcbiAgICAgICAgICAgIGlmIChuZXh0ICYmIG5leHQuX2ZyZWVOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbWJyYWNpbmdSYW5nZSA9IHsgb2Zmc2V0OiByZWdpb24ub2Zmc2V0LCBzaXplOiByZWdpb24uc2l6ZSArIG5leHQuc2l6ZSB9O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWxsUmVnaW9ucy5pbnNlcnRCZWZvcmUobmV4dCwgZW1icmFjaW5nUmFuZ2UpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWxsUmVnaW9ucy5yZW1vdmUocmVnaW9uKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FsbFJlZ2lvbnMucmVtb3ZlKG5leHQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZnJlZVJlZ2lvbnMucmVtb3ZlKG5leHQuX2ZyZWVOb2RlKTtcclxuICAgICAgICAgICAgICAgIHJlZ2lvbiA9IGVtYnJhY2luZ1JhbmdlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX29jY3VwaWVkUmVnaW9ucy5kZWxldGUob2Zmc2V0KTtcclxuICAgICAgICAgICAgcmVnaW9uLl9mcmVlTm9kZSA9IHRoaXMuX2ZyZWVSZWdpb25zLmluc2VydChyZWdpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlzQWxsb2NhdGVkKG9mZnNldCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9vY2N1cGllZFJlZ2lvbnMuaGFzKG9mZnNldCk7XHJcbiAgICB9XHJcbiAgICBleHRlbmQobmV3U2l6ZSkge1xyXG4gICAgICAgIGlmIChuZXdTaXplIDwgdGhpcy5fc2l6ZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NpemUgcmVkdWNpbmcgaXMgbm90IGFsbG93ZWQgaW4gZnJlZSBsaXN0IGFsbG9jYXRvcicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBkaWZmID0gbmV3U2l6ZSAtIHRoaXMuX3NpemU7XHJcbiAgICAgICAgY29uc3QgbGFzdCA9IHRoaXMuX2FsbFJlZ2lvbnMuZW5kO1xyXG4gICAgICAgIGlmIChsYXN0ICYmIGxhc3QuX2ZyZWVOb2RlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZyZWVSZWdpb25zLnJlbW92ZShsYXN0Ll9mcmVlTm9kZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlZ2lvbiA9IHsgb2Zmc2V0OiBsYXN0Lm9mZnNldCwgc2l6ZTogbGFzdC5zaXplICsgZGlmZiwgaXNGcmVlOiB0cnVlIH07XHJcbiAgICAgICAgICAgIHRoaXMuX2FsbFJlZ2lvbnMuaW5zZXJ0QWZ0ZXIobGFzdCwgcmVnaW9uKTtcclxuICAgICAgICAgICAgdGhpcy5fYWxsUmVnaW9ucy5yZW1vdmUobGFzdCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZyZWVSZWdpb25zLmluc2VydChyZWdpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgcmVnaW9uID0geyBvZmZzZXQ6IHRoaXMuX3NpemUsIHNpemU6IGRpZmYsIGlzRnJlZTogdHJ1ZSB9O1xyXG4gICAgICAgICAgICB0aGlzLl9hbGxSZWdpb25zLmluc2VydChyZWdpb24pO1xyXG4gICAgICAgICAgICB0aGlzLl9mcmVlUmVnaW9ucy5pbnNlcnQocmVnaW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fc2l6ZSA9IG5ld1NpemU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRyYXZlcnNlcyBCU1QgdG8gZmluZCB0aGUgc21hbGxlc3QgcmVnaW9uIHJlcXVpcmVkIHNpemUgY2FuIGZpdC5cclxuICAgICAqL1xyXG4gICAgX2ZpbmRNaW5TdWl0YWJsZShzaXplKSB7XHJcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLl9mcmVlUmVnaW9ucy5yb290O1xyXG4gICAgICAgIGxldCBiZXN0O1xyXG4gICAgICAgIHdoaWxlIChub2RlKSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlLnZhbHVlLnNpemUgPT09IHNpemUpIHtcclxuICAgICAgICAgICAgICAgIGJlc3QgPSBub2RlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobm9kZS52YWx1ZS5zaXplIDwgc2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBiZXN0ID0gbm9kZTtcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJlc3Q7XHJcbiAgICB9XHJcbn1cclxuIiwiLyoqXHJcbiAqIFNpbXBsZSBpbXBsZW1lbnRhdGlvbiBvZiBCaW5hcnkgU2VhcmNoIFRyZWUuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQmluYXJ5U2VhcmNoVHJlZSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBjb21wYXJhdG9yIFRvIHNwZWNpZnkgdGhlIG9yZGVyIG9mIGl0ZW1zLCB0aGF0IGNhbiBiZSBhbnkgY29tcGxleCBvYmplY3RzLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihjb21wYXJhdG9yKSB7XHJcbiAgICAgICAgdGhpcy5fY29tcGFyYXRvciA9IGNvbXBhcmF0b3I7XHJcbiAgICAgICAgdGhpcy5fc2l6ZSA9IDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFRoZSByb290IGVsZW1lbnQgb3IgYHVuZGVmaW5lZGAgaWYgdGhlIHRyZWUgaXMgZW1wdHkuXHJcbiAgICAgKi9cclxuICAgIGdldCByb290KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9yb290O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSB0cmVlLlxyXG4gICAgICovXHJcbiAgICBnZXQgc2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVGhlIHNtYWxsZXN0IGVsZW1lbnQgaW4gdGhlIHRyZWUgb3IgYHVuZGVmaW5lZGAgdGhlIHRoZSB0cmVlIGlzIGVtcHR5LlxyXG4gICAgICovXHJcbiAgICBnZXQgbWluKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9yb290KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9taW4odGhpcy5fcm9vdCkudmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFRoZSBiaWdnZXN0IGVsZW1lbnQgaW4gdGhlIHRyZWUgb3IgYHVuZGVmaW5lZGAgdGhlIHRoZSB0cmVlIGlzIGVtcHR5LlxyXG4gICAgICovXHJcbiAgICBnZXQgbWF4KCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9yb290KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tYXgodGhpcy5fcm9vdCkudmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBpbnNlcnQoaXRlbSkge1xyXG4gICAgICAgIHRoaXMuX3NpemUrKztcclxuICAgICAgICBpZiAoIXRoaXMuX3Jvb3QpIHtcclxuICAgICAgICAgICAgdGhpcy5fcm9vdCA9IHsgdmFsdWU6IGl0ZW0gfTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBub2RlID0gdGhpcy5fcm9vdDtcclxuICAgICAgICB3aGlsZSAobm9kZSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fY29tcGFyYXRvcihpdGVtLCBub2RlLnZhbHVlKSA8IDApIHtcclxuICAgICAgICAgICAgICAgIGlmICghbm9kZS5sZWZ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUubGVmdCA9IHsgcGFyZW50OiBub2RlLCB2YWx1ZTogaXRlbSB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICghbm9kZS5yaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLnJpZ2h0ID0geyBwYXJlbnQ6IG5vZGUsIHZhbHVlOiBpdGVtIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpbXBvc3NpYmxlIHRvIGdldCB0aGVyZSwgdGhyb3dpbmcgaXMgdG8gbWFrZSBUUyBhbmFsaXphdG9yIGhhcHB5XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XHJcbiAgICB9XHJcbiAgICByZW1vdmUobm9kZSkge1xyXG4gICAgICAgIHRoaXMuX3NpemUtLTtcclxuICAgICAgICBpZiAobm9kZS5sZWZ0ICYmIG5vZGUucmlnaHQpIHtcclxuICAgICAgICAgICAgY29uc3Qgc3VjY2Vzc29yID0gdGhpcy5fbWluKG5vZGUucmlnaHQpO1xyXG4gICAgICAgICAgICB0aGlzLl9yZXBsYWNlU3VidHJlZShub2RlLCBzdWNjZXNzb3IpO1xyXG4gICAgICAgICAgICAvLyB1cGRhdGUgbGlua3MgdG8gY2hpbGRyZW4gb2YgdGhlIHJlbW92ZWQgbm9kZVxyXG4gICAgICAgICAgICBpZiAobm9kZS5sZWZ0KSB7XHJcbiAgICAgICAgICAgICAgICBzdWNjZXNzb3IubGVmdCA9IG5vZGUubGVmdDtcclxuICAgICAgICAgICAgICAgIG5vZGUubGVmdC5wYXJlbnQgPSBzdWNjZXNzb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG5vZGUucmlnaHQpIHtcclxuICAgICAgICAgICAgICAgIHN1Y2Nlc3Nvci5yaWdodCA9IG5vZGUucmlnaHQ7XHJcbiAgICAgICAgICAgICAgICBub2RlLnJpZ2h0LnBhcmVudCA9IHN1Y2Nlc3NvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChub2RlLmxlZnQpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVwbGFjZVN1YnRyZWUobm9kZSwgbm9kZS5sZWZ0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobm9kZS5yaWdodCkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZXBsYWNlU3VidHJlZShub2RlLCBub2RlLnJpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlcGxhY2VTdWJ0cmVlKG5vZGUsIHVuZGVmaW5lZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJdGVyYXRlcyBlbGVtZW50cyBpbiBhc2NlbmRpbmcgb3JkZXIuXHJcbiAgICAgKi9cclxuICAgICp2YWx1ZXMobm9kZSkge1xyXG4gICAgICAgIGlmIChub2RlKSB7XHJcbiAgICAgICAgICAgIHlpZWxkKiB0aGlzLnZhbHVlcyhub2RlLmxlZnQpO1xyXG4gICAgICAgICAgICB5aWVsZCBub2RlLnZhbHVlO1xyXG4gICAgICAgICAgICB5aWVsZCogdGhpcy52YWx1ZXMobm9kZS5yaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJdGVyYXRlcyBlbGVtZW50cyBpbiBhc2NlbmRpbmcgb3JkZXIuXHJcbiAgICAgKi9cclxuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlcyh0aGlzLl9yb290KTtcclxuICAgIH1cclxuICAgIF9taW4oZnJvbSkge1xyXG4gICAgICAgIGxldCBub2RlID0gZnJvbTtcclxuICAgICAgICB3aGlsZSAobm9kZS5sZWZ0KSB7XHJcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgfVxyXG4gICAgX21heChmcm9tKSB7XHJcbiAgICAgICAgbGV0IG5vZGUgPSBmcm9tO1xyXG4gICAgICAgIHdoaWxlIChub2RlLnJpZ2h0KSB7XHJcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVvcmdhbml6ZXMgdGhlIHRyZWUgc3RydWN0dXJlIHNvIHRoYXQgdGhlIHJlcGxhY2VtZW50IG5vZGUgdGFrZXMgcmVwbGFjZWFibGUncyBwb3NpdGlvbiwgdGhlIGxhdHRlciBpcyByZW1vdmVkLlxyXG4gICAgICovXHJcbiAgICBfcmVwbGFjZVN1YnRyZWUocmVwbGFjZWFibGUsIHJlcGxhY2VtZW50KSB7XHJcbiAgICAgICAgaWYgKHJlcGxhY2VhYmxlLnBhcmVudCkge1xyXG4gICAgICAgICAgICBpZiAocmVwbGFjZWFibGUucGFyZW50LmxlZnQgPT09IHJlcGxhY2VhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICByZXBsYWNlYWJsZS5wYXJlbnQubGVmdCA9IHJlcGxhY2VtZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHJlcGxhY2VhYmxlLnBhcmVudC5yaWdodCA9PT0gcmVwbGFjZWFibGUpIHtcclxuICAgICAgICAgICAgICAgIHJlcGxhY2VhYmxlLnBhcmVudC5yaWdodCA9IHJlcGxhY2VtZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9yb290ID0gcmVwbGFjZW1lbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZXBsYWNlbWVudCkge1xyXG4gICAgICAgICAgICAvLyByZW1vdmUgcmVwbGFjZW1lbnQgZnJvbSBpdHMgY3VycmVudCBsb2NhdGlvblxyXG4gICAgICAgICAgICBpZiAocmVwbGFjZW1lbnQucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVwbGFjZW1lbnQucGFyZW50LmxlZnQgPT09IHJlcGxhY2VtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQucGFyZW50LmxlZnQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXBsYWNlbWVudC5wYXJlbnQucmlnaHQgPT09IHJlcGxhY2VtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQucGFyZW50LnJpZ2h0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlcGxhY2VtZW50LnBhcmVudCA9IHJlcGxhY2VhYmxlLnBhcmVudDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiLyoqXHJcbiAqIFNldCB3aXRoIHByZWRpY3RhYmxlIGl0ZXJhdGlvbiBvcmRlci4gU3RvcmVzIGl0ZW1zIGFzIGEgdHdvIHdheSBsaW5rZWQgbGlzdCB0aHVzIGFsbG93aW5nIHRvIGluc2VydCBpdGVtcyBpbiBiZXR3ZWVuLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGlua2VkU2V0IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuX25vZGVzID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGJlZ2luKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9iZWdpbiAmJiB0aGlzLl9iZWdpbi52YWx1ZTtcclxuICAgIH1cclxuICAgIGdldCBlbmQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuZCAmJiB0aGlzLl9lbmQudmFsdWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEluc2VydHMgYSBuZXcgaXRlbSBhdCB0aGUgZW5kIG9mIHRoZSBzZXQuXHJcbiAgICAgKi9cclxuICAgIGluc2VydChpdGVtKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9ub2Rlcy5oYXMoaXRlbSkpIHtcclxuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHsgdmFsdWU6IGl0ZW0gfTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2VuZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnNlcnRBZnRlcih0aGlzLl9lbmQudmFsdWUsIGl0ZW0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYmVnaW4gPSB0aGlzLl9lbmQgPSBub2RlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbm9kZXMuc2V0KGl0ZW0sIG5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnNlcnRzIGEgbmV3IGl0ZW0gYmVmb3JlIHRoZSBzcGVjaWZpZWQgb25lLiBJZiB0aGUgYmVmb3JlIGl0ZW0gaXMgbm90IGluIHRoZSBzZXQgb3JcclxuICAgICAqIHRoZSBpdGVtIGlzIGFscmVhZHkgaW5zZXJ0ZWQgbm90aGluZyBoYXBwZW5zLlxyXG4gICAgICovXHJcbiAgICBpbnNlcnRCZWZvcmUoYmVmb3JlLCBpdGVtKSB7XHJcbiAgICAgICAgY29uc3QgYmVmb3JlTm9kZSA9IHRoaXMuX25vZGVzLmdldChiZWZvcmUpO1xyXG4gICAgICAgIGlmIChiZWZvcmVOb2RlICYmICF0aGlzLl9ub2Rlcy5oYXMoaXRlbSkpIHtcclxuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHsgdmFsdWU6IGl0ZW0gfTtcclxuICAgICAgICAgICAgaWYgKGJlZm9yZU5vZGUucHJldikge1xyXG4gICAgICAgICAgICAgICAgYmVmb3JlTm9kZS5wcmV2Lm5leHQgPSBub2RlO1xyXG4gICAgICAgICAgICAgICAgbm9kZS5wcmV2ID0gYmVmb3JlTm9kZS5wcmV2O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG5vZGUubmV4dCA9IGJlZm9yZU5vZGU7XHJcbiAgICAgICAgICAgIGJlZm9yZU5vZGUucHJldiA9IG5vZGU7XHJcbiAgICAgICAgICAgIHRoaXMuX25vZGVzLnNldChpdGVtLCBub2RlKTtcclxuICAgICAgICAgICAgaWYgKGJlZm9yZU5vZGUgPT09IHRoaXMuX2JlZ2luKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9iZWdpbiA9IG5vZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEluc2VydHMgYSBuZXcgaXRlbSBhZnRlciB0aGUgc3BlY2lmaWVkIG9uZS4gSWYgdGhlIGFmdGVyIGl0ZW0gaXMgbm90IGluIHRoZSBzZXQgb3JcclxuICAgICAqIHRoZSBpdGVtIGlzIGFscmVhZHkgaW5zZXJ0ZWQgbm90aGluZyBoYXBwZW5zLlxyXG4gICAgICovXHJcbiAgICBpbnNlcnRBZnRlcihhZnRlciwgaXRlbSkge1xyXG4gICAgICAgIGNvbnN0IGFmdGVyTm9kZSA9IHRoaXMuX25vZGVzLmdldChhZnRlcik7XHJcbiAgICAgICAgaWYgKGFmdGVyTm9kZSAmJiAhdGhpcy5fbm9kZXMuaGFzKGl0ZW0pKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB7IHZhbHVlOiBpdGVtIH07XHJcbiAgICAgICAgICAgIGlmIChhZnRlck5vZGUubmV4dCkge1xyXG4gICAgICAgICAgICAgICAgYWZ0ZXJOb2RlLm5leHQucHJldiA9IG5vZGU7XHJcbiAgICAgICAgICAgICAgICBub2RlLm5leHQgPSBhZnRlck5vZGUubmV4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBub2RlLnByZXYgPSBhZnRlck5vZGU7XHJcbiAgICAgICAgICAgIGFmdGVyTm9kZS5uZXh0ID0gbm9kZTtcclxuICAgICAgICAgICAgdGhpcy5fbm9kZXMuc2V0KGl0ZW0sIG5vZGUpO1xyXG4gICAgICAgICAgICBpZiAoYWZ0ZXJOb2RlID09PSB0aGlzLl9lbmQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2VuZCA9IG5vZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgaXRlbSBmcm9tIHRoZSBzZXQuXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZShpdGVtKSB7XHJcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuX25vZGVzLmdldChpdGVtKTtcclxuICAgICAgICBpZiAobm9kZSkge1xyXG4gICAgICAgICAgICBpZiAobm9kZSA9PT0gdGhpcy5fYmVnaW4pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2JlZ2luID0gbm9kZS5uZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChub2RlID09PSB0aGlzLl9lbmQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2VuZCA9IG5vZGUucHJldjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobm9kZS5uZXh0KSB7XHJcbiAgICAgICAgICAgICAgICBub2RlLm5leHQucHJldiA9IG5vZGUucHJldjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobm9kZS5wcmV2KSB7XHJcbiAgICAgICAgICAgICAgICBub2RlLnByZXYubmV4dCA9IG5vZGUubmV4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9ub2Rlcy5kZWxldGUoaXRlbSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBgdW5kZWZpbmVkYCBpZiB0aGUgaXRlbSBpcyBub3QgaW4gdGhlIHNldCBvciBpdCBpcyB0aGUgZmlyc3QgZWxlbWVudHMuXHJcbiAgICAgKi9cclxuICAgIGdldFByZXYoaXRlbSkge1xyXG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLl9ub2Rlcy5nZXQoaXRlbSk7XHJcbiAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS5wcmV2KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlLnByZXYudmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIGB1bmRlZmluZWRgIGlmIHRoZSBpdGVtIGlzIG5vdCBpbiB0aGUgc2V0IG9yIGl0IGlzIHRoZSBsYXN0IGVsZW1lbnRzLlxyXG4gICAgICovXHJcbiAgICBnZXROZXh0KGl0ZW0pIHtcclxuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5fbm9kZXMuZ2V0KGl0ZW0pO1xyXG4gICAgICAgIGlmIChub2RlICYmIG5vZGUubmV4dCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5uZXh0LnZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJdGVyYXRlcyBvdmVyIHRoZSBzZXQgZnJvbSB0aGUgZmlzdCBlbGVtZW50IHRvIHRoZSBsYXN0IChpbiB0aGUgb3JkZXIgb2YgaW5zZXJ0aW9uXHJcbiAgICAgKiBpZiB0aGUgaW5zZXJ0IG1ldGhvZCB3YXMgdXNlZCBvbmx5KS5cclxuICAgICAqL1xyXG4gICAgKnZhbHVlcygpIHtcclxuICAgICAgICBsZXQgbm9kZSA9IHRoaXMuX2JlZ2luO1xyXG4gICAgICAgIHdoaWxlIChub2RlKSB7XHJcbiAgICAgICAgICAgIHlpZWxkIG5vZGUudmFsdWU7XHJcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJdGVyYXRlcyBvdmVyIHRoZSBzZXQgZnJvbSB0aGUgZmlzdCBlbGVtZW50IHRvIHRoZSBsYXN0IChpbiB0aGUgb3JkZXIgb2YgaW5zZXJ0aW9uXHJcbiAgICAgKiBpZiB0aGUgaW5zZXJ0IG1ldGhvZCB3YXMgdXNlZCBvbmx5KS5cclxuICAgICAqL1xyXG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzKCk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IFJlbmRlclN0YXRlIGZyb20gJy4uL3JlbmRlci9zdGF0ZSc7XHJcbmltcG9ydCAqIGFzIGNvbG9yIGZyb20gJy4uL3V0aWwvY29sb3InO1xyXG5pbXBvcnQgKiBhcyB2ZWMyIGZyb20gJy4uL21hdGgvdmVjdG9yMic7XHJcbmltcG9ydCAqIGFzIHZlYzMgZnJvbSAnLi4vbWF0aC92ZWN0b3IzJztcclxuaW1wb3J0ICogYXMgbWF0NCBmcm9tICcuLi9tYXRoL21hdHJpeDQnO1xyXG5pbXBvcnQgR3JpZFNhbXBsZXJCdWZmZXJXcml0ZXIsIHsgQVRUUklCVVRFX01BUFBJTkcgYXMgR1JJRF9TQU1QTEVSX0FUVFJJQlVURVMgfSBmcm9tICcuL2dyaWRfc2FtcGxlcl9idWZmZXJfd3JpdGVyJztcclxuaW1wb3J0IHsgVm9pZEV2ZW50RW1pdHRlciB9IGZyb20gJy4uL3V0aWwvZXZlbnRfZW1pdHRlcic7XHJcbmltcG9ydCBHcmlkUmVuZGVyZXIgZnJvbSAnLi9ncmlkX3JlbmRlcmVyJztcclxuaW1wb3J0IFJlc2V0UmVtb3ZlZFByaW1pdGl2ZXMgZnJvbSAnLi92aXNpYmlsaXR5X3Jlc29sdXRpb25fc3RlcHMvcmVzZXRfcmVtb3ZlZF9wcmltaXRpdmVzJztcclxuaW1wb3J0IEZhZGVvdXRBbGwgZnJvbSAnLi92aXNpYmlsaXR5X3Jlc29sdXRpb25fc3RlcHMvZmFkZW91dF9hbGwnO1xyXG5pbXBvcnQgRmFkZWluVmlzaWJsZSBmcm9tICcuL3Zpc2liaWxpdHlfcmVzb2x1dGlvbl9zdGVwcy9mYWRlaW5fdmlzaWJsZSc7XHJcbmltcG9ydCBGYWRlb3V0T3ZlcmxhcHBlZCBmcm9tICcuL3Zpc2liaWxpdHlfcmVzb2x1dGlvbl9zdGVwcy9mYWRlb3V0X292ZXJsYXBwZWQnO1xyXG5pbXBvcnQgeyBjYWxjdWxhdGVDYW1lcmFQb3NpdGlvbnMgfSBmcm9tICcuLi9yZW5kZXIvdXRpbC9jYW1lcmFfcG9zaXRpb24nO1xyXG5pbXBvcnQgZ2V0RHByIGZyb20gJy4uL3V0aWwvaGQnO1xyXG5jb25zdCBGQURJTkdfU1RPUFBFRCA9IC0xO1xyXG5jb25zdCBERUZBVUxUX0ZBREVfRUZGRUNUX0RVUkFUSU9OID0gMTUwO1xyXG5jb25zdCBJRF9DT01QT05FTlRfU0laRSA9IDI1NjtcclxuY29uc3QgVklTSUJJTElUWV9JTklUX1NUQVRFID0gbmV3IFJlbmRlclN0YXRlKHtcclxuICAgIGNsZWFyQ29sb3I6IGNvbG9yLmNyZWF0ZSgwLCAwLCAwLCAwKSxcclxuICAgIGRpdGhlcjogZmFsc2VcclxufSk7XHJcbmNvbnN0IEVNUFRZX0dSSURfQ0VMTCA9IGNvbG9yLmNyZWF0ZSgwLCAwLCAwLCAxKTtcclxuY29uc3QgRElSRUNUX1BSSU9SSVRZX0dSSURfU1RBVEUgPSBuZXcgUmVuZGVyU3RhdGUoe1xyXG4gICAgY2xlYXJDb2xvcjogRU1QVFlfR1JJRF9DRUxMLFxyXG4gICAgZGVwdGhUZXN0OiB0cnVlLFxyXG4gICAgY2xlYXJEZXB0aDogMCxcclxuICAgIC8vIHByaW1pdGl2ZXMgd2l0aCBlcXVhbCBwcmlvcml0eSBhcmUgcmVzb2x2ZWQgYXMgZm9sbG93aW5nOiBsYXRlciBvbmVzIG92ZXJsYXAgcHJldmlvdXNcclxuICAgIGRlcHRoRnVuYzogNTE4IC8qIEdSRUFURVJfT1JfRVFVQUwgKi8sXHJcbiAgICBkaXRoZXI6IGZhbHNlXHJcbn0pO1xyXG5jb25zdCBSRVZFUlNFX1BSSU9SSVRZX0dSSURfU1RBVEUgPSBuZXcgUmVuZGVyU3RhdGUoe1xyXG4gICAgY2xlYXJDb2xvcjogRU1QVFlfR1JJRF9DRUxMLFxyXG4gICAgZGVwdGhUZXN0OiB0cnVlLFxyXG4gICAgY2xlYXJEZXB0aDogMSxcclxuICAgIGRlcHRoRnVuYzogNTEzIC8qIExFU1MgKi8sXHJcbiAgICBkaXRoZXI6IGZhbHNlXHJcbn0pO1xyXG4vLyBzaXplIG9mIG1pbmltYWwgcmVjb2duaXphYmxlIHNxdWFyZSBzaWRlIGluIGNzcyBwaXhlbHMuXHJcbmNvbnN0IEdSSURfUFJFQ0lTSU9OX1BYID0gNjtcclxuLyoqXHJcbiAqIEFwYXJ0IGZyb20gYmVpbmcgcmVtb3ZlZCBmcm9tIHNjZW5lIHRoZXJlIGFyZSBvdGhlciByZWFzb25zIGZvciBwcmltaXRpdmVzIHRvIGJlIGludmlzaWJsZTogZS5nLiB0aGV5IGFyZVxyXG4gKiBvdmVybGFwcGVkIGJ5IHByaW1pdGl2ZXMgd2l0aCBoaWdoZXIgcHJpb3JpdHkuIFRoaXMgc3RhdGUgaXMgaGlnaGx5IGR5bmFtaWMsIHByaW1pdGl2ZXMgbWF5IGJlIG9mIGRpZmZlcmVudCB0eXBlcyxcclxuICogZnJvbSBkaWZmZXJlbnQgc291cmNlcyBhbmQgdGhleSBjYW4gaGF2ZSBxdWl0ZSBub24tdHJpdmlhbCBzaGFwZXMuIFNvIHRoZXJlIHNob3VsZCBiZSBhIHNpbmdsZSBwb2ludCBvZiBjb2xsaXNpb25cclxuICogcmVzb2x1dGlvbiBmb3IgYWxsIHByaW1pdGl2ZXMgaW4gc2NlbmUsIHRoYXQgaXMgd2hhdCB2aXNpYmlsaXR5IG1hbmFnZXIgaXMuXHJcbiAqXHJcbiAqIFZpc2liaWxpdHkgb2YgcHJpbWl0aXZlcyBpcyBjYWxjdWxhdGVkIGV2ZXJ5IGZyYW1lLiBUbyBzdXBwb3J0IGZhZGUtaW4vb3V0IGFuaW1hdGlvbiB2aXNpYmlsaXR5IHZhbHVlIGlzIGEgZmFjdG9yXHJcbiAqIHRoZSBhbHBoYSBjaGFubmVsIG9mIGEgZmluYWxseSByZW5kZXJlZCBwcmltaXRpdmUgaXMgdG8gYmUgbXVsdGlwbGllZCBieSAodmFsdWUgZnJvbSAwLjAgdG8gMS4wKS4gRm9yIGluc3RhbmNlLFxyXG4gKiBpZiBhbiBvYmplY3QgaXMganVzdCBhcHBlYXJlZCBvbiB0aGUgc2NlbmUsIHRoaXMgZmFjdG9yIHdpbGwgYmUgY2hhbmdlZCBmcm9tIDAuMCB0byAxLjAgaW4gZmFkZUVmZmVjdER1cmF0aW9uTXMgbXMuXHJcbiAqIFRoZXJlIGFyZSA0IHN0ZXBzIHRoZSB3aG9sZSBwcm9jZXNzIGNhbiBiZSByb3VnaGx5IHN1bW1hcml6ZWQgaW50bzpcclxuICogIDEuIGFjdHVhbGl6YXRpb24gLSByZXNldCB2YWx1ZXMgZm9yIHJlbW92ZWQgZnJvbSBzY2VuZSBwcmltaXRpdmVzXHJcbiAqICAyLiBmYWRlLW91dCBhbGwgLSBldmVuIHRob3VnaCBhbGwgcHJpbWl0aXZlcyBhcmUgZmFkZWQgb3V0IGF0IHRoaXMgc3RlcCwgdGhpcyBzdGVwIGlzIGludGVuZGVkIGZvciBpbnZpc2libGVcclxuICogICAgIHByaW1pdGl2ZXMgdG8gYW5pbWF0ZSB0aGVtIGRpc2FwcGVhcmluZy5cclxuICogIDMuIGZhZGUtaW4gdmlzaWJsZSAtIGNoZWNrIHdoaWNoIHByaW1pdGl2ZSBhcmUgdmlzaWJsZSBhbmQgaW5jcmVhc2UgaXRzIGFscGhhIHZpc2liaWxpdHkgdmFsdWUuXHJcbiAqICA0LiBmYWRlLW91dCBvdmVybGFwcGVkIC0gZmluZCBvdmVybGFwcyBieSBjb21wYXJpbmcgY29ycmVzcG9uZGluZyBwaXhlbHMgb2YgdGhlIHNjZW5lIHJlbmRlcmVkIGluIGRpcmVjdCBhbmRcclxuICogICAgIHJldmVyc2UgcHJpb3JpdHkgb3JkZXJzLlxyXG4gKlxyXG4gKiAgRHVlIHRvIHRoZSBmYWN0IHRoYXQgd2UgdXNlIGdyaWQgd2l0aCBmaW5pdGUgcHJlY2lzaW9uIHRoZXJlIGFyZSBzb21lIGNhc2VzIHdoZXJlIHRoaXMgYXBwcm9hY2ggcHJvZHVjZXNcclxuICogIHVucGxlYXNhbnQgYXJ0aWZhY3RzIChibGlua2luZykuIFRvIGNvcGUgd2l0aCBpdCBzdGFiaWxpdHkgc2hpZnQgYW5kIHN0b3Jpbmcgem9vbSBvZiB0aGUgZmlyc3Qgb3ZlcmxhcCBhcmVcclxuICogIGludHJvZHVjZWQsIGJ1dCBpdCB3b3JrcyB3ZWxsIGZvciBub24tdGlsdGVkIG1hcCBvbmx5LlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmlzaWJpbGl0eU1hbmFnZXIge1xyXG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgY2FtZXJhLCByZW5kZXJMb29wLCB0YXJnZXRXaWR0aCwgdGFyZ2V0SGVpZ2h0LCBmYWRlRWZmZWN0RHVyYXRpb24gPSBERUZBVUxUX0ZBREVfRUZGRUNUX0RVUkFUSU9OKSB7XHJcbiAgICAgICAgdGhpcy5vblJlcmVuZGVyUmVxdWlyZWQgPSBuZXcgVm9pZEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMuZmFkZUVmZmVjdER1cmF0aW9uID0gZmFkZUVmZmVjdER1cmF0aW9uO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgICAgIHRoaXMuX2NhbWVyYSA9IGNhbWVyYTtcclxuICAgICAgICB0aGlzLl9yZW5kZXJMb29wID0gcmVuZGVyTG9vcDtcclxuICAgICAgICB0aGlzLl9sYXN0UmVuZGVyVGltZUluTG9vcCA9IEZBRElOR19TVE9QUEVEO1xyXG4gICAgICAgIHRoaXMuX3ByZXZUYXJnZXRTaXplID0geyB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XHJcbiAgICAgICAgdGhpcy5fc2NlbmVVcGRhdGVMaXN0ZW5lciA9IHRoaXMuX29uU2NlbmVVcGRhdGUuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLl9jYW1lcmEub25VcGRhdGUuYWRkTGlzdGVuZXIodGhpcy5fc2NlbmVVcGRhdGVMaXN0ZW5lcik7XHJcbiAgICAgICAgdGhpcy5fYmVmb3JlUmVuZGVyTGlzdGVuZXIgPSB0aGlzLl9vbkJlZm9yZVJlbmRlci5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX3JlbmRlckxvb3Aub25CZWZvcmVSZW5kZXIuYWRkTGlzdGVuZXIodGhpcy5fYmVmb3JlUmVuZGVyTGlzdGVuZXIpO1xyXG4gICAgICAgIHRoaXMuX2RpcmVjdFByaW9yaXR5R3JpZFJlbmRlcmVyID0gbmV3IEdyaWRSZW5kZXJlcihjb250ZXh0LCBESVJFQ1RfUFJJT1JJVFlfR1JJRF9TVEFURSk7XHJcbiAgICAgICAgdGhpcy5fcmV2ZXJzZVByaW9yaXR5R3JpZFJlbmRlcmVyID0gbmV3IEdyaWRSZW5kZXJlcihjb250ZXh0LCBSRVZFUlNFX1BSSU9SSVRZX0dSSURfU1RBVEUpO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRWaXNpYmlsaXR5VGV4dHVyZSA9IGNvbnRleHQuY3JlYXRlRW1wdHkyRFRleHR1cmUoSURfQ09NUE9ORU5UX1NJWkUsIElEX0NPTVBPTkVOVF9TSVpFLCA2NDA4IC8qIFJHQkEgKi8sIDUxMjEgLyogVU5TSUdORURfQllURSAqLyk7XHJcbiAgICAgICAgdGhpcy5fcHJldlZpc2liaWxpdHlUZXh0dXJlID0gY29udGV4dC5jcmVhdGVFbXB0eTJEVGV4dHVyZShJRF9DT01QT05FTlRfU0laRSwgSURfQ09NUE9ORU5UX1NJWkUsIDY0MDggLyogUkdCQSAqLywgNTEyMSAvKiBVTlNJR05FRF9CWVRFICovKTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50VmlzaWJpbGl0eUJ1ZmZlciA9IGNvbnRleHQuY3JlYXRlRnJhbWVidWZmZXIoeyBjb2xvcjogdGhpcy5fY3VycmVudFZpc2liaWxpdHlUZXh0dXJlIH0pO1xyXG4gICAgICAgIHRoaXMuX3ByZXZWaXNpYmlsaXR5QnVmZmVyID0gY29udGV4dC5jcmVhdGVGcmFtZWJ1ZmZlcih7IGNvbG9yOiB0aGlzLl9wcmV2VmlzaWJpbGl0eVRleHR1cmUgfSk7XHJcbiAgICAgICAgdGhpcy5fc3RhYmlsaXR5U2hpZnQgPSB2ZWMzLmNyZWF0ZSgwLCAwLCAwKTtcclxuICAgICAgICB0aGlzLl9ncmlkSGFsZlB4U2l6ZVVuaWZvcm0gPSB2ZWMyLmNyZWF0ZSgwLCAwKTtcclxuICAgICAgICB0aGlzLl9pZEhhbGZQeFNpemVVbmlmb3JtID0gdmVjMi5jcmVhdGUoMC41IC8gSURfQ09NUE9ORU5UX1NJWkUsIDAuNSAvIElEX0NPTVBPTkVOVF9TSVpFKTtcclxuICAgICAgICB0aGlzLl9zdGVwMVJlc2V0UmVtb3ZlZCA9IG5ldyBSZXNldFJlbW92ZWRQcmltaXRpdmVzKCk7XHJcbiAgICAgICAgdGhpcy5fc3RlcDJGYWRlb3V0QWxsID0gbmV3IEZhZGVvdXRBbGwoY29udGV4dCk7XHJcbiAgICAgICAgdGhpcy5fc3RlcDNGYWRlaW5WaXNpYmxlID0gbmV3IEZhZGVpblZpc2libGUoY29udGV4dCk7XHJcbiAgICAgICAgdGhpcy5fc3RlcDRGYWRlb3V0T3ZlcmxhcHBlZCA9IG5ldyBGYWRlb3V0T3ZlcmxhcHBlZChjb250ZXh0KTtcclxuICAgICAgICB0aGlzLl9jbGVhclZpc2liaWxpdHkodGhpcy5fY3VycmVudFZpc2liaWxpdHlCdWZmZXIpO1xyXG4gICAgICAgIHRoaXMuX3ByaW1pdGl2ZVByb3ZpZGVycyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2NvbG9ySWRSZW5kZXJlcnMgPSBbXTtcclxuICAgICAgICB0aGlzLl9yZXNldFJlbW92ZWRSZW5kZXJlcnMgPSBbXTtcclxuICAgICAgICB0aGlzLnNldFRhcmdldFNpemUodGFyZ2V0V2lkdGgsIHRhcmdldEhlaWdodCk7XHJcbiAgICB9XHJcbiAgICBnZXQgdmlzaWJpbGl0eVRleHR1cmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRWaXNpYmlsaXR5VGV4dHVyZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVG8gcHJvdmlkZSBwcm9wZXIgcHJlY2lzaW9uIGluIGNvbGxpc2lvbiByZXNvbHV0aW9uIHNpbXBsaWZpZWQgZ3JpZCBzaXplIGRlcGVuZHMgb24gdGhlIHJlbmRlciB0YXJnZXQsXHJcbiAgICAgKiB0aGF0IGNhbiBiZSBjaGFuZ2VkIGF0IHJ1biB0aW1lIChlLmcuIHRoZSB1c2VyIHJlc2l6ZXMgYnJvd3NlciB3aW5kb3cpLiBBIGxvdCBvZiBhc3NvY2lhdGVkIEdMIHJlc291cmNlcyBpcyBiZVxyXG4gICAgICogdXBkYXRlZCBpbiB0aGF0IGNhc2UuXHJcbiAgICAgKi9cclxuICAgIHNldFRhcmdldFNpemUod2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIGNvbnN0IGdyaWRQcmVjaXNpb25UYXJnZXRQeCA9IEdSSURfUFJFQ0lTSU9OX1BYICogZ2V0RHByKCk7XHJcbiAgICAgICAgY29uc3QgZ3JpZFdpZHRoID0gTWF0aC5jZWlsKHdpZHRoIC8gZ3JpZFByZWNpc2lvblRhcmdldFB4KTtcclxuICAgICAgICBjb25zdCBncmlkSGVpZ2h0ID0gTWF0aC5jZWlsKGhlaWdodCAvIGdyaWRQcmVjaXNpb25UYXJnZXRQeCk7XHJcbiAgICAgICAgdGhpcy5fZGlyZWN0UHJpb3JpdHlHcmlkUmVuZGVyZXIuc2V0UmVzb2x1dGlvbihncmlkV2lkdGgsIGdyaWRIZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuX3JldmVyc2VQcmlvcml0eUdyaWRSZW5kZXJlci5zZXRSZXNvbHV0aW9uKGdyaWRXaWR0aCwgZ3JpZEhlaWdodCk7XHJcbiAgICAgICAgaWYgKHRoaXMuX2dyaWRTYW1wbGVyVmVydGV4QnVmZmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3lHcmlkUmVzb3VyY2VzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG92ZXJsYXBTYW1wbGVyQnVmZmVyV3JpdGVyID0gbmV3IEdyaWRTYW1wbGVyQnVmZmVyV3JpdGVyKGdyaWRXaWR0aCwgZ3JpZEhlaWdodCk7XHJcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuX2NvbnRleHQ7XHJcbiAgICAgICAgdGhpcy5fZ3JpZFNhbXBsZXJWZXJ0ZXhCdWZmZXIgPSBjb250ZXh0LmNyZWF0ZVZlcnRleEJ1ZmZlcihvdmVybGFwU2FtcGxlckJ1ZmZlcldyaXRlci5kYXRhLmJ5dGVMZW5ndGgpO1xyXG4gICAgICAgIHRoaXMuX2dyaWRTYW1wbGVyVmFvID0gY29udGV4dC5jcmVhdGVWYW8oR1JJRF9TQU1QTEVSX0FUVFJJQlVURVMsIHRoaXMuX2dyaWRTYW1wbGVyVmVydGV4QnVmZmVyLCBudWxsKTtcclxuICAgICAgICB0aGlzLl9udW1iZXJPZkdyaWRTYW1wbGVycyA9IG92ZXJsYXBTYW1wbGVyQnVmZmVyV3JpdGVyLm51bWJlck9mU2FtcGxlcnM7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC51cGxvYWREYXRhVG9CdWZmZXIodGhpcy5fZ3JpZFNhbXBsZXJWZXJ0ZXhCdWZmZXIsIG92ZXJsYXBTYW1wbGVyQnVmZmVyV3JpdGVyLmRhdGEpO1xyXG4gICAgICAgIHRoaXMuX3ByZXZUYXJnZXRTaXplLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy5fcHJldlRhcmdldFNpemUuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMuX2dyaWRIYWxmUHhTaXplVW5pZm9ybS54ID0gMC41IC8gZ3JpZFdpZHRoO1xyXG4gICAgICAgIHRoaXMuX2dyaWRIYWxmUHhTaXplVW5pZm9ybS55ID0gMC41IC8gZ3JpZEhlaWdodDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVjYWxjdWxhdGVzIHZpc2liaWxpdHkgb2YgYWxsIGNvbGxpZGluZyBwcmltaXRpdmVzIGluIHNjZW5lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCB0aGUgc2NlbmUgaXMgdG8gYmUgcmVuZGVyZWQgaW50by5cclxuICAgICAqIEBwYXJhbSB1bmlmb3JtcyBTZXQgb2YgcHJlY2FsY3VsYXRlZCB1bmlmb3JtcyBnbG9iYWwgZm9yIGN1cnJlbnQgZnJhbWUuXHJcbiAgICAgKiBAcmV0dXJucyBVcGRhdGVkIHRleHR1cmUgd2l0aCB2aXNpYmlsaXR5IHZhbHVlcyBmb3IgYWxsIHByaW1pdGl2ZXMuXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZVZpc2liaWxpdHlJZk5lZWRlZCgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2lzRGlydHkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9pc0RpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgLy8gUmFzdGVyaXphdGlvbiBtYXkgYmUgbm90IHN0YWJsZSBpbiB0aGUgc2Vuc2Ugb2YgdGhlIHNoYXBlIG9mIHBpeGVscyBvY2N1cGllZCBieSBwYXJ0aWN1bGFyIG9iamVjdCB3aGVuIHRoaXNcclxuICAgICAgICAvLyBvYmplY3QgZ2V0cyBzaGlmdGVkIChlLmcuIHRoZSB1c2VyIGRyYWdzIHRoZSBjZW50ZXIgb2YgdGhlIG1hcCkgYW5kIHNpbmNlIGNvbGxpc2lvbnMgYXJlIGRldGVjdGVkIGJ5XHJcbiAgICAgICAgLy8gb3ZlcmxhcHBlZCBwaXhlbHMgdGhpcyBmYWN0IGNhbiBsZWFkIHRvIGJsaW5raW5nIChmb3VuZCBvdmVybGFwcGluZyBpbiBvbmUgZnJhbWUvbm90IGZvdW5kIGluIHRoZSBuZXh0L2V0YykuXHJcbiAgICAgICAgLy8gRm9yIHRob3NlIG9iamVjdHMgKGFuZCB0aGVpciBwb3NpdGlvbnMpIHRoYXQgYXJlIG5vdCBkaXN0b3J0ZWQgYnkgcGVyc3BlY3RpdmUgaXQgY2FuIGJlIGZpeGVkIGJ5XHJcbiAgICAgICAgLy8gaW50cm9kdWNpbmcgYSBzaGlmdCB0aGF0IHRha2VzIGludG8gYWNjb3VudCB0aGUgYW1vdW50IG9mIGRyYWcgYW5kIGZvcmNlcyB2ZXJ0aWNlcyB0byBiZSBkaXNwbGFjZWQgaW4gdGhlXHJcbiAgICAgICAgLy8gc2FtZSBwb3NpdGlvbiBpbiBncmlkJ3MgY2VsbC5cclxuICAgICAgICBjb25zdCBzaGlmdCA9IHRoaXMuX3N0YWJpbGl0eVNoaWZ0O1xyXG4gICAgICAgIHZlYzIuY29weSh0aGlzLl9jYW1lcmEuY2VudGVyLCBzaGlmdCk7XHJcbiAgICAgICAgc2hpZnQueiA9IDA7XHJcbiAgICAgICAgbWF0NC5hcHBseSh0aGlzLl9jYW1lcmEuZ2V0Vmlld1Byb2pNYXRyaXgoKSwgc2hpZnQsIHNoaWZ0KTtcclxuICAgICAgICAvLyBOREMgKC0xIDogMSkgYXJlIDIgdGltZXMgbGFyZ2VyIHRoYW4gdGV4dHVyZSBjb29yZGluYXRlcyAoMCA6IDEpXHJcbiAgICAgICAgc2hpZnQueCAlPSA0ICogdGhpcy5fZ3JpZEhhbGZQeFNpemVVbmlmb3JtLng7XHJcbiAgICAgICAgc2hpZnQueSAlPSA0ICogdGhpcy5fZ3JpZEhhbGZQeFNpemVVbmlmb3JtLnk7XHJcbiAgICAgICAgY29uc3QgcHJldlRleHR1cmUgPSB0aGlzLl9wcmV2VmlzaWJpbGl0eVRleHR1cmU7XHJcbiAgICAgICAgY29uc3QgcHJldkZyYW1lYnVmZmVyID0gdGhpcy5fcHJldlZpc2liaWxpdHlCdWZmZXI7XHJcbiAgICAgICAgY29uc3QgY3VycmVudFRleHR1cmUgPSB0aGlzLl9jdXJyZW50VmlzaWJpbGl0eVRleHR1cmU7XHJcbiAgICAgICAgY29uc3QgY3VycmVudEZyYW1lYnVmZmVyID0gdGhpcy5fY3VycmVudFZpc2liaWxpdHlCdWZmZXI7XHJcbiAgICAgICAgdGhpcy5fY2xlYXJWaXNpYmlsaXR5KHByZXZGcmFtZWJ1ZmZlcik7XHJcbiAgICAgICAgLy8gb24gdGhpcyBzdGVwXHJcbiAgICAgICAgdGhpcy5fc3RlcDFSZXNldFJlbW92ZWQucmVuZGVyKHByZXZGcmFtZWJ1ZmZlciwgdGhpcy5fcmVzZXRSZW1vdmVkUmVuZGVyZXJzLCBjdXJyZW50VGV4dHVyZSwgdGhpcy5faWRIYWxmUHhTaXplVW5pZm9ybSk7XHJcbiAgICAgICAgLy8gcGFzcyB6b29tIGFzIGEgdmFsdWUgYmV0d2VlbiAwLjAgYW5kIDEuMCwgYXMgYWJzb2x1dGUgdmFsdWUgaXMgbm90IGltcG9ydGFudFxyXG4gICAgICAgIGNvbnN0IHpvb20gPSB0aGlzLl9jYW1lcmEuem9vbSAvIHRoaXMuX2NhbWVyYS5vcHRpb25zLm1heFpvb207XHJcbiAgICAgICAgY29uc3Qgdmlld1Byb2pNYXRyaXggPSB0aGlzLl9jYW1lcmEuZ2V0Vmlld1Byb2pNYXRyaXgoKTtcclxuICAgICAgICBjb25zdCBjYW1lcmFQb3NpdGlvbnMgPSBjYWxjdWxhdGVDYW1lcmFQb3NpdGlvbnModGhpcy5fY2FtZXJhKTtcclxuICAgICAgICBjb25zdCBkaXJlY3RQcmlvcml0eUdyaWQgPSB0aGlzLl9kaXJlY3RQcmlvcml0eUdyaWRSZW5kZXJlci51cGRhdGVHcmlkKHZpZXdQcm9qTWF0cml4LCBjYW1lcmFQb3NpdGlvbnMsIHRoaXMuX2NvbG9ySWRSZW5kZXJlcnMsIHNoaWZ0LCBwcmV2VGV4dHVyZSwgem9vbSk7XHJcbiAgICAgICAgY29uc3QgcmV2ZXJzZVByaW9yaXR5R3JpZCA9IHRoaXMuX3JldmVyc2VQcmlvcml0eUdyaWRSZW5kZXJlci51cGRhdGVHcmlkKHZpZXdQcm9qTWF0cml4LCBjYW1lcmFQb3NpdGlvbnMsIHRoaXMuX2NvbG9ySWRSZW5kZXJlcnMsIHNoaWZ0LCBwcmV2VGV4dHVyZSwgem9vbSk7XHJcbiAgICAgICAgY29uc3Qgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAgICAgY29uc3QgbGFzdFJlbmRlcmluZyA9IHRoaXMuX2xhc3RSZW5kZXJUaW1lSW5Mb29wO1xyXG4gICAgICAgIGNvbnN0IGlzQW5pbWF0aW9uRmluaXNoZWQgPSAobm93IC0gdGhpcy5fbGFzdFNjZW5lVXBkYXRlVGltZSkgPiB0aGlzLmZhZGVFZmZlY3REdXJhdGlvbjtcclxuICAgICAgICBjb25zdCB3YXNBbmltYXRpb25BY3RpdmUgPSBsYXN0UmVuZGVyaW5nICE9PSBGQURJTkdfU1RPUFBFRDtcclxuICAgICAgICBjb25zdCBmYWRlRWZmZWN0ID0gaXNBbmltYXRpb25GaW5pc2hlZCA/XHJcbiAgICAgICAgICAgIDEuMCA6IHdhc0FuaW1hdGlvbkFjdGl2ZSA/IChub3cgLSBsYXN0UmVuZGVyaW5nKSAvIHRoaXMuZmFkZUVmZmVjdER1cmF0aW9uIDogMDtcclxuICAgICAgICBjb25zdCBpZEhhbGZQeCA9IHRoaXMuX2lkSGFsZlB4U2l6ZVVuaWZvcm07XHJcbiAgICAgICAgY29uc3Qgc2FtcGxlclZhbyA9IHRoaXMuX2dyaWRTYW1wbGVyVmFvO1xyXG4gICAgICAgIGNvbnN0IG51bWJlck9mU2FtcGxlcnMgPSB0aGlzLl9udW1iZXJPZkdyaWRTYW1wbGVycztcclxuICAgICAgICB0aGlzLl9jbGVhclZpc2liaWxpdHkoY3VycmVudEZyYW1lYnVmZmVyKTtcclxuICAgICAgICB0aGlzLl9zdGVwMkZhZGVvdXRBbGwucmVuZGVyKGN1cnJlbnRGcmFtZWJ1ZmZlciwgcHJldlRleHR1cmUsIGZhZGVFZmZlY3QpO1xyXG4gICAgICAgIHRoaXMuX3N0ZXAzRmFkZWluVmlzaWJsZS5yZW5kZXIoY3VycmVudEZyYW1lYnVmZmVyLCBzYW1wbGVyVmFvLCBudW1iZXJPZlNhbXBsZXJzLCBkaXJlY3RQcmlvcml0eUdyaWQsIHByZXZUZXh0dXJlLCBpZEhhbGZQeCwgZmFkZUVmZmVjdCk7XHJcbiAgICAgICAgdGhpcy5fc3RlcDRGYWRlb3V0T3ZlcmxhcHBlZC5yZW5kZXIoY3VycmVudEZyYW1lYnVmZmVyLCBzYW1wbGVyVmFvLCBudW1iZXJPZlNhbXBsZXJzLCBkaXJlY3RQcmlvcml0eUdyaWQsIHJldmVyc2VQcmlvcml0eUdyaWQsIHByZXZUZXh0dXJlLCBpZEhhbGZQeCwgZmFkZUVmZmVjdCwgem9vbSk7XHJcbiAgICAgICAgLy8gY2hlY2sgaWYgd2UgbmVlZCBvbmUgbW9yZSByZW5kZXJpbmcgdG8gZmluaXNoIGFuaW1hdGlvblxyXG4gICAgICAgIGlmIChpc0FuaW1hdGlvbkZpbmlzaGVkKSB7XHJcbiAgICAgICAgICAgIC8vIG5vIG1vcmUgcmVuZGVyaW5ncyBuZWVkZWQgZm9yIGZhZGUgZWZmZWN0LCBpdHMgdGltZXN0YW1wIGlzIG1hcmtlZCB3aXRoIHNwZWNpYWwgdmFsdWVcclxuICAgICAgICAgICAgLy8gdG8gdGFrZSBpdCBpbnRvIGFjY291bnQgZHVyaW5nIG5leHQgZmFkZSBlZmZlY3QgYW1vdW50IGNhbGN1bGF0aW9uXHJcbiAgICAgICAgICAgIHRoaXMuX2xhc3RSZW5kZXJUaW1lSW5Mb29wID0gRkFESU5HX1NUT1BQRUQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJMb29wLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9sYXN0UmVuZGVyVGltZUluTG9vcCA9IG5vdztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZWdpc3RlckNvbGxpZGluZ1ByaW1pdGl2ZXMocHJpbWl0aXZlUHJvdmlkZXIsIGNvbG9ySWRSZW5kZXJlciwgcmVzZXRSZW1vdmVSZW5kZXJlcikge1xyXG4gICAgICAgIHRoaXMuX3ByaW1pdGl2ZVByb3ZpZGVycy5wdXNoKHByaW1pdGl2ZVByb3ZpZGVyKTtcclxuICAgICAgICB0aGlzLl9jb2xvcklkUmVuZGVyZXJzLnB1c2goY29sb3JJZFJlbmRlcmVyKTtcclxuICAgICAgICB0aGlzLl9yZXNldFJlbW92ZWRSZW5kZXJlcnMucHVzaChyZXNldFJlbW92ZVJlbmRlcmVyKTtcclxuICAgICAgICBwcmltaXRpdmVQcm92aWRlci5vblVwZGF0ZS5hZGRMaXN0ZW5lcih0aGlzLl9zY2VuZVVwZGF0ZUxpc3RlbmVyKTtcclxuICAgIH1cclxuICAgIGRlcmVnaXN0ZXJDb2xsaWRpbmdQcmltaXRpdmVzKHByaW1pdGl2ZVByb3ZpZGVyLCBjb2xvcklkUmVuZGVyZXIsIHJlc2V0UmVtb3ZlUmVuZGVyZXIpIHtcclxuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLl9wcmltaXRpdmVQcm92aWRlcnMuaW5kZXhPZihwcmltaXRpdmVQcm92aWRlcik7XHJcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcclxuICAgICAgICAgICAgdGhpcy5fcHJpbWl0aXZlUHJvdmlkZXJzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluZGV4ID0gdGhpcy5fY29sb3JJZFJlbmRlcmVycy5pbmRleE9mKGNvbG9ySWRSZW5kZXJlcik7XHJcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcclxuICAgICAgICAgICAgdGhpcy5fY29sb3JJZFJlbmRlcmVycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbmRleCA9IHRoaXMuX3Jlc2V0UmVtb3ZlZFJlbmRlcmVycy5pbmRleE9mKHJlc2V0UmVtb3ZlUmVuZGVyZXIpO1xyXG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0UmVtb3ZlZFJlbmRlcmVycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwcmltaXRpdmVQcm92aWRlci5vblVwZGF0ZS5yZW1vdmVMaXN0ZW5lcih0aGlzLl9zY2VuZVVwZGF0ZUxpc3RlbmVyKTtcclxuICAgIH1cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5fZGVzdHJveUdyaWRSZXNvdXJjZXMoKTtcclxuICAgICAgICB0aGlzLl9kaXJlY3RQcmlvcml0eUdyaWRSZW5kZXJlci5kZXN0cm95KCk7XHJcbiAgICAgICAgdGhpcy5fcmV2ZXJzZVByaW9yaXR5R3JpZFJlbmRlcmVyLmRlc3Ryb3koKTtcclxuICAgICAgICB0aGlzLl9jYW1lcmEub25VcGRhdGUucmVtb3ZlTGlzdGVuZXIodGhpcy5fc2NlbmVVcGRhdGVMaXN0ZW5lcik7XHJcbiAgICAgICAgZm9yIChjb25zdCBwcmltaXRpdmVQcm92aWRlciBvZiB0aGlzLl9wcmltaXRpdmVQcm92aWRlcnMpIHtcclxuICAgICAgICAgICAgcHJpbWl0aXZlUHJvdmlkZXIub25VcGRhdGUucmVtb3ZlTGlzdGVuZXIodGhpcy5fc2NlbmVVcGRhdGVMaXN0ZW5lcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX29uU2NlbmVVcGRhdGUoKSB7XHJcbiAgICAgICAgdGhpcy5fbGFzdFNjZW5lVXBkYXRlVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgICAgIHRoaXMuX3JlbmRlckxvb3AudXBkYXRlKCk7XHJcbiAgICB9XHJcbiAgICBfb25CZWZvcmVSZW5kZXIoKSB7XHJcbiAgICAgICAgdGhpcy5faXNEaXJ0eSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0cyB2aXNpYmlsaXR5IHRleHR1cmUgdG8gaXRzIGluaXRpYWwgc3RhdGUuXHJcbiAgICAgKi9cclxuICAgIF9jbGVhclZpc2liaWxpdHkodGFyZ2V0KSB7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kUmVuZGVyU3RhdGUoVklTSUJJTElUWV9JTklUX1NUQVRFKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRSZW5kZXJUYXJnZXQodGFyZ2V0KTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmNsZWFyQ3VycmVudFRhcmdldCgxNjM4NCAvKiBDT0xPUl9CVUZGRVJfQklUICovKTtcclxuICAgIH1cclxuICAgIF9kZXN0cm95R3JpZFJlc291cmNlcygpIHtcclxuICAgICAgICB0aGlzLl9ncmlkU2FtcGxlclZlcnRleEJ1ZmZlci5kZXN0cm95KCk7XHJcbiAgICAgICAgdGhpcy5fZ3JpZFNhbXBsZXJWYW8uZGVzdHJveSgpO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IEF0dHJpYnV0ZU1hcHBpbmcgfSBmcm9tICcuLi9yZW5kZXIvYXR0cmliX21hcHBpbmcnO1xyXG5pbXBvcnQgQnVmZmVyV3JpdGVyIGZyb20gJy4uL3V0aWwvYnVmZmVyX3dyaXRlcic7XHJcbmltcG9ydCB7IGZsb2F0VG9VaW50MTYgfSBmcm9tICcuLi91dGlsL2dwdXR5cGVzJztcclxuZXhwb3J0IGNvbnN0IEFUVFJJQlVURV9NQVBQSU5HID0gbmV3IEF0dHJpYnV0ZU1hcHBpbmcoW1xyXG4gICAgW1xyXG4gICAgICAgIDAgLyogUE9TSVRJT04gKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIzIC8qIFVOU0lHTkVEX1NIT1JUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXVxyXG5dKTtcclxuLyoqXHJcbiAqIFdyaXRlcyBzYW1wbGVyIHBvc2l0aW9ucyBpbnRvIHZlcnRleCBidWZmZXIgYXMgYSByZWd1bGFyIGdyaWQgd2l0aCB0aGUgc3RlcCBlcXVhbCB0byB0aGUgc2l6ZSBvZiBhIGdyaWQgY2VsbC5cclxuICogVGhlIG51bWJlciBvZiB2ZXJ0aWNlcyAoc2FtcGxlcnMpIGlzIGVxdWFsIHRvIFwid2lkdGggeCBoZWlnaHRcIi5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdyaWRTYW1wbGVyQnVmZmVyV3JpdGVyIGV4dGVuZHMgQnVmZmVyV3JpdGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICBjb25zdCBudW1iZXJPZlNhbXBsZXJzID0gd2lkdGggKiBoZWlnaHQ7XHJcbiAgICAgICAgc3VwZXIoQVRUUklCVVRFX01BUFBJTkcudmVydGV4Qnl0ZVNpemUsIG51bWJlck9mU2FtcGxlcnMsIHVuZGVmaW5lZCwgMCk7XHJcbiAgICAgICAgY29uc3QgY29sU3RlcCA9IGZsb2F0VG9VaW50MTYoMS4wIC8gd2lkdGgpO1xyXG4gICAgICAgIGNvbnN0IHJvd1N0ZXAgPSBmbG9hdFRvVWludDE2KDEuMCAvIGhlaWdodCk7XHJcbiAgICAgICAgY29uc3QgY29sSGFsZlN0ZXAgPSBjb2xTdGVwIC8gMjtcclxuICAgICAgICBjb25zdCByb3dIYWxmU3RlcCA9IHJvd1N0ZXAgLyAyO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBjb2wgPSBjb2xIYWxmU3RlcDsgaSA8IHdpZHRoOyBpKyssIGNvbCArPSBjb2xTdGVwKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwLCByb3cgPSByb3dIYWxmU3RlcDsgaiA8IGhlaWdodDsgaisrLCByb3cgKz0gcm93U3RlcCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fd3JpdGVIYWxmV29yZHMoY29sLCByb3cpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZGF0YSA9IHRoaXMuZ2V0QnVmZmVycygpWzBdLnZlcnRleEJ1ZmZlcjtcclxuICAgICAgICB0aGlzLm51bWJlck9mU2FtcGxlcnMgPSBudW1iZXJPZlNhbXBsZXJzO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IEdsUmVuZGVyZXIgfSBmcm9tICcuLi9yZW5kZXIvZ2xfcmVuZGVyZXInO1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHcmlkUmVuZGVyZXIgZXh0ZW5kcyBHbFJlbmRlcmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIHJlbmRlclN0YXRlKSB7XHJcbiAgICAgICAgc3VwZXIoY29udGV4dCwgcmVuZGVyU3RhdGUpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlR3JpZCguLi5hcmdzKSB7XHJcbiAgICAgICAgdGhpcy5yZW5kZXIodGhpcy5fdGFyZ2V0LCAuLi5hcmdzKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdGV4dHVyZTtcclxuICAgIH1cclxuICAgIF9yZW5kZXIodmlld1Byb2pNYXRyaXgsIGNhbWVyYVBvc2l0aW9ucywgcmVuZGVyZXJzLCBzdGFiaWxpdHlTaGlmdCwgcHJldlZpc2liaWxpdHksIGN1cnJlbnRab29tKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCByZW5kZXJlciBvZiByZW5kZXJlcnMpIHtcclxuICAgICAgICAgICAgcmVuZGVyZXIucmVuZGVyKHRoaXMuX3RhcmdldCwgdmlld1Byb2pNYXRyaXgsIGNhbWVyYVBvc2l0aW9ucywgdGhpcy5fcmVuZGVyU3RhdGUsIHN0YWJpbGl0eVNoaWZ0LCBwcmV2VmlzaWJpbGl0eSwgY3VycmVudFpvb20pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyByZXNvbHV0aW9uIG9mIHRoZSBncmlkLlxyXG4gICAgICovXHJcbiAgICBzZXRSZXNvbHV0aW9uKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICB0aGlzLl9kZXN0cm95UmVzb3VyY2VzKCk7XHJcbiAgICAgICAgdGhpcy5fZGVwdGhCdWZmZXIgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZVJlbmRlcmJ1ZmZlcih3aWR0aCwgaGVpZ2h0LCAzNDA0MSAvKiBERVBUSF9TVEVOQ0lMICovKTtcclxuICAgICAgICB0aGlzLl90ZXh0dXJlID0gdGhpcy5fY29udGV4dC5jcmVhdGVFbXB0eTJEVGV4dHVyZSh3aWR0aCwgaGVpZ2h0LCA2NDA4IC8qIFJHQkEgKi8sIDUxMjEgLyogVU5TSUdORURfQllURSAqLyk7XHJcbiAgICAgICAgdGhpcy5fdGFyZ2V0ID0gdGhpcy5fY29udGV4dC5jcmVhdGVGcmFtZWJ1ZmZlcih7IGNvbG9yOiB0aGlzLl90ZXh0dXJlLCBkZXB0aFN0ZW5jaWw6IHRoaXMuX2RlcHRoQnVmZmVyIH0pO1xyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLl9kZXN0cm95UmVzb3VyY2VzKCk7XHJcbiAgICB9XHJcbiAgICBfcHJlcGFyZVJlbmRlclRhcmdldCh0YXJnZXQsIC4uLmFyZ3MpIHtcclxuICAgICAgICBzdXBlci5fcHJlcGFyZVJlbmRlclRhcmdldCh0YXJnZXQsIC4uLmFyZ3MpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuY2xlYXJDdXJyZW50VGFyZ2V0KDE2Mzg0IC8qIENPTE9SX0JVRkZFUl9CSVQgKi8gfCAyNTYgLyogREVQVEhfQlVGRkVSX0JJVCAqLyk7XHJcbiAgICB9XHJcbiAgICBfZGVzdHJveVJlc291cmNlcygpIHtcclxuICAgICAgICBpZiAodGhpcy5fdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldC5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3RleHR1cmUuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9kZXB0aEJ1ZmZlci5kZXN0cm95KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsIi8qKlxyXG4gKiBPbmUgb2YgdGhlIHN0ZXBzIG9mIHByaW1pdGl2ZXMgdmlzaWJpbGl0eSByZXNvbHV0aW9uIHByb2Nlc3MuIEJhc2ljYWxseSBpdCBkb2VzIG5vdGhpbmcsIGp1c3QgY2FsbCBhcHByb3ByaWF0ZVxyXG4gKiBtZXRob2RzIG9mIENvbGxpZGluZ1ByaW1pdGl2ZVJlbmRlcmVyJ3MsIGJ1dCBpdCBleHBlY3RzIHRoYXQgdGhlc2UgcmVuZGVyZXJzIHdpbGwgY29weSB2aXNpYmlsaXR5IHZhbHVlIG9mIGFjdHVhbFxyXG4gKiBwcmltaXRpdmVzIG9ubHksIHRodXMgcmVtb3ZlZCBwcmltaXRpdmUncyB2YWx1ZXMgd2lsbCBiZSByZXNldCAob3ZlcmxhcCB6b29tIGNsZWFyZWQgYW5kIGFsbCB0aGF0KS4gSXQgaXMgaW1wb3J0YW50XHJcbiAqIGZvciByZXVzaW5nIHRoZXNlIGlkcyBmb3IgZnV0dXJlIHByaW1pdGl2ZXMuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZXNldFJlbW92ZWRQcmltaXRpdmVzIHtcclxuICAgIHJlbmRlcih0YXJnZXQsIHJlbmRlcmVycywgcHJldlZpc2liaWxpdHksIGlkSGFsZlB4U2l6ZVVuaWZvcm0pIHtcclxuICAgICAgICBmb3IgKGNvbnN0IHJlbmRlcmVyIG9mIHJlbmRlcmVycykge1xyXG4gICAgICAgICAgICByZW5kZXJlci5yZW5kZXIodGFyZ2V0LCBwcmV2VmlzaWJpbGl0eSwgaWRIYWxmUHhTaXplVW5pZm9ybSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCBmYWRlb3V0QWxsVmVydGV4U2hhZGVyIGZyb20gJy4vc2hhZGVycy9mYWRlb3V0X2FsbC52ZXJ0JztcclxuaW1wb3J0IGZhZGVvdXRBbGxGcmFnbWVudFNoYWRlciBmcm9tICcuL3NoYWRlcnMvZmFkZW91dF9hbGwuZnJhZyc7XHJcbmltcG9ydCB7IEdsUmVuZGVyZXIgfSBmcm9tICcuLi8uLi9yZW5kZXIvZ2xfcmVuZGVyZXInO1xyXG5pbXBvcnQgUmVuZGVyU3RhdGUgZnJvbSAnLi4vLi4vcmVuZGVyL3N0YXRlJztcclxuaW1wb3J0IElkU2FtcGxlckJ1ZmZlcldyaXRlciwgeyBBVFRSSUJVVEVfTUFQUElORyB9IGZyb20gJy4uL2lkX3NhbXBsZXJfYnVmZmVyX3dyaXRlcic7XHJcbmNvbnN0IFNUQVRFID0gbmV3IFJlbmRlclN0YXRlKHtcclxuICAgIGRpdGhlcjogZmFsc2VcclxufSk7XHJcbi8qKlxyXG4gKiBPbmUgb2YgdGhlIHN0ZXBzIG9mIHByaW1pdGl2ZXMgdmlzaWJpbGl0eSByZXNvbHV0aW9uIHByb2Nlc3MuIEl0IHNhbXBsZXMgYWxsIHZpc2liaWxpdHkgdmFsdWVzIGFuZCBzdWJ0cmFjdFxyXG4gKiBkZWx0YSAoZmFkZW91dEFtb3VudCkgZnJvbSB0aGVtLCB0aGVzZSBuZXcgdmFsdWVzIGFyZSBzdG9yZWQgaW50byBjdXJyZW50IHZpc2liaWxpdHkgdGV4dHVyZS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZhZGVvdXRBbGwgZXh0ZW5kcyBHbFJlbmRlcmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcclxuICAgICAgICBjb25zdCBwcm9ncmFtID0gY29udGV4dC5jcmVhdGVQcm9ncmFtKGZhZGVvdXRBbGxWZXJ0ZXhTaGFkZXIsIGZhZGVvdXRBbGxGcmFnbWVudFNoYWRlciwge1xyXG4gICAgICAgICAgICBhdHRyaWJNYXA6IHtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAwIC8qIFBPU0lUSU9OICovXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBzdXBlcihjb250ZXh0LCBTVEFURSwgcHJvZ3JhbSk7XHJcbiAgICAgICAgY29uc3QgaWRTYW1wbGVyQnVmZmVyV3JpdGVyID0gbmV3IElkU2FtcGxlckJ1ZmZlcldyaXRlcigpO1xyXG4gICAgICAgIHRoaXMuX2lkU2FtcGxlclZlcnRleEJ1ZmZlciA9IHRoaXMuX2NvbnRleHQuY3JlYXRlVmVydGV4QnVmZmVyKGlkU2FtcGxlckJ1ZmZlcldyaXRlci52ZXJ0ZXhEYXRhLmJ5dGVMZW5ndGgpO1xyXG4gICAgICAgIHRoaXMuX2lkU2FtcGxlckluZGV4QnVmZmVyID0gdGhpcy5fY29udGV4dC5jcmVhdGVJbmRleEJ1ZmZlcihpZFNhbXBsZXJCdWZmZXJXcml0ZXIuaW5kZXhEYXRhLmJ5dGVMZW5ndGgpO1xyXG4gICAgICAgIHRoaXMuX2lkU2FtcGxlclZhbyA9IHRoaXMuX2NvbnRleHQuY3JlYXRlVmFvKEFUVFJJQlVURV9NQVBQSU5HLCB0aGlzLl9pZFNhbXBsZXJWZXJ0ZXhCdWZmZXIsIHRoaXMuX2lkU2FtcGxlckluZGV4QnVmZmVyKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LnVwbG9hZERhdGFUb0J1ZmZlcih0aGlzLl9pZFNhbXBsZXJWZXJ0ZXhCdWZmZXIsIGlkU2FtcGxlckJ1ZmZlcldyaXRlci52ZXJ0ZXhEYXRhKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LnVwbG9hZERhdGFUb0J1ZmZlcih0aGlzLl9pZFNhbXBsZXJJbmRleEJ1ZmZlciwgaWRTYW1wbGVyQnVmZmVyV3JpdGVyLmluZGV4RGF0YSk7XHJcbiAgICAgICAgY29udGV4dC5iaW5kUHJvZ3JhbShwcm9ncmFtKTtcclxuICAgICAgICBwcm9ncmFtLnNldEludFNjYWxhclVuaWZvcm0oJ3ByZXZWaXNpYmlsaXR5JywgMCk7XHJcbiAgICB9XHJcbiAgICBfcHJlcGFyZVByb2dyYW0ocHJvZ3JhbSwgcHJldlZpc2liaWxpdHksIGZhZGVvdXRBbW91bnQpIHtcclxuICAgICAgICBzdXBlci5fcHJlcGFyZVByb2dyYW0ocHJvZ3JhbSwgcHJldlZpc2liaWxpdHksIGZhZGVvdXRBbW91bnQpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFRleHR1cmVVbml0KDApO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFRleHR1cmUocHJldlZpc2liaWxpdHkpO1xyXG4gICAgICAgIHByb2dyYW0uc2V0U2NhbGFyVW5pZm9ybSgnZmFkZW91dEFtb3VudCcsIGZhZGVvdXRBbW91bnQpO1xyXG4gICAgfVxyXG4gICAgX3JlbmRlcigpIHtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRWYW8odGhpcy5faWRTYW1wbGVyVmFvKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmRyYXdJbmRleGVkTWVzaCgwLCA2LCA0IC8qIFRSSUFOR0xFUyAqLyk7XHJcbiAgICB9XHJcbn1cclxuIiwibW9kdWxlLmV4cG9ydHMgPSBcIiN2ZXJzaW9uIDEwMFxcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxuYXR0cmlidXRlIHZlYzQgcG9zaXRpb247XFxuXFxudmFyeWluZyB2ZWMyIGlkVGV4Q29vcmRpbmF0ZXM7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICBnbF9Qb3NpdGlvbiA9IHZlYzQocG9zaXRpb24ueHksIDAsIDEpO1xcbiAgICBpZFRleENvb3JkaW5hdGVzID0gcG9zaXRpb24uenc7XFxufVxcblwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIiN2ZXJzaW9uIDEwMFxcblxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgcHJldlZpc2liaWxpdHk7XFxudW5pZm9ybSBmbG9hdCBmYWRlb3V0QW1vdW50O1xcblxcbnZhcnlpbmcgdmVjMiBpZFRleENvb3JkaW5hdGVzO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgdmVjNCB2aXNpYmlsaXR5VmFsdWUgPSB0ZXh0dXJlMkQocHJldlZpc2liaWxpdHksIGlkVGV4Q29vcmRpbmF0ZXMpO1xcbiAgICB2aXNpYmlsaXR5VmFsdWUuYSA9IGNsYW1wKHZpc2liaWxpdHlWYWx1ZS5hIC0gZmFkZW91dEFtb3VudCwgMC4wLCAxLjApO1xcblxcbiAgICBnbF9GcmFnQ29sb3IgPSB2aXNpYmlsaXR5VmFsdWU7XFxufVxcblwiIiwiaW1wb3J0IHsgQXR0cmlidXRlTWFwcGluZyB9IGZyb20gJy4uL3JlbmRlci9hdHRyaWJfbWFwcGluZyc7XHJcbmltcG9ydCBCdWZmZXJXcml0ZXIgZnJvbSAnLi4vdXRpbC9idWZmZXJfd3JpdGVyJztcclxuZXhwb3J0IGNvbnN0IEFUVFJJQlVURV9NQVBQSU5HID0gbmV3IEF0dHJpYnV0ZU1hcHBpbmcoW1xyXG4gICAgW1xyXG4gICAgICAgIDAgLyogUE9TSVRJT04gKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiA0LFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIwIC8qIEJZVEUgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgXVxyXG5dKTtcclxuLyoqXHJcbiAqIFdyaXRlIHZlcnRpY2VzIG9mIHR3byB0cmlhbmdsZXMgdGhhdCBmdWxseSBjb3ZlciB2aXNpYmlsaXR5IHRleHR1cmUsIGl0cyB2YWx1ZXMgY2FuIGJlIHNhbXBsZWQgaW4gZnJhZ21lbnQgc2hhZGVycy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElkU2FtcGxlckJ1ZmZlcldyaXRlciBleHRlbmRzIEJ1ZmZlcldyaXRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcihBVFRSSUJVVEVfTUFQUElORy52ZXJ0ZXhCeXRlU2l6ZSwgNCwgNCwgNik7XHJcbiAgICAgICAgLy8gd2luZG93IHgsIHdpbmRvdyB5LCB0ZXh0dXJlIHgsIHRleHR1cmUgeVxyXG4gICAgICAgIHRoaXMuX3dyaXRlQnl0ZXMoLTEsIC0xLCAwLCAwKTtcclxuICAgICAgICB0aGlzLl93cml0ZUJ5dGVzKC0xLCAxLCAwLCAxKTtcclxuICAgICAgICB0aGlzLl93cml0ZUJ5dGVzKDEsIDEsIDEsIDEpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlQnl0ZXMoMSwgLTEsIDEsIDApO1xyXG4gICAgICAgIHRoaXMud3JpdGVJbmRpY2VzRm9yRmFuKFswLCAxLCAyLCAzXSk7XHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhEYXRhID0gdGhpcy5nZXRCdWZmZXJzKClbMF0udmVydGV4QnVmZmVyO1xyXG4gICAgICAgIHRoaXMuaW5kZXhEYXRhID0gdGhpcy5nZXRCdWZmZXJzKClbMF0uaW5kZXhCdWZmZXI7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgR2xSZW5kZXJlciB9IGZyb20gJy4uLy4uL3JlbmRlci9nbF9yZW5kZXJlcic7XHJcbmltcG9ydCBmYWRlaW5WaXNpYmxlVmVydGV4U2hhZGVyIGZyb20gJy4vc2hhZGVycy9mYWRlaW5fdmlzaWJsZS52ZXJ0JztcclxuaW1wb3J0IGZhZGVpblZpc2libGVGcmFnbWVudFNoYWRlciBmcm9tICcuL3NoYWRlcnMvZmFkZWluX3Zpc2libGUuZnJhZyc7XHJcbmltcG9ydCBSZW5kZXJTdGF0ZSBmcm9tICcuLi8uLi9yZW5kZXIvc3RhdGUnO1xyXG5jb25zdCBTVEFURSA9IG5ldyBSZW5kZXJTdGF0ZSh7XHJcbiAgICBkaXRoZXI6IGZhbHNlXHJcbn0pO1xyXG4vKipcclxuICogT25lIG9mIHRoZSBzdGVwcyBvZiBwcmltaXRpdmVzIHZpc2liaWxpdHkgcmVzb2x1dGlvbiBwcm9jZXNzLiBJdCBzYW1wbGVzIGFsbCBwaXhlbHMgb2YgdGhlIHNjZW5lIChyZW5kZXJlZCBpbiBkaXJlY3RcclxuICogcHJpb3JpdHkgb3JkZXIgaW50byBzaW1wbGlmaWVkIGdyaWQpIGFuZCBhZGRzIGRlbHRhIChmYWRlaW5BbW91bnQpIHRvIGFscGhhIHZpc2liaWxpdHkgb2YgcHJpbWl0aXZlIHdpdGhcclxuICogaWQgaW4gdGhpcyBwaXhlbC4gVGhvc2UgcHJpbWl0aXZlcyBhcmUgY29uc2lkZXJlZCB2aXNpYmxlLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmFkZWluVmlzaWJsZSBleHRlbmRzIEdsUmVuZGVyZXIge1xyXG4gICAgY29uc3RydWN0b3IoY29udGV4dCkge1xyXG4gICAgICAgIGNvbnN0IHByb2dyYW0gPSBjb250ZXh0LmNyZWF0ZVByb2dyYW0oZmFkZWluVmlzaWJsZVZlcnRleFNoYWRlciwgZmFkZWluVmlzaWJsZUZyYWdtZW50U2hhZGVyLCB7XHJcbiAgICAgICAgICAgIGF0dHJpYk1hcDoge1xyXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IDAgLyogUE9TSVRJT04gKi9cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHN1cGVyKGNvbnRleHQsIFNUQVRFLCBwcm9ncmFtKTtcclxuICAgICAgICBjb250ZXh0LmJpbmRQcm9ncmFtKHByb2dyYW0pO1xyXG4gICAgICAgIHByb2dyYW0uc2V0SW50U2NhbGFyVW5pZm9ybSgnZGlyZWN0UHJpb3JpdHlHcmlkJywgMCk7XHJcbiAgICAgICAgcHJvZ3JhbS5zZXRJbnRTY2FsYXJVbmlmb3JtKCdwcmV2VmlzaWJpbGl0eScsIDEpO1xyXG4gICAgfVxyXG4gICAgX3ByZXBhcmVQcm9ncmFtKHByb2dyYW0sIGRhdGEsIHNhbXBsZXJzLCBkaXJlY3RQcmlvcml0eUdyaWQsIHByZXZWaXNpYmlsaXR5LCBpZEhhbGZQeFNpemUsIGZhZGVpbkFtb3VudCkge1xyXG4gICAgICAgIHN1cGVyLl9wcmVwYXJlUHJvZ3JhbShwcm9ncmFtLCBkYXRhLCBzYW1wbGVycywgZGlyZWN0UHJpb3JpdHlHcmlkLCBwcmV2VmlzaWJpbGl0eSwgaWRIYWxmUHhTaXplLCBmYWRlaW5BbW91bnQpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFRleHR1cmVVbml0KDApO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFRleHR1cmUoZGlyZWN0UHJpb3JpdHlHcmlkKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRUZXh0dXJlVW5pdCgxKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRUZXh0dXJlKHByZXZWaXNpYmlsaXR5KTtcclxuICAgICAgICBwcm9ncmFtLnNldFZlY3RvcjJVbmlmb3JtKCdpZEhhbGZQeFNpemUnLCBpZEhhbGZQeFNpemUpO1xyXG4gICAgICAgIHByb2dyYW0uc2V0U2NhbGFyVW5pZm9ybSgnZmFkZWluQW1vdW50JywgZmFkZWluQW1vdW50KTtcclxuICAgIH1cclxuICAgIF9yZW5kZXIoZGF0YSwgbnVtYmVyT2ZTYW1wbGVycykge1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFZhbyhkYXRhKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmRyYXdNZXNoKDAsIG51bWJlck9mU2FtcGxlcnMsIDAgLyogUE9JTlRTICovKTtcclxuICAgIH1cclxufVxyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiI3ZlcnNpb24gMTAwXFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG5hdHRyaWJ1dGUgdmVjMiBwb3NpdGlvbjtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCBkaXJlY3RQcmlvcml0eUdyaWQ7XFxudW5pZm9ybSBzYW1wbGVyMkQgcHJldlZpc2liaWxpdHk7XFxudW5pZm9ybSB2ZWMyIGlkSGFsZlB4U2l6ZTtcXG51bmlmb3JtIGZsb2F0IGZhZGVpbkFtb3VudDtcXG5cXG52YXJ5aW5nIGxvd3AgdmVjNCB2aXNpYmlsaXR5VmFsdWU7XFxuXFxuY29uc3QgdmVjMiBOT19JRCA9IHZlYzIoMCwgMCk7XFxuY29uc3QgdmVjNCBESVNDQVJEX1BPU0lUSU9OID0gdmVjNCgyLCAyLCAyLCAxKTtcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIHZlYzIgcHJpbWl0aXZlSWQgPSB0ZXh0dXJlMkQoZGlyZWN0UHJpb3JpdHlHcmlkLCBwb3NpdGlvbikucmc7XFxuXFxuICAgIGlmIChwcmltaXRpdmVJZCAhPSBOT19JRCkge1xcbiAgICAgICAgdmVjMiBpZFRleENvb3JkaW5hdGVzID0gcHJpbWl0aXZlSWQgKyBpZEhhbGZQeFNpemU7XFxuICAgICAgICB2ZWM0IGlkV2luZG93Q29vcmRpbmF0ZXMgPSB2ZWM0KGlkVGV4Q29vcmRpbmF0ZXMgKiAyLjAgLSAxLjAsIDAsIDEpO1xcbiAgICAgICAgZ2xfUG9zaXRpb24gPSBpZFdpbmRvd0Nvb3JkaW5hdGVzO1xcbiAgICAgICAgZ2xfUG9pbnRTaXplID0gMS4wO1xcblxcbiAgICAgICAgdmlzaWJpbGl0eVZhbHVlID0gdGV4dHVyZTJEKHByZXZWaXNpYmlsaXR5LCBpZFRleENvb3JkaW5hdGVzKTtcXG4gICAgICAgIHZpc2liaWxpdHlWYWx1ZS5hID0gY2xhbXAodmlzaWJpbGl0eVZhbHVlLmEgKyBmYWRlaW5BbW91bnQsIDAuMCwgMS4wKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIGdsX1Bvc2l0aW9uID0gRElTQ0FSRF9QT1NJVElPTjtcXG4gICAgfVxcbn1cXG5cIiIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbnZhcnlpbmcgbG93cCB2ZWM0IHZpc2liaWxpdHlWYWx1ZTtcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIGdsX0ZyYWdDb2xvciA9IHZpc2liaWxpdHlWYWx1ZTtcXG59XFxuXCIiLCJpbXBvcnQgeyBHbFJlbmRlcmVyIH0gZnJvbSAnLi4vLi4vcmVuZGVyL2dsX3JlbmRlcmVyJztcclxuaW1wb3J0IGZhZGVvdXRPdmVybGFwcGVkVmVydGV4U2hhZGVyIGZyb20gJy4vc2hhZGVycy9mYWRlb3V0X292ZXJsYXBwZWQudmVydCc7XHJcbmltcG9ydCBmYWRlb3V0T3ZlcmxhcHBlZEZyYWdtZW50U2hhZGVyIGZyb20gJy4vc2hhZGVycy9mYWRlb3V0X292ZXJsYXBwZWQuZnJhZyc7XHJcbmltcG9ydCBSZW5kZXJTdGF0ZSBmcm9tICcuLi8uLi9yZW5kZXIvc3RhdGUnO1xyXG5jb25zdCBTVEFURSA9IG5ldyBSZW5kZXJTdGF0ZSh7IGRpdGhlcjogZmFsc2UgfSk7XHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZhZGVvdXRPdmVybGFwcGVkIGV4dGVuZHMgR2xSZW5kZXJlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XHJcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IGNvbnRleHQuY3JlYXRlUHJvZ3JhbShmYWRlb3V0T3ZlcmxhcHBlZFZlcnRleFNoYWRlciwgZmFkZW91dE92ZXJsYXBwZWRGcmFnbWVudFNoYWRlciwge1xyXG4gICAgICAgICAgICBhdHRyaWJNYXA6IHtcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAwIC8qIFBPU0lUSU9OICovXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBzdXBlcihjb250ZXh0LCBTVEFURSwgcHJvZ3JhbSk7XHJcbiAgICAgICAgY29udGV4dC5iaW5kUHJvZ3JhbShwcm9ncmFtKTtcclxuICAgICAgICBwcm9ncmFtLnNldEludFNjYWxhclVuaWZvcm0oJ2RpcmVjdFByaW9yaXR5R3JpZCcsIDApO1xyXG4gICAgICAgIHByb2dyYW0uc2V0SW50U2NhbGFyVW5pZm9ybSgncmV2ZXJzZVByaW9yaXR5R3JpZCcsIDEpO1xyXG4gICAgICAgIHByb2dyYW0uc2V0SW50U2NhbGFyVW5pZm9ybSgncHJldlZpc2liaWxpdHknLCAyKTtcclxuICAgIH1cclxuICAgIF9wcmVwYXJlUHJvZ3JhbShwcm9ncmFtLCBkYXRhLCBzYW1wbGVycywgZGlyZWN0UHJpb3JpdHksIHJldmVyc2VQcmlvcml0eSwgcHJldlZpc2liaWxpdHksIGlkSGFsZlB4U2l6ZSwgZmFkZW91dEFtb3VudCwgY3VycmVudFpvb20pIHtcclxuICAgICAgICBzdXBlci5fcHJlcGFyZVByb2dyYW0ocHJvZ3JhbSwgZGF0YSwgc2FtcGxlcnMsIGRpcmVjdFByaW9yaXR5LCByZXZlcnNlUHJpb3JpdHksIHByZXZWaXNpYmlsaXR5LCBpZEhhbGZQeFNpemUsIGZhZGVvdXRBbW91bnQsIGN1cnJlbnRab29tKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRUZXh0dXJlVW5pdCgwKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRUZXh0dXJlKGRpcmVjdFByaW9yaXR5KTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRUZXh0dXJlVW5pdCgxKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRUZXh0dXJlKHJldmVyc2VQcmlvcml0eSk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kVGV4dHVyZVVuaXQoMik7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kVGV4dHVyZShwcmV2VmlzaWJpbGl0eSk7XHJcbiAgICAgICAgcHJvZ3JhbS5zZXRWZWN0b3IyVW5pZm9ybSgnaWRIYWxmUHhTaXplJywgaWRIYWxmUHhTaXplKTtcclxuICAgICAgICBwcm9ncmFtLnNldFNjYWxhclVuaWZvcm0oJ2ZhZGVvdXRBbW91bnQnLCBmYWRlb3V0QW1vdW50KTtcclxuICAgICAgICBwcm9ncmFtLnNldFNjYWxhclVuaWZvcm0oJ2N1cnJlbnRab29tJywgY3VycmVudFpvb20pO1xyXG4gICAgfVxyXG4gICAgX3JlbmRlcihkYXRhLCBudW1iZXJPZlNhbXBsZXJzKSB7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kVmFvKGRhdGEpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuZHJhd01lc2goMCwgbnVtYmVyT2ZTYW1wbGVycywgMCAvKiBQT0lOVFMgKi8pO1xyXG4gICAgfVxyXG59XHJcbiIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbmF0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uO1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIGRpcmVjdFByaW9yaXR5R3JpZDtcXG51bmlmb3JtIHNhbXBsZXIyRCByZXZlcnNlUHJpb3JpdHlHcmlkO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHByZXZWaXNpYmlsaXR5O1xcbnVuaWZvcm0gdmVjMiBpZEhhbGZQeFNpemU7XFxudW5pZm9ybSBmbG9hdCBmYWRlb3V0QW1vdW50O1xcbnVuaWZvcm0gZmxvYXQgY3VycmVudFpvb207XFxuXFxudmFyeWluZyB2ZWM0IHZpc2liaWxpdHlWYWx1ZTtcXG5cXG5jb25zdCB2ZWMyIE5PX0lEID0gdmVjMigwLCAwKTtcXG5jb25zdCB2ZWM0IERJU0NBUkRfUE9TSVRJT04gPSB2ZWM0KDIsIDIsIDIsIDEpO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgdmVjMiBwcmltaXRpdmVJZFJldmVyc2VQcmlvcml0eSA9IHRleHR1cmUyRChyZXZlcnNlUHJpb3JpdHlHcmlkLCBwb3NpdGlvbikucmc7XFxuXFxuICAgIGlmIChcXG4gICAgICAgIHByaW1pdGl2ZUlkUmV2ZXJzZVByaW9yaXR5ICE9IE5PX0lEICYmXFxuICAgICAgICBwcmltaXRpdmVJZFJldmVyc2VQcmlvcml0eSAhPSB0ZXh0dXJlMkQoZGlyZWN0UHJpb3JpdHlHcmlkLCBwb3NpdGlvbikucmdcXG4gICAgKSB7XFxuICAgICAgICB2ZWMyIGlkVGV4Q29vcmRpbmF0ZXMgPSBwcmltaXRpdmVJZFJldmVyc2VQcmlvcml0eSArIGlkSGFsZlB4U2l6ZTtcXG4gICAgICAgIHZlYzQgaWRXaW5kb3dDb29yZGluYXRlcyA9IHZlYzQoaWRUZXhDb29yZGluYXRlcyAqIDIuMCAtIDEuMCwgMCwgMSk7XFxuXFxuICAgICAgICBnbF9Qb3NpdGlvbiA9IGlkV2luZG93Q29vcmRpbmF0ZXM7XFxuICAgICAgICBnbF9Qb2ludFNpemUgPSAxLjA7XFxuXFxuICAgICAgICB2aXNpYmlsaXR5VmFsdWUgPSB0ZXh0dXJlMkQocHJldlZpc2liaWxpdHksIGlkVGV4Q29vcmRpbmF0ZXMpO1xcbiAgICAgICAgdmlzaWJpbGl0eVZhbHVlLmIgPSBjdXJyZW50Wm9vbTtcXG4gICAgICAgIHZpc2liaWxpdHlWYWx1ZS5hID0gY2xhbXAodmlzaWJpbGl0eVZhbHVlLmEgLSBmYWRlb3V0QW1vdW50LCAwLjAsIDEuMCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICBnbF9Qb3NpdGlvbiA9IERJU0NBUkRfUE9TSVRJT047XFxuICAgIH1cXG59XFxuXCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiI3ZlcnNpb24gMTAwXFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG52YXJ5aW5nIGxvd3AgdmVjNCB2aXNpYmlsaXR5VmFsdWU7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICBnbF9GcmFnQ29sb3IgPSB2aXNpYmlsaXR5VmFsdWU7XFxufVxcblwiIiwiaW1wb3J0ICogYXMgdmVjMiBmcm9tICcuLi8uLi9tYXRoL3ZlY3RvcjInO1xyXG5pbXBvcnQgeyB1aW50MTZUb0Zsb2F0IH0gZnJvbSAnLi4vLi4vdXRpbC9ncHV0eXBlcyc7XHJcbmltcG9ydCB7IGNvbXB1dGVTcXVhcmVzQ292ZXJlZEJ5Q29udmV4UG9seWdvbiB9IGZyb20gJy4uLy4uL3V0aWwvY2FydGVzaWFuX2dyaWQnO1xyXG5pbXBvcnQgKiBhcyBhcnJheSBmcm9tICcuLi8uLi91dGlsL2FycmF5JztcclxuLy8gTWFwcyB3b3JsZCBjb29yZGluYXRlcyB0byBjb3JyZXNwb25kaW5nIHBvaW50cyBvbiB0aGUgY2FydGVzaWFuIGdyaWQuXHJcbmNvbnN0IFdPUkxEX01JTl9DT09SRElOQVRFID0gdmVjMi5jcmVhdGUoLTEsIC0xKTtcclxuY29uc3QgR1JJRF9XT1JMRF9SQVRJTyA9IDAuNTtcclxuY29uc3QgR1JJRF9DT09SRElOQVRFU19DT05WRVJURVIgPSAocG9pbnQpID0+IHtcclxuICAgIGNvbnN0IGdyaWRDb29yZGluYXRlcyA9IHZlYzIuY29weShwb2ludCk7XHJcbiAgICB2ZWMyLnN1YihncmlkQ29vcmRpbmF0ZXMsIFdPUkxEX01JTl9DT09SRElOQVRFLCBncmlkQ29vcmRpbmF0ZXMpO1xyXG4gICAgdmVjMi5tdWxuKGdyaWRDb29yZGluYXRlcywgR1JJRF9XT1JMRF9SQVRJTywgZ3JpZENvb3JkaW5hdGVzKTtcclxuICAgIHJldHVybiBncmlkQ29vcmRpbmF0ZXM7XHJcbn07XHJcbmNvbnN0IENBTUVSQV9QT1NJVElPTl9VSU5UMzJfQ09OVkVSVEVSID0gKGNvbXBvbmVudCkgPT4gMC41ICogKGNvbXBvbmVudCArIDEpICogMHhmZmZmZmZmZjtcclxuY29uc3QgSElHSF9DT01QT05FTlRfRVhUUkFDVE9SID0gKGNvbXBvbmVudCkgPT4gdWludDE2VG9GbG9hdChNYXRoLnRydW5jKGNvbXBvbmVudCAvIDB4MTAwMDApKTtcclxuY29uc3QgTE9XX0NPTVBPTkVOVF9FWFRSQUNUT1IgPSAoY29tcG9uZW50KSA9PiB1aW50MTZUb0Zsb2F0KGNvbXBvbmVudCAmIDB4ZmZmZik7XHJcbmNvbnN0IFJFR0lPTl9DT01QQVJBVE9SID0gKGEsIGIpID0+IGEueCAtIGIueCB8fCBhLnkgLSBiLnk7XHJcbmNvbnN0IHRtcENhbWVyYVBvc2l0aW9uID0gdmVjMi5jcmVhdGUoMCwgMCk7XHJcbi8qKlxyXG4gKiBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgd29ybGRzIHZpc2libGUgKGxhcmdlIG1vbml0b3JzL2xvdyB6b29tKSBwcmltaXRpdmVzIGFyZSByZW5kZXJlZCBpbiBtdWx0aXBsZSBwYXNzZXMgZnJvbVxyXG4gKiBkaWZmZXJlbnQgcG9zaXRpb25zIChpZiB0aGUgd3JhcCBtb2RlIG9mIGNvcnJlc3BvbmRpbmcgZGlyZWN0aW9uIGlzIFJFUEVBVCkgdG8gZ2V0IGNvcnJlY3QgZmluYWwgcGljdHVyZS5cclxuICogVGhpcyBtZXRob2QgY2FsY3VsYXRlcyBjYW1lcmEgcG9zaXRpb25zIGFuZCBwcmVwYXJlIHRoZW0gdG8gYmUgcGFzc2VkIHRvIHRoZSByZW5kZXIoKSBtZXRob2QuXHJcbiAqL1xyXG5jb25zdCBjYWNoZWRSZWdpb24gPSBbXTtcclxuY29uc3QgY2FjaGVkUG9zaXRpb25zID0gW107XHJcbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVDYW1lcmFQb3NpdGlvbnMoY2FtZXJhKSB7XHJcbiAgICBjb25zdCB2aXNpYmxlUmVnaW9uID0gY2FtZXJhLmdldFZpc2libGVSZWdpb24oKTtcclxuICAgIGlmIChhcnJheS5jb21wYXJlKFJFR0lPTl9DT01QQVJBVE9SLCBjYWNoZWRSZWdpb24sIHZpc2libGVSZWdpb24pID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGNhY2hlZFBvc2l0aW9ucztcclxuICAgIH1cclxuICAgIGNvbnN0IHBvc2l0aW9ucyA9IFtdO1xyXG4gICAgZm9yIChjb25zdCB3b3JsZFBvc2l0aW9uIG9mIGNvbXB1dGVTcXVhcmVzQ292ZXJlZEJ5Q29udmV4UG9seWdvbih2aXNpYmxlUmVnaW9uLm1hcChHUklEX0NPT1JESU5BVEVTX0NPTlZFUlRFUikpKSB7XHJcbiAgICAgICAgaWYgKChjYW1lcmEub3B0aW9ucy53cmFwTW9kZVggPT09IDIgLyogUkVQRUFUICovIHx8IHdvcmxkUG9zaXRpb24ueCA9PT0gMCkgJiZcclxuICAgICAgICAgICAgKGNhbWVyYS5vcHRpb25zLndyYXBNb2RlWSA9PT0gMiAvKiBSRVBFQVQgKi8gfHwgd29ybGRQb3NpdGlvbi55ID09PSAwKSkge1xyXG4gICAgICAgICAgICAvLyAyLjAgY29udmVydHMgY292ZXJlZCBzcXVhcmUgcG9zaXRpb24gdG8gdGhlIHdvcmxkJ3MgY2VudGVyIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgICAgIC8vIC0xLjAgcmV2ZXJzZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBjYW1lcmEgdG8gc2hvdCB0aGUgd29ybGQgZnJvbVxyXG4gICAgICAgICAgICB2ZWMyLm11bG4od29ybGRQb3NpdGlvbiwgLTEuMCAqIDIuMCwgdG1wQ2FtZXJhUG9zaXRpb24pO1xyXG4gICAgICAgICAgICB2ZWMyLmFkZChjYW1lcmEuY2VudGVyLCB0bXBDYW1lcmFQb3NpdGlvbiwgdG1wQ2FtZXJhUG9zaXRpb24pO1xyXG4gICAgICAgICAgICB2ZWMyLmNvbnZlcnQodG1wQ2FtZXJhUG9zaXRpb24sIENBTUVSQV9QT1NJVElPTl9VSU5UMzJfQ09OVkVSVEVSLCB0bXBDYW1lcmFQb3NpdGlvbik7XHJcbiAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIGxvb2tBdEhpZ2g6IHZlYzIuY29udmVydCh0bXBDYW1lcmFQb3NpdGlvbiwgSElHSF9DT01QT05FTlRfRVhUUkFDVE9SKSxcclxuICAgICAgICAgICAgICAgIGxvb2tBdExvdzogdmVjMi5jb252ZXJ0KHRtcENhbWVyYVBvc2l0aW9uLCBMT1dfQ09NUE9ORU5UX0VYVFJBQ1RPUilcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYXJyYXkuY29weShwb3NpdGlvbnMsIGNhY2hlZFBvc2l0aW9ucyk7XHJcbiAgICBjYWNoZWRQb3NpdGlvbnMubGVuZ3RoID0gcG9zaXRpb25zLmxlbmd0aDtcclxuICAgIGNhY2hlZFJlZ2lvbi5sZW5ndGggPSB2aXNpYmxlUmVnaW9uLmxlbmd0aDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmlzaWJsZVJlZ2lvbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNhY2hlZFJlZ2lvbltpXSA9IHZlYzIuY29weSh2aXNpYmxlUmVnaW9uW2ldLCBjYWNoZWRSZWdpb25baV0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBvc2l0aW9ucztcclxufVxyXG4iLCJpbXBvcnQgKiBhcyB2ZWMyIGZyb20gJy4uL21hdGgvdmVjdG9yMic7XHJcbmltcG9ydCB7IGNvbXB1dGVCQm94Rm9yUG9pbnRzIH0gZnJvbSAnLi4vbWF0aC92ZWN0b3IyJztcclxuLyoqXHJcbiAqIENvbnRhaW5lciBvZiBpbmRleGVkIG1pbi9tYXggdmFsdWVzIHdpdGggYSBzaW5nbGUgdXBkYXRlIG1ldGhvZC5cclxuICovXHJcbmNsYXNzIEV4dHJlbXVtU3RvcmFnZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgpIHtcclxuICAgICAgICB0aGlzLl9taW5zID0gbmV3IEFycmF5KGxlbmd0aCk7XHJcbiAgICAgICAgdGhpcy5fbWF4cyA9IG5ldyBBcnJheShsZW5ndGgpO1xyXG4gICAgICAgIHRoaXMuX21pbnMuZmlsbChOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xyXG4gICAgICAgIHRoaXMuX21heHMuZmlsbChOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlVmFsdWUoaW5kZXgsIHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fbWluc1tpbmRleF0gPSBNYXRoLm1pbih0aGlzLl9taW5zW2luZGV4XSwgdmFsdWUpO1xyXG4gICAgICAgIHRoaXMuX21heHNbaW5kZXhdID0gTWF0aC5tYXgodGhpcy5fbWF4c1tpbmRleF0sIHZhbHVlKTtcclxuICAgIH1cclxuICAgICp2YWx1ZXMoKSB7XHJcbiAgICAgICAgY29uc3QgaXRlbSA9IHsgbWluOiAwLCBtYXg6IDAsIGluZGV4OiAtMSB9O1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbWlucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpdGVtLm1pbiA9IHRoaXMuX21pbnNbaV07XHJcbiAgICAgICAgICAgIGl0ZW0ubWF4ID0gdGhpcy5fbWF4c1tpXTtcclxuICAgICAgICAgICAgaXRlbS5pbmRleCA9IGk7XHJcbiAgICAgICAgICAgIHlpZWxkIGl0ZW07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBTcXVhcmVzIHRoYXQgYXJlIG9ueSB0b3VjaGVkIGJ5IGEgbGluZSAod2l0aCBubyBzaWduaWZpY2FudCBjcm9zc2luZyBhbiBlZGdlKSBzaG91bGQgbm90IGJlIGNvbnNpZGVyZWQgXCJjb3ZlcmVkXCIuXHJcbiAqIEl0IGhhcHBlbnMgd2hlbiBhIHBvaW50IG1hdGNoZXMgdGhlIG1heCBjb29yZGluYXRlIChpbnRlZ2VyKSBhbmQgdGhpcyBjYXNlIGlzIGhhbmRsZWQgaGVyZS5cclxuICovXHJcbmZ1bmN0aW9uIGZsb29yVG9DZWxsQ29vcmRpbmF0ZSh2YWx1ZSwgbWF4VmFsdWUpIHtcclxuICAgIHJldHVybiBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSAmJiBtYXhWYWx1ZSA9PT0gdmFsdWUgPyB2YWx1ZSAtIDEgOiBNYXRoLmZsb29yKHZhbHVlKTtcclxufVxyXG4vKipcclxuICogQ2FsY3VsYXRlcyBzcXVhcmVzIGNvdmVyZWQgKGF0IGxlYXN0IHBhcnRpYWxseSkgYnkgYSBjb252ZXggcG9seWdvbi5cclxuICpcclxuICogQHBhcmFtIHBvaW50cyBDb252ZXggcG9seWdvbiBwb2ludCBjb29yZGluYXRlcyAob24gdGhlIGdyaWQpLlxyXG4gKiBAcmV0dXJucyBMaXN0IG9mIHVuaXQgc3F1YXJlIGNvb3JkaW5hdGVzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVTcXVhcmVzQ292ZXJlZEJ5Q29udmV4UG9seWdvbihwb2ludHMpIHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgY29uc3QgYmJveCA9IGNvbXB1dGVCQm94Rm9yUG9pbnRzKHBvaW50cyk7XHJcbiAgICBjb25zdCBtaW5YID0gTWF0aC5mbG9vcihiYm94Lm1pblgpO1xyXG4gICAgY29uc3QgeExlbmd0aCA9IE1hdGguY2VpbChiYm94Lm1heFgpIC0gbWluWDtcclxuICAgIGNvbnN0IGV4dHJlbXVtcyA9IG5ldyBFeHRyZW11bVN0b3JhZ2UoeExlbmd0aCk7XHJcbiAgICBmb3IgKGxldCBpID0gcG9pbnRzLmxlbmd0aCAtIDEsIGogPSAwOyBqIDwgcG9pbnRzLmxlbmd0aDsgaSA9IGorKykge1xyXG4gICAgICAgIGxldCBwMSA9IHBvaW50c1tpXTtcclxuICAgICAgICBsZXQgcDIgPSBwb2ludHNbal07XHJcbiAgICAgICAgLy8gZ28gZnJvbSBsZWZ0IHRvIHJpZ2h0IGFsd2F5cyB0byBub3QgaGFuZGxlIHRoZSBvcHBvc2l0ZSBjYXNlXHJcbiAgICAgICAgaWYgKHAxLnggPiBwMi54KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRtcCA9IHAxO1xyXG4gICAgICAgICAgICBwMSA9IHAyO1xyXG4gICAgICAgICAgICBwMiA9IHRtcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY2FsY3VsYXRlIGZyb20vdG8gaW50ZXJ2YWwgc28gdGhhdCBvbmx5IFwiaW50ZXJuYWxcIiBpbnRlZ2VyIHgtZXMgYXJlIGNhcHR1cmVkXHJcbiAgICAgICAgY29uc3QgZnJvbVggPSBNYXRoLmZsb29yKHAxLnggKyAxKTtcclxuICAgICAgICBjb25zdCB0b1ggPSBNYXRoLmNlaWwocDIueCAtIDEpO1xyXG4gICAgICAgIGNvbnN0IHNsb3BlID0gKHAxLnkgLSBwMi55KSAvIChwMS54IC0gcDIueCk7XHJcbiAgICAgICAgLy8gaGFuZGxlIHRlcm1pbmFsIHBvaW50cyBzZXBhcmF0ZWx5IGZyb20gdGhlIFwiaW50ZXJuYWxcIiBvbmVzXHJcbiAgICAgICAgZXh0cmVtdW1zLnVwZGF0ZVZhbHVlKGZsb29yVG9DZWxsQ29vcmRpbmF0ZShwMS54LCBiYm94Lm1heFgpIC0gbWluWCwgZmxvb3JUb0NlbGxDb29yZGluYXRlKHAxLnksIGJib3gubWF4WSkpO1xyXG4gICAgICAgIGV4dHJlbXVtcy51cGRhdGVWYWx1ZShmbG9vclRvQ2VsbENvb3JkaW5hdGUocDIueCwgYmJveC5tYXhYKSAtIG1pblgsIGZsb29yVG9DZWxsQ29vcmRpbmF0ZShwMi55LCBiYm94Lm1heFkpKTtcclxuICAgICAgICBmb3IgKGxldCB4ID0gZnJvbVg7IHggPD0gdG9YOyB4KyspIHtcclxuICAgICAgICAgICAgY29uc3QgeUludGVyY2VwdCA9IChpc0Zpbml0ZShzbG9wZSkgPyBzbG9wZSAqICh4IC0gcDEueCkgOiAwKSArIHAxLnk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5leHRYID0geCAtIG1pblg7XHJcbiAgICAgICAgICAgIGNvbnN0IHByZXZYID0gbmV4dFggLSAxO1xyXG4gICAgICAgICAgICBjb25zdCB5ID0gTWF0aC5mbG9vcih5SW50ZXJjZXB0KTtcclxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgd2UgaGl0IGV4YWN0bHkgdGhlIGludGVyc2VjdGlvbiBvZiB0d28gaW50ZWdlciBjb29yZGluYXRlc1xyXG4gICAgICAgICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcih5SW50ZXJjZXB0KSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHlJbnRlcmNlcHQgPT09IGJib3gubWF4WSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4dHJlbXVtcy51cGRhdGVWYWx1ZShwcmV2WCwgeSAtIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGV4dHJlbXVtcy51cGRhdGVWYWx1ZShuZXh0WCwgeSAtIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2xvcGUgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdHdvIGRpYWdvbmFsIHNxdWFyZXMgaW50ZXJzZWN0ZWQgYnkgYSBsaW5lIHdpdGggcG9zaXRpdmUgc2xvcGVcclxuICAgICAgICAgICAgICAgICAgICBleHRyZW11bXMudXBkYXRlVmFsdWUocHJldlgsIHkgLSAxKTtcclxuICAgICAgICAgICAgICAgICAgICBleHRyZW11bXMudXBkYXRlVmFsdWUobmV4dFgsIHkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2xvcGUgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdHdvIGRpYWdvbmFsIHNxdWFyZXMgaW50ZXJzZWN0ZWQgYnkgYSBsaW5lIHdpdGggbmVnYXRpdmUgc2xvcGVcclxuICAgICAgICAgICAgICAgICAgICBleHRyZW11bXMudXBkYXRlVmFsdWUocHJldlgsIHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGV4dHJlbXVtcy51cGRhdGVWYWx1ZShuZXh0WCwgeSAtIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZXh0cmVtdW1zLnVwZGF0ZVZhbHVlKHByZXZYLCB5KTtcclxuICAgICAgICAgICAgICAgIGV4dHJlbXVtcy51cGRhdGVWYWx1ZShuZXh0WCwgeSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IHsgbWluLCBtYXgsIGluZGV4IH0gb2YgZXh0cmVtdW1zLnZhbHVlcygpKSB7XHJcbiAgICAgICAgY29uc3QgeCA9IG1pblggKyBpbmRleDtcclxuICAgICAgICBmb3IgKGxldCB5ID0gbWluOyB5IDw9IG1heDsgeSsrKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZlYzIuY3JlYXRlKHgsIHkpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbiIsImltcG9ydCB7IGNvcHkgfSBmcm9tICcuL2FycmF5JztcclxuaW1wb3J0IHsgTlVNRVJJQ0FMX0NPTVBBUkFUT1IgfSBmcm9tICcuL2NvbXBhcmF0b3InO1xyXG4vKipcclxuICogRmlsdGVycyBhbiBhcnJheSBvZiB2YWx1ZXMgd2l0aCBtZWRpYW4gZmlsdGVyLlxyXG4gKlxyXG4gKiBAcGFyYW0gdmFsdWVzIFZhbHVlcyB0byBiZSBmaWx0ZXJlZC5cclxuICogQHBhcmFtIHdpbmRvd1JhZGl1cyBIb3cgbWFueSB2YWx1ZXMgYXJvdW5kIGEgc2FtcGxlIGdldCBpbnRvIGZpbHRlciB3aW5kb3cuXHJcbiAqIEByZXR1cm5zIEFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBtZWRpYW5GaWx0ZXIodmFsdWVzLCB3aW5kb3dSYWRpdXMgPSAzKSB7XHJcbiAgICBjb25zdCB3aW5kb3cgPSBuZXcgQXJyYXkoMiAqIHdpbmRvd1JhZGl1cyArIDEpO1xyXG4gICAgd2luZG93LmZpbGwodmFsdWVzWzBdKTtcclxuICAgIGNvbnN0IGxlbmd0aCA9IHZhbHVlcy5sZW5ndGg7XHJcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXkobGVuZ3RoKTtcclxuICAgIGNvbnN0IGZpcnN0ID0gdmFsdWVzWzBdO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3aW5kb3dSYWRpdXM7ICsraSkge1xyXG4gICAgICAgIHdpbmRvdy5maWxsKGZpcnN0LCAwLCB3aW5kb3dSYWRpdXMgLSBpICsgMSk7XHJcbiAgICAgICAgY29weSh2YWx1ZXMsIHdpbmRvdywgMCwgaSArIHdpbmRvd1JhZGl1cyArIDEsIHdpbmRvd1JhZGl1cyAtIGkgKyAxKTtcclxuICAgICAgICB3aW5kb3cuc29ydChOVU1FUklDQUxfQ09NUEFSQVRPUik7XHJcbiAgICAgICAgcmVzdWx0W2ldID0gd2luZG93W3dpbmRvd1JhZGl1c107XHJcbiAgICB9XHJcbiAgICBmb3IgKGxldCBpID0gd2luZG93UmFkaXVzOyBpIDwgbGVuZ3RoIC0gd2luZG93UmFkaXVzOyArK2kpIHtcclxuICAgICAgICBjb3B5KHZhbHVlcywgd2luZG93LCBpIC0gd2luZG93UmFkaXVzLCBpICsgd2luZG93UmFkaXVzICsgMSk7XHJcbiAgICAgICAgd2luZG93LnNvcnQoTlVNRVJJQ0FMX0NPTVBBUkFUT1IpO1xyXG4gICAgICAgIHJlc3VsdFtpXSA9IHdpbmRvd1t3aW5kb3dSYWRpdXNdO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbGFzdCA9IHZhbHVlc1t2YWx1ZXMubGVuZ3RoIC0gMV07XHJcbiAgICBmb3IgKGxldCBpID0gbGVuZ3RoIC0gd2luZG93UmFkaXVzOyBpIDwgbGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBjb3B5KHZhbHVlcywgd2luZG93LCBpIC0gd2luZG93UmFkaXVzLCBsZW5ndGgpO1xyXG4gICAgICAgIHdpbmRvdy5maWxsKGxhc3QsIHZhbHVlcy5sZW5ndGggLSBpICsgd2luZG93UmFkaXVzKTtcclxuICAgICAgICB3aW5kb3cuc29ydChOVU1FUklDQUxfQ09NUEFSQVRPUik7XHJcbiAgICAgICAgcmVzdWx0W2ldID0gd2luZG93W3dpbmRvd1JhZGl1c107XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbiIsImltcG9ydCBMaXN0UmVuZGVyVW5pdCBmcm9tICcuL2xpc3RfcmVuZGVyX3VuaXQnO1xyXG5pbXBvcnQgeyBWb2lkRXZlbnRFbWl0dGVyIH0gZnJvbSAnLi4vdXRpbC9ldmVudF9lbWl0dGVyJztcclxuaW1wb3J0IFJlbmRlclN0YXRlIGZyb20gJy4vc3RhdGUnO1xyXG5pbXBvcnQgeyBjYWxjdWxhdGVDYW1lcmFQb3NpdGlvbnMgfSBmcm9tICcuL3V0aWwvY2FtZXJhX3Bvc2l0aW9uJztcclxuY29uc3QgRklOQUxfUkVOREVSX1NUQVRFID0gbmV3IFJlbmRlclN0YXRlKHtcclxuICAgIGNsZWFyRGVwdGg6IDAsXHJcbiAgICBkZXB0aFRlc3Q6IHRydWUsXHJcbiAgICBkZXB0aEZ1bmM6IDUxOCAvKiBHUkVBVEVSX09SX0VRVUFMICovXHJcbn0pO1xyXG4vKipcclxuICogUm9vdCBzY2VuZSByZW5kZXJlci4gSXQgZ2VuZXJhdGVzIGZpbmFsIGNhbnZhcyBpbWFnZSBjb21wb3NpbmcgaXQgZnJvbSBpbmRlcGVuZGVudCBsYXllcnMgKExheWVyUmVuZGVyVW5pdCkuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYWluUmVuZGVyVW5pdCBleHRlbmRzIExpc3RSZW5kZXJVbml0IHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIGNhbWVyYSkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XHJcbiAgICAgICAgdGhpcy5fY2FtZXJhID0gY2FtZXJhO1xyXG4gICAgICAgIHRoaXMub25SZW5kZXIgPSBuZXcgVm9pZEV2ZW50RW1pdHRlcigpO1xyXG4gICAgfVxyXG4gICAgcmVuZGVyKHRhcmdldCkge1xyXG4gICAgICAgIGNvbnN0IHZpZXdQcm9qTWF0aXggPSB0aGlzLl9jYW1lcmEuZ2V0Vmlld1Byb2pNYXRyaXgoKTtcclxuICAgICAgICBjb25zdCBjYW1lcmFQb3NpdGlvbnMgPSBjYWxjdWxhdGVDYW1lcmFQb3NpdGlvbnModGhpcy5fY2FtZXJhKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRSZW5kZXJUYXJnZXQodGFyZ2V0KTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRSZW5kZXJTdGF0ZShGSU5BTF9SRU5ERVJfU1RBVEUpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuY2xlYXJDdXJyZW50VGFyZ2V0KDE3NjY0IC8qIEFMTCAqLyk7XHJcbiAgICAgICAgZm9yIChjb25zdCByZW5kZXJlciBvZiB0aGlzLl9zdWJSZW5kZXJVbml0cykge1xyXG4gICAgICAgICAgICByZW5kZXJlci5yZW5kZXIodGFyZ2V0LCB2aWV3UHJvak1hdGl4LCBjYW1lcmFQb3NpdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm9uUmVuZGVyLmZpcmUoKTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBWb2lkRXZlbnRFbWl0dGVyIH0gZnJvbSAnLi4vdXRpbC9ldmVudF9lbWl0dGVyJztcclxuY2xhc3MgTm9CYXNlUmVuZGVyVW5pdEVycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoJ0Jhc2UgcmVuZGVyIHVuaXQgaXMgbm90IGluIHRoZSBsaXN0Jyk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFNpbXBsZSBpbXBsZW1lbnRhdGlvbiBvZiBDb21wb3NpdGVSZW5kZXJVbml0IHRoYXQganVzdCBydW5zIHN1YiB1bml0cyBpbiB0aGUgb3JkZXIgb2YgYWRkaXRpb24uXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaXN0UmVuZGVyVW5pdCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLm9uVXBkYXRlID0gbmV3IFZvaWRFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLl9zdWJSZW5kZXJVbml0cyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3N1YlJlbmRlclVuaXRVcGRhdGVMaXN0ZW5lciA9IHRoaXMuX29uU3ViUmVuZGVyVW5pdFVwZGF0ZS5iaW5kKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIFJlbmRlclVuaXQgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdC5cclxuICAgICAqL1xyXG4gICAgYWRkUmVuZGVyVW5pdChzdWJSZW5kZXJVbml0KSB7XHJcbiAgICAgICAgdGhpcy5fc3ViUmVuZGVyVW5pdHMucHVzaChzdWJSZW5kZXJVbml0KTtcclxuICAgICAgICBzdWJSZW5kZXJVbml0Lm9uVXBkYXRlLmFkZExpc3RlbmVyKHRoaXMuX3N1YlJlbmRlclVuaXRVcGRhdGVMaXN0ZW5lcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgUmVuZGVyVW5pdCBmcm9tIHRoZSBsaXN0LlxyXG4gICAgICovXHJcbiAgICByZW1vdmVSZW5kZXJVbml0KHN1YlJlbmRlclVuaXQpIHtcclxuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuX3N1YlJlbmRlclVuaXRzLmluZGV4T2Yoc3ViUmVuZGVyVW5pdCk7XHJcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdWJSZW5kZXJVbml0cy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICBzdWJSZW5kZXJVbml0Lm9uVXBkYXRlLnJlbW92ZUxpc3RlbmVyKHRoaXMuX3N1YlJlbmRlclVuaXRVcGRhdGVMaXN0ZW5lcik7XHJcbiAgICAgICAgICAgIHRoaXMub25VcGRhdGUuZmlyZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBSZW5kZXJVbml0IGFib3ZlIHRoZSBiYXNlIG9uZS4gXCJBYm92ZVwiIG1lYW5zIHRoYXQgaXRzIHJlbmRlcigpIG1ldGhvZCB3aWxsIGJlIGNhbGxlZCBhZnRlciB0aGUgYmFzZSdzIG9uZS5cclxuICAgICAqL1xyXG4gICAgYWRkUmVuZGVyVW5pdEFib3ZlKGJhc2UsIHN1YlJlbmRlclVuaXQpIHtcclxuICAgICAgICBjb25zdCBiYXNlSW5kZXggPSB0aGlzLl9zdWJSZW5kZXJVbml0cy5pbmRleE9mKGJhc2UpO1xyXG4gICAgICAgIGlmIChiYXNlSW5kZXggIT09IC0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N1YlJlbmRlclVuaXRzLnNwbGljZShiYXNlSW5kZXggKyAxLCAwLCBzdWJSZW5kZXJVbml0KTtcclxuICAgICAgICAgICAgc3ViUmVuZGVyVW5pdC5vblVwZGF0ZS5hZGRMaXN0ZW5lcih0aGlzLl9zdWJSZW5kZXJVbml0VXBkYXRlTGlzdGVuZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vQmFzZVJlbmRlclVuaXRFcnJvcigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBSZW5kZXJVbml0IGJlbG93IHRoZSBiYXNlIG9uZS4gXCJCZWxvd1wiIG1lYW5zIHRoYXQgaXRzIHJlbmRlcigpIG1ldGhvZCB3aWxsIGJlIGNhbGxlZCBiZWZvcmUgdGhlIGJhc2UncyBvbmUuXHJcbiAgICAgKi9cclxuICAgIGFkZFJlbmRlclVuaXRCZWxvdyhiYXNlLCBzdWJSZW5kZXJVbml0KSB7XHJcbiAgICAgICAgY29uc3QgYmFzZUluZGV4ID0gdGhpcy5fc3ViUmVuZGVyVW5pdHMuaW5kZXhPZihiYXNlKTtcclxuICAgICAgICBpZiAoYmFzZUluZGV4ICE9PSAtMSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdWJSZW5kZXJVbml0cy5zcGxpY2UoYmFzZUluZGV4LCAwLCBzdWJSZW5kZXJVbml0KTtcclxuICAgICAgICAgICAgc3ViUmVuZGVyVW5pdC5vblVwZGF0ZS5hZGRMaXN0ZW5lcih0aGlzLl9zdWJSZW5kZXJVbml0VXBkYXRlTGlzdGVuZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vQmFzZVJlbmRlclVuaXRFcnJvcigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlbmRlcih0YXJnZXQsIC4uLmFyZ3MpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IHJlbmRlcmVyIG9mIHRoaXMuX3N1YlJlbmRlclVuaXRzKSB7XHJcbiAgICAgICAgICAgIHJlbmRlcmVyLnJlbmRlcih0YXJnZXQsIC4uLmFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9vblN1YlJlbmRlclVuaXRVcGRhdGUoKSB7XHJcbiAgICAgICAgdGhpcy5vblVwZGF0ZS5maXJlKCk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IE1lbW9yeVBhZ2UgZnJvbSAnLi9wYWdlJztcclxuaW1wb3J0IHsgY291bnRWZXJ0aWNlcyB9IGZyb20gJy4vY291bnRfdmVydGljZXMnO1xyXG5pbXBvcnQgeyBBcmVuYUFsbG9jYXRvciB9IGZyb20gJy4uLy4uL3V0aWwvYWxsb2NhdG9yJztcclxuY29uc3QgTUFYX1ZFUlRFWF9DT1VOVCA9IDB4MTAwMDA7XHJcbi8vIEZJWE1FKGRtaWtpcykgTGV0J3MgdXNlIG92ZXJzaXplZCBpbmRleCBidWZmZXIgdGlsIHdlIHNvcnQgb3V0IGluZGljZXMgYWxsb2NhdGlvblxyXG4vLyBib3RoIGluIHdyaXRlcnMgYW5kIHRoZSBtYW5hZ2VyLlxyXG5jb25zdCBQQUdFX0lOREVYX0JVRkZFUl9CWVRFX1NJWkUgPSAweDEwMDAwMDtcclxuLyoqXHJcbiAqIE1lbW9yeSBwYWdlIHdpdGggdGhlIGZvbGxvd2luZyBwZWN1bGlhcml0eTogb25jZSBhbGxvY2F0aW9uIGlzIGZhaWxlZCBpdCBnZXRzIGNsb3NlZCBmb3IgYW55IHN1YnNlcXVlbnRcclxuICogYWxsb2NhdGlvbnMuIEl0IGFsbG93IHRvIGtlZXAgcmVsYXRlZCBwcmltaXRpdmVzIGNsb3NlciBpbiBtZW1vcnkuXHJcbiAqL1xyXG5jbGFzcyBTaW5nbGVQYXNzTWVtb3J5UGFnZSBleHRlbmRzIE1lbW9yeVBhZ2Uge1xyXG4gICAgY29uc3RydWN0b3IodmVydGV4QnVmZmVyLCBpbmRleEJ1ZmZlciwgdmFvLCBpbmRleFR5cGUpIHtcclxuICAgICAgICBzdXBlcih2ZXJ0ZXhCdWZmZXIsIGluZGV4QnVmZmVyLCB2YW8sIGluZGV4VHlwZSwgbmV3IEFyZW5hQWxsb2NhdG9yKHZlcnRleEJ1ZmZlci5nZXRTaXplKCkpLCBuZXcgQXJlbmFBbGxvY2F0b3IoaW5kZXhCdWZmZXIuZ2V0U2l6ZSgpKSk7XHJcbiAgICAgICAgdGhpcy5fZmFpbGVkQWxsb2NhdGlvbiA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgYWxsb2NhdGUodmVydGV4Qnl0ZUxlbmd0aCwgaW5kZXhCeXRlTGVuZ3RoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2ZhaWxlZEFsbG9jYXRpb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNodW5rID0gc3VwZXIuYWxsb2NhdGUodmVydGV4Qnl0ZUxlbmd0aCwgaW5kZXhCeXRlTGVuZ3RoKTtcclxuICAgICAgICB0aGlzLl9mYWlsZWRBbGxvY2F0aW9uID0gKGNodW5rID09PSBudWxsKTtcclxuICAgICAgICByZXR1cm4gY2h1bms7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIE1hbmFnZXIgdGhhdCBjb250cm9scyBHTCBtZW1vcnkgYWxsb2NhdGlvbnMgYW5kIHBhZ2luYXRpb24uW11cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1lbW9yeU1hbmFnZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IG1lbW9yeSBtYW5hZ2VyIHRoYXQgd2lsbCBhbGxvY2F0ZSBtZW1vcnkgaW4gYSBnaXZlbiBjb250ZXh0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjb250ZXh0LlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XHJcbiAgICAgICAgdGhpcy5fcGFnZXMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5fZW1wdHlQYWdlc0NsZWFyVGltZW91dCA9IDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFsbG9jYXRlcyBtZW1vcnkgZm9yIGEgZ2l2ZW4gZGF0YSBpbiB0aGUgbWFuYWdlciBhbmQgdXBsb2FkcyBnaXZlbiBkYXRhLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB2ZXJ0ZXhEYXRhIEJ1ZmZlciB3aXRoIHZlcnRpY2VzIHRoYXQgbmVlZHMgdG8gYmUgYWxsb2NhdGVkLlxyXG4gICAgICogQHBhcmFtIGluZGV4RGF0YSBCdWZmZXIgd2l0aCBpbmRpY2VzIHRoYXQgbmVlZHMgdG8gYmUgYWxsb2NhdGVkLlxyXG4gICAgICogQHBhcmFtIGF0dHJpYnV0ZU1hcHBpbmcgTWFwcGluZyBvZiB2ZXJ0ZXggYXR0cmlidXRlcy5cclxuICAgICAqIEByZXR1cm5zIERlc2NyaXB0b3Igb2YgdGhlIGFsbG9jYXRlZCBtZW1vcnkgcmVnaW9uLlxyXG4gICAgICovXHJcbiAgICBhbGxvY2F0ZSh2ZXJ0ZXhEYXRhLCBpbmRleERhdGEsIGF0dHJpYnV0ZU1hcHBpbmcpIHtcclxuICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5fY29udGV4dDtcclxuICAgICAgICBsZXQgcGFnZVNldCA9IHRoaXMuX3BhZ2VzLmdldChhdHRyaWJ1dGVNYXBwaW5nKTtcclxuICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIHBhZ2VzIGZvciB0aGUgZ2l2ZW4gYXR0cmlidXRlIG1hcHBpbmcsIGNyZWF0ZSBhIG5ldyBzZXQuXHJcbiAgICAgICAgaWYgKCFwYWdlU2V0KSB7XHJcbiAgICAgICAgICAgIHBhZ2VTZXQgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3BhZ2VzLnNldChhdHRyaWJ1dGVNYXBwaW5nLCBwYWdlU2V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVHJ5IHRvIGFsbG9jYXRlIGRhdGEgaW4gdGhlIGV4aXN0aW5nIHBhZ2VzLlxyXG4gICAgICAgIGZvciAoY29uc3QgcGFnZSBvZiBwYWdlU2V0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1lbW9yeUNodW5rID0gcGFnZS5hbGxvY2F0ZSh2ZXJ0ZXhEYXRhLmJ5dGVMZW5ndGgsIGluZGV4RGF0YS5ieXRlTGVuZ3RoKTtcclxuICAgICAgICAgICAgaWYgKG1lbW9yeUNodW5rKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTdWNjZXNzISBOb3cgd2UganVzdCB1cGxvYWQgdGhlIGRhdGEuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVQYWdlKHBhZ2UsIG1lbW9yeUNodW5rLCB2ZXJ0ZXhEYXRhLCBpbmRleERhdGEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lbW9yeUNodW5rO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFdlJ3ZlIGZhaWxlZCB0byBhbGxvY2F0ZSB0aGUgZGF0YSBpbiBhbnkgb2YgZXhpc3RpbmcgcGFnZXMuIE5vIHdvcnJpZXNcclxuICAgICAgICAvLyB0aG91Z2gsIHdlIGp1c3QgY3JlYXRlIGEgbmV3IG9uZTopXHJcbiAgICAgICAgY29uc3QgdmVydGV4QnVmZmVyID0gY29udGV4dC5jcmVhdGVWZXJ0ZXhCdWZmZXIoXHJcbiAgICAgICAgLy8gc29tZSBidWZmZXIgd3JpdGVycyBkb24ndCB1c2UgaW5kaWNlcyBhbmQgTUFYX1ZFUlRFWF9DT1VOVCByZXN0cmljdGlvbiBpcyBub3QgYXBwbGllZCBpbiBzdWNoIGNhc2VzXHJcbiAgICAgICAgTWF0aC5tYXgoTUFYX1ZFUlRFWF9DT1VOVCAqIGF0dHJpYnV0ZU1hcHBpbmcudmVydGV4Qnl0ZVNpemUsIHZlcnRleERhdGEuYnl0ZUxlbmd0aCkpO1xyXG4gICAgICAgIGNvbnN0IGluZGV4QnVmZmVyID0gY29udGV4dC5jcmVhdGVJbmRleEJ1ZmZlcihQQUdFX0lOREVYX0JVRkZFUl9CWVRFX1NJWkUpO1xyXG4gICAgICAgIGNvbnN0IHZhbyA9IGNvbnRleHQuY3JlYXRlVmFvKGF0dHJpYnV0ZU1hcHBpbmcsIHZlcnRleEJ1ZmZlciwgaW5kZXhCdWZmZXIpO1xyXG4gICAgICAgIGNvbnN0IHBhZ2UgPSBuZXcgU2luZ2xlUGFzc01lbW9yeVBhZ2UodmVydGV4QnVmZmVyLCBpbmRleEJ1ZmZlciwgdmFvLCA1MTIzIC8qIFVOU0lHTkVEX1NIT1JUICovKTtcclxuICAgICAgICBwYWdlLnNldERlbGVnYXRlKHRoaXMpO1xyXG4gICAgICAgIHBhZ2VTZXQuYWRkKHBhZ2UpO1xyXG4gICAgICAgIC8vIEhlcmUgd2UgYXNzdW1lIHdlIGFsd2F5cyBjYW4gYWxsb2NhdGUgZGF0YSBpbiBhbiBlbXB0eSBwYWdlLlxyXG4gICAgICAgIGNvbnN0IG1lbW9yeUNodW5rID0gcGFnZS5hbGxvY2F0ZSh2ZXJ0ZXhEYXRhLmJ5dGVMZW5ndGgsIGluZGV4RGF0YS5ieXRlTGVuZ3RoKTtcclxuICAgICAgICB0aGlzLl91cGRhdGVQYWdlKHBhZ2UsIG1lbW9yeUNodW5rLCB2ZXJ0ZXhEYXRhLCBpbmRleERhdGEpO1xyXG4gICAgICAgIHJldHVybiBtZW1vcnlDaHVuaztcclxuICAgIH1cclxuICAgIG9uUGFnZUVtcHR5KCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fZW1wdHlQYWdlc0NsZWFyVGltZW91dCkge1xyXG4gICAgICAgICAgICB0aGlzLl9lbXB0eVBhZ2VzQ2xlYXJUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jbGVhckVtcHR5UGFnZXMoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2VtcHR5UGFnZXNDbGVhclRpbWVvdXQgPSAwO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERlc3Ryb3lzIHRoZSBtYW5hZ2VyIGFuZCBhbGwgaXRzIG1lbW9yeSBwYWdlcy4gQWxsIG1lbW9yeSBjaHVua3MgdGhhdCB3ZXJlXHJcbiAgICAgKiBhbGxvY2F0ZWQgaW4gdGhlIG1hbmFnZXIgYmVjb21lIGludmFsaWQuXHJcbiAgICAgKi9cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2VtcHR5UGFnZXNDbGVhclRpbWVvdXQpIHtcclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2VtcHR5UGFnZXNDbGVhclRpbWVvdXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IFssIHBhZ2VTZXRdIG9mIHRoaXMuX3BhZ2VzKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGFnZSBvZiBwYWdlU2V0KSB7XHJcbiAgICAgICAgICAgICAgICBwYWdlLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF91cGRhdGVQYWdlKHBhZ2UsIG1lbW9yeUNodW5rLCB2ZXJ0ZXhEYXRhLCBpbmRleERhdGEpIHtcclxuICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5fY29udGV4dDtcclxuICAgICAgICAvLyBMZXQncyBlbnN1cmUgdGhhdCB3ZSB3b24ndCBicmVhayBhbnkgYm91bmQgVkFPcy5cclxuICAgICAgICBjb250ZXh0LmJpbmRWYW8obnVsbCk7XHJcbiAgICAgICAgY29udGV4dC51cGxvYWREYXRhVG9CdWZmZXIocGFnZS52ZXJ0ZXhCdWZmZXIsIHZlcnRleERhdGEsIG1lbW9yeUNodW5rLnZlcnRleEJ5dGVPZmZzZXQpO1xyXG4gICAgICAgIC8vIFNoaWZ0IGluZGljZXMuXHJcbiAgICAgICAgY29uc3QgYmFzZUluZGV4ID0gY291bnRWZXJ0aWNlcyhtZW1vcnlDaHVuay52ZXJ0ZXhCeXRlT2Zmc2V0LCBwYWdlLnZhby5hdHRyaWJ1dGVNYXBwaW5nKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGV4RGF0YS5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBpbmRleERhdGFbaV0gKz0gYmFzZUluZGV4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb250ZXh0LnVwbG9hZERhdGFUb0J1ZmZlcihwYWdlLmluZGV4QnVmZmVyLCBpbmRleERhdGEsIG1lbW9yeUNodW5rLmluZGV4Qnl0ZU9mZnNldCk7XHJcbiAgICB9XHJcbiAgICBfY2xlYXJFbXB0eVBhZ2VzKCkge1xyXG4gICAgICAgIGZvciAoY29uc3QgcGFnZVNldCBvZiB0aGlzLl9wYWdlcy52YWx1ZXMoKSkge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBhZ2Ugb2YgcGFnZVNldCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhZ2UuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFnZVNldC5kZWxldGUocGFnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFnZS5zZXREZWxlZ2F0ZShudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICBwYWdlLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgQ2h1bmsgZnJvbSAnLi9jaHVuayc7XHJcbmltcG9ydCB7IERlbGVnYXRvckJhc2UgfSBmcm9tICcuLi8uLi91dGlsL2RlbGVnYXRvcic7XHJcbi8qKlxyXG4gKiBBIFwicGFnZVwiIG9mIEdQVSBtZW1vcnkuIENvbXByaXNlcyB2ZXJ0ZXggYW5kIGluZGV4IGJ1ZmZlcnMgb2YgYSBmaXhlZCBzaXplLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWVtb3J5UGFnZSBleHRlbmRzIERlbGVnYXRvckJhc2Uge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHBhZ2UgdG8gbWFuYWdlIGdpdmVuIHZlcnRleCBhbmQgaW5kZXggYnVmZmVycy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmVydGV4QnVmZmVyIFRoZSB2ZXJ0ZXggYnVmZmVyIHRoZSBwYWdlIHdpbGwgbWFuYWdlLlxyXG4gICAgICogQHBhcmFtIGluZGV4QnVmZmVyIFRoZSBpbmRleCBidWZmZXIgdGhlIHBhZ2Ugd2lsbCBtYW5hZ2VyLlxyXG4gICAgICogQHBhcmFtIHZhbyBUaGUgVkFPIG9mIHRoZSBwYWdlLlxyXG4gICAgICogQHBhcmFtIGluZGV4VHlwZSBUeXBlIG9mIGVsZW1lbnRzIG9mIGluZGV4QnVmZmVyLlxyXG4gICAgICogQHBhcmFtIHZlcnRleEFsbG9jYXRvciBBbGxvY2F0b3Igb2YgdmVydGV4IGRhdGEsIGxvZ2ljIG9mIGFsbG9jYXRpb24gZGlyZWN0bHkgaW1wYWN0cyB0aGUgbGlmZWN5Y2xlIG9mIHRoZSBwYWdlLlxyXG4gICAgICogQHBhcmFtIGluZGV4QWxsb2NhdG9yIEFsbG9jYXRvciBvZiBpbmRleCBkYXRhLCBsb2dpYyBvZiBhbGxvY2F0aW9uIGRpcmVjdGx5IGltcGFjdHMgdGhlIGxpZmVjeWNsZSBvZiB0aGUgcGFnZS5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IodmVydGV4QnVmZmVyLCBpbmRleEJ1ZmZlciwgdmFvLCBpbmRleFR5cGUsIHZlcnRleEFsbG9jYXRvciwgaW5kZXhBbGxvY2F0b3IpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMudmVydGV4QnVmZmVyID0gdmVydGV4QnVmZmVyO1xyXG4gICAgICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBpbmRleEJ1ZmZlcjtcclxuICAgICAgICB0aGlzLnZhbyA9IHZhbztcclxuICAgICAgICB0aGlzLmluZGV4VHlwZSA9IGluZGV4VHlwZTtcclxuICAgICAgICB0aGlzLl92ZXJ0ZXhBbGxvY2F0b3IgPSB2ZXJ0ZXhBbGxvY2F0b3I7XHJcbiAgICAgICAgdGhpcy5faW5kZXhBbGxvY2F0b3IgPSBpbmRleEFsbG9jYXRvcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWxsb2NhdGVzIGFuZCB3cml0ZXMgdmVydGV4IGFuZCBpbmRleCBkYXRhIHRvIHRoZSBwYWdlLiBPZmZzZXRzIGluZGljZXNcclxuICAgICAqIGluIGFuIGluZGV4IGFycmF5IHRvIGFwcHJvcHJpYXRlbHkgdGFrZSBpbnRvIGFjY291bnQgb2Zmc2V0IG9mIHRoZSB2ZXJ0ZXhcclxuICAgICAqIGRhdGEuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZlcnRleEJ5dGVMZW5ndGggcmVxdWlyZWQgbnVtYmVyIG9mIGJ5dGVzIGluIHZlcnRleCBidWZmZXJcclxuICAgICAqIEBwYXJhbSBpbmRleEJ5dGVMZW5ndGggcmVxdWlyZWQgbnVtYmVyIG9mIGJ5dGVzIGluIGluZGV4IGJ1ZmZlclxyXG4gICAgICogQHJldHVybnMgbWVtb3J5IGNodW5rIGFsbG9jYXRlZCBvciBgbnVsbGAgaWYgYWxsb2NhdGlvbidzIGZhaWxlZFxyXG4gICAgICovXHJcbiAgICBhbGxvY2F0ZSh2ZXJ0ZXhCeXRlTGVuZ3RoLCBpbmRleEJ5dGVMZW5ndGgpIHtcclxuICAgICAgICBpZiAodGhpcy5fdmVydGV4QWxsb2NhdG9yLm1heEFsbG9jYWJsZVNpemUgPj0gdmVydGV4Qnl0ZUxlbmd0aCAmJlxyXG4gICAgICAgICAgICB0aGlzLl9pbmRleEFsbG9jYXRvci5tYXhBbGxvY2FibGVTaXplID49IGluZGV4Qnl0ZUxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENodW5rKHRoaXMsIHtcclxuICAgICAgICAgICAgICAgIHZlcnRleEJ5dGVPZmZzZXQ6IHRoaXMuX3ZlcnRleEFsbG9jYXRvci5hbGxvY2F0ZSh2ZXJ0ZXhCeXRlTGVuZ3RoKSxcclxuICAgICAgICAgICAgICAgIHZlcnRleEJ5dGVMZW5ndGg6IHZlcnRleEJ5dGVMZW5ndGgsXHJcbiAgICAgICAgICAgICAgICBpbmRleEJ5dGVPZmZzZXQ6IHRoaXMuX2luZGV4QWxsb2NhdG9yLmFsbG9jYXRlKGluZGV4Qnl0ZUxlbmd0aCksXHJcbiAgICAgICAgICAgICAgICBpbmRleEJ5dGVMZW5ndGg6IGluZGV4Qnl0ZUxlbmd0aFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRnJlZXMgYSBwcmV2aW91c2x5IGFsbG9jYXRlZCBtZW1vcnkgY2h1bmsuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byBiZSBmcmVlZC5cclxuICAgICAqL1xyXG4gICAgZnJlZShjaHVuaykge1xyXG4gICAgICAgIHRoaXMuX3ZlcnRleEFsbG9jYXRvci5kZWFsbG9jYXRlKGNodW5rLnZlcnRleEJ5dGVPZmZzZXQpO1xyXG4gICAgICAgIHRoaXMuX2luZGV4QWxsb2NhdG9yLmRlYWxsb2NhdGUoY2h1bmsuaW5kZXhCeXRlT2Zmc2V0KTtcclxuICAgICAgICBpZiAodGhpcy5pc0VtcHR5KCkgJiYgdGhpcy5fZGVsZWdhdGUpIHtcclxuICAgICAgICAgICAgdGhpcy5fZGVsZWdhdGUub25QYWdlRW1wdHkodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcGFnZSBkb2VzIG5vdCBjb250YWluIGFueSBwcmV2aW91c2x5IGFsbG9jYXRlZCBkYXRhXHJcbiAgICAgKiBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXHJcbiAgICAgKi9cclxuICAgIGlzRW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZlcnRleEFsbG9jYXRvci5pc0VtcHR5ICYmIHRoaXMuX2luZGV4QWxsb2NhdG9yLmlzRW1wdHk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERlc3Ryb3lzIHRoZSBwYWdlIGFuZCBhbGwgaXRzIHJlc291cmNlcy5cclxuICAgICAqL1xyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLnZlcnRleEJ1ZmZlci5kZXN0cm95KCk7XHJcbiAgICAgICAgdGhpcy5pbmRleEJ1ZmZlci5kZXN0cm95KCk7XHJcbiAgICAgICAgdGhpcy52YW8uZGVzdHJveSgpO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCBSZWZDb3VudGVkIGZyb20gJy4uLy4uL3V0aWwvcmVmX2NvdW50ZWQnO1xyXG4vKiogSGFuZGxlciB0byBhIGFsbG9jYXRlZCBtZW1vcnkgY2h1bmsuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1lbW9yeUNodW5rIGV4dGVuZHMgUmVmQ291bnRlZCB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgaGFuZGxlciB0byBhIG1lbW9yeSBjaHVuayB3aXRoIGdpdmVuIG9mZnNldHMgYWxsb2NhdGVkIGluXHJcbiAgICAgKiBhIGdpdmVuIG1lbW9yeSBwYWdlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwYWdlIFRoZSBwYWdlIHRoZSBjaHVuayB3YXMgYWxsb2NhdGVkIGluLlxyXG4gICAgICogQHBhcmFtIHZlcnRleE9mZnNldCBUaGUgb2Zmc2V0IG9mIGNodW5rJ3MgdmVydGV4IGRhdGEuXHJcbiAgICAgKiBAcGFyYW0gaW5kZXhPZmZzZXQgVGhlIG9mZnNldCBvZiBjaHVuaydzIGluZGV4IGRhdGEuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHBhZ2UsIGxvY2F0aW9uKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnBhZ2UgPSBwYWdlO1xyXG4gICAgICAgIHRoaXMuX2xvY2F0aW9uID0gbG9jYXRpb247XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgb2Zmc2V0IG9mIHZlcnRleCBkYXRhIG9mIHRoZSBjaHVuayBpbiBieXRlcy5cclxuICAgICAqL1xyXG4gICAgZ2V0IHZlcnRleEJ5dGVPZmZzZXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2F0aW9uLnZlcnRleEJ5dGVPZmZzZXQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgb2Zmc2V0IG9mIGluZGV4IGRhdGEgb2YgdGhlIGNodW5rIGluIGJ5dGVzLlxyXG4gICAgICovXHJcbiAgICBnZXQgaW5kZXhCeXRlT2Zmc2V0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhdGlvbi5pbmRleEJ5dGVPZmZzZXQ7XHJcbiAgICB9XHJcbiAgICBfZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLnBhZ2UuZnJlZSh0aGlzKTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgKiBhcyB2ZWN0b3IyIGZyb20gJy4uL21hdGgvdmVjdG9yMic7XHJcbmltcG9ydCBSZW5kZXJTdGF0ZSBmcm9tICcuL3N0YXRlJztcclxuaW1wb3J0IGZ4YWFGcmFnbWVudFNoYWRlciBmcm9tICcuL3NoYWRlcnMvZnhhYS5mcmFnJztcclxuaW1wb3J0IGZ4YWFWZXJ0ZXhTaGFkZXIgZnJvbSAnLi9zaGFkZXJzL3F1YWQudmVydCc7XHJcbmltcG9ydCBnZXREcHIgZnJvbSAnLi4vdXRpbC9oZCc7XHJcbmltcG9ydCB7IEdsUmVuZGVyZXIgfSBmcm9tICcuL2dsX3JlbmRlcmVyJztcclxuaW1wb3J0IExpc3RSZW5kZXJVbml0IGZyb20gJy4vbGlzdF9yZW5kZXJfdW5pdCc7XHJcbmltcG9ydCB7IEJMRU5EX09WRVJfUkVOREVSX1NUQVRFIH0gZnJvbSAnLi9zdGF0ZSc7XHJcbmNvbnN0IFNUQVRFID0gbmV3IFJlbmRlclN0YXRlKEJMRU5EX09WRVJfUkVOREVSX1NUQVRFKTtcclxuLyoqXHJcbiAqIFJlbmRlcmVyIG9mIEZYQUEgcG9zdHByb2Nlc3NpbmcgcGFzcy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZ4YWFSZW5kZXJVbml0IGV4dGVuZHMgR2xSZW5kZXJlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCByZW5kZXJMb29wKSB7XHJcbiAgICAgICAgc3VwZXIoY29udGV4dCwgU1RBVEUsIGNvbnRleHQuY3JlYXRlUHJvZ3JhbShmeGFhVmVydGV4U2hhZGVyLCBmeGFhRnJhZ21lbnRTaGFkZXIsIHtcclxuICAgICAgICAgICAgYXR0cmliTWFwOiB7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhQb3NpdGlvbjogMCAvKiBQT1NJVElPTiAqL1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIHRoaXMuX3JlbmRlcmVycyA9IG5ldyBMaXN0UmVuZGVyVW5pdCgpO1xyXG4gICAgICAgIHRoaXMuX3JlbmRlckxvb3AgPSByZW5kZXJMb29wO1xyXG4gICAgICAgIHRoaXMub25VcGRhdGUgPSB0aGlzLl9yZW5kZXJlcnMub25VcGRhdGU7XHJcbiAgICAgICAgdGhpcy5fcGl4ZWxTaXplID0gdmVjdG9yMi5jcmVhdGUoMCwgMCk7XHJcbiAgICB9XHJcbiAgICBhZGRSZW5kZXJVbml0KHVuaXQpIHtcclxuICAgICAgICB0aGlzLl9yZW5kZXJlcnMuYWRkUmVuZGVyVW5pdCh1bml0KTtcclxuICAgIH1cclxuICAgIHJlbW92ZVJlbmRlclVuaXQodW5pdCkge1xyXG4gICAgICAgIHRoaXMuX3JlbmRlcmVycy5yZW1vdmVSZW5kZXJVbml0KHVuaXQpO1xyXG4gICAgfVxyXG4gICAgcmVuZGVyKHRhcmdldCwgLi4uYXJncykge1xyXG4gICAgICAgIC8vIHNraXAgYW50aWFsaWFzaW5nIGlmIHRoZXNlIGlzIGFjdGlvbiBpbiB0aGUgc2NlbmVcclxuICAgICAgICBpZiAodGhpcy5fcmVuZGVyTG9vcC5pc0FjdGl2ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlcnMucmVuZGVyKHRhcmdldCwgLi4uYXJncyk7XHJcbiAgICAgICAgICAgIC8vIHNjaGVkdWxlIGF0IGxlYXN0IG9uZSBtb3JlIHJlbmRlcmluZyB0byBub3QgbGVhdmUgc3RhdGljIChzdG9wcGVkKSBzY2VuZSBpbiBub24tYW50aWFsaWFzZWQgc3RhdGVcclxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyTG9vcC51cGRhdGUoKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMuX2ludGVybWVkaWF0ZVJlbmRlcmVCdWZmZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5faW5pdEludGVybWVkaWF0ZVJlbmRlclRhcmdldHModGFyZ2V0LmdldFdpZHRoKCksIHRhcmdldC5nZXRIZWlnaHQoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2ludGVybWVkaWF0ZVJlbmRlcmVCdWZmZXIuZ2V0V2lkdGgoKSAhPT0gdGFyZ2V0LmdldFdpZHRoKCkgfHxcclxuICAgICAgICAgICAgdGhpcy5faW50ZXJtZWRpYXRlUmVuZGVyZUJ1ZmZlci5nZXRIZWlnaHQoKSAhPT0gdGFyZ2V0LmdldEhlaWdodCgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3lJbnRlcm5hbFJlbmRlclRhcmdldHMoKTtcclxuICAgICAgICAgICAgdGhpcy5faW5pdEludGVybWVkaWF0ZVJlbmRlclRhcmdldHModGFyZ2V0LmdldFdpZHRoKCksIHRhcmdldC5nZXRIZWlnaHQoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFJlbmRlclRhcmdldCh0aGlzLl9pbnRlcm1lZGlhdGVSZW5kZXJlQnVmZmVyKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmNsZWFyQ3VycmVudFRhcmdldCgxNzY2NCAvKiBBTEwgKi8pO1xyXG4gICAgICAgIHRoaXMuX3JlbmRlcmVycy5yZW5kZXIodGhpcy5faW50ZXJtZWRpYXRlUmVuZGVyZUJ1ZmZlciwgLi4uYXJncyk7XHJcbiAgICAgICAgLy8gZG8gbm90IHJ1biBhbnRpYWxpYXNpbmcgb24gZW1wdHkgdGhpcy5faW50ZXJtZWRpYXRlUmVuZGVyZUJ1ZmZlclxyXG4gICAgICAgIGlmICghdGhpcy5faW50ZXJtZWRpYXRlUmVuZGVyZUJ1ZmZlci5pc0NsZWFyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUZyYW1lVW5pZm9ybVN0YXRlKHRhcmdldCk7XHJcbiAgICAgICAgICAgIHN1cGVyLnJlbmRlcih0YXJnZXQsIC4uLmFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2ludGVybWVkaWF0ZVJlbmRlcmVCdWZmZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5fZGVzdHJveUludGVybmFsUmVuZGVyVGFyZ2V0cygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9yZW5kZXIoKSB7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kUXVhZFZhbygpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuZHJhd1F1YWQoKTtcclxuICAgIH1cclxuICAgIF9wcmVwYXJlUHJvZ3JhbShwcm9ncmFtLCAuLi5hcmdzKSB7XHJcbiAgICAgICAgc3VwZXIuX3ByZXBhcmVQcm9ncmFtKHByb2dyYW0sIC4uLmFyZ3MpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFRleHR1cmVVbml0KDApO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFRleHR1cmUodGhpcy5faW50ZXJtZWRpYXRlQ29sb3JCdWZmZXIpO1xyXG4gICAgICAgIHByb2dyYW0uc2V0SW50U2NhbGFyVW5pZm9ybSgndGV4dHVyZScsIDApO1xyXG4gICAgICAgIHByb2dyYW0uc2V0VmVjdG9yMlVuaWZvcm0oJ3BpeGVsU2l6ZScsIHRoaXMuX3BpeGVsU2l6ZSk7XHJcbiAgICAgICAgcHJvZ3JhbS5zZXRTY2FsYXJVbmlmb3JtKCdkcHInLCBnZXREcHIoKSk7XHJcbiAgICB9XHJcbiAgICBfdXBkYXRlRnJhbWVVbmlmb3JtU3RhdGUodGFyZ2V0KSB7XHJcbiAgICAgICAgdGhpcy5fcGl4ZWxTaXplLnggPSAxIC8gdGFyZ2V0LmdldFdpZHRoKCk7XHJcbiAgICAgICAgdGhpcy5fcGl4ZWxTaXplLnkgPSAxIC8gdGFyZ2V0LmdldEhlaWdodCgpO1xyXG4gICAgfVxyXG4gICAgX2luaXRJbnRlcm1lZGlhdGVSZW5kZXJUYXJnZXRzKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5fY29udGV4dDtcclxuICAgICAgICBjb25zdCBpbnRlcm1lZGlhdGVDb2xvckJ1ZmZlciA9IHRoaXMuX2ludGVybWVkaWF0ZUNvbG9yQnVmZmVyID1cclxuICAgICAgICAgICAgY29udGV4dC5jcmVhdGVFbXB0eTJEVGV4dHVyZSh3aWR0aCwgaGVpZ2h0LCA2NDA4IC8qIFJHQkEgKi8sIDUxMjEgLyogVU5TSUdORURfQllURSAqLyk7XHJcbiAgICAgICAgY29uc3QgaW50ZXJtZWRpYXRlRGVwdGhTdGVuY2lsQnVmZmVyID0gdGhpcy5faW50ZXJtZWRpYXRlRGVwdGhTdGVuY2lsQnVmZmVyID1cclxuICAgICAgICAgICAgY29udGV4dC5jcmVhdGVSZW5kZXJidWZmZXIod2lkdGgsIGhlaWdodCwgMzQwNDEgLyogREVQVEhfU1RFTkNJTCAqLyk7XHJcbiAgICAgICAgdGhpcy5faW50ZXJtZWRpYXRlUmVuZGVyZUJ1ZmZlciA9IGNvbnRleHQuY3JlYXRlRnJhbWVidWZmZXIoe1xyXG4gICAgICAgICAgICBjb2xvcjogaW50ZXJtZWRpYXRlQ29sb3JCdWZmZXIsXHJcbiAgICAgICAgICAgIGRlcHRoU3RlbmNpbDogaW50ZXJtZWRpYXRlRGVwdGhTdGVuY2lsQnVmZmVyXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfZGVzdHJveUludGVybmFsUmVuZGVyVGFyZ2V0cygpIHtcclxuICAgICAgICB0aGlzLl9pbnRlcm1lZGlhdGVSZW5kZXJlQnVmZmVyLmRlc3Ryb3koKTtcclxuICAgICAgICB0aGlzLl9pbnRlcm1lZGlhdGVDb2xvckJ1ZmZlci5kZXN0cm95KCk7XHJcbiAgICAgICAgdGhpcy5faW50ZXJtZWRpYXRlRGVwdGhTdGVuY2lsQnVmZmVyLmRlc3Ryb3koKTtcclxuICAgIH1cclxufVxyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiI3ZlcnNpb24gMTAwXFxuXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG51bmlmb3JtIHZlYzIgcGl4ZWxTaXplO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHRleHR1cmU7XFxudW5pZm9ybSBmbG9hdCBkcHI7XFxuXFxuY29uc3QgZmxvYXQgRlhBQV9RVUFMSVRZX1NVQlBJWCA9IDAuNzU7XFxuY29uc3QgZmxvYXQgRlhBQV9RVUFMSVRZX0VER0VfVEhSRVNIT0xEID0gMC4wNjM7XFxuY29uc3QgZmxvYXQgRlhBQV9RVUFMSVRZX0VER0VfVEhSRVNIT0xEX01JTiA9IDAuMDYyNTtcXG5jb25zdCBmbG9hdCBFUFNJTE9OID0gMC4wMDAxO1xcblxcbmZsb2F0IGx1bWEodmVjNCByZ2JhKSB7XFxuICAgIHJldHVybiBkb3QocmdiYS54eXosIHZlYzMoMC4yOTksIDAuNTg3LCAwLjExNCkpO1xcbn1cXG5cXG52ZWM0IGZ4YWEoXFxuICAgIHZlYzIgcG9zLFxcbiAgICBzYW1wbGVyMkQgdGV4LFxcbiAgICB2ZWMyIGZ4YWFRdWFsaXR5UmNwRnJhbWUsXFxuICAgIC8vIFRoaXMgdXNlZCB0byBiZSB0aGUgRlhBQV9RVUFMSVRZX1NVQlBJWCBkZWZpbmUuXFxuICAgIC8vIENob29zZSB0aGUgYW1vdW50IG9mIHN1Yi1waXhlbCBhbGlhc2luZyByZW1vdmFsLlxcbiAgICAvLyBUaGlzIGNhbiBlZmZlY3Qgc2hhcnBuZXNzLlxcbiAgICAvLyAgIDEuMDAgLSB1cHBlciBsaW1pdCAoc29mdGVyKVxcbiAgICAvLyAgIDAuNzUgLSBkZWZhdWx0IGFtb3VudCBvZiBmaWx0ZXJpbmdcXG4gICAgLy8gICAwLjUwIC0gbG93ZXIgbGltaXQgKHNoYXJwZXIsIGxlc3Mgc3ViLXBpeGVsIGFsaWFzaW5nIHJlbW92YWwpXFxuICAgIC8vICAgMC4yNSAtIGFsbW9zdCBvZmZcXG4gICAgLy8gICAwLjAwIC0gY29tcGxldGVseSBvZmZcXG4gICAgZmxvYXQgZnhhYVF1YWxpdHlTdWJwaXgsXFxuICAgIC8vIFRoaXMgdXNlZCB0byBiZSB0aGUgRlhBQV9RVUFMSVRZX0VER0VfVEhSRVNIT0xEIGRlZmluZS5cXG4gICAgLy8gVGhlIG1pbmltdW0gYW1vdW50IG9mIGxvY2FsIGNvbnRyYXN0IHJlcXVpcmVkIHRvIGFwcGx5IGFsZ29yaXRobS5cXG4gICAgLy8gICAwLjMzMyAtIHRvbyBsaXR0bGUgKGZhc3RlcilcXG4gICAgLy8gICAwLjI1MCAtIGxvdyBxdWFsaXR5XFxuICAgIC8vICAgMC4xNjYgLSBkZWZhdWx0XFxuICAgIC8vICAgMC4xMjUgLSBoaWdoIHF1YWxpdHlcXG4gICAgLy8gICAwLjA2MyAtIG92ZXJraWxsIChzbG93ZXIpXFxuICAgIGZsb2F0IGZ4YWFRdWFsaXR5RWRnZVRocmVzaG9sZCxcXG4gICAgLy8gVGhpcyB1c2VkIHRvIGJlIHRoZSBGWEFBX1FVQUxJVFlfRURHRV9USFJFU0hPTERfTUlOIGRlZmluZS5cXG4gICAgLy8gVHJpbXMgdGhlIGFsZ29yaXRobSBmcm9tIHByb2Nlc3NpbmcgZGFya3MuXFxuICAgIC8vICAgMC4wODMzIC0gdXBwZXIgbGltaXQgKGRlZmF1bHQsIHRoZSBzdGFydCBvZiB2aXNpYmxlIHVuZmlsdGVyZWQgZWRnZXMpXFxuICAgIC8vICAgMC4wNjI1IC0gaGlnaCBxdWFsaXR5IChmYXN0ZXIpXFxuICAgIC8vICAgMC4wMzEyIC0gdmlzaWJsZSBsaW1pdCAoc2xvd2VyKVxcbiAgICBmbG9hdCBmeGFhUXVhbGl0eUVkZ2VUaHJlc2hvbGRNaW5cXG4pIHtcXG4gICAgdmVjMiBwb3NNO1xcbiAgICBwb3NNLnggPSBwb3MueDtcXG4gICAgcG9zTS55ID0gcG9zLnk7XFxuICAgIHZlYzQgcmdieU0gPSB0ZXh0dXJlMkQodGV4LCBwb3NNKTtcXG4gICAgZmxvYXQgbHVtYU0gPSBsdW1hKHJnYnlNKTtcXG5cXG4gICAgZmxvYXQgbHVtYVMgPSBsdW1hKHRleHR1cmUyRCh0ZXgsIHBvc00gKyB2ZWMyKCAwLCAxKSAqIGZ4YWFRdWFsaXR5UmNwRnJhbWUueHkpKTtcXG4gICAgZmxvYXQgbHVtYUUgPSBsdW1hKHRleHR1cmUyRCh0ZXgsIHBvc00gKyB2ZWMyKCAxLCAwKSAqIGZ4YWFRdWFsaXR5UmNwRnJhbWUueHkpKTtcXG4gICAgZmxvYXQgbHVtYU4gPSBsdW1hKHRleHR1cmUyRCh0ZXgsIHBvc00gKyB2ZWMyKCAwLC0xKSAqIGZ4YWFRdWFsaXR5UmNwRnJhbWUueHkpKTtcXG4gICAgZmxvYXQgbHVtYVcgPSBsdW1hKHRleHR1cmUyRCh0ZXgsIHBvc00gKyB2ZWMyKC0xLCAwKSAqIGZ4YWFRdWFsaXR5UmNwRnJhbWUueHkpKTtcXG5cXG4gICAgZmxvYXQgbWF4U00gPSBtYXgobHVtYVMsIGx1bWFNKTtcXG4gICAgZmxvYXQgbWluU00gPSBtaW4obHVtYVMsIGx1bWFNKTtcXG4gICAgZmxvYXQgbWF4RVNNID0gbWF4KGx1bWFFLCBtYXhTTSk7XFxuICAgIGZsb2F0IG1pbkVTTSA9IG1pbihsdW1hRSwgbWluU00pO1xcbiAgICBmbG9hdCBtYXhXTiA9IG1heChsdW1hTiwgbHVtYVcpO1xcbiAgICBmbG9hdCBtaW5XTiA9IG1pbihsdW1hTiwgbHVtYVcpO1xcbiAgICBmbG9hdCByYW5nZU1heCA9IG1heChtYXhXTiwgbWF4RVNNKTtcXG4gICAgZmxvYXQgcmFuZ2VNaW4gPSBtaW4obWluV04sIG1pbkVTTSk7XFxuICAgIGZsb2F0IHJhbmdlTWF4U2NhbGVkID0gcmFuZ2VNYXggKiBmeGFhUXVhbGl0eUVkZ2VUaHJlc2hvbGQ7XFxuICAgIGZsb2F0IHJhbmdlID0gcmFuZ2VNYXggLSByYW5nZU1pbjtcXG4gICAgZmxvYXQgcmFuZ2VNYXhDbGFtcGVkID0gbWF4KGZ4YWFRdWFsaXR5RWRnZVRocmVzaG9sZE1pbiwgcmFuZ2VNYXhTY2FsZWQpO1xcbiAgICBib29sIGVhcmx5RXhpdCA9IHJhbmdlIDwgcmFuZ2VNYXhDbGFtcGVkO1xcblxcbiAgICBpZiAoZWFybHlFeGl0KVxcbiAgICAgICAgcmV0dXJuIHJnYnlNO1xcblxcbiAgICBmbG9hdCBsdW1hTlcgPSBsdW1hKHRleHR1cmUyRCh0ZXgsIHBvc00gKyB2ZWMyKC0xLC0xKSAqIGZ4YWFRdWFsaXR5UmNwRnJhbWUueHkpKTtcXG4gICAgZmxvYXQgbHVtYVNFID0gbHVtYSh0ZXh0dXJlMkQodGV4LCBwb3NNICsgdmVjMiggMSwgMSkgKiBmeGFhUXVhbGl0eVJjcEZyYW1lLnh5KSk7XFxuICAgIGZsb2F0IGx1bWFORSA9IGx1bWEodGV4dHVyZTJEKHRleCwgcG9zTSArIHZlYzIoIDEsLTEpICogZnhhYVF1YWxpdHlSY3BGcmFtZS54eSkpO1xcbiAgICBmbG9hdCBsdW1hU1cgPSBsdW1hKHRleHR1cmUyRCh0ZXgsIHBvc00gKyB2ZWMyKC0xLCAxKSAqIGZ4YWFRdWFsaXR5UmNwRnJhbWUueHkpKTtcXG5cXG4gICAgZmxvYXQgbHVtYU5TID0gbHVtYU4gKyBsdW1hUztcXG4gICAgZmxvYXQgbHVtYVdFID0gbHVtYVcgKyBsdW1hRTtcXG4gICAgZmxvYXQgc3VicGl4UmNwUmFuZ2UgPSAxLjAvcmFuZ2U7XFxuICAgIGZsb2F0IHN1YnBpeE5TV0UgPSBsdW1hTlMgKyBsdW1hV0U7XFxuICAgIGZsb2F0IGVkZ2VIb3J6MSA9ICgtMi4wICogbHVtYU0pICsgbHVtYU5TO1xcbiAgICBmbG9hdCBlZGdlVmVydDEgPSAoLTIuMCAqIGx1bWFNKSArIGx1bWFXRTtcXG5cXG4gICAgZmxvYXQgbHVtYU5FU0UgPSBsdW1hTkUgKyBsdW1hU0U7XFxuICAgIGZsb2F0IGx1bWFOV05FID0gbHVtYU5XICsgbHVtYU5FO1xcbiAgICBmbG9hdCBlZGdlSG9yejIgPSAoLTIuMCAqIGx1bWFFKSArIGx1bWFORVNFO1xcbiAgICBmbG9hdCBlZGdlVmVydDIgPSAoLTIuMCAqIGx1bWFOKSArIGx1bWFOV05FO1xcblxcbiAgICBmbG9hdCBsdW1hTldTVyA9IGx1bWFOVyArIGx1bWFTVztcXG4gICAgZmxvYXQgbHVtYVNXU0UgPSBsdW1hU1cgKyBsdW1hU0U7XFxuICAgIGZsb2F0IGVkZ2VIb3J6NCA9IChhYnMoZWRnZUhvcnoxKSAqIDIuMCkgKyBhYnMoZWRnZUhvcnoyKTtcXG4gICAgZmxvYXQgZWRnZVZlcnQ0ID0gKGFicyhlZGdlVmVydDEpICogMi4wKSArIGFicyhlZGdlVmVydDIpO1xcbiAgICBmbG9hdCBlZGdlSG9yejMgPSAoLTIuMCAqIGx1bWFXKSArIGx1bWFOV1NXO1xcbiAgICBmbG9hdCBlZGdlVmVydDMgPSAoLTIuMCAqIGx1bWFTKSArIGx1bWFTV1NFO1xcbiAgICBmbG9hdCBlZGdlSG9yeiA9IGFicyhlZGdlSG9yejMpICsgZWRnZUhvcno0O1xcbiAgICBmbG9hdCBlZGdlVmVydCA9IGFicyhlZGdlVmVydDMpICsgZWRnZVZlcnQ0O1xcblxcbiAgICBmbG9hdCBzdWJwaXhOV1NXTkVTRSA9IGx1bWFOV1NXICsgbHVtYU5FU0U7XFxuICAgIGZsb2F0IGxlbmd0aFNpZ24gPSBmeGFhUXVhbGl0eVJjcEZyYW1lLng7XFxuICAgIGJvb2wgaG9yelNwYW4gPSBlZGdlSG9yeiA+PSBlZGdlVmVydDtcXG4gICAgZmxvYXQgc3VicGl4QSA9IHN1YnBpeE5TV0UgKiAyLjAgKyBzdWJwaXhOV1NXTkVTRTtcXG5cXG4gICAgaWYgKGhvcnpTcGFuKSB7XFxuICAgICAgICBsZW5ndGhTaWduID0gZnhhYVF1YWxpdHlSY3BGcmFtZS55O1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgbHVtYU4gPSBsdW1hVztcXG4gICAgICAgIGx1bWFTID0gbHVtYUU7XFxuICAgIH1cXG4gICAgZmxvYXQgc3VicGl4QiA9IChzdWJwaXhBICogKDEuMC8xMi4wKSkgLSBsdW1hTTtcXG5cXG4gICAgZmxvYXQgZ3JhZGllbnROID0gbHVtYU4gLSBsdW1hTTtcXG4gICAgZmxvYXQgZ3JhZGllbnRTID0gbHVtYVMgLSBsdW1hTTtcXG4gICAgZmxvYXQgbHVtYU5OID0gbHVtYU4gKyBsdW1hTTtcXG4gICAgZmxvYXQgbHVtYVNTID0gbHVtYVMgKyBsdW1hTTtcXG4gICAgYm9vbCBwYWlyTiA9IGFicyhncmFkaWVudE4pID49IGFicyhncmFkaWVudFMpO1xcbiAgICBmbG9hdCBncmFkaWVudCA9IG1heChhYnMoZ3JhZGllbnROKSwgYWJzKGdyYWRpZW50UykpO1xcbiAgICBpZiAocGFpck4pIHtcXG4gICAgICAgIGxlbmd0aFNpZ24gPSAtbGVuZ3RoU2lnbjtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIGx1bWFOTiA9IGx1bWFTUztcXG4gICAgfVxcbiAgICBmbG9hdCBzdWJwaXhDID0gY2xhbXAoYWJzKHN1YnBpeEIpICogc3VicGl4UmNwUmFuZ2UsIDAuMCwgMS4wKTtcXG5cXG4gICAgdmVjMiBwb3NCID0gcG9zTTtcXG4gICAgdmVjMiBvZmZOUDtcXG5cXG4gICAgdmVjMiBvZmZITTtcXG4gICAgaWYgKGhvcnpTcGFuKSB7XFxuICAgICAgICBvZmZOUCA9IHZlYzIoZnhhYVF1YWxpdHlSY3BGcmFtZS54LCAwLjApO1xcbiAgICAgICAgb2ZmSE0gPSB2ZWMyKDAuMCwgbGVuZ3RoU2lnbik7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICBvZmZOUCA9IHZlYzIoMC4wLCBmeGFhUXVhbGl0eVJjcEZyYW1lLnkpO1xcbiAgICAgICAgb2ZmSE0gPSB2ZWMyKGxlbmd0aFNpZ24sIDAuMCk7XFxuICAgIH1cXG5cXG4gICAgdmVjMiBwb3NOID0gcG9zQiAtIG9mZk5QICogMi47XFxuICAgIHZlYzIgcG9zUCA9IHBvc0IgKyBvZmZOUCAqIDIuO1xcblxcbiAgICBmbG9hdCBzdWJwaXhEID0gKCgtMi4wKSpzdWJwaXhDKSArIDMuMDtcXG4gICAgZmxvYXQgbHVtYUVuZE4gPSBsdW1hKFxcbiAgICAgICAgbWl4KFxcbiAgICAgICAgICAgIHRleHR1cmUyRCh0ZXgsIHBvc04pLFxcbiAgICAgICAgICAgIHRleHR1cmUyRCh0ZXgsIHBvc04gKyBvZmZITSksXFxuICAgICAgICAgICAgMC41XFxuICAgICAgICApXFxuICAgICk7XFxuICAgIGZsb2F0IHN1YnBpeEUgPSBzdWJwaXhDICogc3VicGl4QztcXG4gICAgZmxvYXQgbHVtYUVuZFAgPSBsdW1hKFxcbiAgICAgICAgbWl4KFxcbiAgICAgICAgICAgIHRleHR1cmUyRCh0ZXgsIHBvc1ApLFxcbiAgICAgICAgICAgIHRleHR1cmUyRCh0ZXgsIHBvc1AgKyBvZmZITSksXFxuICAgICAgICAgICAgMC41XFxuICAgICAgICApXFxuICAgICk7XFxuXFxuICAgIGZsb2F0IGdyYWRpZW50U2NhbGVkID0gZ3JhZGllbnQgKiAwLjI1O1xcbiAgICBmbG9hdCBsdW1hTU0gPSBsdW1hTSAtIGx1bWFOTiAqIDAuNTtcXG4gICAgZmxvYXQgc3VicGl4RiA9IHN1YnBpeEQgKiBzdWJwaXhFO1xcbiAgICBib29sIGx1bWFNTFRaZXJvID0gbHVtYU1NIDwgMC4wO1xcblxcbiAgICBsdW1hRW5kTiAtPSBsdW1hTk4gKiAwLjU7XFxuICAgIGx1bWFFbmRQIC09IGx1bWFOTiAqIDAuNTtcXG4gICAgYm9vbCBkb25lTiA9IGFicyhsdW1hRW5kTikgPj0gZ3JhZGllbnRTY2FsZWQ7XFxuICAgIGJvb2wgZG9uZVAgPSBhYnMobHVtYUVuZFApID49IGdyYWRpZW50U2NhbGVkO1xcbiAgICBpZiAoIWRvbmVOKSB7XFxuICAgICAgICBwb3NOIC09IG9mZk5QICogMy4wO1xcbiAgICB9XFxuICAgIGJvb2wgZG9uZU5QID0gKCFkb25lTikgfHwgKCFkb25lUCk7XFxuICAgIGlmICghZG9uZVApIHtcXG4gICAgICAgIHBvc1AgKz0gb2ZmTlAgKiAzLjA7XFxuICAgIH1cXG5cXG4gICAgaWYgKGRvbmVOUCkge1xcbiAgICAgICAgaWYgKCFkb25lTikge1xcbiAgICAgICAgICAgIGx1bWFFbmROID0gbHVtYShcXG4gICAgICAgICAgICAgICAgbWl4KFxcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZTJEKHRleCwgcG9zTiksXFxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlMkQodGV4LCBwb3NOICsgb2ZmSE0pLFxcbiAgICAgICAgICAgICAgICAgICAgMC41XFxuICAgICAgICAgICAgICAgIClcXG4gICAgICAgICAgICApO1xcbiAgICAgICAgICAgIGx1bWFFbmROID0gbHVtYUVuZE4gLSBsdW1hTk4gKiAwLjU7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoIWRvbmVQKSB7XFxuICAgICAgICAgICAgbHVtYUVuZFAgPSBsdW1hKFxcbiAgICAgICAgICAgICAgICBtaXgoXFxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlMkQodGV4LCBwb3NQLnh5KSxcXG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmUyRCh0ZXgsIHBvc1AueHkgKyBvZmZITSksXFxuICAgICAgICAgICAgICAgICAgICAwLjVcXG4gICAgICAgICAgICAgICAgKVxcbiAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgbHVtYUVuZFAgPSBsdW1hRW5kUCAtIGx1bWFOTiAqIDAuNTtcXG4gICAgICAgIH1cXG4gICAgICAgIGRvbmVOID0gYWJzKGx1bWFFbmROKSA+PSBncmFkaWVudFNjYWxlZDtcXG4gICAgICAgIGRvbmVQID0gYWJzKGx1bWFFbmRQKSA+PSBncmFkaWVudFNjYWxlZDtcXG4gICAgICAgIGlmICghZG9uZU4pIHtcXG4gICAgICAgICAgICBwb3NOIC09IG9mZk5QICogMTIuMDtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICghZG9uZVApIHtcXG4gICAgICAgICAgICBwb3NQICs9IG9mZk5QICogMTIuMDtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICBmbG9hdCBkc3ROID0gcG9zTS54IC0gcG9zTi54O1xcbiAgICBmbG9hdCBkc3RQID0gcG9zUC54IC0gcG9zTS54O1xcbiAgICBpZiAoIWhvcnpTcGFuKSB7XFxuICAgICAgICBkc3ROID0gcG9zTS55IC0gcG9zTi55O1xcbiAgICAgICAgZHN0UCA9IHBvc1AueSAtIHBvc00ueTtcXG4gICAgfVxcbiAgICBib29sIGdvb2RTcGFuTiA9IChsdW1hRW5kTiA8IDAuMCkgIT0gbHVtYU1MVFplcm87XFxuICAgIGZsb2F0IHNwYW5MZW5ndGggPSAoZHN0UCArIGRzdE4pO1xcbiAgICBib29sIGdvb2RTcGFuUCA9IChsdW1hRW5kUCA8IDAuMCkgIT0gbHVtYU1MVFplcm87XFxuICAgIGZsb2F0IHNwYW5MZW5ndGhSY3AgPSAxLjAvc3Bhbkxlbmd0aDtcXG4gICAgYm9vbCBkaXJlY3Rpb25OID0gZHN0TiA8IGRzdFA7XFxuICAgIGZsb2F0IGRzdCA9IG1pbihkc3ROLCBkc3RQKTtcXG4gICAgYm9vbCBnb29kU3BhbiA9IGRpcmVjdGlvbk4gPyBnb29kU3Bhbk4gOiBnb29kU3BhblA7XFxuICAgIGZsb2F0IHN1YnBpeEcgPSBzdWJwaXhGICogc3VicGl4RjtcXG4gICAgZmxvYXQgcGl4ZWxPZmZzZXQgPSAoZHN0ICogKC1zcGFuTGVuZ3RoUmNwKSkgKyAwLjU7XFxuICAgIGZsb2F0IHN1YnBpeEggPSBzdWJwaXhHICogZnhhYVF1YWxpdHlTdWJwaXg7XFxuICAgIGZsb2F0IHBpeGVsT2Zmc2V0R29vZCA9IGdvb2RTcGFuID8gcGl4ZWxPZmZzZXQgOiAwLjA7XFxuICAgIGZsb2F0IHBpeGVsT2Zmc2V0U3VicGl4ID0gbWF4KHBpeGVsT2Zmc2V0R29vZCwgc3VicGl4SCk7XFxuICAgIHZlYzQgY29sb3I7XFxuICAgIGZsb2F0IGZhY3RvciA9IHBpeGVsT2Zmc2V0U3VicGl4O1xcbiAgICBpZiAoaG9yelNwYW4pIHtcXG4gICAgICAgIGNvbG9yID0gbWl4KFxcbiAgICAgICAgICAgIHRleHR1cmUyRCh0ZXgsIHBvc00pLFxcbiAgICAgICAgICAgIHRleHR1cmUyRCh0ZXgsIHBvc00gKyB2ZWMyKDAuMCwgbGVuZ3RoU2lnbikpLFxcbiAgICAgICAgICAgIGZhY3RvclxcbiAgICAgICAgKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIGNvbG9yID0gbWl4KFxcbiAgICAgICAgICAgIHRleHR1cmUyRCh0ZXgsIHBvc00pLFxcbiAgICAgICAgICAgIHRleHR1cmUyRCh0ZXgsIHBvc00gKyB2ZWMyKGxlbmd0aFNpZ24sIDAuMCkpLFxcbiAgICAgICAgICAgIGZhY3RvclxcbiAgICAgICAgKTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gY29sb3I7XFxufVxcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgdmVjMiBwb3MgPSBnbF9GcmFnQ29vcmQueHkgKiBwaXhlbFNpemU7XFxuICAgIHZlYzQgY29sb3IgPSBmeGFhKFxcbiAgICAgICAgcG9zLFxcbiAgICAgICAgdGV4dHVyZSxcXG4gICAgICAgIHBpeGVsU2l6ZSxcXG4gICAgICAgIEZYQUFfUVVBTElUWV9TVUJQSVgsXFxuICAgICAgICBGWEFBX1FVQUxJVFlfRURHRV9USFJFU0hPTEQsXFxuICAgICAgICBGWEFBX1FVQUxJVFlfRURHRV9USFJFU0hPTERfTUlOXFxuICAgICk7XFxuXFxuICAgIC8vIElmIGNvbG9yLmEgaXMgbGVzcyB0aGFuIG9uZSwgdGhlbiB0aGUgY29sb3IgaGFzIGJlZW4gYmxlbmRlZCB3aXRoIGEgYmxhY2sgYmFja2dyb3VuZCBiZWZvcmUuXFxuICAgIC8vIEFuIG9yaWdpbmFsIGNvbG9yIG9mIHRyYW5zcGFyZW50IG9iamVjdHMgaXMgdmVjNChjb2xvci54eXogLyBjb2xvci5hLCBjb2xvci5hKS5cXG4gICAgLy8gV2UgaGF2ZSB0byBibGVuZCBhbiBvcmlnaW5hbCBjb2xvciB3aXRoIGJhY2tncm91bmQgcGF0dGVybi5cXG4gICAgLy8gY29sb3IuYSBjYW4gYmUgdG9vIGNsb3NlIHRvIHplcm8uIENoZWNrIGl0LlxcbiAgICBpZiAoY29sb3IuYSA+IEVQU0lMT04pIHtcXG4gICAgICAgIGNvbG9yLnh5eiAvPSBjb2xvci5hO1xcbiAgICB9XFxuICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbn1cXG5cIiIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleFBvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleFV2O1xcblxcbnVuaWZvcm0gZmxvYXQgekluZGV4O1xcblxcbiNpZm5kZWYgWVZfTEVBU1RfMTZiX1BcXG4jICAgaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcXG4jICAgICAgIGRlZmluZSBZVl9MRUFTVF8xNmJfUCBoaWdocFxcbiMgICBlbHNlXFxuIyAgICAgICBkZWZpbmUgWVZfTEVBU1RfMTZiX1AgbWVkaXVtcFxcbiMgICBlbmRpZlxcbiNlbmRpZlxcblxcbnZhcnlpbmcgWVZfTEVBU1RfMTZiX1AgdmVjMiB1djtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgICBnbF9Qb3NpdGlvbiA9IHZlYzQodmVydGV4UG9zaXRpb24sIHpJbmRleCwgMSk7XFxuICAgIHV2ID0gdmVydGV4VXY7XFxufVxcblwiIiwiaW1wb3J0IHsgR2xSZW5kZXJlciB9IGZyb20gJy4vZ2xfcmVuZGVyZXInO1xyXG5pbXBvcnQgUmVuZGVyU3RhdGUgZnJvbSAnLi9zdGF0ZSc7XHJcbmltcG9ydCB7IFZvaWRFdmVudEVtaXR0ZXIgfSBmcm9tICcuLy4uL3V0aWwvZXZlbnRfZW1pdHRlcic7XHJcbmltcG9ydCBxdWFkVmVydGV4U2hhZGVyIGZyb20gJy4vc2hhZGVycy9xdWFkLnZlcnQnO1xyXG5pbXBvcnQgYmFja2dyb3VuZEZyYWdtZW50U2hhZGVyIGZyb20gJy4vc2hhZGVycy9iYWNrZ3JvdW5kLmZyYWcnO1xyXG5pbXBvcnQgZ2V0RHByIGZyb20gJy4uL3V0aWwvaGQnO1xyXG5jb25zdCBTVEFURSA9IG5ldyBSZW5kZXJTdGF0ZSh7XHJcbiAgICBkZXB0aFRlc3Q6IHRydWUsXHJcbiAgICBkZXB0aEZ1bmM6IDUxOCAvKiBHUkVBVEVSX09SX0VRVUFMICovXHJcbn0pO1xyXG4vKipcclxuICogRmlsbHMgbWFwJ3MgY2FudmFzIHdpdGggYmFja2dyb3VuZCBwYXR0ZXJuIG9uIHJlZ2lvbnMgdGhhdCBoYXZlIG5vIGRhdGEgeWV0LlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFja2dyb3VuZFJlbmRlclVuaXQgZXh0ZW5kcyBHbFJlbmRlcmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcclxuICAgICAgICBjb25zdCBwcm9ncmFtID0gY29udGV4dC5jcmVhdGVQcm9ncmFtKHF1YWRWZXJ0ZXhTaGFkZXIsIGJhY2tncm91bmRGcmFnbWVudFNoYWRlciwge1xyXG4gICAgICAgICAgICBhdHRyaWJNYXA6IHtcclxuICAgICAgICAgICAgICAgIHZlcnRleFBvc2l0aW9uOiAwIC8qIFBPU0lUSU9OICovLFxyXG4gICAgICAgICAgICAgICAgdmVydGV4VXY6IDQgLyogVVYgKi9cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHN1cGVyKGNvbnRleHQsIFNUQVRFLCBwcm9ncmFtKTtcclxuICAgICAgICBjb250ZXh0LmJpbmRQcm9ncmFtKHByb2dyYW0pO1xyXG4gICAgICAgIHByb2dyYW0uc2V0U2NhbGFyVW5pZm9ybSgnekluZGV4JywgLTEpO1xyXG4gICAgICAgIHRoaXMub25VcGRhdGUgPSBuZXcgVm9pZEV2ZW50RW1pdHRlcigpO1xyXG4gICAgfVxyXG4gICAgX3JlbmRlcigpIHtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRRdWFkVmFvKCk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5kcmF3UXVhZCgpO1xyXG4gICAgfVxyXG4gICAgX3ByZXBhcmVQcm9ncmFtKHByb2dyYW0pIHtcclxuICAgICAgICBzdXBlci5fcHJlcGFyZVByb2dyYW0ocHJvZ3JhbSk7XHJcbiAgICAgICAgcHJvZ3JhbS5zZXRTY2FsYXJVbmlmb3JtKCdkcHInLCBnZXREcHIoKSk7XHJcbiAgICB9XHJcbn1cclxuIiwibW9kdWxlLmV4cG9ydHMgPSBcIiN2ZXJzaW9uIDEwMFxcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxudm9pZCBtYWluKCkge1xcbiAgICAvLyBCYWNrZ3JvdW5kIGNvbG9yIHNob3VsZCBtYXRjaCBtYWluIG1hcCBsYXllciBjb2xvci5cXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjk4LCAwLjk3LCAwLjk0LCAxKTtcXG59XFxuXCIiLCJpbXBvcnQgTGlzdFJlbmRlclVuaXQgZnJvbSAnLi9saXN0X3JlbmRlcl91bml0JztcclxuaW1wb3J0IFJlbmRlclN0YXRlIGZyb20gJy4vc3RhdGUnO1xyXG5jb25zdCBERVBUSF9DTEVBUl9TVEFURSA9IG5ldyBSZW5kZXJTdGF0ZSh7XHJcbiAgICBkZXB0aFRlc3Q6IHRydWUsXHJcbiAgICBjbGVhckRlcHRoOiAwXHJcbn0pO1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMYXllclJlbmRlclVuaXQgZXh0ZW5kcyBMaXN0UmVuZGVyVW5pdCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBkZXB0aENsZWFyU3RyYXRlZ3kgPSAwIC8qIE5PX0NMRUFSICovKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl9kZXB0aENsZWFyU3RyYXRlZ3kgPSBkZXB0aENsZWFyU3RyYXRlZ3k7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XHJcbiAgICB9XHJcbiAgICByZW5kZXIodGFyZ2V0LCAuLi5hcmdzKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2RlcHRoQ2xlYXJTdHJhdGVneSA9PT0gMSAvKiBCRUZPUkVfUkVOREVSICovKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFJlbmRlclN0YXRlKERFUFRIX0NMRUFSX1NUQVRFKTtcclxuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kUmVuZGVyVGFyZ2V0KHRhcmdldCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuY2xlYXJDdXJyZW50VGFyZ2V0KDI1NiAvKiBERVBUSF9CVUZGRVJfQklUICovKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3VwZXIucmVuZGVyKHRhcmdldCwgLi4uYXJncyk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IFJlbmRlclN0YXRlIGZyb20gJy4uLy4uL3JlbmRlci9zdGF0ZSc7XHJcbmltcG9ydCB7IGNvdW50SW5kaWNlcyB9IGZyb20gJy4uLy4uL3JlbmRlci9tZW1vcnkvY291bnRfdmVydGljZXMnO1xyXG5pbXBvcnQgcmVzZXRSZW1vdmVkVmVydGV4U2hhZGVyIGZyb20gJy4vc2hhZGVycy9yZXNldF9yZW1vdmVkLnZlcnQnO1xyXG5pbXBvcnQgcmVzZXRSZW1vdmVkRnJhZ21lbnRTaGFkZXIgZnJvbSAnLi9zaGFkZXJzL3Jlc2V0X3JlbW92ZWQuZnJhZyc7XHJcbmltcG9ydCB7IEdsUmVuZGVyZXIgfSBmcm9tICcuLi8uLi9yZW5kZXIvZ2xfcmVuZGVyZXInO1xyXG5pbXBvcnQgeyBiYXRjaFByaW1pdGl2ZXMgfSBmcm9tICcuLi8uLi9yZW5kZXIvcHJpbWl0aXZlcy9wcmltaXRpdmVfYmF0Y2gnO1xyXG5leHBvcnQgY2xhc3MgQ29sbGlkaW5nUHJpbWl0aXZlc1Jlc2V0UmVtb3ZlZFJlbmRlcmVyIGV4dGVuZHMgR2xSZW5kZXJlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBwcmltaXRpdmVQcm92aWRlcikge1xyXG4gICAgICAgIGNvbnN0IHByb2dyYW0gPSBjb250ZXh0LmNyZWF0ZVByb2dyYW0ocmVzZXRSZW1vdmVkVmVydGV4U2hhZGVyLCByZXNldFJlbW92ZWRGcmFnbWVudFNoYWRlciwge1xyXG4gICAgICAgICAgICBhdHRyaWJNYXA6IHtcclxuICAgICAgICAgICAgICAgIHZlcnRleElkOiAyIC8qIElEICovXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBzdXBlcihjb250ZXh0LCBuZXcgUmVuZGVyU3RhdGUoKSwgcHJvZ3JhbSk7XHJcbiAgICAgICAgdGhpcy5fcHJpbWl0aXZlUHJvdmlkZXIgPSBwcmltaXRpdmVQcm92aWRlcjtcclxuICAgICAgICBjb250ZXh0LmJpbmRQcm9ncmFtKHByb2dyYW0pO1xyXG4gICAgICAgIHByb2dyYW0uc2V0SW50U2NhbGFyVW5pZm9ybSgncHJldlZpc2liaWxpdHknLCAwKTtcclxuICAgIH1cclxuICAgIF9yZW5kZXIoKSB7XHJcbiAgICAgICAgY29uc3QgcHJpbWl0aXZlcyA9IHRoaXMuX3ByaW1pdGl2ZVByb3ZpZGVyLnByaW1pdGl2ZXM7XHJcbiAgICAgICAgZm9yIChjb25zdCBtZW1vcnlCYXRjaCBvZiBiYXRjaFByaW1pdGl2ZXMocHJpbWl0aXZlcykpIHtcclxuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kVmFvKG1lbW9yeUJhdGNoLnBhZ2UudmFvKTtcclxuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5kcmF3SW5kZXhlZE1lc2gobWVtb3J5QmF0Y2guaW5kZXhCeXRlT2Zmc2V0LCBjb3VudEluZGljZXMobWVtb3J5QmF0Y2guaW5kZXhCeXRlTGVuZ3RoLCBtZW1vcnlCYXRjaC5wYWdlLmluZGV4VHlwZSksIDAgLyogUE9JTlRTICovKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfcHJlcGFyZVByb2dyYW0ocHJvZ3JhbSwgcHJldlZpc2liaWxpdHksIGlkSGFsZlB4U2l6ZSkge1xyXG4gICAgICAgIHN1cGVyLl9wcmVwYXJlUHJvZ3JhbShwcm9ncmFtLCBwcmV2VmlzaWJpbGl0eSwgaWRIYWxmUHhTaXplKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRUZXh0dXJlVW5pdCgwKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRUZXh0dXJlKHByZXZWaXNpYmlsaXR5KTtcclxuICAgICAgICBwcm9ncmFtLnNldFZlY3RvcjJVbmlmb3JtKCdpZEhhbGZQeFNpemUnLCBpZEhhbGZQeFNpemUpO1xyXG4gICAgfVxyXG59XHJcbiIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleElkO1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHByZXZWaXNpYmlsaXR5O1xcbnVuaWZvcm0gdmVjMiBpZEhhbGZQeFNpemU7XFxuXFxudmFyeWluZyBsb3dwIHZlYzQgdmlzaWJpbGl0eVZhbHVlO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgdmVjMiBpZFRleENvb3JkaW5hdGVzID0gdmVydGV4SWQgKyBpZEhhbGZQeFNpemU7XFxuICAgIHZlYzQgaWRXaW5kb3dDb29yZGluYXRlcyA9IHZlYzQoaWRUZXhDb29yZGluYXRlcyAqIDIuMCAtIDEuMCwgMCwgMSk7XFxuICAgIGdsX1Bvc2l0aW9uID0gaWRXaW5kb3dDb29yZGluYXRlcztcXG4gICAgZ2xfUG9pbnRTaXplID0gMS4wO1xcblxcbiAgICB2aXNpYmlsaXR5VmFsdWUgPSB0ZXh0dXJlMkQocHJldlZpc2liaWxpdHksIGlkVGV4Q29vcmRpbmF0ZXMpO1xcbn1cXG5cIiIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbnZhcnlpbmcgbG93cCB2ZWM0IHZpc2liaWxpdHlWYWx1ZTtcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIGdsX0ZyYWdDb2xvciA9IHZpc2liaWxpdHlWYWx1ZTtcXG59XFxuXCIiLCJpbXBvcnQgeyBFdmVudEVtaXR0ZXIsIFZvaWRFdmVudEVtaXR0ZXIgfSBmcm9tICcuL3V0aWwvZXZlbnRfZW1pdHRlcic7XHJcbmNvbnN0IE1BWF9GUkFNRV9USU1FX0NPVU5UID0gMTAwO1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW5kZXJMb29wIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgbmV3IHJlbmRlciBsb29wLCBidXQgZG9lc24ndCBzY2hlZHVsZSBhbnkgYW5pbWF0aW9uIGZyYW1lcy5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5vbkZyYW1lVGltZXNGdWxsID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMub25CZWZvcmVSZW5kZXIgPSBuZXcgVm9pZEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMub25SZW5kZXIgPSBuZXcgVm9pZEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMuX2lzUnVubmluZyA9IHRoaXMuX3VwZGF0ZUlzUmVxdWVzdGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fbGFzdEZyYW1lVGltZSA9IDA7XHJcbiAgICAgICAgdGhpcy5fZnJhbWVUaW1lcyA9IG5ldyBBcnJheShNQVhfRlJBTUVfVElNRV9DT1VOVCk7XHJcbiAgICAgICAgdGhpcy5fZnJhbWVUaW1lcy5maWxsKDApO1xyXG4gICAgICAgIHRoaXMuX25leHRGcmFtZVRpbWVJZHggPSAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBsb29wIGlzIHJ1bm5pbmcgYSBjaGFpbiBvZiBjb25zZWN1dGl2ZSBhbmltYXRpb25cclxuICAgICAqICAgICAgZnJhbWVzIG9yIG5vdC5cclxuICAgICAqL1xyXG4gICAgZ2V0IGlzQWN0aXZlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pc1J1bm5pbmc7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN0YXJ0cyBhIGNoYWluIG9mIGNvbnNlY3V0aXZlIGFuaW1hdGlvbiBmcmFtZXMuXHJcbiAgICAgKi9cclxuICAgIHN0YXJ0KCkge1xyXG4gICAgICAgIHRoaXMuX2lzUnVubmluZyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fcmVxdWVzdEZyYW1lKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN0b3BzIHByZXZpb3VzbHkgc3RhcnRlZCBjaGFpbiBvZiBjb25zZWN1dGl2ZSBhbmltYXRpb24gZnJhbWVzLiBJZiBhblxyXG4gICAgICogdXBkYXRlIHdhcyByZXF1ZXN0ZWQgYmVmb3JlIHN0b3BwaW5nLCBvbmUgbW9yZSBhbmltYXRpb24gZnJhbWUgd2lsbCBiZVxyXG4gICAgICogZmlyZWQuXHJcbiAgICAgKi9cclxuICAgIHN0b3AoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2lzUnVubmluZykge1xyXG4gICAgICAgICAgICB0aGlzLl9pc1J1bm5pbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl91cGRhdGVJc1JlcXVlc3RlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FuY2VsRnJhbWUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2NoZWR1bGVzIGEgc2luZ2xlXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZSgpIHtcclxuICAgICAgICB0aGlzLl91cGRhdGVJc1JlcXVlc3RlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fcmVxdWVzdEZyYW1lKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN0b3BzIGFsbCB0aGUgcmVuZGVyaW5nIGFjdGl2aXRpZXMuXHJcbiAgICAgKi9cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5fY2FuY2VsRnJhbWUoKTtcclxuICAgIH1cclxuICAgIF9yZW5kZXJGcmFtZSh0aW1lKSB7XHJcbiAgICAgICAgdGhpcy5fcmFmSWQgPSAwO1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZUlzUmVxdWVzdGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5vbkJlZm9yZVJlbmRlci5maXJlKCk7XHJcbiAgICAgICAgdGhpcy5vblJlbmRlci5maXJlKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuX2xhc3RGcmFtZVRpbWUgPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5leHRGcmFtZVRpbWVJZHggPSB0aGlzLl9uZXh0RnJhbWVUaW1lSWR4O1xyXG4gICAgICAgICAgICB0aGlzLl9mcmFtZVRpbWVzW25leHRGcmFtZVRpbWVJZHhdID0gdGltZSAtIHRoaXMuX2xhc3RGcmFtZVRpbWU7XHJcbiAgICAgICAgICAgIHRoaXMuX25leHRGcmFtZVRpbWVJZHggPSAobmV4dEZyYW1lVGltZUlkeCArIDEpICUgTUFYX0ZSQU1FX1RJTUVfQ09VTlQ7XHJcbiAgICAgICAgICAgIC8vIE5leHQgdGltZSBpbmRleCBiZWluZyAwIG1lYW5zIHRoYXQgdGhlIGFycmF5IGlzIGZ1bGwgYW5kIGl0J3NcclxuICAgICAgICAgICAgLy8gdGltZSB0byBub3RpZnkgbGlzdGVuZXJzIGFib3V0IHRoYXQgYmVmb3JlIHdlIHN0YXJ0IHRvIHJld3JpdGVcclxuICAgICAgICAgICAgLy8gdmFsdWVzLlxyXG4gICAgICAgICAgICBpZiAodGhpcy5fbmV4dEZyYW1lVGltZUlkeCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbkZyYW1lVGltZXNGdWxsLmZpcmUodGhpcy5fZnJhbWVUaW1lcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX2lzUnVubmluZykge1xyXG4gICAgICAgICAgICB0aGlzLl9sYXN0RnJhbWVUaW1lID0gdGltZTtcclxuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdEZyYW1lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBJZiB3ZSBkb24ndCBzY2hlZHVsZSBuZXh0IGZyYW1lIGltbWVkaWF0ZWx5IHRoZXJlJ3Mgbm8gd2F5IHRvXHJcbiAgICAgICAgICAgIC8vIHRlbGwgdGhhdCBpdCB3aWxsIGJlIGNvbnNlY3V0aXZlIHRvIHRoZSBjdXJyZW50IG9uZS4gSGVuY2UgdGhlcmUnc1xyXG4gICAgICAgICAgICAvLyBubyBwb2ludCBpbiByZWNvcmRpbmcgYSB0aW1lIGRlbHRhIGluIGl0LlxyXG4gICAgICAgICAgICB0aGlzLl9sYXN0RnJhbWVUaW1lID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfcmVxdWVzdEZyYW1lKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fcmFmSWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmFmSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCh0aW1lKSA9PiB0aGlzLl9yZW5kZXJGcmFtZSh0aW1lKSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9jYW5jZWxGcmFtZSgpIHtcclxuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLl9yYWZJZCk7XHJcbiAgICAgICAgdGhpcy5fcmFmSWQgPSAwO1xyXG4gICAgfVxyXG59XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=