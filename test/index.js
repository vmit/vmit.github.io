/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _src_vector_render_engine_render_context__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _src_vector_render_engine_camera__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15);
/* harmony import */ var _src_vector_render_engine_adapters_vector_api_adapter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(24);
/* harmony import */ var _camera_stuff__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(93);
/* harmony import */ var _src_vector_render_engine_visibility_primitives_label_color_id_point_label_renderer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(95);
/* harmony import */ var _src_vector_render_engine_visibility_primitives_label_color_id_curved_label_renderer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(111);
/* harmony import */ var _src_vector_render_engine_render_primitives_label_point_label_render_unit__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(104);
/* harmony import */ var _src_vector_render_engine_render_primitives_label_curved_label_render_unit__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(113);
/* harmony import */ var _src_vector_render_engine_render_primitives_icon_icon_render_unit__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(115);
/* harmony import */ var _src_vector_render_engine_render_primitives_model_model_render_unit__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(121);
/* harmony import */ var _src_vector_render_engine_render_primitives_polyline_textured_polyline_render_unit__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(127);
/* harmony import */ var _src_vector_render_engine_render_primitives_polyline_polyline_render_unit__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(131);
/* harmony import */ var _src_vector_render_engine_render_primitives_polygon_textured_polygon_render_unit__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(135);
/* harmony import */ var _src_vector_render_engine_render_primitives_polygon_transparent_polygon_render_unit__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(138);
/* harmony import */ var _src_vector_render_engine_render_primitives_polygon_polygon_render_unit__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(139);
/* harmony import */ var _src_vector_render_engine_map_engine__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(142);
/* harmony import */ var _src_vector_render_engine_util_hd__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(48);
/* harmony import */ var _src_vector_render_engine_visibility_primitives_colliding_primitive_reset_removed_renderer__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(182);
/* harmony import */ var _src_vector_render_engine_render_loop__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(185);



















// import ImageRenderUnit from '../../src/vector_render_engine/render/primitives/image/image_render_unit';
// import RasterTilesAdapter from '../../src/vector_render_engine/adapters/raster_tiles/adapter';
// import {TileItem} from '../../src/vector_render_engine/adapters/tile_based_adapter/util/tile_system';
const GL_CONTEXT_ATTRIBS = {
    alpha: false,
    depth: true,
    stencil: false,
    antialias: false,
    failIfMajorPerformanceCaveat: true
};
const camera = new _src_vector_render_engine_camera__WEBPACK_IMPORTED_MODULE_1__["default"]({
    wrapModeX: 2 /* REPEAT */,
    wrapModeY: 0 /* NONE */
});
camera.onUpdate.addListener(() => Object(_camera_stuff__WEBPACK_IMPORTED_MODULE_3__["renderCameraState"])(camera));
camera.center.x = 0.20898437;
camera.center.y = 0.37304687;
camera.zoom = 14;
const canvas = document.querySelector('#canvas');
{
    const { width, height } = canvas.getBoundingClientRect();
    const dpr = Object(_src_vector_render_engine_util_hd__WEBPACK_IMPORTED_MODULE_16__["default"])();
    canvas.width = dpr * width;
    canvas.height = dpr * height;
    camera.screenSize.width = width;
    camera.screenSize.height = height;
}
const cameraMouseController = new _camera_stuff__WEBPACK_IMPORTED_MODULE_3__["CameraMouseController"](canvas, camera);
const mouseDragController = new _camera_stuff__WEBPACK_IMPORTED_MODULE_3__["MouseDragController"](canvas);
mouseDragController.setDelegate(cameraMouseController);
const scrollZoomController = new _camera_stuff__WEBPACK_IMPORTED_MODULE_3__["ScrollZoomController"](canvas);
scrollZoomController.setDelegate(cameraMouseController);
const context = _src_vector_render_engine_render_context__WEBPACK_IMPORTED_MODULE_0__["default"].createFromCanvas(canvas, GL_CONTEXT_ATTRIBS);
const engine = new _src_vector_render_engine_map_engine__WEBPACK_IMPORTED_MODULE_15__["default"](context, camera, new _src_vector_render_engine_render_loop__WEBPACK_IMPORTED_MODULE_18__["default"]());
const vectorAdapter = new _src_vector_render_engine_adapters_vector_api_adapter__WEBPACK_IMPORTED_MODULE_2__["default"](engine, camera, './tile_provider_worker.js?worker', 'map', 
// {
//     tileUrlTemplate: 'https://vec-rdr01e.tst.maps.yandex.ru/vmap2/tiles?l=vmap2&lang=ru_RU&x={{x}}&y={{y}}&z={{z}}&zmin={{zmin}}&zmax={{zmax}}',
//     imageUrlTemplate: 'https://vec-rdr01e.tst.maps.yandex.ru/resources?id={{id}}&scale={{scale}}',
//     meshUrlTemplate: 'https://vec-rdr01e.tst.maps.yandex.ru/meshes?id={{id}}',
//     glyphRangeUrlTemplate: 'https://vec-rdr01e.tst.maps.yandex.ru/glyphs?lang=ru_RU&font_id={{fontId}}&range={{range}}'
// }
{
    tileUrlTemplate: 'https://vec0{{hostAlias}}.maps.yandex.net/vmap2/tiles?l=vmap2&lang=RU_ru&x={{x}}&y={{y}}&z={{z}}&zmin={{zmin}}&zmax={{zmax}}',
    imageUrlTemplate: 'https://vec0{{hostAlias}}.maps.yandex.net/resources?id={{id}}&scale={{scale}}',
    meshUrlTemplate: 'https://vec0{{hostAlias}}.maps.yandex.net/vmap2/meshes?id={{id}}',
    glyphRangeUrlTemplate: 'https://vec0{{hostAlias}}.maps.yandex.net/glyphs?lang=RU_ru&font_id={{fontId}}&range={{range}}'
}, 1 /* X4 */);
// class TrafficLayerAdapter extends RasterTilesAdapter {
//     public _getImageUrl(tile: TileItem): string {
//         return `https://jgo.maps.yandex.net/1.1/tiles?trf&l=trf,trfe&lang=ru_UA&x=${tile.x}&y=${tile.y}&z=${tile.zoom}&scale=${window.devicePixelRatio}&tm=${Math.floor(Date.now() / 1000)}`
//         // return `https://sat03.maps.yandex.net/tiles?l=sat&v=3.419.0&x=${tile.x}&y=${tile.y}&z=${tile.zoom}&scale=${window.devicePixelRatio}&lang=ru_UA`
//     }
// }
// const trafficAdapter = new TrafficLayerAdapter(
//     engine,
//     camera,
//     {width: 256 * window.devicePixelRatio, height: 256 * window.devicePixelRatio}
// );
engine.groundLayer.addRenderUnit(new _src_vector_render_engine_render_primitives_polygon_polygon_render_unit__WEBPACK_IMPORTED_MODULE_14__["default"](context, vectorAdapter.opaquePolygonsProvider));
engine.groundLayer.addRenderUnit(new _src_vector_render_engine_render_primitives_polygon_transparent_polygon_render_unit__WEBPACK_IMPORTED_MODULE_13__["default"](context, vectorAdapter.transparentPolygonsProvider));
engine.groundLayer.addRenderUnit(new _src_vector_render_engine_render_primitives_polygon_textured_polygon_render_unit__WEBPACK_IMPORTED_MODULE_12__["default"](context, vectorAdapter.texturedPolygonsProvider));
engine.groundLayer.addRenderUnit(new _src_vector_render_engine_render_primitives_polyline_polyline_render_unit__WEBPACK_IMPORTED_MODULE_11__["default"](context, camera, vectorAdapter.polylinesProvider));
engine.groundLayer.addRenderUnit(new _src_vector_render_engine_render_primitives_polyline_textured_polyline_render_unit__WEBPACK_IMPORTED_MODULE_10__["default"](context, camera, vectorAdapter.texturedPolylinesProvider));
engine.buildingsLayer.addRenderUnit(new _src_vector_render_engine_render_primitives_model_model_render_unit__WEBPACK_IMPORTED_MODULE_9__["default"](context, vectorAdapter.modelsProvider));
// engine.iconsLayer.addRenderUnit(new ImageRenderUnit(context, trafficAdapter.imagesProvider));
engine.iconsLayer.addRenderUnit(new _src_vector_render_engine_render_primitives_icon_icon_render_unit__WEBPACK_IMPORTED_MODULE_8__["default"](context, camera, vectorAdapter.iconsProvider));
engine.labelsLayer.addRenderUnit(new _src_vector_render_engine_render_primitives_label_curved_label_render_unit__WEBPACK_IMPORTED_MODULE_7__["default"](context, camera, engine.visbilityTextureProvider, vectorAdapter.curvedLabelsProvider));
engine.labelsLayer.addRenderUnit(new _src_vector_render_engine_render_primitives_label_point_label_render_unit__WEBPACK_IMPORTED_MODULE_6__["default"](context, camera, engine.visbilityTextureProvider, vectorAdapter.pointLabelsProvider));
engine.visibilityManager.registerCollidingPrimitives(vectorAdapter.curvedLabelsProvider, new _src_vector_render_engine_visibility_primitives_label_color_id_curved_label_renderer__WEBPACK_IMPORTED_MODULE_5__["default"](context, camera, vectorAdapter.curvedLabelsProvider), new _src_vector_render_engine_visibility_primitives_colliding_primitive_reset_removed_renderer__WEBPACK_IMPORTED_MODULE_17__["CollidingPrimitivesResetRemovedRenderer"](context, vectorAdapter.curvedLabelsProvider));
engine.visibilityManager.registerCollidingPrimitives(vectorAdapter.pointLabelsProvider, new _src_vector_render_engine_visibility_primitives_label_color_id_point_label_renderer__WEBPACK_IMPORTED_MODULE_4__["default"](context, camera, vectorAdapter.pointLabelsProvider), new _src_vector_render_engine_visibility_primitives_colliding_primitive_reset_removed_renderer__WEBPACK_IMPORTED_MODULE_17__["CollidingPrimitivesResetRemovedRenderer"](context, vectorAdapter.pointLabelsProvider));
document.getElementById('moscow').addEventListener('click', () => {
    camera.center.x = 0x1ABFFFFF / 0x7FFFFFFF;
    camera.center.y = 0x2FBFFFFF / 0x7FFFFFFF;
    camera.zoom = 13;
});
document.getElementById('plus').addEventListener('click', () => {
    camera.zoom += 0.1;
});
document.getElementById('minus').addEventListener('click', () => {
    camera.zoom -= 0.1;
});
// setTimeout(() => {
//     console.log('Setting new tile url template');
//     vectorAdapter.setTileUrlTemplate('https://vec-rdr01e.tst.maps.yandex.ru/vmap2/tiles?l=vmap2&lang=ru_RU&x={{x}}&y={{y}}&z={{z}}&zmin={{zmin}}&zmax={{zmax}}');
// }, 4000);


/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultRenderTarget", function() { return DefaultRenderTarget; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RenderContext; });
/* harmony import */ var _attrib_mapping__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _gl_buffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var _gl_framebuffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6);
/* harmony import */ var _gl_program__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7);
/* harmony import */ var _gl_renderbuffer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(8);
/* harmony import */ var _capabilities__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(9);
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(10);
/* harmony import */ var _gl_texture__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(12);
/* harmony import */ var _gl_vao__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(13);
/* harmony import */ var _util_color__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(11);
/* harmony import */ var _util_event_emitter__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(14);











const QUAD_VERTEX_DATA = new Float32Array([
    // tslint:disable
    // x   y  u  v
    -1, -1, 0, 0,
    1, 1, 1, 1,
    -1, 1, 0, 1,
    -1, -1, 0, 0,
    1, -1, 1, 0,
    1, 1, 1, 1
    // tslint:enable
]);
const QUAD_ATTRIB_MAPPING = new _attrib_mapping__WEBPACK_IMPORTED_MODULE_0__["AttributeMapping"]([
    [
        0 /* POSITION */,
        {
            size: 2,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        4 /* UV */,
        {
            size: 2,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ]
]);
/**
 * Default render target of a WebGL context, which is canvas element of the
 * context.
 */
class DefaultRenderTarget {
    constructor(gl) {
        this.isClear = false;
        this._gl = gl;
    }
    bind() {
        const gl = this._gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }
    setSize(width, height) {
        const canvas = this._gl.canvas;
        canvas.width = width;
        canvas.height = height;
    }
    getWidth() {
        return this._gl.drawingBufferWidth;
    }
    getHeight() {
        return this._gl.drawingBufferHeight;
    }
    destroy() {
        // We can't destroy default render target, so do nothing.
        // TODO(dmikis) Throw an exception?
    }
}
/**
 * Wrapper around WebGL context. Serves to localize all GL calls to minimum set
 * of objects.
 */
class RenderContext {
    /**
     * Creates a new wrapper for a given WebGL context.
     *
     * @param gl The context to be wrapped.
     */
    constructor(gl) {
        this._gl = gl;
        this.onLoss = new _util_event_emitter__WEBPACK_IMPORTED_MODULE_10__["VoidEventEmitter"]();
        this._contextLostListener = (e) => {
            e.preventDefault();
            this.onLoss.fire();
        };
        gl.canvas.addEventListener('webglcontextlost', this._contextLostListener);
        this._capabilities = new _capabilities__WEBPACK_IMPORTED_MODULE_5__["default"](gl);
        const vaoExt = gl.getExtension('OES_vertex_array_object');
        if (!vaoExt) {
            throw new Error('OES_vertex_array_object is required.');
        }
        this._vaoExt = vaoExt;
        if (!gl.getExtension('OES_standard_derivatives')) {
            throw new Error('OES_standard_derivatives is required.');
        }
        const defaultRenderTarget = this._boundRenderTarget =
            this._defaultRenderTarget =
                new DefaultRenderTarget(gl);
        const boundState = this._boundRenderState = new _state__WEBPACK_IMPORTED_MODULE_6__["default"]();
        this._unpackPremultiplyAlpha = false;
        // Default viewport and scissor rectangle sizes are equal to the size of
        // the canvas of the WebGL context. But we have no way of knowing them in
        // RenderState's constructor. So we're fixing them here.
        boundState.scissorWidth = boundState.viewportWidth =
            defaultRenderTarget.getWidth();
        boundState.scissorHeight = boundState.viewportHeight =
            defaultRenderTarget.getHeight();
        const quadBuffer = this._quadVertexBuffer =
            new _gl_buffer__WEBPACK_IMPORTED_MODULE_1__["default"](gl, gl.ARRAY_BUFFER, gl.STATIC_DRAW);
        quadBuffer.bind();
        gl.bufferData(gl.ARRAY_BUFFER, QUAD_VERTEX_DATA, gl.STATIC_DRAW);
        this._quadVao = this.createVao(QUAD_ATTRIB_MAPPING, quadBuffer, null);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        this._boundProgram = null;
        this._boundVao = null;
        this._boundTextures = new Array(this._capabilities.getMaxCombinedTextureImageUnits());
        this._boundTextures.fill(null);
        this._boundTextureUnit = 0;
    }
    /**
     * Returns object to request capabilities of the context such as maximum
     * texture size or maximum number of uniform vectors allowed in shaders.
     */
    getCapabilities() {
        return this._capabilities;
    }
    /**
     * Creates a new framebuffer with given attachments.
     *
     * @param descriptor Object containing framebuffer attachments.
     * @returns Created framebuffer object.
     */
    createFramebuffer({ color, depth, stencil, depthStencil }) {
        // TODO Uncomment and put under debug flag (when implemented)
        // if (depthStencil && (depth || stencil)) {
        //     throw new Error(
        //         'Framebuffer can\'t have DEPTH_STENCIL and DEPTH or STENCIL ' +
        //             'attachment simultaneously.'
        //     );
        // }
        const gl = this._gl;
        let width = 0;
        let height = 0;
        if (color) {
            width = color.getWidth();
            height = color.getHeight();
        }
        else if (depth) {
            width = depth.getWidth();
            height = depth.getHeight();
        }
        else if (stencil) {
            width = stencil.getWidth();
            height = stencil.getHeight();
        }
        else if (depthStencil) {
            width = depthStencil.getWidth();
            height = depthStencil.getHeight();
        }
        const framebuffer = new _gl_framebuffer__WEBPACK_IMPORTED_MODULE_2__["default"](gl, width, height);
        this.bindRenderTarget(framebuffer);
        if (color) {
            color.attachToFramebuffer(gl.COLOR_ATTACHMENT0);
        }
        if (depth) {
            depth.attachToFramebuffer(gl.DEPTH_ATTACHMENT);
        }
        if (stencil) {
            stencil.attachToFramebuffer(gl.STENCIL_ATTACHMENT);
        }
        if (depthStencil) {
            depthStencil.attachToFramebuffer(gl.DEPTH_STENCIL_ATTACHMENT);
        }
        // TODO Uncomment and put under debug flag (when implemented)
        // switch (gl.checkFramebufferStatus(gl.FRAMEBUFFER)) {
        //     case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
        //         throw new Error('Framebuffer attachments are not renderable');
        //     case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
        //         throw new Error('Framebuffer attachments are not same size');
        //     case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
        //         throw new Error('Framebuffer has no attachments');
        //     case gl.FRAMEBUFFER_UNSUPPORTED:
        //         throw new Error('Framebuffer has unsupported attachment');
        // }
        return framebuffer;
    }
    /**
     * Allocates a new renderbuffer with given size and format.
     *
     * @param width Width of the renderbuffer.
     * @param height Height of the renderbuffer.
     * @param format Format of the renderbuffer.
     * @return The allocated renderbuffer.
     *
     */
    createRenderbuffer(width, height, format) {
        const gl = this._gl;
        const renderbuffer = new _gl_renderbuffer__WEBPACK_IMPORTED_MODULE_4__["default"](gl, width, height);
        renderbuffer.bind();
        gl.renderbufferStorage(gl.RENDERBUFFER, format, width, height);
        return renderbuffer;
    }
    /**
     * Allocates a new texture with given size, format, type and parameters and
     * fills it with zeroes.
     *
     * @param width Width of the texture.
     * @param height Height of the texture.
     * @param format Pixel format of the texture.
     * @param type Pixel type of the texture.
     * @param params Parameters of the texture.
     * @returns Newly allocated texture.
     */
    createEmpty2DTexture(width, height, format, type, params = _gl_texture__WEBPACK_IMPORTED_MODULE_7__["DEFAULT_TEXTURE_PARAMS"]) {
        const texture = new _gl_texture__WEBPACK_IMPORTED_MODULE_7__["default"](this._gl, width, height, format, type, params);
        return texture;
    }
    /**
     * Creates a new shader program. Uses cache, i.e. if a program with same
     * source string and options is already created, returns it.
     *
     * @param vertexShaderSource Source code of vertex shader of the program.
     * @param fragmentShaderSource Source code of fragment shader of the program.
     * @param options Options.
     * @returns Newly created program or one from the cache.
     */
    createProgram(vertexShaderSource, fragmentShaderSource, options) {
        return new _gl_program__WEBPACK_IMPORTED_MODULE_3__["default"](this._gl, vertexShaderSource, fragmentShaderSource, options);
    }
    createVertexBuffer(size, usage = 35044 /* STATIC_DRAW */) {
        return this._createBuffer(this._gl.ARRAY_BUFFER, size, usage);
    }
    createIndexBuffer(size, usage = 35044 /* STATIC_DRAW */) {
        return this._createBuffer(this._gl.ELEMENT_ARRAY_BUFFER, size, usage);
    }
    // TODO: check https://github.com/Microsoft/TypeScript/issues/24195 to update narrowed data type according
    uploadDataToBuffer(buffer, data, offset = 0) {
        buffer.bind();
        this._gl.bufferSubData(buffer.getTarget(), offset, data);
    }
    /**
     * Creates a new vertex array object in the context.
     *
     * @param attributeMapping Mapping of vertex attrbiutes for the VAO.
     * @param vertexBuffer Vertex buffer to be bound to the VAO.
     * @param indexBuffer Index buffer to be bound to the VAO.
     * @returns The new VAO.
     */
    createVao(attributeMapping, vertexBuffer, indexBuffer) {
        const gl = this._gl;
        const vao = new _gl_vao__WEBPACK_IMPORTED_MODULE_8__["default"](gl, this._vaoExt, attributeMapping);
        vao.bind();
        if (indexBuffer) {
            indexBuffer.bind();
        }
        else {
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        }
        vertexBuffer.bind();
        const vertexByteSize = attributeMapping.vertexByteSize;
        for (const [idx, pointer] of attributeMapping) {
            gl.enableVertexAttribArray(idx);
            gl.vertexAttribPointer(idx, pointer.size, pointer.type, pointer.normalized, vertexByteSize, pointer.offset);
        }
        this._vaoExt.bindVertexArrayOES(null);
        return vao;
    }
    /**
     * Sets new content of texture, provided data must be of length equal to "width * height" and its type
     * must correspond to texture's type {@see PixelType}.
     */
    setTextureData(texture, data) {
        const gl = this._gl;
        const width = texture.getWidth();
        const height = texture.getHeight();
        const format = texture.getFormat();
        const type = texture.getType();
        const params = texture.getParams();
        this._setTextureDataUnpackParams(params);
        this.bindTexture(texture);
        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, height, format, type, data);
        this._onTextureDataUpdated(texture);
    }
    /**
     * Sets new texture content from canvas element.
     */
    setTextureDataFromDomElement(texture, element) {
        const gl = this._gl;
        const format = texture.getFormat();
        const type = texture.getType();
        const params = texture.getParams();
        this._setTextureDataUnpackParams(params);
        this.bindTexture(texture);
        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, format, type, element);
        this._onTextureDataUpdated(texture);
    }
    /**
     * Returns default render target associated with canvas on which the WebGL
     * context operates.
     */
    getDefaultRenderTarget() {
        return this._defaultRenderTarget;
    }
    /**
     * Clears currently bound render target according to a mask.
     *
     * @param mask Bitwise OR of marks, i.e.
     *      `ClearMask.COLOR_BUFFER_BIT | ClearMask.DEPTH_BUFFER_BIT`.
     */
    clearCurrentTarget(mask) {
        if (mask) {
            this._gl.clear(mask);
            this._boundRenderTarget.isClear = true;
        }
    }
    /**
     * Binds a render target to the WebGL context if it's not already bound.
     *
     * @param target The render target to be bound.
     */
    bindRenderTarget(target) {
        if (this._boundRenderTarget !== target) {
            target.bind();
            this._boundRenderTarget = target;
        }
        // Target size could change even if target is already bound.
        // VECTOR-190
        this._setViewportState(new _state__WEBPACK_IMPORTED_MODULE_6__["default"]({
            viewportWidth: target.getWidth(),
            viewportHeight: target.getHeight()
        }));
    }
    /**
     * Binds a render state to the WebGL context with minimum amount of actual
     * state switching.
     *
     * @param state The state to be bound.
     */
    bindRenderState(state) {
        this._setColorBufferState(state);
        this._setBlendState(state);
        this._setCullFaceState(state);
        this._setFrontFaceState(state);
        this._setDepthTestState(state);
        this._setDitherState(state);
        this._setDrawBuffersState(state);
        this._setPolygonOffsetState(state);
        this._setAlphaToCoverageState(state);
        this._setSampleCoverageState(state);
        this._setStencilTestState(state);
        this._setScissorTestState(state);
        this._setViewportState(state);
    }
    /**
     * Binds a program to the WebGL context if it's not already bound.
     *
     * @param program The program to be bound.
     */
    bindProgram(program) {
        if (this._boundProgram !== program) {
            program.bind();
            this._boundProgram = program;
        }
    }
    /**
     * Binds a vertex array object to the context if it's not already bound.
     *
     * @param vao The vertex array object to bind. Passing `null` will unbind
     *      any currently bound VAO.
     */
    bindVao(vao) {
        if (this._boundVao !== vao) {
            if (vao) {
                vao.bind();
            }
            else {
                this._vaoExt.bindVertexArrayOES(null);
            }
            this._boundVao = vao;
        }
    }
    bindQuadVao() {
        this.bindVao(this._quadVao);
    }
    bindTextureUnit(unit) {
        const gl = this._gl;
        if (this._boundTextureUnit !== unit) {
            gl.activeTexture(gl.TEXTURE0 + unit);
            this._boundTextureUnit = unit;
        }
    }
    bindTexture(texture) {
        const boundUnit = this._boundTextureUnit;
        if (this._boundTextures[boundUnit] !== texture) {
            texture.bind();
            this._boundTextures[boundUnit] = texture;
        }
    }
    /**
     * Draws a quad to currently bound render target with currently bound render
     * state, program and uniform state.
     */
    drawQuad() {
        this.drawMesh(0, 6, 4 /* TRIANGLES */);
    }
    /**
     * Draws a mesh from currently bound to ARRAY_BUFFER buffer.
     *
     * @param offset Index of the vertex to start drawing from.
     * @param count Number of vertices to process.
     * @param primitiveType
     */
    drawMesh(offset, count, primitiveType = 4 /* TRIANGLES */) {
        this._gl.drawArrays(primitiveType, offset, count);
        this._boundRenderTarget.isClear = false;
    }
    /**
     * Draws a mesh to currently bound render target with currently bound render
     * state, program and uniform state.
     *
     * @param offset Offset of indices of the mesh in currently bound memory page.
     * @param indexCount Number of indices in the mesh.
     */
    drawIndexedMesh(offset, indexCount, primitiveType = 4 /* TRIANGLES */) {
        const gl = this._gl;
        gl.drawElements(primitiveType, indexCount, gl.UNSIGNED_SHORT, offset);
        this._boundRenderTarget.isClear = false;
    }
    /**
     * Destroys the context and resources owned by it. Note that resources that
     * were created with `create*` method of the context aren't exactly belong
     * to the context, entities that created them have to destroy them.
     */
    destroy() {
        this._quadVao.destroy();
        this._quadVertexBuffer.destroy();
        this._gl.canvas.removeEventListener('webglcontextlost', this._contextLostListener);
    }
    /**
     * Creates a new context from a canvas.
     *
     * @throws An error if fails to create `webgl` context for the canvas.
     * @param canvas The canvas.
     * @param attribs Attributes of the context.
     */
    static createFromCanvas(canvas, attribs) {
        const gl = canvas.getContext('webgl', attribs);
        if (!gl) {
            throw new Error('Failed to create GL context from canvas.');
        }
        return new RenderContext(gl);
    }
    /**
     * Enables or disables a WebGL capability.
     * @see https://www.khronos.org/registry/OpenGL-Refpages/es2.0/xhtml/glEnable.xml
     *
     * @param capability The capability to be enabled of disabled.
     * @param enabled New state of the capability;
     */
    _setCapabilityEnabled(capability, enabled) {
        if (enabled) {
            this._gl.enable(capability);
        }
        else {
            this._gl.disable(capability);
        }
    }
    /**
     * Sets new clear color and color mask from a state if they're different from
     * currently set ones.
     *
     * @param state The state that contains new clear color and color masks.
     */
    _setColorBufferState(state) {
        const gl = this._gl;
        const boundState = this._boundRenderState;
        const newClearColor = state.clearColor;
        if (!_util_color__WEBPACK_IMPORTED_MODULE_9__["areEqual"](boundState.clearColor, newClearColor)) {
            gl.clearColor(newClearColor.r, newClearColor.g, newClearColor.b, newClearColor.a);
            _util_color__WEBPACK_IMPORTED_MODULE_9__["copy"](newClearColor, boundState.clearColor);
        }
        if (boundState.colorMaskR !== state.colorMaskR ||
            boundState.colorMaskG !== state.colorMaskG ||
            boundState.colorMaskB !== state.colorMaskB ||
            boundState.colorMaskAlpha !== state.colorMaskAlpha) {
            this._gl.colorMask(state.colorMaskR, state.colorMaskG, state.colorMaskB, state.colorMaskAlpha);
            boundState.colorMaskR = state.colorMaskR;
            boundState.colorMaskG = state.colorMaskG;
            boundState.colorMaskB = state.colorMaskB;
            boundState.colorMaskAlpha = state.colorMaskAlpha;
        }
    }
    /**
     * Sets blend state and params.
     *
     * @param state The state that contains new blend params.
     */
    _setBlendState(state) {
        const gl = this._gl;
        const boundState = this._boundRenderState;
        if (boundState.blend !== state.blend) {
            this._setCapabilityEnabled(gl.BLEND, state.blend);
            boundState.blend = state.blend;
        }
        if (state.blend) {
            if (boundState.blendEquationRgb !== state.blendEquationRgb ||
                boundState.blendEquationAlpha !== state.blendEquationAlpha) {
                gl.blendEquationSeparate(state.blendEquationRgb, state.blendEquationAlpha);
                boundState.blendEquationRgb = state.blendEquationRgb;
                boundState.blendEquationAlpha = state.blendEquationAlpha;
            }
            if (boundState.blendFuncDstRgb !== state.blendFuncDstRgb ||
                boundState.blendFuncSrcRgb !== state.blendFuncSrcRgb ||
                boundState.blendFuncDstAlpha !== state.blendFuncDstAlpha ||
                boundState.blendFuncSrcAlpha !== state.blendFuncSrcAlpha) {
                gl.blendFuncSeparate(state.blendFuncSrcRgb, state.blendFuncDstRgb, state.blendFuncSrcAlpha, state.blendFuncDstAlpha);
                boundState.blendFuncSrcRgb = state.blendFuncSrcRgb;
                boundState.blendFuncDstRgb = state.blendFuncDstRgb;
                boundState.blendFuncSrcAlpha = state.blendFuncSrcAlpha;
                boundState.blendFuncDstAlpha = state.blendFuncDstAlpha;
            }
        }
    }
    /**
     * Sets cull face state and params.
     *
     * @param state The state that contains new cull face state and mode.
     */
    _setCullFaceState(state) {
        const gl = this._gl;
        const boundState = this._boundRenderState;
        if (boundState.cullFace !== state.cullFace) {
            this._setCapabilityEnabled(gl.CULL_FACE, state.cullFace);
            boundState.cullFace = state.cullFace;
        }
        if (state.cullFace &&
            boundState.cullFaceMode !== state.cullFaceMode) {
            gl.cullFace(state.cullFaceMode);
            boundState.cullFaceMode = state.cullFaceMode;
        }
    }
    /**
     * Sets front face mode.
     *
     * @param state The state that contains new front face mode.
     */
    _setFrontFaceState(state) {
        const boundState = this._boundRenderState;
        if (boundState.frontFaceMode !== state.frontFaceMode) {
            this._gl.frontFace(state.frontFaceMode);
            boundState.frontFaceMode = state.frontFaceMode;
        }
    }
    /**
     * Sets depth test state and params.
     *
     * @param state The state that contains new depth test state and params.
     */
    _setDepthTestState(state) {
        const gl = this._gl;
        const boundState = this._boundRenderState;
        if (boundState.depthTest !== state.depthTest) {
            this._setCapabilityEnabled(gl.DEPTH_TEST, state.depthTest);
            boundState.depthTest = state.depthTest;
        }
        if (state.depthTest) {
            if (boundState.clearDepth !== state.clearDepth) {
                gl.clearDepth(state.clearDepth);
                boundState.clearDepth = state.clearDepth;
            }
            if (boundState.depthMask !== state.depthMask) {
                gl.depthMask(state.depthMask);
                boundState.depthMask = state.depthMask;
            }
            if (boundState.depthFunc !== state.depthFunc) {
                gl.depthFunc(state.depthFunc);
                boundState.depthFunc = state.depthFunc;
            }
            if (boundState.depthRangeNear !== state.depthRangeNear ||
                boundState.depthRangeFar !== state.depthRangeFar) {
                gl.depthRange(state.depthRangeNear, state.depthRangeFar);
                boundState.depthRangeNear = state.depthRangeNear;
                boundState.depthRangeFar = state.depthRangeFar;
            }
        }
    }
    /**
     * Sets dither state.
     *
     * @param state The state that contains new dither state.
     */
    _setDitherState(state) {
        const boundState = this._boundRenderState;
        if (boundState.dither !== state.dither) {
            this._setCapabilityEnabled(this._gl.DITHER, state.dither);
            boundState.dither = state.dither;
        }
    }
    /**
     * Sets draw buffers.
     *
     * @param state The state that contains array of draw buffers.
     */
    _setDrawBuffersState(state) {
        const boundDrawBuffers = this._boundRenderState.drawBuffers;
        if (boundDrawBuffers.length !== state.drawBuffers.length ||
            boundDrawBuffers
                .some((attachment, i) => attachment !== state.drawBuffers[i])) {
            this._boundRenderState.drawBuffers = state.drawBuffers.slice();
        }
    }
    /**
     * Sets polygon offset state and params.
     *
     * @param state The state that contains new polygon offset state and params.
     */
    _setPolygonOffsetState(state) {
        const gl = this._gl;
        const boundState = this._boundRenderState;
        if (boundState.polygonOffset !== state.polygonOffset) {
            this._setCapabilityEnabled(gl.POLYGON_OFFSET_FILL, state.polygonOffset);
            boundState.polygonOffset = state.polygonOffset;
        }
        if (state.polygonOffset &&
            (boundState.polygonOffsetFactor !== state.polygonOffsetFactor ||
                boundState.polygonOffsetUnits !== state.polygonOffsetUnits)) {
            gl.polygonOffset(state.polygonOffsetFactor, state.polygonOffsetUnits);
            boundState.polygonOffsetFactor = state.polygonOffsetFactor;
            boundState.polygonOffsetUnits = state.polygonOffsetUnits;
        }
    }
    /**
     * Sets alpha-to-coverage state.
     *
     * @param state The state that contains new alpha-to-coverage state.
     */
    _setAlphaToCoverageState(state) {
        const boundState = this._boundRenderState;
        if (boundState.sampleAlphaToCoverage !== state.sampleAlphaToCoverage) {
            this._setCapabilityEnabled(this._gl.SAMPLE_ALPHA_TO_COVERAGE, state.sampleAlphaToCoverage);
            boundState.sampleAlphaToCoverage = state.sampleAlphaToCoverage;
        }
    }
    /**
     * Sets sample coverage state.
     *
     * @param state The state that contains new sample coverage state and params.
     */
    _setSampleCoverageState(state) {
        const gl = this._gl;
        const boundState = this._boundRenderState;
        if (boundState.sampleCoverage !== state.sampleCoverage) {
            this._setCapabilityEnabled(gl.SAMPLE_COVERAGE, state.sampleCoverage);
            boundState.sampleCoverage = state.sampleCoverage;
        }
        if (state.sampleCoverage &&
            (boundState.sampleCoverageValue !== state.sampleCoverageValue ||
                boundState.sampleCoverageInvert !== state.sampleCoverageInvert)) {
            gl.sampleCoverage(state.sampleCoverageValue, state.sampleCoverageInvert);
            boundState.sampleCoverageValue = state.sampleCoverageValue;
            boundState.sampleCoverageInvert = state.sampleCoverageInvert;
        }
    }
    /**
     * Sets stencil test state and params.
     *
     * @param state The state that contains new stencil test state and params.
     */
    _setStencilTestState(state) {
        const gl = this._gl;
        const boundState = this._boundRenderState;
        if (boundState.stencilTest !== state.stencilTest) {
            this._setCapabilityEnabled(gl.STENCIL_TEST, state.stencilTest);
            boundState.stencilTest = state.stencilTest;
        }
        if (state.stencilTest) {
            if (boundState.clearStencil !== state.clearStencil) {
                gl.clearStencil(state.clearStencil);
                boundState.clearStencil = state.clearStencil;
            }
            if (boundState.stencilWriteMask !== state.stencilWriteMask) {
                gl.stencilMask(state.stencilWriteMask);
                boundState.stencilWriteMask = state.stencilWriteMask;
            }
            const refOrMaskIsDifferent = (boundState.stencilMask !== state.stencilMask ||
                boundState.stencilReference !== state.stencilReference);
            if (refOrMaskIsDifferent) {
                boundState.stencilMask = state.stencilMask;
                boundState.stencilReference = state.stencilReference;
            }
            if (boundState.stencilFrontFunc !== state.stencilFrontFunc ||
                refOrMaskIsDifferent) {
                gl.stencilFuncSeparate(gl.FRONT, state.stencilFrontFunc, state.stencilReference, state.stencilMask);
                boundState.stencilFrontFunc = state.stencilFrontFunc;
            }
            if (boundState.stencilBackFunc !== state.stencilBackFunc ||
                refOrMaskIsDifferent) {
                gl.stencilFuncSeparate(gl.BACK, state.stencilBackFunc, state.stencilReference, state.stencilMask);
                boundState.stencilBackFunc = state.stencilBackFunc;
            }
            if (boundState.stencilFrontFailOp !== state.stencilFrontFailOp ||
                boundState.stencilFrontDepthFailOp !== state.stencilFrontDepthFailOp ||
                boundState.stencilFrontDepthPassOp !== state.stencilFrontDepthPassOp) {
                gl.stencilOpSeparate(gl.FRONT, state.stencilFrontFailOp, state.stencilFrontDepthFailOp, state.stencilFrontDepthPassOp);
                boundState.stencilFrontFailOp = state.stencilFrontFailOp;
                boundState.stencilFrontDepthFailOp = state.stencilFrontDepthFailOp;
                boundState.stencilFrontDepthPassOp = state.stencilFrontDepthPassOp;
            }
            if (boundState.stencilBackFailOp !== state.stencilBackFailOp ||
                boundState.stencilBackDepthFailOp !== state.stencilBackDepthFailOp ||
                boundState.stencilBackDepthPassOp !== state.stencilBackDepthPassOp) {
                gl.stencilOpSeparate(gl.BACK, state.stencilBackFailOp, state.stencilBackDepthFailOp, state.stencilBackDepthPassOp);
                boundState.stencilBackFailOp = state.stencilBackFailOp;
                boundState.stencilBackDepthFailOp = state.stencilBackDepthFailOp;
                boundState.stencilBackDepthPassOp = state.stencilBackDepthPassOp;
            }
        }
    }
    /**
     * Sets scissor test state and scissor rectangle.
     *
     * @param state The state that contains new scissor test state and scissor
     *      rectangle.
     */
    _setScissorTestState(state) {
        const gl = this._gl;
        const boundState = this._boundRenderState;
        if (boundState.scissorTest !== state.scissorTest) {
            this._setCapabilityEnabled(gl.SCISSOR_TEST, state.scissorTest);
            boundState.scissorTest = state.scissorTest;
        }
        if (state.scissorTest &&
            state.scissorWidth >= 0 &&
            state.scissorHeight >= 0 &&
            (boundState.scissorX !== state.scissorX ||
                boundState.scissorY !== state.scissorY ||
                boundState.scissorWidth !== state.scissorWidth ||
                boundState.scissorHeight !== state.scissorHeight)) {
            gl.scissor(state.scissorX, state.scissorY, state.scissorWidth, state.scissorHeight);
            boundState.scissorX = state.scissorX;
            boundState.scissorY = state.scissorY;
            boundState.scissorWidth = state.scissorWidth;
            boundState.scissorHeight = state.scissorHeight;
        }
    }
    /**
     * Sets viewport.
     *
     * @param state The state that contains new viewport.
     */
    _setViewportState(state) {
        const boundState = this._boundRenderState;
        if (state.viewportWidth >= 0 &&
            state.viewportHeight >= 0 &&
            (boundState.viewportX !== state.viewportX ||
                boundState.viewportY !== state.viewportY ||
                boundState.viewportWidth !== state.viewportWidth ||
                boundState.viewportHeight !== state.viewportHeight)) {
            this._gl.viewport(state.viewportX, state.viewportY, state.viewportWidth, state.viewportHeight);
            boundState.viewportX = state.viewportX;
            boundState.viewportY = state.viewportY;
            boundState.viewportWidth = state.viewportWidth;
            boundState.viewportHeight = state.viewportHeight;
        }
    }
    /**
     * Sets texture data unpack params.
     *
     * @param params Texture params to be set.
     */
    _setTextureDataUnpackParams(params) {
        const gl = this._gl;
        if (this._unpackPremultiplyAlpha !== params.premultipliedAlpha) {
            gl.pixelStorei(37441 /* UNPACK_PREMULTIPLY_ALPHA_WEBGL */, +params.premultipliedAlpha);
            this._unpackPremultiplyAlpha = params.premultipliedAlpha;
        }
    }
    _onTextureDataUpdated(texture) {
        const gl = this._gl;
        const params = texture.getParams();
        if (params.minificationFilter >= 9984 /* NEAREST_MIPMAP_NEAREST */) {
            gl.generateMipmap(gl.TEXTURE_2D);
        }
    }
    /**
     * Creates a new zeroed buffer with a given size and a target.
     *
     * @param target The target of the new buffer, `ARRAY_BUFFER` or
     *      `ELEMENT_ARRAY_BUFFER`.
     * @param size The size of the buffer.
     * @param usage Usage of the buffer.
     * @returns The buffer.
     */
    _createBuffer(target, size, usage = this._gl.STATIC_DRAW) {
        const gl = this._gl;
        const buffer = new _gl_buffer__WEBPACK_IMPORTED_MODULE_1__["default"](gl, target, size);
        // TODO(dmikis) a cleverer way not to break currently bound VAO;
        this.bindVao(null);
        buffer.bind();
        gl.bufferData(target, size, usage);
        return buffer;
    }
}


/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AttributeMapping", function() { return AttributeMapping; });
/* harmony import */ var _util_iterable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _util_pow_of_2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4);


/**
 * Gives size of a GL type.
 *
 * @param type The type.
 * @returns Size of the type in bytes.
 */
function getTypeSize(type) {
    switch (type) {
        case 5120 /* BYTE */:
        case 5121 /* UNSIGNED_BYTE */:
            return 1;
        case 5122 /* SHORT */:
        case 5123 /* UNSIGNED_SHORT */:
            return 2;
        case 5124 /* INT */:
        case 5125 /* UNSIGNED_INT */:
        case 5126 /* FLOAT */:
            return 4;
    }
}
/**
 * Description of how particular attributes of a vertex are packed into a vertex
 * buffer.
 */
class AttributeMapping extends Map {
    /**
     * Creates a new attribute mapping with a set of attributes of given types and
     * sizes. Automatically computes offsets of the attributes.
     *
     * @param mapping The mapping from attribute IDs to types and sizes.
     * @param alignment Desired alignment of attributes in the vertex data
     *      structure. Must be a power of 2.
     */
    constructor(mapping, alignment = 4 /* ALIGN_4_BYTES */) {
        let offset = 0;
        super(Object(_util_iterable__WEBPACK_IMPORTED_MODULE_0__["mapIterable"])(mapping, ([idx, { type, size, normalized }]) => {
            const pointer = [
                idx,
                {
                    type,
                    size,
                    normalized,
                    offset
                }
            ];
            const attributeSize = size * getTypeSize(type);
            const newOffset = Object(_util_pow_of_2__WEBPACK_IMPORTED_MODULE_1__["align"])(offset + attributeSize, -alignment);
            // TODO(dmikis) Check this in debug mode.
            // if (newOffset - offset > attributeSize) {
            //    console.warn(`${newOffset - offset} byte padding's inserted`);
            // }
            offset = newOffset;
            return pointer;
        }));
        this.vertexByteSize = offset;
    }
}


/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findInIterable", function() { return findInIterable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mapIterable", function() { return mapIterable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "filterIterable", function() { return filterIterable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reduceIterable", function() { return reduceIterable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "oneOfIterable", function() { return oneOfIterable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "allOfIterable", function() { return allOfIterable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rangeIterable", function() { return rangeIterable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zipIterables", function() { return zipIterables; });
/**
 * Searches for the first collection item satisfying a predicate.
 *
 * @param collection The collection.
 * @param predicate The predicate.
 * @returns The first item satisfying the predicate or `undefined` if none found.
 */
function findInIterable(collection, predicate) {
    for (const item of collection) {
        if (predicate(item)) {
            return item;
        }
    }
    return;
}
/**
 * Transforms a collection to another one.
 *
 * @param collection The source collection.
 * @param mapper A function producing items for destination collection.
 * @returns Collection of produced items.
 */
function* mapIterable(collection, mapper) {
    for (const item of collection) {
        yield mapper(item);
    }
}
/**
 * Chooses items of a collection satisfying a predicate.
 *
 * @param collection The collection.
 * @param predicate The predicate.
 * @returns Collection of chosen items.
 */
function* filterIterable(collection, predicate) {
    for (const item of collection) {
        if (predicate(item)) {
            yield item;
        }
    }
}
/**
 * Traverses a collection from left to right recomputing an accumulator on every
 * iteration.
 *
 * @param collection The collection.
 * @param reducer The function used to compute next value of the accumulator.
 * @param initial
 * @returns Value of the accumulator.
 */
function reduceIterable(collection, reducer, initial) {
    let result = initial;
    for (const item of collection) {
        result = reducer(result, item);
    }
    return result;
}
/**
 * Checks if there's at least one item in a collection satisfying a predicate.
 *
 * @param collection The collection.
 * @param predicate The predicate.
 * @returns `true` if for at least one item in the collection the predicate returns
 *      `true` and `false` otherwise.
 */
function oneOfIterable(collection, predicate) {
    for (const item of collection) {
        if (predicate(item)) {
            return true;
        }
    }
    return false;
}
/**
 * Checks if all items of a collection satisfy a predicate.
 *
 * @param collection The collection.
 * @param predicate The predicate.
 * @returns `false` if for at least one item in the collection the predicate returns
 *      `false` and `true` otherwise.
 */
function allOfIterable(collection, predicate) {
    for (const item of collection) {
        if (!predicate(item)) {
            return false;
        }
    }
    return true;
}
/**
 * Creates an iterator for [startIndex, startIndex+length) range.
 */
function* rangeIterable(length, startIndex = 0) {
    const endIndex = startIndex + length;
    for (let i = startIndex; i < endIndex; i++) {
        yield i;
    }
}
function* zipIterables(ts, us, zipper = (t, u) => [t, u]) {
    const tIterator = ts[Symbol.iterator]();
    const uIterator = us[Symbol.iterator]();
    for (let t = tIterator.next(), u = uIterator.next(); !(t.done || u.done); t = tIterator.next(), u = uIterator.next()) {
        yield zipper(t.value, u.value);
    }
}


/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isPowOf2", function() { return isPowOf2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "align", function() { return align; });
/**
 * Checks if a number is a power of 2.
 *
 * @param x The number to check.
 * @returns `true` if the number is an integer power of 2 and `false` otherwise.
 */
function isPowOf2(x) {
    return x > 0 && !(x & (x - 1));
}
/**
 * Aligns an offset by an alignment given by a mask.
 *
 * @param offset The offset.
 * @param alignmentMask The alignment mask  a bit field that has `log2(alignment)`
 *      of least significant bits unset and other set, e.g. if `alignment` is 4
 *      then the `alignmentMask` will be `0xffffffc`
 * @returns Aligned offset.
 */
function align(offset, alignmentMask) {
    return (offset - 1 & alignmentMask) - alignmentMask;
}


/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Buffer; });
/** Wrapper around WebGLBuffer object. */
class Buffer {
    /**
     * Creates a new empty buffer in a WebGL context.
     *
     * @param gl The context the buffer will be created in.
     * @param target Binding target of the buffer. Since in WebGL once you've
     *      bound a buffer to a given target you can't bind it any other one,
     *      we "tie" the buffer and it's binding point together.
     * @param size Size of the buffer. We don't do actual allocation in the
     *      wrapper, it's context's responsibility. But it's convenient to be
     *      able to get the size from the wrapper object.
     */
    constructor(gl, target, size) {
        this._gl = gl;
        this._target = target;
        this._handle = gl.createBuffer();
        this._size = size;
    }
    /** Binds the buffer to the context to its binding target. */
    bind() {
        this._gl.bindBuffer(this._target, this._handle);
    }
    /**
     * Returns `true` if the buffer is currently bound to the context to its
     * binding target and `false` otherwise.
     */
    isBound() {
        const gl = this._gl;
        const handle = this._handle;
        switch (this._target) {
            case gl.ARRAY_BUFFER:
                return gl.getParameter(gl.ARRAY_BUFFER_BINDING) === handle;
            case gl.ELEMENT_ARRAY_BUFFER:
                return gl.getParameter(gl.ELEMENT_ARRAY_BUFFER_BINDING) === handle;
        }
        return false;
    }
    /** Returns binding target of the buffer. */
    getTarget() {
        return this._target;
    }
    /** Returns size of the buffer. */
    getSize() {
        return this._size;
    }
    /**
     * Destroys the buffer.
     */
    destroy() {
        this._gl.deleteBuffer(this._handle);
    }
}


/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Framebuffer; });
/** Wrapper around WebGLFramebuffer object. */
class Framebuffer {
    /**
     * Creates a new framebuffer in a WebGL context.
     *
     * @param gl The context the framebuffer will be created in.
     * @param width Width of the framebuffer.
     * @param height Height of the framebuffer.
     */
    constructor(gl, width, height) {
        this.isClear = false;
        this._gl = gl;
        this._handle = gl.createFramebuffer();
        this._width = width;
        this._height = height;
    }
    /**
     * Binds the framebuffer to the WebGL context.
     */
    bind() {
        const gl = this._gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._handle);
    }
    /**
     * Checks if the framebuffer is bound to the WebGL context.
     *
     * @returns `true` if the framebuffer is currently bound to the WebGL context
     *      and `false` otherwise.
     */
    isBound() {
        const gl = this._gl;
        return gl.getParameter(gl.FRAMEBUFFER_BINDING) === this._handle;
    }
    /**
     * Returns width of the framebuffer.
     */
    getWidth() {
        return this._width;
    }
    /**
     * Returns height of the framebuffer.
     */
    getHeight() {
        return this._height;
    }
    /**
     * Reads content of the color attachment as an RGBA bitmap.
     */
    readPixels() {
        const data = new Uint8Array(this.getWidth() * this.getHeight() * 4);
        this._gl.readPixels(0, 0, this._width, this._height, 6408 /* RGBA */, 5121 /* UNSIGNED_BYTE */, data);
        return data;
    }
    /**
     * Destroys the framebuffer.
     */
    destroy() {
        this._gl.deleteFramebuffer(this._handle);
    }
}


/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Program; });
/**
 * Inserts given parameters as preprocessor define directives into shader source.
 *
 * @param source Shader source.
 * @param defines Dictionary with parameters to define with preprocessor directives.
 * @returns Shader source with preprocessor directives inserted.
 */
function insertDefines(source, defines) {
    const definesString = Object.keys(defines)
        .map((defineName) => '#define ' + defineName + ' ' +
        defines[defineName])
        .join('\n');
    const versionIdx = source.indexOf('#version');
    if (versionIdx === -1) {
        return definesString + '\n' + source;
    }
    const nextLineIdx = source.indexOf('\n', versionIdx) + 1;
    return source.slice(0, nextLineIdx) + definesString + '\n' +
        source.slice(nextLineIdx);
}
/**
 * Creates a new shader of a given type out of a given source string.
 *
 * @param gl WebGL context the shader will be created in.
 * @param type The type of the shader, VERTEX_SHADER or FRAGMENT_SHADER.
 * @param source The source string.
 * @throws An error if compilation of the shader fails.
 * @returns The shader WebGL handle.
 */
function compileShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    // TODO Uncomment and put under debug flag (when implemented)
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        throw new Error('Failed to compile shader:\n' + gl.getShaderInfoLog(shader));
    }
    return shader;
}
/** Wrapper around WebGLProgram objects. */
class Program {
    /**
     * Constructs a new program.
     *
     * @param gl WebGL context the program will be created in.
     * @param vertexShaderSource Source code of vertex shader of the program.
     * @param fragmentShaderSource Source code of fragment shader of the program.
     * @param options Options.
     * @throws An error if shader compilation or program linking fails.
     */
    constructor(gl, vertexShaderSource, fragmentShaderSource, options) {
        this._gl = gl;
        const handle = this._handle = gl.createProgram();
        if (options && options.defines) {
            vertexShaderSource = insertDefines(vertexShaderSource, options.defines);
            fragmentShaderSource = insertDefines(fragmentShaderSource, options.defines);
        }
        const vertexShader = compileShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        gl.attachShader(handle, vertexShader);
        gl.attachShader(handle, fragmentShader);
        gl.deleteShader(vertexShader);
        gl.deleteShader(fragmentShader);
        if (options && options.attribMap) {
            Object.keys(options.attribMap)
                .forEach((attributeName) => gl.bindAttribLocation(handle, options.attribMap[attributeName], attributeName));
        }
        gl.linkProgram(handle);
        // TODO Uncomment and put under debug flag (when implemented)
        if (!gl.getProgramParameter(handle, gl.LINK_STATUS)) {
            throw new Error(`Failed to link program:\n${gl.getProgramInfoLog(handle)}`);
        }
        this._uniformCache = new Map();
    }
    /**
     * Binds the program to the WebGL context.
     */
    bind() {
        const gl = this._gl;
        const handle = this._handle;
        // TODO Uncomment and put under debug flag (when implemented)
        // gl.validateProgram(handle);
        // if (!gl.getProgramParameter(handle, gl.VALIDATE_STATUS)) {
        //     throw new Error(
        //         'Failed to validate program:\n' + gl.getProgramInfoLog(handle)
        //     );
        // }
        gl.useProgram(handle);
    }
    /**
     * Checks if the program is bound to the WebGL context.
     *
     * @returns `true` if the program if currently bound to the WebGL context and
     *      `false` otherwise.
     */
    isBound() {
        const gl = this._gl;
        return gl.getParameter(gl.CURRENT_PROGRAM) === this._handle;
    }
    /**
     * Sets an integer scalar value to a uniform. If there's no uniform with
     * given name in the program, silently does nothing.
     *
     * @param uniformName Name of the uniform.
     * @param value The scalar value.
     */
    setIntScalarUniform(uniformName, value) {
        const location = this._getUniformLocation(uniformName);
        if (location) {
            this._gl.uniform1i(location, value);
        }
    }
    /**
     * Sets a scalar value to a uniform. If there's no uniform with
     * given name in the program, silently does nothing.
     *
     * @param uniformName Name of the uniform.
     * @param value The scalar value.
     */
    setScalarUniform(uniformName, value) {
        const location = this._getUniformLocation(uniformName);
        if (location) {
            this._gl.uniform1f(location, value);
        }
    }
    /**
     * Sets a 2D vector to a uniform. If there's no uniform with given name in
     * the program, silently does nothing.
     *
     * @param uniformName Name of the uniform.
     * @param value The vector.
     */
    setVector2Uniform(uniformName, value) {
        const location = this._getUniformLocation(uniformName);
        if (location) {
            this._gl.uniform2f(location, value.x, value.y);
        }
    }
    /**
     * Sets a 3D vector to a uniform. If there's no uniform with given name in
     * the program, silently does nothing.
     *
     * @param uniformName Name of the uniform.
     * @param value The vector.
     */
    setVector3Uniform(uniformName, value) {
        const location = this._getUniformLocation(uniformName);
        if (location) {
            this._gl.uniform3f(location, value.x, value.y, value.z);
        }
    }
    /**
     * Sets a 4D vector to a uniform. If there's no uniform with given name in
     * the program, silently does nothing.
     *
     * @param uniformName Name of the uniform.
     * @param value The vector.
     */
    setVector4Uniform(uniformName, value) {
        const location = this._getUniformLocation(uniformName);
        if (location) {
            this._gl.uniform4f(location, value.x, value.y, value.z, value.w);
        }
    }
    /**
     * Sets a color to a uniform. If there's no uniform with given name in the
     * program, silently does nothing.
     *
     * @param uniformName Name of the uniform.
     * @param value The color.
     */
    setColorUniform(uniformName, value) {
        const location = this._getUniformLocation(uniformName);
        if (location) {
            this._gl.uniform4f(location, value.r, value.g, value.b, value.a);
        }
    }
    /**
     * Sets a 3x3 matrix to a uniform. If there's no uniform with given name in
     * the program, silently does nothing.
     *
     * @param uniformName Name of the uniform.
     * @param value The matrix.
     */
    setMatrix3Uniform(uniformName, value) {
        const location = this._getUniformLocation(uniformName);
        if (location) {
            this._gl.uniformMatrix3fv(location, false, value);
        }
    }
    /**
     * Sets a 4x4 matrix to a uniform. If there's no uniform with given name in
     * the program, silently does nothing.
     *
     * @param uniformName Name of the uniform.
     * @param value The matrix.
     */
    setMatrix4Uniform(uniformName, value) {
        const location = this._getUniformLocation(uniformName);
        if (location) {
            this._gl.uniformMatrix4fv(location, false, value);
        }
    }
    /**
     * Destroys the program.
     */
    destroy() {
        this._gl.deleteProgram(this._handle);
    }
    _getUniformLocation(name) {
        const cache = this._uniformCache;
        let location = cache.get(name);
        if (!location) {
            location = this._gl.getUniformLocation(this._handle, name);
            if (!location) {
                // TODO Uncomment and put under debug flag (when implemented)
                // console.warn(`Uniform ${name} doesn't exist in program.`);
                return null;
            }
            cache.set(name, location);
        }
        return location;
    }
}


/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Renderbuffer; });
/** Wrapper around WebGLRenderbuffer objects. */
class Renderbuffer {
    /**
     * Creates a new renderbuffer in a WebGL context.
     *
     * @param gl The context the renderbuffer will be created in.
     */
    constructor(gl, width, height) {
        this._gl = gl;
        this._handle = gl.createRenderbuffer();
        this._width = width;
        this._height = height;
    }
    /**
     * Binds the renderbuffer to the WebGL context.
     */
    bind() {
        const gl = this._gl;
        gl.bindRenderbuffer(gl.RENDERBUFFER, this._handle);
    }
    /**
     * Checks if the renderbuffer is bound to the WebGL context.
     *
     * @returns `true` if the renderbuffer is currently bound to the WebGL context
     *      and `false` otherwise.
     */
    isBound() {
        const gl = this._gl;
        return gl.getParameter(gl.RENDERBUFFER_BINDING) === this._handle;
    }
    /**
     * Attaches the renderbuffer to a currently bound to the WebGL context
     * framebuffer.
     *
     * @param attachmentPoint Attachment point the renderbuffer will be attached
     *      to.
     */
    attachToFramebuffer(attachmentPoint) {
        const gl = this._gl;
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachmentPoint, gl.RENDERBUFFER, this._handle);
    }
    getWidth() {
        return this._width;
    }
    getHeight() {
        return this._height;
    }
    /**
     * Destroys the renderbuffer.
     */
    destroy() {
        this._gl.deleteRenderbuffer(this._handle);
    }
}


/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RenderContextCapabilitiesManager; });
// tslint:disable
/*
    This is automatically generated by /tools/gl_gen/gen_capabilities.js script.
    Instead of modifying it edit the script and regenerate this file.
*/
class RenderContextCapabilitiesManager {
    constructor(gl) {
        this._gl = gl;
        this._paramValues = new Map();
    }
    getAliasedLineWidthRange() { return this._getParam(33902 /* ALIASED_LINE_WIDTH_RANGE */); }
    getAliasedPointSizeRange() { return this._getParam(33901 /* ALIASED_POINT_SIZE_RANGE */); }
    getMaxCombinedTextureImageUnits() { return this._getParam(35661 /* MAX_COMBINED_TEXTURE_IMAGE_UNITS */); }
    getMaxCubeMapTextureSize() { return this._getParam(34076 /* MAX_CUBE_MAP_TEXTURE_SIZE */); }
    getMaxFragmentUniformVectors() { return this._getParam(36349 /* MAX_FRAGMENT_UNIFORM_VECTORS */); }
    getMaxRenderbufferSize() { return this._getParam(34024 /* MAX_RENDERBUFFER_SIZE */); }
    getMaxTextureImageUnits() { return this._getParam(34930 /* MAX_TEXTURE_IMAGE_UNITS */); }
    getMaxTextureSize() { return this._getParam(3379 /* MAX_TEXTURE_SIZE */); }
    getMaxVaryingVectors() { return this._getParam(36348 /* MAX_VARYING_VECTORS */); }
    getMaxVertexAttribs() { return this._getParam(34921 /* MAX_VERTEX_ATTRIBS */); }
    getMaxVertexTextureImageUnits() { return this._getParam(35660 /* MAX_VERTEX_TEXTURE_IMAGE_UNITS */); }
    getMaxVertexUniformVectors() { return this._getParam(36347 /* MAX_VERTEX_UNIFORM_VECTORS */); }
    getMaxViewportDims() { return this._getParam(3386 /* MAX_VIEWPORT_DIMS */); }
    getRenderer() { return this._getParam(7937 /* RENDERER */); }
    getSubpixelBits() { return this._getParam(3408 /* SUBPIXEL_BITS */); }
    getVendor() { return this._getParam(7936 /* VENDOR */); }
    getVersion() { return this._getParam(7938 /* VERSION */); }
    /** Calling this method w/o `WEBGL_debug_renderer_info` enabled will return `null`! */
    getUnmaskedVendor() { return this._getParam(37445 /* UNMASKED_VENDOR */); }
    /** Calling this method w/o `WEBGL_debug_renderer_info` enabled will return `null`! */
    getUnmaskedRenderer() { return this._getParam(37446 /* UNMASKED_RENDERER */); }
    _getParam(param) {
        const paramValues = this._paramValues;
        let paramValue = paramValues.get(param);
        if (!paramValue) {
            paramValue = this._gl.getParameter(param);
            paramValues.set(param, paramValue);
        }
        return paramValue;
    }
}


/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BLEND_OVER_RENDER_STATE", function() { return BLEND_OVER_RENDER_STATE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BLEND_OVER_PREMULTIPLIED_ALPHA_RENDER_STATE", function() { return BLEND_OVER_PREMULTIPLIED_ALPHA_RENDER_STATE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RenderState; });
/* harmony import */ var _util_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(11);

/**
 * Preset of render state for OVER compositing,
 * @see T. Porter and T. Duff, "Compositing Digital Images", Proceedings of
 *      SIGGRAPH'84, 18 (1984).
 */
const BLEND_OVER_RENDER_STATE = {
    blend: true,
    blendFuncSrcRgb: 770 /* SRC_ALPHA */,
    blendFuncDstRgb: 771 /* ONE_MINUS_SRC_ALPHA */,
    blendFuncSrcAlpha: 1 /* ONE */,
    blendFuncDstAlpha: 771 /* ONE_MINUS_SRC_ALPHA */
};
const BLEND_OVER_PREMULTIPLIED_ALPHA_RENDER_STATE = {
    blend: true,
    blendFuncSrcRgb: 1 /* ONE */,
    blendFuncDstRgb: 771 /* ONE_MINUS_SRC_ALPHA */,
    blendFuncSrcAlpha: 1 /* ONE */,
    blendFuncDstAlpha: 771 /* ONE_MINUS_SRC_ALPHA */
};
/**
 * State of the WebGL rendering pipeline. Doesn't include object bindings since
 * the context handles them.
 */
class RenderState {
    /**
     * Creates a new render state object.
     *
     * @param state Object with state properties that values differ from default
     *      ones.
     */
    constructor(...state) {
        this.clearColor = _util_color__WEBPACK_IMPORTED_MODULE_0__["create"](0, 0, 0, 0);
        this.clearDepth = 1;
        this.clearStencil = 0;
        this.colorMaskR = true;
        this.colorMaskG = true;
        this.colorMaskB = true;
        this.colorMaskAlpha = true;
        this.blend = false;
        this.blendEquationRgb = 32774 /* ADD */;
        this.blendEquationAlpha = 32774 /* ADD */;
        this.blendFuncSrcRgb = 1 /* ONE */;
        this.blendFuncDstRgb = 0 /* ZERO */;
        this.blendFuncSrcAlpha = 1 /* ONE */;
        this.blendFuncDstAlpha = 0 /* ZERO */;
        this.cullFace = false;
        this.cullFaceMode = 1029 /* BACK */;
        this.frontFaceMode = 2305 /* COUNTERCLOCKWISE */;
        this.depthTest = false;
        this.depthFunc = 513 /* LESS */;
        this.depthRangeNear = 0;
        this.depthRangeFar = 1;
        this.depthMask = true;
        this.dither = true;
        this.drawBuffers = [36064 /* COLOR_ATTACHMENT0 */];
        this.polygonOffset = false;
        this.polygonOffsetFactor = 0;
        this.polygonOffsetUnits = 0;
        this.sampleAlphaToCoverage = false;
        this.sampleCoverage = false;
        this.sampleCoverageValue = 1;
        this.sampleCoverageInvert = false;
        this.scissorTest = false;
        this.scissorX = 0;
        this.scissorY = 0;
        // Actual defaults aren't known here since they depend upon context. -1's
        // as "do not change" values.
        this.scissorWidth = -1;
        this.scissorHeight = -1;
        this.stencilTest = false;
        this.stencilReference = 0;
        this.stencilMask = 0xff;
        this.stencilWriteMask = 0xff;
        this.stencilFrontFunc = 519 /* ALWAYS */;
        this.stencilFrontFailOp = 7680 /* KEEP */;
        this.stencilFrontDepthFailOp = 7680 /* KEEP */;
        this.stencilFrontDepthPassOp = 7680 /* KEEP */;
        this.stencilBackFunc = 519 /* ALWAYS */;
        this.stencilBackFailOp = 7680 /* KEEP */;
        this.stencilBackDepthFailOp = 7680 /* KEEP */;
        this.stencilBackDepthPassOp = 7680 /* KEEP */;
        this.viewportX = 0;
        this.viewportY = 0;
        // Actual defaults aren't known here since they depend upon context. -1's
        // as "do not change" values.
        this.viewportWidth = -1;
        this.viewportHeight = -1;
        Object.assign(this, ...state);
    }
}


/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OPAQUE_BLACK", function() { return OPAQUE_BLACK; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TRANSPARENT_BLACK", function() { return TRANSPARENT_BLACK; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "areEqual", function() { return areEqual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodeAbgr8", function() { return decodeAbgr8; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encodeRgba8", function() { return encodeRgba8; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isOpaque", function() { return isOpaque; });
const OPAQUE_BLACK = create(0, 0, 0, 1);
const TRANSPARENT_BLACK = create(0, 0, 0, 0);
/**
 * @param r Red component as a normalized value [0..1]
 * @param g Green component as a normalized value [0..1]
 * @param b Blue component as a normalized value [0..1]
 * @param a Alpha component as a normalized value [0..1]
 *
 * @returns A color with given values assigned to components.
 */
function create(r, g, b, a = 1) {
    return { r, g, b, a };
}
/**
 * Copies a color to another one.
 *
 * @param src The source color.
 * @param dst The color the source color will be copied to.
 * @returns `dst`.
 */
function copy(src, dst = create(0, 0, 0, 0)) {
    dst.r = src.r;
    dst.g = src.g;
    dst.b = src.b;
    dst.a = src.a;
    return dst;
}
function areEqual(c1, c2) {
    return c1.r === c2.r && c1.g === c2.g && c1.b === c2.b && c1.a === c2.a;
}
/**
 * Decodes a color represented as four 8-bit channels encoded into a 32-bit
 * number in ABGR order (from MSB to LSB).
 *
 * @param color Color encoded into unsigned 32-bit integer.
 * @returns Decoded color.
 */
function decodeAbgr8(color) {
    return {
        r: (color >>> 24) / 0xff,
        g: (color >>> 16 & 0xff) / 0xff,
        b: (color >>> 8 & 0xff) / 0xff,
        a: (color & 0xff) / 0xff
    };
}
/**
 * Encodes a color components into four 8 bit numbers packed into 32-bit one.
 *
 * @param c The color to be encoded.
 * @returns The color as 32-bit integer.
 */
function encodeRgba8(c) {
    return (c.r * 0xff |
        (c.g * 0xff << 8) |
        (c.b * 0xff << 16) |
        (c.a * 0xff << 24));
}
/**
 * Checks if a color is completely opaque.
 *
 * @param color The color to be checked.
 * @returns `true` if the color is opaque and `false` otherwise.
 */
function isOpaque(color) {
    return color.a === 1;
}


/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_TEXTURE_PARAMS", function() { return DEFAULT_TEXTURE_PARAMS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Texture; });
/**
 * Our defaults for textures are different from ones in WebGL for two reasons:
 * 1. default minification filter in WebGL is NEAREST_MIPMAP_LINEAR which requires
 *    texture to have all mip levels specified;
 * 2. default wrap modes are REPEAT which isn't supported for NPOT textures.
 */
const DEFAULT_TEXTURE_PARAMS = {
    wrapS: 33071 /* CLAMP_TO_EDGE */,
    wrapT: 33071 /* CLAMP_TO_EDGE */,
    magnificationFilter: 9728 /* NEAREST */,
    minificationFilter: 9728 /* NEAREST */,
    premultipliedAlpha: false
};
/** Wrapper around WebGLTexture objects. For now only works with 2D textures. */
class Texture {
    /**
     * Creates a new texture in a WebGL context.
     *
     * @param gl The context the texture will be created in.
     */
    constructor(gl, width, height, format, type, params = DEFAULT_TEXTURE_PARAMS) {
        this._gl = gl;
        this._format = format;
        this._type = type;
        this._params = params;
        this._width = width;
        this._height = height;
        this._handle = gl.createTexture();
        this.bind();
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, params.wrapS);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, params.wrapT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, params.magnificationFilter);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, params.minificationFilter);
        gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, 0, format, type, null);
    }
    /**
     * Binds the texture to the WebGL context as a 2D texture.
     */
    bind() {
        const gl = this._gl;
        gl.bindTexture(gl.TEXTURE_2D, this._handle);
    }
    /**
     * Checks if the texture is bound to the WebGL context.
     *
     * @returns `true` if the texture is currently bound to the WebGL context
     *      and `false` otherwise.
     */
    isBound() {
        const gl = this._gl;
        return gl.getParameter(gl.TEXTURE_BINDING_2D) === this._handle;
    }
    /**
     * Attaches the texture to a currently bound to the WebGL context framebuffer.
     *
     * @param attachmentPoint Attachment point the texture will be attached to.
     */
    attachToFramebuffer(attachmentPoint) {
        const gl = this._gl;
        gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentPoint, gl.TEXTURE_2D, this._handle, 0);
    }
    /** Returns width of the texture. */
    getWidth() {
        return this._width;
    }
    /** Returns height of the texture. */
    getHeight() {
        return this._height;
    }
    /** Returns pixel format of the texture. */
    getFormat() {
        return this._format;
    }
    /** Return pixel type of the texture. */
    getType() {
        return this._type;
    }
    /** Return params of the texture. */
    getParams() {
        return this._params;
    }
    /**
     * Destroys the texture.
     */
    destroy() {
        this._gl.deleteTexture(this._handle);
    }
}


/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return VertexArrayObject; });
/**
 * Wrapper around vertex array (VAO) object from `OES_vertex_array_object`
 * extension.
 */
class VertexArrayObject {
    /**
     * Creates new VAO in a given WebGL context.
     *
     * @param gl The context.
     * @param vaoExt Instance of `OES_vertex_array_object` extension.
     * @param attributeMapping Mapping of attributes.
     */
    constructor(gl, vaoExt, attributeMapping) {
        this._gl = gl;
        this._vaoExt = vaoExt;
        this._handle = vaoExt.createVertexArrayOES();
        this.attributeMapping = attributeMapping;
    }
    /**
     * Binds the VAO to the context.
     */
    bind() {
        this._vaoExt.bindVertexArrayOES(this._handle);
    }
    /**
     * Checks if the VAO is currently bound to the context.
     *
     * @returns `true` if the VAO is currently bound to the WebGL context and
     *      `false` otherwise.
     */
    isBound() {
        return this._gl.getParameter(this._vaoExt.VERTEX_ARRAY_BINDING_OES) ===
            this._handle;
    }
    /**
     * Destroys the VAO.
     */
    destroy() {
        this._vaoExt.deleteVertexArrayOES(this._handle);
    }
}


/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EventEmitter", function() { return EventEmitter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VoidEventEmitter", function() { return VoidEventEmitter; });
/**
 * Simple pub/sub implementation. The emitter is supposed to emit only one type of event,
 * if someone has to emit events of different types, multiple emitters should be created.
 */
class EventEmitter {
    constructor() {
        this._listeners = new Set();
    }
    /**
     * Adds listener.
     */
    addListener(listener) {
        this._listeners.add(listener);
    }
    /**
     * Removes listener.
     */
    removeListener(listener) {
        this._listeners.delete(listener);
    }
    /**
     * Calls all the added listeners, the order (e.g. of adding) is not guaranteed.
     */
    fire(data) {
        this._listeners.forEach((listener) => {
            listener(data);
        });
    }
}
/**
 * Event emitter with no payload emitted.
 */
class VoidEventEmitter extends EventEmitter {
    fire() {
        super.fire(undefined);
    }
}


/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Camera; });
/* harmony import */ var _math_scalar__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(16);
/* harmony import */ var _util_rad_deg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17);
/* harmony import */ var _util_options__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(18);
/* harmony import */ var _math_matrix4__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(19);
/* harmony import */ var _math_vector2__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(23);
/* harmony import */ var _math_vector3__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(20);
/* harmony import */ var _util_event_emitter__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(14);








// TODO(dmikis) We want to constraint coordinates so visible region doesn't extend
//      out of world boundaries. However, in current implementation it doesn't
//      work properly for aspect ratios >1 on zoom 0 since visible region is
//      larger that the world itself (so there's no way to squeeze it in). For
//      the current case (i.e. cycled in horizontal direction) it is not a problem.
const MAX_TILT = Object(_util_rad_deg__WEBPACK_IMPORTED_MODULE_1__["deg2rad"])(40);
/**
 * If a camera has zoom less than of equal to `NO_TILT_MAX_ZOOM`, tilt won't be
 * allowed.
 */
const NO_TILT_MAX_ZOOM = 1;
/**
 * If a camera has zoom greater than of equal to `FULL_TILT_MIN_ZOOM`, tilt will
 * be allowed up to `MAX_TILT`.
 */
const FULL_TILT_MIN_ZOOM = NO_TILT_MAX_ZOOM + 1;
const FRUSTUM_DIRECTIONS = [
    // tslint:disable
    _math_vector3__WEBPACK_IMPORTED_MODULE_5__["create"](-1, 1, -1),
    _math_vector3__WEBPACK_IMPORTED_MODULE_5__["create"](1, 1, -1),
    _math_vector3__WEBPACK_IMPORTED_MODULE_5__["create"](1, -1, -1),
    _math_vector3__WEBPACK_IMPORTED_MODULE_5__["create"](-1, -1, -1)
    // tslint:enable
];
/**
 * How big the world sould be on a screen if zoom is 0, in device independent pixels
 */
const ZOOM_0_WORLD_CSS_PIXEL_SIZE = 256;
const DEFAULT_OPTIONS = {
    wrapModeX: 1 /* CLAMP_TO_EDGE */,
    wrapModeY: 1 /* CLAMP_TO_EDGE */,
    minZoom: 0,
    maxZoom: 24,
    fov: Object(_util_rad_deg__WEBPACK_IMPORTED_MODULE_1__["deg2rad"])(30)
};
/**
 * Restricts a new value for a center's coordinate according to given wrap mode.
 *
 * @param wrapMode The wrap mode.
 * @param newCoordinate The new value.
 * @param oldCoordinate Current value of the coordinate.
 * @param bboxMin Minimum corresponding coordinate of bounding box of the
 *      visible quadrilateral.
 * @param bboxMax Maximum corresponding coordinate of bounding box of the
 *      visible quadrilateral.
 * @returns Restricted value for the coordinate.
 */
function restrictCoordinate(wrapMode, newCoordinate) {
    switch (wrapMode) {
        case 0 /* NONE */:
            return newCoordinate;
        case 1 /* CLAMP_TO_EDGE */:
            return Object(_math_scalar__WEBPACK_IMPORTED_MODULE_0__["clamp"])(newCoordinate, -1, 1);
        case 2 /* REPEAT */:
            return Object(_math_scalar__WEBPACK_IMPORTED_MODULE_0__["cycleRestrict"])(newCoordinate, -1, 1);
    }
}
/**
 * Camera represents user's point of view in the world space, as a real camera it has restricted field of view,
 * it can move and rotate (with or without animation).
 */
class Camera {
    /**
     * Creates a new camera.
     *
     * @param options Options.
     */
    constructor(options) {
        this.options = Object(_util_options__WEBPACK_IMPORTED_MODULE_2__["default"])(DEFAULT_OPTIONS, options);
        this.center = new Camera._Center(this);
        this.onUpdate = new _util_event_emitter__WEBPACK_IMPORTED_MODULE_6__["VoidEventEmitter"]();
        const screenSize = new Camera._ScreenSize(this);
        this.screenSize = screenSize;
        this._distanceToCenter = 1;
        this._zoom = this.options.minZoom;
        this._tilt = this._azimuth = 0;
        this._dirtyBits = -1 /* ALL */;
        this._viewProjMatrix = _math_matrix4__WEBPACK_IMPORTED_MODULE_3__["copy"](_math_matrix4__WEBPACK_IMPORTED_MODULE_3__["IDENTITY"]);
        this._visibleQuadrilateral = [
            _math_vector3__WEBPACK_IMPORTED_MODULE_5__["create"](0, 0, 0),
            _math_vector3__WEBPACK_IMPORTED_MODULE_5__["create"](0, 0, 0),
            _math_vector3__WEBPACK_IMPORTED_MODULE_5__["create"](0, 0, 0),
            _math_vector3__WEBPACK_IMPORTED_MODULE_5__["create"](0, 0, 0)
        ];
        this._visibleQuadrilateralBBox =
            _math_vector2__WEBPACK_IMPORTED_MODULE_4__["computeBBoxForPoints"](this._visibleQuadrilateral);
        this._pixelSize = _math_vector2__WEBPACK_IMPORTED_MODULE_4__["create"](0, 0);
    }
    get aspectRatio() {
        const { width, height } = this.screenSize;
        if (height !== 0) {
            return width / height;
        }
        else {
            // when height == 0 we cannot compute viewProj matrix or visible region, 1 allows to handle this case with
            // no exceptions thrown, but technically it is not correct and should be reconsidered if any issue is found
            return 1;
        }
    }
    get zoom() {
        return this._zoom;
    }
    get worldToPxFactor() {
        return this._worldToPxFactor;
    }
    /**
     * Sets new zoom to the camera with respect to provided limits in the options.
     */
    set zoom(newZoom) {
        newZoom = Object(_math_scalar__WEBPACK_IMPORTED_MODULE_0__["clamp"])(newZoom, this.options.minZoom, this.options.maxZoom);
        if (newZoom !== this._zoom) {
            this._zoom = newZoom;
            this._computeDistanceToCenter();
            // Constraints on tilt may have changed, we need to recompute it.
            this._tilt = this._constrainTilt(this._tilt);
            this._worldToPxFactor = 2.0 / (ZOOM_0_WORLD_CSS_PIXEL_SIZE * Math.pow(2, newZoom));
            this._setDirtyBits(1 /* VIEW_PROJ_MATRIX */ | 2 /* VISIBLE_QUADRILATERAL */);
        }
    }
    get tilt() {
        return this._tilt;
    }
    set tilt(newTilt) {
        newTilt = this._constrainTilt(newTilt);
        if (this._tilt !== newTilt) {
            this._tilt = newTilt;
            this._setDirtyBits(1 /* VIEW_PROJ_MATRIX */ | 2 /* VISIBLE_QUADRILATERAL */);
        }
    }
    get azimuth() {
        return this._azimuth;
    }
    set azimuth(newAzimuth) {
        newAzimuth = Object(_math_scalar__WEBPACK_IMPORTED_MODULE_0__["cycleRestrict"])(newAzimuth, 0, 2 * Math.PI);
        if (this._azimuth !== newAzimuth) {
            this._azimuth = newAzimuth;
            this._setDirtyBits(1 /* VIEW_PROJ_MATRIX */ | 2 /* VISIBLE_QUADRILATERAL */);
        }
    }
    /**
     * Size of a pixel in NDC.
     */
    get pixelSize() {
        return this._pixelSize;
    }
    /**
     * Invalidate all internally cached values (e.g. view matrix).
     */
    setDirty() {
        this._setDirtyBits(-1 /* ALL */);
    }
    /**
     * Recomputes (if needed) the view projection matrix.
     *
     * @returns The view-projection matrix.
     */
    getViewProjMatrix() {
        const viewProjMatrix = this._viewProjMatrix;
        if (this._dirtyBits & 1 /* VIEW_PROJ_MATRIX */) {
            _math_matrix4__WEBPACK_IMPORTED_MODULE_3__["copy"](_math_matrix4__WEBPACK_IMPORTED_MODULE_3__["IDENTITY"], viewProjMatrix);
            _math_matrix4__WEBPACK_IMPORTED_MODULE_3__["lookAt"](viewProjMatrix, this._computeCenterToCameraVector(), _math_vector3__WEBPACK_IMPORTED_MODULE_5__["ORIGIN"], _math_vector3__WEBPACK_IMPORTED_MODULE_5__["rotateZ"](_math_vector3__WEBPACK_IMPORTED_MODULE_5__["POSITIVE_Y"], this._azimuth), viewProjMatrix);
            const { fov } = this.options;
            const tanFactors = Math.tan(this._tilt) * Math.tan(0.5 * fov);
            _math_matrix4__WEBPACK_IMPORTED_MODULE_3__["perspective"](viewProjMatrix, fov, this.aspectRatio, Math.min(this._distanceToCenter * 0.01, this._distanceToCenter / (1 + tanFactors)), this._distanceToCenter / (1 - tanFactors), viewProjMatrix);
            this._dirtyBits &= ~1 /* VIEW_PROJ_MATRIX */;
        }
        return viewProjMatrix;
    }
    /**
     * Recomputes (if needed) and returns quadrilateral cut on the world plane
     * by frustum of the camera.
     *
     * @return The quadrilateral enclosing visible part of the world plane.
     */
    getVisibleRegion() {
        this._computeVisibleQuadrilateral();
        return this._visibleQuadrilateral;
    }
    /**
     * Recomputes (if needed) and returns bounding box of the visible region.
     *
     * @return Bounding box of the visible quadrilateral.
     */
    getVisibleRegionBBox() {
        this._computeVisibleQuadrilateral();
        return this._visibleQuadrilateralBBox;
    }
    _constrainTilt(tilt) {
        return Object(_math_scalar__WEBPACK_IMPORTED_MODULE_0__["clamp"])(tilt, 0, MAX_TILT * Object(_math_scalar__WEBPACK_IMPORTED_MODULE_0__["smoothStep"])(NO_TILT_MAX_ZOOM, FULL_TILT_MIN_ZOOM, this._zoom));
    }
    _setDirtyBits(bits) {
        if (bits ^ (bits & this._dirtyBits)) {
            this._dirtyBits |= bits;
            this.onUpdate.fire();
        }
    }
    _computeDistanceToCenter() {
        this._distanceToCenter =
            this.screenSize.height * Math.pow(2, -this._zoom) /
                (Math.tan(0.5 * this.options.fov) * ZOOM_0_WORLD_CSS_PIXEL_SIZE);
    }
    _computeCenterToCameraVector(dst = _math_vector3__WEBPACK_IMPORTED_MODULE_5__["create"](0, 0, 0)) {
        _math_vector3__WEBPACK_IMPORTED_MODULE_5__["muln"](_math_vector3__WEBPACK_IMPORTED_MODULE_5__["POSITIVE_Z"], this._distanceToCenter, dst);
        _math_vector3__WEBPACK_IMPORTED_MODULE_5__["rotateX"](dst, this._tilt, dst);
        _math_vector3__WEBPACK_IMPORTED_MODULE_5__["rotateZ"](dst, this._azimuth, dst);
        return dst;
    }
    _computeVisibleQuadrilateral() {
        if (this._dirtyBits & 2 /* VISIBLE_QUADRILATERAL */) {
            const visibleQuadrilateral = this._visibleQuadrilateral;
            const halfFovTan = Math.tan(0.5 * this.options.fov);
            const origin = this._computeCenterToCameraVector();
            _math_vector2__WEBPACK_IMPORTED_MODULE_4__["add"](origin, this.center, origin);
            const scale = _math_vector3__WEBPACK_IMPORTED_MODULE_5__["create"](halfFovTan * this.aspectRatio, halfFovTan, 1);
            const direction = _math_vector3__WEBPACK_IMPORTED_MODULE_5__["create"](0, 0, 0);
            const ray = { origin, direction };
            for (let i = 0; i < 4; ++i) {
                _math_vector3__WEBPACK_IMPORTED_MODULE_5__["mulv"](FRUSTUM_DIRECTIONS[i], scale, direction);
                _math_vector3__WEBPACK_IMPORTED_MODULE_5__["rotateX"](direction, this._tilt, direction);
                _math_vector3__WEBPACK_IMPORTED_MODULE_5__["rotateZ"](direction, this._azimuth, direction);
                if (!_math_vector3__WEBPACK_IMPORTED_MODULE_5__["getPlaneRayIntersection"](_math_vector3__WEBPACK_IMPORTED_MODULE_5__["XY"], ray, visibleQuadrilateral[i])) {
                    throw new Error('Visible quadrilateral is unbounded, engine can\'t handle that case (yet)');
                }
            }
            _math_vector2__WEBPACK_IMPORTED_MODULE_4__["computeBBoxForPoints"](visibleQuadrilateral, this._visibleQuadrilateralBBox);
            this._dirtyBits &= ~2 /* VISIBLE_QUADRILATERAL */;
        }
    }
}
/**
 * Implementation of a center vector of a camera. Takes into account wrapping
 * modes and updates camera's dirty flags.
 */
Camera._Center = class {
    /**
     * Creates new center vector for a camera.
     *
     * @param camera The camera.
     */
    constructor(camera) {
        this._camera = camera;
        this._x = this._y = 0;
    }
    /**
     * @returns Values of abscissa of the center vector.
     */
    get x() {
        return this._x;
    }
    /**
     * Properly clamps or wraps new abscissa value and sets it to the vector.
     *
     * @param newX The new
     */
    set x(newX) {
        const camera = this._camera;
        newX = restrictCoordinate(camera.options.wrapModeX, newX);
        if (this._x !== newX) {
            this._x = newX;
            camera._setDirtyBits(2 /* VISIBLE_QUADRILATERAL */);
        }
    }
    /**
     * @returns Values of ordinate of the center vector.
     */
    get y() {
        return this._y;
    }
    /**
     * Properly clamps or wraps new ordinate value and sets it to the vector.
     */
    set y(newY) {
        const camera = this._camera;
        newY = restrictCoordinate(camera.options.wrapModeY, newY);
        if (this._y !== newY) {
            this._y = newY;
            camera._setDirtyBits(2 /* VISIBLE_QUADRILATERAL */);
        }
    }
};
Camera._ScreenSize = class {
    constructor(camera) {
        this._camera = camera;
        this._width = this._height = 0;
    }
    get width() {
        return this._width;
    }
    set width(newWidth) {
        if (this._width !== newWidth) {
            this._width = newWidth;
            const camera = this._camera;
            camera._setDirtyBits(1 /* VIEW_PROJ_MATRIX */ | 2 /* VISIBLE_QUADRILATERAL */);
            camera._pixelSize.x = 2.0 / this._width;
        }
    }
    get height() {
        return this._height;
    }
    set height(newHeight) {
        if (this._height !== newHeight) {
            this._height = newHeight;
            const camera = this._camera;
            camera._computeDistanceToCenter();
            camera._setDirtyBits(1 /* VIEW_PROJ_MATRIX */ | 2 /* VISIBLE_QUADRILATERAL */);
            camera._pixelSize.y = 2.0 / this._height;
        }
    }
};


/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clamp", function() { return clamp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cycleRestrict", function() { return cycleRestrict; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mix", function() { return mix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "smoothStep", function() { return smoothStep; });
/**
 * Clamps a value to a given range.
 *
 * @param x The value.
 * @param min Start of the range.
 * @param max End of the range.
 * @returns Clamped value.
 */
function clamp(x, min, max) {
    return min < x ? x < max ? x : max : min;
}
/**
 * Restricts a value to a given cycled range, i.e. ends of the range are
 * equivalent. E.g. like angles can be restricted to any range of size `2 * PI`.
 *
 * @param x The value.
 * @param min Start of the range.
 * @param max End of the range.
 * @returns Restricted value.
 */
function cycleRestrict(x, min, max) {
    const d = max - min;
    const s = (x - min) / (max - min);
    return min + d * (s - Math.floor(s));
}
/**
 * Linear interpolation.
 *
 * @param min Value that correspond to 0% progress.
 * @param max Value that correspond to 100% progress.
 * @param progress In 0..1.0 range that maps to 0..100% progress. It is allowed to pass a value
 *      outside of this range, that means progress greater then 100% or negative progress.
 */
function mix(min, max, progress) {
    return (1 - progress) * min + progress * max;
}
/**
 * A step function with a smooth transition between given edges. Completely
 * analogous to `smoothstep` in GLSL (GLSL ES 1.0 8.3).
 *
 * @param edge1 The smaller edge.
 * @param edge2
 * @param x `0` if `x < edge1`, `1` if `x > edge2` and an interpolated value for
 *      `edge1 < x < edge2`.
 */
function smoothStep(edge1, edge2, x) {
    const factor = clamp((x - edge1) / (edge2 - edge1), 0, 1);
    return factor * factor * (3 - 2 * factor);
}


/***/ }),
/* 17 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deg2rad", function() { return deg2rad; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rad2deg", function() { return rad2deg; });
const DEG_TO_RAD = Math.PI / 180;
function deg2rad(x) {
    return x * DEG_TO_RAD;
}
function rad2deg(x) {
    return x / DEG_TO_RAD;
}


/***/ }),
/* 18 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getFullOptions; });
/**
 * Resolves options.
 *
 * @param defaultOptions Object with default values.
 * @param options Object with custom values for options. Later objects "override"
 *      former ones.
 * @returns New object containing resolved options.
 */
function getFullOptions(defaultOptions, ...options) {
    return Object.assign({}, defaultOptions, ...options);
}


/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IDENTITY", function() { return IDENTITY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZERO", function() { return ZERO; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zero", function() { return zero; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateX", function() { return rotateX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateY", function() { return rotateY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateZ", function() { return rotateZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lookAt", function() { return lookAt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "perspective", function() { return perspective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "apply", function() { return apply; });
/* harmony import */ var _vector3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(20);

// TODO(dmikis) RoMatrix4?
const IDENTITY = [
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    0, 0, 0, 1
];
const ZERO = [
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0
];
const MATRIX_SIZE = 16;
/**
 * Creates and returns a new **uninitialized** matrix.
 */
function create() {
    return new Array(MATRIX_SIZE);
}
/**
 * Zeroes a matrix.
 *
 * @param dst The matrix.
 * @returns `dst`.
 */
function zero(dst = create()) {
    for (let i = 0; i < MATRIX_SIZE; ++i) {
        dst[i] = 0;
    }
    return dst;
}
/**
 * Copies a matrix to another one.
 *
 * @param src The matrix to be copied.
 * @param dst The matrix the `src` will be copied to.
 * @returns `dst`.
 */
function copy(src, dst = create()) {
    for (let i = 0; i < MATRIX_SIZE; ++i) {
        dst[i] = src[i];
    }
    return dst;
}
/**
 * Applies a rotation around the X axis by a given angle to a given matrix.
 * Positive direction is from positive Y to positive Z.
 *
 * @param src The matrix to be multiplied by the rotation matrix.
 * @param angle The angle of rotation.
 * @param dst The matrix the product will be stored to. Can be the same as `src`.
 * @returns `dst`.
 */
function rotateX(src, angle, dst = create()) {
    const angleCos = Math.cos(angle);
    const angleSin = Math.sin(angle);
    // The rotation matrix:
    //
    // 1   0    0 0
    // 0 cos -sin 0
    // 0 sin  cos 0
    // 0   0    0 1
    for (let i = 0; i < MATRIX_SIZE; i += 4) {
        dst[i] = src[i];
        const m1i = src[i + 1];
        const m2i = src[i + 2];
        dst[i + 1] = m1i * angleCos - m2i * angleSin;
        dst[i + 2] = m1i * angleSin + m2i * angleCos;
        dst[i + 3] = src[i + 3];
    }
    return dst;
}
/**
 * Applies a rotation around the Y axis by a given angle to a given matrix.
 * Positive direction is from positive X to positive Z.
 *
 * @param src The matrix to be multiplied by the rotation matrix.
 * @param angle The angle of rotation.
 * @param dst The matrix the product will be stored to. Can be the same as `src`.
 * @returns `dst`.
 */
function rotateY(src, angle, dst = create()) {
    const angleCos = Math.cos(angle);
    const angleSin = Math.sin(angle);
    // The rotation matrix:
    //
    // cos 0 -sin 0
    // 0   1    0 0
    // sin 0  cos 0
    // 0    0   0 1
    for (let i = 0; i < MATRIX_SIZE; i += 4) {
        const m0i = src[i];
        const m2i = src[i + 2];
        dst[i] = m0i * angleCos - m2i * angleSin;
        dst[i + 1] = src[i + 1];
        dst[i + 2] = m0i * angleSin + m2i * angleCos;
        dst[i + 3] = src[i + 3];
    }
    return dst;
}
/**
 * Applies a rotation around the X axis by a given angle to a given matrix.
 * Positive direction is from positive X to positive Y.
 *
 * @param src The matrix to be multiplied by the rotation matrix.
 * @param angle The angle of rotation.
 * @param dst The matrix the product will be stored to. Can be the same as `src`.
 * @returns `dst`.
 */
function rotateZ(src, angle, dst = create()) {
    const angleCos = Math.cos(angle);
    const angleSin = Math.sin(angle);
    // The rotation matrix:
    // cos -sin 0 0
    // sin  cos 0 0
    //   0    0 1 0
    //   0    0 0 1
    for (let i = 0; i < MATRIX_SIZE; i += 4) {
        const m0i = src[i];
        const m1i = src[i + 1];
        dst[i] = m0i * angleCos - m1i * angleSin;
        dst[i + 1] = m0i * angleSin + m1i * angleCos;
        dst[i + 2] = src[i + 2];
        dst[i + 3] = src[i + 3];
    }
    return dst;
}
/**
 * Applies a translation by a given vector to a given matrix.
 *
 * @param src The matrix to be multiplied by the translation matrix.
 * @param translation The translation vector.
 * @param dst The matrix the product will be stored to. Can be the same as `src`.
 * @returns `dst`.
 */
function translate(src, translation, dst = create()) {
    for (let i = 0; i < MATRIX_SIZE; i += 4) {
        const m4i = dst[i + 3] = src[i + 3];
        dst[i] = src[i] + m4i * translation.x;
        dst[i + 1] = src[i + 1] + m4i * translation.y;
        dst[i + 2] = src[i + 2] + m4i * translation.z;
    }
    return dst;
}
/**
 * Applies a scale matrix by given factors (packed into a vector) to a given
 * matrix.
 *
 * @param src The matrix to be multiplied by the scale matrix.
 * @param factor The vector the scale factors packed into.
 * @param dst The matrix the product will be stored to. Can be the same as `src`.
 * @returns `dst`.
 */
function scale(src, factor, dst = create()) {
    for (let i = 0; i < MATRIX_SIZE; i += 4) {
        dst[i] = src[i] * factor.x;
        dst[i + 1] = src[i + 1] * factor.y;
        dst[i + 2] = src[i + 2] * factor.z;
        dst[i + 3] = src[i + 3];
    }
    return dst;
}
// The matrix:
// xAxis.x yAxis.x zAxis.x -eye.x
// xAxis.y yAxis.y zAxis.y -eye.y
// xAxis.z yAxis.z zAxis.z -eye.z
//       0       0       0 1
// where xAxis, yAxis and zAxis  axes of the eye coordinate system, eye 
// origin of the eye coordinate system.
const lookAtMatrix = copy(IDENTITY);
/**
 * Applies a matrix of transformation into a coordinate system of a camera
 * defined by its position, a point it's looking at and an up direction vector.
 *
 * @param src The matrix to be multiplied by the scale matrix.
 * @param eye The position of the camera.
 * @param center The point the camera's looking at.
 * @param up The up vector.
 * @param dst The matrix the product will be stored to. Can be the same as `src`.
 * @returns `dst`.
 */
function lookAt(src, eye, center, up, dst = create()) {
    const zAxis = _vector3__WEBPACK_IMPORTED_MODULE_0__["sub"](eye, center);
    _vector3__WEBPACK_IMPORTED_MODULE_0__["normalize"](zAxis, zAxis);
    const xAxis = _vector3__WEBPACK_IMPORTED_MODULE_0__["cross"](up, zAxis);
    _vector3__WEBPACK_IMPORTED_MODULE_0__["normalize"](xAxis, xAxis);
    const yAxis = _vector3__WEBPACK_IMPORTED_MODULE_0__["cross"](zAxis, xAxis);
    lookAtMatrix[0] = xAxis.x;
    lookAtMatrix[1] = yAxis.x;
    lookAtMatrix[2] = zAxis.x;
    lookAtMatrix[4] = xAxis.y;
    lookAtMatrix[5] = yAxis.y;
    lookAtMatrix[6] = zAxis.y;
    lookAtMatrix[8] = xAxis.z;
    lookAtMatrix[9] = yAxis.z;
    lookAtMatrix[10] = zAxis.z;
    lookAtMatrix[12] = -_vector3__WEBPACK_IMPORTED_MODULE_0__["dot"](xAxis, eye);
    lookAtMatrix[13] = -_vector3__WEBPACK_IMPORTED_MODULE_0__["dot"](yAxis, eye);
    lookAtMatrix[14] = -_vector3__WEBPACK_IMPORTED_MODULE_0__["dot"](zAxis, eye);
    return mul(src, lookAtMatrix, dst);
}
/**
 * Applies a perspective matrix to a given one.
 *
 * @param src The matrix to be multiplied by the perspective matrix.
 * @param fov Vertical field of view angle.
 * @param aspectRatio Screen aspect ratio.
 * @param zNear Z-coordinate of near clipping plane.
 * @param zFar Z-coordinate of far clipping plane.
 * @param dst The matrix the product will be stored to. Can be the same as `src`.
 * @returns `dst`.
 */
function perspective(src, fov, aspect, zNear, zFar, dst = create()) {
    const p11 = 1 / Math.tan(0.5 * fov);
    const p00 = p11 / aspect;
    const p22 = (zNear + zFar) / (zNear - zFar);
    const p32 = 2 * zNear * zFar / (zNear - zFar);
    for (let i = 0; i < MATRIX_SIZE; i += 4) {
        dst[i] = src[i] * p00;
        dst[i + 1] = src[i + 1] * p11;
        const m2i = src[i + 2];
        const m3i = src[i + 3];
        dst[i + 2] = m2i * p22 + m3i * p32;
        dst[i + 3] = -m2i;
    }
    return dst;
}
/**
 * Multiplies a matrix by another one, i.e. `dst = m * src`.
 *
 * @param src The right matrix.
 * @param m The left matrix.
 * @param dst The matrix the product will be stored to. Can be the same as `src`.
 * @returns `dst`.
 */
function mul(src, m, dst = create()) {
    for (let i = 0; i < MATRIX_SIZE; i += 4) {
        const m0i = src[i];
        const m1i = src[i + 1];
        const m2i = src[i + 2];
        const m3i = src[i + 3];
        for (let j = 0; j < 4; ++j) {
            dst[i + j] = m0i * m[j] + m1i * m[4 + j] + m2i * m[8 + j] +
                m3i * m[12 + j];
        }
    }
    return dst;
}
/**
 * Applies a matrix to a vector.
 *
 * @param m The matrix.
 * @param v The vector.
 * @returns Normalized product of multiplying the vector by the matrix.
 */
function apply(m, v, dst = _vector3__WEBPACK_IMPORTED_MODULE_0__["create"](0, 0, 0)) {
    const w = m[3] * v.x + m[7] * v.y + m[11] * v.z + m[15];
    const x = (m[0] * v.x + m[4] * v.y + m[8] * v.z + m[12]) / w;
    const y = (m[1] * v.x + m[5] * v.y + m[9] * v.z + m[13]) / w;
    const z = (m[2] * v.x + m[6] * v.y + m[10] * v.z + m[14]) / w;
    dst.x = x;
    dst.y = y;
    dst.z = z;
    return dst;
}


/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ORIGIN", function() { return ORIGIN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "POSITIVE_X", function() { return POSITIVE_X; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NEGATIVE_X", function() { return NEGATIVE_X; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "POSITIVE_Y", function() { return POSITIVE_Y; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NEGATIVE_Y", function() { return NEGATIVE_Y; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "POSITIVE_Z", function() { return POSITIVE_Z; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NEGATIVE_Z", function() { return NEGATIVE_Z; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "areEqual", function() { return areEqual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "areFuzzyEqual", function() { return areFuzzyEqual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "areCollinear", function() { return areCollinear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mulv", function() { return mulv; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "muln", function() { return muln; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divv", function() { return divv; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divn", function() { return divn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cross", function() { return cross; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateX", function() { return rotateX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateY", function() { return rotateY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateZ", function() { return rotateZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "X_AXIS", function() { return X_AXIS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Y_AXIS", function() { return Y_AXIS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Z_AXIS", function() { return Z_AXIS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "XY", function() { return XY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "YZ", function() { return YZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZX", function() { return ZX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPlaneLineIntersection", function() { return getPlaneLineIntersection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPlaneRayIntersection", function() { return getPlaneRayIntersection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPlanePlaneIntersection", function() { return getPlanePlaneIntersection; });
/* harmony import */ var _matrix3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21);
/* harmony import */ var _util_fuzzy_equal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(22);


/**
 * Creates a new vector and initializes it with given components.
 *
 * @param x X component of the vector.
 * @param y Y component of the vector.
 * @param z Z component of the vector.
 * @returns The vector.
 */
function create(x, y, z) {
    return { x, y, z };
}
const ORIGIN = create(0, 0, 0);
const POSITIVE_X = create(1, 0, 0);
const NEGATIVE_X = create(-1, 0, 0);
const POSITIVE_Y = create(0, 1, 0);
const NEGATIVE_Y = create(0, -1, 0);
const POSITIVE_Z = create(0, 0, 1);
const NEGATIVE_Z = create(0, 0, -1);
/**
 * Copies a vector to another one.
 *
 * @param src The source vector.
 * @param dst The vector the source vector will be copied to.
 * @returns `dst`.
 */
function copy(src, dst = create(0, 0, 0)) {
    dst.x = src.x;
    dst.y = src.y;
    dst.z = src.z;
    return dst;
}
/**
 * Checks if two vectors are strictly equal component-wise.
 *
 * @param v1 The first vector.
 * @param v2 The second vector.
 * @returns `true` if the vectors are equal and `false` otherwise.
 */
function areEqual(v1, v2) {
    return v1.x === v2.x && v1.y === v2.y && v1.z === v2.z;
}
/**
 * Checks if corresponding components of two vectors are all within given
 * tolerance from each other.
 *
 * @param v1 The first vector.
 * @param v2 The second vector.
 * @param tolerance The tolerance.
 * @returns `true` if the vectors are "fuzzy" equal and `false` otherwise.
 */
function areFuzzyEqual(v1, v2, tolerance = _util_fuzzy_equal__WEBPACK_IMPORTED_MODULE_1__["DEFAULT_TOLERANCE"]) {
    return (Object(_util_fuzzy_equal__WEBPACK_IMPORTED_MODULE_1__["default"])(v1.x, v2.x, tolerance) &&
        Object(_util_fuzzy_equal__WEBPACK_IMPORTED_MODULE_1__["default"])(v1.y, v2.y, tolerance) &&
        Object(_util_fuzzy_equal__WEBPACK_IMPORTED_MODULE_1__["default"])(v1.z, v2.z, tolerance));
}
/**
 * Checks if two vectors are collinear.
 *
 * @param v1 The first vector.
 * @param v2 The second vector.
 * @returns `true` if the vectors are collinear and `false` otherwise.
 */
function areCollinear(v1, v2) {
    const lambdaX = v1.x / v2.x;
    const lambdaY = v1.y / v2.y;
    const lambdaZ = v1.z / v2.z;
    return lambdaX === lambdaY && lambdaY === lambdaZ;
}
/**
 * Adds two vector and stores the result into a third one, i.e. `dst = a + b`.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function add(a, b, dst = create(0, 0, 0)) {
    dst.x = a.x + b.x;
    dst.y = a.y + b.y;
    dst.z = a.z + b.z;
    return dst;
}
/**
 * Subtracts a vector from another one and stores the result to a third one, i.e.
 * `dst = a - b`.
 *
 * @param a The minuend vector.
 * @param b The subtrahend vector.
 * @param dst The vector the result will be stored to.
 */
function sub(a, b, dst = create(0, 0, 0)) {
    dst.x = a.x - b.x;
    dst.y = a.y - b.y;
    dst.z = a.z - b.z;
    return dst;
}
/**
 * Multiplies two vectors component-wise and stores the result into a third one.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function mulv(a, b, dst = create(0, 0, 0)) {
    dst.x = a.x * b.x;
    dst.y = a.y * b.y;
    dst.z = a.z * b.z;
    return dst;
}
/**
 * Multiplies a vector by a scalar and stores the result into a third vector.
 *
 * @param a The vector.
 * @param n The scalar.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function muln(a, n, dst = create(0, 0, 0)) {
    dst.x = a.x * n;
    dst.y = a.y * n;
    dst.z = a.z * n;
    return dst;
}
/**
 * Divides a vector by another one component wise and stores the result into a
 * third one.
 *
 * @param a The dividend vector.
 * @param b The divisor vector.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function divv(a, b, dst = create(0, 0, 0)) {
    dst.x = a.x / b.x;
    dst.y = a.y / b.y;
    dst.z = a.z / b.z;
    return dst;
}
/**
 * Divides a vector by a scalar and stores the result into a third vector.
 *
 * @param a The dividend vector.
 * @param n The scalar.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function divn(a, n, dst = create(0, 0, 0)) {
    dst.x = a.x / n;
    dst.y = a.y / n;
    dst.z = a.z / n;
    return dst;
}
/**
 * Computes length of a vector.
 *
 * @param v The vector.
 * @returns The length.
 */
function length(v) {
    return Math.hypot(v.x, v.y, v.z);
}
/**
 * Computes distance between ends of two vectors.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @returns The distance, i.e. `length(sub(a, b))`.
 */
function distance(a, b) {
    return Math.hypot(a.x - b.x, a.y - b.y, a.z - b.z);
}
/**
 * Divides a vector by its length (thus making it a unit vector) and stores the
 * result to another one.
 *
 * @param v The vector to be normalized.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function normalize(v, dst = create(0, 0, 0)) {
    return divn(v, length(v), dst);
}
/**
 * Computes dot product of two vectors.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @returns The dot product.
 */
function dot(a, b) {
    return a.x * b.x + a.y * b.y + a.z * b.z;
}
/**
 * Computes cross product of two vectors and stores it to a third one.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function cross(a, b, dst = create(0, 0, 0)) {
    // Write components to a separate variables so we don't produce incorrect
    // results in cases when a == dst or b == dst.
    const x = a.y * b.z - a.z * b.y;
    const y = a.z * b.x - a.x * b.z;
    const z = a.x * b.y - a.y * b.x;
    dst.x = x;
    dst.y = y;
    dst.z = z;
    return dst;
}
/**
 * Rotates vector about the X axis.
 *
 * @param v The vector to be rotated.
 * @param angle The angle of rotation (in radians), positive values rotates from +Y to +Z
 * @param dst The vector the result will be stored to.
 */
function rotateX(v, angle, dst = create(0, 0, 0)) {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    const y = v.y;
    dst.x = v.x;
    dst.y = y * cos - v.z * sin;
    dst.z = y * sin + v.z * cos;
    return dst;
}
/**
 * Rotates vector about the Y axis.
 *
 * @param v The vector to be rotated.
 * @param angle The angle of rotation (in radians), positive values rotates from +X to +Z
 * @param dst The vector the result will be stored to.
 */
function rotateY(v, angle, dst = create(0, 0, 0)) {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    // handle the case when source and destination are the same object: related components can break each other
    v = (v === dst) ? copy(v) : v;
    dst.x = v.x * cos + v.z * sin;
    dst.y = v.y;
    dst.z = -v.x * sin + v.z * cos;
    return dst;
}
/**
 * Rotates vector about the Z axis.
 *
 * @param v The vector to be rotated.
 * @param angle The angle of rotation (in radians), positive values rotates from +X to +Y
 * @param dst The vector the result will be stored to.
 */
function rotateZ(v, angle, dst = create(0, 0, 0)) {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    // handle the case when source and destination are the same object: related components can break each other
    v = (v === dst) ? copy(v) : v;
    dst.x = v.x * cos - v.y * sin;
    dst.y = v.x * sin + v.y * cos;
    dst.z = v.z;
    return dst;
}
const X_AXIS = {
    origin: ORIGIN,
    tangent: POSITIVE_X
};
const Y_AXIS = {
    origin: ORIGIN,
    tangent: POSITIVE_Y
};
const Z_AXIS = {
    origin: ORIGIN,
    tangent: POSITIVE_Z
};
const XY = {
    normal: POSITIVE_Z,
    distance: 0
};
const YZ = {
    normal: POSITIVE_X,
    distance: 0
};
const ZX = {
    normal: POSITIVE_Y,
    distance: 0
};
/**
 * Computes intersection of a plane and a line.
 *
 * @param p The plane.
 * @param l The line.
 * @returns The point or `null` if the line is parallel to the plane.
 */
function getPlaneLineIntersection(p, l) {
    const dotLP = dot(l.tangent, p.normal);
    // If plane normal and line tangent vector are perpendicular intersection is
    // either an empty set or the line itself.
    if (dotLP === 0) {
        return null;
    }
    const intersection = copy(l.tangent);
    muln(intersection, (p.distance - dot(p.normal, l.origin)) / dotLP, intersection);
    add(intersection, l.origin, intersection);
    return intersection;
}
/**
 * Computes an intersection of a plane and a ray and stores it into a given
 * vector.
 *
 * @param plane The plane.
 * @param ray The ray.
 * @param dst The vector the intersection point will be stored to. If there's no
 *      intersection, this vector will be left unmodified.
 * @returns The `dst` or `null` if the ray doesn't have a common point with the
 *      plane.
 */
function getPlaneRayIntersection(plane, ray, dst = create(0, 0, 0)) {
    const dotRP = dot(ray.direction, plane.normal);
    if (dotRP === 0) {
        // The plane normal and the ray direction vector are perpendicular, so
        // intersection is either an empty set or the ray itself.
        return null;
    }
    const lambda = (plane.distance - dot(plane.normal, ray.origin)) / dotRP;
    if (lambda < 0) {
        // The intersection point is on a line that contains the ray, but not on
        // the ray itself.
        return null;
    }
    copy(ray.direction, dst);
    muln(dst, lambda, dst);
    add(dst, ray.origin, dst);
    return dst;
}
/**
 * Computes intersection of two planes.
 *
 * @param p1 The first plane.
 * @param p2 The second plane.
 * @returns The line or `null` if the planes are parallel to each other.
 */
function getPlanePlaneIntersection(p1, p2) {
    const n1 = p1.normal;
    const n2 = p2.normal;
    if (areCollinear(n1, n2)) {
        return null;
    }
    const tangent = cross(n1, n2);
    normalize(tangent);
    return {
        tangent,
        origin: _matrix3__WEBPACK_IMPORTED_MODULE_0__["solve"](_matrix3__WEBPACK_IMPORTED_MODULE_0__["fromRows"](n1, n2, tangent), create(p1.distance, p2.distance, 0))
    };
}


/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zero", function() { return zero; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRows", function() { return fromRows; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "columns", function() { return columns; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromColumns", function() { return fromColumns; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "determinant", function() { return determinant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "solve", function() { return solve; });
/* harmony import */ var _vector3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(20);

const MATRIX_SIZE = 9;
/**
 * Creates and returns a new **uninitialized** matrix.
 */
function create() {
    return new Array(MATRIX_SIZE);
}
/**
 * Zeroes a matrix.
 *
 * @param dst The matrix.
 * @returns `dst`.
 */
function zero(dst = create()) {
    for (let i = 0; i < MATRIX_SIZE; ++i) {
        dst[i] = 0;
    }
    return dst;
}
/**
 * Copies three vectors to a matrix as rows.
 *
 * @param r0 The first row.
 * @param r1 The second row.
 * @param r2 The third row.
 * @param dst The matrix the rows will be written to.
 * @returns `dst`.
 */
function fromRows(r0, r1, r2, dst = create()) {
    dst[0] = r0.x;
    dst[1] = r1.x;
    dst[2] = r2.x;
    dst[3] = r0.y;
    dst[4] = r1.y;
    dst[5] = r2.y;
    dst[6] = r0.z;
    dst[7] = r1.z;
    dst[8] = r2.z;
    return dst;
}
/**
 * Returns array of columns of a matrix.
 *
 * @param m The matrix.
 * @param dst The array columns of the matrix will be written to.
 * @returns `dst`.
 */
function columns(m, dst = [
    _vector3__WEBPACK_IMPORTED_MODULE_0__["create"](0, 0, 0),
    _vector3__WEBPACK_IMPORTED_MODULE_0__["create"](0, 0, 0),
    _vector3__WEBPACK_IMPORTED_MODULE_0__["create"](0, 0, 0)
]) {
    for (let i = 0, j = 0; i < 3; ++i, j += 3) {
        dst[i].x = m[j];
        dst[i].y = m[j + 1];
        dst[i].z = m[j + 2];
    }
    return dst;
}
/**
 * Copies three vectors to a matrix as columns.
 *
 * @param c0 The first column.
 * @param c1 The second column.
 * @param c2 The third column.
 * @param dst The matrix the columns will be written to.
 * @returns `dst`.
 */
function fromColumns(c0, c1, c2, dst = create()) {
    dst[0] = c0.x;
    dst[1] = c0.y;
    dst[2] = c0.z;
    dst[3] = c1.x;
    dst[4] = c1.y;
    dst[5] = c1.z;
    dst[6] = c2.x;
    dst[7] = c2.y;
    dst[8] = c2.z;
    return dst;
}
/**
 * Computes determinant of a matrix.
 *
 * @param m The matrix.
 * @returns The determinant.
 */
function determinant(m) {
    return m[0] * (m[4] * m[8] - m[7] * m[5]) +
        m[3] * (m[1] * m[8] - m[7] * m[2]) +
        m[6] * (m[1] * m[5] - m[4] * m[2]);
}
const staticMatrixColumns = [
    // Not using vector3.create here due to circular dependency.
    { x: 0, y: 0, z: 0 },
    { x: 0, y: 0, z: 0 },
    { x: 0, y: 0, z: 0 }
];
const staticMatrix = create();
/**
 * Solves a system of linear equations represented with a matrix and a vector,
 * i.e.:
 *
 * ```
 * m * (x, y ,z)^T = v
 * ```
 *
 * Uses Cramer's rule.
 * @see https://en.wikipedia.org/wiki/Cramer's_rule
 *
 * @param m The matrix of the system.
 * @param v The vector of the system.
 * @param dst The vector solution of the system will be written to.
 * @return `dst`.
 */
function solve(m, v, dst = _vector3__WEBPACK_IMPORTED_MODULE_0__["create"](0, 0, 0)) {
    const revDet = 1 / determinant(m);
    const [c0, c1, c2] = columns(m, staticMatrixColumns);
    dst.x = revDet * determinant(fromColumns(v, c1, c2, staticMatrix));
    dst.y = revDet * determinant(fromColumns(c0, v, c2, staticMatrix));
    dst.z = revDet * determinant(fromColumns(c0, c1, v, staticMatrix));
    return dst;
}


/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_TOLERANCE", function() { return DEFAULT_TOLERANCE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return areFuzzyEqual; });
const DEFAULT_TOLERANCE = 1e-6;
/**
 * Checks if two floating point number are within a tolerance from each other.
 *
 * @param a The first number.
 * @param b The second number.
 * @param tolerance The tolerance.
 * @returns `true` if the number are within the tolerance and `false` otherwise.
 */
function areFuzzyEqual(a, b, tolerance = DEFAULT_TOLERANCE) {
    const d = a - b;
    return -tolerance < d && d < tolerance;
}


/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZERO", function() { return ZERO; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ORIGIN", function() { return ORIGIN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "POSITIVE_X", function() { return POSITIVE_X; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NEGATIVE_X", function() { return NEGATIVE_X; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "POSITIVE_Y", function() { return POSITIVE_Y; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NEGATIVE_Y", function() { return NEGATIVE_Y; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "areEqual", function() { return areEqual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "areCollinear", function() { return areCollinear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "areFuzzyEqual", function() { return areFuzzyEqual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mulv", function() { return mulv; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "muln", function() { return muln; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divv", function() { return divv; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divn", function() { return divn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mod", function() { return mod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mix", function() { return mix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate45", function() { return rotate45; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate90", function() { return rotate90; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateNeg90", function() { return rotateNeg90; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "convert", function() { return convert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "crossZ", function() { return crossZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EMPTY", function() { return EMPTY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UNIT_BBOX", function() { return UNIT_BBOX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createBBox2", function() { return createBBox2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyBBox2", function() { return copyBBox2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bboxesOverlap", function() { return bboxesOverlap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pointIsInBBox", function() { return pointIsInBBox; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "computeBBoxForPoints", function() { return computeBBoxForPoints; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "X_AXIS", function() { return X_AXIS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Y_AXIS", function() { return Y_AXIS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLineFromPoints", function() { return getLineFromPoints; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSignedDistanceToLine", function() { return getSignedDistanceToLine; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createExtent2", function() { return createExtent2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyExtent2", function() { return copyExtent2; });
/* harmony import */ var _util_fuzzy_equal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(22);

/**
 * Creates a new vector and initializes it with given components.
 *
 * @param x X component of the vector.
 * @param y Y component of the vector.
 * @returns The vector.
 */
function create(x, y) {
    return { x, y };
}
const ZERO = create(0, 0);
const ORIGIN = ZERO;
const POSITIVE_X = create(1, 0);
const NEGATIVE_X = create(-1, 0);
const POSITIVE_Y = create(0, 1);
const NEGATIVE_Y = create(0, -1);
/**
 * Copies a vector to another one.
 *
 * @param src The source vector.
 * @param dst The vector the source vector will be copied to.
 * @returns `dst`.
 */
function copy(src, dst = create(0, 0)) {
    dst.x = src.x;
    dst.y = src.y;
    return dst;
}
/**
 * Checks if two vectors are strictly equal component-wise.
 *
 * @param v1 The first vector.
 * @param v2 The second vector.
 * @returns `true` if the vectors are equal and `false` otherwise.
 */
function areEqual(v1, v2) {
    return v1.x === v2.x && v1.y === v2.y;
}
/**
 * Checks if two vectors are collinear.
 *
 * @param v1 The first vector.
 * @param v2 The second vector.
 * @returns `true` if the vectors are collinear and `false` otherwise.
 */
function areCollinear(v1, v2) {
    return v1.x / v2.x === v1.y / v2.y;
}
/**
 * Checks if corresponding components of two vectors are all within given
 * tolerance from each other.
 *
 * @param v1 The first vector.
 * @param v2 The second vector.
 * @param tolerance The tolerance.
 * @returns `true` if the vectors are "fuzzy" equal and `false` otherwise.
 */
function areFuzzyEqual(v1, v2, tolerance = _util_fuzzy_equal__WEBPACK_IMPORTED_MODULE_0__["DEFAULT_TOLERANCE"]) {
    return (Object(_util_fuzzy_equal__WEBPACK_IMPORTED_MODULE_0__["default"])(v1.x, v2.x, tolerance) &&
        Object(_util_fuzzy_equal__WEBPACK_IMPORTED_MODULE_0__["default"])(v1.y, v2.y, tolerance));
}
/**
 * Adds two vector and stores the result into a third one, i.e. `dst = a + b`.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function add(a, b, dst = create(0, 0)) {
    dst.x = a.x + b.x;
    dst.y = a.y + b.y;
    return dst;
}
/**
 * Subtracts a vector from another one and stores the result to a third one, i.e.
 * `dst = a - b`.
 *
 * @param a The minuend vector.
 * @param b The subtrahend vector.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function sub(a, b, dst = create(0, 0)) {
    dst.x = a.x - b.x;
    dst.y = a.y - b.y;
    return dst;
}
/**
 * Multiplies two vectors component-wise and stores the result into a third one.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function mulv(a, b, dst = create(0, 0)) {
    dst.x = a.x * b.x;
    dst.y = a.y * b.y;
    return dst;
}
/**
 * Multiplies a vector by a scalar and stores the result into a third vector.
 *
 * @param a The vector.
 * @param n The scalar.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function muln(a, n, dst = create(0, 0)) {
    dst.x = a.x * n;
    dst.y = a.y * n;
    return dst;
}
/**
 * Divides a vector by another one component wise and stores the result into a
 * third one.
 *
 * @param a The dividend vector.
 * @param b The divisor vector.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function divv(a, b, dst = create(0, 0)) {
    dst.x = a.x / b.x;
    dst.y = a.y / b.y;
    return dst;
}
/**
 * Divides a vector by a scalar and stores the result into a third vector.
 *
 * @param a The dividend vector.
 * @param n The scalar.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function divn(a, n, dst = create(0, 0)) {
    dst.x = a.x / n;
    dst.y = a.y / n;
    return dst;
}
/**
 * Calculates the reminder after division of a's components by n and stores the result into a third vector.
 *
 * @param a The dividend vector.
 * @param n The scalar.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function mod(a, n, dst = create(0, 0)) {
    dst.x = a.x % n;
    dst.y = a.y % n;
    return dst;
}
/**
 * Linearly interpolates between two vectors, i.e. computes
 * `(1 - factor) * a + factor * b`, and writes the result into a third vector.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @param factor The interpolation factor.
 * @param dst The vector the result will be written to.
 * @returns `dst`.
 */
function mix(a, b, factor, dst = create(0, 0)) {
    dst.x = (1 - factor) * a.x + factor * b.x;
    dst.y = (1 - factor) * a.y + factor * b.y;
    return dst;
}
/**
 * Rotates a vector by a given angle and stores the result into a second vector.
 * Positive direction is from +X to +Y.
 *
 * @param v The vector to rotate.
 * @param angle The angle of rotation.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function rotate(v, angle, dst = create(0, 0)) {
    const x = v.x;
    const y = v.y;
    const angleCos = Math.cos(angle);
    const angleSin = Math.sin(angle);
    dst.x = angleCos * x - angleSin * y;
    dst.y = angleSin * x + angleCos * y;
    return dst;
}
/**
 * Rotates a vector by 45 degrees and stores the result into a second vector.
 * Analogous to `rotate(v, Math.PI / 4, dst)`, but faster.
 *
 * @param v The vector to rotate.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function rotate45(v, dst = create(0, 0)) {
    const y = v.y;
    const s = Math.SQRT1_2;
    dst.y = s * v.x + s * v.y;
    dst.x = s * v.x - s * y;
    return dst;
}
/**
 * Rotates a vector by 90 degrees and stores the result into a second vector.
 * Analogous to `rotate(v, Math.PI / 2, dst)`, but faster.
 *
 * @param v The vector to rotate.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function rotate90(v, dst = create(0, 0)) {
    const y = v.y;
    dst.y = v.x;
    dst.x = -y;
    return dst;
}
/**
 * Rotates a vector by -90 degrees and stores the result into a second vector.
 * Analogous to `rotate(v, -Math.PI / 2, dst)`, but faster.
 *
 * @param v The vector to rotate.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function rotateNeg90(v, dst = create(0, 0)) {
    const y = v.y;
    dst.y = -v.x;
    dst.x = y;
    return dst;
}
/**
 * Inverts signs of components of a vector and stores the result into a second
 * vector. Analogous to `rotate(v, Math.PI, dst)` (or `rotate(v, -Math.PI, dst)`,
 * which is the same), but faster.
 *
 * @param v The vector to invert.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function invert(v, dst = create(0, 0)) {
    dst.x = -v.x;
    dst.y = -v.y;
    return dst;
}
/**
 * Computes length of a vector.
 *
 * @param v The vector.
 * @returns The length.
 */
function length(v) {
    return Math.hypot(v.x, v.y);
}
/**
 * Computes distance between ends of two vectors.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @returns The distance, i.e. `length(sub(a, b))`.
 */
function distance(a, b) {
    return Math.hypot(a.x - b.x, a.y - b.y);
}
/**
 * Divides a vector by its length (thus making it a unit vector) and stores the
 * result to another one.
 *
 * @param v The vector to be normalized.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function normalize(v, dst = create(0, 0)) {
    return divn(v, length(v), dst);
}
/**
 * Converts each component of vector.
 *
 * @param v The vector to be converted.
 * @param converter The component converter.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function convert(v, converter, dst = create(0, 0)) {
    dst.x = converter(v.x);
    dst.y = converter(v.y);
    return dst;
}
/**
 * Computes dot product of two vectors.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @returns The dot product.
 */
function dot(a, b) {
    return a.x * b.x + a.y * b.y;
}
/**
 * Computes Z-component of a cross product of two vectors.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @returns Z-component of the cross product.
 */
function crossZ(a, b) {
    return a.x * b.y - a.y * b.x;
}
const EMPTY = {
    minX: 0,
    maxX: 0,
    minY: 0,
    maxY: 0
};
const UNIT_BBOX = {
    minX: -1,
    maxX: 1,
    minY: -1,
    maxY: 1
};
/**
 * Creates a new bbox and initializes it with given components.
 *
 * @param minX Left border of the bbox.
 * @param maxX Right border of the bbox.
 * @param minY Lower border of the bbox.
 * @param maxY Upper border of the bbox.
 * @returns The bbox.
 */
function createBBox2(minX, maxX, minY, maxY) {
    return { minX, maxX, minY, maxY };
}
/**
 * Copies a bbox to another one.
 *
 * @param src The source bbox.
 * @param dst The bbox the source bbox will be copied to.
 * @returns `dst`.
 */
function copyBBox2(src, dst = createBBox2(0, 0, 0, 0)) {
    dst.minX = src.minX;
    dst.maxX = src.maxX;
    dst.minY = src.minY;
    dst.maxY = src.maxY;
    return dst;
}
/**
 * Checks if two bounding boxes overlap.
 *
 * @param bbox1 A bounding box.
 * @param bbox2 Another bounding box.
 * @returns `true` if given bounding boxes do overlap and `false` otherwise.
 */
function bboxesOverlap(bbox1, bbox2) {
    let leftBBox;
    let rightBBox;
    if (bbox1.minX < bbox2.minX) {
        leftBBox = bbox1;
        rightBBox = bbox2;
    }
    else {
        leftBBox = bbox2;
        rightBBox = bbox1;
    }
    let topBBox;
    let bottomBBox;
    if (bbox1.maxY > bbox2.maxY) {
        topBBox = bbox1;
        bottomBBox = bbox2;
    }
    else {
        topBBox = bbox2;
        bottomBBox = bbox1;
    }
    return rightBBox.minX < leftBBox.maxX && bottomBBox.maxY > topBBox.minY;
}
/**
 * Checks if a 2D point lies inside a bounding box or on its border.
 *
 * @param point The point.
 * @param bbox The bounding box.
 * @returns `true` if the point is inside of the box and `false` otherwise.
 */
function pointIsInBBox(point, bbox) {
    return bbox.minX <= point.x && point.x <= bbox.maxX &&
        bbox.minY <= point.y && point.y <= bbox.maxY;
}
/**
 * Computes bounding box of an array of points and stores it to a given object.
 *
 * @param points The array of points.
 * @param dst The bbox the result will be written to. Left unmodified if the array
 *      of points is empty.
 * @returns `dst`.
 */
function computeBBoxForPoints(points, dst = { minX: 0, maxX: 0, minY: 0, maxY: 0 }) {
    if (points.length === 0) {
        return dst;
    }
    dst.minX = dst.maxX = points[0].x;
    dst.minY = dst.maxY = points[0].y;
    for (let i = 1; i < points.length; ++i) {
        const { x, y } = points[i];
        if (x < dst.minX) {
            dst.minX = x;
        }
        if (x > dst.maxX) {
            dst.maxX = x;
        }
        if (y < dst.minY) {
            dst.minY = y;
        }
        if (y > dst.maxY) {
            dst.maxY = y;
        }
    }
    return dst;
}
const X_AXIS = {
    origin: ORIGIN,
    tangent: POSITIVE_X
};
const Y_AXIS = {
    origin: ORIGIN,
    tangent: POSITIVE_Y
};
function getLineFromPoints(p1, p2, dst = {
    origin: create(0, 0),
    tangent: create(0, 0)
}) {
    copy(p1, dst.origin);
    sub(p2, p1, dst.tangent);
    return dst;
}
/**
 * Computes signed distance from a point to a line.
 *
 * @param p The point.
 * @param l1 Start point of the line.
 * @param l2 End point of the line.
 * @returns Distance from the point to the line. It'll be greater than 0 if the
 *      point lies to the left of the line and less than 0 otherwise.
 */
function getSignedDistanceToLine(p, l) {
    const tangent = l.tangent;
    return dot(sub(p, l.origin), create(-tangent.y, tangent.x)) / length(tangent);
}
/**
 * Creates a new extent and initializes it with given components.
 *
 * @param width Width of the extent.
 * @param Height Height of the extent.
 * @returns The extent.
 */
function createExtent2(width, height) {
    return { width, height };
}
/**
 * Copies an extent to another one.
 *
 * @param src The source bbox.
 * @param dst The extent the source extent will be copied to.
 * @returns `dst`.
 */
function copyExtent2(src, dst = createExtent2(0, 0)) {
    dst.width = src.width;
    dst.height = src.height;
    return dst;
}


/***/ }),
/* 24 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return VectorApiAdapter; });
/* harmony import */ var _tile_based_adapter_adapter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(25);
/* harmony import */ var _primitive_icon_icon_buffer_writer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(35);
/* harmony import */ var _render_memory_sub_chunk__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(40);
/* harmony import */ var _billboard_identified_image_atlas_manager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(42);
/* harmony import */ var _font_df_font__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(44);
/* harmony import */ var _api_image_provider__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(46);
/* harmony import */ var _primitive_model_model_buffer_writer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(50);
/* harmony import */ var _primitive_polyline_textured_polyline_buffer_writer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(51);
/* harmony import */ var _billboard_image_manager__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(54);
/* harmony import */ var _primitive_polygon_textured_polygon_buffer_rewiter__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(55);
/* harmony import */ var _primitive_polygon_polygon_attribute_mapping__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(58);
/* harmony import */ var _primitive_polygon_textured_polygon_attribute_mapping__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(57);
/* harmony import */ var _primitive_billboard_rectangle_attribute_mapping__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(59);
/* harmony import */ var _primitive_label_point_label_attribute_mapping__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(60);
/* harmony import */ var _primitive_label_curved_label_attribute_mapping__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(61);
/* harmony import */ var _primitive_polyline_polyline_attribute_mapping__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(62);
/* harmony import */ var _worker_tile_provider_worker_client__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(63);
/* harmony import */ var _worker_tile_provider_worker_messages__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(64);
/* harmony import */ var _primitive_polygon_transparent_polygon_attribute_mapping__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(66);
/* harmony import */ var _tile_based_adapter_tile_id__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(29);
/* harmony import */ var _util_idle_task_queue__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(67);
/* harmony import */ var _util_stat__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(34);
/* harmony import */ var _util_unique_id__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(31);
/* harmony import */ var _primitive_polygon_renderable_polygon__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(70);
/* harmony import */ var _primitive_polygon_renderable_textured_polygon__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(72);
/* harmony import */ var _primitive_polyline_renderable_polyline__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(73);
/* harmony import */ var _primitive_polyline_renderable_textured_polyline__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(74);
/* harmony import */ var _primitive_model_renderable_model__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(75);
/* harmony import */ var _tile_data__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(76);
/* harmony import */ var _primitive_manager_renderable_primitive_manager__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(77);
/* harmony import */ var _render_primitives_primitive_set_storage__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(79);
/* harmony import */ var _primitive_manager_polygon_manager__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(80);
/* harmony import */ var _render_primitives_disappearing_primitive_set_storage__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(81);
/* harmony import */ var _render_primitives_delayed_disappearing_primitive_set_storage__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(82);
/* harmony import */ var _primitive_manager_zoom_filterable_primitive_manager__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(83);
/* harmony import */ var _primitive_manager_external_mesh_manager__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(84);
/* harmony import */ var _primitive_billboard_rectangle_renderable_billboard_rectangle__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(85);
/* harmony import */ var _primitive_zoom_restricted_label__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(86);
/* harmony import */ var _primitive_zoom_restricted_icon__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(88);
/* harmony import */ var _util_task_queue__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(92);








































const WORLD_SIZE = 2.0;
const NORMAL_TILE_SIDE_SIZE_PX = 256; // tiles of normal size are optimized for displaying in a 256x256 css px square
function getTileSideSizePx(tileSize) {
    switch (tileSize) {
        case 1 /* X4 */:
            return NORMAL_TILE_SIDE_SIZE_PX * 2;
        case 2 /* X16 */:
            return NORMAL_TILE_SIDE_SIZE_PX * 4;
        default:
            return NORMAL_TILE_SIDE_SIZE_PX;
    }
}
const MAX_PERF_LOG_ITEMS_COUNT = 1024;
const QUEUE_TASK_PRIORITIES = {
    firstTilePortion: 20,
    secondTilePortion: 10
};
const DEFAULT_IDLE_TASK_PRIORITY = 0;
// The values are chosen empirically: https://st.yandex-team.ru/VECTOR-300#5be5b638523211001b9bd941
const MINZOOM_DELTAS = {
    pointLabels: 1,
    curvedLabels: 1,
    icons: 0.75
};
class VectorApiAdapter extends _tile_based_adapter_adapter__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(engine, camera, tileProviderWorkerUrl, layerName, { imageUrlTemplate, tileUrlTemplate, meshUrlTemplate, glyphRangeUrlTemplate }, tileSize = 0 /* X1 */, preloadedTilesBeltSize = 0) {
        super(engine, camera, tileSize, preloadedTilesBeltSize, layerName);
        this._tileSideSizePx = getTileSideSizePx(tileSize);
        this._perfLogItems = [];
        this._destroyables = [];
        this._tileProvider = new _worker_tile_provider_worker_client__WEBPACK_IMPORTED_MODULE_16__["TileProviderWorkerClient"](tileProviderWorkerUrl);
        this._tileProvider.sendMessage({
            type: _worker_tile_provider_worker_messages__WEBPACK_IMPORTED_MODULE_17__["TileProviderMessageType"].INIT,
            tileUrlTemplate,
            meshUrlTemplate,
            glyphRangeUrlTemplate
        }, 1 /* IMMEDIATE */);
        this._memoryManager = engine.memoryManager;
        this._glyphAtlas = engine.glyphAtlas;
        this._fontRegistry = engine.fontRegistry;
        this._imageManagerNearest = new _billboard_image_manager__WEBPACK_IMPORTED_MODULE_8__["ImageManager"](new _billboard_identified_image_atlas_manager__WEBPACK_IMPORTED_MODULE_3__["default"](engine.createImageAtlas({
            filter: 9728 /* NEAREST */,
            premultipliedAlpha: false
        })), new _api_image_provider__WEBPACK_IMPORTED_MODULE_5__["ApiImageProvider"](imageUrlTemplate));
        this._imageManagerLinear = new _billboard_image_manager__WEBPACK_IMPORTED_MODULE_8__["ImageManager"](new _billboard_identified_image_atlas_manager__WEBPACK_IMPORTED_MODULE_3__["default"](engine.createImageAtlas({
            filter: 9729 /* LINEAR */,
            premultipliedAlpha: true
        })), new _api_image_provider__WEBPACK_IMPORTED_MODULE_5__["ApiImageProvider"](imageUrlTemplate));
        const fadeEffect = engine.visibilityManager.fadeEffectDuration;
        const opaquePolygonsProvider = this.opaquePolygonsProvider = new _render_primitives_primitive_set_storage__WEBPACK_IMPORTED_MODULE_30__["default"]();
        const transparentPolygonsProvider = this.transparentPolygonsProvider = new _render_primitives_primitive_set_storage__WEBPACK_IMPORTED_MODULE_30__["default"]();
        const texturedPolygonsProvider = this.texturedPolygonsProvider = new _render_primitives_primitive_set_storage__WEBPACK_IMPORTED_MODULE_30__["default"]();
        const polylinesProvider = this.polylinesProvider = new _render_primitives_primitive_set_storage__WEBPACK_IMPORTED_MODULE_30__["default"]();
        const texturedPolylinesProvider = this.texturedPolylinesProvider = new _render_primitives_primitive_set_storage__WEBPACK_IMPORTED_MODULE_30__["default"]();
        const iconsProvider = this.iconsProvider = new _render_primitives_disappearing_primitive_set_storage__WEBPACK_IMPORTED_MODULE_32__["default"]();
        const pointLabelsProvider = this.pointLabelsProvider = new _render_primitives_delayed_disappearing_primitive_set_storage__WEBPACK_IMPORTED_MODULE_33__["default"](fadeEffect);
        const curvedLabelsProvider = this.curvedLabelsProvider = new _render_primitives_delayed_disappearing_primitive_set_storage__WEBPACK_IMPORTED_MODULE_33__["default"](fadeEffect);
        const modelsProvider = this.modelsProvider = new _render_primitives_primitive_set_storage__WEBPACK_IMPORTED_MODULE_30__["default"]();
        this._destroyables.push(pointLabelsProvider, curvedLabelsProvider);
        this._tileDataManagers = [
            new TileDataManager(new _primitive_manager_polygon_manager__WEBPACK_IMPORTED_MODULE_31__["default"](opaquePolygonsProvider, transparentPolygonsProvider), _tile_data__WEBPACK_IMPORTED_MODULE_28__["POLYGON_EXTRACTOR"]),
            new TileDataManager(new _primitive_manager_renderable_primitive_manager__WEBPACK_IMPORTED_MODULE_29__["default"](texturedPolygonsProvider), _tile_data__WEBPACK_IMPORTED_MODULE_28__["TEXTURED_POLYGON_EXTRACTOR"]),
            new TileDataManager(new _primitive_manager_renderable_primitive_manager__WEBPACK_IMPORTED_MODULE_29__["default"](polylinesProvider), _tile_data__WEBPACK_IMPORTED_MODULE_28__["POLYLINE_EXTRACTOR"]),
            new TileDataManager(new _primitive_manager_renderable_primitive_manager__WEBPACK_IMPORTED_MODULE_29__["default"](texturedPolylinesProvider), _tile_data__WEBPACK_IMPORTED_MODULE_28__["TEXTURED_POLYLINE_EXTRACTOR"]),
            new TileDataManager(new _primitive_manager_zoom_filterable_primitive_manager__WEBPACK_IMPORTED_MODULE_34__["default"](iconsProvider, camera), _tile_data__WEBPACK_IMPORTED_MODULE_28__["POINT_EXTRACTOR"]),
            new TileDataManager(new _primitive_manager_zoom_filterable_primitive_manager__WEBPACK_IMPORTED_MODULE_34__["default"](pointLabelsProvider, camera), _tile_data__WEBPACK_IMPORTED_MODULE_28__["POINT_LABEL_EXTRACTOR"]),
            new TileDataManager(new _primitive_manager_zoom_filterable_primitive_manager__WEBPACK_IMPORTED_MODULE_34__["default"](curvedLabelsProvider, camera), _tile_data__WEBPACK_IMPORTED_MODULE_28__["CURVED_LABEL_EXTRACTOR"]),
            new TileDataManager(new _primitive_manager_renderable_primitive_manager__WEBPACK_IMPORTED_MODULE_29__["default"](modelsProvider), _tile_data__WEBPACK_IMPORTED_MODULE_28__["MODEL_EXTRACTOR"]),
            new TileDataManager(new _primitive_manager_external_mesh_manager__WEBPACK_IMPORTED_MODULE_35__["default"](modelsProvider, this._tileProvider, this.engine.memoryManager), _tile_data__WEBPACK_IMPORTED_MODULE_28__["EXTERNAL_MESH_EXTRACTOR"])
        ];
        this._requestedTilesState = new Map();
        this._taskQueue = new _util_task_queue__WEBPACK_IMPORTED_MODULE_39__["default"]();
        this._minorTaskQueue = new _util_idle_task_queue__WEBPACK_IMPORTED_MODULE_20__["default"]();
        this._tileProvider.on(_worker_tile_provider_worker_messages__WEBPACK_IMPORTED_MODULE_17__["TileProviderMessageType"].TILE_RESPONSE, (response) => this._onTileProviderResponse(response));
        this._tileProvider.on(_worker_tile_provider_worker_messages__WEBPACK_IMPORTED_MODULE_17__["TileProviderMessageType"].TILE_ERROR, (response) => this._onTileError(response.tile));
        this._onCameraUpdate();
    }
    destroy() {
        this._tileProvider.destroy();
        for (const destroyable of this._destroyables) {
            destroyable.destroy();
        }
        super.destroy();
    }
    setTileUrlTemplate(tileUrlTemplate) {
        this._tileProvider.sendMessage({
            type: _worker_tile_provider_worker_messages__WEBPACK_IMPORTED_MODULE_17__["TileProviderMessageType"].TILE_URL_UPDATE,
            tileUrlTemplate
        }, 1 /* IMMEDIATE */);
        this._refreshCurrentTiles();
    }
    _createTileRequest(tileItem, priority) {
        const targetZoom = this._getTargetZoom();
        return Object.assign({}, tileItem, { priority, isVisible: this._isTileVisible(tileItem), zoomMin: targetZoom, zoomMax: targetZoom });
    }
    _requestTiles(requests) {
        const requestId = Object(_util_unique_id__WEBPACK_IMPORTED_MODULE_22__["uniqueId"])();
        this._onTilesRequest(requests, requestId);
        for (const request of requests) {
            const requestedTileData = {
                isGeometryReady: false,
                areLabelsReady: false
            };
            this._requestedTilesState.set(Object(_tile_based_adapter_tile_id__WEBPACK_IMPORTED_MODULE_19__["getTileId"])(request), requestedTileData);
        }
        const request = {
            type: _worker_tile_provider_worker_messages__WEBPACK_IMPORTED_MODULE_17__["TileProviderMessageType"].TILE_REQUEST_BATCH,
            responseType: _worker_tile_provider_worker_messages__WEBPACK_IMPORTED_MODULE_17__["TileProviderMessageType"].TILE_RESPONSE,
            errorType: _worker_tile_provider_worker_messages__WEBPACK_IMPORTED_MODULE_17__["TileProviderMessageType"].TILE_ERROR,
            requestId,
            requests
        };
        this._tileProvider.sendMessage(request, 1 /* IMMEDIATE */);
    }
    _cancelTileRequests(requests) {
        for (const request of requests) {
            this._requestedTilesState.delete(Object(_tile_based_adapter_tile_id__WEBPACK_IMPORTED_MODULE_19__["getTileId"])(request.tile));
        }
        this._onCancelTileRequests(requests);
        this._tileProvider.sendMessage({
            type: _worker_tile_provider_worker_messages__WEBPACK_IMPORTED_MODULE_17__["TileProviderMessageType"].TILE_REQUEST_CANCEL_BATCH,
            requests
        });
    }
    _onTileDataUpdate(dataToShow, dataToHide) {
        for (const primitiveManager of this._tileDataManagers) {
            primitiveManager.updatePrimitives(dataToShow, dataToHide);
        }
    }
    _onTileDestroy(_tileItem, data) {
        // release primitives that we've created in allocators
        for (const portion of data) {
            (portion.polygons || []).forEach(releasePrimitive);
            (portion.texturedPolygons || []).forEach(releasePrimitive);
            (portion.polylines || []).forEach(releasePrimitive);
            (portion.texturedPolylines || []).forEach(releasePrimitive);
            (portion.points || []).forEach(releasePrimitive);
            (portion.pointLabels || []).forEach(releasePrimitive);
            (portion.curvedLabels || []).forEach(releasePrimitive);
            (portion.models || []).forEach(releasePrimitive);
        }
    }
    _sendStatisticsBeforeDestroy() {
        super._sendStatisticsBeforeDestroy();
        if (this._perfLogItems.length === 0) {
            return;
        }
        const items = this._perfLogItems;
        items.sort((a, b) => a.parseTime - b.parseTime);
        const min = items[0];
        const max = items[items.length - 1];
        const median = items[Math.floor(items.length / 2)];
        Object(_util_stat__WEBPACK_IMPORTED_MODULE_21__["countTileParseTime"])(this._layerName, min.tile, min.parseTime, max.tile, max.parseTime, median.tile, median.parseTime);
    }
    _onTileProviderResponse(response) {
        this._pushPerfLogItem(response.tile, response.parseTime);
        const tile = response.tile;
        const taskPriority = QUEUE_TASK_PRIORITIES.firstTilePortion +
            this._getTilePriority(tile, this._isTileVisible(tile));
        this._taskQueue.enqueue({
            priority: taskPriority,
            execute: () => {
                // atlas must be updated notwithstanding the tile is active or not
                // as these new glyphs will be used in next tiles
                const atlas = response.glyphAtlasToUpdate;
                if (atlas) {
                    this._glyphAtlas.updateContent(atlas.width, atlas.height, atlas.data, new Map(atlas.glyphLocations));
                }
                const registry = response.fontRegistryToUpdate;
                if (registry) {
                    for (const fontData of registry) {
                        let font;
                        if (this._fontRegistry.contains(fontData.id)) {
                            font = this._fontRegistry.get(fontData.id);
                        }
                        else {
                            font = new _font_df_font__WEBPACK_IMPORTED_MODULE_4__["default"](fontData.id, fontData.xheight, fontData.margin);
                            this._fontRegistry.add(font);
                        }
                        font.addAllGlyphs(fontData.glyphs);
                    }
                }
                const requestId = response.requestId;
                if (!this._isTileStillActive(tile, requestId)) {
                    return;
                }
                // If tile is being refreshed don't visualize any portions until all of them are loaded to avoid a blink
                const isRefreshing = this._isTileRefreshing(tile);
                const iconsSplitted = splitImageDependantPrimitives(response.points, this._imageManagerNearest, (point) => point.styles[0].imageId);
                const texturedPolylinesSplitted = splitImageDependantPrimitives(response.texturedPolylines, this._imageManagerLinear, (polyline) => polyline.styles[0].inline.pattern.imageId);
                const texturedPolygonsImages = getImagesIfAllAllocated(response.texturedPolygons, this._imageManagerNearest, (polygon) => polygon.styles[0].pattern.imageId);
                this._taskQueue.enqueue({
                    priority: QUEUE_TASK_PRIORITIES.secondTilePortion +
                        this._getTilePriority(tile, this._isTileVisible(tile)),
                    execute: () => {
                        if (this._isTileStillActive(tile, response.requestId)) {
                            this._putTileData(tile, {
                                polygons: this._allocatePolygons(response),
                                models: this._allocateMeshes(response),
                                externalMeshes: response.externalMeshes,
                                polylines: this._allocatePolylines(response),
                                pointLabels: this._allocatePointLabels(response),
                                curvedLabels: this._allocateCurvedLabels(response),
                                points: this._allocateIcons(tile, iconsSplitted.primitivesWithAllocatedImages, iconsSplitted.allocatedImages),
                                texturedPolylines: this._allocateTexturedPolylines(tile, texturedPolylinesSplitted.primitivesWithAllocatedImages, texturedPolylinesSplitted.allocatedImages),
                                texturedPolygons: !texturedPolygonsImages.allocatedImages ?
                                    [] :
                                    this._allocateTexturedPolygons(tile, response.texturedPolygons, texturedPolygonsImages.allocatedImages, response.texturedPolygonPages)
                            }, requestId, !isRefreshing);
                            iconsSplitted.allocatedImages.forEach(releasePrimitive);
                            texturedPolylinesSplitted.allocatedImages.forEach(releasePrimitive);
                            if (texturedPolygonsImages.allocatedImages) {
                                texturedPolygonsImages.allocatedImages.forEach(releasePrimitive);
                            }
                            const requestedTileData = this._requestedTilesState.get(Object(_tile_based_adapter_tile_id__WEBPACK_IMPORTED_MODULE_19__["getTileId"])(tile));
                            if (requestedTileData !== undefined) {
                                // TODO: the data is synced on these two properties
                                //       and this code doesn't make much sense for now,
                                //       but it is left "as is" since it is not clear
                                //       how it will be changed in nearest future
                                requestedTileData.isGeometryReady = true;
                                requestedTileData.areLabelsReady = true;
                                this._onTileDataReady(tile, response.url);
                            }
                        }
                    }
                });
                const putDataPromises = [];
                putDataPromises.push(iconsSplitted.missingImages.then((images) => {
                    this._onMissingIconImagesReady(response, iconsSplitted, images);
                }));
                putDataPromises.push(texturedPolylinesSplitted.missingImages.then((images) => {
                    this._onMissingPolylineImagesReady(response, texturedPolylinesSplitted, images);
                }));
                if (texturedPolygonsImages.missingImages) {
                    putDataPromises.push(texturedPolygonsImages.missingImages.then((images) => this._onMissingPolygonImagesReady(response, images)));
                }
                if (isRefreshing) {
                    // When all the portions are loaded, put empty data to visuazlize it
                    Promise.all(putDataPromises).then(() => this._putTileData(tile, {}, requestId, true));
                }
            }
        });
    }
    _onMissingIconImagesReady(response, iconsSplitted, images) {
        const tile = response.tile;
        this._minorTaskQueue.enqueue({
            priority: DEFAULT_IDLE_TASK_PRIORITY +
                this._getTilePriority(tile, this._isTileVisible(tile)),
            execute: () => {
                if (this._isTileStillActive(tile, response.requestId)) {
                    const points = this._allocateIcons(tile, iconsSplitted.primitivesWithMissingImages, images);
                    this._putTileData(tile, { points }, response.requestId, false);
                }
                images.forEach(releasePrimitive);
            }
        });
    }
    _onMissingPolylineImagesReady(response, texturedPolylinesSplitted, images) {
        const tile = response.tile;
        this._minorTaskQueue.enqueue({
            priority: DEFAULT_IDLE_TASK_PRIORITY + this._getTilePriority(tile, this._isTileVisible(tile)),
            execute: () => {
                if (this._isTileStillActive(tile, response.requestId)) {
                    const texturedPolylines = this._allocateTexturedPolylines(tile, texturedPolylinesSplitted.primitivesWithMissingImages, images);
                    this._putTileData(tile, { texturedPolylines }, response.requestId, false);
                }
                images.forEach(releasePrimitive);
            }
        });
    }
    _onMissingPolygonImagesReady(response, images) {
        const tile = response.tile;
        this._minorTaskQueue.enqueue({
            priority: DEFAULT_IDLE_TASK_PRIORITY +
                this._getTilePriority(tile, this._isTileVisible(tile)),
            execute: () => {
                if (this._isTileStillActive(tile, response.requestId)) {
                    const texturedPolygons = this._allocateTexturedPolygons(tile, response.texturedPolygons, images, response.texturedPolygonPages);
                    this._putTileData(tile, { texturedPolygons }, response.requestId, false);
                }
                images.forEach(releasePrimitive);
            }
        });
    }
    _onTileError(tile) {
        super._onTileError(tile);
        this._requestedTilesState.delete(Object(_tile_based_adapter_tile_id__WEBPACK_IMPORTED_MODULE_19__["getTileId"])(tile));
    }
    _isTileVisible(tile) {
        return this._currentTiles.has(Object(_tile_based_adapter_tile_id__WEBPACK_IMPORTED_MODULE_19__["getTileId"])(tile));
    }
    _allocatePolygons(response) {
        const polygonPrimitives = new Array(response.polygons.length + response.transparentPolygons.length);
        const memoryChunks = new MemoryChunks(response.polygonPages, this._memoryManager, _primitive_polygon_polygon_attribute_mapping__WEBPACK_IMPORTED_MODULE_10__["POLYGON_ATTRIBUTE_MAPPING"]);
        const transparentPolygonsMemoryChunks = new MemoryChunks(response.transparentPolygonPages, this._memoryManager, _primitive_polygon_transparent_polygon_attribute_mapping__WEBPACK_IMPORTED_MODULE_18__["TRANSPARENT_POLYGON_ATTRIBUTE_MAPPING"]);
        let index = 0;
        for (let i = 0; i < response.polygons.length; i++, index++) {
            const { bufferLocation } = response.polygons[i];
            polygonPrimitives[index] = new _primitive_polygon_renderable_polygon__WEBPACK_IMPORTED_MODULE_23__["default"](new _render_memory_sub_chunk__WEBPACK_IMPORTED_MODULE_2__["default"](memoryChunks[bufferLocation.bufferIndex], bufferLocation), true);
        }
        for (let i = 0; i < response.transparentPolygons.length; i++, index++) {
            const { bufferLocation } = response.transparentPolygons[i];
            polygonPrimitives[index] = new _primitive_polygon_renderable_polygon__WEBPACK_IMPORTED_MODULE_23__["default"](new _render_memory_sub_chunk__WEBPACK_IMPORTED_MODULE_2__["default"](transparentPolygonsMemoryChunks[bufferLocation.bufferIndex], bufferLocation), false);
        }
        memoryChunks.forEach((chunk) => chunk.release());
        transparentPolygonsMemoryChunks.forEach((chunk) => chunk.release());
        return polygonPrimitives;
    }
    _allocateTexturedPolygons(tile, polygonDescriptions, images, texturedPolygonPages) {
        const texturedPolygonRewriter = new _primitive_polygon_textured_polygon_buffer_rewiter__WEBPACK_IMPORTED_MODULE_9__["default"](texturedPolygonPages);
        const worldToPxFactor = WORLD_SIZE / (this._tileSideSizePx * Math.pow(2, tile.zoom));
        const locations = polygonDescriptions.map((parsedPolygon, index) => {
            const image = images[index];
            if (image) {
                const allocatedImage = image;
                const pattern = parsedPolygon.styles[0].pattern;
                const imageScale = pattern.width / allocatedImage.descriptor.width;
                texturedPolygonRewriter.rewriteUV(parsedPolygon.bufferLocation, allocatedImage.bbox, worldToPxFactor * imageScale);
                return parsedPolygon.bufferLocation;
            }
            else {
                return null;
            }
        });
        const memoryChunks = new MemoryChunks(texturedPolygonPages, this._memoryManager, _primitive_polygon_textured_polygon_attribute_mapping__WEBPACK_IMPORTED_MODULE_11__["TEXTURED_POLYGON_ATTRIBUTE_MAPPING"]);
        const texturedPolygonPrimitives = [];
        for (let i = 0; i < locations.length; i++) {
            const location = locations[i];
            const image = images[i];
            if (location && image) {
                const texturedPolygonPrimitive = new _primitive_polygon_renderable_textured_polygon__WEBPACK_IMPORTED_MODULE_24__["default"](new _render_memory_sub_chunk__WEBPACK_IMPORTED_MODULE_2__["default"](memoryChunks[location.bufferIndex], location), image);
                texturedPolygonPrimitives.push(texturedPolygonPrimitive);
            }
        }
        memoryChunks.forEach((chunk) => chunk.release());
        return texturedPolygonPrimitives;
    }
    _allocateMeshes(tileResponse) {
        const memoryChunks = tileResponse.meshPages.map((page) => this._memoryManager.allocate(page.vertexBuffer, page.indexBuffer, _primitive_model_model_buffer_writer__WEBPACK_IMPORTED_MODULE_6__["default"].ATTRIBUTE_MAPPING));
        const meshPrimitives = tileResponse.meshes.map((mesh) => new _primitive_model_renderable_model__WEBPACK_IMPORTED_MODULE_27__["default"](new _render_memory_sub_chunk__WEBPACK_IMPORTED_MODULE_2__["default"](memoryChunks[mesh.bufferLocation.bufferIndex], mesh.bufferLocation)));
        memoryChunks.forEach((chunk) => chunk.release());
        return meshPrimitives;
    }
    _allocatePolylines(response) {
        const polylinePrimitives = new Array(response.polylines.length);
        const memoryChunks = new MemoryChunks(response.polylinePages, this._memoryManager, _primitive_polyline_polyline_attribute_mapping__WEBPACK_IMPORTED_MODULE_15__["POLYLINE_ATTRIBUTE_MAPPING"]);
        let index = 0;
        for (let i = 0; i < response.polylines.length; i++, index++) {
            const { bufferLocation } = response.polylines[i];
            polylinePrimitives[index] = new _primitive_polyline_renderable_polyline__WEBPACK_IMPORTED_MODULE_25__["default"](new _render_memory_sub_chunk__WEBPACK_IMPORTED_MODULE_2__["default"](memoryChunks[bufferLocation.bufferIndex], bufferLocation));
        }
        memoryChunks.forEach((chunk) => chunk.release());
        return polylinePrimitives;
    }
    _allocateTexturedPolylines(tile, parsedPolylines, images) {
        const texturedPolylineWriter = new _primitive_polyline_textured_polyline_buffer_writer__WEBPACK_IMPORTED_MODULE_7__["default"]();
        const worldToPxFactor = WORLD_SIZE / (this._tileSideSizePx * Math.pow(2, tile.zoom));
        const locations = parsedPolylines.map((parsedPolyline, index) => {
            const image = images[index];
            if (image) {
                const style = parsedPolyline.styles[0];
                const width = (style.inline || style.outline).strokeWidth;
                const imageLocation = image.bbox;
                // image size may not match polyline's strokeWidth, so it must be scaled accordingly in
                // both directions, this factor can be passed to the writer in worldToPxFactor updated.
                const pixelRatio = width / (imageLocation.maxY - imageLocation.minY);
                return texturedPolylineWriter.writeTexturedPolyline(parsedPolyline, width, worldToPxFactor * pixelRatio, imageLocation, style.zIndex);
            }
            else {
                return null;
            }
        });
        const pages = texturedPolylineWriter.getBuffers();
        const memoryChunks = new MemoryChunks(pages, this._memoryManager, _primitive_polyline_textured_polyline_buffer_writer__WEBPACK_IMPORTED_MODULE_7__["default"].ATTRIBUTE_MAPPING);
        const texturedPolylinePrimitives = [];
        for (let i = 0; i < locations.length; i++) {
            const location = locations[i];
            const image = images[i];
            if (location && image) {
                const texturedPolylinePrimitive = new _primitive_polyline_renderable_textured_polyline__WEBPACK_IMPORTED_MODULE_26__["default"](new _render_memory_sub_chunk__WEBPACK_IMPORTED_MODULE_2__["default"](memoryChunks[location.bufferIndex], location), image);
                texturedPolylinePrimitives.push(texturedPolylinePrimitive);
            }
        }
        memoryChunks.forEach((chunk) => chunk.release());
        return texturedPolylinePrimitives;
    }
    _allocatePointLabels(response) {
        const memoryChunks = new MemoryChunks(response.pointLabelPages, this._memoryManager, _primitive_label_point_label_attribute_mapping__WEBPACK_IMPORTED_MODULE_13__["POINT_LABEL_ATTRIBUTE_MAPPING"]);
        const backgroundMemoryChunks = new MemoryChunks(response.pointLabelBackgroundPages, this._memoryManager, _primitive_billboard_rectangle_attribute_mapping__WEBPACK_IMPORTED_MODULE_12__["BILLBOARD_RECTANGLE_ATTRIBUTE_MAPPING"]);
        const pointLabels = response.pointLabels.map(({ bufferLocation, backgroundBufferLocation }) => {
            const backgroundPrimitive = backgroundBufferLocation ?
                new _primitive_billboard_rectangle_renderable_billboard_rectangle__WEBPACK_IMPORTED_MODULE_36__["default"](new _render_memory_sub_chunk__WEBPACK_IMPORTED_MODULE_2__["default"](backgroundMemoryChunks[backgroundBufferLocation.bufferIndex], backgroundBufferLocation)) :
                undefined;
            const labelPrimitive = new _primitive_zoom_restricted_label__WEBPACK_IMPORTED_MODULE_37__["ZoomRestrictedLabel"](new _render_memory_sub_chunk__WEBPACK_IMPORTED_MODULE_2__["default"](memoryChunks[bufferLocation.bufferIndex], bufferLocation), this._glyphAtlas, this._computeMinZoom(response.tile, MINZOOM_DELTAS.pointLabels), backgroundPrimitive);
            if (backgroundPrimitive) {
                backgroundPrimitive.release();
            }
            return labelPrimitive;
        });
        backgroundMemoryChunks.forEach((chunk) => chunk.release());
        memoryChunks.forEach((chunk) => chunk.release());
        return pointLabels;
    }
    _allocateCurvedLabels(response) {
        const memoryChunks = new MemoryChunks(response.curvedLabelPages, this._memoryManager, _primitive_label_curved_label_attribute_mapping__WEBPACK_IMPORTED_MODULE_14__["CURVED_LABEL_ATTRIBUTE_MAPPING"]);
        const curvedLabelPrimitives = response.curvedLabels.map(({ bufferLocation }) => new _primitive_zoom_restricted_label__WEBPACK_IMPORTED_MODULE_37__["ZoomRestrictedLabel"](new _render_memory_sub_chunk__WEBPACK_IMPORTED_MODULE_2__["default"](memoryChunks[bufferLocation.bufferIndex], bufferLocation), this._glyphAtlas, this._computeMinZoom(response.tile, MINZOOM_DELTAS.curvedLabels)));
        memoryChunks.forEach((chunk) => chunk.release());
        return curvedLabelPrimitives;
    }
    _allocateIcons(tile, parsedIcons, images) {
        const iconWriter = new _primitive_icon_icon_buffer_writer__WEBPACK_IMPORTED_MODULE_1__["default"]();
        const locations = parsedIcons.map((parsedIcon, index) => {
            const image = images[index];
            if (image) {
                const style = parsedIcon.styles[0];
                const size = image.descriptor;
                const pixelRatio = style.width / size.width;
                return iconWriter.writeIcon(parsedIcon, image.bbox, size, style.offset, pixelRatio);
            }
            else {
                return null;
            }
        });
        const pages = iconWriter.getBuffers();
        const memoryChunks = new MemoryChunks(pages, this._memoryManager, _primitive_icon_icon_buffer_writer__WEBPACK_IMPORTED_MODULE_1__["default"].ATTRIBUTE_MAPPING);
        const iconPrimitives = [];
        for (let i = 0; i < locations.length; i++) {
            const location = locations[i];
            const image = images[i];
            if (location && image) {
                const iconPrimitive = new _primitive_zoom_restricted_icon__WEBPACK_IMPORTED_MODULE_38__["ZoomRestrictedIcon"](new _render_memory_sub_chunk__WEBPACK_IMPORTED_MODULE_2__["default"](memoryChunks[location.bufferIndex], location), image, this._computeMinZoom(tile, MINZOOM_DELTAS.icons));
                iconPrimitives.push(iconPrimitive);
            }
        }
        memoryChunks.forEach((chunk) => chunk.release());
        return iconPrimitives;
    }
    /**
     * Computes a minimum zoom an object should be still displayed on.
     *
     * @param tile Tile the object belongs to.
     * @param delta Tolerance of the visibility to zooming out, default value was empirically chosen.
     * @returns Minimum zoom for the object.
     */
    _computeMinZoom(tile, delta = 1) {
        return tile.zoom - this._zoomShift - this._targetZoomShift - delta;
    }
    _pushPerfLogItem(tile, parseTime) {
        if (this._perfLogItems.length < MAX_PERF_LOG_ITEMS_COUNT) {
            this._perfLogItems.push({ tile, parseTime });
        }
    }
}
/**
 * Helper class for allocation of an array of memory chunks.
 */
class MemoryChunks extends Array {
    constructor(pages, memoryManager, attribMapping) {
        super(pages.length);
        for (let i = 0; i < pages.length; i++) {
            this[i] = memoryManager.allocate(pages[i].vertexBuffer, pages[i].indexBuffer, attribMapping);
        }
    }
}
/**
 * Data managers responsible for specific type of primitives. It just extracts them from TileData and
 * updates appropriate primitive provider.
 */
class TileDataManager {
    constructor(primitiveManager, primitveExtractor) {
        this._primitiveManager = primitiveManager;
        this._primitiveExtractor = primitveExtractor;
    }
    updatePrimitives(toShow, toHide) {
        this._primitiveManager.updateScene(this._primitiveExtractor(toShow), this._primitiveExtractor(toHide));
    }
}
function releasePrimitive(primitive) {
    if (primitive) {
        primitive.release();
    }
}
/**
 * Turns rejection of original promise into null-value resolution. Nulls on appropriate places
 * are required in allocation of textured primitives.
 */
function nullifyRejection(promise) {
    return new Promise((resolve) => promise.then(resolve, () => resolve(null)));
}
/**
 * Splits primitives into two lists: those that have required images allocated and those which images are to be
 * requested. Required images returned in corresponing arrays (requested images as promises).
 */
function splitImageDependantPrimitives(primitives, imageManager, idMapper) {
    const primitivesWithAllocatedImages = [];
    const allocatedImages = [];
    const primitivesWithMissingImages = [];
    const missingImageIds = [];
    for (const primitive of primitives) {
        const id = idMapper(primitive);
        const allocatedImage = imageManager.getImage(id);
        if (allocatedImage) {
            primitivesWithAllocatedImages.push(primitive);
            allocatedImages.push(allocatedImage);
        }
        else {
            primitivesWithMissingImages.push(primitive);
            missingImageIds.push(nullifyRejection(imageManager.requestImage(id)));
        }
    }
    return {
        primitivesWithAllocatedImages,
        allocatedImages,
        primitivesWithMissingImages,
        missingImages: Promise.all(missingImageIds)
    };
}
/**
 * Returns either array of allocated images (if all required images are on the spot) or promises for them (if at least
 * one required image is not yet allocated).
 */
function getImagesIfAllAllocated(primitives, imageManager, idMapper) {
    let isAnyMissing = false;
    const allocatedImages = new Array(primitives.length);
    const missingImages = new Array(primitives.length);
    for (let i = 0; i < primitives.length; i++) {
        const primitive = primitives[i];
        const id = idMapper(primitive);
        const allocatedImage = imageManager.getImage(id);
        if (allocatedImage) {
            allocatedImages[i] = allocatedImage;
        }
        else {
            isAnyMissing = true;
            missingImages[i] = nullifyRejection(imageManager.requestImage(id));
        }
    }
    if (isAnyMissing) {
        for (let i = 0; i < primitives.length; i++) {
            if (allocatedImages[i]) {
                missingImages[i] = Promise.resolve(allocatedImages[i]);
            }
        }
        return { missingImages: Promise.all(missingImages) };
    }
    else {
        return { allocatedImages };
    }
}


/***/ }),
/* 25 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TileBasedAdapter; });
/* harmony import */ var _adapter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(26);
/* harmony import */ var _util_tile_system__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(28);
/* harmony import */ var _util_iterable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3);
/* harmony import */ var _tile_id__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(29);
/* harmony import */ var _util_event_emitter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(14);
/* harmony import */ var _math_vector2__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(23);
/* harmony import */ var _util_worker__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(30);
/* harmony import */ var _util_visible_tile__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(32);
/* harmony import */ var _belt_tiles__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(33);
/* harmony import */ var _util_stat__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(34);










const NO_TILES_TO_HANDLE = [];
const MAX_PERF_LOG_ITEMS_COUNT = 1024;
// To select which tile to load camera zoom is rounded so the shift is 0.5.
const TARGET_ZOOM_SHIFT = 0.25;
const VISIBLE_TILE_PRIORITY = 200;
function* flattenVisibleDataPortions(tiles) {
    for (const tile of tiles) {
        yield* tile.data.visible;
    }
}
function getZoomShift(tileSize) {
    switch (tileSize) {
        case 1 /* X4 */:
            return -1;
        case 2 /* X16 */:
            return -2;
        default:
            return 0;
    }
}
/**
 * Base class for adapters that get their data in tiles. Content of tiles that come into field of view should
 * be requested, as well as content of invisible tiles should be removed, also tiles on different zoom levels can
 * overlap each other. Managing of all these cases and other tile-specific logic is the responsibility of this class.
 */
class TileBasedAdapter extends _adapter__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(engine, camera, tileSize = 0 /* X1 */, preloadedTilesBeltSize = 0, layerName = '') {
        super(engine, camera);
        this._layerName = layerName;
        this._zoomShift = getZoomShift(tileSize);
        this._targetZoomShift = TARGET_ZOOM_SHIFT;
        this._engineRenderListener = () => this._onEngineRenderEvent();
        this.engine.renderer.onRender.addListener(this._engineRenderListener);
        this._currentTiles = new Map();
        this._allTiles = new Map();
        this._readyForRenderTiles = [];
        this.onTileReady = new _util_event_emitter__WEBPACK_IMPORTED_MODULE_4__["EventEmitter"]();
        this.onTileLoadChange = new _util_event_emitter__WEBPACK_IMPORTED_MODULE_4__["EventEmitter"]();
        this._requestedTiles = new Map();
        this._tilesToRefresh = new Set();
        this._beltSize = preloadedTilesBeltSize;
        // Sometimes the adapter isn't destroyed, just the page closes. Listen
        // for that and send measurements to the statface.
        window.addEventListener('beforeunload', this._onBeforeUnloadListener = this._sendStatisticsBeforeDestroy.bind(this));
        this._tileLoadLogs = [];
    }
    destroy() {
        window.removeEventListener('beforeunload', this._onBeforeUnloadListener);
        this._sendStatisticsBeforeDestroy();
        this.engine.renderer.onRender.removeListener(this._engineRenderListener);
        super.destroy();
    }
    getVisibleTilesNumber() {
        return this._currentTiles.size;
    }
    getPendingTilesNumber() {
        let pendingCounter = 0;
        this._requestedTiles.forEach((requestedTile) => {
            if (this._currentTiles.get(Object(_tile_id__WEBPACK_IMPORTED_MODULE_3__["getTileId"])(requestedTile.tileItem))) {
                pendingCounter++;
            }
        });
        return pendingCounter;
    }
    _getTargetZoom() {
        return Math.floor(this.camera.zoom + this._targetZoomShift);
    }
    /**
     * @param tileItem The tile to which the data belongs.
     * @param data Data portion to be shown in tile once it is ready to visualize.
     * @param requestId ID of the request data was requested with. Based on this the data is being displayed, stored for
     * future use or discarded.
     * @param visualize Is this data portion enough to render this tile and replace overlapped ones if any.
     */
    _putTileData(tileItem, data, requestId = _util_worker__WEBPACK_IMPORTED_MODULE_6__["NO_ID"], visualize = true) {
        const tile = this._allTiles.get(Object(_tile_id__WEBPACK_IMPORTED_MODULE_3__["getTileId"])(tileItem));
        if (!tile) {
            // Data recieved late and probably the tile had been destroyed.
            // Destroy data too.
            this._onTileDestroy(tileItem, [data]);
            return;
        }
        // NO_ID passed here means concrete adapter doesn't care to label tile data with a requestId which most likely
        // means adapter keeps its data as a whole, not splitting it into portions and, therefore, doesn't need its data
        // to be maintained separately as visible/actual. In this case the data is always treated like an actual data.
        if (requestId === tile.data.visibleRequestId && requestId !== _util_worker__WEBPACK_IMPORTED_MODULE_6__["NO_ID"]) {
            tile.data.visible.push(data);
            if (tile.isVisible) {
                // The data is currently displayed so the new portion is added to the scene.
                this._updateTileDataPortions([data], []);
            }
        }
        else if (requestId === tile.data.actualRequestId) {
            // The data is actual and either is just being put into the tile or visualizes all `actual` tile data.
            this._putActualTileData(tile, data, visualize);
        }
        else {
            // The data is neither visible nor actual. Destroy data.
            this._onTileDestroy(tileItem, [data]);
        }
    }
    _onCameraUpdate() {
        const camera = this.camera;
        const zoom = this._getTargetZoom();
        const newCurrent = new Set(Object(_util_visible_tile__WEBPACK_IMPORTED_MODULE_7__["computeVisibleTiles"])(camera.getVisibleRegion(), camera.getVisibleRegionBBox(), camera.options.wrapModeX, camera.options.wrapModeY, Math.max(0, zoom + this._zoomShift)));
        // this._currentTiles contains currently visible tiles, newCurrent contains set of tiles visible from updated
        // camera position, compare these two sets and call this._onVisibleTilesChanged() if there is a difference.
        if (newCurrent.size !== this._currentTiles.size ||
            Object(_util_iterable__WEBPACK_IMPORTED_MODULE_2__["oneOfIterable"])(newCurrent, (tile) => !this._currentTiles.has(Object(_tile_id__WEBPACK_IMPORTED_MODULE_3__["getTileId"])(tile)))) {
            this._onVisibleTilesChanged(newCurrent);
        }
        // this checks prevents leaks of tiles when quick zoom-in/zoom-out happens
        for (const tile of this._currentTiles.values()) {
            if (tile.isReadyToVisualize) {
                this._checkTileReplacements(tile);
            }
        }
    }
    _onTilesRequest(requests, requestId = _util_worker__WEBPACK_IMPORTED_MODULE_6__["NO_ID"]) {
        for (const tileRequest of requests) {
            const requestedTileData = {
                info: {
                    priority: tileRequest.priority
                },
                loadTimestamps: {
                    queued: performance.now(),
                    loaded: 0,
                    rendered: 0,
                    ready: 0
                },
                tileItem: tileRequest
            };
            const tileId = Object(_tile_id__WEBPACK_IMPORTED_MODULE_3__["getTileId"])(tileRequest);
            this._requestedTiles.set(tileId, requestedTileData);
            this._readyTilesChange = true;
            const tile = this._allTiles.get(tileId);
            if (tile) {
                tile.data.actualRequestId = requestId;
            }
        }
    }
    _onCancelTileRequests(requests) {
        for (const request of requests) {
            const tileId = Object(_tile_id__WEBPACK_IMPORTED_MODULE_3__["getTileId"])(request.tile);
            if (this._requestedTiles.delete(tileId)) {
                this._readyTilesChange = true;
                this._tilesToRefresh.delete(tileId);
            }
        }
    }
    _onTileError(tileItem) {
        const tileId = Object(_tile_id__WEBPACK_IMPORTED_MODULE_3__["getTileId"])(tileItem);
        if (this._requestedTiles.delete(tileId)) {
            this._readyTilesChange = true;
            this._tilesToRefresh.delete(tileId);
        }
    }
    /**
     * This method is where the whole magic happens, it manages replacement of current set of visible/preloaded tiles
     * with a new one.
     */
    _onVisibleTilesChanged(visibleTiles) {
        this._currentTiles.clear();
        const tilesToRequest = [];
        for (const tileItem of visibleTiles) {
            let tile = this._allTiles.get(Object(_tile_id__WEBPACK_IMPORTED_MODULE_3__["getTileId"])(tileItem));
            if (!tile) {
                tile = new Tile(tileItem);
                this._allTiles.set(tile.id, tile);
                this._currentTiles.set(tile.id, tile);
                tilesToRequest.push(this._createTileRequest(tileItem, this._getTilePriority(tile.tileItem, true)));
            }
            else {
                this._currentTiles.set(tile.id, tile);
            }
        }
        if (tilesToRequest.length > 0) {
            this._requestTiles(tilesToRequest);
        }
        const beltTiles = new Map();
        for (const beltTileItem of Object(_belt_tiles__WEBPACK_IMPORTED_MODULE_8__["calculateBeltTiles"])(visibleTiles, this._beltSize, this.camera.options.wrapModeX === 2 /* REPEAT */, this.camera.options.wrapModeY === 2 /* REPEAT */)) {
            beltTiles.set(Object(_tile_id__WEBPACK_IMPORTED_MODULE_3__["getTileId"])(beltTileItem), beltTileItem);
        }
        const beltTilesToRequest = [];
        for (const beltTileItem of beltTiles.values()) {
            const tileId = Object(_tile_id__WEBPACK_IMPORTED_MODULE_3__["getTileId"])(beltTileItem);
            let tile = this._allTiles.get(tileId);
            if (!tile) {
                tile = new Tile(beltTileItem);
                this._allTiles.set(tileId, tile);
                beltTilesToRequest.push(this._createTileRequest(beltTileItem, this._getTilePriority(beltTileItem, false)));
            }
        }
        if (beltTilesToRequest.length) {
            this._requestTiles(beltTilesToRequest);
        }
        // broke current relationships to set them up again but with new set of visible tiles
        for (const tile of this._allTiles.values()) {
            tile.toBeReplacedBy.clear();
            tile.replacementFor.clear();
        }
        // TODO: optimize this n^2 relationships resolver
        for (const currentTile of this._currentTiles.values()) {
            for (const tile of this._allTiles.values()) {
                if (tile.isReadyToVisualize &&
                    (Object(_util_tile_system__WEBPACK_IMPORTED_MODULE_1__["isParent"])(tile.tileItem, currentTile.tileItem) || Object(_util_tile_system__WEBPACK_IMPORTED_MODULE_1__["isParent"])(currentTile.tileItem, tile.tileItem))) {
                    tile.toBeReplacedBy.add(currentTile);
                    currentTile.replacementFor.add(tile);
                }
            }
        }
        // remove invisible
        const tilesToCancel = [];
        for (const tile of this._allTiles.values()) {
            if (!this._currentTiles.has(tile.id) && tile.toBeReplacedBy.size === 0) {
                if (tile.isVisible) {
                    this._updateTileData(NO_TILES_TO_HANDLE, [tile]);
                }
                if (!beltTiles.get(tile.id)) {
                    this._destroyTile(tile);
                    tilesToCancel.push(tile);
                }
            }
        }
        if (tilesToCancel.length) {
            // issue cancellation also in case there are non processed data enqueued to try to save some efforts
            this._cancelTileRequests(tilesToCancelations(tilesToCancel));
        }
    }
    _refreshCurrentTiles() {
        const tilesToRequest = [];
        for (const tile of this._currentTiles.values()) {
            const tileItem = tile.tileItem;
            const tileRequest = this._createTileRequest(tileItem, this._getTilePriority(tile.tileItem, true));
            tilesToRequest.push(tileRequest);
            this._tilesToRefresh.add(Object(_tile_id__WEBPACK_IMPORTED_MODULE_3__["getTileId"])(tile.tileItem));
        }
        this._cancelTileRequests(tilesToCancelations(this._currentTiles.values()));
        this._requestTiles(tilesToRequest);
    }
    _onTileDataReady(tileItem, url) {
        const tileId = Object(_tile_id__WEBPACK_IMPORTED_MODULE_3__["getTileId"])(tileItem);
        const tileData = this._requestedTiles.get(tileId);
        this._requestedTiles.delete(tileId);
        this._tilesToRefresh.delete(tileId);
        tileData.info.url = url;
        tileData.loadTimestamps.loaded = performance.now();
        if (this._tileLoadLogs.length < MAX_PERF_LOG_ITEMS_COUNT) {
            this._tileLoadLogs.push({
                tileItem,
                processingTime: tileData.loadTimestamps.loaded - tileData.loadTimestamps.queued
            });
        }
        this._readyForRenderTiles.push(tileData);
        if (this._currentTiles.get(tileId)) {
            this._readyTilesChange = true;
        }
    }
    _isTileStillActive(tileItem, requestId = _util_worker__WEBPACK_IMPORTED_MODULE_6__["NO_ID"]) {
        const tile = this._allTiles.get(Object(_tile_id__WEBPACK_IMPORTED_MODULE_3__["getTileId"])(tileItem));
        if (!tile) {
            return false;
        }
        const isRequestActive = tile.data.actualRequestId === requestId || tile.data.visibleRequestId === requestId;
        return isRequestActive;
    }
    _isTileRefreshing(tile) {
        return this._tilesToRefresh.has(Object(_tile_id__WEBPACK_IMPORTED_MODULE_3__["getTileId"])(tile));
    }
    _getTilePriority(tile, isVisible) {
        const center = this._createTileCoordinateSystem().toTileCoordinates(this.camera.center);
        const zoomDiff = Math.ceil(this.camera.zoom) - tile.zoom;
        const distance = _math_vector2__WEBPACK_IMPORTED_MODULE_5__["distance"](tile, {
            x: Math.floor(center.x / Math.pow(2, zoomDiff)),
            y: Math.floor(center.y / Math.pow(2, zoomDiff))
        });
        return (isVisible ? VISIBLE_TILE_PRIORITY : 0) + 1 / (distance + 1);
    }
    _sendStatisticsBeforeDestroy() {
        if (this._tileLoadLogs.length === 0) {
            return;
        }
        const accumulatedTimings = new Map();
        accumulatedTimings.set('average', {
            sum: 0,
            number: 0
        });
        this._tileLoadLogs.forEach((logItem) => {
            accumulatedTimings.get('average').sum += logItem.processingTime;
            accumulatedTimings.get('average').number++;
            const zoom = logItem.tileItem.zoom.toString();
            if (!accumulatedTimings.has(zoom)) {
                accumulatedTimings.set(zoom, {
                    sum: 0,
                    number: 0
                });
            }
            accumulatedTimings.get(zoom).sum += logItem.processingTime;
            accumulatedTimings.get(zoom).number++;
        });
        const result = [];
        for (const item of accumulatedTimings) {
            result.push({
                zoom: item[0],
                time: (item[1].sum / item[1].number)
            });
        }
        Object(_util_stat__WEBPACK_IMPORTED_MODULE_9__["countTileProcessingTime"])(this._layerName, result);
    }
    /**
     * Puts actual data into the tile and optionally visualizes it.
     *
     * @param tile Tile to put data into.
     * @param data Data to be stored in the tile until visualization.
     * @param visualize If `true` replaces `visible` tile data with `actual` tile data and updates the scene.
     */
    _putActualTileData(tile, data, visualize) {
        tile.data.actual.push(data);
        if (visualize) {
            this._visualizeTile(tile);
        }
    }
    /**
     * Visualizes tile `actual` data: replaces tile `visible` data with tile `actual` data, adds it to the scene,
     * removes old visible data from the scene and destroys it, checks tile replacements and updates `visibleRequestId`.
     * @param tile Tile to visualize.
     */
    _visualizeTile(tile) {
        const toDestroy = tile.data.visible;
        tile.data.visible = tile.data.actual;
        tile.data.actual = [];
        tile.data.visibleRequestId = tile.data.actualRequestId;
        if (!tile.isReadyToVisualize) {
            tile.isReadyToVisualize = true;
            this._checkTileReplacements(tile);
        }
        else if (tile.isVisible) {
            this._updateTileDataPortions(tile.data.visible, []);
        }
        if (toDestroy.length > 0) {
            this._updateTileDataPortions([], toDestroy);
            this._onTileDestroy(tile.tileItem, toDestroy);
        }
    }
    _createTileCoordinateSystem() {
        return new _util_tile_system__WEBPACK_IMPORTED_MODULE_1__["default"](this.camera.zoom);
    }
    // We need do detect when tile is rendered to collect perfomance metrics.
    // We expect that tile will be rendered with first render event after
    // tile data is added to scene.
    _onEngineRenderEvent() {
        if (this._readyForRenderTiles.length) {
            this._readyForRenderTiles.forEach((tileData) => {
                if (this._currentTiles.has(Object(_tile_id__WEBPACK_IMPORTED_MODULE_3__["getTileId"])(tileData.tileItem))) {
                    tileData.loadTimestamps.rendered = performance.now();
                    tileData.loadTimestamps.ready = performance.now();
                    this.onTileReady.fire(tileData);
                }
            });
            this._readyForRenderTiles.length = 0;
        }
        if (this._readyTilesChange) {
            this.onTileLoadChange.fire({
                totalTileNumber: this.getVisibleTilesNumber(),
                readyTileNumber: this.getVisibleTilesNumber() - this.getPendingTilesNumber()
            });
            this._readyTilesChange = false;
        }
    }
    /**
     * Shows/hides tiles if they are not shown/hidden yet. It notifies subclasses by calling appropriate
     * abstract method. Even though visible/invisible tiles are not supposed to be shown/hidden again,
     * there are cases where it simplifies tile visualization logic.
     * It is important to have exactly "update", not "add"/"remove" separately, as some business logic may rely on it,
     * e.g. morphing visible data or managing shared resources.
     */
    _updateTileData(toShow, toRemove) {
        const dataToShow = Array.from(flattenVisibleDataPortions(toShow));
        const dataToRemove = Array.from(flattenVisibleDataPortions(toRemove));
        this._updateTileDataPortions(dataToShow, dataToRemove);
        for (const tile of toShow) {
            tile.isVisible = true;
        }
        for (const tile of toRemove) {
            tile.isVisible = false;
        }
    }
    _updateTileDataPortions(toShow, toRemove) {
        this._onTileDataUpdate(toShow, toRemove);
    }
    /**
     * Removes tile if is not removed with calling all appropriate callbacks (abstract methods)
     * to notify descendant classes. Even though removed tile is not supposed to be removed again,
     * allowing this makes much simpler tile management, especially in tile replacements logic where multiple
     * tiles can have links to the same tile (that is to be removed).
     */
    _destroyTile(tile) {
        if (!tile.isRemoved) {
            tile.isRemoved = true;
            this._allTiles.delete(tile.id);
            this._currentTiles.delete(tile.id);
            this._onTileDestroy(tile.tileItem, [...tile.data.actual, ...tile.data.visible]);
        }
    }
    /**
     * Checks tiles that could be replaced by this one, should be called when tile becomes ready to visualize.
     * As overlapping relationships can happen in both directions (children by parents / parent by children) this
     * method goes one step deeper, i.e. it check not only tiles that should be replaced (to remove them),
     * but also all tiles that cover the replaced ones (to show them).
     */
    _checkTileReplacements(tile) {
        const toDestroy = new Set();
        const toShow = new Set();
        const toHide = new Set();
        for (const tileToReplace of tile.replacementFor) {
            if (Object(_util_iterable__WEBPACK_IMPORTED_MODULE_2__["allOfIterable"])(tileToReplace.toBeReplacedBy, (tile) => tile.isReadyToVisualize)) {
                if (tileToReplace.isVisible) {
                    toHide.add(tileToReplace);
                }
                if (!tileToReplace.isRemoved) {
                    toDestroy.add(tileToReplace);
                }
                for (const tileToShow of tileToReplace.toBeReplacedBy) {
                    if (!tileToShow.isVisible) {
                        toShow.add(tileToShow);
                    }
                }
            }
        }
        if (tile.replacementFor.size === 0 && !tile.isVisible) {
            toShow.add(tile);
        }
        if (toShow.size > 0 || toHide.size > 0) {
            this._updateTileData(toShow, toHide);
        }
        for (const tileToDestroy of toDestroy) {
            this._destroyTile(tileToDestroy);
        }
        if (toDestroy.size > 0) {
            this._cancelTileRequests(tilesToCancelations(toDestroy));
        }
    }
}
/**
 * This class is the main unit of the whole process of tile management. It stores visualizable data and links to
 * dependant tiles (for parent/child overlapping cases).
 */
class Tile {
    constructor(tileItem) {
        this.data = {
            actual: [],
            visible: [],
            actualRequestId: _util_worker__WEBPACK_IMPORTED_MODULE_6__["NO_ID"],
            visibleRequestId: _util_worker__WEBPACK_IMPORTED_MODULE_6__["NO_ID"]
        };
        this.tileItem = tileItem;
        this.id = `${tileItem.x}:${tileItem.y}:${tileItem.zoom}`;
        this.isReadyToVisualize = false;
        this.isVisible = false;
        this.isRemoved = false;
        this.toBeReplacedBy = new Set();
        this.replacementFor = new Set();
    }
}
function tilesToCancelations(tiles) {
    return Array.from(tiles, (tile) => ({
        tile: tile.tileItem,
        requestId: tile.data.actualRequestId
    }));
}


/***/ }),
/* 26 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Adapter; });
/* harmony import */ var _util_function__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27);

class Adapter {
    constructor(engine, camera, cameraUpdateDelay = 5) {
        this.engine = engine;
        this.camera = camera;
        this._cameraUpdateListener = Object(_util_function__WEBPACK_IMPORTED_MODULE_0__["debounce"])(this._onCameraUpdate.bind(this), cameraUpdateDelay);
        camera.onUpdate.addListener(this._cameraUpdateListener);
    }
    destroy() {
        this.camera.onUpdate.removeListener(this._cameraUpdateListener);
    }
    /**
     * Camera update handler, by default do nothing.
     */
    _onCameraUpdate() { }
}


/***/ }),
/* 27 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "debounce", function() { return debounce; });
/**
 * Creates new function which execution is "debounced".
 */
function debounce(func, wait) {
    let timeout = 0;
    return (...args) => {
        const later = () => {
            timeout = 0;
            func(...args);
        };
        if (timeout) {
            clearTimeout(timeout);
        }
        timeout = setTimeout(later, wait);
    };
}


/***/ }),
/* 28 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isParent", function() { return isParent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TileCoordinateSystem; });
/* harmony import */ var _math_scalar__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(16);

/**
 * @return `true` if the first param overlaps the second in tile hierarchy.
 */
function isParent(potentialParent, possibleChild) {
    const zoomDiff = possibleChild.zoom - potentialParent.zoom;
    return zoomDiff > 0 &&
        possibleChild.x >> zoomDiff === potentialParent.x &&
        possibleChild.y >> zoomDiff === potentialParent.y;
}
class TileCoordinateSystem {
    constructor(zoom) {
        this._zoom = Math.ceil(Object(_math_scalar__WEBPACK_IMPORTED_MODULE_0__["clamp"])(zoom, 0, 31));
        this._tileSize = 2 / (1 << this._zoom);
    }
    getZoom() {
        return this._zoom;
    }
    /**
     * @return Tile side length in units of the world coordinate system.
     */
    getTileSize() {
        return this._tileSize;
    }
    /**
     * @return Top left corner coordinates of the tile.
     */
    getTileOffset(tile) {
        return {
            x: this.getTileSize() * tile.x - 1,
            y: 1 - this.getTileSize() * tile.y
        };
    }
    toTileCoordinates(worldCoordinates) {
        return {
            x: (worldCoordinates.x + 1) / this._tileSize,
            y: (1 - worldCoordinates.y) / this._tileSize
        };
    }
}


/***/ }),
/* 29 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTileIdByRawValues", function() { return getTileIdByRawValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTileId", function() { return getTileId; });
function getTileIdByRawValues(x, y, zoom) {
    return `${x}:${y}:${zoom}`;
}
function getTileId(tile) {
    return getTileIdByRawValues(tile.x, tile.y, tile.zoom);
}


/***/ }),
/* 30 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NO_ID", function() { return NO_ID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "messageIs", function() { return messageIs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebWorkerCommunicator", function() { return WebWorkerCommunicator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebWorkerClient", function() { return WebWorkerClient; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebWorkerImplementation", function() { return WebWorkerImplementation; });
/* harmony import */ var _event_emitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(14);
/* harmony import */ var _unique_id__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(31);
/**
 * Base interface for webworker messages, both incoming and outgoing ones.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Transferable
 */


const MESSAGE_BATCH_MAX_SIZE = 50;
const FLUSH_TIMEOUT = 50;
// each subsequent message debounces postMessage call, that can lead to infinite delay, this const limits it
const MAX_FLUSH_TIMEOUT = 250;
const NO_ID = -1;
/**
 * Checks message type with type guarding. It gives a little bit more elegant alternative
 * to tagged type unions providing the same type safety.
 *
 * @param message to be checked
 * @param type the value of the "type" property
 * @return {boolean}
 */
function messageIs(message, type) {
    return message.type === type;
}
/**
 * Base class for both sides of a webworker: its implementation (separate js that is run in a worker thread) and
 * a controller for the main thread. They have similar mechanism of sending/receiving messages that is implement here.
 */
class WebWorkerCommunicator {
    constructor(addressee) {
        this._addressee = addressee;
        this._events = new _event_emitter__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this._listeners = new Map();
        this._transferableExtractors = new Map();
        this._messages = [];
        this._transferables = [];
        this._timeoutHandle = 0;
        this._flushMessagesBinded = this._flushMessages.bind(this);
    }
    setTransferableExtractor(type, extractor) {
        this._transferableExtractors.set(type, extractor);
    }
    /**
     * Send a message to the opposite side of the web worker communication channel.
     * Messages are batched by delaying postMessage call to group messages that come during this delay and minimize
     * the number of interprocess communications that badly affect performance.
     *
     * @param message Message to be sent.
     * @param urgency IMMEDIATE forces message to be sent immediately (synchronous call) with no batching delay,
     *                DEFAULT debounces sending for another FLUSH_TIMEOUT.
     */
    sendMessage(message, urgency = 0 /* DEFAULT */) {
        const transferableExtractor = this._transferableExtractors.get(message.type);
        const transferables = transferableExtractor ? transferableExtractor(message) : undefined;
        const isFirstMessageInBatch = (this._messages.length === 0);
        if (isFirstMessageInBatch) {
            this._firstMessageTime = performance.now();
        }
        // Send messages asynchronously packing them into one message.
        // We don't want to abuse the web worker communication channel and
        // send messages asynchronously in short period of time or many messages synchronously.
        this._messages.push(message);
        if (transferables) {
            this._transferables = this._transferables.concat(transferables);
        }
        clearTimeout(this._timeoutHandle);
        if (this._messages.length > MESSAGE_BATCH_MAX_SIZE ||
            urgency === 1 /* IMMEDIATE */ ||
            (!isFirstMessageInBatch && (performance.now() - this._firstMessageTime) > MAX_FLUSH_TIMEOUT)) {
            this._flushMessages();
        }
        else {
            this._timeoutHandle = setTimeout(this._flushMessagesBinded, FLUSH_TIMEOUT);
        }
    }
    /**
     * Sends request message to/from worker as promise, the other side can respond and the promise is resolved.
     * Request/response is synchronized by the requestId field.
     */
    request(request, urgency) {
        return new Promise((resolve, reject) => {
            if (request.requestId === NO_ID) {
                request.requestId = Object(_unique_id__WEBPACK_IMPORTED_MODULE_1__["uniqueId"])();
            }
            const listener = (message) => {
                if (messageIs(message, request.responseType) &&
                    message.requestId === request.requestId) {
                    resolve(message);
                    this._events.removeListener(listener);
                }
                if (messageIs(message, request.errorType) &&
                    message.requestId === request.requestId) {
                    reject();
                    this.off(listener);
                }
            };
            this._events.addListener(listener);
            this.sendMessage(request, urgency);
        });
    }
    /**
     * Responds to provided request.
     */
    respond(request, response, urgency) {
        response.requestId = request.requestId;
        this.sendMessage(response, urgency);
    }
    /**
     * Sets a listener to specific type of incoming messages.
     */
    on(type, listener) {
        const typeSafeListener = (message) => {
            if (messageIs(message, type)) {
                listener(message);
            }
        };
        this._listeners.set(listener, typeSafeListener);
        this._events.addListener(typeSafeListener);
    }
    /**
     * Removes incoming messages listener.
     */
    off(listener) {
        const typeSafeListener = this._listeners.get(listener);
        if (typeSafeListener) {
            this._events.removeListener(typeSafeListener);
        }
    }
    /**
     * Starts listening for incoming messages.
     */
    listen() {
        this._addressee.onmessage = ({ data: messages }) => {
            for (const message of messages) {
                this.onMessage(message);
            }
        };
    }
    /**
     * Handler of incoming messages.
     */
    onMessage(message) {
        this._events.fire(message);
    }
    _flushMessages() {
        this._addressee.postMessage(this._messages, this._transferables);
        this._messages.length = 0;
        this._transferables.length = 0;
    }
}
/**
 * Base class for a webworker controller for the main thread code.
 * It also wraps creation of a native Worker.
 */
class WebWorkerClient extends WebWorkerCommunicator {
    /**
     * @param url URL of webworker's deployed js file
     */
    constructor(url) {
        const worker = new Worker(url);
        super(worker);
        this._worker = worker;
        this.listen();
    }
    destroy() {
        this._worker.terminate();
    }
}
/**
 * Base class for a webworker thread implementation. Concrete class should be the entry point for a webworker js build:
 *     new ConcreteWebWorkerImplementation(<DedicatedWorkerGlobalScope>self).run();
 */
class WebWorkerImplementation extends WebWorkerCommunicator {
    run() {
        this.listen();
    }
}


/***/ }),
/* 31 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "uniqueId", function() { return uniqueId; });
let id = 1;
/**
 * Generates unique id
*/
function uniqueId() {
    return id++;
}


/***/ }),
/* 32 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "computeVisibleTiles", function() { return computeVisibleTiles; });
const TILE_0_0_0 = { x: 0, y: 0, zoom: 0 };
/**
 * Computes set of tiles visible through a camera. Tiles in the set are guaranteed
 * to be unique.
 *
 * FIXME(dmikis) The uniqueness guarantee is broken currently, but code that uses
 *      this function doesn't suffer from that.
 *
 * @param camera The camera.
 * @returns An iterator over visible tile items.
 */
function* computeVisibleTiles(visibleRegion, visibleRegionBBox, wrapModeX, wrapModeY, zoom) {
    if (zoom === 0) {
        // The only tile on zoom 0 encompasses the whole world. Thus there's
        // little to no point computing that camera sees it: we can tell that
        // right away.
        yield TILE_0_0_0;
        return;
    }
    const tileCount = 1 << zoom;
    const tileIdxMask = tileCount - 1;
    // The idea behind the code below is quite simple: determine columns of the
    // tile grid that are visible to the camera, then for each column find
    // range of row indices that are visible.
    // Here's how we approach computing tile indices from world coordinates.
    // First, we transform world coordinates from [-1, 1] range to [0, 2],
    // dealing with inconsistency with Y axis direction in world and tile grid
    // coordinate system. Let's designate such a coordinate as C (for either X
    // or Y). Size of a tile is 2 / tileCount. Thus,
    //
    //      tileIdx = Math.floor(C / (2 / tileCount))
    //              = Math.floor(C * tileCount / 2)
    //
    const { minX, maxX, minY, maxY } = visibleRegionBBox;
    const minTX = Math.floor((minX + 1) * tileCount / 2);
    const maxTX = Math.floor((maxX + 1) * tileCount / 2);
    const columnCount = maxTX - minTX + 1;
    // Arrays of indices of bottommost and topmost tiles correspondingly for
    // each column.
    // FIXME(dmikis) If number of columns is too large, we'll consume a lot of
    //      memory here. There's a method to do without the arrays, but it's a
    //      bit more complicated to implement.
    const minYs = new Array(columnCount);
    const maxYs = new Array(columnCount);
    // Common sense suggests that those indices can't be greater (less) than the
    // index of a tile row intersected by a line y = minY (y = maxY). Note that
    // maxY corresponds to a tile row with lesser index, not other way around.
    minYs.fill(Math.floor((1 - minY) * tileCount / 2));
    maxYs.fill(Math.floor((1 - maxY) * tileCount / 2));
    const visiblePolygonLength = visibleRegion.length;
    let prevX = visibleRegion[visiblePolygonLength - 1].x + 1;
    let prevY = 1 - visibleRegion[visiblePolygonLength - 1].y;
    let prevTX = Math.floor(prevX * tileCount / 2);
    let prevTY = Math.floor(prevY * tileCount / 2);
    // Iterate over edges of visible polygon of the camera to compute index of
    // topmost and bottommost tiles for each column.
    for (let i = 0; i < visiblePolygonLength; ++i) {
        const x = visibleRegion[i].x + 1;
        const y = 1 - visibleRegion[i].y;
        const tx = Math.floor(x * tileCount / 2);
        const ty = Math.floor(y * tileCount / 2);
        // For each edge we compute 4-connected line of tiles on the tile grid.
        // Length of a 4-connected line always equals Manhattan distance between
        // its ends. However, to avoid unnecessary computation, we omit last tile
        // for every edge. But, since the polygon is closed, we'll iterate over
        // all tiles intersected by edges anyway.
        const l = Math.abs(tx - prevTX) + Math.abs(ty - prevTY);
        const lx = x - prevX;
        const ly = y - prevY;
        const dtx = lx > 0 ? 1 : -1;
        const dty = ly > 0 ? 1 : -1;
        const a = 2 * dtx * ly;
        const b = -2 * dtx * lx;
        const c = dtx * tileCount * (lx * prevY - ly * prevX) + a * (~dtx >>> 31);
        for (let i = 0, tx = prevTX, ty = prevTY; i < l; ++i) {
            const intercept = a * tx + b * ty + c;
            // The math here is somewhat cumbersome to avoid divisions, but the
            // essence is that we try to check through which side the edge of
            // visible polygon exits the tile. Depending on that we "move" to
            // next tile in either vertical or horizontal direction.
            if (0 <= intercept && intercept <= -b) {
                tx += dtx;
            }
            else {
                ty += dty;
            }
            const yIdx = tx - minTX;
            if (maxYs[yIdx] < ty) {
                maxYs[yIdx] = ty;
            }
            if (minYs[yIdx] > ty) {
                minYs[yIdx] = ty;
            }
        }
        prevX = x;
        prevY = y;
        prevTX = tx;
        prevTY = ty;
    }
    // If the world is repeated along X axis, we need to "fold" the array of columns,
    // i.e. compute union of row intervals for columns tileCount indices apart.
    if (wrapModeX === 2 /* REPEAT */ && columnCount > tileCount) {
        for (let i = 0; i < tileCount; ++i) {
            for (let j = i + tileCount; j < columnCount; j += tileCount) {
                if (maxYs[i] < maxYs[j]) {
                    maxYs[i] = maxYs[j];
                }
                if (minYs[i] > minYs[j]) {
                    minYs[i] = minYs[j];
                }
            }
        }
    }
    // If the world is repeated along Y axis, we need to wrap indices in minYs
    // and maxYs arrays to [0, tileCount) interval.
    if (wrapModeY === 2 /* REPEAT */) {
        for (let i = 0; i < columnCount && i < tileCount; ++i) {
            const dy = maxYs[i] - minYs[i];
            // If there's more than tileCount rows between maxY and minY, then the
            // world is encompassed somewhere within visible region.
            if (dy > tileCount) {
                minYs[i] = 0;
                maxYs[i] = tileIdxMask;
            }
            else {
                const minY = minYs[i] &= tileIdxMask;
                maxYs[i] = minY + dy;
            }
        }
    }
    else {
        for (let i = 0; i < columnCount && i < tileCount; ++i) {
            minYs[i] = Math.max(minYs[i], 0);
            maxYs[i] = Math.min(maxYs[i], tileIdxMask);
        }
    }
    if (wrapModeX === 2 /* REPEAT */) {
        for (let i = 0; i < columnCount && i < tileCount; ++i) {
            const tx = (i + minTX) & tileIdxMask;
            for (let ty = minYs[i]; ty <= maxYs[i]; ++ty) {
                yield {
                    x: tx,
                    y: ty & tileIdxMask,
                    zoom
                };
            }
        }
    }
    else {
        for (let tx = Math.max(minTX, 0), txEnd = Math.min(maxTX, tileIdxMask); tx <= txEnd; ++tx) {
            const i = tx - minTX;
            for (let ty = minYs[i]; ty <= maxYs[i]; ++ty) {
                yield {
                    x: tx,
                    y: ty & tileIdxMask,
                    zoom
                };
            }
        }
    }
}


/***/ }),
/* 33 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "calculateBeltTiles", function() { return calculateBeltTiles; });
/* harmony import */ var _tile_id__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(29);
/* harmony import */ var _math_vector2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(23);
/* harmony import */ var _math_scalar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(16);



const LEFT_SIDE = {
    direction: _math_vector2__WEBPACK_IMPORTED_MODULE_1__["create"](0, -1),
    normal: _math_vector2__WEBPACK_IMPORTED_MODULE_1__["create"](-1, 0),
    diagonal: _math_vector2__WEBPACK_IMPORTED_MODULE_1__["create"](-1, -1),
    prevSide: () => BOTTOM_SIDE,
    nextSide: () => TOP_SIDE
};
const RIGHT_SIDE = {
    direction: _math_vector2__WEBPACK_IMPORTED_MODULE_1__["create"](0, +1),
    normal: _math_vector2__WEBPACK_IMPORTED_MODULE_1__["create"](+1, 0),
    diagonal: _math_vector2__WEBPACK_IMPORTED_MODULE_1__["create"](+1, +1),
    prevSide: () => TOP_SIDE,
    nextSide: () => BOTTOM_SIDE
};
const TOP_SIDE = {
    direction: _math_vector2__WEBPACK_IMPORTED_MODULE_1__["create"](+1, 0),
    normal: _math_vector2__WEBPACK_IMPORTED_MODULE_1__["create"](0, -1),
    diagonal: _math_vector2__WEBPACK_IMPORTED_MODULE_1__["create"](+1, -1),
    prevSide: () => LEFT_SIDE,
    nextSide: () => RIGHT_SIDE
};
const BOTTOM_SIDE = {
    direction: _math_vector2__WEBPACK_IMPORTED_MODULE_1__["create"](-1, 0),
    normal: _math_vector2__WEBPACK_IMPORTED_MODULE_1__["create"](0, +1),
    diagonal: _math_vector2__WEBPACK_IMPORTED_MODULE_1__["create"](-1, +1),
    prevSide: () => RIGHT_SIDE,
    nextSide: () => LEFT_SIDE
};
/**
 * Adds tile to belt tiles if it doesn't fall out of the world. Cycling coordinates can't fall out,
 * they just got adjusted directly in tile item.
 */
function addTileIfAppropriate(tile, beltTiles, maxCoordinate, isXCycled, isYCycled) {
    tile.x = isXCycled ? Object(_math_scalar__WEBPACK_IMPORTED_MODULE_2__["cycleRestrict"])(tile.x, 0, maxCoordinate) : tile.x;
    tile.y = isYCycled ? Object(_math_scalar__WEBPACK_IMPORTED_MODULE_2__["cycleRestrict"])(tile.y, 0, maxCoordinate) : tile.y;
    if ((0 <= tile.x) && (tile.x < maxCoordinate) &&
        (0 <= tile.y) && (tile.y < maxCoordinate)) {
        beltTiles.set(Object(_tile_id__WEBPACK_IMPORTED_MODULE_0__["getTileId"])(tile), tile);
    }
}
/**
 * The algorithm is implemented as a state machine, this method produces belt tiles and sets appropriate state.
 * How to change this state (determine current tile and its side) is described in four TileSide implementations:
 * left, right, top and bottom.
 */
function move(tiles, state, size, maxCoordinate, isXCycled, isYCycled) {
    // add tiles outward in the direction of the normal
    for (let i = 1; i <= size; i++) {
        addTileIfAppropriate({
            x: state.currentTile.x + i * state.currentTileSide.normal.x,
            y: state.currentTile.y + i * state.currentTileSide.normal.y,
            zoom: state.currentTile.zoom
        }, state.beltTiles, maxCoordinate, isXCycled, isYCycled);
    }
    // check diagonal tile
    const diagonalNeighbour = tiles.get(Object(_tile_id__WEBPACK_IMPORTED_MODULE_0__["getTileIdByRawValues"])(state.currentTile.x + state.currentTileSide.diagonal.x, state.currentTile.y + state.currentTileSide.diagonal.y, state.currentTile.zoom));
    if (diagonalNeighbour) {
        state.currentTile = diagonalNeighbour;
        state.currentTileSide = state.currentTileSide.prevSide();
        return;
    }
    // check neighbour in the same direction
    const neighbour = tiles.get(Object(_tile_id__WEBPACK_IMPORTED_MODULE_0__["getTileIdByRawValues"])(state.currentTile.x + state.currentTileSide.direction.x, state.currentTile.y + state.currentTileSide.direction.y, state.currentTile.zoom));
    if (neighbour) {
        state.currentTile = neighbour;
        return;
    }
    // handle corner tiles
    for (let i = 1; i <= size; i++) {
        for (let j = 1; j <= size; j++) {
            addTileIfAppropriate({
                x: state.currentTile.x + i * state.currentTileSide.diagonal.x,
                y: state.currentTile.y + j * state.currentTileSide.diagonal.y,
                zoom: state.currentTile.zoom
            }, state.beltTiles, maxCoordinate, isXCycled, isYCycled);
        }
    }
    state.currentTileSide = state.currentTileSide.nextSide();
}
/**
 * Calculates tiles that surround provided region (set of tiles), the region must be one or more convex polygons
 * with no holes, otherwise correctness is not guaranteed. Multiple polygons can happen when the camera looks
 * at the edge of the world capturing cycled tiles from different sides.
 * The logic of including tiles in the "belt" is as follows: shortest distance from "outside" to any point
 * in the original region should be not less than tileSize * beltSize.
 *
 * @param tiles Set of tiles that cover a convex polygon.
 * @param beltSize "thickness" (in tiles) of the surrounding area.
 */
function calculateBeltTiles(tiles, beltSize, isXCycled, isYCycled) {
    // the algorithm in simple words:
    //   1. find a tile on an edge of the polygon (e.g. one of the leftmost ones)
    //   2. go around the polygon tile-by-tile adding surrounding tiles outwardly
    const indexedTiles = new Map();
    const beltTiles = new Map();
    // index tiles
    for (const tileItem of tiles) {
        indexedTiles.set(Object(_tile_id__WEBPACK_IMPORTED_MODULE_0__["getTileId"])(tileItem), tileItem);
    }
    // tiles are grouped into one or more convex polygons, process these polygons one by one
    const tilesToProcess = new Map(indexedTiles);
    while (tilesToProcess.size > 0) {
        let leftmostTile = { x: Number.POSITIVE_INFINITY, y: 0, zoom: 0 };
        // find the leftmost tile to start walking from
        for (const tileItem of tilesToProcess.values()) {
            if (tileItem.x < leftmostTile.x) {
                leftmostTile = tileItem;
            }
        }
        // save min/max y value per x coordinate to be able
        // to mark these tiles as processed (remove from tilesToProcess)
        const maxY = [];
        const minY = [];
        const initState = { currentTile: leftmostTile, currentTileSide: LEFT_SIDE, beltTiles };
        const state = Object.assign({}, initState);
        const maxCoordinate = Math.pow(2, leftmostTile.zoom);
        do {
            // move around while we don't reach the init position
            move(tilesToProcess, state, beltSize, maxCoordinate, isXCycled, isYCycled);
            const index = state.currentTile.x - initState.currentTile.x;
            maxY[index] = maxY[index] === undefined ? state.currentTile.y : Math.max(maxY[index], state.currentTile.y);
            minY[index] = minY[index] === undefined ? state.currentTile.y : Math.min(minY[index], state.currentTile.y);
        } while (state.currentTile !== initState.currentTile ||
            state.currentTileSide !== initState.currentTileSide);
        // mark tiles from current polygon as processed
        const zoom = leftmostTile.zoom;
        for (let i = 0; i < maxY.length; i++) {
            const x = leftmostTile.x + i;
            for (let y = minY[i]; y <= maxY[i]; y++) {
                tilesToProcess.delete(Object(_tile_id__WEBPACK_IMPORTED_MODULE_0__["getTileIdByRawValues"])(x, y, zoom));
            }
        }
    }
    // remove belt tiles that overlaps to avoid duplications
    for (const tileId of beltTiles.keys()) {
        if (indexedTiles.has(tileId)) {
            beltTiles.delete(tileId);
        }
    }
    return beltTiles.values();
}


/***/ }),
/* 34 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "countFps", function() { return countFps; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "countTileParseTime", function() { return countTileParseTime; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "countTileProcessingTime", function() { return countTileProcessingTime; });
const PROJECT_ID = 443;
function chooseStatUrl() {
    // FIXME(dmikis) Ideally we should be get this URLs from config.
    const STAT_URLS = {
        ru: 'https://yandex.ru/clck',
        com: 'https://yandex.com/clck',
        tr: 'https://yandex.com.tr/clck'
    };
    const tld = location.hostname.split('.').pop();
    switch (tld) {
        case 'tr':
            return STAT_URLS.tr;
        case 'com':
        case 'fr':
            return STAT_URLS.com;
        default:
            return STAT_URLS.ru;
    }
}
const STAT_URL = chooseStatUrl();
function stringifyVars(vars) {
    return Object.keys(vars).map((key) => `${key}=${vars[key]}`).join(',');
}
function count(pid, cid, path, vars) {
    const url = `${STAT_URL}/counter`;
    const data = `/dtype=stred/pid=${pid}/cid=${cid}` +
        `/path=${path.join('.')}/${vars ? `vars=${stringifyVars(vars)}/` : ''}`;
    if (!(navigator.sendBeacon && navigator.sendBeacon(url, data + '*'))) {
        const image = new Image();
        image.src = url + data + `rnd=${Date.now()}${Math.random() * 100 | 0}/*`;
    }
}
const PERF_COUNTER_ID = 73323;
/**
 * Log user's rendering perf to statface.
 *
 * @param fps FPS
 */
function countFps(fps) {
    const roundedFps = Math.floor(fps / 10) * 10;
    count(PROJECT_ID, PERF_COUNTER_ID, ['fps', `${roundedFps}-${roundedFps + 10}`, (fps * 100).toFixed()]);
}
function encodeTileItem(tileItem) {
    return `${tileItem.x}.${tileItem.y}.${tileItem.zoom}`;
}
function countTileParseTime(layer, minTimeTile, minTime, maxTimeTile, maxTime, medianTimeTile, medianTime) {
    count(PROJECT_ID, PERF_COUNTER_ID, [
        'tile_parse',
        layer
    ], {
        minTime: minTime.toFixed(),
        medianTime: medianTime.toFixed(),
        maxTime: maxTime.toFixed(),
        minTileItem: encodeTileItem(minTimeTile),
        medianTileItem: encodeTileItem(medianTimeTile),
        maxTileItem: encodeTileItem(maxTimeTile)
    });
}
function countTileProcessingTime(layer, items) {
    const varsToLog = {};
    items.forEach((item) => {
        if (item.zoom === 'average') {
            count(PROJECT_ID, PERF_COUNTER_ID, [
                'tile_processing_average',
                layer,
                (Math.ceil(item.time / 250) * 250).toString()
            ]);
        }
        varsToLog[item.zoom] = item.time.toFixed();
    });
    count(PROJECT_ID, PERF_COUNTER_ID, ['tile_processing', layer], varsToLog);
}


/***/ }),
/* 35 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return IconBufferWriter; });
/* harmony import */ var _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _util_buffer_writer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(36);


/**
 * Writer of geometry data of icons.
 */
class IconBufferWriter extends _util_buffer_writer__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor() {
        super(IconBufferWriter.ATTRIBUTE_MAPPING.vertexByteSize);
    }
    /**
     * Writes an icon to buffers.
     *
     * @param icon Icon to be written to buffer.
     * @param location Image location in atlas.
     * @param size Image size in atlas.
     * @param offset Offset of image points in CSS pixels.
     * @param pixelRatio Ratio of image size in CSS pixels to the size in atlas pixels.
     *
     * @returns Location of the icon data in buffers.
     */
    writeIcon(icon, location, size, offset, pixelRatio) {
        const top = offset.y;
        const bottom = offset.y + size.height * pixelRatio;
        const left = offset.x;
        const right = offset.x + size.width * pixelRatio;
        this.writeVertex(icon.position, left, bottom, location.minX, location.minY);
        this.writeVertex(icon.position, left, top, location.minX, location.maxY);
        this.writeVertex(icon.position, right, bottom, location.maxX, location.minY);
        this.writeVertex(icon.position, right, top, location.maxX, location.maxY);
        this.writeIndicesForContinuousStrip(4);
        return this.endMesh();
    }
    /**
     * Writes a vertex to the vertex buffer.
     *
     * @param position Position of the vertex in display coordinates.
     * @param uv UVs of the vertex.
     * @return Index of the written vertex.
     */
    writeVertex(position, displacementX, displacementY, uvX, uvY) {
        const vertexIdx = this.getCurrentVertexIdx();
        this._writeWorldCoordinate(position);
        this._writeHalfWords(displacementX, displacementY);
        this._writeHalfWords(uvX, uvY);
        return vertexIdx;
    }
}
/** Description of how a writer stores vertex data. */
IconBufferWriter.ATTRIBUTE_MAPPING = new _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__["AttributeMapping"]([
    [
        0 /* POSITION_HIGH */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        1 /* POSITION_LOW */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        6 /* DISPLACEMENT */,
        {
            size: 2,
            type: 5122 /* SHORT */,
            normalized: false
        }
    ],
    [
        4 /* UV */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: false
        }
    ]
]);


/***/ }),
/* 36 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WORD_BYTE_SIZE", function() { return WORD_BYTE_SIZE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BufferWriter; });
/* harmony import */ var _gputypes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(38);


const WORD_BYTE_SIZE = 4;
/**
 * Generates triangles of a fan of a given length as if it is continuous and
 * starts with 0.
 *
 * @param count Number of vertices in the fan.
 * @returns Iterator over indices of triangles.
 */
function* generateFan(count) {
    for (let i = 2; i < count; ++i) {
        yield 0;
        yield i - 1;
        yield i;
    }
}
/**
 * Generates triangles of a strip of a given length as if it is continuous and
 * starts with 0.
 *
 * @param count Number of vertices in the fan.
 * @returns Iterator over indices of triangles.
 */
function* generateStrip(count) {
    yield 0;
    yield 1;
    yield 2;
    let offset0 = 1;
    let offset1 = 2;
    for (let i = 3; i < count; ++i) {
        yield i - offset0;
        yield i - offset1;
        yield i;
        const tmp = offset0;
        offset0 = offset1;
        offset1 = tmp;
    }
}
/**
 * Vertex buffer helper class, that supports sequential writing interface and takes over some single-buffer operations.
 * It is an integral part of the buffer writer class and its main purpose is to make the writer's code easier.
 */
class VertexBuffer {
    /**
     * @param byteSize Initial size of the buffer in bytes. As it gets filled by words
     *      the size must be a multiply of 4.
     */
    constructor(byteSize) {
        this._nextWordOffset = 0;
        this._initBuffers(byteSize);
    }
    /**
     * @returns true if there is no free space remaining in buffer.
     */
    get isFull() {
        return this._nextWordOffset >= this._uint32View.length;
    }
    /**
     * @returns The number of words (4 bytes values) already written.
     */
    get occupiedSize() {
        return this._nextWordOffset;
    }
    /**
     * @return Max number of bytes this buffer is able to store. It can be increased by the extend() method.
     */
    get byteSize() {
        return this._uint32View.byteLength;
    }
    /**
     * Extends buffer to the new size. The new size must be not less than current one and it must be a multiply of 4.
     */
    extend(newByteSize) {
        // TODO assert newByteLength is larger than current _arrayBuffer and its is a multiply of the word size.
        const oldUint32View = this._uint32View;
        this._initBuffers(newByteSize);
        this._uint32View.set(oldUint32View);
    }
    /**
     * Appends value as a uint32 number.
     */
    pushUint32(value) {
        this._uint32View[this._nextWordOffset++] = value;
    }
    /**
     * Appends value as a float32 number.
     */
    pushFloat32(value) {
        this._float32View[this._nextWordOffset++] = value;
    }
    /**
     * @returns uint8 view of this buffer. The size of the view matches the amount of written data.
     */
    asUint32Array() {
        return this._uint32View.subarray(0, this.occupiedSize);
    }
    _initBuffers(byteLength) {
        const arrayBuffer = new ArrayBuffer(byteLength);
        this._uint32View = new Uint32Array(arrayBuffer);
        this._float32View = new Float32Array(arrayBuffer);
    }
    /**
     * Moves "tail" data (from the offset specified to the end of the buffer) of one buffer to another. The cursors of
     * buffers will be appropriately updated to reflect data changes.
     */
    static transferDataTail(src, dst, srcWordOffset, dstOffset = 0) {
        const tailLength = src.occupiedSize - srcWordOffset;
        const srcTail = src._uint32View.subarray(srcWordOffset, src.occupiedSize);
        dst._uint32View.set(srcTail, dstOffset);
        dst._nextWordOffset = tailLength;
        src._nextWordOffset = srcWordOffset;
    }
}
/**
 * Index buffer helper class, that supports sequential writing interface and takes over some single-buffer operations.
 * It is an integral part of the buffer writer class and its main purpose is to make the writer's code easier.
 */
class IndexBuffer {
    /**
     * @param size Initial size of the buffer.
     */
    constructor(size) {
        this._nextIndexOffset = 0;
        this._uint16View = new Uint16Array(size);
    }
    /**
     * @returns The number of indices already written.
     */
    get occupiedSize() {
        return this._nextIndexOffset;
    }
    /**
     * @return Max number of indices this buffer is able to store. It can be increased by the extend() method.
     */
    get size() {
        return this._uint16View.length;
    }
    /**
     * Extends buffer to the new size.
     */
    extend(newSize) {
        // TODO assert newByteLength is larger than current _arrayBuffer
        const oldUint16View = this._uint16View;
        this._uint16View = new Uint16Array(newSize);
        this._uint16View.set(oldUint16View);
    }
    /**
     * Appends index to the end of the buffer.
     */
    push(index) {
        this._uint16View[this._nextIndexOffset++] = index;
    }
    /**
     * @returns uint16 view of this buffer. The size of the view matches the amount of written data.
     */
    asUint16Array() {
        return new Uint16Array(this._uint16View.buffer, 0, this.occupiedSize);
    }
    /**
     * Moves "tail" data (from the offset specified to the end of the buffer) of one buffer to another. The offsets of
     * buffers will be appropriately updated to reflect data changes.
     * baseIndex will be deducted from all moved indices.
     */
    static transferDataTail(src, dst, baseIndex, srcOffset, dstOffset = 0) {
        for (let i = srcOffset, j = dstOffset; i < src.occupiedSize; i++, j++) {
            dst._uint16View[j] = src._uint16View[i] - baseIndex;
        }
        dst._nextIndexOffset = src.occupiedSize - srcOffset;
        src._nextIndexOffset = srcOffset;
    }
}
/**
 * Base buffer writer implementation. Can write unsigned short indices and
 * provides facilities for child classes to handle writing vertex data. Defines
 * a concept of current mesh. Basically, it mean that all vertices and indices
 * written to a writer between two `endMesh` calls (or construction of the writer
 * and an `endMesh` call) must be considered belonging to one atomic piece of
 * geometry and should not be spitted between separate buffers.
 */
class BufferWriter {
    /**
     * Creates a new writer and allocates initial amount of memory to store data.
     * Also implicitly "start" a mesh.
     *
     * @param vertexByteSize
     * @param initVertexBufferSize Init size (in vertices) of growing vertex buffers.
     * @param maxVertexBufferSize Max size (in vertices) of vertex buffers.
     * @param initIndexBufferUint16Size Init size (in uint16 number) of growing index buffers.
     */
    constructor(vertexByteSize, initVertexBufferSize = 0x400, maxVertexBufferSize = 0x10000, initIndexBufferUint16Size = 0xc00) {
        this._vertexByteSize = vertexByteSize;
        this._initVertexBufferByteSize = vertexByteSize * initVertexBufferSize;
        this._maxVertexBufferByteSize = vertexByteSize * maxVertexBufferSize;
        this._initIndexBufferUint16Size = initIndexBufferUint16Size;
        this._vertexBuffer = new VertexBuffer(this._initVertexBufferByteSize);
        this._vertexBuffers = [this._vertexBuffer];
        this._indexBuffer = new IndexBuffer(this._initIndexBufferUint16Size);
        this._indexBuffers = [this._indexBuffer];
        this._currentMeshVertexOffset = 0;
        this._currentMeshIndexOffset = 0;
        this._currentMeshBaseIndex = 0;
    }
    /**
     * Writes a bunch of indices to the underlying storage as unsigned short
     * numbers. If current storage doesn't have enough space to accommodate
     * given indices, the writer will automatically resize it. The writer
     * automatically adds base index to the supplied values, so from a user
     * point of view first vertex of a mesh has index 0 and there's no need
     * to take into account it's offset while generating mesh's topology.
     *
     * @param indices Array of indices to write.
     */
    writeIndices(indices) {
        this._ensureEnoughIndexBufferSpace(indices.length);
        const buffer = this._indexBuffer;
        const baseIndex = this._currentMeshBaseIndex;
        for (let i = 0; i < indices.length; ++i) {
            buffer.push(baseIndex + indices[i]);
        }
    }
    /**
     * Generates triangle indices from an array of indices of a triangle strip
     * (as in GL) and writes generated triplets to the managed index buffer.
     * @see OpenGL ES 2.0 Spec, 2.6.1
     *
     * @param indices Indices of the strip.
     */
    writeIndicesForStrip(indices) {
        this._ensureEnoughIndexBufferSpace(3 * (indices.length - 2));
        const buffer = this._indexBuffer;
        const baseIndex = this._currentMeshBaseIndex;
        for (const i of generateStrip(indices.length)) {
            buffer.push(baseIndex + indices[i]);
        }
    }
    /**
     * Generates triangle indices from a continuous triangle strip of a given
     * length and writes generated triplets to managed index buffer.
     * @see OpenGL ES 2.0 Spec, 2.6.1
     *
     * @param indexCount
     * @param baseIndexInMesh
     */
    writeIndicesForContinuousStrip(indexCount, baseIndexInMesh = 0) {
        this._ensureEnoughIndexBufferSpace(3 * (indexCount - 2));
        const buffer = this._indexBuffer;
        const baseIndex = this._currentMeshBaseIndex + baseIndexInMesh;
        for (const i of generateStrip(indexCount)) {
            buffer.push(baseIndex + i);
        }
    }
    /**
     * Generates triangle indices from an array of indices of a triangle fan (as
     * in GL) and writes generated triplets to the managed index buffer.
     * @see OpenGL ES 2.0 Spec, 2.6.1
     *
     * @param indices Indices of the strip.
     */
    writeIndicesForFan(indices) {
        this._ensureEnoughIndexBufferSpace(3 * (indices.length - 2));
        const buffer = this._indexBuffer;
        const baseIndex = this._currentMeshBaseIndex;
        for (const i of generateFan(indices.length)) {
            buffer.push(baseIndex + indices[i]);
        }
    }
    /**
     * Generates triangle indices from a continuous triangle fan of a given length
     * and writes generated triplets to managed index buffer.
     * @see OpenGL ES 2.0 Spec, 2.6.1
     *
     * @param indexCount
     * @param baseIndexInMesh
     */
    writeIndicesForContinuousFan(indexCount, baseIndexInMesh = 0) {
        this._ensureEnoughIndexBufferSpace(3 * (indexCount - 2));
        const buffer = this._indexBuffer;
        const baseIndex = baseIndexInMesh + this._currentMeshBaseIndex;
        for (const i of generateFan(indexCount)) {
            buffer.push(baseIndex + i);
        }
    }
    /**
     * Ends current mesh and implicitly starts a new one.
     *
     * @returns Internal index of vertex and index buffers the mesh was written
     *      to and its memory location in them.
     */
    endMesh() {
        const currentMeshVertexOffset = this._currentMeshVertexOffset;
        const vertexOccupiedSize = this._vertexBuffer.occupiedSize;
        this._currentMeshVertexOffset = vertexOccupiedSize;
        this._currentMeshBaseIndex = (vertexOccupiedSize << 2) / this._vertexByteSize;
        const currentMeshIndexOffset = this._currentMeshIndexOffset;
        const indexOccupiedSize = this._indexBuffer.occupiedSize;
        this._currentMeshIndexOffset = indexOccupiedSize;
        return {
            vertexByteOffset: currentMeshVertexOffset << 2,
            vertexByteLength: vertexOccupiedSize - currentMeshVertexOffset << 2,
            indexByteOffset: currentMeshIndexOffset << 1,
            indexByteLength: indexOccupiedSize - currentMeshIndexOffset << 1,
            // We can't return actual buffer reference since it can change if
            // the buffer gets reallocated.
            bufferIndex: this._vertexBuffers.length - 1
        };
    }
    /**
     * Returns an array of currently owned buffer data. This call's better
     * made when you're done with the writer since if the writer decides to
     * resize any of the buffers some of the references in the returned array
     * may become outdated.
     */
    getBuffers() {
        return Object(_array__WEBPACK_IMPORTED_MODULE_1__["zip"])(this._vertexBuffers, this._indexBuffers, (vertexBuffer, indexBuffer) => ({
            vertexBuffer: vertexBuffer.asUint32Array(),
            indexBuffer: indexBuffer.asUint16Array()
        }));
    }
    /**
     * Returns an offset in the current vertex buffer to the location where next
     * piece of data will be written.
     */
    getCurrentVertexBufferByteOffset() {
        return this._vertexBuffer.occupiedSize << 2;
    }
    /**
     * Returns index of currently written vertex structure in the current vertex
     * buffer.
     */
    getCurrentVertexIdx() {
        return ((this._vertexBuffer.occupiedSize << 2) / this._vertexByteSize | 0) - this._currentMeshBaseIndex;
    }
    /**
     * Writes a floating point value to the current vertex buffer and advances
     * the offset by 4 bytes.
     *
     * @param value The value to be written.
     */
    _writeFloat32(value) {
        this._ensureEnoughVertexBufferSpace();
        this._vertexBuffer.pushFloat32(value);
    }
    /**
     * Writes an unsigned integer value to the current vertex buffer and advances
     * the offset by 4 bytes.
     *
     * @param value The value to be written.
     */
    _writeWord(value) {
        this._ensureEnoughVertexBufferSpace();
        this._vertexBuffer.pushUint32(value);
    }
    /**
     * Writes an unsigned short value to the current vertex buffer and advances
     * the offset by 2 bytes. Passed values will be truncated to 16 bits.
     *
     * @param value The value to be written.
     */
    _writeHalfWords(v1, v2) {
        this._writeWord(v2 << 16 | v1 & 0xffff);
    }
    /**
     * Writes an unsigned byte value to the current vertex buffer and advances
     * the offset by 1 byte. Passed values will be truncated to 8 bits.
     *
     * @param value The value to be written.
     */
    _writeBytes(v1, v2, v3, v4) {
        this._writeWord(v4 << 24 |
            (v3 & 0xff) << 16 |
            (v2 & 0xff) << 8 |
            v1 & 0xff);
    }
    /**
     * Encodes a world coordinate vector as a pair of 32-bit integers (splitting
     * them in turn into to 16-bit ones).
     *
     * @param c The world coordinate.
     */
    _writeWorldCoordinate(c) {
        // To avoid using GPU singed integer conversions we shift and scale world
        // coordinates so they're in [0, 1] range (instead of [-1, 1]) and then
        // encoded as unsigned 32 bit integers split into to 16 bit ones.
        const xUint32 = Object(_gputypes__WEBPACK_IMPORTED_MODULE_0__["floatToUint32"])(0.5 * (c.x + 1));
        const yUint32 = Object(_gputypes__WEBPACK_IMPORTED_MODULE_0__["floatToUint32"])(0.5 * (c.y + 1));
        this._writeHalfWords(xUint32 >>> 16, yUint32 >>> 16);
        this._writeHalfWords(xUint32, yUint32);
    }
    /**
     * Computes new bigger size of a vertex buffer based on its current size. By
     * default just double the current size.
     *
     * @param currentByteSize Current size of the index buffer in bytes.
     * @returns The new size.
     */
    _getNextVertexBufferByteSize(currentByteSize) {
        return currentByteSize << 1;
    }
    /**
     * Computes new bigger size of an index buffer based on its current size. By
     * default just double the current size.
     *
     * @param currentUint16Size Current size of the index buffer in shorts.
     * @returns The new size.
     */
    _getNextIndexBufferUint16Size(currentUint16Size) {
        return currentUint16Size << 1;
    }
    /**
     * Ensures that the managed vertex buffer has enough space to fit in a chunk
     * of data of a given size. Either does nothing, resizes the current vertex
     * buffer or creates entirely new pair of vertex and index buffers.
     *
     * @param valueSize Byte size of the data that needs to be accommodated by
     *      the vertex buffer.
     */
    _ensureEnoughVertexBufferSpace() {
        const vertexBuffer = this._vertexBuffer;
        if (!vertexBuffer.isFull) {
            // We have enough space, so nothing to be done.
            return;
        }
        if (vertexBuffer.byteSize < this._maxVertexBufferByteSize) {
            // If we can just resize the current vertex buffer, do that.
            this._vertexBuffer.extend(this._getNextVertexBufferByteSize(vertexBuffer.byteSize));
            return;
        }
        // If there's no enough space in the current vertex buffer and it's
        // already of maximum size, allocate new vertex and index buffers and
        // copy data of the current mesh to them from the current buffers.
        // Then make those buffer the current ones.
        const currentMeshVertexOffset = this._currentMeshVertexOffset;
        const currentMeshVertexByteSize = (vertexBuffer.occupiedSize - currentMeshVertexOffset) * 4;
        const maxVertexBufferByteSize = this._maxVertexBufferByteSize;
        if (currentMeshVertexByteSize === maxVertexBufferByteSize) {
            throw new Error('Mesh is too big to fit in.');
        }
        let newVertexBufferByteSize = this._initVertexBufferByteSize;
        // Initial vertex buffer size may be too small to accommodate the current
        // mesh, so we find next bigger size that is sufficient.
        while (newVertexBufferByteSize <= currentMeshVertexByteSize) {
            newVertexBufferByteSize = this._getNextVertexBufferByteSize(newVertexBufferByteSize);
        }
        const newVertexBuffer = new VertexBuffer(newVertexBufferByteSize);
        VertexBuffer.transferDataTail(vertexBuffer, newVertexBuffer, currentMeshVertexOffset);
        this._vertexBuffer = newVertexBuffer;
        this._vertexBuffers.push(newVertexBuffer);
        this._currentMeshVertexOffset = 0;
        const indexBuffer = this._indexBuffer;
        const currentMeshIndexOffset = this._currentMeshIndexOffset;
        const currentMeshIndexSize = indexBuffer.occupiedSize - currentMeshIndexOffset;
        let newIndexBufferSize = this._initIndexBufferUint16Size;
        // Initial index buffer size may be too small to accommodate the current
        // mesh, so we find next bigger size that is sufficient.
        while (newIndexBufferSize <= currentMeshIndexSize) {
            newIndexBufferSize = this._getNextIndexBufferUint16Size(newIndexBufferSize);
        }
        const newIndexBuffer = new IndexBuffer(newIndexBufferSize);
        // Since the current mesh's copied to the beginning of the new vertex
        // buffer, it's base index now is 0. If the mesh has any written indices,
        // they're already offset by the old base index.
        IndexBuffer.transferDataTail(indexBuffer, newIndexBuffer, this._currentMeshBaseIndex, currentMeshIndexOffset);
        this._currentMeshBaseIndex = 0;
        this._currentMeshIndexOffset = 0;
        this._indexBuffer = newIndexBuffer;
        this._indexBuffers.push(newIndexBuffer);
    }
    /**
     * Ensures that the managed index buffer has enough space to fit in a given
     * number of indices. Either does nothing or resizes the current index
     * buffer.
     *
     * @param indexCount Number of indices client wants to write to the managed
     *      index buffer.
     */
    _ensureEnoughIndexBufferSpace(indexCount) {
        const buffer = this._indexBuffer;
        const requiredSize = buffer.occupiedSize + indexCount;
        if (requiredSize <= buffer.size) {
            // We have enough space so nothing to be done.
            return;
        }
        let newBufferSize = buffer.size;
        // Let's compute new larger size of the index buffer until we can
        // accommodate incoming data.
        while (requiredSize > newBufferSize) {
            newBufferSize = this._getNextIndexBufferUint16Size(newBufferSize);
        }
        this._indexBuffer.extend(newBufferSize);
    }
}


/***/ }),
/* 37 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floatToUint8", function() { return floatToUint8; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floatToUint16", function() { return floatToUint16; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floatToInt16", function() { return floatToInt16; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floatToUint32", function() { return floatToUint32; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floatToInt32", function() { return floatToInt32; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "int32ToFloat", function() { return int32ToFloat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "uint32ToFloat", function() { return uint32ToFloat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "int16ToFloat", function() { return int16ToFloat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "uint16ToFloat", function() { return uint16ToFloat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "uint8ToFloat", function() { return uint8ToFloat; });
const UINT8_MAX = 0xff;
const UINT16_MAX = 0xffff;
const UINT32_MAX = 0xffffffff;
function floatToUint8(x) {
    return UINT8_MAX * x | 0;
}
function floatToUint16(x) {
    return x * UINT16_MAX | 0;
}
function floatToInt16(x) {
    return (x * UINT16_MAX - 1) / 2 | 0;
}
function floatToUint32(x) {
    return x * UINT32_MAX | 0;
}
function floatToInt32(x) {
    return (x * UINT32_MAX - 1) / 2 | 0;
}
function int32ToFloat(x) {
    return (2 * x + 1) / UINT32_MAX;
}
function uint32ToFloat(x) {
    return x / UINT32_MAX;
}
function int16ToFloat(x) {
    return (2 * x + 1) / UINT16_MAX;
}
function uint16ToFloat(x) {
    return x / UINT16_MAX;
}
function uint8ToFloat(x) {
    return x / UINT8_MAX;
}


/***/ }),
/* 38 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "swap", function() { return swap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reverse", function() { return reverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shuffle", function() { return shuffle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zip", function() { return zip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compare", function() { return compare; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "insertionSort", function() { return insertionSort; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mergeSort", function() { return mergeSort; });
/* harmony import */ var _comparator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(39);

/**
 * Swaps two values in an array.
 *
 * @param array The array.
 * @param i Index of a value to be swapped.
 * @param j Index of a value to be swapped.
 */
function swap(array, i, j) {
    const t = array[i];
    array[i] = array[j];
    array[j] = t;
}
/**
 * Reverses order of elements in a range in an array.
 *
 * @param array The array.
 * @param start The start of the range.
 * @param end The end of the range.
 */
function reverse(array, start = 0, end = array.length) {
    for (let i = start, j = end - 1; i < j; ++i, --j) {
        swap(array, i, j);
    }
}
/**
 * Rotates a range of elements in an array by given amount.
 *
 * @param array The array.
 * @param amount The amount.
 * @param start The start of the range.
 * @param end The end of the range.
 */
function rotate(array, amount = 1, start = 0, end = array.length) {
    reverse(array, start, end);
    reverse(array, start, start + amount);
    reverse(array, start + amount, end);
}
/**
 * Copies a range of elements from a source array to a range in a destination
 * array.
 *
 * @param src The source array.
 * @param dst The destination array.
 * @param srcStart The start of the source range.
 * @param srcStart The start of the source range.
 * @param dstStart The start of the destination range.
 */
function copy(src, dst, srcStart = 0, srcEnd = src.length, dstStart = 0) {
    for (let i = srcStart, j = dstStart; i < srcEnd; ++i, ++j) {
        dst[j] = src[i];
    }
}
/**
 * Shuffles randomly a range of elements in an array.
 *
 * @param array The array.
 * @param start The start of the range.
 * @param end The end of the range.
 */
function shuffle(array, start = 0, end = array.length) {
    for (let i = start, j = i + 1; i < end; ++i, ++j) {
        swap(array, i, j + (Math.random() * (end - j) | 0));
    }
}
function zip(ts, us, zipper = (t, u) => [t, u]) {
    const l = Math.min(ts.length, us.length);
    const vs = new Array(l);
    for (let i = 0; i < l; ++i) {
        vs[i] = zipper(ts[i], us[i]);
    }
    return vs;
}
/**
 * Compares two arrays lexicographically. The order is specified be the comparator parameter.
 *
 * @param comparator Elements comparator with standard signature.
 * @param a The first array to compare.
 * @param b The second array to compare.
 * @returns 0 if all elements and lengths are equal,
 *      negative number if the first element is less then the second (lexicographically),
 *      positive number if the first element is greater then the second,
 *      if all the elements are equal the lengths are being compared.
 */
function compare(comparator, a, b) {
    const length = Math.min(a.length, b.length);
    for (let i = 0; i < length; i++) {
        const result = comparator(a[i], b[i]);
        if (result) {
            return result;
        }
    }
    return a.length - b.length;
}
/**
 * Sorts a range of elements of an array in place with insertion sort.
 *
 * @param array The array to be sorted.
 * @param comparator Comparator for array elements.
 * @param start Index of the first element in the range to be sorted.
 * @param end Index of an element behind the last element in the range to be
 *      sorted.
 */
function insertionSort(array, comparator = _comparator__WEBPACK_IMPORTED_MODULE_0__["DEFAULT_COMPARATOR"], start = 0, end = array.length) {
    for (let i = start; i < end; ++i) {
        for (let j = i; j > start && comparator(array[j - 1], array[j]) > 0; --j) {
            swap(array, j - 1, j);
        }
    }
}
const BLOCK_SIZE = 32;
/**
 * Merges two sorted ranges of an array. Stores the result into another one.
 *
 * @param src The array with the ranges to be merged.
 * @param dst The array the resulting range will be stored to.
 * @param comparator The comparator for array elements.
 * @param start Start of the first range to be merged.
 * @param middle End of the first and simultaneously start of the second range
 *      to be merged.
 * @param end End of the second range to be merged.
 * @param dstOffset Offset of merged range in the result array.
 */
function merge(src, dst, comparator, start, middle, end, dstOffset) {
    let i = dstOffset;
    let j = start;
    let k = middle;
    while (j < middle && k < end) {
        dst[i++] = comparator(src[j], src[k]) > 0 ? src[k++] : src[j++];
    }
    copy(src, dst, j, middle, i);
    copy(src, dst, k, end, i);
}
/**
 * Sorts a range of elements of an array with merge sort.
 *
 * @param array  The array to be sorted.
 * @param comparator Comparator for array elements.
 * @param end Index of an element behind the last element in the range to be
 *      sorted.
 */
function mergeSort(array, comparator = _comparator__WEBPACK_IMPORTED_MODULE_0__["DEFAULT_COMPARATOR"], start = 0, end = array.length) {
    // First and foremost: if the range is smaller than the block size, just
    // perform insertion sort on it.
    if (end - start <= BLOCK_SIZE) {
        insertionSort(array, comparator, start, end);
        return;
    }
    // First we split the given range into subranges of size BLOCK_SIZE and
    // sort every range with insertion sort.
    {
        let s = start;
        let e = s + BLOCK_SIZE;
        while (e < end) {
            insertionSort(array, comparator, s, e);
            s = e;
            e += BLOCK_SIZE;
        }
        insertionSort(array, comparator, s, end);
    }
    // TODO(dmikis): Implement in-place merge. It seems there're reasonably
    //      complex solutions out there.
    const auxArray = new Array(end - start);
    // Then we merge blocks pairs, increase block size by 2 and repeat.
    for (let blockSize = BLOCK_SIZE; blockSize < end - start; blockSize += blockSize) {
        // TODO(dmikis): Before aforementioned todo maybe implement array
        // pingponging to cut down amount of full copies.
        copy(array, auxArray, start, end);
        let i = start;
        let s = 0;
        let m = blockSize;
        let e = m + blockSize;
        while (e < end - start) {
            merge(auxArray, array, comparator, s, m, e, i);
            s = e;
            m = s + blockSize;
            e = m + blockSize;
            i += 2 * blockSize;
        }
        merge(auxArray, array, comparator, s, Math.min(m, end - start), end - start, i);
    }
}


/***/ }),
/* 39 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_COMPARATOR", function() { return DEFAULT_COMPARATOR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NUMERICAL_COMPARATOR", function() { return NUMERICAL_COMPARATOR; });
function DEFAULT_COMPARATOR(a, b) {
    if (a > b) {
        return 1;
    }
    if (a < b) {
        return -1;
    }
    return 0;
}
function NUMERICAL_COMPARATOR(a, b) {
    return a - b;
}


/***/ }),
/* 40 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MemorySubChunk; });
/* harmony import */ var _count_vertices__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(41);

/**
 * Represents a region in a memory chunk. Memory is allocated by big chunks for performance reasons,
 * and we need a mechanism to control those chunk's suballocation to properly free
 * the occupied memory - that is what this class is for.
 */
class MemorySubChunk {
    constructor(chunk, location) {
        this.memoryChunk = chunk;
        this._location = location;
        chunk.retain();
    }
    /**
     * @returns Offset of vertex data of the chunk in bytes.
     */
    get vertexByteOffset() {
        return this.memoryChunk.vertexByteOffset + this._location.vertexByteOffset;
    }
    /**
     * @returns Offset of index data of the chunk in bytes.
     */
    get indexByteOffset() {
        return this.memoryChunk.indexByteOffset + this._location.indexByteOffset;
    }
    /**
     * @returns Number of indexes occupied by this chunk.
     */
    get indexCount() {
        return Object(_count_vertices__WEBPACK_IMPORTED_MODULE_0__["countIndices"])(this._location.indexByteLength, this.memoryChunk.page.indexType);
    }
    /**
     * @returns Number of bytes occupied by this chunk for vertex data.
     */
    get vertexByteLength() {
        return this._location.vertexByteLength;
    }
    /**
     * @returns Number of bytes occupied by this chunk for index data.
     */
    get indexByteLength() {
        return this._location.indexByteLength;
    }
    destroy() {
        this.memoryChunk.release();
    }
}


/***/ }),
/* 41 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "countVertices", function() { return countVertices; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "countIndices", function() { return countIndices; });
/**
 * @returns Integer number of vertices that fit into a region of specified in bytes size.
 */
function countVertices(vertexByteSize, attribMapping) {
    return vertexByteSize / attribMapping.vertexByteSize | 0;
}
/**
 * @returns Integer number of indices that fit into a region of specified in bytes size.
 */
function countIndices(indexByteSize, type) {
    switch (type) {
        case 5123 /* UNSIGNED_SHORT */:
            return indexByteSize >> 1;
        case 5125 /* UNSIGNED_INT */:
            return indexByteSize >> 2;
        default:
            return -1;
    }
}


/***/ }),
/* 42 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AllocatedImage", function() { return AllocatedImage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return IdentifiedImageAtlasManager; });
/* harmony import */ var _util_ref_counted__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(43);

/**
 * Represents an allocated image. Allocated image is a shareable resource that should be resealed
 * when there are no clients use it. As it is not possible to rely on the GC, clients should
 * manually retain their required images and release them when they are not required anymore.
 */
class AllocatedImage extends _util_ref_counted__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(descriptor, bbox, atlasManager) {
        super();
        this.descriptor = descriptor;
        this.bbox = bbox;
        this.atlasManager = atlasManager;
    }
    updateImage(sourceImage, locationRegion, sourceImageRegion) {
        this.atlasManager.atlas.updateImage(this.bbox, sourceImage, locationRegion, sourceImageRegion);
    }
    _destroy() {
        this.atlasManager.removeImage(this.descriptor);
    }
}
/**
 * Manages allocation of images by id.
 */
class IdentifiedImageAtlasManager {
    constructor(imageAtlas) {
        this.atlas = imageAtlas;
        this._locations = new Map();
    }
    get size() {
        return this._locations.size;
    }
    getImage(id, retain = false) {
        const imageLocation = this._locations.get(id);
        if (retain && imageLocation) {
            imageLocation.retain();
        }
        return imageLocation || null;
    }
    allocateImage(descriptor, image) {
        const location = this.atlas.allocateImage(descriptor, image);
        if (location) {
            const image = new AllocatedImage(descriptor, location, this);
            this._locations.set(descriptor.id, image);
            return image;
        }
        return null;
    }
    removeImage(image) {
        const location = this._locations.get(image.id);
        if (location) {
            this.atlas.removeImage(location.bbox);
            this._locations.delete(image.id);
        }
    }
    contains(id) {
        return this._locations.has(id);
    }
    reserveLocation(descriptor) {
        const location = this.atlas.reserveLocation(descriptor);
        if (location) {
            const image = new AllocatedImage(descriptor, location, this);
            this._locations.set(descriptor.id, image);
            return image;
        }
        return null;
    }
}


/***/ }),
/* 43 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ReferenceCounted; });
/**
 * Simple reference counting for shared entities that need explicit destruction.
 */
class ReferenceCounted {
    /**
     * Initializes reference count to 1.
     */
    constructor() {
        this._refCount = 1;
    }
    /**
     * Increments reference count.
     */
    retain() {
        if (this._refCount === 0) {
            throw new Error('Tried to retain a destroyed object.');
        }
        this._refCount++;
    }
    /**
     * Decrements reference count and, if it's reached 0, destroys the object.
     */
    release() {
        if (this._refCount === 0) {
            throw new Error('Tried to release a destroyed object.');
        }
        this._refCount--;
        if (this._refCount === 0) {
            this._destroy();
        }
    }
}


/***/ }),
/* 44 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DfFont; });
/* harmony import */ var _font__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(45);

const UNKNOWN_GLYPH = {
    id: -1,
    width: 0,
    height: 0,
    bearingX: 0,
    bearingY: 0,
    advance: 18
};
/**
 * Font whose glyphs are specified in distance field bitmaps. It's "margin" metric specifies glyph bitmap inner padding,
 * that is required to fit a "blurred" glyph image. This margin should be considered during layouting to draw glyphs of
 * proper sizes.
 */
class DfFont extends _font__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(id, xheight, margin) {
        super(id, xheight, UNKNOWN_GLYPH);
        this.margin = margin;
    }
}


/***/ }),
/* 45 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Font; });
/**
 * Font is just a collection of glyph descriptions.
 */
class Font {
    /**
     * @param id Font id.
     * @param xheight The height of the "x" char in abstract points, in fact is used a the font size.
     * @param unknownGlyphInstance An instance of glyph to be served as a stub when nonexistent glyph
     *     is requested. Requesting nonexistent glyphs normally should not happen.
     *     The stub just allows to avoid tedious null checks in font clients.
     */
    constructor(id, xheight, unknownGlyphInstance) {
        this.id = id;
        this.xheight = xheight;
        this._unknownGlyphInstance = unknownGlyphInstance;
        this._glyphs = new Map();
    }
    /**
     * @return Glyph with specified id or unknown glyph instance.
     */
    getGlyph(glyphId) {
        const glyph = this._glyphs.get(glyphId);
        if (glyph) {
            return glyph;
        }
        else {
            console.warn('Wow-wow-wow, something went wrong, you should not request nonexistent glyphs');
            return this._unknownGlyphInstance;
        }
    }
    /**
     * @returns All stored glyphs.
     */
    getAllGlyphs() {
        return [...this._glyphs.values()];
    }
    /**
     * Adds glyph description.
     */
    addGlyph(glyph) {
        this._glyphs.set(glyph.id, glyph);
    }
    /**
     * Adds glyph descriptions from the iterable.
     */
    addAllGlyphs(glyphs) {
        for (const glyph of glyphs) {
            this.addGlyph(glyph);
        }
    }
}


/***/ }),
/* 46 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ApiImageProvider", function() { return ApiImageProvider; });
/* harmony import */ var _billboard_image_provider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(47);
/* harmony import */ var _util_hd__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(48);
/* harmony import */ var _util_hosts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(49);



/**
 * Image provider that gets images from specific API entry point.
 */
class ApiImageProvider extends _billboard_image_provider__WEBPACK_IMPORTED_MODULE_0__["ImageProvider"] {
    constructor(imageUrlTemplate) {
        super();
        this._imageUrlTemplate = imageUrlTemplate;
    }
    getImageUrl(id) {
        // API can return scaled images that allows us to request images according
        // to user's DPI and render them properly, non-integer numbers are accepted.
        return this._imageUrlTemplate
            .replace('{{hostAlias}}', Object(_util_hosts__WEBPACK_IMPORTED_MODULE_2__["getHostAliasByUid"])(id))
            .replace(/\{\{id\}\}/g, id)
            .replace('{{scale}}', Object(_util_hd__WEBPACK_IMPORTED_MODULE_1__["default"])().toString());
    }
}


/***/ }),
/* 47 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageProvider", function() { return ImageProvider; });
/**
 * Abstract image content provider, concrete implementations should specify the entry point in getImageUrl().
 */
class ImageProvider {
    /**
     * Gets image bitmap via an HTMLImageElement and a canvas.
     */
    getImage(id) {
        return new Promise((resolve, reject) => {
            const imageElement = new Image();
            imageElement.crossOrigin = 'anonymous';
            imageElement.onload = () => resolve(imageElement);
            imageElement.onerror = reject;
            imageElement.src = this.getImageUrl(id);
        });
    }
}


/***/ }),
/* 48 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getDpr; });
/**
 * Gives the device pixel ration if it's greater than 1 and 1 otherwise. This's
 * here purely to be compatible with jsapi which does the same thing for reasons
 * unknows (thanks, kashey).
 *
 * @returns Capped device pixel ratio.
 */
function getDpr() {
    return devicePixelRatio > 1 ? devicePixelRatio : 1;
}


/***/ }),
/* 49 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getHostAliasByUid", function() { return getHostAliasByUid; });
const HOST_ALIASES_N = 4;
function getHostAliasByUid(uid) {
    let sum = 0;
    for (let i = 0; i < uid.length; i++) {
        sum += uid.charCodeAt(i);
    }
    return (sum % HOST_ALIASES_N + 1).toString();
}


/***/ }),
/* 50 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ModelBufferWriter; });
/* harmony import */ var _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _util_buffer_writer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(36);


/**
 * Base class for 3D models buffer writers. It is not supposed to write indices, instead it writes vertices (possibly
 * duplicated) in order that correspond to triangular facets of the mesh.
 */
class ModelBufferWriter extends _util_buffer_writer__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor() {
        super(ModelBufferWriter.ATTRIBUTE_MAPPING.vertexByteSize);
    }
    /**
     * Writes a vertex to the vertex buffer.
     */
    _writeVertex(v, colorRgba8) {
        const vertexIdx = this.getCurrentVertexIdx();
        this._writeWorldCoordinate(v);
        this._writeFloat32(v.z);
        this._writeWord(colorRgba8);
        return vertexIdx;
    }
}
/**
 * Description of how attributes of vertices are packed into a vertex buffer.
 */
ModelBufferWriter.ATTRIBUTE_MAPPING = new _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__["AttributeMapping"]([
    [
        0 /* POSITION_HIGH */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        1 /* POSITION_LOW */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        3 /* HEIGHT */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        7 /* COLOR */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ]
]);


/***/ }),
/* 51 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TexturedPolylineBufferWriter; });
/* harmony import */ var _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _util_buffer_writer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(36);
/* harmony import */ var _textured_polyline_geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(52);
/* harmony import */ var _util_z_index__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(53);




/**
 * Writer of geometry data of polyline hulls.
 */
class TexturedPolylineBufferWriter extends _util_buffer_writer__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor() {
        super(TexturedPolylineBufferWriter.ATTRIBUTE_MAPPING.vertexByteSize);
    }
    /**
     * Generates a hull for a polyline and writes it to the writer.
     *
     * @param polyline The polyline to be written.
     * @param width Thickness of the polyline.
     * @param worldToPxFactor Ratio of world coordinates to pixels.
     * @param imageLocation Image location in atlas.
     * @param zIndex Z-index of the polyline.
     */
    writeTexturedPolyline(polyline, width, worldToPxFactor, imageLocation, zIndex) {
        Object(_textured_polyline_geometry__WEBPACK_IMPORTED_MODULE_2__["default"])(this, polyline.vertices, worldToPxFactor, imageLocation, width, Object(_util_z_index__WEBPACK_IMPORTED_MODULE_3__["intToZIndex"])(zIndex + 1));
        return this.endMesh();
    }
    /**
     * Writes a vertex to the vertex buffer.
     *
     * @param position Position of the vertex in world coordinates.
     * @param displacement Displacement vector, in most cases must be normalized, the width is considered in shaders.
     * @param halfWidth Thickness of the polyline.
     * @param patterWidth Width of the image that is repeated along the polyline.
     * @param patternHalfHeight Image half height multiplied by `sign(s)`, where `s` is a [-1; 1] distance to the
     * analytical polyline along segment's normal.
     * @param length Length of the polyline for current vertex, needed to correctly calculate image uv x coordinate.
     * @param uv UV coordinates of the image.
     * @param zIndex Z-index of the polyline.
     *
     * @return Index of the written vertex.
     */
    writeVertex(position, displacement, halfWidth, patternWidth, patternHalfHeight, length, uv, zIndex) {
        const vertexIdx = this.getCurrentVertexIdx();
        this._writeWorldCoordinate(position);
        this._writeFloat32(displacement.x);
        this._writeFloat32(displacement.y);
        this._writeHalfWords(uv.x, uv.y);
        this._writeFloat32(zIndex);
        this._writeFloat32(halfWidth);
        this._writeHalfWords(patternWidth, length);
        this._writeFloat32(patternHalfHeight);
        return vertexIdx;
    }
}
/** Description of how a writer stores vertex data. */
TexturedPolylineBufferWriter.ATTRIBUTE_MAPPING = new _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__["AttributeMapping"]([
    [
        0 /* POSITION_HIGH */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        1 /* POSITION_LOW */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        6 /* DISPLACEMENT */,
        {
            size: 2,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        4 /* UV */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: false
        }
    ],
    [
        9 /* PRIORITY */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        11 /* AUX */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        12 /* AUX1 */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: false
        }
    ],
    [
        13 /* AUX2 */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ]
]);


/***/ }),
/* 52 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return writeTexturedPolylineGeometry; });
/* harmony import */ var _math_vector2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(23);

/**
 * Writes polyline image geometry (set of triangles that draw up a solid thick polyline) into a buffer writer.
 *
 * @param writer Output buffer writer.
 * @param polyline Polyline to be written.
 * @param worldToPxFactor Ratio of world coordinates to pixels.
 * @param imageLocation Image location in atlas.
 * @param width Thickness of the polyline.
 * @param z Z-index of the polyline.
 */
function writeTexturedPolylineGeometry(writer, polyline, worldToPxFactor, imageLocation, width, z) {
    const hWidth = width / 2;
    const patternWidth = imageLocation.maxX - imageLocation.minX;
    const patternHalfHeight = (imageLocation.maxY - imageLocation.minY) / 2;
    const segment = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["create"](0, 0);
    const dir = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["create"](0, 0);
    const prevDir = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["create"](0, 0);
    const norm = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["create"](0, 0);
    const normInv = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["create"](0, 0);
    const uv = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["create"](imageLocation.minX, 0);
    let prevBottomRight = -1;
    let prevTopRight = -1;
    let length = 0;
    let prevLength = 0;
    for (let i = 1; i < polyline.length; i++) {
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["sub"](polyline[i], polyline[i - 1], segment);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["normalize"](segment, dir);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["rotate90"](dir, norm);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["muln"](norm, -1, normInv);
        // segment is written as a rectangle (two triangles)
        uv.y = imageLocation.minY;
        const topLeft = writer.writeVertex(polyline[i - 1], norm, hWidth, patternWidth, patternHalfHeight, length, uv, z);
        uv.y = imageLocation.maxY;
        const bottomLeft = writer.writeVertex(polyline[i - 1], normInv, hWidth, patternWidth, -patternHalfHeight, length, uv, z);
        // update length of the polyline in pixels
        length += _math_vector2__WEBPACK_IMPORTED_MODULE_0__["length"](segment) / worldToPxFactor;
        uv.y = imageLocation.minY;
        const topRight = writer.writeVertex(polyline[i], norm, hWidth, patternWidth, patternHalfHeight, length, uv, z);
        uv.y = imageLocation.maxY;
        const bottomRight = writer.writeVertex(polyline[i], normInv, hWidth, patternWidth, -patternHalfHeight, length, uv, z);
        // write line join that fills an empty space on corners
        if (1 < i && i < polyline.length) {
            uv.y = (imageLocation.maxY + imageLocation.minY) / 2;
            const joinPointIndex = writer.writeVertex(polyline[i - 1], _math_vector2__WEBPACK_IMPORTED_MODULE_0__["ZERO"], hWidth, patternWidth, 0, prevLength, uv, z);
            // find out where the fracture of segments is located to create correct join with minimum overdraw
            const turnLeft = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["crossZ"](prevDir, dir) > 0;
            if (turnLeft) {
                writer.writeIndices([
                    joinPointIndex, bottomLeft, prevBottomRight
                ]);
            }
            else {
                writer.writeIndices([
                    joinPointIndex, prevTopRight, topLeft
                ]);
            }
        }
        writer.writeIndices([
            topLeft, topRight, bottomLeft,
            topRight, bottomRight, bottomLeft
        ]);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["copy"](dir, prevDir);
        prevBottomRight = bottomRight;
        prevTopRight = topRight;
        prevLength = length;
    }
}


/***/ }),
/* 53 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "intToZIndex", function() { return intToZIndex; });
const MIN_ZINDEX = -1 + Math.pow(2, 1 - 24); // epsilon is added (for normalized 24-bit value) to free up reserved value
function intToZIndex(x) {
    return Math.max(MIN_ZINDEX, x / 0x7fffff);
}


/***/ }),
/* 54 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageManager", function() { return ImageManager; });
/**
 * Manages allocation of requested images. The same images can be requested multiple times from different places,
 * this class takes over duplication of HTTP requests/atlas allocations providing simple async interface for
 * getting allocated images.
 */
class ImageManager {
    constructor(atlas, provider) {
        this._atlas = atlas;
        this._provider = provider;
        this._requests = new Map();
    }
    /**
     * Returns image if it is already allocated. Pay attention that resulted allocated image is "retained",
     * so it must be released once it is passed to a responsible client.
     */
    getImage(id) {
        const image = this._atlas.getImage(id, true);
        if (image) {
            image.retain();
        }
        return image;
    }
    /**
     * Request image from image provider, if it is already allocated no request is made, but it is returned
     * wrapped into a resolved promise. Pay attention that resulted allocated image is "retained", so it must be
     * released once it is passed to a responsible client.
     */
    requestImage(id) {
        const allocatedImage = this._atlas.getImage(id, true);
        if (allocatedImage) {
            return Promise.resolve(allocatedImage);
        }
        else {
            const request = this._requests.get(id);
            if (request) {
                request.then((allocatedImage) => allocatedImage && allocatedImage.retain());
                return request;
            }
            else {
                const request = this._provider
                    .getImage(id)
                    .then((image) => {
                    this._requests.delete(id);
                    const { width, height } = image;
                    const allocatedImage = this._atlas.allocateImage({ id, width, height }, image);
                    if (!allocatedImage) {
                        throw new Error('Couldn\' allocated image');
                    }
                    else {
                        return allocatedImage;
                    }
                }, () => {
                    this._requests.delete(id);
                    throw new Error('Image request failed');
                });
                this._requests.set(id, request);
                return request;
            }
        }
    }
}


/***/ }),
/* 55 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TexturedPolygonBufferRewriter; });
/* harmony import */ var _util_buffer_rewriter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(56);
/* harmony import */ var _textured_polygon_attribute_mapping__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(57);


class TexturedPolygonBufferRewriter extends _util_buffer_rewriter__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(buffers) {
        super(_textured_polygon_attribute_mapping__WEBPACK_IMPORTED_MODULE_1__["TEXTURED_POLYGON_ATTRIBUTE_MAPPING"], buffers);
    }
    /**
     * @param location Location of the polygon in memory.
     * @param imageLocation Location of the pattern in atlas.
     * @param imageScale How world coordinates relate to the image size.
     */
    rewriteUV(location, imageLocation, imageScale) {
        const uvOffset = this._getAttribOffset(4 /* UV */);
        const scaleOffset = this._getAttribOffset(11 /* AUX */);
        this._forEachVertex(location, (writer) => {
            writer.writeHalfWords(uvOffset, imageLocation.minX, imageLocation.minY);
            writer.writeHalfWords(uvOffset + 1, imageLocation.maxX - imageLocation.minX, imageLocation.maxY - imageLocation.minY);
            writer.writeFloat32(scaleOffset, imageScale);
        });
    }
}


/***/ }),
/* 56 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BufferRewriter; });
/* harmony import */ var _buffer_writer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(36);

/**
 * Class that is exposed as an interface for writing to a specific vertex attribute.
 */
class VertexWriter {
    constructor(vertexBuffer) {
        this._vertexBuffer = new Uint32Array(vertexBuffer.buffer, 0, vertexBuffer.length);
        this._vertexBufferFloat32View = new Float32Array(vertexBuffer.buffer, 0, vertexBuffer.length);
    }
    /**
     * Writes float attribute into specific position in buffer.
     *
     * @param attribOffset Offset of an attribute in words (4 bytes), get it from BufferRewriter#_getAttribOffset().
     * @param value Value to be written.
     */
    writeFloat32(attribOffset, value) {
        this._vertexBufferFloat32View[this.vertexOffset + attribOffset] = value;
    }
    /**
     * Writes a word attribute into specific position in buffer.
     *
     * @param attribOffset Offset of an attribute in words (4 bytes), get it from BufferRewriter#_getAttribOffset().
     * @param value Value to be written.
     */
    writeWord(attribOffset, value) {
        this._vertexBuffer[this.vertexOffset + attribOffset] = value;
    }
    /**
     * Writes two half word attribute values into specific position in buffer.
     *
     * @param attribOffset Offset of an attribute in words (4 bytes), get it from BufferRewriter#_getAttribOffset().
     * @param value Value to be written.
     */
    writeHalfWords(attribOffset, v1, v2) {
        this.writeWord(attribOffset, v2 << 16 | v1 & 0xffff);
    }
}
/**
 * Provides some utils for rewriting vertex attribute values, see VertexWriter and tests for some tips of how to do it.
 * TODO: consider supporting of separate buffers for different attributes, that will make this class less useful
 */
class BufferRewriter {
    constructor(attribMapping, buffers) {
        this._attribMapping = attribMapping;
        this._buffers = buffers;
    }
    /**
     * Walks over all vertices exposing VertexWriter for each one by calling the handler argument.
     */
    _forEachVertex(location, handler) {
        const vertexWriter = new VertexWriter(this._buffers[location.bufferIndex].vertexBuffer);
        const vertexByteSize = this._attribMapping.vertexByteSize;
        for (let i = 0; i < location.vertexByteLength; i += vertexByteSize) {
            vertexWriter.vertexOffset = (location.vertexByteOffset + i) / _buffer_writer__WEBPACK_IMPORTED_MODULE_0__["WORD_BYTE_SIZE"];
            handler(vertexWriter);
        }
    }
    /**
     * @returns Offset in words (4 bytes) of specific attribute in a vertex (format is defined by AttributeMapping).
     */
    _getAttribOffset(attrib) {
        const attribPointer = this._attribMapping.get(attrib);
        return attribPointer ? attribPointer.offset / _buffer_writer__WEBPACK_IMPORTED_MODULE_0__["WORD_BYTE_SIZE"] : -1;
    }
}


/***/ }),
/* 57 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEXTURED_POLYGON_ATTRIBUTE_MAPPING", function() { return TEXTURED_POLYGON_ATTRIBUTE_MAPPING; });
/* harmony import */ var _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);

/**
 * Description of how attributes of vertices are packed into a vertex buffer.
 */
const TEXTURED_POLYGON_ATTRIBUTE_MAPPING = new _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__["AttributeMapping"]([
    [
        0 /* POSITION_HIGH */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        1 /* POSITION_LOW */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        4 /* UV */,
        {
            size: 4,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: false
        }
    ],
    [
        11 /* AUX */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        10 /* Z_INDEX */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ]
]);


/***/ }),
/* 58 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "POLYGON_ATTRIBUTE_MAPPING", function() { return POLYGON_ATTRIBUTE_MAPPING; });
/* harmony import */ var _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);

/**
 * Description of how attributes of vertices are packed into a vertex buffer.
 */
const POLYGON_ATTRIBUTE_MAPPING = new _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__["AttributeMapping"]([
    [
        0 /* POSITION_HIGH */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        1 /* POSITION_LOW */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        7 /* COLOR */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        10 /* Z_INDEX */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ]
]);


/***/ }),
/* 59 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BILLBOARD_RECTANGLE_ATTRIBUTE_MAPPING", function() { return BILLBOARD_RECTANGLE_ATTRIBUTE_MAPPING; });
/* harmony import */ var _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);

/** Description of how a writer stores vertex data. */
const BILLBOARD_RECTANGLE_ATTRIBUTE_MAPPING = new _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__["AttributeMapping"]([
    [
        2 /* ID */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        0 /* POSITION_HIGH */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        1 /* POSITION_LOW */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        6 /* DISPLACEMENT */,
        {
            size: 2,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        4 /* UV */,
        {
            size: 2,
            type: 5122 /* SHORT */,
            normalized: true
        }
    ],
    [
        7 /* COLOR */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        11 /* AUX */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ]
]);


/***/ }),
/* 60 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "POINT_LABEL_ATTRIBUTE_MAPPING", function() { return POINT_LABEL_ATTRIBUTE_MAPPING; });
/* harmony import */ var _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);

/** Description of how a writer stores vertex data. */
const POINT_LABEL_ATTRIBUTE_MAPPING = new _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__["AttributeMapping"]([
    [
        2 /* ID */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        0 /* POSITION_HIGH */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        1 /* POSITION_LOW */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        6 /* DISPLACEMENT */,
        {
            size: 2,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        4 /* UV */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: false
        }
    ],
    [
        7 /* COLOR */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        8 /* OUTLINE_COLOR */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        9 /* PRIORITY */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        11 /* AUX */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ]
]);


/***/ }),
/* 61 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CURVED_LABEL_ATTRIBUTE_MAPPING", function() { return CURVED_LABEL_ATTRIBUTE_MAPPING; });
/* harmony import */ var _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);

/** Description of how a writer stores vertex data. */
const CURVED_LABEL_ATTRIBUTE_MAPPING = new _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__["AttributeMapping"]([
    [
        2 /* ID */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        0 /* POSITION_HIGH */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        1 /* POSITION_LOW */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        6 /* DISPLACEMENT */,
        {
            size: 3,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        4 /* UV */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: false
        }
    ],
    [
        7 /* COLOR */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        8 /* OUTLINE_COLOR */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        9 /* PRIORITY */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        12 /* AUX1 */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        13 /* AUX2 */,
        {
            size: 4,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        14 /* AUX3 */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        15 /* AUX4 */,
        {
            size: 4,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        11 /* AUX */,
        {
            size: 2,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ]
]);


/***/ }),
/* 62 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "POLYLINE_ATTRIBUTE_MAPPING", function() { return POLYLINE_ATTRIBUTE_MAPPING; });
/* harmony import */ var _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);

/**
 * Description of how attributes of vertices are packed into a vertex buffer.
 */
const POLYLINE_ATTRIBUTE_MAPPING = new _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__["AttributeMapping"]([
    /** Vertex world position. */
    [
        0 /* POSITION */,
        {
            size: 4,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    /** Normal to polyline segment the vertex belong to. */
    [
        5 /* NORMAL */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    /**
     * "UV" vertex that used to compute stroke and dashes. It's components:
     *
     *   - distance to the analytical polyline along segment's normal;
     *   - distance to the analytical polyline along segment.
     */
    [
        4 /* UV */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: false
        }
    ],
    /**
     * Vector with polyline's half width and dash style. It's components:
     *
     *   - half width;
     *   - length of a dash;
     *   - distance between dashes.
     */
    [
        11 /* AUX */,
        {
            size: 3,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    /**
     * Miter (i.e. how much displacement of the vertex is longer then the
     * normal).
     */
    [
        12 /* AUX1 */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    /**
     * Limit on displacement tangent component.Applied to avoid geometry
     * glitches in over-degenerative cases.
     */
    [
        13 /* AUX2 */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    /**
     * Distance to the first vertex along the polyline.
     */
    [
        14 /* AUX3 */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    /** Polyline's color. */
    [
        7 /* COLOR */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    /** Polyline's Z index. */
    [
        10 /* Z_INDEX */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ]
]);


/***/ }),
/* 63 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TileProviderWorkerClient", function() { return TileProviderWorkerClient; });
/* harmony import */ var _util_worker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30);

class TileProviderWorkerClient extends _util_worker__WEBPACK_IMPORTED_MODULE_0__["WebWorkerClient"] {
}


/***/ }),
/* 64 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TileProviderMessageType", function() { return TileProviderMessageType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "geometryTransferableExtractor", function() { return geometryTransferableExtractor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "meshTransferableExtractor", function() { return meshTransferableExtractor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "labelTransferableExtractor", function() { return labelTransferableExtractor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tileTransferableExtractor", function() { return tileTransferableExtractor; });
/* harmony import */ var _primitive_provider_worker_messages__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(65);

var TileProviderMessageType;
(function (TileProviderMessageType) {
    TileProviderMessageType[TileProviderMessageType["INIT"] = 0] = "INIT";
    TileProviderMessageType[TileProviderMessageType["TILE_URL_UPDATE"] = 1] = "TILE_URL_UPDATE";
    TileProviderMessageType[TileProviderMessageType["TILE_REQUEST_BATCH"] = 2] = "TILE_REQUEST_BATCH";
    TileProviderMessageType[TileProviderMessageType["TILE_REQUEST_CANCEL_BATCH"] = 3] = "TILE_REQUEST_CANCEL_BATCH";
    TileProviderMessageType[TileProviderMessageType["TILE_RESPONSE"] = 4] = "TILE_RESPONSE";
    TileProviderMessageType[TileProviderMessageType["TILE_ERROR"] = 5] = "TILE_ERROR";
    TileProviderMessageType[TileProviderMessageType["GEOMETRY_RESPONSE"] = 6] = "GEOMETRY_RESPONSE";
    TileProviderMessageType[TileProviderMessageType["LABELS_RESPONSE"] = 7] = "LABELS_RESPONSE";
    TileProviderMessageType[TileProviderMessageType["MESH_REQUEST"] = 8] = "MESH_REQUEST";
    TileProviderMessageType[TileProviderMessageType["MESH_REQUEST_CANCEL"] = 9] = "MESH_REQUEST_CANCEL";
    TileProviderMessageType[TileProviderMessageType["MESH_RESPONSE"] = 10] = "MESH_RESPONSE";
    TileProviderMessageType[TileProviderMessageType["MESH_ERROR"] = 11] = "MESH_ERROR";
})(TileProviderMessageType || (TileProviderMessageType = {}));
const geometryTransferableExtractor = function (message, transferables = []) {
    Object(_primitive_provider_worker_messages__WEBPACK_IMPORTED_MODULE_0__["extractTransferables"])(message.polygonPages, transferables);
    Object(_primitive_provider_worker_messages__WEBPACK_IMPORTED_MODULE_0__["extractTransferables"])(message.transparentPolygonPages, transferables);
    Object(_primitive_provider_worker_messages__WEBPACK_IMPORTED_MODULE_0__["extractTransferables"])(message.texturedPolygonPages, transferables);
    Object(_primitive_provider_worker_messages__WEBPACK_IMPORTED_MODULE_0__["extractTransferables"])(message.meshPages, transferables);
    Object(_primitive_provider_worker_messages__WEBPACK_IMPORTED_MODULE_0__["extractTransferables"])(message.polylinePages, transferables);
    return transferables;
};
const meshTransferableExtractor = function (message) {
    const transferables = [];
    Object(_primitive_provider_worker_messages__WEBPACK_IMPORTED_MODULE_0__["extractTransferables"])(message.pages, transferables);
    return transferables;
};
const labelTransferableExtractor = function (message, transferables = []) {
    Object(_primitive_provider_worker_messages__WEBPACK_IMPORTED_MODULE_0__["extractTransferables"])(message.pointLabelPages, transferables);
    Object(_primitive_provider_worker_messages__WEBPACK_IMPORTED_MODULE_0__["extractTransferables"])(message.pointLabelBackgroundPages, transferables);
    Object(_primitive_provider_worker_messages__WEBPACK_IMPORTED_MODULE_0__["extractTransferables"])(message.curvedLabelPages, transferables);
    return transferables;
};
const tileTransferableExtractor = function (message) {
    const transferables = [];
    geometryTransferableExtractor(message, transferables);
    labelTransferableExtractor(message, transferables);
    return transferables;
};


/***/ }),
/* 65 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractTransferables", function() { return extractTransferables; });
/**
 * Extract ArrayBuffers (that are tansferable) from pages.
 */
function extractTransferables(pages, output) {
    for (const page of pages) {
        output.push(page.vertexBuffer.buffer, page.indexBuffer.buffer);
    }
}


/***/ }),
/* 66 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TRANSPARENT_POLYGON_ATTRIBUTE_MAPPING", function() { return TRANSPARENT_POLYGON_ATTRIBUTE_MAPPING; });
/* harmony import */ var _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _polygon_attribute_mapping__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(58);


/**
 * Description of how attributes of vertices are packed into a vertex buffer.
 */
const TRANSPARENT_POLYGON_ATTRIBUTE_MAPPING = new _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__["AttributeMapping"](_polygon_attribute_mapping__WEBPACK_IMPORTED_MODULE_1__["POLYGON_ATTRIBUTE_MAPPING"]);


/***/ }),
/* 67 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return IdleTaskQueue; });
/* harmony import */ var _priority_queue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(68);

const MAX_DEQUEUE_TIMEOUT = 1000; // ms
// TODO: remove this shim when all supported browsers implement it
const SHIMMED_PROCESSING_DURATION_MS = 25;
window.cancelIdleCallback = window.cancelIdleCallback || window.clearTimeout;
window.requestIdleCallback = window.requestIdleCallback || function (handler) {
    const startTime = performance.now();
    return setTimeout(() => {
        handler({
            didTimeout: false,
            timeRemaining: () => Math.max(0, SHIMMED_PROCESSING_DURATION_MS - (performance.now() - startTime))
        });
    });
};
/**
 * It is a task queue. Tasks are dequeued during idle period.
 */
class IdleTaskQueue {
    constructor() {
        this._queue = new _priority_queue__WEBPACK_IMPORTED_MODULE_0__["default"]();
        this._dequeueIdleHandle = 0;
    }
    destroy() {
        cancelIdleCallback(this._dequeueIdleHandle);
    }
    /**
     * Enqueues a task to the queue.
     *
     * @param task The task.
     */
    enqueue(task) {
        this._queue.enqueue(task);
        this._run();
    }
    _dequeue(deadline) {
        const queue = this._queue;
        if (queue.isEmpty()) {
            return;
        }
        if (deadline.didTimeout) {
            queue.dequeue().execute();
        }
        else {
            while (deadline.timeRemaining() && !queue.isEmpty()) {
                queue.dequeue().execute();
            }
        }
        this._dequeueIdleHandle = 0;
        if (!this._queue.isEmpty()) {
            this._run();
        }
    }
    _run() {
        if (!this._dequeueIdleHandle) {
            this._dequeueIdleHandle = requestIdleCallback((deadline) => {
                this._dequeue(deadline);
            }, { timeout: MAX_DEQUEUE_TIMEOUT });
        }
    }
}


/***/ }),
/* 68 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PriorityQueue; });
/* harmony import */ var _binary_heap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(69);

function itemComparator(a, b) {
    return a.priority - b.priority;
}
/**
 * Priority queue based on a heap.
 */
class PriorityQueue {
    /**
     * Constructs new empty priority queue.
     */
    constructor() {
        this._heap = new _binary_heap__WEBPACK_IMPORTED_MODULE_0__["default"](itemComparator);
    }
    /**
     * Adds an item into the queue.
     *
     * @param item The item.
     */
    enqueue(item) {
        this._heap.insert(item);
    }
    /**
     * Removes next item from the queue.
     *
     * @returns The next item or `undefined` if the queue's empty.
     */
    dequeue() {
        return this._heap.pop();
    }
    /**
     * Checks if the queue has no items in it.
     *
     * @returns `true` if there're no items it the queue and `false` otherwise.
     */
    isEmpty() {
        return this._heap.size === 0;
    }
}


/***/ }),
/* 69 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BinaryHeap; });
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _comparator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39);


/**
 * Computes index of the parent of an item.
 *
 * @param idx Index of the item.
 * @returns Index of the parent.
 */
function getParentIdx(idx) {
    return (idx + 1 >> 1) - 1;
}
/**
 * Computes index of the left child of an item.
 *
 * @param idx Index of the item.
 * @returns Index of the child.
 */
function getFirstChildIdx(idx) {
    return (idx + 1 << 1) - 1;
}
class BinaryHeap {
    /**
     * Constructs a new empty heap. Order of items in the heap will be defined
     * by a given comparator.
     *
     * @param comparator The comparator.
     */
    constructor(comparator = _comparator__WEBPACK_IMPORTED_MODULE_1__["DEFAULT_COMPARATOR"]) {
        // TODO(dmikis) Investigate preallocation.
        this._items = [];
        this._comparator = comparator;
    }
    /**
     * Inserts an item into the heap.
     *
     * @param item The item to be inserted.
     */
    insert(item) {
        const items = this._items;
        const comparator = this._comparator;
        // Insert the new item as bottom right-most child of the heap.
        let idx = items.push(item) - 1;
        let parentIdx = getParentIdx(idx);
        // Walk the heap upward and restore heap property on the way.
        while (parentIdx > -1 &&
            comparator(items[idx], items[parentIdx]) > 0) {
            Object(_array__WEBPACK_IMPORTED_MODULE_0__["swap"])(items, idx, parentIdx);
            idx = parentIdx;
            parentIdx = getParentIdx(idx);
        }
    }
    /**
     * Removes "maximum" item from the head.
     *
     * @returns The removed item or `undefined` is the heap's empty.
     */
    pop() {
        const items = this._items;
        if (items.length === 0) {
            return undefined;
        }
        const newSize = items.length - 1;
        // Place max item at the end of the items array.
        Object(_array__WEBPACK_IMPORTED_MODULE_0__["swap"])(items, 0, newSize);
        // Walk downward from the new root to restore heap property.
        let idx = 0;
        let childIdx = 1;
        const comparator = this._comparator;
        while (childIdx < newSize) {
            if (childIdx + 1 < newSize &&
                comparator(items[childIdx], items[childIdx + 1]) < 0) {
                childIdx += 1;
            }
            if (comparator(items[idx], items[childIdx]) > 0) {
                break;
            }
            Object(_array__WEBPACK_IMPORTED_MODULE_0__["swap"])(items, idx, childIdx);
            idx = childIdx;
            childIdx = getFirstChildIdx(childIdx);
        }
        // Remove previously placed at the end previous max item.
        return items.pop();
    }
    /**
     * @returns "Maximum" item in the heap or `undefined` if the head is empty.
     */
    peek() {
        return this._items[0];
    }
    /**
     * @returns Iterator over all items in the heap. Note that order of items
     *      is undefined.
     */
    *[Symbol.iterator]() {
        for (const item of this._items) {
            yield item;
        }
    }
    /**
     * @returns Number of items in the heap.
     */
    get size() {
        return this._items.length;
    }
}


/***/ }),
/* 70 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RenderablePolygon; });
/* harmony import */ var _renderable_primitive__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(71);

/**
 * Allocated in GPU memory polygon.
 */
class RenderablePolygon extends _renderable_primitive__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(memorySubChunk, isOpaque) {
        super(memorySubChunk);
        this.isOpaque = isOpaque;
    }
}


/***/ }),
/* 71 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RenderablePrimitive; });
/* harmony import */ var _util_ref_counted__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(43);

/**
 * Base class for primitive objects that are ready to be fed to the renderer.
 */
class RenderablePrimitive extends _util_ref_counted__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(memorySubChunk) {
        super();
        this.memorySubChunk = memorySubChunk;
    }
    _destroy() {
        this.memorySubChunk.destroy();
    }
}


/***/ }),
/* 72 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RenderableTexturedPolygon; });
/* harmony import */ var _renderable_primitive__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(71);

class RenderableTexturedPolygon extends _renderable_primitive__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(memoryChunk, allocatedImage) {
        super(memoryChunk);
        this._allocatedImage = allocatedImage;
        this.atlas = allocatedImage.atlasManager.atlas;
        allocatedImage.retain();
    }
    _destroy() {
        this._allocatedImage.release();
        super._destroy();
    }
}


/***/ }),
/* 73 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RenderablePolyline; });
/* harmony import */ var _renderable_primitive__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(71);

class RenderablePolyline extends _renderable_primitive__WEBPACK_IMPORTED_MODULE_0__["default"] {
}


/***/ }),
/* 74 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RenderableTexturedPolyline; });
/* harmony import */ var _renderable_polyline__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(73);

class RenderableTexturedPolyline extends _renderable_polyline__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(memoryChunk, allocatedImage) {
        super(memoryChunk);
        this._allocatedImage = allocatedImage;
        this.atlas = allocatedImage.atlasManager.atlas;
        allocatedImage.retain();
    }
    _destroy() {
        this._allocatedImage.release();
        super._destroy();
    }
}


/***/ }),
/* 75 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RenderableModel; });
/* harmony import */ var _renderable_primitive__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(71);

/**
 * A general primitive that is best suitable for storing simple colored 3D models.
 */
class RenderableModel extends _renderable_primitive__WEBPACK_IMPORTED_MODULE_0__["default"] {
}


/***/ }),
/* 76 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "POLYGON_EXTRACTOR", function() { return POLYGON_EXTRACTOR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEXTURED_POLYGON_EXTRACTOR", function() { return TEXTURED_POLYGON_EXTRACTOR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "POLYLINE_EXTRACTOR", function() { return POLYLINE_EXTRACTOR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEXTURED_POLYLINE_EXTRACTOR", function() { return TEXTURED_POLYLINE_EXTRACTOR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "POINT_EXTRACTOR", function() { return POINT_EXTRACTOR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "POINT_LABEL_EXTRACTOR", function() { return POINT_LABEL_EXTRACTOR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CURVED_LABEL_EXTRACTOR", function() { return CURVED_LABEL_EXTRACTOR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MODEL_EXTRACTOR", function() { return MODEL_EXTRACTOR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EXTERNAL_MESH_EXTRACTOR", function() { return EXTERNAL_MESH_EXTRACTOR; });
const POLYGON_EXTRACTOR = (data) => flat(map('polygons', data));
const TEXTURED_POLYGON_EXTRACTOR = (data) => flat(map('texturedPolygons', data));
const POLYLINE_EXTRACTOR = (data) => flat(map('polylines', data));
const TEXTURED_POLYLINE_EXTRACTOR = (data) => flat(map('texturedPolylines', data));
const POINT_EXTRACTOR = (data) => flat(map('points', data));
const POINT_LABEL_EXTRACTOR = (data) => flat(map('pointLabels', data));
const CURVED_LABEL_EXTRACTOR = (data) => flat(map('curvedLabels', data));
const MODEL_EXTRACTOR = (data) => flat(map('models', data));
const EXTERNAL_MESH_EXTRACTOR = (data) => flat(map('externalMeshes', data));
/**
 * Maps list of TileData's into list of specified primitives.
 */
function* map(type, data) {
    for (const portion of data) {
        yield portion[type];
    }
}
/**
 * Flatten two dimensional list of primitives in a single dimensional one.
 */
function* flat(primitives) {
    for (const portion of primitives) {
        if (portion) {
            yield* portion;
        }
    }
}


/***/ }),
/* 77 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RenderablePrimitiveManager; });
/* harmony import */ var _primitive_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(78);

/**
 * Manager of primitives that have a single assiciated renderable primitive. The "management" is pretty straightforward:
 * it directly adds/removes associated primitives into the storage.
 */
class RenderablePrimitiveManager extends _primitive_manager__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(primitivesStorage) {
        super();
        this._primitivesStorage = primitivesStorage;
    }
    updateScene(toShow, toHide) {
        this._primitivesStorage.add(...toShow);
        this._primitivesStorage.delete(...toHide);
    }
    destroyPrimitives(_toDestroy) {
        // no need to destroy anything, RenderablePrimitive are released when removed from primmitive storage
    }
}


/***/ }),
/* 78 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PrimitiveManager; });
/**
 * Often primitives can't be dirrectly added into or removed from scene, there can be some specific (business) logic
 * associated with these operations. This class provides basic methods for such implementations that
 * allows to manage primitives of all types in the same manner.
 */
class PrimitiveManager {
    destroy() { }
}


/***/ }),
/* 79 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PrimitiveSetStorage; });
/* harmony import */ var _util_event_emitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(14);

/**
 * Primitive storage that stores primitive in a set. It acts as a primitive provider as well.
 */
class PrimitiveSetStorage {
    constructor() {
        this._primitiveSet = new Set();
        this.onUpdate = new _util_event_emitter__WEBPACK_IMPORTED_MODULE_0__["VoidEventEmitter"]();
    }
    get primitives() {
        return this._primitiveSet;
    }
    add(...primitives) {
        for (const primitive of primitives) {
            primitive.retain();
            this._primitiveSet.add(primitive);
        }
        if (primitives.length > 0) {
            this.onUpdate.fire();
        }
    }
    delete(...primitives) {
        for (const primitive of primitives) {
            if (this._primitiveSet.delete(primitive)) {
                primitive.release();
            }
        }
        if (primitives.length > 0) {
            this.onUpdate.fire();
        }
    }
    clear() {
        this._primitiveSet.clear();
        this.onUpdate.fire();
    }
}


/***/ }),
/* 80 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PolygonManager; });
/* harmony import */ var _renderable_primitive_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(77);

/**
 * Polygons should be separated by opaqueness and there are two distinct primitive providers
 * for them: opaque and tansparent. That is what this manager takes care of.
 */
class PolygonManager extends _renderable_primitive_manager__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(opaquePolygonStorage, transparentPolygonStorage) {
        super(opaquePolygonStorage);
        this._opaquePolygonStorage = opaquePolygonStorage;
        this._transparentPolygonStorage = transparentPolygonStorage;
    }
    updateScene(toShow, toHide) {
        for (const primitive of toShow) {
            if (primitive.isOpaque) {
                this._opaquePolygonStorage.add(primitive);
            }
            else {
                this._transparentPolygonStorage.add(primitive);
            }
        }
        for (const primitive of toHide) {
            if (primitive.isOpaque) {
                this._opaquePolygonStorage.delete(primitive);
            }
            else {
                this._transparentPolygonStorage.delete(primitive);
            }
        }
    }
}


/***/ }),
/* 81 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DisappearingPrimitiveSetStorage; });
/* harmony import */ var _primitive_set_storage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(79);

/**
 * Simple primitive set storage that distinguish visible/hidden primitives. It also acts as a primitive provider.
 */
class DisappearingPrimitiveSetStorage extends _primitive_set_storage__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super();
        this._visiblePrimitives = new Set();
    }
    get primitives() {
        return this.visiblePrimitives;
    }
    get visiblePrimitives() {
        return this._visiblePrimitives;
    }
    add(...primitives) {
        super.add(...primitives);
        this.show(...primitives);
    }
    delete(...primitives) {
        this.hide(...primitives);
        super.delete(...primitives);
    }
    show(...primitives) {
        for (const primitive of primitives) {
            if (this._primitiveSet.has(primitive)) {
                this._visiblePrimitives.add(primitive);
            }
        }
    }
    hide(...primitives) {
        for (const primitive of primitives) {
            this._visiblePrimitives.delete(primitive);
        }
    }
    _isAllowedToShowPrimitive(primitive) {
        return this._primitiveSet.has(primitive);
    }
}


/***/ }),
/* 82 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DelayedDisappearingPrimitiveSetStorage; });
/* harmony import */ var _util_iterable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _disappearing_primitive_set_storage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(81);


/**
 * Primitive storage that stores primitive in a set. It acts as a primitive provider as well.
 */
class DelayedDisappearingPrimitiveSetStorage extends _disappearing_primitive_set_storage__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor(appearingEffectDuration) {
        super();
        this._appearingEffectDuration = appearingEffectDuration;
        this._scheduledRemoves = new Map();
        this._timeoutIds = new Set();
    }
    get primitives() {
        return this._primitiveSet;
    }
    add(...primitives) {
        // primitives that are scheduled for removing was not removed "physically", that is why
        // they should be filtered out to prevent multiple adding of the same primitive in parent
        const notScheduledForRemovePrimitives = [];
        for (const primitive of primitives) {
            const primitivesToDelete = this._scheduledRemoves.get(primitive);
            if (primitivesToDelete) {
                // if this primitive is scheduled for removing it is deleted from its batch,
                // thus canceling the removing in the callback
                primitivesToDelete.delete(primitive);
                this._scheduledRemoves.delete(primitive);
            }
            else {
                notScheduledForRemovePrimitives.push(primitive);
            }
        }
        super.add(...notScheduledForRemovePrimitives);
        this.show(...notScheduledForRemovePrimitives);
    }
    delete(...primitives) {
        this.hide(...primitives);
        // primitives are batched in a set to be deleted in one setTimeout callback for performance,
        // filter out primitives which removing was already scheduled
        const primitivesToDelete = new Set(Object(_util_iterable__WEBPACK_IMPORTED_MODULE_0__["filterIterable"])(primitives, (primitive) => !this._scheduledRemoves.has(primitive)));
        if (primitivesToDelete.size > 0) {
            const timeoutId = setTimeout(() => {
                // primitivesToDelete contains relevant for removing primitives, it can be updated in the add() method
                // if a primitive is added back, thus, in fact, canceling removing of this specific primitive
                super.delete(...primitivesToDelete);
                for (const primitive of primitivesToDelete) {
                    this._scheduledRemoves.delete(primitive);
                }
                this._timeoutIds.delete(timeoutId);
            }, this._appearingEffectDuration);
            for (const primitive of primitivesToDelete) {
                this._scheduledRemoves.set(primitive, primitivesToDelete);
            }
            this._timeoutIds.add(timeoutId);
        }
    }
    destroy() {
        for (const timeoutId of this._timeoutIds) {
            clearTimeout(timeoutId);
        }
    }
    _isAllowedToShowPrimitive(primitive) {
        return super._isAllowedToShowPrimitive(primitive) && !this._scheduledRemoves.has(primitive);
    }
}


/***/ }),
/* 83 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ZoomFilterablePrimitiveManager; });
/* harmony import */ var _renderable_primitive_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(77);
/* harmony import */ var _util_iterable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);


/**
 * It is required to hide some primitives (that don't scale with zoom, e.g. labels or icons) by "too irrelevant" zoom,
 * to prevent mess of collapsed objects on the screen. This primitive manager is a temporary solution,
 * proper handling of zoom slices will replace it.
 */
// TODO: this manager is a tmp solution, correct handling of zoom slices is going to replace it
class ZoomFilterablePrimitiveManager extends _renderable_primitive_manager__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(primitivesStorage, camera) {
        super(primitivesStorage);
        this._disappearingPrimitivesStorage = primitivesStorage;
        this._camera = camera;
        this._primitives = new Set();
        this._prevZoom = camera.zoom;
        this._zoomUpdateListener = this._onZoomUpdated.bind(this);
        this._camera.onUpdate.addListener(this._zoomUpdateListener);
    }
    updateScene(toShow, toHide) {
        // save primitives to filter them later
        super.updateScene(Object(_util_iterable__WEBPACK_IMPORTED_MODULE_1__["mapIterable"])(toShow, (primitive) => {
            this._primitives.add(primitive);
            return primitive;
        }), Object(_util_iterable__WEBPACK_IMPORTED_MODULE_1__["mapIterable"])(toHide, (primitive) => {
            this._primitives.delete(primitive);
            return primitive;
        }));
        // check if there are added primitives that could be removed by zoom restrictions
        this._updateZoomVisibility();
    }
    _onZoomUpdated() {
        if (this._prevZoom !== this._camera.zoom) {
            this._updateZoomVisibility();
            this._prevZoom = this._camera.zoom;
        }
    }
    _updateZoomVisibility() {
        const zoom = this._camera.zoom;
        this._disappearingPrimitivesStorage.show(...Object(_util_iterable__WEBPACK_IMPORTED_MODULE_1__["filterIterable"])(this._primitives, ({ minZoom }) => zoom >= minZoom));
        this._disappearingPrimitivesStorage.hide(...Object(_util_iterable__WEBPACK_IMPORTED_MODULE_1__["filterIterable"])(this._primitives, ({ minZoom }) => zoom < minZoom));
    }
    destroy() {
        this._camera.onUpdate.removeListener(this._zoomUpdateListener);
    }
}


/***/ }),
/* 84 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ExternalMeshPrimitiveManager; });
/* harmony import */ var _worker_tile_provider_worker_messages__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(64);
/* harmony import */ var _render_memory_sub_chunk__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(40);
/* harmony import */ var _primitive_model_model_buffer_writer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(50);
/* harmony import */ var _primitive_manager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(78);
/* harmony import */ var _primitive_model_renderable_model__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(75);
/* harmony import */ var _util_worker__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(30);






/**
 * External meshes come in polygons (kind of building outlines). This manager controls quering external meshes
 * according to added polygons, as many of them can share the same mesh (usually across multiple tiles).
 */
class ExternalMeshPrimitiveManager extends _primitive_manager__WEBPACK_IMPORTED_MODULE_3__["default"] {
    constructor(primitivesStorage, geometryProvider, memoryManager) {
        super();
        this._primitivesStorage = primitivesStorage;
        this._tileProvider = geometryProvider;
        this._memoryManager = memoryManager;
        this._externalMeshes = new Map();
    }
    updateScene(toShow, toHide) {
        for (const primitive of toShow) {
            this._addPrimitive(primitive);
        }
        for (const primitive of toHide) {
            this._removePrimitive(primitive);
        }
    }
    _addPrimitive(primitive) {
        const id = getFullMeshId(primitive);
        let external = this._externalMeshes.get(id);
        if (!external) {
            external = {
                visiblePolygons: new Set(),
                isVisible: false
            };
            this._externalMeshes.set(id, external);
            this._tileProvider.request({
                type: _worker_tile_provider_worker_messages__WEBPACK_IMPORTED_MODULE_0__["TileProviderMessageType"].MESH_REQUEST,
                responseType: _worker_tile_provider_worker_messages__WEBPACK_IMPORTED_MODULE_0__["TileProviderMessageType"].MESH_RESPONSE,
                errorType: _worker_tile_provider_worker_messages__WEBPACK_IMPORTED_MODULE_0__["TileProviderMessageType"].MESH_ERROR,
                mesh: primitive,
                requestId: _util_worker__WEBPACK_IMPORTED_MODULE_5__["NO_ID"]
            }).then((response) => {
                const external = this._externalMeshes.get(id);
                if (external && !external.isVisible) {
                    const location = response.location;
                    const chunks = response.pages.map((page) => this._memoryManager.allocate(page.vertexBuffer, page.indexBuffer, _primitive_model_model_buffer_writer__WEBPACK_IMPORTED_MODULE_2__["default"].ATTRIBUTE_MAPPING));
                    external.mesh = new _primitive_model_renderable_model__WEBPACK_IMPORTED_MODULE_4__["default"](new _render_memory_sub_chunk__WEBPACK_IMPORTED_MODULE_1__["default"](chunks[location.bufferIndex], location));
                    external.isVisible = true;
                    this._primitivesStorage.add(external.mesh);
                    chunks.forEach((chunk) => chunk.release());
                }
            });
        }
        external.visiblePolygons.add(primitive);
    }
    _removePrimitive(primitive) {
        const id = getFullMeshId(primitive);
        const external = this._externalMeshes.get(id);
        if (external) {
            external.visiblePolygons.delete(primitive);
            // destroy external mesh if there is no visible polygons remaining
            if (external.visiblePolygons.size === 0) {
                this._externalMeshes.delete(id);
                if (external.mesh) {
                    external.mesh.release();
                    this._primitivesStorage.delete(external.mesh);
                    external.isVisible = false;
                }
                else {
                    // if no mesh yet returned cancel request
                    this._tileProvider.sendMessage({
                        type: _worker_tile_provider_worker_messages__WEBPACK_IMPORTED_MODULE_0__["TileProviderMessageType"].MESH_REQUEST_CANCEL,
                        mesh: primitive
                    });
                }
            }
        }
    }
}
function getFullMeshId(mesh) {
    return mesh.objectId + mesh.meshId;
}


/***/ }),
/* 85 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RenderableBillboardRectangle; });
/* harmony import */ var _renderable_primitive__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(71);

class RenderableBillboardRectangle extends _renderable_primitive__WEBPACK_IMPORTED_MODULE_0__["default"] {
}


/***/ }),
/* 86 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZoomRestrictedLabel", function() { return ZoomRestrictedLabel; });
/* harmony import */ var _primitive_label_renderable_label__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(87);

class ZoomRestrictedLabel extends _primitive_label_renderable_label__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(memorySubChunk, atlas, minZoom, background) {
        super(memorySubChunk, atlas, background);
        this.minZoom = minZoom;
    }
}


/***/ }),
/* 87 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RenderableLabel; });
/* harmony import */ var _renderable_primitive__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(71);

/**
 * Allocated in GPU memory label.
 */
class RenderableLabel extends _renderable_primitive__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Constructs a new renderable label.
     *
     * @param memorySubChunk
     * @param atlas
     * @param background
     */
    constructor(memorySubChunk, atlas, background) {
        super(memorySubChunk);
        this.atlas = atlas;
        this.background = background;
        if (background) {
            background.retain();
        }
    }
    _destroy() {
        if (this.background) {
            this.background.release();
        }
        super._destroy();
    }
}


/***/ }),
/* 88 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZoomRestrictedIcon", function() { return ZoomRestrictedIcon; });
/* harmony import */ var _primitive_icon_renderable_icon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(89);

class ZoomRestrictedIcon extends _primitive_icon_renderable_icon__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(memorySubChunk, allocatedImage, minZoom) {
        super(memorySubChunk, allocatedImage);
        this.minZoom = minZoom;
    }
}


/***/ }),
/* 89 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RenderableIcon; });
/* harmony import */ var _image_renderable_image__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(90);

class RenderableIcon extends _image_renderable_image__WEBPACK_IMPORTED_MODULE_0__["default"] {
}


/***/ }),
/* 90 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RenderableImage; });
/* harmony import */ var _textured_renderable_primitive__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(91);

class RenderableImage extends _textured_renderable_primitive__WEBPACK_IMPORTED_MODULE_0__["default"] {
}


/***/ }),
/* 91 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TexturedRenderablePrimitive; });
/* harmony import */ var _renderable_primitive__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(71);

class TexturedRenderablePrimitive extends _renderable_primitive__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(memoryChunk, allocatedImage) {
        super(memoryChunk);
        this._allocatedImage = allocatedImage;
        this.atlas = allocatedImage.atlasManager.atlas;
        this._allocatedImage.retain();
    }
    _destroy() {
        this._allocatedImage.release();
        super._destroy();
    }
}


/***/ }),
/* 92 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TaskQueue; });
/* harmony import */ var _priority_queue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(68);
/* harmony import */ var _util_event_emitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(14);


const DEQUEUE_TIMEOUT = 1; // ms
/**
 * Prioritized task queue.
 */
class TaskQueue {
    /**
     * Constructs an empty task queue.
     */
    constructor() {
        this._queue = new _priority_queue__WEBPACK_IMPORTED_MODULE_0__["default"]();
        this._frozen = false;
        this._dequeueTimeoutHandle = 0;
        this.onEmpty = new _util_event_emitter__WEBPACK_IMPORTED_MODULE_1__["VoidEventEmitter"]();
    }
    /**
     * Destroys the queue. Any remaining tasks won't be executed.
     */
    destroy() {
        clearTimeout(this._dequeueTimeoutHandle);
    }
    /**
     * Enqueues a task to the queue and schedules processing of the queue.
     *
     * @param task The task.
     * @returns Promise that will be fullfilled when the task successfully
     *      finishes or rejected if there's an error.
     */
    enqueue(task) {
        if (!this._frozen) {
            this._setDequeueTimeout();
        }
        return new Promise((resolve, reject) => {
            this._queue.enqueue({
                execute() {
                    try {
                        task.execute();
                        resolve();
                    }
                    catch (error) {
                        reject(error);
                    }
                },
                priority: task.priority
            });
        });
    }
    isEmpty() {
        return this._queue.isEmpty();
    }
    freeze() {
        if (this._dequeueTimeoutHandle) {
            clearTimeout(this._dequeueTimeoutHandle);
            this._dequeueTimeoutHandle = 0;
        }
        this._frozen = true;
    }
    unfreeze() {
        this._frozen = false;
        if (!this._queue.isEmpty()) {
            this._setDequeueTimeout();
        }
    }
    _dequeue() {
        const task = this._queue.dequeue();
        if (task) {
            task.execute();
        }
        if (this._queue.isEmpty()) {
            this._dequeueTimeoutHandle = 0;
            this.onEmpty.fire();
        }
        else {
            this._dequeueTimeoutHandle = setTimeout(() => this._dequeue(), DEQUEUE_TIMEOUT);
        }
    }
    _setDequeueTimeout() {
        if (!this._dequeueTimeoutHandle) {
            this._dequeueTimeoutHandle = setTimeout(() => this._dequeue(), DEQUEUE_TIMEOUT);
        }
    }
}


/***/ }),
/* 93 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MouseDragController", function() { return MouseDragController; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ScrollZoomController", function() { return ScrollZoomController; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CameraMouseController", function() { return CameraMouseController; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "renderCameraState", function() { return renderCameraState; });
/* harmony import */ var _src_vector_render_engine_util_delegator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(94);
/* harmony import */ var _src_vector_render_engine_math_vector2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(23);


class MouseDragController extends _src_vector_render_engine_util_delegator__WEBPACK_IMPORTED_MODULE_0__["DelegatorBase"] {
    constructor(target) {
        super();
        this._target = target;
        this._pressedButton = -1 /* NONE */;
        this._prevMouseCoords = _src_vector_render_engine_math_vector2__WEBPACK_IMPORTED_MODULE_1__["create"](0, 0);
        target.addEventListener('mousedown', this);
        target.addEventListener('click', this);
        target.addEventListener('contextmenu', this);
    }
    handleEvent(e) {
        switch (e.type) {
            case 'click':
            case 'contextmenu':
                e.preventDefault();
                break;
            case 'mousedown':
                if (this._pressedButton === -1 /* NONE */) {
                    this._pressedButton = e.button;
                    this._prevMouseCoords.x = e.clientX;
                    this._prevMouseCoords.y = e.clientY;
                    document.body.addEventListener('mousemove', this);
                    document.body.addEventListener('mouseup', this);
                }
                e.preventDefault();
                break;
            case 'mousemove':
                if (this._delegate === null) {
                    break;
                }
                const mouseCoords = _src_vector_render_engine_math_vector2__WEBPACK_IMPORTED_MODULE_1__["create"](e.clientX, e.clientY);
                const delta = _src_vector_render_engine_math_vector2__WEBPACK_IMPORTED_MODULE_1__["sub"](mouseCoords, this._prevMouseCoords);
                switch (this._pressedButton) {
                    case 0 /* LEFT */:
                        this._delegate.onLeftButtonDrag(delta);
                        break;
                    case 1 /* MIDDLE */:
                        this._delegate.onMiddleButtonDrag(delta);
                        break;
                    case 2 /* RIGHT */:
                        this._delegate.onRightButtonDrag(delta);
                        break;
                }
                _src_vector_render_engine_math_vector2__WEBPACK_IMPORTED_MODULE_1__["copy"](mouseCoords, this._prevMouseCoords);
                e.preventDefault();
                break;
            case 'mouseup':
                if (this._pressedButton === e.button) {
                    document.body.removeEventListener('mouseup', this);
                    document.body.removeEventListener('mousemove', this);
                    this._pressedButton = -1 /* NONE */;
                }
                e.preventDefault();
                break;
        }
    }
    destroy() {
        this._target.removeEventListener('contextmenu', this);
        this._target.removeEventListener('click', this);
        this._target.removeEventListener('mousedown', this);
    }
}
class ScrollZoomController extends _src_vector_render_engine_util_delegator__WEBPACK_IMPORTED_MODULE_0__["DelegatorBase"] {
    constructor(target) {
        super();
        this._target = target;
        target.addEventListener('wheel', this);
    }
    handleEvent(e) {
        const delegate = this._delegate;
        if (!delegate) {
            return;
        }
        if (e.deltaY < 0) {
            delegate.onScrollIn();
        }
        else {
            delegate.onScrollOut();
        }
        e.preventDefault();
    }
    destroy() {
        this._target.removeEventListener('wheel', this);
    }
}
const ZOOM_STEP = 0.1;
const TILT_AZIMUTH_FACTOR = Math.PI / 1024;
class CameraMouseController {
    constructor(canvas, camera) {
        this._camera = camera;
        this._canvasSize = _src_vector_render_engine_math_vector2__WEBPACK_IMPORTED_MODULE_1__["create"](canvas.width, canvas.height);
        this.dragFactor = 1;
    }
    onLeftButtonDrag(delta) {
        // That's not exact, but good enough for now.
        _src_vector_render_engine_math_vector2__WEBPACK_IMPORTED_MODULE_1__["divv"](delta, this._canvasSize, delta);
        const camera = this._camera;
        _src_vector_render_engine_math_vector2__WEBPACK_IMPORTED_MODULE_1__["muln"](delta, this.dragFactor * camera.screenSize.height * Math.pow(2, -camera.zoom) /
            (Math.tan(0.5 * camera.options.fov) * 64), delta);
        const center = this._camera.center;
        center.x -= delta.x;
        center.y += delta.y;
        this._camera.setDirty();
    }
    onMiddleButtonDrag() { }
    onRightButtonDrag(delta) {
        const camera = this._camera;
        camera.tilt += delta.y * TILT_AZIMUTH_FACTOR;
        camera.azimuth += delta.x * TILT_AZIMUTH_FACTOR;
        this._camera.setDirty();
    }
    onScrollIn() {
        this._camera.zoom += ZOOM_STEP;
        this._camera.setDirty();
    }
    onScrollOut() {
        this._camera.zoom -= ZOOM_STEP;
        this._camera.setDirty();
    }
}
const cameraStateElement = document.querySelector('#camera_state');
const cameraStateText = cameraStateElement && cameraStateElement.firstChild;
function renderCameraState(camera) {
    const { center: { x, y }, zoom, tilt, azimuth } = camera;
    cameraStateText.replaceData(0, cameraStateText.length, `center: (${x.toFixed(8)},${y.toFixed(8)}); zoom: ${zoom.toFixed(4)}; ` +
        `tilt: ${tilt.toFixed(4)}; azimuth: ${azimuth.toFixed(4)}`);
}


/***/ }),
/* 94 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DelegatorBase", function() { return DelegatorBase; });
class DelegatorBase {
    constructor() {
        this._delegate = null;
    }
    setDelegate(delegate) {
        this._delegate = delegate;
    }
}


/***/ }),
/* 95 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ColorIdPointLabelRenderer; });
/* harmony import */ var _shader_point_label_vert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96);
/* harmony import */ var _shader_point_label_vert__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_shader_point_label_vert__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _shader_color_id_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(97);
/* harmony import */ var _shader_color_id_frag__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_shader_color_id_frag__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _color_id_label_renderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(98);
/* harmony import */ var _render_primitives_label_point_label_render_unit__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(104);




/**
 * Point labels renderer for collision resolution.
 */
class ColorIdPointLabelRenderer extends _color_id_label_renderer__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor(context, camera, primitiveProvider) {
        const program = context.createProgram(_shader_point_label_vert__WEBPACK_IMPORTED_MODULE_0___default.a, _shader_color_id_frag__WEBPACK_IMPORTED_MODULE_1___default.a, _render_primitives_label_point_label_render_unit__WEBPACK_IMPORTED_MODULE_3__["PROGRAM_OPTIONS"]);
        super(context, program, primitiveProvider, camera);
    }
}


/***/ }),
/* 96 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec2 vertexId;\n\n// point in the world the label is anchored to\nattribute vec2 vertexPosHigh;\nattribute vec2 vertexPosLow;\n\n// vector of concrete glyph point displacement (top-left, bottom-left, ...) relative to label's center, in px\nattribute vec2 vertexDisplacement;\n\n// coordinates of the glyph vertex in the atlas\nattribute vec2 vertexUV;\n\nattribute float vertexPriority;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\nuniform vec2 pixelSize;\nuniform sampler2D visibility;\nuniform vec2 idHalfPxSize;\nuniform vec2 shift;\nuniform lowp float currentZoom;\n\nvarying vec2 uv;\nvarying lowp vec4 color;\nvarying lowp vec4 outlineColor;\nvarying mediump float scale;\n\nconst vec4 DISCARD_POSITION = vec4(2, 2, 2, 1);\n\nconst float YV_H_1_0 = 1.999969482421875;\nconst float YV_L_1_1 = 0.000030517112463712692;\n\n/**\n * Projects specific point label vertex onto the screen.\n */\nvec4 projectPointLabelVertex_1_2(\n    mat4 viewProjMatrix,\n    vec2 lookAtHigh,\n    vec2 lookAtLow,\n    vec2 posHigh,\n    vec2 posLow,\n    vec2 displacement,\n    vec2 pxSize\n) {\n    vec4 position = viewProjMatrix * vec4(\n        YV_H_1_0 * (posHigh - lookAtHigh) +\n            YV_L_1_1 * (posLow - lookAtLow),\n        0,\n        1\n    );\n    position = vec4(position.xy / position.w, 0.0, 1.0);\n\n    return position + vec4(displacement * pxSize, 0.0, 0.0);\n}\n\n\n\n\nvoid main(void) {\n    vec2 idTexCoordinate = vertexId.xy + idHalfPxSize;\n    float overlapZoom = texture2D(visibility, idTexCoordinate).b;\n    if (currentZoom < overlapZoom) {\n        gl_Position = DISCARD_POSITION;\n    } else {\n        gl_Position = projectPointLabelVertex_1_2(\n            viewProjMatrix,\n            lookAtHigh,\n            lookAtLow,\n            vertexPosHigh,\n            vertexPosLow,\n            vertexDisplacement,\n            pixelSize\n        );\n        gl_Position.xy += shift;\n        gl_Position.z = vertexPriority;\n        color = vec4(vertexId, 0, 1);\n    }\n\n}\n"

/***/ }),
/* 97 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nvarying lowp vec4 color;\n\nvoid main(void) {\n    gl_FragColor = color;\n}\n"

/***/ }),
/* 98 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ColorIdLabelRenderer; });
/* harmony import */ var _colliding_primitive_color_id_renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(99);

/**
 * "color id" renderer for labels, both for point and curved ones.
 */
class ColorIdLabelRenderer extends _colliding_primitive_color_id_renderer__WEBPACK_IMPORTED_MODULE_0__["CollidingPrimitiveColorIdRenderer"] {
    constructor(context, program, primitiveProvider, camera) {
        super(context, program, primitiveProvider);
        this._camera = camera;
    }
    _prepareProgram(program, viewProjMatrix, cameraPositions, state, stabilityShift, visibility, currentZoom) {
        super._prepareProgram(program, viewProjMatrix, cameraPositions, state, stabilityShift, visibility, currentZoom);
        program.setVector2Uniform('pixelSize', this._camera.pixelSize);
    }
}


/***/ }),
/* 99 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CollidingPrimitiveColorIdRenderer", function() { return CollidingPrimitiveColorIdRenderer; });
/* harmony import */ var _render_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);
/* harmony import */ var _math_vector2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(23);
/* harmony import */ var _render_primitives_world_primitive_render_unit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(100);



class CollidingPrimitiveColorIdRenderer extends _render_primitives_world_primitive_render_unit__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor(context, program, primitiveProvider) {
        super(context, new _render_state__WEBPACK_IMPORTED_MODULE_0__["default"](), program, primitiveProvider);
        this._idHalfPxSizeUniform = _math_vector2__WEBPACK_IMPORTED_MODULE_1__["create"](0, 0);
    }
    _getPrimitives() {
        return this.primitiveProvider.visiblePrimitives;
    }
    _prepareProgram(program, viewProjMatrix, cameraPositions, state, stabilityShift, visibility, currentZoom) {
        super._prepareProgram(program, viewProjMatrix, cameraPositions, state, stabilityShift, visibility, currentZoom);
        this._idHalfPxSizeUniform.x = 0.5 / visibility.getWidth();
        this._idHalfPxSizeUniform.y = 0.5 / visibility.getHeight();
        this._context.bindTextureUnit(0);
        this._context.bindTexture(visibility);
        program.setIntScalarUniform('visibility', 0);
        program.setVector2Uniform('idHalfPxSize', this._idHalfPxSizeUniform);
        program.setVector2Uniform('shift', stabilityShift);
        program.setScalarUniform('currentZoom', currentZoom);
    }
    _prepareRenderTarget(target, _viewProjMatrix, _cameraPositions, state, _stabilityShift, _visibility, _currentZoom) {
        this._context.bindRenderState(state);
        this._context.bindRenderTarget(target);
    }
}


/***/ }),
/* 100 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WorldPrimitiveRenderUnit; });
/* harmony import */ var _gl_renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(101);
/* harmony import */ var _memory_count_vertices__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(41);
/* harmony import */ var _primitive_batch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(102);



/**
 * Base class for rendering visible primitives. Being visible in the world means that they all need view-projection
 * matrix and camera positions (multiple positions are used for rendering repeated world). These parameters are
 * predefined as external requirements for render() method.
 */
class WorldPrimitiveRenderUnit extends _gl_renderer__WEBPACK_IMPORTED_MODULE_0__["GlRenderer"] {
    constructor(context, renderState, program, primitiveProvider) {
        super(context, renderState, program);
        this.primitiveProvider = primitiveProvider;
        this.onUpdate = primitiveProvider.onUpdate;
    }
    render(target, viewProjMatrix, cameraPositions, ...args) {
        super.render(target, viewProjMatrix, cameraPositions, ...args);
    }
    _render(_viewProjMatrix, cameraPositions) {
        for (const cameraPosition of cameraPositions) {
            this._program.setVector2Uniform('lookAtHigh', cameraPosition.lookAtHigh);
            this._program.setVector2Uniform('lookAtLow', cameraPosition.lookAtLow);
            for (const memoryBatch of Object(_primitive_batch__WEBPACK_IMPORTED_MODULE_2__["batchPrimitives"])(this._getPrimitives(), this._canBatchAdjacentPrimitives)) {
                this._renderBatch(memoryBatch);
            }
        }
    }
    _getPrimitives() {
        return this.primitiveProvider.primitives;
    }
    _prepareProgram(program, viewProjMatrix, cameraPositions, ...args) {
        super._prepareProgram(program, viewProjMatrix, cameraPositions, ...args);
        program.setMatrix4Uniform('viewProjMatrix', viewProjMatrix);
    }
    _renderBatch(memoryBatch) {
        this._context.bindVao(memoryBatch.page.vao);
        this._context.drawIndexedMesh(memoryBatch.indexByteOffset, Object(_memory_count_vertices__WEBPACK_IMPORTED_MODULE_1__["countIndices"])(memoryBatch.indexByteLength, memoryBatch.page.indexType));
    }
    /**
     * Determines if two adjacent primitives can be rendered in one batch (by a single draw call). They already
     * lay successively in memory, but there could be other reasons that forbid batching, like using different textures.
     * The method should be overridden in subclasses if their primitives have such complex rules of batching.
     */
    _canBatchAdjacentPrimitives(_a, _b) {
        return true;
    }
}


/***/ }),
/* 101 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GlRenderer", function() { return GlRenderer; });
/**
 * Base class for any WebGL renderer, it just defines basic structure of GL-calls allowing to override any part.
 * A specific renderer may need any number of additional arguments to perform rendering, they are provided in
 * additionalParams in the render() method.
 */
class GlRenderer {
    constructor(context, renderState, program) {
        this._context = context;
        this._renderState = renderState;
        this._program = program;
    }
    render(target, ...args) {
        if (this._program) {
            this._prepareProgram(this._program, ...args);
        }
        this._prepareRenderTarget(target, ...args);
        this._render(...args);
    }
    destroy() {
        if (this._program) {
            this._program.destroy();
        }
    }
    /**
     * Binds program and sets required uniforms. Subclasses are supposed to override
     * this method to add their own uniforms.
     */
    _prepareProgram(program, ..._args) {
        this._context.bindProgram(program);
    }
    /**
     * Binds render state and render target, no clear happens here, but this method
     * can be overridden in subclasses to add any setups they need.
     */
    _prepareRenderTarget(target, ..._args) {
        this._context.bindRenderState(this._renderState);
        this._context.bindRenderTarget(target);
    }
}


/***/ }),
/* 102 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchPrimitives", function() { return batchPrimitives; });
/* harmony import */ var _memory_relative_location__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(103);

/**
 * Creates batch from first primitives.
 */
function initBatch(primitive) {
    const subChunk = primitive.memorySubChunk;
    return {
        firstPrimitive: primitive,
        page: subChunk.memoryChunk.page,
        vertexByteOffset: subChunk.vertexByteOffset,
        vertexByteLength: subChunk.vertexByteLength,
        indexByteOffset: subChunk.indexByteOffset,
        indexByteLength: subChunk.indexByteLength
    };
}
/**
 * Batches primitives that can be rendered by a single draw call, that is critical for performance.
 * Performance gain from this method is possible (while it is not strictly required) if primitives
 * are sorted by memory offset and there are no many "holes" between them.
 * Minimal requiremets for batching is location in the same buffer (memory page), additional
 * requirements (such as having shared texture or similar) can be imposed in canBatchPridicate.
 */
function batchPrimitives(primitives, canBatchPridicate) {
    const canBatch = (a, b) => {
        if (
        // minimal requirements for batching is that primitives lay in the same page
        (a.memorySubChunk.memoryChunk.page !== b.memorySubChunk.memoryChunk.page) ||
            // chack external requirements if specified
            (canBatchPridicate && !canBatchPridicate(a, b))) {
            return false;
        }
        else {
            return true;
        }
    };
    return Object(_memory_relative_location__WEBPACK_IMPORTED_MODULE_0__["batchAllocatedObjects"])(primitives, (primitive) => primitive.memorySubChunk, initBatch, canBatch);
}


/***/ }),
/* 103 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "appendToBatch", function() { return appendToBatch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchAllocatedObjects", function() { return batchAllocatedObjects; });
/**
 * Appends portion of memory to batch if they are adjacent.
 *
 * @returns `true` if both params are adjacent and the batch was successfully updated, `false` otherwise.
 */
function appendToBatch(memoryLocation, batch) {
    if (batch.vertexByteOffset + batch.vertexByteLength === memoryLocation.vertexByteOffset &&
        batch.indexByteOffset + batch.indexByteLength === memoryLocation.indexByteOffset) {
        batch.vertexByteLength += memoryLocation.vertexByteLength;
        batch.indexByteLength += memoryLocation.indexByteLength;
        return true;
    }
    return false;
}
/**
 * Combines objects allocated in memory into batches. No sorting is done in this method, the objects are supposed
 * to be sorted by index/vertex offsets to make batching effective. The batch is created by factory since it can
 * contains problem specific information.
 *
 * @param objects List of allocated objects.
 * @param getMemoryLocation Returns memory location of specific object.
 * @param createBatch Initiates batch by the first object.
 * @param canBatch Checks if two objects can be allocated.
 * @returns Iterable list of batches.
 */
function* batchAllocatedObjects(objects, getMemoryLocation, createBatch, canBatch = () => true) {
    const iterator = objects[Symbol.iterator]();
    let primitive = iterator.next().value;
    if (!primitive) {
        return;
    }
    let prev = primitive;
    let batch = createBatch(prev);
    primitive = iterator.next().value;
    while (primitive) {
        const primitiveMemoryLocation = getMemoryLocation(primitive);
        if (!canBatch(prev, primitive, batch) || !appendToBatch(primitiveMemoryLocation, batch)) {
            yield batch;
            batch = createBatch(primitive);
        }
        prev = primitive;
        primitive = iterator.next().value;
    }
    yield batch;
}


/***/ }),
/* 104 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PROGRAM_OPTIONS", function() { return PROGRAM_OPTIONS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PointLabelRenderUnit; });
/* harmony import */ var _shader_point_label_vert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(105);
/* harmony import */ var _shader_point_label_vert__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_shader_point_label_vert__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _shader_df_text_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(106);
/* harmony import */ var _shader_df_text_frag__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_shader_df_text_frag__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _label_render_unit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(107);
/* harmony import */ var _billboard_rectangle_billboard_rectangle_render_unit__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(108);
/* harmony import */ var _util_event_emitter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(14);
/* harmony import */ var _util_iterable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(3);






const PROGRAM_OPTIONS = {
    attribMap: {
        vertexId: 2 /* ID */,
        vertexPosHigh: 0 /* POSITION_HIGH */,
        vertexPosLow: 1 /* POSITION_LOW */,
        vertexDisplacement: 6 /* DISPLACEMENT */,
        vertexUV: 4 /* UV */,
        vertexPriority: 9 /* PRIORITY */,
        vertexColor: 7 /* COLOR */,
        vertexOutlineColor: 8 /* OUTLINE_COLOR */,
        vertexScale: 11 /* AUX */
    }
};
/**
 * Renders backgrounds extracted from point labels.
 */
class BackgroundPrimitiveProvider {
    constructor(labelsProvider) {
        this.onUpdate = new _util_event_emitter__WEBPACK_IMPORTED_MODULE_4__["VoidEventEmitter"]();
        this._labelsProvider = labelsProvider;
    }
    get primitives() {
        return Object(_util_iterable__WEBPACK_IMPORTED_MODULE_5__["mapIterable"])(Object(_util_iterable__WEBPACK_IMPORTED_MODULE_5__["filterIterable"])(this._labelsProvider.primitives, (label) => label.background !== undefined), (label) => label.background);
    }
}
/**
 * Point labels renderer. It uses appropriate program to layout glyphs on GPU.
 */
class PointLabelRenderUnit extends _label_render_unit__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor(context, camera, visibilityProvider, primitiveProvider) {
        const program = context.createProgram(_shader_point_label_vert__WEBPACK_IMPORTED_MODULE_0___default.a, _shader_df_text_frag__WEBPACK_IMPORTED_MODULE_1___default.a, PROGRAM_OPTIONS);
        super(context, program, camera, visibilityProvider, primitiveProvider);
        this._backgroundRenderer = new _billboard_rectangle_billboard_rectangle_render_unit__WEBPACK_IMPORTED_MODULE_3__["default"](context, camera, visibilityProvider, new BackgroundPrimitiveProvider(primitiveProvider));
        this._backgroundRenderer.onUpdate.addListener(() => this.onUpdate.fire());
    }
    render(target, viewProjMatrix, cameraPositions) {
        this._backgroundRenderer.render(target, viewProjMatrix, cameraPositions);
        super.render(target, viewProjMatrix, cameraPositions);
    }
}


/***/ }),
/* 105 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec2 vertexId;\n\n// point in the world the label is anchored to\nattribute vec2 vertexPosHigh;\nattribute vec2 vertexPosLow;\n\n// vector of concrete glyph point displacement (top-left, bottom-left, ...) relative to label's center, in px\nattribute vec2 vertexDisplacement;\n\n// coordinates of the glyph vertex in the atlas\nattribute vec2 vertexUV;\n\nattribute float vertexPriority;\n\nattribute lowp vec4 vertexColor;\nattribute lowp vec4 vertexOutlineColor;\nattribute float vertexScale;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\nuniform vec2 pixelSize;\nuniform sampler2D visibility;\nuniform vec2 idHalfPxSize;\nuniform vec2 shift;\nuniform lowp float currentZoom;\n\nvarying vec2 uv;\nvarying lowp vec4 color;\nvarying lowp vec4 outlineColor;\nvarying mediump float scale;\n\nconst vec4 DISCARD_POSITION = vec4(2, 2, 2, 1);\n\nconst float YV_H_1_0 = 1.999969482421875;\nconst float YV_L_1_1 = 0.000030517112463712692;\n\n/**\n * Projects specific point label vertex onto the screen.\n */\nvec4 projectPointLabelVertex_1_2(\n    mat4 viewProjMatrix,\n    vec2 lookAtHigh,\n    vec2 lookAtLow,\n    vec2 posHigh,\n    vec2 posLow,\n    vec2 displacement,\n    vec2 pxSize\n) {\n    vec4 position = viewProjMatrix * vec4(\n        YV_H_1_0 * (posHigh - lookAtHigh) +\n            YV_L_1_1 * (posLow - lookAtLow),\n        0,\n        1\n    );\n    position = vec4(position.xy / position.w, 0.0, 1.0);\n\n    return position + vec4(displacement * pxSize, 0.0, 0.0);\n}\n\n\n\n\nvoid main(void) {\n    float visibilityAlpha = texture2D(visibility, vertexId.xy + idHalfPxSize).a;\n    if (visibilityAlpha != 0.0) {\n        gl_Position = projectPointLabelVertex_1_2(\n            viewProjMatrix,\n            lookAtHigh,\n            lookAtLow,\n            vertexPosHigh,\n            vertexPosLow,\n            vertexDisplacement,\n            pixelSize\n        );\n\n        uv = vertexUV;\n        color = vertexColor;\n        outlineColor = vertexOutlineColor;\n        scale = vertexScale;\n\n        color.a *= visibilityAlpha;\n        outlineColor.a *= visibilityAlpha;\n    } else {\n        gl_Position = DISCARD_POSITION;\n    }\n}\n"

/***/ }),
/* 106 */
/***/ (function(module, exports) {

module.exports = "#version 100\n\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform float dpr;\nuniform sampler2D atlas;\nuniform vec2 atlasSize;\n\nvarying vec2 uv;\nvarying lowp vec4 color;\nvarying lowp vec4 outlineColor;\nvarying float scale;\n\nconst float MAX_CORRECTED_GLYPH_SCALE = 0.5;\nconst float GLYPH_BASE_WEIGHT = 0.7;\nconst float GLYPH_BASE_SMOTHNESS = 0.1;\nconst float GLYPH_WEIGHT_SCALE_IMPACT = 0.1;\nconst float GLYPH_SMOOTHNESS_SCALE_IMPACT = 0.06;\nconst float OUTLINE_WEIGHT_SCALE_IMPACT = 0.125;\n\nvoid main(void) {\n    // low scale glyphs (less than 0.5) should be a little bit bolder and smoother\n    float scaleClamped = clamp(scale, 0.0, MAX_CORRECTED_GLYPH_SCALE);\n    // weight is responsible for glyph boldness, the less weight value the bolder the text\n    float weight = GLYPH_BASE_WEIGHT + GLYPH_WEIGHT_SCALE_IMPACT * scaleClamped;\n    // smoothness is how blurred glyphs are, the less smoothness value the less blurring\n    float smoothness = (GLYPH_BASE_SMOTHNESS + GLYPH_SMOOTHNESS_SCALE_IMPACT / scaleClamped) / dpr;\n\n    vec4 resultColor = color;\n    float dist = texture2D(atlas, uv / atlasSize).a;\n    float alpha = smoothstep(weight - smoothness, weight + smoothness, dist);\n\n    if (outlineColor.a != 0.0) {\n        // to render outline the glyph is rendered a little bit bolder with different color at edges\n        weight = weight - OUTLINE_WEIGHT_SCALE_IMPACT / scale;\n        resultColor = mix(outlineColor, color, alpha);\n        alpha = smoothstep(weight - smoothness, weight + smoothness, dist);\n    }\n\n    gl_FragColor = vec4(resultColor.rgb, resultColor.a * alpha);\n}\n"

/***/ }),
/* 107 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LabelRenderUnit; });
/* harmony import */ var _world_primitive_render_unit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(100);
/* harmony import */ var _math_vector2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(23);
/* harmony import */ var _render_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(10);



/**
 * Base renderer that incapsulates all the GL specifics to make labels rendered.
 */
class LabelRenderUnit extends _world_primitive_render_unit__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(context, program, camera, visibilityProvider, primitiveProvider) {
        super(context, new _render_state__WEBPACK_IMPORTED_MODULE_2__["default"](_render_state__WEBPACK_IMPORTED_MODULE_2__["BLEND_OVER_RENDER_STATE"]), program, primitiveProvider);
        this._camera = camera;
        this._visibilityProvider = visibilityProvider;
        this._idHalfPxSizeUniform = _math_vector2__WEBPACK_IMPORTED_MODULE_1__["create"](0, 0);
        this._atlasSizeUniform = _math_vector2__WEBPACK_IMPORTED_MODULE_1__["create"](0, 0);
        context.bindProgram(program);
        program.setIntScalarUniform('visibility', 0);
    }
    _prepareProgram(program, viewProjMatrix, cameraPositions) {
        const visibility = this._visibilityProvider();
        super._prepareProgram(program, viewProjMatrix, cameraPositions);
        this._idHalfPxSizeUniform.x = 0.5 / visibility.getWidth();
        this._idHalfPxSizeUniform.y = 0.5 / visibility.getHeight();
        this._context.bindTextureUnit(0);
        this._context.bindTexture(visibility);
        program.setVector2Uniform('idHalfPxSize', this._idHalfPxSizeUniform);
        program.setVector2Uniform('pixelSize', this._camera.pixelSize);
        program.setScalarUniform('dpr', window.devicePixelRatio);
    }
    _renderBatch(memoryBatch) {
        const atlas = memoryBatch.firstPrimitive.atlas;
        this._atlasSizeUniform.x = atlas.width;
        this._atlasSizeUniform.y = atlas.height;
        this._program.setIntScalarUniform('atlas', 1);
        this._program.setVector2Uniform('atlasSize', this._atlasSizeUniform);
        this._context.bindTextureUnit(1);
        this._context.bindTexture(atlas.texture);
        super._renderBatch(memoryBatch);
    }
    _canBatchAdjacentPrimitives(a, b) {
        return super._canBatchAdjacentPrimitives(a, b) && (a.atlas === b.atlas);
    }
}


/***/ }),
/* 108 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BillboardRectangleRenderUnit; });
/* harmony import */ var _shader_billboard_rectangle_vert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(109);
/* harmony import */ var _shader_billboard_rectangle_vert__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_shader_billboard_rectangle_vert__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _shader_billboard_rectangle_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(110);
/* harmony import */ var _shader_billboard_rectangle_frag__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_shader_billboard_rectangle_frag__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _math_vector2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(23);
/* harmony import */ var _world_primitive_render_unit__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(100);
/* harmony import */ var _render_state__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(10);






const RENDER_STATE = new _render_state__WEBPACK_IMPORTED_MODULE_4__["default"](_render_state__WEBPACK_IMPORTED_MODULE_4__["BLEND_OVER_RENDER_STATE"]);
/**
 * Renderer of billboard rectangles.
 */
class BillboardRectangleRenderUnit extends _world_primitive_render_unit__WEBPACK_IMPORTED_MODULE_3__["default"] {
    constructor(context, camera, visibilityProvider, primitiveProvider) {
        const program = context.createProgram(_shader_billboard_rectangle_vert__WEBPACK_IMPORTED_MODULE_0___default.a, _shader_billboard_rectangle_frag__WEBPACK_IMPORTED_MODULE_1___default.a, {
            attribMap: {
                vertexId: 2 /* ID */,
                vertexPosHigh: 0 /* POSITION_HIGH */,
                vertexPosLow: 1 /* POSITION_LOW */,
                vertexDisplacement: 6 /* DISPLACEMENT */,
                vertexUV: 4 /* UV */,
                vertexColor: 7 /* COLOR */,
                vertexBorderRadii: 11 /* AUX */
            }
        });
        super(context, RENDER_STATE, program, primitiveProvider);
        this._visibilityProvider = visibilityProvider;
        this._camera = camera;
        this._visibilitySizeUniform = _math_vector2__WEBPACK_IMPORTED_MODULE_2__["create"](0, 0);
        context.bindProgram(program);
        program.setIntScalarUniform('visibility', 0);
    }
    _prepareProgram(program, viewProjMatrix, cameraPositions) {
        super._prepareProgram(program, viewProjMatrix, cameraPositions);
        const visibility = this._visibilityProvider();
        this._visibilitySizeUniform.x = visibility.getWidth();
        this._visibilitySizeUniform.y = visibility.getHeight();
        this._context.bindTextureUnit(0);
        this._context.bindTexture(visibility);
        program.setVector2Uniform('visibilitySize', this._visibilitySizeUniform);
        program.setVector2Uniform('pixelSize', this._camera.pixelSize);
    }
}


/***/ }),
/* 109 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec2 vertexId;\nattribute vec2 vertexPosHigh;\nattribute vec2 vertexPosLow;\nattribute vec2 vertexDisplacement;\nattribute vec2 vertexUV;\nattribute vec4 vertexColor;\nattribute vec2 vertexBorderRadii;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\nuniform vec2 pixelSize;\nuniform sampler2D visibility;\nuniform vec2 visibilitySize;\n\nvarying vec2 uv;\nvarying vec4 color;\nvarying vec2 borderRadii;\n\nconst vec4 DISCARD_POSITION = vec4(2, 2, 2, 1);\nconst float YV_H = 1.999969482421875;\nconst float YV_L = 0.000030517112463712692;\nvec2 VISIBILITY_HALF_PX = 0.5 / visibilitySize;\n\nvoid main(void) {\n    float visibilityAlpha = texture2D(visibility, vertexId.xy + VISIBILITY_HALF_PX).a;\n    if (visibilityAlpha == 0.0) {\n        gl_Position = DISCARD_POSITION;\n        return;\n    }\n\n    vec4 position = viewProjMatrix * vec4(\n        YV_H * (vertexPosHigh - lookAtHigh) +\n            YV_L * (vertexPosLow - lookAtLow),\n        0,\n        1\n    );\n    position.xyz /= position.w;\n    position.w = 1.0;\n\n    gl_Position = position + vec4(vertexDisplacement * pixelSize, 0.0, 0.0);\n\n    uv = vertexUV;\n    color = vertexColor;\n    color.a *= visibilityAlpha;\n    borderRadii = vertexBorderRadii;\n}\n"

/***/ }),
/* 110 */
/***/ (function(module, exports) {

module.exports = "#version 100\n\nprecision mediump float;\n#define GLSLIFY 1\n\nvarying vec2 uv;\nvarying vec4 color;\nvarying vec2 borderRadii;\n\nfloat roundedRectangle(const in vec2 uv, const in vec2 radii) {\n    vec2 absUv = abs(uv);\n    vec2 q = absUv + radii - 1.0;\n    return min(q.x, q.y) > 0.0 ? length(q / radii) : max(absUv.x, absUv.y);\n}\n\nvoid main(void) {\n    gl_FragColor = step(roundedRectangle(uv, borderRadii), 1.0) * color;\n}\n"

/***/ }),
/* 111 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ColorIdCurvedLabelRenderer; });
/* harmony import */ var _shader_curved_label_vert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(112);
/* harmony import */ var _shader_curved_label_vert__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_shader_curved_label_vert__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _shader_color_id_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(97);
/* harmony import */ var _shader_color_id_frag__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_shader_color_id_frag__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _render_primitives_label_curved_label_render_unit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(113);
/* harmony import */ var _color_id_label_renderer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(98);




/**
 * Curved labels renderer for collision resolution.
 */
class ColorIdCurvedLabelRenderer extends _color_id_label_renderer__WEBPACK_IMPORTED_MODULE_3__["default"] {
    constructor(context, camera, primitiveProvider) {
        const program = context.createProgram(_shader_curved_label_vert__WEBPACK_IMPORTED_MODULE_0___default.a, _shader_color_id_frag__WEBPACK_IMPORTED_MODULE_1___default.a, _render_primitives_label_curved_label_render_unit__WEBPACK_IMPORTED_MODULE_2__["PROGRAM_OPTIONS"]);
        super(context, program, primitiveProvider, camera);
    }
}


/***/ }),
/* 112 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec2 vertexId;\n\n// point in the world the label is anchored to\nattribute vec2 vertexPosHigh;\nattribute vec2 vertexPosLow;\n\n// vector of concrete glyph point displacement (top-left, bottom-left, ...) relative to glyph's center (two values),\n// and distance of the glyph center to label's center (third value), in px\nattribute vec3 vertexDisplacements;\n\n// coordinates of the glyph vertex in the atlas\nattribute vec2 vertexUV;\n\nattribute float vertexPriority;\n\nattribute lowp vec4 vertexColor;\nattribute lowp vec4 vertexOutlineColor;\nattribute vec2 polylineLength_vertexScale;\n\n// deltas relative to the world point encoded in vertexPosHigh/vertexPosLow encoded via lengths and and angles of\n// corresponding vectors\nattribute vec4 leftPolylineRatios;\nattribute vec4 leftPolylineAngles;\nattribute vec4 rightPolylineRatios;\nattribute vec4 rightPolylineAngles;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\nuniform vec2 pixelSize;\nuniform sampler2D visibility;\nuniform vec2 idHalfPxSize;\nuniform vec2 shift;\nuniform lowp float currentZoom;\n\nvarying vec2 uv;\nvarying lowp vec4 color;\nvarying lowp vec4 outlineColor;\nvarying float scale;\n\nconst vec4 DISCARD_POSITION = vec4(2, 2, 2, 1);\n\nconst float YV_H_1_0 = 1.999969482421875;\nconst float YV_L_1_1 = 0.000030517112463712692;\n\nconst float PI_1_2 = 3.1415927410125732;\n\nconst int MAX_POLYLINE_POINTS_1_3 = 4;\nconst float INFINITY_1_4 = 1000000.0; // large enough for a segment length to consider it infinity\n\n/**\n * Returns world coordinate (plus delta) projected on screen, in pixels.\n */\nvec2 project_1_5(\n    mat4 viewProjMatrix,\n    vec2 lookAtHigh,\n    vec2 lookAtLow,\n    vec2 pixelSize,\n    vec2 pointHigh,\n    vec2 pointLow,\n    vec2 delta\n) {\n    vec4 position = viewProjMatrix * vec4(\n            YV_H_1_0 * (pointHigh - lookAtHigh) + YV_L_1_1 * (pointLow - lookAtLow) + delta,\n            0,\n            1\n        );\n    vec2 projected = position.xy / position.w;\n    return projected / pixelSize;\n}\n\n/**\n * Each point of the polyline is encoded as a vector from the polyline center by its normalized angle and the ratio of\n * its length to the polyline's length.\n */\nvec2 decodePolylineDeltas_1_6(float ratio, float angle, float polylineLength) {\n    // denormalize angle back to radians\n    float a = angle * 2.0 * PI_1_2 - PI_1_2;\n    // length of a vector\n    float len = ratio * polylineLength;\n    // restored point's (x, y) coordinates\n    return vec2(cos(a), sin(a)) * len;\n}\n\n/**\n * Projects specific curved label vertex onto the screen. The label is layouted by centering polyline in\n * the vertexPosHigh/vertexPosLow and other points are used to guide concrete gryph vertex.\n * Number of polyline points is hardcoded to pass them in attributes.\n */\nvec4 projectCurvedLabelVertex_1_7(\n    mat4 viewProjMatrix,\n    vec2 lookAtHigh,\n    vec2 lookAtLow,\n    vec2 pxSize,\n    vec2 posHigh,\n    vec2 posLow,\n    vec2 displacement,\n    float lineDisplacement,\n    float polylineLength,\n    vec4 leftPolylineRatios,\n    vec4 leftPolylineAngles,\n    vec4 rightPolylineRatios,\n    vec4 rightPolylineAngles\n) {\n    vec2 polylineDeltas[MAX_POLYLINE_POINTS_1_3];\n    vec2 position = project_1_5(viewProjMatrix, lookAtHigh, lookAtLow, pxSize, posHigh, posLow, vec2(0, 0));\n    float remainingLength = abs(lineDisplacement);\n    for (int i = 0; i < MAX_POLYLINE_POINTS_1_3; i++) {\n        vec2 projectedPoint;\n\n        // figure out the direction (left/right) at the first step\n        if (i == 0) {\n            projectedPoint = project_1_5(\n                viewProjMatrix,\n                lookAtHigh,\n                lookAtLow,\n                pxSize,\n                posHigh,\n                posLow,\n                decodePolylineDeltas_1_6(rightPolylineRatios[0], rightPolylineAngles[0], polylineLength)\n            );\n            bool isRightPart = lineDisplacement > 0.0;\n            bool isInverted = projectedPoint.x < position.x;\n\n            // the map could be rotated and curved label should change its direction if they got upside down\n            // using center segment to identify this case is an approximation (ideally we should check all segments)\n            if (isRightPart ^^ isInverted) {\n                polylineDeltas[0] = decodePolylineDeltas_1_6(rightPolylineRatios[0], rightPolylineAngles[0], polylineLength);\n                polylineDeltas[1] = decodePolylineDeltas_1_6(rightPolylineRatios[1], rightPolylineAngles[1], polylineLength);\n                polylineDeltas[2] = decodePolylineDeltas_1_6(rightPolylineRatios[2], rightPolylineAngles[2], polylineLength);\n                polylineDeltas[3] = decodePolylineDeltas_1_6(rightPolylineRatios[3], rightPolylineAngles[3], polylineLength);\n            } else {\n                polylineDeltas[0] = decodePolylineDeltas_1_6(leftPolylineRatios[0], leftPolylineAngles[0], polylineLength);\n                polylineDeltas[1] = decodePolylineDeltas_1_6(leftPolylineRatios[1], leftPolylineAngles[1], polylineLength);\n                polylineDeltas[2] = decodePolylineDeltas_1_6(leftPolylineRatios[2], leftPolylineAngles[2], polylineLength);\n                polylineDeltas[3] = decodePolylineDeltas_1_6(leftPolylineRatios[3], leftPolylineAngles[3], polylineLength);\n            }\n\n            // the first right point of the segment already calculated,\n            // recalculate the point if this part of the label goes other direction\n            if (!(isRightPart && !isInverted) && !(!isRightPart && isInverted)) {\n                projectedPoint = project_1_5(viewProjMatrix, lookAtHigh, lookAtLow, pxSize, posHigh, posLow, polylineDeltas[i]);\n            }\n        } else {\n            projectedPoint = project_1_5(viewProjMatrix, lookAtHigh, lookAtLow, pxSize, posHigh, posLow, polylineDeltas[i]);\n        }\n\n        vec2 segment = projectedPoint - position;\n        bool isLast = i == (MAX_POLYLINE_POINTS_1_3 - 1);\n        float segmentLength = (isLast || (polylineDeltas[i + 1] == vec2(0, 0))) ? INFINITY_1_4 : length(segment);\n\n        if (segmentLength > remainingLength) {\n            float signFactor = lineDisplacement > 0.0 ? 1.0 : -1.0;\n            vec2 direction = normalize(segment);\n            vec2 normal = vec2(-direction.y, direction.x);\n\n            position += direction * remainingLength;\n            position += signFactor * direction * displacement.x;\n            position += signFactor * normal * displacement.y;\n\n            break;\n        } else {\n            remainingLength -= segmentLength;\n            position += segment;\n        }\n    }\n\n    return vec4(position * pxSize, 0.0, 1.0);\n}\n\n\n\n\n\n/**\n * Curved labels are layouted here: the label is centered in the vertexPosHigh/vertexPosLow and polyline points\n * are used to guide concrete gryph vertex. Number of polyline points is hardcoded to pass them in attributes.\n */\nvoid main(void) {\n    vec2 idTexCoordinate = vertexId.xy + idHalfPxSize;\n    float overlapZoom = texture2D(visibility, idTexCoordinate).b;\n\n    if (currentZoom < overlapZoom) {\n        gl_Position = DISCARD_POSITION;\n    } else {\n        vec2 vertexDisplacement = vertexDisplacements.xy;\n        float vertexLineDisplacement = vertexDisplacements.z;\n        float polylineLength = polylineLength_vertexScale[0];\n        gl_Position = projectCurvedLabelVertex_1_7(\n            viewProjMatrix,\n            lookAtHigh,\n            lookAtLow,\n            pixelSize,\n            vertexPosHigh,\n            vertexPosLow,\n            vertexDisplacement,\n            vertexLineDisplacement,\n            polylineLength,\n            leftPolylineRatios,\n            leftPolylineAngles,\n            rightPolylineRatios,\n            rightPolylineAngles\n        );\n\n        gl_Position.xy += shift;\n        gl_Position.z = vertexPriority;\n\n        color = vec4(vertexId, 0, 1);\n    }\n}\n"

/***/ }),
/* 113 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PROGRAM_OPTIONS", function() { return PROGRAM_OPTIONS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CurvedLabelRenderUnit; });
/* harmony import */ var _shader_curved_label_vert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(114);
/* harmony import */ var _shader_curved_label_vert__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_shader_curved_label_vert__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _shader_df_text_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(106);
/* harmony import */ var _shader_df_text_frag__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_shader_df_text_frag__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _label_render_unit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(107);



const PROGRAM_OPTIONS = {
    attribMap: {
        vertexId: 2 /* ID */,
        vertexPosHigh: 0 /* POSITION_HIGH */,
        vertexPosLow: 1 /* POSITION_LOW */,
        vertexDisplacements: 6 /* DISPLACEMENT */,
        vertexUV: 4 /* UV */,
        vertexColor: 7 /* COLOR */,
        vertexOutlineColor: 8 /* OUTLINE_COLOR */,
        vertexPriority: 9 /* PRIORITY */,
        leftPolylineRatios: 12 /* AUX1 */,
        leftPolylineAngles: 13 /* AUX2 */,
        rightPolylineRatios: 14 /* AUX3 */,
        rightPolylineAngles: 15 /* AUX4 */,
        polylineLength_vertexScale: 11 /* AUX */
    }
};
/**
 * Curved labels renderer. It uses appropriate program to layout glyphs on GPU.
 */
class CurvedLabelRenderUnit extends _label_render_unit__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor(context, camera, visibilityProvider, primitiveProvider) {
        const program = context.createProgram(_shader_curved_label_vert__WEBPACK_IMPORTED_MODULE_0___default.a, _shader_df_text_frag__WEBPACK_IMPORTED_MODULE_1___default.a, PROGRAM_OPTIONS);
        super(context, program, camera, visibilityProvider, primitiveProvider);
    }
}


/***/ }),
/* 114 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec2 vertexId;\n\n// point in the world the label is anchored to\nattribute vec2 vertexPosHigh;\nattribute vec2 vertexPosLow;\n\n// vector of concrete glyph point displacement (top-left, bottom-left, ...) relative to glyph's center (two values),\n// and distance of the glyph center to label's center (third value), in px\nattribute vec3 vertexDisplacements;\n\n// coordinates of the glyph vertex in the atlas\nattribute vec2 vertexUV;\n\nattribute float vertexPriority;\n\nattribute lowp vec4 vertexColor;\nattribute lowp vec4 vertexOutlineColor;\nattribute vec2 polylineLength_vertexScale;\n\n// deltas relative to the world point encoded in vertexPosHigh/vertexPosLow encoded via lengths and and angles of\n// corresponding vectors\nattribute vec4 leftPolylineRatios;\nattribute vec4 leftPolylineAngles;\nattribute vec4 rightPolylineRatios;\nattribute vec4 rightPolylineAngles;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\nuniform vec2 pixelSize;\nuniform sampler2D visibility;\nuniform vec2 idHalfPxSize;\nuniform vec2 shift;\nuniform lowp float currentZoom;\n\nvarying vec2 uv;\nvarying lowp vec4 color;\nvarying lowp vec4 outlineColor;\nvarying float scale;\n\nconst vec4 DISCARD_POSITION = vec4(2, 2, 2, 1);\n\nconst float YV_H_1_0 = 1.999969482421875;\nconst float YV_L_1_1 = 0.000030517112463712692;\n\nconst float PI_1_2 = 3.1415927410125732;\n\nconst int MAX_POLYLINE_POINTS_1_3 = 4;\nconst float INFINITY_1_4 = 1000000.0; // large enough for a segment length to consider it infinity\n\n/**\n * Returns world coordinate (plus delta) projected on screen, in pixels.\n */\nvec2 project_1_5(\n    mat4 viewProjMatrix,\n    vec2 lookAtHigh,\n    vec2 lookAtLow,\n    vec2 pixelSize,\n    vec2 pointHigh,\n    vec2 pointLow,\n    vec2 delta\n) {\n    vec4 position = viewProjMatrix * vec4(\n            YV_H_1_0 * (pointHigh - lookAtHigh) + YV_L_1_1 * (pointLow - lookAtLow) + delta,\n            0,\n            1\n        );\n    vec2 projected = position.xy / position.w;\n    return projected / pixelSize;\n}\n\n/**\n * Each point of the polyline is encoded as a vector from the polyline center by its normalized angle and the ratio of\n * its length to the polyline's length.\n */\nvec2 decodePolylineDeltas_1_6(float ratio, float angle, float polylineLength) {\n    // denormalize angle back to radians\n    float a = angle * 2.0 * PI_1_2 - PI_1_2;\n    // length of a vector\n    float len = ratio * polylineLength;\n    // restored point's (x, y) coordinates\n    return vec2(cos(a), sin(a)) * len;\n}\n\n/**\n * Projects specific curved label vertex onto the screen. The label is layouted by centering polyline in\n * the vertexPosHigh/vertexPosLow and other points are used to guide concrete gryph vertex.\n * Number of polyline points is hardcoded to pass them in attributes.\n */\nvec4 projectCurvedLabelVertex_1_7(\n    mat4 viewProjMatrix,\n    vec2 lookAtHigh,\n    vec2 lookAtLow,\n    vec2 pxSize,\n    vec2 posHigh,\n    vec2 posLow,\n    vec2 displacement,\n    float lineDisplacement,\n    float polylineLength,\n    vec4 leftPolylineRatios,\n    vec4 leftPolylineAngles,\n    vec4 rightPolylineRatios,\n    vec4 rightPolylineAngles\n) {\n    vec2 polylineDeltas[MAX_POLYLINE_POINTS_1_3];\n    vec2 position = project_1_5(viewProjMatrix, lookAtHigh, lookAtLow, pxSize, posHigh, posLow, vec2(0, 0));\n    float remainingLength = abs(lineDisplacement);\n    for (int i = 0; i < MAX_POLYLINE_POINTS_1_3; i++) {\n        vec2 projectedPoint;\n\n        // figure out the direction (left/right) at the first step\n        if (i == 0) {\n            projectedPoint = project_1_5(\n                viewProjMatrix,\n                lookAtHigh,\n                lookAtLow,\n                pxSize,\n                posHigh,\n                posLow,\n                decodePolylineDeltas_1_6(rightPolylineRatios[0], rightPolylineAngles[0], polylineLength)\n            );\n            bool isRightPart = lineDisplacement > 0.0;\n            bool isInverted = projectedPoint.x < position.x;\n\n            // the map could be rotated and curved label should change its direction if they got upside down\n            // using center segment to identify this case is an approximation (ideally we should check all segments)\n            if (isRightPart ^^ isInverted) {\n                polylineDeltas[0] = decodePolylineDeltas_1_6(rightPolylineRatios[0], rightPolylineAngles[0], polylineLength);\n                polylineDeltas[1] = decodePolylineDeltas_1_6(rightPolylineRatios[1], rightPolylineAngles[1], polylineLength);\n                polylineDeltas[2] = decodePolylineDeltas_1_6(rightPolylineRatios[2], rightPolylineAngles[2], polylineLength);\n                polylineDeltas[3] = decodePolylineDeltas_1_6(rightPolylineRatios[3], rightPolylineAngles[3], polylineLength);\n            } else {\n                polylineDeltas[0] = decodePolylineDeltas_1_6(leftPolylineRatios[0], leftPolylineAngles[0], polylineLength);\n                polylineDeltas[1] = decodePolylineDeltas_1_6(leftPolylineRatios[1], leftPolylineAngles[1], polylineLength);\n                polylineDeltas[2] = decodePolylineDeltas_1_6(leftPolylineRatios[2], leftPolylineAngles[2], polylineLength);\n                polylineDeltas[3] = decodePolylineDeltas_1_6(leftPolylineRatios[3], leftPolylineAngles[3], polylineLength);\n            }\n\n            // the first right point of the segment already calculated,\n            // recalculate the point if this part of the label goes other direction\n            if (!(isRightPart && !isInverted) && !(!isRightPart && isInverted)) {\n                projectedPoint = project_1_5(viewProjMatrix, lookAtHigh, lookAtLow, pxSize, posHigh, posLow, polylineDeltas[i]);\n            }\n        } else {\n            projectedPoint = project_1_5(viewProjMatrix, lookAtHigh, lookAtLow, pxSize, posHigh, posLow, polylineDeltas[i]);\n        }\n\n        vec2 segment = projectedPoint - position;\n        bool isLast = i == (MAX_POLYLINE_POINTS_1_3 - 1);\n        float segmentLength = (isLast || (polylineDeltas[i + 1] == vec2(0, 0))) ? INFINITY_1_4 : length(segment);\n\n        if (segmentLength > remainingLength) {\n            float signFactor = lineDisplacement > 0.0 ? 1.0 : -1.0;\n            vec2 direction = normalize(segment);\n            vec2 normal = vec2(-direction.y, direction.x);\n\n            position += direction * remainingLength;\n            position += signFactor * direction * displacement.x;\n            position += signFactor * normal * displacement.y;\n\n            break;\n        } else {\n            remainingLength -= segmentLength;\n            position += segment;\n        }\n    }\n\n    return vec4(position * pxSize, 0.0, 1.0);\n}\n\n\n\n\nvoid main(void) {\n    float visibilityAlpha = texture2D(visibility, vertexId.xy + idHalfPxSize).a;\n    if (visibilityAlpha != 0.0) {\n        vec2 vertexDisplacement = vertexDisplacements.xy;\n        float vertexLineDisplacement = vertexDisplacements.z;\n        float polylineLength = polylineLength_vertexScale[0];\n        float vertexScale = polylineLength_vertexScale[1];\n        gl_Position = projectCurvedLabelVertex_1_7(\n            viewProjMatrix,\n            lookAtHigh,\n            lookAtLow,\n            pixelSize,\n            vertexPosHigh,\n            vertexPosLow,\n            vertexDisplacement,\n            vertexLineDisplacement,\n            polylineLength,\n            leftPolylineRatios,\n            leftPolylineAngles,\n            rightPolylineRatios,\n            rightPolylineAngles\n        );\n\n        uv = vertexUV;\n        color = vertexColor;\n        outlineColor = vertexOutlineColor;\n        scale = vertexScale;\n\n        color.a *= visibilityAlpha;\n        outlineColor.a *= visibilityAlpha;\n    } else {\n        gl_Position = DISCARD_POSITION;\n    }\n}\n"

/***/ }),
/* 115 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return IconRenderUnit; });
/* harmony import */ var _shader_icon_vert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(116);
/* harmony import */ var _shader_icon_vert__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_shader_icon_vert__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _shader_icon_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(117);
/* harmony import */ var _shader_icon_frag__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_shader_icon_frag__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _image_image_render_unit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(118);



/**
 * Renderer of icon primitives.
 */
class IconRenderUnit extends _image_image_render_unit__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor(context, camera, primitiveProvider) {
        const program = context.createProgram(_shader_icon_vert__WEBPACK_IMPORTED_MODULE_0___default.a, _shader_icon_frag__WEBPACK_IMPORTED_MODULE_1___default.a, {
            attribMap: {
                vertexPosHigh: 0 /* POSITION_HIGH */,
                vertexPosLow: 1 /* POSITION_LOW */,
                vertexDisplacement: 6 /* DISPLACEMENT */,
                vertexUV: 4 /* UV */
            }
        });
        super(context, primitiveProvider, program);
        this._camera = camera;
    }
    _prepareProgram(program, viewProjMatrix, cameraPositions) {
        super._prepareProgram(program, viewProjMatrix, cameraPositions);
        program.setVector2Uniform('pixelSize', this._camera.pixelSize);
    }
}


/***/ }),
/* 116 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec2 vertexPosHigh;\nattribute vec2 vertexPosLow;\nattribute vec2 vertexDisplacement;\nattribute vec2 vertexUV;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\nuniform vec2 pixelSize;\n\nvarying vec2 uv;\n\nconst float YV_H = 1.999969482421875;\nconst float YV_L = 0.000030517112463712692;\n\nvoid main() {\n    vec4 position = viewProjMatrix * vec4(\n        YV_H * (vertexPosHigh - lookAtHigh) +\n            YV_L * (vertexPosLow - lookAtLow),\n        0,\n        1\n    );\n    position = vec4(position.xy / position.w, 0.0, 1.0);\n\n    gl_Position = position + vec4(vertexDisplacement * pixelSize, 0.0, 0.0);\n\n    uv = vertexUV;\n}\n"

/***/ }),
/* 117 */
/***/ (function(module, exports) {

module.exports = "#version 100\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform sampler2D atlas;\nuniform vec2 atlasSize;\n\nvarying vec2 uv;\n\nvoid main() {\n    gl_FragColor = texture2D(atlas, uv / atlasSize);\n}\n"

/***/ }),
/* 118 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ImageRenderUnit; });
/* harmony import */ var _shader_image_vert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(119);
/* harmony import */ var _shader_image_vert__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_shader_image_vert__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _shader_image_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(120);
/* harmony import */ var _shader_image_frag__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_shader_image_frag__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _math_vector2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(23);
/* harmony import */ var _world_primitive_render_unit__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(100);
/* harmony import */ var _render_state__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(10);






const RENDER_STATE = new _render_state__WEBPACK_IMPORTED_MODULE_4__["default"](_render_state__WEBPACK_IMPORTED_MODULE_4__["BLEND_OVER_RENDER_STATE"]);
function createDefaultProgram(context) {
    return context.createProgram(_shader_image_vert__WEBPACK_IMPORTED_MODULE_0___default.a, _shader_image_frag__WEBPACK_IMPORTED_MODULE_1___default.a, {
        attribMap: {
            vertexPosHigh: 0 /* POSITION_HIGH */,
            vertexPosLow: 1 /* POSITION_LOW */,
            vertexUV: 4 /* UV */
        }
    });
}
/**
 * Renderer of image primitives.
 */
class ImageRenderUnit extends _world_primitive_render_unit__WEBPACK_IMPORTED_MODULE_3__["default"] {
    constructor(context, primitiveProvider, program = createDefaultProgram(context)) {
        super(context, RENDER_STATE, program, primitiveProvider);
        this._atlasSizeUniform = _math_vector2__WEBPACK_IMPORTED_MODULE_2__["create"](0, 0);
        context.bindProgram(program);
        program.setIntScalarUniform('atlas', 0);
    }
    _renderBatch(memoryBatch) {
        const atlas = memoryBatch.firstPrimitive.atlas;
        this._atlasSizeUniform.x = atlas.width;
        this._atlasSizeUniform.y = atlas.height;
        if (atlas.isDirty) {
            atlas.syncTexture();
        }
        this._program.setVector2Uniform('atlasSize', this._atlasSizeUniform);
        this._context.bindTextureUnit(0);
        this._context.bindTexture(atlas.texture);
        super._renderBatch(memoryBatch);
    }
    _canBatchAdjacentPrimitives(a, b) {
        return super._canBatchAdjacentPrimitives(a, b) && (a.atlas === b.atlas);
    }
}


/***/ }),
/* 119 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec2 vertexPosHigh;\nattribute vec2 vertexPosLow;\nattribute vec2 vertexUV;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\n\nvarying vec2 uv;\n\nconst float YV_H = 1.999969482421875;\nconst float YV_L = 0.000030517112463712692;\n\nvoid main() {\n    vec4 position = viewProjMatrix * vec4(\n        YV_H * (vertexPosHigh - lookAtHigh) +\n            YV_L * (vertexPosLow - lookAtLow),\n        0,\n        1\n    );\n\n    gl_Position = position;\n\n    uv = vertexUV;\n}\n"

/***/ }),
/* 120 */
/***/ (function(module, exports) {

module.exports = "#version 100\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform sampler2D atlas;\nuniform vec2 atlasSize;\n\nvarying vec2 uv;\n\nvoid main() {\n    gl_FragColor = texture2D(atlas, uv / atlasSize);\n\n    if (gl_FragColor.a == 0.0) {\n        discard;\n    }\n}\n"

/***/ }),
/* 121 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ModelRenderUnit; });
/* harmony import */ var _shader_model_vert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(122);
/* harmony import */ var _shader_model_vert__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_shader_model_vert__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _shader_model_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(123);
/* harmony import */ var _shader_model_frag__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_shader_model_frag__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _math_vector2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(23);
/* harmony import */ var _overlay_overlay_renderer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(124);
/* harmony import */ var _render_state__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(10);
/* harmony import */ var _world_primitive_render_unit__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(100);






const RENDER_STATE = new _render_state__WEBPACK_IMPORTED_MODULE_4__["default"]({
    depthTest: true
});
/**
 * Renderer of models. It renders models into a texture with depth test and then this texture into the render target.
 * It allows to show only the top facets of semi-transparent objects without exposing their inner structure.
 */
class ModelRenderUnit extends _world_primitive_render_unit__WEBPACK_IMPORTED_MODULE_5__["default"] {
    constructor(context, primitiveProvider) {
        const program = context.createProgram(_shader_model_vert__WEBPACK_IMPORTED_MODULE_0___default.a, _shader_model_frag__WEBPACK_IMPORTED_MODULE_1___default.a, {
            attribMap: {
                vertexPosHigh: 0 /* POSITION_HIGH */,
                vertexPosLow: 1 /* POSITION_LOW */,
                vertexHeight: 3 /* HEIGHT */,
                vertexColor: 7 /* COLOR */
            }
        });
        super(context, RENDER_STATE, program, primitiveProvider);
        this._outputSize = Object(_math_vector2__WEBPACK_IMPORTED_MODULE_2__["createExtent2"])(-1, -1);
        this._overlayRenderer = new _overlay_overlay_renderer__WEBPACK_IMPORTED_MODULE_3__["default"](context);
    }
    render(target, viewProjMatrix, cameraPositions) {
        this._syncOutputBuffer(target);
        super.render(this._outputBuffer, viewProjMatrix, cameraPositions);
        // do not run unnecessary copying if this._outputBuffer was not updated (no models in scene?)
        if (!this._outputBuffer.isClear) {
            // copy into the final target
            this._overlayRenderer.render(target, this._outputTexture);
        }
    }
    destroy() {
        this._overlayRenderer.destroy();
        if (this._outputTexture) {
            this._outputTexture.destroy();
        }
        if (this._outputDepthBuffer) {
            this._outputDepthBuffer.destroy();
        }
        if (this._outputBuffer) {
            this._outputBuffer.destroy();
        }
        super.destroy();
    }
    _syncOutputBuffer(target) {
        // make sure the intermediate texture fits the output target
        if (this._outputSize.width !== target.getWidth() ||
            this._outputSize.height !== target.getHeight()) {
            if (this._outputTexture || this._outputDepthBuffer || this._outputBuffer) {
                this._outputTexture.destroy();
                this._outputDepthBuffer.destroy();
                this._outputBuffer.destroy();
            }
            this._outputSize = { width: target.getWidth(), height: target.getHeight() };
            this._outputTexture = this._context.createEmpty2DTexture(this._outputSize.width, this._outputSize.height, 6408 /* RGBA */, 5121 /* UNSIGNED_BYTE */);
            this._outputDepthBuffer = this._context.createRenderbuffer(this._outputSize.width, this._outputSize.height, 34041 /* DEPTH_STENCIL */);
            this._outputBuffer = this._context.createFramebuffer({
                color: this._outputTexture,
                depthStencil: this._outputDepthBuffer
            });
        }
    }
    /**
     * Overridden _bindRenderTarget() to bind intermediate render target to render models into and
     * later put its content into the final target.
     */
    _prepareRenderTarget(target, viewProjMatrix, cameraPositions) {
        super._prepareRenderTarget(target, viewProjMatrix, cameraPositions);
        this._context.clearCurrentTarget(16384 /* COLOR_BUFFER_BIT */ | 256 /* DEPTH_BUFFER_BIT */);
    }
}


/***/ }),
/* 122 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec3 vertexPosHigh;\nattribute vec3 vertexPosLow;\nattribute float vertexHeight;\nattribute vec4 vertexColor;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\n\nvarying vec4 globalPos;\nvarying vec4 diffuseColor;\n\nconst float YV_H = 1.999969482421875;\nconst float YV_L = 0.000030517112463712692;\n\nvoid main(void) {\n    globalPos = vec4(\n        YV_H * (vertexPosHigh.xy - lookAtHigh) + YV_L * (vertexPosLow.xy - lookAtLow),\n        vertexHeight,\n        1\n    );\n\n    gl_Position = viewProjMatrix * globalPos;\n    diffuseColor = vertexColor;\n}\n"

/***/ }),
/* 123 */
/***/ (function(module, exports) {

module.exports = "#version 100\n\n#extension GL_OES_standard_derivatives : require\n\nprecision mediump float;\n#define GLSLIFY 1\n\nvarying vec4 diffuseColor;\nvarying vec4 globalPos;\n\nconst vec3 LIGHT_DIRECTION = normalize(vec3(0.5, 0.5, 1.0));\nconst float LIGHT_INTENSITY = 0.3;\nconst float AMBIENT_LIGHT_INTENSITY = 1.0 - LIGHT_INTENSITY;\nconst float HORIZONTAL_PLANE_DIFFUSE_INTENSITY =\n    AMBIENT_LIGHT_INTENSITY + 0.5 * LIGHT_INTENSITY * (LIGHT_DIRECTION.z + 1.0);\n\nvoid main(void) {\n    vec3 pos = globalPos.xyz;\n\n    vec3 dxpos = normalize(dFdx(pos));\n    vec3 dypos = normalize(dFdy(pos));\n    vec3 normal = normalize(cross(dxpos, dypos));\n\n    gl_FragColor = vec4(\n        diffuseColor.rgb * (AMBIENT_LIGHT_INTENSITY + 0.5 * LIGHT_INTENSITY * (dot(normal, LIGHT_DIRECTION) + 1.0)) /\n            HORIZONTAL_PLANE_DIFFUSE_INTENSITY,\n        diffuseColor.a\n    );\n}\n"

/***/ }),
/* 124 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return OverlayRenderer; });
/* harmony import */ var _shader_overlay_vert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(125);
/* harmony import */ var _shader_overlay_vert__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_shader_overlay_vert__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _shader_overlay_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(126);
/* harmony import */ var _shader_overlay_frag__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_shader_overlay_frag__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _render_gl_renderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(101);
/* harmony import */ var _render_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(10);





const RENDER_STATE = new _render_state__WEBPACK_IMPORTED_MODULE_3__["default"](_render_state__WEBPACK_IMPORTED_MODULE_3__["BLEND_OVER_RENDER_STATE"]);
/**
 * Renders a texture into a render target with OVER compositing. The texture will completely overlay the target, i.e.
 * it is stretched/shrinked to fit the target width/height, so ideally they should have the same dimensions.
 */
class OverlayRenderer extends _render_gl_renderer__WEBPACK_IMPORTED_MODULE_2__["GlRenderer"] {
    constructor(context) {
        const program = context.createProgram(_shader_overlay_vert__WEBPACK_IMPORTED_MODULE_0___default.a, _shader_overlay_frag__WEBPACK_IMPORTED_MODULE_1___default.a, {
            attribMap: {
                vertexPosition: 0 /* POSITION */,
                vertexUV: 4 /* UV */
            }
        });
        super(context, RENDER_STATE, program);
    }
    _render(texture) {
        this._context.bindTextureUnit(0);
        this._context.bindTexture(texture);
        this._context.bindQuadVao();
        this._context.drawQuad();
    }
}


/***/ }),
/* 125 */
/***/ (function(module, exports) {

module.exports = "#version 100\nprecision mediump float;\n#define GLSLIFY 1\n\nattribute vec2 vertexPosition;\nattribute vec2 vertexUV;\n\nvarying vec2 uv;\n\nvoid main() {\n    gl_Position = vec4(vertexPosition, 0, 1);\n    uv = vertexUV;\n}\n"

/***/ }),
/* 126 */
/***/ (function(module, exports) {

module.exports = "#version 100\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform sampler2D texture;\n\nvarying vec2 uv;\n\nvoid main() {\n    gl_FragColor = texture2D(texture, uv);\n}\n"

/***/ }),
/* 127 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TexturedPolylineRenderUnit; });
/* harmony import */ var _shader_textured_polyline_vert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(128);
/* harmony import */ var _shader_textured_polyline_vert__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_shader_textured_polyline_vert__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _shader_textured_polyline_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(129);
/* harmony import */ var _shader_textured_polyline_frag__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_shader_textured_polyline_frag__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _math_vector2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(23);
/* harmony import */ var _render_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(10);
/* harmony import */ var _base_polyline_render_unit__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(130);





const FILTER_RADIUS = 1.0 / devicePixelRatio;
const RENDER_STATE = new _render_state__WEBPACK_IMPORTED_MODULE_3__["default"](_render_state__WEBPACK_IMPORTED_MODULE_3__["BLEND_OVER_PREMULTIPLIED_ALPHA_RENDER_STATE"], {
    depthTest: true,
    depthMask: false,
    depthFunc: 518 /* GREATER_OR_EQUAL */
});
/**
 * Renderer of polyline primitives.
 */
class TexturedPolylineRenderUnit extends _base_polyline_render_unit__WEBPACK_IMPORTED_MODULE_4__["default"] {
    constructor(context, camera, primitiveProvider) {
        const program = context.createProgram(_shader_textured_polyline_vert__WEBPACK_IMPORTED_MODULE_0___default.a, _shader_textured_polyline_frag__WEBPACK_IMPORTED_MODULE_1___default.a, {
            defines: {
                FILTER_RADIUS: `float(${FILTER_RADIUS})`
            },
            attribMap: {
                vertexPosHigh: 0 /* POSITION_HIGH */,
                vertexPosLow: 1 /* POSITION_LOW */,
                vertexDisplacement: 6 /* DISPLACEMENT */,
                vertexUV: 4 /* UV */,
                vertexZIndex: 9 /* PRIORITY */,
                vertexHalfWidth: 11 /* AUX */,
                vertexPattern: 12 /* AUX1 */,
                vertexPatternHalfHeight: 13 /* AUX2 */
            }
        });
        super(context, RENDER_STATE, program, primitiveProvider, camera);
        this._atlasSizeUniform = _math_vector2__WEBPACK_IMPORTED_MODULE_2__["create"](0, 0);
        context.bindProgram(program);
        program.setIntScalarUniform('atlas', 0);
    }
    _renderBatch(memoryBatch) {
        const atlas = memoryBatch.firstPrimitive.atlas;
        this._atlasSizeUniform.x = atlas.width;
        this._atlasSizeUniform.y = atlas.height;
        if (atlas.isDirty) {
            atlas.syncTexture();
        }
        this._program.setVector2Uniform('atlasSize', this._atlasSizeUniform);
        this._context.bindTextureUnit(0);
        this._context.bindTexture(atlas.texture);
        super._renderBatch(memoryBatch);
    }
    _canBatchAdjacentPrimitives(a, b) {
        return super._canBatchAdjacentPrimitives(a, b) && (a.atlas === b.atlas);
    }
}


/***/ }),
/* 128 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\n#ifndef FILTER_RADIUS\n#   error FILTER_RADIUS must be set\n#endif\n\nattribute vec2 vertexPosHigh;\nattribute vec2 vertexPosLow;\nattribute vec2 vertexDisplacement;\nattribute vec2 vertexUV;\nattribute float vertexHalfWidth;\nattribute vec2 vertexPattern;\nattribute float vertexPatternHalfHeight;\nattribute float vertexZIndex;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\nuniform float worldToPxFactor;\n\nvarying vec2 uv;\nvarying float s;\nvarying float patternLength;\nvarying float len;\nvarying float halfWidth;\nvarying float extHalfWidth;\nvarying float patternHalfHeight;\n\nconst float YV_H = 1.999969482421875;\nconst float YV_L = 0.000030517112463712692;\n\nvoid main(void) {\n    halfWidth = vertexHalfWidth;\n    extHalfWidth = halfWidth + FILTER_RADIUS;\n\n    vec4 position = viewProjMatrix * vec4(\n        YV_H * (vertexPosHigh - lookAtHigh) +\n            YV_L * (vertexPosLow - lookAtLow) +\n                worldToPxFactor * extHalfWidth * vertexDisplacement,\n        0,\n        1\n    );\n\n    position.xy /= position.w;\n    position.z = vertexZIndex;\n    position.w = 1.0;\n\n    gl_Position = position;\n\n    patternLength = vertexPattern[0];\n    len = vertexPattern[1];\n    // Distance to the analytical line along segment's normal\n    s = sign(vertexPatternHalfHeight) * extHalfWidth;\n    // The whole texture is being sampled to the original geometry. For pixels in the extended polyline part the topmost\n    // (bottommost) texels are taken. To make this happen the UV texture coordinates are extended in proportion to the\n    // polyline width extension.\n    patternHalfHeight = abs(vertexPatternHalfHeight);\n    uv = vec2(vertexUV.x, vertexUV.y - vertexPatternHalfHeight * FILTER_RADIUS / halfWidth);\n}\n"

/***/ }),
/* 129 */
/***/ (function(module, exports) {

module.exports = "#version 100\n\n#ifndef FILTER_RADIUS\n#   error FILTER_RADIUS must be set\n#endif\n\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform sampler2D atlas;\nuniform vec2 atlasSize;\n\nvarying vec2 uv;\nvarying float s;\nvarying float patternLength;\nvarying float len;\nvarying float halfWidth;\nvarying float extHalfWidth;\nvarying float patternHalfHeight;\n\nvoid main(void) {\n    lowp float alpha = smoothstep(0.0, FILTER_RADIUS + min(FILTER_RADIUS, extHalfWidth), extHalfWidth - abs(s));\n\n    // Clamp texture U coordinate by 0.5px from both sides to avoid bleeding.\n    vec2 uvAdjusted = vec2(uv.x + clamp(mod(len, patternLength), 0.5, patternLength - 0.5), uv.y);\n    // UV texture coordinates have been extended in proportion to the polyline width extension.\n    // Clamp texture V coordinate to the original geometry minus 0.5px to avoid bleeding.\n    float patternToGeometryFactor = halfWidth / patternHalfHeight;\n    float clampTo = halfWidth - 0.5 * patternToGeometryFactor;\n    if (step(clampTo, abs(s)) == 1.) {\n        float delta = s - clamp(s, -clampTo, clampTo);\n        uvAdjusted.y += delta / patternToGeometryFactor;\n    }\n\n    lowp vec4 color = texture2D(atlas, uvAdjusted / atlasSize);\n    gl_FragColor = color * alpha;\n}\n"

/***/ }),
/* 130 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BasePolylineRenderUnit; });
/* harmony import */ var _world_primitive_render_unit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(100);

/**
 * Base renderer of polyline primitives.
 */
class BasePolylineRenderUnit extends _world_primitive_render_unit__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(context, renderState, program, primitiveProvider, camera) {
        super(context, renderState, program, primitiveProvider);
        this._camera = camera;
    }
    _prepareProgram(program, viewProjMatrix, cameraPositions) {
        super._prepareProgram(program, viewProjMatrix, cameraPositions);
        program.setScalarUniform('worldToPxFactor', this._camera.worldToPxFactor);
    }
}


/***/ }),
/* 131 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_RENDER_STATE_PARAMS", function() { return DEFAULT_RENDER_STATE_PARAMS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PolylineRenderUnit; });
/* harmony import */ var _primitive_polyline_polyline_buffer_writer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(132);
/* harmony import */ var _shader_polyline_vert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(133);
/* harmony import */ var _shader_polyline_vert__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_shader_polyline_vert__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _shader_polyline_frag__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(134);
/* harmony import */ var _shader_polyline_frag__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_shader_polyline_frag__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _base_polyline_render_unit__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(130);
/* harmony import */ var _render_state__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(10);





// Values was chosen by team consensus in VECTOR-197
const FILTER_RADIUS = 1.0 / devicePixelRatio; // px
const DEFAULT_RENDER_STATE_PARAMS = {
    blend: true,
    blendFuncSrcRgb: 1 /* ONE */,
    blendFuncDstRgb: 771 /* ONE_MINUS_SRC_ALPHA */,
    blendFuncSrcAlpha: 1 /* ONE */,
    blendFuncDstAlpha: 771 /* ONE_MINUS_SRC_ALPHA */
};
/**
 * Renderer of polyline primitives. Its default render state is aimed to render opaque polylines.
 */
class PolylineRenderUnit extends _base_polyline_render_unit__WEBPACK_IMPORTED_MODULE_3__["default"] {
    constructor(context, camera, primitiveProvider, renderState = new _render_state__WEBPACK_IMPORTED_MODULE_4__["default"](DEFAULT_RENDER_STATE_PARAMS)) {
        const program = context.createProgram(_shader_polyline_vert__WEBPACK_IMPORTED_MODULE_1___default.a, _shader_polyline_frag__WEBPACK_IMPORTED_MODULE_2___default.a, {
            defines: {
                FILTER_RADIUS: `float(${FILTER_RADIUS})`,
                MAX_HALF_WIDTH: `float(${_primitive_polyline_polyline_buffer_writer__WEBPACK_IMPORTED_MODULE_0__["MAX_HALF_WIDTH"]})`,
                MAX_FILL_GAP: `float(${_primitive_polyline_polyline_buffer_writer__WEBPACK_IMPORTED_MODULE_0__["MAX_FILL_GAP"]})`
            },
            attribMap: {
                vertexPos: 0 /* POSITION */,
                vertexNormalPacked: 5 /* NORMAL */,
                vertexUvPacked: 4 /* UV */,
                vertexWidthFillGap: 11 /* AUX */,
                vertexColor: 7 /* COLOR */,
                vertexMiter: 12 /* AUX1 */,
                vertexVLimit: 13 /* AUX2 */,
                vertexLength: 14 /* AUX3 */
            }
        });
        super(context, renderState, program, primitiveProvider, camera);
    }
}


/***/ }),
/* 132 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAX_HALF_WIDTH", function() { return MAX_HALF_WIDTH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAX_FILL_GAP", function() { return MAX_FILL_GAP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PolylineBufferWriter; });
/* harmony import */ var _math_vector2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(23);
/* harmony import */ var _util_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(11);
/* harmony import */ var _util_buffer_writer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(36);
/* harmony import */ var _polyline_attribute_mapping__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(62);
/* harmony import */ var _util_gputypes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(37);
/* harmony import */ var _util_z_index__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(53);
/* harmony import */ var _math_scalar__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(16);







/**
 * Computes miter of a join between two segments.
 *
 * @param n1 Normal vector of the first segment.
 * @param n2 Normal vector of the second segment.
 * @returns Miter value, i.e. by how match displacement is longer than a normal
 *      one.
 */
function computeMiter(n1, n2) {
    return Math.sqrt(2 / (1 + _math_vector2__WEBPACK_IMPORTED_MODULE_0__["dot"](n1, n2)));
}
const SEGMENT_VERTEX_COUNT = 4;
const SQUARE_CAP_VERTEX_COUNT = 5;
const ROUND_CAP_VERTEX_COUNT = 4;
const FLOAT_MAX = 3.4028234663852886e+38;
const MITER_LIMIT = 4;
const UV_POS_ONE_PACKED = 255; // packed 1
const UV_NEG_ONE_PACKED = 1; // packed -1
const UV_ZERO_PACKED = 128;
/**
 * Packs a component of uv into a unsigned 8-bit value. After packing -1 will
 * become 1 and 1 will become 255. That's need to emulate zero-preserving
 * normalization (we can't rely on WebGL to do it for us :().
 *
 * @param c The component.
 * @returns Packed component.
 */
function packUvComponent(c) {
    // We don't truncate here because buffer writer will do that for us.
    return 128 + (127 * c);
}
/**
 * Half width of the polyline is stored in a normalized attribute. This constant
 * defines half width value of 1 corresponds to.
 */
const MAX_HALF_WIDTH = 255 / 4; // px
/**
 * Same as for polyline half width, but for dash pattern definition.
 */
const MAX_FILL_GAP = 255; // px
class PolylineBufferWriter extends _util_buffer_writer__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor() {
        super(_polyline_attribute_mapping__WEBPACK_IMPORTED_MODULE_3__["POLYLINE_ATTRIBUTE_MAPPING"].vertexByteSize);
        this._displacement = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["create"](0, 0);
        this._prevDisplacement = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["create"](0, 0);
        this._initPolylineState([_math_vector2__WEBPACK_IMPORTED_MODULE_0__["ZERO"], _math_vector2__WEBPACK_IMPORTED_MODULE_0__["ZERO"]], 0, 0, 0, 0, 0 /* MITER */, 0);
    }
    /**
     * Generates a mesh for a polyline with a given style, baking all necessary
     * parameters into attributes.
     *
     * @param polyline The polyline.
     * @param style The polyline style.
     * @returns Location of the written mesh in the managed buffers.
     */
    writePolyline(polyline, style, zIndex) {
        const { vertices } = polyline;
        const lastIdx = vertices.length - 1;
        if (lastIdx < 1) {
            throw new Error('One vertex in not a polyline. It\'s not even a line.');
        }
        this._initPolylineState(vertices, Object(_util_color__WEBPACK_IMPORTED_MODULE_1__["encodeRgba8"])(style.strokeColor), style.strokeWidth, style.dash ? style.dash.fill : 0, style.dash ? style.dash.gap : 0, style.join, Object(_util_z_index__WEBPACK_IMPORTED_MODULE_5__["intToZIndex"])(zIndex));
        this._writeCap(style.startCap, vertices[0], 1);
        for (let i = 1; i < lastIdx; ++i) {
            this._writeSegment(vertices[i - 1], vertices[i], vertices[i + 1]);
            this._writeJoin(vertices[i]);
        }
        this._writeLastSegment(vertices[lastIdx - 1], vertices[lastIdx]);
        this._writeCap(style.endCap, vertices[lastIdx], 1);
        return this.endMesh();
    }
    _initPolylineState(vertices, colorRgba8, width, fill, gap, join, zIndex) {
        this._baseIndex = this._polylineLength = this._lastDirection = 0;
        this._lastSignedMiter = 1;
        const displacement = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["sub"](vertices[1], vertices[0], this._displacement);
        this._segmentLength = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["length"](displacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["divn"](displacement, this._segmentLength, displacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["rotate90"](displacement, displacement);
        this._colorRgba8 = colorRgba8;
        this._halfWidthFillGapPacked =
            Object(_util_gputypes__WEBPACK_IMPORTED_MODULE_4__["floatToUint8"])(Object(_math_scalar__WEBPACK_IMPORTED_MODULE_6__["clamp"])(0.5 * width, 0, MAX_HALF_WIDTH) / MAX_HALF_WIDTH) |
                Object(_util_gputypes__WEBPACK_IMPORTED_MODULE_4__["floatToUint8"])(Object(_math_scalar__WEBPACK_IMPORTED_MODULE_6__["clamp"])(fill, 0, MAX_FILL_GAP) / MAX_FILL_GAP) << 8 |
                Object(_util_gputypes__WEBPACK_IMPORTED_MODULE_4__["floatToUint8"])(Object(_math_scalar__WEBPACK_IMPORTED_MODULE_6__["clamp"])(gap, 0, MAX_FILL_GAP) / MAX_FILL_GAP) << 16;
        this._join = join;
        this._zIndex = zIndex;
    }
    /**
     * Writes a single vertex into managed vertex buffer.
     *
     * @param position Vertex world position.
     * @param normal Normal of segment the vertex belongs to.
     * @param u Normalized distance to the polyline along the normal.
     * @param v Normalized distance to the polyline along the tangent.
     * @param polylineLength Distance to the first vertex along the polyline.
     * @param miter Join miter.
     * @param lengthCorrectionLimit Limit on the vertex displacement along the
     *      polyline.
     */
    _writeVertex(position, normal, uPacked, vPacked, polylineLength, miter, lengthCorrectionLimit) {
        this._writeWorldCoordinate(position);
        this._writeHalfWords(Object(_util_gputypes__WEBPACK_IMPORTED_MODULE_4__["floatToUint16"])(0.5 * (normal.x * Math.SQRT1_2 + 1)), Object(_util_gputypes__WEBPACK_IMPORTED_MODULE_4__["floatToUint16"])(0.5 * (normal.y * Math.SQRT1_2 + 1)));
        this._writeHalfWords(uPacked, vPacked);
        this._writeWord(this._halfWidthFillGapPacked);
        this._writeFloat32(miter);
        this._writeFloat32(lengthCorrectionLimit);
        this._writeFloat32(polylineLength);
        this._writeWord(this._colorRgba8);
        this._writeFloat32(this._zIndex);
    }
    _writeCap(cap, endVertex, displacementSign) {
        switch (cap) {
            case 1 /* ROUND */:
                this._writeRoundCap(endVertex, displacementSign);
                break;
            case 2 /* SQUARE */:
                this._writeSquareCap(endVertex, displacementSign);
                break;
        }
    }
    _writeRoundCap(endVertex, displacementSign) {
        const displacement = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["create"](0, 0);
        const polylineLength = this._polylineLength;
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["muln"](this._displacement, -displacementSign, displacement);
        this._writeVertex(endVertex, displacement, UV_NEG_ONE_PACKED, UV_ZERO_PACKED, polylineLength, 1, FLOAT_MAX);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["rotate90"](this._displacement, displacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["sub"](displacement, this._displacement, displacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["muln"](displacement, displacementSign, displacement);
        this._writeVertex(endVertex, displacement, UV_NEG_ONE_PACKED, UV_POS_ONE_PACKED, polylineLength, 1, FLOAT_MAX);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["muln"](this._displacement, displacementSign, displacement);
        this._writeVertex(endVertex, displacement, UV_POS_ONE_PACKED, UV_ZERO_PACKED, polylineLength, 1, FLOAT_MAX);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["rotate90"](this._displacement, displacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["add"](displacement, this._displacement, displacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["muln"](displacement, displacementSign, displacement);
        this._writeVertex(endVertex, displacement, UV_POS_ONE_PACKED, UV_POS_ONE_PACKED, polylineLength, 1, FLOAT_MAX);
        this.writeIndicesForContinuousStrip(ROUND_CAP_VERTEX_COUNT, this._baseIndex);
        this._baseIndex += ROUND_CAP_VERTEX_COUNT;
    }
    _writeSquareCap(endVertex, displacementSign) {
        const displacement = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["create"](0, 0);
        const polylineLength = this._polylineLength;
        this._writeVertex(endVertex, _math_vector2__WEBPACK_IMPORTED_MODULE_0__["ZERO"], UV_ZERO_PACKED, UV_ZERO_PACKED, polylineLength, 1, 0);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["muln"](this._displacement, -displacementSign, displacement);
        this._writeVertex(endVertex, displacement, UV_POS_ONE_PACKED, UV_ZERO_PACKED, polylineLength, 1, FLOAT_MAX);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["rotate90"](this._displacement, displacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["sub"](displacement, this._displacement, displacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["muln"](displacement, displacementSign, displacement);
        this._writeVertex(endVertex, displacement, UV_POS_ONE_PACKED, UV_ZERO_PACKED, polylineLength, 1, FLOAT_MAX);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["rotate90"](this._displacement, displacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["sub"](displacement, this._displacement, displacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["muln"](displacement, displacementSign, displacement);
        this._writeVertex(endVertex, displacement, UV_POS_ONE_PACKED, UV_ZERO_PACKED, polylineLength, 1, FLOAT_MAX);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["muln"](this._displacement, displacementSign, displacement);
        this._writeVertex(endVertex, this._displacement, UV_POS_ONE_PACKED, UV_ZERO_PACKED, polylineLength, 1, FLOAT_MAX);
        this.writeIndicesForContinuousFan(SQUARE_CAP_VERTEX_COUNT, this._baseIndex);
        this._baseIndex += SQUARE_CAP_VERTEX_COUNT;
    }
    _writeSegment(start, end, nextEnd) {
        const displacement = this._displacement;
        const polylineLength = this._polylineLength;
        const nextSegmentLength = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["distance"](nextEnd, end);
        const nextSegmentNormal = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["sub"](nextEnd, end);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["divn"](nextSegmentNormal, nextSegmentLength, nextSegmentNormal);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["rotate90"](nextSegmentNormal, nextSegmentNormal);
        const direction1 = this._lastDirection;
        const direction2 = Math.sign(_math_vector2__WEBPACK_IMPORTED_MODULE_0__["crossZ"](displacement, nextSegmentNormal));
        const miter1 = this._lastSignedMiter;
        const miter2 = computeMiter(displacement, nextSegmentNormal);
        this._writeVertex(start, displacement, UV_POS_ONE_PACKED, UV_ZERO_PACKED, polylineLength, direction1 === -1 && (this._join !== 0 /* MITER */ || Math.abs(miter1) > MITER_LIMIT) ?
            1 :
            miter1, direction1 === -1 ? -FLOAT_MAX : 0.5 * this._segmentLength);
        this._writeVertex(end, displacement, UV_POS_ONE_PACKED, UV_ZERO_PACKED, polylineLength + this._segmentLength, direction2 === -1 && (this._join !== 0 /* MITER */ || miter2 > MITER_LIMIT) ?
            1 :
            direction2 * miter2, direction2 === -1 ? FLOAT_MAX : -0.5 * this._segmentLength);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["invert"](displacement, displacement);
        this._writeVertex(start, displacement, UV_NEG_ONE_PACKED, UV_ZERO_PACKED, polylineLength, direction1 === 1 && (this._join !== 0 /* MITER */ || Math.abs(miter1) > MITER_LIMIT) ?
            1 :
            miter1, direction1 === 1 ? -FLOAT_MAX : 0.5 * this._segmentLength);
        this._writeVertex(end, displacement, UV_NEG_ONE_PACKED, UV_ZERO_PACKED, polylineLength + this._segmentLength, direction2 === 1 && (this._join !== 0 /* MITER */ || miter2 > MITER_LIMIT) ?
            1 :
            direction2 * miter2, direction2 === 1 ? FLOAT_MAX : -0.5 * this._segmentLength);
        this.writeIndicesForContinuousStrip(SEGMENT_VERTEX_COUNT, this._baseIndex);
        this._baseIndex += SEGMENT_VERTEX_COUNT;
        this._lastSignedMiter = -direction2 * miter2;
        this._lastDirection = direction2;
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["copy"](displacement, this._prevDisplacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["copy"](nextSegmentNormal, displacement);
        this._polylineLength += this._segmentLength;
        this._segmentLength = nextSegmentLength;
    }
    _writeJoin(joinVertex) {
        switch (this._join) {
            case 2 /* BEVEL */:
                this._writeBevelJoin(joinVertex);
                break;
            case 1 /* ROUND */:
                this._writeRoundJoin(joinVertex);
                break;
            case 0 /* MITER */:
                if (Math.abs(this._lastSignedMiter) > MITER_LIMIT) {
                    this._writeBevelJoin(joinVertex);
                }
                break;
        }
    }
    _writeBevelJoin(joinVertex) {
        const lastDirection = this._lastDirection;
        const displacement = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["invert"](this._displacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["add"](displacement, this._prevDisplacement, displacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["muln"](displacement, 0.5 * lastDirection, displacement);
        this._writeVertex(joinVertex, displacement, lastDirection === -1 /* LEFT */ ?
            UV_POS_ONE_PACKED :
            UV_NEG_ONE_PACKED, UV_ZERO_PACKED, this._polylineLength, 1, 1);
        const baseIndex = this._baseIndex;
        this.writeIndices([
            baseIndex - 1,
            baseIndex - 3,
            baseIndex,
            baseIndex,
            lastDirection === -1 /* LEFT */ ? baseIndex + 1 : baseIndex + 3,
            lastDirection === -1 /* LEFT */ ? baseIndex + 3 : baseIndex + 1
        ]);
        this._baseIndex += 1;
    }
    _writeRoundJoin(joinVertex) {
        const polylineLength = this._polylineLength;
        this._writeVertex(joinVertex, _math_vector2__WEBPACK_IMPORTED_MODULE_0__["ZERO"], UV_ZERO_PACKED, UV_ZERO_PACKED, polylineLength, 0, 0);
        const lastDirection = this._lastDirection;
        const middleDisplacement = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["invert"](this._prevDisplacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["add"](this._displacement, middleDisplacement, middleDisplacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["normalize"](middleDisplacement, middleDisplacement);
        const displacement = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["invert"](this._prevDisplacement);
        const miter1 = computeMiter(middleDisplacement, displacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["add"](displacement, middleDisplacement, displacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["normalize"](displacement, displacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["muln"](displacement, -lastDirection * miter1, displacement);
        this._writeVertex(joinVertex, displacement, lastDirection === -1 /* LEFT */ ?
            UV_POS_ONE_PACKED :
            UV_NEG_ONE_PACKED, packUvComponent(Math.sqrt(miter1 * miter1 - 1)), polylineLength, 1, FLOAT_MAX);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["muln"](middleDisplacement, -lastDirection, displacement);
        this._writeVertex(joinVertex, displacement, lastDirection === -1 /* LEFT */ ?
            UV_POS_ONE_PACKED :
            UV_NEG_ONE_PACKED, UV_ZERO_PACKED, polylineLength, 1, FLOAT_MAX);
        const miter2 = computeMiter(middleDisplacement, this._displacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["add"](this._displacement, middleDisplacement, displacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["normalize"](displacement, displacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["muln"](displacement, -lastDirection * miter2, displacement);
        this._writeVertex(joinVertex, displacement, lastDirection === -1 /* LEFT */ ?
            UV_POS_ONE_PACKED :
            UV_NEG_ONE_PACKED, packUvComponent(Math.sqrt(miter2 * miter2 - 1)), polylineLength, 1, FLOAT_MAX);
        const baseIndex = this._baseIndex;
        this.writeIndices([
            baseIndex - 3,
            baseIndex - 1,
            baseIndex,
            baseIndex,
            lastDirection === -1 /* LEFT */ ? baseIndex - 3 : baseIndex - 1,
            baseIndex + 1,
            baseIndex,
            baseIndex + 1,
            baseIndex + 2,
            baseIndex,
            baseIndex + 2,
            baseIndex + 3,
            baseIndex,
            baseIndex + 3,
            lastDirection === -1 /* LEFT */ ? baseIndex + 4 : baseIndex + 6,
            baseIndex,
            baseIndex + 4,
            baseIndex + 6
        ]);
        this._baseIndex += 4;
    }
    _writeLastSegment(start, end) {
        const displacement = this._displacement;
        const lastDirection = this._lastDirection;
        const polylineLength = this._polylineLength;
        const miter = this._lastSignedMiter;
        this._writeVertex(start, displacement, UV_POS_ONE_PACKED, UV_ZERO_PACKED, polylineLength, lastDirection === -1 /* LEFT */ && (this._join !== 0 /* MITER */ || Math.abs(miter) > MITER_LIMIT) ?
            1 :
            miter, lastDirection === -1 /* LEFT */ ? -FLOAT_MAX : this._segmentLength);
        this._writeVertex(end, displacement, UV_POS_ONE_PACKED, UV_ZERO_PACKED, polylineLength + this._segmentLength, 1, FLOAT_MAX);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["invert"](displacement, displacement);
        this._writeVertex(start, displacement, UV_NEG_ONE_PACKED, UV_ZERO_PACKED, polylineLength, lastDirection === 1 /* RIGHT */ && (this._join !== 0 /* MITER */ || Math.abs(miter) > MITER_LIMIT) ?
            1 :
            miter, lastDirection === 1 /* RIGHT */ ? -FLOAT_MAX : this._segmentLength);
        this._writeVertex(end, displacement, UV_NEG_ONE_PACKED, UV_ZERO_PACKED, polylineLength + this._segmentLength, 1, FLOAT_MAX);
        this.writeIndicesForContinuousStrip(SEGMENT_VERTEX_COUNT, this._baseIndex);
        this._baseIndex += SEGMENT_VERTEX_COUNT;
    }
}


/***/ }),
/* 133 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\n#ifndef FILTER_RADIUS\n#   error FILTER_RADIUS must be set\n#endif\n\n#ifndef MAX_HALF_WIDTH\n#   error MAX_HALF_WIDTH must be set\n#endif\n\n#ifndef MAX_FILL_GAP\n#   error MAX_FILL_GAP must be set\n#endif\n\nattribute vec4 vertexPos;\nattribute vec2 vertexNormalPacked;\nattribute vec2 vertexUvPacked;\nattribute vec3 vertexWidthFillGap;\nattribute vec4 vertexColor;\nattribute float vertexMiter;\nattribute float vertexVLimit;\nattribute float vertexLength;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\nuniform float worldToPxFactor;\n\nvarying vec2 uv;\nvarying float len;\nvarying float halfWidth;\nvarying vec3 dash;\nvarying vec4 color;\n\nconst float YV_H = 1.999969482421875;\nconst float YV_L = 0.000030517112463712692;\nconst vec4 YV_HHLL = vec4(YV_H, YV_H, YV_L, YV_L);\n\nconst float SQRT2 = 1.4142135381698608;\n\nvec2 unpackUv(const in vec2 uv) {\n    return (uv - 128.) / 127.;\n}\n\nvoid main(void) {\n    vec2 normal = (2.0 * vertexNormalPacked - 1.0) * SQRT2;\n\n    halfWidth = float(MAX_HALF_WIDTH) * vertexWidthFillGap.x;\n    halfWidth += FILTER_RADIUS;\n\n    float tangentLength = min(\n        sqrt(vertexMiter * vertexMiter - 1.) * halfWidth * worldToPxFactor,\n        abs(vertexVLimit)\n    );\n\n    vec4 lookAt = vec4(lookAtHigh, lookAtLow);\n    vec4 relativeToEyePosition = YV_HHLL * (vertexPos - lookAt);\n\n    gl_Position = viewProjMatrix * vec4(\n        relativeToEyePosition.xy + relativeToEyePosition.zw +\n                worldToPxFactor * halfWidth * normal -\n                    sign(vertexMiter) * tangentLength * vec2(normal.y, -normal.x),\n        0,\n        1\n    );\n\n    uv = unpackUv(vertexUvPacked) * halfWidth;\n    len = (vertexLength + sign(vertexVLimit) * tangentLength) / worldToPxFactor;\n\n    dash.xy = vec2(MAX_FILL_GAP) * vertexWidthFillGap.yz;\n    dash.z = dash.x + dash.y;\n\n    color = vertexColor;\n    color.rgb *= color.a;\n}\n"

/***/ }),
/* 134 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\n#ifndef FILTER_RADIUS\n#   error FILTER_RADIUS must be set\n#endif\n\nvarying highp vec2 uv;\nvarying highp float len;\nvarying highp float halfWidth;\nvarying lowp vec3 dash;\nvarying lowp vec4 color;\n\nvoid main(void) {\n    lowp float alpha =\n        smoothstep(0.0, FILTER_RADIUS + min(FILTER_RADIUS, halfWidth), halfWidth - length(uv));\n\n    if (dash.z > 0.0) {\n        lowp vec3 halfDash = dash * 0.5;\n        lowp float dashPhase = mod(len + halfDash.y, dash.z);\n        lowp float r = min(FILTER_RADIUS, halfDash.y);\n\n        alpha *= smoothstep(-r, r, halfDash.x - abs(dashPhase - halfDash.z));\n    }\n\n    gl_FragColor = color * alpha;\n}\n"

/***/ }),
/* 135 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TexturedPolygonRenderUnit; });
/* harmony import */ var _shader_textured_polygon_vert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(136);
/* harmony import */ var _shader_textured_polygon_vert__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_shader_textured_polygon_vert__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _shader_textured_polygon_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(137);
/* harmony import */ var _shader_textured_polygon_frag__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_shader_textured_polygon_frag__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _math_vector2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(23);
/* harmony import */ var _render_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(10);
/* harmony import */ var _world_primitive_render_unit__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(100);






const RENDER_STATE = new _render_state__WEBPACK_IMPORTED_MODULE_3__["default"](_render_state__WEBPACK_IMPORTED_MODULE_3__["BLEND_OVER_RENDER_STATE"], {
    depthTest: true,
    depthMask: false,
    depthFunc: 518 /* GREATER_OR_EQUAL */
});
/**
 * Renderer of polyline primitives.
 */
class TexturedPolygonRenderUnit extends _world_primitive_render_unit__WEBPACK_IMPORTED_MODULE_4__["default"] {
    constructor(context, primitiveProvider) {
        const program = context.createProgram(_shader_textured_polygon_vert__WEBPACK_IMPORTED_MODULE_0___default.a, _shader_textured_polygon_frag__WEBPACK_IMPORTED_MODULE_1___default.a, {
            attribMap: {
                vertexPosHigh: 0 /* POSITION_HIGH */,
                vertexPosLow: 1 /* POSITION_LOW */,
                vertexUV: 4 /* UV */,
                vertexImageScale: 11 /* AUX */,
                vertexZIndex: 10 /* Z_INDEX */
            }
        });
        super(context, RENDER_STATE, program, primitiveProvider);
        this._atlasSizeUniform = _math_vector2__WEBPACK_IMPORTED_MODULE_2__["create"](0, 0);
        context.bindProgram(program);
        program.setIntScalarUniform('atlas', 0);
    }
    _renderBatch(memoryBatch) {
        const atlas = memoryBatch.firstPrimitive.atlas;
        this._atlasSizeUniform.x = atlas.width;
        this._atlasSizeUniform.y = atlas.height;
        if (atlas.isDirty) {
            atlas.syncTexture();
        }
        this._program.setVector2Uniform('atlasSize', this._atlasSizeUniform);
        this._context.bindTextureUnit(0);
        this._context.bindTexture(atlas.texture);
        super._renderBatch(memoryBatch);
    }
    _canBatchAdjacentPrimitives(a, b) {
        return super._canBatchAdjacentPrimitives(a, b) && (a.atlas === b.atlas);
    }
}


/***/ }),
/* 136 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec2 vertexPosHigh;\nattribute vec2 vertexPosLow;\nattribute vec4 vertexUV;\nattribute float vertexImageScale;\nattribute float vertexZIndex;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\n\nvarying vec2 uvPosition;\nvarying vec2 textureSize;\nvarying vec2 uvDisplacement;\n\nconst float YV_H = 1.999969482421875;\nconst float YV_L = 0.000030517112463712692;\n\nvoid main(void) {\n    uvPosition = vertexUV.xy;\n    textureSize = vertexUV.zw;\n\n    // The same pattern image should match across multiple (usually adjacent) polygons and it should have\n    // stable position realtive to the polygon. Also pattern is repeated at both directions.\n    // To meet these requirements the world is covered (virtually) by a texture of appropriate size (repeated image)\n    // and vertex coordinates are mapped to these texture coordinates (uvDisplacement).\n    // But due to limited precision we've got to work with \"narrow\" floats (as it is done in world position calculation):\n    //   1. calculate how big texture pattern in world coordinates (scaledTextureSize)\n    //   2. find the closest to eye coordinates texture base point (the bottom left point of the pattern)\n    //   3. use vertex position and textureBasePoint vectors to find coordinates in virtual texture\n    //   4. find uv coordinates in real texture using mod operation\n    //\n    // Both textureBasePoint and position are relativelly small vectors so that precision requirements are met,\n    // and correct interpolation of repeated image is possible by using single base point in all vertices.\n\n    vec2 scaledTextureSize = textureSize * vertexImageScale; // texture size in world coordinates\n    vec2 textureBasePoint = mod(YV_H * lookAtHigh, scaledTextureSize) + mod(YV_L * lookAtLow, scaledTextureSize);\n    vec2 position = YV_H * (vertexPosHigh - lookAtHigh) + YV_L * (vertexPosLow - lookAtLow);\n\n    gl_Position = viewProjMatrix * vec4(position, 0, 1);\n    gl_Position.xy /= gl_Position.w;\n    gl_Position.z = vertexZIndex;\n    gl_Position.w = 1.0;\n\n    // convert world coordinates back to teture pixels\n    uvDisplacement = (position + textureBasePoint) / vertexImageScale;\n}\n"

/***/ }),
/* 137 */
/***/ (function(module, exports) {

module.exports = "#version 100\n\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform sampler2D atlas;\nuniform vec2 atlasSize;\n\nvarying vec2 uvPosition;\nvarying vec2 textureSize;\nvarying vec2 uvDisplacement;\n\nvoid main(void) {\n    vec2 uvAdjusted = vec2(\n        uvPosition.x + mod(uvDisplacement.x, textureSize.x),\n        uvPosition.y + mod(uvDisplacement.y, textureSize.y)\n    );\n\n    gl_FragColor = texture2D(atlas, uvAdjusted / atlasSize);\n}\n"

/***/ }),
/* 138 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TransparentPolygonRenderUnit; });
/* harmony import */ var _polygon_render_unit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(139);
/* harmony import */ var _render_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);




/**
 * Renderer of transparent polygon primitives.
 */
class TransparentPolygonRenderUnit extends _polygon_render_unit__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(context, primitiveProvider) {
        super(context, primitiveProvider, new _render_state__WEBPACK_IMPORTED_MODULE_1__["default"](_polygon_render_unit__WEBPACK_IMPORTED_MODULE_0__["DEFAULT_RENDER_STATE_PARAMS"], { depthMask: false }, _render_state__WEBPACK_IMPORTED_MODULE_1__["BLEND_OVER_RENDER_STATE"]));
    }
}


/***/ }),
/* 139 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_RENDER_STATE_PARAMS", function() { return DEFAULT_RENDER_STATE_PARAMS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PolygonRenderUnit; });
/* harmony import */ var _shader_polygon_vert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(140);
/* harmony import */ var _shader_polygon_vert__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_shader_polygon_vert__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _shader_polygon_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(141);
/* harmony import */ var _shader_polygon_frag__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_shader_polygon_frag__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _render_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(10);
/* harmony import */ var _world_primitive_render_unit__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(100);




const DEFAULT_RENDER_STATE_PARAMS = {
    depthTest: true,
    depthFunc: 518 /* GREATER_OR_EQUAL */
};
/**
 * Renderer of polygon primitives.
 */
class PolygonRenderUnit extends _world_primitive_render_unit__WEBPACK_IMPORTED_MODULE_3__["default"] {
    constructor(context, primitiveProvider, renderState = new _render_state__WEBPACK_IMPORTED_MODULE_2__["default"](DEFAULT_RENDER_STATE_PARAMS)) {
        const program = context.createProgram(_shader_polygon_vert__WEBPACK_IMPORTED_MODULE_0___default.a, _shader_polygon_frag__WEBPACK_IMPORTED_MODULE_1___default.a, {
            attribMap: {
                vertexPosHigh: 0 /* POSITION_HIGH */,
                vertexPosLow: 1 /* POSITION_LOW */,
                vertexColor: 7 /* COLOR */,
                vertexZIndex: 10 /* Z_INDEX */
            }
        });
        super(context, renderState, program, primitiveProvider);
    }
}


/***/ }),
/* 140 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec2 vertexPosHigh;\nattribute vec2 vertexPosLow;\nattribute vec4 vertexColor;\nattribute float vertexZIndex;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\n\nvarying vec4 color;\n\nconst float YV_H = 1.999969482421875;\nconst float YV_L = 0.000030517112463712692;\n\nvoid main(void) {\n    vec4 position = viewProjMatrix * vec4(\n        YV_H * (vertexPosHigh - lookAtHigh) +\n            YV_L * (vertexPosLow - lookAtLow),\n        0,\n        1\n    );\n\n    position.xy /= position.w;\n    position.z = vertexZIndex;\n    position.w = 1.0;\n\n    gl_Position = position;\n\n    color = vertexColor;\n}\n"

/***/ }),
/* 141 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nvarying lowp vec4 color;\n\nvoid main(void) {\n    gl_FragColor = color;\n}\n"

/***/ }),
/* 142 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MapEngine; });
/* harmony import */ var _engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(143);
/* harmony import */ var _render_fxaa_render_unit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(176);
/* harmony import */ var _render_background_render_unit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(179);
/* harmony import */ var _render_layer_render_unit__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(181);




/**
 * Ground layer with background that goes right after sub render units. It allows to add other LayerRenderUnits above
 * groundLayer without worrying that they destroy depth information collected on ground and broke background (that has
 * a performance optimisation: it uses depth information from the layers below to prevent extensive pixel overwriting).
 */
class BackgroundedGroundLayer extends _render_layer_render_unit__WEBPACK_IMPORTED_MODULE_3__["default"] {
    constructor(context, depthClearStrategy = 0 /* NO_CLEAR */) {
        super(context, depthClearStrategy);
        this._background = new _render_background_render_unit__WEBPACK_IMPORTED_MODULE_2__["default"](context);
    }
    render(target, ...args) {
        super.render(target, ...args);
        this._background.render(target);
    }
}
class MapEngine extends _engine__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(context, camera, renderLoop) {
        super(context, camera, renderLoop);
        this._destroyables = [];
        const antialiasingLayer = new _render_fxaa_render_unit__WEBPACK_IMPORTED_MODULE_1__["default"](context, this.renderLoop);
        this.backgoundLayer = new _render_layer_render_unit__WEBPACK_IMPORTED_MODULE_3__["default"](context);
        this.groundLayer = new BackgroundedGroundLayer(context);
        this.buildingsLayer = new _render_layer_render_unit__WEBPACK_IMPORTED_MODULE_3__["default"](context);
        this.iconsLayer = new _render_layer_render_unit__WEBPACK_IMPORTED_MODULE_3__["default"](context);
        this.labelsLayer = new _render_layer_render_unit__WEBPACK_IMPORTED_MODULE_3__["default"](context);
        antialiasingLayer.addRenderUnit(this.buildingsLayer);
        this.renderer.addRenderUnit(this.backgoundLayer);
        this.renderer.addRenderUnit(this.groundLayer);
        this.renderer.addRenderUnit(antialiasingLayer);
        this.renderer.addRenderUnit(this.iconsLayer);
        this.renderer.addRenderUnit(this.labelsLayer);
        this._destroyables.push(antialiasingLayer);
        // force initial rendering (no data yet, just background) as the canvas (black) can already be visible to users,
        // renderer is called directly (without scheduling via render loop) as it is pretty much safe to assume
        // that no rendering is scheduled for this frame, and deferred update can potentially cause a single frame blink
        this.renderer.render(this._renderTarget);
    }
    destroy() {
        // destroy in reverse order to prevent potential issues if destroyables own each other
        for (let i = this._destroyables.length - 1; i >= 0; i--) {
            this._destroyables[i].destroy();
        }
        super.destroy();
    }
}


/***/ }),
/* 143 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Engine; });
/* harmony import */ var _util_event_emitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(14);
/* harmony import */ var _render_font_renderable_df_glyph_atlas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(144);
/* harmony import */ var _font_df_font_registry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(146);
/* harmony import */ var _render_billboard_renderable_image_atlas__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(148);
/* harmony import */ var _visibility_visibility_manager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(154);
/* harmony import */ var _util_median_filter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(170);
/* harmony import */ var _util_stat__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(34);
/* harmony import */ var _render_main_render_unit__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(171);
/* harmony import */ var _render_memory_manager__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(173);









class Engine {
    constructor(context, camera, renderLoop) {
        this.context = context;
        this._camera = camera;
        this._renderTarget = context.getDefaultRenderTarget();
        this.renderer = new _render_main_render_unit__WEBPACK_IMPORTED_MODULE_7__["default"](context, camera);
        this.renderLoop = renderLoop;
        this.memoryManager = new _render_memory_manager__WEBPACK_IMPORTED_MODULE_8__["default"](context);
        this._atlases = new Set();
        this.visibilityManager = new _visibility_visibility_manager__WEBPACK_IMPORTED_MODULE_4__["default"](context, camera, renderLoop, this._renderTarget.getWidth(), this._renderTarget.getHeight());
        this.visbilityTextureProvider = () => {
            this.visibilityManager.updateVisibilityIfNeeded();
            return this.visibilityManager.visibilityTexture;
        };
        this._frameTimingsListener = this._onFrameTimesFull.bind(this);
        renderLoop.onFrameTimesFull.addListener(this._frameTimingsListener);
        this._renderListener = this._onRender.bind(this);
        renderLoop.onRender.addListener(this._renderListener);
        this._updateListener = () => this.renderLoop.update();
        this.glyphAtlas = new _render_font_renderable_df_glyph_atlas__WEBPACK_IMPORTED_MODULE_1__["default"](context);
        this.fontRegistry = new _font_df_font_registry__WEBPACK_IMPORTED_MODULE_2__["default"]();
        this.onInternalError = new _util_event_emitter__WEBPACK_IMPORTED_MODULE_0__["VoidEventEmitter"]();
        this._camera.onUpdate.addListener(this._updateListener);
        this.renderer.onUpdate.addListener(this._updateListener);
        this._contextLostListener = () => this.onInternalError.fire();
        this.context.onLoss.addListener(this._contextLostListener);
    }
    setRenderTargetSize(width, height) {
        if (this._renderTarget.getWidth() !== width ||
            this._renderTarget.getHeight() !== height) {
            this._renderTarget.setSize(width, height);
            this.visibilityManager.setTargetSize(width, height);
        }
    }
    createImageAtlas(params) {
        const atlas = new _render_billboard_renderable_image_atlas__WEBPACK_IMPORTED_MODULE_3__["default"](this.context, params);
        atlas.onContentUpdate.addListener(this._updateListener);
        this._atlases.add(atlas);
        return atlas;
    }
    removeImageAtlas(atlas) {
        atlas.destroy();
        atlas.onContentUpdate.removeListener(this._updateListener);
        this._atlases.delete(atlas);
    }
    getCamera() {
        return this._camera;
    }
    destroy() {
        this._camera.onUpdate.removeListener(this._updateListener);
        this.renderer.onUpdate.removeListener(this._updateListener);
        for (const atlas of this._atlases) {
            atlas.onContentUpdate.removeListener(this._updateListener);
            atlas.destroy();
        }
        this.glyphAtlas.destroy();
        this.context.onLoss.removeListener(this._contextLostListener);
    }
    _onRender() {
        this.renderer.render(this._renderTarget);
    }
    _onFrameTimesFull(times) {
        Object(_util_stat__WEBPACK_IMPORTED_MODULE_6__["countFps"])(1e3 * times.length / Object(_util_median_filter__WEBPACK_IMPORTED_MODULE_5__["medianFilter"])(times).reduce((sum, time) => sum + time));
        // For now we acquire frame timing and log them only once a session.
        this.renderLoop.onFrameTimesFull.removeListener(this._frameTimingsListener);
    }
}


/***/ }),
/* 144 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RenderableDfGlyphAtlas; });
/* harmony import */ var _font_df_glyph_atlas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(145);

/**
 * Atlas that manages allocation in GL texture.
 */
class RenderableDfGlyphAtlas extends _font_df_glyph_atlas__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(context) {
        super(0, 0, new Uint8Array(0), new Map());
        this._context = context;
        this.texture = this._createTexture(0, 0);
    }
    destroy() {
        this.texture.destroy();
    }
    /**
     * Updates the whole content of the glyph bitmap atlas, texture also get updated.
     *
     * @param width new bitmap width
     * @param height new bitmap height
     * @param data, length should be strictly equal to width * height
     */
    updateContent(width, height, data, glyphLocations) {
        this.width = width;
        this.height = height;
        this.data = data;
        this._glyphLocations = glyphLocations;
        const texture = this.texture;
        if (!texture || texture.getWidth() !== width || texture.getHeight() !== height) {
            if (this.texture) {
                this.texture.destroy();
            }
            this.texture = this._createTexture(width, height);
        }
        this._context.setTextureData(this.texture, data);
    }
    _createTexture(width, height) {
        return this._context.createEmpty2DTexture(width, height, 6406 /* ALPHA */, 5121 /* UNSIGNED_BYTE */, {
            wrapS: 33071 /* CLAMP_TO_EDGE */,
            wrapT: 33071 /* CLAMP_TO_EDGE */,
            magnificationFilter: 9729 /* LINEAR */,
            minificationFilter: 9729 /* LINEAR */,
            premultipliedAlpha: false
        });
    }
}


/***/ }),
/* 145 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DfGlyphAtlas; });
const UNKNOWN_GLYPH_LOCATION = {
    minX: 0,
    maxX: 0,
    minY: 0,
    maxY: 0
};
/**
 * Abstract glyph atlas interface.
 */
class DfGlyphAtlas {
    constructor(width, height, data, glyphLocations) {
        this.width = width;
        this.height = height;
        this.data = data;
        this._glyphLocations = glyphLocations;
    }
    /**
     * @return Glyph location or fake location pointing to the origin (0, 0).
     */
    getGlyphLocation(fontId, glyphId) {
        const glyphLocation = this._glyphLocations.get(fontId + glyphId);
        if (glyphLocation) {
            return glyphLocation;
        }
        else {
            console.warn('Wow-wow-wow, something went wrong, you should not request nonexistent glyph locations');
            return UNKNOWN_GLYPH_LOCATION;
        }
    }
    /**
     * @return All glyph locations as [glyph id, glyph location] array. Glyph id is font id concatenated with glyph id.
     */
    getAllGlyphLocations() {
        return [...this._glyphLocations.entries()];
    }
}


/***/ }),
/* 146 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DfFontRegistry; });
/* harmony import */ var _font_registry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(147);
/* harmony import */ var _df_font__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(44);


/**
 * Registry that stores distance field fonts.
 */
class DfFontRegistry extends _font_registry__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super(new _df_font__WEBPACK_IMPORTED_MODULE_1__["default"]('UNKNOWN_DF_FONT', 14, 0));
    }
}


/***/ }),
/* 147 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return FontRegistry; });
/**
 * A central storage of all available fonts.
 */
class FontRegistry {
    /**
     * @param unknownFontInstance An instance of specific font type to be served as a stub when nonexistent font
     *     is requested. Requesting nonexistent fonts normally should not happen.
     *     The stub just allows to avoid tedious null checks in registry clients.
     */
    constructor(unknownFontInstance) {
        this._fonts = new Map();
        this._unknownFontInstance = unknownFontInstance;
    }
    /**
     * @return If a font with specified id is in the registry.
     */
    contains(fontId) {
        return this._fonts.has(fontId);
    }
    /**
     * @return Font with specified id or unknown font instance if it is not found.
     */
    get(fontId) {
        const font = this._fonts.get(fontId);
        if (font) {
            return font;
        }
        else {
            console.warn('Wow-wow-wow, something went wrong, you should not request nonexistent fonts');
            return this._unknownFontInstance;
        }
    }
    /**
     * @return All stored fonts.
     */
    getAll() {
        return [...this._fonts.values()];
    }
    /**
     * Adds new for to the registry.
     */
    add(font) {
        this._fonts.set(font.id, font);
    }
}


/***/ }),
/* 148 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RenderableImageAtlas; });
/* harmony import */ var _billboard_image_atlas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(149);

/**
 * Atlas that manages allocation in GL texture.
 */
class RenderableImageAtlas extends _billboard_image_atlas__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(context, params) {
        super();
        const { filter, premultipliedAlpha } = params;
        this._context = context;
        this._filter = filter;
        this._premultipliedAlpha = premultipliedAlpha;
        this.texture = this._createTexture(this.width, this.height, filter, premultipliedAlpha);
        this.isDirty = false;
    }
    /**
     * Updates GL texture with changed data. Should be called after each image added to take effect in shaders.
     */
    syncTexture() {
        this._context.setTextureDataFromDomElement(this.texture, this.canvas);
        this.isDirty = false;
    }
    updateImage(location, sourceImage, locationRegion, sourceImageRegion) {
        super.updateImage(location, sourceImage, locationRegion, sourceImageRegion);
        this.isDirty = true;
    }
    destroy() {
        this.texture.destroy();
    }
    _expand(newWidth, newHeight) {
        super._expand(newWidth, newHeight);
        this.texture.destroy();
        this.texture = this._createTexture(this.width, this.height, this._filter, this._premultipliedAlpha);
        this.isDirty = true;
    }
    _createTexture(width, height, filter, premultipliedAlpha) {
        return this._context.createEmpty2DTexture(width, height, 6408 /* RGBA */, 5121 /* UNSIGNED_BYTE */, {
            minificationFilter: filter,
            magnificationFilter: filter,
            wrapS: 33071 /* CLAMP_TO_EDGE */,
            wrapT: 33071 /* CLAMP_TO_EDGE */,
            premultipliedAlpha
        });
    }
}


/***/ }),
/* 149 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ImageAtlas; });
/* harmony import */ var _math_vector2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(23);
/* harmony import */ var _util_allocator_2d__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(150);
/* harmony import */ var _util_event_emitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(14);



const INIT_ATLAS_WIDTH = 256;
const INIT_ATLAS_HEIGHT = 256;
const MAX_ATLAS_WIDTH = 2048;
const MAX_ATLAS_HEIGHT = 2048;
const EXPAND_FACTOR = 2;
/**
 * Manages allocation of images. It resizes itself (up to a fixed limit) when there is no region
 * of enough size for the next image.
 */
class ImageAtlas {
    constructor(initAtlasWidth = INIT_ATLAS_WIDTH, initAtlasHeight = INIT_ATLAS_HEIGHT) {
        this.onContentUpdate = new _util_event_emitter__WEBPACK_IMPORTED_MODULE_2__["VoidEventEmitter"]();
        this.canvas = document.createElement('canvas');
        this.canvas.width = initAtlasWidth;
        this.canvas.height = initAtlasHeight;
        this._canvasContext = this.canvas.getContext('2d');
        this._allocator = new _util_allocator_2d__WEBPACK_IMPORTED_MODULE_1__["ShelfAllocator2D"](this.width, this.height);
    }
    get width() {
        return this.canvas.width;
    }
    get height() {
        return this.canvas.height;
    }
    /**
     * Allocates image bitmap.
     */
    allocateImage(descriptor, image) {
        const location = this._allocate(descriptor);
        if (location) {
            const region = Object(_math_vector2__WEBPACK_IMPORTED_MODULE_0__["createBBox2"])(0, descriptor.width, 0, descriptor.height);
            this.updateImage(location, image, region, region);
        }
        return location;
    }
    /**
     * Reserves space of appropriate size that can be updated later with updateImage() method.
     */
    reserveLocation(descriptor) {
        return this._allocate(descriptor);
    }
    /**
     * Updates image content in appropriate location. Assumes that there is really such location reserved,
     * no check for this is done.
     *
     * @param location Location in atlas of the image.
     * @param sourceImage Image to update atlas from.
     * @param locationRegion Region (bbox with coordinates relative to the location's bbox) of the location to update.
     * @param sourceImageRegion Region of the image (BBox2 in image's coordinate space) to be copied into atlas.
     */
    updateImage(location, sourceImage, locationRegion = Object(_math_vector2__WEBPACK_IMPORTED_MODULE_0__["createBBox2"])(0, location.maxX - location.minX, 0, location.maxY - location.minY), sourceImageRegion = Object(_math_vector2__WEBPACK_IMPORTED_MODULE_0__["createBBox2"])(0, sourceImage.width, 0, sourceImage.height)) {
        const srcX = sourceImageRegion.minX;
        const srcY = sourceImageRegion.minY;
        const srcW = sourceImageRegion.maxX - sourceImageRegion.minX;
        const srcH = sourceImageRegion.maxY - sourceImageRegion.minY;
        const dstX = location.minX + locationRegion.minX;
        const dstY = location.minY + locationRegion.minY;
        const dstW = locationRegion.maxX - locationRegion.minX;
        const dstH = locationRegion.maxY - locationRegion.minY;
        this._canvasContext.clearRect(dstX, dstY, dstW, dstH);
        this._canvasContext.drawImage(sourceImage, srcX, srcY, srcW, srcH, dstX, dstY, dstW, dstH);
        this.onContentUpdate.fire();
    }
    /**
     * Deallocates image from the atlas.
     */
    removeImage(image) {
        this._allocator.deallocate(image);
    }
    _allocate(descriptor) {
        let location = this._allocator.allocate(descriptor);
        // incremental expand can be inefficient if two or more iterations are needed to allocate an image,
        // but it is expected to be a rare (if any) case, rework if it turns out to be wrong
        while (!location) {
            const expandedWidth = this.width * EXPAND_FACTOR;
            const expandedHeight = this.height * EXPAND_FACTOR;
            if (expandedWidth <= MAX_ATLAS_WIDTH && expandedHeight <= MAX_ATLAS_HEIGHT) {
                this._expand(expandedWidth, expandedHeight);
                location = this._allocator.allocate(descriptor);
            }
            else {
                break;
            }
        }
        return location;
    }
    _expand(newWidth, newHeight) {
        this._allocator.resize(newWidth, newHeight);
        // setting new width/height to canvas will clear it,
        // so current data is saved to be restored immediately after resizing
        const data = this._canvasContext.getImageData(0, 0, this.width, this.height);
        this.canvas.width = newWidth;
        this.canvas.height = newHeight;
        this._canvasContext.putImageData(data, 0, 0);
    }
}


/***/ }),
/* 150 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShelfAllocator2D", function() { return ShelfAllocator2D; });
/* harmony import */ var _allocator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(151);

/**
 * A rectangular region with fixed height. Utility class for shelf allocation defined below.
 */
class Shelf {
    constructor(width, height) {
        this.width = width;
        this.height = height;
        this._allocator = new _allocator__WEBPACK_IMPORTED_MODULE_0__["FreeListAllocator"](this.width);
    }
    allocate(width) {
        return this._allocator.allocate(width);
    }
    deallocate(offset) {
        this._allocator.deallocate(offset);
    }
    isAllocated(offset) {
        return this._allocator.isAllocated(offset);
    }
    canAllocate(width) {
        return this._allocator.maxAllocableSize >= width;
    }
    resize(width) {
        this._allocator.extend(width);
        this.width = width;
    }
}
/**
 * Allocates rectangles in "shelves" (height fixed regions). They are created of necessity when the next object doesnt
 * fit any existing shelf. To optimize space usage it tries to find the best shelf for allocation (min height diff).
 * A shelf when allocated is never deallocated back and exists during all the allocator lifetime.
 */
class ShelfAllocator2D {
    constructor(width, height) {
        this.width = width;
        this.height = height;
        this._shelves = new Map();
        this._shelfAllocator = new _allocator__WEBPACK_IMPORTED_MODULE_0__["ArenaAllocator"](height); // no shelf deallocation, that is why ArenaAllocator is fine
    }
    allocate(object) {
        let bestShelf;
        let bestShelfOffset = -1;
        let bestShelfRatio = -1;
        for (const [offset, shelf] of this._shelves.entries()) {
            const shelfRatio = object.height / shelf.height;
            if (shelfRatio === 1 && shelf.canAllocate(object.width)) {
                bestShelf = shelf;
                bestShelfOffset = offset;
                break;
            }
            else if (shelfRatio < 1 && shelfRatio > bestShelfRatio && shelf.canAllocate(object.width)) {
                bestShelf = shelf;
                bestShelfOffset = offset;
                bestShelfRatio = shelfRatio;
            }
        }
        if (!bestShelf && this._shelfAllocator.maxAllocableSize >= object.height && this.width >= object.width) {
            const offset = this._shelfAllocator.allocate(object.height);
            bestShelf = new Shelf(this.width, object.height);
            bestShelfOffset = offset;
            this._shelves.set(offset, bestShelf);
        }
        if (bestShelf) {
            const left = bestShelf.allocate(object.width);
            const top = bestShelfOffset;
            const location = {
                minX: left,
                maxX: left + object.width,
                minY: top,
                maxY: top + object.height
            };
            return location;
        }
        else {
            return null;
        }
    }
    deallocate(objectLocation) {
        const shelf = this._shelves.get(objectLocation.minY);
        if (shelf) {
            shelf.deallocate(objectLocation.minX);
        }
    }
    isAllocated(objectLocation) {
        const shelf = this._shelves.get(objectLocation.minY);
        return !!shelf && shelf.isAllocated(objectLocation.minX);
    }
    resize(width, height) {
        this._shelfAllocator.extend(height);
        for (const shelf of this._shelves.values()) {
            shelf.resize(width);
        }
        this.width = width;
        this.height = height;
    }
}


/***/ }),
/* 151 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArenaAllocator", function() { return ArenaAllocator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FreeListAllocator", function() { return FreeListAllocator; });
/* harmony import */ var _binary_tree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(152);
/* harmony import */ var _linked_set__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(153);


/**
 * Alignes an offset so it's a multiple of an alignment.
 *
 * @param offset The offset.
 * @param alignment The alignment.
 * @returns Aligned offset.
 */
function align(offset, alignment) {
    return alignment * Math.ceil(offset / alignment);
}
class ArenaAllocator {
    /**
     * Constructs a new empty arena allocator.
     *
     * @param size Size of managed region.
     * @param alignment alignment of offsets.
     */
    constructor(size, alignment = 1) {
        this._size = size;
        this._alignment = alignment;
        this._freeOffset = 0;
        this._allocatedOffsets = new Set();
    }
    get size() {
        return this._size;
    }
    get maxAllocableSize() {
        return this._size - this._freeOffset;
    }
    get isEmpty() {
        return this._allocatedOffsets.size === 0;
    }
    allocate(size) {
        if (this._size >= this._freeOffset + size) {
            const offset = this._freeOffset;
            this._freeOffset = align(offset + size, this._alignment);
            this._allocatedOffsets.add(offset);
            return offset;
        }
        else {
            return -1;
        }
    }
    deallocate(offset) {
        this._allocatedOffsets.delete(offset);
    }
    isAllocated(offset) {
        return offset < this._freeOffset;
    }
    extend(newSize) {
        if (newSize < this._freeOffset) {
            throw new Error('Could not reduce the size because it conflicts with already allocated region.');
        }
        this._size = newSize;
    }
}
/**
 * Allocator optimised for both primary operations: allocation and deallocation. It uses BST for efficient lookup of
 * suitable free region during allocation and two way linked list for fast adjacent free regions merge.
 * Max allocable size is also determined by means of the BST.
 */
class FreeListAllocator {
    constructor(size) {
        this._size = size;
        this._allRegions = new _linked_set__WEBPACK_IMPORTED_MODULE_1__["default"]();
        this._occupiedRegions = new Map();
        this._freeRegions = new _binary_tree__WEBPACK_IMPORTED_MODULE_0__["BinarySearchTree"]((rangeA, rangeB) => rangeA.size - rangeB.size);
        const initRegion = { offset: 0, size };
        this._allRegions.insert(initRegion);
        initRegion._freeNode = this._freeRegions.insert(initRegion);
    }
    get size() {
        return this._size;
    }
    get maxAllocableSize() {
        const max = this._freeRegions.max;
        return max ? max.size : 0;
    }
    get isEmpty() {
        return this._occupiedRegions.size === 0;
    }
    allocate(size) {
        const node = this._findMinSuitable(size);
        if (!node) {
            return -1;
        }
        const range = node.value;
        // current region is not available anymore
        // it is removed from the free regions pool
        this._freeRegions.remove(node);
        // new occupied one is created
        const occupiedRange = { offset: range.offset, size };
        this._occupiedRegions.set(range.offset, occupiedRange);
        this._allRegions.insertAfter(range, occupiedRange);
        this._allRegions.remove(range);
        // dont loose remaining if any
        // it should be returned back to the free regions pool
        if (range.size > size) {
            const remainingRange = { offset: range.offset + size, size: range.size - size };
            remainingRange._freeNode = this._freeRegions.insert(remainingRange);
            this._allRegions.insertAfter(occupiedRange, remainingRange);
        }
        return occupiedRange.offset;
    }
    deallocate(offset) {
        let region = this._occupiedRegions.get(offset);
        if (region) {
            // check if the region can be merged with its previous neighbor
            const prev = this._allRegions.getPrev(region);
            if (prev && prev._freeNode) {
                const embracingRange = { offset: prev.offset, size: prev.size + region.size };
                this._allRegions.insertAfter(prev, embracingRange);
                this._allRegions.remove(region);
                this._allRegions.remove(prev);
                this._freeRegions.remove(prev._freeNode);
                region = embracingRange;
            }
            // check if the region can be merged with its next neighbor
            const next = this._allRegions.getNext(region);
            if (next && next._freeNode) {
                const embracingRange = { offset: region.offset, size: region.size + next.size };
                this._allRegions.insertBefore(next, embracingRange);
                this._allRegions.remove(region);
                this._allRegions.remove(next);
                this._freeRegions.remove(next._freeNode);
                region = embracingRange;
            }
            this._occupiedRegions.delete(offset);
            region._freeNode = this._freeRegions.insert(region);
        }
    }
    isAllocated(offset) {
        return this._occupiedRegions.has(offset);
    }
    extend(newSize) {
        if (newSize < this._size) {
            throw new Error('Size reducing is not allowed in free list allocator');
        }
        const diff = newSize - this._size;
        const last = this._allRegions.end;
        if (last && last._freeNode) {
            this._freeRegions.remove(last._freeNode);
            const region = { offset: last.offset, size: last.size + diff, isFree: true };
            this._allRegions.insertAfter(last, region);
            this._allRegions.remove(last);
            this._freeRegions.insert(region);
        }
        else {
            const region = { offset: this._size, size: diff, isFree: true };
            this._allRegions.insert(region);
            this._freeRegions.insert(region);
        }
        this._size = newSize;
    }
    /**
     * Traverses BST to find the smallest region required size can fit.
     */
    _findMinSuitable(size) {
        let node = this._freeRegions.root;
        let best;
        while (node) {
            if (node.value.size === size) {
                best = node;
                break;
            }
            else if (node.value.size < size) {
                node = node.right;
            }
            else {
                best = node;
                node = node.left;
            }
        }
        return best;
    }
}


/***/ }),
/* 152 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BinarySearchTree", function() { return BinarySearchTree; });
/**
 * Simple implementation of Binary Search Tree.
 */
class BinarySearchTree {
    /**
     * @param comparator To specify the order of items, that can be any complex objects.
     */
    constructor(comparator) {
        this._comparator = comparator;
        this._size = 0;
    }
    /**
     * @returns The root element or `undefined` if the tree is empty.
     */
    get root() {
        return this._root;
    }
    /**
     * @returns The number of items in the tree.
     */
    get size() {
        return this._size;
    }
    /**
     * @returns The smallest element in the tree or `undefined` the the tree is empty.
     */
    get min() {
        if (this._root) {
            return this._min(this._root).value;
        }
        return undefined;
    }
    /**
     * @returns The biggest element in the tree or `undefined` the the tree is empty.
     */
    get max() {
        if (this._root) {
            return this._max(this._root).value;
        }
        return undefined;
    }
    insert(item) {
        this._size++;
        if (!this._root) {
            this._root = { value: item };
            return this._root;
        }
        let node = this._root;
        while (node) {
            if (this._comparator(item, node.value) < 0) {
                if (!node.left) {
                    return node.left = { parent: node, value: item };
                }
                node = node.left;
            }
            else {
                if (!node.right) {
                    return node.right = { parent: node, value: item };
                }
                node = node.right;
            }
        }
        // impossible to get there, throwing is to make TS analizator happy
        throw new Error();
    }
    remove(node) {
        this._size--;
        if (node.left && node.right) {
            const successor = this._min(node.right);
            this._replaceSubtree(node, successor);
            // update links to children of the removed node
            if (node.left) {
                successor.left = node.left;
                node.left.parent = successor;
            }
            if (node.right) {
                successor.right = node.right;
                node.right.parent = successor;
            }
        }
        else if (node.left) {
            this._replaceSubtree(node, node.left);
        }
        else if (node.right) {
            this._replaceSubtree(node, node.right);
        }
        else {
            this._replaceSubtree(node, undefined);
        }
    }
    /**
     * Iterates elements in ascending order.
     */
    *values(node) {
        if (node) {
            yield* this.values(node.left);
            yield node.value;
            yield* this.values(node.right);
        }
    }
    /**
     * Iterates elements in ascending order.
     */
    [Symbol.iterator]() {
        return this.values(this._root);
    }
    _min(from) {
        let node = from;
        while (node.left) {
            node = node.left;
        }
        return node;
    }
    _max(from) {
        let node = from;
        while (node.right) {
            node = node.right;
        }
        return node;
    }
    /**
     * Reorganizes the tree structure so that the replacement node takes replaceable's position, the latter is removed.
     */
    _replaceSubtree(replaceable, replacement) {
        if (replaceable.parent) {
            if (replaceable.parent.left === replaceable) {
                replaceable.parent.left = replacement;
            }
            else if (replaceable.parent.right === replaceable) {
                replaceable.parent.right = replacement;
            }
        }
        else {
            this._root = replacement;
        }
        if (replacement) {
            // remove replacement from its current location
            if (replacement.parent) {
                if (replacement.parent.left === replacement) {
                    replacement.parent.left = undefined;
                }
                else if (replacement.parent.right === replacement) {
                    replacement.parent.right = undefined;
                }
            }
            replacement.parent = replaceable.parent;
        }
    }
}


/***/ }),
/* 153 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LinkedSet; });
/**
 * Set with predictable iteration order. Stores items as a two way linked list thus allowing to insert items in between.
 */
class LinkedSet {
    constructor() {
        this._nodes = new Map();
    }
    get begin() {
        return this._begin && this._begin.value;
    }
    get end() {
        return this._end && this._end.value;
    }
    /**
     * Inserts a new item at the end of the set.
     */
    insert(item) {
        if (!this._nodes.has(item)) {
            const node = { value: item };
            if (this._end) {
                this.insertAfter(this._end.value, item);
            }
            else {
                this._begin = this._end = node;
                this._nodes.set(item, node);
            }
        }
    }
    /**
     * Inserts a new item before the specified one. If the before item is not in the set or
     * the item is already inserted nothing happens.
     */
    insertBefore(before, item) {
        const beforeNode = this._nodes.get(before);
        if (beforeNode && !this._nodes.has(item)) {
            const node = { value: item };
            if (beforeNode.prev) {
                beforeNode.prev.next = node;
                node.prev = beforeNode.prev;
            }
            node.next = beforeNode;
            beforeNode.prev = node;
            this._nodes.set(item, node);
            if (beforeNode === this._begin) {
                this._begin = node;
            }
        }
    }
    /**
     * Inserts a new item after the specified one. If the after item is not in the set or
     * the item is already inserted nothing happens.
     */
    insertAfter(after, item) {
        const afterNode = this._nodes.get(after);
        if (afterNode && !this._nodes.has(item)) {
            const node = { value: item };
            if (afterNode.next) {
                afterNode.next.prev = node;
                node.next = afterNode.next;
            }
            node.prev = afterNode;
            afterNode.next = node;
            this._nodes.set(item, node);
            if (afterNode === this._end) {
                this._end = node;
            }
        }
    }
    /**
     * Removes item from the set.
     */
    remove(item) {
        const node = this._nodes.get(item);
        if (node) {
            if (node === this._begin) {
                this._begin = node.next;
            }
            if (node === this._end) {
                this._end = node.prev;
            }
            if (node.next) {
                node.next.prev = node.prev;
            }
            if (node.prev) {
                node.prev.next = node.next;
            }
            this._nodes.delete(item);
        }
    }
    /**
     * @returns `undefined` if the item is not in the set or it is the first elements.
     */
    getPrev(item) {
        const node = this._nodes.get(item);
        if (node && node.prev) {
            return node.prev.value;
        }
        return undefined;
    }
    /**
     * @returns `undefined` if the item is not in the set or it is the last elements.
     */
    getNext(item) {
        const node = this._nodes.get(item);
        if (node && node.next) {
            return node.next.value;
        }
        return undefined;
    }
    /**
     * Iterates over the set from the fist element to the last (in the order of insertion
     * if the insert method was used only).
     */
    *values() {
        let node = this._begin;
        while (node) {
            yield node.value;
            node = node.next;
        }
    }
    /**
     * Iterates over the set from the fist element to the last (in the order of insertion
     * if the insert method was used only).
     */
    [Symbol.iterator]() {
        return this.values();
    }
}


/***/ }),
/* 154 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return VisibilityManager; });
/* harmony import */ var _render_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);
/* harmony import */ var _util_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(11);
/* harmony import */ var _math_vector2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(23);
/* harmony import */ var _math_vector3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(20);
/* harmony import */ var _math_matrix4__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(19);
/* harmony import */ var _grid_sampler_buffer_writer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(155);
/* harmony import */ var _util_event_emitter__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(14);
/* harmony import */ var _grid_renderer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(156);
/* harmony import */ var _visibility_resolution_steps_reset_removed_primitives__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(157);
/* harmony import */ var _visibility_resolution_steps_fadeout_all__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(158);
/* harmony import */ var _visibility_resolution_steps_fadein_visible__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(162);
/* harmony import */ var _visibility_resolution_steps_fadeout_overlapped__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(165);
/* harmony import */ var _render_util_camera_position__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(168);
/* harmony import */ var _util_hd__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(48);














const FADING_STOPPED = -1;
const DEFAULT_FADE_EFFECT_DURATION = 150;
const ID_COMPONENT_SIZE = 256;
const VISIBILITY_INIT_STATE = new _render_state__WEBPACK_IMPORTED_MODULE_0__["default"]({
    clearColor: _util_color__WEBPACK_IMPORTED_MODULE_1__["create"](0, 0, 0, 0),
    dither: false
});
const EMPTY_GRID_CELL = _util_color__WEBPACK_IMPORTED_MODULE_1__["create"](0, 0, 0, 1);
const DIRECT_PRIORITY_GRID_STATE = new _render_state__WEBPACK_IMPORTED_MODULE_0__["default"]({
    clearColor: EMPTY_GRID_CELL,
    depthTest: true,
    clearDepth: 0,
    // primitives with equal priority are resolved as following: later ones overlap previous
    depthFunc: 518 /* GREATER_OR_EQUAL */,
    dither: false
});
const REVERSE_PRIORITY_GRID_STATE = new _render_state__WEBPACK_IMPORTED_MODULE_0__["default"]({
    clearColor: EMPTY_GRID_CELL,
    depthTest: true,
    clearDepth: 1,
    depthFunc: 513 /* LESS */,
    dither: false
});
// size of minimal recognizable square side in css pixels.
const GRID_PRECISION_PX = 6;
/**
 * Apart from being removed from scene there are other reasons for primitives to be invisible: e.g. they are
 * overlapped by primitives with higher priority. This state is highly dynamic, primitives may be of different types,
 * from different sources and they can have quite non-trivial shapes. So there should be a single point of collision
 * resolution for all primitives in scene, that is what visibility manager is.
 *
 * Visibility of primitives is calculated every frame. To support fade-in/out animation visibility value is a factor
 * the alpha channel of a finally rendered primitive is to be multiplied by (value from 0.0 to 1.0). For instance,
 * if an object is just appeared on the scene, this factor will be changed from 0.0 to 1.0 in fadeEffectDurationMs ms.
 * There are 4 steps the whole process can be roughly summarized into:
 *  1. actualization - reset values for removed from scene primitives
 *  2. fade-out all - even though all primitives are faded out at this step, this step is intended for invisible
 *     primitives to animate them disappearing.
 *  3. fade-in visible - check which primitive are visible and increase its alpha visibility value.
 *  4. fade-out overlapped - find overlaps by comparing corresponding pixels of the scene rendered in direct and
 *     reverse priority orders.
 *
 *  Due to the fact that we use grid with finite precision there are some cases where this approach produces
 *  unpleasant artifacts (blinking). To cope with it stability shift and storing zoom of the first overlap are
 *  introduced, but it works well for non-tilted map only.
 */
class VisibilityManager {
    constructor(context, camera, renderLoop, targetWidth, targetHeight, fadeEffectDuration = DEFAULT_FADE_EFFECT_DURATION) {
        this.onRerenderRequired = new _util_event_emitter__WEBPACK_IMPORTED_MODULE_6__["VoidEventEmitter"]();
        this.fadeEffectDuration = fadeEffectDuration;
        this._context = context;
        this._camera = camera;
        this._renderLoop = renderLoop;
        this._lastRenderTimeInLoop = FADING_STOPPED;
        this._prevTargetSize = { width: 0, height: 0 };
        this._sceneUpdateListener = this._onSceneUpdate.bind(this);
        this._camera.onUpdate.addListener(this._sceneUpdateListener);
        this._beforeRenderListener = this._onBeforeRender.bind(this);
        this._renderLoop.onBeforeRender.addListener(this._beforeRenderListener);
        this._directPriorityGridRenderer = new _grid_renderer__WEBPACK_IMPORTED_MODULE_7__["default"](context, DIRECT_PRIORITY_GRID_STATE);
        this._reversePriorityGridRenderer = new _grid_renderer__WEBPACK_IMPORTED_MODULE_7__["default"](context, REVERSE_PRIORITY_GRID_STATE);
        this._currentVisibilityTexture = context.createEmpty2DTexture(ID_COMPONENT_SIZE, ID_COMPONENT_SIZE, 6408 /* RGBA */, 5121 /* UNSIGNED_BYTE */);
        this._prevVisibilityTexture = context.createEmpty2DTexture(ID_COMPONENT_SIZE, ID_COMPONENT_SIZE, 6408 /* RGBA */, 5121 /* UNSIGNED_BYTE */);
        this._currentVisibilityBuffer = context.createFramebuffer({ color: this._currentVisibilityTexture });
        this._prevVisibilityBuffer = context.createFramebuffer({ color: this._prevVisibilityTexture });
        this._stabilityShift = _math_vector3__WEBPACK_IMPORTED_MODULE_3__["create"](0, 0, 0);
        this._gridHalfPxSizeUniform = _math_vector2__WEBPACK_IMPORTED_MODULE_2__["create"](0, 0);
        this._idHalfPxSizeUniform = _math_vector2__WEBPACK_IMPORTED_MODULE_2__["create"](0.5 / ID_COMPONENT_SIZE, 0.5 / ID_COMPONENT_SIZE);
        this._step1ResetRemoved = new _visibility_resolution_steps_reset_removed_primitives__WEBPACK_IMPORTED_MODULE_8__["default"]();
        this._step2FadeoutAll = new _visibility_resolution_steps_fadeout_all__WEBPACK_IMPORTED_MODULE_9__["default"](context);
        this._step3FadeinVisible = new _visibility_resolution_steps_fadein_visible__WEBPACK_IMPORTED_MODULE_10__["default"](context);
        this._step4FadeoutOverlapped = new _visibility_resolution_steps_fadeout_overlapped__WEBPACK_IMPORTED_MODULE_11__["default"](context);
        this._clearVisibility(this._currentVisibilityBuffer);
        this._primitiveProviders = [];
        this._colorIdRenderers = [];
        this._resetRemovedRenderers = [];
        this.setTargetSize(targetWidth, targetHeight);
    }
    get visibilityTexture() {
        return this._currentVisibilityTexture;
    }
    /**
     * To provide proper precision in collision resolution simplified grid size depends on the render target,
     * that can be changed at run time (e.g. the user resizes browser window). A lot of associated GL resources is be
     * updated in that case.
     */
    setTargetSize(width, height) {
        const gridPrecisionTargetPx = GRID_PRECISION_PX * Object(_util_hd__WEBPACK_IMPORTED_MODULE_13__["default"])();
        const gridWidth = Math.ceil(width / gridPrecisionTargetPx);
        const gridHeight = Math.ceil(height / gridPrecisionTargetPx);
        this._directPriorityGridRenderer.setResolution(gridWidth, gridHeight);
        this._reversePriorityGridRenderer.setResolution(gridWidth, gridHeight);
        if (this._gridSamplerVertexBuffer) {
            this._destroyGridResources();
        }
        const overlapSamplerBufferWriter = new _grid_sampler_buffer_writer__WEBPACK_IMPORTED_MODULE_5__["default"](gridWidth, gridHeight);
        const context = this._context;
        this._gridSamplerVertexBuffer = context.createVertexBuffer(overlapSamplerBufferWriter.data.byteLength);
        this._gridSamplerVao = context.createVao(_grid_sampler_buffer_writer__WEBPACK_IMPORTED_MODULE_5__["ATTRIBUTE_MAPPING"], this._gridSamplerVertexBuffer, null);
        this._numberOfGridSamplers = overlapSamplerBufferWriter.numberOfSamplers;
        this._context.uploadDataToBuffer(this._gridSamplerVertexBuffer, overlapSamplerBufferWriter.data);
        this._prevTargetSize.width = width;
        this._prevTargetSize.height = height;
        this._gridHalfPxSizeUniform.x = 0.5 / gridWidth;
        this._gridHalfPxSizeUniform.y = 0.5 / gridHeight;
    }
    /**
     * Recalculates visibility of all colliding primitives in scene.
     *
     * @param target The target the scene is to be rendered into.
     * @param uniforms Set of precalculated uniforms global for current frame.
     * @returns Updated texture with visibility values for all primitives.
     */
    updateVisibilityIfNeeded() {
        if (!this._isDirty) {
            return;
        }
        this._isDirty = false;
        // Rasterization may be not stable in the sense of the shape of pixels occupied by particular object when this
        // object gets shifted (e.g. the user drags the center of the map) and since collisions are detected by
        // overlapped pixels this fact can lead to blinking (found overlapping in one frame/not found in the next/etc).
        // For those objects (and their positions) that are not distorted by perspective it can be fixed by
        // introducing a shift that takes into account the amount of drag and forces vertices to be displaced in the
        // same position in grid's cell.
        const shift = this._stabilityShift;
        _math_vector2__WEBPACK_IMPORTED_MODULE_2__["copy"](this._camera.center, shift);
        shift.z = 0;
        _math_matrix4__WEBPACK_IMPORTED_MODULE_4__["apply"](this._camera.getViewProjMatrix(), shift, shift);
        // NDC (-1 : 1) are 2 times larger than texture coordinates (0 : 1)
        shift.x %= 4 * this._gridHalfPxSizeUniform.x;
        shift.y %= 4 * this._gridHalfPxSizeUniform.y;
        const prevTexture = this._prevVisibilityTexture;
        const prevFramebuffer = this._prevVisibilityBuffer;
        const currentTexture = this._currentVisibilityTexture;
        const currentFramebuffer = this._currentVisibilityBuffer;
        this._clearVisibility(prevFramebuffer);
        // on this step
        this._step1ResetRemoved.render(prevFramebuffer, this._resetRemovedRenderers, currentTexture, this._idHalfPxSizeUniform);
        // pass zoom as a value between 0.0 and 1.0, as absolute value is not important
        const zoom = this._camera.zoom / this._camera.options.maxZoom;
        const viewProjMatrix = this._camera.getViewProjMatrix();
        const cameraPositions = Object(_render_util_camera_position__WEBPACK_IMPORTED_MODULE_12__["calculateCameraPositions"])(this._camera);
        const directPriorityGrid = this._directPriorityGridRenderer.updateGrid(viewProjMatrix, cameraPositions, this._colorIdRenderers, shift, prevTexture, zoom);
        const reversePriorityGrid = this._reversePriorityGridRenderer.updateGrid(viewProjMatrix, cameraPositions, this._colorIdRenderers, shift, prevTexture, zoom);
        const now = performance.now();
        const lastRendering = this._lastRenderTimeInLoop;
        const isAnimationFinished = (now - this._lastSceneUpdateTime) > this.fadeEffectDuration;
        const wasAnimationActive = lastRendering !== FADING_STOPPED;
        const fadeEffect = isAnimationFinished ?
            1.0 : wasAnimationActive ? (now - lastRendering) / this.fadeEffectDuration : 0;
        const idHalfPx = this._idHalfPxSizeUniform;
        const samplerVao = this._gridSamplerVao;
        const numberOfSamplers = this._numberOfGridSamplers;
        this._clearVisibility(currentFramebuffer);
        this._step2FadeoutAll.render(currentFramebuffer, prevTexture, fadeEffect);
        this._step3FadeinVisible.render(currentFramebuffer, samplerVao, numberOfSamplers, directPriorityGrid, prevTexture, idHalfPx, fadeEffect);
        this._step4FadeoutOverlapped.render(currentFramebuffer, samplerVao, numberOfSamplers, directPriorityGrid, reversePriorityGrid, prevTexture, idHalfPx, fadeEffect, zoom);
        // check if we need one more rendering to finish animation
        if (isAnimationFinished) {
            // no more renderings needed for fade effect, its timestamp is marked with special value
            // to take it into account during next fade effect amount calculation
            this._lastRenderTimeInLoop = FADING_STOPPED;
        }
        else {
            this._renderLoop.update();
            this._lastRenderTimeInLoop = now;
        }
    }
    registerCollidingPrimitives(primitiveProvider, colorIdRenderer, resetRemoveRenderer) {
        this._primitiveProviders.push(primitiveProvider);
        this._colorIdRenderers.push(colorIdRenderer);
        this._resetRemovedRenderers.push(resetRemoveRenderer);
        primitiveProvider.onUpdate.addListener(this._sceneUpdateListener);
    }
    deregisterCollidingPrimitives(primitiveProvider, colorIdRenderer, resetRemoveRenderer) {
        let index = this._primitiveProviders.indexOf(primitiveProvider);
        if (index > -1) {
            this._primitiveProviders.splice(index, 1);
        }
        index = this._colorIdRenderers.indexOf(colorIdRenderer);
        if (index > -1) {
            this._colorIdRenderers.splice(index, 1);
        }
        index = this._resetRemovedRenderers.indexOf(resetRemoveRenderer);
        if (index > -1) {
            this._resetRemovedRenderers.splice(index, 1);
        }
        primitiveProvider.onUpdate.removeListener(this._sceneUpdateListener);
    }
    destroy() {
        this._destroyGridResources();
        this._directPriorityGridRenderer.destroy();
        this._reversePriorityGridRenderer.destroy();
        this._camera.onUpdate.removeListener(this._sceneUpdateListener);
        for (const primitiveProvider of this._primitiveProviders) {
            primitiveProvider.onUpdate.removeListener(this._sceneUpdateListener);
        }
    }
    _onSceneUpdate() {
        this._lastSceneUpdateTime = performance.now();
        this._renderLoop.update();
    }
    _onBeforeRender() {
        this._isDirty = true;
    }
    /**
     * Resets visibility texture to its initial state.
     */
    _clearVisibility(target) {
        this._context.bindRenderState(VISIBILITY_INIT_STATE);
        this._context.bindRenderTarget(target);
        this._context.clearCurrentTarget(16384 /* COLOR_BUFFER_BIT */);
    }
    _destroyGridResources() {
        this._gridSamplerVertexBuffer.destroy();
        this._gridSamplerVao.destroy();
    }
}


/***/ }),
/* 155 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ATTRIBUTE_MAPPING", function() { return ATTRIBUTE_MAPPING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GridSamplerBufferWriter; });
/* harmony import */ var _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _util_buffer_writer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(36);
/* harmony import */ var _util_gputypes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(37);



const ATTRIBUTE_MAPPING = new _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__["AttributeMapping"]([
    [
        0 /* POSITION */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ]
]);
/**
 * Writes sampler positions into vertex buffer as a regular grid with the step equal to the size of a grid cell.
 * The number of vertices (samplers) is equal to "width x height".
 */
class GridSamplerBufferWriter extends _util_buffer_writer__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor(width, height) {
        const numberOfSamplers = width * height;
        super(ATTRIBUTE_MAPPING.vertexByteSize, numberOfSamplers, undefined, 0);
        const colStep = Object(_util_gputypes__WEBPACK_IMPORTED_MODULE_2__["floatToUint16"])(1.0 / width);
        const rowStep = Object(_util_gputypes__WEBPACK_IMPORTED_MODULE_2__["floatToUint16"])(1.0 / height);
        const colHalfStep = colStep / 2;
        const rowHalfStep = rowStep / 2;
        for (let i = 0, col = colHalfStep; i < width; i++, col += colStep) {
            for (let j = 0, row = rowHalfStep; j < height; j++, row += rowStep) {
                this._writeHalfWords(col, row);
            }
        }
        this.data = this.getBuffers()[0].vertexBuffer;
        this.numberOfSamplers = numberOfSamplers;
    }
}


/***/ }),
/* 156 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GridRenderer; });
/* harmony import */ var _render_gl_renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(101);

class GridRenderer extends _render_gl_renderer__WEBPACK_IMPORTED_MODULE_0__["GlRenderer"] {
    constructor(context, renderState) {
        super(context, renderState);
    }
    updateGrid(...args) {
        this.render(this._target, ...args);
        return this._texture;
    }
    _render(viewProjMatrix, cameraPositions, renderers, stabilityShift, prevVisibility, currentZoom) {
        for (const renderer of renderers) {
            renderer.render(this._target, viewProjMatrix, cameraPositions, this._renderState, stabilityShift, prevVisibility, currentZoom);
        }
    }
    /**
     * Updates resolution of the grid.
     */
    setResolution(width, height) {
        this._destroyResources();
        this._depthBuffer = this._context.createRenderbuffer(width, height, 34041 /* DEPTH_STENCIL */);
        this._texture = this._context.createEmpty2DTexture(width, height, 6408 /* RGBA */, 5121 /* UNSIGNED_BYTE */);
        this._target = this._context.createFramebuffer({ color: this._texture, depthStencil: this._depthBuffer });
    }
    destroy() {
        this._destroyResources();
    }
    _prepareRenderTarget(target, ...args) {
        super._prepareRenderTarget(target, ...args);
        this._context.clearCurrentTarget(16384 /* COLOR_BUFFER_BIT */ | 256 /* DEPTH_BUFFER_BIT */);
    }
    _destroyResources() {
        if (this._target) {
            this._target.destroy();
            this._texture.destroy();
            this._depthBuffer.destroy();
        }
    }
}


/***/ }),
/* 157 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ResetRemovedPrimitives; });
/**
 * One of the steps of primitives visibility resolution process. Basically it does nothing, just call appropriate
 * methods of CollidingPrimitiveRenderer's, but it expects that these renderers will copy visibility value of actual
 * primitives only, thus removed primitive's values will be reset (overlap zoom cleared and all that). It is important
 * for reusing these ids for future primitives.
 */
class ResetRemovedPrimitives {
    render(target, renderers, prevVisibility, idHalfPxSizeUniform) {
        for (const renderer of renderers) {
            renderer.render(target, prevVisibility, idHalfPxSizeUniform);
        }
    }
}


/***/ }),
/* 158 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return FadeoutAll; });
/* harmony import */ var _shaders_fadeout_all_vert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(159);
/* harmony import */ var _shaders_fadeout_all_vert__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_shaders_fadeout_all_vert__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _shaders_fadeout_all_frag__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(160);
/* harmony import */ var _shaders_fadeout_all_frag__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_shaders_fadeout_all_frag__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _render_gl_renderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(101);
/* harmony import */ var _render_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(10);
/* harmony import */ var _id_sampler_buffer_writer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(161);





const STATE = new _render_state__WEBPACK_IMPORTED_MODULE_3__["default"]({
    dither: false
});
/**
 * One of the steps of primitives visibility resolution process. It samples all visibility values and subtract
 * delta (fadeoutAmount) from them, these new values are stored into current visibility texture.
 */
class FadeoutAll extends _render_gl_renderer__WEBPACK_IMPORTED_MODULE_2__["GlRenderer"] {
    constructor(context) {
        const program = context.createProgram(_shaders_fadeout_all_vert__WEBPACK_IMPORTED_MODULE_0___default.a, _shaders_fadeout_all_frag__WEBPACK_IMPORTED_MODULE_1___default.a, {
            attribMap: {
                position: 0 /* POSITION */
            }
        });
        super(context, STATE, program);
        const idSamplerBufferWriter = new _id_sampler_buffer_writer__WEBPACK_IMPORTED_MODULE_4__["default"]();
        this._idSamplerVertexBuffer = this._context.createVertexBuffer(idSamplerBufferWriter.vertexData.byteLength);
        this._idSamplerIndexBuffer = this._context.createIndexBuffer(idSamplerBufferWriter.indexData.byteLength);
        this._idSamplerVao = this._context.createVao(_id_sampler_buffer_writer__WEBPACK_IMPORTED_MODULE_4__["ATTRIBUTE_MAPPING"], this._idSamplerVertexBuffer, this._idSamplerIndexBuffer);
        this._context.uploadDataToBuffer(this._idSamplerVertexBuffer, idSamplerBufferWriter.vertexData);
        this._context.uploadDataToBuffer(this._idSamplerIndexBuffer, idSamplerBufferWriter.indexData);
        context.bindProgram(program);
        program.setIntScalarUniform('prevVisibility', 0);
    }
    _prepareProgram(program, prevVisibility, fadeoutAmount) {
        super._prepareProgram(program, prevVisibility, fadeoutAmount);
        this._context.bindTextureUnit(0);
        this._context.bindTexture(prevVisibility);
        program.setScalarUniform('fadeoutAmount', fadeoutAmount);
    }
    _render() {
        this._context.bindVao(this._idSamplerVao);
        this._context.drawIndexedMesh(0, 6, 4 /* TRIANGLES */);
    }
}


/***/ }),
/* 159 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec4 position;\n\nvarying vec2 idTexCoordinates;\n\nvoid main() {\n    gl_Position = vec4(position.xy, 0, 1);\n    idTexCoordinates = position.zw;\n}\n"

/***/ }),
/* 160 */
/***/ (function(module, exports) {

module.exports = "#version 100\n\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform sampler2D prevVisibility;\nuniform float fadeoutAmount;\n\nvarying vec2 idTexCoordinates;\n\nvoid main() {\n    vec4 visibilityValue = texture2D(prevVisibility, idTexCoordinates);\n    visibilityValue.a = clamp(visibilityValue.a - fadeoutAmount, 0.0, 1.0);\n\n    gl_FragColor = visibilityValue;\n}\n"

/***/ }),
/* 161 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ATTRIBUTE_MAPPING", function() { return ATTRIBUTE_MAPPING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return IdSamplerBufferWriter; });
/* harmony import */ var _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _util_buffer_writer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(36);


const ATTRIBUTE_MAPPING = new _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__["AttributeMapping"]([
    [
        0 /* POSITION */,
        {
            size: 4,
            type: 5120 /* BYTE */,
            normalized: false
        }
    ]
]);
/**
 * Write vertices of two triangles that fully cover visibility texture, its values can be sampled in fragment shaders.
 */
class IdSamplerBufferWriter extends _util_buffer_writer__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor() {
        super(ATTRIBUTE_MAPPING.vertexByteSize, 4, 4, 6);
        // window x, window y, texture x, texture y
        this._writeBytes(-1, -1, 0, 0);
        this._writeBytes(-1, 1, 0, 1);
        this._writeBytes(1, 1, 1, 1);
        this._writeBytes(1, -1, 1, 0);
        this.writeIndicesForFan([0, 1, 2, 3]);
        this.vertexData = this.getBuffers()[0].vertexBuffer;
        this.indexData = this.getBuffers()[0].indexBuffer;
    }
}


/***/ }),
/* 162 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return FadeinVisible; });
/* harmony import */ var _render_gl_renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(101);
/* harmony import */ var _shaders_fadein_visible_vert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(163);
/* harmony import */ var _shaders_fadein_visible_vert__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_shaders_fadein_visible_vert__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _shaders_fadein_visible_frag__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(164);
/* harmony import */ var _shaders_fadein_visible_frag__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_shaders_fadein_visible_frag__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _render_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(10);




const STATE = new _render_state__WEBPACK_IMPORTED_MODULE_3__["default"]({
    dither: false
});
/**
 * One of the steps of primitives visibility resolution process. It samples all pixels of the scene (rendered in direct
 * priority order into simplified grid) and adds delta (fadeinAmount) to alpha visibility of primitive with
 * id in this pixel. Those primitives are considered visible.
 */
class FadeinVisible extends _render_gl_renderer__WEBPACK_IMPORTED_MODULE_0__["GlRenderer"] {
    constructor(context) {
        const program = context.createProgram(_shaders_fadein_visible_vert__WEBPACK_IMPORTED_MODULE_1___default.a, _shaders_fadein_visible_frag__WEBPACK_IMPORTED_MODULE_2___default.a, {
            attribMap: {
                position: 0 /* POSITION */
            }
        });
        super(context, STATE, program);
        context.bindProgram(program);
        program.setIntScalarUniform('directPriorityGrid', 0);
        program.setIntScalarUniform('prevVisibility', 1);
    }
    _prepareProgram(program, data, samplers, directPriorityGrid, prevVisibility, idHalfPxSize, fadeinAmount) {
        super._prepareProgram(program, data, samplers, directPriorityGrid, prevVisibility, idHalfPxSize, fadeinAmount);
        this._context.bindTextureUnit(0);
        this._context.bindTexture(directPriorityGrid);
        this._context.bindTextureUnit(1);
        this._context.bindTexture(prevVisibility);
        program.setVector2Uniform('idHalfPxSize', idHalfPxSize);
        program.setScalarUniform('fadeinAmount', fadeinAmount);
    }
    _render(data, numberOfSamplers) {
        this._context.bindVao(data);
        this._context.drawMesh(0, numberOfSamplers, 0 /* POINTS */);
    }
}


/***/ }),
/* 163 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec2 position;\n\nuniform sampler2D directPriorityGrid;\nuniform sampler2D prevVisibility;\nuniform vec2 idHalfPxSize;\nuniform float fadeinAmount;\n\nvarying lowp vec4 visibilityValue;\n\nconst vec2 NO_ID = vec2(0, 0);\nconst vec4 DISCARD_POSITION = vec4(2, 2, 2, 1);\n\nvoid main() {\n    vec2 primitiveId = texture2D(directPriorityGrid, position).rg;\n\n    if (primitiveId != NO_ID) {\n        vec2 idTexCoordinates = primitiveId + idHalfPxSize;\n        vec4 idWindowCoordinates = vec4(idTexCoordinates * 2.0 - 1.0, 0, 1);\n        gl_Position = idWindowCoordinates;\n        gl_PointSize = 1.0;\n\n        visibilityValue = texture2D(prevVisibility, idTexCoordinates);\n        visibilityValue.a = clamp(visibilityValue.a + fadeinAmount, 0.0, 1.0);\n    } else {\n        gl_Position = DISCARD_POSITION;\n    }\n}\n"

/***/ }),
/* 164 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nvarying lowp vec4 visibilityValue;\n\nvoid main() {\n    gl_FragColor = visibilityValue;\n}\n"

/***/ }),
/* 165 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return FadeoutOverlapped; });
/* harmony import */ var _render_gl_renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(101);
/* harmony import */ var _shaders_fadeout_overlapped_vert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(166);
/* harmony import */ var _shaders_fadeout_overlapped_vert__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_shaders_fadeout_overlapped_vert__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _shaders_fadeout_overlapped_frag__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(167);
/* harmony import */ var _shaders_fadeout_overlapped_frag__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_shaders_fadeout_overlapped_frag__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _render_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(10);




const STATE = new _render_state__WEBPACK_IMPORTED_MODULE_3__["default"]({ dither: false });
class FadeoutOverlapped extends _render_gl_renderer__WEBPACK_IMPORTED_MODULE_0__["GlRenderer"] {
    constructor(context) {
        const program = context.createProgram(_shaders_fadeout_overlapped_vert__WEBPACK_IMPORTED_MODULE_1___default.a, _shaders_fadeout_overlapped_frag__WEBPACK_IMPORTED_MODULE_2___default.a, {
            attribMap: {
                position: 0 /* POSITION */
            }
        });
        super(context, STATE, program);
        context.bindProgram(program);
        program.setIntScalarUniform('directPriorityGrid', 0);
        program.setIntScalarUniform('reversePriorityGrid', 1);
        program.setIntScalarUniform('prevVisibility', 2);
    }
    _prepareProgram(program, data, samplers, directPriority, reversePriority, prevVisibility, idHalfPxSize, fadeoutAmount, currentZoom) {
        super._prepareProgram(program, data, samplers, directPriority, reversePriority, prevVisibility, idHalfPxSize, fadeoutAmount, currentZoom);
        this._context.bindTextureUnit(0);
        this._context.bindTexture(directPriority);
        this._context.bindTextureUnit(1);
        this._context.bindTexture(reversePriority);
        this._context.bindTextureUnit(2);
        this._context.bindTexture(prevVisibility);
        program.setVector2Uniform('idHalfPxSize', idHalfPxSize);
        program.setScalarUniform('fadeoutAmount', fadeoutAmount);
        program.setScalarUniform('currentZoom', currentZoom);
    }
    _render(data, numberOfSamplers) {
        this._context.bindVao(data);
        this._context.drawMesh(0, numberOfSamplers, 0 /* POINTS */);
    }
}


/***/ }),
/* 166 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec2 position;\n\nuniform sampler2D directPriorityGrid;\nuniform sampler2D reversePriorityGrid;\nuniform sampler2D prevVisibility;\nuniform vec2 idHalfPxSize;\nuniform float fadeoutAmount;\nuniform float currentZoom;\n\nvarying vec4 visibilityValue;\n\nconst vec2 NO_ID = vec2(0, 0);\nconst vec4 DISCARD_POSITION = vec4(2, 2, 2, 1);\n\nvoid main() {\n    vec2 primitiveIdReversePriority = texture2D(reversePriorityGrid, position).rg;\n\n    if (\n        primitiveIdReversePriority != NO_ID &&\n        primitiveIdReversePriority != texture2D(directPriorityGrid, position).rg\n    ) {\n        vec2 idTexCoordinates = primitiveIdReversePriority + idHalfPxSize;\n        vec4 idWindowCoordinates = vec4(idTexCoordinates * 2.0 - 1.0, 0, 1);\n\n        gl_Position = idWindowCoordinates;\n        gl_PointSize = 1.0;\n\n        visibilityValue = texture2D(prevVisibility, idTexCoordinates);\n        visibilityValue.b = currentZoom;\n        visibilityValue.a = clamp(visibilityValue.a - fadeoutAmount, 0.0, 1.0);\n    } else {\n        gl_Position = DISCARD_POSITION;\n    }\n}\n"

/***/ }),
/* 167 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nvarying lowp vec4 visibilityValue;\n\nvoid main() {\n    gl_FragColor = visibilityValue;\n}\n"

/***/ }),
/* 168 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "calculateCameraPositions", function() { return calculateCameraPositions; });
/* harmony import */ var _math_vector2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(23);
/* harmony import */ var _util_gputypes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(37);
/* harmony import */ var _util_cartesian_grid__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(169);
/* harmony import */ var _util_array__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(38);




// Maps world coordinates to corresponding points on the cartesian grid.
const WORLD_MIN_COORDINATE = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["create"](-1, -1);
const GRID_WORLD_RATIO = 0.5;
const GRID_COORDINATES_CONVERTER = (point) => {
    const gridCoordinates = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["copy"](point);
    _math_vector2__WEBPACK_IMPORTED_MODULE_0__["sub"](gridCoordinates, WORLD_MIN_COORDINATE, gridCoordinates);
    _math_vector2__WEBPACK_IMPORTED_MODULE_0__["muln"](gridCoordinates, GRID_WORLD_RATIO, gridCoordinates);
    return gridCoordinates;
};
const CAMERA_POSITION_UINT32_CONVERTER = (component) => 0.5 * (component + 1) * 0xffffffff;
const HIGH_COMPONENT_EXTRACTOR = (component) => Object(_util_gputypes__WEBPACK_IMPORTED_MODULE_1__["uint16ToFloat"])(Math.trunc(component / 0x10000));
const LOW_COMPONENT_EXTRACTOR = (component) => Object(_util_gputypes__WEBPACK_IMPORTED_MODULE_1__["uint16ToFloat"])(component & 0xffff);
const REGION_COMPARATOR = (a, b) => a.x - b.x || a.y - b.y;
const tmpCameraPosition = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["create"](0, 0);
/**
 * If there are multiple worlds visible (large monitors/low zoom) primitives are rendered in multiple passes from
 * different positions (if the wrap mode of corresponding direction is REPEAT) to get correct final picture.
 * This method calculates camera positions and prepare them to be passed to the render() method.
 */
const cachedRegion = [];
const cachedPositions = [];
function calculateCameraPositions(camera) {
    const visibleRegion = camera.getVisibleRegion();
    if (_util_array__WEBPACK_IMPORTED_MODULE_3__["compare"](REGION_COMPARATOR, cachedRegion, visibleRegion) === 0) {
        return cachedPositions;
    }
    const positions = [];
    for (const worldPosition of Object(_util_cartesian_grid__WEBPACK_IMPORTED_MODULE_2__["computeSquaresCoveredByConvexPolygon"])(visibleRegion.map(GRID_COORDINATES_CONVERTER))) {
        if ((camera.options.wrapModeX === 2 /* REPEAT */ || worldPosition.x === 0) &&
            (camera.options.wrapModeY === 2 /* REPEAT */ || worldPosition.y === 0)) {
            // 2.0 converts covered square position to the world's center coordinates
            // -1.0 reverses the position of the camera to shot the world from
            _math_vector2__WEBPACK_IMPORTED_MODULE_0__["muln"](worldPosition, -1.0 * 2.0, tmpCameraPosition);
            _math_vector2__WEBPACK_IMPORTED_MODULE_0__["add"](camera.center, tmpCameraPosition, tmpCameraPosition);
            _math_vector2__WEBPACK_IMPORTED_MODULE_0__["convert"](tmpCameraPosition, CAMERA_POSITION_UINT32_CONVERTER, tmpCameraPosition);
            positions.push({
                lookAtHigh: _math_vector2__WEBPACK_IMPORTED_MODULE_0__["convert"](tmpCameraPosition, HIGH_COMPONENT_EXTRACTOR),
                lookAtLow: _math_vector2__WEBPACK_IMPORTED_MODULE_0__["convert"](tmpCameraPosition, LOW_COMPONENT_EXTRACTOR)
            });
        }
    }
    _util_array__WEBPACK_IMPORTED_MODULE_3__["copy"](positions, cachedPositions);
    cachedPositions.length = positions.length;
    cachedRegion.length = visibleRegion.length;
    for (let i = 0; i < visibleRegion.length; i++) {
        cachedRegion[i] = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["copy"](visibleRegion[i], cachedRegion[i]);
    }
    return positions;
}


/***/ }),
/* 169 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "computeSquaresCoveredByConvexPolygon", function() { return computeSquaresCoveredByConvexPolygon; });
/* harmony import */ var _math_vector2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(23);


/**
 * Container of indexed min/max values with a single update method.
 */
class ExtremumStorage {
    constructor(length) {
        this._mins = new Array(length);
        this._maxs = new Array(length);
        this._mins.fill(Number.POSITIVE_INFINITY);
        this._maxs.fill(Number.NEGATIVE_INFINITY);
    }
    updateValue(index, value) {
        this._mins[index] = Math.min(this._mins[index], value);
        this._maxs[index] = Math.max(this._maxs[index], value);
    }
    *values() {
        const item = { min: 0, max: 0, index: -1 };
        for (let i = 0; i < this._mins.length; i++) {
            item.min = this._mins[i];
            item.max = this._maxs[i];
            item.index = i;
            yield item;
        }
    }
}
/**
 * Squares that are ony touched by a line (with no significant crossing an edge) should not be considered "covered".
 * It happens when a point matches the max coordinate (integer) and this case is handled here.
 */
function floorToCellCoordinate(value, maxValue) {
    return Number.isInteger(value) && maxValue === value ? value - 1 : Math.floor(value);
}
/**
 * Calculates squares covered (at least partially) by a convex polygon.
 *
 * @param points Convex polygon point coordinates (on the grid).
 * @returns List of unit square coordinates.
 */
function computeSquaresCoveredByConvexPolygon(points) {
    const result = [];
    const bbox = Object(_math_vector2__WEBPACK_IMPORTED_MODULE_0__["computeBBoxForPoints"])(points);
    const minX = Math.floor(bbox.minX);
    const xLength = Math.ceil(bbox.maxX) - minX;
    const extremums = new ExtremumStorage(xLength);
    for (let i = points.length - 1, j = 0; j < points.length; i = j++) {
        let p1 = points[i];
        let p2 = points[j];
        // go from left to right always to not handle the opposite case
        if (p1.x > p2.x) {
            const tmp = p1;
            p1 = p2;
            p2 = tmp;
        }
        // calculate from/to interval so that only "internal" integer x-es are captured
        const fromX = Math.floor(p1.x + 1);
        const toX = Math.ceil(p2.x - 1);
        const slope = (p1.y - p2.y) / (p1.x - p2.x);
        // handle terminal points separately from the "internal" ones
        extremums.updateValue(floorToCellCoordinate(p1.x, bbox.maxX) - minX, floorToCellCoordinate(p1.y, bbox.maxY));
        extremums.updateValue(floorToCellCoordinate(p2.x, bbox.maxX) - minX, floorToCellCoordinate(p2.y, bbox.maxY));
        for (let x = fromX; x <= toX; x++) {
            const yIntercept = (isFinite(slope) ? slope * (x - p1.x) : 0) + p1.y;
            const nextX = x - minX;
            const prevX = nextX - 1;
            const y = Math.floor(yIntercept);
            // check if we hit exactly the intersection of two integer coordinates
            if (Number.isInteger(yIntercept)) {
                if (yIntercept === bbox.maxY) {
                    extremums.updateValue(prevX, y - 1);
                    extremums.updateValue(nextX, y - 1);
                }
                else if (slope > 0) {
                    // two diagonal squares intersected by a line with positive slope
                    extremums.updateValue(prevX, y - 1);
                    extremums.updateValue(nextX, y);
                }
                else if (slope < 0) {
                    // two diagonal squares intersected by a line with negative slope
                    extremums.updateValue(prevX, y);
                    extremums.updateValue(nextX, y - 1);
                }
            }
            else {
                extremums.updateValue(prevX, y);
                extremums.updateValue(nextX, y);
            }
        }
    }
    for (const { min, max, index } of extremums.values()) {
        const x = minX + index;
        for (let y = min; y <= max; y++) {
            result.push(_math_vector2__WEBPACK_IMPORTED_MODULE_0__["create"](x, y));
        }
    }
    return result;
}


/***/ }),
/* 170 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "medianFilter", function() { return medianFilter; });
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _comparator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(39);


/**
 * Filters an array of values with median filter.
 *
 * @param values Values to be filtered.
 * @param windowRadius How many values around a sample get into filter window.
 * @returns Array of filtered values.
 */
function medianFilter(values, windowRadius = 3) {
    const window = new Array(2 * windowRadius + 1);
    window.fill(values[0]);
    const length = values.length;
    const result = new Array(length);
    const first = values[0];
    for (let i = 0; i < windowRadius; ++i) {
        window.fill(first, 0, windowRadius - i + 1);
        Object(_array__WEBPACK_IMPORTED_MODULE_0__["copy"])(values, window, 0, i + windowRadius + 1, windowRadius - i + 1);
        window.sort(_comparator__WEBPACK_IMPORTED_MODULE_1__["NUMERICAL_COMPARATOR"]);
        result[i] = window[windowRadius];
    }
    for (let i = windowRadius; i < length - windowRadius; ++i) {
        Object(_array__WEBPACK_IMPORTED_MODULE_0__["copy"])(values, window, i - windowRadius, i + windowRadius + 1);
        window.sort(_comparator__WEBPACK_IMPORTED_MODULE_1__["NUMERICAL_COMPARATOR"]);
        result[i] = window[windowRadius];
    }
    const last = values[values.length - 1];
    for (let i = length - windowRadius; i < length; ++i) {
        Object(_array__WEBPACK_IMPORTED_MODULE_0__["copy"])(values, window, i - windowRadius, length);
        window.fill(last, values.length - i + windowRadius);
        window.sort(_comparator__WEBPACK_IMPORTED_MODULE_1__["NUMERICAL_COMPARATOR"]);
        result[i] = window[windowRadius];
    }
    return result;
}


/***/ }),
/* 171 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MainRenderUnit; });
/* harmony import */ var _list_render_unit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(172);
/* harmony import */ var _util_event_emitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(14);
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(10);
/* harmony import */ var _util_camera_position__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(168);




const FINAL_RENDER_STATE = new _state__WEBPACK_IMPORTED_MODULE_2__["default"]({
    clearDepth: 0,
    depthTest: true,
    depthFunc: 518 /* GREATER_OR_EQUAL */
});
/**
 * Root scene renderer. It generates final canvas image composing it from independent layers (LayerRenderUnit).
 */
class MainRenderUnit extends _list_render_unit__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(context, camera) {
        super();
        this._context = context;
        this._camera = camera;
        this.onRender = new _util_event_emitter__WEBPACK_IMPORTED_MODULE_1__["VoidEventEmitter"]();
    }
    render(target) {
        const viewProjMatix = this._camera.getViewProjMatrix();
        const cameraPositions = Object(_util_camera_position__WEBPACK_IMPORTED_MODULE_3__["calculateCameraPositions"])(this._camera);
        this._context.bindRenderTarget(target);
        this._context.bindRenderState(FINAL_RENDER_STATE);
        this._context.clearCurrentTarget(17664 /* ALL */);
        for (const renderer of this._subRenderUnits) {
            renderer.render(target, viewProjMatix, cameraPositions);
        }
        this.onRender.fire();
    }
}


/***/ }),
/* 172 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ListRenderUnit; });
/* harmony import */ var _util_event_emitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(14);

class NoBaseRenderUnitError extends Error {
    constructor() {
        super('Base render unit is not in the list');
    }
}
/**
 * Simple implementation of CompositeRenderUnit that just runs sub units in the order of addition.
 */
class ListRenderUnit {
    constructor() {
        this.onUpdate = new _util_event_emitter__WEBPACK_IMPORTED_MODULE_0__["VoidEventEmitter"]();
        this._subRenderUnits = [];
        this._subRenderUnitUpdateListener = this._onSubRenderUnitUpdate.bind(this);
    }
    /**
     * Adds RenderUnit to the end of the list.
     */
    addRenderUnit(subRenderUnit) {
        this._subRenderUnits.push(subRenderUnit);
        subRenderUnit.onUpdate.addListener(this._subRenderUnitUpdateListener);
    }
    /**
     * Removes RenderUnit from the list.
     */
    removeRenderUnit(subRenderUnit) {
        const index = this._subRenderUnits.indexOf(subRenderUnit);
        if (index !== -1) {
            this._subRenderUnits.splice(index, 1);
            subRenderUnit.onUpdate.removeListener(this._subRenderUnitUpdateListener);
            this.onUpdate.fire();
        }
    }
    /**
     * Adds RenderUnit above the base one. "Above" means that its render() method will be called after the base's one.
     */
    addRenderUnitAbove(base, subRenderUnit) {
        const baseIndex = this._subRenderUnits.indexOf(base);
        if (baseIndex !== -1) {
            this._subRenderUnits.splice(baseIndex + 1, 0, subRenderUnit);
            subRenderUnit.onUpdate.addListener(this._subRenderUnitUpdateListener);
        }
        else {
            throw new NoBaseRenderUnitError();
        }
    }
    /**
     * Adds RenderUnit below the base one. "Below" means that its render() method will be called before the base's one.
     */
    addRenderUnitBelow(base, subRenderUnit) {
        const baseIndex = this._subRenderUnits.indexOf(base);
        if (baseIndex !== -1) {
            this._subRenderUnits.splice(baseIndex, 0, subRenderUnit);
            subRenderUnit.onUpdate.addListener(this._subRenderUnitUpdateListener);
        }
        else {
            throw new NoBaseRenderUnitError();
        }
    }
    render(target, ...args) {
        for (const renderer of this._subRenderUnits) {
            renderer.render(target, ...args);
        }
    }
    _onSubRenderUnitUpdate() {
        this.onUpdate.fire();
    }
}


/***/ }),
/* 173 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MemoryManager; });
/* harmony import */ var _page__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(174);
/* harmony import */ var _count_vertices__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(41);
/* harmony import */ var _util_allocator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(151);



const MAX_VERTEX_COUNT = 0x10000;
// FIXME(dmikis) Let's use oversized index buffer til we sort out indices allocation
// both in writers and the manager.
const PAGE_INDEX_BUFFER_BYTE_SIZE = 0x100000;
/**
 * Memory page with the following peculiarity: once allocation is failed it gets closed for any subsequent
 * allocations. It allow to keep related primitives closer in memory.
 */
class SinglePassMemoryPage extends _page__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(vertexBuffer, indexBuffer, vao, indexType) {
        super(vertexBuffer, indexBuffer, vao, indexType, new _util_allocator__WEBPACK_IMPORTED_MODULE_2__["ArenaAllocator"](vertexBuffer.getSize()), new _util_allocator__WEBPACK_IMPORTED_MODULE_2__["ArenaAllocator"](indexBuffer.getSize()));
        this._failedAllocation = false;
    }
    allocate(vertexByteLength, indexByteLength) {
        if (this._failedAllocation) {
            return null;
        }
        const chunk = super.allocate(vertexByteLength, indexByteLength);
        this._failedAllocation = (chunk === null);
        return chunk;
    }
}
/**
 * Manager that controls GL memory allocations and pagination.[]
 */
class MemoryManager {
    /**
     * Creates a new memory manager that will allocate memory in a given context.
     *
     * @param context The context.
     */
    constructor(context) {
        this._context = context;
        this._pages = new Map();
        this._emptyPagesClearTimeout = 0;
    }
    /**
     * Allocates memory for a given data in the manager and uploads given data.
     *
     * @param vertexData Buffer with vertices that needs to be allocated.
     * @param indexData Buffer with indices that needs to be allocated.
     * @param attributeMapping Mapping of vertex attributes.
     * @returns Descriptor of the allocated memory region.
     */
    allocate(vertexData, indexData, attributeMapping) {
        const context = this._context;
        let pageSet = this._pages.get(attributeMapping);
        // If there's no pages for the given attribute mapping, create a new set.
        if (!pageSet) {
            pageSet = new Set();
            this._pages.set(attributeMapping, pageSet);
        }
        // Try to allocate data in the existing pages.
        for (const page of pageSet) {
            const memoryChunk = page.allocate(vertexData.byteLength, indexData.byteLength);
            if (memoryChunk) {
                // Success! Now we just upload the data.
                this._updatePage(page, memoryChunk, vertexData, indexData);
                return memoryChunk;
            }
        }
        // We've failed to allocate the data in any of existing pages. No worries
        // though, we just create a new one:)
        const vertexBuffer = context.createVertexBuffer(
        // some buffer writers don't use indices and MAX_VERTEX_COUNT restriction is not applied in such cases
        Math.max(MAX_VERTEX_COUNT * attributeMapping.vertexByteSize, vertexData.byteLength));
        const indexBuffer = context.createIndexBuffer(PAGE_INDEX_BUFFER_BYTE_SIZE);
        const vao = context.createVao(attributeMapping, vertexBuffer, indexBuffer);
        const page = new SinglePassMemoryPage(vertexBuffer, indexBuffer, vao, 5123 /* UNSIGNED_SHORT */);
        page.setDelegate(this);
        pageSet.add(page);
        // Here we assume we always can allocate data in an empty page.
        const memoryChunk = page.allocate(vertexData.byteLength, indexData.byteLength);
        this._updatePage(page, memoryChunk, vertexData, indexData);
        return memoryChunk;
    }
    onPageEmpty() {
        if (!this._emptyPagesClearTimeout) {
            this._emptyPagesClearTimeout = setTimeout(() => {
                this._clearEmptyPages();
                this._emptyPagesClearTimeout = 0;
            });
        }
    }
    /**
     * Destroys the manager and all its memory pages. All memory chunks that were
     * allocated in the manager become invalid.
     */
    destroy() {
        if (this._emptyPagesClearTimeout) {
            clearTimeout(this._emptyPagesClearTimeout);
        }
        for (const [, pageSet] of this._pages) {
            for (const page of pageSet) {
                page.destroy();
            }
        }
    }
    _updatePage(page, memoryChunk, vertexData, indexData) {
        const context = this._context;
        // Let's ensure that we won't break any bound VAOs.
        context.bindVao(null);
        context.uploadDataToBuffer(page.vertexBuffer, vertexData, memoryChunk.vertexByteOffset);
        // Shift indices.
        const baseIndex = Object(_count_vertices__WEBPACK_IMPORTED_MODULE_1__["countVertices"])(memoryChunk.vertexByteOffset, page.vao.attributeMapping);
        for (let i = 0; i < indexData.length; ++i) {
            indexData[i] += baseIndex;
        }
        context.uploadDataToBuffer(page.indexBuffer, indexData, memoryChunk.indexByteOffset);
    }
    _clearEmptyPages() {
        for (const pageSet of this._pages.values()) {
            for (const page of pageSet) {
                if (page.isEmpty()) {
                    pageSet.delete(page);
                    page.setDelegate(null);
                    page.destroy();
                }
            }
        }
    }
}


/***/ }),
/* 174 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MemoryPage; });
/* harmony import */ var _chunk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(175);
/* harmony import */ var _util_delegator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(94);


/**
 * A "page" of GPU memory. Comprises vertex and index buffers of a fixed size.
 */
class MemoryPage extends _util_delegator__WEBPACK_IMPORTED_MODULE_1__["DelegatorBase"] {
    /**
     * Creates a new page to manage given vertex and index buffers.
     *
     * @param vertexBuffer The vertex buffer the page will manage.
     * @param indexBuffer The index buffer the page will manager.
     * @param vao The VAO of the page.
     * @param indexType Type of elements of indexBuffer.
     * @param vertexAllocator Allocator of vertex data, logic of allocation directly impacts the lifecycle of the page.
     * @param indexAllocator Allocator of index data, logic of allocation directly impacts the lifecycle of the page.
     */
    constructor(vertexBuffer, indexBuffer, vao, indexType, vertexAllocator, indexAllocator) {
        super();
        this.vertexBuffer = vertexBuffer;
        this.indexBuffer = indexBuffer;
        this.vao = vao;
        this.indexType = indexType;
        this._vertexAllocator = vertexAllocator;
        this._indexAllocator = indexAllocator;
    }
    /**
     * Allocates and writes vertex and index data to the page. Offsets indices
     * in an index array to appropriately take into account offset of the vertex
     * data.
     *
     * @param vertexByteLength required number of bytes in vertex buffer
     * @param indexByteLength required number of bytes in index buffer
     * @returns memory chunk allocated or `null` if allocation's failed
     */
    allocate(vertexByteLength, indexByteLength) {
        if (this._vertexAllocator.maxAllocableSize >= vertexByteLength &&
            this._indexAllocator.maxAllocableSize >= indexByteLength) {
            return new _chunk__WEBPACK_IMPORTED_MODULE_0__["default"](this, {
                vertexByteOffset: this._vertexAllocator.allocate(vertexByteLength),
                vertexByteLength: vertexByteLength,
                indexByteOffset: this._indexAllocator.allocate(indexByteLength),
                indexByteLength: indexByteLength
            });
        }
        else {
            return null;
        }
    }
    /**
     * Frees a previously allocated memory chunk.
     *
     * @param chunk The chunk to be freed.
     */
    free(chunk) {
        this._vertexAllocator.deallocate(chunk.vertexByteOffset);
        this._indexAllocator.deallocate(chunk.indexByteOffset);
        if (this.isEmpty() && this._delegate) {
            this._delegate.onPageEmpty(this);
        }
    }
    /**
     * Returns `true` if the page does not contain any previously allocated data
     * and `false` otherwise.
     */
    isEmpty() {
        return this._vertexAllocator.isEmpty && this._indexAllocator.isEmpty;
    }
    /**
     * Destroys the page and all its resources.
     */
    destroy() {
        this.vertexBuffer.destroy();
        this.indexBuffer.destroy();
        this.vao.destroy();
    }
}


/***/ }),
/* 175 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MemoryChunk; });
/* harmony import */ var _util_ref_counted__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(43);

/** Handler to a allocated memory chunk. */
class MemoryChunk extends _util_ref_counted__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * Creates a new handler to a memory chunk with given offsets allocated in
     * a given memory page.
     *
     * @param page The page the chunk was allocated in.
     * @param vertexOffset The offset of chunk's vertex data.
     * @param indexOffset The offset of chunk's index data.
     */
    constructor(page, location) {
        super();
        this.page = page;
        this._location = location;
    }
    /**
     * Returns offset of vertex data of the chunk in bytes.
     */
    get vertexByteOffset() {
        return this._location.vertexByteOffset;
    }
    /**
     * Returns offset of index data of the chunk in bytes.
     */
    get indexByteOffset() {
        return this._location.indexByteOffset;
    }
    _destroy() {
        this.page.free(this);
    }
}


/***/ }),
/* 176 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return FxaaRenderUnit; });
/* harmony import */ var _math_vector2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(23);
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/* harmony import */ var _shaders_fxaa_frag__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(177);
/* harmony import */ var _shaders_fxaa_frag__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_shaders_fxaa_frag__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _shaders_quad_vert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(178);
/* harmony import */ var _shaders_quad_vert__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_shaders_quad_vert__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _util_hd__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(48);
/* harmony import */ var _gl_renderer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(101);
/* harmony import */ var _list_render_unit__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(172);








const STATE = new _state__WEBPACK_IMPORTED_MODULE_1__["default"](_state__WEBPACK_IMPORTED_MODULE_1__["BLEND_OVER_RENDER_STATE"]);
/**
 * Renderer of FXAA postprocessing pass.
 */
class FxaaRenderUnit extends _gl_renderer__WEBPACK_IMPORTED_MODULE_5__["GlRenderer"] {
    constructor(context, renderLoop) {
        super(context, STATE, context.createProgram(_shaders_quad_vert__WEBPACK_IMPORTED_MODULE_3___default.a, _shaders_fxaa_frag__WEBPACK_IMPORTED_MODULE_2___default.a, {
            attribMap: {
                vertexPosition: 0 /* POSITION */
            }
        }));
        this._renderers = new _list_render_unit__WEBPACK_IMPORTED_MODULE_6__["default"]();
        this._renderLoop = renderLoop;
        this.onUpdate = this._renderers.onUpdate;
        this._pixelSize = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["create"](0, 0);
    }
    addRenderUnit(unit) {
        this._renderers.addRenderUnit(unit);
    }
    removeRenderUnit(unit) {
        this._renderers.removeRenderUnit(unit);
    }
    render(target, ...args) {
        // skip antialiasing if these is action in the scene
        if (this._renderLoop.isActive) {
            this._renderers.render(target, ...args);
            // schedule at least one more rendering to not leave static (stopped) scene in non-antialiased state
            this._renderLoop.update();
            return;
        }
        if (!this._intermediateRendereBuffer) {
            this._initIntermediateRenderTargets(target.getWidth(), target.getHeight());
        }
        else if (this._intermediateRendereBuffer.getWidth() !== target.getWidth() ||
            this._intermediateRendereBuffer.getHeight() !== target.getHeight()) {
            this._destroyInternalRenderTargets();
            this._initIntermediateRenderTargets(target.getWidth(), target.getHeight());
        }
        this._context.bindRenderTarget(this._intermediateRendereBuffer);
        this._context.clearCurrentTarget(17664 /* ALL */);
        this._renderers.render(this._intermediateRendereBuffer, ...args);
        // do not run antialiasing on empty this._intermediateRendereBuffer
        if (!this._intermediateRendereBuffer.isClear) {
            this._updateFrameUniformState(target);
            super.render(target, ...args);
        }
    }
    destroy() {
        if (this._intermediateRendereBuffer) {
            this._destroyInternalRenderTargets();
        }
    }
    _render() {
        this._context.bindQuadVao();
        this._context.drawQuad();
    }
    _prepareProgram(program, ...args) {
        super._prepareProgram(program, ...args);
        this._context.bindTextureUnit(0);
        this._context.bindTexture(this._intermediateColorBuffer);
        program.setIntScalarUniform('texture', 0);
        program.setVector2Uniform('pixelSize', this._pixelSize);
        program.setScalarUniform('dpr', Object(_util_hd__WEBPACK_IMPORTED_MODULE_4__["default"])());
    }
    _updateFrameUniformState(target) {
        this._pixelSize.x = 1 / target.getWidth();
        this._pixelSize.y = 1 / target.getHeight();
    }
    _initIntermediateRenderTargets(width, height) {
        const context = this._context;
        const intermediateColorBuffer = this._intermediateColorBuffer =
            context.createEmpty2DTexture(width, height, 6408 /* RGBA */, 5121 /* UNSIGNED_BYTE */);
        const intermediateDepthStencilBuffer = this._intermediateDepthStencilBuffer =
            context.createRenderbuffer(width, height, 34041 /* DEPTH_STENCIL */);
        this._intermediateRendereBuffer = context.createFramebuffer({
            color: intermediateColorBuffer,
            depthStencil: intermediateDepthStencilBuffer
        });
    }
    _destroyInternalRenderTargets() {
        this._intermediateRendereBuffer.destroy();
        this._intermediateColorBuffer.destroy();
        this._intermediateDepthStencilBuffer.destroy();
    }
}


/***/ }),
/* 177 */
/***/ (function(module, exports) {

module.exports = "#version 100\n\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform vec2 pixelSize;\nuniform sampler2D texture;\nuniform float dpr;\n\nconst float FXAA_QUALITY_SUBPIX = 0.75;\nconst float FXAA_QUALITY_EDGE_THRESHOLD = 0.063;\nconst float FXAA_QUALITY_EDGE_THRESHOLD_MIN = 0.0625;\nconst float EPSILON = 0.0001;\n\nfloat luma(vec4 rgba) {\n    return dot(rgba.xyz, vec3(0.299, 0.587, 0.114));\n}\n\nvec4 fxaa(\n    vec2 pos,\n    sampler2D tex,\n    vec2 fxaaQualityRcpFrame,\n    // This used to be the FXAA_QUALITY_SUBPIX define.\n    // Choose the amount of sub-pixel aliasing removal.\n    // This can effect sharpness.\n    //   1.00 - upper limit (softer)\n    //   0.75 - default amount of filtering\n    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)\n    //   0.25 - almost off\n    //   0.00 - completely off\n    float fxaaQualitySubpix,\n    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.\n    // The minimum amount of local contrast required to apply algorithm.\n    //   0.333 - too little (faster)\n    //   0.250 - low quality\n    //   0.166 - default\n    //   0.125 - high quality\n    //   0.063 - overkill (slower)\n    float fxaaQualityEdgeThreshold,\n    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.\n    // Trims the algorithm from processing darks.\n    //   0.0833 - upper limit (default, the start of visible unfiltered edges)\n    //   0.0625 - high quality (faster)\n    //   0.0312 - visible limit (slower)\n    float fxaaQualityEdgeThresholdMin\n) {\n    vec2 posM;\n    posM.x = pos.x;\n    posM.y = pos.y;\n    vec4 rgbyM = texture2D(tex, posM);\n    float lumaM = luma(rgbyM);\n\n    float lumaS = luma(texture2D(tex, posM + vec2( 0, 1) * fxaaQualityRcpFrame.xy));\n    float lumaE = luma(texture2D(tex, posM + vec2( 1, 0) * fxaaQualityRcpFrame.xy));\n    float lumaN = luma(texture2D(tex, posM + vec2( 0,-1) * fxaaQualityRcpFrame.xy));\n    float lumaW = luma(texture2D(tex, posM + vec2(-1, 0) * fxaaQualityRcpFrame.xy));\n\n    float maxSM = max(lumaS, lumaM);\n    float minSM = min(lumaS, lumaM);\n    float maxESM = max(lumaE, maxSM);\n    float minESM = min(lumaE, minSM);\n    float maxWN = max(lumaN, lumaW);\n    float minWN = min(lumaN, lumaW);\n    float rangeMax = max(maxWN, maxESM);\n    float rangeMin = min(minWN, minESM);\n    float rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\n    float range = rangeMax - rangeMin;\n    float rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\n    bool earlyExit = range < rangeMaxClamped;\n\n    if (earlyExit)\n        return rgbyM;\n\n    float lumaNW = luma(texture2D(tex, posM + vec2(-1,-1) * fxaaQualityRcpFrame.xy));\n    float lumaSE = luma(texture2D(tex, posM + vec2( 1, 1) * fxaaQualityRcpFrame.xy));\n    float lumaNE = luma(texture2D(tex, posM + vec2( 1,-1) * fxaaQualityRcpFrame.xy));\n    float lumaSW = luma(texture2D(tex, posM + vec2(-1, 1) * fxaaQualityRcpFrame.xy));\n\n    float lumaNS = lumaN + lumaS;\n    float lumaWE = lumaW + lumaE;\n    float subpixRcpRange = 1.0/range;\n    float subpixNSWE = lumaNS + lumaWE;\n    float edgeHorz1 = (-2.0 * lumaM) + lumaNS;\n    float edgeVert1 = (-2.0 * lumaM) + lumaWE;\n\n    float lumaNESE = lumaNE + lumaSE;\n    float lumaNWNE = lumaNW + lumaNE;\n    float edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\n    float edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\n\n    float lumaNWSW = lumaNW + lumaSW;\n    float lumaSWSE = lumaSW + lumaSE;\n    float edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\n    float edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\n    float edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\n    float edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\n    float edgeHorz = abs(edgeHorz3) + edgeHorz4;\n    float edgeVert = abs(edgeVert3) + edgeVert4;\n\n    float subpixNWSWNESE = lumaNWSW + lumaNESE;\n    float lengthSign = fxaaQualityRcpFrame.x;\n    bool horzSpan = edgeHorz >= edgeVert;\n    float subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\n\n    if (horzSpan) {\n        lengthSign = fxaaQualityRcpFrame.y;\n    } else {\n        lumaN = lumaW;\n        lumaS = lumaE;\n    }\n    float subpixB = (subpixA * (1.0/12.0)) - lumaM;\n\n    float gradientN = lumaN - lumaM;\n    float gradientS = lumaS - lumaM;\n    float lumaNN = lumaN + lumaM;\n    float lumaSS = lumaS + lumaM;\n    bool pairN = abs(gradientN) >= abs(gradientS);\n    float gradient = max(abs(gradientN), abs(gradientS));\n    if (pairN) {\n        lengthSign = -lengthSign;\n    } else {\n        lumaNN = lumaSS;\n    }\n    float subpixC = clamp(abs(subpixB) * subpixRcpRange, 0.0, 1.0);\n\n    vec2 posB = posM;\n    vec2 offNP;\n\n    vec2 offHM;\n    if (horzSpan) {\n        offNP = vec2(fxaaQualityRcpFrame.x, 0.0);\n        offHM = vec2(0.0, lengthSign);\n    } else {\n        offNP = vec2(0.0, fxaaQualityRcpFrame.y);\n        offHM = vec2(lengthSign, 0.0);\n    }\n\n    vec2 posN = posB - offNP * 2.;\n    vec2 posP = posB + offNP * 2.;\n\n    float subpixD = ((-2.0)*subpixC) + 3.0;\n    float lumaEndN = luma(\n        mix(\n            texture2D(tex, posN),\n            texture2D(tex, posN + offHM),\n            0.5\n        )\n    );\n    float subpixE = subpixC * subpixC;\n    float lumaEndP = luma(\n        mix(\n            texture2D(tex, posP),\n            texture2D(tex, posP + offHM),\n            0.5\n        )\n    );\n\n    float gradientScaled = gradient * 0.25;\n    float lumaMM = lumaM - lumaNN * 0.5;\n    float subpixF = subpixD * subpixE;\n    bool lumaMLTZero = lumaMM < 0.0;\n\n    lumaEndN -= lumaNN * 0.5;\n    lumaEndP -= lumaNN * 0.5;\n    bool doneN = abs(lumaEndN) >= gradientScaled;\n    bool doneP = abs(lumaEndP) >= gradientScaled;\n    if (!doneN) {\n        posN -= offNP * 3.0;\n    }\n    bool doneNP = (!doneN) || (!doneP);\n    if (!doneP) {\n        posP += offNP * 3.0;\n    }\n\n    if (doneNP) {\n        if (!doneN) {\n            lumaEndN = luma(\n                mix(\n                    texture2D(tex, posN),\n                    texture2D(tex, posN + offHM),\n                    0.5\n                )\n            );\n            lumaEndN = lumaEndN - lumaNN * 0.5;\n        }\n        if (!doneP) {\n            lumaEndP = luma(\n                mix(\n                    texture2D(tex, posP.xy),\n                    texture2D(tex, posP.xy + offHM),\n                    0.5\n                )\n            );\n            lumaEndP = lumaEndP - lumaNN * 0.5;\n        }\n        doneN = abs(lumaEndN) >= gradientScaled;\n        doneP = abs(lumaEndP) >= gradientScaled;\n        if (!doneN) {\n            posN -= offNP * 12.0;\n        }\n        if (!doneP) {\n            posP += offNP * 12.0;\n        }\n    }\n    float dstN = posM.x - posN.x;\n    float dstP = posP.x - posM.x;\n    if (!horzSpan) {\n        dstN = posM.y - posN.y;\n        dstP = posP.y - posM.y;\n    }\n    bool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\n    float spanLength = (dstP + dstN);\n    bool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\n    float spanLengthRcp = 1.0/spanLength;\n    bool directionN = dstN < dstP;\n    float dst = min(dstN, dstP);\n    bool goodSpan = directionN ? goodSpanN : goodSpanP;\n    float subpixG = subpixF * subpixF;\n    float pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\n    float subpixH = subpixG * fxaaQualitySubpix;\n    float pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\n    float pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\n    vec4 color;\n    float factor = pixelOffsetSubpix;\n    if (horzSpan) {\n        color = mix(\n            texture2D(tex, posM),\n            texture2D(tex, posM + vec2(0.0, lengthSign)),\n            factor\n        );\n    } else {\n        color = mix(\n            texture2D(tex, posM),\n            texture2D(tex, posM + vec2(lengthSign, 0.0)),\n            factor\n        );\n    }\n\n    return color;\n}\n\nvoid main() {\n    vec2 pos = gl_FragCoord.xy * pixelSize;\n    vec4 color = fxaa(\n        pos,\n        texture,\n        pixelSize,\n        FXAA_QUALITY_SUBPIX,\n        FXAA_QUALITY_EDGE_THRESHOLD,\n        FXAA_QUALITY_EDGE_THRESHOLD_MIN\n    );\n\n    // If color.a is less than one, then the color has been blended with a black background before.\n    // An original color of transparent objects is vec4(color.xyz / color.a, color.a).\n    // We have to blend an original color with background pattern.\n    // color.a can be too close to zero. Check it.\n    if (color.a > EPSILON) {\n        color.xyz /= color.a;\n    }\n    gl_FragColor = color;\n}\n"

/***/ }),
/* 178 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec2 vertexPosition;\nattribute vec2 vertexUv;\n\nuniform float zIndex;\n\n#ifndef YV_LEAST_16b_P\n#   ifdef GL_FRAGMENT_PRECISION_HIGH\n#       define YV_LEAST_16b_P highp\n#   else\n#       define YV_LEAST_16b_P mediump\n#   endif\n#endif\n\nvarying YV_LEAST_16b_P vec2 uv;\n\nvoid main(void) {\n    gl_Position = vec4(vertexPosition, zIndex, 1);\n    uv = vertexUv;\n}\n"

/***/ }),
/* 179 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BackgroundRenderUnit; });
/* harmony import */ var _gl_renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(101);
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/* harmony import */ var _util_event_emitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(14);
/* harmony import */ var _shaders_quad_vert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(178);
/* harmony import */ var _shaders_quad_vert__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_shaders_quad_vert__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _shaders_background_frag__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(180);
/* harmony import */ var _shaders_background_frag__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_shaders_background_frag__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _util_hd__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(48);






const STATE = new _state__WEBPACK_IMPORTED_MODULE_1__["default"]({
    depthTest: true,
    depthFunc: 518 /* GREATER_OR_EQUAL */
});
/**
 * Fills map's canvas with background pattern on regions that have no data yet.
 */
class BackgroundRenderUnit extends _gl_renderer__WEBPACK_IMPORTED_MODULE_0__["GlRenderer"] {
    constructor(context) {
        const program = context.createProgram(_shaders_quad_vert__WEBPACK_IMPORTED_MODULE_3___default.a, _shaders_background_frag__WEBPACK_IMPORTED_MODULE_4___default.a, {
            attribMap: {
                vertexPosition: 0 /* POSITION */,
                vertexUv: 4 /* UV */
            }
        });
        super(context, STATE, program);
        context.bindProgram(program);
        program.setScalarUniform('zIndex', -1);
        this.onUpdate = new _util_event_emitter__WEBPACK_IMPORTED_MODULE_2__["VoidEventEmitter"]();
    }
    _render() {
        this._context.bindQuadVao();
        this._context.drawQuad();
    }
    _prepareProgram(program) {
        super._prepareProgram(program);
        program.setScalarUniform('dpr', Object(_util_hd__WEBPACK_IMPORTED_MODULE_5__["default"])());
    }
}


/***/ }),
/* 180 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nvoid main() {\n    // Background color should match main map layer color.\n    gl_FragColor = vec4(0.98, 0.97, 0.94, 1);\n}\n"

/***/ }),
/* 181 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LayerRenderUnit; });
/* harmony import */ var _list_render_unit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(172);
/* harmony import */ var _state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);


const DEPTH_CLEAR_STATE = new _state__WEBPACK_IMPORTED_MODULE_1__["default"]({
    depthTest: true,
    clearDepth: 0
});
class LayerRenderUnit extends _list_render_unit__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(context, depthClearStrategy = 0 /* NO_CLEAR */) {
        super();
        this._depthClearStrategy = depthClearStrategy;
        this._context = context;
    }
    render(target, ...args) {
        if (this._depthClearStrategy === 1 /* BEFORE_RENDER */) {
            this._context.bindRenderState(DEPTH_CLEAR_STATE);
            this._context.bindRenderTarget(target);
            this._context.clearCurrentTarget(256 /* DEPTH_BUFFER_BIT */);
        }
        super.render(target, ...args);
    }
}


/***/ }),
/* 182 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CollidingPrimitivesResetRemovedRenderer", function() { return CollidingPrimitivesResetRemovedRenderer; });
/* harmony import */ var _render_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);
/* harmony import */ var _render_memory_count_vertices__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(41);
/* harmony import */ var _shaders_reset_removed_vert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(183);
/* harmony import */ var _shaders_reset_removed_vert__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_shaders_reset_removed_vert__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _shaders_reset_removed_frag__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(184);
/* harmony import */ var _shaders_reset_removed_frag__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_shaders_reset_removed_frag__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _render_gl_renderer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(101);
/* harmony import */ var _render_primitives_primitive_batch__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(102);






class CollidingPrimitivesResetRemovedRenderer extends _render_gl_renderer__WEBPACK_IMPORTED_MODULE_4__["GlRenderer"] {
    constructor(context, primitiveProvider) {
        const program = context.createProgram(_shaders_reset_removed_vert__WEBPACK_IMPORTED_MODULE_2___default.a, _shaders_reset_removed_frag__WEBPACK_IMPORTED_MODULE_3___default.a, {
            attribMap: {
                vertexId: 2 /* ID */
            }
        });
        super(context, new _render_state__WEBPACK_IMPORTED_MODULE_0__["default"](), program);
        this._primitiveProvider = primitiveProvider;
        context.bindProgram(program);
        program.setIntScalarUniform('prevVisibility', 0);
    }
    _render() {
        const primitives = this._primitiveProvider.primitives;
        for (const memoryBatch of Object(_render_primitives_primitive_batch__WEBPACK_IMPORTED_MODULE_5__["batchPrimitives"])(primitives)) {
            this._context.bindVao(memoryBatch.page.vao);
            this._context.drawIndexedMesh(memoryBatch.indexByteOffset, Object(_render_memory_count_vertices__WEBPACK_IMPORTED_MODULE_1__["countIndices"])(memoryBatch.indexByteLength, memoryBatch.page.indexType), 0 /* POINTS */);
        }
    }
    _prepareProgram(program, prevVisibility, idHalfPxSize) {
        super._prepareProgram(program, prevVisibility, idHalfPxSize);
        this._context.bindTextureUnit(0);
        this._context.bindTexture(prevVisibility);
        program.setVector2Uniform('idHalfPxSize', idHalfPxSize);
    }
}


/***/ }),
/* 183 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec2 vertexId;\n\nuniform sampler2D prevVisibility;\nuniform vec2 idHalfPxSize;\n\nvarying lowp vec4 visibilityValue;\n\nvoid main() {\n    vec2 idTexCoordinates = vertexId + idHalfPxSize;\n    vec4 idWindowCoordinates = vec4(idTexCoordinates * 2.0 - 1.0, 0, 1);\n    gl_Position = idWindowCoordinates;\n    gl_PointSize = 1.0;\n\n    visibilityValue = texture2D(prevVisibility, idTexCoordinates);\n}\n"

/***/ }),
/* 184 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nvarying lowp vec4 visibilityValue;\n\nvoid main() {\n    gl_FragColor = visibilityValue;\n}\n"

/***/ }),
/* 185 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RenderLoop; });
/* harmony import */ var _util_event_emitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(14);

const MAX_FRAME_TIME_COUNT = 100;
class RenderLoop {
    /**
     * Create a new render loop, but doesn't schedule any animation frames.
     */
    constructor() {
        this.onFrameTimesFull = new _util_event_emitter__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this.onBeforeRender = new _util_event_emitter__WEBPACK_IMPORTED_MODULE_0__["VoidEventEmitter"]();
        this.onRender = new _util_event_emitter__WEBPACK_IMPORTED_MODULE_0__["VoidEventEmitter"]();
        this._isRunning = this._updateIsRequested = false;
        this._lastFrameTime = 0;
        this._frameTimes = new Array(MAX_FRAME_TIME_COUNT);
        this._frameTimes.fill(0);
        this._nextFrameTimeIdx = 0;
    }
    /**
     * @returns Whether the loop is running a chain of consecutive animation
     *      frames or not.
     */
    get isActive() {
        return this._isRunning;
    }
    /**
     * Starts a chain of consecutive animation frames.
     */
    start() {
        this._isRunning = true;
        this._requestFrame();
    }
    /**
     * Stops previously started chain of consecutive animation frames. If an
     * update was requested before stopping, one more animation frame will be
     * fired.
     */
    stop() {
        if (this._isRunning) {
            this._isRunning = false;
            if (!this._updateIsRequested) {
                this._cancelFrame();
            }
        }
    }
    /**
     * Schedules a single
     */
    update() {
        this._updateIsRequested = true;
        this._requestFrame();
    }
    /**
     * Stops all the rendering activities.
     */
    destroy() {
        this._cancelFrame();
    }
    _renderFrame(time) {
        this._rafId = 0;
        this._updateIsRequested = false;
        this.onBeforeRender.fire();
        this.onRender.fire();
        if (this._lastFrameTime > 0) {
            const nextFrameTimeIdx = this._nextFrameTimeIdx;
            this._frameTimes[nextFrameTimeIdx] = time - this._lastFrameTime;
            this._nextFrameTimeIdx = (nextFrameTimeIdx + 1) % MAX_FRAME_TIME_COUNT;
            // Next time index being 0 means that the array is full and it's
            // time to notify listeners about that before we start to rewrite
            // values.
            if (this._nextFrameTimeIdx === 0) {
                this.onFrameTimesFull.fire(this._frameTimes);
            }
        }
        if (this._isRunning) {
            this._lastFrameTime = time;
            this._requestFrame();
        }
        else {
            // If we don't schedule next frame immediately there's no way to
            // tell that it will be consecutive to the current one. Hence there's
            // no point in recording a time delta in it.
            this._lastFrameTime = 0;
        }
    }
    _requestFrame() {
        if (!this._rafId) {
            this._rafId = requestAnimationFrame(((time) => this._renderFrame(time)));
        }
    }
    _cancelFrame() {
        cancelAnimationFrame(this._rafId);
        this._rafId = 0;
    }
}


/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vdG9vbHMvc3RhbmQvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9jb250ZXh0LnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvYXR0cmliX21hcHBpbmcudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvaXRlcmFibGUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvcG93X29mXzIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9nbC9idWZmZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9nbC9mcmFtZWJ1ZmZlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL2dsL3Byb2dyYW0udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9nbC9yZW5kZXJidWZmZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9jYXBhYmlsaXRpZXMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9zdGF0ZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9jb2xvci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL2dsL3RleHR1cmUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9nbC92YW8udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvZXZlbnRfZW1pdHRlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvY2FtZXJhLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9tYXRoL3NjYWxhci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9yYWRfZGVnLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL29wdGlvbnMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL21hdGgvbWF0cml4NC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvbWF0aC92ZWN0b3IzLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9tYXRoL21hdHJpeDMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvZnV6enlfZXF1YWwudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL21hdGgvdmVjdG9yMi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdmVjdG9yX2FwaS9hZGFwdGVyLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9hZGFwdGVycy90aWxlX2Jhc2VkX2FkYXB0ZXIvYWRhcHRlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvYWRhcHRlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9mdW5jdGlvbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdGlsZV9iYXNlZF9hZGFwdGVyL3V0aWwvdGlsZV9zeXN0ZW0udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2FkYXB0ZXJzL3RpbGVfYmFzZWRfYWRhcHRlci90aWxlX2lkLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL3dvcmtlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC91bmlxdWVfaWQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2FkYXB0ZXJzL3RpbGVfYmFzZWRfYWRhcHRlci91dGlsL3Zpc2libGVfdGlsZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdGlsZV9iYXNlZF9hZGFwdGVyL2JlbHRfdGlsZXMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvc3RhdC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL2ljb24vaWNvbl9idWZmZXJfd3JpdGVyLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL2J1ZmZlcl93cml0ZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvZ3B1dHlwZXMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvYXJyYXkudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvY29tcGFyYXRvci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL21lbW9yeS9zdWJfY2h1bmsudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9tZW1vcnkvY291bnRfdmVydGljZXMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2JpbGxib2FyZC9pZGVudGlmaWVkX2ltYWdlX2F0bGFzX21hbmFnZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvcmVmX2NvdW50ZWQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2ZvbnQvZGZfZm9udC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvZm9udC9mb250LnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9hZGFwdGVycy92ZWN0b3JfYXBpL2FwaV9pbWFnZV9wcm92aWRlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYmlsbGJvYXJkL2ltYWdlX3Byb3ZpZGVyLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL2hkLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9hZGFwdGVycy92ZWN0b3JfYXBpL3V0aWwvaG9zdHMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3ByaW1pdGl2ZS9tb2RlbC9tb2RlbF9idWZmZXJfd3JpdGVyLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9wcmltaXRpdmUvcG9seWxpbmUvdGV4dHVyZWRfcG9seWxpbmVfYnVmZmVyX3dyaXRlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL3BvbHlsaW5lL3RleHR1cmVkX3BvbHlsaW5lX2dlb21ldHJ5LnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL3pfaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2JpbGxib2FyZC9pbWFnZV9tYW5hZ2VyLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9wcmltaXRpdmUvcG9seWdvbi90ZXh0dXJlZF9wb2x5Z29uX2J1ZmZlcl9yZXdpdGVyLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL2J1ZmZlcl9yZXdyaXRlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL3BvbHlnb24vdGV4dHVyZWRfcG9seWdvbl9hdHRyaWJ1dGVfbWFwcGluZy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL3BvbHlnb24vcG9seWdvbl9hdHRyaWJ1dGVfbWFwcGluZy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL2JpbGxib2FyZF9yZWN0YW5nbGUvYXR0cmlidXRlX21hcHBpbmcudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3ByaW1pdGl2ZS9sYWJlbC9wb2ludF9sYWJlbF9hdHRyaWJ1dGVfbWFwcGluZy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL2xhYmVsL2N1cnZlZF9sYWJlbF9hdHRyaWJ1dGVfbWFwcGluZy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL3BvbHlsaW5lL3BvbHlsaW5lX2F0dHJpYnV0ZV9tYXBwaW5nLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9hZGFwdGVycy92ZWN0b3JfYXBpL3dvcmtlci90aWxlX3Byb3ZpZGVyX3dvcmtlcl9jbGllbnQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2FkYXB0ZXJzL3ZlY3Rvcl9hcGkvd29ya2VyL3RpbGVfcHJvdmlkZXJfd29ya2VyX21lc3NhZ2VzLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9hZGFwdGVycy92ZWN0b3JfYXBpL3dvcmtlci9wcmltaXRpdmVfcHJvdmlkZXJfd29ya2VyX21lc3NhZ2VzLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9wcmltaXRpdmUvcG9seWdvbi90cmFuc3BhcmVudF9wb2x5Z29uX2F0dHJpYnV0ZV9tYXBwaW5nLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL2lkbGVfdGFza19xdWV1ZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9wcmlvcml0eV9xdWV1ZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9iaW5hcnlfaGVhcC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL3BvbHlnb24vcmVuZGVyYWJsZV9wb2x5Z29uLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9wcmltaXRpdmUvcmVuZGVyYWJsZV9wcmltaXRpdmUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3ByaW1pdGl2ZS9wb2x5Z29uL3JlbmRlcmFibGVfdGV4dHVyZWRfcG9seWdvbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL3BvbHlsaW5lL3JlbmRlcmFibGVfcG9seWxpbmUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3ByaW1pdGl2ZS9wb2x5bGluZS9yZW5kZXJhYmxlX3RleHR1cmVkX3BvbHlsaW5lLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9wcmltaXRpdmUvbW9kZWwvcmVuZGVyYWJsZV9tb2RlbC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdmVjdG9yX2FwaS90aWxlX2RhdGEudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2FkYXB0ZXJzL3ZlY3Rvcl9hcGkvcHJpbWl0aXZlX21hbmFnZXIvcmVuZGVyYWJsZV9wcmltaXRpdmVfbWFuYWdlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdmVjdG9yX2FwaS9wcmltaXRpdmVfbWFuYWdlci9wcmltaXRpdmVfbWFuYWdlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvcHJpbWl0aXZlX3NldF9zdG9yYWdlLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9hZGFwdGVycy92ZWN0b3JfYXBpL3ByaW1pdGl2ZV9tYW5hZ2VyL3BvbHlnb25fbWFuYWdlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvZGlzYXBwZWFyaW5nX3ByaW1pdGl2ZV9zZXRfc3RvcmFnZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvZGVsYXllZF9kaXNhcHBlYXJpbmdfcHJpbWl0aXZlX3NldF9zdG9yYWdlLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9hZGFwdGVycy92ZWN0b3JfYXBpL3ByaW1pdGl2ZV9tYW5hZ2VyL3pvb21fZmlsdGVyYWJsZV9wcmltaXRpdmVfbWFuYWdlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdmVjdG9yX2FwaS9wcmltaXRpdmVfbWFuYWdlci9leHRlcm5hbF9tZXNoX21hbmFnZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3ByaW1pdGl2ZS9iaWxsYm9hcmRfcmVjdGFuZ2xlL3JlbmRlcmFibGVfYmlsbGJvYXJkX3JlY3RhbmdsZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdmVjdG9yX2FwaS9wcmltaXRpdmUvem9vbV9yZXN0cmljdGVkX2xhYmVsLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9wcmltaXRpdmUvbGFiZWwvcmVuZGVyYWJsZV9sYWJlbC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdmVjdG9yX2FwaS9wcmltaXRpdmUvem9vbV9yZXN0cmljdGVkX2ljb24udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3ByaW1pdGl2ZS9pY29uL3JlbmRlcmFibGVfaWNvbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL2ltYWdlL3JlbmRlcmFibGVfaW1hZ2UudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3ByaW1pdGl2ZS90ZXh0dXJlZF9yZW5kZXJhYmxlX3ByaW1pdGl2ZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC90YXNrX3F1ZXVlLnRzIiwid2VicGFjazovLy8uL3Rvb2xzL3N0YW5kL2NhbWVyYV9zdHVmZi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9kZWxlZ2F0b3IudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3Zpc2liaWxpdHkvcHJpbWl0aXZlcy9sYWJlbC9jb2xvcl9pZF9wb2ludF9sYWJlbF9yZW5kZXJlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdmlzaWJpbGl0eS9wcmltaXRpdmVzL2xhYmVsL3NoYWRlci9wb2ludF9sYWJlbC52ZXJ0Iiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS92aXNpYmlsaXR5L3ByaW1pdGl2ZXMvbGFiZWwvc2hhZGVyL2NvbG9yX2lkLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3Zpc2liaWxpdHkvcHJpbWl0aXZlcy9sYWJlbC9jb2xvcl9pZF9sYWJlbF9yZW5kZXJlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdmlzaWJpbGl0eS9wcmltaXRpdmVzL2NvbGxpZGluZ19wcmltaXRpdmVfY29sb3JfaWRfcmVuZGVyZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL3dvcmxkX3ByaW1pdGl2ZV9yZW5kZXJfdW5pdC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL2dsX3JlbmRlcmVyLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9wcmltaXRpdmVfYmF0Y2gudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9tZW1vcnkvcmVsYXRpdmVfbG9jYXRpb24udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL2xhYmVsL3BvaW50X2xhYmVsX3JlbmRlcl91bml0LnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9sYWJlbC9zaGFkZXIvcG9pbnRfbGFiZWwudmVydCIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvbGFiZWwvc2hhZGVyL2RmX3RleHQuZnJhZyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvbGFiZWwvbGFiZWxfcmVuZGVyX3VuaXQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL2JpbGxib2FyZF9yZWN0YW5nbGUvYmlsbGJvYXJkX3JlY3RhbmdsZV9yZW5kZXJfdW5pdC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvYmlsbGJvYXJkX3JlY3RhbmdsZS9zaGFkZXIvYmlsbGJvYXJkX3JlY3RhbmdsZS52ZXJ0Iiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9iaWxsYm9hcmRfcmVjdGFuZ2xlL3NoYWRlci9iaWxsYm9hcmRfcmVjdGFuZ2xlLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3Zpc2liaWxpdHkvcHJpbWl0aXZlcy9sYWJlbC9jb2xvcl9pZF9jdXJ2ZWRfbGFiZWxfcmVuZGVyZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3Zpc2liaWxpdHkvcHJpbWl0aXZlcy9sYWJlbC9zaGFkZXIvY3VydmVkX2xhYmVsLnZlcnQiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL2xhYmVsL2N1cnZlZF9sYWJlbF9yZW5kZXJfdW5pdC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvbGFiZWwvc2hhZGVyL2N1cnZlZF9sYWJlbC52ZXJ0Iiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9pY29uL2ljb25fcmVuZGVyX3VuaXQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL2ljb24vc2hhZGVyL2ljb24udmVydCIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvaWNvbi9zaGFkZXIvaWNvbi5mcmFnIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9pbWFnZS9pbWFnZV9yZW5kZXJfdW5pdC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvaW1hZ2Uvc2hhZGVyL2ltYWdlLnZlcnQiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL2ltYWdlL3NoYWRlci9pbWFnZS5mcmFnIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9tb2RlbC9tb2RlbF9yZW5kZXJfdW5pdC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvbW9kZWwvc2hhZGVyL21vZGVsLnZlcnQiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL21vZGVsL3NoYWRlci9tb2RlbC5mcmFnIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9vdmVybGF5L292ZXJsYXlfcmVuZGVyZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL292ZXJsYXkvc2hhZGVyL292ZXJsYXkudmVydCIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvb3ZlcmxheS9zaGFkZXIvb3ZlcmxheS5mcmFnIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9wb2x5bGluZS90ZXh0dXJlZF9wb2x5bGluZV9yZW5kZXJfdW5pdC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvcG9seWxpbmUvc2hhZGVyL3RleHR1cmVkX3BvbHlsaW5lLnZlcnQiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL3BvbHlsaW5lL3NoYWRlci90ZXh0dXJlZF9wb2x5bGluZS5mcmFnIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9wb2x5bGluZS9iYXNlX3BvbHlsaW5lX3JlbmRlcl91bml0LnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9wb2x5bGluZS9wb2x5bGluZV9yZW5kZXJfdW5pdC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL3BvbHlsaW5lL3BvbHlsaW5lX2J1ZmZlcl93cml0ZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL3BvbHlsaW5lL3NoYWRlci9wb2x5bGluZS52ZXJ0Iiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9wb2x5bGluZS9zaGFkZXIvcG9seWxpbmUuZnJhZyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvcG9seWdvbi90ZXh0dXJlZF9wb2x5Z29uX3JlbmRlcl91bml0LnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9wb2x5Z29uL3NoYWRlci90ZXh0dXJlZF9wb2x5Z29uLnZlcnQiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL3BvbHlnb24vc2hhZGVyL3RleHR1cmVkX3BvbHlnb24uZnJhZyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvcG9seWdvbi90cmFuc3BhcmVudF9wb2x5Z29uX3JlbmRlcl91bml0LnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9wb2x5Z29uL3BvbHlnb25fcmVuZGVyX3VuaXQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL3BvbHlnb24vc2hhZGVyL3BvbHlnb24udmVydCIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvcG9seWdvbi9zaGFkZXIvcG9seWdvbi5mcmFnIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9tYXBfZW5naW5lLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9lbmdpbmUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9mb250L3JlbmRlcmFibGVfZGZfZ2x5cGhfYXRsYXMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2ZvbnQvZGZfZ2x5cGhfYXRsYXMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2ZvbnQvZGZfZm9udF9yZWdpc3RyeS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvZm9udC9mb250X3JlZ2lzdHJ5LnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvYmlsbGJvYXJkL3JlbmRlcmFibGVfaW1hZ2VfYXRsYXMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2JpbGxib2FyZC9pbWFnZV9hdGxhcy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9hbGxvY2F0b3JfMmQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvYWxsb2NhdG9yLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL2JpbmFyeV90cmVlLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL2xpbmtlZF9zZXQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3Zpc2liaWxpdHkvdmlzaWJpbGl0eV9tYW5hZ2VyLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS92aXNpYmlsaXR5L2dyaWRfc2FtcGxlcl9idWZmZXJfd3JpdGVyLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS92aXNpYmlsaXR5L2dyaWRfcmVuZGVyZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3Zpc2liaWxpdHkvdmlzaWJpbGl0eV9yZXNvbHV0aW9uX3N0ZXBzL3Jlc2V0X3JlbW92ZWRfcHJpbWl0aXZlcy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdmlzaWJpbGl0eS92aXNpYmlsaXR5X3Jlc29sdXRpb25fc3RlcHMvZmFkZW91dF9hbGwudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3Zpc2liaWxpdHkvdmlzaWJpbGl0eV9yZXNvbHV0aW9uX3N0ZXBzL3NoYWRlcnMvZmFkZW91dF9hbGwudmVydCIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdmlzaWJpbGl0eS92aXNpYmlsaXR5X3Jlc29sdXRpb25fc3RlcHMvc2hhZGVycy9mYWRlb3V0X2FsbC5mcmFnIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS92aXNpYmlsaXR5L2lkX3NhbXBsZXJfYnVmZmVyX3dyaXRlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdmlzaWJpbGl0eS92aXNpYmlsaXR5X3Jlc29sdXRpb25fc3RlcHMvZmFkZWluX3Zpc2libGUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3Zpc2liaWxpdHkvdmlzaWJpbGl0eV9yZXNvbHV0aW9uX3N0ZXBzL3NoYWRlcnMvZmFkZWluX3Zpc2libGUudmVydCIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdmlzaWJpbGl0eS92aXNpYmlsaXR5X3Jlc29sdXRpb25fc3RlcHMvc2hhZGVycy9mYWRlaW5fdmlzaWJsZS5mcmFnIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS92aXNpYmlsaXR5L3Zpc2liaWxpdHlfcmVzb2x1dGlvbl9zdGVwcy9mYWRlb3V0X292ZXJsYXBwZWQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3Zpc2liaWxpdHkvdmlzaWJpbGl0eV9yZXNvbHV0aW9uX3N0ZXBzL3NoYWRlcnMvZmFkZW91dF9vdmVybGFwcGVkLnZlcnQiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3Zpc2liaWxpdHkvdmlzaWJpbGl0eV9yZXNvbHV0aW9uX3N0ZXBzL3NoYWRlcnMvZmFkZW91dF9vdmVybGFwcGVkLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci91dGlsL2NhbWVyYV9wb3NpdGlvbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9jYXJ0ZXNpYW5fZ3JpZC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9tZWRpYW5fZmlsdGVyLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvbWFpbl9yZW5kZXJfdW5pdC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL2xpc3RfcmVuZGVyX3VuaXQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9tZW1vcnkvbWFuYWdlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL21lbW9yeS9wYWdlLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvbWVtb3J5L2NodW5rLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvZnhhYV9yZW5kZXJfdW5pdC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3NoYWRlcnMvZnhhYS5mcmFnIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvc2hhZGVycy9xdWFkLnZlcnQiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9iYWNrZ3JvdW5kX3JlbmRlcl91bml0LnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvc2hhZGVycy9iYWNrZ3JvdW5kLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9sYXllcl9yZW5kZXJfdW5pdC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdmlzaWJpbGl0eS9wcmltaXRpdmVzL2NvbGxpZGluZ19wcmltaXRpdmVfcmVzZXRfcmVtb3ZlZF9yZW5kZXJlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdmlzaWJpbGl0eS9wcmltaXRpdmVzL3NoYWRlcnMvcmVzZXRfcmVtb3ZlZC52ZXJ0Iiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS92aXNpYmlsaXR5L3ByaW1pdGl2ZXMvc2hhZGVycy9yZXNldF9yZW1vdmVkLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlcl9sb29wLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtEQUEwQyxnQ0FBZ0M7QUFDMUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnRUFBd0Qsa0JBQWtCO0FBQzFFO0FBQ0EseURBQWlELGNBQWM7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUF5QyxpQ0FBaUM7QUFDMUUsd0hBQWdILG1CQUFtQixFQUFFO0FBQ3JJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7OztBQUdBO0FBQ0E7Ozs7Ozs7O0FDbEZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBb0U7QUFDVDtBQUMrQjtBQUMyQjtBQUNZO0FBQ0U7QUFDakI7QUFDRTtBQUNoQjtBQUNHO0FBQzBCO0FBQ2pCO0FBQ2M7QUFDTTtBQUN2QjtBQUMzQztBQUNOO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsK0NBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxlQUFlO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyw4Q0FBVztBQUM5QztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9EQUFjO0FBQzNCO0FBQ0EsWUFBWSxnREFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0RBQU07QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDbnlCQTtBQUFBO0FBQUE7QUFBQTtBQUErQztBQUNOO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGtFQUFXLGtCQUFrQix5QkFBeUI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNERBQUs7QUFDbkM7QUFDQTtBQUNBLGtDQUFrQyxtQkFBbUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMxREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSw0QkFBNEIsY0FBYztBQUMxQztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSx3REFBd0QscUJBQXFCO0FBQzdFO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN4R0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBOzs7Ozs7OztBQ3BCQTtBQUFBO0FBQUE7QUFDZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNwREE7QUFBQTtBQUFBO0FBQ2U7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMzREE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2U7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELDZCQUE2QjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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TztBQUNQLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7Ozs7Ozs7O0FDakVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3ZGQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsOENBQWEsQ0FBQyxpREFBZ0I7QUFDOUM7QUFDQTs7Ozs7Ozs7QUNuV0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLElBQUksK0NBQWM7QUFDbEIsSUFBSSwrQ0FBYztBQUNsQixJQUFJLCtDQUFjO0FBQ2xCO0FBQ0EsMEJBQTBCLE9BQU87QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLG1CQUFtQjtBQUN4QixLQUFLLG1CQUFtQjtBQUN4QixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sMkJBQTJCLCtDQUFjO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzFIQTtBQUFBO0FBQUE7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNaQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVk7QUFDWjtBQUNPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywyQ0FBMkMsbUVBQWlCO0FBQ25FLFlBQVksaUVBQW1CO0FBQy9CLFFBQVEsaUVBQW1CO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsMkRBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxpQkFBaUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMvS0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBOzs7Ozs7OztBQ05BO0FBQUE7QUFBQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcseUJBQXlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDBCQUEwQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGVBQWU7QUFDdEMsdUNBQXVDLGlCQUFpQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0NBQWtDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0NBQWtDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0NBQWtDO0FBQ3pEO0FBQ0EsbUNBQW1DLGdCQUFnQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsYUFBYTtBQUM1RjtBQUNBLG1DQUFtQyxnQkFBZ0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2hLQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQTREO0FBQ2pCO0FBQ087QUFDbEQ7QUFDQSxlQUFlLG9EQUFXO0FBQzFCLFlBQVksb0RBQVc7QUFDdkIsY0FBYyxvREFBVztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0RBQVc7QUFDMUIsWUFBWSxvREFBVztBQUN2QixjQUFjLG9EQUFXO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvREFBVztBQUMxQixZQUFZLG9EQUFXO0FBQ3ZCLGNBQWMsb0RBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9EQUFXO0FBQzFCLFlBQVksb0RBQVc7QUFDdkIsY0FBYyxvREFBVztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGtFQUFhO0FBQ3RDLHlCQUF5QixrRUFBYTtBQUN0QztBQUNBO0FBQ0Esc0JBQXNCLDBEQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixXQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx3Q0FBd0MscUVBQW9CO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxxRUFBb0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixXQUFXO0FBQzlCLHVCQUF1QixXQUFXO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDBEQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0EsaUNBQWlDLGNBQWM7QUFDL0Msc0NBQXNDLHFFQUFvQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQy9JQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxJQUFJLEdBQUcsVUFBVTtBQUM5RDtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUIscUNBQXFDLElBQUksT0FBTyxJQUFJO0FBQ3BELGlCQUFpQixlQUFlLEdBQUcsZUFBZSxvQkFBb0IsUUFBUTtBQUM5RTtBQUNBO0FBQ0Esd0NBQXdDLFdBQVcsRUFBRSx3QkFBd0I7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxrREFBa0QsV0FBVyxHQUFHLGdCQUFnQjtBQUNoRjtBQUNBO0FBQ0EsY0FBYyxXQUFXLEdBQUcsV0FBVyxHQUFHLGNBQWM7QUFDeEQ7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOzs7Ozs7OztBQ3ZFQTtBQUFBO0FBQUE7QUFBQTtBQUErRDtBQUNYO0FBQ3BEO0FBQ0E7QUFDQTtBQUNlLCtCQUErQiwyREFBWTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsdUVBQWdCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNqRkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUEyQztBQUNiO0FBQ3ZCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixXQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixXQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsc0JBQXNCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrREFBRztBQUNsQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwrREFBYTtBQUNyQyx3QkFBd0IsK0RBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDM2VBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7Ozs7Ozs7O0FDaENBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLHdDQUF3QyxZQUFZO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsbUJBQW1CLFlBQVk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywyQ0FBMkMsOERBQWtCO0FBQ3BFLHVCQUF1QixTQUFTO0FBQ2hDLHVCQUF1QixxREFBcUQ7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHVDQUF1Qyw4REFBa0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MseUJBQXlCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDckxBO0FBQUE7QUFBQTtBQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTs7Ozs7Ozs7QUNYQTtBQUFBO0FBQUE7QUFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvRUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzdDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNsQkE7QUFBQTtBQUFBO0FBQUE7QUFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDZCQUE2Qix5REFBZ0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2xFQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ2U7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMvQkE7QUFBQTtBQUFBO0FBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2UscUJBQXFCLDZDQUFJO0FBQ3hD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDM0VBO0FBQUE7QUFBQTtBQUErRDtBQUMvRDtBQUNPLDJDQUEyQyx1RUFBZ0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzNHQTtBQUFBO0FBQUE7QUFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ08sdUNBQXVDLHVFQUFnQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNqTEE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QyxzRkFBd0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQzlCQTtBQUFBO0FBQUE7QUFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQSw0QkFBNEIsb0VBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDbkVBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBZ0M7QUFDaUI7QUFDSztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDZDQUFVO0FBQzdDO0FBQ0EsNkRBQTZELDhEQUFjLDhCQUE4Qiw4REFBYztBQUN2SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2U7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTs7Ozs7OztBQy9CQSw2RUFBNkUscUNBQXFDLDRCQUE0QixzQ0FBc0MsaUJBQWlCLHNEQUFzRCwwRUFBMEUsd0NBQXdDLHlCQUF5QixzRUFBc0UsR0FBRyxHOzs7Ozs7QUNBL2MsdUZBQXVGLGlCQUFpQixxQ0FBcUMsR0FBRyxHOzs7Ozs7O0FDQWhKO0FBQUE7QUFBQTtBQUFzRTtBQUN0RTtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsZ0VBQVk7QUFDaEQsa0NBQWtDLG9FQUFnQjtBQUNsRCw0QkFBNEIsb0VBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiaW5kZXgudHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMCk7XG4iLCJpbXBvcnQgQ29udGV4dCBmcm9tICcuLi8uLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL2NvbnRleHQnO1xyXG5pbXBvcnQgQ2FtZXJhIGZyb20gJy4uLy4uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9jYW1lcmEnO1xyXG5pbXBvcnQgVmVjdG9yQXBpQWRhcHRlciBmcm9tICcuLi8uLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdmVjdG9yX2FwaS9hZGFwdGVyJztcclxuaW1wb3J0IHsgQ2FtZXJhTW91c2VDb250cm9sbGVyLCBNb3VzZURyYWdDb250cm9sbGVyLCBTY3JvbGxab29tQ29udHJvbGxlciwgcmVuZGVyQ2FtZXJhU3RhdGUgfSBmcm9tICcuL2NhbWVyYV9zdHVmZic7XHJcbmltcG9ydCBDb2xvcklkUG9pbnRMYWJlbFJlbmRlcmVyIGZyb20gJy4uLy4uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS92aXNpYmlsaXR5L3ByaW1pdGl2ZXMvbGFiZWwvY29sb3JfaWRfcG9pbnRfbGFiZWxfcmVuZGVyZXInO1xyXG5pbXBvcnQgQ29sb3JJZEN1cnZlZExhYmVsUmVuZGVyZXIgZnJvbSAnLi4vLi4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3Zpc2liaWxpdHkvcHJpbWl0aXZlcy9sYWJlbC9jb2xvcl9pZF9jdXJ2ZWRfbGFiZWxfcmVuZGVyZXInO1xyXG5pbXBvcnQgUG9pbnRMYWJlbFJlbmRlclVuaXQgZnJvbSAnLi4vLi4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL2xhYmVsL3BvaW50X2xhYmVsX3JlbmRlcl91bml0JztcclxuaW1wb3J0IEN1cnZlZExhYmVsUmVuZGVyVW5pdCBmcm9tICcuLi8uLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvbGFiZWwvY3VydmVkX2xhYmVsX3JlbmRlcl91bml0JztcclxuaW1wb3J0IEljb25SZW5kZXJVbml0IGZyb20gJy4uLy4uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9pY29uL2ljb25fcmVuZGVyX3VuaXQnO1xyXG5pbXBvcnQgTW9kZWxSZW5kZXJVbml0IGZyb20gJy4uLy4uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9tb2RlbC9tb2RlbF9yZW5kZXJfdW5pdCc7XHJcbmltcG9ydCBUZXh0dXJlZFBvbHlsaW5lUmVuZGVyVW5pdCBmcm9tICcuLi8uLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvcG9seWxpbmUvdGV4dHVyZWRfcG9seWxpbmVfcmVuZGVyX3VuaXQnO1xyXG5pbXBvcnQgUG9seWxpbmVSZW5kZXJVbml0IGZyb20gJy4uLy4uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9wb2x5bGluZS9wb2x5bGluZV9yZW5kZXJfdW5pdCc7XHJcbmltcG9ydCBUZXh0dXJlZFBvbHlnb25SZW5kZXJVbml0IGZyb20gJy4uLy4uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9wb2x5Z29uL3RleHR1cmVkX3BvbHlnb25fcmVuZGVyX3VuaXQnO1xyXG5pbXBvcnQgVHJhbnNwYXJlbnRQb2x5Z29uUmVuZGVyVW5pdCBmcm9tICcuLi8uLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvcG9seWdvbi90cmFuc3BhcmVudF9wb2x5Z29uX3JlbmRlcl91bml0JztcclxuaW1wb3J0IFBvbHlnb25SZW5kZXJVbml0IGZyb20gJy4uLy4uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9wb2x5Z29uL3BvbHlnb25fcmVuZGVyX3VuaXQnO1xyXG5pbXBvcnQgTWFwRW5naW5lIGZyb20gJy4uLy4uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9tYXBfZW5naW5lJztcclxuaW1wb3J0IGdldERwciBmcm9tICcuLi8uLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9oZCc7XHJcbmltcG9ydCB7IENvbGxpZGluZ1ByaW1pdGl2ZXNSZXNldFJlbW92ZWRSZW5kZXJlciB9IGZyb20gJy4uLy4uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS92aXNpYmlsaXR5L3ByaW1pdGl2ZXMvY29sbGlkaW5nX3ByaW1pdGl2ZV9yZXNldF9yZW1vdmVkX3JlbmRlcmVyJztcclxuaW1wb3J0IFJlbmRlckxvb3AgZnJvbSAnLi4vLi4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlcl9sb29wJztcclxuLy8gaW1wb3J0IEltYWdlUmVuZGVyVW5pdCBmcm9tICcuLi8uLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvaW1hZ2UvaW1hZ2VfcmVuZGVyX3VuaXQnO1xyXG4vLyBpbXBvcnQgUmFzdGVyVGlsZXNBZGFwdGVyIGZyb20gJy4uLy4uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9hZGFwdGVycy9yYXN0ZXJfdGlsZXMvYWRhcHRlcic7XHJcbi8vIGltcG9ydCB7VGlsZUl0ZW19IGZyb20gJy4uLy4uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9hZGFwdGVycy90aWxlX2Jhc2VkX2FkYXB0ZXIvdXRpbC90aWxlX3N5c3RlbSc7XHJcbmNvbnN0IEdMX0NPTlRFWFRfQVRUUklCUyA9IHtcclxuICAgIGFscGhhOiBmYWxzZSxcclxuICAgIGRlcHRoOiB0cnVlLFxyXG4gICAgc3RlbmNpbDogZmFsc2UsXHJcbiAgICBhbnRpYWxpYXM6IGZhbHNlLFxyXG4gICAgZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdDogdHJ1ZVxyXG59O1xyXG5jb25zdCBjYW1lcmEgPSBuZXcgQ2FtZXJhKHtcclxuICAgIHdyYXBNb2RlWDogMiAvKiBSRVBFQVQgKi8sXHJcbiAgICB3cmFwTW9kZVk6IDAgLyogTk9ORSAqL1xyXG59KTtcclxuY2FtZXJhLm9uVXBkYXRlLmFkZExpc3RlbmVyKCgpID0+IHJlbmRlckNhbWVyYVN0YXRlKGNhbWVyYSkpO1xyXG5jYW1lcmEuY2VudGVyLnggPSAwLjIwODk4NDM3O1xyXG5jYW1lcmEuY2VudGVyLnkgPSAwLjM3MzA0Njg3O1xyXG5jYW1lcmEuem9vbSA9IDE0O1xyXG5jb25zdCBjYW52YXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjY2FudmFzJyk7XHJcbntcclxuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgY29uc3QgZHByID0gZ2V0RHByKCk7XHJcbiAgICBjYW52YXMud2lkdGggPSBkcHIgKiB3aWR0aDtcclxuICAgIGNhbnZhcy5oZWlnaHQgPSBkcHIgKiBoZWlnaHQ7XHJcbiAgICBjYW1lcmEuc2NyZWVuU2l6ZS53aWR0aCA9IHdpZHRoO1xyXG4gICAgY2FtZXJhLnNjcmVlblNpemUuaGVpZ2h0ID0gaGVpZ2h0O1xyXG59XHJcbmNvbnN0IGNhbWVyYU1vdXNlQ29udHJvbGxlciA9IG5ldyBDYW1lcmFNb3VzZUNvbnRyb2xsZXIoY2FudmFzLCBjYW1lcmEpO1xyXG5jb25zdCBtb3VzZURyYWdDb250cm9sbGVyID0gbmV3IE1vdXNlRHJhZ0NvbnRyb2xsZXIoY2FudmFzKTtcclxubW91c2VEcmFnQ29udHJvbGxlci5zZXREZWxlZ2F0ZShjYW1lcmFNb3VzZUNvbnRyb2xsZXIpO1xyXG5jb25zdCBzY3JvbGxab29tQ29udHJvbGxlciA9IG5ldyBTY3JvbGxab29tQ29udHJvbGxlcihjYW52YXMpO1xyXG5zY3JvbGxab29tQ29udHJvbGxlci5zZXREZWxlZ2F0ZShjYW1lcmFNb3VzZUNvbnRyb2xsZXIpO1xyXG5jb25zdCBjb250ZXh0ID0gQ29udGV4dC5jcmVhdGVGcm9tQ2FudmFzKGNhbnZhcywgR0xfQ09OVEVYVF9BVFRSSUJTKTtcclxuY29uc3QgZW5naW5lID0gbmV3IE1hcEVuZ2luZShjb250ZXh0LCBjYW1lcmEsIG5ldyBSZW5kZXJMb29wKCkpO1xyXG5jb25zdCB2ZWN0b3JBZGFwdGVyID0gbmV3IFZlY3RvckFwaUFkYXB0ZXIoZW5naW5lLCBjYW1lcmEsICcuL3RpbGVfcHJvdmlkZXJfd29ya2VyLmpzP3dvcmtlcicsICdtYXAnLCBcclxuLy8ge1xyXG4vLyAgICAgdGlsZVVybFRlbXBsYXRlOiAnaHR0cHM6Ly92ZWMtcmRyMDFlLnRzdC5tYXBzLnlhbmRleC5ydS92bWFwMi90aWxlcz9sPXZtYXAyJmxhbmc9cnVfUlUmeD17e3h9fSZ5PXt7eX19Jno9e3t6fX0mem1pbj17e3ptaW59fSZ6bWF4PXt7em1heH19JyxcclxuLy8gICAgIGltYWdlVXJsVGVtcGxhdGU6ICdodHRwczovL3ZlYy1yZHIwMWUudHN0Lm1hcHMueWFuZGV4LnJ1L3Jlc291cmNlcz9pZD17e2lkfX0mc2NhbGU9e3tzY2FsZX19JyxcclxuLy8gICAgIG1lc2hVcmxUZW1wbGF0ZTogJ2h0dHBzOi8vdmVjLXJkcjAxZS50c3QubWFwcy55YW5kZXgucnUvbWVzaGVzP2lkPXt7aWR9fScsXHJcbi8vICAgICBnbHlwaFJhbmdlVXJsVGVtcGxhdGU6ICdodHRwczovL3ZlYy1yZHIwMWUudHN0Lm1hcHMueWFuZGV4LnJ1L2dseXBocz9sYW5nPXJ1X1JVJmZvbnRfaWQ9e3tmb250SWR9fSZyYW5nZT17e3JhbmdlfX0nXHJcbi8vIH1cclxue1xyXG4gICAgdGlsZVVybFRlbXBsYXRlOiAnaHR0cHM6Ly92ZWMwe3tob3N0QWxpYXN9fS5tYXBzLnlhbmRleC5uZXQvdm1hcDIvdGlsZXM/bD12bWFwMiZsYW5nPVJVX3J1Jng9e3t4fX0meT17e3l9fSZ6PXt7en19JnptaW49e3t6bWlufX0mem1heD17e3ptYXh9fScsXHJcbiAgICBpbWFnZVVybFRlbXBsYXRlOiAnaHR0cHM6Ly92ZWMwe3tob3N0QWxpYXN9fS5tYXBzLnlhbmRleC5uZXQvcmVzb3VyY2VzP2lkPXt7aWR9fSZzY2FsZT17e3NjYWxlfX0nLFxyXG4gICAgbWVzaFVybFRlbXBsYXRlOiAnaHR0cHM6Ly92ZWMwe3tob3N0QWxpYXN9fS5tYXBzLnlhbmRleC5uZXQvdm1hcDIvbWVzaGVzP2lkPXt7aWR9fScsXHJcbiAgICBnbHlwaFJhbmdlVXJsVGVtcGxhdGU6ICdodHRwczovL3ZlYzB7e2hvc3RBbGlhc319Lm1hcHMueWFuZGV4Lm5ldC9nbHlwaHM/bGFuZz1SVV9ydSZmb250X2lkPXt7Zm9udElkfX0mcmFuZ2U9e3tyYW5nZX19J1xyXG59LCAxIC8qIFg0ICovKTtcclxuLy8gY2xhc3MgVHJhZmZpY0xheWVyQWRhcHRlciBleHRlbmRzIFJhc3RlclRpbGVzQWRhcHRlciB7XHJcbi8vICAgICBwdWJsaWMgX2dldEltYWdlVXJsKHRpbGU6IFRpbGVJdGVtKTogc3RyaW5nIHtcclxuLy8gICAgICAgICByZXR1cm4gYGh0dHBzOi8vamdvLm1hcHMueWFuZGV4Lm5ldC8xLjEvdGlsZXM/dHJmJmw9dHJmLHRyZmUmbGFuZz1ydV9VQSZ4PSR7dGlsZS54fSZ5PSR7dGlsZS55fSZ6PSR7dGlsZS56b29tfSZzY2FsZT0ke3dpbmRvdy5kZXZpY2VQaXhlbFJhdGlvfSZ0bT0ke01hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApfWBcclxuLy8gICAgICAgICAvLyByZXR1cm4gYGh0dHBzOi8vc2F0MDMubWFwcy55YW5kZXgubmV0L3RpbGVzP2w9c2F0JnY9My40MTkuMCZ4PSR7dGlsZS54fSZ5PSR7dGlsZS55fSZ6PSR7dGlsZS56b29tfSZzY2FsZT0ke3dpbmRvdy5kZXZpY2VQaXhlbFJhdGlvfSZsYW5nPXJ1X1VBYFxyXG4vLyAgICAgfVxyXG4vLyB9XHJcbi8vIGNvbnN0IHRyYWZmaWNBZGFwdGVyID0gbmV3IFRyYWZmaWNMYXllckFkYXB0ZXIoXHJcbi8vICAgICBlbmdpbmUsXHJcbi8vICAgICBjYW1lcmEsXHJcbi8vICAgICB7d2lkdGg6IDI1NiAqIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvLCBoZWlnaHQ6IDI1NiAqIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvfVxyXG4vLyApO1xyXG5lbmdpbmUuZ3JvdW5kTGF5ZXIuYWRkUmVuZGVyVW5pdChuZXcgUG9seWdvblJlbmRlclVuaXQoY29udGV4dCwgdmVjdG9yQWRhcHRlci5vcGFxdWVQb2x5Z29uc1Byb3ZpZGVyKSk7XHJcbmVuZ2luZS5ncm91bmRMYXllci5hZGRSZW5kZXJVbml0KG5ldyBUcmFuc3BhcmVudFBvbHlnb25SZW5kZXJVbml0KGNvbnRleHQsIHZlY3RvckFkYXB0ZXIudHJhbnNwYXJlbnRQb2x5Z29uc1Byb3ZpZGVyKSk7XHJcbmVuZ2luZS5ncm91bmRMYXllci5hZGRSZW5kZXJVbml0KG5ldyBUZXh0dXJlZFBvbHlnb25SZW5kZXJVbml0KGNvbnRleHQsIHZlY3RvckFkYXB0ZXIudGV4dHVyZWRQb2x5Z29uc1Byb3ZpZGVyKSk7XHJcbmVuZ2luZS5ncm91bmRMYXllci5hZGRSZW5kZXJVbml0KG5ldyBQb2x5bGluZVJlbmRlclVuaXQoY29udGV4dCwgY2FtZXJhLCB2ZWN0b3JBZGFwdGVyLnBvbHlsaW5lc1Byb3ZpZGVyKSk7XHJcbmVuZ2luZS5ncm91bmRMYXllci5hZGRSZW5kZXJVbml0KG5ldyBUZXh0dXJlZFBvbHlsaW5lUmVuZGVyVW5pdChjb250ZXh0LCBjYW1lcmEsIHZlY3RvckFkYXB0ZXIudGV4dHVyZWRQb2x5bGluZXNQcm92aWRlcikpO1xyXG5lbmdpbmUuYnVpbGRpbmdzTGF5ZXIuYWRkUmVuZGVyVW5pdChuZXcgTW9kZWxSZW5kZXJVbml0KGNvbnRleHQsIHZlY3RvckFkYXB0ZXIubW9kZWxzUHJvdmlkZXIpKTtcclxuLy8gZW5naW5lLmljb25zTGF5ZXIuYWRkUmVuZGVyVW5pdChuZXcgSW1hZ2VSZW5kZXJVbml0KGNvbnRleHQsIHRyYWZmaWNBZGFwdGVyLmltYWdlc1Byb3ZpZGVyKSk7XHJcbmVuZ2luZS5pY29uc0xheWVyLmFkZFJlbmRlclVuaXQobmV3IEljb25SZW5kZXJVbml0KGNvbnRleHQsIGNhbWVyYSwgdmVjdG9yQWRhcHRlci5pY29uc1Byb3ZpZGVyKSk7XHJcbmVuZ2luZS5sYWJlbHNMYXllci5hZGRSZW5kZXJVbml0KG5ldyBDdXJ2ZWRMYWJlbFJlbmRlclVuaXQoY29udGV4dCwgY2FtZXJhLCBlbmdpbmUudmlzYmlsaXR5VGV4dHVyZVByb3ZpZGVyLCB2ZWN0b3JBZGFwdGVyLmN1cnZlZExhYmVsc1Byb3ZpZGVyKSk7XHJcbmVuZ2luZS5sYWJlbHNMYXllci5hZGRSZW5kZXJVbml0KG5ldyBQb2ludExhYmVsUmVuZGVyVW5pdChjb250ZXh0LCBjYW1lcmEsIGVuZ2luZS52aXNiaWxpdHlUZXh0dXJlUHJvdmlkZXIsIHZlY3RvckFkYXB0ZXIucG9pbnRMYWJlbHNQcm92aWRlcikpO1xyXG5lbmdpbmUudmlzaWJpbGl0eU1hbmFnZXIucmVnaXN0ZXJDb2xsaWRpbmdQcmltaXRpdmVzKHZlY3RvckFkYXB0ZXIuY3VydmVkTGFiZWxzUHJvdmlkZXIsIG5ldyBDb2xvcklkQ3VydmVkTGFiZWxSZW5kZXJlcihjb250ZXh0LCBjYW1lcmEsIHZlY3RvckFkYXB0ZXIuY3VydmVkTGFiZWxzUHJvdmlkZXIpLCBuZXcgQ29sbGlkaW5nUHJpbWl0aXZlc1Jlc2V0UmVtb3ZlZFJlbmRlcmVyKGNvbnRleHQsIHZlY3RvckFkYXB0ZXIuY3VydmVkTGFiZWxzUHJvdmlkZXIpKTtcclxuZW5naW5lLnZpc2liaWxpdHlNYW5hZ2VyLnJlZ2lzdGVyQ29sbGlkaW5nUHJpbWl0aXZlcyh2ZWN0b3JBZGFwdGVyLnBvaW50TGFiZWxzUHJvdmlkZXIsIG5ldyBDb2xvcklkUG9pbnRMYWJlbFJlbmRlcmVyKGNvbnRleHQsIGNhbWVyYSwgdmVjdG9yQWRhcHRlci5wb2ludExhYmVsc1Byb3ZpZGVyKSwgbmV3IENvbGxpZGluZ1ByaW1pdGl2ZXNSZXNldFJlbW92ZWRSZW5kZXJlcihjb250ZXh0LCB2ZWN0b3JBZGFwdGVyLnBvaW50TGFiZWxzUHJvdmlkZXIpKTtcclxuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21vc2NvdycpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xyXG4gICAgY2FtZXJhLmNlbnRlci54ID0gMHgxQUJGRkZGRiAvIDB4N0ZGRkZGRkY7XHJcbiAgICBjYW1lcmEuY2VudGVyLnkgPSAweDJGQkZGRkZGIC8gMHg3RkZGRkZGRjtcclxuICAgIGNhbWVyYS56b29tID0gMTM7XHJcbn0pO1xyXG5kb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGx1cycpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xyXG4gICAgY2FtZXJhLnpvb20gKz0gMC4xO1xyXG59KTtcclxuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21pbnVzJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XHJcbiAgICBjYW1lcmEuem9vbSAtPSAwLjE7XHJcbn0pO1xyXG4vLyBzZXRUaW1lb3V0KCgpID0+IHtcclxuLy8gICAgIGNvbnNvbGUubG9nKCdTZXR0aW5nIG5ldyB0aWxlIHVybCB0ZW1wbGF0ZScpO1xyXG4vLyAgICAgdmVjdG9yQWRhcHRlci5zZXRUaWxlVXJsVGVtcGxhdGUoJ2h0dHBzOi8vdmVjLXJkcjAxZS50c3QubWFwcy55YW5kZXgucnUvdm1hcDIvdGlsZXM/bD12bWFwMiZsYW5nPXJ1X1JVJng9e3t4fX0meT17e3l9fSZ6PXt7en19JnptaW49e3t6bWlufX0mem1heD17e3ptYXh9fScpO1xyXG4vLyB9LCA0MDAwKTtcclxuIiwiaW1wb3J0IHsgQXR0cmlidXRlTWFwcGluZyB9IGZyb20gJy4vYXR0cmliX21hcHBpbmcnO1xyXG5pbXBvcnQgQnVmZmVyIGZyb20gJy4vZ2wvYnVmZmVyJztcclxuaW1wb3J0IEZyYW1lYnVmZmVyIGZyb20gJy4vZ2wvZnJhbWVidWZmZXInO1xyXG5pbXBvcnQgUHJvZ3JhbSBmcm9tICcuL2dsL3Byb2dyYW0nO1xyXG5pbXBvcnQgUmVuZGVyYnVmZmVyIGZyb20gJy4vZ2wvcmVuZGVyYnVmZmVyJztcclxuaW1wb3J0IFJlbmRlckNvbnRleHRDYXBhYmlsaXRpZXNNYW5hZ2VyIGZyb20gJy4vY2FwYWJpbGl0aWVzJztcclxuaW1wb3J0IFJlbmRlclN0YXRlIGZyb20gJy4vc3RhdGUnO1xyXG5pbXBvcnQgVGV4dHVyZSwgeyBERUZBVUxUX1RFWFRVUkVfUEFSQU1TIH0gZnJvbSAnLi9nbC90ZXh0dXJlJztcclxuaW1wb3J0IFZlcnRleEFycmF5T2JqZWN0IGZyb20gJy4vZ2wvdmFvJztcclxuaW1wb3J0ICogYXMgY29sb3IgZnJvbSAnLi4vdXRpbC9jb2xvcic7XHJcbmltcG9ydCB7IFZvaWRFdmVudEVtaXR0ZXIgfSBmcm9tICcuLi91dGlsL2V2ZW50X2VtaXR0ZXInO1xyXG5jb25zdCBRVUFEX1ZFUlRFWF9EQVRBID0gbmV3IEZsb2F0MzJBcnJheShbXHJcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZVxyXG4gICAgLy8geCAgIHkgIHUgIHZcclxuICAgIC0xLCAtMSwgMCwgMCxcclxuICAgIDEsIDEsIDEsIDEsXHJcbiAgICAtMSwgMSwgMCwgMSxcclxuICAgIC0xLCAtMSwgMCwgMCxcclxuICAgIDEsIC0xLCAxLCAwLFxyXG4gICAgMSwgMSwgMSwgMVxyXG4gICAgLy8gdHNsaW50OmVuYWJsZVxyXG5dKTtcclxuY29uc3QgUVVBRF9BVFRSSUJfTUFQUElORyA9IG5ldyBBdHRyaWJ1dGVNYXBwaW5nKFtcclxuICAgIFtcclxuICAgICAgICAwIC8qIFBPU0lUSU9OICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMixcclxuICAgICAgICAgICAgdHlwZTogNTEyNiAvKiBGTE9BVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDQgLyogVVYgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTI2IC8qIEZMT0FUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgIF1cclxuXSk7XHJcbi8qKlxyXG4gKiBEZWZhdWx0IHJlbmRlciB0YXJnZXQgb2YgYSBXZWJHTCBjb250ZXh0LCB3aGljaCBpcyBjYW52YXMgZWxlbWVudCBvZiB0aGVcclxuICogY29udGV4dC5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBEZWZhdWx0UmVuZGVyVGFyZ2V0IHtcclxuICAgIGNvbnN0cnVjdG9yKGdsKSB7XHJcbiAgICAgICAgdGhpcy5pc0NsZWFyID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fZ2wgPSBnbDtcclxuICAgIH1cclxuICAgIGJpbmQoKSB7XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcclxuICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xyXG4gICAgfVxyXG4gICAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgY29uc3QgY2FudmFzID0gdGhpcy5fZ2wuY2FudmFzO1xyXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICB9XHJcbiAgICBnZXRXaWR0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2wuZHJhd2luZ0J1ZmZlcldpZHRoO1xyXG4gICAgfVxyXG4gICAgZ2V0SGVpZ2h0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9nbC5kcmF3aW5nQnVmZmVySGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICAvLyBXZSBjYW4ndCBkZXN0cm95IGRlZmF1bHQgcmVuZGVyIHRhcmdldCwgc28gZG8gbm90aGluZy5cclxuICAgICAgICAvLyBUT0RPKGRtaWtpcykgVGhyb3cgYW4gZXhjZXB0aW9uP1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBXcmFwcGVyIGFyb3VuZCBXZWJHTCBjb250ZXh0LiBTZXJ2ZXMgdG8gbG9jYWxpemUgYWxsIEdMIGNhbGxzIHRvIG1pbmltdW0gc2V0XHJcbiAqIG9mIG9iamVjdHMuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW5kZXJDb250ZXh0IHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyB3cmFwcGVyIGZvciBhIGdpdmVuIFdlYkdMIGNvbnRleHQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGdsIFRoZSBjb250ZXh0IHRvIGJlIHdyYXBwZWQuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGdsKSB7XHJcbiAgICAgICAgdGhpcy5fZ2wgPSBnbDtcclxuICAgICAgICB0aGlzLm9uTG9zcyA9IG5ldyBWb2lkRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dExvc3RMaXN0ZW5lciA9IChlKSA9PiB7XHJcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgdGhpcy5vbkxvc3MuZmlyZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgZ2wuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dGxvc3QnLCB0aGlzLl9jb250ZXh0TG9zdExpc3RlbmVyKTtcclxuICAgICAgICB0aGlzLl9jYXBhYmlsaXRpZXMgPSBuZXcgUmVuZGVyQ29udGV4dENhcGFiaWxpdGllc01hbmFnZXIoZ2wpO1xyXG4gICAgICAgIGNvbnN0IHZhb0V4dCA9IGdsLmdldEV4dGVuc2lvbignT0VTX3ZlcnRleF9hcnJheV9vYmplY3QnKTtcclxuICAgICAgICBpZiAoIXZhb0V4dCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0IGlzIHJlcXVpcmVkLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl92YW9FeHQgPSB2YW9FeHQ7XHJcbiAgICAgICAgaWYgKCFnbC5nZXRFeHRlbnNpb24oJ09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcycpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzIGlzIHJlcXVpcmVkLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBkZWZhdWx0UmVuZGVyVGFyZ2V0ID0gdGhpcy5fYm91bmRSZW5kZXJUYXJnZXQgPVxyXG4gICAgICAgICAgICB0aGlzLl9kZWZhdWx0UmVuZGVyVGFyZ2V0ID1cclxuICAgICAgICAgICAgICAgIG5ldyBEZWZhdWx0UmVuZGVyVGFyZ2V0KGdsKTtcclxuICAgICAgICBjb25zdCBib3VuZFN0YXRlID0gdGhpcy5fYm91bmRSZW5kZXJTdGF0ZSA9IG5ldyBSZW5kZXJTdGF0ZSgpO1xyXG4gICAgICAgIHRoaXMuX3VucGFja1ByZW11bHRpcGx5QWxwaGEgPSBmYWxzZTtcclxuICAgICAgICAvLyBEZWZhdWx0IHZpZXdwb3J0IGFuZCBzY2lzc29yIHJlY3RhbmdsZSBzaXplcyBhcmUgZXF1YWwgdG8gdGhlIHNpemUgb2ZcclxuICAgICAgICAvLyB0aGUgY2FudmFzIG9mIHRoZSBXZWJHTCBjb250ZXh0LiBCdXQgd2UgaGF2ZSBubyB3YXkgb2Yga25vd2luZyB0aGVtIGluXHJcbiAgICAgICAgLy8gUmVuZGVyU3RhdGUncyBjb25zdHJ1Y3Rvci4gU28gd2UncmUgZml4aW5nIHRoZW0gaGVyZS5cclxuICAgICAgICBib3VuZFN0YXRlLnNjaXNzb3JXaWR0aCA9IGJvdW5kU3RhdGUudmlld3BvcnRXaWR0aCA9XHJcbiAgICAgICAgICAgIGRlZmF1bHRSZW5kZXJUYXJnZXQuZ2V0V2lkdGgoKTtcclxuICAgICAgICBib3VuZFN0YXRlLnNjaXNzb3JIZWlnaHQgPSBib3VuZFN0YXRlLnZpZXdwb3J0SGVpZ2h0ID1cclxuICAgICAgICAgICAgZGVmYXVsdFJlbmRlclRhcmdldC5nZXRIZWlnaHQoKTtcclxuICAgICAgICBjb25zdCBxdWFkQnVmZmVyID0gdGhpcy5fcXVhZFZlcnRleEJ1ZmZlciA9XHJcbiAgICAgICAgICAgIG5ldyBCdWZmZXIoZ2wsIGdsLkFSUkFZX0JVRkZFUiwgZ2wuU1RBVElDX0RSQVcpO1xyXG4gICAgICAgIHF1YWRCdWZmZXIuYmluZCgpO1xyXG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBRVUFEX1ZFUlRFWF9EQVRBLCBnbC5TVEFUSUNfRFJBVyk7XHJcbiAgICAgICAgdGhpcy5fcXVhZFZhbyA9IHRoaXMuY3JlYXRlVmFvKFFVQURfQVRUUklCX01BUFBJTkcsIHF1YWRCdWZmZXIsIG51bGwpO1xyXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBudWxsKTtcclxuICAgICAgICB0aGlzLl9ib3VuZFByb2dyYW0gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2JvdW5kVmFvID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9ib3VuZFRleHR1cmVzID0gbmV3IEFycmF5KHRoaXMuX2NhcGFiaWxpdGllcy5nZXRNYXhDb21iaW5lZFRleHR1cmVJbWFnZVVuaXRzKCkpO1xyXG4gICAgICAgIHRoaXMuX2JvdW5kVGV4dHVyZXMuZmlsbChudWxsKTtcclxuICAgICAgICB0aGlzLl9ib3VuZFRleHR1cmVVbml0ID0gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBvYmplY3QgdG8gcmVxdWVzdCBjYXBhYmlsaXRpZXMgb2YgdGhlIGNvbnRleHQgc3VjaCBhcyBtYXhpbXVtXHJcbiAgICAgKiB0ZXh0dXJlIHNpemUgb3IgbWF4aW11bSBudW1iZXIgb2YgdW5pZm9ybSB2ZWN0b3JzIGFsbG93ZWQgaW4gc2hhZGVycy5cclxuICAgICAqL1xyXG4gICAgZ2V0Q2FwYWJpbGl0aWVzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jYXBhYmlsaXRpZXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgZnJhbWVidWZmZXIgd2l0aCBnaXZlbiBhdHRhY2htZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZGVzY3JpcHRvciBPYmplY3QgY29udGFpbmluZyBmcmFtZWJ1ZmZlciBhdHRhY2htZW50cy5cclxuICAgICAqIEByZXR1cm5zIENyZWF0ZWQgZnJhbWVidWZmZXIgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBjcmVhdGVGcmFtZWJ1ZmZlcih7IGNvbG9yLCBkZXB0aCwgc3RlbmNpbCwgZGVwdGhTdGVuY2lsIH0pIHtcclxuICAgICAgICAvLyBUT0RPIFVuY29tbWVudCBhbmQgcHV0IHVuZGVyIGRlYnVnIGZsYWcgKHdoZW4gaW1wbGVtZW50ZWQpXHJcbiAgICAgICAgLy8gaWYgKGRlcHRoU3RlbmNpbCAmJiAoZGVwdGggfHwgc3RlbmNpbCkpIHtcclxuICAgICAgICAvLyAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgIC8vICAgICAgICAgJ0ZyYW1lYnVmZmVyIGNhblxcJ3QgaGF2ZSBERVBUSF9TVEVOQ0lMIGFuZCBERVBUSCBvciBTVEVOQ0lMICcgK1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICdhdHRhY2htZW50IHNpbXVsdGFuZW91c2x5LidcclxuICAgICAgICAvLyAgICAgKTtcclxuICAgICAgICAvLyB9XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcclxuICAgICAgICBsZXQgd2lkdGggPSAwO1xyXG4gICAgICAgIGxldCBoZWlnaHQgPSAwO1xyXG4gICAgICAgIGlmIChjb2xvcikge1xyXG4gICAgICAgICAgICB3aWR0aCA9IGNvbG9yLmdldFdpZHRoKCk7XHJcbiAgICAgICAgICAgIGhlaWdodCA9IGNvbG9yLmdldEhlaWdodCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkZXB0aCkge1xyXG4gICAgICAgICAgICB3aWR0aCA9IGRlcHRoLmdldFdpZHRoKCk7XHJcbiAgICAgICAgICAgIGhlaWdodCA9IGRlcHRoLmdldEhlaWdodCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzdGVuY2lsKSB7XHJcbiAgICAgICAgICAgIHdpZHRoID0gc3RlbmNpbC5nZXRXaWR0aCgpO1xyXG4gICAgICAgICAgICBoZWlnaHQgPSBzdGVuY2lsLmdldEhlaWdodCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkZXB0aFN0ZW5jaWwpIHtcclxuICAgICAgICAgICAgd2lkdGggPSBkZXB0aFN0ZW5jaWwuZ2V0V2lkdGgoKTtcclxuICAgICAgICAgICAgaGVpZ2h0ID0gZGVwdGhTdGVuY2lsLmdldEhlaWdodCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBmcmFtZWJ1ZmZlciA9IG5ldyBGcmFtZWJ1ZmZlcihnbCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5iaW5kUmVuZGVyVGFyZ2V0KGZyYW1lYnVmZmVyKTtcclxuICAgICAgICBpZiAoY29sb3IpIHtcclxuICAgICAgICAgICAgY29sb3IuYXR0YWNoVG9GcmFtZWJ1ZmZlcihnbC5DT0xPUl9BVFRBQ0hNRU5UMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkZXB0aCkge1xyXG4gICAgICAgICAgICBkZXB0aC5hdHRhY2hUb0ZyYW1lYnVmZmVyKGdsLkRFUFRIX0FUVEFDSE1FTlQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RlbmNpbCkge1xyXG4gICAgICAgICAgICBzdGVuY2lsLmF0dGFjaFRvRnJhbWVidWZmZXIoZ2wuU1RFTkNJTF9BVFRBQ0hNRU5UKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRlcHRoU3RlbmNpbCkge1xyXG4gICAgICAgICAgICBkZXB0aFN0ZW5jaWwuYXR0YWNoVG9GcmFtZWJ1ZmZlcihnbC5ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUT0RPIFVuY29tbWVudCBhbmQgcHV0IHVuZGVyIGRlYnVnIGZsYWcgKHdoZW4gaW1wbGVtZW50ZWQpXHJcbiAgICAgICAgLy8gc3dpdGNoIChnbC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKGdsLkZSQU1FQlVGRkVSKSkge1xyXG4gICAgICAgIC8vICAgICBjYXNlIGdsLkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfQVRUQUNITUVOVDpcclxuICAgICAgICAvLyAgICAgICAgIHRocm93IG5ldyBFcnJvcignRnJhbWVidWZmZXIgYXR0YWNobWVudHMgYXJlIG5vdCByZW5kZXJhYmxlJyk7XHJcbiAgICAgICAgLy8gICAgIGNhc2UgZ2wuRlJBTUVCVUZGRVJfSU5DT01QTEVURV9ESU1FTlNJT05TOlxyXG4gICAgICAgIC8vICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGcmFtZWJ1ZmZlciBhdHRhY2htZW50cyBhcmUgbm90IHNhbWUgc2l6ZScpO1xyXG4gICAgICAgIC8vICAgICBjYXNlIGdsLkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfTUlTU0lOR19BVFRBQ0hNRU5UOlxyXG4gICAgICAgIC8vICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGcmFtZWJ1ZmZlciBoYXMgbm8gYXR0YWNobWVudHMnKTtcclxuICAgICAgICAvLyAgICAgY2FzZSBnbC5GUkFNRUJVRkZFUl9VTlNVUFBPUlRFRDpcclxuICAgICAgICAvLyAgICAgICAgIHRocm93IG5ldyBFcnJvcignRnJhbWVidWZmZXIgaGFzIHVuc3VwcG9ydGVkIGF0dGFjaG1lbnQnKTtcclxuICAgICAgICAvLyB9XHJcbiAgICAgICAgcmV0dXJuIGZyYW1lYnVmZmVyO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBbGxvY2F0ZXMgYSBuZXcgcmVuZGVyYnVmZmVyIHdpdGggZ2l2ZW4gc2l6ZSBhbmQgZm9ybWF0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB3aWR0aCBXaWR0aCBvZiB0aGUgcmVuZGVyYnVmZmVyLlxyXG4gICAgICogQHBhcmFtIGhlaWdodCBIZWlnaHQgb2YgdGhlIHJlbmRlcmJ1ZmZlci5cclxuICAgICAqIEBwYXJhbSBmb3JtYXQgRm9ybWF0IG9mIHRoZSByZW5kZXJidWZmZXIuXHJcbiAgICAgKiBAcmV0dXJuIFRoZSBhbGxvY2F0ZWQgcmVuZGVyYnVmZmVyLlxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgY3JlYXRlUmVuZGVyYnVmZmVyKHdpZHRoLCBoZWlnaHQsIGZvcm1hdCkge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XHJcbiAgICAgICAgY29uc3QgcmVuZGVyYnVmZmVyID0gbmV3IFJlbmRlcmJ1ZmZlcihnbCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgcmVuZGVyYnVmZmVyLmJpbmQoKTtcclxuICAgICAgICBnbC5yZW5kZXJidWZmZXJTdG9yYWdlKGdsLlJFTkRFUkJVRkZFUiwgZm9ybWF0LCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICByZXR1cm4gcmVuZGVyYnVmZmVyO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBbGxvY2F0ZXMgYSBuZXcgdGV4dHVyZSB3aXRoIGdpdmVuIHNpemUsIGZvcm1hdCwgdHlwZSBhbmQgcGFyYW1ldGVycyBhbmRcclxuICAgICAqIGZpbGxzIGl0IHdpdGggemVyb2VzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB3aWR0aCBXaWR0aCBvZiB0aGUgdGV4dHVyZS5cclxuICAgICAqIEBwYXJhbSBoZWlnaHQgSGVpZ2h0IG9mIHRoZSB0ZXh0dXJlLlxyXG4gICAgICogQHBhcmFtIGZvcm1hdCBQaXhlbCBmb3JtYXQgb2YgdGhlIHRleHR1cmUuXHJcbiAgICAgKiBAcGFyYW0gdHlwZSBQaXhlbCB0eXBlIG9mIHRoZSB0ZXh0dXJlLlxyXG4gICAgICogQHBhcmFtIHBhcmFtcyBQYXJhbWV0ZXJzIG9mIHRoZSB0ZXh0dXJlLlxyXG4gICAgICogQHJldHVybnMgTmV3bHkgYWxsb2NhdGVkIHRleHR1cmUuXHJcbiAgICAgKi9cclxuICAgIGNyZWF0ZUVtcHR5MkRUZXh0dXJlKHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgdHlwZSwgcGFyYW1zID0gREVGQVVMVF9URVhUVVJFX1BBUkFNUykge1xyXG4gICAgICAgIGNvbnN0IHRleHR1cmUgPSBuZXcgVGV4dHVyZSh0aGlzLl9nbCwgd2lkdGgsIGhlaWdodCwgZm9ybWF0LCB0eXBlLCBwYXJhbXMpO1xyXG4gICAgICAgIHJldHVybiB0ZXh0dXJlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHNoYWRlciBwcm9ncmFtLiBVc2VzIGNhY2hlLCBpLmUuIGlmIGEgcHJvZ3JhbSB3aXRoIHNhbWVcclxuICAgICAqIHNvdXJjZSBzdHJpbmcgYW5kIG9wdGlvbnMgaXMgYWxyZWFkeSBjcmVhdGVkLCByZXR1cm5zIGl0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB2ZXJ0ZXhTaGFkZXJTb3VyY2UgU291cmNlIGNvZGUgb2YgdmVydGV4IHNoYWRlciBvZiB0aGUgcHJvZ3JhbS5cclxuICAgICAqIEBwYXJhbSBmcmFnbWVudFNoYWRlclNvdXJjZSBTb3VyY2UgY29kZSBvZiBmcmFnbWVudCBzaGFkZXIgb2YgdGhlIHByb2dyYW0uXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zLlxyXG4gICAgICogQHJldHVybnMgTmV3bHkgY3JlYXRlZCBwcm9ncmFtIG9yIG9uZSBmcm9tIHRoZSBjYWNoZS5cclxuICAgICAqL1xyXG4gICAgY3JlYXRlUHJvZ3JhbSh2ZXJ0ZXhTaGFkZXJTb3VyY2UsIGZyYWdtZW50U2hhZGVyU291cmNlLCBvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9ncmFtKHRoaXMuX2dsLCB2ZXJ0ZXhTaGFkZXJTb3VyY2UsIGZyYWdtZW50U2hhZGVyU291cmNlLCBvcHRpb25zKTtcclxuICAgIH1cclxuICAgIGNyZWF0ZVZlcnRleEJ1ZmZlcihzaXplLCB1c2FnZSA9IDM1MDQ0IC8qIFNUQVRJQ19EUkFXICovKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUJ1ZmZlcih0aGlzLl9nbC5BUlJBWV9CVUZGRVIsIHNpemUsIHVzYWdlKTtcclxuICAgIH1cclxuICAgIGNyZWF0ZUluZGV4QnVmZmVyKHNpemUsIHVzYWdlID0gMzUwNDQgLyogU1RBVElDX0RSQVcgKi8pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY3JlYXRlQnVmZmVyKHRoaXMuX2dsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBzaXplLCB1c2FnZSk7XHJcbiAgICB9XHJcbiAgICAvLyBUT0RPOiBjaGVjayBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzI0MTk1IHRvIHVwZGF0ZSBuYXJyb3dlZCBkYXRhIHR5cGUgYWNjb3JkaW5nXHJcbiAgICB1cGxvYWREYXRhVG9CdWZmZXIoYnVmZmVyLCBkYXRhLCBvZmZzZXQgPSAwKSB7XHJcbiAgICAgICAgYnVmZmVyLmJpbmQoKTtcclxuICAgICAgICB0aGlzLl9nbC5idWZmZXJTdWJEYXRhKGJ1ZmZlci5nZXRUYXJnZXQoKSwgb2Zmc2V0LCBkYXRhKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyB2ZXJ0ZXggYXJyYXkgb2JqZWN0IGluIHRoZSBjb250ZXh0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhdHRyaWJ1dGVNYXBwaW5nIE1hcHBpbmcgb2YgdmVydGV4IGF0dHJiaXV0ZXMgZm9yIHRoZSBWQU8uXHJcbiAgICAgKiBAcGFyYW0gdmVydGV4QnVmZmVyIFZlcnRleCBidWZmZXIgdG8gYmUgYm91bmQgdG8gdGhlIFZBTy5cclxuICAgICAqIEBwYXJhbSBpbmRleEJ1ZmZlciBJbmRleCBidWZmZXIgdG8gYmUgYm91bmQgdG8gdGhlIFZBTy5cclxuICAgICAqIEByZXR1cm5zIFRoZSBuZXcgVkFPLlxyXG4gICAgICovXHJcbiAgICBjcmVhdGVWYW8oYXR0cmlidXRlTWFwcGluZywgdmVydGV4QnVmZmVyLCBpbmRleEJ1ZmZlcikge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XHJcbiAgICAgICAgY29uc3QgdmFvID0gbmV3IFZlcnRleEFycmF5T2JqZWN0KGdsLCB0aGlzLl92YW9FeHQsIGF0dHJpYnV0ZU1hcHBpbmcpO1xyXG4gICAgICAgIHZhby5iaW5kKCk7XHJcbiAgICAgICAgaWYgKGluZGV4QnVmZmVyKSB7XHJcbiAgICAgICAgICAgIGluZGV4QnVmZmVyLmJpbmQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2ZXJ0ZXhCdWZmZXIuYmluZCgpO1xyXG4gICAgICAgIGNvbnN0IHZlcnRleEJ5dGVTaXplID0gYXR0cmlidXRlTWFwcGluZy52ZXJ0ZXhCeXRlU2l6ZTtcclxuICAgICAgICBmb3IgKGNvbnN0IFtpZHgsIHBvaW50ZXJdIG9mIGF0dHJpYnV0ZU1hcHBpbmcpIHtcclxuICAgICAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoaWR4KTtcclxuICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihpZHgsIHBvaW50ZXIuc2l6ZSwgcG9pbnRlci50eXBlLCBwb2ludGVyLm5vcm1hbGl6ZWQsIHZlcnRleEJ5dGVTaXplLCBwb2ludGVyLm9mZnNldCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3Zhb0V4dC5iaW5kVmVydGV4QXJyYXlPRVMobnVsbCk7XHJcbiAgICAgICAgcmV0dXJuIHZhbztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBuZXcgY29udGVudCBvZiB0ZXh0dXJlLCBwcm92aWRlZCBkYXRhIG11c3QgYmUgb2YgbGVuZ3RoIGVxdWFsIHRvIFwid2lkdGggKiBoZWlnaHRcIiBhbmQgaXRzIHR5cGVcclxuICAgICAqIG11c3QgY29ycmVzcG9uZCB0byB0ZXh0dXJlJ3MgdHlwZSB7QHNlZSBQaXhlbFR5cGV9LlxyXG4gICAgICovXHJcbiAgICBzZXRUZXh0dXJlRGF0YSh0ZXh0dXJlLCBkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcclxuICAgICAgICBjb25zdCB3aWR0aCA9IHRleHR1cmUuZ2V0V2lkdGgoKTtcclxuICAgICAgICBjb25zdCBoZWlnaHQgPSB0ZXh0dXJlLmdldEhlaWdodCgpO1xyXG4gICAgICAgIGNvbnN0IGZvcm1hdCA9IHRleHR1cmUuZ2V0Rm9ybWF0KCk7XHJcbiAgICAgICAgY29uc3QgdHlwZSA9IHRleHR1cmUuZ2V0VHlwZSgpO1xyXG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHRleHR1cmUuZ2V0UGFyYW1zKCk7XHJcbiAgICAgICAgdGhpcy5fc2V0VGV4dHVyZURhdGFVbnBhY2tQYXJhbXMocGFyYW1zKTtcclxuICAgICAgICB0aGlzLmJpbmRUZXh0dXJlKHRleHR1cmUpO1xyXG4gICAgICAgIGdsLnRleFN1YkltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgMCwgMCwgd2lkdGgsIGhlaWdodCwgZm9ybWF0LCB0eXBlLCBkYXRhKTtcclxuICAgICAgICB0aGlzLl9vblRleHR1cmVEYXRhVXBkYXRlZCh0ZXh0dXJlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBuZXcgdGV4dHVyZSBjb250ZW50IGZyb20gY2FudmFzIGVsZW1lbnQuXHJcbiAgICAgKi9cclxuICAgIHNldFRleHR1cmVEYXRhRnJvbURvbUVsZW1lbnQodGV4dHVyZSwgZWxlbWVudCkge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XHJcbiAgICAgICAgY29uc3QgZm9ybWF0ID0gdGV4dHVyZS5nZXRGb3JtYXQoKTtcclxuICAgICAgICBjb25zdCB0eXBlID0gdGV4dHVyZS5nZXRUeXBlKCk7XHJcbiAgICAgICAgY29uc3QgcGFyYW1zID0gdGV4dHVyZS5nZXRQYXJhbXMoKTtcclxuICAgICAgICB0aGlzLl9zZXRUZXh0dXJlRGF0YVVucGFja1BhcmFtcyhwYXJhbXMpO1xyXG4gICAgICAgIHRoaXMuYmluZFRleHR1cmUodGV4dHVyZSk7XHJcbiAgICAgICAgZ2wudGV4U3ViSW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCAwLCAwLCBmb3JtYXQsIHR5cGUsIGVsZW1lbnQpO1xyXG4gICAgICAgIHRoaXMuX29uVGV4dHVyZURhdGFVcGRhdGVkKHRleHR1cmUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGRlZmF1bHQgcmVuZGVyIHRhcmdldCBhc3NvY2lhdGVkIHdpdGggY2FudmFzIG9uIHdoaWNoIHRoZSBXZWJHTFxyXG4gICAgICogY29udGV4dCBvcGVyYXRlcy5cclxuICAgICAqL1xyXG4gICAgZ2V0RGVmYXVsdFJlbmRlclRhcmdldCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmYXVsdFJlbmRlclRhcmdldDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXJzIGN1cnJlbnRseSBib3VuZCByZW5kZXIgdGFyZ2V0IGFjY29yZGluZyB0byBhIG1hc2suXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG1hc2sgQml0d2lzZSBPUiBvZiBtYXJrcywgaS5lLlxyXG4gICAgICogICAgICBgQ2xlYXJNYXNrLkNPTE9SX0JVRkZFUl9CSVQgfCBDbGVhck1hc2suREVQVEhfQlVGRkVSX0JJVGAuXHJcbiAgICAgKi9cclxuICAgIGNsZWFyQ3VycmVudFRhcmdldChtYXNrKSB7XHJcbiAgICAgICAgaWYgKG1hc2spIHtcclxuICAgICAgICAgICAgdGhpcy5fZ2wuY2xlYXIobWFzayk7XHJcbiAgICAgICAgICAgIHRoaXMuX2JvdW5kUmVuZGVyVGFyZ2V0LmlzQ2xlYXIgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQmluZHMgYSByZW5kZXIgdGFyZ2V0IHRvIHRoZSBXZWJHTCBjb250ZXh0IGlmIGl0J3Mgbm90IGFscmVhZHkgYm91bmQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRhcmdldCBUaGUgcmVuZGVyIHRhcmdldCB0byBiZSBib3VuZC5cclxuICAgICAqL1xyXG4gICAgYmluZFJlbmRlclRhcmdldCh0YXJnZXQpIHtcclxuICAgICAgICBpZiAodGhpcy5fYm91bmRSZW5kZXJUYXJnZXQgIT09IHRhcmdldCkge1xyXG4gICAgICAgICAgICB0YXJnZXQuYmluZCgpO1xyXG4gICAgICAgICAgICB0aGlzLl9ib3VuZFJlbmRlclRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVGFyZ2V0IHNpemUgY291bGQgY2hhbmdlIGV2ZW4gaWYgdGFyZ2V0IGlzIGFscmVhZHkgYm91bmQuXHJcbiAgICAgICAgLy8gVkVDVE9SLTE5MFxyXG4gICAgICAgIHRoaXMuX3NldFZpZXdwb3J0U3RhdGUobmV3IFJlbmRlclN0YXRlKHtcclxuICAgICAgICAgICAgdmlld3BvcnRXaWR0aDogdGFyZ2V0LmdldFdpZHRoKCksXHJcbiAgICAgICAgICAgIHZpZXdwb3J0SGVpZ2h0OiB0YXJnZXQuZ2V0SGVpZ2h0KClcclxuICAgICAgICB9KSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEJpbmRzIGEgcmVuZGVyIHN0YXRlIHRvIHRoZSBXZWJHTCBjb250ZXh0IHdpdGggbWluaW11bSBhbW91bnQgb2YgYWN0dWFsXHJcbiAgICAgKiBzdGF0ZSBzd2l0Y2hpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHN0YXRlIFRoZSBzdGF0ZSB0byBiZSBib3VuZC5cclxuICAgICAqL1xyXG4gICAgYmluZFJlbmRlclN0YXRlKHN0YXRlKSB7XHJcbiAgICAgICAgdGhpcy5fc2V0Q29sb3JCdWZmZXJTdGF0ZShzdGF0ZSk7XHJcbiAgICAgICAgdGhpcy5fc2V0QmxlbmRTdGF0ZShzdGF0ZSk7XHJcbiAgICAgICAgdGhpcy5fc2V0Q3VsbEZhY2VTdGF0ZShzdGF0ZSk7XHJcbiAgICAgICAgdGhpcy5fc2V0RnJvbnRGYWNlU3RhdGUoc3RhdGUpO1xyXG4gICAgICAgIHRoaXMuX3NldERlcHRoVGVzdFN0YXRlKHN0YXRlKTtcclxuICAgICAgICB0aGlzLl9zZXREaXRoZXJTdGF0ZShzdGF0ZSk7XHJcbiAgICAgICAgdGhpcy5fc2V0RHJhd0J1ZmZlcnNTdGF0ZShzdGF0ZSk7XHJcbiAgICAgICAgdGhpcy5fc2V0UG9seWdvbk9mZnNldFN0YXRlKHN0YXRlKTtcclxuICAgICAgICB0aGlzLl9zZXRBbHBoYVRvQ292ZXJhZ2VTdGF0ZShzdGF0ZSk7XHJcbiAgICAgICAgdGhpcy5fc2V0U2FtcGxlQ292ZXJhZ2VTdGF0ZShzdGF0ZSk7XHJcbiAgICAgICAgdGhpcy5fc2V0U3RlbmNpbFRlc3RTdGF0ZShzdGF0ZSk7XHJcbiAgICAgICAgdGhpcy5fc2V0U2Npc3NvclRlc3RTdGF0ZShzdGF0ZSk7XHJcbiAgICAgICAgdGhpcy5fc2V0Vmlld3BvcnRTdGF0ZShzdGF0ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEJpbmRzIGEgcHJvZ3JhbSB0byB0aGUgV2ViR0wgY29udGV4dCBpZiBpdCdzIG5vdCBhbHJlYWR5IGJvdW5kLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwcm9ncmFtIFRoZSBwcm9ncmFtIHRvIGJlIGJvdW5kLlxyXG4gICAgICovXHJcbiAgICBiaW5kUHJvZ3JhbShwcm9ncmFtKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2JvdW5kUHJvZ3JhbSAhPT0gcHJvZ3JhbSkge1xyXG4gICAgICAgICAgICBwcm9ncmFtLmJpbmQoKTtcclxuICAgICAgICAgICAgdGhpcy5fYm91bmRQcm9ncmFtID0gcHJvZ3JhbTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEJpbmRzIGEgdmVydGV4IGFycmF5IG9iamVjdCB0byB0aGUgY29udGV4dCBpZiBpdCdzIG5vdCBhbHJlYWR5IGJvdW5kLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB2YW8gVGhlIHZlcnRleCBhcnJheSBvYmplY3QgdG8gYmluZC4gUGFzc2luZyBgbnVsbGAgd2lsbCB1bmJpbmRcclxuICAgICAqICAgICAgYW55IGN1cnJlbnRseSBib3VuZCBWQU8uXHJcbiAgICAgKi9cclxuICAgIGJpbmRWYW8odmFvKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2JvdW5kVmFvICE9PSB2YW8pIHtcclxuICAgICAgICAgICAgaWYgKHZhbykge1xyXG4gICAgICAgICAgICAgICAgdmFvLmJpbmQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Zhb0V4dC5iaW5kVmVydGV4QXJyYXlPRVMobnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fYm91bmRWYW8gPSB2YW87XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYmluZFF1YWRWYW8oKSB7XHJcbiAgICAgICAgdGhpcy5iaW5kVmFvKHRoaXMuX3F1YWRWYW8pO1xyXG4gICAgfVxyXG4gICAgYmluZFRleHR1cmVVbml0KHVuaXQpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xyXG4gICAgICAgIGlmICh0aGlzLl9ib3VuZFRleHR1cmVVbml0ICE9PSB1bml0KSB7XHJcbiAgICAgICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB1bml0KTtcclxuICAgICAgICAgICAgdGhpcy5fYm91bmRUZXh0dXJlVW5pdCA9IHVuaXQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYmluZFRleHR1cmUodGV4dHVyZSkge1xyXG4gICAgICAgIGNvbnN0IGJvdW5kVW5pdCA9IHRoaXMuX2JvdW5kVGV4dHVyZVVuaXQ7XHJcbiAgICAgICAgaWYgKHRoaXMuX2JvdW5kVGV4dHVyZXNbYm91bmRVbml0XSAhPT0gdGV4dHVyZSkge1xyXG4gICAgICAgICAgICB0ZXh0dXJlLmJpbmQoKTtcclxuICAgICAgICAgICAgdGhpcy5fYm91bmRUZXh0dXJlc1tib3VuZFVuaXRdID0gdGV4dHVyZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERyYXdzIGEgcXVhZCB0byBjdXJyZW50bHkgYm91bmQgcmVuZGVyIHRhcmdldCB3aXRoIGN1cnJlbnRseSBib3VuZCByZW5kZXJcclxuICAgICAqIHN0YXRlLCBwcm9ncmFtIGFuZCB1bmlmb3JtIHN0YXRlLlxyXG4gICAgICovXHJcbiAgICBkcmF3UXVhZCgpIHtcclxuICAgICAgICB0aGlzLmRyYXdNZXNoKDAsIDYsIDQgLyogVFJJQU5HTEVTICovKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRHJhd3MgYSBtZXNoIGZyb20gY3VycmVudGx5IGJvdW5kIHRvIEFSUkFZX0JVRkZFUiBidWZmZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9mZnNldCBJbmRleCBvZiB0aGUgdmVydGV4IHRvIHN0YXJ0IGRyYXdpbmcgZnJvbS5cclxuICAgICAqIEBwYXJhbSBjb3VudCBOdW1iZXIgb2YgdmVydGljZXMgdG8gcHJvY2Vzcy5cclxuICAgICAqIEBwYXJhbSBwcmltaXRpdmVUeXBlXHJcbiAgICAgKi9cclxuICAgIGRyYXdNZXNoKG9mZnNldCwgY291bnQsIHByaW1pdGl2ZVR5cGUgPSA0IC8qIFRSSUFOR0xFUyAqLykge1xyXG4gICAgICAgIHRoaXMuX2dsLmRyYXdBcnJheXMocHJpbWl0aXZlVHlwZSwgb2Zmc2V0LCBjb3VudCk7XHJcbiAgICAgICAgdGhpcy5fYm91bmRSZW5kZXJUYXJnZXQuaXNDbGVhciA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3cyBhIG1lc2ggdG8gY3VycmVudGx5IGJvdW5kIHJlbmRlciB0YXJnZXQgd2l0aCBjdXJyZW50bHkgYm91bmQgcmVuZGVyXHJcbiAgICAgKiBzdGF0ZSwgcHJvZ3JhbSBhbmQgdW5pZm9ybSBzdGF0ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IE9mZnNldCBvZiBpbmRpY2VzIG9mIHRoZSBtZXNoIGluIGN1cnJlbnRseSBib3VuZCBtZW1vcnkgcGFnZS5cclxuICAgICAqIEBwYXJhbSBpbmRleENvdW50IE51bWJlciBvZiBpbmRpY2VzIGluIHRoZSBtZXNoLlxyXG4gICAgICovXHJcbiAgICBkcmF3SW5kZXhlZE1lc2gob2Zmc2V0LCBpbmRleENvdW50LCBwcmltaXRpdmVUeXBlID0gNCAvKiBUUklBTkdMRVMgKi8pIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xyXG4gICAgICAgIGdsLmRyYXdFbGVtZW50cyhwcmltaXRpdmVUeXBlLCBpbmRleENvdW50LCBnbC5VTlNJR05FRF9TSE9SVCwgb2Zmc2V0KTtcclxuICAgICAgICB0aGlzLl9ib3VuZFJlbmRlclRhcmdldC5pc0NsZWFyID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERlc3Ryb3lzIHRoZSBjb250ZXh0IGFuZCByZXNvdXJjZXMgb3duZWQgYnkgaXQuIE5vdGUgdGhhdCByZXNvdXJjZXMgdGhhdFxyXG4gICAgICogd2VyZSBjcmVhdGVkIHdpdGggYGNyZWF0ZSpgIG1ldGhvZCBvZiB0aGUgY29udGV4dCBhcmVuJ3QgZXhhY3RseSBiZWxvbmdcclxuICAgICAqIHRvIHRoZSBjb250ZXh0LCBlbnRpdGllcyB0aGF0IGNyZWF0ZWQgdGhlbSBoYXZlIHRvIGRlc3Ryb3kgdGhlbS5cclxuICAgICAqL1xyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLl9xdWFkVmFvLmRlc3Ryb3koKTtcclxuICAgICAgICB0aGlzLl9xdWFkVmVydGV4QnVmZmVyLmRlc3Ryb3koKTtcclxuICAgICAgICB0aGlzLl9nbC5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0bG9zdCcsIHRoaXMuX2NvbnRleHRMb3N0TGlzdGVuZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNvbnRleHQgZnJvbSBhIGNhbnZhcy5cclxuICAgICAqXHJcbiAgICAgKiBAdGhyb3dzIEFuIGVycm9yIGlmIGZhaWxzIHRvIGNyZWF0ZSBgd2ViZ2xgIGNvbnRleHQgZm9yIHRoZSBjYW52YXMuXHJcbiAgICAgKiBAcGFyYW0gY2FudmFzIFRoZSBjYW52YXMuXHJcbiAgICAgKiBAcGFyYW0gYXR0cmlicyBBdHRyaWJ1dGVzIG9mIHRoZSBjb250ZXh0LlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3JlYXRlRnJvbUNhbnZhcyhjYW52YXMsIGF0dHJpYnMpIHtcclxuICAgICAgICBjb25zdCBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcsIGF0dHJpYnMpO1xyXG4gICAgICAgIGlmICghZ2wpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gY3JlYXRlIEdMIGNvbnRleHQgZnJvbSBjYW52YXMuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgUmVuZGVyQ29udGV4dChnbCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgYSBXZWJHTCBjYXBhYmlsaXR5LlxyXG4gICAgICogQHNlZSBodHRwczovL3d3dy5raHJvbm9zLm9yZy9yZWdpc3RyeS9PcGVuR0wtUmVmcGFnZXMvZXMyLjAveGh0bWwvZ2xFbmFibGUueG1sXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNhcGFiaWxpdHkgVGhlIGNhcGFiaWxpdHkgdG8gYmUgZW5hYmxlZCBvZiBkaXNhYmxlZC5cclxuICAgICAqIEBwYXJhbSBlbmFibGVkIE5ldyBzdGF0ZSBvZiB0aGUgY2FwYWJpbGl0eTtcclxuICAgICAqL1xyXG4gICAgX3NldENhcGFiaWxpdHlFbmFibGVkKGNhcGFiaWxpdHksIGVuYWJsZWQpIHtcclxuICAgICAgICBpZiAoZW5hYmxlZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9nbC5lbmFibGUoY2FwYWJpbGl0eSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9nbC5kaXNhYmxlKGNhcGFiaWxpdHkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBuZXcgY2xlYXIgY29sb3IgYW5kIGNvbG9yIG1hc2sgZnJvbSBhIHN0YXRlIGlmIHRoZXkncmUgZGlmZmVyZW50IGZyb21cclxuICAgICAqIGN1cnJlbnRseSBzZXQgb25lcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3RhdGUgVGhlIHN0YXRlIHRoYXQgY29udGFpbnMgbmV3IGNsZWFyIGNvbG9yIGFuZCBjb2xvciBtYXNrcy5cclxuICAgICAqL1xyXG4gICAgX3NldENvbG9yQnVmZmVyU3RhdGUoc3RhdGUpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xyXG4gICAgICAgIGNvbnN0IGJvdW5kU3RhdGUgPSB0aGlzLl9ib3VuZFJlbmRlclN0YXRlO1xyXG4gICAgICAgIGNvbnN0IG5ld0NsZWFyQ29sb3IgPSBzdGF0ZS5jbGVhckNvbG9yO1xyXG4gICAgICAgIGlmICghY29sb3IuYXJlRXF1YWwoYm91bmRTdGF0ZS5jbGVhckNvbG9yLCBuZXdDbGVhckNvbG9yKSkge1xyXG4gICAgICAgICAgICBnbC5jbGVhckNvbG9yKG5ld0NsZWFyQ29sb3IuciwgbmV3Q2xlYXJDb2xvci5nLCBuZXdDbGVhckNvbG9yLmIsIG5ld0NsZWFyQ29sb3IuYSk7XHJcbiAgICAgICAgICAgIGNvbG9yLmNvcHkobmV3Q2xlYXJDb2xvciwgYm91bmRTdGF0ZS5jbGVhckNvbG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGJvdW5kU3RhdGUuY29sb3JNYXNrUiAhPT0gc3RhdGUuY29sb3JNYXNrUiB8fFxyXG4gICAgICAgICAgICBib3VuZFN0YXRlLmNvbG9yTWFza0cgIT09IHN0YXRlLmNvbG9yTWFza0cgfHxcclxuICAgICAgICAgICAgYm91bmRTdGF0ZS5jb2xvck1hc2tCICE9PSBzdGF0ZS5jb2xvck1hc2tCIHx8XHJcbiAgICAgICAgICAgIGJvdW5kU3RhdGUuY29sb3JNYXNrQWxwaGEgIT09IHN0YXRlLmNvbG9yTWFza0FscGhhKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsLmNvbG9yTWFzayhzdGF0ZS5jb2xvck1hc2tSLCBzdGF0ZS5jb2xvck1hc2tHLCBzdGF0ZS5jb2xvck1hc2tCLCBzdGF0ZS5jb2xvck1hc2tBbHBoYSk7XHJcbiAgICAgICAgICAgIGJvdW5kU3RhdGUuY29sb3JNYXNrUiA9IHN0YXRlLmNvbG9yTWFza1I7XHJcbiAgICAgICAgICAgIGJvdW5kU3RhdGUuY29sb3JNYXNrRyA9IHN0YXRlLmNvbG9yTWFza0c7XHJcbiAgICAgICAgICAgIGJvdW5kU3RhdGUuY29sb3JNYXNrQiA9IHN0YXRlLmNvbG9yTWFza0I7XHJcbiAgICAgICAgICAgIGJvdW5kU3RhdGUuY29sb3JNYXNrQWxwaGEgPSBzdGF0ZS5jb2xvck1hc2tBbHBoYTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgYmxlbmQgc3RhdGUgYW5kIHBhcmFtcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3RhdGUgVGhlIHN0YXRlIHRoYXQgY29udGFpbnMgbmV3IGJsZW5kIHBhcmFtcy5cclxuICAgICAqL1xyXG4gICAgX3NldEJsZW5kU3RhdGUoc3RhdGUpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xyXG4gICAgICAgIGNvbnN0IGJvdW5kU3RhdGUgPSB0aGlzLl9ib3VuZFJlbmRlclN0YXRlO1xyXG4gICAgICAgIGlmIChib3VuZFN0YXRlLmJsZW5kICE9PSBzdGF0ZS5ibGVuZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zZXRDYXBhYmlsaXR5RW5hYmxlZChnbC5CTEVORCwgc3RhdGUuYmxlbmQpO1xyXG4gICAgICAgICAgICBib3VuZFN0YXRlLmJsZW5kID0gc3RhdGUuYmxlbmQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdGF0ZS5ibGVuZCkge1xyXG4gICAgICAgICAgICBpZiAoYm91bmRTdGF0ZS5ibGVuZEVxdWF0aW9uUmdiICE9PSBzdGF0ZS5ibGVuZEVxdWF0aW9uUmdiIHx8XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLmJsZW5kRXF1YXRpb25BbHBoYSAhPT0gc3RhdGUuYmxlbmRFcXVhdGlvbkFscGhhKSB7XHJcbiAgICAgICAgICAgICAgICBnbC5ibGVuZEVxdWF0aW9uU2VwYXJhdGUoc3RhdGUuYmxlbmRFcXVhdGlvblJnYiwgc3RhdGUuYmxlbmRFcXVhdGlvbkFscGhhKTtcclxuICAgICAgICAgICAgICAgIGJvdW5kU3RhdGUuYmxlbmRFcXVhdGlvblJnYiA9IHN0YXRlLmJsZW5kRXF1YXRpb25SZ2I7XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLmJsZW5kRXF1YXRpb25BbHBoYSA9IHN0YXRlLmJsZW5kRXF1YXRpb25BbHBoYTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYm91bmRTdGF0ZS5ibGVuZEZ1bmNEc3RSZ2IgIT09IHN0YXRlLmJsZW5kRnVuY0RzdFJnYiB8fFxyXG4gICAgICAgICAgICAgICAgYm91bmRTdGF0ZS5ibGVuZEZ1bmNTcmNSZ2IgIT09IHN0YXRlLmJsZW5kRnVuY1NyY1JnYiB8fFxyXG4gICAgICAgICAgICAgICAgYm91bmRTdGF0ZS5ibGVuZEZ1bmNEc3RBbHBoYSAhPT0gc3RhdGUuYmxlbmRGdW5jRHN0QWxwaGEgfHxcclxuICAgICAgICAgICAgICAgIGJvdW5kU3RhdGUuYmxlbmRGdW5jU3JjQWxwaGEgIT09IHN0YXRlLmJsZW5kRnVuY1NyY0FscGhhKSB7XHJcbiAgICAgICAgICAgICAgICBnbC5ibGVuZEZ1bmNTZXBhcmF0ZShzdGF0ZS5ibGVuZEZ1bmNTcmNSZ2IsIHN0YXRlLmJsZW5kRnVuY0RzdFJnYiwgc3RhdGUuYmxlbmRGdW5jU3JjQWxwaGEsIHN0YXRlLmJsZW5kRnVuY0RzdEFscGhhKTtcclxuICAgICAgICAgICAgICAgIGJvdW5kU3RhdGUuYmxlbmRGdW5jU3JjUmdiID0gc3RhdGUuYmxlbmRGdW5jU3JjUmdiO1xyXG4gICAgICAgICAgICAgICAgYm91bmRTdGF0ZS5ibGVuZEZ1bmNEc3RSZ2IgPSBzdGF0ZS5ibGVuZEZ1bmNEc3RSZ2I7XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLmJsZW5kRnVuY1NyY0FscGhhID0gc3RhdGUuYmxlbmRGdW5jU3JjQWxwaGE7XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLmJsZW5kRnVuY0RzdEFscGhhID0gc3RhdGUuYmxlbmRGdW5jRHN0QWxwaGE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgY3VsbCBmYWNlIHN0YXRlIGFuZCBwYXJhbXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHN0YXRlIFRoZSBzdGF0ZSB0aGF0IGNvbnRhaW5zIG5ldyBjdWxsIGZhY2Ugc3RhdGUgYW5kIG1vZGUuXHJcbiAgICAgKi9cclxuICAgIF9zZXRDdWxsRmFjZVN0YXRlKHN0YXRlKSB7XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcclxuICAgICAgICBjb25zdCBib3VuZFN0YXRlID0gdGhpcy5fYm91bmRSZW5kZXJTdGF0ZTtcclxuICAgICAgICBpZiAoYm91bmRTdGF0ZS5jdWxsRmFjZSAhPT0gc3RhdGUuY3VsbEZhY2UpIHtcclxuICAgICAgICAgICAgdGhpcy5fc2V0Q2FwYWJpbGl0eUVuYWJsZWQoZ2wuQ1VMTF9GQUNFLCBzdGF0ZS5jdWxsRmFjZSk7XHJcbiAgICAgICAgICAgIGJvdW5kU3RhdGUuY3VsbEZhY2UgPSBzdGF0ZS5jdWxsRmFjZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0YXRlLmN1bGxGYWNlICYmXHJcbiAgICAgICAgICAgIGJvdW5kU3RhdGUuY3VsbEZhY2VNb2RlICE9PSBzdGF0ZS5jdWxsRmFjZU1vZGUpIHtcclxuICAgICAgICAgICAgZ2wuY3VsbEZhY2Uoc3RhdGUuY3VsbEZhY2VNb2RlKTtcclxuICAgICAgICAgICAgYm91bmRTdGF0ZS5jdWxsRmFjZU1vZGUgPSBzdGF0ZS5jdWxsRmFjZU1vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIGZyb250IGZhY2UgbW9kZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3RhdGUgVGhlIHN0YXRlIHRoYXQgY29udGFpbnMgbmV3IGZyb250IGZhY2UgbW9kZS5cclxuICAgICAqL1xyXG4gICAgX3NldEZyb250RmFjZVN0YXRlKHN0YXRlKSB7XHJcbiAgICAgICAgY29uc3QgYm91bmRTdGF0ZSA9IHRoaXMuX2JvdW5kUmVuZGVyU3RhdGU7XHJcbiAgICAgICAgaWYgKGJvdW5kU3RhdGUuZnJvbnRGYWNlTW9kZSAhPT0gc3RhdGUuZnJvbnRGYWNlTW9kZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9nbC5mcm9udEZhY2Uoc3RhdGUuZnJvbnRGYWNlTW9kZSk7XHJcbiAgICAgICAgICAgIGJvdW5kU3RhdGUuZnJvbnRGYWNlTW9kZSA9IHN0YXRlLmZyb250RmFjZU1vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIGRlcHRoIHRlc3Qgc3RhdGUgYW5kIHBhcmFtcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3RhdGUgVGhlIHN0YXRlIHRoYXQgY29udGFpbnMgbmV3IGRlcHRoIHRlc3Qgc3RhdGUgYW5kIHBhcmFtcy5cclxuICAgICAqL1xyXG4gICAgX3NldERlcHRoVGVzdFN0YXRlKHN0YXRlKSB7XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcclxuICAgICAgICBjb25zdCBib3VuZFN0YXRlID0gdGhpcy5fYm91bmRSZW5kZXJTdGF0ZTtcclxuICAgICAgICBpZiAoYm91bmRTdGF0ZS5kZXB0aFRlc3QgIT09IHN0YXRlLmRlcHRoVGVzdCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zZXRDYXBhYmlsaXR5RW5hYmxlZChnbC5ERVBUSF9URVNULCBzdGF0ZS5kZXB0aFRlc3QpO1xyXG4gICAgICAgICAgICBib3VuZFN0YXRlLmRlcHRoVGVzdCA9IHN0YXRlLmRlcHRoVGVzdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0YXRlLmRlcHRoVGVzdCkge1xyXG4gICAgICAgICAgICBpZiAoYm91bmRTdGF0ZS5jbGVhckRlcHRoICE9PSBzdGF0ZS5jbGVhckRlcHRoKSB7XHJcbiAgICAgICAgICAgICAgICBnbC5jbGVhckRlcHRoKHN0YXRlLmNsZWFyRGVwdGgpO1xyXG4gICAgICAgICAgICAgICAgYm91bmRTdGF0ZS5jbGVhckRlcHRoID0gc3RhdGUuY2xlYXJEZXB0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYm91bmRTdGF0ZS5kZXB0aE1hc2sgIT09IHN0YXRlLmRlcHRoTWFzaykge1xyXG4gICAgICAgICAgICAgICAgZ2wuZGVwdGhNYXNrKHN0YXRlLmRlcHRoTWFzayk7XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLmRlcHRoTWFzayA9IHN0YXRlLmRlcHRoTWFzaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYm91bmRTdGF0ZS5kZXB0aEZ1bmMgIT09IHN0YXRlLmRlcHRoRnVuYykge1xyXG4gICAgICAgICAgICAgICAgZ2wuZGVwdGhGdW5jKHN0YXRlLmRlcHRoRnVuYyk7XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLmRlcHRoRnVuYyA9IHN0YXRlLmRlcHRoRnVuYztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYm91bmRTdGF0ZS5kZXB0aFJhbmdlTmVhciAhPT0gc3RhdGUuZGVwdGhSYW5nZU5lYXIgfHxcclxuICAgICAgICAgICAgICAgIGJvdW5kU3RhdGUuZGVwdGhSYW5nZUZhciAhPT0gc3RhdGUuZGVwdGhSYW5nZUZhcikge1xyXG4gICAgICAgICAgICAgICAgZ2wuZGVwdGhSYW5nZShzdGF0ZS5kZXB0aFJhbmdlTmVhciwgc3RhdGUuZGVwdGhSYW5nZUZhcik7XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLmRlcHRoUmFuZ2VOZWFyID0gc3RhdGUuZGVwdGhSYW5nZU5lYXI7XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLmRlcHRoUmFuZ2VGYXIgPSBzdGF0ZS5kZXB0aFJhbmdlRmFyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIGRpdGhlciBzdGF0ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3RhdGUgVGhlIHN0YXRlIHRoYXQgY29udGFpbnMgbmV3IGRpdGhlciBzdGF0ZS5cclxuICAgICAqL1xyXG4gICAgX3NldERpdGhlclN0YXRlKHN0YXRlKSB7XHJcbiAgICAgICAgY29uc3QgYm91bmRTdGF0ZSA9IHRoaXMuX2JvdW5kUmVuZGVyU3RhdGU7XHJcbiAgICAgICAgaWYgKGJvdW5kU3RhdGUuZGl0aGVyICE9PSBzdGF0ZS5kaXRoZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5fc2V0Q2FwYWJpbGl0eUVuYWJsZWQodGhpcy5fZ2wuRElUSEVSLCBzdGF0ZS5kaXRoZXIpO1xyXG4gICAgICAgICAgICBib3VuZFN0YXRlLmRpdGhlciA9IHN0YXRlLmRpdGhlcjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgZHJhdyBidWZmZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzdGF0ZSBUaGUgc3RhdGUgdGhhdCBjb250YWlucyBhcnJheSBvZiBkcmF3IGJ1ZmZlcnMuXHJcbiAgICAgKi9cclxuICAgIF9zZXREcmF3QnVmZmVyc1N0YXRlKHN0YXRlKSB7XHJcbiAgICAgICAgY29uc3QgYm91bmREcmF3QnVmZmVycyA9IHRoaXMuX2JvdW5kUmVuZGVyU3RhdGUuZHJhd0J1ZmZlcnM7XHJcbiAgICAgICAgaWYgKGJvdW5kRHJhd0J1ZmZlcnMubGVuZ3RoICE9PSBzdGF0ZS5kcmF3QnVmZmVycy5sZW5ndGggfHxcclxuICAgICAgICAgICAgYm91bmREcmF3QnVmZmVyc1xyXG4gICAgICAgICAgICAgICAgLnNvbWUoKGF0dGFjaG1lbnQsIGkpID0+IGF0dGFjaG1lbnQgIT09IHN0YXRlLmRyYXdCdWZmZXJzW2ldKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9ib3VuZFJlbmRlclN0YXRlLmRyYXdCdWZmZXJzID0gc3RhdGUuZHJhd0J1ZmZlcnMuc2xpY2UoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgcG9seWdvbiBvZmZzZXQgc3RhdGUgYW5kIHBhcmFtcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3RhdGUgVGhlIHN0YXRlIHRoYXQgY29udGFpbnMgbmV3IHBvbHlnb24gb2Zmc2V0IHN0YXRlIGFuZCBwYXJhbXMuXHJcbiAgICAgKi9cclxuICAgIF9zZXRQb2x5Z29uT2Zmc2V0U3RhdGUoc3RhdGUpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xyXG4gICAgICAgIGNvbnN0IGJvdW5kU3RhdGUgPSB0aGlzLl9ib3VuZFJlbmRlclN0YXRlO1xyXG4gICAgICAgIGlmIChib3VuZFN0YXRlLnBvbHlnb25PZmZzZXQgIT09IHN0YXRlLnBvbHlnb25PZmZzZXQpIHtcclxuICAgICAgICAgICAgdGhpcy5fc2V0Q2FwYWJpbGl0eUVuYWJsZWQoZ2wuUE9MWUdPTl9PRkZTRVRfRklMTCwgc3RhdGUucG9seWdvbk9mZnNldCk7XHJcbiAgICAgICAgICAgIGJvdW5kU3RhdGUucG9seWdvbk9mZnNldCA9IHN0YXRlLnBvbHlnb25PZmZzZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdGF0ZS5wb2x5Z29uT2Zmc2V0ICYmXHJcbiAgICAgICAgICAgIChib3VuZFN0YXRlLnBvbHlnb25PZmZzZXRGYWN0b3IgIT09IHN0YXRlLnBvbHlnb25PZmZzZXRGYWN0b3IgfHxcclxuICAgICAgICAgICAgICAgIGJvdW5kU3RhdGUucG9seWdvbk9mZnNldFVuaXRzICE9PSBzdGF0ZS5wb2x5Z29uT2Zmc2V0VW5pdHMpKSB7XHJcbiAgICAgICAgICAgIGdsLnBvbHlnb25PZmZzZXQoc3RhdGUucG9seWdvbk9mZnNldEZhY3Rvciwgc3RhdGUucG9seWdvbk9mZnNldFVuaXRzKTtcclxuICAgICAgICAgICAgYm91bmRTdGF0ZS5wb2x5Z29uT2Zmc2V0RmFjdG9yID0gc3RhdGUucG9seWdvbk9mZnNldEZhY3RvcjtcclxuICAgICAgICAgICAgYm91bmRTdGF0ZS5wb2x5Z29uT2Zmc2V0VW5pdHMgPSBzdGF0ZS5wb2x5Z29uT2Zmc2V0VW5pdHM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIGFscGhhLXRvLWNvdmVyYWdlIHN0YXRlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzdGF0ZSBUaGUgc3RhdGUgdGhhdCBjb250YWlucyBuZXcgYWxwaGEtdG8tY292ZXJhZ2Ugc3RhdGUuXHJcbiAgICAgKi9cclxuICAgIF9zZXRBbHBoYVRvQ292ZXJhZ2VTdGF0ZShzdGF0ZSkge1xyXG4gICAgICAgIGNvbnN0IGJvdW5kU3RhdGUgPSB0aGlzLl9ib3VuZFJlbmRlclN0YXRlO1xyXG4gICAgICAgIGlmIChib3VuZFN0YXRlLnNhbXBsZUFscGhhVG9Db3ZlcmFnZSAhPT0gc3RhdGUuc2FtcGxlQWxwaGFUb0NvdmVyYWdlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldENhcGFiaWxpdHlFbmFibGVkKHRoaXMuX2dsLlNBTVBMRV9BTFBIQV9UT19DT1ZFUkFHRSwgc3RhdGUuc2FtcGxlQWxwaGFUb0NvdmVyYWdlKTtcclxuICAgICAgICAgICAgYm91bmRTdGF0ZS5zYW1wbGVBbHBoYVRvQ292ZXJhZ2UgPSBzdGF0ZS5zYW1wbGVBbHBoYVRvQ292ZXJhZ2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHNhbXBsZSBjb3ZlcmFnZSBzdGF0ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3RhdGUgVGhlIHN0YXRlIHRoYXQgY29udGFpbnMgbmV3IHNhbXBsZSBjb3ZlcmFnZSBzdGF0ZSBhbmQgcGFyYW1zLlxyXG4gICAgICovXHJcbiAgICBfc2V0U2FtcGxlQ292ZXJhZ2VTdGF0ZShzdGF0ZSkge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XHJcbiAgICAgICAgY29uc3QgYm91bmRTdGF0ZSA9IHRoaXMuX2JvdW5kUmVuZGVyU3RhdGU7XHJcbiAgICAgICAgaWYgKGJvdW5kU3RhdGUuc2FtcGxlQ292ZXJhZ2UgIT09IHN0YXRlLnNhbXBsZUNvdmVyYWdlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldENhcGFiaWxpdHlFbmFibGVkKGdsLlNBTVBMRV9DT1ZFUkFHRSwgc3RhdGUuc2FtcGxlQ292ZXJhZ2UpO1xyXG4gICAgICAgICAgICBib3VuZFN0YXRlLnNhbXBsZUNvdmVyYWdlID0gc3RhdGUuc2FtcGxlQ292ZXJhZ2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdGF0ZS5zYW1wbGVDb3ZlcmFnZSAmJlxyXG4gICAgICAgICAgICAoYm91bmRTdGF0ZS5zYW1wbGVDb3ZlcmFnZVZhbHVlICE9PSBzdGF0ZS5zYW1wbGVDb3ZlcmFnZVZhbHVlIHx8XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLnNhbXBsZUNvdmVyYWdlSW52ZXJ0ICE9PSBzdGF0ZS5zYW1wbGVDb3ZlcmFnZUludmVydCkpIHtcclxuICAgICAgICAgICAgZ2wuc2FtcGxlQ292ZXJhZ2Uoc3RhdGUuc2FtcGxlQ292ZXJhZ2VWYWx1ZSwgc3RhdGUuc2FtcGxlQ292ZXJhZ2VJbnZlcnQpO1xyXG4gICAgICAgICAgICBib3VuZFN0YXRlLnNhbXBsZUNvdmVyYWdlVmFsdWUgPSBzdGF0ZS5zYW1wbGVDb3ZlcmFnZVZhbHVlO1xyXG4gICAgICAgICAgICBib3VuZFN0YXRlLnNhbXBsZUNvdmVyYWdlSW52ZXJ0ID0gc3RhdGUuc2FtcGxlQ292ZXJhZ2VJbnZlcnQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHN0ZW5jaWwgdGVzdCBzdGF0ZSBhbmQgcGFyYW1zLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzdGF0ZSBUaGUgc3RhdGUgdGhhdCBjb250YWlucyBuZXcgc3RlbmNpbCB0ZXN0IHN0YXRlIGFuZCBwYXJhbXMuXHJcbiAgICAgKi9cclxuICAgIF9zZXRTdGVuY2lsVGVzdFN0YXRlKHN0YXRlKSB7XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcclxuICAgICAgICBjb25zdCBib3VuZFN0YXRlID0gdGhpcy5fYm91bmRSZW5kZXJTdGF0ZTtcclxuICAgICAgICBpZiAoYm91bmRTdGF0ZS5zdGVuY2lsVGVzdCAhPT0gc3RhdGUuc3RlbmNpbFRlc3QpIHtcclxuICAgICAgICAgICAgdGhpcy5fc2V0Q2FwYWJpbGl0eUVuYWJsZWQoZ2wuU1RFTkNJTF9URVNULCBzdGF0ZS5zdGVuY2lsVGVzdCk7XHJcbiAgICAgICAgICAgIGJvdW5kU3RhdGUuc3RlbmNpbFRlc3QgPSBzdGF0ZS5zdGVuY2lsVGVzdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0YXRlLnN0ZW5jaWxUZXN0KSB7XHJcbiAgICAgICAgICAgIGlmIChib3VuZFN0YXRlLmNsZWFyU3RlbmNpbCAhPT0gc3RhdGUuY2xlYXJTdGVuY2lsKSB7XHJcbiAgICAgICAgICAgICAgICBnbC5jbGVhclN0ZW5jaWwoc3RhdGUuY2xlYXJTdGVuY2lsKTtcclxuICAgICAgICAgICAgICAgIGJvdW5kU3RhdGUuY2xlYXJTdGVuY2lsID0gc3RhdGUuY2xlYXJTdGVuY2lsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChib3VuZFN0YXRlLnN0ZW5jaWxXcml0ZU1hc2sgIT09IHN0YXRlLnN0ZW5jaWxXcml0ZU1hc2spIHtcclxuICAgICAgICAgICAgICAgIGdsLnN0ZW5jaWxNYXNrKHN0YXRlLnN0ZW5jaWxXcml0ZU1hc2spO1xyXG4gICAgICAgICAgICAgICAgYm91bmRTdGF0ZS5zdGVuY2lsV3JpdGVNYXNrID0gc3RhdGUuc3RlbmNpbFdyaXRlTWFzaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCByZWZPck1hc2tJc0RpZmZlcmVudCA9IChib3VuZFN0YXRlLnN0ZW5jaWxNYXNrICE9PSBzdGF0ZS5zdGVuY2lsTWFzayB8fFxyXG4gICAgICAgICAgICAgICAgYm91bmRTdGF0ZS5zdGVuY2lsUmVmZXJlbmNlICE9PSBzdGF0ZS5zdGVuY2lsUmVmZXJlbmNlKTtcclxuICAgICAgICAgICAgaWYgKHJlZk9yTWFza0lzRGlmZmVyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLnN0ZW5jaWxNYXNrID0gc3RhdGUuc3RlbmNpbE1hc2s7XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLnN0ZW5jaWxSZWZlcmVuY2UgPSBzdGF0ZS5zdGVuY2lsUmVmZXJlbmNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChib3VuZFN0YXRlLnN0ZW5jaWxGcm9udEZ1bmMgIT09IHN0YXRlLnN0ZW5jaWxGcm9udEZ1bmMgfHxcclxuICAgICAgICAgICAgICAgIHJlZk9yTWFza0lzRGlmZmVyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBnbC5zdGVuY2lsRnVuY1NlcGFyYXRlKGdsLkZST05ULCBzdGF0ZS5zdGVuY2lsRnJvbnRGdW5jLCBzdGF0ZS5zdGVuY2lsUmVmZXJlbmNlLCBzdGF0ZS5zdGVuY2lsTWFzayk7XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLnN0ZW5jaWxGcm9udEZ1bmMgPSBzdGF0ZS5zdGVuY2lsRnJvbnRGdW5jO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChib3VuZFN0YXRlLnN0ZW5jaWxCYWNrRnVuYyAhPT0gc3RhdGUuc3RlbmNpbEJhY2tGdW5jIHx8XHJcbiAgICAgICAgICAgICAgICByZWZPck1hc2tJc0RpZmZlcmVudCkge1xyXG4gICAgICAgICAgICAgICAgZ2wuc3RlbmNpbEZ1bmNTZXBhcmF0ZShnbC5CQUNLLCBzdGF0ZS5zdGVuY2lsQmFja0Z1bmMsIHN0YXRlLnN0ZW5jaWxSZWZlcmVuY2UsIHN0YXRlLnN0ZW5jaWxNYXNrKTtcclxuICAgICAgICAgICAgICAgIGJvdW5kU3RhdGUuc3RlbmNpbEJhY2tGdW5jID0gc3RhdGUuc3RlbmNpbEJhY2tGdW5jO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChib3VuZFN0YXRlLnN0ZW5jaWxGcm9udEZhaWxPcCAhPT0gc3RhdGUuc3RlbmNpbEZyb250RmFpbE9wIHx8XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLnN0ZW5jaWxGcm9udERlcHRoRmFpbE9wICE9PSBzdGF0ZS5zdGVuY2lsRnJvbnREZXB0aEZhaWxPcCB8fFxyXG4gICAgICAgICAgICAgICAgYm91bmRTdGF0ZS5zdGVuY2lsRnJvbnREZXB0aFBhc3NPcCAhPT0gc3RhdGUuc3RlbmNpbEZyb250RGVwdGhQYXNzT3ApIHtcclxuICAgICAgICAgICAgICAgIGdsLnN0ZW5jaWxPcFNlcGFyYXRlKGdsLkZST05ULCBzdGF0ZS5zdGVuY2lsRnJvbnRGYWlsT3AsIHN0YXRlLnN0ZW5jaWxGcm9udERlcHRoRmFpbE9wLCBzdGF0ZS5zdGVuY2lsRnJvbnREZXB0aFBhc3NPcCk7XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLnN0ZW5jaWxGcm9udEZhaWxPcCA9IHN0YXRlLnN0ZW5jaWxGcm9udEZhaWxPcDtcclxuICAgICAgICAgICAgICAgIGJvdW5kU3RhdGUuc3RlbmNpbEZyb250RGVwdGhGYWlsT3AgPSBzdGF0ZS5zdGVuY2lsRnJvbnREZXB0aEZhaWxPcDtcclxuICAgICAgICAgICAgICAgIGJvdW5kU3RhdGUuc3RlbmNpbEZyb250RGVwdGhQYXNzT3AgPSBzdGF0ZS5zdGVuY2lsRnJvbnREZXB0aFBhc3NPcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYm91bmRTdGF0ZS5zdGVuY2lsQmFja0ZhaWxPcCAhPT0gc3RhdGUuc3RlbmNpbEJhY2tGYWlsT3AgfHxcclxuICAgICAgICAgICAgICAgIGJvdW5kU3RhdGUuc3RlbmNpbEJhY2tEZXB0aEZhaWxPcCAhPT0gc3RhdGUuc3RlbmNpbEJhY2tEZXB0aEZhaWxPcCB8fFxyXG4gICAgICAgICAgICAgICAgYm91bmRTdGF0ZS5zdGVuY2lsQmFja0RlcHRoUGFzc09wICE9PSBzdGF0ZS5zdGVuY2lsQmFja0RlcHRoUGFzc09wKSB7XHJcbiAgICAgICAgICAgICAgICBnbC5zdGVuY2lsT3BTZXBhcmF0ZShnbC5CQUNLLCBzdGF0ZS5zdGVuY2lsQmFja0ZhaWxPcCwgc3RhdGUuc3RlbmNpbEJhY2tEZXB0aEZhaWxPcCwgc3RhdGUuc3RlbmNpbEJhY2tEZXB0aFBhc3NPcCk7XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLnN0ZW5jaWxCYWNrRmFpbE9wID0gc3RhdGUuc3RlbmNpbEJhY2tGYWlsT3A7XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLnN0ZW5jaWxCYWNrRGVwdGhGYWlsT3AgPSBzdGF0ZS5zdGVuY2lsQmFja0RlcHRoRmFpbE9wO1xyXG4gICAgICAgICAgICAgICAgYm91bmRTdGF0ZS5zdGVuY2lsQmFja0RlcHRoUGFzc09wID0gc3RhdGUuc3RlbmNpbEJhY2tEZXB0aFBhc3NPcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBzY2lzc29yIHRlc3Qgc3RhdGUgYW5kIHNjaXNzb3IgcmVjdGFuZ2xlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzdGF0ZSBUaGUgc3RhdGUgdGhhdCBjb250YWlucyBuZXcgc2Npc3NvciB0ZXN0IHN0YXRlIGFuZCBzY2lzc29yXHJcbiAgICAgKiAgICAgIHJlY3RhbmdsZS5cclxuICAgICAqL1xyXG4gICAgX3NldFNjaXNzb3JUZXN0U3RhdGUoc3RhdGUpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xyXG4gICAgICAgIGNvbnN0IGJvdW5kU3RhdGUgPSB0aGlzLl9ib3VuZFJlbmRlclN0YXRlO1xyXG4gICAgICAgIGlmIChib3VuZFN0YXRlLnNjaXNzb3JUZXN0ICE9PSBzdGF0ZS5zY2lzc29yVGVzdCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zZXRDYXBhYmlsaXR5RW5hYmxlZChnbC5TQ0lTU09SX1RFU1QsIHN0YXRlLnNjaXNzb3JUZXN0KTtcclxuICAgICAgICAgICAgYm91bmRTdGF0ZS5zY2lzc29yVGVzdCA9IHN0YXRlLnNjaXNzb3JUZXN0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RhdGUuc2Npc3NvclRlc3QgJiZcclxuICAgICAgICAgICAgc3RhdGUuc2Npc3NvcldpZHRoID49IDAgJiZcclxuICAgICAgICAgICAgc3RhdGUuc2Npc3NvckhlaWdodCA+PSAwICYmXHJcbiAgICAgICAgICAgIChib3VuZFN0YXRlLnNjaXNzb3JYICE9PSBzdGF0ZS5zY2lzc29yWCB8fFxyXG4gICAgICAgICAgICAgICAgYm91bmRTdGF0ZS5zY2lzc29yWSAhPT0gc3RhdGUuc2Npc3NvclkgfHxcclxuICAgICAgICAgICAgICAgIGJvdW5kU3RhdGUuc2Npc3NvcldpZHRoICE9PSBzdGF0ZS5zY2lzc29yV2lkdGggfHxcclxuICAgICAgICAgICAgICAgIGJvdW5kU3RhdGUuc2Npc3NvckhlaWdodCAhPT0gc3RhdGUuc2Npc3NvckhlaWdodCkpIHtcclxuICAgICAgICAgICAgZ2wuc2Npc3NvcihzdGF0ZS5zY2lzc29yWCwgc3RhdGUuc2Npc3NvclksIHN0YXRlLnNjaXNzb3JXaWR0aCwgc3RhdGUuc2Npc3NvckhlaWdodCk7XHJcbiAgICAgICAgICAgIGJvdW5kU3RhdGUuc2Npc3NvclggPSBzdGF0ZS5zY2lzc29yWDtcclxuICAgICAgICAgICAgYm91bmRTdGF0ZS5zY2lzc29yWSA9IHN0YXRlLnNjaXNzb3JZO1xyXG4gICAgICAgICAgICBib3VuZFN0YXRlLnNjaXNzb3JXaWR0aCA9IHN0YXRlLnNjaXNzb3JXaWR0aDtcclxuICAgICAgICAgICAgYm91bmRTdGF0ZS5zY2lzc29ySGVpZ2h0ID0gc3RhdGUuc2Npc3NvckhlaWdodDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdmlld3BvcnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHN0YXRlIFRoZSBzdGF0ZSB0aGF0IGNvbnRhaW5zIG5ldyB2aWV3cG9ydC5cclxuICAgICAqL1xyXG4gICAgX3NldFZpZXdwb3J0U3RhdGUoc3RhdGUpIHtcclxuICAgICAgICBjb25zdCBib3VuZFN0YXRlID0gdGhpcy5fYm91bmRSZW5kZXJTdGF0ZTtcclxuICAgICAgICBpZiAoc3RhdGUudmlld3BvcnRXaWR0aCA+PSAwICYmXHJcbiAgICAgICAgICAgIHN0YXRlLnZpZXdwb3J0SGVpZ2h0ID49IDAgJiZcclxuICAgICAgICAgICAgKGJvdW5kU3RhdGUudmlld3BvcnRYICE9PSBzdGF0ZS52aWV3cG9ydFggfHxcclxuICAgICAgICAgICAgICAgIGJvdW5kU3RhdGUudmlld3BvcnRZICE9PSBzdGF0ZS52aWV3cG9ydFkgfHxcclxuICAgICAgICAgICAgICAgIGJvdW5kU3RhdGUudmlld3BvcnRXaWR0aCAhPT0gc3RhdGUudmlld3BvcnRXaWR0aCB8fFxyXG4gICAgICAgICAgICAgICAgYm91bmRTdGF0ZS52aWV3cG9ydEhlaWdodCAhPT0gc3RhdGUudmlld3BvcnRIZWlnaHQpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsLnZpZXdwb3J0KHN0YXRlLnZpZXdwb3J0WCwgc3RhdGUudmlld3BvcnRZLCBzdGF0ZS52aWV3cG9ydFdpZHRoLCBzdGF0ZS52aWV3cG9ydEhlaWdodCk7XHJcbiAgICAgICAgICAgIGJvdW5kU3RhdGUudmlld3BvcnRYID0gc3RhdGUudmlld3BvcnRYO1xyXG4gICAgICAgICAgICBib3VuZFN0YXRlLnZpZXdwb3J0WSA9IHN0YXRlLnZpZXdwb3J0WTtcclxuICAgICAgICAgICAgYm91bmRTdGF0ZS52aWV3cG9ydFdpZHRoID0gc3RhdGUudmlld3BvcnRXaWR0aDtcclxuICAgICAgICAgICAgYm91bmRTdGF0ZS52aWV3cG9ydEhlaWdodCA9IHN0YXRlLnZpZXdwb3J0SGVpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0ZXh0dXJlIGRhdGEgdW5wYWNrIHBhcmFtcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcGFyYW1zIFRleHR1cmUgcGFyYW1zIHRvIGJlIHNldC5cclxuICAgICAqL1xyXG4gICAgX3NldFRleHR1cmVEYXRhVW5wYWNrUGFyYW1zKHBhcmFtcykge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XHJcbiAgICAgICAgaWYgKHRoaXMuX3VucGFja1ByZW11bHRpcGx5QWxwaGEgIT09IHBhcmFtcy5wcmVtdWx0aXBsaWVkQWxwaGEpIHtcclxuICAgICAgICAgICAgZ2wucGl4ZWxTdG9yZWkoMzc0NDEgLyogVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMICovLCArcGFyYW1zLnByZW11bHRpcGxpZWRBbHBoYSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3VucGFja1ByZW11bHRpcGx5QWxwaGEgPSBwYXJhbXMucHJlbXVsdGlwbGllZEFscGhhO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9vblRleHR1cmVEYXRhVXBkYXRlZCh0ZXh0dXJlKSB7XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcclxuICAgICAgICBjb25zdCBwYXJhbXMgPSB0ZXh0dXJlLmdldFBhcmFtcygpO1xyXG4gICAgICAgIGlmIChwYXJhbXMubWluaWZpY2F0aW9uRmlsdGVyID49IDk5ODQgLyogTkVBUkVTVF9NSVBNQVBfTkVBUkVTVCAqLykge1xyXG4gICAgICAgICAgICBnbC5nZW5lcmF0ZU1pcG1hcChnbC5URVhUVVJFXzJEKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgemVyb2VkIGJ1ZmZlciB3aXRoIGEgZ2l2ZW4gc2l6ZSBhbmQgYSB0YXJnZXQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IG9mIHRoZSBuZXcgYnVmZmVyLCBgQVJSQVlfQlVGRkVSYCBvclxyXG4gICAgICogICAgICBgRUxFTUVOVF9BUlJBWV9CVUZGRVJgLlxyXG4gICAgICogQHBhcmFtIHNpemUgVGhlIHNpemUgb2YgdGhlIGJ1ZmZlci5cclxuICAgICAqIEBwYXJhbSB1c2FnZSBVc2FnZSBvZiB0aGUgYnVmZmVyLlxyXG4gICAgICogQHJldHVybnMgVGhlIGJ1ZmZlci5cclxuICAgICAqL1xyXG4gICAgX2NyZWF0ZUJ1ZmZlcih0YXJnZXQsIHNpemUsIHVzYWdlID0gdGhpcy5fZ2wuU1RBVElDX0RSQVcpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xyXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBCdWZmZXIoZ2wsIHRhcmdldCwgc2l6ZSk7XHJcbiAgICAgICAgLy8gVE9ETyhkbWlraXMpIGEgY2xldmVyZXIgd2F5IG5vdCB0byBicmVhayBjdXJyZW50bHkgYm91bmQgVkFPO1xyXG4gICAgICAgIHRoaXMuYmluZFZhbyhudWxsKTtcclxuICAgICAgICBidWZmZXIuYmluZCgpO1xyXG4gICAgICAgIGdsLmJ1ZmZlckRhdGEodGFyZ2V0LCBzaXplLCB1c2FnZSk7XHJcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBtYXBJdGVyYWJsZSB9IGZyb20gJy4uL3V0aWwvaXRlcmFibGUnO1xyXG5pbXBvcnQgeyBhbGlnbiB9IGZyb20gJy4uL3V0aWwvcG93X29mXzInO1xyXG4vKipcclxuICogR2l2ZXMgc2l6ZSBvZiBhIEdMIHR5cGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB0eXBlIFRoZSB0eXBlLlxyXG4gKiBAcmV0dXJucyBTaXplIG9mIHRoZSB0eXBlIGluIGJ5dGVzLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0VHlwZVNpemUodHlwZSkge1xyXG4gICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgY2FzZSA1MTIwIC8qIEJZVEUgKi86XHJcbiAgICAgICAgY2FzZSA1MTIxIC8qIFVOU0lHTkVEX0JZVEUgKi86XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIGNhc2UgNTEyMiAvKiBTSE9SVCAqLzpcclxuICAgICAgICBjYXNlIDUxMjMgLyogVU5TSUdORURfU0hPUlQgKi86XHJcbiAgICAgICAgICAgIHJldHVybiAyO1xyXG4gICAgICAgIGNhc2UgNTEyNCAvKiBJTlQgKi86XHJcbiAgICAgICAgY2FzZSA1MTI1IC8qIFVOU0lHTkVEX0lOVCAqLzpcclxuICAgICAgICBjYXNlIDUxMjYgLyogRkxPQVQgKi86XHJcbiAgICAgICAgICAgIHJldHVybiA0O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBEZXNjcmlwdGlvbiBvZiBob3cgcGFydGljdWxhciBhdHRyaWJ1dGVzIG9mIGEgdmVydGV4IGFyZSBwYWNrZWQgaW50byBhIHZlcnRleFxyXG4gKiBidWZmZXIuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQXR0cmlidXRlTWFwcGluZyBleHRlbmRzIE1hcCB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgYXR0cmlidXRlIG1hcHBpbmcgd2l0aCBhIHNldCBvZiBhdHRyaWJ1dGVzIG9mIGdpdmVuIHR5cGVzIGFuZFxyXG4gICAgICogc2l6ZXMuIEF1dG9tYXRpY2FsbHkgY29tcHV0ZXMgb2Zmc2V0cyBvZiB0aGUgYXR0cmlidXRlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbWFwcGluZyBUaGUgbWFwcGluZyBmcm9tIGF0dHJpYnV0ZSBJRHMgdG8gdHlwZXMgYW5kIHNpemVzLlxyXG4gICAgICogQHBhcmFtIGFsaWdubWVudCBEZXNpcmVkIGFsaWdubWVudCBvZiBhdHRyaWJ1dGVzIGluIHRoZSB2ZXJ0ZXggZGF0YVxyXG4gICAgICogICAgICBzdHJ1Y3R1cmUuIE11c3QgYmUgYSBwb3dlciBvZiAyLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihtYXBwaW5nLCBhbGlnbm1lbnQgPSA0IC8qIEFMSUdOXzRfQllURVMgKi8pIHtcclxuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcclxuICAgICAgICBzdXBlcihtYXBJdGVyYWJsZShtYXBwaW5nLCAoW2lkeCwgeyB0eXBlLCBzaXplLCBub3JtYWxpemVkIH1dKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBvaW50ZXIgPSBbXHJcbiAgICAgICAgICAgICAgICBpZHgsXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZSxcclxuICAgICAgICAgICAgICAgICAgICBzaXplLFxyXG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZVNpemUgPSBzaXplICogZ2V0VHlwZVNpemUodHlwZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld09mZnNldCA9IGFsaWduKG9mZnNldCArIGF0dHJpYnV0ZVNpemUsIC1hbGlnbm1lbnQpO1xyXG4gICAgICAgICAgICAvLyBUT0RPKGRtaWtpcykgQ2hlY2sgdGhpcyBpbiBkZWJ1ZyBtb2RlLlxyXG4gICAgICAgICAgICAvLyBpZiAobmV3T2Zmc2V0IC0gb2Zmc2V0ID4gYXR0cmlidXRlU2l6ZSkge1xyXG4gICAgICAgICAgICAvLyAgICBjb25zb2xlLndhcm4oYCR7bmV3T2Zmc2V0IC0gb2Zmc2V0fSBieXRlIHBhZGRpbmcncyBpbnNlcnRlZGApO1xyXG4gICAgICAgICAgICAvLyB9XHJcbiAgICAgICAgICAgIG9mZnNldCA9IG5ld09mZnNldDtcclxuICAgICAgICAgICAgcmV0dXJuIHBvaW50ZXI7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIHRoaXMudmVydGV4Qnl0ZVNpemUgPSBvZmZzZXQ7XHJcbiAgICB9XHJcbn1cclxuIiwiLyoqXHJcbiAqIFNlYXJjaGVzIGZvciB0aGUgZmlyc3QgY29sbGVjdGlvbiBpdGVtIHNhdGlzZnlpbmcgYSBwcmVkaWNhdGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uLlxyXG4gKiBAcGFyYW0gcHJlZGljYXRlIFRoZSBwcmVkaWNhdGUuXHJcbiAqIEByZXR1cm5zIFRoZSBmaXJzdCBpdGVtIHNhdGlzZnlpbmcgdGhlIHByZWRpY2F0ZSBvciBgdW5kZWZpbmVkYCBpZiBub25lIGZvdW5kLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRJbkl0ZXJhYmxlKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xyXG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGNvbGxlY3Rpb24pIHtcclxuICAgICAgICBpZiAocHJlZGljYXRlKGl0ZW0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybjtcclxufVxyXG4vKipcclxuICogVHJhbnNmb3JtcyBhIGNvbGxlY3Rpb24gdG8gYW5vdGhlciBvbmUuXHJcbiAqXHJcbiAqIEBwYXJhbSBjb2xsZWN0aW9uIFRoZSBzb3VyY2UgY29sbGVjdGlvbi5cclxuICogQHBhcmFtIG1hcHBlciBBIGZ1bmN0aW9uIHByb2R1Y2luZyBpdGVtcyBmb3IgZGVzdGluYXRpb24gY29sbGVjdGlvbi5cclxuICogQHJldHVybnMgQ29sbGVjdGlvbiBvZiBwcm9kdWNlZCBpdGVtcy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiogbWFwSXRlcmFibGUoY29sbGVjdGlvbiwgbWFwcGVyKSB7XHJcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgY29sbGVjdGlvbikge1xyXG4gICAgICAgIHlpZWxkIG1hcHBlcihpdGVtKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ2hvb3NlcyBpdGVtcyBvZiBhIGNvbGxlY3Rpb24gc2F0aXNmeWluZyBhIHByZWRpY2F0ZS5cclxuICpcclxuICogQHBhcmFtIGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24uXHJcbiAqIEBwYXJhbSBwcmVkaWNhdGUgVGhlIHByZWRpY2F0ZS5cclxuICogQHJldHVybnMgQ29sbGVjdGlvbiBvZiBjaG9zZW4gaXRlbXMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24qIGZpbHRlckl0ZXJhYmxlKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xyXG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGNvbGxlY3Rpb24pIHtcclxuICAgICAgICBpZiAocHJlZGljYXRlKGl0ZW0pKSB7XHJcbiAgICAgICAgICAgIHlpZWxkIGl0ZW07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUcmF2ZXJzZXMgYSBjb2xsZWN0aW9uIGZyb20gbGVmdCB0byByaWdodCByZWNvbXB1dGluZyBhbiBhY2N1bXVsYXRvciBvbiBldmVyeVxyXG4gKiBpdGVyYXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uLlxyXG4gKiBAcGFyYW0gcmVkdWNlciBUaGUgZnVuY3Rpb24gdXNlZCB0byBjb21wdXRlIG5leHQgdmFsdWUgb2YgdGhlIGFjY3VtdWxhdG9yLlxyXG4gKiBAcGFyYW0gaW5pdGlhbFxyXG4gKiBAcmV0dXJucyBWYWx1ZSBvZiB0aGUgYWNjdW11bGF0b3IuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcmVkdWNlSXRlcmFibGUoY29sbGVjdGlvbiwgcmVkdWNlciwgaW5pdGlhbCkge1xyXG4gICAgbGV0IHJlc3VsdCA9IGluaXRpYWw7XHJcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgY29sbGVjdGlvbikge1xyXG4gICAgICAgIHJlc3VsdCA9IHJlZHVjZXIocmVzdWx0LCBpdGVtKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuLyoqXHJcbiAqIENoZWNrcyBpZiB0aGVyZSdzIGF0IGxlYXN0IG9uZSBpdGVtIGluIGEgY29sbGVjdGlvbiBzYXRpc2Z5aW5nIGEgcHJlZGljYXRlLlxyXG4gKlxyXG4gKiBAcGFyYW0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbi5cclxuICogQHBhcmFtIHByZWRpY2F0ZSBUaGUgcHJlZGljYXRlLlxyXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgZm9yIGF0IGxlYXN0IG9uZSBpdGVtIGluIHRoZSBjb2xsZWN0aW9uIHRoZSBwcmVkaWNhdGUgcmV0dXJuc1xyXG4gKiAgICAgIGB0cnVlYCBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gb25lT2ZJdGVyYWJsZShjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcclxuICAgIGZvciAoY29uc3QgaXRlbSBvZiBjb2xsZWN0aW9uKSB7XHJcbiAgICAgICAgaWYgKHByZWRpY2F0ZShpdGVtKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBhbGwgaXRlbXMgb2YgYSBjb2xsZWN0aW9uIHNhdGlzZnkgYSBwcmVkaWNhdGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uLlxyXG4gKiBAcGFyYW0gcHJlZGljYXRlIFRoZSBwcmVkaWNhdGUuXHJcbiAqIEByZXR1cm5zIGBmYWxzZWAgaWYgZm9yIGF0IGxlYXN0IG9uZSBpdGVtIGluIHRoZSBjb2xsZWN0aW9uIHRoZSBwcmVkaWNhdGUgcmV0dXJuc1xyXG4gKiAgICAgIGBmYWxzZWAgYW5kIGB0cnVlYCBvdGhlcndpc2UuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYWxsT2ZJdGVyYWJsZShjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcclxuICAgIGZvciAoY29uc3QgaXRlbSBvZiBjb2xsZWN0aW9uKSB7XHJcbiAgICAgICAgaWYgKCFwcmVkaWNhdGUoaXRlbSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGFuIGl0ZXJhdG9yIGZvciBbc3RhcnRJbmRleCwgc3RhcnRJbmRleCtsZW5ndGgpIHJhbmdlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uKiByYW5nZUl0ZXJhYmxlKGxlbmd0aCwgc3RhcnRJbmRleCA9IDApIHtcclxuICAgIGNvbnN0IGVuZEluZGV4ID0gc3RhcnRJbmRleCArIGxlbmd0aDtcclxuICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpIDwgZW5kSW5kZXg7IGkrKykge1xyXG4gICAgICAgIHlpZWxkIGk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uKiB6aXBJdGVyYWJsZXModHMsIHVzLCB6aXBwZXIgPSAodCwgdSkgPT4gW3QsIHVdKSB7XHJcbiAgICBjb25zdCB0SXRlcmF0b3IgPSB0c1tTeW1ib2wuaXRlcmF0b3JdKCk7XHJcbiAgICBjb25zdCB1SXRlcmF0b3IgPSB1c1tTeW1ib2wuaXRlcmF0b3JdKCk7XHJcbiAgICBmb3IgKGxldCB0ID0gdEl0ZXJhdG9yLm5leHQoKSwgdSA9IHVJdGVyYXRvci5uZXh0KCk7ICEodC5kb25lIHx8IHUuZG9uZSk7IHQgPSB0SXRlcmF0b3IubmV4dCgpLCB1ID0gdUl0ZXJhdG9yLm5leHQoKSkge1xyXG4gICAgICAgIHlpZWxkIHppcHBlcih0LnZhbHVlLCB1LnZhbHVlKTtcclxuICAgIH1cclxufVxyXG4iLCIvKipcclxuICogQ2hlY2tzIGlmIGEgbnVtYmVyIGlzIGEgcG93ZXIgb2YgMi5cclxuICpcclxuICogQHBhcmFtIHggVGhlIG51bWJlciB0byBjaGVjay5cclxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBudW1iZXIgaXMgYW4gaW50ZWdlciBwb3dlciBvZiAyIGFuZCBgZmFsc2VgIG90aGVyd2lzZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1Bvd09mMih4KSB7XHJcbiAgICByZXR1cm4geCA+IDAgJiYgISh4ICYgKHggLSAxKSk7XHJcbn1cclxuLyoqXHJcbiAqIEFsaWducyBhbiBvZmZzZXQgYnkgYW4gYWxpZ25tZW50IGdpdmVuIGJ5IGEgbWFzay5cclxuICpcclxuICogQHBhcmFtIG9mZnNldCBUaGUgb2Zmc2V0LlxyXG4gKiBAcGFyYW0gYWxpZ25tZW50TWFzayBUaGUgYWxpZ25tZW50IG1hc2sg4oCUIGEgYml0IGZpZWxkIHRoYXQgaGFzIGBsb2cyKGFsaWdubWVudClgXHJcbiAqICAgICAgb2YgbGVhc3Qgc2lnbmlmaWNhbnQgYml0cyB1bnNldCBhbmQgb3RoZXIgc2V0LCBlLmcuIGlmIGBhbGlnbm1lbnRgIGlzIDRcclxuICogICAgICB0aGVuIHRoZSBgYWxpZ25tZW50TWFza2Agd2lsbCBiZSBgMHhmZmZmZmZjYFxyXG4gKiBAcmV0dXJucyBBbGlnbmVkIG9mZnNldC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBhbGlnbihvZmZzZXQsIGFsaWdubWVudE1hc2spIHtcclxuICAgIHJldHVybiAob2Zmc2V0IC0gMSAmIGFsaWdubWVudE1hc2spIC0gYWxpZ25tZW50TWFzaztcclxufVxyXG4iLCIvKiogV3JhcHBlciBhcm91bmQgV2ViR0xCdWZmZXIgb2JqZWN0LiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCdWZmZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGVtcHR5IGJ1ZmZlciBpbiBhIFdlYkdMIGNvbnRleHQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGdsIFRoZSBjb250ZXh0IHRoZSBidWZmZXIgd2lsbCBiZSBjcmVhdGVkIGluLlxyXG4gICAgICogQHBhcmFtIHRhcmdldCBCaW5kaW5nIHRhcmdldCBvZiB0aGUgYnVmZmVyLiBTaW5jZSBpbiBXZWJHTCBvbmNlIHlvdSd2ZVxyXG4gICAgICogICAgICBib3VuZCBhIGJ1ZmZlciB0byBhIGdpdmVuIHRhcmdldCB5b3UgY2FuJ3QgYmluZCBpdCBhbnkgb3RoZXIgb25lLFxyXG4gICAgICogICAgICB3ZSBcInRpZVwiIHRoZSBidWZmZXIgYW5kIGl0J3MgYmluZGluZyBwb2ludCB0b2dldGhlci5cclxuICAgICAqIEBwYXJhbSBzaXplIFNpemUgb2YgdGhlIGJ1ZmZlci4gV2UgZG9uJ3QgZG8gYWN0dWFsIGFsbG9jYXRpb24gaW4gdGhlXHJcbiAgICAgKiAgICAgIHdyYXBwZXIsIGl0J3MgY29udGV4dCdzIHJlc3BvbnNpYmlsaXR5LiBCdXQgaXQncyBjb252ZW5pZW50IHRvIGJlXHJcbiAgICAgKiAgICAgIGFibGUgdG8gZ2V0IHRoZSBzaXplIGZyb20gdGhlIHdyYXBwZXIgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihnbCwgdGFyZ2V0LCBzaXplKSB7XHJcbiAgICAgICAgdGhpcy5fZ2wgPSBnbDtcclxuICAgICAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgdGhpcy5faGFuZGxlID0gZ2wuY3JlYXRlQnVmZmVyKCk7XHJcbiAgICAgICAgdGhpcy5fc2l6ZSA9IHNpemU7XHJcbiAgICB9XHJcbiAgICAvKiogQmluZHMgdGhlIGJ1ZmZlciB0byB0aGUgY29udGV4dCB0byBpdHMgYmluZGluZyB0YXJnZXQuICovXHJcbiAgICBiaW5kKCkge1xyXG4gICAgICAgIHRoaXMuX2dsLmJpbmRCdWZmZXIodGhpcy5fdGFyZ2V0LCB0aGlzLl9oYW5kbGUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYnVmZmVyIGlzIGN1cnJlbnRseSBib3VuZCB0byB0aGUgY29udGV4dCB0byBpdHNcclxuICAgICAqIGJpbmRpbmcgdGFyZ2V0IGFuZCBgZmFsc2VgIG90aGVyd2lzZS5cclxuICAgICAqL1xyXG4gICAgaXNCb3VuZCgpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xyXG4gICAgICAgIGNvbnN0IGhhbmRsZSA9IHRoaXMuX2hhbmRsZTtcclxuICAgICAgICBzd2l0Y2ggKHRoaXMuX3RhcmdldCkge1xyXG4gICAgICAgICAgICBjYXNlIGdsLkFSUkFZX0JVRkZFUjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBnbC5nZXRQYXJhbWV0ZXIoZ2wuQVJSQVlfQlVGRkVSX0JJTkRJTkcpID09PSBoYW5kbGU7XHJcbiAgICAgICAgICAgIGNhc2UgZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2wuZ2V0UGFyYW1ldGVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSX0JJTkRJTkcpID09PSBoYW5kbGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8qKiBSZXR1cm5zIGJpbmRpbmcgdGFyZ2V0IG9mIHRoZSBidWZmZXIuICovXHJcbiAgICBnZXRUYXJnZXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RhcmdldDtcclxuICAgIH1cclxuICAgIC8qKiBSZXR1cm5zIHNpemUgb2YgdGhlIGJ1ZmZlci4gKi9cclxuICAgIGdldFNpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpemU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERlc3Ryb3lzIHRoZSBidWZmZXIuXHJcbiAgICAgKi9cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5fZ2wuZGVsZXRlQnVmZmVyKHRoaXMuX2hhbmRsZSk7XHJcbiAgICB9XHJcbn1cclxuIiwiLyoqIFdyYXBwZXIgYXJvdW5kIFdlYkdMRnJhbWVidWZmZXIgb2JqZWN0LiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGcmFtZWJ1ZmZlciB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgZnJhbWVidWZmZXIgaW4gYSBXZWJHTCBjb250ZXh0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBnbCBUaGUgY29udGV4dCB0aGUgZnJhbWVidWZmZXIgd2lsbCBiZSBjcmVhdGVkIGluLlxyXG4gICAgICogQHBhcmFtIHdpZHRoIFdpZHRoIG9mIHRoZSBmcmFtZWJ1ZmZlci5cclxuICAgICAqIEBwYXJhbSBoZWlnaHQgSGVpZ2h0IG9mIHRoZSBmcmFtZWJ1ZmZlci5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZ2wsIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICB0aGlzLmlzQ2xlYXIgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9nbCA9IGdsO1xyXG4gICAgICAgIHRoaXMuX2hhbmRsZSA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XHJcbiAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEJpbmRzIHRoZSBmcmFtZWJ1ZmZlciB0byB0aGUgV2ViR0wgY29udGV4dC5cclxuICAgICAqL1xyXG4gICAgYmluZCgpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xyXG4gICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5faGFuZGxlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIHRoZSBmcmFtZWJ1ZmZlciBpcyBib3VuZCB0byB0aGUgV2ViR0wgY29udGV4dC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGZyYW1lYnVmZmVyIGlzIGN1cnJlbnRseSBib3VuZCB0byB0aGUgV2ViR0wgY29udGV4dFxyXG4gICAgICogICAgICBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXHJcbiAgICAgKi9cclxuICAgIGlzQm91bmQoKSB7XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcclxuICAgICAgICByZXR1cm4gZ2wuZ2V0UGFyYW1ldGVyKGdsLkZSQU1FQlVGRkVSX0JJTkRJTkcpID09PSB0aGlzLl9oYW5kbGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgd2lkdGggb2YgdGhlIGZyYW1lYnVmZmVyLlxyXG4gICAgICovXHJcbiAgICBnZXRXaWR0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fd2lkdGg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgaGVpZ2h0IG9mIHRoZSBmcmFtZWJ1ZmZlci5cclxuICAgICAqL1xyXG4gICAgZ2V0SGVpZ2h0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlYWRzIGNvbnRlbnQgb2YgdGhlIGNvbG9yIGF0dGFjaG1lbnQgYXMgYW4gUkdCQSBiaXRtYXAuXHJcbiAgICAgKi9cclxuICAgIHJlYWRQaXhlbHMoKSB7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KHRoaXMuZ2V0V2lkdGgoKSAqIHRoaXMuZ2V0SGVpZ2h0KCkgKiA0KTtcclxuICAgICAgICB0aGlzLl9nbC5yZWFkUGl4ZWxzKDAsIDAsIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQsIDY0MDggLyogUkdCQSAqLywgNTEyMSAvKiBVTlNJR05FRF9CWVRFICovLCBkYXRhKTtcclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGVzdHJveXMgdGhlIGZyYW1lYnVmZmVyLlxyXG4gICAgICovXHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMuX2dsLmRlbGV0ZUZyYW1lYnVmZmVyKHRoaXMuX2hhbmRsZSk7XHJcbiAgICB9XHJcbn1cclxuIiwiLyoqXHJcbiAqIEluc2VydHMgZ2l2ZW4gcGFyYW1ldGVycyBhcyBwcmVwcm9jZXNzb3IgZGVmaW5lIGRpcmVjdGl2ZXMgaW50byBzaGFkZXIgc291cmNlLlxyXG4gKlxyXG4gKiBAcGFyYW0gc291cmNlIFNoYWRlciBzb3VyY2UuXHJcbiAqIEBwYXJhbSBkZWZpbmVzIERpY3Rpb25hcnkgd2l0aCBwYXJhbWV0ZXJzIHRvIGRlZmluZSB3aXRoIHByZXByb2Nlc3NvciBkaXJlY3RpdmVzLlxyXG4gKiBAcmV0dXJucyBTaGFkZXIgc291cmNlIHdpdGggcHJlcHJvY2Vzc29yIGRpcmVjdGl2ZXMgaW5zZXJ0ZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBpbnNlcnREZWZpbmVzKHNvdXJjZSwgZGVmaW5lcykge1xyXG4gICAgY29uc3QgZGVmaW5lc1N0cmluZyA9IE9iamVjdC5rZXlzKGRlZmluZXMpXHJcbiAgICAgICAgLm1hcCgoZGVmaW5lTmFtZSkgPT4gJyNkZWZpbmUgJyArIGRlZmluZU5hbWUgKyAnICcgK1xyXG4gICAgICAgIGRlZmluZXNbZGVmaW5lTmFtZV0pXHJcbiAgICAgICAgLmpvaW4oJ1xcbicpO1xyXG4gICAgY29uc3QgdmVyc2lvbklkeCA9IHNvdXJjZS5pbmRleE9mKCcjdmVyc2lvbicpO1xyXG4gICAgaWYgKHZlcnNpb25JZHggPT09IC0xKSB7XHJcbiAgICAgICAgcmV0dXJuIGRlZmluZXNTdHJpbmcgKyAnXFxuJyArIHNvdXJjZTtcclxuICAgIH1cclxuICAgIGNvbnN0IG5leHRMaW5lSWR4ID0gc291cmNlLmluZGV4T2YoJ1xcbicsIHZlcnNpb25JZHgpICsgMTtcclxuICAgIHJldHVybiBzb3VyY2Uuc2xpY2UoMCwgbmV4dExpbmVJZHgpICsgZGVmaW5lc1N0cmluZyArICdcXG4nICtcclxuICAgICAgICBzb3VyY2Uuc2xpY2UobmV4dExpbmVJZHgpO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IHNoYWRlciBvZiBhIGdpdmVuIHR5cGUgb3V0IG9mIGEgZ2l2ZW4gc291cmNlIHN0cmluZy5cclxuICpcclxuICogQHBhcmFtIGdsIFdlYkdMIGNvbnRleHQgdGhlIHNoYWRlciB3aWxsIGJlIGNyZWF0ZWQgaW4uXHJcbiAqIEBwYXJhbSB0eXBlIFRoZSB0eXBlIG9mIHRoZSBzaGFkZXIsIFZFUlRFWF9TSEFERVIgb3IgRlJBR01FTlRfU0hBREVSLlxyXG4gKiBAcGFyYW0gc291cmNlIFRoZSBzb3VyY2Ugc3RyaW5nLlxyXG4gKiBAdGhyb3dzIEFuIGVycm9yIGlmIGNvbXBpbGF0aW9uIG9mIHRoZSBzaGFkZXIgZmFpbHMuXHJcbiAqIEByZXR1cm5zIFRoZSBzaGFkZXIgV2ViR0wgaGFuZGxlLlxyXG4gKi9cclxuZnVuY3Rpb24gY29tcGlsZVNoYWRlcihnbCwgdHlwZSwgc291cmNlKSB7XHJcbiAgICBjb25zdCBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIodHlwZSk7XHJcbiAgICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzb3VyY2UpO1xyXG4gICAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xyXG4gICAgLy8gVE9ETyBVbmNvbW1lbnQgYW5kIHB1dCB1bmRlciBkZWJ1ZyBmbGFnICh3aGVuIGltcGxlbWVudGVkKVxyXG4gICAgaWYgKCFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBjb21waWxlIHNoYWRlcjpcXG4nICsgZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBzaGFkZXI7XHJcbn1cclxuLyoqIFdyYXBwZXIgYXJvdW5kIFdlYkdMUHJvZ3JhbSBvYmplY3RzLiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcm9ncmFtIHtcclxuICAgIC8qKlxyXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBwcm9ncmFtLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBnbCBXZWJHTCBjb250ZXh0IHRoZSBwcm9ncmFtIHdpbGwgYmUgY3JlYXRlZCBpbi5cclxuICAgICAqIEBwYXJhbSB2ZXJ0ZXhTaGFkZXJTb3VyY2UgU291cmNlIGNvZGUgb2YgdmVydGV4IHNoYWRlciBvZiB0aGUgcHJvZ3JhbS5cclxuICAgICAqIEBwYXJhbSBmcmFnbWVudFNoYWRlclNvdXJjZSBTb3VyY2UgY29kZSBvZiBmcmFnbWVudCBzaGFkZXIgb2YgdGhlIHByb2dyYW0uXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zLlxyXG4gICAgICogQHRocm93cyBBbiBlcnJvciBpZiBzaGFkZXIgY29tcGlsYXRpb24gb3IgcHJvZ3JhbSBsaW5raW5nIGZhaWxzLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihnbCwgdmVydGV4U2hhZGVyU291cmNlLCBmcmFnbWVudFNoYWRlclNvdXJjZSwgb3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMuX2dsID0gZ2w7XHJcbiAgICAgICAgY29uc3QgaGFuZGxlID0gdGhpcy5faGFuZGxlID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xyXG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZGVmaW5lcykge1xyXG4gICAgICAgICAgICB2ZXJ0ZXhTaGFkZXJTb3VyY2UgPSBpbnNlcnREZWZpbmVzKHZlcnRleFNoYWRlclNvdXJjZSwgb3B0aW9ucy5kZWZpbmVzKTtcclxuICAgICAgICAgICAgZnJhZ21lbnRTaGFkZXJTb3VyY2UgPSBpbnNlcnREZWZpbmVzKGZyYWdtZW50U2hhZGVyU291cmNlLCBvcHRpb25zLmRlZmluZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB2ZXJ0ZXhTaGFkZXIgPSBjb21waWxlU2hhZGVyKGdsLCBnbC5WRVJURVhfU0hBREVSLCB2ZXJ0ZXhTaGFkZXJTb3VyY2UpO1xyXG4gICAgICAgIGNvbnN0IGZyYWdtZW50U2hhZGVyID0gY29tcGlsZVNoYWRlcihnbCwgZ2wuRlJBR01FTlRfU0hBREVSLCBmcmFnbWVudFNoYWRlclNvdXJjZSk7XHJcbiAgICAgICAgZ2wuYXR0YWNoU2hhZGVyKGhhbmRsZSwgdmVydGV4U2hhZGVyKTtcclxuICAgICAgICBnbC5hdHRhY2hTaGFkZXIoaGFuZGxlLCBmcmFnbWVudFNoYWRlcik7XHJcbiAgICAgICAgZ2wuZGVsZXRlU2hhZGVyKHZlcnRleFNoYWRlcik7XHJcbiAgICAgICAgZ2wuZGVsZXRlU2hhZGVyKGZyYWdtZW50U2hhZGVyKTtcclxuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmF0dHJpYk1hcCkge1xyXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhvcHRpb25zLmF0dHJpYk1hcClcclxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKChhdHRyaWJ1dGVOYW1lKSA9PiBnbC5iaW5kQXR0cmliTG9jYXRpb24oaGFuZGxlLCBvcHRpb25zLmF0dHJpYk1hcFthdHRyaWJ1dGVOYW1lXSwgYXR0cmlidXRlTmFtZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBnbC5saW5rUHJvZ3JhbShoYW5kbGUpO1xyXG4gICAgICAgIC8vIFRPRE8gVW5jb21tZW50IGFuZCBwdXQgdW5kZXIgZGVidWcgZmxhZyAod2hlbiBpbXBsZW1lbnRlZClcclxuICAgICAgICBpZiAoIWdsLmdldFByb2dyYW1QYXJhbWV0ZXIoaGFuZGxlLCBnbC5MSU5LX1NUQVRVUykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gbGluayBwcm9ncmFtOlxcbiR7Z2wuZ2V0UHJvZ3JhbUluZm9Mb2coaGFuZGxlKX1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fdW5pZm9ybUNhY2hlID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBCaW5kcyB0aGUgcHJvZ3JhbSB0byB0aGUgV2ViR0wgY29udGV4dC5cclxuICAgICAqL1xyXG4gICAgYmluZCgpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xyXG4gICAgICAgIGNvbnN0IGhhbmRsZSA9IHRoaXMuX2hhbmRsZTtcclxuICAgICAgICAvLyBUT0RPIFVuY29tbWVudCBhbmQgcHV0IHVuZGVyIGRlYnVnIGZsYWcgKHdoZW4gaW1wbGVtZW50ZWQpXHJcbiAgICAgICAgLy8gZ2wudmFsaWRhdGVQcm9ncmFtKGhhbmRsZSk7XHJcbiAgICAgICAgLy8gaWYgKCFnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKGhhbmRsZSwgZ2wuVkFMSURBVEVfU1RBVFVTKSkge1xyXG4gICAgICAgIC8vICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgLy8gICAgICAgICAnRmFpbGVkIHRvIHZhbGlkYXRlIHByb2dyYW06XFxuJyArIGdsLmdldFByb2dyYW1JbmZvTG9nKGhhbmRsZSlcclxuICAgICAgICAvLyAgICAgKTtcclxuICAgICAgICAvLyB9XHJcbiAgICAgICAgZ2wudXNlUHJvZ3JhbShoYW5kbGUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgdGhlIHByb2dyYW0gaXMgYm91bmQgdG8gdGhlIFdlYkdMIGNvbnRleHQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBwcm9ncmFtIGlmIGN1cnJlbnRseSBib3VuZCB0byB0aGUgV2ViR0wgY29udGV4dCBhbmRcclxuICAgICAqICAgICAgYGZhbHNlYCBvdGhlcndpc2UuXHJcbiAgICAgKi9cclxuICAgIGlzQm91bmQoKSB7XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcclxuICAgICAgICByZXR1cm4gZ2wuZ2V0UGFyYW1ldGVyKGdsLkNVUlJFTlRfUFJPR1JBTSkgPT09IHRoaXMuX2hhbmRsZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBhbiBpbnRlZ2VyIHNjYWxhciB2YWx1ZSB0byBhIHVuaWZvcm0uIElmIHRoZXJlJ3Mgbm8gdW5pZm9ybSB3aXRoXHJcbiAgICAgKiBnaXZlbiBuYW1lIGluIHRoZSBwcm9ncmFtLCBzaWxlbnRseSBkb2VzIG5vdGhpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHVuaWZvcm1OYW1lIE5hbWUgb2YgdGhlIHVuaWZvcm0uXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHNjYWxhciB2YWx1ZS5cclxuICAgICAqL1xyXG4gICAgc2V0SW50U2NhbGFyVW5pZm9ybSh1bmlmb3JtTmFtZSwgdmFsdWUpIHtcclxuICAgICAgICBjb25zdCBsb2NhdGlvbiA9IHRoaXMuX2dldFVuaWZvcm1Mb2NhdGlvbih1bmlmb3JtTmFtZSk7XHJcbiAgICAgICAgaWYgKGxvY2F0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsLnVuaWZvcm0xaShsb2NhdGlvbiwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBhIHNjYWxhciB2YWx1ZSB0byBhIHVuaWZvcm0uIElmIHRoZXJlJ3Mgbm8gdW5pZm9ybSB3aXRoXHJcbiAgICAgKiBnaXZlbiBuYW1lIGluIHRoZSBwcm9ncmFtLCBzaWxlbnRseSBkb2VzIG5vdGhpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHVuaWZvcm1OYW1lIE5hbWUgb2YgdGhlIHVuaWZvcm0uXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHNjYWxhciB2YWx1ZS5cclxuICAgICAqL1xyXG4gICAgc2V0U2NhbGFyVW5pZm9ybSh1bmlmb3JtTmFtZSwgdmFsdWUpIHtcclxuICAgICAgICBjb25zdCBsb2NhdGlvbiA9IHRoaXMuX2dldFVuaWZvcm1Mb2NhdGlvbih1bmlmb3JtTmFtZSk7XHJcbiAgICAgICAgaWYgKGxvY2F0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsLnVuaWZvcm0xZihsb2NhdGlvbiwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBhIDJEIHZlY3RvciB0byBhIHVuaWZvcm0uIElmIHRoZXJlJ3Mgbm8gdW5pZm9ybSB3aXRoIGdpdmVuIG5hbWUgaW5cclxuICAgICAqIHRoZSBwcm9ncmFtLCBzaWxlbnRseSBkb2VzIG5vdGhpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHVuaWZvcm1OYW1lIE5hbWUgb2YgdGhlIHVuaWZvcm0uXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZlY3Rvci5cclxuICAgICAqL1xyXG4gICAgc2V0VmVjdG9yMlVuaWZvcm0odW5pZm9ybU5hbWUsIHZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgbG9jYXRpb24gPSB0aGlzLl9nZXRVbmlmb3JtTG9jYXRpb24odW5pZm9ybU5hbWUpO1xyXG4gICAgICAgIGlmIChsb2NhdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLl9nbC51bmlmb3JtMmYobG9jYXRpb24sIHZhbHVlLngsIHZhbHVlLnkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBhIDNEIHZlY3RvciB0byBhIHVuaWZvcm0uIElmIHRoZXJlJ3Mgbm8gdW5pZm9ybSB3aXRoIGdpdmVuIG5hbWUgaW5cclxuICAgICAqIHRoZSBwcm9ncmFtLCBzaWxlbnRseSBkb2VzIG5vdGhpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHVuaWZvcm1OYW1lIE5hbWUgb2YgdGhlIHVuaWZvcm0uXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZlY3Rvci5cclxuICAgICAqL1xyXG4gICAgc2V0VmVjdG9yM1VuaWZvcm0odW5pZm9ybU5hbWUsIHZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgbG9jYXRpb24gPSB0aGlzLl9nZXRVbmlmb3JtTG9jYXRpb24odW5pZm9ybU5hbWUpO1xyXG4gICAgICAgIGlmIChsb2NhdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLl9nbC51bmlmb3JtM2YobG9jYXRpb24sIHZhbHVlLngsIHZhbHVlLnksIHZhbHVlLnopO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBhIDREIHZlY3RvciB0byBhIHVuaWZvcm0uIElmIHRoZXJlJ3Mgbm8gdW5pZm9ybSB3aXRoIGdpdmVuIG5hbWUgaW5cclxuICAgICAqIHRoZSBwcm9ncmFtLCBzaWxlbnRseSBkb2VzIG5vdGhpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHVuaWZvcm1OYW1lIE5hbWUgb2YgdGhlIHVuaWZvcm0uXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZlY3Rvci5cclxuICAgICAqL1xyXG4gICAgc2V0VmVjdG9yNFVuaWZvcm0odW5pZm9ybU5hbWUsIHZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgbG9jYXRpb24gPSB0aGlzLl9nZXRVbmlmb3JtTG9jYXRpb24odW5pZm9ybU5hbWUpO1xyXG4gICAgICAgIGlmIChsb2NhdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLl9nbC51bmlmb3JtNGYobG9jYXRpb24sIHZhbHVlLngsIHZhbHVlLnksIHZhbHVlLnosIHZhbHVlLncpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBhIGNvbG9yIHRvIGEgdW5pZm9ybS4gSWYgdGhlcmUncyBubyB1bmlmb3JtIHdpdGggZ2l2ZW4gbmFtZSBpbiB0aGVcclxuICAgICAqIHByb2dyYW0sIHNpbGVudGx5IGRvZXMgbm90aGluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdW5pZm9ybU5hbWUgTmFtZSBvZiB0aGUgdW5pZm9ybS5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgY29sb3IuXHJcbiAgICAgKi9cclxuICAgIHNldENvbG9yVW5pZm9ybSh1bmlmb3JtTmFtZSwgdmFsdWUpIHtcclxuICAgICAgICBjb25zdCBsb2NhdGlvbiA9IHRoaXMuX2dldFVuaWZvcm1Mb2NhdGlvbih1bmlmb3JtTmFtZSk7XHJcbiAgICAgICAgaWYgKGxvY2F0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsLnVuaWZvcm00Zihsb2NhdGlvbiwgdmFsdWUuciwgdmFsdWUuZywgdmFsdWUuYiwgdmFsdWUuYSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIGEgM3gzIG1hdHJpeCB0byBhIHVuaWZvcm0uIElmIHRoZXJlJ3Mgbm8gdW5pZm9ybSB3aXRoIGdpdmVuIG5hbWUgaW5cclxuICAgICAqIHRoZSBwcm9ncmFtLCBzaWxlbnRseSBkb2VzIG5vdGhpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHVuaWZvcm1OYW1lIE5hbWUgb2YgdGhlIHVuaWZvcm0uXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIG1hdHJpeC5cclxuICAgICAqL1xyXG4gICAgc2V0TWF0cml4M1VuaWZvcm0odW5pZm9ybU5hbWUsIHZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgbG9jYXRpb24gPSB0aGlzLl9nZXRVbmlmb3JtTG9jYXRpb24odW5pZm9ybU5hbWUpO1xyXG4gICAgICAgIGlmIChsb2NhdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLl9nbC51bmlmb3JtTWF0cml4M2Z2KGxvY2F0aW9uLCBmYWxzZSwgdmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBhIDR4NCBtYXRyaXggdG8gYSB1bmlmb3JtLiBJZiB0aGVyZSdzIG5vIHVuaWZvcm0gd2l0aCBnaXZlbiBuYW1lIGluXHJcbiAgICAgKiB0aGUgcHJvZ3JhbSwgc2lsZW50bHkgZG9lcyBub3RoaW5nLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB1bmlmb3JtTmFtZSBOYW1lIG9mIHRoZSB1bmlmb3JtLlxyXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSBtYXRyaXguXHJcbiAgICAgKi9cclxuICAgIHNldE1hdHJpeDRVbmlmb3JtKHVuaWZvcm1OYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IGxvY2F0aW9uID0gdGhpcy5fZ2V0VW5pZm9ybUxvY2F0aW9uKHVuaWZvcm1OYW1lKTtcclxuICAgICAgICBpZiAobG9jYXRpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5fZ2wudW5pZm9ybU1hdHJpeDRmdihsb2NhdGlvbiwgZmFsc2UsIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERlc3Ryb3lzIHRoZSBwcm9ncmFtLlxyXG4gICAgICovXHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMuX2dsLmRlbGV0ZVByb2dyYW0odGhpcy5faGFuZGxlKTtcclxuICAgIH1cclxuICAgIF9nZXRVbmlmb3JtTG9jYXRpb24obmFtZSkge1xyXG4gICAgICAgIGNvbnN0IGNhY2hlID0gdGhpcy5fdW5pZm9ybUNhY2hlO1xyXG4gICAgICAgIGxldCBsb2NhdGlvbiA9IGNhY2hlLmdldChuYW1lKTtcclxuICAgICAgICBpZiAoIWxvY2F0aW9uKSB7XHJcbiAgICAgICAgICAgIGxvY2F0aW9uID0gdGhpcy5fZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX2hhbmRsZSwgbmFtZSk7XHJcbiAgICAgICAgICAgIGlmICghbG9jYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE8gVW5jb21tZW50IGFuZCBwdXQgdW5kZXIgZGVidWcgZmxhZyAod2hlbiBpbXBsZW1lbnRlZClcclxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybihgVW5pZm9ybSAke25hbWV9IGRvZXNuJ3QgZXhpc3QgaW4gcHJvZ3JhbS5gKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhY2hlLnNldChuYW1lLCBsb2NhdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBsb2NhdGlvbjtcclxuICAgIH1cclxufVxyXG4iLCIvKiogV3JhcHBlciBhcm91bmQgV2ViR0xSZW5kZXJidWZmZXIgb2JqZWN0cy4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVuZGVyYnVmZmVyIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyByZW5kZXJidWZmZXIgaW4gYSBXZWJHTCBjb250ZXh0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBnbCBUaGUgY29udGV4dCB0aGUgcmVuZGVyYnVmZmVyIHdpbGwgYmUgY3JlYXRlZCBpbi5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZ2wsIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICB0aGlzLl9nbCA9IGdsO1xyXG4gICAgICAgIHRoaXMuX2hhbmRsZSA9IGdsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xyXG4gICAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBCaW5kcyB0aGUgcmVuZGVyYnVmZmVyIHRvIHRoZSBXZWJHTCBjb250ZXh0LlxyXG4gICAgICovXHJcbiAgICBiaW5kKCkge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XHJcbiAgICAgICAgZ2wuYmluZFJlbmRlcmJ1ZmZlcihnbC5SRU5ERVJCVUZGRVIsIHRoaXMuX2hhbmRsZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyBpZiB0aGUgcmVuZGVyYnVmZmVyIGlzIGJvdW5kIHRvIHRoZSBXZWJHTCBjb250ZXh0LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVuZGVyYnVmZmVyIGlzIGN1cnJlbnRseSBib3VuZCB0byB0aGUgV2ViR0wgY29udGV4dFxyXG4gICAgICogICAgICBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXHJcbiAgICAgKi9cclxuICAgIGlzQm91bmQoKSB7XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcclxuICAgICAgICByZXR1cm4gZ2wuZ2V0UGFyYW1ldGVyKGdsLlJFTkRFUkJVRkZFUl9CSU5ESU5HKSA9PT0gdGhpcy5faGFuZGxlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBdHRhY2hlcyB0aGUgcmVuZGVyYnVmZmVyIHRvIGEgY3VycmVudGx5IGJvdW5kIHRvIHRoZSBXZWJHTCBjb250ZXh0XHJcbiAgICAgKiBmcmFtZWJ1ZmZlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYXR0YWNobWVudFBvaW50IEF0dGFjaG1lbnQgcG9pbnQgdGhlIHJlbmRlcmJ1ZmZlciB3aWxsIGJlIGF0dGFjaGVkXHJcbiAgICAgKiAgICAgIHRvLlxyXG4gICAgICovXHJcbiAgICBhdHRhY2hUb0ZyYW1lYnVmZmVyKGF0dGFjaG1lbnRQb2ludCkge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XHJcbiAgICAgICAgZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGF0dGFjaG1lbnRQb2ludCwgZ2wuUkVOREVSQlVGRkVSLCB0aGlzLl9oYW5kbGUpO1xyXG4gICAgfVxyXG4gICAgZ2V0V2lkdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dpZHRoO1xyXG4gICAgfVxyXG4gICAgZ2V0SGVpZ2h0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERlc3Ryb3lzIHRoZSByZW5kZXJidWZmZXIuXHJcbiAgICAgKi9cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5fZ2wuZGVsZXRlUmVuZGVyYnVmZmVyKHRoaXMuX2hhbmRsZSk7XHJcbiAgICB9XHJcbn1cclxuIiwiLy8gdHNsaW50OmRpc2FibGVcclxuLypcclxuICAgIFRoaXMgaXMgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgYnkgL3Rvb2xzL2dsX2dlbi9nZW5fY2FwYWJpbGl0aWVzLmpzIHNjcmlwdC5cclxuICAgIEluc3RlYWQgb2YgbW9kaWZ5aW5nIGl0IGVkaXQgdGhlIHNjcmlwdCBhbmQgcmVnZW5lcmF0ZSB0aGlzIGZpbGUuXHJcbiovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbmRlckNvbnRleHRDYXBhYmlsaXRpZXNNYW5hZ2VyIHtcclxuICAgIGNvbnN0cnVjdG9yKGdsKSB7XHJcbiAgICAgICAgdGhpcy5fZ2wgPSBnbDtcclxuICAgICAgICB0aGlzLl9wYXJhbVZhbHVlcyA9IG5ldyBNYXAoKTtcclxuICAgIH1cclxuICAgIGdldEFsaWFzZWRMaW5lV2lkdGhSYW5nZSgpIHsgcmV0dXJuIHRoaXMuX2dldFBhcmFtKDMzOTAyIC8qIEFMSUFTRURfTElORV9XSURUSF9SQU5HRSAqLyk7IH1cclxuICAgIGdldEFsaWFzZWRQb2ludFNpemVSYW5nZSgpIHsgcmV0dXJuIHRoaXMuX2dldFBhcmFtKDMzOTAxIC8qIEFMSUFTRURfUE9JTlRfU0laRV9SQU5HRSAqLyk7IH1cclxuICAgIGdldE1heENvbWJpbmVkVGV4dHVyZUltYWdlVW5pdHMoKSB7IHJldHVybiB0aGlzLl9nZXRQYXJhbSgzNTY2MSAvKiBNQVhfQ09NQklORURfVEVYVFVSRV9JTUFHRV9VTklUUyAqLyk7IH1cclxuICAgIGdldE1heEN1YmVNYXBUZXh0dXJlU2l6ZSgpIHsgcmV0dXJuIHRoaXMuX2dldFBhcmFtKDM0MDc2IC8qIE1BWF9DVUJFX01BUF9URVhUVVJFX1NJWkUgKi8pOyB9XHJcbiAgICBnZXRNYXhGcmFnbWVudFVuaWZvcm1WZWN0b3JzKCkgeyByZXR1cm4gdGhpcy5fZ2V0UGFyYW0oMzYzNDkgLyogTUFYX0ZSQUdNRU5UX1VOSUZPUk1fVkVDVE9SUyAqLyk7IH1cclxuICAgIGdldE1heFJlbmRlcmJ1ZmZlclNpemUoKSB7IHJldHVybiB0aGlzLl9nZXRQYXJhbSgzNDAyNCAvKiBNQVhfUkVOREVSQlVGRkVSX1NJWkUgKi8pOyB9XHJcbiAgICBnZXRNYXhUZXh0dXJlSW1hZ2VVbml0cygpIHsgcmV0dXJuIHRoaXMuX2dldFBhcmFtKDM0OTMwIC8qIE1BWF9URVhUVVJFX0lNQUdFX1VOSVRTICovKTsgfVxyXG4gICAgZ2V0TWF4VGV4dHVyZVNpemUoKSB7IHJldHVybiB0aGlzLl9nZXRQYXJhbSgzMzc5IC8qIE1BWF9URVhUVVJFX1NJWkUgKi8pOyB9XHJcbiAgICBnZXRNYXhWYXJ5aW5nVmVjdG9ycygpIHsgcmV0dXJuIHRoaXMuX2dldFBhcmFtKDM2MzQ4IC8qIE1BWF9WQVJZSU5HX1ZFQ1RPUlMgKi8pOyB9XHJcbiAgICBnZXRNYXhWZXJ0ZXhBdHRyaWJzKCkgeyByZXR1cm4gdGhpcy5fZ2V0UGFyYW0oMzQ5MjEgLyogTUFYX1ZFUlRFWF9BVFRSSUJTICovKTsgfVxyXG4gICAgZ2V0TWF4VmVydGV4VGV4dHVyZUltYWdlVW5pdHMoKSB7IHJldHVybiB0aGlzLl9nZXRQYXJhbSgzNTY2MCAvKiBNQVhfVkVSVEVYX1RFWFRVUkVfSU1BR0VfVU5JVFMgKi8pOyB9XHJcbiAgICBnZXRNYXhWZXJ0ZXhVbmlmb3JtVmVjdG9ycygpIHsgcmV0dXJuIHRoaXMuX2dldFBhcmFtKDM2MzQ3IC8qIE1BWF9WRVJURVhfVU5JRk9STV9WRUNUT1JTICovKTsgfVxyXG4gICAgZ2V0TWF4Vmlld3BvcnREaW1zKCkgeyByZXR1cm4gdGhpcy5fZ2V0UGFyYW0oMzM4NiAvKiBNQVhfVklFV1BPUlRfRElNUyAqLyk7IH1cclxuICAgIGdldFJlbmRlcmVyKCkgeyByZXR1cm4gdGhpcy5fZ2V0UGFyYW0oNzkzNyAvKiBSRU5ERVJFUiAqLyk7IH1cclxuICAgIGdldFN1YnBpeGVsQml0cygpIHsgcmV0dXJuIHRoaXMuX2dldFBhcmFtKDM0MDggLyogU1VCUElYRUxfQklUUyAqLyk7IH1cclxuICAgIGdldFZlbmRvcigpIHsgcmV0dXJuIHRoaXMuX2dldFBhcmFtKDc5MzYgLyogVkVORE9SICovKTsgfVxyXG4gICAgZ2V0VmVyc2lvbigpIHsgcmV0dXJuIHRoaXMuX2dldFBhcmFtKDc5MzggLyogVkVSU0lPTiAqLyk7IH1cclxuICAgIC8qKiBDYWxsaW5nIHRoaXMgbWV0aG9kIHcvbyBgV0VCR0xfZGVidWdfcmVuZGVyZXJfaW5mb2AgZW5hYmxlZCB3aWxsIHJldHVybiBgbnVsbGAhICovXHJcbiAgICBnZXRVbm1hc2tlZFZlbmRvcigpIHsgcmV0dXJuIHRoaXMuX2dldFBhcmFtKDM3NDQ1IC8qIFVOTUFTS0VEX1ZFTkRPUiAqLyk7IH1cclxuICAgIC8qKiBDYWxsaW5nIHRoaXMgbWV0aG9kIHcvbyBgV0VCR0xfZGVidWdfcmVuZGVyZXJfaW5mb2AgZW5hYmxlZCB3aWxsIHJldHVybiBgbnVsbGAhICovXHJcbiAgICBnZXRVbm1hc2tlZFJlbmRlcmVyKCkgeyByZXR1cm4gdGhpcy5fZ2V0UGFyYW0oMzc0NDYgLyogVU5NQVNLRURfUkVOREVSRVIgKi8pOyB9XHJcbiAgICBfZ2V0UGFyYW0ocGFyYW0pIHtcclxuICAgICAgICBjb25zdCBwYXJhbVZhbHVlcyA9IHRoaXMuX3BhcmFtVmFsdWVzO1xyXG4gICAgICAgIGxldCBwYXJhbVZhbHVlID0gcGFyYW1WYWx1ZXMuZ2V0KHBhcmFtKTtcclxuICAgICAgICBpZiAoIXBhcmFtVmFsdWUpIHtcclxuICAgICAgICAgICAgcGFyYW1WYWx1ZSA9IHRoaXMuX2dsLmdldFBhcmFtZXRlcihwYXJhbSk7XHJcbiAgICAgICAgICAgIHBhcmFtVmFsdWVzLnNldChwYXJhbSwgcGFyYW1WYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwYXJhbVZhbHVlO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCAqIGFzIGNvbG9yIGZyb20gJy4uL3V0aWwvY29sb3InO1xyXG4vKipcclxuICogUHJlc2V0IG9mIHJlbmRlciBzdGF0ZSBmb3IgT1ZFUiBjb21wb3NpdGluZyxcclxuICogQHNlZSBULiBQb3J0ZXIgYW5kIFQuIER1ZmYsIFwiQ29tcG9zaXRpbmcgRGlnaXRhbCBJbWFnZXNcIiwgUHJvY2VlZGluZ3Mgb2ZcclxuICogICAgICBTSUdHUkFQSCc4NCwgMTggKDE5ODQpLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IEJMRU5EX09WRVJfUkVOREVSX1NUQVRFID0ge1xyXG4gICAgYmxlbmQ6IHRydWUsXHJcbiAgICBibGVuZEZ1bmNTcmNSZ2I6IDc3MCAvKiBTUkNfQUxQSEEgKi8sXHJcbiAgICBibGVuZEZ1bmNEc3RSZ2I6IDc3MSAvKiBPTkVfTUlOVVNfU1JDX0FMUEhBICovLFxyXG4gICAgYmxlbmRGdW5jU3JjQWxwaGE6IDEgLyogT05FICovLFxyXG4gICAgYmxlbmRGdW5jRHN0QWxwaGE6IDc3MSAvKiBPTkVfTUlOVVNfU1JDX0FMUEhBICovXHJcbn07XHJcbmV4cG9ydCBjb25zdCBCTEVORF9PVkVSX1BSRU1VTFRJUExJRURfQUxQSEFfUkVOREVSX1NUQVRFID0ge1xyXG4gICAgYmxlbmQ6IHRydWUsXHJcbiAgICBibGVuZEZ1bmNTcmNSZ2I6IDEgLyogT05FICovLFxyXG4gICAgYmxlbmRGdW5jRHN0UmdiOiA3NzEgLyogT05FX01JTlVTX1NSQ19BTFBIQSAqLyxcclxuICAgIGJsZW5kRnVuY1NyY0FscGhhOiAxIC8qIE9ORSAqLyxcclxuICAgIGJsZW5kRnVuY0RzdEFscGhhOiA3NzEgLyogT05FX01JTlVTX1NSQ19BTFBIQSAqL1xyXG59O1xyXG4vKipcclxuICogU3RhdGUgb2YgdGhlIFdlYkdMIHJlbmRlcmluZyBwaXBlbGluZS4gRG9lc24ndCBpbmNsdWRlIG9iamVjdCBiaW5kaW5ncyBzaW5jZVxyXG4gKiB0aGUgY29udGV4dCBoYW5kbGVzIHRoZW0uXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW5kZXJTdGF0ZSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgcmVuZGVyIHN0YXRlIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3RhdGUgT2JqZWN0IHdpdGggc3RhdGUgcHJvcGVydGllcyB0aGF0IHZhbHVlcyBkaWZmZXIgZnJvbSBkZWZhdWx0XHJcbiAgICAgKiAgICAgIG9uZXMuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKC4uLnN0YXRlKSB7XHJcbiAgICAgICAgdGhpcy5jbGVhckNvbG9yID0gY29sb3IuY3JlYXRlKDAsIDAsIDAsIDApO1xyXG4gICAgICAgIHRoaXMuY2xlYXJEZXB0aCA9IDE7XHJcbiAgICAgICAgdGhpcy5jbGVhclN0ZW5jaWwgPSAwO1xyXG4gICAgICAgIHRoaXMuY29sb3JNYXNrUiA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5jb2xvck1hc2tHID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmNvbG9yTWFza0IgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuY29sb3JNYXNrQWxwaGEgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuYmxlbmQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmJsZW5kRXF1YXRpb25SZ2IgPSAzMjc3NCAvKiBBREQgKi87XHJcbiAgICAgICAgdGhpcy5ibGVuZEVxdWF0aW9uQWxwaGEgPSAzMjc3NCAvKiBBREQgKi87XHJcbiAgICAgICAgdGhpcy5ibGVuZEZ1bmNTcmNSZ2IgPSAxIC8qIE9ORSAqLztcclxuICAgICAgICB0aGlzLmJsZW5kRnVuY0RzdFJnYiA9IDAgLyogWkVSTyAqLztcclxuICAgICAgICB0aGlzLmJsZW5kRnVuY1NyY0FscGhhID0gMSAvKiBPTkUgKi87XHJcbiAgICAgICAgdGhpcy5ibGVuZEZ1bmNEc3RBbHBoYSA9IDAgLyogWkVSTyAqLztcclxuICAgICAgICB0aGlzLmN1bGxGYWNlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5jdWxsRmFjZU1vZGUgPSAxMDI5IC8qIEJBQ0sgKi87XHJcbiAgICAgICAgdGhpcy5mcm9udEZhY2VNb2RlID0gMjMwNSAvKiBDT1VOVEVSQ0xPQ0tXSVNFICovO1xyXG4gICAgICAgIHRoaXMuZGVwdGhUZXN0ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5kZXB0aEZ1bmMgPSA1MTMgLyogTEVTUyAqLztcclxuICAgICAgICB0aGlzLmRlcHRoUmFuZ2VOZWFyID0gMDtcclxuICAgICAgICB0aGlzLmRlcHRoUmFuZ2VGYXIgPSAxO1xyXG4gICAgICAgIHRoaXMuZGVwdGhNYXNrID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmRpdGhlciA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5kcmF3QnVmZmVycyA9IFszNjA2NCAvKiBDT0xPUl9BVFRBQ0hNRU5UMCAqL107XHJcbiAgICAgICAgdGhpcy5wb2x5Z29uT2Zmc2V0ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5wb2x5Z29uT2Zmc2V0RmFjdG9yID0gMDtcclxuICAgICAgICB0aGlzLnBvbHlnb25PZmZzZXRVbml0cyA9IDA7XHJcbiAgICAgICAgdGhpcy5zYW1wbGVBbHBoYVRvQ292ZXJhZ2UgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnNhbXBsZUNvdmVyYWdlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5zYW1wbGVDb3ZlcmFnZVZhbHVlID0gMTtcclxuICAgICAgICB0aGlzLnNhbXBsZUNvdmVyYWdlSW52ZXJ0ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5zY2lzc29yVGVzdCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuc2Npc3NvclggPSAwO1xyXG4gICAgICAgIHRoaXMuc2Npc3NvclkgPSAwO1xyXG4gICAgICAgIC8vIEFjdHVhbCBkZWZhdWx0cyBhcmVuJ3Qga25vd24gaGVyZSBzaW5jZSB0aGV5IGRlcGVuZCB1cG9uIGNvbnRleHQuIC0xJ3NcclxuICAgICAgICAvLyBhcyBcImRvIG5vdCBjaGFuZ2VcIiB2YWx1ZXMuXHJcbiAgICAgICAgdGhpcy5zY2lzc29yV2lkdGggPSAtMTtcclxuICAgICAgICB0aGlzLnNjaXNzb3JIZWlnaHQgPSAtMTtcclxuICAgICAgICB0aGlzLnN0ZW5jaWxUZXN0ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5zdGVuY2lsUmVmZXJlbmNlID0gMDtcclxuICAgICAgICB0aGlzLnN0ZW5jaWxNYXNrID0gMHhmZjtcclxuICAgICAgICB0aGlzLnN0ZW5jaWxXcml0ZU1hc2sgPSAweGZmO1xyXG4gICAgICAgIHRoaXMuc3RlbmNpbEZyb250RnVuYyA9IDUxOSAvKiBBTFdBWVMgKi87XHJcbiAgICAgICAgdGhpcy5zdGVuY2lsRnJvbnRGYWlsT3AgPSA3NjgwIC8qIEtFRVAgKi87XHJcbiAgICAgICAgdGhpcy5zdGVuY2lsRnJvbnREZXB0aEZhaWxPcCA9IDc2ODAgLyogS0VFUCAqLztcclxuICAgICAgICB0aGlzLnN0ZW5jaWxGcm9udERlcHRoUGFzc09wID0gNzY4MCAvKiBLRUVQICovO1xyXG4gICAgICAgIHRoaXMuc3RlbmNpbEJhY2tGdW5jID0gNTE5IC8qIEFMV0FZUyAqLztcclxuICAgICAgICB0aGlzLnN0ZW5jaWxCYWNrRmFpbE9wID0gNzY4MCAvKiBLRUVQICovO1xyXG4gICAgICAgIHRoaXMuc3RlbmNpbEJhY2tEZXB0aEZhaWxPcCA9IDc2ODAgLyogS0VFUCAqLztcclxuICAgICAgICB0aGlzLnN0ZW5jaWxCYWNrRGVwdGhQYXNzT3AgPSA3NjgwIC8qIEtFRVAgKi87XHJcbiAgICAgICAgdGhpcy52aWV3cG9ydFggPSAwO1xyXG4gICAgICAgIHRoaXMudmlld3BvcnRZID0gMDtcclxuICAgICAgICAvLyBBY3R1YWwgZGVmYXVsdHMgYXJlbid0IGtub3duIGhlcmUgc2luY2UgdGhleSBkZXBlbmQgdXBvbiBjb250ZXh0LiAtMSdzXHJcbiAgICAgICAgLy8gYXMgXCJkbyBub3QgY2hhbmdlXCIgdmFsdWVzLlxyXG4gICAgICAgIHRoaXMudmlld3BvcnRXaWR0aCA9IC0xO1xyXG4gICAgICAgIHRoaXMudmlld3BvcnRIZWlnaHQgPSAtMTtcclxuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIC4uLnN0YXRlKTtcclxuICAgIH1cclxufVxyXG4iLCJleHBvcnQgY29uc3QgT1BBUVVFX0JMQUNLID0gY3JlYXRlKDAsIDAsIDAsIDEpO1xyXG5leHBvcnQgY29uc3QgVFJBTlNQQVJFTlRfQkxBQ0sgPSBjcmVhdGUoMCwgMCwgMCwgMCk7XHJcbi8qKlxyXG4gKiBAcGFyYW0gciBSZWQgY29tcG9uZW50IGFzIGEgbm9ybWFsaXplZCB2YWx1ZSBbMC4uMV1cclxuICogQHBhcmFtIGcgR3JlZW4gY29tcG9uZW50IGFzIGEgbm9ybWFsaXplZCB2YWx1ZSBbMC4uMV1cclxuICogQHBhcmFtIGIgQmx1ZSBjb21wb25lbnQgYXMgYSBub3JtYWxpemVkIHZhbHVlIFswLi4xXVxyXG4gKiBAcGFyYW0gYSBBbHBoYSBjb21wb25lbnQgYXMgYSBub3JtYWxpemVkIHZhbHVlIFswLi4xXVxyXG4gKlxyXG4gKiBAcmV0dXJucyBBIGNvbG9yIHdpdGggZ2l2ZW4gdmFsdWVzIGFzc2lnbmVkIHRvIGNvbXBvbmVudHMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKHIsIGcsIGIsIGEgPSAxKSB7XHJcbiAgICByZXR1cm4geyByLCBnLCBiLCBhIH07XHJcbn1cclxuLyoqXHJcbiAqIENvcGllcyBhIGNvbG9yIHRvIGFub3RoZXIgb25lLlxyXG4gKlxyXG4gKiBAcGFyYW0gc3JjIFRoZSBzb3VyY2UgY29sb3IuXHJcbiAqIEBwYXJhbSBkc3QgVGhlIGNvbG9yIHRoZSBzb3VyY2UgY29sb3Igd2lsbCBiZSBjb3BpZWQgdG8uXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvcHkoc3JjLCBkc3QgPSBjcmVhdGUoMCwgMCwgMCwgMCkpIHtcclxuICAgIGRzdC5yID0gc3JjLnI7XHJcbiAgICBkc3QuZyA9IHNyYy5nO1xyXG4gICAgZHN0LmIgPSBzcmMuYjtcclxuICAgIGRzdC5hID0gc3JjLmE7XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBhcmVFcXVhbChjMSwgYzIpIHtcclxuICAgIHJldHVybiBjMS5yID09PSBjMi5yICYmIGMxLmcgPT09IGMyLmcgJiYgYzEuYiA9PT0gYzIuYiAmJiBjMS5hID09PSBjMi5hO1xyXG59XHJcbi8qKlxyXG4gKiBEZWNvZGVzIGEgY29sb3IgcmVwcmVzZW50ZWQgYXMgZm91ciA4LWJpdCBjaGFubmVscyBlbmNvZGVkIGludG8gYSAzMi1iaXRcclxuICogbnVtYmVyIGluIEFCR1Igb3JkZXIgKGZyb20gTVNCIHRvIExTQikuXHJcbiAqXHJcbiAqIEBwYXJhbSBjb2xvciBDb2xvciBlbmNvZGVkIGludG8gdW5zaWduZWQgMzItYml0IGludGVnZXIuXHJcbiAqIEByZXR1cm5zIERlY29kZWQgY29sb3IuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlQWJncjgoY29sb3IpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcjogKGNvbG9yID4+PiAyNCkgLyAweGZmLFxyXG4gICAgICAgIGc6IChjb2xvciA+Pj4gMTYgJiAweGZmKSAvIDB4ZmYsXHJcbiAgICAgICAgYjogKGNvbG9yID4+PiA4ICYgMHhmZikgLyAweGZmLFxyXG4gICAgICAgIGE6IChjb2xvciAmIDB4ZmYpIC8gMHhmZlxyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogRW5jb2RlcyBhIGNvbG9yIGNvbXBvbmVudHMgaW50byBmb3VyIDggYml0IG51bWJlcnMgcGFja2VkIGludG8gMzItYml0IG9uZS5cclxuICpcclxuICogQHBhcmFtIGMgVGhlIGNvbG9yIHRvIGJlIGVuY29kZWQuXHJcbiAqIEByZXR1cm5zIFRoZSBjb2xvciBhcyAzMi1iaXQgaW50ZWdlci5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVSZ2JhOChjKSB7XHJcbiAgICByZXR1cm4gKGMuciAqIDB4ZmYgfFxyXG4gICAgICAgIChjLmcgKiAweGZmIDw8IDgpIHxcclxuICAgICAgICAoYy5iICogMHhmZiA8PCAxNikgfFxyXG4gICAgICAgIChjLmEgKiAweGZmIDw8IDI0KSk7XHJcbn1cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBhIGNvbG9yIGlzIGNvbXBsZXRlbHkgb3BhcXVlLlxyXG4gKlxyXG4gKiBAcGFyYW0gY29sb3IgVGhlIGNvbG9yIHRvIGJlIGNoZWNrZWQuXHJcbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgY29sb3IgaXMgb3BhcXVlIGFuZCBgZmFsc2VgIG90aGVyd2lzZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc09wYXF1ZShjb2xvcikge1xyXG4gICAgcmV0dXJuIGNvbG9yLmEgPT09IDE7XHJcbn1cclxuIiwiLyoqXHJcbiAqIE91ciBkZWZhdWx0cyBmb3IgdGV4dHVyZXMgYXJlIGRpZmZlcmVudCBmcm9tIG9uZXMgaW4gV2ViR0wgZm9yIHR3byByZWFzb25zOlxyXG4gKiAxLiBkZWZhdWx0IG1pbmlmaWNhdGlvbiBmaWx0ZXIgaW4gV2ViR0wgaXMgTkVBUkVTVF9NSVBNQVBfTElORUFSIHdoaWNoIHJlcXVpcmVzXHJcbiAqICAgIHRleHR1cmUgdG8gaGF2ZSBhbGwgbWlwIGxldmVscyBzcGVjaWZpZWQ7XHJcbiAqIDIuIGRlZmF1bHQgd3JhcCBtb2RlcyBhcmUgUkVQRUFUIHdoaWNoIGlzbid0IHN1cHBvcnRlZCBmb3IgTlBPVCB0ZXh0dXJlcy5cclxuICovXHJcbmV4cG9ydCBjb25zdCBERUZBVUxUX1RFWFRVUkVfUEFSQU1TID0ge1xyXG4gICAgd3JhcFM6IDMzMDcxIC8qIENMQU1QX1RPX0VER0UgKi8sXHJcbiAgICB3cmFwVDogMzMwNzEgLyogQ0xBTVBfVE9fRURHRSAqLyxcclxuICAgIG1hZ25pZmljYXRpb25GaWx0ZXI6IDk3MjggLyogTkVBUkVTVCAqLyxcclxuICAgIG1pbmlmaWNhdGlvbkZpbHRlcjogOTcyOCAvKiBORUFSRVNUICovLFxyXG4gICAgcHJlbXVsdGlwbGllZEFscGhhOiBmYWxzZVxyXG59O1xyXG4vKiogV3JhcHBlciBhcm91bmQgV2ViR0xUZXh0dXJlIG9iamVjdHMuIEZvciBub3cgb25seSB3b3JrcyB3aXRoIDJEIHRleHR1cmVzLiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXh0dXJlIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyB0ZXh0dXJlIGluIGEgV2ViR0wgY29udGV4dC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZ2wgVGhlIGNvbnRleHQgdGhlIHRleHR1cmUgd2lsbCBiZSBjcmVhdGVkIGluLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihnbCwgd2lkdGgsIGhlaWdodCwgZm9ybWF0LCB0eXBlLCBwYXJhbXMgPSBERUZBVUxUX1RFWFRVUkVfUEFSQU1TKSB7XHJcbiAgICAgICAgdGhpcy5fZ2wgPSBnbDtcclxuICAgICAgICB0aGlzLl9mb3JtYXQgPSBmb3JtYXQ7XHJcbiAgICAgICAgdGhpcy5fdHlwZSA9IHR5cGU7XHJcbiAgICAgICAgdGhpcy5fcGFyYW1zID0gcGFyYW1zO1xyXG4gICAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMuX2hhbmRsZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcclxuICAgICAgICB0aGlzLmJpbmQoKTtcclxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBwYXJhbXMud3JhcFMpO1xyXG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIHBhcmFtcy53cmFwVCk7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIHBhcmFtcy5tYWduaWZpY2F0aW9uRmlsdGVyKTtcclxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgcGFyYW1zLm1pbmlmaWNhdGlvbkZpbHRlcik7XHJcbiAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBmb3JtYXQsIHdpZHRoLCBoZWlnaHQsIDAsIGZvcm1hdCwgdHlwZSwgbnVsbCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEJpbmRzIHRoZSB0ZXh0dXJlIHRvIHRoZSBXZWJHTCBjb250ZXh0IGFzIGEgMkQgdGV4dHVyZS5cclxuICAgICAqL1xyXG4gICAgYmluZCgpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xyXG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMuX2hhbmRsZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyBpZiB0aGUgdGV4dHVyZSBpcyBib3VuZCB0byB0aGUgV2ViR0wgY29udGV4dC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHRleHR1cmUgaXMgY3VycmVudGx5IGJvdW5kIHRvIHRoZSBXZWJHTCBjb250ZXh0XHJcbiAgICAgKiAgICAgIGFuZCBgZmFsc2VgIG90aGVyd2lzZS5cclxuICAgICAqL1xyXG4gICAgaXNCb3VuZCgpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xyXG4gICAgICAgIHJldHVybiBnbC5nZXRQYXJhbWV0ZXIoZ2wuVEVYVFVSRV9CSU5ESU5HXzJEKSA9PT0gdGhpcy5faGFuZGxlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBdHRhY2hlcyB0aGUgdGV4dHVyZSB0byBhIGN1cnJlbnRseSBib3VuZCB0byB0aGUgV2ViR0wgY29udGV4dCBmcmFtZWJ1ZmZlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYXR0YWNobWVudFBvaW50IEF0dGFjaG1lbnQgcG9pbnQgdGhlIHRleHR1cmUgd2lsbCBiZSBhdHRhY2hlZCB0by5cclxuICAgICAqL1xyXG4gICAgYXR0YWNoVG9GcmFtZWJ1ZmZlcihhdHRhY2htZW50UG9pbnQpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xyXG4gICAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBhdHRhY2htZW50UG9pbnQsIGdsLlRFWFRVUkVfMkQsIHRoaXMuX2hhbmRsZSwgMCk7XHJcbiAgICB9XHJcbiAgICAvKiogUmV0dXJucyB3aWR0aCBvZiB0aGUgdGV4dHVyZS4gKi9cclxuICAgIGdldFdpZHRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl93aWR0aDtcclxuICAgIH1cclxuICAgIC8qKiBSZXR1cm5zIGhlaWdodCBvZiB0aGUgdGV4dHVyZS4gKi9cclxuICAgIGdldEhlaWdodCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgLyoqIFJldHVybnMgcGl4ZWwgZm9ybWF0IG9mIHRoZSB0ZXh0dXJlLiAqL1xyXG4gICAgZ2V0Rm9ybWF0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9mb3JtYXQ7XHJcbiAgICB9XHJcbiAgICAvKiogUmV0dXJuIHBpeGVsIHR5cGUgb2YgdGhlIHRleHR1cmUuICovXHJcbiAgICBnZXRUeXBlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90eXBlO1xyXG4gICAgfVxyXG4gICAgLyoqIFJldHVybiBwYXJhbXMgb2YgdGhlIHRleHR1cmUuICovXHJcbiAgICBnZXRQYXJhbXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmFtcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGVzdHJveXMgdGhlIHRleHR1cmUuXHJcbiAgICAgKi9cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5fZ2wuZGVsZXRlVGV4dHVyZSh0aGlzLl9oYW5kbGUpO1xyXG4gICAgfVxyXG59XHJcbiIsIi8qKlxyXG4gKiBXcmFwcGVyIGFyb3VuZCB2ZXJ0ZXggYXJyYXkgKFZBTykgb2JqZWN0IGZyb20gYE9FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0YFxyXG4gKiBleHRlbnNpb24uXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWZXJ0ZXhBcnJheU9iamVjdCB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgbmV3IFZBTyBpbiBhIGdpdmVuIFdlYkdMIGNvbnRleHQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGdsIFRoZSBjb250ZXh0LlxyXG4gICAgICogQHBhcmFtIHZhb0V4dCBJbnN0YW5jZSBvZiBgT0VTX3ZlcnRleF9hcnJheV9vYmplY3RgIGV4dGVuc2lvbi5cclxuICAgICAqIEBwYXJhbSBhdHRyaWJ1dGVNYXBwaW5nIE1hcHBpbmcgb2YgYXR0cmlidXRlcy5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZ2wsIHZhb0V4dCwgYXR0cmlidXRlTWFwcGluZykge1xyXG4gICAgICAgIHRoaXMuX2dsID0gZ2w7XHJcbiAgICAgICAgdGhpcy5fdmFvRXh0ID0gdmFvRXh0O1xyXG4gICAgICAgIHRoaXMuX2hhbmRsZSA9IHZhb0V4dC5jcmVhdGVWZXJ0ZXhBcnJheU9FUygpO1xyXG4gICAgICAgIHRoaXMuYXR0cmlidXRlTWFwcGluZyA9IGF0dHJpYnV0ZU1hcHBpbmc7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEJpbmRzIHRoZSBWQU8gdG8gdGhlIGNvbnRleHQuXHJcbiAgICAgKi9cclxuICAgIGJpbmQoKSB7XHJcbiAgICAgICAgdGhpcy5fdmFvRXh0LmJpbmRWZXJ0ZXhBcnJheU9FUyh0aGlzLl9oYW5kbGUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgdGhlIFZBTyBpcyBjdXJyZW50bHkgYm91bmQgdG8gdGhlIGNvbnRleHQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBWQU8gaXMgY3VycmVudGx5IGJvdW5kIHRvIHRoZSBXZWJHTCBjb250ZXh0IGFuZFxyXG4gICAgICogICAgICBgZmFsc2VgIG90aGVyd2lzZS5cclxuICAgICAqL1xyXG4gICAgaXNCb3VuZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2wuZ2V0UGFyYW1ldGVyKHRoaXMuX3Zhb0V4dC5WRVJURVhfQVJSQVlfQklORElOR19PRVMpID09PVxyXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERlc3Ryb3lzIHRoZSBWQU8uXHJcbiAgICAgKi9cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5fdmFvRXh0LmRlbGV0ZVZlcnRleEFycmF5T0VTKHRoaXMuX2hhbmRsZSk7XHJcbiAgICB9XHJcbn1cclxuIiwiLyoqXHJcbiAqIFNpbXBsZSBwdWIvc3ViIGltcGxlbWVudGF0aW9uLiBUaGUgZW1pdHRlciBpcyBzdXBwb3NlZCB0byBlbWl0IG9ubHkgb25lIHR5cGUgb2YgZXZlbnQsXHJcbiAqIGlmIHNvbWVvbmUgaGFzIHRvIGVtaXQgZXZlbnRzIG9mIGRpZmZlcmVudCB0eXBlcywgbXVsdGlwbGUgZW1pdHRlcnMgc2hvdWxkIGJlIGNyZWF0ZWQuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgRXZlbnRFbWl0dGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IG5ldyBTZXQoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBsaXN0ZW5lci5cclxuICAgICAqL1xyXG4gICAgYWRkTGlzdGVuZXIobGlzdGVuZXIpIHtcclxuICAgICAgICB0aGlzLl9saXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBsaXN0ZW5lci5cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlTGlzdGVuZXIobGlzdGVuZXIpIHtcclxuICAgICAgICB0aGlzLl9saXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbHMgYWxsIHRoZSBhZGRlZCBsaXN0ZW5lcnMsIHRoZSBvcmRlciAoZS5nLiBvZiBhZGRpbmcpIGlzIG5vdCBndWFyYW50ZWVkLlxyXG4gICAgICovXHJcbiAgICBmaXJlKGRhdGEpIHtcclxuICAgICAgICB0aGlzLl9saXN0ZW5lcnMuZm9yRWFjaCgobGlzdGVuZXIpID0+IHtcclxuICAgICAgICAgICAgbGlzdGVuZXIoZGF0YSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEV2ZW50IGVtaXR0ZXIgd2l0aCBubyBwYXlsb2FkIGVtaXR0ZWQuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgVm9pZEV2ZW50RW1pdHRlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XHJcbiAgICBmaXJlKCkge1xyXG4gICAgICAgIHN1cGVyLmZpcmUodW5kZWZpbmVkKTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBjbGFtcCwgY3ljbGVSZXN0cmljdCB9IGZyb20gJy4vbWF0aC9zY2FsYXInO1xyXG5pbXBvcnQgeyBkZWcycmFkIH0gZnJvbSAnLi91dGlsL3JhZF9kZWcnO1xyXG5pbXBvcnQgZ2V0RnVsbE9wdGlvbnMgZnJvbSAnLi91dGlsL29wdGlvbnMnO1xyXG5pbXBvcnQgKiBhcyBtYXQ0IGZyb20gJy4vbWF0aC9tYXRyaXg0JztcclxuaW1wb3J0IHsgc21vb3RoU3RlcCB9IGZyb20gJy4vbWF0aC9zY2FsYXInO1xyXG5pbXBvcnQgKiBhcyB2ZWMyIGZyb20gJy4vbWF0aC92ZWN0b3IyJztcclxuaW1wb3J0ICogYXMgdmVjMyBmcm9tICcuL21hdGgvdmVjdG9yMyc7XHJcbmltcG9ydCB7IFZvaWRFdmVudEVtaXR0ZXIgfSBmcm9tICcuL3V0aWwvZXZlbnRfZW1pdHRlcic7XHJcbi8vIFRPRE8oZG1pa2lzKSBXZSB3YW50IHRvIGNvbnN0cmFpbnQgY29vcmRpbmF0ZXMgc28gdmlzaWJsZSByZWdpb24gZG9lc24ndCBleHRlbmRcclxuLy8gICAgICBvdXQgb2Ygd29ybGQgYm91bmRhcmllcy4gSG93ZXZlciwgaW4gY3VycmVudCBpbXBsZW1lbnRhdGlvbiBpdCBkb2Vzbid0XHJcbi8vICAgICAgd29yayBwcm9wZXJseSBmb3IgYXNwZWN0IHJhdGlvcyA+MSBvbiB6b29tIDAgc2luY2UgdmlzaWJsZSByZWdpb24gaXNcclxuLy8gICAgICBsYXJnZXIgdGhhdCB0aGUgd29ybGQgaXRzZWxmIChzbyB0aGVyZSdzIG5vIHdheSB0byBzcXVlZXplIGl0IGluKS4gRm9yXHJcbi8vICAgICAgdGhlIGN1cnJlbnQgY2FzZSAoaS5lLiBjeWNsZWQgaW4gaG9yaXpvbnRhbCBkaXJlY3Rpb24pIGl0IGlzIG5vdCBhIHByb2JsZW0uXHJcbmNvbnN0IE1BWF9USUxUID0gZGVnMnJhZCg0MCk7XHJcbi8qKlxyXG4gKiBJZiBhIGNhbWVyYSBoYXMgem9vbSBsZXNzIHRoYW4gb2YgZXF1YWwgdG8gYE5PX1RJTFRfTUFYX1pPT01gLCB0aWx0IHdvbid0IGJlXHJcbiAqIGFsbG93ZWQuXHJcbiAqL1xyXG5jb25zdCBOT19USUxUX01BWF9aT09NID0gMTtcclxuLyoqXHJcbiAqIElmIGEgY2FtZXJhIGhhcyB6b29tIGdyZWF0ZXIgdGhhbiBvZiBlcXVhbCB0byBgRlVMTF9USUxUX01JTl9aT09NYCwgdGlsdCB3aWxsXHJcbiAqIGJlIGFsbG93ZWQgdXAgdG8gYE1BWF9USUxUYC5cclxuICovXHJcbmNvbnN0IEZVTExfVElMVF9NSU5fWk9PTSA9IE5PX1RJTFRfTUFYX1pPT00gKyAxO1xyXG5jb25zdCBGUlVTVFVNX0RJUkVDVElPTlMgPSBbXHJcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZVxyXG4gICAgdmVjMy5jcmVhdGUoLTEsIDEsIC0xKSxcclxuICAgIHZlYzMuY3JlYXRlKDEsIDEsIC0xKSxcclxuICAgIHZlYzMuY3JlYXRlKDEsIC0xLCAtMSksXHJcbiAgICB2ZWMzLmNyZWF0ZSgtMSwgLTEsIC0xKVxyXG4gICAgLy8gdHNsaW50OmVuYWJsZVxyXG5dO1xyXG4vKipcclxuICogSG93IGJpZyB0aGUgd29ybGQgc291bGQgYmUgb24gYSBzY3JlZW4gaWYgem9vbSBpcyAwLCBpbiBkZXZpY2UgaW5kZXBlbmRlbnQgcGl4ZWxzXHJcbiAqL1xyXG5jb25zdCBaT09NXzBfV09STERfQ1NTX1BJWEVMX1NJWkUgPSAyNTY7XHJcbmNvbnN0IERFRkFVTFRfT1BUSU9OUyA9IHtcclxuICAgIHdyYXBNb2RlWDogMSAvKiBDTEFNUF9UT19FREdFICovLFxyXG4gICAgd3JhcE1vZGVZOiAxIC8qIENMQU1QX1RPX0VER0UgKi8sXHJcbiAgICBtaW5ab29tOiAwLFxyXG4gICAgbWF4Wm9vbTogMjQsXHJcbiAgICBmb3Y6IGRlZzJyYWQoMzApXHJcbn07XHJcbi8qKlxyXG4gKiBSZXN0cmljdHMgYSBuZXcgdmFsdWUgZm9yIGEgY2VudGVyJ3MgY29vcmRpbmF0ZSBhY2NvcmRpbmcgdG8gZ2l2ZW4gd3JhcCBtb2RlLlxyXG4gKlxyXG4gKiBAcGFyYW0gd3JhcE1vZGUgVGhlIHdyYXAgbW9kZS5cclxuICogQHBhcmFtIG5ld0Nvb3JkaW5hdGUgVGhlIG5ldyB2YWx1ZS5cclxuICogQHBhcmFtIG9sZENvb3JkaW5hdGUgQ3VycmVudCB2YWx1ZSBvZiB0aGUgY29vcmRpbmF0ZS5cclxuICogQHBhcmFtIGJib3hNaW4gTWluaW11bSBjb3JyZXNwb25kaW5nIGNvb3JkaW5hdGUgb2YgYm91bmRpbmcgYm94IG9mIHRoZVxyXG4gKiAgICAgIHZpc2libGUgcXVhZHJpbGF0ZXJhbC5cclxuICogQHBhcmFtIGJib3hNYXggTWF4aW11bSBjb3JyZXNwb25kaW5nIGNvb3JkaW5hdGUgb2YgYm91bmRpbmcgYm94IG9mIHRoZVxyXG4gKiAgICAgIHZpc2libGUgcXVhZHJpbGF0ZXJhbC5cclxuICogQHJldHVybnMgUmVzdHJpY3RlZCB2YWx1ZSBmb3IgdGhlIGNvb3JkaW5hdGUuXHJcbiAqL1xyXG5mdW5jdGlvbiByZXN0cmljdENvb3JkaW5hdGUod3JhcE1vZGUsIG5ld0Nvb3JkaW5hdGUpIHtcclxuICAgIHN3aXRjaCAod3JhcE1vZGUpIHtcclxuICAgICAgICBjYXNlIDAgLyogTk9ORSAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIG5ld0Nvb3JkaW5hdGU7XHJcbiAgICAgICAgY2FzZSAxIC8qIENMQU1QX1RPX0VER0UgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBjbGFtcChuZXdDb29yZGluYXRlLCAtMSwgMSk7XHJcbiAgICAgICAgY2FzZSAyIC8qIFJFUEVBVCAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIGN5Y2xlUmVzdHJpY3QobmV3Q29vcmRpbmF0ZSwgLTEsIDEpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDYW1lcmEgcmVwcmVzZW50cyB1c2VyJ3MgcG9pbnQgb2YgdmlldyBpbiB0aGUgd29ybGQgc3BhY2UsIGFzIGEgcmVhbCBjYW1lcmEgaXQgaGFzIHJlc3RyaWN0ZWQgZmllbGQgb2YgdmlldyxcclxuICogaXQgY2FuIG1vdmUgYW5kIHJvdGF0ZSAod2l0aCBvciB3aXRob3V0IGFuaW1hdGlvbikuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDYW1lcmEge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNhbWVyYS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0gZ2V0RnVsbE9wdGlvbnMoREVGQVVMVF9PUFRJT05TLCBvcHRpb25zKTtcclxuICAgICAgICB0aGlzLmNlbnRlciA9IG5ldyBDYW1lcmEuX0NlbnRlcih0aGlzKTtcclxuICAgICAgICB0aGlzLm9uVXBkYXRlID0gbmV3IFZvaWRFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBjb25zdCBzY3JlZW5TaXplID0gbmV3IENhbWVyYS5fU2NyZWVuU2l6ZSh0aGlzKTtcclxuICAgICAgICB0aGlzLnNjcmVlblNpemUgPSBzY3JlZW5TaXplO1xyXG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlVG9DZW50ZXIgPSAxO1xyXG4gICAgICAgIHRoaXMuX3pvb20gPSB0aGlzLm9wdGlvbnMubWluWm9vbTtcclxuICAgICAgICB0aGlzLl90aWx0ID0gdGhpcy5fYXppbXV0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5fZGlydHlCaXRzID0gLTEgLyogQUxMICovO1xyXG4gICAgICAgIHRoaXMuX3ZpZXdQcm9qTWF0cml4ID0gbWF0NC5jb3B5KG1hdDQuSURFTlRJVFkpO1xyXG4gICAgICAgIHRoaXMuX3Zpc2libGVRdWFkcmlsYXRlcmFsID0gW1xyXG4gICAgICAgICAgICB2ZWMzLmNyZWF0ZSgwLCAwLCAwKSxcclxuICAgICAgICAgICAgdmVjMy5jcmVhdGUoMCwgMCwgMCksXHJcbiAgICAgICAgICAgIHZlYzMuY3JlYXRlKDAsIDAsIDApLFxyXG4gICAgICAgICAgICB2ZWMzLmNyZWF0ZSgwLCAwLCAwKVxyXG4gICAgICAgIF07XHJcbiAgICAgICAgdGhpcy5fdmlzaWJsZVF1YWRyaWxhdGVyYWxCQm94ID1cclxuICAgICAgICAgICAgdmVjMi5jb21wdXRlQkJveEZvclBvaW50cyh0aGlzLl92aXNpYmxlUXVhZHJpbGF0ZXJhbCk7XHJcbiAgICAgICAgdGhpcy5fcGl4ZWxTaXplID0gdmVjMi5jcmVhdGUoMCwgMCk7XHJcbiAgICB9XHJcbiAgICBnZXQgYXNwZWN0UmF0aW8oKSB7XHJcbiAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSB0aGlzLnNjcmVlblNpemU7XHJcbiAgICAgICAgaWYgKGhlaWdodCAhPT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gd2lkdGggLyBoZWlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB3aGVuIGhlaWdodCA9PSAwIHdlIGNhbm5vdCBjb21wdXRlIHZpZXdQcm9qIG1hdHJpeCBvciB2aXNpYmxlIHJlZ2lvbiwgMSBhbGxvd3MgdG8gaGFuZGxlIHRoaXMgY2FzZSB3aXRoXHJcbiAgICAgICAgICAgIC8vIG5vIGV4Y2VwdGlvbnMgdGhyb3duLCBidXQgdGVjaG5pY2FsbHkgaXQgaXMgbm90IGNvcnJlY3QgYW5kIHNob3VsZCBiZSByZWNvbnNpZGVyZWQgaWYgYW55IGlzc3VlIGlzIGZvdW5kXHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCB6b29tKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl96b29tO1xyXG4gICAgfVxyXG4gICAgZ2V0IHdvcmxkVG9QeEZhY3RvcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fd29ybGRUb1B4RmFjdG9yO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIG5ldyB6b29tIHRvIHRoZSBjYW1lcmEgd2l0aCByZXNwZWN0IHRvIHByb3ZpZGVkIGxpbWl0cyBpbiB0aGUgb3B0aW9ucy5cclxuICAgICAqL1xyXG4gICAgc2V0IHpvb20obmV3Wm9vbSkge1xyXG4gICAgICAgIG5ld1pvb20gPSBjbGFtcChuZXdab29tLCB0aGlzLm9wdGlvbnMubWluWm9vbSwgdGhpcy5vcHRpb25zLm1heFpvb20pO1xyXG4gICAgICAgIGlmIChuZXdab29tICE9PSB0aGlzLl96b29tKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3pvb20gPSBuZXdab29tO1xyXG4gICAgICAgICAgICB0aGlzLl9jb21wdXRlRGlzdGFuY2VUb0NlbnRlcigpO1xyXG4gICAgICAgICAgICAvLyBDb25zdHJhaW50cyBvbiB0aWx0IG1heSBoYXZlIGNoYW5nZWQsIHdlIG5lZWQgdG8gcmVjb21wdXRlIGl0LlxyXG4gICAgICAgICAgICB0aGlzLl90aWx0ID0gdGhpcy5fY29uc3RyYWluVGlsdCh0aGlzLl90aWx0KTtcclxuICAgICAgICAgICAgdGhpcy5fd29ybGRUb1B4RmFjdG9yID0gMi4wIC8gKFpPT01fMF9XT1JMRF9DU1NfUElYRUxfU0laRSAqIE1hdGgucG93KDIsIG5ld1pvb20pKTtcclxuICAgICAgICAgICAgdGhpcy5fc2V0RGlydHlCaXRzKDEgLyogVklFV19QUk9KX01BVFJJWCAqLyB8IDIgLyogVklTSUJMRV9RVUFEUklMQVRFUkFMICovKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgdGlsdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdGlsdDtcclxuICAgIH1cclxuICAgIHNldCB0aWx0KG5ld1RpbHQpIHtcclxuICAgICAgICBuZXdUaWx0ID0gdGhpcy5fY29uc3RyYWluVGlsdChuZXdUaWx0KTtcclxuICAgICAgICBpZiAodGhpcy5fdGlsdCAhPT0gbmV3VGlsdCkge1xyXG4gICAgICAgICAgICB0aGlzLl90aWx0ID0gbmV3VGlsdDtcclxuICAgICAgICAgICAgdGhpcy5fc2V0RGlydHlCaXRzKDEgLyogVklFV19QUk9KX01BVFJJWCAqLyB8IDIgLyogVklTSUJMRV9RVUFEUklMQVRFUkFMICovKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgYXppbXV0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYXppbXV0aDtcclxuICAgIH1cclxuICAgIHNldCBhemltdXRoKG5ld0F6aW11dGgpIHtcclxuICAgICAgICBuZXdBemltdXRoID0gY3ljbGVSZXN0cmljdChuZXdBemltdXRoLCAwLCAyICogTWF0aC5QSSk7XHJcbiAgICAgICAgaWYgKHRoaXMuX2F6aW11dGggIT09IG5ld0F6aW11dGgpIHtcclxuICAgICAgICAgICAgdGhpcy5fYXppbXV0aCA9IG5ld0F6aW11dGg7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldERpcnR5Qml0cygxIC8qIFZJRVdfUFJPSl9NQVRSSVggKi8gfCAyIC8qIFZJU0lCTEVfUVVBRFJJTEFURVJBTCAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTaXplIG9mIGEgcGl4ZWwgaW4gTkRDLlxyXG4gICAgICovXHJcbiAgICBnZXQgcGl4ZWxTaXplKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9waXhlbFNpemU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEludmFsaWRhdGUgYWxsIGludGVybmFsbHkgY2FjaGVkIHZhbHVlcyAoZS5nLiB2aWV3IG1hdHJpeCkuXHJcbiAgICAgKi9cclxuICAgIHNldERpcnR5KCkge1xyXG4gICAgICAgIHRoaXMuX3NldERpcnR5Qml0cygtMSAvKiBBTEwgKi8pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWNvbXB1dGVzIChpZiBuZWVkZWQpIHRoZSB2aWV3IHByb2plY3Rpb24gbWF0cml4LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFRoZSB2aWV3LXByb2plY3Rpb24gbWF0cml4LlxyXG4gICAgICovXHJcbiAgICBnZXRWaWV3UHJvak1hdHJpeCgpIHtcclxuICAgICAgICBjb25zdCB2aWV3UHJvak1hdHJpeCA9IHRoaXMuX3ZpZXdQcm9qTWF0cml4O1xyXG4gICAgICAgIGlmICh0aGlzLl9kaXJ0eUJpdHMgJiAxIC8qIFZJRVdfUFJPSl9NQVRSSVggKi8pIHtcclxuICAgICAgICAgICAgbWF0NC5jb3B5KG1hdDQuSURFTlRJVFksIHZpZXdQcm9qTWF0cml4KTtcclxuICAgICAgICAgICAgbWF0NC5sb29rQXQodmlld1Byb2pNYXRyaXgsIHRoaXMuX2NvbXB1dGVDZW50ZXJUb0NhbWVyYVZlY3RvcigpLCB2ZWMzLk9SSUdJTiwgdmVjMy5yb3RhdGVaKHZlYzMuUE9TSVRJVkVfWSwgdGhpcy5fYXppbXV0aCksIHZpZXdQcm9qTWF0cml4KTtcclxuICAgICAgICAgICAgY29uc3QgeyBmb3YgfSA9IHRoaXMub3B0aW9ucztcclxuICAgICAgICAgICAgY29uc3QgdGFuRmFjdG9ycyA9IE1hdGgudGFuKHRoaXMuX3RpbHQpICogTWF0aC50YW4oMC41ICogZm92KTtcclxuICAgICAgICAgICAgbWF0NC5wZXJzcGVjdGl2ZSh2aWV3UHJvak1hdHJpeCwgZm92LCB0aGlzLmFzcGVjdFJhdGlvLCBNYXRoLm1pbih0aGlzLl9kaXN0YW5jZVRvQ2VudGVyICogMC4wMSwgdGhpcy5fZGlzdGFuY2VUb0NlbnRlciAvICgxICsgdGFuRmFjdG9ycykpLCB0aGlzLl9kaXN0YW5jZVRvQ2VudGVyIC8gKDEgLSB0YW5GYWN0b3JzKSwgdmlld1Byb2pNYXRyaXgpO1xyXG4gICAgICAgICAgICB0aGlzLl9kaXJ0eUJpdHMgJj0gfjEgLyogVklFV19QUk9KX01BVFJJWCAqLztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZpZXdQcm9qTWF0cml4O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWNvbXB1dGVzIChpZiBuZWVkZWQpIGFuZCByZXR1cm5zIHF1YWRyaWxhdGVyYWwgY3V0IG9uIHRoZSB3b3JsZCBwbGFuZVxyXG4gICAgICogYnkgZnJ1c3R1bSBvZiB0aGUgY2FtZXJhLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4gVGhlIHF1YWRyaWxhdGVyYWwgZW5jbG9zaW5nIHZpc2libGUgcGFydCBvZiB0aGUgd29ybGQgcGxhbmUuXHJcbiAgICAgKi9cclxuICAgIGdldFZpc2libGVSZWdpb24oKSB7XHJcbiAgICAgICAgdGhpcy5fY29tcHV0ZVZpc2libGVRdWFkcmlsYXRlcmFsKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2libGVRdWFkcmlsYXRlcmFsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWNvbXB1dGVzIChpZiBuZWVkZWQpIGFuZCByZXR1cm5zIGJvdW5kaW5nIGJveCBvZiB0aGUgdmlzaWJsZSByZWdpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiBCb3VuZGluZyBib3ggb2YgdGhlIHZpc2libGUgcXVhZHJpbGF0ZXJhbC5cclxuICAgICAqL1xyXG4gICAgZ2V0VmlzaWJsZVJlZ2lvbkJCb3goKSB7XHJcbiAgICAgICAgdGhpcy5fY29tcHV0ZVZpc2libGVRdWFkcmlsYXRlcmFsKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2libGVRdWFkcmlsYXRlcmFsQkJveDtcclxuICAgIH1cclxuICAgIF9jb25zdHJhaW5UaWx0KHRpbHQpIHtcclxuICAgICAgICByZXR1cm4gY2xhbXAodGlsdCwgMCwgTUFYX1RJTFQgKiBzbW9vdGhTdGVwKE5PX1RJTFRfTUFYX1pPT00sIEZVTExfVElMVF9NSU5fWk9PTSwgdGhpcy5fem9vbSkpO1xyXG4gICAgfVxyXG4gICAgX3NldERpcnR5Qml0cyhiaXRzKSB7XHJcbiAgICAgICAgaWYgKGJpdHMgXiAoYml0cyAmIHRoaXMuX2RpcnR5Qml0cykpIHtcclxuICAgICAgICAgICAgdGhpcy5fZGlydHlCaXRzIHw9IGJpdHM7XHJcbiAgICAgICAgICAgIHRoaXMub25VcGRhdGUuZmlyZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9jb21wdXRlRGlzdGFuY2VUb0NlbnRlcigpIHtcclxuICAgICAgICB0aGlzLl9kaXN0YW5jZVRvQ2VudGVyID1cclxuICAgICAgICAgICAgdGhpcy5zY3JlZW5TaXplLmhlaWdodCAqIE1hdGgucG93KDIsIC10aGlzLl96b29tKSAvXHJcbiAgICAgICAgICAgICAgICAoTWF0aC50YW4oMC41ICogdGhpcy5vcHRpb25zLmZvdikgKiBaT09NXzBfV09STERfQ1NTX1BJWEVMX1NJWkUpO1xyXG4gICAgfVxyXG4gICAgX2NvbXB1dGVDZW50ZXJUb0NhbWVyYVZlY3Rvcihkc3QgPSB2ZWMzLmNyZWF0ZSgwLCAwLCAwKSkge1xyXG4gICAgICAgIHZlYzMubXVsbih2ZWMzLlBPU0lUSVZFX1osIHRoaXMuX2Rpc3RhbmNlVG9DZW50ZXIsIGRzdCk7XHJcbiAgICAgICAgdmVjMy5yb3RhdGVYKGRzdCwgdGhpcy5fdGlsdCwgZHN0KTtcclxuICAgICAgICB2ZWMzLnJvdGF0ZVooZHN0LCB0aGlzLl9hemltdXRoLCBkc3QpO1xyXG4gICAgICAgIHJldHVybiBkc3Q7XHJcbiAgICB9XHJcbiAgICBfY29tcHV0ZVZpc2libGVRdWFkcmlsYXRlcmFsKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9kaXJ0eUJpdHMgJiAyIC8qIFZJU0lCTEVfUVVBRFJJTEFURVJBTCAqLykge1xyXG4gICAgICAgICAgICBjb25zdCB2aXNpYmxlUXVhZHJpbGF0ZXJhbCA9IHRoaXMuX3Zpc2libGVRdWFkcmlsYXRlcmFsO1xyXG4gICAgICAgICAgICBjb25zdCBoYWxmRm92VGFuID0gTWF0aC50YW4oMC41ICogdGhpcy5vcHRpb25zLmZvdik7XHJcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbiA9IHRoaXMuX2NvbXB1dGVDZW50ZXJUb0NhbWVyYVZlY3RvcigpO1xyXG4gICAgICAgICAgICB2ZWMyLmFkZChvcmlnaW4sIHRoaXMuY2VudGVyLCBvcmlnaW4pO1xyXG4gICAgICAgICAgICBjb25zdCBzY2FsZSA9IHZlYzMuY3JlYXRlKGhhbGZGb3ZUYW4gKiB0aGlzLmFzcGVjdFJhdGlvLCBoYWxmRm92VGFuLCAxKTtcclxuICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uID0gdmVjMy5jcmVhdGUoMCwgMCwgMCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJheSA9IHsgb3JpZ2luLCBkaXJlY3Rpb24gfTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyArK2kpIHtcclxuICAgICAgICAgICAgICAgIHZlYzMubXVsdihGUlVTVFVNX0RJUkVDVElPTlNbaV0sIHNjYWxlLCBkaXJlY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgdmVjMy5yb3RhdGVYKGRpcmVjdGlvbiwgdGhpcy5fdGlsdCwgZGlyZWN0aW9uKTtcclxuICAgICAgICAgICAgICAgIHZlYzMucm90YXRlWihkaXJlY3Rpb24sIHRoaXMuX2F6aW11dGgsIGRpcmVjdGlvbik7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXZlYzMuZ2V0UGxhbmVSYXlJbnRlcnNlY3Rpb24odmVjMy5YWSwgcmF5LCB2aXNpYmxlUXVhZHJpbGF0ZXJhbFtpXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Zpc2libGUgcXVhZHJpbGF0ZXJhbCBpcyB1bmJvdW5kZWQsIGVuZ2luZSBjYW5cXCd0IGhhbmRsZSB0aGF0IGNhc2UgKHlldCknKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2ZWMyLmNvbXB1dGVCQm94Rm9yUG9pbnRzKHZpc2libGVRdWFkcmlsYXRlcmFsLCB0aGlzLl92aXNpYmxlUXVhZHJpbGF0ZXJhbEJCb3gpO1xyXG4gICAgICAgICAgICB0aGlzLl9kaXJ0eUJpdHMgJj0gfjIgLyogVklTSUJMRV9RVUFEUklMQVRFUkFMICovO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogSW1wbGVtZW50YXRpb24gb2YgYSBjZW50ZXIgdmVjdG9yIG9mIGEgY2FtZXJhLiBUYWtlcyBpbnRvIGFjY291bnQgd3JhcHBpbmdcclxuICogbW9kZXMgYW5kIHVwZGF0ZXMgY2FtZXJhJ3MgZGlydHkgZmxhZ3MuXHJcbiAqL1xyXG5DYW1lcmEuX0NlbnRlciA9IGNsYXNzIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBuZXcgY2VudGVyIHZlY3RvciBmb3IgYSBjYW1lcmEuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNhbWVyYSBUaGUgY2FtZXJhLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihjYW1lcmEpIHtcclxuICAgICAgICB0aGlzLl9jYW1lcmEgPSBjYW1lcmE7XHJcbiAgICAgICAgdGhpcy5feCA9IHRoaXMuX3kgPSAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBWYWx1ZXMgb2YgYWJzY2lzc2Egb2YgdGhlIGNlbnRlciB2ZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIGdldCB4KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl94O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQcm9wZXJseSBjbGFtcHMgb3Igd3JhcHMgbmV3IGFic2Npc3NhIHZhbHVlIGFuZCBzZXRzIGl0IHRvIHRoZSB2ZWN0b3IuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG5ld1ggVGhlIG5ld1xyXG4gICAgICovXHJcbiAgICBzZXQgeChuZXdYKSB7XHJcbiAgICAgICAgY29uc3QgY2FtZXJhID0gdGhpcy5fY2FtZXJhO1xyXG4gICAgICAgIG5ld1ggPSByZXN0cmljdENvb3JkaW5hdGUoY2FtZXJhLm9wdGlvbnMud3JhcE1vZGVYLCBuZXdYKTtcclxuICAgICAgICBpZiAodGhpcy5feCAhPT0gbmV3WCkge1xyXG4gICAgICAgICAgICB0aGlzLl94ID0gbmV3WDtcclxuICAgICAgICAgICAgY2FtZXJhLl9zZXREaXJ0eUJpdHMoMiAvKiBWSVNJQkxFX1FVQURSSUxBVEVSQUwgKi8pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVmFsdWVzIG9mIG9yZGluYXRlIG9mIHRoZSBjZW50ZXIgdmVjdG9yLlxyXG4gICAgICovXHJcbiAgICBnZXQgeSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5feTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUHJvcGVybHkgY2xhbXBzIG9yIHdyYXBzIG5ldyBvcmRpbmF0ZSB2YWx1ZSBhbmQgc2V0cyBpdCB0byB0aGUgdmVjdG9yLlxyXG4gICAgICovXHJcbiAgICBzZXQgeShuZXdZKSB7XHJcbiAgICAgICAgY29uc3QgY2FtZXJhID0gdGhpcy5fY2FtZXJhO1xyXG4gICAgICAgIG5ld1kgPSByZXN0cmljdENvb3JkaW5hdGUoY2FtZXJhLm9wdGlvbnMud3JhcE1vZGVZLCBuZXdZKTtcclxuICAgICAgICBpZiAodGhpcy5feSAhPT0gbmV3WSkge1xyXG4gICAgICAgICAgICB0aGlzLl95ID0gbmV3WTtcclxuICAgICAgICAgICAgY2FtZXJhLl9zZXREaXJ0eUJpdHMoMiAvKiBWSVNJQkxFX1FVQURSSUxBVEVSQUwgKi8pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuQ2FtZXJhLl9TY3JlZW5TaXplID0gY2xhc3Mge1xyXG4gICAgY29uc3RydWN0b3IoY2FtZXJhKSB7XHJcbiAgICAgICAgdGhpcy5fY2FtZXJhID0gY2FtZXJhO1xyXG4gICAgICAgIHRoaXMuX3dpZHRoID0gdGhpcy5faGVpZ2h0ID0gMDtcclxuICAgIH1cclxuICAgIGdldCB3aWR0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fd2lkdGg7XHJcbiAgICB9XHJcbiAgICBzZXQgd2lkdGgobmV3V2lkdGgpIHtcclxuICAgICAgICBpZiAodGhpcy5fd2lkdGggIT09IG5ld1dpZHRoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3dpZHRoID0gbmV3V2lkdGg7XHJcbiAgICAgICAgICAgIGNvbnN0IGNhbWVyYSA9IHRoaXMuX2NhbWVyYTtcclxuICAgICAgICAgICAgY2FtZXJhLl9zZXREaXJ0eUJpdHMoMSAvKiBWSUVXX1BST0pfTUFUUklYICovIHwgMiAvKiBWSVNJQkxFX1FVQURSSUxBVEVSQUwgKi8pO1xyXG4gICAgICAgICAgICBjYW1lcmEuX3BpeGVsU2l6ZS54ID0gMi4wIC8gdGhpcy5fd2lkdGg7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0IGhlaWdodCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgc2V0IGhlaWdodChuZXdIZWlnaHQpIHtcclxuICAgICAgICBpZiAodGhpcy5faGVpZ2h0ICE9PSBuZXdIZWlnaHQpIHtcclxuICAgICAgICAgICAgdGhpcy5faGVpZ2h0ID0gbmV3SGVpZ2h0O1xyXG4gICAgICAgICAgICBjb25zdCBjYW1lcmEgPSB0aGlzLl9jYW1lcmE7XHJcbiAgICAgICAgICAgIGNhbWVyYS5fY29tcHV0ZURpc3RhbmNlVG9DZW50ZXIoKTtcclxuICAgICAgICAgICAgY2FtZXJhLl9zZXREaXJ0eUJpdHMoMSAvKiBWSUVXX1BST0pfTUFUUklYICovIHwgMiAvKiBWSVNJQkxFX1FVQURSSUxBVEVSQUwgKi8pO1xyXG4gICAgICAgICAgICBjYW1lcmEuX3BpeGVsU2l6ZS55ID0gMi4wIC8gdGhpcy5faGVpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENsYW1wcyBhIHZhbHVlIHRvIGEgZ2l2ZW4gcmFuZ2UuXHJcbiAqXHJcbiAqIEBwYXJhbSB4IFRoZSB2YWx1ZS5cclxuICogQHBhcmFtIG1pbiBTdGFydCBvZiB0aGUgcmFuZ2UuXHJcbiAqIEBwYXJhbSBtYXggRW5kIG9mIHRoZSByYW5nZS5cclxuICogQHJldHVybnMgQ2xhbXBlZCB2YWx1ZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjbGFtcCh4LCBtaW4sIG1heCkge1xyXG4gICAgcmV0dXJuIG1pbiA8IHggPyB4IDwgbWF4ID8geCA6IG1heCA6IG1pbjtcclxufVxyXG4vKipcclxuICogUmVzdHJpY3RzIGEgdmFsdWUgdG8gYSBnaXZlbiBjeWNsZWQgcmFuZ2UsIGkuZS4gZW5kcyBvZiB0aGUgcmFuZ2UgYXJlXHJcbiAqIGVxdWl2YWxlbnQuIEUuZy4gbGlrZSBhbmdsZXMgY2FuIGJlIHJlc3RyaWN0ZWQgdG8gYW55IHJhbmdlIG9mIHNpemUgYDIgKiBQSWAuXHJcbiAqXHJcbiAqIEBwYXJhbSB4IFRoZSB2YWx1ZS5cclxuICogQHBhcmFtIG1pbiBTdGFydCBvZiB0aGUgcmFuZ2UuXHJcbiAqIEBwYXJhbSBtYXggRW5kIG9mIHRoZSByYW5nZS5cclxuICogQHJldHVybnMgUmVzdHJpY3RlZCB2YWx1ZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjeWNsZVJlc3RyaWN0KHgsIG1pbiwgbWF4KSB7XHJcbiAgICBjb25zdCBkID0gbWF4IC0gbWluO1xyXG4gICAgY29uc3QgcyA9ICh4IC0gbWluKSAvIChtYXggLSBtaW4pO1xyXG4gICAgcmV0dXJuIG1pbiArIGQgKiAocyAtIE1hdGguZmxvb3IocykpO1xyXG59XHJcbi8qKlxyXG4gKiBMaW5lYXIgaW50ZXJwb2xhdGlvbi5cclxuICpcclxuICogQHBhcmFtIG1pbiBWYWx1ZSB0aGF0IGNvcnJlc3BvbmQgdG8gMCUgcHJvZ3Jlc3MuXHJcbiAqIEBwYXJhbSBtYXggVmFsdWUgdGhhdCBjb3JyZXNwb25kIHRvIDEwMCUgcHJvZ3Jlc3MuXHJcbiAqIEBwYXJhbSBwcm9ncmVzcyBJbiAwLi4xLjAgcmFuZ2UgdGhhdCBtYXBzIHRvIDAuLjEwMCUgcHJvZ3Jlc3MuIEl0IGlzIGFsbG93ZWQgdG8gcGFzcyBhIHZhbHVlXHJcbiAqICAgICAgb3V0c2lkZSBvZiB0aGlzIHJhbmdlLCB0aGF0IG1lYW5zIHByb2dyZXNzIGdyZWF0ZXIgdGhlbiAxMDAlIG9yIG5lZ2F0aXZlIHByb2dyZXNzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG1peChtaW4sIG1heCwgcHJvZ3Jlc3MpIHtcclxuICAgIHJldHVybiAoMSAtIHByb2dyZXNzKSAqIG1pbiArIHByb2dyZXNzICogbWF4O1xyXG59XHJcbi8qKlxyXG4gKiBBIHN0ZXAgZnVuY3Rpb24gd2l0aCBhIHNtb290aCB0cmFuc2l0aW9uIGJldHdlZW4gZ2l2ZW4gZWRnZXMuIENvbXBsZXRlbHlcclxuICogYW5hbG9nb3VzIHRvIGBzbW9vdGhzdGVwYCBpbiBHTFNMIChHTFNMIEVTIDEuMCDCpzguMykuXHJcbiAqXHJcbiAqIEBwYXJhbSBlZGdlMSBUaGUgc21hbGxlciBlZGdlLlxyXG4gKiBAcGFyYW0gZWRnZTJcclxuICogQHBhcmFtIHggYDBgIGlmIGB4IDwgZWRnZTFgLCBgMWAgaWYgYHggPiBlZGdlMmAgYW5kIGFuIGludGVycG9sYXRlZCB2YWx1ZSBmb3JcclxuICogICAgICBgZWRnZTEgPCB4IDwgZWRnZTJgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNtb290aFN0ZXAoZWRnZTEsIGVkZ2UyLCB4KSB7XHJcbiAgICBjb25zdCBmYWN0b3IgPSBjbGFtcCgoeCAtIGVkZ2UxKSAvIChlZGdlMiAtIGVkZ2UxKSwgMCwgMSk7XHJcbiAgICByZXR1cm4gZmFjdG9yICogZmFjdG9yICogKDMgLSAyICogZmFjdG9yKTtcclxufVxyXG4iLCJjb25zdCBERUdfVE9fUkFEID0gTWF0aC5QSSAvIDE4MDtcclxuZXhwb3J0IGZ1bmN0aW9uIGRlZzJyYWQoeCkge1xyXG4gICAgcmV0dXJuIHggKiBERUdfVE9fUkFEO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiByYWQyZGVnKHgpIHtcclxuICAgIHJldHVybiB4IC8gREVHX1RPX1JBRDtcclxufVxyXG4iLCIvKipcclxuICogUmVzb2x2ZXMgb3B0aW9ucy5cclxuICpcclxuICogQHBhcmFtIGRlZmF1bHRPcHRpb25zIE9iamVjdCB3aXRoIGRlZmF1bHQgdmFsdWVzLlxyXG4gKiBAcGFyYW0gb3B0aW9ucyBPYmplY3Qgd2l0aCBjdXN0b20gdmFsdWVzIGZvciBvcHRpb25zLiBMYXRlciBvYmplY3RzIFwib3ZlcnJpZGVcIlxyXG4gKiAgICAgIGZvcm1lciBvbmVzLlxyXG4gKiBAcmV0dXJucyBOZXcgb2JqZWN0IGNvbnRhaW5pbmcgcmVzb2x2ZWQgb3B0aW9ucy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEZ1bGxPcHRpb25zKGRlZmF1bHRPcHRpb25zLCAuLi5vcHRpb25zKSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIC4uLm9wdGlvbnMpO1xyXG59XHJcbiIsImltcG9ydCAqIGFzIHZlY3RvcjMgZnJvbSAnLi92ZWN0b3IzJztcclxuLy8gVE9ETyhkbWlraXMpIFJvTWF0cml4ND9cclxuZXhwb3J0IGNvbnN0IElERU5USVRZID0gW1xyXG4gICAgMSwgMCwgMCwgMCxcclxuICAgIDAsIDEsIDAsIDAsXHJcbiAgICAwLCAwLCAxLCAwLFxyXG4gICAgMCwgMCwgMCwgMVxyXG5dO1xyXG5leHBvcnQgY29uc3QgWkVSTyA9IFtcclxuICAgIDAsIDAsIDAsIDAsXHJcbiAgICAwLCAwLCAwLCAwLFxyXG4gICAgMCwgMCwgMCwgMCxcclxuICAgIDAsIDAsIDAsIDBcclxuXTtcclxuY29uc3QgTUFUUklYX1NJWkUgPSAxNjtcclxuLyoqXHJcbiAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBuZXcgKip1bmluaXRpYWxpemVkKiogbWF0cml4LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcclxuICAgIHJldHVybiBuZXcgQXJyYXkoTUFUUklYX1NJWkUpO1xyXG59XHJcbi8qKlxyXG4gKiBaZXJvZXMgYSBtYXRyaXguXHJcbiAqXHJcbiAqIEBwYXJhbSBkc3QgVGhlIG1hdHJpeC5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gemVybyhkc3QgPSBjcmVhdGUoKSkge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNQVRSSVhfU0laRTsgKytpKSB7XHJcbiAgICAgICAgZHN0W2ldID0gMDtcclxuICAgIH1cclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIENvcGllcyBhIG1hdHJpeCB0byBhbm90aGVyIG9uZS5cclxuICpcclxuICogQHBhcmFtIHNyYyBUaGUgbWF0cml4IHRvIGJlIGNvcGllZC5cclxuICogQHBhcmFtIGRzdCBUaGUgbWF0cml4IHRoZSBgc3JjYCB3aWxsIGJlIGNvcGllZCB0by5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29weShzcmMsIGRzdCA9IGNyZWF0ZSgpKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1BVFJJWF9TSVpFOyArK2kpIHtcclxuICAgICAgICBkc3RbaV0gPSBzcmNbaV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbi8qKlxyXG4gKiBBcHBsaWVzIGEgcm90YXRpb24gYXJvdW5kIHRoZSBYIGF4aXMgYnkgYSBnaXZlbiBhbmdsZSB0byBhIGdpdmVuIG1hdHJpeC5cclxuICogUG9zaXRpdmUgZGlyZWN0aW9uIGlzIGZyb20gcG9zaXRpdmUgWSB0byBwb3NpdGl2ZSBaLlxyXG4gKlxyXG4gKiBAcGFyYW0gc3JjIFRoZSBtYXRyaXggdG8gYmUgbXVsdGlwbGllZCBieSB0aGUgcm90YXRpb24gbWF0cml4LlxyXG4gKiBAcGFyYW0gYW5nbGUgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSBtYXRyaXggdGhlIHByb2R1Y3Qgd2lsbCBiZSBzdG9yZWQgdG8uIENhbiBiZSB0aGUgc2FtZSBhcyBgc3JjYC5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWChzcmMsIGFuZ2xlLCBkc3QgPSBjcmVhdGUoKSkge1xyXG4gICAgY29uc3QgYW5nbGVDb3MgPSBNYXRoLmNvcyhhbmdsZSk7XHJcbiAgICBjb25zdCBhbmdsZVNpbiA9IE1hdGguc2luKGFuZ2xlKTtcclxuICAgIC8vIFRoZSByb3RhdGlvbiBtYXRyaXg6XHJcbiAgICAvL1xyXG4gICAgLy8gMSAgIDAgICAgMCAwXHJcbiAgICAvLyAwIGNvcyAtc2luIDBcclxuICAgIC8vIDAgc2luICBjb3MgMFxyXG4gICAgLy8gMCAgIDAgICAgMCAxXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1BVFJJWF9TSVpFOyBpICs9IDQpIHtcclxuICAgICAgICBkc3RbaV0gPSBzcmNbaV07XHJcbiAgICAgICAgY29uc3QgbTFpID0gc3JjW2kgKyAxXTtcclxuICAgICAgICBjb25zdCBtMmkgPSBzcmNbaSArIDJdO1xyXG4gICAgICAgIGRzdFtpICsgMV0gPSBtMWkgKiBhbmdsZUNvcyAtIG0yaSAqIGFuZ2xlU2luO1xyXG4gICAgICAgIGRzdFtpICsgMl0gPSBtMWkgKiBhbmdsZVNpbiArIG0yaSAqIGFuZ2xlQ29zO1xyXG4gICAgICAgIGRzdFtpICsgM10gPSBzcmNbaSArIDNdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogQXBwbGllcyBhIHJvdGF0aW9uIGFyb3VuZCB0aGUgWSBheGlzIGJ5IGEgZ2l2ZW4gYW5nbGUgdG8gYSBnaXZlbiBtYXRyaXguXHJcbiAqIFBvc2l0aXZlIGRpcmVjdGlvbiBpcyBmcm9tIHBvc2l0aXZlIFggdG8gcG9zaXRpdmUgWi5cclxuICpcclxuICogQHBhcmFtIHNyYyBUaGUgbWF0cml4IHRvIGJlIG11bHRpcGxpZWQgYnkgdGhlIHJvdGF0aW9uIG1hdHJpeC5cclxuICogQHBhcmFtIGFuZ2xlIFRoZSBhbmdsZSBvZiByb3RhdGlvbi5cclxuICogQHBhcmFtIGRzdCBUaGUgbWF0cml4IHRoZSBwcm9kdWN0IHdpbGwgYmUgc3RvcmVkIHRvLiBDYW4gYmUgdGhlIHNhbWUgYXMgYHNyY2AuXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVkoc3JjLCBhbmdsZSwgZHN0ID0gY3JlYXRlKCkpIHtcclxuICAgIGNvbnN0IGFuZ2xlQ29zID0gTWF0aC5jb3MoYW5nbGUpO1xyXG4gICAgY29uc3QgYW5nbGVTaW4gPSBNYXRoLnNpbihhbmdsZSk7XHJcbiAgICAvLyBUaGUgcm90YXRpb24gbWF0cml4OlxyXG4gICAgLy9cclxuICAgIC8vIGNvcyAwIC1zaW4gMFxyXG4gICAgLy8gMCAgIDEgICAgMCAwXHJcbiAgICAvLyBzaW4gMCAgY29zIDBcclxuICAgIC8vIDAgICAgMCAgIDAgMVxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNQVRSSVhfU0laRTsgaSArPSA0KSB7XHJcbiAgICAgICAgY29uc3QgbTBpID0gc3JjW2ldO1xyXG4gICAgICAgIGNvbnN0IG0yaSA9IHNyY1tpICsgMl07XHJcbiAgICAgICAgZHN0W2ldID0gbTBpICogYW5nbGVDb3MgLSBtMmkgKiBhbmdsZVNpbjtcclxuICAgICAgICBkc3RbaSArIDFdID0gc3JjW2kgKyAxXTtcclxuICAgICAgICBkc3RbaSArIDJdID0gbTBpICogYW5nbGVTaW4gKyBtMmkgKiBhbmdsZUNvcztcclxuICAgICAgICBkc3RbaSArIDNdID0gc3JjW2kgKyAzXTtcclxuICAgIH1cclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIEFwcGxpZXMgYSByb3RhdGlvbiBhcm91bmQgdGhlIFggYXhpcyBieSBhIGdpdmVuIGFuZ2xlIHRvIGEgZ2l2ZW4gbWF0cml4LlxyXG4gKiBQb3NpdGl2ZSBkaXJlY3Rpb24gaXMgZnJvbSBwb3NpdGl2ZSBYIHRvIHBvc2l0aXZlIFkuXHJcbiAqXHJcbiAqIEBwYXJhbSBzcmMgVGhlIG1hdHJpeCB0byBiZSBtdWx0aXBsaWVkIGJ5IHRoZSByb3RhdGlvbiBtYXRyaXguXHJcbiAqIEBwYXJhbSBhbmdsZSBUaGUgYW5nbGUgb2Ygcm90YXRpb24uXHJcbiAqIEBwYXJhbSBkc3QgVGhlIG1hdHJpeCB0aGUgcHJvZHVjdCB3aWxsIGJlIHN0b3JlZCB0by4gQ2FuIGJlIHRoZSBzYW1lIGFzIGBzcmNgLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVaKHNyYywgYW5nbGUsIGRzdCA9IGNyZWF0ZSgpKSB7XHJcbiAgICBjb25zdCBhbmdsZUNvcyA9IE1hdGguY29zKGFuZ2xlKTtcclxuICAgIGNvbnN0IGFuZ2xlU2luID0gTWF0aC5zaW4oYW5nbGUpO1xyXG4gICAgLy8gVGhlIHJvdGF0aW9uIG1hdHJpeDpcclxuICAgIC8vIGNvcyAtc2luIDAgMFxyXG4gICAgLy8gc2luICBjb3MgMCAwXHJcbiAgICAvLyAgIDAgICAgMCAxIDBcclxuICAgIC8vICAgMCAgICAwIDAgMVxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNQVRSSVhfU0laRTsgaSArPSA0KSB7XHJcbiAgICAgICAgY29uc3QgbTBpID0gc3JjW2ldO1xyXG4gICAgICAgIGNvbnN0IG0xaSA9IHNyY1tpICsgMV07XHJcbiAgICAgICAgZHN0W2ldID0gbTBpICogYW5nbGVDb3MgLSBtMWkgKiBhbmdsZVNpbjtcclxuICAgICAgICBkc3RbaSArIDFdID0gbTBpICogYW5nbGVTaW4gKyBtMWkgKiBhbmdsZUNvcztcclxuICAgICAgICBkc3RbaSArIDJdID0gc3JjW2kgKyAyXTtcclxuICAgICAgICBkc3RbaSArIDNdID0gc3JjW2kgKyAzXTtcclxuICAgIH1cclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIEFwcGxpZXMgYSB0cmFuc2xhdGlvbiBieSBhIGdpdmVuIHZlY3RvciB0byBhIGdpdmVuIG1hdHJpeC5cclxuICpcclxuICogQHBhcmFtIHNyYyBUaGUgbWF0cml4IHRvIGJlIG11bHRpcGxpZWQgYnkgdGhlIHRyYW5zbGF0aW9uIG1hdHJpeC5cclxuICogQHBhcmFtIHRyYW5zbGF0aW9uIFRoZSB0cmFuc2xhdGlvbiB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBkc3QgVGhlIG1hdHJpeCB0aGUgcHJvZHVjdCB3aWxsIGJlIHN0b3JlZCB0by4gQ2FuIGJlIHRoZSBzYW1lIGFzIGBzcmNgLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2xhdGUoc3JjLCB0cmFuc2xhdGlvbiwgZHN0ID0gY3JlYXRlKCkpIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTUFUUklYX1NJWkU7IGkgKz0gNCkge1xyXG4gICAgICAgIGNvbnN0IG00aSA9IGRzdFtpICsgM10gPSBzcmNbaSArIDNdO1xyXG4gICAgICAgIGRzdFtpXSA9IHNyY1tpXSArIG00aSAqIHRyYW5zbGF0aW9uLng7XHJcbiAgICAgICAgZHN0W2kgKyAxXSA9IHNyY1tpICsgMV0gKyBtNGkgKiB0cmFuc2xhdGlvbi55O1xyXG4gICAgICAgIGRzdFtpICsgMl0gPSBzcmNbaSArIDJdICsgbTRpICogdHJhbnNsYXRpb24uejtcclxuICAgIH1cclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIEFwcGxpZXMgYSBzY2FsZSBtYXRyaXggYnkgZ2l2ZW4gZmFjdG9ycyAocGFja2VkIGludG8gYSB2ZWN0b3IpIHRvIGEgZ2l2ZW5cclxuICogbWF0cml4LlxyXG4gKlxyXG4gKiBAcGFyYW0gc3JjIFRoZSBtYXRyaXggdG8gYmUgbXVsdGlwbGllZCBieSB0aGUgc2NhbGUgbWF0cml4LlxyXG4gKiBAcGFyYW0gZmFjdG9yIFRoZSB2ZWN0b3IgdGhlIHNjYWxlIGZhY3RvcnMgcGFja2VkIGludG8uXHJcbiAqIEBwYXJhbSBkc3QgVGhlIG1hdHJpeCB0aGUgcHJvZHVjdCB3aWxsIGJlIHN0b3JlZCB0by4gQ2FuIGJlIHRoZSBzYW1lIGFzIGBzcmNgLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzY2FsZShzcmMsIGZhY3RvciwgZHN0ID0gY3JlYXRlKCkpIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTUFUUklYX1NJWkU7IGkgKz0gNCkge1xyXG4gICAgICAgIGRzdFtpXSA9IHNyY1tpXSAqIGZhY3Rvci54O1xyXG4gICAgICAgIGRzdFtpICsgMV0gPSBzcmNbaSArIDFdICogZmFjdG9yLnk7XHJcbiAgICAgICAgZHN0W2kgKyAyXSA9IHNyY1tpICsgMl0gKiBmYWN0b3IuejtcclxuICAgICAgICBkc3RbaSArIDNdID0gc3JjW2kgKyAzXTtcclxuICAgIH1cclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLy8gVGhlIG1hdHJpeDpcclxuLy8geEF4aXMueCB5QXhpcy54IHpBeGlzLnggLWV5ZS54XHJcbi8vIHhBeGlzLnkgeUF4aXMueSB6QXhpcy55IC1leWUueVxyXG4vLyB4QXhpcy56IHlBeGlzLnogekF4aXMueiAtZXllLnpcclxuLy8gICAgICAgMCAgICAgICAwICAgICAgIDAgMVxyXG4vLyB3aGVyZSB4QXhpcywgeUF4aXMgYW5kIHpBeGlzIOKAlCBheGVzIG9mIHRoZSBleWUgY29vcmRpbmF0ZSBzeXN0ZW0sIGV5ZSDigJRcclxuLy8gb3JpZ2luIG9mIHRoZSBleWUgY29vcmRpbmF0ZSBzeXN0ZW0uXHJcbmNvbnN0IGxvb2tBdE1hdHJpeCA9IGNvcHkoSURFTlRJVFkpO1xyXG4vKipcclxuICogQXBwbGllcyBhIG1hdHJpeCBvZiB0cmFuc2Zvcm1hdGlvbiBpbnRvIGEgY29vcmRpbmF0ZSBzeXN0ZW0gb2YgYSBjYW1lcmFcclxuICogZGVmaW5lZCBieSBpdHMgcG9zaXRpb24sIGEgcG9pbnQgaXQncyBsb29raW5nIGF0IGFuZCBhbiB1cCBkaXJlY3Rpb24gdmVjdG9yLlxyXG4gKlxyXG4gKiBAcGFyYW0gc3JjIFRoZSBtYXRyaXggdG8gYmUgbXVsdGlwbGllZCBieSB0aGUgc2NhbGUgbWF0cml4LlxyXG4gKiBAcGFyYW0gZXllIFRoZSBwb3NpdGlvbiBvZiB0aGUgY2FtZXJhLlxyXG4gKiBAcGFyYW0gY2VudGVyIFRoZSBwb2ludCB0aGUgY2FtZXJhJ3MgbG9va2luZyBhdC5cclxuICogQHBhcmFtIHVwIFRoZSB1cCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBkc3QgVGhlIG1hdHJpeCB0aGUgcHJvZHVjdCB3aWxsIGJlIHN0b3JlZCB0by4gQ2FuIGJlIHRoZSBzYW1lIGFzIGBzcmNgLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBsb29rQXQoc3JjLCBleWUsIGNlbnRlciwgdXAsIGRzdCA9IGNyZWF0ZSgpKSB7XHJcbiAgICBjb25zdCB6QXhpcyA9IHZlY3RvcjMuc3ViKGV5ZSwgY2VudGVyKTtcclxuICAgIHZlY3RvcjMubm9ybWFsaXplKHpBeGlzLCB6QXhpcyk7XHJcbiAgICBjb25zdCB4QXhpcyA9IHZlY3RvcjMuY3Jvc3ModXAsIHpBeGlzKTtcclxuICAgIHZlY3RvcjMubm9ybWFsaXplKHhBeGlzLCB4QXhpcyk7XHJcbiAgICBjb25zdCB5QXhpcyA9IHZlY3RvcjMuY3Jvc3MoekF4aXMsIHhBeGlzKTtcclxuICAgIGxvb2tBdE1hdHJpeFswXSA9IHhBeGlzLng7XHJcbiAgICBsb29rQXRNYXRyaXhbMV0gPSB5QXhpcy54O1xyXG4gICAgbG9va0F0TWF0cml4WzJdID0gekF4aXMueDtcclxuICAgIGxvb2tBdE1hdHJpeFs0XSA9IHhBeGlzLnk7XHJcbiAgICBsb29rQXRNYXRyaXhbNV0gPSB5QXhpcy55O1xyXG4gICAgbG9va0F0TWF0cml4WzZdID0gekF4aXMueTtcclxuICAgIGxvb2tBdE1hdHJpeFs4XSA9IHhBeGlzLno7XHJcbiAgICBsb29rQXRNYXRyaXhbOV0gPSB5QXhpcy56O1xyXG4gICAgbG9va0F0TWF0cml4WzEwXSA9IHpBeGlzLno7XHJcbiAgICBsb29rQXRNYXRyaXhbMTJdID0gLXZlY3RvcjMuZG90KHhBeGlzLCBleWUpO1xyXG4gICAgbG9va0F0TWF0cml4WzEzXSA9IC12ZWN0b3IzLmRvdCh5QXhpcywgZXllKTtcclxuICAgIGxvb2tBdE1hdHJpeFsxNF0gPSAtdmVjdG9yMy5kb3QoekF4aXMsIGV5ZSk7XHJcbiAgICByZXR1cm4gbXVsKHNyYywgbG9va0F0TWF0cml4LCBkc3QpO1xyXG59XHJcbi8qKlxyXG4gKiBBcHBsaWVzIGEgcGVyc3BlY3RpdmUgbWF0cml4IHRvIGEgZ2l2ZW4gb25lLlxyXG4gKlxyXG4gKiBAcGFyYW0gc3JjIFRoZSBtYXRyaXggdG8gYmUgbXVsdGlwbGllZCBieSB0aGUgcGVyc3BlY3RpdmUgbWF0cml4LlxyXG4gKiBAcGFyYW0gZm92IFZlcnRpY2FsIGZpZWxkIG9mIHZpZXcgYW5nbGUuXHJcbiAqIEBwYXJhbSBhc3BlY3RSYXRpbyBTY3JlZW4gYXNwZWN0IHJhdGlvLlxyXG4gKiBAcGFyYW0gek5lYXIgWi1jb29yZGluYXRlIG9mIG5lYXIgY2xpcHBpbmcgcGxhbmUuXHJcbiAqIEBwYXJhbSB6RmFyIFotY29vcmRpbmF0ZSBvZiBmYXIgY2xpcHBpbmcgcGxhbmUuXHJcbiAqIEBwYXJhbSBkc3QgVGhlIG1hdHJpeCB0aGUgcHJvZHVjdCB3aWxsIGJlIHN0b3JlZCB0by4gQ2FuIGJlIHRoZSBzYW1lIGFzIGBzcmNgLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBwZXJzcGVjdGl2ZShzcmMsIGZvdiwgYXNwZWN0LCB6TmVhciwgekZhciwgZHN0ID0gY3JlYXRlKCkpIHtcclxuICAgIGNvbnN0IHAxMSA9IDEgLyBNYXRoLnRhbigwLjUgKiBmb3YpO1xyXG4gICAgY29uc3QgcDAwID0gcDExIC8gYXNwZWN0O1xyXG4gICAgY29uc3QgcDIyID0gKHpOZWFyICsgekZhcikgLyAoek5lYXIgLSB6RmFyKTtcclxuICAgIGNvbnN0IHAzMiA9IDIgKiB6TmVhciAqIHpGYXIgLyAoek5lYXIgLSB6RmFyKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTUFUUklYX1NJWkU7IGkgKz0gNCkge1xyXG4gICAgICAgIGRzdFtpXSA9IHNyY1tpXSAqIHAwMDtcclxuICAgICAgICBkc3RbaSArIDFdID0gc3JjW2kgKyAxXSAqIHAxMTtcclxuICAgICAgICBjb25zdCBtMmkgPSBzcmNbaSArIDJdO1xyXG4gICAgICAgIGNvbnN0IG0zaSA9IHNyY1tpICsgM107XHJcbiAgICAgICAgZHN0W2kgKyAyXSA9IG0yaSAqIHAyMiArIG0zaSAqIHAzMjtcclxuICAgICAgICBkc3RbaSArIDNdID0gLW0yaTtcclxuICAgIH1cclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIE11bHRpcGxpZXMgYSBtYXRyaXggYnkgYW5vdGhlciBvbmUsIGkuZS4gYGRzdCA9IG0gKiBzcmNgLlxyXG4gKlxyXG4gKiBAcGFyYW0gc3JjIFRoZSByaWdodCBtYXRyaXguXHJcbiAqIEBwYXJhbSBtIFRoZSBsZWZ0IG1hdHJpeC5cclxuICogQHBhcmFtIGRzdCBUaGUgbWF0cml4IHRoZSBwcm9kdWN0IHdpbGwgYmUgc3RvcmVkIHRvLiBDYW4gYmUgdGhlIHNhbWUgYXMgYHNyY2AuXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG11bChzcmMsIG0sIGRzdCA9IGNyZWF0ZSgpKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1BVFJJWF9TSVpFOyBpICs9IDQpIHtcclxuICAgICAgICBjb25zdCBtMGkgPSBzcmNbaV07XHJcbiAgICAgICAgY29uc3QgbTFpID0gc3JjW2kgKyAxXTtcclxuICAgICAgICBjb25zdCBtMmkgPSBzcmNbaSArIDJdO1xyXG4gICAgICAgIGNvbnN0IG0zaSA9IHNyY1tpICsgM107XHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCA0OyArK2opIHtcclxuICAgICAgICAgICAgZHN0W2kgKyBqXSA9IG0waSAqIG1bal0gKyBtMWkgKiBtWzQgKyBqXSArIG0yaSAqIG1bOCArIGpdICtcclxuICAgICAgICAgICAgICAgIG0zaSAqIG1bMTIgKyBqXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbi8qKlxyXG4gKiBBcHBsaWVzIGEgbWF0cml4IHRvIGEgdmVjdG9yLlxyXG4gKlxyXG4gKiBAcGFyYW0gbSBUaGUgbWF0cml4LlxyXG4gKiBAcGFyYW0gdiBUaGUgdmVjdG9yLlxyXG4gKiBAcmV0dXJucyBOb3JtYWxpemVkIHByb2R1Y3Qgb2YgbXVsdGlwbHlpbmcgdGhlIHZlY3RvciBieSB0aGUgbWF0cml4LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5KG0sIHYsIGRzdCA9IHZlY3RvcjMuY3JlYXRlKDAsIDAsIDApKSB7XHJcbiAgICBjb25zdCB3ID0gbVszXSAqIHYueCArIG1bN10gKiB2LnkgKyBtWzExXSAqIHYueiArIG1bMTVdO1xyXG4gICAgY29uc3QgeCA9IChtWzBdICogdi54ICsgbVs0XSAqIHYueSArIG1bOF0gKiB2LnogKyBtWzEyXSkgLyB3O1xyXG4gICAgY29uc3QgeSA9IChtWzFdICogdi54ICsgbVs1XSAqIHYueSArIG1bOV0gKiB2LnogKyBtWzEzXSkgLyB3O1xyXG4gICAgY29uc3QgeiA9IChtWzJdICogdi54ICsgbVs2XSAqIHYueSArIG1bMTBdICogdi56ICsgbVsxNF0pIC8gdztcclxuICAgIGRzdC54ID0geDtcclxuICAgIGRzdC55ID0geTtcclxuICAgIGRzdC56ID0gejtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuIiwiaW1wb3J0ICogYXMgbWF0cml4MyBmcm9tICcuL21hdHJpeDMnO1xyXG5pbXBvcnQgYXJlRnV6enlFcXVhbFNjYWxhciwgeyBERUZBVUxUX1RPTEVSQU5DRSB9IGZyb20gJy4uL3V0aWwvZnV6enlfZXF1YWwnO1xyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyB2ZWN0b3IgYW5kIGluaXRpYWxpemVzIGl0IHdpdGggZ2l2ZW4gY29tcG9uZW50cy5cclxuICpcclxuICogQHBhcmFtIHggWCBjb21wb25lbnQgb2YgdGhlIHZlY3Rvci5cclxuICogQHBhcmFtIHkgWSBjb21wb25lbnQgb2YgdGhlIHZlY3Rvci5cclxuICogQHBhcmFtIHogWiBjb21wb25lbnQgb2YgdGhlIHZlY3Rvci5cclxuICogQHJldHVybnMgVGhlIHZlY3Rvci5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoeCwgeSwgeikge1xyXG4gICAgcmV0dXJuIHsgeCwgeSwgeiB9O1xyXG59XHJcbmV4cG9ydCBjb25zdCBPUklHSU4gPSBjcmVhdGUoMCwgMCwgMCk7XHJcbmV4cG9ydCBjb25zdCBQT1NJVElWRV9YID0gY3JlYXRlKDEsIDAsIDApO1xyXG5leHBvcnQgY29uc3QgTkVHQVRJVkVfWCA9IGNyZWF0ZSgtMSwgMCwgMCk7XHJcbmV4cG9ydCBjb25zdCBQT1NJVElWRV9ZID0gY3JlYXRlKDAsIDEsIDApO1xyXG5leHBvcnQgY29uc3QgTkVHQVRJVkVfWSA9IGNyZWF0ZSgwLCAtMSwgMCk7XHJcbmV4cG9ydCBjb25zdCBQT1NJVElWRV9aID0gY3JlYXRlKDAsIDAsIDEpO1xyXG5leHBvcnQgY29uc3QgTkVHQVRJVkVfWiA9IGNyZWF0ZSgwLCAwLCAtMSk7XHJcbi8qKlxyXG4gKiBDb3BpZXMgYSB2ZWN0b3IgdG8gYW5vdGhlciBvbmUuXHJcbiAqXHJcbiAqIEBwYXJhbSBzcmMgVGhlIHNvdXJjZSB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBkc3QgVGhlIHZlY3RvciB0aGUgc291cmNlIHZlY3RvciB3aWxsIGJlIGNvcGllZCB0by5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29weShzcmMsIGRzdCA9IGNyZWF0ZSgwLCAwLCAwKSkge1xyXG4gICAgZHN0LnggPSBzcmMueDtcclxuICAgIGRzdC55ID0gc3JjLnk7XHJcbiAgICBkc3QueiA9IHNyYy56O1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogQ2hlY2tzIGlmIHR3byB2ZWN0b3JzIGFyZSBzdHJpY3RseSBlcXVhbCBjb21wb25lbnQtd2lzZS5cclxuICpcclxuICogQHBhcmFtIHYxIFRoZSBmaXJzdCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSB2MiBUaGUgc2Vjb25kIHZlY3Rvci5cclxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYXJlRXF1YWwodjEsIHYyKSB7XHJcbiAgICByZXR1cm4gdjEueCA9PT0gdjIueCAmJiB2MS55ID09PSB2Mi55ICYmIHYxLnogPT09IHYyLno7XHJcbn1cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBjb3JyZXNwb25kaW5nIGNvbXBvbmVudHMgb2YgdHdvIHZlY3RvcnMgYXJlIGFsbCB3aXRoaW4gZ2l2ZW5cclxuICogdG9sZXJhbmNlIGZyb20gZWFjaCBvdGhlci5cclxuICpcclxuICogQHBhcmFtIHYxIFRoZSBmaXJzdCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSB2MiBUaGUgc2Vjb25kIHZlY3Rvci5cclxuICogQHBhcmFtIHRvbGVyYW5jZSBUaGUgdG9sZXJhbmNlLlxyXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZlY3RvcnMgYXJlIFwiZnV6enlcIiBlcXVhbCBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYXJlRnV6enlFcXVhbCh2MSwgdjIsIHRvbGVyYW5jZSA9IERFRkFVTFRfVE9MRVJBTkNFKSB7XHJcbiAgICByZXR1cm4gKGFyZUZ1enp5RXF1YWxTY2FsYXIodjEueCwgdjIueCwgdG9sZXJhbmNlKSAmJlxyXG4gICAgICAgIGFyZUZ1enp5RXF1YWxTY2FsYXIodjEueSwgdjIueSwgdG9sZXJhbmNlKSAmJlxyXG4gICAgICAgIGFyZUZ1enp5RXF1YWxTY2FsYXIodjEueiwgdjIueiwgdG9sZXJhbmNlKSk7XHJcbn1cclxuLyoqXHJcbiAqIENoZWNrcyBpZiB0d28gdmVjdG9ycyBhcmUgY29sbGluZWFyLlxyXG4gKlxyXG4gKiBAcGFyYW0gdjEgVGhlIGZpcnN0IHZlY3Rvci5cclxuICogQHBhcmFtIHYyIFRoZSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZlY3RvcnMgYXJlIGNvbGxpbmVhciBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYXJlQ29sbGluZWFyKHYxLCB2Mikge1xyXG4gICAgY29uc3QgbGFtYmRhWCA9IHYxLnggLyB2Mi54O1xyXG4gICAgY29uc3QgbGFtYmRhWSA9IHYxLnkgLyB2Mi55O1xyXG4gICAgY29uc3QgbGFtYmRhWiA9IHYxLnogLyB2Mi56O1xyXG4gICAgcmV0dXJuIGxhbWJkYVggPT09IGxhbWJkYVkgJiYgbGFtYmRhWSA9PT0gbGFtYmRhWjtcclxufVxyXG4vKipcclxuICogQWRkcyB0d28gdmVjdG9yIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbnRvIGEgdGhpcmQgb25lLCBpLmUuIGBkc3QgPSBhICsgYmAuXHJcbiAqXHJcbiAqIEBwYXJhbSBhIFRoZSBmaXJzdCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSB2ZWN0b3IgdGhlIHJlc3VsdCB3aWxsIGJlIHN0b3JlZCB0by5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYWRkKGEsIGIsIGRzdCA9IGNyZWF0ZSgwLCAwLCAwKSkge1xyXG4gICAgZHN0LnggPSBhLnggKyBiLng7XHJcbiAgICBkc3QueSA9IGEueSArIGIueTtcclxuICAgIGRzdC56ID0gYS56ICsgYi56O1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogU3VidHJhY3RzIGEgdmVjdG9yIGZyb20gYW5vdGhlciBvbmUgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IHRvIGEgdGhpcmQgb25lLCBpLmUuXHJcbiAqIGBkc3QgPSBhIC0gYmAuXHJcbiAqXHJcbiAqIEBwYXJhbSBhIFRoZSBtaW51ZW5kIHZlY3Rvci5cclxuICogQHBhcmFtIGIgVGhlIHN1YnRyYWhlbmQgdmVjdG9yLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSB2ZWN0b3IgdGhlIHJlc3VsdCB3aWxsIGJlIHN0b3JlZCB0by5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzdWIoYSwgYiwgZHN0ID0gY3JlYXRlKDAsIDAsIDApKSB7XHJcbiAgICBkc3QueCA9IGEueCAtIGIueDtcclxuICAgIGRzdC55ID0gYS55IC0gYi55O1xyXG4gICAgZHN0LnogPSBhLnogLSBiLno7XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbi8qKlxyXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWN0b3JzIGNvbXBvbmVudC13aXNlIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbnRvIGEgdGhpcmQgb25lLlxyXG4gKlxyXG4gKiBAcGFyYW0gYSBUaGUgZmlyc3QgdmVjdG9yLlxyXG4gKiBAcGFyYW0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cclxuICogQHBhcmFtIGRzdCBUaGUgdmVjdG9yIHRoZSByZXN1bHQgd2lsbCBiZSBzdG9yZWQgdG8uXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG11bHYoYSwgYiwgZHN0ID0gY3JlYXRlKDAsIDAsIDApKSB7XHJcbiAgICBkc3QueCA9IGEueCAqIGIueDtcclxuICAgIGRzdC55ID0gYS55ICogYi55O1xyXG4gICAgZHN0LnogPSBhLnogKiBiLno7XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbi8qKlxyXG4gKiBNdWx0aXBsaWVzIGEgdmVjdG9yIGJ5IGEgc2NhbGFyIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbnRvIGEgdGhpcmQgdmVjdG9yLlxyXG4gKlxyXG4gKiBAcGFyYW0gYSBUaGUgdmVjdG9yLlxyXG4gKiBAcGFyYW0gbiBUaGUgc2NhbGFyLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSB2ZWN0b3IgdGhlIHJlc3VsdCB3aWxsIGJlIHN0b3JlZCB0by5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbXVsbihhLCBuLCBkc3QgPSBjcmVhdGUoMCwgMCwgMCkpIHtcclxuICAgIGRzdC54ID0gYS54ICogbjtcclxuICAgIGRzdC55ID0gYS55ICogbjtcclxuICAgIGRzdC56ID0gYS56ICogbjtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIERpdmlkZXMgYSB2ZWN0b3IgYnkgYW5vdGhlciBvbmUgY29tcG9uZW50IHdpc2UgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGludG8gYVxyXG4gKiB0aGlyZCBvbmUuXHJcbiAqXHJcbiAqIEBwYXJhbSBhIFRoZSBkaXZpZGVuZCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBiIFRoZSBkaXZpc29yIHZlY3Rvci5cclxuICogQHBhcmFtIGRzdCBUaGUgdmVjdG9yIHRoZSByZXN1bHQgd2lsbCBiZSBzdG9yZWQgdG8uXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRpdnYoYSwgYiwgZHN0ID0gY3JlYXRlKDAsIDAsIDApKSB7XHJcbiAgICBkc3QueCA9IGEueCAvIGIueDtcclxuICAgIGRzdC55ID0gYS55IC8gYi55O1xyXG4gICAgZHN0LnogPSBhLnogLyBiLno7XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbi8qKlxyXG4gKiBEaXZpZGVzIGEgdmVjdG9yIGJ5IGEgc2NhbGFyIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbnRvIGEgdGhpcmQgdmVjdG9yLlxyXG4gKlxyXG4gKiBAcGFyYW0gYSBUaGUgZGl2aWRlbmQgdmVjdG9yLlxyXG4gKiBAcGFyYW0gbiBUaGUgc2NhbGFyLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSB2ZWN0b3IgdGhlIHJlc3VsdCB3aWxsIGJlIHN0b3JlZCB0by5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZGl2bihhLCBuLCBkc3QgPSBjcmVhdGUoMCwgMCwgMCkpIHtcclxuICAgIGRzdC54ID0gYS54IC8gbjtcclxuICAgIGRzdC55ID0gYS55IC8gbjtcclxuICAgIGRzdC56ID0gYS56IC8gbjtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIENvbXB1dGVzIGxlbmd0aCBvZiBhIHZlY3Rvci5cclxuICpcclxuICogQHBhcmFtIHYgVGhlIHZlY3Rvci5cclxuICogQHJldHVybnMgVGhlIGxlbmd0aC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBsZW5ndGgodikge1xyXG4gICAgcmV0dXJuIE1hdGguaHlwb3Qodi54LCB2LnksIHYueik7XHJcbn1cclxuLyoqXHJcbiAqIENvbXB1dGVzIGRpc3RhbmNlIGJldHdlZW4gZW5kcyBvZiB0d28gdmVjdG9ycy5cclxuICpcclxuICogQHBhcmFtIGEgVGhlIGZpcnN0IHZlY3Rvci5cclxuICogQHBhcmFtIGIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEByZXR1cm5zIFRoZSBkaXN0YW5jZSwgaS5lLiBgbGVuZ3RoKHN1YihhLCBiKSlgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRpc3RhbmNlKGEsIGIpIHtcclxuICAgIHJldHVybiBNYXRoLmh5cG90KGEueCAtIGIueCwgYS55IC0gYi55LCBhLnogLSBiLnopO1xyXG59XHJcbi8qKlxyXG4gKiBEaXZpZGVzIGEgdmVjdG9yIGJ5IGl0cyBsZW5ndGggKHRodXMgbWFraW5nIGl0IGEgdW5pdCB2ZWN0b3IpIGFuZCBzdG9yZXMgdGhlXHJcbiAqIHJlc3VsdCB0byBhbm90aGVyIG9uZS5cclxuICpcclxuICogQHBhcmFtIHYgVGhlIHZlY3RvciB0byBiZSBub3JtYWxpemVkLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSB2ZWN0b3IgdGhlIHJlc3VsdCB3aWxsIGJlIHN0b3JlZCB0by5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplKHYsIGRzdCA9IGNyZWF0ZSgwLCAwLCAwKSkge1xyXG4gICAgcmV0dXJuIGRpdm4odiwgbGVuZ3RoKHYpLCBkc3QpO1xyXG59XHJcbi8qKlxyXG4gKiBDb21wdXRlcyBkb3QgcHJvZHVjdCBvZiB0d28gdmVjdG9ycy5cclxuICpcclxuICogQHBhcmFtIGEgVGhlIGZpcnN0IHZlY3Rvci5cclxuICogQHBhcmFtIGIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEByZXR1cm5zIFRoZSBkb3QgcHJvZHVjdC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBkb3QoYSwgYikge1xyXG4gICAgcmV0dXJuIGEueCAqIGIueCArIGEueSAqIGIueSArIGEueiAqIGIuejtcclxufVxyXG4vKipcclxuICogQ29tcHV0ZXMgY3Jvc3MgcHJvZHVjdCBvZiB0d28gdmVjdG9ycyBhbmQgc3RvcmVzIGl0IHRvIGEgdGhpcmQgb25lLlxyXG4gKlxyXG4gKiBAcGFyYW0gYSBUaGUgZmlyc3QgdmVjdG9yLlxyXG4gKiBAcGFyYW0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cclxuICogQHBhcmFtIGRzdCBUaGUgdmVjdG9yIHRoZSByZXN1bHQgd2lsbCBiZSBzdG9yZWQgdG8uXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNyb3NzKGEsIGIsIGRzdCA9IGNyZWF0ZSgwLCAwLCAwKSkge1xyXG4gICAgLy8gV3JpdGUgY29tcG9uZW50cyB0byBhIHNlcGFyYXRlIHZhcmlhYmxlcyBzbyB3ZSBkb24ndCBwcm9kdWNlIGluY29ycmVjdFxyXG4gICAgLy8gcmVzdWx0cyBpbiBjYXNlcyB3aGVuIGEgPT0gZHN0IG9yIGIgPT0gZHN0LlxyXG4gICAgY29uc3QgeCA9IGEueSAqIGIueiAtIGEueiAqIGIueTtcclxuICAgIGNvbnN0IHkgPSBhLnogKiBiLnggLSBhLnggKiBiLno7XHJcbiAgICBjb25zdCB6ID0gYS54ICogYi55IC0gYS55ICogYi54O1xyXG4gICAgZHN0LnggPSB4O1xyXG4gICAgZHN0LnkgPSB5O1xyXG4gICAgZHN0LnogPSB6O1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogUm90YXRlcyB2ZWN0b3IgYWJvdXQgdGhlIFggYXhpcy5cclxuICpcclxuICogQHBhcmFtIHYgVGhlIHZlY3RvciB0byBiZSByb3RhdGVkLlxyXG4gKiBAcGFyYW0gYW5nbGUgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uIChpbiByYWRpYW5zKSwgcG9zaXRpdmUgdmFsdWVzIHJvdGF0ZXMgZnJvbSArWSB0byArWlxyXG4gKiBAcGFyYW0gZHN0IFRoZSB2ZWN0b3IgdGhlIHJlc3VsdCB3aWxsIGJlIHN0b3JlZCB0by5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVYKHYsIGFuZ2xlLCBkc3QgPSBjcmVhdGUoMCwgMCwgMCkpIHtcclxuICAgIGNvbnN0IGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcclxuICAgIGNvbnN0IHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcclxuICAgIGNvbnN0IHkgPSB2Lnk7XHJcbiAgICBkc3QueCA9IHYueDtcclxuICAgIGRzdC55ID0geSAqIGNvcyAtIHYueiAqIHNpbjtcclxuICAgIGRzdC56ID0geSAqIHNpbiArIHYueiAqIGNvcztcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIFJvdGF0ZXMgdmVjdG9yIGFib3V0IHRoZSBZIGF4aXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB2IFRoZSB2ZWN0b3IgdG8gYmUgcm90YXRlZC5cclxuICogQHBhcmFtIGFuZ2xlIFRoZSBhbmdsZSBvZiByb3RhdGlvbiAoaW4gcmFkaWFucyksIHBvc2l0aXZlIHZhbHVlcyByb3RhdGVzIGZyb20gK1ggdG8gK1pcclxuICogQHBhcmFtIGRzdCBUaGUgdmVjdG9yIHRoZSByZXN1bHQgd2lsbCBiZSBzdG9yZWQgdG8uXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWSh2LCBhbmdsZSwgZHN0ID0gY3JlYXRlKDAsIDAsIDApKSB7XHJcbiAgICBjb25zdCBjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XHJcbiAgICBjb25zdCBzaW4gPSBNYXRoLnNpbihhbmdsZSk7XHJcbiAgICAvLyBoYW5kbGUgdGhlIGNhc2Ugd2hlbiBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGFyZSB0aGUgc2FtZSBvYmplY3Q6IHJlbGF0ZWQgY29tcG9uZW50cyBjYW4gYnJlYWsgZWFjaCBvdGhlclxyXG4gICAgdiA9ICh2ID09PSBkc3QpID8gY29weSh2KSA6IHY7XHJcbiAgICBkc3QueCA9IHYueCAqIGNvcyArIHYueiAqIHNpbjtcclxuICAgIGRzdC55ID0gdi55O1xyXG4gICAgZHN0LnogPSAtdi54ICogc2luICsgdi56ICogY29zO1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogUm90YXRlcyB2ZWN0b3IgYWJvdXQgdGhlIFogYXhpcy5cclxuICpcclxuICogQHBhcmFtIHYgVGhlIHZlY3RvciB0byBiZSByb3RhdGVkLlxyXG4gKiBAcGFyYW0gYW5nbGUgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uIChpbiByYWRpYW5zKSwgcG9zaXRpdmUgdmFsdWVzIHJvdGF0ZXMgZnJvbSArWCB0byArWVxyXG4gKiBAcGFyYW0gZHN0IFRoZSB2ZWN0b3IgdGhlIHJlc3VsdCB3aWxsIGJlIHN0b3JlZCB0by5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVaKHYsIGFuZ2xlLCBkc3QgPSBjcmVhdGUoMCwgMCwgMCkpIHtcclxuICAgIGNvbnN0IGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcclxuICAgIGNvbnN0IHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcclxuICAgIC8vIGhhbmRsZSB0aGUgY2FzZSB3aGVuIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gYXJlIHRoZSBzYW1lIG9iamVjdDogcmVsYXRlZCBjb21wb25lbnRzIGNhbiBicmVhayBlYWNoIG90aGVyXHJcbiAgICB2ID0gKHYgPT09IGRzdCkgPyBjb3B5KHYpIDogdjtcclxuICAgIGRzdC54ID0gdi54ICogY29zIC0gdi55ICogc2luO1xyXG4gICAgZHN0LnkgPSB2LnggKiBzaW4gKyB2LnkgKiBjb3M7XHJcbiAgICBkc3QueiA9IHYuejtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuZXhwb3J0IGNvbnN0IFhfQVhJUyA9IHtcclxuICAgIG9yaWdpbjogT1JJR0lOLFxyXG4gICAgdGFuZ2VudDogUE9TSVRJVkVfWFxyXG59O1xyXG5leHBvcnQgY29uc3QgWV9BWElTID0ge1xyXG4gICAgb3JpZ2luOiBPUklHSU4sXHJcbiAgICB0YW5nZW50OiBQT1NJVElWRV9ZXHJcbn07XHJcbmV4cG9ydCBjb25zdCBaX0FYSVMgPSB7XHJcbiAgICBvcmlnaW46IE9SSUdJTixcclxuICAgIHRhbmdlbnQ6IFBPU0lUSVZFX1pcclxufTtcclxuZXhwb3J0IGNvbnN0IFhZID0ge1xyXG4gICAgbm9ybWFsOiBQT1NJVElWRV9aLFxyXG4gICAgZGlzdGFuY2U6IDBcclxufTtcclxuZXhwb3J0IGNvbnN0IFlaID0ge1xyXG4gICAgbm9ybWFsOiBQT1NJVElWRV9YLFxyXG4gICAgZGlzdGFuY2U6IDBcclxufTtcclxuZXhwb3J0IGNvbnN0IFpYID0ge1xyXG4gICAgbm9ybWFsOiBQT1NJVElWRV9ZLFxyXG4gICAgZGlzdGFuY2U6IDBcclxufTtcclxuLyoqXHJcbiAqIENvbXB1dGVzIGludGVyc2VjdGlvbiBvZiBhIHBsYW5lIGFuZCBhIGxpbmUuXHJcbiAqXHJcbiAqIEBwYXJhbSBwIFRoZSBwbGFuZS5cclxuICogQHBhcmFtIGwgVGhlIGxpbmUuXHJcbiAqIEByZXR1cm5zIFRoZSBwb2ludCBvciBgbnVsbGAgaWYgdGhlIGxpbmUgaXMgcGFyYWxsZWwgdG8gdGhlIHBsYW5lLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFBsYW5lTGluZUludGVyc2VjdGlvbihwLCBsKSB7XHJcbiAgICBjb25zdCBkb3RMUCA9IGRvdChsLnRhbmdlbnQsIHAubm9ybWFsKTtcclxuICAgIC8vIElmIHBsYW5lIG5vcm1hbCBhbmQgbGluZSB0YW5nZW50IHZlY3RvciBhcmUgcGVycGVuZGljdWxhciBpbnRlcnNlY3Rpb24gaXNcclxuICAgIC8vIGVpdGhlciBhbiBlbXB0eSBzZXQgb3IgdGhlIGxpbmUgaXRzZWxmLlxyXG4gICAgaWYgKGRvdExQID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBjb25zdCBpbnRlcnNlY3Rpb24gPSBjb3B5KGwudGFuZ2VudCk7XHJcbiAgICBtdWxuKGludGVyc2VjdGlvbiwgKHAuZGlzdGFuY2UgLSBkb3QocC5ub3JtYWwsIGwub3JpZ2luKSkgLyBkb3RMUCwgaW50ZXJzZWN0aW9uKTtcclxuICAgIGFkZChpbnRlcnNlY3Rpb24sIGwub3JpZ2luLCBpbnRlcnNlY3Rpb24pO1xyXG4gICAgcmV0dXJuIGludGVyc2VjdGlvbjtcclxufVxyXG4vKipcclxuICogQ29tcHV0ZXMgYW4gaW50ZXJzZWN0aW9uIG9mIGEgcGxhbmUgYW5kIGEgcmF5IGFuZCBzdG9yZXMgaXQgaW50byBhIGdpdmVuXHJcbiAqIHZlY3Rvci5cclxuICpcclxuICogQHBhcmFtIHBsYW5lIFRoZSBwbGFuZS5cclxuICogQHBhcmFtIHJheSBUaGUgcmF5LlxyXG4gKiBAcGFyYW0gZHN0IFRoZSB2ZWN0b3IgdGhlIGludGVyc2VjdGlvbiBwb2ludCB3aWxsIGJlIHN0b3JlZCB0by4gSWYgdGhlcmUncyBub1xyXG4gKiAgICAgIGludGVyc2VjdGlvbiwgdGhpcyB2ZWN0b3Igd2lsbCBiZSBsZWZ0IHVubW9kaWZpZWQuXHJcbiAqIEByZXR1cm5zIFRoZSBgZHN0YCBvciBgbnVsbGAgaWYgdGhlIHJheSBkb2Vzbid0IGhhdmUgYSBjb21tb24gcG9pbnQgd2l0aCB0aGVcclxuICogICAgICBwbGFuZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRQbGFuZVJheUludGVyc2VjdGlvbihwbGFuZSwgcmF5LCBkc3QgPSBjcmVhdGUoMCwgMCwgMCkpIHtcclxuICAgIGNvbnN0IGRvdFJQID0gZG90KHJheS5kaXJlY3Rpb24sIHBsYW5lLm5vcm1hbCk7XHJcbiAgICBpZiAoZG90UlAgPT09IDApIHtcclxuICAgICAgICAvLyBUaGUgcGxhbmUgbm9ybWFsIGFuZCB0aGUgcmF5IGRpcmVjdGlvbiB2ZWN0b3IgYXJlIHBlcnBlbmRpY3VsYXIsIHNvXHJcbiAgICAgICAgLy8gaW50ZXJzZWN0aW9uIGlzIGVpdGhlciBhbiBlbXB0eSBzZXQgb3IgdGhlIHJheSBpdHNlbGYuXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBjb25zdCBsYW1iZGEgPSAocGxhbmUuZGlzdGFuY2UgLSBkb3QocGxhbmUubm9ybWFsLCByYXkub3JpZ2luKSkgLyBkb3RSUDtcclxuICAgIGlmIChsYW1iZGEgPCAwKSB7XHJcbiAgICAgICAgLy8gVGhlIGludGVyc2VjdGlvbiBwb2ludCBpcyBvbiBhIGxpbmUgdGhhdCBjb250YWlucyB0aGUgcmF5LCBidXQgbm90IG9uXHJcbiAgICAgICAgLy8gdGhlIHJheSBpdHNlbGYuXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBjb3B5KHJheS5kaXJlY3Rpb24sIGRzdCk7XHJcbiAgICBtdWxuKGRzdCwgbGFtYmRhLCBkc3QpO1xyXG4gICAgYWRkKGRzdCwgcmF5Lm9yaWdpbiwgZHN0KTtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIENvbXB1dGVzIGludGVyc2VjdGlvbiBvZiB0d28gcGxhbmVzLlxyXG4gKlxyXG4gKiBAcGFyYW0gcDEgVGhlIGZpcnN0IHBsYW5lLlxyXG4gKiBAcGFyYW0gcDIgVGhlIHNlY29uZCBwbGFuZS5cclxuICogQHJldHVybnMgVGhlIGxpbmUgb3IgYG51bGxgIGlmIHRoZSBwbGFuZXMgYXJlIHBhcmFsbGVsIHRvIGVhY2ggb3RoZXIuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGxhbmVQbGFuZUludGVyc2VjdGlvbihwMSwgcDIpIHtcclxuICAgIGNvbnN0IG4xID0gcDEubm9ybWFsO1xyXG4gICAgY29uc3QgbjIgPSBwMi5ub3JtYWw7XHJcbiAgICBpZiAoYXJlQ29sbGluZWFyKG4xLCBuMikpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGNvbnN0IHRhbmdlbnQgPSBjcm9zcyhuMSwgbjIpO1xyXG4gICAgbm9ybWFsaXplKHRhbmdlbnQpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0YW5nZW50LFxyXG4gICAgICAgIG9yaWdpbjogbWF0cml4My5zb2x2ZShtYXRyaXgzLmZyb21Sb3dzKG4xLCBuMiwgdGFuZ2VudCksIGNyZWF0ZShwMS5kaXN0YW5jZSwgcDIuZGlzdGFuY2UsIDApKVxyXG4gICAgfTtcclxufVxyXG4iLCJpbXBvcnQgKiBhcyB2ZWN0b3IzIGZyb20gJy4vdmVjdG9yMyc7XHJcbmNvbnN0IE1BVFJJWF9TSVpFID0gOTtcclxuLyoqXHJcbiAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBuZXcgKip1bmluaXRpYWxpemVkKiogbWF0cml4LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcclxuICAgIHJldHVybiBuZXcgQXJyYXkoTUFUUklYX1NJWkUpO1xyXG59XHJcbi8qKlxyXG4gKiBaZXJvZXMgYSBtYXRyaXguXHJcbiAqXHJcbiAqIEBwYXJhbSBkc3QgVGhlIG1hdHJpeC5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gemVybyhkc3QgPSBjcmVhdGUoKSkge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNQVRSSVhfU0laRTsgKytpKSB7XHJcbiAgICAgICAgZHN0W2ldID0gMDtcclxuICAgIH1cclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIENvcGllcyB0aHJlZSB2ZWN0b3JzIHRvIGEgbWF0cml4IGFzIHJvd3MuXHJcbiAqXHJcbiAqIEBwYXJhbSByMCBUaGUgZmlyc3Qgcm93LlxyXG4gKiBAcGFyYW0gcjEgVGhlIHNlY29uZCByb3cuXHJcbiAqIEBwYXJhbSByMiBUaGUgdGhpcmQgcm93LlxyXG4gKiBAcGFyYW0gZHN0IFRoZSBtYXRyaXggdGhlIHJvd3Mgd2lsbCBiZSB3cml0dGVuIHRvLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBmcm9tUm93cyhyMCwgcjEsIHIyLCBkc3QgPSBjcmVhdGUoKSkge1xyXG4gICAgZHN0WzBdID0gcjAueDtcclxuICAgIGRzdFsxXSA9IHIxLng7XHJcbiAgICBkc3RbMl0gPSByMi54O1xyXG4gICAgZHN0WzNdID0gcjAueTtcclxuICAgIGRzdFs0XSA9IHIxLnk7XHJcbiAgICBkc3RbNV0gPSByMi55O1xyXG4gICAgZHN0WzZdID0gcjAuejtcclxuICAgIGRzdFs3XSA9IHIxLno7XHJcbiAgICBkc3RbOF0gPSByMi56O1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBhcnJheSBvZiBjb2x1bW5zIG9mIGEgbWF0cml4LlxyXG4gKlxyXG4gKiBAcGFyYW0gbSBUaGUgbWF0cml4LlxyXG4gKiBAcGFyYW0gZHN0IFRoZSBhcnJheSBjb2x1bW5zIG9mIHRoZSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIHRvLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb2x1bW5zKG0sIGRzdCA9IFtcclxuICAgIHZlY3RvcjMuY3JlYXRlKDAsIDAsIDApLFxyXG4gICAgdmVjdG9yMy5jcmVhdGUoMCwgMCwgMCksXHJcbiAgICB2ZWN0b3IzLmNyZWF0ZSgwLCAwLCAwKVxyXG5dKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCAzOyArK2ksIGogKz0gMykge1xyXG4gICAgICAgIGRzdFtpXS54ID0gbVtqXTtcclxuICAgICAgICBkc3RbaV0ueSA9IG1baiArIDFdO1xyXG4gICAgICAgIGRzdFtpXS56ID0gbVtqICsgMl07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbi8qKlxyXG4gKiBDb3BpZXMgdGhyZWUgdmVjdG9ycyB0byBhIG1hdHJpeCBhcyBjb2x1bW5zLlxyXG4gKlxyXG4gKiBAcGFyYW0gYzAgVGhlIGZpcnN0IGNvbHVtbi5cclxuICogQHBhcmFtIGMxIFRoZSBzZWNvbmQgY29sdW1uLlxyXG4gKiBAcGFyYW0gYzIgVGhlIHRoaXJkIGNvbHVtbi5cclxuICogQHBhcmFtIGRzdCBUaGUgbWF0cml4IHRoZSBjb2x1bW5zIHdpbGwgYmUgd3JpdHRlbiB0by5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZnJvbUNvbHVtbnMoYzAsIGMxLCBjMiwgZHN0ID0gY3JlYXRlKCkpIHtcclxuICAgIGRzdFswXSA9IGMwLng7XHJcbiAgICBkc3RbMV0gPSBjMC55O1xyXG4gICAgZHN0WzJdID0gYzAuejtcclxuICAgIGRzdFszXSA9IGMxLng7XHJcbiAgICBkc3RbNF0gPSBjMS55O1xyXG4gICAgZHN0WzVdID0gYzEuejtcclxuICAgIGRzdFs2XSA9IGMyLng7XHJcbiAgICBkc3RbN10gPSBjMi55O1xyXG4gICAgZHN0WzhdID0gYzIuejtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIENvbXB1dGVzIGRldGVybWluYW50IG9mIGEgbWF0cml4LlxyXG4gKlxyXG4gKiBAcGFyYW0gbSBUaGUgbWF0cml4LlxyXG4gKiBAcmV0dXJucyBUaGUgZGV0ZXJtaW5hbnQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZGV0ZXJtaW5hbnQobSkge1xyXG4gICAgcmV0dXJuIG1bMF0gKiAobVs0XSAqIG1bOF0gLSBtWzddICogbVs1XSkgK1xyXG4gICAgICAgIG1bM10gKiAobVsxXSAqIG1bOF0gLSBtWzddICogbVsyXSkgK1xyXG4gICAgICAgIG1bNl0gKiAobVsxXSAqIG1bNV0gLSBtWzRdICogbVsyXSk7XHJcbn1cclxuY29uc3Qgc3RhdGljTWF0cml4Q29sdW1ucyA9IFtcclxuICAgIC8vIE5vdCB1c2luZyB2ZWN0b3IzLmNyZWF0ZSBoZXJlIGR1ZSB0byBjaXJjdWxhciBkZXBlbmRlbmN5LlxyXG4gICAgeyB4OiAwLCB5OiAwLCB6OiAwIH0sXHJcbiAgICB7IHg6IDAsIHk6IDAsIHo6IDAgfSxcclxuICAgIHsgeDogMCwgeTogMCwgejogMCB9XHJcbl07XHJcbmNvbnN0IHN0YXRpY01hdHJpeCA9IGNyZWF0ZSgpO1xyXG4vKipcclxuICogU29sdmVzIGEgc3lzdGVtIG9mIGxpbmVhciBlcXVhdGlvbnMgcmVwcmVzZW50ZWQgd2l0aCBhIG1hdHJpeCBhbmQgYSB2ZWN0b3IsXHJcbiAqIGkuZS46XHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBtICogKHgsIHkgLHopXlQgPSB2XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBVc2VzIENyYW1lcidzIHJ1bGUuXHJcbiAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ3JhbWVyJ3NfcnVsZVxyXG4gKlxyXG4gKiBAcGFyYW0gbSBUaGUgbWF0cml4IG9mIHRoZSBzeXN0ZW0uXHJcbiAqIEBwYXJhbSB2IFRoZSB2ZWN0b3Igb2YgdGhlIHN5c3RlbS5cclxuICogQHBhcmFtIGRzdCBUaGUgdmVjdG9yIHNvbHV0aW9uIG9mIHRoZSBzeXN0ZW0gd2lsbCBiZSB3cml0dGVuIHRvLlxyXG4gKiBAcmV0dXJuIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNvbHZlKG0sIHYsIGRzdCA9IHZlY3RvcjMuY3JlYXRlKDAsIDAsIDApKSB7XHJcbiAgICBjb25zdCByZXZEZXQgPSAxIC8gZGV0ZXJtaW5hbnQobSk7XHJcbiAgICBjb25zdCBbYzAsIGMxLCBjMl0gPSBjb2x1bW5zKG0sIHN0YXRpY01hdHJpeENvbHVtbnMpO1xyXG4gICAgZHN0LnggPSByZXZEZXQgKiBkZXRlcm1pbmFudChmcm9tQ29sdW1ucyh2LCBjMSwgYzIsIHN0YXRpY01hdHJpeCkpO1xyXG4gICAgZHN0LnkgPSByZXZEZXQgKiBkZXRlcm1pbmFudChmcm9tQ29sdW1ucyhjMCwgdiwgYzIsIHN0YXRpY01hdHJpeCkpO1xyXG4gICAgZHN0LnogPSByZXZEZXQgKiBkZXRlcm1pbmFudChmcm9tQ29sdW1ucyhjMCwgYzEsIHYsIHN0YXRpY01hdHJpeCkpO1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4iLCJleHBvcnQgY29uc3QgREVGQVVMVF9UT0xFUkFOQ0UgPSAxZS02O1xyXG4vKipcclxuICogQ2hlY2tzIGlmIHR3byBmbG9hdGluZyBwb2ludCBudW1iZXIgYXJlIHdpdGhpbiBhIHRvbGVyYW5jZSBmcm9tIGVhY2ggb3RoZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSBhIFRoZSBmaXJzdCBudW1iZXIuXHJcbiAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgbnVtYmVyLlxyXG4gKiBAcGFyYW0gdG9sZXJhbmNlIFRoZSB0b2xlcmFuY2UuXHJcbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgbnVtYmVyIGFyZSB3aXRoaW4gdGhlIHRvbGVyYW5jZSBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhcmVGdXp6eUVxdWFsKGEsIGIsIHRvbGVyYW5jZSA9IERFRkFVTFRfVE9MRVJBTkNFKSB7XHJcbiAgICBjb25zdCBkID0gYSAtIGI7XHJcbiAgICByZXR1cm4gLXRvbGVyYW5jZSA8IGQgJiYgZCA8IHRvbGVyYW5jZTtcclxufVxyXG4iLCJpbXBvcnQgYXJlRnV6enlFcXVhbFNjYWxhciwgeyBERUZBVUxUX1RPTEVSQU5DRSB9IGZyb20gJy4uL3V0aWwvZnV6enlfZXF1YWwnO1xyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyB2ZWN0b3IgYW5kIGluaXRpYWxpemVzIGl0IHdpdGggZ2l2ZW4gY29tcG9uZW50cy5cclxuICpcclxuICogQHBhcmFtIHggWCBjb21wb25lbnQgb2YgdGhlIHZlY3Rvci5cclxuICogQHBhcmFtIHkgWSBjb21wb25lbnQgb2YgdGhlIHZlY3Rvci5cclxuICogQHJldHVybnMgVGhlIHZlY3Rvci5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoeCwgeSkge1xyXG4gICAgcmV0dXJuIHsgeCwgeSB9O1xyXG59XHJcbmV4cG9ydCBjb25zdCBaRVJPID0gY3JlYXRlKDAsIDApO1xyXG5leHBvcnQgY29uc3QgT1JJR0lOID0gWkVSTztcclxuZXhwb3J0IGNvbnN0IFBPU0lUSVZFX1ggPSBjcmVhdGUoMSwgMCk7XHJcbmV4cG9ydCBjb25zdCBORUdBVElWRV9YID0gY3JlYXRlKC0xLCAwKTtcclxuZXhwb3J0IGNvbnN0IFBPU0lUSVZFX1kgPSBjcmVhdGUoMCwgMSk7XHJcbmV4cG9ydCBjb25zdCBORUdBVElWRV9ZID0gY3JlYXRlKDAsIC0xKTtcclxuLyoqXHJcbiAqIENvcGllcyBhIHZlY3RvciB0byBhbm90aGVyIG9uZS5cclxuICpcclxuICogQHBhcmFtIHNyYyBUaGUgc291cmNlIHZlY3Rvci5cclxuICogQHBhcmFtIGRzdCBUaGUgdmVjdG9yIHRoZSBzb3VyY2UgdmVjdG9yIHdpbGwgYmUgY29waWVkIHRvLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb3B5KHNyYywgZHN0ID0gY3JlYXRlKDAsIDApKSB7XHJcbiAgICBkc3QueCA9IHNyYy54O1xyXG4gICAgZHN0LnkgPSBzcmMueTtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIENoZWNrcyBpZiB0d28gdmVjdG9ycyBhcmUgc3RyaWN0bHkgZXF1YWwgY29tcG9uZW50LXdpc2UuXHJcbiAqXHJcbiAqIEBwYXJhbSB2MSBUaGUgZmlyc3QgdmVjdG9yLlxyXG4gKiBAcGFyYW0gdjIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGFyZUVxdWFsKHYxLCB2Mikge1xyXG4gICAgcmV0dXJuIHYxLnggPT09IHYyLnggJiYgdjEueSA9PT0gdjIueTtcclxufVxyXG4vKipcclxuICogQ2hlY2tzIGlmIHR3byB2ZWN0b3JzIGFyZSBjb2xsaW5lYXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB2MSBUaGUgZmlyc3QgdmVjdG9yLlxyXG4gKiBAcGFyYW0gdjIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmVjdG9ycyBhcmUgY29sbGluZWFyIGFuZCBgZmFsc2VgIG90aGVyd2lzZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBhcmVDb2xsaW5lYXIodjEsIHYyKSB7XHJcbiAgICByZXR1cm4gdjEueCAvIHYyLnggPT09IHYxLnkgLyB2Mi55O1xyXG59XHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgY29ycmVzcG9uZGluZyBjb21wb25lbnRzIG9mIHR3byB2ZWN0b3JzIGFyZSBhbGwgd2l0aGluIGdpdmVuXHJcbiAqIHRvbGVyYW5jZSBmcm9tIGVhY2ggb3RoZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB2MSBUaGUgZmlyc3QgdmVjdG9yLlxyXG4gKiBAcGFyYW0gdjIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSB0b2xlcmFuY2UgVGhlIHRvbGVyYW5jZS5cclxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB2ZWN0b3JzIGFyZSBcImZ1enp5XCIgZXF1YWwgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGFyZUZ1enp5RXF1YWwodjEsIHYyLCB0b2xlcmFuY2UgPSBERUZBVUxUX1RPTEVSQU5DRSkge1xyXG4gICAgcmV0dXJuIChhcmVGdXp6eUVxdWFsU2NhbGFyKHYxLngsIHYyLngsIHRvbGVyYW5jZSkgJiZcclxuICAgICAgICBhcmVGdXp6eUVxdWFsU2NhbGFyKHYxLnksIHYyLnksIHRvbGVyYW5jZSkpO1xyXG59XHJcbi8qKlxyXG4gKiBBZGRzIHR3byB2ZWN0b3IgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGludG8gYSB0aGlyZCBvbmUsIGkuZS4gYGRzdCA9IGEgKyBiYC5cclxuICpcclxuICogQHBhcmFtIGEgVGhlIGZpcnN0IHZlY3Rvci5cclxuICogQHBhcmFtIGIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBkc3QgVGhlIHZlY3RvciB0aGUgcmVzdWx0IHdpbGwgYmUgc3RvcmVkIHRvLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBhZGQoYSwgYiwgZHN0ID0gY3JlYXRlKDAsIDApKSB7XHJcbiAgICBkc3QueCA9IGEueCArIGIueDtcclxuICAgIGRzdC55ID0gYS55ICsgYi55O1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogU3VidHJhY3RzIGEgdmVjdG9yIGZyb20gYW5vdGhlciBvbmUgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IHRvIGEgdGhpcmQgb25lLCBpLmUuXHJcbiAqIGBkc3QgPSBhIC0gYmAuXHJcbiAqXHJcbiAqIEBwYXJhbSBhIFRoZSBtaW51ZW5kIHZlY3Rvci5cclxuICogQHBhcmFtIGIgVGhlIHN1YnRyYWhlbmQgdmVjdG9yLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSB2ZWN0b3IgdGhlIHJlc3VsdCB3aWxsIGJlIHN0b3JlZCB0by5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc3ViKGEsIGIsIGRzdCA9IGNyZWF0ZSgwLCAwKSkge1xyXG4gICAgZHN0LnggPSBhLnggLSBiLng7XHJcbiAgICBkc3QueSA9IGEueSAtIGIueTtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIE11bHRpcGxpZXMgdHdvIHZlY3RvcnMgY29tcG9uZW50LXdpc2UgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGludG8gYSB0aGlyZCBvbmUuXHJcbiAqXHJcbiAqIEBwYXJhbSBhIFRoZSBmaXJzdCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSB2ZWN0b3IgdGhlIHJlc3VsdCB3aWxsIGJlIHN0b3JlZCB0by5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbXVsdihhLCBiLCBkc3QgPSBjcmVhdGUoMCwgMCkpIHtcclxuICAgIGRzdC54ID0gYS54ICogYi54O1xyXG4gICAgZHN0LnkgPSBhLnkgKiBiLnk7XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbi8qKlxyXG4gKiBNdWx0aXBsaWVzIGEgdmVjdG9yIGJ5IGEgc2NhbGFyIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbnRvIGEgdGhpcmQgdmVjdG9yLlxyXG4gKlxyXG4gKiBAcGFyYW0gYSBUaGUgdmVjdG9yLlxyXG4gKiBAcGFyYW0gbiBUaGUgc2NhbGFyLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSB2ZWN0b3IgdGhlIHJlc3VsdCB3aWxsIGJlIHN0b3JlZCB0by5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbXVsbihhLCBuLCBkc3QgPSBjcmVhdGUoMCwgMCkpIHtcclxuICAgIGRzdC54ID0gYS54ICogbjtcclxuICAgIGRzdC55ID0gYS55ICogbjtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIERpdmlkZXMgYSB2ZWN0b3IgYnkgYW5vdGhlciBvbmUgY29tcG9uZW50IHdpc2UgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGludG8gYVxyXG4gKiB0aGlyZCBvbmUuXHJcbiAqXHJcbiAqIEBwYXJhbSBhIFRoZSBkaXZpZGVuZCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBiIFRoZSBkaXZpc29yIHZlY3Rvci5cclxuICogQHBhcmFtIGRzdCBUaGUgdmVjdG9yIHRoZSByZXN1bHQgd2lsbCBiZSBzdG9yZWQgdG8uXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRpdnYoYSwgYiwgZHN0ID0gY3JlYXRlKDAsIDApKSB7XHJcbiAgICBkc3QueCA9IGEueCAvIGIueDtcclxuICAgIGRzdC55ID0gYS55IC8gYi55O1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogRGl2aWRlcyBhIHZlY3RvciBieSBhIHNjYWxhciBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW50byBhIHRoaXJkIHZlY3Rvci5cclxuICpcclxuICogQHBhcmFtIGEgVGhlIGRpdmlkZW5kIHZlY3Rvci5cclxuICogQHBhcmFtIG4gVGhlIHNjYWxhci5cclxuICogQHBhcmFtIGRzdCBUaGUgdmVjdG9yIHRoZSByZXN1bHQgd2lsbCBiZSBzdG9yZWQgdG8uXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRpdm4oYSwgbiwgZHN0ID0gY3JlYXRlKDAsIDApKSB7XHJcbiAgICBkc3QueCA9IGEueCAvIG47XHJcbiAgICBkc3QueSA9IGEueSAvIG47XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSByZW1pbmRlciBhZnRlciBkaXZpc2lvbiBvZiBhJ3MgY29tcG9uZW50cyBieSBuIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbnRvIGEgdGhpcmQgdmVjdG9yLlxyXG4gKlxyXG4gKiBAcGFyYW0gYSBUaGUgZGl2aWRlbmQgdmVjdG9yLlxyXG4gKiBAcGFyYW0gbiBUaGUgc2NhbGFyLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSB2ZWN0b3IgdGhlIHJlc3VsdCB3aWxsIGJlIHN0b3JlZCB0by5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbW9kKGEsIG4sIGRzdCA9IGNyZWF0ZSgwLCAwKSkge1xyXG4gICAgZHN0LnggPSBhLnggJSBuO1xyXG4gICAgZHN0LnkgPSBhLnkgJSBuO1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogTGluZWFybHkgaW50ZXJwb2xhdGVzIGJldHdlZW4gdHdvIHZlY3RvcnMsIGkuZS4gY29tcHV0ZXNcclxuICogYCgxIC0gZmFjdG9yKSAqIGEgKyBmYWN0b3IgKiBiYCwgYW5kIHdyaXRlcyB0aGUgcmVzdWx0IGludG8gYSB0aGlyZCB2ZWN0b3IuXHJcbiAqXHJcbiAqIEBwYXJhbSBhIFRoZSBmaXJzdCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBAcGFyYW0gZmFjdG9yIFRoZSBpbnRlcnBvbGF0aW9uIGZhY3Rvci5cclxuICogQHBhcmFtIGRzdCBUaGUgdmVjdG9yIHRoZSByZXN1bHQgd2lsbCBiZSB3cml0dGVuIHRvLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBtaXgoYSwgYiwgZmFjdG9yLCBkc3QgPSBjcmVhdGUoMCwgMCkpIHtcclxuICAgIGRzdC54ID0gKDEgLSBmYWN0b3IpICogYS54ICsgZmFjdG9yICogYi54O1xyXG4gICAgZHN0LnkgPSAoMSAtIGZhY3RvcikgKiBhLnkgKyBmYWN0b3IgKiBiLnk7XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbi8qKlxyXG4gKiBSb3RhdGVzIGEgdmVjdG9yIGJ5IGEgZ2l2ZW4gYW5nbGUgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGludG8gYSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBQb3NpdGl2ZSBkaXJlY3Rpb24gaXMgZnJvbSArWCB0byArWS5cclxuICpcclxuICogQHBhcmFtIHYgVGhlIHZlY3RvciB0byByb3RhdGUuXHJcbiAqIEBwYXJhbSBhbmdsZSBUaGUgYW5nbGUgb2Ygcm90YXRpb24uXHJcbiAqIEBwYXJhbSBkc3QgVGhlIHZlY3RvciB0aGUgcmVzdWx0IHdpbGwgYmUgc3RvcmVkIHRvLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiByb3RhdGUodiwgYW5nbGUsIGRzdCA9IGNyZWF0ZSgwLCAwKSkge1xyXG4gICAgY29uc3QgeCA9IHYueDtcclxuICAgIGNvbnN0IHkgPSB2Lnk7XHJcbiAgICBjb25zdCBhbmdsZUNvcyA9IE1hdGguY29zKGFuZ2xlKTtcclxuICAgIGNvbnN0IGFuZ2xlU2luID0gTWF0aC5zaW4oYW5nbGUpO1xyXG4gICAgZHN0LnggPSBhbmdsZUNvcyAqIHggLSBhbmdsZVNpbiAqIHk7XHJcbiAgICBkc3QueSA9IGFuZ2xlU2luICogeCArIGFuZ2xlQ29zICogeTtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIFJvdGF0ZXMgYSB2ZWN0b3IgYnkgNDUgZGVncmVlcyBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW50byBhIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEFuYWxvZ291cyB0byBgcm90YXRlKHYsIE1hdGguUEkgLyA0LCBkc3QpYCwgYnV0IGZhc3Rlci5cclxuICpcclxuICogQHBhcmFtIHYgVGhlIHZlY3RvciB0byByb3RhdGUuXHJcbiAqIEBwYXJhbSBkc3QgVGhlIHZlY3RvciB0aGUgcmVzdWx0IHdpbGwgYmUgc3RvcmVkIHRvLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiByb3RhdGU0NSh2LCBkc3QgPSBjcmVhdGUoMCwgMCkpIHtcclxuICAgIGNvbnN0IHkgPSB2Lnk7XHJcbiAgICBjb25zdCBzID0gTWF0aC5TUVJUMV8yO1xyXG4gICAgZHN0LnkgPSBzICogdi54ICsgcyAqIHYueTtcclxuICAgIGRzdC54ID0gcyAqIHYueCAtIHMgKiB5O1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogUm90YXRlcyBhIHZlY3RvciBieSA5MCBkZWdyZWVzIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbnRvIGEgc2Vjb25kIHZlY3Rvci5cclxuICogQW5hbG9nb3VzIHRvIGByb3RhdGUodiwgTWF0aC5QSSAvIDIsIGRzdClgLCBidXQgZmFzdGVyLlxyXG4gKlxyXG4gKiBAcGFyYW0gdiBUaGUgdmVjdG9yIHRvIHJvdGF0ZS5cclxuICogQHBhcmFtIGRzdCBUaGUgdmVjdG9yIHRoZSByZXN1bHQgd2lsbCBiZSBzdG9yZWQgdG8uXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZTkwKHYsIGRzdCA9IGNyZWF0ZSgwLCAwKSkge1xyXG4gICAgY29uc3QgeSA9IHYueTtcclxuICAgIGRzdC55ID0gdi54O1xyXG4gICAgZHN0LnggPSAteTtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIFJvdGF0ZXMgYSB2ZWN0b3IgYnkgLTkwIGRlZ3JlZXMgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGludG8gYSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBBbmFsb2dvdXMgdG8gYHJvdGF0ZSh2LCAtTWF0aC5QSSAvIDIsIGRzdClgLCBidXQgZmFzdGVyLlxyXG4gKlxyXG4gKiBAcGFyYW0gdiBUaGUgdmVjdG9yIHRvIHJvdGF0ZS5cclxuICogQHBhcmFtIGRzdCBUaGUgdmVjdG9yIHRoZSByZXN1bHQgd2lsbCBiZSBzdG9yZWQgdG8uXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZU5lZzkwKHYsIGRzdCA9IGNyZWF0ZSgwLCAwKSkge1xyXG4gICAgY29uc3QgeSA9IHYueTtcclxuICAgIGRzdC55ID0gLXYueDtcclxuICAgIGRzdC54ID0geTtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIEludmVydHMgc2lnbnMgb2YgY29tcG9uZW50cyBvZiBhIHZlY3RvciBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW50byBhIHNlY29uZFxyXG4gKiB2ZWN0b3IuIEFuYWxvZ291cyB0byBgcm90YXRlKHYsIE1hdGguUEksIGRzdClgIChvciBgcm90YXRlKHYsIC1NYXRoLlBJLCBkc3QpYCxcclxuICogd2hpY2ggaXMgdGhlIHNhbWUpLCBidXQgZmFzdGVyLlxyXG4gKlxyXG4gKiBAcGFyYW0gdiBUaGUgdmVjdG9yIHRvIGludmVydC5cclxuICogQHBhcmFtIGRzdCBUaGUgdmVjdG9yIHRoZSByZXN1bHQgd2lsbCBiZSBzdG9yZWQgdG8uXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGludmVydCh2LCBkc3QgPSBjcmVhdGUoMCwgMCkpIHtcclxuICAgIGRzdC54ID0gLXYueDtcclxuICAgIGRzdC55ID0gLXYueTtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIENvbXB1dGVzIGxlbmd0aCBvZiBhIHZlY3Rvci5cclxuICpcclxuICogQHBhcmFtIHYgVGhlIHZlY3Rvci5cclxuICogQHJldHVybnMgVGhlIGxlbmd0aC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBsZW5ndGgodikge1xyXG4gICAgcmV0dXJuIE1hdGguaHlwb3Qodi54LCB2LnkpO1xyXG59XHJcbi8qKlxyXG4gKiBDb21wdXRlcyBkaXN0YW5jZSBiZXR3ZWVuIGVuZHMgb2YgdHdvIHZlY3RvcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSBhIFRoZSBmaXJzdCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBAcmV0dXJucyBUaGUgZGlzdGFuY2UsIGkuZS4gYGxlbmd0aChzdWIoYSwgYikpYC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XHJcbiAgICByZXR1cm4gTWF0aC5oeXBvdChhLnggLSBiLngsIGEueSAtIGIueSk7XHJcbn1cclxuLyoqXHJcbiAqIERpdmlkZXMgYSB2ZWN0b3IgYnkgaXRzIGxlbmd0aCAodGh1cyBtYWtpbmcgaXQgYSB1bml0IHZlY3RvcikgYW5kIHN0b3JlcyB0aGVcclxuICogcmVzdWx0IHRvIGFub3RoZXIgb25lLlxyXG4gKlxyXG4gKiBAcGFyYW0gdiBUaGUgdmVjdG9yIHRvIGJlIG5vcm1hbGl6ZWQuXHJcbiAqIEBwYXJhbSBkc3QgVGhlIHZlY3RvciB0aGUgcmVzdWx0IHdpbGwgYmUgc3RvcmVkIHRvLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUodiwgZHN0ID0gY3JlYXRlKDAsIDApKSB7XHJcbiAgICByZXR1cm4gZGl2bih2LCBsZW5ndGgodiksIGRzdCk7XHJcbn1cclxuLyoqXHJcbiAqIENvbnZlcnRzIGVhY2ggY29tcG9uZW50IG9mIHZlY3Rvci5cclxuICpcclxuICogQHBhcmFtIHYgVGhlIHZlY3RvciB0byBiZSBjb252ZXJ0ZWQuXHJcbiAqIEBwYXJhbSBjb252ZXJ0ZXIgVGhlIGNvbXBvbmVudCBjb252ZXJ0ZXIuXHJcbiAqIEBwYXJhbSBkc3QgVGhlIHZlY3RvciB0aGUgcmVzdWx0IHdpbGwgYmUgc3RvcmVkIHRvLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0KHYsIGNvbnZlcnRlciwgZHN0ID0gY3JlYXRlKDAsIDApKSB7XHJcbiAgICBkc3QueCA9IGNvbnZlcnRlcih2LngpO1xyXG4gICAgZHN0LnkgPSBjb252ZXJ0ZXIodi55KTtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIENvbXB1dGVzIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWN0b3JzLlxyXG4gKlxyXG4gKiBAcGFyYW0gYSBUaGUgZmlyc3QgdmVjdG9yLlxyXG4gKiBAcGFyYW0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cclxuICogQHJldHVybnMgVGhlIGRvdCBwcm9kdWN0LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRvdChhLCBiKSB7XHJcbiAgICByZXR1cm4gYS54ICogYi54ICsgYS55ICogYi55O1xyXG59XHJcbi8qKlxyXG4gKiBDb21wdXRlcyBaLWNvbXBvbmVudCBvZiBhIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIHZlY3RvcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSBhIFRoZSBmaXJzdCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBAcmV0dXJucyBaLWNvbXBvbmVudCBvZiB0aGUgY3Jvc3MgcHJvZHVjdC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjcm9zc1ooYSwgYikge1xyXG4gICAgcmV0dXJuIGEueCAqIGIueSAtIGEueSAqIGIueDtcclxufVxyXG5leHBvcnQgY29uc3QgRU1QVFkgPSB7XHJcbiAgICBtaW5YOiAwLFxyXG4gICAgbWF4WDogMCxcclxuICAgIG1pblk6IDAsXHJcbiAgICBtYXhZOiAwXHJcbn07XHJcbmV4cG9ydCBjb25zdCBVTklUX0JCT1ggPSB7XHJcbiAgICBtaW5YOiAtMSxcclxuICAgIG1heFg6IDEsXHJcbiAgICBtaW5ZOiAtMSxcclxuICAgIG1heFk6IDFcclxufTtcclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgYmJveCBhbmQgaW5pdGlhbGl6ZXMgaXQgd2l0aCBnaXZlbiBjb21wb25lbnRzLlxyXG4gKlxyXG4gKiBAcGFyYW0gbWluWCBMZWZ0IGJvcmRlciBvZiB0aGUgYmJveC5cclxuICogQHBhcmFtIG1heFggUmlnaHQgYm9yZGVyIG9mIHRoZSBiYm94LlxyXG4gKiBAcGFyYW0gbWluWSBMb3dlciBib3JkZXIgb2YgdGhlIGJib3guXHJcbiAqIEBwYXJhbSBtYXhZIFVwcGVyIGJvcmRlciBvZiB0aGUgYmJveC5cclxuICogQHJldHVybnMgVGhlIGJib3guXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQkJveDIobWluWCwgbWF4WCwgbWluWSwgbWF4WSkge1xyXG4gICAgcmV0dXJuIHsgbWluWCwgbWF4WCwgbWluWSwgbWF4WSB9O1xyXG59XHJcbi8qKlxyXG4gKiBDb3BpZXMgYSBiYm94IHRvIGFub3RoZXIgb25lLlxyXG4gKlxyXG4gKiBAcGFyYW0gc3JjIFRoZSBzb3VyY2UgYmJveC5cclxuICogQHBhcmFtIGRzdCBUaGUgYmJveCB0aGUgc291cmNlIGJib3ggd2lsbCBiZSBjb3BpZWQgdG8uXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvcHlCQm94MihzcmMsIGRzdCA9IGNyZWF0ZUJCb3gyKDAsIDAsIDAsIDApKSB7XHJcbiAgICBkc3QubWluWCA9IHNyYy5taW5YO1xyXG4gICAgZHN0Lm1heFggPSBzcmMubWF4WDtcclxuICAgIGRzdC5taW5ZID0gc3JjLm1pblk7XHJcbiAgICBkc3QubWF4WSA9IHNyYy5tYXhZO1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogQ2hlY2tzIGlmIHR3byBib3VuZGluZyBib3hlcyBvdmVybGFwLlxyXG4gKlxyXG4gKiBAcGFyYW0gYmJveDEgQSBib3VuZGluZyBib3guXHJcbiAqIEBwYXJhbSBiYm94MiBBbm90aGVyIGJvdW5kaW5nIGJveC5cclxuICogQHJldHVybnMgYHRydWVgIGlmIGdpdmVuIGJvdW5kaW5nIGJveGVzIGRvIG92ZXJsYXAgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGJib3hlc092ZXJsYXAoYmJveDEsIGJib3gyKSB7XHJcbiAgICBsZXQgbGVmdEJCb3g7XHJcbiAgICBsZXQgcmlnaHRCQm94O1xyXG4gICAgaWYgKGJib3gxLm1pblggPCBiYm94Mi5taW5YKSB7XHJcbiAgICAgICAgbGVmdEJCb3ggPSBiYm94MTtcclxuICAgICAgICByaWdodEJCb3ggPSBiYm94MjtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGxlZnRCQm94ID0gYmJveDI7XHJcbiAgICAgICAgcmlnaHRCQm94ID0gYmJveDE7XHJcbiAgICB9XHJcbiAgICBsZXQgdG9wQkJveDtcclxuICAgIGxldCBib3R0b21CQm94O1xyXG4gICAgaWYgKGJib3gxLm1heFkgPiBiYm94Mi5tYXhZKSB7XHJcbiAgICAgICAgdG9wQkJveCA9IGJib3gxO1xyXG4gICAgICAgIGJvdHRvbUJCb3ggPSBiYm94MjtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRvcEJCb3ggPSBiYm94MjtcclxuICAgICAgICBib3R0b21CQm94ID0gYmJveDE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmlnaHRCQm94Lm1pblggPCBsZWZ0QkJveC5tYXhYICYmIGJvdHRvbUJCb3gubWF4WSA+IHRvcEJCb3gubWluWTtcclxufVxyXG4vKipcclxuICogQ2hlY2tzIGlmIGEgMkQgcG9pbnQgbGllcyBpbnNpZGUgYSBib3VuZGluZyBib3ggb3Igb24gaXRzIGJvcmRlci5cclxuICpcclxuICogQHBhcmFtIHBvaW50IFRoZSBwb2ludC5cclxuICogQHBhcmFtIGJib3ggVGhlIGJvdW5kaW5nIGJveC5cclxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBwb2ludCBpcyBpbnNpZGUgb2YgdGhlIGJveCBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcG9pbnRJc0luQkJveChwb2ludCwgYmJveCkge1xyXG4gICAgcmV0dXJuIGJib3gubWluWCA8PSBwb2ludC54ICYmIHBvaW50LnggPD0gYmJveC5tYXhYICYmXHJcbiAgICAgICAgYmJveC5taW5ZIDw9IHBvaW50LnkgJiYgcG9pbnQueSA8PSBiYm94Lm1heFk7XHJcbn1cclxuLyoqXHJcbiAqIENvbXB1dGVzIGJvdW5kaW5nIGJveCBvZiBhbiBhcnJheSBvZiBwb2ludHMgYW5kIHN0b3JlcyBpdCB0byBhIGdpdmVuIG9iamVjdC5cclxuICpcclxuICogQHBhcmFtIHBvaW50cyBUaGUgYXJyYXkgb2YgcG9pbnRzLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSBiYm94IHRoZSByZXN1bHQgd2lsbCBiZSB3cml0dGVuIHRvLiBMZWZ0IHVubW9kaWZpZWQgaWYgdGhlIGFycmF5XHJcbiAqICAgICAgb2YgcG9pbnRzIGlzIGVtcHR5LlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlQkJveEZvclBvaW50cyhwb2ludHMsIGRzdCA9IHsgbWluWDogMCwgbWF4WDogMCwgbWluWTogMCwgbWF4WTogMCB9KSB7XHJcbiAgICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBkc3Q7XHJcbiAgICB9XHJcbiAgICBkc3QubWluWCA9IGRzdC5tYXhYID0gcG9pbnRzWzBdLng7XHJcbiAgICBkc3QubWluWSA9IGRzdC5tYXhZID0gcG9pbnRzWzBdLnk7XHJcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHBvaW50cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gcG9pbnRzW2ldO1xyXG4gICAgICAgIGlmICh4IDwgZHN0Lm1pblgpIHtcclxuICAgICAgICAgICAgZHN0Lm1pblggPSB4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoeCA+IGRzdC5tYXhYKSB7XHJcbiAgICAgICAgICAgIGRzdC5tYXhYID0geDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHkgPCBkc3QubWluWSkge1xyXG4gICAgICAgICAgICBkc3QubWluWSA9IHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh5ID4gZHN0Lm1heFkpIHtcclxuICAgICAgICAgICAgZHN0Lm1heFkgPSB5O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuZXhwb3J0IGNvbnN0IFhfQVhJUyA9IHtcclxuICAgIG9yaWdpbjogT1JJR0lOLFxyXG4gICAgdGFuZ2VudDogUE9TSVRJVkVfWFxyXG59O1xyXG5leHBvcnQgY29uc3QgWV9BWElTID0ge1xyXG4gICAgb3JpZ2luOiBPUklHSU4sXHJcbiAgICB0YW5nZW50OiBQT1NJVElWRV9ZXHJcbn07XHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRMaW5lRnJvbVBvaW50cyhwMSwgcDIsIGRzdCA9IHtcclxuICAgIG9yaWdpbjogY3JlYXRlKDAsIDApLFxyXG4gICAgdGFuZ2VudDogY3JlYXRlKDAsIDApXHJcbn0pIHtcclxuICAgIGNvcHkocDEsIGRzdC5vcmlnaW4pO1xyXG4gICAgc3ViKHAyLCBwMSwgZHN0LnRhbmdlbnQpO1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogQ29tcHV0ZXMgc2lnbmVkIGRpc3RhbmNlIGZyb20gYSBwb2ludCB0byBhIGxpbmUuXHJcbiAqXHJcbiAqIEBwYXJhbSBwIFRoZSBwb2ludC5cclxuICogQHBhcmFtIGwxIFN0YXJ0IHBvaW50IG9mIHRoZSBsaW5lLlxyXG4gKiBAcGFyYW0gbDIgRW5kIHBvaW50IG9mIHRoZSBsaW5lLlxyXG4gKiBAcmV0dXJucyBEaXN0YW5jZSBmcm9tIHRoZSBwb2ludCB0byB0aGUgbGluZS4gSXQnbGwgYmUgZ3JlYXRlciB0aGFuIDAgaWYgdGhlXHJcbiAqICAgICAgcG9pbnQgbGllcyB0byB0aGUgbGVmdCBvZiB0aGUgbGluZSBhbmQgbGVzcyB0aGFuIDAgb3RoZXJ3aXNlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFNpZ25lZERpc3RhbmNlVG9MaW5lKHAsIGwpIHtcclxuICAgIGNvbnN0IHRhbmdlbnQgPSBsLnRhbmdlbnQ7XHJcbiAgICByZXR1cm4gZG90KHN1YihwLCBsLm9yaWdpbiksIGNyZWF0ZSgtdGFuZ2VudC55LCB0YW5nZW50LngpKSAvIGxlbmd0aCh0YW5nZW50KTtcclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBleHRlbnQgYW5kIGluaXRpYWxpemVzIGl0IHdpdGggZ2l2ZW4gY29tcG9uZW50cy5cclxuICpcclxuICogQHBhcmFtIHdpZHRoIFdpZHRoIG9mIHRoZSBleHRlbnQuXHJcbiAqIEBwYXJhbSBIZWlnaHQgSGVpZ2h0IG9mIHRoZSBleHRlbnQuXHJcbiAqIEByZXR1cm5zIFRoZSBleHRlbnQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRXh0ZW50Mih3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICByZXR1cm4geyB3aWR0aCwgaGVpZ2h0IH07XHJcbn1cclxuLyoqXHJcbiAqIENvcGllcyBhbiBleHRlbnQgdG8gYW5vdGhlciBvbmUuXHJcbiAqXHJcbiAqIEBwYXJhbSBzcmMgVGhlIHNvdXJjZSBiYm94LlxyXG4gKiBAcGFyYW0gZHN0IFRoZSBleHRlbnQgdGhlIHNvdXJjZSBleHRlbnQgd2lsbCBiZSBjb3BpZWQgdG8uXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvcHlFeHRlbnQyKHNyYywgZHN0ID0gY3JlYXRlRXh0ZW50MigwLCAwKSkge1xyXG4gICAgZHN0LndpZHRoID0gc3JjLndpZHRoO1xyXG4gICAgZHN0LmhlaWdodCA9IHNyYy5oZWlnaHQ7XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbiIsImltcG9ydCBUaWxlQmFzZWRBZGFwdGVyIGZyb20gJy4uL3RpbGVfYmFzZWRfYWRhcHRlci9hZGFwdGVyJztcclxuaW1wb3J0IEljb25CdWZmZXJXcml0ZXIgZnJvbSAnLi4vLi4vcHJpbWl0aXZlL2ljb24vaWNvbl9idWZmZXJfd3JpdGVyJztcclxuaW1wb3J0IE1lbW9yeVN1YkNodW5rIGZyb20gJy4uLy4uL3JlbmRlci9tZW1vcnkvc3ViX2NodW5rJztcclxuaW1wb3J0IElkZW50aWZpZWRJbWFnZUF0bGFzTWFuYWdlciBmcm9tICcuLi8uLi9iaWxsYm9hcmQvaWRlbnRpZmllZF9pbWFnZV9hdGxhc19tYW5hZ2VyJztcclxuaW1wb3J0IERmRm9udCBmcm9tICcuLi8uLi9mb250L2RmX2ZvbnQnO1xyXG5pbXBvcnQgeyBBcGlJbWFnZVByb3ZpZGVyIH0gZnJvbSAnLi9hcGlfaW1hZ2VfcHJvdmlkZXInO1xyXG5pbXBvcnQgTW9kZWxCdWZmZXJXcml0ZXIgZnJvbSAnLi4vLi4vcHJpbWl0aXZlL21vZGVsL21vZGVsX2J1ZmZlcl93cml0ZXInO1xyXG5pbXBvcnQgVGV4dHVyZWRQb2x5bGluZUJ1ZmZlcldyaXRlciBmcm9tICcuLi8uLi9wcmltaXRpdmUvcG9seWxpbmUvdGV4dHVyZWRfcG9seWxpbmVfYnVmZmVyX3dyaXRlcic7XHJcbmltcG9ydCB7IEltYWdlTWFuYWdlciB9IGZyb20gJy4uLy4uL2JpbGxib2FyZC9pbWFnZV9tYW5hZ2VyJztcclxuaW1wb3J0IFRleHR1cmVkUG9seWdvbkJ1ZmZlclJld3JpdGVyIGZyb20gJy4uLy4uL3ByaW1pdGl2ZS9wb2x5Z29uL3RleHR1cmVkX3BvbHlnb25fYnVmZmVyX3Jld2l0ZXInO1xyXG5pbXBvcnQgeyBQT0xZR09OX0FUVFJJQlVURV9NQVBQSU5HIH0gZnJvbSAnLi4vLi4vcHJpbWl0aXZlL3BvbHlnb24vcG9seWdvbl9hdHRyaWJ1dGVfbWFwcGluZyc7XHJcbmltcG9ydCB7IFRFWFRVUkVEX1BPTFlHT05fQVRUUklCVVRFX01BUFBJTkcgfSBmcm9tICcuLi8uLi9wcmltaXRpdmUvcG9seWdvbi90ZXh0dXJlZF9wb2x5Z29uX2F0dHJpYnV0ZV9tYXBwaW5nJztcclxuaW1wb3J0IHsgQklMTEJPQVJEX1JFQ1RBTkdMRV9BVFRSSUJVVEVfTUFQUElORyB9IGZyb20gJy4uLy4uL3ByaW1pdGl2ZS9iaWxsYm9hcmRfcmVjdGFuZ2xlL2F0dHJpYnV0ZV9tYXBwaW5nJztcclxuaW1wb3J0IHsgUE9JTlRfTEFCRUxfQVRUUklCVVRFX01BUFBJTkcgfSBmcm9tICcuLi8uLi9wcmltaXRpdmUvbGFiZWwvcG9pbnRfbGFiZWxfYXR0cmlidXRlX21hcHBpbmcnO1xyXG5pbXBvcnQgeyBDVVJWRURfTEFCRUxfQVRUUklCVVRFX01BUFBJTkcgfSBmcm9tICcuLi8uLi9wcmltaXRpdmUvbGFiZWwvY3VydmVkX2xhYmVsX2F0dHJpYnV0ZV9tYXBwaW5nJztcclxuaW1wb3J0IHsgUE9MWUxJTkVfQVRUUklCVVRFX01BUFBJTkcgfSBmcm9tICcuLi8uLi9wcmltaXRpdmUvcG9seWxpbmUvcG9seWxpbmVfYXR0cmlidXRlX21hcHBpbmcnO1xyXG5pbXBvcnQgeyBUaWxlUHJvdmlkZXJXb3JrZXJDbGllbnQgfSBmcm9tICcuL3dvcmtlci90aWxlX3Byb3ZpZGVyX3dvcmtlcl9jbGllbnQnO1xyXG5pbXBvcnQgeyBUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZSB9IGZyb20gJy4vd29ya2VyL3RpbGVfcHJvdmlkZXJfd29ya2VyX21lc3NhZ2VzJztcclxuaW1wb3J0IHsgVFJBTlNQQVJFTlRfUE9MWUdPTl9BVFRSSUJVVEVfTUFQUElORyB9IGZyb20gJy4uLy4uL3ByaW1pdGl2ZS9wb2x5Z29uL3RyYW5zcGFyZW50X3BvbHlnb25fYXR0cmlidXRlX21hcHBpbmcnO1xyXG5pbXBvcnQgeyBnZXRUaWxlSWQgfSBmcm9tICcuLi90aWxlX2Jhc2VkX2FkYXB0ZXIvdGlsZV9pZCc7XHJcbmltcG9ydCBJZGxlVGFza1F1ZXVlIGZyb20gJy4uLy4uL3V0aWwvaWRsZV90YXNrX3F1ZXVlJztcclxuaW1wb3J0IHsgY291bnRUaWxlUGFyc2VUaW1lIH0gZnJvbSAnLi4vLi4vdXRpbC9zdGF0JztcclxuaW1wb3J0IHsgdW5pcXVlSWQgfSBmcm9tICcuLi8uLi91dGlsL3VuaXF1ZV9pZCc7XHJcbmltcG9ydCBSZW5kZXJhYmxlUG9seWdvbiBmcm9tICcuLi8uLi9wcmltaXRpdmUvcG9seWdvbi9yZW5kZXJhYmxlX3BvbHlnb24nO1xyXG5pbXBvcnQgUmVuZGVyYWJsZVRleHR1cmVkUG9seWdvbiBmcm9tICcuLi8uLi9wcmltaXRpdmUvcG9seWdvbi9yZW5kZXJhYmxlX3RleHR1cmVkX3BvbHlnb24nO1xyXG5pbXBvcnQgUmVuZGVyYWJsZVBvbHlsaW5lIGZyb20gJy4uLy4uL3ByaW1pdGl2ZS9wb2x5bGluZS9yZW5kZXJhYmxlX3BvbHlsaW5lJztcclxuaW1wb3J0IFJlbmRlcmFibGVUZXh0dXJlZFBvbHlsaW5lIGZyb20gJy4uLy4uL3ByaW1pdGl2ZS9wb2x5bGluZS9yZW5kZXJhYmxlX3RleHR1cmVkX3BvbHlsaW5lJztcclxuaW1wb3J0IFJlbmRlcmFibGVNb2RlbCBmcm9tICcuLi8uLi9wcmltaXRpdmUvbW9kZWwvcmVuZGVyYWJsZV9tb2RlbCc7XHJcbmltcG9ydCB7IFBPTFlHT05fRVhUUkFDVE9SLCBURVhUVVJFRF9QT0xZR09OX0VYVFJBQ1RPUiwgUE9MWUxJTkVfRVhUUkFDVE9SLCBURVhUVVJFRF9QT0xZTElORV9FWFRSQUNUT1IsIFBPSU5UX0VYVFJBQ1RPUiwgUE9JTlRfTEFCRUxfRVhUUkFDVE9SLCBDVVJWRURfTEFCRUxfRVhUUkFDVE9SLCBNT0RFTF9FWFRSQUNUT1IsIEVYVEVSTkFMX01FU0hfRVhUUkFDVE9SIH0gZnJvbSAnLi90aWxlX2RhdGEnO1xyXG5pbXBvcnQgUmVuZGVyYWJsZVByaW1pdGl2ZU1hbmFnZXIgZnJvbSAnLi9wcmltaXRpdmVfbWFuYWdlci9yZW5kZXJhYmxlX3ByaW1pdGl2ZV9tYW5hZ2VyJztcclxuaW1wb3J0IFByaW1pdGl2ZVNldFN0b3JhZ2UgZnJvbSAnLi4vLi4vcmVuZGVyL3ByaW1pdGl2ZXMvcHJpbWl0aXZlX3NldF9zdG9yYWdlJztcclxuaW1wb3J0IFBvbHlnb25NYW5hZ2VyIGZyb20gJy4vcHJpbWl0aXZlX21hbmFnZXIvcG9seWdvbl9tYW5hZ2VyJztcclxuaW1wb3J0IERpc2FwcGVhcmluZ1ByaW1pdGl2ZVNldFN0b3JhZ2UgZnJvbSAnLi4vLi4vcmVuZGVyL3ByaW1pdGl2ZXMvZGlzYXBwZWFyaW5nX3ByaW1pdGl2ZV9zZXRfc3RvcmFnZSc7XHJcbmltcG9ydCBEZWxheWVkRGlzYXBwZWFyaW5nUHJpbWl0aXZlU2V0U3RvcmFnZSBmcm9tICcuLi8uLi9yZW5kZXIvcHJpbWl0aXZlcy9kZWxheWVkX2Rpc2FwcGVhcmluZ19wcmltaXRpdmVfc2V0X3N0b3JhZ2UnO1xyXG5pbXBvcnQgWm9vbUZpbHRlcmFibGVQcmltaXRpdmVNYW5hZ2VyIGZyb20gJy4vcHJpbWl0aXZlX21hbmFnZXIvem9vbV9maWx0ZXJhYmxlX3ByaW1pdGl2ZV9tYW5hZ2VyJztcclxuaW1wb3J0IEV4dGVybmFsTWVzaFByaW1pdGl2ZU1hbmFnZXIgZnJvbSAnLi9wcmltaXRpdmVfbWFuYWdlci9leHRlcm5hbF9tZXNoX21hbmFnZXInO1xyXG5pbXBvcnQgUmVuZGVyYWJsZUJpbGxib2FyZFJlY3RhbmdsZSBmcm9tICcuLi8uLi9wcmltaXRpdmUvYmlsbGJvYXJkX3JlY3RhbmdsZS9yZW5kZXJhYmxlX2JpbGxib2FyZF9yZWN0YW5nbGUnO1xyXG5pbXBvcnQgeyBab29tUmVzdHJpY3RlZExhYmVsIH0gZnJvbSAnLi9wcmltaXRpdmUvem9vbV9yZXN0cmljdGVkX2xhYmVsJztcclxuaW1wb3J0IHsgWm9vbVJlc3RyaWN0ZWRJY29uIH0gZnJvbSAnLi9wcmltaXRpdmUvem9vbV9yZXN0cmljdGVkX2ljb24nO1xyXG5pbXBvcnQgUHJpb3JpdHlRdWV1ZSBmcm9tICcuLi8uLi91dGlsL3Rhc2tfcXVldWUnO1xyXG5jb25zdCBXT1JMRF9TSVpFID0gMi4wO1xyXG5jb25zdCBOT1JNQUxfVElMRV9TSURFX1NJWkVfUFggPSAyNTY7IC8vIHRpbGVzIG9mIG5vcm1hbCBzaXplIGFyZSBvcHRpbWl6ZWQgZm9yIGRpc3BsYXlpbmcgaW4gYSAyNTZ4MjU2IGNzcyBweCBzcXVhcmVcclxuZnVuY3Rpb24gZ2V0VGlsZVNpZGVTaXplUHgodGlsZVNpemUpIHtcclxuICAgIHN3aXRjaCAodGlsZVNpemUpIHtcclxuICAgICAgICBjYXNlIDEgLyogWDQgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBOT1JNQUxfVElMRV9TSURFX1NJWkVfUFggKiAyO1xyXG4gICAgICAgIGNhc2UgMiAvKiBYMTYgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBOT1JNQUxfVElMRV9TSURFX1NJWkVfUFggKiA0O1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiBOT1JNQUxfVElMRV9TSURFX1NJWkVfUFg7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgTUFYX1BFUkZfTE9HX0lURU1TX0NPVU5UID0gMTAyNDtcclxuY29uc3QgUVVFVUVfVEFTS19QUklPUklUSUVTID0ge1xyXG4gICAgZmlyc3RUaWxlUG9ydGlvbjogMjAsXHJcbiAgICBzZWNvbmRUaWxlUG9ydGlvbjogMTBcclxufTtcclxuY29uc3QgREVGQVVMVF9JRExFX1RBU0tfUFJJT1JJVFkgPSAwO1xyXG4vLyBUaGUgdmFsdWVzIGFyZSBjaG9zZW4gZW1waXJpY2FsbHk6IGh0dHBzOi8vc3QueWFuZGV4LXRlYW0ucnUvVkVDVE9SLTMwMCM1YmU1YjYzODUyMzIxMTAwMWI5YmQ5NDFcclxuY29uc3QgTUlOWk9PTV9ERUxUQVMgPSB7XHJcbiAgICBwb2ludExhYmVsczogMSxcclxuICAgIGN1cnZlZExhYmVsczogMSxcclxuICAgIGljb25zOiAwLjc1XHJcbn07XHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZlY3RvckFwaUFkYXB0ZXIgZXh0ZW5kcyBUaWxlQmFzZWRBZGFwdGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGVuZ2luZSwgY2FtZXJhLCB0aWxlUHJvdmlkZXJXb3JrZXJVcmwsIGxheWVyTmFtZSwgeyBpbWFnZVVybFRlbXBsYXRlLCB0aWxlVXJsVGVtcGxhdGUsIG1lc2hVcmxUZW1wbGF0ZSwgZ2x5cGhSYW5nZVVybFRlbXBsYXRlIH0sIHRpbGVTaXplID0gMCAvKiBYMSAqLywgcHJlbG9hZGVkVGlsZXNCZWx0U2l6ZSA9IDApIHtcclxuICAgICAgICBzdXBlcihlbmdpbmUsIGNhbWVyYSwgdGlsZVNpemUsIHByZWxvYWRlZFRpbGVzQmVsdFNpemUsIGxheWVyTmFtZSk7XHJcbiAgICAgICAgdGhpcy5fdGlsZVNpZGVTaXplUHggPSBnZXRUaWxlU2lkZVNpemVQeCh0aWxlU2l6ZSk7XHJcbiAgICAgICAgdGhpcy5fcGVyZkxvZ0l0ZW1zID0gW107XHJcbiAgICAgICAgdGhpcy5fZGVzdHJveWFibGVzID0gW107XHJcbiAgICAgICAgdGhpcy5fdGlsZVByb3ZpZGVyID0gbmV3IFRpbGVQcm92aWRlcldvcmtlckNsaWVudCh0aWxlUHJvdmlkZXJXb3JrZXJVcmwpO1xyXG4gICAgICAgIHRoaXMuX3RpbGVQcm92aWRlci5zZW5kTWVzc2FnZSh7XHJcbiAgICAgICAgICAgIHR5cGU6IFRpbGVQcm92aWRlck1lc3NhZ2VUeXBlLklOSVQsXHJcbiAgICAgICAgICAgIHRpbGVVcmxUZW1wbGF0ZSxcclxuICAgICAgICAgICAgbWVzaFVybFRlbXBsYXRlLFxyXG4gICAgICAgICAgICBnbHlwaFJhbmdlVXJsVGVtcGxhdGVcclxuICAgICAgICB9LCAxIC8qIElNTUVESUFURSAqLyk7XHJcbiAgICAgICAgdGhpcy5fbWVtb3J5TWFuYWdlciA9IGVuZ2luZS5tZW1vcnlNYW5hZ2VyO1xyXG4gICAgICAgIHRoaXMuX2dseXBoQXRsYXMgPSBlbmdpbmUuZ2x5cGhBdGxhcztcclxuICAgICAgICB0aGlzLl9mb250UmVnaXN0cnkgPSBlbmdpbmUuZm9udFJlZ2lzdHJ5O1xyXG4gICAgICAgIHRoaXMuX2ltYWdlTWFuYWdlck5lYXJlc3QgPSBuZXcgSW1hZ2VNYW5hZ2VyKG5ldyBJZGVudGlmaWVkSW1hZ2VBdGxhc01hbmFnZXIoZW5naW5lLmNyZWF0ZUltYWdlQXRsYXMoe1xyXG4gICAgICAgICAgICBmaWx0ZXI6IDk3MjggLyogTkVBUkVTVCAqLyxcclxuICAgICAgICAgICAgcHJlbXVsdGlwbGllZEFscGhhOiBmYWxzZVxyXG4gICAgICAgIH0pKSwgbmV3IEFwaUltYWdlUHJvdmlkZXIoaW1hZ2VVcmxUZW1wbGF0ZSkpO1xyXG4gICAgICAgIHRoaXMuX2ltYWdlTWFuYWdlckxpbmVhciA9IG5ldyBJbWFnZU1hbmFnZXIobmV3IElkZW50aWZpZWRJbWFnZUF0bGFzTWFuYWdlcihlbmdpbmUuY3JlYXRlSW1hZ2VBdGxhcyh7XHJcbiAgICAgICAgICAgIGZpbHRlcjogOTcyOSAvKiBMSU5FQVIgKi8sXHJcbiAgICAgICAgICAgIHByZW11bHRpcGxpZWRBbHBoYTogdHJ1ZVxyXG4gICAgICAgIH0pKSwgbmV3IEFwaUltYWdlUHJvdmlkZXIoaW1hZ2VVcmxUZW1wbGF0ZSkpO1xyXG4gICAgICAgIGNvbnN0IGZhZGVFZmZlY3QgPSBlbmdpbmUudmlzaWJpbGl0eU1hbmFnZXIuZmFkZUVmZmVjdER1cmF0aW9uO1xyXG4gICAgICAgIGNvbnN0IG9wYXF1ZVBvbHlnb25zUHJvdmlkZXIgPSB0aGlzLm9wYXF1ZVBvbHlnb25zUHJvdmlkZXIgPSBuZXcgUHJpbWl0aXZlU2V0U3RvcmFnZSgpO1xyXG4gICAgICAgIGNvbnN0IHRyYW5zcGFyZW50UG9seWdvbnNQcm92aWRlciA9IHRoaXMudHJhbnNwYXJlbnRQb2x5Z29uc1Byb3ZpZGVyID0gbmV3IFByaW1pdGl2ZVNldFN0b3JhZ2UoKTtcclxuICAgICAgICBjb25zdCB0ZXh0dXJlZFBvbHlnb25zUHJvdmlkZXIgPSB0aGlzLnRleHR1cmVkUG9seWdvbnNQcm92aWRlciA9IG5ldyBQcmltaXRpdmVTZXRTdG9yYWdlKCk7XHJcbiAgICAgICAgY29uc3QgcG9seWxpbmVzUHJvdmlkZXIgPSB0aGlzLnBvbHlsaW5lc1Byb3ZpZGVyID0gbmV3IFByaW1pdGl2ZVNldFN0b3JhZ2UoKTtcclxuICAgICAgICBjb25zdCB0ZXh0dXJlZFBvbHlsaW5lc1Byb3ZpZGVyID0gdGhpcy50ZXh0dXJlZFBvbHlsaW5lc1Byb3ZpZGVyID0gbmV3IFByaW1pdGl2ZVNldFN0b3JhZ2UoKTtcclxuICAgICAgICBjb25zdCBpY29uc1Byb3ZpZGVyID0gdGhpcy5pY29uc1Byb3ZpZGVyID0gbmV3IERpc2FwcGVhcmluZ1ByaW1pdGl2ZVNldFN0b3JhZ2UoKTtcclxuICAgICAgICBjb25zdCBwb2ludExhYmVsc1Byb3ZpZGVyID0gdGhpcy5wb2ludExhYmVsc1Byb3ZpZGVyID0gbmV3IERlbGF5ZWREaXNhcHBlYXJpbmdQcmltaXRpdmVTZXRTdG9yYWdlKGZhZGVFZmZlY3QpO1xyXG4gICAgICAgIGNvbnN0IGN1cnZlZExhYmVsc1Byb3ZpZGVyID0gdGhpcy5jdXJ2ZWRMYWJlbHNQcm92aWRlciA9IG5ldyBEZWxheWVkRGlzYXBwZWFyaW5nUHJpbWl0aXZlU2V0U3RvcmFnZShmYWRlRWZmZWN0KTtcclxuICAgICAgICBjb25zdCBtb2RlbHNQcm92aWRlciA9IHRoaXMubW9kZWxzUHJvdmlkZXIgPSBuZXcgUHJpbWl0aXZlU2V0U3RvcmFnZSgpO1xyXG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lhYmxlcy5wdXNoKHBvaW50TGFiZWxzUHJvdmlkZXIsIGN1cnZlZExhYmVsc1Byb3ZpZGVyKTtcclxuICAgICAgICB0aGlzLl90aWxlRGF0YU1hbmFnZXJzID0gW1xyXG4gICAgICAgICAgICBuZXcgVGlsZURhdGFNYW5hZ2VyKG5ldyBQb2x5Z29uTWFuYWdlcihvcGFxdWVQb2x5Z29uc1Byb3ZpZGVyLCB0cmFuc3BhcmVudFBvbHlnb25zUHJvdmlkZXIpLCBQT0xZR09OX0VYVFJBQ1RPUiksXHJcbiAgICAgICAgICAgIG5ldyBUaWxlRGF0YU1hbmFnZXIobmV3IFJlbmRlcmFibGVQcmltaXRpdmVNYW5hZ2VyKHRleHR1cmVkUG9seWdvbnNQcm92aWRlciksIFRFWFRVUkVEX1BPTFlHT05fRVhUUkFDVE9SKSxcclxuICAgICAgICAgICAgbmV3IFRpbGVEYXRhTWFuYWdlcihuZXcgUmVuZGVyYWJsZVByaW1pdGl2ZU1hbmFnZXIocG9seWxpbmVzUHJvdmlkZXIpLCBQT0xZTElORV9FWFRSQUNUT1IpLFxyXG4gICAgICAgICAgICBuZXcgVGlsZURhdGFNYW5hZ2VyKG5ldyBSZW5kZXJhYmxlUHJpbWl0aXZlTWFuYWdlcih0ZXh0dXJlZFBvbHlsaW5lc1Byb3ZpZGVyKSwgVEVYVFVSRURfUE9MWUxJTkVfRVhUUkFDVE9SKSxcclxuICAgICAgICAgICAgbmV3IFRpbGVEYXRhTWFuYWdlcihuZXcgWm9vbUZpbHRlcmFibGVQcmltaXRpdmVNYW5hZ2VyKGljb25zUHJvdmlkZXIsIGNhbWVyYSksIFBPSU5UX0VYVFJBQ1RPUiksXHJcbiAgICAgICAgICAgIG5ldyBUaWxlRGF0YU1hbmFnZXIobmV3IFpvb21GaWx0ZXJhYmxlUHJpbWl0aXZlTWFuYWdlcihwb2ludExhYmVsc1Byb3ZpZGVyLCBjYW1lcmEpLCBQT0lOVF9MQUJFTF9FWFRSQUNUT1IpLFxyXG4gICAgICAgICAgICBuZXcgVGlsZURhdGFNYW5hZ2VyKG5ldyBab29tRmlsdGVyYWJsZVByaW1pdGl2ZU1hbmFnZXIoY3VydmVkTGFiZWxzUHJvdmlkZXIsIGNhbWVyYSksIENVUlZFRF9MQUJFTF9FWFRSQUNUT1IpLFxyXG4gICAgICAgICAgICBuZXcgVGlsZURhdGFNYW5hZ2VyKG5ldyBSZW5kZXJhYmxlUHJpbWl0aXZlTWFuYWdlcihtb2RlbHNQcm92aWRlciksIE1PREVMX0VYVFJBQ1RPUiksXHJcbiAgICAgICAgICAgIG5ldyBUaWxlRGF0YU1hbmFnZXIobmV3IEV4dGVybmFsTWVzaFByaW1pdGl2ZU1hbmFnZXIobW9kZWxzUHJvdmlkZXIsIHRoaXMuX3RpbGVQcm92aWRlciwgdGhpcy5lbmdpbmUubWVtb3J5TWFuYWdlciksIEVYVEVSTkFMX01FU0hfRVhUUkFDVE9SKVxyXG4gICAgICAgIF07XHJcbiAgICAgICAgdGhpcy5fcmVxdWVzdGVkVGlsZXNTdGF0ZSA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLl90YXNrUXVldWUgPSBuZXcgUHJpb3JpdHlRdWV1ZSgpO1xyXG4gICAgICAgIHRoaXMuX21pbm9yVGFza1F1ZXVlID0gbmV3IElkbGVUYXNrUXVldWUoKTtcclxuICAgICAgICB0aGlzLl90aWxlUHJvdmlkZXIub24oVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGUuVElMRV9SRVNQT05TRSwgKHJlc3BvbnNlKSA9PiB0aGlzLl9vblRpbGVQcm92aWRlclJlc3BvbnNlKHJlc3BvbnNlKSk7XHJcbiAgICAgICAgdGhpcy5fdGlsZVByb3ZpZGVyLm9uKFRpbGVQcm92aWRlck1lc3NhZ2VUeXBlLlRJTEVfRVJST1IsIChyZXNwb25zZSkgPT4gdGhpcy5fb25UaWxlRXJyb3IocmVzcG9uc2UudGlsZSkpO1xyXG4gICAgICAgIHRoaXMuX29uQ2FtZXJhVXBkYXRlKCk7XHJcbiAgICB9XHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMuX3RpbGVQcm92aWRlci5kZXN0cm95KCk7XHJcbiAgICAgICAgZm9yIChjb25zdCBkZXN0cm95YWJsZSBvZiB0aGlzLl9kZXN0cm95YWJsZXMpIHtcclxuICAgICAgICAgICAgZGVzdHJveWFibGUuZGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdXBlci5kZXN0cm95KCk7XHJcbiAgICB9XHJcbiAgICBzZXRUaWxlVXJsVGVtcGxhdGUodGlsZVVybFRlbXBsYXRlKSB7XHJcbiAgICAgICAgdGhpcy5fdGlsZVByb3ZpZGVyLnNlbmRNZXNzYWdlKHtcclxuICAgICAgICAgICAgdHlwZTogVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGUuVElMRV9VUkxfVVBEQVRFLFxyXG4gICAgICAgICAgICB0aWxlVXJsVGVtcGxhdGVcclxuICAgICAgICB9LCAxIC8qIElNTUVESUFURSAqLyk7XHJcbiAgICAgICAgdGhpcy5fcmVmcmVzaEN1cnJlbnRUaWxlcygpO1xyXG4gICAgfVxyXG4gICAgX2NyZWF0ZVRpbGVSZXF1ZXN0KHRpbGVJdGVtLCBwcmlvcml0eSkge1xyXG4gICAgICAgIGNvbnN0IHRhcmdldFpvb20gPSB0aGlzLl9nZXRUYXJnZXRab29tKCk7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHRpbGVJdGVtLCB7IHByaW9yaXR5LCBpc1Zpc2libGU6IHRoaXMuX2lzVGlsZVZpc2libGUodGlsZUl0ZW0pLCB6b29tTWluOiB0YXJnZXRab29tLCB6b29tTWF4OiB0YXJnZXRab29tIH0pO1xyXG4gICAgfVxyXG4gICAgX3JlcXVlc3RUaWxlcyhyZXF1ZXN0cykge1xyXG4gICAgICAgIGNvbnN0IHJlcXVlc3RJZCA9IHVuaXF1ZUlkKCk7XHJcbiAgICAgICAgdGhpcy5fb25UaWxlc1JlcXVlc3QocmVxdWVzdHMsIHJlcXVlc3RJZCk7XHJcbiAgICAgICAgZm9yIChjb25zdCByZXF1ZXN0IG9mIHJlcXVlc3RzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RlZFRpbGVEYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgaXNHZW9tZXRyeVJlYWR5OiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGFyZUxhYmVsc1JlYWR5OiBmYWxzZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0ZWRUaWxlc1N0YXRlLnNldChnZXRUaWxlSWQocmVxdWVzdCksIHJlcXVlc3RlZFRpbGVEYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHtcclxuICAgICAgICAgICAgdHlwZTogVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGUuVElMRV9SRVFVRVNUX0JBVENILFxyXG4gICAgICAgICAgICByZXNwb25zZVR5cGU6IFRpbGVQcm92aWRlck1lc3NhZ2VUeXBlLlRJTEVfUkVTUE9OU0UsXHJcbiAgICAgICAgICAgIGVycm9yVHlwZTogVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGUuVElMRV9FUlJPUixcclxuICAgICAgICAgICAgcmVxdWVzdElkLFxyXG4gICAgICAgICAgICByZXF1ZXN0c1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5fdGlsZVByb3ZpZGVyLnNlbmRNZXNzYWdlKHJlcXVlc3QsIDEgLyogSU1NRURJQVRFICovKTtcclxuICAgIH1cclxuICAgIF9jYW5jZWxUaWxlUmVxdWVzdHMocmVxdWVzdHMpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IHJlcXVlc3Qgb2YgcmVxdWVzdHMpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdGVkVGlsZXNTdGF0ZS5kZWxldGUoZ2V0VGlsZUlkKHJlcXVlc3QudGlsZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9vbkNhbmNlbFRpbGVSZXF1ZXN0cyhyZXF1ZXN0cyk7XHJcbiAgICAgICAgdGhpcy5fdGlsZVByb3ZpZGVyLnNlbmRNZXNzYWdlKHtcclxuICAgICAgICAgICAgdHlwZTogVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGUuVElMRV9SRVFVRVNUX0NBTkNFTF9CQVRDSCxcclxuICAgICAgICAgICAgcmVxdWVzdHNcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIF9vblRpbGVEYXRhVXBkYXRlKGRhdGFUb1Nob3csIGRhdGFUb0hpZGUpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IHByaW1pdGl2ZU1hbmFnZXIgb2YgdGhpcy5fdGlsZURhdGFNYW5hZ2Vycykge1xyXG4gICAgICAgICAgICBwcmltaXRpdmVNYW5hZ2VyLnVwZGF0ZVByaW1pdGl2ZXMoZGF0YVRvU2hvdywgZGF0YVRvSGlkZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX29uVGlsZURlc3Ryb3koX3RpbGVJdGVtLCBkYXRhKSB7XHJcbiAgICAgICAgLy8gcmVsZWFzZSBwcmltaXRpdmVzIHRoYXQgd2UndmUgY3JlYXRlZCBpbiBhbGxvY2F0b3JzXHJcbiAgICAgICAgZm9yIChjb25zdCBwb3J0aW9uIG9mIGRhdGEpIHtcclxuICAgICAgICAgICAgKHBvcnRpb24ucG9seWdvbnMgfHwgW10pLmZvckVhY2gocmVsZWFzZVByaW1pdGl2ZSk7XHJcbiAgICAgICAgICAgIChwb3J0aW9uLnRleHR1cmVkUG9seWdvbnMgfHwgW10pLmZvckVhY2gocmVsZWFzZVByaW1pdGl2ZSk7XHJcbiAgICAgICAgICAgIChwb3J0aW9uLnBvbHlsaW5lcyB8fCBbXSkuZm9yRWFjaChyZWxlYXNlUHJpbWl0aXZlKTtcclxuICAgICAgICAgICAgKHBvcnRpb24udGV4dHVyZWRQb2x5bGluZXMgfHwgW10pLmZvckVhY2gocmVsZWFzZVByaW1pdGl2ZSk7XHJcbiAgICAgICAgICAgIChwb3J0aW9uLnBvaW50cyB8fCBbXSkuZm9yRWFjaChyZWxlYXNlUHJpbWl0aXZlKTtcclxuICAgICAgICAgICAgKHBvcnRpb24ucG9pbnRMYWJlbHMgfHwgW10pLmZvckVhY2gocmVsZWFzZVByaW1pdGl2ZSk7XHJcbiAgICAgICAgICAgIChwb3J0aW9uLmN1cnZlZExhYmVscyB8fCBbXSkuZm9yRWFjaChyZWxlYXNlUHJpbWl0aXZlKTtcclxuICAgICAgICAgICAgKHBvcnRpb24ubW9kZWxzIHx8IFtdKS5mb3JFYWNoKHJlbGVhc2VQcmltaXRpdmUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9zZW5kU3RhdGlzdGljc0JlZm9yZURlc3Ryb3koKSB7XHJcbiAgICAgICAgc3VwZXIuX3NlbmRTdGF0aXN0aWNzQmVmb3JlRGVzdHJveSgpO1xyXG4gICAgICAgIGlmICh0aGlzLl9wZXJmTG9nSXRlbXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaXRlbXMgPSB0aGlzLl9wZXJmTG9nSXRlbXM7XHJcbiAgICAgICAgaXRlbXMuc29ydCgoYSwgYikgPT4gYS5wYXJzZVRpbWUgLSBiLnBhcnNlVGltZSk7XHJcbiAgICAgICAgY29uc3QgbWluID0gaXRlbXNbMF07XHJcbiAgICAgICAgY29uc3QgbWF4ID0gaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgY29uc3QgbWVkaWFuID0gaXRlbXNbTWF0aC5mbG9vcihpdGVtcy5sZW5ndGggLyAyKV07XHJcbiAgICAgICAgY291bnRUaWxlUGFyc2VUaW1lKHRoaXMuX2xheWVyTmFtZSwgbWluLnRpbGUsIG1pbi5wYXJzZVRpbWUsIG1heC50aWxlLCBtYXgucGFyc2VUaW1lLCBtZWRpYW4udGlsZSwgbWVkaWFuLnBhcnNlVGltZSk7XHJcbiAgICB9XHJcbiAgICBfb25UaWxlUHJvdmlkZXJSZXNwb25zZShyZXNwb25zZSkge1xyXG4gICAgICAgIHRoaXMuX3B1c2hQZXJmTG9nSXRlbShyZXNwb25zZS50aWxlLCByZXNwb25zZS5wYXJzZVRpbWUpO1xyXG4gICAgICAgIGNvbnN0IHRpbGUgPSByZXNwb25zZS50aWxlO1xyXG4gICAgICAgIGNvbnN0IHRhc2tQcmlvcml0eSA9IFFVRVVFX1RBU0tfUFJJT1JJVElFUy5maXJzdFRpbGVQb3J0aW9uICtcclxuICAgICAgICAgICAgdGhpcy5fZ2V0VGlsZVByaW9yaXR5KHRpbGUsIHRoaXMuX2lzVGlsZVZpc2libGUodGlsZSkpO1xyXG4gICAgICAgIHRoaXMuX3Rhc2tRdWV1ZS5lbnF1ZXVlKHtcclxuICAgICAgICAgICAgcHJpb3JpdHk6IHRhc2tQcmlvcml0eSxcclxuICAgICAgICAgICAgZXhlY3V0ZTogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gYXRsYXMgbXVzdCBiZSB1cGRhdGVkIG5vdHdpdGhzdGFuZGluZyB0aGUgdGlsZSBpcyBhY3RpdmUgb3Igbm90XHJcbiAgICAgICAgICAgICAgICAvLyBhcyB0aGVzZSBuZXcgZ2x5cGhzIHdpbGwgYmUgdXNlZCBpbiBuZXh0IHRpbGVzXHJcbiAgICAgICAgICAgICAgICBjb25zdCBhdGxhcyA9IHJlc3BvbnNlLmdseXBoQXRsYXNUb1VwZGF0ZTtcclxuICAgICAgICAgICAgICAgIGlmIChhdGxhcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dseXBoQXRsYXMudXBkYXRlQ29udGVudChhdGxhcy53aWR0aCwgYXRsYXMuaGVpZ2h0LCBhdGxhcy5kYXRhLCBuZXcgTWFwKGF0bGFzLmdseXBoTG9jYXRpb25zKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZWdpc3RyeSA9IHJlc3BvbnNlLmZvbnRSZWdpc3RyeVRvVXBkYXRlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlZ2lzdHJ5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBmb250RGF0YSBvZiByZWdpc3RyeSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZm9udDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2ZvbnRSZWdpc3RyeS5jb250YWlucyhmb250RGF0YS5pZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnQgPSB0aGlzLl9mb250UmVnaXN0cnkuZ2V0KGZvbnREYXRhLmlkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnQgPSBuZXcgRGZGb250KGZvbnREYXRhLmlkLCBmb250RGF0YS54aGVpZ2h0LCBmb250RGF0YS5tYXJnaW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZm9udFJlZ2lzdHJ5LmFkZChmb250KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb250LmFkZEFsbEdseXBocyhmb250RGF0YS5nbHlwaHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RJZCA9IHJlc3BvbnNlLnJlcXVlc3RJZDtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5faXNUaWxlU3RpbGxBY3RpdmUodGlsZSwgcmVxdWVzdElkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIElmIHRpbGUgaXMgYmVpbmcgcmVmcmVzaGVkIGRvbid0IHZpc3VhbGl6ZSBhbnkgcG9ydGlvbnMgdW50aWwgYWxsIG9mIHRoZW0gYXJlIGxvYWRlZCB0byBhdm9pZCBhIGJsaW5rXHJcbiAgICAgICAgICAgICAgICBjb25zdCBpc1JlZnJlc2hpbmcgPSB0aGlzLl9pc1RpbGVSZWZyZXNoaW5nKHRpbGUpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaWNvbnNTcGxpdHRlZCA9IHNwbGl0SW1hZ2VEZXBlbmRhbnRQcmltaXRpdmVzKHJlc3BvbnNlLnBvaW50cywgdGhpcy5faW1hZ2VNYW5hZ2VyTmVhcmVzdCwgKHBvaW50KSA9PiBwb2ludC5zdHlsZXNbMF0uaW1hZ2VJZCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0dXJlZFBvbHlsaW5lc1NwbGl0dGVkID0gc3BsaXRJbWFnZURlcGVuZGFudFByaW1pdGl2ZXMocmVzcG9uc2UudGV4dHVyZWRQb2x5bGluZXMsIHRoaXMuX2ltYWdlTWFuYWdlckxpbmVhciwgKHBvbHlsaW5lKSA9PiBwb2x5bGluZS5zdHlsZXNbMF0uaW5saW5lLnBhdHRlcm4uaW1hZ2VJZCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0dXJlZFBvbHlnb25zSW1hZ2VzID0gZ2V0SW1hZ2VzSWZBbGxBbGxvY2F0ZWQocmVzcG9uc2UudGV4dHVyZWRQb2x5Z29ucywgdGhpcy5faW1hZ2VNYW5hZ2VyTmVhcmVzdCwgKHBvbHlnb24pID0+IHBvbHlnb24uc3R5bGVzWzBdLnBhdHRlcm4uaW1hZ2VJZCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90YXNrUXVldWUuZW5xdWV1ZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHk6IFFVRVVFX1RBU0tfUFJJT1JJVElFUy5zZWNvbmRUaWxlUG9ydGlvbiArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2dldFRpbGVQcmlvcml0eSh0aWxlLCB0aGlzLl9pc1RpbGVWaXNpYmxlKHRpbGUpKSxcclxuICAgICAgICAgICAgICAgICAgICBleGVjdXRlOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc1RpbGVTdGlsbEFjdGl2ZSh0aWxlLCByZXNwb25zZS5yZXF1ZXN0SWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wdXRUaWxlRGF0YSh0aWxlLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9seWdvbnM6IHRoaXMuX2FsbG9jYXRlUG9seWdvbnMocmVzcG9uc2UpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsczogdGhpcy5fYWxsb2NhdGVNZXNoZXMocmVzcG9uc2UpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVybmFsTWVzaGVzOiByZXNwb25zZS5leHRlcm5hbE1lc2hlcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2x5bGluZXM6IHRoaXMuX2FsbG9jYXRlUG9seWxpbmVzKHJlc3BvbnNlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludExhYmVsczogdGhpcy5fYWxsb2NhdGVQb2ludExhYmVscyhyZXNwb25zZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VydmVkTGFiZWxzOiB0aGlzLl9hbGxvY2F0ZUN1cnZlZExhYmVscyhyZXNwb25zZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzOiB0aGlzLl9hbGxvY2F0ZUljb25zKHRpbGUsIGljb25zU3BsaXR0ZWQucHJpbWl0aXZlc1dpdGhBbGxvY2F0ZWRJbWFnZXMsIGljb25zU3BsaXR0ZWQuYWxsb2NhdGVkSW1hZ2VzKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlZFBvbHlsaW5lczogdGhpcy5fYWxsb2NhdGVUZXh0dXJlZFBvbHlsaW5lcyh0aWxlLCB0ZXh0dXJlZFBvbHlsaW5lc1NwbGl0dGVkLnByaW1pdGl2ZXNXaXRoQWxsb2NhdGVkSW1hZ2VzLCB0ZXh0dXJlZFBvbHlsaW5lc1NwbGl0dGVkLmFsbG9jYXRlZEltYWdlcyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZWRQb2x5Z29uczogIXRleHR1cmVkUG9seWdvbnNJbWFnZXMuYWxsb2NhdGVkSW1hZ2VzID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW10gOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hbGxvY2F0ZVRleHR1cmVkUG9seWdvbnModGlsZSwgcmVzcG9uc2UudGV4dHVyZWRQb2x5Z29ucywgdGV4dHVyZWRQb2x5Z29uc0ltYWdlcy5hbGxvY2F0ZWRJbWFnZXMsIHJlc3BvbnNlLnRleHR1cmVkUG9seWdvblBhZ2VzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgcmVxdWVzdElkLCAhaXNSZWZyZXNoaW5nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb25zU3BsaXR0ZWQuYWxsb2NhdGVkSW1hZ2VzLmZvckVhY2gocmVsZWFzZVByaW1pdGl2ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlZFBvbHlsaW5lc1NwbGl0dGVkLmFsbG9jYXRlZEltYWdlcy5mb3JFYWNoKHJlbGVhc2VQcmltaXRpdmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRleHR1cmVkUG9seWdvbnNJbWFnZXMuYWxsb2NhdGVkSW1hZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZWRQb2x5Z29uc0ltYWdlcy5hbGxvY2F0ZWRJbWFnZXMuZm9yRWFjaChyZWxlYXNlUHJpbWl0aXZlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RlZFRpbGVEYXRhID0gdGhpcy5fcmVxdWVzdGVkVGlsZXNTdGF0ZS5nZXQoZ2V0VGlsZUlkKHRpbGUpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0ZWRUaWxlRGF0YSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogdGhlIGRhdGEgaXMgc3luY2VkIG9uIHRoZXNlIHR3byBwcm9wZXJ0aWVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgYW5kIHRoaXMgY29kZSBkb2Vzbid0IG1ha2UgbXVjaCBzZW5zZSBmb3Igbm93LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgIGJ1dCBpdCBpcyBsZWZ0IFwiYXMgaXNcIiBzaW5jZSBpdCBpcyBub3QgY2xlYXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICBob3cgaXQgd2lsbCBiZSBjaGFuZ2VkIGluIG5lYXJlc3QgZnV0dXJlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdGVkVGlsZURhdGEuaXNHZW9tZXRyeVJlYWR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0ZWRUaWxlRGF0YS5hcmVMYWJlbHNSZWFkeSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25UaWxlRGF0YVJlYWR5KHRpbGUsIHJlc3BvbnNlLnVybCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHB1dERhdGFQcm9taXNlcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgcHV0RGF0YVByb21pc2VzLnB1c2goaWNvbnNTcGxpdHRlZC5taXNzaW5nSW1hZ2VzLnRoZW4oKGltYWdlcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29uTWlzc2luZ0ljb25JbWFnZXNSZWFkeShyZXNwb25zZSwgaWNvbnNTcGxpdHRlZCwgaW1hZ2VzKTtcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgIHB1dERhdGFQcm9taXNlcy5wdXNoKHRleHR1cmVkUG9seWxpbmVzU3BsaXR0ZWQubWlzc2luZ0ltYWdlcy50aGVuKChpbWFnZXMpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbk1pc3NpbmdQb2x5bGluZUltYWdlc1JlYWR5KHJlc3BvbnNlLCB0ZXh0dXJlZFBvbHlsaW5lc1NwbGl0dGVkLCBpbWFnZXMpO1xyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRleHR1cmVkUG9seWdvbnNJbWFnZXMubWlzc2luZ0ltYWdlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHB1dERhdGFQcm9taXNlcy5wdXNoKHRleHR1cmVkUG9seWdvbnNJbWFnZXMubWlzc2luZ0ltYWdlcy50aGVuKChpbWFnZXMpID0+IHRoaXMuX29uTWlzc2luZ1BvbHlnb25JbWFnZXNSZWFkeShyZXNwb25zZSwgaW1hZ2VzKSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzUmVmcmVzaGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gYWxsIHRoZSBwb3J0aW9ucyBhcmUgbG9hZGVkLCBwdXQgZW1wdHkgZGF0YSB0byB2aXN1YXpsaXplIGl0XHJcbiAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5hbGwocHV0RGF0YVByb21pc2VzKS50aGVuKCgpID0+IHRoaXMuX3B1dFRpbGVEYXRhKHRpbGUsIHt9LCByZXF1ZXN0SWQsIHRydWUpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX29uTWlzc2luZ0ljb25JbWFnZXNSZWFkeShyZXNwb25zZSwgaWNvbnNTcGxpdHRlZCwgaW1hZ2VzKSB7XHJcbiAgICAgICAgY29uc3QgdGlsZSA9IHJlc3BvbnNlLnRpbGU7XHJcbiAgICAgICAgdGhpcy5fbWlub3JUYXNrUXVldWUuZW5xdWV1ZSh7XHJcbiAgICAgICAgICAgIHByaW9yaXR5OiBERUZBVUxUX0lETEVfVEFTS19QUklPUklUWSArXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9nZXRUaWxlUHJpb3JpdHkodGlsZSwgdGhpcy5faXNUaWxlVmlzaWJsZSh0aWxlKSksXHJcbiAgICAgICAgICAgIGV4ZWN1dGU6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc1RpbGVTdGlsbEFjdGl2ZSh0aWxlLCByZXNwb25zZS5yZXF1ZXN0SWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9pbnRzID0gdGhpcy5fYWxsb2NhdGVJY29ucyh0aWxlLCBpY29uc1NwbGl0dGVkLnByaW1pdGl2ZXNXaXRoTWlzc2luZ0ltYWdlcywgaW1hZ2VzKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wdXRUaWxlRGF0YSh0aWxlLCB7IHBvaW50cyB9LCByZXNwb25zZS5yZXF1ZXN0SWQsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGltYWdlcy5mb3JFYWNoKHJlbGVhc2VQcmltaXRpdmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfb25NaXNzaW5nUG9seWxpbmVJbWFnZXNSZWFkeShyZXNwb25zZSwgdGV4dHVyZWRQb2x5bGluZXNTcGxpdHRlZCwgaW1hZ2VzKSB7XHJcbiAgICAgICAgY29uc3QgdGlsZSA9IHJlc3BvbnNlLnRpbGU7XHJcbiAgICAgICAgdGhpcy5fbWlub3JUYXNrUXVldWUuZW5xdWV1ZSh7XHJcbiAgICAgICAgICAgIHByaW9yaXR5OiBERUZBVUxUX0lETEVfVEFTS19QUklPUklUWSArIHRoaXMuX2dldFRpbGVQcmlvcml0eSh0aWxlLCB0aGlzLl9pc1RpbGVWaXNpYmxlKHRpbGUpKSxcclxuICAgICAgICAgICAgZXhlY3V0ZTogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzVGlsZVN0aWxsQWN0aXZlKHRpbGUsIHJlc3BvbnNlLnJlcXVlc3RJZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0dXJlZFBvbHlsaW5lcyA9IHRoaXMuX2FsbG9jYXRlVGV4dHVyZWRQb2x5bGluZXModGlsZSwgdGV4dHVyZWRQb2x5bGluZXNTcGxpdHRlZC5wcmltaXRpdmVzV2l0aE1pc3NpbmdJbWFnZXMsIGltYWdlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHV0VGlsZURhdGEodGlsZSwgeyB0ZXh0dXJlZFBvbHlsaW5lcyB9LCByZXNwb25zZS5yZXF1ZXN0SWQsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGltYWdlcy5mb3JFYWNoKHJlbGVhc2VQcmltaXRpdmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfb25NaXNzaW5nUG9seWdvbkltYWdlc1JlYWR5KHJlc3BvbnNlLCBpbWFnZXMpIHtcclxuICAgICAgICBjb25zdCB0aWxlID0gcmVzcG9uc2UudGlsZTtcclxuICAgICAgICB0aGlzLl9taW5vclRhc2tRdWV1ZS5lbnF1ZXVlKHtcclxuICAgICAgICAgICAgcHJpb3JpdHk6IERFRkFVTFRfSURMRV9UQVNLX1BSSU9SSVRZICtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2dldFRpbGVQcmlvcml0eSh0aWxlLCB0aGlzLl9pc1RpbGVWaXNpYmxlKHRpbGUpKSxcclxuICAgICAgICAgICAgZXhlY3V0ZTogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzVGlsZVN0aWxsQWN0aXZlKHRpbGUsIHJlc3BvbnNlLnJlcXVlc3RJZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0dXJlZFBvbHlnb25zID0gdGhpcy5fYWxsb2NhdGVUZXh0dXJlZFBvbHlnb25zKHRpbGUsIHJlc3BvbnNlLnRleHR1cmVkUG9seWdvbnMsIGltYWdlcywgcmVzcG9uc2UudGV4dHVyZWRQb2x5Z29uUGFnZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3B1dFRpbGVEYXRhKHRpbGUsIHsgdGV4dHVyZWRQb2x5Z29ucyB9LCByZXNwb25zZS5yZXF1ZXN0SWQsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGltYWdlcy5mb3JFYWNoKHJlbGVhc2VQcmltaXRpdmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfb25UaWxlRXJyb3IodGlsZSkge1xyXG4gICAgICAgIHN1cGVyLl9vblRpbGVFcnJvcih0aWxlKTtcclxuICAgICAgICB0aGlzLl9yZXF1ZXN0ZWRUaWxlc1N0YXRlLmRlbGV0ZShnZXRUaWxlSWQodGlsZSkpO1xyXG4gICAgfVxyXG4gICAgX2lzVGlsZVZpc2libGUodGlsZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50VGlsZXMuaGFzKGdldFRpbGVJZCh0aWxlKSk7XHJcbiAgICB9XHJcbiAgICBfYWxsb2NhdGVQb2x5Z29ucyhyZXNwb25zZSkge1xyXG4gICAgICAgIGNvbnN0IHBvbHlnb25QcmltaXRpdmVzID0gbmV3IEFycmF5KHJlc3BvbnNlLnBvbHlnb25zLmxlbmd0aCArIHJlc3BvbnNlLnRyYW5zcGFyZW50UG9seWdvbnMubGVuZ3RoKTtcclxuICAgICAgICBjb25zdCBtZW1vcnlDaHVua3MgPSBuZXcgTWVtb3J5Q2h1bmtzKHJlc3BvbnNlLnBvbHlnb25QYWdlcywgdGhpcy5fbWVtb3J5TWFuYWdlciwgUE9MWUdPTl9BVFRSSUJVVEVfTUFQUElORyk7XHJcbiAgICAgICAgY29uc3QgdHJhbnNwYXJlbnRQb2x5Z29uc01lbW9yeUNodW5rcyA9IG5ldyBNZW1vcnlDaHVua3MocmVzcG9uc2UudHJhbnNwYXJlbnRQb2x5Z29uUGFnZXMsIHRoaXMuX21lbW9yeU1hbmFnZXIsIFRSQU5TUEFSRU5UX1BPTFlHT05fQVRUUklCVVRFX01BUFBJTkcpO1xyXG4gICAgICAgIGxldCBpbmRleCA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXNwb25zZS5wb2x5Z29ucy5sZW5ndGg7IGkrKywgaW5kZXgrKykge1xyXG4gICAgICAgICAgICBjb25zdCB7IGJ1ZmZlckxvY2F0aW9uIH0gPSByZXNwb25zZS5wb2x5Z29uc1tpXTtcclxuICAgICAgICAgICAgcG9seWdvblByaW1pdGl2ZXNbaW5kZXhdID0gbmV3IFJlbmRlcmFibGVQb2x5Z29uKG5ldyBNZW1vcnlTdWJDaHVuayhtZW1vcnlDaHVua3NbYnVmZmVyTG9jYXRpb24uYnVmZmVySW5kZXhdLCBidWZmZXJMb2NhdGlvbiksIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3BvbnNlLnRyYW5zcGFyZW50UG9seWdvbnMubGVuZ3RoOyBpKyssIGluZGV4KyspIHtcclxuICAgICAgICAgICAgY29uc3QgeyBidWZmZXJMb2NhdGlvbiB9ID0gcmVzcG9uc2UudHJhbnNwYXJlbnRQb2x5Z29uc1tpXTtcclxuICAgICAgICAgICAgcG9seWdvblByaW1pdGl2ZXNbaW5kZXhdID0gbmV3IFJlbmRlcmFibGVQb2x5Z29uKG5ldyBNZW1vcnlTdWJDaHVuayh0cmFuc3BhcmVudFBvbHlnb25zTWVtb3J5Q2h1bmtzW2J1ZmZlckxvY2F0aW9uLmJ1ZmZlckluZGV4XSwgYnVmZmVyTG9jYXRpb24pLCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1lbW9yeUNodW5rcy5mb3JFYWNoKChjaHVuaykgPT4gY2h1bmsucmVsZWFzZSgpKTtcclxuICAgICAgICB0cmFuc3BhcmVudFBvbHlnb25zTWVtb3J5Q2h1bmtzLmZvckVhY2goKGNodW5rKSA9PiBjaHVuay5yZWxlYXNlKCkpO1xyXG4gICAgICAgIHJldHVybiBwb2x5Z29uUHJpbWl0aXZlcztcclxuICAgIH1cclxuICAgIF9hbGxvY2F0ZVRleHR1cmVkUG9seWdvbnModGlsZSwgcG9seWdvbkRlc2NyaXB0aW9ucywgaW1hZ2VzLCB0ZXh0dXJlZFBvbHlnb25QYWdlcykge1xyXG4gICAgICAgIGNvbnN0IHRleHR1cmVkUG9seWdvblJld3JpdGVyID0gbmV3IFRleHR1cmVkUG9seWdvbkJ1ZmZlclJld3JpdGVyKHRleHR1cmVkUG9seWdvblBhZ2VzKTtcclxuICAgICAgICBjb25zdCB3b3JsZFRvUHhGYWN0b3IgPSBXT1JMRF9TSVpFIC8gKHRoaXMuX3RpbGVTaWRlU2l6ZVB4ICogTWF0aC5wb3coMiwgdGlsZS56b29tKSk7XHJcbiAgICAgICAgY29uc3QgbG9jYXRpb25zID0gcG9seWdvbkRlc2NyaXB0aW9ucy5tYXAoKHBhcnNlZFBvbHlnb24sIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGltYWdlID0gaW1hZ2VzW2luZGV4XTtcclxuICAgICAgICAgICAgaWYgKGltYWdlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhbGxvY2F0ZWRJbWFnZSA9IGltYWdlO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGF0dGVybiA9IHBhcnNlZFBvbHlnb24uc3R5bGVzWzBdLnBhdHRlcm47XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbWFnZVNjYWxlID0gcGF0dGVybi53aWR0aCAvIGFsbG9jYXRlZEltYWdlLmRlc2NyaXB0b3Iud2lkdGg7XHJcbiAgICAgICAgICAgICAgICB0ZXh0dXJlZFBvbHlnb25SZXdyaXRlci5yZXdyaXRlVVYocGFyc2VkUG9seWdvbi5idWZmZXJMb2NhdGlvbiwgYWxsb2NhdGVkSW1hZ2UuYmJveCwgd29ybGRUb1B4RmFjdG9yICogaW1hZ2VTY2FsZSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkUG9seWdvbi5idWZmZXJMb2NhdGlvbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgbWVtb3J5Q2h1bmtzID0gbmV3IE1lbW9yeUNodW5rcyh0ZXh0dXJlZFBvbHlnb25QYWdlcywgdGhpcy5fbWVtb3J5TWFuYWdlciwgVEVYVFVSRURfUE9MWUdPTl9BVFRSSUJVVEVfTUFQUElORyk7XHJcbiAgICAgICAgY29uc3QgdGV4dHVyZWRQb2x5Z29uUHJpbWl0aXZlcyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jYXRpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0gbG9jYXRpb25zW2ldO1xyXG4gICAgICAgICAgICBjb25zdCBpbWFnZSA9IGltYWdlc1tpXTtcclxuICAgICAgICAgICAgaWYgKGxvY2F0aW9uICYmIGltYWdlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0dXJlZFBvbHlnb25QcmltaXRpdmUgPSBuZXcgUmVuZGVyYWJsZVRleHR1cmVkUG9seWdvbihuZXcgTWVtb3J5U3ViQ2h1bmsobWVtb3J5Q2h1bmtzW2xvY2F0aW9uLmJ1ZmZlckluZGV4XSwgbG9jYXRpb24pLCBpbWFnZSk7XHJcbiAgICAgICAgICAgICAgICB0ZXh0dXJlZFBvbHlnb25QcmltaXRpdmVzLnB1c2godGV4dHVyZWRQb2x5Z29uUHJpbWl0aXZlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBtZW1vcnlDaHVua3MuZm9yRWFjaCgoY2h1bmspID0+IGNodW5rLnJlbGVhc2UoKSk7XHJcbiAgICAgICAgcmV0dXJuIHRleHR1cmVkUG9seWdvblByaW1pdGl2ZXM7XHJcbiAgICB9XHJcbiAgICBfYWxsb2NhdGVNZXNoZXModGlsZVJlc3BvbnNlKSB7XHJcbiAgICAgICAgY29uc3QgbWVtb3J5Q2h1bmtzID0gdGlsZVJlc3BvbnNlLm1lc2hQYWdlcy5tYXAoKHBhZ2UpID0+IHRoaXMuX21lbW9yeU1hbmFnZXIuYWxsb2NhdGUocGFnZS52ZXJ0ZXhCdWZmZXIsIHBhZ2UuaW5kZXhCdWZmZXIsIE1vZGVsQnVmZmVyV3JpdGVyLkFUVFJJQlVURV9NQVBQSU5HKSk7XHJcbiAgICAgICAgY29uc3QgbWVzaFByaW1pdGl2ZXMgPSB0aWxlUmVzcG9uc2UubWVzaGVzLm1hcCgobWVzaCkgPT4gbmV3IFJlbmRlcmFibGVNb2RlbChuZXcgTWVtb3J5U3ViQ2h1bmsobWVtb3J5Q2h1bmtzW21lc2guYnVmZmVyTG9jYXRpb24uYnVmZmVySW5kZXhdLCBtZXNoLmJ1ZmZlckxvY2F0aW9uKSkpO1xyXG4gICAgICAgIG1lbW9yeUNodW5rcy5mb3JFYWNoKChjaHVuaykgPT4gY2h1bmsucmVsZWFzZSgpKTtcclxuICAgICAgICByZXR1cm4gbWVzaFByaW1pdGl2ZXM7XHJcbiAgICB9XHJcbiAgICBfYWxsb2NhdGVQb2x5bGluZXMocmVzcG9uc2UpIHtcclxuICAgICAgICBjb25zdCBwb2x5bGluZVByaW1pdGl2ZXMgPSBuZXcgQXJyYXkocmVzcG9uc2UucG9seWxpbmVzLmxlbmd0aCk7XHJcbiAgICAgICAgY29uc3QgbWVtb3J5Q2h1bmtzID0gbmV3IE1lbW9yeUNodW5rcyhyZXNwb25zZS5wb2x5bGluZVBhZ2VzLCB0aGlzLl9tZW1vcnlNYW5hZ2VyLCBQT0xZTElORV9BVFRSSUJVVEVfTUFQUElORyk7XHJcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3BvbnNlLnBvbHlsaW5lcy5sZW5ndGg7IGkrKywgaW5kZXgrKykge1xyXG4gICAgICAgICAgICBjb25zdCB7IGJ1ZmZlckxvY2F0aW9uIH0gPSByZXNwb25zZS5wb2x5bGluZXNbaV07XHJcbiAgICAgICAgICAgIHBvbHlsaW5lUHJpbWl0aXZlc1tpbmRleF0gPSBuZXcgUmVuZGVyYWJsZVBvbHlsaW5lKG5ldyBNZW1vcnlTdWJDaHVuayhtZW1vcnlDaHVua3NbYnVmZmVyTG9jYXRpb24uYnVmZmVySW5kZXhdLCBidWZmZXJMb2NhdGlvbikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtZW1vcnlDaHVua3MuZm9yRWFjaCgoY2h1bmspID0+IGNodW5rLnJlbGVhc2UoKSk7XHJcbiAgICAgICAgcmV0dXJuIHBvbHlsaW5lUHJpbWl0aXZlcztcclxuICAgIH1cclxuICAgIF9hbGxvY2F0ZVRleHR1cmVkUG9seWxpbmVzKHRpbGUsIHBhcnNlZFBvbHlsaW5lcywgaW1hZ2VzKSB7XHJcbiAgICAgICAgY29uc3QgdGV4dHVyZWRQb2x5bGluZVdyaXRlciA9IG5ldyBUZXh0dXJlZFBvbHlsaW5lQnVmZmVyV3JpdGVyKCk7XHJcbiAgICAgICAgY29uc3Qgd29ybGRUb1B4RmFjdG9yID0gV09STERfU0laRSAvICh0aGlzLl90aWxlU2lkZVNpemVQeCAqIE1hdGgucG93KDIsIHRpbGUuem9vbSkpO1xyXG4gICAgICAgIGNvbnN0IGxvY2F0aW9ucyA9IHBhcnNlZFBvbHlsaW5lcy5tYXAoKHBhcnNlZFBvbHlsaW5lLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBpbWFnZSA9IGltYWdlc1tpbmRleF07XHJcbiAgICAgICAgICAgIGlmIChpbWFnZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3R5bGUgPSBwYXJzZWRQb2x5bGluZS5zdHlsZXNbMF07XHJcbiAgICAgICAgICAgICAgICBjb25zdCB3aWR0aCA9IChzdHlsZS5pbmxpbmUgfHwgc3R5bGUub3V0bGluZSkuc3Ryb2tlV2lkdGg7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbWFnZUxvY2F0aW9uID0gaW1hZ2UuYmJveDtcclxuICAgICAgICAgICAgICAgIC8vIGltYWdlIHNpemUgbWF5IG5vdCBtYXRjaCBwb2x5bGluZSdzIHN0cm9rZVdpZHRoLCBzbyBpdCBtdXN0IGJlIHNjYWxlZCBhY2NvcmRpbmdseSBpblxyXG4gICAgICAgICAgICAgICAgLy8gYm90aCBkaXJlY3Rpb25zLCB0aGlzIGZhY3RvciBjYW4gYmUgcGFzc2VkIHRvIHRoZSB3cml0ZXIgaW4gd29ybGRUb1B4RmFjdG9yIHVwZGF0ZWQuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBwaXhlbFJhdGlvID0gd2lkdGggLyAoaW1hZ2VMb2NhdGlvbi5tYXhZIC0gaW1hZ2VMb2NhdGlvbi5taW5ZKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0dXJlZFBvbHlsaW5lV3JpdGVyLndyaXRlVGV4dHVyZWRQb2x5bGluZShwYXJzZWRQb2x5bGluZSwgd2lkdGgsIHdvcmxkVG9QeEZhY3RvciAqIHBpeGVsUmF0aW8sIGltYWdlTG9jYXRpb24sIHN0eWxlLnpJbmRleCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IHBhZ2VzID0gdGV4dHVyZWRQb2x5bGluZVdyaXRlci5nZXRCdWZmZXJzKCk7XHJcbiAgICAgICAgY29uc3QgbWVtb3J5Q2h1bmtzID0gbmV3IE1lbW9yeUNodW5rcyhwYWdlcywgdGhpcy5fbWVtb3J5TWFuYWdlciwgVGV4dHVyZWRQb2x5bGluZUJ1ZmZlcldyaXRlci5BVFRSSUJVVEVfTUFQUElORyk7XHJcbiAgICAgICAgY29uc3QgdGV4dHVyZWRQb2x5bGluZVByaW1pdGl2ZXMgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxvY2F0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBsb2NhdGlvbiA9IGxvY2F0aW9uc1tpXTtcclxuICAgICAgICAgICAgY29uc3QgaW1hZ2UgPSBpbWFnZXNbaV07XHJcbiAgICAgICAgICAgIGlmIChsb2NhdGlvbiAmJiBpbWFnZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dHVyZWRQb2x5bGluZVByaW1pdGl2ZSA9IG5ldyBSZW5kZXJhYmxlVGV4dHVyZWRQb2x5bGluZShuZXcgTWVtb3J5U3ViQ2h1bmsobWVtb3J5Q2h1bmtzW2xvY2F0aW9uLmJ1ZmZlckluZGV4XSwgbG9jYXRpb24pLCBpbWFnZSk7XHJcbiAgICAgICAgICAgICAgICB0ZXh0dXJlZFBvbHlsaW5lUHJpbWl0aXZlcy5wdXNoKHRleHR1cmVkUG9seWxpbmVQcmltaXRpdmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1lbW9yeUNodW5rcy5mb3JFYWNoKChjaHVuaykgPT4gY2h1bmsucmVsZWFzZSgpKTtcclxuICAgICAgICByZXR1cm4gdGV4dHVyZWRQb2x5bGluZVByaW1pdGl2ZXM7XHJcbiAgICB9XHJcbiAgICBfYWxsb2NhdGVQb2ludExhYmVscyhyZXNwb25zZSkge1xyXG4gICAgICAgIGNvbnN0IG1lbW9yeUNodW5rcyA9IG5ldyBNZW1vcnlDaHVua3MocmVzcG9uc2UucG9pbnRMYWJlbFBhZ2VzLCB0aGlzLl9tZW1vcnlNYW5hZ2VyLCBQT0lOVF9MQUJFTF9BVFRSSUJVVEVfTUFQUElORyk7XHJcbiAgICAgICAgY29uc3QgYmFja2dyb3VuZE1lbW9yeUNodW5rcyA9IG5ldyBNZW1vcnlDaHVua3MocmVzcG9uc2UucG9pbnRMYWJlbEJhY2tncm91bmRQYWdlcywgdGhpcy5fbWVtb3J5TWFuYWdlciwgQklMTEJPQVJEX1JFQ1RBTkdMRV9BVFRSSUJVVEVfTUFQUElORyk7XHJcbiAgICAgICAgY29uc3QgcG9pbnRMYWJlbHMgPSByZXNwb25zZS5wb2ludExhYmVscy5tYXAoKHsgYnVmZmVyTG9jYXRpb24sIGJhY2tncm91bmRCdWZmZXJMb2NhdGlvbiB9KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJhY2tncm91bmRQcmltaXRpdmUgPSBiYWNrZ3JvdW5kQnVmZmVyTG9jYXRpb24gP1xyXG4gICAgICAgICAgICAgICAgbmV3IFJlbmRlcmFibGVCaWxsYm9hcmRSZWN0YW5nbGUobmV3IE1lbW9yeVN1YkNodW5rKGJhY2tncm91bmRNZW1vcnlDaHVua3NbYmFja2dyb3VuZEJ1ZmZlckxvY2F0aW9uLmJ1ZmZlckluZGV4XSwgYmFja2dyb3VuZEJ1ZmZlckxvY2F0aW9uKSkgOlxyXG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBjb25zdCBsYWJlbFByaW1pdGl2ZSA9IG5ldyBab29tUmVzdHJpY3RlZExhYmVsKG5ldyBNZW1vcnlTdWJDaHVuayhtZW1vcnlDaHVua3NbYnVmZmVyTG9jYXRpb24uYnVmZmVySW5kZXhdLCBidWZmZXJMb2NhdGlvbiksIHRoaXMuX2dseXBoQXRsYXMsIHRoaXMuX2NvbXB1dGVNaW5ab29tKHJlc3BvbnNlLnRpbGUsIE1JTlpPT01fREVMVEFTLnBvaW50TGFiZWxzKSwgYmFja2dyb3VuZFByaW1pdGl2ZSk7XHJcbiAgICAgICAgICAgIGlmIChiYWNrZ3JvdW5kUHJpbWl0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kUHJpbWl0aXZlLnJlbGVhc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbGFiZWxQcmltaXRpdmU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYmFja2dyb3VuZE1lbW9yeUNodW5rcy5mb3JFYWNoKChjaHVuaykgPT4gY2h1bmsucmVsZWFzZSgpKTtcclxuICAgICAgICBtZW1vcnlDaHVua3MuZm9yRWFjaCgoY2h1bmspID0+IGNodW5rLnJlbGVhc2UoKSk7XHJcbiAgICAgICAgcmV0dXJuIHBvaW50TGFiZWxzO1xyXG4gICAgfVxyXG4gICAgX2FsbG9jYXRlQ3VydmVkTGFiZWxzKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgY29uc3QgbWVtb3J5Q2h1bmtzID0gbmV3IE1lbW9yeUNodW5rcyhyZXNwb25zZS5jdXJ2ZWRMYWJlbFBhZ2VzLCB0aGlzLl9tZW1vcnlNYW5hZ2VyLCBDVVJWRURfTEFCRUxfQVRUUklCVVRFX01BUFBJTkcpO1xyXG4gICAgICAgIGNvbnN0IGN1cnZlZExhYmVsUHJpbWl0aXZlcyA9IHJlc3BvbnNlLmN1cnZlZExhYmVscy5tYXAoKHsgYnVmZmVyTG9jYXRpb24gfSkgPT4gbmV3IFpvb21SZXN0cmljdGVkTGFiZWwobmV3IE1lbW9yeVN1YkNodW5rKG1lbW9yeUNodW5rc1tidWZmZXJMb2NhdGlvbi5idWZmZXJJbmRleF0sIGJ1ZmZlckxvY2F0aW9uKSwgdGhpcy5fZ2x5cGhBdGxhcywgdGhpcy5fY29tcHV0ZU1pblpvb20ocmVzcG9uc2UudGlsZSwgTUlOWk9PTV9ERUxUQVMuY3VydmVkTGFiZWxzKSkpO1xyXG4gICAgICAgIG1lbW9yeUNodW5rcy5mb3JFYWNoKChjaHVuaykgPT4gY2h1bmsucmVsZWFzZSgpKTtcclxuICAgICAgICByZXR1cm4gY3VydmVkTGFiZWxQcmltaXRpdmVzO1xyXG4gICAgfVxyXG4gICAgX2FsbG9jYXRlSWNvbnModGlsZSwgcGFyc2VkSWNvbnMsIGltYWdlcykge1xyXG4gICAgICAgIGNvbnN0IGljb25Xcml0ZXIgPSBuZXcgSWNvbkJ1ZmZlcldyaXRlcigpO1xyXG4gICAgICAgIGNvbnN0IGxvY2F0aW9ucyA9IHBhcnNlZEljb25zLm1hcCgocGFyc2VkSWNvbiwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaW1hZ2UgPSBpbWFnZXNbaW5kZXhdO1xyXG4gICAgICAgICAgICBpZiAoaW1hZ2UpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0eWxlID0gcGFyc2VkSWNvbi5zdHlsZXNbMF07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzaXplID0gaW1hZ2UuZGVzY3JpcHRvcjtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBpeGVsUmF0aW8gPSBzdHlsZS53aWR0aCAvIHNpemUud2lkdGg7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaWNvbldyaXRlci53cml0ZUljb24ocGFyc2VkSWNvbiwgaW1hZ2UuYmJveCwgc2l6ZSwgc3R5bGUub2Zmc2V0LCBwaXhlbFJhdGlvKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgcGFnZXMgPSBpY29uV3JpdGVyLmdldEJ1ZmZlcnMoKTtcclxuICAgICAgICBjb25zdCBtZW1vcnlDaHVua3MgPSBuZXcgTWVtb3J5Q2h1bmtzKHBhZ2VzLCB0aGlzLl9tZW1vcnlNYW5hZ2VyLCBJY29uQnVmZmVyV3JpdGVyLkFUVFJJQlVURV9NQVBQSU5HKTtcclxuICAgICAgICBjb25zdCBpY29uUHJpbWl0aXZlcyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jYXRpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0gbG9jYXRpb25zW2ldO1xyXG4gICAgICAgICAgICBjb25zdCBpbWFnZSA9IGltYWdlc1tpXTtcclxuICAgICAgICAgICAgaWYgKGxvY2F0aW9uICYmIGltYWdlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpY29uUHJpbWl0aXZlID0gbmV3IFpvb21SZXN0cmljdGVkSWNvbihuZXcgTWVtb3J5U3ViQ2h1bmsobWVtb3J5Q2h1bmtzW2xvY2F0aW9uLmJ1ZmZlckluZGV4XSwgbG9jYXRpb24pLCBpbWFnZSwgdGhpcy5fY29tcHV0ZU1pblpvb20odGlsZSwgTUlOWk9PTV9ERUxUQVMuaWNvbnMpKTtcclxuICAgICAgICAgICAgICAgIGljb25QcmltaXRpdmVzLnB1c2goaWNvblByaW1pdGl2ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbWVtb3J5Q2h1bmtzLmZvckVhY2goKGNodW5rKSA9PiBjaHVuay5yZWxlYXNlKCkpO1xyXG4gICAgICAgIHJldHVybiBpY29uUHJpbWl0aXZlcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgYSBtaW5pbXVtIHpvb20gYW4gb2JqZWN0IHNob3VsZCBiZSBzdGlsbCBkaXNwbGF5ZWQgb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRpbGUgVGlsZSB0aGUgb2JqZWN0IGJlbG9uZ3MgdG8uXHJcbiAgICAgKiBAcGFyYW0gZGVsdGEgVG9sZXJhbmNlIG9mIHRoZSB2aXNpYmlsaXR5IHRvIHpvb21pbmcgb3V0LCBkZWZhdWx0IHZhbHVlIHdhcyBlbXBpcmljYWxseSBjaG9zZW4uXHJcbiAgICAgKiBAcmV0dXJucyBNaW5pbXVtIHpvb20gZm9yIHRoZSBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIF9jb21wdXRlTWluWm9vbSh0aWxlLCBkZWx0YSA9IDEpIHtcclxuICAgICAgICByZXR1cm4gdGlsZS56b29tIC0gdGhpcy5fem9vbVNoaWZ0IC0gdGhpcy5fdGFyZ2V0Wm9vbVNoaWZ0IC0gZGVsdGE7XHJcbiAgICB9XHJcbiAgICBfcHVzaFBlcmZMb2dJdGVtKHRpbGUsIHBhcnNlVGltZSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9wZXJmTG9nSXRlbXMubGVuZ3RoIDwgTUFYX1BFUkZfTE9HX0lURU1TX0NPVU5UKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3BlcmZMb2dJdGVtcy5wdXNoKHsgdGlsZSwgcGFyc2VUaW1lIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogSGVscGVyIGNsYXNzIGZvciBhbGxvY2F0aW9uIG9mIGFuIGFycmF5IG9mIG1lbW9yeSBjaHVua3MuXHJcbiAqL1xyXG5jbGFzcyBNZW1vcnlDaHVua3MgZXh0ZW5kcyBBcnJheSB7XHJcbiAgICBjb25zdHJ1Y3RvcihwYWdlcywgbWVtb3J5TWFuYWdlciwgYXR0cmliTWFwcGluZykge1xyXG4gICAgICAgIHN1cGVyKHBhZ2VzLmxlbmd0aCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWdlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzW2ldID0gbWVtb3J5TWFuYWdlci5hbGxvY2F0ZShwYWdlc1tpXS52ZXJ0ZXhCdWZmZXIsIHBhZ2VzW2ldLmluZGV4QnVmZmVyLCBhdHRyaWJNYXBwaW5nKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIERhdGEgbWFuYWdlcnMgcmVzcG9uc2libGUgZm9yIHNwZWNpZmljIHR5cGUgb2YgcHJpbWl0aXZlcy4gSXQganVzdCBleHRyYWN0cyB0aGVtIGZyb20gVGlsZURhdGEgYW5kXHJcbiAqIHVwZGF0ZXMgYXBwcm9wcmlhdGUgcHJpbWl0aXZlIHByb3ZpZGVyLlxyXG4gKi9cclxuY2xhc3MgVGlsZURhdGFNYW5hZ2VyIHtcclxuICAgIGNvbnN0cnVjdG9yKHByaW1pdGl2ZU1hbmFnZXIsIHByaW1pdHZlRXh0cmFjdG9yKSB7XHJcbiAgICAgICAgdGhpcy5fcHJpbWl0aXZlTWFuYWdlciA9IHByaW1pdGl2ZU1hbmFnZXI7XHJcbiAgICAgICAgdGhpcy5fcHJpbWl0aXZlRXh0cmFjdG9yID0gcHJpbWl0dmVFeHRyYWN0b3I7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVQcmltaXRpdmVzKHRvU2hvdywgdG9IaWRlKSB7XHJcbiAgICAgICAgdGhpcy5fcHJpbWl0aXZlTWFuYWdlci51cGRhdGVTY2VuZSh0aGlzLl9wcmltaXRpdmVFeHRyYWN0b3IodG9TaG93KSwgdGhpcy5fcHJpbWl0aXZlRXh0cmFjdG9yKHRvSGlkZSkpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHJlbGVhc2VQcmltaXRpdmUocHJpbWl0aXZlKSB7XHJcbiAgICBpZiAocHJpbWl0aXZlKSB7XHJcbiAgICAgICAgcHJpbWl0aXZlLnJlbGVhc2UoKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVHVybnMgcmVqZWN0aW9uIG9mIG9yaWdpbmFsIHByb21pc2UgaW50byBudWxsLXZhbHVlIHJlc29sdXRpb24uIE51bGxzIG9uIGFwcHJvcHJpYXRlIHBsYWNlc1xyXG4gKiBhcmUgcmVxdWlyZWQgaW4gYWxsb2NhdGlvbiBvZiB0ZXh0dXJlZCBwcmltaXRpdmVzLlxyXG4gKi9cclxuZnVuY3Rpb24gbnVsbGlmeVJlamVjdGlvbihwcm9taXNlKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHByb21pc2UudGhlbihyZXNvbHZlLCAoKSA9PiByZXNvbHZlKG51bGwpKSk7XHJcbn1cclxuLyoqXHJcbiAqIFNwbGl0cyBwcmltaXRpdmVzIGludG8gdHdvIGxpc3RzOiB0aG9zZSB0aGF0IGhhdmUgcmVxdWlyZWQgaW1hZ2VzIGFsbG9jYXRlZCBhbmQgdGhvc2Ugd2hpY2ggaW1hZ2VzIGFyZSB0byBiZVxyXG4gKiByZXF1ZXN0ZWQuIFJlcXVpcmVkIGltYWdlcyByZXR1cm5lZCBpbiBjb3JyZXNwb25pbmcgYXJyYXlzIChyZXF1ZXN0ZWQgaW1hZ2VzIGFzIHByb21pc2VzKS5cclxuICovXHJcbmZ1bmN0aW9uIHNwbGl0SW1hZ2VEZXBlbmRhbnRQcmltaXRpdmVzKHByaW1pdGl2ZXMsIGltYWdlTWFuYWdlciwgaWRNYXBwZXIpIHtcclxuICAgIGNvbnN0IHByaW1pdGl2ZXNXaXRoQWxsb2NhdGVkSW1hZ2VzID0gW107XHJcbiAgICBjb25zdCBhbGxvY2F0ZWRJbWFnZXMgPSBbXTtcclxuICAgIGNvbnN0IHByaW1pdGl2ZXNXaXRoTWlzc2luZ0ltYWdlcyA9IFtdO1xyXG4gICAgY29uc3QgbWlzc2luZ0ltYWdlSWRzID0gW107XHJcbiAgICBmb3IgKGNvbnN0IHByaW1pdGl2ZSBvZiBwcmltaXRpdmVzKSB7XHJcbiAgICAgICAgY29uc3QgaWQgPSBpZE1hcHBlcihwcmltaXRpdmUpO1xyXG4gICAgICAgIGNvbnN0IGFsbG9jYXRlZEltYWdlID0gaW1hZ2VNYW5hZ2VyLmdldEltYWdlKGlkKTtcclxuICAgICAgICBpZiAoYWxsb2NhdGVkSW1hZ2UpIHtcclxuICAgICAgICAgICAgcHJpbWl0aXZlc1dpdGhBbGxvY2F0ZWRJbWFnZXMucHVzaChwcmltaXRpdmUpO1xyXG4gICAgICAgICAgICBhbGxvY2F0ZWRJbWFnZXMucHVzaChhbGxvY2F0ZWRJbWFnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwcmltaXRpdmVzV2l0aE1pc3NpbmdJbWFnZXMucHVzaChwcmltaXRpdmUpO1xyXG4gICAgICAgICAgICBtaXNzaW5nSW1hZ2VJZHMucHVzaChudWxsaWZ5UmVqZWN0aW9uKGltYWdlTWFuYWdlci5yZXF1ZXN0SW1hZ2UoaWQpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBwcmltaXRpdmVzV2l0aEFsbG9jYXRlZEltYWdlcyxcclxuICAgICAgICBhbGxvY2F0ZWRJbWFnZXMsXHJcbiAgICAgICAgcHJpbWl0aXZlc1dpdGhNaXNzaW5nSW1hZ2VzLFxyXG4gICAgICAgIG1pc3NpbmdJbWFnZXM6IFByb21pc2UuYWxsKG1pc3NpbmdJbWFnZUlkcylcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgZWl0aGVyIGFycmF5IG9mIGFsbG9jYXRlZCBpbWFnZXMgKGlmIGFsbCByZXF1aXJlZCBpbWFnZXMgYXJlIG9uIHRoZSBzcG90KSBvciBwcm9taXNlcyBmb3IgdGhlbSAoaWYgYXQgbGVhc3RcclxuICogb25lIHJlcXVpcmVkIGltYWdlIGlzIG5vdCB5ZXQgYWxsb2NhdGVkKS5cclxuICovXHJcbmZ1bmN0aW9uIGdldEltYWdlc0lmQWxsQWxsb2NhdGVkKHByaW1pdGl2ZXMsIGltYWdlTWFuYWdlciwgaWRNYXBwZXIpIHtcclxuICAgIGxldCBpc0FueU1pc3NpbmcgPSBmYWxzZTtcclxuICAgIGNvbnN0IGFsbG9jYXRlZEltYWdlcyA9IG5ldyBBcnJheShwcmltaXRpdmVzLmxlbmd0aCk7XHJcbiAgICBjb25zdCBtaXNzaW5nSW1hZ2VzID0gbmV3IEFycmF5KHByaW1pdGl2ZXMubGVuZ3RoKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJpbWl0aXZlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHByaW1pdGl2ZSA9IHByaW1pdGl2ZXNbaV07XHJcbiAgICAgICAgY29uc3QgaWQgPSBpZE1hcHBlcihwcmltaXRpdmUpO1xyXG4gICAgICAgIGNvbnN0IGFsbG9jYXRlZEltYWdlID0gaW1hZ2VNYW5hZ2VyLmdldEltYWdlKGlkKTtcclxuICAgICAgICBpZiAoYWxsb2NhdGVkSW1hZ2UpIHtcclxuICAgICAgICAgICAgYWxsb2NhdGVkSW1hZ2VzW2ldID0gYWxsb2NhdGVkSW1hZ2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpc0FueU1pc3NpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICBtaXNzaW5nSW1hZ2VzW2ldID0gbnVsbGlmeVJlamVjdGlvbihpbWFnZU1hbmFnZXIucmVxdWVzdEltYWdlKGlkKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGlzQW55TWlzc2luZykge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJpbWl0aXZlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoYWxsb2NhdGVkSW1hZ2VzW2ldKSB7XHJcbiAgICAgICAgICAgICAgICBtaXNzaW5nSW1hZ2VzW2ldID0gUHJvbWlzZS5yZXNvbHZlKGFsbG9jYXRlZEltYWdlc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgbWlzc2luZ0ltYWdlczogUHJvbWlzZS5hbGwobWlzc2luZ0ltYWdlcykgfTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB7IGFsbG9jYXRlZEltYWdlcyB9O1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCBBZGFwdGVyIGZyb20gJy4uL2FkYXB0ZXInO1xyXG5pbXBvcnQgVGlsZUNvb3JkaW5hdGVTeXN0ZW0sIHsgaXNQYXJlbnQgfSBmcm9tICcuL3V0aWwvdGlsZV9zeXN0ZW0nO1xyXG5pbXBvcnQgeyBhbGxPZkl0ZXJhYmxlLCBvbmVPZkl0ZXJhYmxlIH0gZnJvbSAnLi4vLi4vdXRpbC9pdGVyYWJsZSc7XHJcbmltcG9ydCB7IGdldFRpbGVJZCB9IGZyb20gJy4vdGlsZV9pZCc7XHJcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJy4uLy4uL3V0aWwvZXZlbnRfZW1pdHRlcic7XHJcbmltcG9ydCAqIGFzIHZlYzIgZnJvbSAnLi4vLi4vbWF0aC92ZWN0b3IyJztcclxuaW1wb3J0IHsgTk9fSUQgfSBmcm9tICcuLi8uLi91dGlsL3dvcmtlcic7XHJcbmltcG9ydCB7IGNvbXB1dGVWaXNpYmxlVGlsZXMgfSBmcm9tICcuL3V0aWwvdmlzaWJsZV90aWxlJztcclxuaW1wb3J0IHsgY2FsY3VsYXRlQmVsdFRpbGVzIH0gZnJvbSAnLi9iZWx0X3RpbGVzJztcclxuaW1wb3J0IHsgY291bnRUaWxlUHJvY2Vzc2luZ1RpbWUgfSBmcm9tICcuLi8uLi91dGlsL3N0YXQnO1xyXG5jb25zdCBOT19USUxFU19UT19IQU5ETEUgPSBbXTtcclxuY29uc3QgTUFYX1BFUkZfTE9HX0lURU1TX0NPVU5UID0gMTAyNDtcclxuLy8gVG8gc2VsZWN0IHdoaWNoIHRpbGUgdG8gbG9hZCBjYW1lcmEgem9vbSBpcyByb3VuZGVkIHNvIHRoZSBzaGlmdCBpcyAwLjUuXHJcbmNvbnN0IFRBUkdFVF9aT09NX1NISUZUID0gMC4yNTtcclxuY29uc3QgVklTSUJMRV9USUxFX1BSSU9SSVRZID0gMjAwO1xyXG5mdW5jdGlvbiogZmxhdHRlblZpc2libGVEYXRhUG9ydGlvbnModGlsZXMpIHtcclxuICAgIGZvciAoY29uc3QgdGlsZSBvZiB0aWxlcykge1xyXG4gICAgICAgIHlpZWxkKiB0aWxlLmRhdGEudmlzaWJsZTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRab29tU2hpZnQodGlsZVNpemUpIHtcclxuICAgIHN3aXRjaCAodGlsZVNpemUpIHtcclxuICAgICAgICBjYXNlIDEgLyogWDQgKi86XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICBjYXNlIDIgLyogWDE2ICovOlxyXG4gICAgICAgICAgICByZXR1cm4gLTI7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEJhc2UgY2xhc3MgZm9yIGFkYXB0ZXJzIHRoYXQgZ2V0IHRoZWlyIGRhdGEgaW4gdGlsZXMuIENvbnRlbnQgb2YgdGlsZXMgdGhhdCBjb21lIGludG8gZmllbGQgb2YgdmlldyBzaG91bGRcclxuICogYmUgcmVxdWVzdGVkLCBhcyB3ZWxsIGFzIGNvbnRlbnQgb2YgaW52aXNpYmxlIHRpbGVzIHNob3VsZCBiZSByZW1vdmVkLCBhbHNvIHRpbGVzIG9uIGRpZmZlcmVudCB6b29tIGxldmVscyBjYW5cclxuICogb3ZlcmxhcCBlYWNoIG90aGVyLiBNYW5hZ2luZyBvZiBhbGwgdGhlc2UgY2FzZXMgYW5kIG90aGVyIHRpbGUtc3BlY2lmaWMgbG9naWMgaXMgdGhlIHJlc3BvbnNpYmlsaXR5IG9mIHRoaXMgY2xhc3MuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaWxlQmFzZWRBZGFwdGVyIGV4dGVuZHMgQWRhcHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihlbmdpbmUsIGNhbWVyYSwgdGlsZVNpemUgPSAwIC8qIFgxICovLCBwcmVsb2FkZWRUaWxlc0JlbHRTaXplID0gMCwgbGF5ZXJOYW1lID0gJycpIHtcclxuICAgICAgICBzdXBlcihlbmdpbmUsIGNhbWVyYSk7XHJcbiAgICAgICAgdGhpcy5fbGF5ZXJOYW1lID0gbGF5ZXJOYW1lO1xyXG4gICAgICAgIHRoaXMuX3pvb21TaGlmdCA9IGdldFpvb21TaGlmdCh0aWxlU2l6ZSk7XHJcbiAgICAgICAgdGhpcy5fdGFyZ2V0Wm9vbVNoaWZ0ID0gVEFSR0VUX1pPT01fU0hJRlQ7XHJcbiAgICAgICAgdGhpcy5fZW5naW5lUmVuZGVyTGlzdGVuZXIgPSAoKSA9PiB0aGlzLl9vbkVuZ2luZVJlbmRlckV2ZW50KCk7XHJcbiAgICAgICAgdGhpcy5lbmdpbmUucmVuZGVyZXIub25SZW5kZXIuYWRkTGlzdGVuZXIodGhpcy5fZW5naW5lUmVuZGVyTGlzdGVuZXIpO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRUaWxlcyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLl9hbGxUaWxlcyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLl9yZWFkeUZvclJlbmRlclRpbGVzID0gW107XHJcbiAgICAgICAgdGhpcy5vblRpbGVSZWFkeSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLm9uVGlsZUxvYWRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5fcmVxdWVzdGVkVGlsZXMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5fdGlsZXNUb1JlZnJlc2ggPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgdGhpcy5fYmVsdFNpemUgPSBwcmVsb2FkZWRUaWxlc0JlbHRTaXplO1xyXG4gICAgICAgIC8vIFNvbWV0aW1lcyB0aGUgYWRhcHRlciBpc24ndCBkZXN0cm95ZWQsIGp1c3QgdGhlIHBhZ2UgY2xvc2VzLiBMaXN0ZW5cclxuICAgICAgICAvLyBmb3IgdGhhdCBhbmQgc2VuZCBtZWFzdXJlbWVudHMgdG8gdGhlIHN0YXRmYWNlLlxyXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCB0aGlzLl9vbkJlZm9yZVVubG9hZExpc3RlbmVyID0gdGhpcy5fc2VuZFN0YXRpc3RpY3NCZWZvcmVEZXN0cm95LmJpbmQodGhpcykpO1xyXG4gICAgICAgIHRoaXMuX3RpbGVMb2FkTG9ncyA9IFtdO1xyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgdGhpcy5fb25CZWZvcmVVbmxvYWRMaXN0ZW5lcik7XHJcbiAgICAgICAgdGhpcy5fc2VuZFN0YXRpc3RpY3NCZWZvcmVEZXN0cm95KCk7XHJcbiAgICAgICAgdGhpcy5lbmdpbmUucmVuZGVyZXIub25SZW5kZXIucmVtb3ZlTGlzdGVuZXIodGhpcy5fZW5naW5lUmVuZGVyTGlzdGVuZXIpO1xyXG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcclxuICAgIH1cclxuICAgIGdldFZpc2libGVUaWxlc051bWJlcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudFRpbGVzLnNpemU7XHJcbiAgICB9XHJcbiAgICBnZXRQZW5kaW5nVGlsZXNOdW1iZXIoKSB7XHJcbiAgICAgICAgbGV0IHBlbmRpbmdDb3VudGVyID0gMDtcclxuICAgICAgICB0aGlzLl9yZXF1ZXN0ZWRUaWxlcy5mb3JFYWNoKChyZXF1ZXN0ZWRUaWxlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50VGlsZXMuZ2V0KGdldFRpbGVJZChyZXF1ZXN0ZWRUaWxlLnRpbGVJdGVtKSkpIHtcclxuICAgICAgICAgICAgICAgIHBlbmRpbmdDb3VudGVyKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcGVuZGluZ0NvdW50ZXI7XHJcbiAgICB9XHJcbiAgICBfZ2V0VGFyZ2V0Wm9vbSgpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcih0aGlzLmNhbWVyYS56b29tICsgdGhpcy5fdGFyZ2V0Wm9vbVNoaWZ0KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHRpbGVJdGVtIFRoZSB0aWxlIHRvIHdoaWNoIHRoZSBkYXRhIGJlbG9uZ3MuXHJcbiAgICAgKiBAcGFyYW0gZGF0YSBEYXRhIHBvcnRpb24gdG8gYmUgc2hvd24gaW4gdGlsZSBvbmNlIGl0IGlzIHJlYWR5IHRvIHZpc3VhbGl6ZS5cclxuICAgICAqIEBwYXJhbSByZXF1ZXN0SWQgSUQgb2YgdGhlIHJlcXVlc3QgZGF0YSB3YXMgcmVxdWVzdGVkIHdpdGguIEJhc2VkIG9uIHRoaXMgdGhlIGRhdGEgaXMgYmVpbmcgZGlzcGxheWVkLCBzdG9yZWQgZm9yXHJcbiAgICAgKiBmdXR1cmUgdXNlIG9yIGRpc2NhcmRlZC5cclxuICAgICAqIEBwYXJhbSB2aXN1YWxpemUgSXMgdGhpcyBkYXRhIHBvcnRpb24gZW5vdWdoIHRvIHJlbmRlciB0aGlzIHRpbGUgYW5kIHJlcGxhY2Ugb3ZlcmxhcHBlZCBvbmVzIGlmIGFueS5cclxuICAgICAqL1xyXG4gICAgX3B1dFRpbGVEYXRhKHRpbGVJdGVtLCBkYXRhLCByZXF1ZXN0SWQgPSBOT19JRCwgdmlzdWFsaXplID0gdHJ1ZSkge1xyXG4gICAgICAgIGNvbnN0IHRpbGUgPSB0aGlzLl9hbGxUaWxlcy5nZXQoZ2V0VGlsZUlkKHRpbGVJdGVtKSk7XHJcbiAgICAgICAgaWYgKCF0aWxlKSB7XHJcbiAgICAgICAgICAgIC8vIERhdGEgcmVjaWV2ZWQgbGF0ZSBhbmQgcHJvYmFibHkgdGhlIHRpbGUgaGFkIGJlZW4gZGVzdHJveWVkLlxyXG4gICAgICAgICAgICAvLyBEZXN0cm95IGRhdGEgdG9vLlxyXG4gICAgICAgICAgICB0aGlzLl9vblRpbGVEZXN0cm95KHRpbGVJdGVtLCBbZGF0YV0pO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE5PX0lEIHBhc3NlZCBoZXJlIG1lYW5zIGNvbmNyZXRlIGFkYXB0ZXIgZG9lc24ndCBjYXJlIHRvIGxhYmVsIHRpbGUgZGF0YSB3aXRoIGEgcmVxdWVzdElkIHdoaWNoIG1vc3QgbGlrZWx5XHJcbiAgICAgICAgLy8gbWVhbnMgYWRhcHRlciBrZWVwcyBpdHMgZGF0YSBhcyBhIHdob2xlLCBub3Qgc3BsaXR0aW5nIGl0IGludG8gcG9ydGlvbnMgYW5kLCB0aGVyZWZvcmUsIGRvZXNuJ3QgbmVlZCBpdHMgZGF0YVxyXG4gICAgICAgIC8vIHRvIGJlIG1haW50YWluZWQgc2VwYXJhdGVseSBhcyB2aXNpYmxlL2FjdHVhbC4gSW4gdGhpcyBjYXNlIHRoZSBkYXRhIGlzIGFsd2F5cyB0cmVhdGVkIGxpa2UgYW4gYWN0dWFsIGRhdGEuXHJcbiAgICAgICAgaWYgKHJlcXVlc3RJZCA9PT0gdGlsZS5kYXRhLnZpc2libGVSZXF1ZXN0SWQgJiYgcmVxdWVzdElkICE9PSBOT19JRCkge1xyXG4gICAgICAgICAgICB0aWxlLmRhdGEudmlzaWJsZS5wdXNoKGRhdGEpO1xyXG4gICAgICAgICAgICBpZiAodGlsZS5pc1Zpc2libGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZSBkYXRhIGlzIGN1cnJlbnRseSBkaXNwbGF5ZWQgc28gdGhlIG5ldyBwb3J0aW9uIGlzIGFkZGVkIHRvIHRoZSBzY2VuZS5cclxuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVRpbGVEYXRhUG9ydGlvbnMoW2RhdGFdLCBbXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocmVxdWVzdElkID09PSB0aWxlLmRhdGEuYWN0dWFsUmVxdWVzdElkKSB7XHJcbiAgICAgICAgICAgIC8vIFRoZSBkYXRhIGlzIGFjdHVhbCBhbmQgZWl0aGVyIGlzIGp1c3QgYmVpbmcgcHV0IGludG8gdGhlIHRpbGUgb3IgdmlzdWFsaXplcyBhbGwgYGFjdHVhbGAgdGlsZSBkYXRhLlxyXG4gICAgICAgICAgICB0aGlzLl9wdXRBY3R1YWxUaWxlRGF0YSh0aWxlLCBkYXRhLCB2aXN1YWxpemUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gVGhlIGRhdGEgaXMgbmVpdGhlciB2aXNpYmxlIG5vciBhY3R1YWwuIERlc3Ryb3kgZGF0YS5cclxuICAgICAgICAgICAgdGhpcy5fb25UaWxlRGVzdHJveSh0aWxlSXRlbSwgW2RhdGFdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfb25DYW1lcmFVcGRhdGUoKSB7XHJcbiAgICAgICAgY29uc3QgY2FtZXJhID0gdGhpcy5jYW1lcmE7XHJcbiAgICAgICAgY29uc3Qgem9vbSA9IHRoaXMuX2dldFRhcmdldFpvb20oKTtcclxuICAgICAgICBjb25zdCBuZXdDdXJyZW50ID0gbmV3IFNldChjb21wdXRlVmlzaWJsZVRpbGVzKGNhbWVyYS5nZXRWaXNpYmxlUmVnaW9uKCksIGNhbWVyYS5nZXRWaXNpYmxlUmVnaW9uQkJveCgpLCBjYW1lcmEub3B0aW9ucy53cmFwTW9kZVgsIGNhbWVyYS5vcHRpb25zLndyYXBNb2RlWSwgTWF0aC5tYXgoMCwgem9vbSArIHRoaXMuX3pvb21TaGlmdCkpKTtcclxuICAgICAgICAvLyB0aGlzLl9jdXJyZW50VGlsZXMgY29udGFpbnMgY3VycmVudGx5IHZpc2libGUgdGlsZXMsIG5ld0N1cnJlbnQgY29udGFpbnMgc2V0IG9mIHRpbGVzIHZpc2libGUgZnJvbSB1cGRhdGVkXHJcbiAgICAgICAgLy8gY2FtZXJhIHBvc2l0aW9uLCBjb21wYXJlIHRoZXNlIHR3byBzZXRzIGFuZCBjYWxsIHRoaXMuX29uVmlzaWJsZVRpbGVzQ2hhbmdlZCgpIGlmIHRoZXJlIGlzIGEgZGlmZmVyZW5jZS5cclxuICAgICAgICBpZiAobmV3Q3VycmVudC5zaXplICE9PSB0aGlzLl9jdXJyZW50VGlsZXMuc2l6ZSB8fFxyXG4gICAgICAgICAgICBvbmVPZkl0ZXJhYmxlKG5ld0N1cnJlbnQsICh0aWxlKSA9PiAhdGhpcy5fY3VycmVudFRpbGVzLmhhcyhnZXRUaWxlSWQodGlsZSkpKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9vblZpc2libGVUaWxlc0NoYW5nZWQobmV3Q3VycmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHRoaXMgY2hlY2tzIHByZXZlbnRzIGxlYWtzIG9mIHRpbGVzIHdoZW4gcXVpY2sgem9vbS1pbi96b29tLW91dCBoYXBwZW5zXHJcbiAgICAgICAgZm9yIChjb25zdCB0aWxlIG9mIHRoaXMuX2N1cnJlbnRUaWxlcy52YWx1ZXMoKSkge1xyXG4gICAgICAgICAgICBpZiAodGlsZS5pc1JlYWR5VG9WaXN1YWxpemUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrVGlsZVJlcGxhY2VtZW50cyh0aWxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9vblRpbGVzUmVxdWVzdChyZXF1ZXN0cywgcmVxdWVzdElkID0gTk9fSUQpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IHRpbGVSZXF1ZXN0IG9mIHJlcXVlc3RzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RlZFRpbGVEYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgaW5mbzoge1xyXG4gICAgICAgICAgICAgICAgICAgIHByaW9yaXR5OiB0aWxlUmVxdWVzdC5wcmlvcml0eVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGxvYWRUaW1lc3RhbXBzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcXVldWVkOiBwZXJmb3JtYW5jZS5ub3coKSxcclxuICAgICAgICAgICAgICAgICAgICBsb2FkZWQ6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZWQ6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVhZHk6IDBcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB0aWxlSXRlbTogdGlsZVJlcXVlc3RcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3QgdGlsZUlkID0gZ2V0VGlsZUlkKHRpbGVSZXF1ZXN0KTtcclxuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdGVkVGlsZXMuc2V0KHRpbGVJZCwgcmVxdWVzdGVkVGlsZURhdGEpO1xyXG4gICAgICAgICAgICB0aGlzLl9yZWFkeVRpbGVzQ2hhbmdlID0gdHJ1ZTtcclxuICAgICAgICAgICAgY29uc3QgdGlsZSA9IHRoaXMuX2FsbFRpbGVzLmdldCh0aWxlSWQpO1xyXG4gICAgICAgICAgICBpZiAodGlsZSkge1xyXG4gICAgICAgICAgICAgICAgdGlsZS5kYXRhLmFjdHVhbFJlcXVlc3RJZCA9IHJlcXVlc3RJZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9vbkNhbmNlbFRpbGVSZXF1ZXN0cyhyZXF1ZXN0cykge1xyXG4gICAgICAgIGZvciAoY29uc3QgcmVxdWVzdCBvZiByZXF1ZXN0cykge1xyXG4gICAgICAgICAgICBjb25zdCB0aWxlSWQgPSBnZXRUaWxlSWQocmVxdWVzdC50aWxlKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3JlcXVlc3RlZFRpbGVzLmRlbGV0ZSh0aWxlSWQpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWFkeVRpbGVzQ2hhbmdlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RpbGVzVG9SZWZyZXNoLmRlbGV0ZSh0aWxlSWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX29uVGlsZUVycm9yKHRpbGVJdGVtKSB7XHJcbiAgICAgICAgY29uc3QgdGlsZUlkID0gZ2V0VGlsZUlkKHRpbGVJdGVtKTtcclxuICAgICAgICBpZiAodGhpcy5fcmVxdWVzdGVkVGlsZXMuZGVsZXRlKHRpbGVJZCkpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVhZHlUaWxlc0NoYW5nZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX3RpbGVzVG9SZWZyZXNoLmRlbGV0ZSh0aWxlSWQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgd2hlcmUgdGhlIHdob2xlIG1hZ2ljIGhhcHBlbnMsIGl0IG1hbmFnZXMgcmVwbGFjZW1lbnQgb2YgY3VycmVudCBzZXQgb2YgdmlzaWJsZS9wcmVsb2FkZWQgdGlsZXNcclxuICAgICAqIHdpdGggYSBuZXcgb25lLlxyXG4gICAgICovXHJcbiAgICBfb25WaXNpYmxlVGlsZXNDaGFuZ2VkKHZpc2libGVUaWxlcykge1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRUaWxlcy5jbGVhcigpO1xyXG4gICAgICAgIGNvbnN0IHRpbGVzVG9SZXF1ZXN0ID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCB0aWxlSXRlbSBvZiB2aXNpYmxlVGlsZXMpIHtcclxuICAgICAgICAgICAgbGV0IHRpbGUgPSB0aGlzLl9hbGxUaWxlcy5nZXQoZ2V0VGlsZUlkKHRpbGVJdGVtKSk7XHJcbiAgICAgICAgICAgIGlmICghdGlsZSkge1xyXG4gICAgICAgICAgICAgICAgdGlsZSA9IG5ldyBUaWxlKHRpbGVJdGVtKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FsbFRpbGVzLnNldCh0aWxlLmlkLCB0aWxlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRUaWxlcy5zZXQodGlsZS5pZCwgdGlsZSk7XHJcbiAgICAgICAgICAgICAgICB0aWxlc1RvUmVxdWVzdC5wdXNoKHRoaXMuX2NyZWF0ZVRpbGVSZXF1ZXN0KHRpbGVJdGVtLCB0aGlzLl9nZXRUaWxlUHJpb3JpdHkodGlsZS50aWxlSXRlbSwgdHJ1ZSkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRUaWxlcy5zZXQodGlsZS5pZCwgdGlsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRpbGVzVG9SZXF1ZXN0Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdFRpbGVzKHRpbGVzVG9SZXF1ZXN0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYmVsdFRpbGVzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIGZvciAoY29uc3QgYmVsdFRpbGVJdGVtIG9mIGNhbGN1bGF0ZUJlbHRUaWxlcyh2aXNpYmxlVGlsZXMsIHRoaXMuX2JlbHRTaXplLCB0aGlzLmNhbWVyYS5vcHRpb25zLndyYXBNb2RlWCA9PT0gMiAvKiBSRVBFQVQgKi8sIHRoaXMuY2FtZXJhLm9wdGlvbnMud3JhcE1vZGVZID09PSAyIC8qIFJFUEVBVCAqLykpIHtcclxuICAgICAgICAgICAgYmVsdFRpbGVzLnNldChnZXRUaWxlSWQoYmVsdFRpbGVJdGVtKSwgYmVsdFRpbGVJdGVtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYmVsdFRpbGVzVG9SZXF1ZXN0ID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBiZWx0VGlsZUl0ZW0gb2YgYmVsdFRpbGVzLnZhbHVlcygpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRpbGVJZCA9IGdldFRpbGVJZChiZWx0VGlsZUl0ZW0pO1xyXG4gICAgICAgICAgICBsZXQgdGlsZSA9IHRoaXMuX2FsbFRpbGVzLmdldCh0aWxlSWQpO1xyXG4gICAgICAgICAgICBpZiAoIXRpbGUpIHtcclxuICAgICAgICAgICAgICAgIHRpbGUgPSBuZXcgVGlsZShiZWx0VGlsZUl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWxsVGlsZXMuc2V0KHRpbGVJZCwgdGlsZSk7XHJcbiAgICAgICAgICAgICAgICBiZWx0VGlsZXNUb1JlcXVlc3QucHVzaCh0aGlzLl9jcmVhdGVUaWxlUmVxdWVzdChiZWx0VGlsZUl0ZW0sIHRoaXMuX2dldFRpbGVQcmlvcml0eShiZWx0VGlsZUl0ZW0sIGZhbHNlKSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChiZWx0VGlsZXNUb1JlcXVlc3QubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RUaWxlcyhiZWx0VGlsZXNUb1JlcXVlc3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBicm9rZSBjdXJyZW50IHJlbGF0aW9uc2hpcHMgdG8gc2V0IHRoZW0gdXAgYWdhaW4gYnV0IHdpdGggbmV3IHNldCBvZiB2aXNpYmxlIHRpbGVzXHJcbiAgICAgICAgZm9yIChjb25zdCB0aWxlIG9mIHRoaXMuX2FsbFRpbGVzLnZhbHVlcygpKSB7XHJcbiAgICAgICAgICAgIHRpbGUudG9CZVJlcGxhY2VkQnkuY2xlYXIoKTtcclxuICAgICAgICAgICAgdGlsZS5yZXBsYWNlbWVudEZvci5jbGVhcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUT0RPOiBvcHRpbWl6ZSB0aGlzIG5eMiByZWxhdGlvbnNoaXBzIHJlc29sdmVyXHJcbiAgICAgICAgZm9yIChjb25zdCBjdXJyZW50VGlsZSBvZiB0aGlzLl9jdXJyZW50VGlsZXMudmFsdWVzKCkpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCB0aWxlIG9mIHRoaXMuX2FsbFRpbGVzLnZhbHVlcygpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGlsZS5pc1JlYWR5VG9WaXN1YWxpemUgJiZcclxuICAgICAgICAgICAgICAgICAgICAoaXNQYXJlbnQodGlsZS50aWxlSXRlbSwgY3VycmVudFRpbGUudGlsZUl0ZW0pIHx8IGlzUGFyZW50KGN1cnJlbnRUaWxlLnRpbGVJdGVtLCB0aWxlLnRpbGVJdGVtKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aWxlLnRvQmVSZXBsYWNlZEJ5LmFkZChjdXJyZW50VGlsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRpbGUucmVwbGFjZW1lbnRGb3IuYWRkKHRpbGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHJlbW92ZSBpbnZpc2libGVcclxuICAgICAgICBjb25zdCB0aWxlc1RvQ2FuY2VsID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCB0aWxlIG9mIHRoaXMuX2FsbFRpbGVzLnZhbHVlcygpKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fY3VycmVudFRpbGVzLmhhcyh0aWxlLmlkKSAmJiB0aWxlLnRvQmVSZXBsYWNlZEJ5LnNpemUgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aWxlLmlzVmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVRpbGVEYXRhKE5PX1RJTEVTX1RPX0hBTkRMRSwgW3RpbGVdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghYmVsdFRpbGVzLmdldCh0aWxlLmlkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3lUaWxlKHRpbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRpbGVzVG9DYW5jZWwucHVzaCh0aWxlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGlsZXNUb0NhbmNlbC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgLy8gaXNzdWUgY2FuY2VsbGF0aW9uIGFsc28gaW4gY2FzZSB0aGVyZSBhcmUgbm9uIHByb2Nlc3NlZCBkYXRhIGVucXVldWVkIHRvIHRyeSB0byBzYXZlIHNvbWUgZWZmb3J0c1xyXG4gICAgICAgICAgICB0aGlzLl9jYW5jZWxUaWxlUmVxdWVzdHModGlsZXNUb0NhbmNlbGF0aW9ucyh0aWxlc1RvQ2FuY2VsKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3JlZnJlc2hDdXJyZW50VGlsZXMoKSB7XHJcbiAgICAgICAgY29uc3QgdGlsZXNUb1JlcXVlc3QgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IHRpbGUgb2YgdGhpcy5fY3VycmVudFRpbGVzLnZhbHVlcygpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRpbGVJdGVtID0gdGlsZS50aWxlSXRlbTtcclxuICAgICAgICAgICAgY29uc3QgdGlsZVJlcXVlc3QgPSB0aGlzLl9jcmVhdGVUaWxlUmVxdWVzdCh0aWxlSXRlbSwgdGhpcy5fZ2V0VGlsZVByaW9yaXR5KHRpbGUudGlsZUl0ZW0sIHRydWUpKTtcclxuICAgICAgICAgICAgdGlsZXNUb1JlcXVlc3QucHVzaCh0aWxlUmVxdWVzdCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3RpbGVzVG9SZWZyZXNoLmFkZChnZXRUaWxlSWQodGlsZS50aWxlSXRlbSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9jYW5jZWxUaWxlUmVxdWVzdHModGlsZXNUb0NhbmNlbGF0aW9ucyh0aGlzLl9jdXJyZW50VGlsZXMudmFsdWVzKCkpKTtcclxuICAgICAgICB0aGlzLl9yZXF1ZXN0VGlsZXModGlsZXNUb1JlcXVlc3QpO1xyXG4gICAgfVxyXG4gICAgX29uVGlsZURhdGFSZWFkeSh0aWxlSXRlbSwgdXJsKSB7XHJcbiAgICAgICAgY29uc3QgdGlsZUlkID0gZ2V0VGlsZUlkKHRpbGVJdGVtKTtcclxuICAgICAgICBjb25zdCB0aWxlRGF0YSA9IHRoaXMuX3JlcXVlc3RlZFRpbGVzLmdldCh0aWxlSWQpO1xyXG4gICAgICAgIHRoaXMuX3JlcXVlc3RlZFRpbGVzLmRlbGV0ZSh0aWxlSWQpO1xyXG4gICAgICAgIHRoaXMuX3RpbGVzVG9SZWZyZXNoLmRlbGV0ZSh0aWxlSWQpO1xyXG4gICAgICAgIHRpbGVEYXRhLmluZm8udXJsID0gdXJsO1xyXG4gICAgICAgIHRpbGVEYXRhLmxvYWRUaW1lc3RhbXBzLmxvYWRlZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgICAgIGlmICh0aGlzLl90aWxlTG9hZExvZ3MubGVuZ3RoIDwgTUFYX1BFUkZfTE9HX0lURU1TX0NPVU5UKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RpbGVMb2FkTG9ncy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIHRpbGVJdGVtLFxyXG4gICAgICAgICAgICAgICAgcHJvY2Vzc2luZ1RpbWU6IHRpbGVEYXRhLmxvYWRUaW1lc3RhbXBzLmxvYWRlZCAtIHRpbGVEYXRhLmxvYWRUaW1lc3RhbXBzLnF1ZXVlZFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcmVhZHlGb3JSZW5kZXJUaWxlcy5wdXNoKHRpbGVEYXRhKTtcclxuICAgICAgICBpZiAodGhpcy5fY3VycmVudFRpbGVzLmdldCh0aWxlSWQpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlYWR5VGlsZXNDaGFuZ2UgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9pc1RpbGVTdGlsbEFjdGl2ZSh0aWxlSXRlbSwgcmVxdWVzdElkID0gTk9fSUQpIHtcclxuICAgICAgICBjb25zdCB0aWxlID0gdGhpcy5fYWxsVGlsZXMuZ2V0KGdldFRpbGVJZCh0aWxlSXRlbSkpO1xyXG4gICAgICAgIGlmICghdGlsZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGlzUmVxdWVzdEFjdGl2ZSA9IHRpbGUuZGF0YS5hY3R1YWxSZXF1ZXN0SWQgPT09IHJlcXVlc3RJZCB8fCB0aWxlLmRhdGEudmlzaWJsZVJlcXVlc3RJZCA9PT0gcmVxdWVzdElkO1xyXG4gICAgICAgIHJldHVybiBpc1JlcXVlc3RBY3RpdmU7XHJcbiAgICB9XHJcbiAgICBfaXNUaWxlUmVmcmVzaGluZyh0aWxlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RpbGVzVG9SZWZyZXNoLmhhcyhnZXRUaWxlSWQodGlsZSkpO1xyXG4gICAgfVxyXG4gICAgX2dldFRpbGVQcmlvcml0eSh0aWxlLCBpc1Zpc2libGUpIHtcclxuICAgICAgICBjb25zdCBjZW50ZXIgPSB0aGlzLl9jcmVhdGVUaWxlQ29vcmRpbmF0ZVN5c3RlbSgpLnRvVGlsZUNvb3JkaW5hdGVzKHRoaXMuY2FtZXJhLmNlbnRlcik7XHJcbiAgICAgICAgY29uc3Qgem9vbURpZmYgPSBNYXRoLmNlaWwodGhpcy5jYW1lcmEuem9vbSkgLSB0aWxlLnpvb207XHJcbiAgICAgICAgY29uc3QgZGlzdGFuY2UgPSB2ZWMyLmRpc3RhbmNlKHRpbGUsIHtcclxuICAgICAgICAgICAgeDogTWF0aC5mbG9vcihjZW50ZXIueCAvIE1hdGgucG93KDIsIHpvb21EaWZmKSksXHJcbiAgICAgICAgICAgIHk6IE1hdGguZmxvb3IoY2VudGVyLnkgLyBNYXRoLnBvdygyLCB6b29tRGlmZikpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIChpc1Zpc2libGUgPyBWSVNJQkxFX1RJTEVfUFJJT1JJVFkgOiAwKSArIDEgLyAoZGlzdGFuY2UgKyAxKTtcclxuICAgIH1cclxuICAgIF9zZW5kU3RhdGlzdGljc0JlZm9yZURlc3Ryb3koKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3RpbGVMb2FkTG9ncy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBhY2N1bXVsYXRlZFRpbWluZ3MgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgYWNjdW11bGF0ZWRUaW1pbmdzLnNldCgnYXZlcmFnZScsIHtcclxuICAgICAgICAgICAgc3VtOiAwLFxyXG4gICAgICAgICAgICBudW1iZXI6IDBcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl90aWxlTG9hZExvZ3MuZm9yRWFjaCgobG9nSXRlbSkgPT4ge1xyXG4gICAgICAgICAgICBhY2N1bXVsYXRlZFRpbWluZ3MuZ2V0KCdhdmVyYWdlJykuc3VtICs9IGxvZ0l0ZW0ucHJvY2Vzc2luZ1RpbWU7XHJcbiAgICAgICAgICAgIGFjY3VtdWxhdGVkVGltaW5ncy5nZXQoJ2F2ZXJhZ2UnKS5udW1iZXIrKztcclxuICAgICAgICAgICAgY29uc3Qgem9vbSA9IGxvZ0l0ZW0udGlsZUl0ZW0uem9vbS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBpZiAoIWFjY3VtdWxhdGVkVGltaW5ncy5oYXMoem9vbSkpIHtcclxuICAgICAgICAgICAgICAgIGFjY3VtdWxhdGVkVGltaW5ncy5zZXQoem9vbSwge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1bTogMCxcclxuICAgICAgICAgICAgICAgICAgICBudW1iZXI6IDBcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFjY3VtdWxhdGVkVGltaW5ncy5nZXQoem9vbSkuc3VtICs9IGxvZ0l0ZW0ucHJvY2Vzc2luZ1RpbWU7XHJcbiAgICAgICAgICAgIGFjY3VtdWxhdGVkVGltaW5ncy5nZXQoem9vbSkubnVtYmVyKys7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGFjY3VtdWxhdGVkVGltaW5ncykge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB6b29tOiBpdGVtWzBdLFxyXG4gICAgICAgICAgICAgICAgdGltZTogKGl0ZW1bMV0uc3VtIC8gaXRlbVsxXS5udW1iZXIpXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb3VudFRpbGVQcm9jZXNzaW5nVGltZSh0aGlzLl9sYXllck5hbWUsIHJlc3VsdCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFB1dHMgYWN0dWFsIGRhdGEgaW50byB0aGUgdGlsZSBhbmQgb3B0aW9uYWxseSB2aXN1YWxpemVzIGl0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0aWxlIFRpbGUgdG8gcHV0IGRhdGEgaW50by5cclxuICAgICAqIEBwYXJhbSBkYXRhIERhdGEgdG8gYmUgc3RvcmVkIGluIHRoZSB0aWxlIHVudGlsIHZpc3VhbGl6YXRpb24uXHJcbiAgICAgKiBAcGFyYW0gdmlzdWFsaXplIElmIGB0cnVlYCByZXBsYWNlcyBgdmlzaWJsZWAgdGlsZSBkYXRhIHdpdGggYGFjdHVhbGAgdGlsZSBkYXRhIGFuZCB1cGRhdGVzIHRoZSBzY2VuZS5cclxuICAgICAqL1xyXG4gICAgX3B1dEFjdHVhbFRpbGVEYXRhKHRpbGUsIGRhdGEsIHZpc3VhbGl6ZSkge1xyXG4gICAgICAgIHRpbGUuZGF0YS5hY3R1YWwucHVzaChkYXRhKTtcclxuICAgICAgICBpZiAodmlzdWFsaXplKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Zpc3VhbGl6ZVRpbGUodGlsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBWaXN1YWxpemVzIHRpbGUgYGFjdHVhbGAgZGF0YTogcmVwbGFjZXMgdGlsZSBgdmlzaWJsZWAgZGF0YSB3aXRoIHRpbGUgYGFjdHVhbGAgZGF0YSwgYWRkcyBpdCB0byB0aGUgc2NlbmUsXHJcbiAgICAgKiByZW1vdmVzIG9sZCB2aXNpYmxlIGRhdGEgZnJvbSB0aGUgc2NlbmUgYW5kIGRlc3Ryb3lzIGl0LCBjaGVja3MgdGlsZSByZXBsYWNlbWVudHMgYW5kIHVwZGF0ZXMgYHZpc2libGVSZXF1ZXN0SWRgLlxyXG4gICAgICogQHBhcmFtIHRpbGUgVGlsZSB0byB2aXN1YWxpemUuXHJcbiAgICAgKi9cclxuICAgIF92aXN1YWxpemVUaWxlKHRpbGUpIHtcclxuICAgICAgICBjb25zdCB0b0Rlc3Ryb3kgPSB0aWxlLmRhdGEudmlzaWJsZTtcclxuICAgICAgICB0aWxlLmRhdGEudmlzaWJsZSA9IHRpbGUuZGF0YS5hY3R1YWw7XHJcbiAgICAgICAgdGlsZS5kYXRhLmFjdHVhbCA9IFtdO1xyXG4gICAgICAgIHRpbGUuZGF0YS52aXNpYmxlUmVxdWVzdElkID0gdGlsZS5kYXRhLmFjdHVhbFJlcXVlc3RJZDtcclxuICAgICAgICBpZiAoIXRpbGUuaXNSZWFkeVRvVmlzdWFsaXplKSB7XHJcbiAgICAgICAgICAgIHRpbGUuaXNSZWFkeVRvVmlzdWFsaXplID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5fY2hlY2tUaWxlUmVwbGFjZW1lbnRzKHRpbGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aWxlLmlzVmlzaWJsZSkge1xyXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVUaWxlRGF0YVBvcnRpb25zKHRpbGUuZGF0YS52aXNpYmxlLCBbXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0b0Rlc3Ryb3kubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVUaWxlRGF0YVBvcnRpb25zKFtdLCB0b0Rlc3Ryb3kpO1xyXG4gICAgICAgICAgICB0aGlzLl9vblRpbGVEZXN0cm95KHRpbGUudGlsZUl0ZW0sIHRvRGVzdHJveSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2NyZWF0ZVRpbGVDb29yZGluYXRlU3lzdGVtKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVGlsZUNvb3JkaW5hdGVTeXN0ZW0odGhpcy5jYW1lcmEuem9vbSk7XHJcbiAgICB9XHJcbiAgICAvLyBXZSBuZWVkIGRvIGRldGVjdCB3aGVuIHRpbGUgaXMgcmVuZGVyZWQgdG8gY29sbGVjdCBwZXJmb21hbmNlIG1ldHJpY3MuXHJcbiAgICAvLyBXZSBleHBlY3QgdGhhdCB0aWxlIHdpbGwgYmUgcmVuZGVyZWQgd2l0aCBmaXJzdCByZW5kZXIgZXZlbnQgYWZ0ZXJcclxuICAgIC8vIHRpbGUgZGF0YSBpcyBhZGRlZCB0byBzY2VuZS5cclxuICAgIF9vbkVuZ2luZVJlbmRlckV2ZW50KCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9yZWFkeUZvclJlbmRlclRpbGVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZWFkeUZvclJlbmRlclRpbGVzLmZvckVhY2goKHRpbGVEYXRhKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY3VycmVudFRpbGVzLmhhcyhnZXRUaWxlSWQodGlsZURhdGEudGlsZUl0ZW0pKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRpbGVEYXRhLmxvYWRUaW1lc3RhbXBzLnJlbmRlcmVkID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGlsZURhdGEubG9hZFRpbWVzdGFtcHMucmVhZHkgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uVGlsZVJlYWR5LmZpcmUodGlsZURhdGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5fcmVhZHlGb3JSZW5kZXJUaWxlcy5sZW5ndGggPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fcmVhZHlUaWxlc0NoYW5nZSkge1xyXG4gICAgICAgICAgICB0aGlzLm9uVGlsZUxvYWRDaGFuZ2UuZmlyZSh7XHJcbiAgICAgICAgICAgICAgICB0b3RhbFRpbGVOdW1iZXI6IHRoaXMuZ2V0VmlzaWJsZVRpbGVzTnVtYmVyKCksXHJcbiAgICAgICAgICAgICAgICByZWFkeVRpbGVOdW1iZXI6IHRoaXMuZ2V0VmlzaWJsZVRpbGVzTnVtYmVyKCkgLSB0aGlzLmdldFBlbmRpbmdUaWxlc051bWJlcigpXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLl9yZWFkeVRpbGVzQ2hhbmdlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTaG93cy9oaWRlcyB0aWxlcyBpZiB0aGV5IGFyZSBub3Qgc2hvd24vaGlkZGVuIHlldC4gSXQgbm90aWZpZXMgc3ViY2xhc3NlcyBieSBjYWxsaW5nIGFwcHJvcHJpYXRlXHJcbiAgICAgKiBhYnN0cmFjdCBtZXRob2QuIEV2ZW4gdGhvdWdoIHZpc2libGUvaW52aXNpYmxlIHRpbGVzIGFyZSBub3Qgc3VwcG9zZWQgdG8gYmUgc2hvd24vaGlkZGVuIGFnYWluLFxyXG4gICAgICogdGhlcmUgYXJlIGNhc2VzIHdoZXJlIGl0IHNpbXBsaWZpZXMgdGlsZSB2aXN1YWxpemF0aW9uIGxvZ2ljLlxyXG4gICAgICogSXQgaXMgaW1wb3J0YW50IHRvIGhhdmUgZXhhY3RseSBcInVwZGF0ZVwiLCBub3QgXCJhZGRcIi9cInJlbW92ZVwiIHNlcGFyYXRlbHksIGFzIHNvbWUgYnVzaW5lc3MgbG9naWMgbWF5IHJlbHkgb24gaXQsXHJcbiAgICAgKiBlLmcuIG1vcnBoaW5nIHZpc2libGUgZGF0YSBvciBtYW5hZ2luZyBzaGFyZWQgcmVzb3VyY2VzLlxyXG4gICAgICovXHJcbiAgICBfdXBkYXRlVGlsZURhdGEodG9TaG93LCB0b1JlbW92ZSkge1xyXG4gICAgICAgIGNvbnN0IGRhdGFUb1Nob3cgPSBBcnJheS5mcm9tKGZsYXR0ZW5WaXNpYmxlRGF0YVBvcnRpb25zKHRvU2hvdykpO1xyXG4gICAgICAgIGNvbnN0IGRhdGFUb1JlbW92ZSA9IEFycmF5LmZyb20oZmxhdHRlblZpc2libGVEYXRhUG9ydGlvbnModG9SZW1vdmUpKTtcclxuICAgICAgICB0aGlzLl91cGRhdGVUaWxlRGF0YVBvcnRpb25zKGRhdGFUb1Nob3csIGRhdGFUb1JlbW92ZSk7XHJcbiAgICAgICAgZm9yIChjb25zdCB0aWxlIG9mIHRvU2hvdykge1xyXG4gICAgICAgICAgICB0aWxlLmlzVmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3QgdGlsZSBvZiB0b1JlbW92ZSkge1xyXG4gICAgICAgICAgICB0aWxlLmlzVmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF91cGRhdGVUaWxlRGF0YVBvcnRpb25zKHRvU2hvdywgdG9SZW1vdmUpIHtcclxuICAgICAgICB0aGlzLl9vblRpbGVEYXRhVXBkYXRlKHRvU2hvdywgdG9SZW1vdmUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIHRpbGUgaWYgaXMgbm90IHJlbW92ZWQgd2l0aCBjYWxsaW5nIGFsbCBhcHByb3ByaWF0ZSBjYWxsYmFja3MgKGFic3RyYWN0IG1ldGhvZHMpXHJcbiAgICAgKiB0byBub3RpZnkgZGVzY2VuZGFudCBjbGFzc2VzLiBFdmVuIHRob3VnaCByZW1vdmVkIHRpbGUgaXMgbm90IHN1cHBvc2VkIHRvIGJlIHJlbW92ZWQgYWdhaW4sXHJcbiAgICAgKiBhbGxvd2luZyB0aGlzIG1ha2VzIG11Y2ggc2ltcGxlciB0aWxlIG1hbmFnZW1lbnQsIGVzcGVjaWFsbHkgaW4gdGlsZSByZXBsYWNlbWVudHMgbG9naWMgd2hlcmUgbXVsdGlwbGVcclxuICAgICAqIHRpbGVzIGNhbiBoYXZlIGxpbmtzIHRvIHRoZSBzYW1lIHRpbGUgKHRoYXQgaXMgdG8gYmUgcmVtb3ZlZCkuXHJcbiAgICAgKi9cclxuICAgIF9kZXN0cm95VGlsZSh0aWxlKSB7XHJcbiAgICAgICAgaWYgKCF0aWxlLmlzUmVtb3ZlZCkge1xyXG4gICAgICAgICAgICB0aWxlLmlzUmVtb3ZlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX2FsbFRpbGVzLmRlbGV0ZSh0aWxlLmlkKTtcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudFRpbGVzLmRlbGV0ZSh0aWxlLmlkKTtcclxuICAgICAgICAgICAgdGhpcy5fb25UaWxlRGVzdHJveSh0aWxlLnRpbGVJdGVtLCBbLi4udGlsZS5kYXRhLmFjdHVhbCwgLi4udGlsZS5kYXRhLnZpc2libGVdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB0aWxlcyB0aGF0IGNvdWxkIGJlIHJlcGxhY2VkIGJ5IHRoaXMgb25lLCBzaG91bGQgYmUgY2FsbGVkIHdoZW4gdGlsZSBiZWNvbWVzIHJlYWR5IHRvIHZpc3VhbGl6ZS5cclxuICAgICAqIEFzIG92ZXJsYXBwaW5nIHJlbGF0aW9uc2hpcHMgY2FuIGhhcHBlbiBpbiBib3RoIGRpcmVjdGlvbnMgKGNoaWxkcmVuIGJ5IHBhcmVudHMgLyBwYXJlbnQgYnkgY2hpbGRyZW4pIHRoaXNcclxuICAgICAqIG1ldGhvZCBnb2VzIG9uZSBzdGVwIGRlZXBlciwgaS5lLiBpdCBjaGVjayBub3Qgb25seSB0aWxlcyB0aGF0IHNob3VsZCBiZSByZXBsYWNlZCAodG8gcmVtb3ZlIHRoZW0pLFxyXG4gICAgICogYnV0IGFsc28gYWxsIHRpbGVzIHRoYXQgY292ZXIgdGhlIHJlcGxhY2VkIG9uZXMgKHRvIHNob3cgdGhlbSkuXHJcbiAgICAgKi9cclxuICAgIF9jaGVja1RpbGVSZXBsYWNlbWVudHModGlsZSkge1xyXG4gICAgICAgIGNvbnN0IHRvRGVzdHJveSA9IG5ldyBTZXQoKTtcclxuICAgICAgICBjb25zdCB0b1Nob3cgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgY29uc3QgdG9IaWRlID0gbmV3IFNldCgpO1xyXG4gICAgICAgIGZvciAoY29uc3QgdGlsZVRvUmVwbGFjZSBvZiB0aWxlLnJlcGxhY2VtZW50Rm9yKSB7XHJcbiAgICAgICAgICAgIGlmIChhbGxPZkl0ZXJhYmxlKHRpbGVUb1JlcGxhY2UudG9CZVJlcGxhY2VkQnksICh0aWxlKSA9PiB0aWxlLmlzUmVhZHlUb1Zpc3VhbGl6ZSkpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aWxlVG9SZXBsYWNlLmlzVmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvSGlkZS5hZGQodGlsZVRvUmVwbGFjZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRpbGVUb1JlcGxhY2UuaXNSZW1vdmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9EZXN0cm95LmFkZCh0aWxlVG9SZXBsYWNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdGlsZVRvU2hvdyBvZiB0aWxlVG9SZXBsYWNlLnRvQmVSZXBsYWNlZEJ5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aWxlVG9TaG93LmlzVmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b1Nob3cuYWRkKHRpbGVUb1Nob3cpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGlsZS5yZXBsYWNlbWVudEZvci5zaXplID09PSAwICYmICF0aWxlLmlzVmlzaWJsZSkge1xyXG4gICAgICAgICAgICB0b1Nob3cuYWRkKHRpbGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodG9TaG93LnNpemUgPiAwIHx8IHRvSGlkZS5zaXplID4gMCkge1xyXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVUaWxlRGF0YSh0b1Nob3csIHRvSGlkZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3QgdGlsZVRvRGVzdHJveSBvZiB0b0Rlc3Ryb3kpIHtcclxuICAgICAgICAgICAgdGhpcy5fZGVzdHJveVRpbGUodGlsZVRvRGVzdHJveSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0b0Rlc3Ryb3kuc2l6ZSA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5fY2FuY2VsVGlsZVJlcXVlc3RzKHRpbGVzVG9DYW5jZWxhdGlvbnModG9EZXN0cm95KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUaGlzIGNsYXNzIGlzIHRoZSBtYWluIHVuaXQgb2YgdGhlIHdob2xlIHByb2Nlc3Mgb2YgdGlsZSBtYW5hZ2VtZW50LiBJdCBzdG9yZXMgdmlzdWFsaXphYmxlIGRhdGEgYW5kIGxpbmtzIHRvXHJcbiAqIGRlcGVuZGFudCB0aWxlcyAoZm9yIHBhcmVudC9jaGlsZCBvdmVybGFwcGluZyBjYXNlcykuXHJcbiAqL1xyXG5jbGFzcyBUaWxlIHtcclxuICAgIGNvbnN0cnVjdG9yKHRpbGVJdGVtKSB7XHJcbiAgICAgICAgdGhpcy5kYXRhID0ge1xyXG4gICAgICAgICAgICBhY3R1YWw6IFtdLFxyXG4gICAgICAgICAgICB2aXNpYmxlOiBbXSxcclxuICAgICAgICAgICAgYWN0dWFsUmVxdWVzdElkOiBOT19JRCxcclxuICAgICAgICAgICAgdmlzaWJsZVJlcXVlc3RJZDogTk9fSURcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMudGlsZUl0ZW0gPSB0aWxlSXRlbTtcclxuICAgICAgICB0aGlzLmlkID0gYCR7dGlsZUl0ZW0ueH06JHt0aWxlSXRlbS55fToke3RpbGVJdGVtLnpvb219YDtcclxuICAgICAgICB0aGlzLmlzUmVhZHlUb1Zpc3VhbGl6ZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaXNWaXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pc1JlbW92ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnRvQmVSZXBsYWNlZEJ5ID0gbmV3IFNldCgpO1xyXG4gICAgICAgIHRoaXMucmVwbGFjZW1lbnRGb3IgPSBuZXcgU2V0KCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gdGlsZXNUb0NhbmNlbGF0aW9ucyh0aWxlcykge1xyXG4gICAgcmV0dXJuIEFycmF5LmZyb20odGlsZXMsICh0aWxlKSA9PiAoe1xyXG4gICAgICAgIHRpbGU6IHRpbGUudGlsZUl0ZW0sXHJcbiAgICAgICAgcmVxdWVzdElkOiB0aWxlLmRhdGEuYWN0dWFsUmVxdWVzdElkXHJcbiAgICB9KSk7XHJcbn1cclxuIiwiaW1wb3J0IHsgZGVib3VuY2UgfSBmcm9tICcuLi91dGlsL2Z1bmN0aW9uJztcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQWRhcHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihlbmdpbmUsIGNhbWVyYSwgY2FtZXJhVXBkYXRlRGVsYXkgPSA1KSB7XHJcbiAgICAgICAgdGhpcy5lbmdpbmUgPSBlbmdpbmU7XHJcbiAgICAgICAgdGhpcy5jYW1lcmEgPSBjYW1lcmE7XHJcbiAgICAgICAgdGhpcy5fY2FtZXJhVXBkYXRlTGlzdGVuZXIgPSBkZWJvdW5jZSh0aGlzLl9vbkNhbWVyYVVwZGF0ZS5iaW5kKHRoaXMpLCBjYW1lcmFVcGRhdGVEZWxheSk7XHJcbiAgICAgICAgY2FtZXJhLm9uVXBkYXRlLmFkZExpc3RlbmVyKHRoaXMuX2NhbWVyYVVwZGF0ZUxpc3RlbmVyKTtcclxuICAgIH1cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5jYW1lcmEub25VcGRhdGUucmVtb3ZlTGlzdGVuZXIodGhpcy5fY2FtZXJhVXBkYXRlTGlzdGVuZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYW1lcmEgdXBkYXRlIGhhbmRsZXIsIGJ5IGRlZmF1bHQgZG8gbm90aGluZy5cclxuICAgICAqL1xyXG4gICAgX29uQ2FtZXJhVXBkYXRlKCkgeyB9XHJcbn1cclxuIiwiLyoqXHJcbiAqIENyZWF0ZXMgbmV3IGZ1bmN0aW9uIHdoaWNoIGV4ZWN1dGlvbiBpcyBcImRlYm91bmNlZFwiLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQpIHtcclxuICAgIGxldCB0aW1lb3V0ID0gMDtcclxuICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xyXG4gICAgICAgIGNvbnN0IGxhdGVyID0gKCkgPT4ge1xyXG4gICAgICAgICAgICB0aW1lb3V0ID0gMDtcclxuICAgICAgICAgICAgZnVuYyguLi5hcmdzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICh0aW1lb3V0KSB7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xyXG4gICAgfTtcclxufVxyXG4iLCJpbXBvcnQgeyBjbGFtcCB9IGZyb20gJy4uLy4uLy4uL21hdGgvc2NhbGFyJztcclxuLyoqXHJcbiAqIEByZXR1cm4gYHRydWVgIGlmIHRoZSBmaXJzdCBwYXJhbSBvdmVybGFwcyB0aGUgc2Vjb25kIGluIHRpbGUgaGllcmFyY2h5LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzUGFyZW50KHBvdGVudGlhbFBhcmVudCwgcG9zc2libGVDaGlsZCkge1xyXG4gICAgY29uc3Qgem9vbURpZmYgPSBwb3NzaWJsZUNoaWxkLnpvb20gLSBwb3RlbnRpYWxQYXJlbnQuem9vbTtcclxuICAgIHJldHVybiB6b29tRGlmZiA+IDAgJiZcclxuICAgICAgICBwb3NzaWJsZUNoaWxkLnggPj4gem9vbURpZmYgPT09IHBvdGVudGlhbFBhcmVudC54ICYmXHJcbiAgICAgICAgcG9zc2libGVDaGlsZC55ID4+IHpvb21EaWZmID09PSBwb3RlbnRpYWxQYXJlbnQueTtcclxufVxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaWxlQ29vcmRpbmF0ZVN5c3RlbSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih6b29tKSB7XHJcbiAgICAgICAgdGhpcy5fem9vbSA9IE1hdGguY2VpbChjbGFtcCh6b29tLCAwLCAzMSkpO1xyXG4gICAgICAgIHRoaXMuX3RpbGVTaXplID0gMiAvICgxIDw8IHRoaXMuX3pvb20pO1xyXG4gICAgfVxyXG4gICAgZ2V0Wm9vbSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fem9vbTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiBUaWxlIHNpZGUgbGVuZ3RoIGluIHVuaXRzIG9mIHRoZSB3b3JsZCBjb29yZGluYXRlIHN5c3RlbS5cclxuICAgICAqL1xyXG4gICAgZ2V0VGlsZVNpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RpbGVTaXplO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIFRvcCBsZWZ0IGNvcm5lciBjb29yZGluYXRlcyBvZiB0aGUgdGlsZS5cclxuICAgICAqL1xyXG4gICAgZ2V0VGlsZU9mZnNldCh0aWxlKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgeDogdGhpcy5nZXRUaWxlU2l6ZSgpICogdGlsZS54IC0gMSxcclxuICAgICAgICAgICAgeTogMSAtIHRoaXMuZ2V0VGlsZVNpemUoKSAqIHRpbGUueVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICB0b1RpbGVDb29yZGluYXRlcyh3b3JsZENvb3JkaW5hdGVzKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgeDogKHdvcmxkQ29vcmRpbmF0ZXMueCArIDEpIC8gdGhpcy5fdGlsZVNpemUsXHJcbiAgICAgICAgICAgIHk6ICgxIC0gd29ybGRDb29yZGluYXRlcy55KSAvIHRoaXMuX3RpbGVTaXplXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG4iLCJleHBvcnQgZnVuY3Rpb24gZ2V0VGlsZUlkQnlSYXdWYWx1ZXMoeCwgeSwgem9vbSkge1xyXG4gICAgcmV0dXJuIGAke3h9OiR7eX06JHt6b29tfWA7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFRpbGVJZCh0aWxlKSB7XHJcbiAgICByZXR1cm4gZ2V0VGlsZUlkQnlSYXdWYWx1ZXModGlsZS54LCB0aWxlLnksIHRpbGUuem9vbSk7XHJcbn1cclxuIiwiLyoqXHJcbiAqIEJhc2UgaW50ZXJmYWNlIGZvciB3ZWJ3b3JrZXIgbWVzc2FnZXMsIGJvdGggaW5jb21pbmcgYW5kIG91dGdvaW5nIG9uZXMuXHJcbiAqXHJcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1RyYW5zZmVyYWJsZVxyXG4gKi9cclxuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnLi9ldmVudF9lbWl0dGVyJztcclxuaW1wb3J0IHsgdW5pcXVlSWQgfSBmcm9tICcuL3VuaXF1ZV9pZCc7XHJcbmNvbnN0IE1FU1NBR0VfQkFUQ0hfTUFYX1NJWkUgPSA1MDtcclxuY29uc3QgRkxVU0hfVElNRU9VVCA9IDUwO1xyXG4vLyBlYWNoIHN1YnNlcXVlbnQgbWVzc2FnZSBkZWJvdW5jZXMgcG9zdE1lc3NhZ2UgY2FsbCwgdGhhdCBjYW4gbGVhZCB0byBpbmZpbml0ZSBkZWxheSwgdGhpcyBjb25zdCBsaW1pdHMgaXRcclxuY29uc3QgTUFYX0ZMVVNIX1RJTUVPVVQgPSAyNTA7XHJcbmV4cG9ydCBjb25zdCBOT19JRCA9IC0xO1xyXG4vKipcclxuICogQ2hlY2tzIG1lc3NhZ2UgdHlwZSB3aXRoIHR5cGUgZ3VhcmRpbmcuIEl0IGdpdmVzIGEgbGl0dGxlIGJpdCBtb3JlIGVsZWdhbnQgYWx0ZXJuYXRpdmVcclxuICogdG8gdGFnZ2VkIHR5cGUgdW5pb25zIHByb3ZpZGluZyB0aGUgc2FtZSB0eXBlIHNhZmV0eS5cclxuICpcclxuICogQHBhcmFtIG1lc3NhZ2UgdG8gYmUgY2hlY2tlZFxyXG4gKiBAcGFyYW0gdHlwZSB0aGUgdmFsdWUgb2YgdGhlIFwidHlwZVwiIHByb3BlcnR5XHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbWVzc2FnZUlzKG1lc3NhZ2UsIHR5cGUpIHtcclxuICAgIHJldHVybiBtZXNzYWdlLnR5cGUgPT09IHR5cGU7XHJcbn1cclxuLyoqXHJcbiAqIEJhc2UgY2xhc3MgZm9yIGJvdGggc2lkZXMgb2YgYSB3ZWJ3b3JrZXI6IGl0cyBpbXBsZW1lbnRhdGlvbiAoc2VwYXJhdGUganMgdGhhdCBpcyBydW4gaW4gYSB3b3JrZXIgdGhyZWFkKSBhbmRcclxuICogYSBjb250cm9sbGVyIGZvciB0aGUgbWFpbiB0aHJlYWQuIFRoZXkgaGF2ZSBzaW1pbGFyIG1lY2hhbmlzbSBvZiBzZW5kaW5nL3JlY2VpdmluZyBtZXNzYWdlcyB0aGF0IGlzIGltcGxlbWVudCBoZXJlLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFdlYldvcmtlckNvbW11bmljYXRvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihhZGRyZXNzZWUpIHtcclxuICAgICAgICB0aGlzLl9hZGRyZXNzZWUgPSBhZGRyZXNzZWU7XHJcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLl90cmFuc2ZlcmFibGVFeHRyYWN0b3JzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuX21lc3NhZ2VzID0gW107XHJcbiAgICAgICAgdGhpcy5fdHJhbnNmZXJhYmxlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3RpbWVvdXRIYW5kbGUgPSAwO1xyXG4gICAgICAgIHRoaXMuX2ZsdXNoTWVzc2FnZXNCaW5kZWQgPSB0aGlzLl9mbHVzaE1lc3NhZ2VzLmJpbmQodGhpcyk7XHJcbiAgICB9XHJcbiAgICBzZXRUcmFuc2ZlcmFibGVFeHRyYWN0b3IodHlwZSwgZXh0cmFjdG9yKSB7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNmZXJhYmxlRXh0cmFjdG9ycy5zZXQodHlwZSwgZXh0cmFjdG9yKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2VuZCBhIG1lc3NhZ2UgdG8gdGhlIG9wcG9zaXRlIHNpZGUgb2YgdGhlIHdlYiB3b3JrZXIgY29tbXVuaWNhdGlvbiBjaGFubmVsLlxyXG4gICAgICogTWVzc2FnZXMgYXJlIGJhdGNoZWQgYnkgZGVsYXlpbmcgcG9zdE1lc3NhZ2UgY2FsbCB0byBncm91cCBtZXNzYWdlcyB0aGF0IGNvbWUgZHVyaW5nIHRoaXMgZGVsYXkgYW5kIG1pbmltaXplXHJcbiAgICAgKiB0aGUgbnVtYmVyIG9mIGludGVycHJvY2VzcyBjb21tdW5pY2F0aW9ucyB0aGF0IGJhZGx5IGFmZmVjdCBwZXJmb3JtYW5jZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSBNZXNzYWdlIHRvIGJlIHNlbnQuXHJcbiAgICAgKiBAcGFyYW0gdXJnZW5jeSBJTU1FRElBVEUgZm9yY2VzIG1lc3NhZ2UgdG8gYmUgc2VudCBpbW1lZGlhdGVseSAoc3luY2hyb25vdXMgY2FsbCkgd2l0aCBubyBiYXRjaGluZyBkZWxheSxcclxuICAgICAqICAgICAgICAgICAgICAgIERFRkFVTFQgZGVib3VuY2VzIHNlbmRpbmcgZm9yIGFub3RoZXIgRkxVU0hfVElNRU9VVC5cclxuICAgICAqL1xyXG4gICAgc2VuZE1lc3NhZ2UobWVzc2FnZSwgdXJnZW5jeSA9IDAgLyogREVGQVVMVCAqLykge1xyXG4gICAgICAgIGNvbnN0IHRyYW5zZmVyYWJsZUV4dHJhY3RvciA9IHRoaXMuX3RyYW5zZmVyYWJsZUV4dHJhY3RvcnMuZ2V0KG1lc3NhZ2UudHlwZSk7XHJcbiAgICAgICAgY29uc3QgdHJhbnNmZXJhYmxlcyA9IHRyYW5zZmVyYWJsZUV4dHJhY3RvciA/IHRyYW5zZmVyYWJsZUV4dHJhY3RvcihtZXNzYWdlKSA6IHVuZGVmaW5lZDtcclxuICAgICAgICBjb25zdCBpc0ZpcnN0TWVzc2FnZUluQmF0Y2ggPSAodGhpcy5fbWVzc2FnZXMubGVuZ3RoID09PSAwKTtcclxuICAgICAgICBpZiAoaXNGaXJzdE1lc3NhZ2VJbkJhdGNoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZpcnN0TWVzc2FnZVRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU2VuZCBtZXNzYWdlcyBhc3luY2hyb25vdXNseSBwYWNraW5nIHRoZW0gaW50byBvbmUgbWVzc2FnZS5cclxuICAgICAgICAvLyBXZSBkb24ndCB3YW50IHRvIGFidXNlIHRoZSB3ZWIgd29ya2VyIGNvbW11bmljYXRpb24gY2hhbm5lbCBhbmRcclxuICAgICAgICAvLyBzZW5kIG1lc3NhZ2VzIGFzeW5jaHJvbm91c2x5IGluIHNob3J0IHBlcmlvZCBvZiB0aW1lIG9yIG1hbnkgbWVzc2FnZXMgc3luY2hyb25vdXNseS5cclxuICAgICAgICB0aGlzLl9tZXNzYWdlcy5wdXNoKG1lc3NhZ2UpO1xyXG4gICAgICAgIGlmICh0cmFuc2ZlcmFibGVzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zZmVyYWJsZXMgPSB0aGlzLl90cmFuc2ZlcmFibGVzLmNvbmNhdCh0cmFuc2ZlcmFibGVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXRIYW5kbGUpO1xyXG4gICAgICAgIGlmICh0aGlzLl9tZXNzYWdlcy5sZW5ndGggPiBNRVNTQUdFX0JBVENIX01BWF9TSVpFIHx8XHJcbiAgICAgICAgICAgIHVyZ2VuY3kgPT09IDEgLyogSU1NRURJQVRFICovIHx8XHJcbiAgICAgICAgICAgICghaXNGaXJzdE1lc3NhZ2VJbkJhdGNoICYmIChwZXJmb3JtYW5jZS5ub3coKSAtIHRoaXMuX2ZpcnN0TWVzc2FnZVRpbWUpID4gTUFYX0ZMVVNIX1RJTUVPVVQpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZsdXNoTWVzc2FnZXMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RpbWVvdXRIYW5kbGUgPSBzZXRUaW1lb3V0KHRoaXMuX2ZsdXNoTWVzc2FnZXNCaW5kZWQsIEZMVVNIX1RJTUVPVVQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2VuZHMgcmVxdWVzdCBtZXNzYWdlIHRvL2Zyb20gd29ya2VyIGFzIHByb21pc2UsIHRoZSBvdGhlciBzaWRlIGNhbiByZXNwb25kIGFuZCB0aGUgcHJvbWlzZSBpcyByZXNvbHZlZC5cclxuICAgICAqIFJlcXVlc3QvcmVzcG9uc2UgaXMgc3luY2hyb25pemVkIGJ5IHRoZSByZXF1ZXN0SWQgZmllbGQuXHJcbiAgICAgKi9cclxuICAgIHJlcXVlc3QocmVxdWVzdCwgdXJnZW5jeSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0LnJlcXVlc3RJZCA9PT0gTk9fSUQpIHtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3QucmVxdWVzdElkID0gdW5pcXVlSWQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBsaXN0ZW5lciA9IChtZXNzYWdlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZUlzKG1lc3NhZ2UsIHJlcXVlc3QucmVzcG9uc2VUeXBlKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucmVxdWVzdElkID09PSByZXF1ZXN0LnJlcXVlc3RJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUobWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKGxpc3RlbmVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlSXMobWVzc2FnZSwgcmVxdWVzdC5lcnJvclR5cGUpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yZXF1ZXN0SWQgPT09IHJlcXVlc3QucmVxdWVzdElkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vZmYobGlzdGVuZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMuYWRkTGlzdGVuZXIobGlzdGVuZXIpO1xyXG4gICAgICAgICAgICB0aGlzLnNlbmRNZXNzYWdlKHJlcXVlc3QsIHVyZ2VuY3kpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNwb25kcyB0byBwcm92aWRlZCByZXF1ZXN0LlxyXG4gICAgICovXHJcbiAgICByZXNwb25kKHJlcXVlc3QsIHJlc3BvbnNlLCB1cmdlbmN5KSB7XHJcbiAgICAgICAgcmVzcG9uc2UucmVxdWVzdElkID0gcmVxdWVzdC5yZXF1ZXN0SWQ7XHJcbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZShyZXNwb25zZSwgdXJnZW5jeSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgYSBsaXN0ZW5lciB0byBzcGVjaWZpYyB0eXBlIG9mIGluY29taW5nIG1lc3NhZ2VzLlxyXG4gICAgICovXHJcbiAgICBvbih0eXBlLCBsaXN0ZW5lcikge1xyXG4gICAgICAgIGNvbnN0IHR5cGVTYWZlTGlzdGVuZXIgPSAobWVzc2FnZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAobWVzc2FnZUlzKG1lc3NhZ2UsIHR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcihtZXNzYWdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzLnNldChsaXN0ZW5lciwgdHlwZVNhZmVMaXN0ZW5lcik7XHJcbiAgICAgICAgdGhpcy5fZXZlbnRzLmFkZExpc3RlbmVyKHR5cGVTYWZlTGlzdGVuZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGluY29taW5nIG1lc3NhZ2VzIGxpc3RlbmVyLlxyXG4gICAgICovXHJcbiAgICBvZmYobGlzdGVuZXIpIHtcclxuICAgICAgICBjb25zdCB0eXBlU2FmZUxpc3RlbmVyID0gdGhpcy5fbGlzdGVuZXJzLmdldChsaXN0ZW5lcik7XHJcbiAgICAgICAgaWYgKHR5cGVTYWZlTGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKHR5cGVTYWZlTGlzdGVuZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3RhcnRzIGxpc3RlbmluZyBmb3IgaW5jb21pbmcgbWVzc2FnZXMuXHJcbiAgICAgKi9cclxuICAgIGxpc3RlbigpIHtcclxuICAgICAgICB0aGlzLl9hZGRyZXNzZWUub25tZXNzYWdlID0gKHsgZGF0YTogbWVzc2FnZXMgfSkgPT4ge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgbWVzc2FnZXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub25NZXNzYWdlKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlciBvZiBpbmNvbWluZyBtZXNzYWdlcy5cclxuICAgICAqL1xyXG4gICAgb25NZXNzYWdlKG1lc3NhZ2UpIHtcclxuICAgICAgICB0aGlzLl9ldmVudHMuZmlyZShtZXNzYWdlKTtcclxuICAgIH1cclxuICAgIF9mbHVzaE1lc3NhZ2VzKCkge1xyXG4gICAgICAgIHRoaXMuX2FkZHJlc3NlZS5wb3N0TWVzc2FnZSh0aGlzLl9tZXNzYWdlcywgdGhpcy5fdHJhbnNmZXJhYmxlcyk7XHJcbiAgICAgICAgdGhpcy5fbWVzc2FnZXMubGVuZ3RoID0gMDtcclxuICAgICAgICB0aGlzLl90cmFuc2ZlcmFibGVzLmxlbmd0aCA9IDA7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEJhc2UgY2xhc3MgZm9yIGEgd2Vid29ya2VyIGNvbnRyb2xsZXIgZm9yIHRoZSBtYWluIHRocmVhZCBjb2RlLlxyXG4gKiBJdCBhbHNvIHdyYXBzIGNyZWF0aW9uIG9mIGEgbmF0aXZlIFdvcmtlci5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBXZWJXb3JrZXJDbGllbnQgZXh0ZW5kcyBXZWJXb3JrZXJDb21tdW5pY2F0b3Ige1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gdXJsIFVSTCBvZiB3ZWJ3b3JrZXIncyBkZXBsb3llZCBqcyBmaWxlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHVybCkge1xyXG4gICAgICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIodXJsKTtcclxuICAgICAgICBzdXBlcih3b3JrZXIpO1xyXG4gICAgICAgIHRoaXMuX3dvcmtlciA9IHdvcmtlcjtcclxuICAgICAgICB0aGlzLmxpc3RlbigpO1xyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLl93b3JrZXIudGVybWluYXRlKCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEJhc2UgY2xhc3MgZm9yIGEgd2Vid29ya2VyIHRocmVhZCBpbXBsZW1lbnRhdGlvbi4gQ29uY3JldGUgY2xhc3Mgc2hvdWxkIGJlIHRoZSBlbnRyeSBwb2ludCBmb3IgYSB3ZWJ3b3JrZXIganMgYnVpbGQ6XHJcbiAqICAgICBuZXcgQ29uY3JldGVXZWJXb3JrZXJJbXBsZW1lbnRhdGlvbig8RGVkaWNhdGVkV29ya2VyR2xvYmFsU2NvcGU+c2VsZikucnVuKCk7XHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgV2ViV29ya2VySW1wbGVtZW50YXRpb24gZXh0ZW5kcyBXZWJXb3JrZXJDb21tdW5pY2F0b3Ige1xyXG4gICAgcnVuKCkge1xyXG4gICAgICAgIHRoaXMubGlzdGVuKCk7XHJcbiAgICB9XHJcbn1cclxuIiwibGV0IGlkID0gMTtcclxuLyoqXHJcbiAqIEdlbmVyYXRlcyB1bmlxdWUgaWRcclxuKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVuaXF1ZUlkKCkge1xyXG4gICAgcmV0dXJuIGlkKys7XHJcbn1cclxuIiwiY29uc3QgVElMRV8wXzBfMCA9IHsgeDogMCwgeTogMCwgem9vbTogMCB9O1xyXG4vKipcclxuICogQ29tcHV0ZXMgc2V0IG9mIHRpbGVzIHZpc2libGUgdGhyb3VnaCBhIGNhbWVyYS4gVGlsZXMgaW4gdGhlIHNldCBhcmUgZ3VhcmFudGVlZFxyXG4gKiB0byBiZSB1bmlxdWUuXHJcbiAqXHJcbiAqIEZJWE1FKGRtaWtpcykgVGhlIHVuaXF1ZW5lc3MgZ3VhcmFudGVlIGlzIGJyb2tlbiBjdXJyZW50bHksIGJ1dCBjb2RlIHRoYXQgdXNlc1xyXG4gKiAgICAgIHRoaXMgZnVuY3Rpb24gZG9lc24ndCBzdWZmZXIgZnJvbSB0aGF0LlxyXG4gKlxyXG4gKiBAcGFyYW0gY2FtZXJhIFRoZSBjYW1lcmEuXHJcbiAqIEByZXR1cm5zIEFuIGl0ZXJhdG9yIG92ZXIgdmlzaWJsZSB0aWxlIGl0ZW1zLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uKiBjb21wdXRlVmlzaWJsZVRpbGVzKHZpc2libGVSZWdpb24sIHZpc2libGVSZWdpb25CQm94LCB3cmFwTW9kZVgsIHdyYXBNb2RlWSwgem9vbSkge1xyXG4gICAgaWYgKHpvb20gPT09IDApIHtcclxuICAgICAgICAvLyBUaGUgb25seSB0aWxlIG9uIHpvb20gMCBlbmNvbXBhc3NlcyB0aGUgd2hvbGUgd29ybGQuIFRodXMgdGhlcmUnc1xyXG4gICAgICAgIC8vIGxpdHRsZSB0byBubyBwb2ludCBjb21wdXRpbmcgdGhhdCBjYW1lcmEgc2VlcyBpdDogd2UgY2FuIHRlbGwgdGhhdFxyXG4gICAgICAgIC8vIHJpZ2h0IGF3YXkuXHJcbiAgICAgICAgeWllbGQgVElMRV8wXzBfMDtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCB0aWxlQ291bnQgPSAxIDw8IHpvb207XHJcbiAgICBjb25zdCB0aWxlSWR4TWFzayA9IHRpbGVDb3VudCAtIDE7XHJcbiAgICAvLyBUaGUgaWRlYSBiZWhpbmQgdGhlIGNvZGUgYmVsb3cgaXMgcXVpdGUgc2ltcGxlOiBkZXRlcm1pbmUgY29sdW1ucyBvZiB0aGVcclxuICAgIC8vIHRpbGUgZ3JpZCB0aGF0IGFyZSB2aXNpYmxlIHRvIHRoZSBjYW1lcmEsIHRoZW4gZm9yIGVhY2ggY29sdW1uIGZpbmRcclxuICAgIC8vIHJhbmdlIG9mIHJvdyBpbmRpY2VzIHRoYXQgYXJlIHZpc2libGUuXHJcbiAgICAvLyBIZXJlJ3MgaG93IHdlIGFwcHJvYWNoIGNvbXB1dGluZyB0aWxlIGluZGljZXMgZnJvbSB3b3JsZCBjb29yZGluYXRlcy5cclxuICAgIC8vIEZpcnN0LCB3ZSB0cmFuc2Zvcm0gd29ybGQgY29vcmRpbmF0ZXMgZnJvbSBbLTEsIDFdIHJhbmdlIHRvIFswLCAyXSxcclxuICAgIC8vIGRlYWxpbmcgd2l0aCBpbmNvbnNpc3RlbmN5IHdpdGggWSBheGlzIGRpcmVjdGlvbiBpbiB3b3JsZCBhbmQgdGlsZSBncmlkXHJcbiAgICAvLyBjb29yZGluYXRlIHN5c3RlbS4gTGV0J3MgZGVzaWduYXRlIHN1Y2ggYSBjb29yZGluYXRlIGFzIEMgKGZvciBlaXRoZXIgWFxyXG4gICAgLy8gb3IgWSkuIFNpemUgb2YgYSB0aWxlIGlzIDIgLyB0aWxlQ291bnQuIFRodXMsXHJcbiAgICAvL1xyXG4gICAgLy8gICAgICB0aWxlSWR4ID0gTWF0aC5mbG9vcihDIC8gKDIgLyB0aWxlQ291bnQpKVxyXG4gICAgLy8gICAgICAgICAgICAgID0gTWF0aC5mbG9vcihDICogdGlsZUNvdW50IC8gMilcclxuICAgIC8vXHJcbiAgICBjb25zdCB7IG1pblgsIG1heFgsIG1pblksIG1heFkgfSA9IHZpc2libGVSZWdpb25CQm94O1xyXG4gICAgY29uc3QgbWluVFggPSBNYXRoLmZsb29yKChtaW5YICsgMSkgKiB0aWxlQ291bnQgLyAyKTtcclxuICAgIGNvbnN0IG1heFRYID0gTWF0aC5mbG9vcigobWF4WCArIDEpICogdGlsZUNvdW50IC8gMik7XHJcbiAgICBjb25zdCBjb2x1bW5Db3VudCA9IG1heFRYIC0gbWluVFggKyAxO1xyXG4gICAgLy8gQXJyYXlzIG9mIGluZGljZXMgb2YgYm90dG9tbW9zdCBhbmQgdG9wbW9zdCB0aWxlcyBjb3JyZXNwb25kaW5nbHkgZm9yXHJcbiAgICAvLyBlYWNoIGNvbHVtbi5cclxuICAgIC8vIEZJWE1FKGRtaWtpcykgSWYgbnVtYmVyIG9mIGNvbHVtbnMgaXMgdG9vIGxhcmdlLCB3ZSdsbCBjb25zdW1lIGEgbG90IG9mXHJcbiAgICAvLyAgICAgIG1lbW9yeSBoZXJlLiBUaGVyZSdzIGEgbWV0aG9kIHRvIGRvIHdpdGhvdXQgdGhlIGFycmF5cywgYnV0IGl0J3MgYVxyXG4gICAgLy8gICAgICBiaXQgbW9yZSBjb21wbGljYXRlZCB0byBpbXBsZW1lbnQuXHJcbiAgICBjb25zdCBtaW5ZcyA9IG5ldyBBcnJheShjb2x1bW5Db3VudCk7XHJcbiAgICBjb25zdCBtYXhZcyA9IG5ldyBBcnJheShjb2x1bW5Db3VudCk7XHJcbiAgICAvLyBDb21tb24gc2Vuc2Ugc3VnZ2VzdHMgdGhhdCB0aG9zZSBpbmRpY2VzIGNhbid0IGJlIGdyZWF0ZXIgKGxlc3MpIHRoYW4gdGhlXHJcbiAgICAvLyBpbmRleCBvZiBhIHRpbGUgcm93IGludGVyc2VjdGVkIGJ5IGEgbGluZSB5ID0gbWluWSAoeSA9IG1heFkpLiBOb3RlIHRoYXRcclxuICAgIC8vIG1heFkgY29ycmVzcG9uZHMgdG8gYSB0aWxlIHJvdyB3aXRoIGxlc3NlciBpbmRleCwgbm90IG90aGVyIHdheSBhcm91bmQuXHJcbiAgICBtaW5Zcy5maWxsKE1hdGguZmxvb3IoKDEgLSBtaW5ZKSAqIHRpbGVDb3VudCAvIDIpKTtcclxuICAgIG1heFlzLmZpbGwoTWF0aC5mbG9vcigoMSAtIG1heFkpICogdGlsZUNvdW50IC8gMikpO1xyXG4gICAgY29uc3QgdmlzaWJsZVBvbHlnb25MZW5ndGggPSB2aXNpYmxlUmVnaW9uLmxlbmd0aDtcclxuICAgIGxldCBwcmV2WCA9IHZpc2libGVSZWdpb25bdmlzaWJsZVBvbHlnb25MZW5ndGggLSAxXS54ICsgMTtcclxuICAgIGxldCBwcmV2WSA9IDEgLSB2aXNpYmxlUmVnaW9uW3Zpc2libGVQb2x5Z29uTGVuZ3RoIC0gMV0ueTtcclxuICAgIGxldCBwcmV2VFggPSBNYXRoLmZsb29yKHByZXZYICogdGlsZUNvdW50IC8gMik7XHJcbiAgICBsZXQgcHJldlRZID0gTWF0aC5mbG9vcihwcmV2WSAqIHRpbGVDb3VudCAvIDIpO1xyXG4gICAgLy8gSXRlcmF0ZSBvdmVyIGVkZ2VzIG9mIHZpc2libGUgcG9seWdvbiBvZiB0aGUgY2FtZXJhIHRvIGNvbXB1dGUgaW5kZXggb2ZcclxuICAgIC8vIHRvcG1vc3QgYW5kIGJvdHRvbW1vc3QgdGlsZXMgZm9yIGVhY2ggY29sdW1uLlxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2aXNpYmxlUG9seWdvbkxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgY29uc3QgeCA9IHZpc2libGVSZWdpb25baV0ueCArIDE7XHJcbiAgICAgICAgY29uc3QgeSA9IDEgLSB2aXNpYmxlUmVnaW9uW2ldLnk7XHJcbiAgICAgICAgY29uc3QgdHggPSBNYXRoLmZsb29yKHggKiB0aWxlQ291bnQgLyAyKTtcclxuICAgICAgICBjb25zdCB0eSA9IE1hdGguZmxvb3IoeSAqIHRpbGVDb3VudCAvIDIpO1xyXG4gICAgICAgIC8vIEZvciBlYWNoIGVkZ2Ugd2UgY29tcHV0ZSA0LWNvbm5lY3RlZCBsaW5lIG9mIHRpbGVzIG9uIHRoZSB0aWxlIGdyaWQuXHJcbiAgICAgICAgLy8gTGVuZ3RoIG9mIGEgNC1jb25uZWN0ZWQgbGluZSBhbHdheXMgZXF1YWxzIE1hbmhhdHRhbiBkaXN0YW5jZSBiZXR3ZWVuXHJcbiAgICAgICAgLy8gaXRzIGVuZHMuIEhvd2V2ZXIsIHRvIGF2b2lkIHVubmVjZXNzYXJ5IGNvbXB1dGF0aW9uLCB3ZSBvbWl0IGxhc3QgdGlsZVxyXG4gICAgICAgIC8vIGZvciBldmVyeSBlZGdlLiBCdXQsIHNpbmNlIHRoZSBwb2x5Z29uIGlzIGNsb3NlZCwgd2UnbGwgaXRlcmF0ZSBvdmVyXHJcbiAgICAgICAgLy8gYWxsIHRpbGVzIGludGVyc2VjdGVkIGJ5IGVkZ2VzIGFueXdheS5cclxuICAgICAgICBjb25zdCBsID0gTWF0aC5hYnModHggLSBwcmV2VFgpICsgTWF0aC5hYnModHkgLSBwcmV2VFkpO1xyXG4gICAgICAgIGNvbnN0IGx4ID0geCAtIHByZXZYO1xyXG4gICAgICAgIGNvbnN0IGx5ID0geSAtIHByZXZZO1xyXG4gICAgICAgIGNvbnN0IGR0eCA9IGx4ID4gMCA/IDEgOiAtMTtcclxuICAgICAgICBjb25zdCBkdHkgPSBseSA+IDAgPyAxIDogLTE7XHJcbiAgICAgICAgY29uc3QgYSA9IDIgKiBkdHggKiBseTtcclxuICAgICAgICBjb25zdCBiID0gLTIgKiBkdHggKiBseDtcclxuICAgICAgICBjb25zdCBjID0gZHR4ICogdGlsZUNvdW50ICogKGx4ICogcHJldlkgLSBseSAqIHByZXZYKSArIGEgKiAofmR0eCA+Pj4gMzEpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCB0eCA9IHByZXZUWCwgdHkgPSBwcmV2VFk7IGkgPCBsOyArK2kpIHtcclxuICAgICAgICAgICAgY29uc3QgaW50ZXJjZXB0ID0gYSAqIHR4ICsgYiAqIHR5ICsgYztcclxuICAgICAgICAgICAgLy8gVGhlIG1hdGggaGVyZSBpcyBzb21ld2hhdCBjdW1iZXJzb21lIHRvIGF2b2lkIGRpdmlzaW9ucywgYnV0IHRoZVxyXG4gICAgICAgICAgICAvLyBlc3NlbmNlIGlzIHRoYXQgd2UgdHJ5IHRvIGNoZWNrIHRocm91Z2ggd2hpY2ggc2lkZSB0aGUgZWRnZSBvZlxyXG4gICAgICAgICAgICAvLyB2aXNpYmxlIHBvbHlnb24gZXhpdHMgdGhlIHRpbGUuIERlcGVuZGluZyBvbiB0aGF0IHdlIFwibW92ZVwiIHRvXHJcbiAgICAgICAgICAgIC8vIG5leHQgdGlsZSBpbiBlaXRoZXIgdmVydGljYWwgb3IgaG9yaXpvbnRhbCBkaXJlY3Rpb24uXHJcbiAgICAgICAgICAgIGlmICgwIDw9IGludGVyY2VwdCAmJiBpbnRlcmNlcHQgPD0gLWIpIHtcclxuICAgICAgICAgICAgICAgIHR4ICs9IGR0eDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHR5ICs9IGR0eTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCB5SWR4ID0gdHggLSBtaW5UWDtcclxuICAgICAgICAgICAgaWYgKG1heFlzW3lJZHhdIDwgdHkpIHtcclxuICAgICAgICAgICAgICAgIG1heFlzW3lJZHhdID0gdHk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG1pbllzW3lJZHhdID4gdHkpIHtcclxuICAgICAgICAgICAgICAgIG1pbllzW3lJZHhdID0gdHk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcHJldlggPSB4O1xyXG4gICAgICAgIHByZXZZID0geTtcclxuICAgICAgICBwcmV2VFggPSB0eDtcclxuICAgICAgICBwcmV2VFkgPSB0eTtcclxuICAgIH1cclxuICAgIC8vIElmIHRoZSB3b3JsZCBpcyByZXBlYXRlZCBhbG9uZyBYIGF4aXMsIHdlIG5lZWQgdG8gXCJmb2xkXCIgdGhlIGFycmF5IG9mIGNvbHVtbnMsXHJcbiAgICAvLyBpLmUuIGNvbXB1dGUgdW5pb24gb2Ygcm93IGludGVydmFscyBmb3IgY29sdW1ucyB0aWxlQ291bnQgaW5kaWNlcyBhcGFydC5cclxuICAgIGlmICh3cmFwTW9kZVggPT09IDIgLyogUkVQRUFUICovICYmIGNvbHVtbkNvdW50ID4gdGlsZUNvdW50KSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aWxlQ291bnQ7ICsraSkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gaSArIHRpbGVDb3VudDsgaiA8IGNvbHVtbkNvdW50OyBqICs9IHRpbGVDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1heFlzW2ldIDwgbWF4WXNbal0pIHtcclxuICAgICAgICAgICAgICAgICAgICBtYXhZc1tpXSA9IG1heFlzW2pdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG1pbllzW2ldID4gbWluWXNbal0pIHtcclxuICAgICAgICAgICAgICAgICAgICBtaW5Zc1tpXSA9IG1pbllzW2pdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gSWYgdGhlIHdvcmxkIGlzIHJlcGVhdGVkIGFsb25nIFkgYXhpcywgd2UgbmVlZCB0byB3cmFwIGluZGljZXMgaW4gbWluWXNcclxuICAgIC8vIGFuZCBtYXhZcyBhcnJheXMgdG8gWzAsIHRpbGVDb3VudCkgaW50ZXJ2YWwuXHJcbiAgICBpZiAod3JhcE1vZGVZID09PSAyIC8qIFJFUEVBVCAqLykge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sdW1uQ291bnQgJiYgaSA8IHRpbGVDb3VudDsgKytpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGR5ID0gbWF4WXNbaV0gLSBtaW5Zc1tpXTtcclxuICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBtb3JlIHRoYW4gdGlsZUNvdW50IHJvd3MgYmV0d2VlbiBtYXhZIGFuZCBtaW5ZLCB0aGVuIHRoZVxyXG4gICAgICAgICAgICAvLyB3b3JsZCBpcyBlbmNvbXBhc3NlZCBzb21ld2hlcmUgd2l0aGluIHZpc2libGUgcmVnaW9uLlxyXG4gICAgICAgICAgICBpZiAoZHkgPiB0aWxlQ291bnQpIHtcclxuICAgICAgICAgICAgICAgIG1pbllzW2ldID0gMDtcclxuICAgICAgICAgICAgICAgIG1heFlzW2ldID0gdGlsZUlkeE1hc2s7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtaW5ZID0gbWluWXNbaV0gJj0gdGlsZUlkeE1hc2s7XHJcbiAgICAgICAgICAgICAgICBtYXhZc1tpXSA9IG1pblkgKyBkeTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sdW1uQ291bnQgJiYgaSA8IHRpbGVDb3VudDsgKytpKSB7XHJcbiAgICAgICAgICAgIG1pbllzW2ldID0gTWF0aC5tYXgobWluWXNbaV0sIDApO1xyXG4gICAgICAgICAgICBtYXhZc1tpXSA9IE1hdGgubWluKG1heFlzW2ldLCB0aWxlSWR4TWFzayk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHdyYXBNb2RlWCA9PT0gMiAvKiBSRVBFQVQgKi8pIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHVtbkNvdW50ICYmIGkgPCB0aWxlQ291bnQ7ICsraSkge1xyXG4gICAgICAgICAgICBjb25zdCB0eCA9IChpICsgbWluVFgpICYgdGlsZUlkeE1hc2s7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHR5ID0gbWluWXNbaV07IHR5IDw9IG1heFlzW2ldOyArK3R5KSB7XHJcbiAgICAgICAgICAgICAgICB5aWVsZCB7XHJcbiAgICAgICAgICAgICAgICAgICAgeDogdHgsXHJcbiAgICAgICAgICAgICAgICAgICAgeTogdHkgJiB0aWxlSWR4TWFzayxcclxuICAgICAgICAgICAgICAgICAgICB6b29tXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZm9yIChsZXQgdHggPSBNYXRoLm1heChtaW5UWCwgMCksIHR4RW5kID0gTWF0aC5taW4obWF4VFgsIHRpbGVJZHhNYXNrKTsgdHggPD0gdHhFbmQ7ICsrdHgpIHtcclxuICAgICAgICAgICAgY29uc3QgaSA9IHR4IC0gbWluVFg7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHR5ID0gbWluWXNbaV07IHR5IDw9IG1heFlzW2ldOyArK3R5KSB7XHJcbiAgICAgICAgICAgICAgICB5aWVsZCB7XHJcbiAgICAgICAgICAgICAgICAgICAgeDogdHgsXHJcbiAgICAgICAgICAgICAgICAgICAgeTogdHkgJiB0aWxlSWR4TWFzayxcclxuICAgICAgICAgICAgICAgICAgICB6b29tXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IGdldFRpbGVJZCwgZ2V0VGlsZUlkQnlSYXdWYWx1ZXMgfSBmcm9tICcuL3RpbGVfaWQnO1xyXG5pbXBvcnQgKiBhcyB2ZWMyIGZyb20gJy4uLy4uL21hdGgvdmVjdG9yMic7XHJcbmltcG9ydCB7IGN5Y2xlUmVzdHJpY3QgfSBmcm9tICcuLi8uLi9tYXRoL3NjYWxhcic7XHJcbmNvbnN0IExFRlRfU0lERSA9IHtcclxuICAgIGRpcmVjdGlvbjogdmVjMi5jcmVhdGUoMCwgLTEpLFxyXG4gICAgbm9ybWFsOiB2ZWMyLmNyZWF0ZSgtMSwgMCksXHJcbiAgICBkaWFnb25hbDogdmVjMi5jcmVhdGUoLTEsIC0xKSxcclxuICAgIHByZXZTaWRlOiAoKSA9PiBCT1RUT01fU0lERSxcclxuICAgIG5leHRTaWRlOiAoKSA9PiBUT1BfU0lERVxyXG59O1xyXG5jb25zdCBSSUdIVF9TSURFID0ge1xyXG4gICAgZGlyZWN0aW9uOiB2ZWMyLmNyZWF0ZSgwLCArMSksXHJcbiAgICBub3JtYWw6IHZlYzIuY3JlYXRlKCsxLCAwKSxcclxuICAgIGRpYWdvbmFsOiB2ZWMyLmNyZWF0ZSgrMSwgKzEpLFxyXG4gICAgcHJldlNpZGU6ICgpID0+IFRPUF9TSURFLFxyXG4gICAgbmV4dFNpZGU6ICgpID0+IEJPVFRPTV9TSURFXHJcbn07XHJcbmNvbnN0IFRPUF9TSURFID0ge1xyXG4gICAgZGlyZWN0aW9uOiB2ZWMyLmNyZWF0ZSgrMSwgMCksXHJcbiAgICBub3JtYWw6IHZlYzIuY3JlYXRlKDAsIC0xKSxcclxuICAgIGRpYWdvbmFsOiB2ZWMyLmNyZWF0ZSgrMSwgLTEpLFxyXG4gICAgcHJldlNpZGU6ICgpID0+IExFRlRfU0lERSxcclxuICAgIG5leHRTaWRlOiAoKSA9PiBSSUdIVF9TSURFXHJcbn07XHJcbmNvbnN0IEJPVFRPTV9TSURFID0ge1xyXG4gICAgZGlyZWN0aW9uOiB2ZWMyLmNyZWF0ZSgtMSwgMCksXHJcbiAgICBub3JtYWw6IHZlYzIuY3JlYXRlKDAsICsxKSxcclxuICAgIGRpYWdvbmFsOiB2ZWMyLmNyZWF0ZSgtMSwgKzEpLFxyXG4gICAgcHJldlNpZGU6ICgpID0+IFJJR0hUX1NJREUsXHJcbiAgICBuZXh0U2lkZTogKCkgPT4gTEVGVF9TSURFXHJcbn07XHJcbi8qKlxyXG4gKiBBZGRzIHRpbGUgdG8gYmVsdCB0aWxlcyBpZiBpdCBkb2Vzbid0IGZhbGwgb3V0IG9mIHRoZSB3b3JsZC4gQ3ljbGluZyBjb29yZGluYXRlcyBjYW4ndCBmYWxsIG91dCxcclxuICogdGhleSBqdXN0IGdvdCBhZGp1c3RlZCBkaXJlY3RseSBpbiB0aWxlIGl0ZW0uXHJcbiAqL1xyXG5mdW5jdGlvbiBhZGRUaWxlSWZBcHByb3ByaWF0ZSh0aWxlLCBiZWx0VGlsZXMsIG1heENvb3JkaW5hdGUsIGlzWEN5Y2xlZCwgaXNZQ3ljbGVkKSB7XHJcbiAgICB0aWxlLnggPSBpc1hDeWNsZWQgPyBjeWNsZVJlc3RyaWN0KHRpbGUueCwgMCwgbWF4Q29vcmRpbmF0ZSkgOiB0aWxlLng7XHJcbiAgICB0aWxlLnkgPSBpc1lDeWNsZWQgPyBjeWNsZVJlc3RyaWN0KHRpbGUueSwgMCwgbWF4Q29vcmRpbmF0ZSkgOiB0aWxlLnk7XHJcbiAgICBpZiAoKDAgPD0gdGlsZS54KSAmJiAodGlsZS54IDwgbWF4Q29vcmRpbmF0ZSkgJiZcclxuICAgICAgICAoMCA8PSB0aWxlLnkpICYmICh0aWxlLnkgPCBtYXhDb29yZGluYXRlKSkge1xyXG4gICAgICAgIGJlbHRUaWxlcy5zZXQoZ2V0VGlsZUlkKHRpbGUpLCB0aWxlKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGhlIGFsZ29yaXRobSBpcyBpbXBsZW1lbnRlZCBhcyBhIHN0YXRlIG1hY2hpbmUsIHRoaXMgbWV0aG9kIHByb2R1Y2VzIGJlbHQgdGlsZXMgYW5kIHNldHMgYXBwcm9wcmlhdGUgc3RhdGUuXHJcbiAqIEhvdyB0byBjaGFuZ2UgdGhpcyBzdGF0ZSAoZGV0ZXJtaW5lIGN1cnJlbnQgdGlsZSBhbmQgaXRzIHNpZGUpIGlzIGRlc2NyaWJlZCBpbiBmb3VyIFRpbGVTaWRlIGltcGxlbWVudGF0aW9uczpcclxuICogbGVmdCwgcmlnaHQsIHRvcCBhbmQgYm90dG9tLlxyXG4gKi9cclxuZnVuY3Rpb24gbW92ZSh0aWxlcywgc3RhdGUsIHNpemUsIG1heENvb3JkaW5hdGUsIGlzWEN5Y2xlZCwgaXNZQ3ljbGVkKSB7XHJcbiAgICAvLyBhZGQgdGlsZXMgb3V0d2FyZCBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBub3JtYWxcclxuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IHNpemU7IGkrKykge1xyXG4gICAgICAgIGFkZFRpbGVJZkFwcHJvcHJpYXRlKHtcclxuICAgICAgICAgICAgeDogc3RhdGUuY3VycmVudFRpbGUueCArIGkgKiBzdGF0ZS5jdXJyZW50VGlsZVNpZGUubm9ybWFsLngsXHJcbiAgICAgICAgICAgIHk6IHN0YXRlLmN1cnJlbnRUaWxlLnkgKyBpICogc3RhdGUuY3VycmVudFRpbGVTaWRlLm5vcm1hbC55LFxyXG4gICAgICAgICAgICB6b29tOiBzdGF0ZS5jdXJyZW50VGlsZS56b29tXHJcbiAgICAgICAgfSwgc3RhdGUuYmVsdFRpbGVzLCBtYXhDb29yZGluYXRlLCBpc1hDeWNsZWQsIGlzWUN5Y2xlZCk7XHJcbiAgICB9XHJcbiAgICAvLyBjaGVjayBkaWFnb25hbCB0aWxlXHJcbiAgICBjb25zdCBkaWFnb25hbE5laWdoYm91ciA9IHRpbGVzLmdldChnZXRUaWxlSWRCeVJhd1ZhbHVlcyhzdGF0ZS5jdXJyZW50VGlsZS54ICsgc3RhdGUuY3VycmVudFRpbGVTaWRlLmRpYWdvbmFsLngsIHN0YXRlLmN1cnJlbnRUaWxlLnkgKyBzdGF0ZS5jdXJyZW50VGlsZVNpZGUuZGlhZ29uYWwueSwgc3RhdGUuY3VycmVudFRpbGUuem9vbSkpO1xyXG4gICAgaWYgKGRpYWdvbmFsTmVpZ2hib3VyKSB7XHJcbiAgICAgICAgc3RhdGUuY3VycmVudFRpbGUgPSBkaWFnb25hbE5laWdoYm91cjtcclxuICAgICAgICBzdGF0ZS5jdXJyZW50VGlsZVNpZGUgPSBzdGF0ZS5jdXJyZW50VGlsZVNpZGUucHJldlNpZGUoKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAvLyBjaGVjayBuZWlnaGJvdXIgaW4gdGhlIHNhbWUgZGlyZWN0aW9uXHJcbiAgICBjb25zdCBuZWlnaGJvdXIgPSB0aWxlcy5nZXQoZ2V0VGlsZUlkQnlSYXdWYWx1ZXMoc3RhdGUuY3VycmVudFRpbGUueCArIHN0YXRlLmN1cnJlbnRUaWxlU2lkZS5kaXJlY3Rpb24ueCwgc3RhdGUuY3VycmVudFRpbGUueSArIHN0YXRlLmN1cnJlbnRUaWxlU2lkZS5kaXJlY3Rpb24ueSwgc3RhdGUuY3VycmVudFRpbGUuem9vbSkpO1xyXG4gICAgaWYgKG5laWdoYm91cikge1xyXG4gICAgICAgIHN0YXRlLmN1cnJlbnRUaWxlID0gbmVpZ2hib3VyO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIC8vIGhhbmRsZSBjb3JuZXIgdGlsZXNcclxuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IHNpemU7IGkrKykge1xyXG4gICAgICAgIGZvciAobGV0IGogPSAxOyBqIDw9IHNpemU7IGorKykge1xyXG4gICAgICAgICAgICBhZGRUaWxlSWZBcHByb3ByaWF0ZSh7XHJcbiAgICAgICAgICAgICAgICB4OiBzdGF0ZS5jdXJyZW50VGlsZS54ICsgaSAqIHN0YXRlLmN1cnJlbnRUaWxlU2lkZS5kaWFnb25hbC54LFxyXG4gICAgICAgICAgICAgICAgeTogc3RhdGUuY3VycmVudFRpbGUueSArIGogKiBzdGF0ZS5jdXJyZW50VGlsZVNpZGUuZGlhZ29uYWwueSxcclxuICAgICAgICAgICAgICAgIHpvb206IHN0YXRlLmN1cnJlbnRUaWxlLnpvb21cclxuICAgICAgICAgICAgfSwgc3RhdGUuYmVsdFRpbGVzLCBtYXhDb29yZGluYXRlLCBpc1hDeWNsZWQsIGlzWUN5Y2xlZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGUuY3VycmVudFRpbGVTaWRlID0gc3RhdGUuY3VycmVudFRpbGVTaWRlLm5leHRTaWRlKCk7XHJcbn1cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGlsZXMgdGhhdCBzdXJyb3VuZCBwcm92aWRlZCByZWdpb24gKHNldCBvZiB0aWxlcyksIHRoZSByZWdpb24gbXVzdCBiZSBvbmUgb3IgbW9yZSBjb252ZXggcG9seWdvbnNcclxuICogd2l0aCBubyBob2xlcywgb3RoZXJ3aXNlIGNvcnJlY3RuZXNzIGlzIG5vdCBndWFyYW50ZWVkLiBNdWx0aXBsZSBwb2x5Z29ucyBjYW4gaGFwcGVuIHdoZW4gdGhlIGNhbWVyYSBsb29rc1xyXG4gKiBhdCB0aGUgZWRnZSBvZiB0aGUgd29ybGQgY2FwdHVyaW5nIGN5Y2xlZCB0aWxlcyBmcm9tIGRpZmZlcmVudCBzaWRlcy5cclxuICogVGhlIGxvZ2ljIG9mIGluY2x1ZGluZyB0aWxlcyBpbiB0aGUgXCJiZWx0XCIgaXMgYXMgZm9sbG93czogc2hvcnRlc3QgZGlzdGFuY2UgZnJvbSBcIm91dHNpZGVcIiB0byBhbnkgcG9pbnRcclxuICogaW4gdGhlIG9yaWdpbmFsIHJlZ2lvbiBzaG91bGQgYmUgbm90IGxlc3MgdGhhbiB0aWxlU2l6ZSAqIGJlbHRTaXplLlxyXG4gKlxyXG4gKiBAcGFyYW0gdGlsZXMgU2V0IG9mIHRpbGVzIHRoYXQgY292ZXIgYSBjb252ZXggcG9seWdvbi5cclxuICogQHBhcmFtIGJlbHRTaXplIFwidGhpY2tuZXNzXCIgKGluIHRpbGVzKSBvZiB0aGUgc3Vycm91bmRpbmcgYXJlYS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVCZWx0VGlsZXModGlsZXMsIGJlbHRTaXplLCBpc1hDeWNsZWQsIGlzWUN5Y2xlZCkge1xyXG4gICAgLy8gdGhlIGFsZ29yaXRobSBpbiBzaW1wbGUgd29yZHM6XHJcbiAgICAvLyAgIDEuIGZpbmQgYSB0aWxlIG9uIGFuIGVkZ2Ugb2YgdGhlIHBvbHlnb24gKGUuZy4gb25lIG9mIHRoZSBsZWZ0bW9zdCBvbmVzKVxyXG4gICAgLy8gICAyLiBnbyBhcm91bmQgdGhlIHBvbHlnb24gdGlsZS1ieS10aWxlIGFkZGluZyBzdXJyb3VuZGluZyB0aWxlcyBvdXR3YXJkbHlcclxuICAgIGNvbnN0IGluZGV4ZWRUaWxlcyA9IG5ldyBNYXAoKTtcclxuICAgIGNvbnN0IGJlbHRUaWxlcyA9IG5ldyBNYXAoKTtcclxuICAgIC8vIGluZGV4IHRpbGVzXHJcbiAgICBmb3IgKGNvbnN0IHRpbGVJdGVtIG9mIHRpbGVzKSB7XHJcbiAgICAgICAgaW5kZXhlZFRpbGVzLnNldChnZXRUaWxlSWQodGlsZUl0ZW0pLCB0aWxlSXRlbSk7XHJcbiAgICB9XHJcbiAgICAvLyB0aWxlcyBhcmUgZ3JvdXBlZCBpbnRvIG9uZSBvciBtb3JlIGNvbnZleCBwb2x5Z29ucywgcHJvY2VzcyB0aGVzZSBwb2x5Z29ucyBvbmUgYnkgb25lXHJcbiAgICBjb25zdCB0aWxlc1RvUHJvY2VzcyA9IG5ldyBNYXAoaW5kZXhlZFRpbGVzKTtcclxuICAgIHdoaWxlICh0aWxlc1RvUHJvY2Vzcy5zaXplID4gMCkge1xyXG4gICAgICAgIGxldCBsZWZ0bW9zdFRpbGUgPSB7IHg6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgeTogMCwgem9vbTogMCB9O1xyXG4gICAgICAgIC8vIGZpbmQgdGhlIGxlZnRtb3N0IHRpbGUgdG8gc3RhcnQgd2Fsa2luZyBmcm9tXHJcbiAgICAgICAgZm9yIChjb25zdCB0aWxlSXRlbSBvZiB0aWxlc1RvUHJvY2Vzcy52YWx1ZXMoKSkge1xyXG4gICAgICAgICAgICBpZiAodGlsZUl0ZW0ueCA8IGxlZnRtb3N0VGlsZS54KSB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0bW9zdFRpbGUgPSB0aWxlSXRlbTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzYXZlIG1pbi9tYXggeSB2YWx1ZSBwZXIgeCBjb29yZGluYXRlIHRvIGJlIGFibGVcclxuICAgICAgICAvLyB0byBtYXJrIHRoZXNlIHRpbGVzIGFzIHByb2Nlc3NlZCAocmVtb3ZlIGZyb20gdGlsZXNUb1Byb2Nlc3MpXHJcbiAgICAgICAgY29uc3QgbWF4WSA9IFtdO1xyXG4gICAgICAgIGNvbnN0IG1pblkgPSBbXTtcclxuICAgICAgICBjb25zdCBpbml0U3RhdGUgPSB7IGN1cnJlbnRUaWxlOiBsZWZ0bW9zdFRpbGUsIGN1cnJlbnRUaWxlU2lkZTogTEVGVF9TSURFLCBiZWx0VGlsZXMgfTtcclxuICAgICAgICBjb25zdCBzdGF0ZSA9IE9iamVjdC5hc3NpZ24oe30sIGluaXRTdGF0ZSk7XHJcbiAgICAgICAgY29uc3QgbWF4Q29vcmRpbmF0ZSA9IE1hdGgucG93KDIsIGxlZnRtb3N0VGlsZS56b29tKTtcclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIC8vIG1vdmUgYXJvdW5kIHdoaWxlIHdlIGRvbid0IHJlYWNoIHRoZSBpbml0IHBvc2l0aW9uXHJcbiAgICAgICAgICAgIG1vdmUodGlsZXNUb1Byb2Nlc3MsIHN0YXRlLCBiZWx0U2l6ZSwgbWF4Q29vcmRpbmF0ZSwgaXNYQ3ljbGVkLCBpc1lDeWNsZWQpO1xyXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHN0YXRlLmN1cnJlbnRUaWxlLnggLSBpbml0U3RhdGUuY3VycmVudFRpbGUueDtcclxuICAgICAgICAgICAgbWF4WVtpbmRleF0gPSBtYXhZW2luZGV4XSA9PT0gdW5kZWZpbmVkID8gc3RhdGUuY3VycmVudFRpbGUueSA6IE1hdGgubWF4KG1heFlbaW5kZXhdLCBzdGF0ZS5jdXJyZW50VGlsZS55KTtcclxuICAgICAgICAgICAgbWluWVtpbmRleF0gPSBtaW5ZW2luZGV4XSA9PT0gdW5kZWZpbmVkID8gc3RhdGUuY3VycmVudFRpbGUueSA6IE1hdGgubWluKG1pbllbaW5kZXhdLCBzdGF0ZS5jdXJyZW50VGlsZS55KTtcclxuICAgICAgICB9IHdoaWxlIChzdGF0ZS5jdXJyZW50VGlsZSAhPT0gaW5pdFN0YXRlLmN1cnJlbnRUaWxlIHx8XHJcbiAgICAgICAgICAgIHN0YXRlLmN1cnJlbnRUaWxlU2lkZSAhPT0gaW5pdFN0YXRlLmN1cnJlbnRUaWxlU2lkZSk7XHJcbiAgICAgICAgLy8gbWFyayB0aWxlcyBmcm9tIGN1cnJlbnQgcG9seWdvbiBhcyBwcm9jZXNzZWRcclxuICAgICAgICBjb25zdCB6b29tID0gbGVmdG1vc3RUaWxlLnpvb207XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhZLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHggPSBsZWZ0bW9zdFRpbGUueCArIGk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSBtaW5ZW2ldOyB5IDw9IG1heFlbaV07IHkrKykge1xyXG4gICAgICAgICAgICAgICAgdGlsZXNUb1Byb2Nlc3MuZGVsZXRlKGdldFRpbGVJZEJ5UmF3VmFsdWVzKHgsIHksIHpvb20pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIHJlbW92ZSBiZWx0IHRpbGVzIHRoYXQgb3ZlcmxhcHMgdG8gYXZvaWQgZHVwbGljYXRpb25zXHJcbiAgICBmb3IgKGNvbnN0IHRpbGVJZCBvZiBiZWx0VGlsZXMua2V5cygpKSB7XHJcbiAgICAgICAgaWYgKGluZGV4ZWRUaWxlcy5oYXModGlsZUlkKSkge1xyXG4gICAgICAgICAgICBiZWx0VGlsZXMuZGVsZXRlKHRpbGVJZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGJlbHRUaWxlcy52YWx1ZXMoKTtcclxufVxyXG4iLCJjb25zdCBQUk9KRUNUX0lEID0gNDQzO1xyXG5mdW5jdGlvbiBjaG9vc2VTdGF0VXJsKCkge1xyXG4gICAgLy8gRklYTUUoZG1pa2lzKSBJZGVhbGx5IHdlIHNob3VsZCBiZSBnZXQgdGhpcyBVUkxzIGZyb20gY29uZmlnLlxyXG4gICAgY29uc3QgU1RBVF9VUkxTID0ge1xyXG4gICAgICAgIHJ1OiAnaHR0cHM6Ly95YW5kZXgucnUvY2xjaycsXHJcbiAgICAgICAgY29tOiAnaHR0cHM6Ly95YW5kZXguY29tL2NsY2snLFxyXG4gICAgICAgIHRyOiAnaHR0cHM6Ly95YW5kZXguY29tLnRyL2NsY2snXHJcbiAgICB9O1xyXG4gICAgY29uc3QgdGxkID0gbG9jYXRpb24uaG9zdG5hbWUuc3BsaXQoJy4nKS5wb3AoKTtcclxuICAgIHN3aXRjaCAodGxkKSB7XHJcbiAgICAgICAgY2FzZSAndHInOlxyXG4gICAgICAgICAgICByZXR1cm4gU1RBVF9VUkxTLnRyO1xyXG4gICAgICAgIGNhc2UgJ2NvbSc6XHJcbiAgICAgICAgY2FzZSAnZnInOlxyXG4gICAgICAgICAgICByZXR1cm4gU1RBVF9VUkxTLmNvbTtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gU1RBVF9VUkxTLnJ1O1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IFNUQVRfVVJMID0gY2hvb3NlU3RhdFVybCgpO1xyXG5mdW5jdGlvbiBzdHJpbmdpZnlWYXJzKHZhcnMpIHtcclxuICAgIHJldHVybiBPYmplY3Qua2V5cyh2YXJzKS5tYXAoKGtleSkgPT4gYCR7a2V5fT0ke3ZhcnNba2V5XX1gKS5qb2luKCcsJyk7XHJcbn1cclxuZnVuY3Rpb24gY291bnQocGlkLCBjaWQsIHBhdGgsIHZhcnMpIHtcclxuICAgIGNvbnN0IHVybCA9IGAke1NUQVRfVVJMfS9jb3VudGVyYDtcclxuICAgIGNvbnN0IGRhdGEgPSBgL2R0eXBlPXN0cmVkL3BpZD0ke3BpZH0vY2lkPSR7Y2lkfWAgK1xyXG4gICAgICAgIGAvcGF0aD0ke3BhdGguam9pbignLicpfS8ke3ZhcnMgPyBgdmFycz0ke3N0cmluZ2lmeVZhcnModmFycyl9L2AgOiAnJ31gO1xyXG4gICAgaWYgKCEobmF2aWdhdG9yLnNlbmRCZWFjb24gJiYgbmF2aWdhdG9yLnNlbmRCZWFjb24odXJsLCBkYXRhICsgJyonKSkpIHtcclxuICAgICAgICBjb25zdCBpbWFnZSA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICAgIGltYWdlLnNyYyA9IHVybCArIGRhdGEgKyBgcm5kPSR7RGF0ZS5ub3coKX0ke01hdGgucmFuZG9tKCkgKiAxMDAgfCAwfS8qYDtcclxuICAgIH1cclxufVxyXG5jb25zdCBQRVJGX0NPVU5URVJfSUQgPSA3MzMyMztcclxuLyoqXHJcbiAqIExvZyB1c2VyJ3MgcmVuZGVyaW5nIHBlcmYgdG8gc3RhdGZhY2UuXHJcbiAqXHJcbiAqIEBwYXJhbSBmcHMgRlBTXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY291bnRGcHMoZnBzKSB7XHJcbiAgICBjb25zdCByb3VuZGVkRnBzID0gTWF0aC5mbG9vcihmcHMgLyAxMCkgKiAxMDtcclxuICAgIGNvdW50KFBST0pFQ1RfSUQsIFBFUkZfQ09VTlRFUl9JRCwgWydmcHMnLCBgJHtyb3VuZGVkRnBzfS0ke3JvdW5kZWRGcHMgKyAxMH1gLCAoZnBzICogMTAwKS50b0ZpeGVkKCldKTtcclxufVxyXG5mdW5jdGlvbiBlbmNvZGVUaWxlSXRlbSh0aWxlSXRlbSkge1xyXG4gICAgcmV0dXJuIGAke3RpbGVJdGVtLnh9LiR7dGlsZUl0ZW0ueX0uJHt0aWxlSXRlbS56b29tfWA7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGNvdW50VGlsZVBhcnNlVGltZShsYXllciwgbWluVGltZVRpbGUsIG1pblRpbWUsIG1heFRpbWVUaWxlLCBtYXhUaW1lLCBtZWRpYW5UaW1lVGlsZSwgbWVkaWFuVGltZSkge1xyXG4gICAgY291bnQoUFJPSkVDVF9JRCwgUEVSRl9DT1VOVEVSX0lELCBbXHJcbiAgICAgICAgJ3RpbGVfcGFyc2UnLFxyXG4gICAgICAgIGxheWVyXHJcbiAgICBdLCB7XHJcbiAgICAgICAgbWluVGltZTogbWluVGltZS50b0ZpeGVkKCksXHJcbiAgICAgICAgbWVkaWFuVGltZTogbWVkaWFuVGltZS50b0ZpeGVkKCksXHJcbiAgICAgICAgbWF4VGltZTogbWF4VGltZS50b0ZpeGVkKCksXHJcbiAgICAgICAgbWluVGlsZUl0ZW06IGVuY29kZVRpbGVJdGVtKG1pblRpbWVUaWxlKSxcclxuICAgICAgICBtZWRpYW5UaWxlSXRlbTogZW5jb2RlVGlsZUl0ZW0obWVkaWFuVGltZVRpbGUpLFxyXG4gICAgICAgIG1heFRpbGVJdGVtOiBlbmNvZGVUaWxlSXRlbShtYXhUaW1lVGlsZSlcclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBjb3VudFRpbGVQcm9jZXNzaW5nVGltZShsYXllciwgaXRlbXMpIHtcclxuICAgIGNvbnN0IHZhcnNUb0xvZyA9IHt9O1xyXG4gICAgaXRlbXMuZm9yRWFjaCgoaXRlbSkgPT4ge1xyXG4gICAgICAgIGlmIChpdGVtLnpvb20gPT09ICdhdmVyYWdlJykge1xyXG4gICAgICAgICAgICBjb3VudChQUk9KRUNUX0lELCBQRVJGX0NPVU5URVJfSUQsIFtcclxuICAgICAgICAgICAgICAgICd0aWxlX3Byb2Nlc3NpbmdfYXZlcmFnZScsXHJcbiAgICAgICAgICAgICAgICBsYXllcixcclxuICAgICAgICAgICAgICAgIChNYXRoLmNlaWwoaXRlbS50aW1lIC8gMjUwKSAqIDI1MCkudG9TdHJpbmcoKVxyXG4gICAgICAgICAgICBdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyc1RvTG9nW2l0ZW0uem9vbV0gPSBpdGVtLnRpbWUudG9GaXhlZCgpO1xyXG4gICAgfSk7XHJcbiAgICBjb3VudChQUk9KRUNUX0lELCBQRVJGX0NPVU5URVJfSUQsIFsndGlsZV9wcm9jZXNzaW5nJywgbGF5ZXJdLCB2YXJzVG9Mb2cpO1xyXG59XHJcbiIsImltcG9ydCB7IEF0dHJpYnV0ZU1hcHBpbmcgfSBmcm9tICcuLi8uLi9yZW5kZXIvYXR0cmliX21hcHBpbmcnO1xyXG5pbXBvcnQgQnVmZmVyV3JpdGVyIGZyb20gJy4uLy4uL3V0aWwvYnVmZmVyX3dyaXRlcic7XHJcbi8qKlxyXG4gKiBXcml0ZXIgb2YgZ2VvbWV0cnkgZGF0YSBvZiBpY29ucy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEljb25CdWZmZXJXcml0ZXIgZXh0ZW5kcyBCdWZmZXJXcml0ZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoSWNvbkJ1ZmZlcldyaXRlci5BVFRSSUJVVEVfTUFQUElORy52ZXJ0ZXhCeXRlU2l6ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhbiBpY29uIHRvIGJ1ZmZlcnMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGljb24gSWNvbiB0byBiZSB3cml0dGVuIHRvIGJ1ZmZlci5cclxuICAgICAqIEBwYXJhbSBsb2NhdGlvbiBJbWFnZSBsb2NhdGlvbiBpbiBhdGxhcy5cclxuICAgICAqIEBwYXJhbSBzaXplIEltYWdlIHNpemUgaW4gYXRsYXMuXHJcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IE9mZnNldCBvZiBpbWFnZSBwb2ludHMgaW4gQ1NTIHBpeGVscy5cclxuICAgICAqIEBwYXJhbSBwaXhlbFJhdGlvIFJhdGlvIG9mIGltYWdlIHNpemUgaW4gQ1NTIHBpeGVscyB0byB0aGUgc2l6ZSBpbiBhdGxhcyBwaXhlbHMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgTG9jYXRpb24gb2YgdGhlIGljb24gZGF0YSBpbiBidWZmZXJzLlxyXG4gICAgICovXHJcbiAgICB3cml0ZUljb24oaWNvbiwgbG9jYXRpb24sIHNpemUsIG9mZnNldCwgcGl4ZWxSYXRpbykge1xyXG4gICAgICAgIGNvbnN0IHRvcCA9IG9mZnNldC55O1xyXG4gICAgICAgIGNvbnN0IGJvdHRvbSA9IG9mZnNldC55ICsgc2l6ZS5oZWlnaHQgKiBwaXhlbFJhdGlvO1xyXG4gICAgICAgIGNvbnN0IGxlZnQgPSBvZmZzZXQueDtcclxuICAgICAgICBjb25zdCByaWdodCA9IG9mZnNldC54ICsgc2l6ZS53aWR0aCAqIHBpeGVsUmF0aW87XHJcbiAgICAgICAgdGhpcy53cml0ZVZlcnRleChpY29uLnBvc2l0aW9uLCBsZWZ0LCBib3R0b20sIGxvY2F0aW9uLm1pblgsIGxvY2F0aW9uLm1pblkpO1xyXG4gICAgICAgIHRoaXMud3JpdGVWZXJ0ZXgoaWNvbi5wb3NpdGlvbiwgbGVmdCwgdG9wLCBsb2NhdGlvbi5taW5YLCBsb2NhdGlvbi5tYXhZKTtcclxuICAgICAgICB0aGlzLndyaXRlVmVydGV4KGljb24ucG9zaXRpb24sIHJpZ2h0LCBib3R0b20sIGxvY2F0aW9uLm1heFgsIGxvY2F0aW9uLm1pblkpO1xyXG4gICAgICAgIHRoaXMud3JpdGVWZXJ0ZXgoaWNvbi5wb3NpdGlvbiwgcmlnaHQsIHRvcCwgbG9jYXRpb24ubWF4WCwgbG9jYXRpb24ubWF4WSk7XHJcbiAgICAgICAgdGhpcy53cml0ZUluZGljZXNGb3JDb250aW51b3VzU3RyaXAoNCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kTWVzaCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYSB2ZXJ0ZXggdG8gdGhlIHZlcnRleCBidWZmZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBvc2l0aW9uIFBvc2l0aW9uIG9mIHRoZSB2ZXJ0ZXggaW4gZGlzcGxheSBjb29yZGluYXRlcy5cclxuICAgICAqIEBwYXJhbSB1diBVVnMgb2YgdGhlIHZlcnRleC5cclxuICAgICAqIEByZXR1cm4gSW5kZXggb2YgdGhlIHdyaXR0ZW4gdmVydGV4LlxyXG4gICAgICovXHJcbiAgICB3cml0ZVZlcnRleChwb3NpdGlvbiwgZGlzcGxhY2VtZW50WCwgZGlzcGxhY2VtZW50WSwgdXZYLCB1dlkpIHtcclxuICAgICAgICBjb25zdCB2ZXJ0ZXhJZHggPSB0aGlzLmdldEN1cnJlbnRWZXJ0ZXhJZHgoKTtcclxuICAgICAgICB0aGlzLl93cml0ZVdvcmxkQ29vcmRpbmF0ZShwb3NpdGlvbik7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVIYWxmV29yZHMoZGlzcGxhY2VtZW50WCwgZGlzcGxhY2VtZW50WSk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVIYWxmV29yZHModXZYLCB1dlkpO1xyXG4gICAgICAgIHJldHVybiB2ZXJ0ZXhJZHg7XHJcbiAgICB9XHJcbn1cclxuLyoqIERlc2NyaXB0aW9uIG9mIGhvdyBhIHdyaXRlciBzdG9yZXMgdmVydGV4IGRhdGEuICovXHJcbkljb25CdWZmZXJXcml0ZXIuQVRUUklCVVRFX01BUFBJTkcgPSBuZXcgQXR0cmlidXRlTWFwcGluZyhbXHJcbiAgICBbXHJcbiAgICAgICAgMCAvKiBQT1NJVElPTl9ISUdIICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMixcclxuICAgICAgICAgICAgdHlwZTogNTEyMyAvKiBVTlNJR05FRF9TSE9SVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgMSAvKiBQT1NJVElPTl9MT1cgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIzIC8qIFVOU0lHTkVEX1NIT1JUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICA2IC8qIERJU1BMQUNFTUVOVCAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDIsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjIgLyogU0hPUlQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICA0IC8qIFVWICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMixcclxuICAgICAgICAgICAgdHlwZTogNTEyMyAvKiBVTlNJR05FRF9TSE9SVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICBdXHJcbl0pO1xyXG4iLCJpbXBvcnQgeyBmbG9hdFRvVWludDMyIH0gZnJvbSAnLi9ncHV0eXBlcyc7XHJcbmltcG9ydCB7IHppcCB9IGZyb20gJy4vYXJyYXknO1xyXG5leHBvcnQgY29uc3QgV09SRF9CWVRFX1NJWkUgPSA0O1xyXG4vKipcclxuICogR2VuZXJhdGVzIHRyaWFuZ2xlcyBvZiBhIGZhbiBvZiBhIGdpdmVuIGxlbmd0aCBhcyBpZiBpdCBpcyBjb250aW51b3VzIGFuZFxyXG4gKiBzdGFydHMgd2l0aCAwLlxyXG4gKlxyXG4gKiBAcGFyYW0gY291bnQgTnVtYmVyIG9mIHZlcnRpY2VzIGluIHRoZSBmYW4uXHJcbiAqIEByZXR1cm5zIEl0ZXJhdG9yIG92ZXIgaW5kaWNlcyBvZiB0cmlhbmdsZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiogZ2VuZXJhdGVGYW4oY291bnQpIHtcclxuICAgIGZvciAobGV0IGkgPSAyOyBpIDwgY291bnQ7ICsraSkge1xyXG4gICAgICAgIHlpZWxkIDA7XHJcbiAgICAgICAgeWllbGQgaSAtIDE7XHJcbiAgICAgICAgeWllbGQgaTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogR2VuZXJhdGVzIHRyaWFuZ2xlcyBvZiBhIHN0cmlwIG9mIGEgZ2l2ZW4gbGVuZ3RoIGFzIGlmIGl0IGlzIGNvbnRpbnVvdXMgYW5kXHJcbiAqIHN0YXJ0cyB3aXRoIDAuXHJcbiAqXHJcbiAqIEBwYXJhbSBjb3VudCBOdW1iZXIgb2YgdmVydGljZXMgaW4gdGhlIGZhbi5cclxuICogQHJldHVybnMgSXRlcmF0b3Igb3ZlciBpbmRpY2VzIG9mIHRyaWFuZ2xlcy5cclxuICovXHJcbmZ1bmN0aW9uKiBnZW5lcmF0ZVN0cmlwKGNvdW50KSB7XHJcbiAgICB5aWVsZCAwO1xyXG4gICAgeWllbGQgMTtcclxuICAgIHlpZWxkIDI7XHJcbiAgICBsZXQgb2Zmc2V0MCA9IDE7XHJcbiAgICBsZXQgb2Zmc2V0MSA9IDI7XHJcbiAgICBmb3IgKGxldCBpID0gMzsgaSA8IGNvdW50OyArK2kpIHtcclxuICAgICAgICB5aWVsZCBpIC0gb2Zmc2V0MDtcclxuICAgICAgICB5aWVsZCBpIC0gb2Zmc2V0MTtcclxuICAgICAgICB5aWVsZCBpO1xyXG4gICAgICAgIGNvbnN0IHRtcCA9IG9mZnNldDA7XHJcbiAgICAgICAgb2Zmc2V0MCA9IG9mZnNldDE7XHJcbiAgICAgICAgb2Zmc2V0MSA9IHRtcDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVmVydGV4IGJ1ZmZlciBoZWxwZXIgY2xhc3MsIHRoYXQgc3VwcG9ydHMgc2VxdWVudGlhbCB3cml0aW5nIGludGVyZmFjZSBhbmQgdGFrZXMgb3ZlciBzb21lIHNpbmdsZS1idWZmZXIgb3BlcmF0aW9ucy5cclxuICogSXQgaXMgYW4gaW50ZWdyYWwgcGFydCBvZiB0aGUgYnVmZmVyIHdyaXRlciBjbGFzcyBhbmQgaXRzIG1haW4gcHVycG9zZSBpcyB0byBtYWtlIHRoZSB3cml0ZXIncyBjb2RlIGVhc2llci5cclxuICovXHJcbmNsYXNzIFZlcnRleEJ1ZmZlciB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBieXRlU2l6ZSBJbml0aWFsIHNpemUgb2YgdGhlIGJ1ZmZlciBpbiBieXRlcy4gQXMgaXQgZ2V0cyBmaWxsZWQgYnkgd29yZHNcclxuICAgICAqICAgICAgdGhlIHNpemUgbXVzdCBiZSBhIG11bHRpcGx5IG9mIDQuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGJ5dGVTaXplKSB7XHJcbiAgICAgICAgdGhpcy5fbmV4dFdvcmRPZmZzZXQgPSAwO1xyXG4gICAgICAgIHRoaXMuX2luaXRCdWZmZXJzKGJ5dGVTaXplKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGVyZSBpcyBubyBmcmVlIHNwYWNlIHJlbWFpbmluZyBpbiBidWZmZXIuXHJcbiAgICAgKi9cclxuICAgIGdldCBpc0Z1bGwoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX25leHRXb3JkT2Zmc2V0ID49IHRoaXMuX3VpbnQzMlZpZXcubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIHdvcmRzICg0IGJ5dGVzIHZhbHVlcykgYWxyZWFkeSB3cml0dGVuLlxyXG4gICAgICovXHJcbiAgICBnZXQgb2NjdXBpZWRTaXplKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9uZXh0V29yZE9mZnNldDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiBNYXggbnVtYmVyIG9mIGJ5dGVzIHRoaXMgYnVmZmVyIGlzIGFibGUgdG8gc3RvcmUuIEl0IGNhbiBiZSBpbmNyZWFzZWQgYnkgdGhlIGV4dGVuZCgpIG1ldGhvZC5cclxuICAgICAqL1xyXG4gICAgZ2V0IGJ5dGVTaXplKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl91aW50MzJWaWV3LmJ5dGVMZW5ndGg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEV4dGVuZHMgYnVmZmVyIHRvIHRoZSBuZXcgc2l6ZS4gVGhlIG5ldyBzaXplIG11c3QgYmUgbm90IGxlc3MgdGhhbiBjdXJyZW50IG9uZSBhbmQgaXQgbXVzdCBiZSBhIG11bHRpcGx5IG9mIDQuXHJcbiAgICAgKi9cclxuICAgIGV4dGVuZChuZXdCeXRlU2l6ZSkge1xyXG4gICAgICAgIC8vIFRPRE8gYXNzZXJ0IG5ld0J5dGVMZW5ndGggaXMgbGFyZ2VyIHRoYW4gY3VycmVudCBfYXJyYXlCdWZmZXIgYW5kIGl0cyBpcyBhIG11bHRpcGx5IG9mIHRoZSB3b3JkIHNpemUuXHJcbiAgICAgICAgY29uc3Qgb2xkVWludDMyVmlldyA9IHRoaXMuX3VpbnQzMlZpZXc7XHJcbiAgICAgICAgdGhpcy5faW5pdEJ1ZmZlcnMobmV3Qnl0ZVNpemUpO1xyXG4gICAgICAgIHRoaXMuX3VpbnQzMlZpZXcuc2V0KG9sZFVpbnQzMlZpZXcpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBlbmRzIHZhbHVlIGFzIGEgdWludDMyIG51bWJlci5cclxuICAgICAqL1xyXG4gICAgcHVzaFVpbnQzMih2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX3VpbnQzMlZpZXdbdGhpcy5fbmV4dFdvcmRPZmZzZXQrK10gPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXBwZW5kcyB2YWx1ZSBhcyBhIGZsb2F0MzIgbnVtYmVyLlxyXG4gICAgICovXHJcbiAgICBwdXNoRmxvYXQzMih2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX2Zsb2F0MzJWaWV3W3RoaXMuX25leHRXb3JkT2Zmc2V0KytdID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIHVpbnQ4IHZpZXcgb2YgdGhpcyBidWZmZXIuIFRoZSBzaXplIG9mIHRoZSB2aWV3IG1hdGNoZXMgdGhlIGFtb3VudCBvZiB3cml0dGVuIGRhdGEuXHJcbiAgICAgKi9cclxuICAgIGFzVWludDMyQXJyYXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VpbnQzMlZpZXcuc3ViYXJyYXkoMCwgdGhpcy5vY2N1cGllZFNpemUpO1xyXG4gICAgfVxyXG4gICAgX2luaXRCdWZmZXJzKGJ5dGVMZW5ndGgpIHtcclxuICAgICAgICBjb25zdCBhcnJheUJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihieXRlTGVuZ3RoKTtcclxuICAgICAgICB0aGlzLl91aW50MzJWaWV3ID0gbmV3IFVpbnQzMkFycmF5KGFycmF5QnVmZmVyKTtcclxuICAgICAgICB0aGlzLl9mbG9hdDMyVmlldyA9IG5ldyBGbG9hdDMyQXJyYXkoYXJyYXlCdWZmZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBNb3ZlcyBcInRhaWxcIiBkYXRhIChmcm9tIHRoZSBvZmZzZXQgc3BlY2lmaWVkIHRvIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlcikgb2Ygb25lIGJ1ZmZlciB0byBhbm90aGVyLiBUaGUgY3Vyc29ycyBvZlxyXG4gICAgICogYnVmZmVycyB3aWxsIGJlIGFwcHJvcHJpYXRlbHkgdXBkYXRlZCB0byByZWZsZWN0IGRhdGEgY2hhbmdlcy5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHRyYW5zZmVyRGF0YVRhaWwoc3JjLCBkc3QsIHNyY1dvcmRPZmZzZXQsIGRzdE9mZnNldCA9IDApIHtcclxuICAgICAgICBjb25zdCB0YWlsTGVuZ3RoID0gc3JjLm9jY3VwaWVkU2l6ZSAtIHNyY1dvcmRPZmZzZXQ7XHJcbiAgICAgICAgY29uc3Qgc3JjVGFpbCA9IHNyYy5fdWludDMyVmlldy5zdWJhcnJheShzcmNXb3JkT2Zmc2V0LCBzcmMub2NjdXBpZWRTaXplKTtcclxuICAgICAgICBkc3QuX3VpbnQzMlZpZXcuc2V0KHNyY1RhaWwsIGRzdE9mZnNldCk7XHJcbiAgICAgICAgZHN0Ll9uZXh0V29yZE9mZnNldCA9IHRhaWxMZW5ndGg7XHJcbiAgICAgICAgc3JjLl9uZXh0V29yZE9mZnNldCA9IHNyY1dvcmRPZmZzZXQ7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEluZGV4IGJ1ZmZlciBoZWxwZXIgY2xhc3MsIHRoYXQgc3VwcG9ydHMgc2VxdWVudGlhbCB3cml0aW5nIGludGVyZmFjZSBhbmQgdGFrZXMgb3ZlciBzb21lIHNpbmdsZS1idWZmZXIgb3BlcmF0aW9ucy5cclxuICogSXQgaXMgYW4gaW50ZWdyYWwgcGFydCBvZiB0aGUgYnVmZmVyIHdyaXRlciBjbGFzcyBhbmQgaXRzIG1haW4gcHVycG9zZSBpcyB0byBtYWtlIHRoZSB3cml0ZXIncyBjb2RlIGVhc2llci5cclxuICovXHJcbmNsYXNzIEluZGV4QnVmZmVyIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHNpemUgSW5pdGlhbCBzaXplIG9mIHRoZSBidWZmZXIuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHNpemUpIHtcclxuICAgICAgICB0aGlzLl9uZXh0SW5kZXhPZmZzZXQgPSAwO1xyXG4gICAgICAgIHRoaXMuX3VpbnQxNlZpZXcgPSBuZXcgVWludDE2QXJyYXkoc2l6ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgaW5kaWNlcyBhbHJlYWR5IHdyaXR0ZW4uXHJcbiAgICAgKi9cclxuICAgIGdldCBvY2N1cGllZFNpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX25leHRJbmRleE9mZnNldDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiBNYXggbnVtYmVyIG9mIGluZGljZXMgdGhpcyBidWZmZXIgaXMgYWJsZSB0byBzdG9yZS4gSXQgY2FuIGJlIGluY3JlYXNlZCBieSB0aGUgZXh0ZW5kKCkgbWV0aG9kLlxyXG4gICAgICovXHJcbiAgICBnZXQgc2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdWludDE2Vmlldy5sZW5ndGg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEV4dGVuZHMgYnVmZmVyIHRvIHRoZSBuZXcgc2l6ZS5cclxuICAgICAqL1xyXG4gICAgZXh0ZW5kKG5ld1NpemUpIHtcclxuICAgICAgICAvLyBUT0RPIGFzc2VydCBuZXdCeXRlTGVuZ3RoIGlzIGxhcmdlciB0aGFuIGN1cnJlbnQgX2FycmF5QnVmZmVyXHJcbiAgICAgICAgY29uc3Qgb2xkVWludDE2VmlldyA9IHRoaXMuX3VpbnQxNlZpZXc7XHJcbiAgICAgICAgdGhpcy5fdWludDE2VmlldyA9IG5ldyBVaW50MTZBcnJheShuZXdTaXplKTtcclxuICAgICAgICB0aGlzLl91aW50MTZWaWV3LnNldChvbGRVaW50MTZWaWV3KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXBwZW5kcyBpbmRleCB0byB0aGUgZW5kIG9mIHRoZSBidWZmZXIuXHJcbiAgICAgKi9cclxuICAgIHB1c2goaW5kZXgpIHtcclxuICAgICAgICB0aGlzLl91aW50MTZWaWV3W3RoaXMuX25leHRJbmRleE9mZnNldCsrXSA9IGluZGV4O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyB1aW50MTYgdmlldyBvZiB0aGlzIGJ1ZmZlci4gVGhlIHNpemUgb2YgdGhlIHZpZXcgbWF0Y2hlcyB0aGUgYW1vdW50IG9mIHdyaXR0ZW4gZGF0YS5cclxuICAgICAqL1xyXG4gICAgYXNVaW50MTZBcnJheSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQxNkFycmF5KHRoaXMuX3VpbnQxNlZpZXcuYnVmZmVyLCAwLCB0aGlzLm9jY3VwaWVkU2l6ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE1vdmVzIFwidGFpbFwiIGRhdGEgKGZyb20gdGhlIG9mZnNldCBzcGVjaWZpZWQgdG8gdGhlIGVuZCBvZiB0aGUgYnVmZmVyKSBvZiBvbmUgYnVmZmVyIHRvIGFub3RoZXIuIFRoZSBvZmZzZXRzIG9mXHJcbiAgICAgKiBidWZmZXJzIHdpbGwgYmUgYXBwcm9wcmlhdGVseSB1cGRhdGVkIHRvIHJlZmxlY3QgZGF0YSBjaGFuZ2VzLlxyXG4gICAgICogYmFzZUluZGV4IHdpbGwgYmUgZGVkdWN0ZWQgZnJvbSBhbGwgbW92ZWQgaW5kaWNlcy5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHRyYW5zZmVyRGF0YVRhaWwoc3JjLCBkc3QsIGJhc2VJbmRleCwgc3JjT2Zmc2V0LCBkc3RPZmZzZXQgPSAwKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IHNyY09mZnNldCwgaiA9IGRzdE9mZnNldDsgaSA8IHNyYy5vY2N1cGllZFNpemU7IGkrKywgaisrKSB7XHJcbiAgICAgICAgICAgIGRzdC5fdWludDE2Vmlld1tqXSA9IHNyYy5fdWludDE2Vmlld1tpXSAtIGJhc2VJbmRleDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZHN0Ll9uZXh0SW5kZXhPZmZzZXQgPSBzcmMub2NjdXBpZWRTaXplIC0gc3JjT2Zmc2V0O1xyXG4gICAgICAgIHNyYy5fbmV4dEluZGV4T2Zmc2V0ID0gc3JjT2Zmc2V0O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBCYXNlIGJ1ZmZlciB3cml0ZXIgaW1wbGVtZW50YXRpb24uIENhbiB3cml0ZSB1bnNpZ25lZCBzaG9ydCBpbmRpY2VzIGFuZFxyXG4gKiBwcm92aWRlcyBmYWNpbGl0aWVzIGZvciBjaGlsZCBjbGFzc2VzIHRvIGhhbmRsZSB3cml0aW5nIHZlcnRleCBkYXRhLiBEZWZpbmVzXHJcbiAqIGEgY29uY2VwdCBvZiBjdXJyZW50IG1lc2guIEJhc2ljYWxseSwgaXQgbWVhbiB0aGF0IGFsbCB2ZXJ0aWNlcyBhbmQgaW5kaWNlc1xyXG4gKiB3cml0dGVuIHRvIGEgd3JpdGVyIGJldHdlZW4gdHdvIGBlbmRNZXNoYCBjYWxscyAob3IgY29uc3RydWN0aW9uIG9mIHRoZSB3cml0ZXJcclxuICogYW5kIGFuIGBlbmRNZXNoYCBjYWxsKSBtdXN0IGJlIGNvbnNpZGVyZWQgYmVsb25naW5nIHRvIG9uZSBhdG9taWMgcGllY2Ugb2ZcclxuICogZ2VvbWV0cnkgYW5kIHNob3VsZCBub3QgYmUgc3BpdHRlZCBiZXR3ZWVuIHNlcGFyYXRlIGJ1ZmZlcnMuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCdWZmZXJXcml0ZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHdyaXRlciBhbmQgYWxsb2NhdGVzIGluaXRpYWwgYW1vdW50IG9mIG1lbW9yeSB0byBzdG9yZSBkYXRhLlxyXG4gICAgICogQWxzbyBpbXBsaWNpdGx5IFwic3RhcnRcIiBhIG1lc2guXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZlcnRleEJ5dGVTaXplXHJcbiAgICAgKiBAcGFyYW0gaW5pdFZlcnRleEJ1ZmZlclNpemUgSW5pdCBzaXplIChpbiB2ZXJ0aWNlcykgb2YgZ3Jvd2luZyB2ZXJ0ZXggYnVmZmVycy5cclxuICAgICAqIEBwYXJhbSBtYXhWZXJ0ZXhCdWZmZXJTaXplIE1heCBzaXplIChpbiB2ZXJ0aWNlcykgb2YgdmVydGV4IGJ1ZmZlcnMuXHJcbiAgICAgKiBAcGFyYW0gaW5pdEluZGV4QnVmZmVyVWludDE2U2l6ZSBJbml0IHNpemUgKGluIHVpbnQxNiBudW1iZXIpIG9mIGdyb3dpbmcgaW5kZXggYnVmZmVycy5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IodmVydGV4Qnl0ZVNpemUsIGluaXRWZXJ0ZXhCdWZmZXJTaXplID0gMHg0MDAsIG1heFZlcnRleEJ1ZmZlclNpemUgPSAweDEwMDAwLCBpbml0SW5kZXhCdWZmZXJVaW50MTZTaXplID0gMHhjMDApIHtcclxuICAgICAgICB0aGlzLl92ZXJ0ZXhCeXRlU2l6ZSA9IHZlcnRleEJ5dGVTaXplO1xyXG4gICAgICAgIHRoaXMuX2luaXRWZXJ0ZXhCdWZmZXJCeXRlU2l6ZSA9IHZlcnRleEJ5dGVTaXplICogaW5pdFZlcnRleEJ1ZmZlclNpemU7XHJcbiAgICAgICAgdGhpcy5fbWF4VmVydGV4QnVmZmVyQnl0ZVNpemUgPSB2ZXJ0ZXhCeXRlU2l6ZSAqIG1heFZlcnRleEJ1ZmZlclNpemU7XHJcbiAgICAgICAgdGhpcy5faW5pdEluZGV4QnVmZmVyVWludDE2U2l6ZSA9IGluaXRJbmRleEJ1ZmZlclVpbnQxNlNpemU7XHJcbiAgICAgICAgdGhpcy5fdmVydGV4QnVmZmVyID0gbmV3IFZlcnRleEJ1ZmZlcih0aGlzLl9pbml0VmVydGV4QnVmZmVyQnl0ZVNpemUpO1xyXG4gICAgICAgIHRoaXMuX3ZlcnRleEJ1ZmZlcnMgPSBbdGhpcy5fdmVydGV4QnVmZmVyXTtcclxuICAgICAgICB0aGlzLl9pbmRleEJ1ZmZlciA9IG5ldyBJbmRleEJ1ZmZlcih0aGlzLl9pbml0SW5kZXhCdWZmZXJVaW50MTZTaXplKTtcclxuICAgICAgICB0aGlzLl9pbmRleEJ1ZmZlcnMgPSBbdGhpcy5faW5kZXhCdWZmZXJdO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRNZXNoVmVydGV4T2Zmc2V0ID0gMDtcclxuICAgICAgICB0aGlzLl9jdXJyZW50TWVzaEluZGV4T2Zmc2V0ID0gMDtcclxuICAgICAgICB0aGlzLl9jdXJyZW50TWVzaEJhc2VJbmRleCA9IDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIGJ1bmNoIG9mIGluZGljZXMgdG8gdGhlIHVuZGVybHlpbmcgc3RvcmFnZSBhcyB1bnNpZ25lZCBzaG9ydFxyXG4gICAgICogbnVtYmVycy4gSWYgY3VycmVudCBzdG9yYWdlIGRvZXNuJ3QgaGF2ZSBlbm91Z2ggc3BhY2UgdG8gYWNjb21tb2RhdGVcclxuICAgICAqIGdpdmVuIGluZGljZXMsIHRoZSB3cml0ZXIgd2lsbCBhdXRvbWF0aWNhbGx5IHJlc2l6ZSBpdC4gVGhlIHdyaXRlclxyXG4gICAgICogYXV0b21hdGljYWxseSBhZGRzIGJhc2UgaW5kZXggdG8gdGhlIHN1cHBsaWVkIHZhbHVlcywgc28gZnJvbSBhIHVzZXJcclxuICAgICAqIHBvaW50IG9mIHZpZXcgZmlyc3QgdmVydGV4IG9mIGEgbWVzaCBoYXMgaW5kZXggMCBhbmQgdGhlcmUncyBubyBuZWVkXHJcbiAgICAgKiB0byB0YWtlIGludG8gYWNjb3VudCBpdCdzIG9mZnNldCB3aGlsZSBnZW5lcmF0aW5nIG1lc2gncyB0b3BvbG9neS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaW5kaWNlcyBBcnJheSBvZiBpbmRpY2VzIHRvIHdyaXRlLlxyXG4gICAgICovXHJcbiAgICB3cml0ZUluZGljZXMoaW5kaWNlcykge1xyXG4gICAgICAgIHRoaXMuX2Vuc3VyZUVub3VnaEluZGV4QnVmZmVyU3BhY2UoaW5kaWNlcy5sZW5ndGgpO1xyXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuX2luZGV4QnVmZmVyO1xyXG4gICAgICAgIGNvbnN0IGJhc2VJbmRleCA9IHRoaXMuX2N1cnJlbnRNZXNoQmFzZUluZGV4O1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kaWNlcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBidWZmZXIucHVzaChiYXNlSW5kZXggKyBpbmRpY2VzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlcyB0cmlhbmdsZSBpbmRpY2VzIGZyb20gYW4gYXJyYXkgb2YgaW5kaWNlcyBvZiBhIHRyaWFuZ2xlIHN0cmlwXHJcbiAgICAgKiAoYXMgaW4gR0wpIGFuZCB3cml0ZXMgZ2VuZXJhdGVkIHRyaXBsZXRzIHRvIHRoZSBtYW5hZ2VkIGluZGV4IGJ1ZmZlci5cclxuICAgICAqIEBzZWUgT3BlbkdMIEVTIDIuMCBTcGVjLCDCpzIuNi4xXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGluZGljZXMgSW5kaWNlcyBvZiB0aGUgc3RyaXAuXHJcbiAgICAgKi9cclxuICAgIHdyaXRlSW5kaWNlc0ZvclN0cmlwKGluZGljZXMpIHtcclxuICAgICAgICB0aGlzLl9lbnN1cmVFbm91Z2hJbmRleEJ1ZmZlclNwYWNlKDMgKiAoaW5kaWNlcy5sZW5ndGggLSAyKSk7XHJcbiAgICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5faW5kZXhCdWZmZXI7XHJcbiAgICAgICAgY29uc3QgYmFzZUluZGV4ID0gdGhpcy5fY3VycmVudE1lc2hCYXNlSW5kZXg7XHJcbiAgICAgICAgZm9yIChjb25zdCBpIG9mIGdlbmVyYXRlU3RyaXAoaW5kaWNlcy5sZW5ndGgpKSB7XHJcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoKGJhc2VJbmRleCArIGluZGljZXNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJhdGVzIHRyaWFuZ2xlIGluZGljZXMgZnJvbSBhIGNvbnRpbnVvdXMgdHJpYW5nbGUgc3RyaXAgb2YgYSBnaXZlblxyXG4gICAgICogbGVuZ3RoIGFuZCB3cml0ZXMgZ2VuZXJhdGVkIHRyaXBsZXRzIHRvIG1hbmFnZWQgaW5kZXggYnVmZmVyLlxyXG4gICAgICogQHNlZSBPcGVuR0wgRVMgMi4wIFNwZWMsIMKnMi42LjFcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaW5kZXhDb3VudFxyXG4gICAgICogQHBhcmFtIGJhc2VJbmRleEluTWVzaFxyXG4gICAgICovXHJcbiAgICB3cml0ZUluZGljZXNGb3JDb250aW51b3VzU3RyaXAoaW5kZXhDb3VudCwgYmFzZUluZGV4SW5NZXNoID0gMCkge1xyXG4gICAgICAgIHRoaXMuX2Vuc3VyZUVub3VnaEluZGV4QnVmZmVyU3BhY2UoMyAqIChpbmRleENvdW50IC0gMikpO1xyXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuX2luZGV4QnVmZmVyO1xyXG4gICAgICAgIGNvbnN0IGJhc2VJbmRleCA9IHRoaXMuX2N1cnJlbnRNZXNoQmFzZUluZGV4ICsgYmFzZUluZGV4SW5NZXNoO1xyXG4gICAgICAgIGZvciAoY29uc3QgaSBvZiBnZW5lcmF0ZVN0cmlwKGluZGV4Q291bnQpKSB7XHJcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoKGJhc2VJbmRleCArIGkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJhdGVzIHRyaWFuZ2xlIGluZGljZXMgZnJvbSBhbiBhcnJheSBvZiBpbmRpY2VzIG9mIGEgdHJpYW5nbGUgZmFuIChhc1xyXG4gICAgICogaW4gR0wpIGFuZCB3cml0ZXMgZ2VuZXJhdGVkIHRyaXBsZXRzIHRvIHRoZSBtYW5hZ2VkIGluZGV4IGJ1ZmZlci5cclxuICAgICAqIEBzZWUgT3BlbkdMIEVTIDIuMCBTcGVjLCDCpzIuNi4xXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGluZGljZXMgSW5kaWNlcyBvZiB0aGUgc3RyaXAuXHJcbiAgICAgKi9cclxuICAgIHdyaXRlSW5kaWNlc0ZvckZhbihpbmRpY2VzKSB7XHJcbiAgICAgICAgdGhpcy5fZW5zdXJlRW5vdWdoSW5kZXhCdWZmZXJTcGFjZSgzICogKGluZGljZXMubGVuZ3RoIC0gMikpO1xyXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuX2luZGV4QnVmZmVyO1xyXG4gICAgICAgIGNvbnN0IGJhc2VJbmRleCA9IHRoaXMuX2N1cnJlbnRNZXNoQmFzZUluZGV4O1xyXG4gICAgICAgIGZvciAoY29uc3QgaSBvZiBnZW5lcmF0ZUZhbihpbmRpY2VzLmxlbmd0aCkpIHtcclxuICAgICAgICAgICAgYnVmZmVyLnB1c2goYmFzZUluZGV4ICsgaW5kaWNlc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZXMgdHJpYW5nbGUgaW5kaWNlcyBmcm9tIGEgY29udGludW91cyB0cmlhbmdsZSBmYW4gb2YgYSBnaXZlbiBsZW5ndGhcclxuICAgICAqIGFuZCB3cml0ZXMgZ2VuZXJhdGVkIHRyaXBsZXRzIHRvIG1hbmFnZWQgaW5kZXggYnVmZmVyLlxyXG4gICAgICogQHNlZSBPcGVuR0wgRVMgMi4wIFNwZWMsIMKnMi42LjFcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaW5kZXhDb3VudFxyXG4gICAgICogQHBhcmFtIGJhc2VJbmRleEluTWVzaFxyXG4gICAgICovXHJcbiAgICB3cml0ZUluZGljZXNGb3JDb250aW51b3VzRmFuKGluZGV4Q291bnQsIGJhc2VJbmRleEluTWVzaCA9IDApIHtcclxuICAgICAgICB0aGlzLl9lbnN1cmVFbm91Z2hJbmRleEJ1ZmZlclNwYWNlKDMgKiAoaW5kZXhDb3VudCAtIDIpKTtcclxuICAgICAgICBjb25zdCBidWZmZXIgPSB0aGlzLl9pbmRleEJ1ZmZlcjtcclxuICAgICAgICBjb25zdCBiYXNlSW5kZXggPSBiYXNlSW5kZXhJbk1lc2ggKyB0aGlzLl9jdXJyZW50TWVzaEJhc2VJbmRleDtcclxuICAgICAgICBmb3IgKGNvbnN0IGkgb2YgZ2VuZXJhdGVGYW4oaW5kZXhDb3VudCkpIHtcclxuICAgICAgICAgICAgYnVmZmVyLnB1c2goYmFzZUluZGV4ICsgaSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmRzIGN1cnJlbnQgbWVzaCBhbmQgaW1wbGljaXRseSBzdGFydHMgYSBuZXcgb25lLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIEludGVybmFsIGluZGV4IG9mIHZlcnRleCBhbmQgaW5kZXggYnVmZmVycyB0aGUgbWVzaCB3YXMgd3JpdHRlblxyXG4gICAgICogICAgICB0byBhbmQgaXRzIG1lbW9yeSBsb2NhdGlvbiBpbiB0aGVtLlxyXG4gICAgICovXHJcbiAgICBlbmRNZXNoKCkge1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRNZXNoVmVydGV4T2Zmc2V0ID0gdGhpcy5fY3VycmVudE1lc2hWZXJ0ZXhPZmZzZXQ7XHJcbiAgICAgICAgY29uc3QgdmVydGV4T2NjdXBpZWRTaXplID0gdGhpcy5fdmVydGV4QnVmZmVyLm9jY3VwaWVkU2l6ZTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50TWVzaFZlcnRleE9mZnNldCA9IHZlcnRleE9jY3VwaWVkU2l6ZTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50TWVzaEJhc2VJbmRleCA9ICh2ZXJ0ZXhPY2N1cGllZFNpemUgPDwgMikgLyB0aGlzLl92ZXJ0ZXhCeXRlU2l6ZTtcclxuICAgICAgICBjb25zdCBjdXJyZW50TWVzaEluZGV4T2Zmc2V0ID0gdGhpcy5fY3VycmVudE1lc2hJbmRleE9mZnNldDtcclxuICAgICAgICBjb25zdCBpbmRleE9jY3VwaWVkU2l6ZSA9IHRoaXMuX2luZGV4QnVmZmVyLm9jY3VwaWVkU2l6ZTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50TWVzaEluZGV4T2Zmc2V0ID0gaW5kZXhPY2N1cGllZFNpemU7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdmVydGV4Qnl0ZU9mZnNldDogY3VycmVudE1lc2hWZXJ0ZXhPZmZzZXQgPDwgMixcclxuICAgICAgICAgICAgdmVydGV4Qnl0ZUxlbmd0aDogdmVydGV4T2NjdXBpZWRTaXplIC0gY3VycmVudE1lc2hWZXJ0ZXhPZmZzZXQgPDwgMixcclxuICAgICAgICAgICAgaW5kZXhCeXRlT2Zmc2V0OiBjdXJyZW50TWVzaEluZGV4T2Zmc2V0IDw8IDEsXHJcbiAgICAgICAgICAgIGluZGV4Qnl0ZUxlbmd0aDogaW5kZXhPY2N1cGllZFNpemUgLSBjdXJyZW50TWVzaEluZGV4T2Zmc2V0IDw8IDEsXHJcbiAgICAgICAgICAgIC8vIFdlIGNhbid0IHJldHVybiBhY3R1YWwgYnVmZmVyIHJlZmVyZW5jZSBzaW5jZSBpdCBjYW4gY2hhbmdlIGlmXHJcbiAgICAgICAgICAgIC8vIHRoZSBidWZmZXIgZ2V0cyByZWFsbG9jYXRlZC5cclxuICAgICAgICAgICAgYnVmZmVySW5kZXg6IHRoaXMuX3ZlcnRleEJ1ZmZlcnMubGVuZ3RoIC0gMVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgY3VycmVudGx5IG93bmVkIGJ1ZmZlciBkYXRhLiBUaGlzIGNhbGwncyBiZXR0ZXJcclxuICAgICAqIG1hZGUgd2hlbiB5b3UncmUgZG9uZSB3aXRoIHRoZSB3cml0ZXIgc2luY2UgaWYgdGhlIHdyaXRlciBkZWNpZGVzIHRvXHJcbiAgICAgKiByZXNpemUgYW55IG9mIHRoZSBidWZmZXJzIHNvbWUgb2YgdGhlIHJlZmVyZW5jZXMgaW4gdGhlIHJldHVybmVkIGFycmF5XHJcbiAgICAgKiBtYXkgYmVjb21lIG91dGRhdGVkLlxyXG4gICAgICovXHJcbiAgICBnZXRCdWZmZXJzKCkge1xyXG4gICAgICAgIHJldHVybiB6aXAodGhpcy5fdmVydGV4QnVmZmVycywgdGhpcy5faW5kZXhCdWZmZXJzLCAodmVydGV4QnVmZmVyLCBpbmRleEJ1ZmZlcikgPT4gKHtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyOiB2ZXJ0ZXhCdWZmZXIuYXNVaW50MzJBcnJheSgpLFxyXG4gICAgICAgICAgICBpbmRleEJ1ZmZlcjogaW5kZXhCdWZmZXIuYXNVaW50MTZBcnJheSgpXHJcbiAgICAgICAgfSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFuIG9mZnNldCBpbiB0aGUgY3VycmVudCB2ZXJ0ZXggYnVmZmVyIHRvIHRoZSBsb2NhdGlvbiB3aGVyZSBuZXh0XHJcbiAgICAgKiBwaWVjZSBvZiBkYXRhIHdpbGwgYmUgd3JpdHRlbi5cclxuICAgICAqL1xyXG4gICAgZ2V0Q3VycmVudFZlcnRleEJ1ZmZlckJ5dGVPZmZzZXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZlcnRleEJ1ZmZlci5vY2N1cGllZFNpemUgPDwgMjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBpbmRleCBvZiBjdXJyZW50bHkgd3JpdHRlbiB2ZXJ0ZXggc3RydWN0dXJlIGluIHRoZSBjdXJyZW50IHZlcnRleFxyXG4gICAgICogYnVmZmVyLlxyXG4gICAgICovXHJcbiAgICBnZXRDdXJyZW50VmVydGV4SWR4KCkge1xyXG4gICAgICAgIHJldHVybiAoKHRoaXMuX3ZlcnRleEJ1ZmZlci5vY2N1cGllZFNpemUgPDwgMikgLyB0aGlzLl92ZXJ0ZXhCeXRlU2l6ZSB8IDApIC0gdGhpcy5fY3VycmVudE1lc2hCYXNlSW5kZXg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIGZsb2F0aW5nIHBvaW50IHZhbHVlIHRvIHRoZSBjdXJyZW50IHZlcnRleCBidWZmZXIgYW5kIGFkdmFuY2VzXHJcbiAgICAgKiB0aGUgb2Zmc2V0IGJ5IDQgYnl0ZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBiZSB3cml0dGVuLlxyXG4gICAgICovXHJcbiAgICBfd3JpdGVGbG9hdDMyKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fZW5zdXJlRW5vdWdoVmVydGV4QnVmZmVyU3BhY2UoKTtcclxuICAgICAgICB0aGlzLl92ZXJ0ZXhCdWZmZXIucHVzaEZsb2F0MzIodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYW4gdW5zaWduZWQgaW50ZWdlciB2YWx1ZSB0byB0aGUgY3VycmVudCB2ZXJ0ZXggYnVmZmVyIGFuZCBhZHZhbmNlc1xyXG4gICAgICogdGhlIG9mZnNldCBieSA0IGJ5dGVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgd3JpdHRlbi5cclxuICAgICAqL1xyXG4gICAgX3dyaXRlV29yZCh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX2Vuc3VyZUVub3VnaFZlcnRleEJ1ZmZlclNwYWNlKCk7XHJcbiAgICAgICAgdGhpcy5fdmVydGV4QnVmZmVyLnB1c2hVaW50MzIodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYW4gdW5zaWduZWQgc2hvcnQgdmFsdWUgdG8gdGhlIGN1cnJlbnQgdmVydGV4IGJ1ZmZlciBhbmQgYWR2YW5jZXNcclxuICAgICAqIHRoZSBvZmZzZXQgYnkgMiBieXRlcy4gUGFzc2VkIHZhbHVlcyB3aWxsIGJlIHRydW5jYXRlZCB0byAxNiBiaXRzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgd3JpdHRlbi5cclxuICAgICAqL1xyXG4gICAgX3dyaXRlSGFsZldvcmRzKHYxLCB2Mikge1xyXG4gICAgICAgIHRoaXMuX3dyaXRlV29yZCh2MiA8PCAxNiB8IHYxICYgMHhmZmZmKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGFuIHVuc2lnbmVkIGJ5dGUgdmFsdWUgdG8gdGhlIGN1cnJlbnQgdmVydGV4IGJ1ZmZlciBhbmQgYWR2YW5jZXNcclxuICAgICAqIHRoZSBvZmZzZXQgYnkgMSBieXRlLiBQYXNzZWQgdmFsdWVzIHdpbGwgYmUgdHJ1bmNhdGVkIHRvIDggYml0cy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIHdyaXR0ZW4uXHJcbiAgICAgKi9cclxuICAgIF93cml0ZUJ5dGVzKHYxLCB2MiwgdjMsIHY0KSB7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVXb3JkKHY0IDw8IDI0IHxcclxuICAgICAgICAgICAgKHYzICYgMHhmZikgPDwgMTYgfFxyXG4gICAgICAgICAgICAodjIgJiAweGZmKSA8PCA4IHxcclxuICAgICAgICAgICAgdjEgJiAweGZmKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRW5jb2RlcyBhIHdvcmxkIGNvb3JkaW5hdGUgdmVjdG9yIGFzIGEgcGFpciBvZiAzMi1iaXQgaW50ZWdlcnMgKHNwbGl0dGluZ1xyXG4gICAgICogdGhlbSBpbiB0dXJuIGludG8gdG8gMTYtYml0IG9uZXMpLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjIFRoZSB3b3JsZCBjb29yZGluYXRlLlxyXG4gICAgICovXHJcbiAgICBfd3JpdGVXb3JsZENvb3JkaW5hdGUoYykge1xyXG4gICAgICAgIC8vIFRvIGF2b2lkIHVzaW5nIEdQVSBzaW5nZWQgaW50ZWdlciBjb252ZXJzaW9ucyB3ZSBzaGlmdCBhbmQgc2NhbGUgd29ybGRcclxuICAgICAgICAvLyBjb29yZGluYXRlcyBzbyB0aGV5J3JlIGluIFswLCAxXSByYW5nZSAoaW5zdGVhZCBvZiBbLTEsIDFdKSBhbmQgdGhlblxyXG4gICAgICAgIC8vIGVuY29kZWQgYXMgdW5zaWduZWQgMzIgYml0IGludGVnZXJzIHNwbGl0IGludG8gdG8gMTYgYml0IG9uZXMuXHJcbiAgICAgICAgY29uc3QgeFVpbnQzMiA9IGZsb2F0VG9VaW50MzIoMC41ICogKGMueCArIDEpKTtcclxuICAgICAgICBjb25zdCB5VWludDMyID0gZmxvYXRUb1VpbnQzMigwLjUgKiAoYy55ICsgMSkpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlSGFsZldvcmRzKHhVaW50MzIgPj4+IDE2LCB5VWludDMyID4+PiAxNik7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVIYWxmV29yZHMoeFVpbnQzMiwgeVVpbnQzMik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbXB1dGVzIG5ldyBiaWdnZXIgc2l6ZSBvZiBhIHZlcnRleCBidWZmZXIgYmFzZWQgb24gaXRzIGN1cnJlbnQgc2l6ZS4gQnlcclxuICAgICAqIGRlZmF1bHQganVzdCBkb3VibGUgdGhlIGN1cnJlbnQgc2l6ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3VycmVudEJ5dGVTaXplIEN1cnJlbnQgc2l6ZSBvZiB0aGUgaW5kZXggYnVmZmVyIGluIGJ5dGVzLlxyXG4gICAgICogQHJldHVybnMgVGhlIG5ldyBzaXplLlxyXG4gICAgICovXHJcbiAgICBfZ2V0TmV4dFZlcnRleEJ1ZmZlckJ5dGVTaXplKGN1cnJlbnRCeXRlU2l6ZSkge1xyXG4gICAgICAgIHJldHVybiBjdXJyZW50Qnl0ZVNpemUgPDwgMTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgbmV3IGJpZ2dlciBzaXplIG9mIGFuIGluZGV4IGJ1ZmZlciBiYXNlZCBvbiBpdHMgY3VycmVudCBzaXplLiBCeVxyXG4gICAgICogZGVmYXVsdCBqdXN0IGRvdWJsZSB0aGUgY3VycmVudCBzaXplLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjdXJyZW50VWludDE2U2l6ZSBDdXJyZW50IHNpemUgb2YgdGhlIGluZGV4IGJ1ZmZlciBpbiBzaG9ydHMuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgbmV3IHNpemUuXHJcbiAgICAgKi9cclxuICAgIF9nZXROZXh0SW5kZXhCdWZmZXJVaW50MTZTaXplKGN1cnJlbnRVaW50MTZTaXplKSB7XHJcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRVaW50MTZTaXplIDw8IDE7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVuc3VyZXMgdGhhdCB0aGUgbWFuYWdlZCB2ZXJ0ZXggYnVmZmVyIGhhcyBlbm91Z2ggc3BhY2UgdG8gZml0IGluIGEgY2h1bmtcclxuICAgICAqIG9mIGRhdGEgb2YgYSBnaXZlbiBzaXplLiBFaXRoZXIgZG9lcyBub3RoaW5nLCByZXNpemVzIHRoZSBjdXJyZW50IHZlcnRleFxyXG4gICAgICogYnVmZmVyIG9yIGNyZWF0ZXMgZW50aXJlbHkgbmV3IHBhaXIgb2YgdmVydGV4IGFuZCBpbmRleCBidWZmZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB2YWx1ZVNpemUgQnl0ZSBzaXplIG9mIHRoZSBkYXRhIHRoYXQgbmVlZHMgdG8gYmUgYWNjb21tb2RhdGVkIGJ5XHJcbiAgICAgKiAgICAgIHRoZSB2ZXJ0ZXggYnVmZmVyLlxyXG4gICAgICovXHJcbiAgICBfZW5zdXJlRW5vdWdoVmVydGV4QnVmZmVyU3BhY2UoKSB7XHJcbiAgICAgICAgY29uc3QgdmVydGV4QnVmZmVyID0gdGhpcy5fdmVydGV4QnVmZmVyO1xyXG4gICAgICAgIGlmICghdmVydGV4QnVmZmVyLmlzRnVsbCkge1xyXG4gICAgICAgICAgICAvLyBXZSBoYXZlIGVub3VnaCBzcGFjZSwgc28gbm90aGluZyB0byBiZSBkb25lLlxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2ZXJ0ZXhCdWZmZXIuYnl0ZVNpemUgPCB0aGlzLl9tYXhWZXJ0ZXhCdWZmZXJCeXRlU2l6ZSkge1xyXG4gICAgICAgICAgICAvLyBJZiB3ZSBjYW4ganVzdCByZXNpemUgdGhlIGN1cnJlbnQgdmVydGV4IGJ1ZmZlciwgZG8gdGhhdC5cclxuICAgICAgICAgICAgdGhpcy5fdmVydGV4QnVmZmVyLmV4dGVuZCh0aGlzLl9nZXROZXh0VmVydGV4QnVmZmVyQnl0ZVNpemUodmVydGV4QnVmZmVyLmJ5dGVTaXplKSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWYgdGhlcmUncyBubyBlbm91Z2ggc3BhY2UgaW4gdGhlIGN1cnJlbnQgdmVydGV4IGJ1ZmZlciBhbmQgaXQnc1xyXG4gICAgICAgIC8vIGFscmVhZHkgb2YgbWF4aW11bSBzaXplLCBhbGxvY2F0ZSBuZXcgdmVydGV4IGFuZCBpbmRleCBidWZmZXJzIGFuZFxyXG4gICAgICAgIC8vIGNvcHkgZGF0YSBvZiB0aGUgY3VycmVudCBtZXNoIHRvIHRoZW0gZnJvbSB0aGUgY3VycmVudCBidWZmZXJzLlxyXG4gICAgICAgIC8vIFRoZW4gbWFrZSB0aG9zZSBidWZmZXIgdGhlIGN1cnJlbnQgb25lcy5cclxuICAgICAgICBjb25zdCBjdXJyZW50TWVzaFZlcnRleE9mZnNldCA9IHRoaXMuX2N1cnJlbnRNZXNoVmVydGV4T2Zmc2V0O1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRNZXNoVmVydGV4Qnl0ZVNpemUgPSAodmVydGV4QnVmZmVyLm9jY3VwaWVkU2l6ZSAtIGN1cnJlbnRNZXNoVmVydGV4T2Zmc2V0KSAqIDQ7XHJcbiAgICAgICAgY29uc3QgbWF4VmVydGV4QnVmZmVyQnl0ZVNpemUgPSB0aGlzLl9tYXhWZXJ0ZXhCdWZmZXJCeXRlU2l6ZTtcclxuICAgICAgICBpZiAoY3VycmVudE1lc2hWZXJ0ZXhCeXRlU2l6ZSA9PT0gbWF4VmVydGV4QnVmZmVyQnl0ZVNpemUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXNoIGlzIHRvbyBiaWcgdG8gZml0IGluLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgbmV3VmVydGV4QnVmZmVyQnl0ZVNpemUgPSB0aGlzLl9pbml0VmVydGV4QnVmZmVyQnl0ZVNpemU7XHJcbiAgICAgICAgLy8gSW5pdGlhbCB2ZXJ0ZXggYnVmZmVyIHNpemUgbWF5IGJlIHRvbyBzbWFsbCB0byBhY2NvbW1vZGF0ZSB0aGUgY3VycmVudFxyXG4gICAgICAgIC8vIG1lc2gsIHNvIHdlIGZpbmQgbmV4dCBiaWdnZXIgc2l6ZSB0aGF0IGlzIHN1ZmZpY2llbnQuXHJcbiAgICAgICAgd2hpbGUgKG5ld1ZlcnRleEJ1ZmZlckJ5dGVTaXplIDw9IGN1cnJlbnRNZXNoVmVydGV4Qnl0ZVNpemUpIHtcclxuICAgICAgICAgICAgbmV3VmVydGV4QnVmZmVyQnl0ZVNpemUgPSB0aGlzLl9nZXROZXh0VmVydGV4QnVmZmVyQnl0ZVNpemUobmV3VmVydGV4QnVmZmVyQnl0ZVNpemUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBuZXdWZXJ0ZXhCdWZmZXIgPSBuZXcgVmVydGV4QnVmZmVyKG5ld1ZlcnRleEJ1ZmZlckJ5dGVTaXplKTtcclxuICAgICAgICBWZXJ0ZXhCdWZmZXIudHJhbnNmZXJEYXRhVGFpbCh2ZXJ0ZXhCdWZmZXIsIG5ld1ZlcnRleEJ1ZmZlciwgY3VycmVudE1lc2hWZXJ0ZXhPZmZzZXQpO1xyXG4gICAgICAgIHRoaXMuX3ZlcnRleEJ1ZmZlciA9IG5ld1ZlcnRleEJ1ZmZlcjtcclxuICAgICAgICB0aGlzLl92ZXJ0ZXhCdWZmZXJzLnB1c2gobmV3VmVydGV4QnVmZmVyKTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50TWVzaFZlcnRleE9mZnNldCA9IDA7XHJcbiAgICAgICAgY29uc3QgaW5kZXhCdWZmZXIgPSB0aGlzLl9pbmRleEJ1ZmZlcjtcclxuICAgICAgICBjb25zdCBjdXJyZW50TWVzaEluZGV4T2Zmc2V0ID0gdGhpcy5fY3VycmVudE1lc2hJbmRleE9mZnNldDtcclxuICAgICAgICBjb25zdCBjdXJyZW50TWVzaEluZGV4U2l6ZSA9IGluZGV4QnVmZmVyLm9jY3VwaWVkU2l6ZSAtIGN1cnJlbnRNZXNoSW5kZXhPZmZzZXQ7XHJcbiAgICAgICAgbGV0IG5ld0luZGV4QnVmZmVyU2l6ZSA9IHRoaXMuX2luaXRJbmRleEJ1ZmZlclVpbnQxNlNpemU7XHJcbiAgICAgICAgLy8gSW5pdGlhbCBpbmRleCBidWZmZXIgc2l6ZSBtYXkgYmUgdG9vIHNtYWxsIHRvIGFjY29tbW9kYXRlIHRoZSBjdXJyZW50XHJcbiAgICAgICAgLy8gbWVzaCwgc28gd2UgZmluZCBuZXh0IGJpZ2dlciBzaXplIHRoYXQgaXMgc3VmZmljaWVudC5cclxuICAgICAgICB3aGlsZSAobmV3SW5kZXhCdWZmZXJTaXplIDw9IGN1cnJlbnRNZXNoSW5kZXhTaXplKSB7XHJcbiAgICAgICAgICAgIG5ld0luZGV4QnVmZmVyU2l6ZSA9IHRoaXMuX2dldE5leHRJbmRleEJ1ZmZlclVpbnQxNlNpemUobmV3SW5kZXhCdWZmZXJTaXplKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbmV3SW5kZXhCdWZmZXIgPSBuZXcgSW5kZXhCdWZmZXIobmV3SW5kZXhCdWZmZXJTaXplKTtcclxuICAgICAgICAvLyBTaW5jZSB0aGUgY3VycmVudCBtZXNoJ3MgY29waWVkIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIG5ldyB2ZXJ0ZXhcclxuICAgICAgICAvLyBidWZmZXIsIGl0J3MgYmFzZSBpbmRleCBub3cgaXMgMC4gSWYgdGhlIG1lc2ggaGFzIGFueSB3cml0dGVuIGluZGljZXMsXHJcbiAgICAgICAgLy8gdGhleSdyZSBhbHJlYWR5IG9mZnNldCBieSB0aGUgb2xkIGJhc2UgaW5kZXguXHJcbiAgICAgICAgSW5kZXhCdWZmZXIudHJhbnNmZXJEYXRhVGFpbChpbmRleEJ1ZmZlciwgbmV3SW5kZXhCdWZmZXIsIHRoaXMuX2N1cnJlbnRNZXNoQmFzZUluZGV4LCBjdXJyZW50TWVzaEluZGV4T2Zmc2V0KTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50TWVzaEJhc2VJbmRleCA9IDA7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudE1lc2hJbmRleE9mZnNldCA9IDA7XHJcbiAgICAgICAgdGhpcy5faW5kZXhCdWZmZXIgPSBuZXdJbmRleEJ1ZmZlcjtcclxuICAgICAgICB0aGlzLl9pbmRleEJ1ZmZlcnMucHVzaChuZXdJbmRleEJ1ZmZlcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVuc3VyZXMgdGhhdCB0aGUgbWFuYWdlZCBpbmRleCBidWZmZXIgaGFzIGVub3VnaCBzcGFjZSB0byBmaXQgaW4gYSBnaXZlblxyXG4gICAgICogbnVtYmVyIG9mIGluZGljZXMuIEVpdGhlciBkb2VzIG5vdGhpbmcgb3IgcmVzaXplcyB0aGUgY3VycmVudCBpbmRleFxyXG4gICAgICogYnVmZmVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpbmRleENvdW50IE51bWJlciBvZiBpbmRpY2VzIGNsaWVudCB3YW50cyB0byB3cml0ZSB0byB0aGUgbWFuYWdlZFxyXG4gICAgICogICAgICBpbmRleCBidWZmZXIuXHJcbiAgICAgKi9cclxuICAgIF9lbnN1cmVFbm91Z2hJbmRleEJ1ZmZlclNwYWNlKGluZGV4Q291bnQpIHtcclxuICAgICAgICBjb25zdCBidWZmZXIgPSB0aGlzLl9pbmRleEJ1ZmZlcjtcclxuICAgICAgICBjb25zdCByZXF1aXJlZFNpemUgPSBidWZmZXIub2NjdXBpZWRTaXplICsgaW5kZXhDb3VudDtcclxuICAgICAgICBpZiAocmVxdWlyZWRTaXplIDw9IGJ1ZmZlci5zaXplKSB7XHJcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgZW5vdWdoIHNwYWNlIHNvIG5vdGhpbmcgdG8gYmUgZG9uZS5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgbmV3QnVmZmVyU2l6ZSA9IGJ1ZmZlci5zaXplO1xyXG4gICAgICAgIC8vIExldCdzIGNvbXB1dGUgbmV3IGxhcmdlciBzaXplIG9mIHRoZSBpbmRleCBidWZmZXIgdW50aWwgd2UgY2FuXHJcbiAgICAgICAgLy8gYWNjb21tb2RhdGUgaW5jb21pbmcgZGF0YS5cclxuICAgICAgICB3aGlsZSAocmVxdWlyZWRTaXplID4gbmV3QnVmZmVyU2l6ZSkge1xyXG4gICAgICAgICAgICBuZXdCdWZmZXJTaXplID0gdGhpcy5fZ2V0TmV4dEluZGV4QnVmZmVyVWludDE2U2l6ZShuZXdCdWZmZXJTaXplKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5faW5kZXhCdWZmZXIuZXh0ZW5kKG5ld0J1ZmZlclNpemUpO1xyXG4gICAgfVxyXG59XHJcbiIsImNvbnN0IFVJTlQ4X01BWCA9IDB4ZmY7XHJcbmNvbnN0IFVJTlQxNl9NQVggPSAweGZmZmY7XHJcbmNvbnN0IFVJTlQzMl9NQVggPSAweGZmZmZmZmZmO1xyXG5leHBvcnQgZnVuY3Rpb24gZmxvYXRUb1VpbnQ4KHgpIHtcclxuICAgIHJldHVybiBVSU5UOF9NQVggKiB4IHwgMDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gZmxvYXRUb1VpbnQxNih4KSB7XHJcbiAgICByZXR1cm4geCAqIFVJTlQxNl9NQVggfCAwO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBmbG9hdFRvSW50MTYoeCkge1xyXG4gICAgcmV0dXJuICh4ICogVUlOVDE2X01BWCAtIDEpIC8gMiB8IDA7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGZsb2F0VG9VaW50MzIoeCkge1xyXG4gICAgcmV0dXJuIHggKiBVSU5UMzJfTUFYIHwgMDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gZmxvYXRUb0ludDMyKHgpIHtcclxuICAgIHJldHVybiAoeCAqIFVJTlQzMl9NQVggLSAxKSAvIDIgfCAwO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBpbnQzMlRvRmxvYXQoeCkge1xyXG4gICAgcmV0dXJuICgyICogeCArIDEpIC8gVUlOVDMyX01BWDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gdWludDMyVG9GbG9hdCh4KSB7XHJcbiAgICByZXR1cm4geCAvIFVJTlQzMl9NQVg7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGludDE2VG9GbG9hdCh4KSB7XHJcbiAgICByZXR1cm4gKDIgKiB4ICsgMSkgLyBVSU5UMTZfTUFYO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiB1aW50MTZUb0Zsb2F0KHgpIHtcclxuICAgIHJldHVybiB4IC8gVUlOVDE2X01BWDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gdWludDhUb0Zsb2F0KHgpIHtcclxuICAgIHJldHVybiB4IC8gVUlOVDhfTUFYO1xyXG59XHJcbiIsImltcG9ydCB7IERFRkFVTFRfQ09NUEFSQVRPUiB9IGZyb20gJy4vY29tcGFyYXRvcic7XHJcbi8qKlxyXG4gKiBTd2FwcyB0d28gdmFsdWVzIGluIGFuIGFycmF5LlxyXG4gKlxyXG4gKiBAcGFyYW0gYXJyYXkgVGhlIGFycmF5LlxyXG4gKiBAcGFyYW0gaSBJbmRleCBvZiBhIHZhbHVlIHRvIGJlIHN3YXBwZWQuXHJcbiAqIEBwYXJhbSBqIEluZGV4IG9mIGEgdmFsdWUgdG8gYmUgc3dhcHBlZC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzd2FwKGFycmF5LCBpLCBqKSB7XHJcbiAgICBjb25zdCB0ID0gYXJyYXlbaV07XHJcbiAgICBhcnJheVtpXSA9IGFycmF5W2pdO1xyXG4gICAgYXJyYXlbal0gPSB0O1xyXG59XHJcbi8qKlxyXG4gKiBSZXZlcnNlcyBvcmRlciBvZiBlbGVtZW50cyBpbiBhIHJhbmdlIGluIGFuIGFycmF5LlxyXG4gKlxyXG4gKiBAcGFyYW0gYXJyYXkgVGhlIGFycmF5LlxyXG4gKiBAcGFyYW0gc3RhcnQgVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cclxuICogQHBhcmFtIGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiByZXZlcnNlKGFycmF5LCBzdGFydCA9IDAsIGVuZCA9IGFycmF5Lmxlbmd0aCkge1xyXG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0LCBqID0gZW5kIC0gMTsgaSA8IGo7ICsraSwgLS1qKSB7XHJcbiAgICAgICAgc3dhcChhcnJheSwgaSwgaik7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJvdGF0ZXMgYSByYW5nZSBvZiBlbGVtZW50cyBpbiBhbiBhcnJheSBieSBnaXZlbiBhbW91bnQuXHJcbiAqXHJcbiAqIEBwYXJhbSBhcnJheSBUaGUgYXJyYXkuXHJcbiAqIEBwYXJhbSBhbW91bnQgVGhlIGFtb3VudC5cclxuICogQHBhcmFtIHN0YXJ0IFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXHJcbiAqIEBwYXJhbSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlKGFycmF5LCBhbW91bnQgPSAxLCBzdGFydCA9IDAsIGVuZCA9IGFycmF5Lmxlbmd0aCkge1xyXG4gICAgcmV2ZXJzZShhcnJheSwgc3RhcnQsIGVuZCk7XHJcbiAgICByZXZlcnNlKGFycmF5LCBzdGFydCwgc3RhcnQgKyBhbW91bnQpO1xyXG4gICAgcmV2ZXJzZShhcnJheSwgc3RhcnQgKyBhbW91bnQsIGVuZCk7XHJcbn1cclxuLyoqXHJcbiAqIENvcGllcyBhIHJhbmdlIG9mIGVsZW1lbnRzIGZyb20gYSBzb3VyY2UgYXJyYXkgdG8gYSByYW5nZSBpbiBhIGRlc3RpbmF0aW9uXHJcbiAqIGFycmF5LlxyXG4gKlxyXG4gKiBAcGFyYW0gc3JjIFRoZSBzb3VyY2UgYXJyYXkuXHJcbiAqIEBwYXJhbSBkc3QgVGhlIGRlc3RpbmF0aW9uIGFycmF5LlxyXG4gKiBAcGFyYW0gc3JjU3RhcnQgVGhlIHN0YXJ0IG9mIHRoZSBzb3VyY2UgcmFuZ2UuXHJcbiAqIEBwYXJhbSBzcmNTdGFydCBUaGUgc3RhcnQgb2YgdGhlIHNvdXJjZSByYW5nZS5cclxuICogQHBhcmFtIGRzdFN0YXJ0IFRoZSBzdGFydCBvZiB0aGUgZGVzdGluYXRpb24gcmFuZ2UuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29weShzcmMsIGRzdCwgc3JjU3RhcnQgPSAwLCBzcmNFbmQgPSBzcmMubGVuZ3RoLCBkc3RTdGFydCA9IDApIHtcclxuICAgIGZvciAobGV0IGkgPSBzcmNTdGFydCwgaiA9IGRzdFN0YXJ0OyBpIDwgc3JjRW5kOyArK2ksICsraikge1xyXG4gICAgICAgIGRzdFtqXSA9IHNyY1tpXTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogU2h1ZmZsZXMgcmFuZG9tbHkgYSByYW5nZSBvZiBlbGVtZW50cyBpbiBhbiBhcnJheS5cclxuICpcclxuICogQHBhcmFtIGFycmF5IFRoZSBhcnJheS5cclxuICogQHBhcmFtIHN0YXJ0IFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXHJcbiAqIEBwYXJhbSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2h1ZmZsZShhcnJheSwgc3RhcnQgPSAwLCBlbmQgPSBhcnJheS5sZW5ndGgpIHtcclxuICAgIGZvciAobGV0IGkgPSBzdGFydCwgaiA9IGkgKyAxOyBpIDwgZW5kOyArK2ksICsraikge1xyXG4gICAgICAgIHN3YXAoYXJyYXksIGksIGogKyAoTWF0aC5yYW5kb20oKSAqIChlbmQgLSBqKSB8IDApKTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgZnVuY3Rpb24gemlwKHRzLCB1cywgemlwcGVyID0gKHQsIHUpID0+IFt0LCB1XSkge1xyXG4gICAgY29uc3QgbCA9IE1hdGgubWluKHRzLmxlbmd0aCwgdXMubGVuZ3RoKTtcclxuICAgIGNvbnN0IHZzID0gbmV3IEFycmF5KGwpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyArK2kpIHtcclxuICAgICAgICB2c1tpXSA9IHppcHBlcih0c1tpXSwgdXNbaV0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZzO1xyXG59XHJcbi8qKlxyXG4gKiBDb21wYXJlcyB0d28gYXJyYXlzIGxleGljb2dyYXBoaWNhbGx5LiBUaGUgb3JkZXIgaXMgc3BlY2lmaWVkIGJlIHRoZSBjb21wYXJhdG9yIHBhcmFtZXRlci5cclxuICpcclxuICogQHBhcmFtIGNvbXBhcmF0b3IgRWxlbWVudHMgY29tcGFyYXRvciB3aXRoIHN0YW5kYXJkIHNpZ25hdHVyZS5cclxuICogQHBhcmFtIGEgVGhlIGZpcnN0IGFycmF5IHRvIGNvbXBhcmUuXHJcbiAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgYXJyYXkgdG8gY29tcGFyZS5cclxuICogQHJldHVybnMgMCBpZiBhbGwgZWxlbWVudHMgYW5kIGxlbmd0aHMgYXJlIGVxdWFsLFxyXG4gKiAgICAgIG5lZ2F0aXZlIG51bWJlciBpZiB0aGUgZmlyc3QgZWxlbWVudCBpcyBsZXNzIHRoZW4gdGhlIHNlY29uZCAobGV4aWNvZ3JhcGhpY2FsbHkpLFxyXG4gKiAgICAgIHBvc2l0aXZlIG51bWJlciBpZiB0aGUgZmlyc3QgZWxlbWVudCBpcyBncmVhdGVyIHRoZW4gdGhlIHNlY29uZCxcclxuICogICAgICBpZiBhbGwgdGhlIGVsZW1lbnRzIGFyZSBlcXVhbCB0aGUgbGVuZ3RocyBhcmUgYmVpbmcgY29tcGFyZWQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZShjb21wYXJhdG9yLCBhLCBiKSB7XHJcbiAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1pbihhLmxlbmd0aCwgYi5sZW5ndGgpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbXBhcmF0b3IoYVtpXSwgYltpXSk7XHJcbiAgICAgICAgaWYgKHJlc3VsdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBhLmxlbmd0aCAtIGIubGVuZ3RoO1xyXG59XHJcbi8qKlxyXG4gKiBTb3J0cyBhIHJhbmdlIG9mIGVsZW1lbnRzIG9mIGFuIGFycmF5IGluIHBsYWNlIHdpdGggaW5zZXJ0aW9uIHNvcnQuXHJcbiAqXHJcbiAqIEBwYXJhbSBhcnJheSBUaGUgYXJyYXkgdG8gYmUgc29ydGVkLlxyXG4gKiBAcGFyYW0gY29tcGFyYXRvciBDb21wYXJhdG9yIGZvciBhcnJheSBlbGVtZW50cy5cclxuICogQHBhcmFtIHN0YXJ0IEluZGV4IG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSByYW5nZSB0byBiZSBzb3J0ZWQuXHJcbiAqIEBwYXJhbSBlbmQgSW5kZXggb2YgYW4gZWxlbWVudCBiZWhpbmQgdGhlIGxhc3QgZWxlbWVudCBpbiB0aGUgcmFuZ2UgdG8gYmVcclxuICogICAgICBzb3J0ZWQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaW5zZXJ0aW9uU29ydChhcnJheSwgY29tcGFyYXRvciA9IERFRkFVTFRfQ09NUEFSQVRPUiwgc3RhcnQgPSAwLCBlbmQgPSBhcnJheS5sZW5ndGgpIHtcclxuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaiA9IGk7IGogPiBzdGFydCAmJiBjb21wYXJhdG9yKGFycmF5W2ogLSAxXSwgYXJyYXlbal0pID4gMDsgLS1qKSB7XHJcbiAgICAgICAgICAgIHN3YXAoYXJyYXksIGogLSAxLCBqKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuY29uc3QgQkxPQ0tfU0laRSA9IDMyO1xyXG4vKipcclxuICogTWVyZ2VzIHR3byBzb3J0ZWQgcmFuZ2VzIG9mIGFuIGFycmF5LiBTdG9yZXMgdGhlIHJlc3VsdCBpbnRvIGFub3RoZXIgb25lLlxyXG4gKlxyXG4gKiBAcGFyYW0gc3JjIFRoZSBhcnJheSB3aXRoIHRoZSByYW5nZXMgdG8gYmUgbWVyZ2VkLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSBhcnJheSB0aGUgcmVzdWx0aW5nIHJhbmdlIHdpbGwgYmUgc3RvcmVkIHRvLlxyXG4gKiBAcGFyYW0gY29tcGFyYXRvciBUaGUgY29tcGFyYXRvciBmb3IgYXJyYXkgZWxlbWVudHMuXHJcbiAqIEBwYXJhbSBzdGFydCBTdGFydCBvZiB0aGUgZmlyc3QgcmFuZ2UgdG8gYmUgbWVyZ2VkLlxyXG4gKiBAcGFyYW0gbWlkZGxlIEVuZCBvZiB0aGUgZmlyc3QgYW5kIHNpbXVsdGFuZW91c2x5IHN0YXJ0IG9mIHRoZSBzZWNvbmQgcmFuZ2VcclxuICogICAgICB0byBiZSBtZXJnZWQuXHJcbiAqIEBwYXJhbSBlbmQgRW5kIG9mIHRoZSBzZWNvbmQgcmFuZ2UgdG8gYmUgbWVyZ2VkLlxyXG4gKiBAcGFyYW0gZHN0T2Zmc2V0IE9mZnNldCBvZiBtZXJnZWQgcmFuZ2UgaW4gdGhlIHJlc3VsdCBhcnJheS5cclxuICovXHJcbmZ1bmN0aW9uIG1lcmdlKHNyYywgZHN0LCBjb21wYXJhdG9yLCBzdGFydCwgbWlkZGxlLCBlbmQsIGRzdE9mZnNldCkge1xyXG4gICAgbGV0IGkgPSBkc3RPZmZzZXQ7XHJcbiAgICBsZXQgaiA9IHN0YXJ0O1xyXG4gICAgbGV0IGsgPSBtaWRkbGU7XHJcbiAgICB3aGlsZSAoaiA8IG1pZGRsZSAmJiBrIDwgZW5kKSB7XHJcbiAgICAgICAgZHN0W2krK10gPSBjb21wYXJhdG9yKHNyY1tqXSwgc3JjW2tdKSA+IDAgPyBzcmNbaysrXSA6IHNyY1tqKytdO1xyXG4gICAgfVxyXG4gICAgY29weShzcmMsIGRzdCwgaiwgbWlkZGxlLCBpKTtcclxuICAgIGNvcHkoc3JjLCBkc3QsIGssIGVuZCwgaSk7XHJcbn1cclxuLyoqXHJcbiAqIFNvcnRzIGEgcmFuZ2Ugb2YgZWxlbWVudHMgb2YgYW4gYXJyYXkgd2l0aCBtZXJnZSBzb3J0LlxyXG4gKlxyXG4gKiBAcGFyYW0gYXJyYXkgIFRoZSBhcnJheSB0byBiZSBzb3J0ZWQuXHJcbiAqIEBwYXJhbSBjb21wYXJhdG9yIENvbXBhcmF0b3IgZm9yIGFycmF5IGVsZW1lbnRzLlxyXG4gKiBAcGFyYW0gZW5kIEluZGV4IG9mIGFuIGVsZW1lbnQgYmVoaW5kIHRoZSBsYXN0IGVsZW1lbnQgaW4gdGhlIHJhbmdlIHRvIGJlXHJcbiAqICAgICAgc29ydGVkLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlU29ydChhcnJheSwgY29tcGFyYXRvciA9IERFRkFVTFRfQ09NUEFSQVRPUiwgc3RhcnQgPSAwLCBlbmQgPSBhcnJheS5sZW5ndGgpIHtcclxuICAgIC8vIEZpcnN0IGFuZCBmb3JlbW9zdDogaWYgdGhlIHJhbmdlIGlzIHNtYWxsZXIgdGhhbiB0aGUgYmxvY2sgc2l6ZSwganVzdFxyXG4gICAgLy8gcGVyZm9ybSBpbnNlcnRpb24gc29ydCBvbiBpdC5cclxuICAgIGlmIChlbmQgLSBzdGFydCA8PSBCTE9DS19TSVpFKSB7XHJcbiAgICAgICAgaW5zZXJ0aW9uU29ydChhcnJheSwgY29tcGFyYXRvciwgc3RhcnQsIGVuZCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgLy8gRmlyc3Qgd2Ugc3BsaXQgdGhlIGdpdmVuIHJhbmdlIGludG8gc3VicmFuZ2VzIG9mIHNpemUgQkxPQ0tfU0laRSBhbmRcclxuICAgIC8vIHNvcnQgZXZlcnkgcmFuZ2Ugd2l0aCBpbnNlcnRpb24gc29ydC5cclxuICAgIHtcclxuICAgICAgICBsZXQgcyA9IHN0YXJ0O1xyXG4gICAgICAgIGxldCBlID0gcyArIEJMT0NLX1NJWkU7XHJcbiAgICAgICAgd2hpbGUgKGUgPCBlbmQpIHtcclxuICAgICAgICAgICAgaW5zZXJ0aW9uU29ydChhcnJheSwgY29tcGFyYXRvciwgcywgZSk7XHJcbiAgICAgICAgICAgIHMgPSBlO1xyXG4gICAgICAgICAgICBlICs9IEJMT0NLX1NJWkU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluc2VydGlvblNvcnQoYXJyYXksIGNvbXBhcmF0b3IsIHMsIGVuZCk7XHJcbiAgICB9XHJcbiAgICAvLyBUT0RPKGRtaWtpcyk6IEltcGxlbWVudCBpbi1wbGFjZSBtZXJnZS4gSXQgc2VlbXMgdGhlcmUncmUgcmVhc29uYWJseVxyXG4gICAgLy8gICAgICBjb21wbGV4IHNvbHV0aW9ucyBvdXQgdGhlcmUuXHJcbiAgICBjb25zdCBhdXhBcnJheSA9IG5ldyBBcnJheShlbmQgLSBzdGFydCk7XHJcbiAgICAvLyBUaGVuIHdlIG1lcmdlIGJsb2NrcyBwYWlycywgaW5jcmVhc2UgYmxvY2sgc2l6ZSBieSAyIGFuZCByZXBlYXQuXHJcbiAgICBmb3IgKGxldCBibG9ja1NpemUgPSBCTE9DS19TSVpFOyBibG9ja1NpemUgPCBlbmQgLSBzdGFydDsgYmxvY2tTaXplICs9IGJsb2NrU2l6ZSkge1xyXG4gICAgICAgIC8vIFRPRE8oZG1pa2lzKTogQmVmb3JlIGFmb3JlbWVudGlvbmVkIHRvZG8gbWF5YmUgaW1wbGVtZW50IGFycmF5XHJcbiAgICAgICAgLy8gcGluZ3BvbmdpbmcgdG8gY3V0IGRvd24gYW1vdW50IG9mIGZ1bGwgY29waWVzLlxyXG4gICAgICAgIGNvcHkoYXJyYXksIGF1eEFycmF5LCBzdGFydCwgZW5kKTtcclxuICAgICAgICBsZXQgaSA9IHN0YXJ0O1xyXG4gICAgICAgIGxldCBzID0gMDtcclxuICAgICAgICBsZXQgbSA9IGJsb2NrU2l6ZTtcclxuICAgICAgICBsZXQgZSA9IG0gKyBibG9ja1NpemU7XHJcbiAgICAgICAgd2hpbGUgKGUgPCBlbmQgLSBzdGFydCkge1xyXG4gICAgICAgICAgICBtZXJnZShhdXhBcnJheSwgYXJyYXksIGNvbXBhcmF0b3IsIHMsIG0sIGUsIGkpO1xyXG4gICAgICAgICAgICBzID0gZTtcclxuICAgICAgICAgICAgbSA9IHMgKyBibG9ja1NpemU7XHJcbiAgICAgICAgICAgIGUgPSBtICsgYmxvY2tTaXplO1xyXG4gICAgICAgICAgICBpICs9IDIgKiBibG9ja1NpemU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1lcmdlKGF1eEFycmF5LCBhcnJheSwgY29tcGFyYXRvciwgcywgTWF0aC5taW4obSwgZW5kIC0gc3RhcnQpLCBlbmQgLSBzdGFydCwgaSk7XHJcbiAgICB9XHJcbn1cclxuIiwiZXhwb3J0IGZ1bmN0aW9uIERFRkFVTFRfQ09NUEFSQVRPUihhLCBiKSB7XHJcbiAgICBpZiAoYSA+IGIpIHtcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIH1cclxuICAgIGlmIChhIDwgYikge1xyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuICAgIHJldHVybiAwO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBOVU1FUklDQUxfQ09NUEFSQVRPUihhLCBiKSB7XHJcbiAgICByZXR1cm4gYSAtIGI7XHJcbn1cclxuIiwiaW1wb3J0IHsgY291bnRJbmRpY2VzIH0gZnJvbSAnLi9jb3VudF92ZXJ0aWNlcyc7XHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgcmVnaW9uIGluIGEgbWVtb3J5IGNodW5rLiBNZW1vcnkgaXMgYWxsb2NhdGVkIGJ5IGJpZyBjaHVua3MgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsXHJcbiAqIGFuZCB3ZSBuZWVkIGEgbWVjaGFuaXNtIHRvIGNvbnRyb2wgdGhvc2UgY2h1bmsncyBzdWJhbGxvY2F0aW9uIHRvIHByb3Blcmx5IGZyZWVcclxuICogdGhlIG9jY3VwaWVkIG1lbW9yeSAtIHRoYXQgaXMgd2hhdCB0aGlzIGNsYXNzIGlzIGZvci5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1lbW9yeVN1YkNodW5rIHtcclxuICAgIGNvbnN0cnVjdG9yKGNodW5rLCBsb2NhdGlvbikge1xyXG4gICAgICAgIHRoaXMubWVtb3J5Q2h1bmsgPSBjaHVuaztcclxuICAgICAgICB0aGlzLl9sb2NhdGlvbiA9IGxvY2F0aW9uO1xyXG4gICAgICAgIGNodW5rLnJldGFpbigpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBPZmZzZXQgb2YgdmVydGV4IGRhdGEgb2YgdGhlIGNodW5rIGluIGJ5dGVzLlxyXG4gICAgICovXHJcbiAgICBnZXQgdmVydGV4Qnl0ZU9mZnNldCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tZW1vcnlDaHVuay52ZXJ0ZXhCeXRlT2Zmc2V0ICsgdGhpcy5fbG9jYXRpb24udmVydGV4Qnl0ZU9mZnNldDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgT2Zmc2V0IG9mIGluZGV4IGRhdGEgb2YgdGhlIGNodW5rIGluIGJ5dGVzLlxyXG4gICAgICovXHJcbiAgICBnZXQgaW5kZXhCeXRlT2Zmc2V0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1lbW9yeUNodW5rLmluZGV4Qnl0ZU9mZnNldCArIHRoaXMuX2xvY2F0aW9uLmluZGV4Qnl0ZU9mZnNldDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgTnVtYmVyIG9mIGluZGV4ZXMgb2NjdXBpZWQgYnkgdGhpcyBjaHVuay5cclxuICAgICAqL1xyXG4gICAgZ2V0IGluZGV4Q291bnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvdW50SW5kaWNlcyh0aGlzLl9sb2NhdGlvbi5pbmRleEJ5dGVMZW5ndGgsIHRoaXMubWVtb3J5Q2h1bmsucGFnZS5pbmRleFR5cGUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBOdW1iZXIgb2YgYnl0ZXMgb2NjdXBpZWQgYnkgdGhpcyBjaHVuayBmb3IgdmVydGV4IGRhdGEuXHJcbiAgICAgKi9cclxuICAgIGdldCB2ZXJ0ZXhCeXRlTGVuZ3RoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhdGlvbi52ZXJ0ZXhCeXRlTGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBOdW1iZXIgb2YgYnl0ZXMgb2NjdXBpZWQgYnkgdGhpcyBjaHVuayBmb3IgaW5kZXggZGF0YS5cclxuICAgICAqL1xyXG4gICAgZ2V0IGluZGV4Qnl0ZUxlbmd0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYXRpb24uaW5kZXhCeXRlTGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLm1lbW9yeUNodW5rLnJlbGVhc2UoKTtcclxuICAgIH1cclxufVxyXG4iLCIvKipcclxuICogQHJldHVybnMgSW50ZWdlciBudW1iZXIgb2YgdmVydGljZXMgdGhhdCBmaXQgaW50byBhIHJlZ2lvbiBvZiBzcGVjaWZpZWQgaW4gYnl0ZXMgc2l6ZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb3VudFZlcnRpY2VzKHZlcnRleEJ5dGVTaXplLCBhdHRyaWJNYXBwaW5nKSB7XHJcbiAgICByZXR1cm4gdmVydGV4Qnl0ZVNpemUgLyBhdHRyaWJNYXBwaW5nLnZlcnRleEJ5dGVTaXplIHwgMDtcclxufVxyXG4vKipcclxuICogQHJldHVybnMgSW50ZWdlciBudW1iZXIgb2YgaW5kaWNlcyB0aGF0IGZpdCBpbnRvIGEgcmVnaW9uIG9mIHNwZWNpZmllZCBpbiBieXRlcyBzaXplLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvdW50SW5kaWNlcyhpbmRleEJ5dGVTaXplLCB0eXBlKSB7XHJcbiAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICBjYXNlIDUxMjMgLyogVU5TSUdORURfU0hPUlQgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBpbmRleEJ5dGVTaXplID4+IDE7XHJcbiAgICAgICAgY2FzZSA1MTI1IC8qIFVOU0lHTkVEX0lOVCAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIGluZGV4Qnl0ZVNpemUgPj4gMjtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IFJlZmVyZW5jZUNvdW50ZWQgZnJvbSAnLi4vdXRpbC9yZWZfY291bnRlZCc7XHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGFuIGFsbG9jYXRlZCBpbWFnZS4gQWxsb2NhdGVkIGltYWdlIGlzIGEgc2hhcmVhYmxlIHJlc291cmNlIHRoYXQgc2hvdWxkIGJlIHJlc2VhbGVkXHJcbiAqIHdoZW4gdGhlcmUgYXJlIG5vIGNsaWVudHMgdXNlIGl0LiBBcyBpdCBpcyBub3QgcG9zc2libGUgdG8gcmVseSBvbiB0aGUgR0MsIGNsaWVudHMgc2hvdWxkXHJcbiAqIG1hbnVhbGx5IHJldGFpbiB0aGVpciByZXF1aXJlZCBpbWFnZXMgYW5kIHJlbGVhc2UgdGhlbSB3aGVuIHRoZXkgYXJlIG5vdCByZXF1aXJlZCBhbnltb3JlLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEFsbG9jYXRlZEltYWdlIGV4dGVuZHMgUmVmZXJlbmNlQ291bnRlZCB7XHJcbiAgICBjb25zdHJ1Y3RvcihkZXNjcmlwdG9yLCBiYm94LCBhdGxhc01hbmFnZXIpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuZGVzY3JpcHRvciA9IGRlc2NyaXB0b3I7XHJcbiAgICAgICAgdGhpcy5iYm94ID0gYmJveDtcclxuICAgICAgICB0aGlzLmF0bGFzTWFuYWdlciA9IGF0bGFzTWFuYWdlcjtcclxuICAgIH1cclxuICAgIHVwZGF0ZUltYWdlKHNvdXJjZUltYWdlLCBsb2NhdGlvblJlZ2lvbiwgc291cmNlSW1hZ2VSZWdpb24pIHtcclxuICAgICAgICB0aGlzLmF0bGFzTWFuYWdlci5hdGxhcy51cGRhdGVJbWFnZSh0aGlzLmJib3gsIHNvdXJjZUltYWdlLCBsb2NhdGlvblJlZ2lvbiwgc291cmNlSW1hZ2VSZWdpb24pO1xyXG4gICAgfVxyXG4gICAgX2Rlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5hdGxhc01hbmFnZXIucmVtb3ZlSW1hZ2UodGhpcy5kZXNjcmlwdG9yKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogTWFuYWdlcyBhbGxvY2F0aW9uIG9mIGltYWdlcyBieSBpZC5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElkZW50aWZpZWRJbWFnZUF0bGFzTWFuYWdlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihpbWFnZUF0bGFzKSB7XHJcbiAgICAgICAgdGhpcy5hdGxhcyA9IGltYWdlQXRsYXM7XHJcbiAgICAgICAgdGhpcy5fbG9jYXRpb25zID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHNpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2F0aW9ucy5zaXplO1xyXG4gICAgfVxyXG4gICAgZ2V0SW1hZ2UoaWQsIHJldGFpbiA9IGZhbHNlKSB7XHJcbiAgICAgICAgY29uc3QgaW1hZ2VMb2NhdGlvbiA9IHRoaXMuX2xvY2F0aW9ucy5nZXQoaWQpO1xyXG4gICAgICAgIGlmIChyZXRhaW4gJiYgaW1hZ2VMb2NhdGlvbikge1xyXG4gICAgICAgICAgICBpbWFnZUxvY2F0aW9uLnJldGFpbigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaW1hZ2VMb2NhdGlvbiB8fCBudWxsO1xyXG4gICAgfVxyXG4gICAgYWxsb2NhdGVJbWFnZShkZXNjcmlwdG9yLCBpbWFnZSkge1xyXG4gICAgICAgIGNvbnN0IGxvY2F0aW9uID0gdGhpcy5hdGxhcy5hbGxvY2F0ZUltYWdlKGRlc2NyaXB0b3IsIGltYWdlKTtcclxuICAgICAgICBpZiAobG9jYXRpb24pIHtcclxuICAgICAgICAgICAgY29uc3QgaW1hZ2UgPSBuZXcgQWxsb2NhdGVkSW1hZ2UoZGVzY3JpcHRvciwgbG9jYXRpb24sIHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLl9sb2NhdGlvbnMuc2V0KGRlc2NyaXB0b3IuaWQsIGltYWdlKTtcclxuICAgICAgICAgICAgcmV0dXJuIGltYWdlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHJlbW92ZUltYWdlKGltYWdlKSB7XHJcbiAgICAgICAgY29uc3QgbG9jYXRpb24gPSB0aGlzLl9sb2NhdGlvbnMuZ2V0KGltYWdlLmlkKTtcclxuICAgICAgICBpZiAobG9jYXRpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5hdGxhcy5yZW1vdmVJbWFnZShsb2NhdGlvbi5iYm94KTtcclxuICAgICAgICAgICAgdGhpcy5fbG9jYXRpb25zLmRlbGV0ZShpbWFnZS5pZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29udGFpbnMoaWQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYXRpb25zLmhhcyhpZCk7XHJcbiAgICB9XHJcbiAgICByZXNlcnZlTG9jYXRpb24oZGVzY3JpcHRvcikge1xyXG4gICAgICAgIGNvbnN0IGxvY2F0aW9uID0gdGhpcy5hdGxhcy5yZXNlcnZlTG9jYXRpb24oZGVzY3JpcHRvcik7XHJcbiAgICAgICAgaWYgKGxvY2F0aW9uKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGltYWdlID0gbmV3IEFsbG9jYXRlZEltYWdlKGRlc2NyaXB0b3IsIGxvY2F0aW9uLCB0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5fbG9jYXRpb25zLnNldChkZXNjcmlwdG9yLmlkLCBpbWFnZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBpbWFnZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn1cclxuIiwiLyoqXHJcbiAqIFNpbXBsZSByZWZlcmVuY2UgY291bnRpbmcgZm9yIHNoYXJlZCBlbnRpdGllcyB0aGF0IG5lZWQgZXhwbGljaXQgZGVzdHJ1Y3Rpb24uXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWZlcmVuY2VDb3VudGVkIHtcclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6ZXMgcmVmZXJlbmNlIGNvdW50IHRvIDEuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuX3JlZkNvdW50ID0gMTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSW5jcmVtZW50cyByZWZlcmVuY2UgY291bnQuXHJcbiAgICAgKi9cclxuICAgIHJldGFpbigpIHtcclxuICAgICAgICBpZiAodGhpcy5fcmVmQ291bnQgPT09IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmllZCB0byByZXRhaW4gYSBkZXN0cm95ZWQgb2JqZWN0LicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9yZWZDb3VudCsrO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEZWNyZW1lbnRzIHJlZmVyZW5jZSBjb3VudCBhbmQsIGlmIGl0J3MgcmVhY2hlZCAwLCBkZXN0cm95cyB0aGUgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICByZWxlYXNlKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9yZWZDb3VudCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyaWVkIHRvIHJlbGVhc2UgYSBkZXN0cm95ZWQgb2JqZWN0LicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9yZWZDb3VudC0tO1xyXG4gICAgICAgIGlmICh0aGlzLl9yZWZDb3VudCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLl9kZXN0cm95KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCBGb250IGZyb20gJy4vZm9udCc7XHJcbmNvbnN0IFVOS05PV05fR0xZUEggPSB7XHJcbiAgICBpZDogLTEsXHJcbiAgICB3aWR0aDogMCxcclxuICAgIGhlaWdodDogMCxcclxuICAgIGJlYXJpbmdYOiAwLFxyXG4gICAgYmVhcmluZ1k6IDAsXHJcbiAgICBhZHZhbmNlOiAxOFxyXG59O1xyXG4vKipcclxuICogRm9udCB3aG9zZSBnbHlwaHMgYXJlIHNwZWNpZmllZCBpbiBkaXN0YW5jZSBmaWVsZCBiaXRtYXBzLiBJdCdzIFwibWFyZ2luXCIgbWV0cmljIHNwZWNpZmllcyBnbHlwaCBiaXRtYXAgaW5uZXIgcGFkZGluZyxcclxuICogdGhhdCBpcyByZXF1aXJlZCB0byBmaXQgYSBcImJsdXJyZWRcIiBnbHlwaCBpbWFnZS4gVGhpcyBtYXJnaW4gc2hvdWxkIGJlIGNvbnNpZGVyZWQgZHVyaW5nIGxheW91dGluZyB0byBkcmF3IGdseXBocyBvZlxyXG4gKiBwcm9wZXIgc2l6ZXMuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZkZvbnQgZXh0ZW5kcyBGb250IHtcclxuICAgIGNvbnN0cnVjdG9yKGlkLCB4aGVpZ2h0LCBtYXJnaW4pIHtcclxuICAgICAgICBzdXBlcihpZCwgeGhlaWdodCwgVU5LTk9XTl9HTFlQSCk7XHJcbiAgICAgICAgdGhpcy5tYXJnaW4gPSBtYXJnaW47XHJcbiAgICB9XHJcbn1cclxuIiwiLyoqXHJcbiAqIEZvbnQgaXMganVzdCBhIGNvbGxlY3Rpb24gb2YgZ2x5cGggZGVzY3JpcHRpb25zLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRm9udCB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBpZCBGb250IGlkLlxyXG4gICAgICogQHBhcmFtIHhoZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgXCJ4XCIgY2hhciBpbiBhYnN0cmFjdCBwb2ludHMsIGluIGZhY3QgaXMgdXNlZCBhIHRoZSBmb250IHNpemUuXHJcbiAgICAgKiBAcGFyYW0gdW5rbm93bkdseXBoSW5zdGFuY2UgQW4gaW5zdGFuY2Ugb2YgZ2x5cGggdG8gYmUgc2VydmVkIGFzIGEgc3R1YiB3aGVuIG5vbmV4aXN0ZW50IGdseXBoXHJcbiAgICAgKiAgICAgaXMgcmVxdWVzdGVkLiBSZXF1ZXN0aW5nIG5vbmV4aXN0ZW50IGdseXBocyBub3JtYWxseSBzaG91bGQgbm90IGhhcHBlbi5cclxuICAgICAqICAgICBUaGUgc3R1YiBqdXN0IGFsbG93cyB0byBhdm9pZCB0ZWRpb3VzIG51bGwgY2hlY2tzIGluIGZvbnQgY2xpZW50cy5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoaWQsIHhoZWlnaHQsIHVua25vd25HbHlwaEluc3RhbmNlKSB7XHJcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG4gICAgICAgIHRoaXMueGhlaWdodCA9IHhoZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5fdW5rbm93bkdseXBoSW5zdGFuY2UgPSB1bmtub3duR2x5cGhJbnN0YW5jZTtcclxuICAgICAgICB0aGlzLl9nbHlwaHMgPSBuZXcgTWFwKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gR2x5cGggd2l0aCBzcGVjaWZpZWQgaWQgb3IgdW5rbm93biBnbHlwaCBpbnN0YW5jZS5cclxuICAgICAqL1xyXG4gICAgZ2V0R2x5cGgoZ2x5cGhJZCkge1xyXG4gICAgICAgIGNvbnN0IGdseXBoID0gdGhpcy5fZ2x5cGhzLmdldChnbHlwaElkKTtcclxuICAgICAgICBpZiAoZ2x5cGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdseXBoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdXb3ctd293LXdvdywgc29tZXRoaW5nIHdlbnQgd3JvbmcsIHlvdSBzaG91bGQgbm90IHJlcXVlc3Qgbm9uZXhpc3RlbnQgZ2x5cGhzJyk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl91bmtub3duR2x5cGhJbnN0YW5jZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIEFsbCBzdG9yZWQgZ2x5cGhzLlxyXG4gICAgICovXHJcbiAgICBnZXRBbGxHbHlwaHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIFsuLi50aGlzLl9nbHlwaHMudmFsdWVzKCldO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGdseXBoIGRlc2NyaXB0aW9uLlxyXG4gICAgICovXHJcbiAgICBhZGRHbHlwaChnbHlwaCkge1xyXG4gICAgICAgIHRoaXMuX2dseXBocy5zZXQoZ2x5cGguaWQsIGdseXBoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBnbHlwaCBkZXNjcmlwdGlvbnMgZnJvbSB0aGUgaXRlcmFibGUuXHJcbiAgICAgKi9cclxuICAgIGFkZEFsbEdseXBocyhnbHlwaHMpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGdseXBoIG9mIGdseXBocykge1xyXG4gICAgICAgICAgICB0aGlzLmFkZEdseXBoKGdseXBoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgSW1hZ2VQcm92aWRlciB9IGZyb20gJy4uLy4uL2JpbGxib2FyZC9pbWFnZV9wcm92aWRlcic7XHJcbmltcG9ydCBnZXREcHIgZnJvbSAnLi4vLi4vdXRpbC9oZCc7XHJcbmltcG9ydCB7IGdldEhvc3RBbGlhc0J5VWlkIH0gZnJvbSAnLi91dGlsL2hvc3RzJztcclxuLyoqXHJcbiAqIEltYWdlIHByb3ZpZGVyIHRoYXQgZ2V0cyBpbWFnZXMgZnJvbSBzcGVjaWZpYyBBUEkgZW50cnkgcG9pbnQuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQXBpSW1hZ2VQcm92aWRlciBleHRlbmRzIEltYWdlUHJvdmlkZXIge1xyXG4gICAgY29uc3RydWN0b3IoaW1hZ2VVcmxUZW1wbGF0ZSkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5faW1hZ2VVcmxUZW1wbGF0ZSA9IGltYWdlVXJsVGVtcGxhdGU7XHJcbiAgICB9XHJcbiAgICBnZXRJbWFnZVVybChpZCkge1xyXG4gICAgICAgIC8vIEFQSSBjYW4gcmV0dXJuIHNjYWxlZCBpbWFnZXMgdGhhdCBhbGxvd3MgdXMgdG8gcmVxdWVzdCBpbWFnZXMgYWNjb3JkaW5nXHJcbiAgICAgICAgLy8gdG8gdXNlcidzIERQSSBhbmQgcmVuZGVyIHRoZW0gcHJvcGVybHksIG5vbi1pbnRlZ2VyIG51bWJlcnMgYXJlIGFjY2VwdGVkLlxyXG4gICAgICAgIHJldHVybiB0aGlzLl9pbWFnZVVybFRlbXBsYXRlXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKCd7e2hvc3RBbGlhc319JywgZ2V0SG9zdEFsaWFzQnlVaWQoaWQpKVxyXG4gICAgICAgICAgICAucmVwbGFjZSgvXFx7XFx7aWRcXH1cXH0vZywgaWQpXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKCd7e3NjYWxlfX0nLCBnZXREcHIoKS50b1N0cmluZygpKTtcclxuICAgIH1cclxufVxyXG4iLCIvKipcclxuICogQWJzdHJhY3QgaW1hZ2UgY29udGVudCBwcm92aWRlciwgY29uY3JldGUgaW1wbGVtZW50YXRpb25zIHNob3VsZCBzcGVjaWZ5IHRoZSBlbnRyeSBwb2ludCBpbiBnZXRJbWFnZVVybCgpLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEltYWdlUHJvdmlkZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGltYWdlIGJpdG1hcCB2aWEgYW4gSFRNTEltYWdlRWxlbWVudCBhbmQgYSBjYW52YXMuXHJcbiAgICAgKi9cclxuICAgIGdldEltYWdlKGlkKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaW1hZ2VFbGVtZW50ID0gbmV3IEltYWdlKCk7XHJcbiAgICAgICAgICAgIGltYWdlRWxlbWVudC5jcm9zc09yaWdpbiA9ICdhbm9ueW1vdXMnO1xyXG4gICAgICAgICAgICBpbWFnZUVsZW1lbnQub25sb2FkID0gKCkgPT4gcmVzb2x2ZShpbWFnZUVsZW1lbnQpO1xyXG4gICAgICAgICAgICBpbWFnZUVsZW1lbnQub25lcnJvciA9IHJlamVjdDtcclxuICAgICAgICAgICAgaW1hZ2VFbGVtZW50LnNyYyA9IHRoaXMuZ2V0SW1hZ2VVcmwoaWQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbiIsIi8qKlxyXG4gKiBHaXZlcyB0aGUgZGV2aWNlIHBpeGVsIHJhdGlvbiBpZiBpdCdzIGdyZWF0ZXIgdGhhbiAxIGFuZCAxIG90aGVyd2lzZS4gVGhpcydzXHJcbiAqIGhlcmUgcHVyZWx5IHRvIGJlIGNvbXBhdGlibGUgd2l0aCBqc2FwaSB3aGljaCBkb2VzIHRoZSBzYW1lIHRoaW5nIGZvciByZWFzb25zXHJcbiAqIHVua25vd3MgKHRoYW5rcywga2FzaGV5KS5cclxuICpcclxuICogQHJldHVybnMgQ2FwcGVkIGRldmljZSBwaXhlbCByYXRpby5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldERwcigpIHtcclxuICAgIHJldHVybiBkZXZpY2VQaXhlbFJhdGlvID4gMSA/IGRldmljZVBpeGVsUmF0aW8gOiAxO1xyXG59XHJcbiIsImNvbnN0IEhPU1RfQUxJQVNFU19OID0gNDtcclxuZXhwb3J0IGZ1bmN0aW9uIGdldEhvc3RBbGlhc0J5VWlkKHVpZCkge1xyXG4gICAgbGV0IHN1bSA9IDA7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVpZC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHN1bSArPSB1aWQuY2hhckNvZGVBdChpKTtcclxuICAgIH1cclxuICAgIHJldHVybiAoc3VtICUgSE9TVF9BTElBU0VTX04gKyAxKS50b1N0cmluZygpO1xyXG59XHJcbiIsImltcG9ydCB7IEF0dHJpYnV0ZU1hcHBpbmcgfSBmcm9tICcuLi8uLi9yZW5kZXIvYXR0cmliX21hcHBpbmcnO1xyXG5pbXBvcnQgQnVmZmVyV3JpdGVyIGZyb20gJy4uLy4uL3V0aWwvYnVmZmVyX3dyaXRlcic7XHJcbi8qKlxyXG4gKiBCYXNlIGNsYXNzIGZvciAzRCBtb2RlbHMgYnVmZmVyIHdyaXRlcnMuIEl0IGlzIG5vdCBzdXBwb3NlZCB0byB3cml0ZSBpbmRpY2VzLCBpbnN0ZWFkIGl0IHdyaXRlcyB2ZXJ0aWNlcyAocG9zc2libHlcclxuICogZHVwbGljYXRlZCkgaW4gb3JkZXIgdGhhdCBjb3JyZXNwb25kIHRvIHRyaWFuZ3VsYXIgZmFjZXRzIG9mIHRoZSBtZXNoLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW9kZWxCdWZmZXJXcml0ZXIgZXh0ZW5kcyBCdWZmZXJXcml0ZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoTW9kZWxCdWZmZXJXcml0ZXIuQVRUUklCVVRFX01BUFBJTkcudmVydGV4Qnl0ZVNpemUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYSB2ZXJ0ZXggdG8gdGhlIHZlcnRleCBidWZmZXIuXHJcbiAgICAgKi9cclxuICAgIF93cml0ZVZlcnRleCh2LCBjb2xvclJnYmE4KSB7XHJcbiAgICAgICAgY29uc3QgdmVydGV4SWR4ID0gdGhpcy5nZXRDdXJyZW50VmVydGV4SWR4KCk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVXb3JsZENvb3JkaW5hdGUodik7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVGbG9hdDMyKHYueik7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVXb3JkKGNvbG9yUmdiYTgpO1xyXG4gICAgICAgIHJldHVybiB2ZXJ0ZXhJZHg7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIERlc2NyaXB0aW9uIG9mIGhvdyBhdHRyaWJ1dGVzIG9mIHZlcnRpY2VzIGFyZSBwYWNrZWQgaW50byBhIHZlcnRleCBidWZmZXIuXHJcbiAqL1xyXG5Nb2RlbEJ1ZmZlcldyaXRlci5BVFRSSUJVVEVfTUFQUElORyA9IG5ldyBBdHRyaWJ1dGVNYXBwaW5nKFtcclxuICAgIFtcclxuICAgICAgICAwIC8qIFBPU0lUSU9OX0hJR0ggKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIzIC8qIFVOU0lHTkVEX1NIT1JUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICAxIC8qIFBPU0lUSU9OX0xPVyAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDIsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjMgLyogVU5TSUdORURfU0hPUlQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDMgLyogSEVJR0hUICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMSxcclxuICAgICAgICAgICAgdHlwZTogNTEyNiAvKiBGTE9BVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDcgLyogQ09MT1IgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiA0LFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIxIC8qIFVOU0lHTkVEX0JZVEUgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcclxuICAgICAgICB9XHJcbiAgICBdXHJcbl0pO1xyXG4iLCJpbXBvcnQgeyBBdHRyaWJ1dGVNYXBwaW5nIH0gZnJvbSAnLi4vLi4vcmVuZGVyL2F0dHJpYl9tYXBwaW5nJztcclxuaW1wb3J0IEJ1ZmZlcldyaXRlciBmcm9tICcuLi8uLi91dGlsL2J1ZmZlcl93cml0ZXInO1xyXG5pbXBvcnQgd3JpdGVUZXh0dXJlZFBvbHlsaW5lR2VvbWV0cnkgZnJvbSAnLi90ZXh0dXJlZF9wb2x5bGluZV9nZW9tZXRyeSc7XHJcbmltcG9ydCB7IGludFRvWkluZGV4IH0gZnJvbSAnLi4vLi4vdXRpbC96X2luZGV4JztcclxuLyoqXHJcbiAqIFdyaXRlciBvZiBnZW9tZXRyeSBkYXRhIG9mIHBvbHlsaW5lIGh1bGxzLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGV4dHVyZWRQb2x5bGluZUJ1ZmZlcldyaXRlciBleHRlbmRzIEJ1ZmZlcldyaXRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcihUZXh0dXJlZFBvbHlsaW5lQnVmZmVyV3JpdGVyLkFUVFJJQlVURV9NQVBQSU5HLnZlcnRleEJ5dGVTaXplKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJhdGVzIGEgaHVsbCBmb3IgYSBwb2x5bGluZSBhbmQgd3JpdGVzIGl0IHRvIHRoZSB3cml0ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBvbHlsaW5lIFRoZSBwb2x5bGluZSB0byBiZSB3cml0dGVuLlxyXG4gICAgICogQHBhcmFtIHdpZHRoIFRoaWNrbmVzcyBvZiB0aGUgcG9seWxpbmUuXHJcbiAgICAgKiBAcGFyYW0gd29ybGRUb1B4RmFjdG9yIFJhdGlvIG9mIHdvcmxkIGNvb3JkaW5hdGVzIHRvIHBpeGVscy5cclxuICAgICAqIEBwYXJhbSBpbWFnZUxvY2F0aW9uIEltYWdlIGxvY2F0aW9uIGluIGF0bGFzLlxyXG4gICAgICogQHBhcmFtIHpJbmRleCBaLWluZGV4IG9mIHRoZSBwb2x5bGluZS5cclxuICAgICAqL1xyXG4gICAgd3JpdGVUZXh0dXJlZFBvbHlsaW5lKHBvbHlsaW5lLCB3aWR0aCwgd29ybGRUb1B4RmFjdG9yLCBpbWFnZUxvY2F0aW9uLCB6SW5kZXgpIHtcclxuICAgICAgICB3cml0ZVRleHR1cmVkUG9seWxpbmVHZW9tZXRyeSh0aGlzLCBwb2x5bGluZS52ZXJ0aWNlcywgd29ybGRUb1B4RmFjdG9yLCBpbWFnZUxvY2F0aW9uLCB3aWR0aCwgaW50VG9aSW5kZXgoekluZGV4ICsgMSkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVuZE1lc2goKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGEgdmVydGV4IHRvIHRoZSB2ZXJ0ZXggYnVmZmVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwb3NpdGlvbiBQb3NpdGlvbiBvZiB0aGUgdmVydGV4IGluIHdvcmxkIGNvb3JkaW5hdGVzLlxyXG4gICAgICogQHBhcmFtIGRpc3BsYWNlbWVudCBEaXNwbGFjZW1lbnQgdmVjdG9yLCBpbiBtb3N0IGNhc2VzIG11c3QgYmUgbm9ybWFsaXplZCwgdGhlIHdpZHRoIGlzIGNvbnNpZGVyZWQgaW4gc2hhZGVycy5cclxuICAgICAqIEBwYXJhbSBoYWxmV2lkdGggVGhpY2tuZXNzIG9mIHRoZSBwb2x5bGluZS5cclxuICAgICAqIEBwYXJhbSBwYXR0ZXJXaWR0aCBXaWR0aCBvZiB0aGUgaW1hZ2UgdGhhdCBpcyByZXBlYXRlZCBhbG9uZyB0aGUgcG9seWxpbmUuXHJcbiAgICAgKiBAcGFyYW0gcGF0dGVybkhhbGZIZWlnaHQgSW1hZ2UgaGFsZiBoZWlnaHQgbXVsdGlwbGllZCBieSBgc2lnbihzKWAsIHdoZXJlIGBzYCBpcyBhIFstMTsgMV0gZGlzdGFuY2UgdG8gdGhlXHJcbiAgICAgKiBhbmFseXRpY2FsIHBvbHlsaW5lIGFsb25nIHNlZ21lbnQncyBub3JtYWwuXHJcbiAgICAgKiBAcGFyYW0gbGVuZ3RoIExlbmd0aCBvZiB0aGUgcG9seWxpbmUgZm9yIGN1cnJlbnQgdmVydGV4LCBuZWVkZWQgdG8gY29ycmVjdGx5IGNhbGN1bGF0ZSBpbWFnZSB1diB4IGNvb3JkaW5hdGUuXHJcbiAgICAgKiBAcGFyYW0gdXYgVVYgY29vcmRpbmF0ZXMgb2YgdGhlIGltYWdlLlxyXG4gICAgICogQHBhcmFtIHpJbmRleCBaLWluZGV4IG9mIHRoZSBwb2x5bGluZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIEluZGV4IG9mIHRoZSB3cml0dGVuIHZlcnRleC5cclxuICAgICAqL1xyXG4gICAgd3JpdGVWZXJ0ZXgocG9zaXRpb24sIGRpc3BsYWNlbWVudCwgaGFsZldpZHRoLCBwYXR0ZXJuV2lkdGgsIHBhdHRlcm5IYWxmSGVpZ2h0LCBsZW5ndGgsIHV2LCB6SW5kZXgpIHtcclxuICAgICAgICBjb25zdCB2ZXJ0ZXhJZHggPSB0aGlzLmdldEN1cnJlbnRWZXJ0ZXhJZHgoKTtcclxuICAgICAgICB0aGlzLl93cml0ZVdvcmxkQ29vcmRpbmF0ZShwb3NpdGlvbik7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVGbG9hdDMyKGRpc3BsYWNlbWVudC54KTtcclxuICAgICAgICB0aGlzLl93cml0ZUZsb2F0MzIoZGlzcGxhY2VtZW50LnkpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlSGFsZldvcmRzKHV2LngsIHV2LnkpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlRmxvYXQzMih6SW5kZXgpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlRmxvYXQzMihoYWxmV2lkdGgpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlSGFsZldvcmRzKHBhdHRlcm5XaWR0aCwgbGVuZ3RoKTtcclxuICAgICAgICB0aGlzLl93cml0ZUZsb2F0MzIocGF0dGVybkhhbGZIZWlnaHQpO1xyXG4gICAgICAgIHJldHVybiB2ZXJ0ZXhJZHg7XHJcbiAgICB9XHJcbn1cclxuLyoqIERlc2NyaXB0aW9uIG9mIGhvdyBhIHdyaXRlciBzdG9yZXMgdmVydGV4IGRhdGEuICovXHJcblRleHR1cmVkUG9seWxpbmVCdWZmZXJXcml0ZXIuQVRUUklCVVRFX01BUFBJTkcgPSBuZXcgQXR0cmlidXRlTWFwcGluZyhbXHJcbiAgICBbXHJcbiAgICAgICAgMCAvKiBQT1NJVElPTl9ISUdIICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMixcclxuICAgICAgICAgICAgdHlwZTogNTEyMyAvKiBVTlNJR05FRF9TSE9SVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgMSAvKiBQT1NJVElPTl9MT1cgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIzIC8qIFVOU0lHTkVEX1NIT1JUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICA2IC8qIERJU1BMQUNFTUVOVCAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDIsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjYgLyogRkxPQVQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICA0IC8qIFVWICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMixcclxuICAgICAgICAgICAgdHlwZTogNTEyMyAvKiBVTlNJR05FRF9TSE9SVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDkgLyogUFJJT1JJVFkgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAxLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTI2IC8qIEZMT0FUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgMTEgLyogQVVYICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMSxcclxuICAgICAgICAgICAgdHlwZTogNTEyNiAvKiBGTE9BVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDEyIC8qIEFVWDEgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIzIC8qIFVOU0lHTkVEX1NIT1JUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgMTMgLyogQVVYMiAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDEsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjYgLyogRkxPQVQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgXVxyXG5dKTtcclxuIiwiaW1wb3J0ICogYXMgdmVjMiBmcm9tICcuLi8uLi9tYXRoL3ZlY3RvcjInO1xyXG4vKipcclxuICogV3JpdGVzIHBvbHlsaW5lIGltYWdlIGdlb21ldHJ5IChzZXQgb2YgdHJpYW5nbGVzIHRoYXQgZHJhdyB1cCBhIHNvbGlkIHRoaWNrIHBvbHlsaW5lKSBpbnRvIGEgYnVmZmVyIHdyaXRlci5cclxuICpcclxuICogQHBhcmFtIHdyaXRlciBPdXRwdXQgYnVmZmVyIHdyaXRlci5cclxuICogQHBhcmFtIHBvbHlsaW5lIFBvbHlsaW5lIHRvIGJlIHdyaXR0ZW4uXHJcbiAqIEBwYXJhbSB3b3JsZFRvUHhGYWN0b3IgUmF0aW8gb2Ygd29ybGQgY29vcmRpbmF0ZXMgdG8gcGl4ZWxzLlxyXG4gKiBAcGFyYW0gaW1hZ2VMb2NhdGlvbiBJbWFnZSBsb2NhdGlvbiBpbiBhdGxhcy5cclxuICogQHBhcmFtIHdpZHRoIFRoaWNrbmVzcyBvZiB0aGUgcG9seWxpbmUuXHJcbiAqIEBwYXJhbSB6IFotaW5kZXggb2YgdGhlIHBvbHlsaW5lLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gd3JpdGVUZXh0dXJlZFBvbHlsaW5lR2VvbWV0cnkod3JpdGVyLCBwb2x5bGluZSwgd29ybGRUb1B4RmFjdG9yLCBpbWFnZUxvY2F0aW9uLCB3aWR0aCwgeikge1xyXG4gICAgY29uc3QgaFdpZHRoID0gd2lkdGggLyAyO1xyXG4gICAgY29uc3QgcGF0dGVybldpZHRoID0gaW1hZ2VMb2NhdGlvbi5tYXhYIC0gaW1hZ2VMb2NhdGlvbi5taW5YO1xyXG4gICAgY29uc3QgcGF0dGVybkhhbGZIZWlnaHQgPSAoaW1hZ2VMb2NhdGlvbi5tYXhZIC0gaW1hZ2VMb2NhdGlvbi5taW5ZKSAvIDI7XHJcbiAgICBjb25zdCBzZWdtZW50ID0gdmVjMi5jcmVhdGUoMCwgMCk7XHJcbiAgICBjb25zdCBkaXIgPSB2ZWMyLmNyZWF0ZSgwLCAwKTtcclxuICAgIGNvbnN0IHByZXZEaXIgPSB2ZWMyLmNyZWF0ZSgwLCAwKTtcclxuICAgIGNvbnN0IG5vcm0gPSB2ZWMyLmNyZWF0ZSgwLCAwKTtcclxuICAgIGNvbnN0IG5vcm1JbnYgPSB2ZWMyLmNyZWF0ZSgwLCAwKTtcclxuICAgIGNvbnN0IHV2ID0gdmVjMi5jcmVhdGUoaW1hZ2VMb2NhdGlvbi5taW5YLCAwKTtcclxuICAgIGxldCBwcmV2Qm90dG9tUmlnaHQgPSAtMTtcclxuICAgIGxldCBwcmV2VG9wUmlnaHQgPSAtMTtcclxuICAgIGxldCBsZW5ndGggPSAwO1xyXG4gICAgbGV0IHByZXZMZW5ndGggPSAwO1xyXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwb2x5bGluZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZlYzIuc3ViKHBvbHlsaW5lW2ldLCBwb2x5bGluZVtpIC0gMV0sIHNlZ21lbnQpO1xyXG4gICAgICAgIHZlYzIubm9ybWFsaXplKHNlZ21lbnQsIGRpcik7XHJcbiAgICAgICAgdmVjMi5yb3RhdGU5MChkaXIsIG5vcm0pO1xyXG4gICAgICAgIHZlYzIubXVsbihub3JtLCAtMSwgbm9ybUludik7XHJcbiAgICAgICAgLy8gc2VnbWVudCBpcyB3cml0dGVuIGFzIGEgcmVjdGFuZ2xlICh0d28gdHJpYW5nbGVzKVxyXG4gICAgICAgIHV2LnkgPSBpbWFnZUxvY2F0aW9uLm1pblk7XHJcbiAgICAgICAgY29uc3QgdG9wTGVmdCA9IHdyaXRlci53cml0ZVZlcnRleChwb2x5bGluZVtpIC0gMV0sIG5vcm0sIGhXaWR0aCwgcGF0dGVybldpZHRoLCBwYXR0ZXJuSGFsZkhlaWdodCwgbGVuZ3RoLCB1diwgeik7XHJcbiAgICAgICAgdXYueSA9IGltYWdlTG9jYXRpb24ubWF4WTtcclxuICAgICAgICBjb25zdCBib3R0b21MZWZ0ID0gd3JpdGVyLndyaXRlVmVydGV4KHBvbHlsaW5lW2kgLSAxXSwgbm9ybUludiwgaFdpZHRoLCBwYXR0ZXJuV2lkdGgsIC1wYXR0ZXJuSGFsZkhlaWdodCwgbGVuZ3RoLCB1diwgeik7XHJcbiAgICAgICAgLy8gdXBkYXRlIGxlbmd0aCBvZiB0aGUgcG9seWxpbmUgaW4gcGl4ZWxzXHJcbiAgICAgICAgbGVuZ3RoICs9IHZlYzIubGVuZ3RoKHNlZ21lbnQpIC8gd29ybGRUb1B4RmFjdG9yO1xyXG4gICAgICAgIHV2LnkgPSBpbWFnZUxvY2F0aW9uLm1pblk7XHJcbiAgICAgICAgY29uc3QgdG9wUmlnaHQgPSB3cml0ZXIud3JpdGVWZXJ0ZXgocG9seWxpbmVbaV0sIG5vcm0sIGhXaWR0aCwgcGF0dGVybldpZHRoLCBwYXR0ZXJuSGFsZkhlaWdodCwgbGVuZ3RoLCB1diwgeik7XHJcbiAgICAgICAgdXYueSA9IGltYWdlTG9jYXRpb24ubWF4WTtcclxuICAgICAgICBjb25zdCBib3R0b21SaWdodCA9IHdyaXRlci53cml0ZVZlcnRleChwb2x5bGluZVtpXSwgbm9ybUludiwgaFdpZHRoLCBwYXR0ZXJuV2lkdGgsIC1wYXR0ZXJuSGFsZkhlaWdodCwgbGVuZ3RoLCB1diwgeik7XHJcbiAgICAgICAgLy8gd3JpdGUgbGluZSBqb2luIHRoYXQgZmlsbHMgYW4gZW1wdHkgc3BhY2Ugb24gY29ybmVyc1xyXG4gICAgICAgIGlmICgxIDwgaSAmJiBpIDwgcG9seWxpbmUubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHV2LnkgPSAoaW1hZ2VMb2NhdGlvbi5tYXhZICsgaW1hZ2VMb2NhdGlvbi5taW5ZKSAvIDI7XHJcbiAgICAgICAgICAgIGNvbnN0IGpvaW5Qb2ludEluZGV4ID0gd3JpdGVyLndyaXRlVmVydGV4KHBvbHlsaW5lW2kgLSAxXSwgdmVjMi5aRVJPLCBoV2lkdGgsIHBhdHRlcm5XaWR0aCwgMCwgcHJldkxlbmd0aCwgdXYsIHopO1xyXG4gICAgICAgICAgICAvLyBmaW5kIG91dCB3aGVyZSB0aGUgZnJhY3R1cmUgb2Ygc2VnbWVudHMgaXMgbG9jYXRlZCB0byBjcmVhdGUgY29ycmVjdCBqb2luIHdpdGggbWluaW11bSBvdmVyZHJhd1xyXG4gICAgICAgICAgICBjb25zdCB0dXJuTGVmdCA9IHZlYzIuY3Jvc3NaKHByZXZEaXIsIGRpcikgPiAwO1xyXG4gICAgICAgICAgICBpZiAodHVybkxlZnQpIHtcclxuICAgICAgICAgICAgICAgIHdyaXRlci53cml0ZUluZGljZXMoW1xyXG4gICAgICAgICAgICAgICAgICAgIGpvaW5Qb2ludEluZGV4LCBib3R0b21MZWZ0LCBwcmV2Qm90dG9tUmlnaHRcclxuICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgd3JpdGVyLndyaXRlSW5kaWNlcyhbXHJcbiAgICAgICAgICAgICAgICAgICAgam9pblBvaW50SW5kZXgsIHByZXZUb3BSaWdodCwgdG9wTGVmdFxyXG4gICAgICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgd3JpdGVyLndyaXRlSW5kaWNlcyhbXHJcbiAgICAgICAgICAgIHRvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0LFxyXG4gICAgICAgICAgICB0b3BSaWdodCwgYm90dG9tUmlnaHQsIGJvdHRvbUxlZnRcclxuICAgICAgICBdKTtcclxuICAgICAgICB2ZWMyLmNvcHkoZGlyLCBwcmV2RGlyKTtcclxuICAgICAgICBwcmV2Qm90dG9tUmlnaHQgPSBib3R0b21SaWdodDtcclxuICAgICAgICBwcmV2VG9wUmlnaHQgPSB0b3BSaWdodDtcclxuICAgICAgICBwcmV2TGVuZ3RoID0gbGVuZ3RoO1xyXG4gICAgfVxyXG59XHJcbiIsImNvbnN0IE1JTl9aSU5ERVggPSAtMSArIE1hdGgucG93KDIsIDEgLSAyNCk7IC8vIGVwc2lsb24gaXMgYWRkZWQgKGZvciBub3JtYWxpemVkIDI0LWJpdCB2YWx1ZSkgdG8gZnJlZSB1cCByZXNlcnZlZCB2YWx1ZVxyXG5leHBvcnQgZnVuY3Rpb24gaW50VG9aSW5kZXgoeCkge1xyXG4gICAgcmV0dXJuIE1hdGgubWF4KE1JTl9aSU5ERVgsIHggLyAweDdmZmZmZik7XHJcbn1cclxuIiwiLyoqXHJcbiAqIE1hbmFnZXMgYWxsb2NhdGlvbiBvZiByZXF1ZXN0ZWQgaW1hZ2VzLiBUaGUgc2FtZSBpbWFnZXMgY2FuIGJlIHJlcXVlc3RlZCBtdWx0aXBsZSB0aW1lcyBmcm9tIGRpZmZlcmVudCBwbGFjZXMsXHJcbiAqIHRoaXMgY2xhc3MgdGFrZXMgb3ZlciBkdXBsaWNhdGlvbiBvZiBIVFRQIHJlcXVlc3RzL2F0bGFzIGFsbG9jYXRpb25zIHByb3ZpZGluZyBzaW1wbGUgYXN5bmMgaW50ZXJmYWNlIGZvclxyXG4gKiBnZXR0aW5nIGFsbG9jYXRlZCBpbWFnZXMuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgSW1hZ2VNYW5hZ2VyIHtcclxuICAgIGNvbnN0cnVjdG9yKGF0bGFzLCBwcm92aWRlcikge1xyXG4gICAgICAgIHRoaXMuX2F0bGFzID0gYXRsYXM7XHJcbiAgICAgICAgdGhpcy5fcHJvdmlkZXIgPSBwcm92aWRlcjtcclxuICAgICAgICB0aGlzLl9yZXF1ZXN0cyA9IG5ldyBNYXAoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBpbWFnZSBpZiBpdCBpcyBhbHJlYWR5IGFsbG9jYXRlZC4gUGF5IGF0dGVudGlvbiB0aGF0IHJlc3VsdGVkIGFsbG9jYXRlZCBpbWFnZSBpcyBcInJldGFpbmVkXCIsXHJcbiAgICAgKiBzbyBpdCBtdXN0IGJlIHJlbGVhc2VkIG9uY2UgaXQgaXMgcGFzc2VkIHRvIGEgcmVzcG9uc2libGUgY2xpZW50LlxyXG4gICAgICovXHJcbiAgICBnZXRJbWFnZShpZCkge1xyXG4gICAgICAgIGNvbnN0IGltYWdlID0gdGhpcy5fYXRsYXMuZ2V0SW1hZ2UoaWQsIHRydWUpO1xyXG4gICAgICAgIGlmIChpbWFnZSkge1xyXG4gICAgICAgICAgICBpbWFnZS5yZXRhaW4oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGltYWdlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXF1ZXN0IGltYWdlIGZyb20gaW1hZ2UgcHJvdmlkZXIsIGlmIGl0IGlzIGFscmVhZHkgYWxsb2NhdGVkIG5vIHJlcXVlc3QgaXMgbWFkZSwgYnV0IGl0IGlzIHJldHVybmVkXHJcbiAgICAgKiB3cmFwcGVkIGludG8gYSByZXNvbHZlZCBwcm9taXNlLiBQYXkgYXR0ZW50aW9uIHRoYXQgcmVzdWx0ZWQgYWxsb2NhdGVkIGltYWdlIGlzIFwicmV0YWluZWRcIiwgc28gaXQgbXVzdCBiZVxyXG4gICAgICogcmVsZWFzZWQgb25jZSBpdCBpcyBwYXNzZWQgdG8gYSByZXNwb25zaWJsZSBjbGllbnQuXHJcbiAgICAgKi9cclxuICAgIHJlcXVlc3RJbWFnZShpZCkge1xyXG4gICAgICAgIGNvbnN0IGFsbG9jYXRlZEltYWdlID0gdGhpcy5fYXRsYXMuZ2V0SW1hZ2UoaWQsIHRydWUpO1xyXG4gICAgICAgIGlmIChhbGxvY2F0ZWRJbWFnZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGFsbG9jYXRlZEltYWdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLl9yZXF1ZXN0cy5nZXQoaWQpO1xyXG4gICAgICAgICAgICBpZiAocmVxdWVzdCkge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC50aGVuKChhbGxvY2F0ZWRJbWFnZSkgPT4gYWxsb2NhdGVkSW1hZ2UgJiYgYWxsb2NhdGVkSW1hZ2UucmV0YWluKCkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5fcHJvdmlkZXJcclxuICAgICAgICAgICAgICAgICAgICAuZ2V0SW1hZ2UoaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKGltYWdlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVxdWVzdHMuZGVsZXRlKGlkKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGltYWdlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFsbG9jYXRlZEltYWdlID0gdGhpcy5fYXRsYXMuYWxsb2NhdGVJbWFnZSh7IGlkLCB3aWR0aCwgaGVpZ2h0IH0sIGltYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWFsbG9jYXRlZEltYWdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGRuXFwnIGFsbG9jYXRlZCBpbWFnZScpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFsbG9jYXRlZEltYWdlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXF1ZXN0cy5kZWxldGUoaWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2UgcmVxdWVzdCBmYWlsZWQnKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVxdWVzdHMuc2V0KGlkLCByZXF1ZXN0KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXF1ZXN0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCBCdWZmZXJSZXdyaXRlciBmcm9tICcuLi8uLi91dGlsL2J1ZmZlcl9yZXdyaXRlcic7XHJcbmltcG9ydCB7IFRFWFRVUkVEX1BPTFlHT05fQVRUUklCVVRFX01BUFBJTkcgfSBmcm9tICcuL3RleHR1cmVkX3BvbHlnb25fYXR0cmlidXRlX21hcHBpbmcnO1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXh0dXJlZFBvbHlnb25CdWZmZXJSZXdyaXRlciBleHRlbmRzIEJ1ZmZlclJld3JpdGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGJ1ZmZlcnMpIHtcclxuICAgICAgICBzdXBlcihURVhUVVJFRF9QT0xZR09OX0FUVFJJQlVURV9NQVBQSU5HLCBidWZmZXJzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGxvY2F0aW9uIExvY2F0aW9uIG9mIHRoZSBwb2x5Z29uIGluIG1lbW9yeS5cclxuICAgICAqIEBwYXJhbSBpbWFnZUxvY2F0aW9uIExvY2F0aW9uIG9mIHRoZSBwYXR0ZXJuIGluIGF0bGFzLlxyXG4gICAgICogQHBhcmFtIGltYWdlU2NhbGUgSG93IHdvcmxkIGNvb3JkaW5hdGVzIHJlbGF0ZSB0byB0aGUgaW1hZ2Ugc2l6ZS5cclxuICAgICAqL1xyXG4gICAgcmV3cml0ZVVWKGxvY2F0aW9uLCBpbWFnZUxvY2F0aW9uLCBpbWFnZVNjYWxlKSB7XHJcbiAgICAgICAgY29uc3QgdXZPZmZzZXQgPSB0aGlzLl9nZXRBdHRyaWJPZmZzZXQoNCAvKiBVViAqLyk7XHJcbiAgICAgICAgY29uc3Qgc2NhbGVPZmZzZXQgPSB0aGlzLl9nZXRBdHRyaWJPZmZzZXQoMTEgLyogQVVYICovKTtcclxuICAgICAgICB0aGlzLl9mb3JFYWNoVmVydGV4KGxvY2F0aW9uLCAod3JpdGVyKSA9PiB7XHJcbiAgICAgICAgICAgIHdyaXRlci53cml0ZUhhbGZXb3Jkcyh1dk9mZnNldCwgaW1hZ2VMb2NhdGlvbi5taW5YLCBpbWFnZUxvY2F0aW9uLm1pblkpO1xyXG4gICAgICAgICAgICB3cml0ZXIud3JpdGVIYWxmV29yZHModXZPZmZzZXQgKyAxLCBpbWFnZUxvY2F0aW9uLm1heFggLSBpbWFnZUxvY2F0aW9uLm1pblgsIGltYWdlTG9jYXRpb24ubWF4WSAtIGltYWdlTG9jYXRpb24ubWluWSk7XHJcbiAgICAgICAgICAgIHdyaXRlci53cml0ZUZsb2F0MzIoc2NhbGVPZmZzZXQsIGltYWdlU2NhbGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IFdPUkRfQllURV9TSVpFIH0gZnJvbSAnLi9idWZmZXJfd3JpdGVyJztcclxuLyoqXHJcbiAqIENsYXNzIHRoYXQgaXMgZXhwb3NlZCBhcyBhbiBpbnRlcmZhY2UgZm9yIHdyaXRpbmcgdG8gYSBzcGVjaWZpYyB2ZXJ0ZXggYXR0cmlidXRlLlxyXG4gKi9cclxuY2xhc3MgVmVydGV4V3JpdGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHZlcnRleEJ1ZmZlcikge1xyXG4gICAgICAgIHRoaXMuX3ZlcnRleEJ1ZmZlciA9IG5ldyBVaW50MzJBcnJheSh2ZXJ0ZXhCdWZmZXIuYnVmZmVyLCAwLCB2ZXJ0ZXhCdWZmZXIubGVuZ3RoKTtcclxuICAgICAgICB0aGlzLl92ZXJ0ZXhCdWZmZXJGbG9hdDMyVmlldyA9IG5ldyBGbG9hdDMyQXJyYXkodmVydGV4QnVmZmVyLmJ1ZmZlciwgMCwgdmVydGV4QnVmZmVyLmxlbmd0aCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBmbG9hdCBhdHRyaWJ1dGUgaW50byBzcGVjaWZpYyBwb3NpdGlvbiBpbiBidWZmZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGF0dHJpYk9mZnNldCBPZmZzZXQgb2YgYW4gYXR0cmlidXRlIGluIHdvcmRzICg0IGJ5dGVzKSwgZ2V0IGl0IGZyb20gQnVmZmVyUmV3cml0ZXIjX2dldEF0dHJpYk9mZnNldCgpLlxyXG4gICAgICogQHBhcmFtIHZhbHVlIFZhbHVlIHRvIGJlIHdyaXR0ZW4uXHJcbiAgICAgKi9cclxuICAgIHdyaXRlRmxvYXQzMihhdHRyaWJPZmZzZXQsIHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fdmVydGV4QnVmZmVyRmxvYXQzMlZpZXdbdGhpcy52ZXJ0ZXhPZmZzZXQgKyBhdHRyaWJPZmZzZXRdID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIHdvcmQgYXR0cmlidXRlIGludG8gc3BlY2lmaWMgcG9zaXRpb24gaW4gYnVmZmVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhdHRyaWJPZmZzZXQgT2Zmc2V0IG9mIGFuIGF0dHJpYnV0ZSBpbiB3b3JkcyAoNCBieXRlcyksIGdldCBpdCBmcm9tIEJ1ZmZlclJld3JpdGVyI19nZXRBdHRyaWJPZmZzZXQoKS5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSBWYWx1ZSB0byBiZSB3cml0dGVuLlxyXG4gICAgICovXHJcbiAgICB3cml0ZVdvcmQoYXR0cmliT2Zmc2V0LCB2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX3ZlcnRleEJ1ZmZlclt0aGlzLnZlcnRleE9mZnNldCArIGF0dHJpYk9mZnNldF0gPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIHR3byBoYWxmIHdvcmQgYXR0cmlidXRlIHZhbHVlcyBpbnRvIHNwZWNpZmljIHBvc2l0aW9uIGluIGJ1ZmZlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYXR0cmliT2Zmc2V0IE9mZnNldCBvZiBhbiBhdHRyaWJ1dGUgaW4gd29yZHMgKDQgYnl0ZXMpLCBnZXQgaXQgZnJvbSBCdWZmZXJSZXdyaXRlciNfZ2V0QXR0cmliT2Zmc2V0KCkuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgVmFsdWUgdG8gYmUgd3JpdHRlbi5cclxuICAgICAqL1xyXG4gICAgd3JpdGVIYWxmV29yZHMoYXR0cmliT2Zmc2V0LCB2MSwgdjIpIHtcclxuICAgICAgICB0aGlzLndyaXRlV29yZChhdHRyaWJPZmZzZXQsIHYyIDw8IDE2IHwgdjEgJiAweGZmZmYpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBQcm92aWRlcyBzb21lIHV0aWxzIGZvciByZXdyaXRpbmcgdmVydGV4IGF0dHJpYnV0ZSB2YWx1ZXMsIHNlZSBWZXJ0ZXhXcml0ZXIgYW5kIHRlc3RzIGZvciBzb21lIHRpcHMgb2YgaG93IHRvIGRvIGl0LlxyXG4gKiBUT0RPOiBjb25zaWRlciBzdXBwb3J0aW5nIG9mIHNlcGFyYXRlIGJ1ZmZlcnMgZm9yIGRpZmZlcmVudCBhdHRyaWJ1dGVzLCB0aGF0IHdpbGwgbWFrZSB0aGlzIGNsYXNzIGxlc3MgdXNlZnVsXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCdWZmZXJSZXdyaXRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihhdHRyaWJNYXBwaW5nLCBidWZmZXJzKSB7XHJcbiAgICAgICAgdGhpcy5fYXR0cmliTWFwcGluZyA9IGF0dHJpYk1hcHBpbmc7XHJcbiAgICAgICAgdGhpcy5fYnVmZmVycyA9IGJ1ZmZlcnM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdhbGtzIG92ZXIgYWxsIHZlcnRpY2VzIGV4cG9zaW5nIFZlcnRleFdyaXRlciBmb3IgZWFjaCBvbmUgYnkgY2FsbGluZyB0aGUgaGFuZGxlciBhcmd1bWVudC5cclxuICAgICAqL1xyXG4gICAgX2ZvckVhY2hWZXJ0ZXgobG9jYXRpb24sIGhhbmRsZXIpIHtcclxuICAgICAgICBjb25zdCB2ZXJ0ZXhXcml0ZXIgPSBuZXcgVmVydGV4V3JpdGVyKHRoaXMuX2J1ZmZlcnNbbG9jYXRpb24uYnVmZmVySW5kZXhdLnZlcnRleEJ1ZmZlcik7XHJcbiAgICAgICAgY29uc3QgdmVydGV4Qnl0ZVNpemUgPSB0aGlzLl9hdHRyaWJNYXBwaW5nLnZlcnRleEJ5dGVTaXplO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jYXRpb24udmVydGV4Qnl0ZUxlbmd0aDsgaSArPSB2ZXJ0ZXhCeXRlU2l6ZSkge1xyXG4gICAgICAgICAgICB2ZXJ0ZXhXcml0ZXIudmVydGV4T2Zmc2V0ID0gKGxvY2F0aW9uLnZlcnRleEJ5dGVPZmZzZXQgKyBpKSAvIFdPUkRfQllURV9TSVpFO1xyXG4gICAgICAgICAgICBoYW5kbGVyKHZlcnRleFdyaXRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBPZmZzZXQgaW4gd29yZHMgKDQgYnl0ZXMpIG9mIHNwZWNpZmljIGF0dHJpYnV0ZSBpbiBhIHZlcnRleCAoZm9ybWF0IGlzIGRlZmluZWQgYnkgQXR0cmlidXRlTWFwcGluZykuXHJcbiAgICAgKi9cclxuICAgIF9nZXRBdHRyaWJPZmZzZXQoYXR0cmliKSB7XHJcbiAgICAgICAgY29uc3QgYXR0cmliUG9pbnRlciA9IHRoaXMuX2F0dHJpYk1hcHBpbmcuZ2V0KGF0dHJpYik7XHJcbiAgICAgICAgcmV0dXJuIGF0dHJpYlBvaW50ZXIgPyBhdHRyaWJQb2ludGVyLm9mZnNldCAvIFdPUkRfQllURV9TSVpFIDogLTE7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgQXR0cmlidXRlTWFwcGluZyB9IGZyb20gJy4uLy4uL3JlbmRlci9hdHRyaWJfbWFwcGluZyc7XHJcbi8qKlxyXG4gKiBEZXNjcmlwdGlvbiBvZiBob3cgYXR0cmlidXRlcyBvZiB2ZXJ0aWNlcyBhcmUgcGFja2VkIGludG8gYSB2ZXJ0ZXggYnVmZmVyLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IFRFWFRVUkVEX1BPTFlHT05fQVRUUklCVVRFX01BUFBJTkcgPSBuZXcgQXR0cmlidXRlTWFwcGluZyhbXHJcbiAgICBbXHJcbiAgICAgICAgMCAvKiBQT1NJVElPTl9ISUdIICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMixcclxuICAgICAgICAgICAgdHlwZTogNTEyMyAvKiBVTlNJR05FRF9TSE9SVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgMSAvKiBQT1NJVElPTl9MT1cgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIzIC8qIFVOU0lHTkVEX1NIT1JUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICA0IC8qIFVWICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogNCxcclxuICAgICAgICAgICAgdHlwZTogNTEyMyAvKiBVTlNJR05FRF9TSE9SVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDExIC8qIEFVWCAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDEsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjYgLyogRkxPQVQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICAxMCAvKiBaX0lOREVYICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMSxcclxuICAgICAgICAgICAgdHlwZTogNTEyNiAvKiBGTE9BVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICBdXHJcbl0pO1xyXG4iLCJpbXBvcnQgeyBBdHRyaWJ1dGVNYXBwaW5nIH0gZnJvbSAnLi4vLi4vcmVuZGVyL2F0dHJpYl9tYXBwaW5nJztcclxuLyoqXHJcbiAqIERlc2NyaXB0aW9uIG9mIGhvdyBhdHRyaWJ1dGVzIG9mIHZlcnRpY2VzIGFyZSBwYWNrZWQgaW50byBhIHZlcnRleCBidWZmZXIuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgUE9MWUdPTl9BVFRSSUJVVEVfTUFQUElORyA9IG5ldyBBdHRyaWJ1dGVNYXBwaW5nKFtcclxuICAgIFtcclxuICAgICAgICAwIC8qIFBPU0lUSU9OX0hJR0ggKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIzIC8qIFVOU0lHTkVEX1NIT1JUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICAxIC8qIFBPU0lUSU9OX0xPVyAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDIsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjMgLyogVU5TSUdORURfU0hPUlQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDcgLyogQ09MT1IgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiA0LFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIxIC8qIFVOU0lHTkVEX0JZVEUgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDEwIC8qIFpfSU5ERVggKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAxLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTI2IC8qIEZMT0FUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgIF1cclxuXSk7XHJcbiIsImltcG9ydCB7IEF0dHJpYnV0ZU1hcHBpbmcgfSBmcm9tICcuLi8uLi9yZW5kZXIvYXR0cmliX21hcHBpbmcnO1xyXG4vKiogRGVzY3JpcHRpb24gb2YgaG93IGEgd3JpdGVyIHN0b3JlcyB2ZXJ0ZXggZGF0YS4gKi9cclxuZXhwb3J0IGNvbnN0IEJJTExCT0FSRF9SRUNUQU5HTEVfQVRUUklCVVRFX01BUFBJTkcgPSBuZXcgQXR0cmlidXRlTWFwcGluZyhbXHJcbiAgICBbXHJcbiAgICAgICAgMiAvKiBJRCAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDQsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjEgLyogVU5TSUdORURfQllURSAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgMCAvKiBQT1NJVElPTl9ISUdIICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMixcclxuICAgICAgICAgICAgdHlwZTogNTEyMyAvKiBVTlNJR05FRF9TSE9SVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgMSAvKiBQT1NJVElPTl9MT1cgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIzIC8qIFVOU0lHTkVEX1NIT1JUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICA2IC8qIERJU1BMQUNFTUVOVCAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDIsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjYgLyogRkxPQVQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICA0IC8qIFVWICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMixcclxuICAgICAgICAgICAgdHlwZTogNTEyMiAvKiBTSE9SVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgNyAvKiBDT0xPUiAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDQsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjEgLyogVU5TSUdORURfQllURSAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgMTEgLyogQVVYICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMixcclxuICAgICAgICAgICAgdHlwZTogNTEyMyAvKiBVTlNJR05FRF9TSE9SVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF1cclxuXSk7XHJcbiIsImltcG9ydCB7IEF0dHJpYnV0ZU1hcHBpbmcgfSBmcm9tICcuLi8uLi9yZW5kZXIvYXR0cmliX21hcHBpbmcnO1xyXG4vKiogRGVzY3JpcHRpb24gb2YgaG93IGEgd3JpdGVyIHN0b3JlcyB2ZXJ0ZXggZGF0YS4gKi9cclxuZXhwb3J0IGNvbnN0IFBPSU5UX0xBQkVMX0FUVFJJQlVURV9NQVBQSU5HID0gbmV3IEF0dHJpYnV0ZU1hcHBpbmcoW1xyXG4gICAgW1xyXG4gICAgICAgIDIgLyogSUQgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiA0LFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIxIC8qIFVOU0lHTkVEX0JZVEUgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDAgLyogUE9TSVRJT05fSElHSCAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDIsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjMgLyogVU5TSUdORURfU0hPUlQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDEgLyogUE9TSVRJT05fTE9XICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMixcclxuICAgICAgICAgICAgdHlwZTogNTEyMyAvKiBVTlNJR05FRF9TSE9SVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgNiAvKiBESVNQTEFDRU1FTlQgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTI2IC8qIEZMT0FUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgNCAvKiBVViAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDIsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjMgLyogVU5TSUdORURfU0hPUlQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICA3IC8qIENPTE9SICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogNCxcclxuICAgICAgICAgICAgdHlwZTogNTEyMSAvKiBVTlNJR05FRF9CWVRFICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICA4IC8qIE9VVExJTkVfQ09MT1IgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiA0LFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIxIC8qIFVOU0lHTkVEX0JZVEUgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDkgLyogUFJJT1JJVFkgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAxLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTI2IC8qIEZMT0FUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgMTEgLyogQVVYICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMSxcclxuICAgICAgICAgICAgdHlwZTogNTEyNiAvKiBGTE9BVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICBdXHJcbl0pO1xyXG4iLCJpbXBvcnQgeyBBdHRyaWJ1dGVNYXBwaW5nIH0gZnJvbSAnLi4vLi4vcmVuZGVyL2F0dHJpYl9tYXBwaW5nJztcclxuLyoqIERlc2NyaXB0aW9uIG9mIGhvdyBhIHdyaXRlciBzdG9yZXMgdmVydGV4IGRhdGEuICovXHJcbmV4cG9ydCBjb25zdCBDVVJWRURfTEFCRUxfQVRUUklCVVRFX01BUFBJTkcgPSBuZXcgQXR0cmlidXRlTWFwcGluZyhbXHJcbiAgICBbXHJcbiAgICAgICAgMiAvKiBJRCAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDQsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjEgLyogVU5TSUdORURfQllURSAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgMCAvKiBQT1NJVElPTl9ISUdIICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMixcclxuICAgICAgICAgICAgdHlwZTogNTEyMyAvKiBVTlNJR05FRF9TSE9SVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgMSAvKiBQT1NJVElPTl9MT1cgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIzIC8qIFVOU0lHTkVEX1NIT1JUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICA2IC8qIERJU1BMQUNFTUVOVCAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDMsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjYgLyogRkxPQVQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICA0IC8qIFVWICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMixcclxuICAgICAgICAgICAgdHlwZTogNTEyMyAvKiBVTlNJR05FRF9TSE9SVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDcgLyogQ09MT1IgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiA0LFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIxIC8qIFVOU0lHTkVEX0JZVEUgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDggLyogT1VUTElORV9DT0xPUiAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDQsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjEgLyogVU5TSUdORURfQllURSAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgOSAvKiBQUklPUklUWSAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDEsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjYgLyogRkxPQVQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICAxMiAvKiBBVVgxICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogNCxcclxuICAgICAgICAgICAgdHlwZTogNTEyMSAvKiBVTlNJR05FRF9CWVRFICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICAxMyAvKiBBVVgyICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogNCxcclxuICAgICAgICAgICAgdHlwZTogNTEyMyAvKiBVTlNJR05FRF9TSE9SVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgMTQgLyogQVVYMyAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDQsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjEgLyogVU5TSUdORURfQllURSAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgMTUgLyogQVVYNCAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDQsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjMgLyogVU5TSUdORURfU0hPUlQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDExIC8qIEFVWCAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDIsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjYgLyogRkxPQVQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgXVxyXG5dKTtcclxuIiwiaW1wb3J0IHsgQXR0cmlidXRlTWFwcGluZyB9IGZyb20gJy4uLy4uL3JlbmRlci9hdHRyaWJfbWFwcGluZyc7XHJcbi8qKlxyXG4gKiBEZXNjcmlwdGlvbiBvZiBob3cgYXR0cmlidXRlcyBvZiB2ZXJ0aWNlcyBhcmUgcGFja2VkIGludG8gYSB2ZXJ0ZXggYnVmZmVyLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IFBPTFlMSU5FX0FUVFJJQlVURV9NQVBQSU5HID0gbmV3IEF0dHJpYnV0ZU1hcHBpbmcoW1xyXG4gICAgLyoqIFZlcnRleCB3b3JsZCBwb3NpdGlvbi4gKi9cclxuICAgIFtcclxuICAgICAgICAwIC8qIFBPU0lUSU9OICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogNCxcclxuICAgICAgICAgICAgdHlwZTogNTEyMyAvKiBVTlNJR05FRF9TSE9SVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICAvKiogTm9ybWFsIHRvIHBvbHlsaW5lIHNlZ21lbnQgdGhlIHZlcnRleCBiZWxvbmcgdG8uICovXHJcbiAgICBbXHJcbiAgICAgICAgNSAvKiBOT1JNQUwgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIzIC8qIFVOU0lHTkVEX1NIT1JUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIC8qKlxyXG4gICAgICogXCJVVlwiIHZlcnRleCB0aGF0IHVzZWQgdG8gY29tcHV0ZSBzdHJva2UgYW5kIGRhc2hlcy4gSXQncyBjb21wb25lbnRzOlxyXG4gICAgICpcclxuICAgICAqICAgLSBkaXN0YW5jZSB0byB0aGUgYW5hbHl0aWNhbCBwb2x5bGluZSBhbG9uZyBzZWdtZW50J3Mgbm9ybWFsO1xyXG4gICAgICogICAtIGRpc3RhbmNlIHRvIHRoZSBhbmFseXRpY2FsIHBvbHlsaW5lIGFsb25nIHNlZ21lbnQuXHJcbiAgICAgKi9cclxuICAgIFtcclxuICAgICAgICA0IC8qIFVWICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMixcclxuICAgICAgICAgICAgdHlwZTogNTEyMyAvKiBVTlNJR05FRF9TSE9SVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgLyoqXHJcbiAgICAgKiBWZWN0b3Igd2l0aCBwb2x5bGluZSdzIGhhbGYgd2lkdGggYW5kIGRhc2ggc3R5bGUuIEl0J3MgY29tcG9uZW50czpcclxuICAgICAqXHJcbiAgICAgKiAgIC0gaGFsZiB3aWR0aDtcclxuICAgICAqICAgLSBsZW5ndGggb2YgYSBkYXNoO1xyXG4gICAgICogICAtIGRpc3RhbmNlIGJldHdlZW4gZGFzaGVzLlxyXG4gICAgICovXHJcbiAgICBbXHJcbiAgICAgICAgMTEgLyogQVVYICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMyxcclxuICAgICAgICAgICAgdHlwZTogNTEyMSAvKiBVTlNJR05FRF9CWVRFICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIC8qKlxyXG4gICAgICogTWl0ZXIgKGkuZS4gaG93IG11Y2ggZGlzcGxhY2VtZW50IG9mIHRoZSB2ZXJ0ZXggaXMgbG9uZ2VyIHRoZW4gdGhlXHJcbiAgICAgKiBub3JtYWwpLlxyXG4gICAgICovXHJcbiAgICBbXHJcbiAgICAgICAgMTIgLyogQVVYMSAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDEsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjYgLyogRkxPQVQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIC8qKlxyXG4gICAgICogTGltaXQgb24gZGlzcGxhY2VtZW50IHRhbmdlbnQgY29tcG9uZW50LkFwcGxpZWQgdG8gYXZvaWQgZ2VvbWV0cnlcclxuICAgICAqIGdsaXRjaGVzIGluIG92ZXItZGVnZW5lcmF0aXZlIGNhc2VzLlxyXG4gICAgICovXHJcbiAgICBbXHJcbiAgICAgICAgMTMgLyogQVVYMiAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDEsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjYgLyogRkxPQVQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIC8qKlxyXG4gICAgICogRGlzdGFuY2UgdG8gdGhlIGZpcnN0IHZlcnRleCBhbG9uZyB0aGUgcG9seWxpbmUuXHJcbiAgICAgKi9cclxuICAgIFtcclxuICAgICAgICAxNCAvKiBBVVgzICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMSxcclxuICAgICAgICAgICAgdHlwZTogNTEyNiAvKiBGTE9BVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgLyoqIFBvbHlsaW5lJ3MgY29sb3IuICovXHJcbiAgICBbXHJcbiAgICAgICAgNyAvKiBDT0xPUiAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDQsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjEgLyogVU5TSUdORURfQllURSAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICAvKiogUG9seWxpbmUncyBaIGluZGV4LiAqL1xyXG4gICAgW1xyXG4gICAgICAgIDEwIC8qIFpfSU5ERVggKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAxLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTI2IC8qIEZMT0FUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgIF1cclxuXSk7XHJcbiIsImltcG9ydCB7IFdlYldvcmtlckNsaWVudCB9IGZyb20gJy4uLy4uLy4uL3V0aWwvd29ya2VyJztcclxuZXhwb3J0IGNsYXNzIFRpbGVQcm92aWRlcldvcmtlckNsaWVudCBleHRlbmRzIFdlYldvcmtlckNsaWVudCB7XHJcbn1cclxuIiwiaW1wb3J0IHsgZXh0cmFjdFRyYW5zZmVyYWJsZXMgfSBmcm9tICcuL3ByaW1pdGl2ZV9wcm92aWRlcl93b3JrZXJfbWVzc2FnZXMnO1xyXG5leHBvcnQgdmFyIFRpbGVQcm92aWRlck1lc3NhZ2VUeXBlO1xyXG4oZnVuY3Rpb24gKFRpbGVQcm92aWRlck1lc3NhZ2VUeXBlKSB7XHJcbiAgICBUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZVtUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZVtcIklOSVRcIl0gPSAwXSA9IFwiSU5JVFwiO1xyXG4gICAgVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGVbVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGVbXCJUSUxFX1VSTF9VUERBVEVcIl0gPSAxXSA9IFwiVElMRV9VUkxfVVBEQVRFXCI7XHJcbiAgICBUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZVtUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZVtcIlRJTEVfUkVRVUVTVF9CQVRDSFwiXSA9IDJdID0gXCJUSUxFX1JFUVVFU1RfQkFUQ0hcIjtcclxuICAgIFRpbGVQcm92aWRlck1lc3NhZ2VUeXBlW1RpbGVQcm92aWRlck1lc3NhZ2VUeXBlW1wiVElMRV9SRVFVRVNUX0NBTkNFTF9CQVRDSFwiXSA9IDNdID0gXCJUSUxFX1JFUVVFU1RfQ0FOQ0VMX0JBVENIXCI7XHJcbiAgICBUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZVtUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZVtcIlRJTEVfUkVTUE9OU0VcIl0gPSA0XSA9IFwiVElMRV9SRVNQT05TRVwiO1xyXG4gICAgVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGVbVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGVbXCJUSUxFX0VSUk9SXCJdID0gNV0gPSBcIlRJTEVfRVJST1JcIjtcclxuICAgIFRpbGVQcm92aWRlck1lc3NhZ2VUeXBlW1RpbGVQcm92aWRlck1lc3NhZ2VUeXBlW1wiR0VPTUVUUllfUkVTUE9OU0VcIl0gPSA2XSA9IFwiR0VPTUVUUllfUkVTUE9OU0VcIjtcclxuICAgIFRpbGVQcm92aWRlck1lc3NhZ2VUeXBlW1RpbGVQcm92aWRlck1lc3NhZ2VUeXBlW1wiTEFCRUxTX1JFU1BPTlNFXCJdID0gN10gPSBcIkxBQkVMU19SRVNQT05TRVwiO1xyXG4gICAgVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGVbVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGVbXCJNRVNIX1JFUVVFU1RcIl0gPSA4XSA9IFwiTUVTSF9SRVFVRVNUXCI7XHJcbiAgICBUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZVtUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZVtcIk1FU0hfUkVRVUVTVF9DQU5DRUxcIl0gPSA5XSA9IFwiTUVTSF9SRVFVRVNUX0NBTkNFTFwiO1xyXG4gICAgVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGVbVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGVbXCJNRVNIX1JFU1BPTlNFXCJdID0gMTBdID0gXCJNRVNIX1JFU1BPTlNFXCI7XHJcbiAgICBUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZVtUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZVtcIk1FU0hfRVJST1JcIl0gPSAxMV0gPSBcIk1FU0hfRVJST1JcIjtcclxufSkoVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGUgfHwgKFRpbGVQcm92aWRlck1lc3NhZ2VUeXBlID0ge30pKTtcclxuZXhwb3J0IGNvbnN0IGdlb21ldHJ5VHJhbnNmZXJhYmxlRXh0cmFjdG9yID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHRyYW5zZmVyYWJsZXMgPSBbXSkge1xyXG4gICAgZXh0cmFjdFRyYW5zZmVyYWJsZXMobWVzc2FnZS5wb2x5Z29uUGFnZXMsIHRyYW5zZmVyYWJsZXMpO1xyXG4gICAgZXh0cmFjdFRyYW5zZmVyYWJsZXMobWVzc2FnZS50cmFuc3BhcmVudFBvbHlnb25QYWdlcywgdHJhbnNmZXJhYmxlcyk7XHJcbiAgICBleHRyYWN0VHJhbnNmZXJhYmxlcyhtZXNzYWdlLnRleHR1cmVkUG9seWdvblBhZ2VzLCB0cmFuc2ZlcmFibGVzKTtcclxuICAgIGV4dHJhY3RUcmFuc2ZlcmFibGVzKG1lc3NhZ2UubWVzaFBhZ2VzLCB0cmFuc2ZlcmFibGVzKTtcclxuICAgIGV4dHJhY3RUcmFuc2ZlcmFibGVzKG1lc3NhZ2UucG9seWxpbmVQYWdlcywgdHJhbnNmZXJhYmxlcyk7XHJcbiAgICByZXR1cm4gdHJhbnNmZXJhYmxlcztcclxufTtcclxuZXhwb3J0IGNvbnN0IG1lc2hUcmFuc2ZlcmFibGVFeHRyYWN0b3IgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xyXG4gICAgY29uc3QgdHJhbnNmZXJhYmxlcyA9IFtdO1xyXG4gICAgZXh0cmFjdFRyYW5zZmVyYWJsZXMobWVzc2FnZS5wYWdlcywgdHJhbnNmZXJhYmxlcyk7XHJcbiAgICByZXR1cm4gdHJhbnNmZXJhYmxlcztcclxufTtcclxuZXhwb3J0IGNvbnN0IGxhYmVsVHJhbnNmZXJhYmxlRXh0cmFjdG9yID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHRyYW5zZmVyYWJsZXMgPSBbXSkge1xyXG4gICAgZXh0cmFjdFRyYW5zZmVyYWJsZXMobWVzc2FnZS5wb2ludExhYmVsUGFnZXMsIHRyYW5zZmVyYWJsZXMpO1xyXG4gICAgZXh0cmFjdFRyYW5zZmVyYWJsZXMobWVzc2FnZS5wb2ludExhYmVsQmFja2dyb3VuZFBhZ2VzLCB0cmFuc2ZlcmFibGVzKTtcclxuICAgIGV4dHJhY3RUcmFuc2ZlcmFibGVzKG1lc3NhZ2UuY3VydmVkTGFiZWxQYWdlcywgdHJhbnNmZXJhYmxlcyk7XHJcbiAgICByZXR1cm4gdHJhbnNmZXJhYmxlcztcclxufTtcclxuZXhwb3J0IGNvbnN0IHRpbGVUcmFuc2ZlcmFibGVFeHRyYWN0b3IgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xyXG4gICAgY29uc3QgdHJhbnNmZXJhYmxlcyA9IFtdO1xyXG4gICAgZ2VvbWV0cnlUcmFuc2ZlcmFibGVFeHRyYWN0b3IobWVzc2FnZSwgdHJhbnNmZXJhYmxlcyk7XHJcbiAgICBsYWJlbFRyYW5zZmVyYWJsZUV4dHJhY3RvcihtZXNzYWdlLCB0cmFuc2ZlcmFibGVzKTtcclxuICAgIHJldHVybiB0cmFuc2ZlcmFibGVzO1xyXG59O1xyXG4iLCIvKipcclxuICogRXh0cmFjdCBBcnJheUJ1ZmZlcnMgKHRoYXQgYXJlIHRhbnNmZXJhYmxlKSBmcm9tIHBhZ2VzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RUcmFuc2ZlcmFibGVzKHBhZ2VzLCBvdXRwdXQpIHtcclxuICAgIGZvciAoY29uc3QgcGFnZSBvZiBwYWdlcykge1xyXG4gICAgICAgIG91dHB1dC5wdXNoKHBhZ2UudmVydGV4QnVmZmVyLmJ1ZmZlciwgcGFnZS5pbmRleEJ1ZmZlci5idWZmZXIpO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IEF0dHJpYnV0ZU1hcHBpbmcgfSBmcm9tICcuLi8uLi9yZW5kZXIvYXR0cmliX21hcHBpbmcnO1xyXG5pbXBvcnQgeyBQT0xZR09OX0FUVFJJQlVURV9NQVBQSU5HIH0gZnJvbSAnLi9wb2x5Z29uX2F0dHJpYnV0ZV9tYXBwaW5nJztcclxuLyoqXHJcbiAqIERlc2NyaXB0aW9uIG9mIGhvdyBhdHRyaWJ1dGVzIG9mIHZlcnRpY2VzIGFyZSBwYWNrZWQgaW50byBhIHZlcnRleCBidWZmZXIuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgVFJBTlNQQVJFTlRfUE9MWUdPTl9BVFRSSUJVVEVfTUFQUElORyA9IG5ldyBBdHRyaWJ1dGVNYXBwaW5nKFBPTFlHT05fQVRUUklCVVRFX01BUFBJTkcpO1xyXG4iLCJpbXBvcnQgUHJpb3JpdHlRdWV1ZSBmcm9tICcuL3ByaW9yaXR5X3F1ZXVlJztcclxuY29uc3QgTUFYX0RFUVVFVUVfVElNRU9VVCA9IDEwMDA7IC8vIG1zXHJcbi8vIFRPRE86IHJlbW92ZSB0aGlzIHNoaW0gd2hlbiBhbGwgc3VwcG9ydGVkIGJyb3dzZXJzIGltcGxlbWVudCBpdFxyXG5jb25zdCBTSElNTUVEX1BST0NFU1NJTkdfRFVSQVRJT05fTVMgPSAyNTtcclxud2luZG93LmNhbmNlbElkbGVDYWxsYmFjayA9IHdpbmRvdy5jYW5jZWxJZGxlQ2FsbGJhY2sgfHwgd2luZG93LmNsZWFyVGltZW91dDtcclxud2luZG93LnJlcXVlc3RJZGxlQ2FsbGJhY2sgPSB3aW5kb3cucmVxdWVzdElkbGVDYWxsYmFjayB8fCBmdW5jdGlvbiAoaGFuZGxlcikge1xyXG4gICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICByZXR1cm4gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgaGFuZGxlcih7XHJcbiAgICAgICAgICAgIGRpZFRpbWVvdXQ6IGZhbHNlLFxyXG4gICAgICAgICAgICB0aW1lUmVtYWluaW5nOiAoKSA9PiBNYXRoLm1heCgwLCBTSElNTUVEX1BST0NFU1NJTkdfRFVSQVRJT05fTVMgLSAocGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydFRpbWUpKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn07XHJcbi8qKlxyXG4gKiBJdCBpcyBhIHRhc2sgcXVldWUuIFRhc2tzIGFyZSBkZXF1ZXVlZCBkdXJpbmcgaWRsZSBwZXJpb2QuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJZGxlVGFza1F1ZXVlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuX3F1ZXVlID0gbmV3IFByaW9yaXR5UXVldWUoKTtcclxuICAgICAgICB0aGlzLl9kZXF1ZXVlSWRsZUhhbmRsZSA9IDA7XHJcbiAgICB9XHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIGNhbmNlbElkbGVDYWxsYmFjayh0aGlzLl9kZXF1ZXVlSWRsZUhhbmRsZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVucXVldWVzIGEgdGFzayB0byB0aGUgcXVldWUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRhc2sgVGhlIHRhc2suXHJcbiAgICAgKi9cclxuICAgIGVucXVldWUodGFzaykge1xyXG4gICAgICAgIHRoaXMuX3F1ZXVlLmVucXVldWUodGFzayk7XHJcbiAgICAgICAgdGhpcy5fcnVuKCk7XHJcbiAgICB9XHJcbiAgICBfZGVxdWV1ZShkZWFkbGluZSkge1xyXG4gICAgICAgIGNvbnN0IHF1ZXVlID0gdGhpcy5fcXVldWU7XHJcbiAgICAgICAgaWYgKHF1ZXVlLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkZWFkbGluZS5kaWRUaW1lb3V0KSB7XHJcbiAgICAgICAgICAgIHF1ZXVlLmRlcXVldWUoKS5leGVjdXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB3aGlsZSAoZGVhZGxpbmUudGltZVJlbWFpbmluZygpICYmICFxdWV1ZS5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgIHF1ZXVlLmRlcXVldWUoKS5leGVjdXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZGVxdWV1ZUlkbGVIYW5kbGUgPSAwO1xyXG4gICAgICAgIGlmICghdGhpcy5fcXVldWUuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3J1bigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9ydW4oKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9kZXF1ZXVlSWRsZUhhbmRsZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9kZXF1ZXVlSWRsZUhhbmRsZSA9IHJlcXVlc3RJZGxlQ2FsbGJhY2soKGRlYWRsaW5lKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kZXF1ZXVlKGRlYWRsaW5lKTtcclxuICAgICAgICAgICAgfSwgeyB0aW1lb3V0OiBNQVhfREVRVUVVRV9USU1FT1VUIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgQmluYXJ5SGVhcCBmcm9tICcuL2JpbmFyeV9oZWFwJztcclxuZnVuY3Rpb24gaXRlbUNvbXBhcmF0b3IoYSwgYikge1xyXG4gICAgcmV0dXJuIGEucHJpb3JpdHkgLSBiLnByaW9yaXR5O1xyXG59XHJcbi8qKlxyXG4gKiBQcmlvcml0eSBxdWV1ZSBiYXNlZCBvbiBhIGhlYXAuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcmlvcml0eVF1ZXVlIHtcclxuICAgIC8qKlxyXG4gICAgICogQ29uc3RydWN0cyBuZXcgZW1wdHkgcHJpb3JpdHkgcXVldWUuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuX2hlYXAgPSBuZXcgQmluYXJ5SGVhcChpdGVtQ29tcGFyYXRvcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYW4gaXRlbSBpbnRvIHRoZSBxdWV1ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaXRlbSBUaGUgaXRlbS5cclxuICAgICAqL1xyXG4gICAgZW5xdWV1ZShpdGVtKSB7XHJcbiAgICAgICAgdGhpcy5faGVhcC5pbnNlcnQoaXRlbSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgbmV4dCBpdGVtIGZyb20gdGhlIHF1ZXVlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFRoZSBuZXh0IGl0ZW0gb3IgYHVuZGVmaW5lZGAgaWYgdGhlIHF1ZXVlJ3MgZW1wdHkuXHJcbiAgICAgKi9cclxuICAgIGRlcXVldWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlYXAucG9wKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyBpZiB0aGUgcXVldWUgaGFzIG5vIGl0ZW1zIGluIGl0LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGVyZSdyZSBubyBpdGVtcyBpdCB0aGUgcXVldWUgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxyXG4gICAgICovXHJcbiAgICBpc0VtcHR5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9oZWFwLnNpemUgPT09IDA7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgc3dhcCB9IGZyb20gJy4vYXJyYXknO1xyXG5pbXBvcnQgeyBERUZBVUxUX0NPTVBBUkFUT1IgfSBmcm9tICcuL2NvbXBhcmF0b3InO1xyXG4vKipcclxuICogQ29tcHV0ZXMgaW5kZXggb2YgdGhlIHBhcmVudCBvZiBhbiBpdGVtLlxyXG4gKlxyXG4gKiBAcGFyYW0gaWR4IEluZGV4IG9mIHRoZSBpdGVtLlxyXG4gKiBAcmV0dXJucyBJbmRleCBvZiB0aGUgcGFyZW50LlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0UGFyZW50SWR4KGlkeCkge1xyXG4gICAgcmV0dXJuIChpZHggKyAxID4+IDEpIC0gMTtcclxufVxyXG4vKipcclxuICogQ29tcHV0ZXMgaW5kZXggb2YgdGhlIGxlZnQgY2hpbGQgb2YgYW4gaXRlbS5cclxuICpcclxuICogQHBhcmFtIGlkeCBJbmRleCBvZiB0aGUgaXRlbS5cclxuICogQHJldHVybnMgSW5kZXggb2YgdGhlIGNoaWxkLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0Rmlyc3RDaGlsZElkeChpZHgpIHtcclxuICAgIHJldHVybiAoaWR4ICsgMSA8PCAxKSAtIDE7XHJcbn1cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmluYXJ5SGVhcCB7XHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgZW1wdHkgaGVhcC4gT3JkZXIgb2YgaXRlbXMgaW4gdGhlIGhlYXAgd2lsbCBiZSBkZWZpbmVkXHJcbiAgICAgKiBieSBhIGdpdmVuIGNvbXBhcmF0b3IuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbXBhcmF0b3IgVGhlIGNvbXBhcmF0b3IuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGNvbXBhcmF0b3IgPSBERUZBVUxUX0NPTVBBUkFUT1IpIHtcclxuICAgICAgICAvLyBUT0RPKGRtaWtpcykgSW52ZXN0aWdhdGUgcHJlYWxsb2NhdGlvbi5cclxuICAgICAgICB0aGlzLl9pdGVtcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2NvbXBhcmF0b3IgPSBjb21wYXJhdG9yO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnNlcnRzIGFuIGl0ZW0gaW50byB0aGUgaGVhcC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaXRlbSBUaGUgaXRlbSB0byBiZSBpbnNlcnRlZC5cclxuICAgICAqL1xyXG4gICAgaW5zZXJ0KGl0ZW0pIHtcclxuICAgICAgICBjb25zdCBpdGVtcyA9IHRoaXMuX2l0ZW1zO1xyXG4gICAgICAgIGNvbnN0IGNvbXBhcmF0b3IgPSB0aGlzLl9jb21wYXJhdG9yO1xyXG4gICAgICAgIC8vIEluc2VydCB0aGUgbmV3IGl0ZW0gYXMgYm90dG9tIHJpZ2h0LW1vc3QgY2hpbGQgb2YgdGhlIGhlYXAuXHJcbiAgICAgICAgbGV0IGlkeCA9IGl0ZW1zLnB1c2goaXRlbSkgLSAxO1xyXG4gICAgICAgIGxldCBwYXJlbnRJZHggPSBnZXRQYXJlbnRJZHgoaWR4KTtcclxuICAgICAgICAvLyBXYWxrIHRoZSBoZWFwIHVwd2FyZCBhbmQgcmVzdG9yZSBoZWFwIHByb3BlcnR5IG9uIHRoZSB3YXkuXHJcbiAgICAgICAgd2hpbGUgKHBhcmVudElkeCA+IC0xICYmXHJcbiAgICAgICAgICAgIGNvbXBhcmF0b3IoaXRlbXNbaWR4XSwgaXRlbXNbcGFyZW50SWR4XSkgPiAwKSB7XHJcbiAgICAgICAgICAgIHN3YXAoaXRlbXMsIGlkeCwgcGFyZW50SWR4KTtcclxuICAgICAgICAgICAgaWR4ID0gcGFyZW50SWR4O1xyXG4gICAgICAgICAgICBwYXJlbnRJZHggPSBnZXRQYXJlbnRJZHgoaWR4KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgXCJtYXhpbXVtXCIgaXRlbSBmcm9tIHRoZSBoZWFkLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFRoZSByZW1vdmVkIGl0ZW0gb3IgYHVuZGVmaW5lZGAgaXMgdGhlIGhlYXAncyBlbXB0eS5cclxuICAgICAqL1xyXG4gICAgcG9wKCkge1xyXG4gICAgICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5faXRlbXM7XHJcbiAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBuZXdTaXplID0gaXRlbXMubGVuZ3RoIC0gMTtcclxuICAgICAgICAvLyBQbGFjZSBtYXggaXRlbSBhdCB0aGUgZW5kIG9mIHRoZSBpdGVtcyBhcnJheS5cclxuICAgICAgICBzd2FwKGl0ZW1zLCAwLCBuZXdTaXplKTtcclxuICAgICAgICAvLyBXYWxrIGRvd253YXJkIGZyb20gdGhlIG5ldyByb290IHRvIHJlc3RvcmUgaGVhcCBwcm9wZXJ0eS5cclxuICAgICAgICBsZXQgaWR4ID0gMDtcclxuICAgICAgICBsZXQgY2hpbGRJZHggPSAxO1xyXG4gICAgICAgIGNvbnN0IGNvbXBhcmF0b3IgPSB0aGlzLl9jb21wYXJhdG9yO1xyXG4gICAgICAgIHdoaWxlIChjaGlsZElkeCA8IG5ld1NpemUpIHtcclxuICAgICAgICAgICAgaWYgKGNoaWxkSWR4ICsgMSA8IG5ld1NpemUgJiZcclxuICAgICAgICAgICAgICAgIGNvbXBhcmF0b3IoaXRlbXNbY2hpbGRJZHhdLCBpdGVtc1tjaGlsZElkeCArIDFdKSA8IDApIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkSWR4ICs9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNvbXBhcmF0b3IoaXRlbXNbaWR4XSwgaXRlbXNbY2hpbGRJZHhdKSA+IDApIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN3YXAoaXRlbXMsIGlkeCwgY2hpbGRJZHgpO1xyXG4gICAgICAgICAgICBpZHggPSBjaGlsZElkeDtcclxuICAgICAgICAgICAgY2hpbGRJZHggPSBnZXRGaXJzdENoaWxkSWR4KGNoaWxkSWR4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUmVtb3ZlIHByZXZpb3VzbHkgcGxhY2VkIGF0IHRoZSBlbmQgcHJldmlvdXMgbWF4IGl0ZW0uXHJcbiAgICAgICAgcmV0dXJuIGl0ZW1zLnBvcCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBcIk1heGltdW1cIiBpdGVtIGluIHRoZSBoZWFwIG9yIGB1bmRlZmluZWRgIGlmIHRoZSBoZWFkIGlzIGVtcHR5LlxyXG4gICAgICovXHJcbiAgICBwZWVrKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtc1swXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgSXRlcmF0b3Igb3ZlciBhbGwgaXRlbXMgaW4gdGhlIGhlYXAuIE5vdGUgdGhhdCBvcmRlciBvZiBpdGVtc1xyXG4gICAgICogICAgICBpcyB1bmRlZmluZWQuXHJcbiAgICAgKi9cclxuICAgICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5faXRlbXMpIHtcclxuICAgICAgICAgICAgeWllbGQgaXRlbTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIE51bWJlciBvZiBpdGVtcyBpbiB0aGUgaGVhcC5cclxuICAgICAqL1xyXG4gICAgZ2V0IHNpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1zLmxlbmd0aDtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgUmVuZGVyYWJsZVByaW1pdGl2ZSBmcm9tICcuLi9yZW5kZXJhYmxlX3ByaW1pdGl2ZSc7XHJcbi8qKlxyXG4gKiBBbGxvY2F0ZWQgaW4gR1BVIG1lbW9yeSBwb2x5Z29uLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVuZGVyYWJsZVBvbHlnb24gZXh0ZW5kcyBSZW5kZXJhYmxlUHJpbWl0aXZlIHtcclxuICAgIGNvbnN0cnVjdG9yKG1lbW9yeVN1YkNodW5rLCBpc09wYXF1ZSkge1xyXG4gICAgICAgIHN1cGVyKG1lbW9yeVN1YkNodW5rKTtcclxuICAgICAgICB0aGlzLmlzT3BhcXVlID0gaXNPcGFxdWU7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IFJlZmVyZW5jZUNvdW50ZWQgZnJvbSAnLi4vdXRpbC9yZWZfY291bnRlZCc7XHJcbi8qKlxyXG4gKiBCYXNlIGNsYXNzIGZvciBwcmltaXRpdmUgb2JqZWN0cyB0aGF0IGFyZSByZWFkeSB0byBiZSBmZWQgdG8gdGhlIHJlbmRlcmVyLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVuZGVyYWJsZVByaW1pdGl2ZSBleHRlbmRzIFJlZmVyZW5jZUNvdW50ZWQge1xyXG4gICAgY29uc3RydWN0b3IobWVtb3J5U3ViQ2h1bmspIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMubWVtb3J5U3ViQ2h1bmsgPSBtZW1vcnlTdWJDaHVuaztcclxuICAgIH1cclxuICAgIF9kZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMubWVtb3J5U3ViQ2h1bmsuZGVzdHJveSgpO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCBSZW5kZXJhYmxlUHJpbWl0aXZlIGZyb20gJy4uL3JlbmRlcmFibGVfcHJpbWl0aXZlJztcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVuZGVyYWJsZVRleHR1cmVkUG9seWdvbiBleHRlbmRzIFJlbmRlcmFibGVQcmltaXRpdmUge1xyXG4gICAgY29uc3RydWN0b3IobWVtb3J5Q2h1bmssIGFsbG9jYXRlZEltYWdlKSB7XHJcbiAgICAgICAgc3VwZXIobWVtb3J5Q2h1bmspO1xyXG4gICAgICAgIHRoaXMuX2FsbG9jYXRlZEltYWdlID0gYWxsb2NhdGVkSW1hZ2U7XHJcbiAgICAgICAgdGhpcy5hdGxhcyA9IGFsbG9jYXRlZEltYWdlLmF0bGFzTWFuYWdlci5hdGxhcztcclxuICAgICAgICBhbGxvY2F0ZWRJbWFnZS5yZXRhaW4oKTtcclxuICAgIH1cclxuICAgIF9kZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMuX2FsbG9jYXRlZEltYWdlLnJlbGVhc2UoKTtcclxuICAgICAgICBzdXBlci5fZGVzdHJveSgpO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCBSZW5kZXJhYmxlUHJpbWl0aXZlIGZyb20gJy4uL3JlbmRlcmFibGVfcHJpbWl0aXZlJztcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVuZGVyYWJsZVBvbHlsaW5lIGV4dGVuZHMgUmVuZGVyYWJsZVByaW1pdGl2ZSB7XHJcbn1cclxuIiwiaW1wb3J0IFJlbmRlcmFibGVQb2x5bGluZSBmcm9tICcuL3JlbmRlcmFibGVfcG9seWxpbmUnO1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW5kZXJhYmxlVGV4dHVyZWRQb2x5bGluZSBleHRlbmRzIFJlbmRlcmFibGVQb2x5bGluZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihtZW1vcnlDaHVuaywgYWxsb2NhdGVkSW1hZ2UpIHtcclxuICAgICAgICBzdXBlcihtZW1vcnlDaHVuayk7XHJcbiAgICAgICAgdGhpcy5fYWxsb2NhdGVkSW1hZ2UgPSBhbGxvY2F0ZWRJbWFnZTtcclxuICAgICAgICB0aGlzLmF0bGFzID0gYWxsb2NhdGVkSW1hZ2UuYXRsYXNNYW5hZ2VyLmF0bGFzO1xyXG4gICAgICAgIGFsbG9jYXRlZEltYWdlLnJldGFpbigpO1xyXG4gICAgfVxyXG4gICAgX2Rlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5fYWxsb2NhdGVkSW1hZ2UucmVsZWFzZSgpO1xyXG4gICAgICAgIHN1cGVyLl9kZXN0cm95KCk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IFJlbmRlcmFibGVQcmltaXRpdmUgZnJvbSAnLi4vcmVuZGVyYWJsZV9wcmltaXRpdmUnO1xyXG4vKipcclxuICogQSBnZW5lcmFsIHByaW1pdGl2ZSB0aGF0IGlzIGJlc3Qgc3VpdGFibGUgZm9yIHN0b3Jpbmcgc2ltcGxlIGNvbG9yZWQgM0QgbW9kZWxzLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVuZGVyYWJsZU1vZGVsIGV4dGVuZHMgUmVuZGVyYWJsZVByaW1pdGl2ZSB7XHJcbn1cclxuIiwiZXhwb3J0IGNvbnN0IFBPTFlHT05fRVhUUkFDVE9SID0gKGRhdGEpID0+IGZsYXQobWFwKCdwb2x5Z29ucycsIGRhdGEpKTtcclxuZXhwb3J0IGNvbnN0IFRFWFRVUkVEX1BPTFlHT05fRVhUUkFDVE9SID0gKGRhdGEpID0+IGZsYXQobWFwKCd0ZXh0dXJlZFBvbHlnb25zJywgZGF0YSkpO1xyXG5leHBvcnQgY29uc3QgUE9MWUxJTkVfRVhUUkFDVE9SID0gKGRhdGEpID0+IGZsYXQobWFwKCdwb2x5bGluZXMnLCBkYXRhKSk7XHJcbmV4cG9ydCBjb25zdCBURVhUVVJFRF9QT0xZTElORV9FWFRSQUNUT1IgPSAoZGF0YSkgPT4gZmxhdChtYXAoJ3RleHR1cmVkUG9seWxpbmVzJywgZGF0YSkpO1xyXG5leHBvcnQgY29uc3QgUE9JTlRfRVhUUkFDVE9SID0gKGRhdGEpID0+IGZsYXQobWFwKCdwb2ludHMnLCBkYXRhKSk7XHJcbmV4cG9ydCBjb25zdCBQT0lOVF9MQUJFTF9FWFRSQUNUT1IgPSAoZGF0YSkgPT4gZmxhdChtYXAoJ3BvaW50TGFiZWxzJywgZGF0YSkpO1xyXG5leHBvcnQgY29uc3QgQ1VSVkVEX0xBQkVMX0VYVFJBQ1RPUiA9IChkYXRhKSA9PiBmbGF0KG1hcCgnY3VydmVkTGFiZWxzJywgZGF0YSkpO1xyXG5leHBvcnQgY29uc3QgTU9ERUxfRVhUUkFDVE9SID0gKGRhdGEpID0+IGZsYXQobWFwKCdtb2RlbHMnLCBkYXRhKSk7XHJcbmV4cG9ydCBjb25zdCBFWFRFUk5BTF9NRVNIX0VYVFJBQ1RPUiA9IChkYXRhKSA9PiBmbGF0KG1hcCgnZXh0ZXJuYWxNZXNoZXMnLCBkYXRhKSk7XHJcbi8qKlxyXG4gKiBNYXBzIGxpc3Qgb2YgVGlsZURhdGEncyBpbnRvIGxpc3Qgb2Ygc3BlY2lmaWVkIHByaW1pdGl2ZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiogbWFwKHR5cGUsIGRhdGEpIHtcclxuICAgIGZvciAoY29uc3QgcG9ydGlvbiBvZiBkYXRhKSB7XHJcbiAgICAgICAgeWllbGQgcG9ydGlvblt0eXBlXTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogRmxhdHRlbiB0d28gZGltZW5zaW9uYWwgbGlzdCBvZiBwcmltaXRpdmVzIGluIGEgc2luZ2xlIGRpbWVuc2lvbmFsIG9uZS5cclxuICovXHJcbmZ1bmN0aW9uKiBmbGF0KHByaW1pdGl2ZXMpIHtcclxuICAgIGZvciAoY29uc3QgcG9ydGlvbiBvZiBwcmltaXRpdmVzKSB7XHJcbiAgICAgICAgaWYgKHBvcnRpb24pIHtcclxuICAgICAgICAgICAgeWllbGQqIHBvcnRpb247XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCBQcmltaXRpdmVNYW5hZ2VyIGZyb20gJy4vcHJpbWl0aXZlX21hbmFnZXInO1xyXG4vKipcclxuICogTWFuYWdlciBvZiBwcmltaXRpdmVzIHRoYXQgaGF2ZSBhIHNpbmdsZSBhc3NpY2lhdGVkIHJlbmRlcmFibGUgcHJpbWl0aXZlLiBUaGUgXCJtYW5hZ2VtZW50XCIgaXMgcHJldHR5IHN0cmFpZ2h0Zm9yd2FyZDpcclxuICogaXQgZGlyZWN0bHkgYWRkcy9yZW1vdmVzIGFzc29jaWF0ZWQgcHJpbWl0aXZlcyBpbnRvIHRoZSBzdG9yYWdlLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVuZGVyYWJsZVByaW1pdGl2ZU1hbmFnZXIgZXh0ZW5kcyBQcmltaXRpdmVNYW5hZ2VyIHtcclxuICAgIGNvbnN0cnVjdG9yKHByaW1pdGl2ZXNTdG9yYWdlKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl9wcmltaXRpdmVzU3RvcmFnZSA9IHByaW1pdGl2ZXNTdG9yYWdlO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlU2NlbmUodG9TaG93LCB0b0hpZGUpIHtcclxuICAgICAgICB0aGlzLl9wcmltaXRpdmVzU3RvcmFnZS5hZGQoLi4udG9TaG93KTtcclxuICAgICAgICB0aGlzLl9wcmltaXRpdmVzU3RvcmFnZS5kZWxldGUoLi4udG9IaWRlKTtcclxuICAgIH1cclxuICAgIGRlc3Ryb3lQcmltaXRpdmVzKF90b0Rlc3Ryb3kpIHtcclxuICAgICAgICAvLyBubyBuZWVkIHRvIGRlc3Ryb3kgYW55dGhpbmcsIFJlbmRlcmFibGVQcmltaXRpdmUgYXJlIHJlbGVhc2VkIHdoZW4gcmVtb3ZlZCBmcm9tIHByaW1taXRpdmUgc3RvcmFnZVxyXG4gICAgfVxyXG59XHJcbiIsIi8qKlxyXG4gKiBPZnRlbiBwcmltaXRpdmVzIGNhbid0IGJlIGRpcnJlY3RseSBhZGRlZCBpbnRvIG9yIHJlbW92ZWQgZnJvbSBzY2VuZSwgdGhlcmUgY2FuIGJlIHNvbWUgc3BlY2lmaWMgKGJ1c2luZXNzKSBsb2dpY1xyXG4gKiBhc3NvY2lhdGVkIHdpdGggdGhlc2Ugb3BlcmF0aW9ucy4gVGhpcyBjbGFzcyBwcm92aWRlcyBiYXNpYyBtZXRob2RzIGZvciBzdWNoIGltcGxlbWVudGF0aW9ucyB0aGF0XHJcbiAqIGFsbG93cyB0byBtYW5hZ2UgcHJpbWl0aXZlcyBvZiBhbGwgdHlwZXMgaW4gdGhlIHNhbWUgbWFubmVyLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJpbWl0aXZlTWFuYWdlciB7XHJcbiAgICBkZXN0cm95KCkgeyB9XHJcbn1cclxuIiwiaW1wb3J0IHsgVm9pZEV2ZW50RW1pdHRlciB9IGZyb20gJy4uLy4uL3V0aWwvZXZlbnRfZW1pdHRlcic7XHJcbi8qKlxyXG4gKiBQcmltaXRpdmUgc3RvcmFnZSB0aGF0IHN0b3JlcyBwcmltaXRpdmUgaW4gYSBzZXQuIEl0IGFjdHMgYXMgYSBwcmltaXRpdmUgcHJvdmlkZXIgYXMgd2VsbC5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByaW1pdGl2ZVNldFN0b3JhZ2Uge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5fcHJpbWl0aXZlU2V0ID0gbmV3IFNldCgpO1xyXG4gICAgICAgIHRoaXMub25VcGRhdGUgPSBuZXcgVm9pZEV2ZW50RW1pdHRlcigpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHByaW1pdGl2ZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaW1pdGl2ZVNldDtcclxuICAgIH1cclxuICAgIGFkZCguLi5wcmltaXRpdmVzKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBwcmltaXRpdmUgb2YgcHJpbWl0aXZlcykge1xyXG4gICAgICAgICAgICBwcmltaXRpdmUucmV0YWluKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3ByaW1pdGl2ZVNldC5hZGQocHJpbWl0aXZlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHByaW1pdGl2ZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICB0aGlzLm9uVXBkYXRlLmZpcmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBkZWxldGUoLi4ucHJpbWl0aXZlcykge1xyXG4gICAgICAgIGZvciAoY29uc3QgcHJpbWl0aXZlIG9mIHByaW1pdGl2ZXMpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3ByaW1pdGl2ZVNldC5kZWxldGUocHJpbWl0aXZlKSkge1xyXG4gICAgICAgICAgICAgICAgcHJpbWl0aXZlLnJlbGVhc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocHJpbWl0aXZlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25VcGRhdGUuZmlyZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNsZWFyKCkge1xyXG4gICAgICAgIHRoaXMuX3ByaW1pdGl2ZVNldC5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMub25VcGRhdGUuZmlyZSgpO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCBSZW5kZXJhYmxlUHJpbWl0aXZlTWFuYWdlciBmcm9tICcuL3JlbmRlcmFibGVfcHJpbWl0aXZlX21hbmFnZXInO1xyXG4vKipcclxuICogUG9seWdvbnMgc2hvdWxkIGJlIHNlcGFyYXRlZCBieSBvcGFxdWVuZXNzIGFuZCB0aGVyZSBhcmUgdHdvIGRpc3RpbmN0IHByaW1pdGl2ZSBwcm92aWRlcnNcclxuICogZm9yIHRoZW06IG9wYXF1ZSBhbmQgdGFuc3BhcmVudC4gVGhhdCBpcyB3aGF0IHRoaXMgbWFuYWdlciB0YWtlcyBjYXJlIG9mLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9seWdvbk1hbmFnZXIgZXh0ZW5kcyBSZW5kZXJhYmxlUHJpbWl0aXZlTWFuYWdlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcGFxdWVQb2x5Z29uU3RvcmFnZSwgdHJhbnNwYXJlbnRQb2x5Z29uU3RvcmFnZSkge1xyXG4gICAgICAgIHN1cGVyKG9wYXF1ZVBvbHlnb25TdG9yYWdlKTtcclxuICAgICAgICB0aGlzLl9vcGFxdWVQb2x5Z29uU3RvcmFnZSA9IG9wYXF1ZVBvbHlnb25TdG9yYWdlO1xyXG4gICAgICAgIHRoaXMuX3RyYW5zcGFyZW50UG9seWdvblN0b3JhZ2UgPSB0cmFuc3BhcmVudFBvbHlnb25TdG9yYWdlO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlU2NlbmUodG9TaG93LCB0b0hpZGUpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IHByaW1pdGl2ZSBvZiB0b1Nob3cpIHtcclxuICAgICAgICAgICAgaWYgKHByaW1pdGl2ZS5pc09wYXF1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fb3BhcXVlUG9seWdvblN0b3JhZ2UuYWRkKHByaW1pdGl2ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90cmFuc3BhcmVudFBvbHlnb25TdG9yYWdlLmFkZChwcmltaXRpdmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3QgcHJpbWl0aXZlIG9mIHRvSGlkZSkge1xyXG4gICAgICAgICAgICBpZiAocHJpbWl0aXZlLmlzT3BhcXVlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9vcGFxdWVQb2x5Z29uU3RvcmFnZS5kZWxldGUocHJpbWl0aXZlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zcGFyZW50UG9seWdvblN0b3JhZ2UuZGVsZXRlKHByaW1pdGl2ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IFByaW1pdGl2ZVNldFN0b3JhZ2UgZnJvbSAnLi9wcmltaXRpdmVfc2V0X3N0b3JhZ2UnO1xyXG4vKipcclxuICogU2ltcGxlIHByaW1pdGl2ZSBzZXQgc3RvcmFnZSB0aGF0IGRpc3Rpbmd1aXNoIHZpc2libGUvaGlkZGVuIHByaW1pdGl2ZXMuIEl0IGFsc28gYWN0cyBhcyBhIHByaW1pdGl2ZSBwcm92aWRlci5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERpc2FwcGVhcmluZ1ByaW1pdGl2ZVNldFN0b3JhZ2UgZXh0ZW5kcyBQcmltaXRpdmVTZXRTdG9yYWdlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fdmlzaWJsZVByaW1pdGl2ZXMgPSBuZXcgU2V0KCk7XHJcbiAgICB9XHJcbiAgICBnZXQgcHJpbWl0aXZlcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52aXNpYmxlUHJpbWl0aXZlcztcclxuICAgIH1cclxuICAgIGdldCB2aXNpYmxlUHJpbWl0aXZlcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaWJsZVByaW1pdGl2ZXM7XHJcbiAgICB9XHJcbiAgICBhZGQoLi4ucHJpbWl0aXZlcykge1xyXG4gICAgICAgIHN1cGVyLmFkZCguLi5wcmltaXRpdmVzKTtcclxuICAgICAgICB0aGlzLnNob3coLi4ucHJpbWl0aXZlcyk7XHJcbiAgICB9XHJcbiAgICBkZWxldGUoLi4ucHJpbWl0aXZlcykge1xyXG4gICAgICAgIHRoaXMuaGlkZSguLi5wcmltaXRpdmVzKTtcclxuICAgICAgICBzdXBlci5kZWxldGUoLi4ucHJpbWl0aXZlcyk7XHJcbiAgICB9XHJcbiAgICBzaG93KC4uLnByaW1pdGl2ZXMpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IHByaW1pdGl2ZSBvZiBwcmltaXRpdmVzKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9wcmltaXRpdmVTZXQuaGFzKHByaW1pdGl2ZSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Zpc2libGVQcmltaXRpdmVzLmFkZChwcmltaXRpdmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaGlkZSguLi5wcmltaXRpdmVzKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBwcmltaXRpdmUgb2YgcHJpbWl0aXZlcykge1xyXG4gICAgICAgICAgICB0aGlzLl92aXNpYmxlUHJpbWl0aXZlcy5kZWxldGUocHJpbWl0aXZlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfaXNBbGxvd2VkVG9TaG93UHJpbWl0aXZlKHByaW1pdGl2ZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wcmltaXRpdmVTZXQuaGFzKHByaW1pdGl2ZSk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgZmlsdGVySXRlcmFibGUgfSBmcm9tICcuLi8uLi91dGlsL2l0ZXJhYmxlJztcclxuaW1wb3J0IERpc2FwcGVhcmluZ1ByaW1pdGl2ZVNldFN0b3JhZ2UgZnJvbSAnLi9kaXNhcHBlYXJpbmdfcHJpbWl0aXZlX3NldF9zdG9yYWdlJztcclxuLyoqXHJcbiAqIFByaW1pdGl2ZSBzdG9yYWdlIHRoYXQgc3RvcmVzIHByaW1pdGl2ZSBpbiBhIHNldC4gSXQgYWN0cyBhcyBhIHByaW1pdGl2ZSBwcm92aWRlciBhcyB3ZWxsLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGVsYXllZERpc2FwcGVhcmluZ1ByaW1pdGl2ZVNldFN0b3JhZ2UgZXh0ZW5kcyBEaXNhcHBlYXJpbmdQcmltaXRpdmVTZXRTdG9yYWdlIHtcclxuICAgIGNvbnN0cnVjdG9yKGFwcGVhcmluZ0VmZmVjdER1cmF0aW9uKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl9hcHBlYXJpbmdFZmZlY3REdXJhdGlvbiA9IGFwcGVhcmluZ0VmZmVjdER1cmF0aW9uO1xyXG4gICAgICAgIHRoaXMuX3NjaGVkdWxlZFJlbW92ZXMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5fdGltZW91dElkcyA9IG5ldyBTZXQoKTtcclxuICAgIH1cclxuICAgIGdldCBwcmltaXRpdmVzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wcmltaXRpdmVTZXQ7XHJcbiAgICB9XHJcbiAgICBhZGQoLi4ucHJpbWl0aXZlcykge1xyXG4gICAgICAgIC8vIHByaW1pdGl2ZXMgdGhhdCBhcmUgc2NoZWR1bGVkIGZvciByZW1vdmluZyB3YXMgbm90IHJlbW92ZWQgXCJwaHlzaWNhbGx5XCIsIHRoYXQgaXMgd2h5XHJcbiAgICAgICAgLy8gdGhleSBzaG91bGQgYmUgZmlsdGVyZWQgb3V0IHRvIHByZXZlbnQgbXVsdGlwbGUgYWRkaW5nIG9mIHRoZSBzYW1lIHByaW1pdGl2ZSBpbiBwYXJlbnRcclxuICAgICAgICBjb25zdCBub3RTY2hlZHVsZWRGb3JSZW1vdmVQcmltaXRpdmVzID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBwcmltaXRpdmUgb2YgcHJpbWl0aXZlcykge1xyXG4gICAgICAgICAgICBjb25zdCBwcmltaXRpdmVzVG9EZWxldGUgPSB0aGlzLl9zY2hlZHVsZWRSZW1vdmVzLmdldChwcmltaXRpdmUpO1xyXG4gICAgICAgICAgICBpZiAocHJpbWl0aXZlc1RvRGVsZXRlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIHByaW1pdGl2ZSBpcyBzY2hlZHVsZWQgZm9yIHJlbW92aW5nIGl0IGlzIGRlbGV0ZWQgZnJvbSBpdHMgYmF0Y2gsXHJcbiAgICAgICAgICAgICAgICAvLyB0aHVzIGNhbmNlbGluZyB0aGUgcmVtb3ZpbmcgaW4gdGhlIGNhbGxiYWNrXHJcbiAgICAgICAgICAgICAgICBwcmltaXRpdmVzVG9EZWxldGUuZGVsZXRlKHByaW1pdGl2ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zY2hlZHVsZWRSZW1vdmVzLmRlbGV0ZShwcmltaXRpdmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbm90U2NoZWR1bGVkRm9yUmVtb3ZlUHJpbWl0aXZlcy5wdXNoKHByaW1pdGl2ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgc3VwZXIuYWRkKC4uLm5vdFNjaGVkdWxlZEZvclJlbW92ZVByaW1pdGl2ZXMpO1xyXG4gICAgICAgIHRoaXMuc2hvdyguLi5ub3RTY2hlZHVsZWRGb3JSZW1vdmVQcmltaXRpdmVzKTtcclxuICAgIH1cclxuICAgIGRlbGV0ZSguLi5wcmltaXRpdmVzKSB7XHJcbiAgICAgICAgdGhpcy5oaWRlKC4uLnByaW1pdGl2ZXMpO1xyXG4gICAgICAgIC8vIHByaW1pdGl2ZXMgYXJlIGJhdGNoZWQgaW4gYSBzZXQgdG8gYmUgZGVsZXRlZCBpbiBvbmUgc2V0VGltZW91dCBjYWxsYmFjayBmb3IgcGVyZm9ybWFuY2UsXHJcbiAgICAgICAgLy8gZmlsdGVyIG91dCBwcmltaXRpdmVzIHdoaWNoIHJlbW92aW5nIHdhcyBhbHJlYWR5IHNjaGVkdWxlZFxyXG4gICAgICAgIGNvbnN0IHByaW1pdGl2ZXNUb0RlbGV0ZSA9IG5ldyBTZXQoZmlsdGVySXRlcmFibGUocHJpbWl0aXZlcywgKHByaW1pdGl2ZSkgPT4gIXRoaXMuX3NjaGVkdWxlZFJlbW92ZXMuaGFzKHByaW1pdGl2ZSkpKTtcclxuICAgICAgICBpZiAocHJpbWl0aXZlc1RvRGVsZXRlLnNpemUgPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gcHJpbWl0aXZlc1RvRGVsZXRlIGNvbnRhaW5zIHJlbGV2YW50IGZvciByZW1vdmluZyBwcmltaXRpdmVzLCBpdCBjYW4gYmUgdXBkYXRlZCBpbiB0aGUgYWRkKCkgbWV0aG9kXHJcbiAgICAgICAgICAgICAgICAvLyBpZiBhIHByaW1pdGl2ZSBpcyBhZGRlZCBiYWNrLCB0aHVzLCBpbiBmYWN0LCBjYW5jZWxpbmcgcmVtb3Zpbmcgb2YgdGhpcyBzcGVjaWZpYyBwcmltaXRpdmVcclxuICAgICAgICAgICAgICAgIHN1cGVyLmRlbGV0ZSguLi5wcmltaXRpdmVzVG9EZWxldGUpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwcmltaXRpdmUgb2YgcHJpbWl0aXZlc1RvRGVsZXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2NoZWR1bGVkUmVtb3Zlcy5kZWxldGUocHJpbWl0aXZlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX3RpbWVvdXRJZHMuZGVsZXRlKHRpbWVvdXRJZCk7XHJcbiAgICAgICAgICAgIH0sIHRoaXMuX2FwcGVhcmluZ0VmZmVjdER1cmF0aW9uKTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBwcmltaXRpdmUgb2YgcHJpbWl0aXZlc1RvRGVsZXRlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zY2hlZHVsZWRSZW1vdmVzLnNldChwcmltaXRpdmUsIHByaW1pdGl2ZXNUb0RlbGV0ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fdGltZW91dElkcy5hZGQodGltZW91dElkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIGZvciAoY29uc3QgdGltZW91dElkIG9mIHRoaXMuX3RpbWVvdXRJZHMpIHtcclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2lzQWxsb3dlZFRvU2hvd1ByaW1pdGl2ZShwcmltaXRpdmUpIHtcclxuICAgICAgICByZXR1cm4gc3VwZXIuX2lzQWxsb3dlZFRvU2hvd1ByaW1pdGl2ZShwcmltaXRpdmUpICYmICF0aGlzLl9zY2hlZHVsZWRSZW1vdmVzLmhhcyhwcmltaXRpdmUpO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCBSZW5kZXJhYmxlUHJpbWl0aXZlTWFuYWdlciBmcm9tICcuL3JlbmRlcmFibGVfcHJpbWl0aXZlX21hbmFnZXInO1xyXG5pbXBvcnQgeyBtYXBJdGVyYWJsZSwgZmlsdGVySXRlcmFibGUgfSBmcm9tICcuLi8uLi8uLi91dGlsL2l0ZXJhYmxlJztcclxuLyoqXHJcbiAqIEl0IGlzIHJlcXVpcmVkIHRvIGhpZGUgc29tZSBwcmltaXRpdmVzICh0aGF0IGRvbid0IHNjYWxlIHdpdGggem9vbSwgZS5nLiBsYWJlbHMgb3IgaWNvbnMpIGJ5IFwidG9vIGlycmVsZXZhbnRcIiB6b29tLFxyXG4gKiB0byBwcmV2ZW50IG1lc3Mgb2YgY29sbGFwc2VkIG9iamVjdHMgb24gdGhlIHNjcmVlbi4gVGhpcyBwcmltaXRpdmUgbWFuYWdlciBpcyBhIHRlbXBvcmFyeSBzb2x1dGlvbixcclxuICogcHJvcGVyIGhhbmRsaW5nIG9mIHpvb20gc2xpY2VzIHdpbGwgcmVwbGFjZSBpdC5cclxuICovXHJcbi8vIFRPRE86IHRoaXMgbWFuYWdlciBpcyBhIHRtcCBzb2x1dGlvbiwgY29ycmVjdCBoYW5kbGluZyBvZiB6b29tIHNsaWNlcyBpcyBnb2luZyB0byByZXBsYWNlIGl0XHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFpvb21GaWx0ZXJhYmxlUHJpbWl0aXZlTWFuYWdlciBleHRlbmRzIFJlbmRlcmFibGVQcmltaXRpdmVNYW5hZ2VyIHtcclxuICAgIGNvbnN0cnVjdG9yKHByaW1pdGl2ZXNTdG9yYWdlLCBjYW1lcmEpIHtcclxuICAgICAgICBzdXBlcihwcmltaXRpdmVzU3RvcmFnZSk7XHJcbiAgICAgICAgdGhpcy5fZGlzYXBwZWFyaW5nUHJpbWl0aXZlc1N0b3JhZ2UgPSBwcmltaXRpdmVzU3RvcmFnZTtcclxuICAgICAgICB0aGlzLl9jYW1lcmEgPSBjYW1lcmE7XHJcbiAgICAgICAgdGhpcy5fcHJpbWl0aXZlcyA9IG5ldyBTZXQoKTtcclxuICAgICAgICB0aGlzLl9wcmV2Wm9vbSA9IGNhbWVyYS56b29tO1xyXG4gICAgICAgIHRoaXMuX3pvb21VcGRhdGVMaXN0ZW5lciA9IHRoaXMuX29uWm9vbVVwZGF0ZWQuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLl9jYW1lcmEub25VcGRhdGUuYWRkTGlzdGVuZXIodGhpcy5fem9vbVVwZGF0ZUxpc3RlbmVyKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZVNjZW5lKHRvU2hvdywgdG9IaWRlKSB7XHJcbiAgICAgICAgLy8gc2F2ZSBwcmltaXRpdmVzIHRvIGZpbHRlciB0aGVtIGxhdGVyXHJcbiAgICAgICAgc3VwZXIudXBkYXRlU2NlbmUobWFwSXRlcmFibGUodG9TaG93LCAocHJpbWl0aXZlKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX3ByaW1pdGl2ZXMuYWRkKHByaW1pdGl2ZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBwcmltaXRpdmU7XHJcbiAgICAgICAgfSksIG1hcEl0ZXJhYmxlKHRvSGlkZSwgKHByaW1pdGl2ZSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9wcmltaXRpdmVzLmRlbGV0ZShwcmltaXRpdmUpO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJpbWl0aXZlO1xyXG4gICAgICAgIH0pKTtcclxuICAgICAgICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgYWRkZWQgcHJpbWl0aXZlcyB0aGF0IGNvdWxkIGJlIHJlbW92ZWQgYnkgem9vbSByZXN0cmljdGlvbnNcclxuICAgICAgICB0aGlzLl91cGRhdGVab29tVmlzaWJpbGl0eSgpO1xyXG4gICAgfVxyXG4gICAgX29uWm9vbVVwZGF0ZWQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3ByZXZab29tICE9PSB0aGlzLl9jYW1lcmEuem9vbSkge1xyXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVab29tVmlzaWJpbGl0eSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9wcmV2Wm9vbSA9IHRoaXMuX2NhbWVyYS56b29tO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF91cGRhdGVab29tVmlzaWJpbGl0eSgpIHtcclxuICAgICAgICBjb25zdCB6b29tID0gdGhpcy5fY2FtZXJhLnpvb207XHJcbiAgICAgICAgdGhpcy5fZGlzYXBwZWFyaW5nUHJpbWl0aXZlc1N0b3JhZ2Uuc2hvdyguLi5maWx0ZXJJdGVyYWJsZSh0aGlzLl9wcmltaXRpdmVzLCAoeyBtaW5ab29tIH0pID0+IHpvb20gPj0gbWluWm9vbSkpO1xyXG4gICAgICAgIHRoaXMuX2Rpc2FwcGVhcmluZ1ByaW1pdGl2ZXNTdG9yYWdlLmhpZGUoLi4uZmlsdGVySXRlcmFibGUodGhpcy5fcHJpbWl0aXZlcywgKHsgbWluWm9vbSB9KSA9PiB6b29tIDwgbWluWm9vbSkpO1xyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLl9jYW1lcmEub25VcGRhdGUucmVtb3ZlTGlzdGVuZXIodGhpcy5fem9vbVVwZGF0ZUxpc3RlbmVyKTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZSB9IGZyb20gJy4uL3dvcmtlci90aWxlX3Byb3ZpZGVyX3dvcmtlcl9tZXNzYWdlcyc7XHJcbmltcG9ydCBNZW1vcnlTdWJDaHVuayBmcm9tICcuLi8uLi8uLi9yZW5kZXIvbWVtb3J5L3N1Yl9jaHVuayc7XHJcbmltcG9ydCBNb2RlbEJ1ZmZlcldyaXRlciBmcm9tICcuLi8uLi8uLi9wcmltaXRpdmUvbW9kZWwvbW9kZWxfYnVmZmVyX3dyaXRlcic7XHJcbmltcG9ydCBQcmltaXRpdmVNYW5hZ2VyIGZyb20gJy4vcHJpbWl0aXZlX21hbmFnZXInO1xyXG5pbXBvcnQgUmVuZGVyYWJsZU1vZGVsIGZyb20gJy4uLy4uLy4uL3ByaW1pdGl2ZS9tb2RlbC9yZW5kZXJhYmxlX21vZGVsJztcclxuaW1wb3J0IHsgTk9fSUQgfSBmcm9tICcuLi8uLi8uLi91dGlsL3dvcmtlcic7XHJcbi8qKlxyXG4gKiBFeHRlcm5hbCBtZXNoZXMgY29tZSBpbiBwb2x5Z29ucyAoa2luZCBvZiBidWlsZGluZyBvdXRsaW5lcykuIFRoaXMgbWFuYWdlciBjb250cm9scyBxdWVyaW5nIGV4dGVybmFsIG1lc2hlc1xyXG4gKiBhY2NvcmRpbmcgdG8gYWRkZWQgcG9seWdvbnMsIGFzIG1hbnkgb2YgdGhlbSBjYW4gc2hhcmUgdGhlIHNhbWUgbWVzaCAodXN1YWxseSBhY3Jvc3MgbXVsdGlwbGUgdGlsZXMpLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXh0ZXJuYWxNZXNoUHJpbWl0aXZlTWFuYWdlciBleHRlbmRzIFByaW1pdGl2ZU1hbmFnZXIge1xyXG4gICAgY29uc3RydWN0b3IocHJpbWl0aXZlc1N0b3JhZ2UsIGdlb21ldHJ5UHJvdmlkZXIsIG1lbW9yeU1hbmFnZXIpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX3ByaW1pdGl2ZXNTdG9yYWdlID0gcHJpbWl0aXZlc1N0b3JhZ2U7XHJcbiAgICAgICAgdGhpcy5fdGlsZVByb3ZpZGVyID0gZ2VvbWV0cnlQcm92aWRlcjtcclxuICAgICAgICB0aGlzLl9tZW1vcnlNYW5hZ2VyID0gbWVtb3J5TWFuYWdlcjtcclxuICAgICAgICB0aGlzLl9leHRlcm5hbE1lc2hlcyA9IG5ldyBNYXAoKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZVNjZW5lKHRvU2hvdywgdG9IaWRlKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBwcmltaXRpdmUgb2YgdG9TaG93KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FkZFByaW1pdGl2ZShwcmltaXRpdmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IHByaW1pdGl2ZSBvZiB0b0hpZGUpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlUHJpbWl0aXZlKHByaW1pdGl2ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2FkZFByaW1pdGl2ZShwcmltaXRpdmUpIHtcclxuICAgICAgICBjb25zdCBpZCA9IGdldEZ1bGxNZXNoSWQocHJpbWl0aXZlKTtcclxuICAgICAgICBsZXQgZXh0ZXJuYWwgPSB0aGlzLl9leHRlcm5hbE1lc2hlcy5nZXQoaWQpO1xyXG4gICAgICAgIGlmICghZXh0ZXJuYWwpIHtcclxuICAgICAgICAgICAgZXh0ZXJuYWwgPSB7XHJcbiAgICAgICAgICAgICAgICB2aXNpYmxlUG9seWdvbnM6IG5ldyBTZXQoKSxcclxuICAgICAgICAgICAgICAgIGlzVmlzaWJsZTogZmFsc2VcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5fZXh0ZXJuYWxNZXNoZXMuc2V0KGlkLCBleHRlcm5hbCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3RpbGVQcm92aWRlci5yZXF1ZXN0KHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFRpbGVQcm92aWRlck1lc3NhZ2VUeXBlLk1FU0hfUkVRVUVTVCxcclxuICAgICAgICAgICAgICAgIHJlc3BvbnNlVHlwZTogVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGUuTUVTSF9SRVNQT05TRSxcclxuICAgICAgICAgICAgICAgIGVycm9yVHlwZTogVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGUuTUVTSF9FUlJPUixcclxuICAgICAgICAgICAgICAgIG1lc2g6IHByaW1pdGl2ZSxcclxuICAgICAgICAgICAgICAgIHJlcXVlc3RJZDogTk9fSURcclxuICAgICAgICAgICAgfSkudGhlbigocmVzcG9uc2UpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGV4dGVybmFsID0gdGhpcy5fZXh0ZXJuYWxNZXNoZXMuZ2V0KGlkKTtcclxuICAgICAgICAgICAgICAgIGlmIChleHRlcm5hbCAmJiAhZXh0ZXJuYWwuaXNWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9jYXRpb24gPSByZXNwb25zZS5sb2NhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVua3MgPSByZXNwb25zZS5wYWdlcy5tYXAoKHBhZ2UpID0+IHRoaXMuX21lbW9yeU1hbmFnZXIuYWxsb2NhdGUocGFnZS52ZXJ0ZXhCdWZmZXIsIHBhZ2UuaW5kZXhCdWZmZXIsIE1vZGVsQnVmZmVyV3JpdGVyLkFUVFJJQlVURV9NQVBQSU5HKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXh0ZXJuYWwubWVzaCA9IG5ldyBSZW5kZXJhYmxlTW9kZWwobmV3IE1lbW9yeVN1YkNodW5rKGNodW5rc1tsb2NhdGlvbi5idWZmZXJJbmRleF0sIGxvY2F0aW9uKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXh0ZXJuYWwuaXNWaXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcmltaXRpdmVzU3RvcmFnZS5hZGQoZXh0ZXJuYWwubWVzaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtzLmZvckVhY2goKGNodW5rKSA9PiBjaHVuay5yZWxlYXNlKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZXh0ZXJuYWwudmlzaWJsZVBvbHlnb25zLmFkZChwcmltaXRpdmUpO1xyXG4gICAgfVxyXG4gICAgX3JlbW92ZVByaW1pdGl2ZShwcmltaXRpdmUpIHtcclxuICAgICAgICBjb25zdCBpZCA9IGdldEZ1bGxNZXNoSWQocHJpbWl0aXZlKTtcclxuICAgICAgICBjb25zdCBleHRlcm5hbCA9IHRoaXMuX2V4dGVybmFsTWVzaGVzLmdldChpZCk7XHJcbiAgICAgICAgaWYgKGV4dGVybmFsKSB7XHJcbiAgICAgICAgICAgIGV4dGVybmFsLnZpc2libGVQb2x5Z29ucy5kZWxldGUocHJpbWl0aXZlKTtcclxuICAgICAgICAgICAgLy8gZGVzdHJveSBleHRlcm5hbCBtZXNoIGlmIHRoZXJlIGlzIG5vIHZpc2libGUgcG9seWdvbnMgcmVtYWluaW5nXHJcbiAgICAgICAgICAgIGlmIChleHRlcm5hbC52aXNpYmxlUG9seWdvbnMuc2l6ZSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZXh0ZXJuYWxNZXNoZXMuZGVsZXRlKGlkKTtcclxuICAgICAgICAgICAgICAgIGlmIChleHRlcm5hbC5tZXNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXh0ZXJuYWwubWVzaC5yZWxlYXNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJpbWl0aXZlc1N0b3JhZ2UuZGVsZXRlKGV4dGVybmFsLm1lc2gpO1xyXG4gICAgICAgICAgICAgICAgICAgIGV4dGVybmFsLmlzVmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgbm8gbWVzaCB5ZXQgcmV0dXJuZWQgY2FuY2VsIHJlcXVlc3RcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90aWxlUHJvdmlkZXIuc2VuZE1lc3NhZ2Uoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZS5NRVNIX1JFUVVFU1RfQ0FOQ0VMLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNoOiBwcmltaXRpdmVcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRGdWxsTWVzaElkKG1lc2gpIHtcclxuICAgIHJldHVybiBtZXNoLm9iamVjdElkICsgbWVzaC5tZXNoSWQ7XHJcbn1cclxuIiwiaW1wb3J0IFJlbmRlcmFibGVQcmltaXRpdmUgZnJvbSAnLi4vcmVuZGVyYWJsZV9wcmltaXRpdmUnO1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW5kZXJhYmxlQmlsbGJvYXJkUmVjdGFuZ2xlIGV4dGVuZHMgUmVuZGVyYWJsZVByaW1pdGl2ZSB7XHJcbn1cclxuIiwiaW1wb3J0IFJlbmRlcmFibGVMYWJlbCBmcm9tICcuLi8uLi8uLi9wcmltaXRpdmUvbGFiZWwvcmVuZGVyYWJsZV9sYWJlbCc7XHJcbmV4cG9ydCBjbGFzcyBab29tUmVzdHJpY3RlZExhYmVsIGV4dGVuZHMgUmVuZGVyYWJsZUxhYmVsIHtcclxuICAgIGNvbnN0cnVjdG9yKG1lbW9yeVN1YkNodW5rLCBhdGxhcywgbWluWm9vbSwgYmFja2dyb3VuZCkge1xyXG4gICAgICAgIHN1cGVyKG1lbW9yeVN1YkNodW5rLCBhdGxhcywgYmFja2dyb3VuZCk7XHJcbiAgICAgICAgdGhpcy5taW5ab29tID0gbWluWm9vbTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgUmVuZGVyYWJsZVByaW1pdGl2ZSBmcm9tICcuLi9yZW5kZXJhYmxlX3ByaW1pdGl2ZSc7XHJcbi8qKlxyXG4gKiBBbGxvY2F0ZWQgaW4gR1BVIG1lbW9yeSBsYWJlbC5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbmRlcmFibGVMYWJlbCBleHRlbmRzIFJlbmRlcmFibGVQcmltaXRpdmUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IHJlbmRlcmFibGUgbGFiZWwuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG1lbW9yeVN1YkNodW5rXHJcbiAgICAgKiBAcGFyYW0gYXRsYXNcclxuICAgICAqIEBwYXJhbSBiYWNrZ3JvdW5kXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG1lbW9yeVN1YkNodW5rLCBhdGxhcywgYmFja2dyb3VuZCkge1xyXG4gICAgICAgIHN1cGVyKG1lbW9yeVN1YkNodW5rKTtcclxuICAgICAgICB0aGlzLmF0bGFzID0gYXRsYXM7XHJcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kID0gYmFja2dyb3VuZDtcclxuICAgICAgICBpZiAoYmFja2dyb3VuZCkge1xyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kLnJldGFpbigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9kZXN0cm95KCkge1xyXG4gICAgICAgIGlmICh0aGlzLmJhY2tncm91bmQpIHtcclxuICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kLnJlbGVhc2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3VwZXIuX2Rlc3Ryb3koKTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgUmVuZGVyYWJsZUljb24gZnJvbSAnLi4vLi4vLi4vcHJpbWl0aXZlL2ljb24vcmVuZGVyYWJsZV9pY29uJztcclxuZXhwb3J0IGNsYXNzIFpvb21SZXN0cmljdGVkSWNvbiBleHRlbmRzIFJlbmRlcmFibGVJY29uIHtcclxuICAgIGNvbnN0cnVjdG9yKG1lbW9yeVN1YkNodW5rLCBhbGxvY2F0ZWRJbWFnZSwgbWluWm9vbSkge1xyXG4gICAgICAgIHN1cGVyKG1lbW9yeVN1YkNodW5rLCBhbGxvY2F0ZWRJbWFnZSk7XHJcbiAgICAgICAgdGhpcy5taW5ab29tID0gbWluWm9vbTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgUmVuZGVyYWJsZUltYWdlIGZyb20gJy4uL2ltYWdlL3JlbmRlcmFibGVfaW1hZ2UnO1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW5kZXJhYmxlSWNvbiBleHRlbmRzIFJlbmRlcmFibGVJbWFnZSB7XHJcbn1cclxuIiwiaW1wb3J0IFRleHR1cmVkUmVuZGVyYWJsZVByaW1pdGl2ZSBmcm9tICcuLi90ZXh0dXJlZF9yZW5kZXJhYmxlX3ByaW1pdGl2ZSc7XHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbmRlcmFibGVJbWFnZSBleHRlbmRzIFRleHR1cmVkUmVuZGVyYWJsZVByaW1pdGl2ZSB7XHJcbn1cclxuIiwiaW1wb3J0IFJlbmRlcmFibGVQcmltaXRpdmUgZnJvbSAnLi9yZW5kZXJhYmxlX3ByaW1pdGl2ZSc7XHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRleHR1cmVkUmVuZGVyYWJsZVByaW1pdGl2ZSBleHRlbmRzIFJlbmRlcmFibGVQcmltaXRpdmUge1xyXG4gICAgY29uc3RydWN0b3IobWVtb3J5Q2h1bmssIGFsbG9jYXRlZEltYWdlKSB7XHJcbiAgICAgICAgc3VwZXIobWVtb3J5Q2h1bmspO1xyXG4gICAgICAgIHRoaXMuX2FsbG9jYXRlZEltYWdlID0gYWxsb2NhdGVkSW1hZ2U7XHJcbiAgICAgICAgdGhpcy5hdGxhcyA9IGFsbG9jYXRlZEltYWdlLmF0bGFzTWFuYWdlci5hdGxhcztcclxuICAgICAgICB0aGlzLl9hbGxvY2F0ZWRJbWFnZS5yZXRhaW4oKTtcclxuICAgIH1cclxuICAgIF9kZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMuX2FsbG9jYXRlZEltYWdlLnJlbGVhc2UoKTtcclxuICAgICAgICBzdXBlci5fZGVzdHJveSgpO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCBQcmlvcml0eVFldWV1ZSBmcm9tICcuL3ByaW9yaXR5X3F1ZXVlJztcclxuaW1wb3J0IHsgVm9pZEV2ZW50RW1pdHRlciB9IGZyb20gJy4uL3V0aWwvZXZlbnRfZW1pdHRlcic7XHJcbmNvbnN0IERFUVVFVUVfVElNRU9VVCA9IDE7IC8vIG1zXHJcbi8qKlxyXG4gKiBQcmlvcml0aXplZCB0YXNrIHF1ZXVlLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGFza1F1ZXVlIHtcclxuICAgIC8qKlxyXG4gICAgICogQ29uc3RydWN0cyBhbiBlbXB0eSB0YXNrIHF1ZXVlLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLl9xdWV1ZSA9IG5ldyBQcmlvcml0eVFldWV1ZSgpO1xyXG4gICAgICAgIHRoaXMuX2Zyb3plbiA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2RlcXVldWVUaW1lb3V0SGFuZGxlID0gMDtcclxuICAgICAgICB0aGlzLm9uRW1wdHkgPSBuZXcgVm9pZEV2ZW50RW1pdHRlcigpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXN0cm95cyB0aGUgcXVldWUuIEFueSByZW1haW5pbmcgdGFza3Mgd29uJ3QgYmUgZXhlY3V0ZWQuXHJcbiAgICAgKi9cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2RlcXVldWVUaW1lb3V0SGFuZGxlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRW5xdWV1ZXMgYSB0YXNrIHRvIHRoZSBxdWV1ZSBhbmQgc2NoZWR1bGVzIHByb2Nlc3Npbmcgb2YgdGhlIHF1ZXVlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0YXNrIFRoZSB0YXNrLlxyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB0aGF0IHdpbGwgYmUgZnVsbGZpbGxlZCB3aGVuIHRoZSB0YXNrIHN1Y2Nlc3NmdWxseVxyXG4gICAgICogICAgICBmaW5pc2hlcyBvciByZWplY3RlZCBpZiB0aGVyZSdzIGFuIGVycm9yLlxyXG4gICAgICovXHJcbiAgICBlbnF1ZXVlKHRhc2spIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2Zyb3plbikge1xyXG4gICAgICAgICAgICB0aGlzLl9zZXREZXF1ZXVlVGltZW91dCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9xdWV1ZS5lbnF1ZXVlKHtcclxuICAgICAgICAgICAgICAgIGV4ZWN1dGUoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFzay5leGVjdXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHByaW9yaXR5OiB0YXNrLnByaW9yaXR5XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaXNFbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcXVldWUuaXNFbXB0eSgpO1xyXG4gICAgfVxyXG4gICAgZnJlZXplKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9kZXF1ZXVlVGltZW91dEhhbmRsZSkge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fZGVxdWV1ZVRpbWVvdXRIYW5kbGUpO1xyXG4gICAgICAgICAgICB0aGlzLl9kZXF1ZXVlVGltZW91dEhhbmRsZSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2Zyb3plbiA9IHRydWU7XHJcbiAgICB9XHJcbiAgICB1bmZyZWV6ZSgpIHtcclxuICAgICAgICB0aGlzLl9mcm96ZW4gPSBmYWxzZTtcclxuICAgICAgICBpZiAoIXRoaXMuX3F1ZXVlLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zZXREZXF1ZXVlVGltZW91dCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9kZXF1ZXVlKCkge1xyXG4gICAgICAgIGNvbnN0IHRhc2sgPSB0aGlzLl9xdWV1ZS5kZXF1ZXVlKCk7XHJcbiAgICAgICAgaWYgKHRhc2spIHtcclxuICAgICAgICAgICAgdGFzay5leGVjdXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9xdWV1ZS5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgdGhpcy5fZGVxdWV1ZVRpbWVvdXRIYW5kbGUgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLm9uRW1wdHkuZmlyZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fZGVxdWV1ZVRpbWVvdXRIYW5kbGUgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuX2RlcXVldWUoKSwgREVRVUVVRV9USU1FT1VUKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfc2V0RGVxdWV1ZVRpbWVvdXQoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9kZXF1ZXVlVGltZW91dEhhbmRsZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9kZXF1ZXVlVGltZW91dEhhbmRsZSA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5fZGVxdWV1ZSgpLCBERVFVRVVFX1RJTUVPVVQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBEZWxlZ2F0b3JCYXNlIH0gZnJvbSAnLi4vLi4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvZGVsZWdhdG9yJztcclxuaW1wb3J0ICogYXMgdmVjMiBmcm9tICcuLi8uLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvbWF0aC92ZWN0b3IyJztcclxuZXhwb3J0IGNsYXNzIE1vdXNlRHJhZ0NvbnRyb2xsZXIgZXh0ZW5kcyBEZWxlZ2F0b3JCYXNlIHtcclxuICAgIGNvbnN0cnVjdG9yKHRhcmdldCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgIHRoaXMuX3ByZXNzZWRCdXR0b24gPSAtMSAvKiBOT05FICovO1xyXG4gICAgICAgIHRoaXMuX3ByZXZNb3VzZUNvb3JkcyA9IHZlYzIuY3JlYXRlKDAsIDApO1xyXG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzKTtcclxuICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzKTtcclxuICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCB0aGlzKTtcclxuICAgIH1cclxuICAgIGhhbmRsZUV2ZW50KGUpIHtcclxuICAgICAgICBzd2l0Y2ggKGUudHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlICdjbGljayc6XHJcbiAgICAgICAgICAgIGNhc2UgJ2NvbnRleHRtZW51JzpcclxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdtb3VzZWRvd24nOlxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3ByZXNzZWRCdXR0b24gPT09IC0xIC8qIE5PTkUgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcmVzc2VkQnV0dG9uID0gZS5idXR0b247XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJldk1vdXNlQ29vcmRzLnggPSBlLmNsaWVudFg7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJldk1vdXNlQ29vcmRzLnkgPSBlLmNsaWVudFk7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdtb3VzZW1vdmUnOlxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2RlbGVnYXRlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtb3VzZUNvb3JkcyA9IHZlYzIuY3JlYXRlKGUuY2xpZW50WCwgZS5jbGllbnRZKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gdmVjMi5zdWIobW91c2VDb29yZHMsIHRoaXMuX3ByZXZNb3VzZUNvb3Jkcyk7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3ByZXNzZWRCdXR0b24pIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDAgLyogTEVGVCAqLzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVsZWdhdGUub25MZWZ0QnV0dG9uRHJhZyhkZWx0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMSAvKiBNSURETEUgKi86XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlbGVnYXRlLm9uTWlkZGxlQnV0dG9uRHJhZyhkZWx0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMiAvKiBSSUdIVCAqLzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVsZWdhdGUub25SaWdodEJ1dHRvbkRyYWcoZGVsdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZlYzIuY29weShtb3VzZUNvb3JkcywgdGhpcy5fcHJldk1vdXNlQ29vcmRzKTtcclxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdtb3VzZXVwJzpcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wcmVzc2VkQnV0dG9uID09PSBlLmJ1dHRvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJlc3NlZEJ1dHRvbiA9IC0xIC8qIE5PTkUgKi87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMuX3RhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX3RhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX3RhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzKTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgY2xhc3MgU2Nyb2xsWm9vbUNvbnRyb2xsZXIgZXh0ZW5kcyBEZWxlZ2F0b3JCYXNlIHtcclxuICAgIGNvbnN0cnVjdG9yKHRhcmdldCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIHRoaXMpO1xyXG4gICAgfVxyXG4gICAgaGFuZGxlRXZlbnQoZSkge1xyXG4gICAgICAgIGNvbnN0IGRlbGVnYXRlID0gdGhpcy5fZGVsZWdhdGU7XHJcbiAgICAgICAgaWYgKCFkZWxlZ2F0ZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlLmRlbHRhWSA8IDApIHtcclxuICAgICAgICAgICAgZGVsZWdhdGUub25TY3JvbGxJbigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZGVsZWdhdGUub25TY3JvbGxPdXQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLl90YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2hlZWwnLCB0aGlzKTtcclxuICAgIH1cclxufVxyXG5jb25zdCBaT09NX1NURVAgPSAwLjE7XHJcbmNvbnN0IFRJTFRfQVpJTVVUSF9GQUNUT1IgPSBNYXRoLlBJIC8gMTAyNDtcclxuZXhwb3J0IGNsYXNzIENhbWVyYU1vdXNlQ29udHJvbGxlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihjYW52YXMsIGNhbWVyYSkge1xyXG4gICAgICAgIHRoaXMuX2NhbWVyYSA9IGNhbWVyYTtcclxuICAgICAgICB0aGlzLl9jYW52YXNTaXplID0gdmVjMi5jcmVhdGUoY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLmRyYWdGYWN0b3IgPSAxO1xyXG4gICAgfVxyXG4gICAgb25MZWZ0QnV0dG9uRHJhZyhkZWx0YSkge1xyXG4gICAgICAgIC8vIFRoYXQncyBub3QgZXhhY3QsIGJ1dCBnb29kIGVub3VnaCBmb3Igbm93LlxyXG4gICAgICAgIHZlYzIuZGl2dihkZWx0YSwgdGhpcy5fY2FudmFzU2l6ZSwgZGVsdGEpO1xyXG4gICAgICAgIGNvbnN0IGNhbWVyYSA9IHRoaXMuX2NhbWVyYTtcclxuICAgICAgICB2ZWMyLm11bG4oZGVsdGEsIHRoaXMuZHJhZ0ZhY3RvciAqIGNhbWVyYS5zY3JlZW5TaXplLmhlaWdodCAqIE1hdGgucG93KDIsIC1jYW1lcmEuem9vbSkgL1xyXG4gICAgICAgICAgICAoTWF0aC50YW4oMC41ICogY2FtZXJhLm9wdGlvbnMuZm92KSAqIDY0KSwgZGVsdGEpO1xyXG4gICAgICAgIGNvbnN0IGNlbnRlciA9IHRoaXMuX2NhbWVyYS5jZW50ZXI7XHJcbiAgICAgICAgY2VudGVyLnggLT0gZGVsdGEueDtcclxuICAgICAgICBjZW50ZXIueSArPSBkZWx0YS55O1xyXG4gICAgICAgIHRoaXMuX2NhbWVyYS5zZXREaXJ0eSgpO1xyXG4gICAgfVxyXG4gICAgb25NaWRkbGVCdXR0b25EcmFnKCkgeyB9XHJcbiAgICBvblJpZ2h0QnV0dG9uRHJhZyhkZWx0YSkge1xyXG4gICAgICAgIGNvbnN0IGNhbWVyYSA9IHRoaXMuX2NhbWVyYTtcclxuICAgICAgICBjYW1lcmEudGlsdCArPSBkZWx0YS55ICogVElMVF9BWklNVVRIX0ZBQ1RPUjtcclxuICAgICAgICBjYW1lcmEuYXppbXV0aCArPSBkZWx0YS54ICogVElMVF9BWklNVVRIX0ZBQ1RPUjtcclxuICAgICAgICB0aGlzLl9jYW1lcmEuc2V0RGlydHkoKTtcclxuICAgIH1cclxuICAgIG9uU2Nyb2xsSW4oKSB7XHJcbiAgICAgICAgdGhpcy5fY2FtZXJhLnpvb20gKz0gWk9PTV9TVEVQO1xyXG4gICAgICAgIHRoaXMuX2NhbWVyYS5zZXREaXJ0eSgpO1xyXG4gICAgfVxyXG4gICAgb25TY3JvbGxPdXQoKSB7XHJcbiAgICAgICAgdGhpcy5fY2FtZXJhLnpvb20gLT0gWk9PTV9TVEVQO1xyXG4gICAgICAgIHRoaXMuX2NhbWVyYS5zZXREaXJ0eSgpO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IGNhbWVyYVN0YXRlRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNjYW1lcmFfc3RhdGUnKTtcclxuY29uc3QgY2FtZXJhU3RhdGVUZXh0ID0gY2FtZXJhU3RhdGVFbGVtZW50ICYmIGNhbWVyYVN0YXRlRWxlbWVudC5maXJzdENoaWxkO1xyXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyQ2FtZXJhU3RhdGUoY2FtZXJhKSB7XHJcbiAgICBjb25zdCB7IGNlbnRlcjogeyB4LCB5IH0sIHpvb20sIHRpbHQsIGF6aW11dGggfSA9IGNhbWVyYTtcclxuICAgIGNhbWVyYVN0YXRlVGV4dC5yZXBsYWNlRGF0YSgwLCBjYW1lcmFTdGF0ZVRleHQubGVuZ3RoLCBgY2VudGVyOiAoJHt4LnRvRml4ZWQoOCl9LCR7eS50b0ZpeGVkKDgpfSk7IHpvb206ICR7em9vbS50b0ZpeGVkKDQpfTsgYCArXHJcbiAgICAgICAgYHRpbHQ6ICR7dGlsdC50b0ZpeGVkKDQpfTsgYXppbXV0aDogJHthemltdXRoLnRvRml4ZWQoNCl9YCk7XHJcbn1cclxuIiwiZXhwb3J0IGNsYXNzIERlbGVnYXRvckJhc2Uge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5fZGVsZWdhdGUgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgc2V0RGVsZWdhdGUoZGVsZWdhdGUpIHtcclxuICAgICAgICB0aGlzLl9kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCBwb2ludExhYmVsVmVydGV4U2hhZGVyIGZyb20gJy4vc2hhZGVyL3BvaW50X2xhYmVsLnZlcnQnO1xyXG5pbXBvcnQgY29sb3JJZEZyYWdtZW50U2hhZGVyIGZyb20gJy4vc2hhZGVyL2NvbG9yX2lkLmZyYWcnO1xyXG5pbXBvcnQgQ29sbGlkaW5nTGFiZWxDb2xvcklkUmVuZGVyZXIgZnJvbSAnLi9jb2xvcl9pZF9sYWJlbF9yZW5kZXJlcic7XHJcbmltcG9ydCB7IFBST0dSQU1fT1BUSU9OUyB9IGZyb20gJy4uLy4uLy4uL3JlbmRlci9wcmltaXRpdmVzL2xhYmVsL3BvaW50X2xhYmVsX3JlbmRlcl91bml0JztcclxuLyoqXHJcbiAqIFBvaW50IGxhYmVscyByZW5kZXJlciBmb3IgY29sbGlzaW9uIHJlc29sdXRpb24uXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb2xvcklkUG9pbnRMYWJlbFJlbmRlcmVyIGV4dGVuZHMgQ29sbGlkaW5nTGFiZWxDb2xvcklkUmVuZGVyZXIge1xyXG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgY2FtZXJhLCBwcmltaXRpdmVQcm92aWRlcikge1xyXG4gICAgICAgIGNvbnN0IHByb2dyYW0gPSBjb250ZXh0LmNyZWF0ZVByb2dyYW0ocG9pbnRMYWJlbFZlcnRleFNoYWRlciwgY29sb3JJZEZyYWdtZW50U2hhZGVyLCBQUk9HUkFNX09QVElPTlMpO1xyXG4gICAgICAgIHN1cGVyKGNvbnRleHQsIHByb2dyYW0sIHByaW1pdGl2ZVByb3ZpZGVyLCBjYW1lcmEpO1xyXG4gICAgfVxyXG59XHJcbiIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleElkO1xcblxcbi8vIHBvaW50IGluIHRoZSB3b3JsZCB0aGUgbGFiZWwgaXMgYW5jaG9yZWQgdG9cXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhQb3NIaWdoO1xcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleFBvc0xvdztcXG5cXG4vLyB2ZWN0b3Igb2YgY29uY3JldGUgZ2x5cGggcG9pbnQgZGlzcGxhY2VtZW50ICh0b3AtbGVmdCwgYm90dG9tLWxlZnQsIC4uLikgcmVsYXRpdmUgdG8gbGFiZWwncyBjZW50ZXIsIGluIHB4XFxuYXR0cmlidXRlIHZlYzIgdmVydGV4RGlzcGxhY2VtZW50O1xcblxcbi8vIGNvb3JkaW5hdGVzIG9mIHRoZSBnbHlwaCB2ZXJ0ZXggaW4gdGhlIGF0bGFzXFxuYXR0cmlidXRlIHZlYzIgdmVydGV4VVY7XFxuXFxuYXR0cmlidXRlIGZsb2F0IHZlcnRleFByaW9yaXR5O1xcblxcbnVuaWZvcm0gdmVjMiBsb29rQXRIaWdoO1xcbnVuaWZvcm0gdmVjMiBsb29rQXRMb3c7XFxudW5pZm9ybSBtYXQ0IHZpZXdQcm9qTWF0cml4O1xcbnVuaWZvcm0gdmVjMiBwaXhlbFNpemU7XFxudW5pZm9ybSBzYW1wbGVyMkQgdmlzaWJpbGl0eTtcXG51bmlmb3JtIHZlYzIgaWRIYWxmUHhTaXplO1xcbnVuaWZvcm0gdmVjMiBzaGlmdDtcXG51bmlmb3JtIGxvd3AgZmxvYXQgY3VycmVudFpvb207XFxuXFxudmFyeWluZyB2ZWMyIHV2O1xcbnZhcnlpbmcgbG93cCB2ZWM0IGNvbG9yO1xcbnZhcnlpbmcgbG93cCB2ZWM0IG91dGxpbmVDb2xvcjtcXG52YXJ5aW5nIG1lZGl1bXAgZmxvYXQgc2NhbGU7XFxuXFxuY29uc3QgdmVjNCBESVNDQVJEX1BPU0lUSU9OID0gdmVjNCgyLCAyLCAyLCAxKTtcXG5cXG5jb25zdCBmbG9hdCBZVl9IXzFfMCA9IDEuOTk5OTY5NDgyNDIxODc1O1xcbmNvbnN0IGZsb2F0IFlWX0xfMV8xID0gMC4wMDAwMzA1MTcxMTI0NjM3MTI2OTI7XFxuXFxuLyoqXFxuICogUHJvamVjdHMgc3BlY2lmaWMgcG9pbnQgbGFiZWwgdmVydGV4IG9udG8gdGhlIHNjcmVlbi5cXG4gKi9cXG52ZWM0IHByb2plY3RQb2ludExhYmVsVmVydGV4XzFfMihcXG4gICAgbWF0NCB2aWV3UHJvak1hdHJpeCxcXG4gICAgdmVjMiBsb29rQXRIaWdoLFxcbiAgICB2ZWMyIGxvb2tBdExvdyxcXG4gICAgdmVjMiBwb3NIaWdoLFxcbiAgICB2ZWMyIHBvc0xvdyxcXG4gICAgdmVjMiBkaXNwbGFjZW1lbnQsXFxuICAgIHZlYzIgcHhTaXplXFxuKSB7XFxuICAgIHZlYzQgcG9zaXRpb24gPSB2aWV3UHJvak1hdHJpeCAqIHZlYzQoXFxuICAgICAgICBZVl9IXzFfMCAqIChwb3NIaWdoIC0gbG9va0F0SGlnaCkgK1xcbiAgICAgICAgICAgIFlWX0xfMV8xICogKHBvc0xvdyAtIGxvb2tBdExvdyksXFxuICAgICAgICAwLFxcbiAgICAgICAgMVxcbiAgICApO1xcbiAgICBwb3NpdGlvbiA9IHZlYzQocG9zaXRpb24ueHkgLyBwb3NpdGlvbi53LCAwLjAsIDEuMCk7XFxuXFxuICAgIHJldHVybiBwb3NpdGlvbiArIHZlYzQoZGlzcGxhY2VtZW50ICogcHhTaXplLCAwLjAsIDAuMCk7XFxufVxcblxcblxcblxcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIHZlYzIgaWRUZXhDb29yZGluYXRlID0gdmVydGV4SWQueHkgKyBpZEhhbGZQeFNpemU7XFxuICAgIGZsb2F0IG92ZXJsYXBab29tID0gdGV4dHVyZTJEKHZpc2liaWxpdHksIGlkVGV4Q29vcmRpbmF0ZSkuYjtcXG4gICAgaWYgKGN1cnJlbnRab29tIDwgb3ZlcmxhcFpvb20pIHtcXG4gICAgICAgIGdsX1Bvc2l0aW9uID0gRElTQ0FSRF9QT1NJVElPTjtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdFBvaW50TGFiZWxWZXJ0ZXhfMV8yKFxcbiAgICAgICAgICAgIHZpZXdQcm9qTWF0cml4LFxcbiAgICAgICAgICAgIGxvb2tBdEhpZ2gsXFxuICAgICAgICAgICAgbG9va0F0TG93LFxcbiAgICAgICAgICAgIHZlcnRleFBvc0hpZ2gsXFxuICAgICAgICAgICAgdmVydGV4UG9zTG93LFxcbiAgICAgICAgICAgIHZlcnRleERpc3BsYWNlbWVudCxcXG4gICAgICAgICAgICBwaXhlbFNpemVcXG4gICAgICAgICk7XFxuICAgICAgICBnbF9Qb3NpdGlvbi54eSArPSBzaGlmdDtcXG4gICAgICAgIGdsX1Bvc2l0aW9uLnogPSB2ZXJ0ZXhQcmlvcml0eTtcXG4gICAgICAgIGNvbG9yID0gdmVjNCh2ZXJ0ZXhJZCwgMCwgMSk7XFxuICAgIH1cXG5cXG59XFxuXCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiI3ZlcnNpb24gMTAwXFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG52YXJ5aW5nIGxvd3AgdmVjNCBjb2xvcjtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgICBnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG59XFxuXCIiLCJpbXBvcnQgeyBDb2xsaWRpbmdQcmltaXRpdmVDb2xvcklkUmVuZGVyZXIgfSBmcm9tICcuLi9jb2xsaWRpbmdfcHJpbWl0aXZlX2NvbG9yX2lkX3JlbmRlcmVyJztcclxuLyoqXHJcbiAqIFwiY29sb3IgaWRcIiByZW5kZXJlciBmb3IgbGFiZWxzLCBib3RoIGZvciBwb2ludCBhbmQgY3VydmVkIG9uZXMuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb2xvcklkTGFiZWxSZW5kZXJlciBleHRlbmRzIENvbGxpZGluZ1ByaW1pdGl2ZUNvbG9ySWRSZW5kZXJlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBwcm9ncmFtLCBwcmltaXRpdmVQcm92aWRlciwgY2FtZXJhKSB7XHJcbiAgICAgICAgc3VwZXIoY29udGV4dCwgcHJvZ3JhbSwgcHJpbWl0aXZlUHJvdmlkZXIpO1xyXG4gICAgICAgIHRoaXMuX2NhbWVyYSA9IGNhbWVyYTtcclxuICAgIH1cclxuICAgIF9wcmVwYXJlUHJvZ3JhbShwcm9ncmFtLCB2aWV3UHJvak1hdHJpeCwgY2FtZXJhUG9zaXRpb25zLCBzdGF0ZSwgc3RhYmlsaXR5U2hpZnQsIHZpc2liaWxpdHksIGN1cnJlbnRab29tKSB7XHJcbiAgICAgICAgc3VwZXIuX3ByZXBhcmVQcm9ncmFtKHByb2dyYW0sIHZpZXdQcm9qTWF0cml4LCBjYW1lcmFQb3NpdGlvbnMsIHN0YXRlLCBzdGFiaWxpdHlTaGlmdCwgdmlzaWJpbGl0eSwgY3VycmVudFpvb20pO1xyXG4gICAgICAgIHByb2dyYW0uc2V0VmVjdG9yMlVuaWZvcm0oJ3BpeGVsU2l6ZScsIHRoaXMuX2NhbWVyYS5waXhlbFNpemUpO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCBSZW5kZXJTdGF0ZSBmcm9tICcuLi8uLi9yZW5kZXIvc3RhdGUnO1xyXG5pbXBvcnQgKiBhcyB2ZWMyIGZyb20gJy4uLy4uL21hdGgvdmVjdG9yMic7XHJcbmltcG9ydCBXb3JsZFByaW1pdGl2ZVJlbmRlclVuaXQgZnJvbSAnLi4vLi4vcmVuZGVyL3ByaW1pdGl2ZXMvd29ybGRfcHJpbWl0aXZlX3JlbmRlcl91bml0JztcclxuZXhwb3J0IGNsYXNzIENvbGxpZGluZ1ByaW1pdGl2ZUNvbG9ySWRSZW5kZXJlciBleHRlbmRzIFdvcmxkUHJpbWl0aXZlUmVuZGVyVW5pdCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBwcm9ncmFtLCBwcmltaXRpdmVQcm92aWRlcikge1xyXG4gICAgICAgIHN1cGVyKGNvbnRleHQsIG5ldyBSZW5kZXJTdGF0ZSgpLCBwcm9ncmFtLCBwcmltaXRpdmVQcm92aWRlcik7XHJcbiAgICAgICAgdGhpcy5faWRIYWxmUHhTaXplVW5pZm9ybSA9IHZlYzIuY3JlYXRlKDAsIDApO1xyXG4gICAgfVxyXG4gICAgX2dldFByaW1pdGl2ZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHJpbWl0aXZlUHJvdmlkZXIudmlzaWJsZVByaW1pdGl2ZXM7XHJcbiAgICB9XHJcbiAgICBfcHJlcGFyZVByb2dyYW0ocHJvZ3JhbSwgdmlld1Byb2pNYXRyaXgsIGNhbWVyYVBvc2l0aW9ucywgc3RhdGUsIHN0YWJpbGl0eVNoaWZ0LCB2aXNpYmlsaXR5LCBjdXJyZW50Wm9vbSkge1xyXG4gICAgICAgIHN1cGVyLl9wcmVwYXJlUHJvZ3JhbShwcm9ncmFtLCB2aWV3UHJvak1hdHJpeCwgY2FtZXJhUG9zaXRpb25zLCBzdGF0ZSwgc3RhYmlsaXR5U2hpZnQsIHZpc2liaWxpdHksIGN1cnJlbnRab29tKTtcclxuICAgICAgICB0aGlzLl9pZEhhbGZQeFNpemVVbmlmb3JtLnggPSAwLjUgLyB2aXNpYmlsaXR5LmdldFdpZHRoKCk7XHJcbiAgICAgICAgdGhpcy5faWRIYWxmUHhTaXplVW5pZm9ybS55ID0gMC41IC8gdmlzaWJpbGl0eS5nZXRIZWlnaHQoKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRUZXh0dXJlVW5pdCgwKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRUZXh0dXJlKHZpc2liaWxpdHkpO1xyXG4gICAgICAgIHByb2dyYW0uc2V0SW50U2NhbGFyVW5pZm9ybSgndmlzaWJpbGl0eScsIDApO1xyXG4gICAgICAgIHByb2dyYW0uc2V0VmVjdG9yMlVuaWZvcm0oJ2lkSGFsZlB4U2l6ZScsIHRoaXMuX2lkSGFsZlB4U2l6ZVVuaWZvcm0pO1xyXG4gICAgICAgIHByb2dyYW0uc2V0VmVjdG9yMlVuaWZvcm0oJ3NoaWZ0Jywgc3RhYmlsaXR5U2hpZnQpO1xyXG4gICAgICAgIHByb2dyYW0uc2V0U2NhbGFyVW5pZm9ybSgnY3VycmVudFpvb20nLCBjdXJyZW50Wm9vbSk7XHJcbiAgICB9XHJcbiAgICBfcHJlcGFyZVJlbmRlclRhcmdldCh0YXJnZXQsIF92aWV3UHJvak1hdHJpeCwgX2NhbWVyYVBvc2l0aW9ucywgc3RhdGUsIF9zdGFiaWxpdHlTaGlmdCwgX3Zpc2liaWxpdHksIF9jdXJyZW50Wm9vbSkge1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFJlbmRlclN0YXRlKHN0YXRlKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRSZW5kZXJUYXJnZXQodGFyZ2V0KTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBHbFJlbmRlcmVyIH0gZnJvbSAnLi4vZ2xfcmVuZGVyZXInO1xyXG5pbXBvcnQgeyBjb3VudEluZGljZXMgfSBmcm9tICcuLi9tZW1vcnkvY291bnRfdmVydGljZXMnO1xyXG5pbXBvcnQgeyBiYXRjaFByaW1pdGl2ZXMgfSBmcm9tICcuL3ByaW1pdGl2ZV9iYXRjaCc7XHJcbi8qKlxyXG4gKiBCYXNlIGNsYXNzIGZvciByZW5kZXJpbmcgdmlzaWJsZSBwcmltaXRpdmVzLiBCZWluZyB2aXNpYmxlIGluIHRoZSB3b3JsZCBtZWFucyB0aGF0IHRoZXkgYWxsIG5lZWQgdmlldy1wcm9qZWN0aW9uXHJcbiAqIG1hdHJpeCBhbmQgY2FtZXJhIHBvc2l0aW9ucyAobXVsdGlwbGUgcG9zaXRpb25zIGFyZSB1c2VkIGZvciByZW5kZXJpbmcgcmVwZWF0ZWQgd29ybGQpLiBUaGVzZSBwYXJhbWV0ZXJzIGFyZVxyXG4gKiBwcmVkZWZpbmVkIGFzIGV4dGVybmFsIHJlcXVpcmVtZW50cyBmb3IgcmVuZGVyKCkgbWV0aG9kLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV29ybGRQcmltaXRpdmVSZW5kZXJVbml0IGV4dGVuZHMgR2xSZW5kZXJlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCByZW5kZXJTdGF0ZSwgcHJvZ3JhbSwgcHJpbWl0aXZlUHJvdmlkZXIpIHtcclxuICAgICAgICBzdXBlcihjb250ZXh0LCByZW5kZXJTdGF0ZSwgcHJvZ3JhbSk7XHJcbiAgICAgICAgdGhpcy5wcmltaXRpdmVQcm92aWRlciA9IHByaW1pdGl2ZVByb3ZpZGVyO1xyXG4gICAgICAgIHRoaXMub25VcGRhdGUgPSBwcmltaXRpdmVQcm92aWRlci5vblVwZGF0ZTtcclxuICAgIH1cclxuICAgIHJlbmRlcih0YXJnZXQsIHZpZXdQcm9qTWF0cml4LCBjYW1lcmFQb3NpdGlvbnMsIC4uLmFyZ3MpIHtcclxuICAgICAgICBzdXBlci5yZW5kZXIodGFyZ2V0LCB2aWV3UHJvak1hdHJpeCwgY2FtZXJhUG9zaXRpb25zLCAuLi5hcmdzKTtcclxuICAgIH1cclxuICAgIF9yZW5kZXIoX3ZpZXdQcm9qTWF0cml4LCBjYW1lcmFQb3NpdGlvbnMpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGNhbWVyYVBvc2l0aW9uIG9mIGNhbWVyYVBvc2l0aW9ucykge1xyXG4gICAgICAgICAgICB0aGlzLl9wcm9ncmFtLnNldFZlY3RvcjJVbmlmb3JtKCdsb29rQXRIaWdoJywgY2FtZXJhUG9zaXRpb24ubG9va0F0SGlnaCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3Byb2dyYW0uc2V0VmVjdG9yMlVuaWZvcm0oJ2xvb2tBdExvdycsIGNhbWVyYVBvc2l0aW9uLmxvb2tBdExvdyk7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgbWVtb3J5QmF0Y2ggb2YgYmF0Y2hQcmltaXRpdmVzKHRoaXMuX2dldFByaW1pdGl2ZXMoKSwgdGhpcy5fY2FuQmF0Y2hBZGphY2VudFByaW1pdGl2ZXMpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJCYXRjaChtZW1vcnlCYXRjaCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfZ2V0UHJpbWl0aXZlcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wcmltaXRpdmVQcm92aWRlci5wcmltaXRpdmVzO1xyXG4gICAgfVxyXG4gICAgX3ByZXBhcmVQcm9ncmFtKHByb2dyYW0sIHZpZXdQcm9qTWF0cml4LCBjYW1lcmFQb3NpdGlvbnMsIC4uLmFyZ3MpIHtcclxuICAgICAgICBzdXBlci5fcHJlcGFyZVByb2dyYW0ocHJvZ3JhbSwgdmlld1Byb2pNYXRyaXgsIGNhbWVyYVBvc2l0aW9ucywgLi4uYXJncyk7XHJcbiAgICAgICAgcHJvZ3JhbS5zZXRNYXRyaXg0VW5pZm9ybSgndmlld1Byb2pNYXRyaXgnLCB2aWV3UHJvak1hdHJpeCk7XHJcbiAgICB9XHJcbiAgICBfcmVuZGVyQmF0Y2gobWVtb3J5QmF0Y2gpIHtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRWYW8obWVtb3J5QmF0Y2gucGFnZS52YW8pO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuZHJhd0luZGV4ZWRNZXNoKG1lbW9yeUJhdGNoLmluZGV4Qnl0ZU9mZnNldCwgY291bnRJbmRpY2VzKG1lbW9yeUJhdGNoLmluZGV4Qnl0ZUxlbmd0aCwgbWVtb3J5QmF0Y2gucGFnZS5pbmRleFR5cGUpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGV0ZXJtaW5lcyBpZiB0d28gYWRqYWNlbnQgcHJpbWl0aXZlcyBjYW4gYmUgcmVuZGVyZWQgaW4gb25lIGJhdGNoIChieSBhIHNpbmdsZSBkcmF3IGNhbGwpLiBUaGV5IGFscmVhZHlcclxuICAgICAqIGxheSBzdWNjZXNzaXZlbHkgaW4gbWVtb3J5LCBidXQgdGhlcmUgY291bGQgYmUgb3RoZXIgcmVhc29ucyB0aGF0IGZvcmJpZCBiYXRjaGluZywgbGlrZSB1c2luZyBkaWZmZXJlbnQgdGV4dHVyZXMuXHJcbiAgICAgKiBUaGUgbWV0aG9kIHNob3VsZCBiZSBvdmVycmlkZGVuIGluIHN1YmNsYXNzZXMgaWYgdGhlaXIgcHJpbWl0aXZlcyBoYXZlIHN1Y2ggY29tcGxleCBydWxlcyBvZiBiYXRjaGluZy5cclxuICAgICAqL1xyXG4gICAgX2NhbkJhdGNoQWRqYWNlbnRQcmltaXRpdmVzKF9hLCBfYikge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG59XHJcbiIsIi8qKlxyXG4gKiBCYXNlIGNsYXNzIGZvciBhbnkgV2ViR0wgcmVuZGVyZXIsIGl0IGp1c3QgZGVmaW5lcyBiYXNpYyBzdHJ1Y3R1cmUgb2YgR0wtY2FsbHMgYWxsb3dpbmcgdG8gb3ZlcnJpZGUgYW55IHBhcnQuXHJcbiAqIEEgc3BlY2lmaWMgcmVuZGVyZXIgbWF5IG5lZWQgYW55IG51bWJlciBvZiBhZGRpdGlvbmFsIGFyZ3VtZW50cyB0byBwZXJmb3JtIHJlbmRlcmluZywgdGhleSBhcmUgcHJvdmlkZWQgaW5cclxuICogYWRkaXRpb25hbFBhcmFtcyBpbiB0aGUgcmVuZGVyKCkgbWV0aG9kLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEdsUmVuZGVyZXIge1xyXG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgcmVuZGVyU3RhdGUsIHByb2dyYW0pIHtcclxuICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcclxuICAgICAgICB0aGlzLl9yZW5kZXJTdGF0ZSA9IHJlbmRlclN0YXRlO1xyXG4gICAgICAgIHRoaXMuX3Byb2dyYW0gPSBwcm9ncmFtO1xyXG4gICAgfVxyXG4gICAgcmVuZGVyKHRhcmdldCwgLi4uYXJncykge1xyXG4gICAgICAgIGlmICh0aGlzLl9wcm9ncmFtKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3ByZXBhcmVQcm9ncmFtKHRoaXMuX3Byb2dyYW0sIC4uLmFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9wcmVwYXJlUmVuZGVyVGFyZ2V0KHRhcmdldCwgLi4uYXJncyk7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyKC4uLmFyZ3MpO1xyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICBpZiAodGhpcy5fcHJvZ3JhbSkge1xyXG4gICAgICAgICAgICB0aGlzLl9wcm9ncmFtLmRlc3Ryb3koKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEJpbmRzIHByb2dyYW0gYW5kIHNldHMgcmVxdWlyZWQgdW5pZm9ybXMuIFN1YmNsYXNzZXMgYXJlIHN1cHBvc2VkIHRvIG92ZXJyaWRlXHJcbiAgICAgKiB0aGlzIG1ldGhvZCB0byBhZGQgdGhlaXIgb3duIHVuaWZvcm1zLlxyXG4gICAgICovXHJcbiAgICBfcHJlcGFyZVByb2dyYW0ocHJvZ3JhbSwgLi4uX2FyZ3MpIHtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRQcm9ncmFtKHByb2dyYW0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBCaW5kcyByZW5kZXIgc3RhdGUgYW5kIHJlbmRlciB0YXJnZXQsIG5vIGNsZWFyIGhhcHBlbnMgaGVyZSwgYnV0IHRoaXMgbWV0aG9kXHJcbiAgICAgKiBjYW4gYmUgb3ZlcnJpZGRlbiBpbiBzdWJjbGFzc2VzIHRvIGFkZCBhbnkgc2V0dXBzIHRoZXkgbmVlZC5cclxuICAgICAqL1xyXG4gICAgX3ByZXBhcmVSZW5kZXJUYXJnZXQodGFyZ2V0LCAuLi5fYXJncykge1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFJlbmRlclN0YXRlKHRoaXMuX3JlbmRlclN0YXRlKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRSZW5kZXJUYXJnZXQodGFyZ2V0KTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBiYXRjaEFsbG9jYXRlZE9iamVjdHMgfSBmcm9tICcuLi9tZW1vcnkvcmVsYXRpdmVfbG9jYXRpb24nO1xyXG4vKipcclxuICogQ3JlYXRlcyBiYXRjaCBmcm9tIGZpcnN0IHByaW1pdGl2ZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBpbml0QmF0Y2gocHJpbWl0aXZlKSB7XHJcbiAgICBjb25zdCBzdWJDaHVuayA9IHByaW1pdGl2ZS5tZW1vcnlTdWJDaHVuaztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZmlyc3RQcmltaXRpdmU6IHByaW1pdGl2ZSxcclxuICAgICAgICBwYWdlOiBzdWJDaHVuay5tZW1vcnlDaHVuay5wYWdlLFxyXG4gICAgICAgIHZlcnRleEJ5dGVPZmZzZXQ6IHN1YkNodW5rLnZlcnRleEJ5dGVPZmZzZXQsXHJcbiAgICAgICAgdmVydGV4Qnl0ZUxlbmd0aDogc3ViQ2h1bmsudmVydGV4Qnl0ZUxlbmd0aCxcclxuICAgICAgICBpbmRleEJ5dGVPZmZzZXQ6IHN1YkNodW5rLmluZGV4Qnl0ZU9mZnNldCxcclxuICAgICAgICBpbmRleEJ5dGVMZW5ndGg6IHN1YkNodW5rLmluZGV4Qnl0ZUxlbmd0aFxyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogQmF0Y2hlcyBwcmltaXRpdmVzIHRoYXQgY2FuIGJlIHJlbmRlcmVkIGJ5IGEgc2luZ2xlIGRyYXcgY2FsbCwgdGhhdCBpcyBjcml0aWNhbCBmb3IgcGVyZm9ybWFuY2UuXHJcbiAqIFBlcmZvcm1hbmNlIGdhaW4gZnJvbSB0aGlzIG1ldGhvZCBpcyBwb3NzaWJsZSAod2hpbGUgaXQgaXMgbm90IHN0cmljdGx5IHJlcXVpcmVkKSBpZiBwcmltaXRpdmVzXHJcbiAqIGFyZSBzb3J0ZWQgYnkgbWVtb3J5IG9mZnNldCBhbmQgdGhlcmUgYXJlIG5vIG1hbnkgXCJob2xlc1wiIGJldHdlZW4gdGhlbS5cclxuICogTWluaW1hbCByZXF1aXJlbWV0cyBmb3IgYmF0Y2hpbmcgaXMgbG9jYXRpb24gaW4gdGhlIHNhbWUgYnVmZmVyIChtZW1vcnkgcGFnZSksIGFkZGl0aW9uYWxcclxuICogcmVxdWlyZW1lbnRzIChzdWNoIGFzIGhhdmluZyBzaGFyZWQgdGV4dHVyZSBvciBzaW1pbGFyKSBjYW4gYmUgaW1wb3NlZCBpbiBjYW5CYXRjaFByaWRpY2F0ZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBiYXRjaFByaW1pdGl2ZXMocHJpbWl0aXZlcywgY2FuQmF0Y2hQcmlkaWNhdGUpIHtcclxuICAgIGNvbnN0IGNhbkJhdGNoID0gKGEsIGIpID0+IHtcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgLy8gbWluaW1hbCByZXF1aXJlbWVudHMgZm9yIGJhdGNoaW5nIGlzIHRoYXQgcHJpbWl0aXZlcyBsYXkgaW4gdGhlIHNhbWUgcGFnZVxyXG4gICAgICAgIChhLm1lbW9yeVN1YkNodW5rLm1lbW9yeUNodW5rLnBhZ2UgIT09IGIubWVtb3J5U3ViQ2h1bmsubWVtb3J5Q2h1bmsucGFnZSkgfHxcclxuICAgICAgICAgICAgLy8gY2hhY2sgZXh0ZXJuYWwgcmVxdWlyZW1lbnRzIGlmIHNwZWNpZmllZFxyXG4gICAgICAgICAgICAoY2FuQmF0Y2hQcmlkaWNhdGUgJiYgIWNhbkJhdGNoUHJpZGljYXRlKGEsIGIpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGJhdGNoQWxsb2NhdGVkT2JqZWN0cyhwcmltaXRpdmVzLCAocHJpbWl0aXZlKSA9PiBwcmltaXRpdmUubWVtb3J5U3ViQ2h1bmssIGluaXRCYXRjaCwgY2FuQmF0Y2gpO1xyXG59XHJcbiIsIi8qKlxyXG4gKiBBcHBlbmRzIHBvcnRpb24gb2YgbWVtb3J5IHRvIGJhdGNoIGlmIHRoZXkgYXJlIGFkamFjZW50LlxyXG4gKlxyXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgYm90aCBwYXJhbXMgYXJlIGFkamFjZW50IGFuZCB0aGUgYmF0Y2ggd2FzIHN1Y2Nlc3NmdWxseSB1cGRhdGVkLCBgZmFsc2VgIG90aGVyd2lzZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRUb0JhdGNoKG1lbW9yeUxvY2F0aW9uLCBiYXRjaCkge1xyXG4gICAgaWYgKGJhdGNoLnZlcnRleEJ5dGVPZmZzZXQgKyBiYXRjaC52ZXJ0ZXhCeXRlTGVuZ3RoID09PSBtZW1vcnlMb2NhdGlvbi52ZXJ0ZXhCeXRlT2Zmc2V0ICYmXHJcbiAgICAgICAgYmF0Y2guaW5kZXhCeXRlT2Zmc2V0ICsgYmF0Y2guaW5kZXhCeXRlTGVuZ3RoID09PSBtZW1vcnlMb2NhdGlvbi5pbmRleEJ5dGVPZmZzZXQpIHtcclxuICAgICAgICBiYXRjaC52ZXJ0ZXhCeXRlTGVuZ3RoICs9IG1lbW9yeUxvY2F0aW9uLnZlcnRleEJ5dGVMZW5ndGg7XHJcbiAgICAgICAgYmF0Y2guaW5kZXhCeXRlTGVuZ3RoICs9IG1lbW9yeUxvY2F0aW9uLmluZGV4Qnl0ZUxlbmd0aDtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG4vKipcclxuICogQ29tYmluZXMgb2JqZWN0cyBhbGxvY2F0ZWQgaW4gbWVtb3J5IGludG8gYmF0Y2hlcy4gTm8gc29ydGluZyBpcyBkb25lIGluIHRoaXMgbWV0aG9kLCB0aGUgb2JqZWN0cyBhcmUgc3VwcG9zZWRcclxuICogdG8gYmUgc29ydGVkIGJ5IGluZGV4L3ZlcnRleCBvZmZzZXRzIHRvIG1ha2UgYmF0Y2hpbmcgZWZmZWN0aXZlLiBUaGUgYmF0Y2ggaXMgY3JlYXRlZCBieSBmYWN0b3J5IHNpbmNlIGl0IGNhblxyXG4gKiBjb250YWlucyBwcm9ibGVtIHNwZWNpZmljIGluZm9ybWF0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0gb2JqZWN0cyBMaXN0IG9mIGFsbG9jYXRlZCBvYmplY3RzLlxyXG4gKiBAcGFyYW0gZ2V0TWVtb3J5TG9jYXRpb24gUmV0dXJucyBtZW1vcnkgbG9jYXRpb24gb2Ygc3BlY2lmaWMgb2JqZWN0LlxyXG4gKiBAcGFyYW0gY3JlYXRlQmF0Y2ggSW5pdGlhdGVzIGJhdGNoIGJ5IHRoZSBmaXJzdCBvYmplY3QuXHJcbiAqIEBwYXJhbSBjYW5CYXRjaCBDaGVja3MgaWYgdHdvIG9iamVjdHMgY2FuIGJlIGFsbG9jYXRlZC5cclxuICogQHJldHVybnMgSXRlcmFibGUgbGlzdCBvZiBiYXRjaGVzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uKiBiYXRjaEFsbG9jYXRlZE9iamVjdHMob2JqZWN0cywgZ2V0TWVtb3J5TG9jYXRpb24sIGNyZWF0ZUJhdGNoLCBjYW5CYXRjaCA9ICgpID0+IHRydWUpIHtcclxuICAgIGNvbnN0IGl0ZXJhdG9yID0gb2JqZWN0c1tTeW1ib2wuaXRlcmF0b3JdKCk7XHJcbiAgICBsZXQgcHJpbWl0aXZlID0gaXRlcmF0b3IubmV4dCgpLnZhbHVlO1xyXG4gICAgaWYgKCFwcmltaXRpdmUpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBsZXQgcHJldiA9IHByaW1pdGl2ZTtcclxuICAgIGxldCBiYXRjaCA9IGNyZWF0ZUJhdGNoKHByZXYpO1xyXG4gICAgcHJpbWl0aXZlID0gaXRlcmF0b3IubmV4dCgpLnZhbHVlO1xyXG4gICAgd2hpbGUgKHByaW1pdGl2ZSkge1xyXG4gICAgICAgIGNvbnN0IHByaW1pdGl2ZU1lbW9yeUxvY2F0aW9uID0gZ2V0TWVtb3J5TG9jYXRpb24ocHJpbWl0aXZlKTtcclxuICAgICAgICBpZiAoIWNhbkJhdGNoKHByZXYsIHByaW1pdGl2ZSwgYmF0Y2gpIHx8ICFhcHBlbmRUb0JhdGNoKHByaW1pdGl2ZU1lbW9yeUxvY2F0aW9uLCBiYXRjaCkpIHtcclxuICAgICAgICAgICAgeWllbGQgYmF0Y2g7XHJcbiAgICAgICAgICAgIGJhdGNoID0gY3JlYXRlQmF0Y2gocHJpbWl0aXZlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHJldiA9IHByaW1pdGl2ZTtcclxuICAgICAgICBwcmltaXRpdmUgPSBpdGVyYXRvci5uZXh0KCkudmFsdWU7XHJcbiAgICB9XHJcbiAgICB5aWVsZCBiYXRjaDtcclxufVxyXG4iLCJpbXBvcnQgcG9pbnRMYWJlbFZlcnRleFNoYWRlciBmcm9tICcuL3NoYWRlci9wb2ludF9sYWJlbC52ZXJ0JztcclxuaW1wb3J0IGRmVGV4dEZyYWdtZW50U2hhZGVyIGZyb20gJy4vc2hhZGVyL2RmX3RleHQuZnJhZyc7XHJcbmltcG9ydCBMYWJlbFJlbmRlclVuaXQgZnJvbSAnLi9sYWJlbF9yZW5kZXJfdW5pdCc7XHJcbmltcG9ydCBCaWxsYm9hcmRSZWN0YW5nbGVSZW5kZXJVbml0IGZyb20gJy4uL2JpbGxib2FyZF9yZWN0YW5nbGUvYmlsbGJvYXJkX3JlY3RhbmdsZV9yZW5kZXJfdW5pdCc7XHJcbmltcG9ydCB7IFZvaWRFdmVudEVtaXR0ZXIgfSBmcm9tICcuLi8uLi8uLi91dGlsL2V2ZW50X2VtaXR0ZXInO1xyXG5pbXBvcnQgeyBtYXBJdGVyYWJsZSwgZmlsdGVySXRlcmFibGUgfSBmcm9tICcuLi8uLi8uLi91dGlsL2l0ZXJhYmxlJztcclxuZXhwb3J0IGNvbnN0IFBST0dSQU1fT1BUSU9OUyA9IHtcclxuICAgIGF0dHJpYk1hcDoge1xyXG4gICAgICAgIHZlcnRleElkOiAyIC8qIElEICovLFxyXG4gICAgICAgIHZlcnRleFBvc0hpZ2g6IDAgLyogUE9TSVRJT05fSElHSCAqLyxcclxuICAgICAgICB2ZXJ0ZXhQb3NMb3c6IDEgLyogUE9TSVRJT05fTE9XICovLFxyXG4gICAgICAgIHZlcnRleERpc3BsYWNlbWVudDogNiAvKiBESVNQTEFDRU1FTlQgKi8sXHJcbiAgICAgICAgdmVydGV4VVY6IDQgLyogVVYgKi8sXHJcbiAgICAgICAgdmVydGV4UHJpb3JpdHk6IDkgLyogUFJJT1JJVFkgKi8sXHJcbiAgICAgICAgdmVydGV4Q29sb3I6IDcgLyogQ09MT1IgKi8sXHJcbiAgICAgICAgdmVydGV4T3V0bGluZUNvbG9yOiA4IC8qIE9VVExJTkVfQ09MT1IgKi8sXHJcbiAgICAgICAgdmVydGV4U2NhbGU6IDExIC8qIEFVWCAqL1xyXG4gICAgfVxyXG59O1xyXG4vKipcclxuICogUmVuZGVycyBiYWNrZ3JvdW5kcyBleHRyYWN0ZWQgZnJvbSBwb2ludCBsYWJlbHMuXHJcbiAqL1xyXG5jbGFzcyBCYWNrZ3JvdW5kUHJpbWl0aXZlUHJvdmlkZXIge1xyXG4gICAgY29uc3RydWN0b3IobGFiZWxzUHJvdmlkZXIpIHtcclxuICAgICAgICB0aGlzLm9uVXBkYXRlID0gbmV3IFZvaWRFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLl9sYWJlbHNQcm92aWRlciA9IGxhYmVsc1Byb3ZpZGVyO1xyXG4gICAgfVxyXG4gICAgZ2V0IHByaW1pdGl2ZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIG1hcEl0ZXJhYmxlKGZpbHRlckl0ZXJhYmxlKHRoaXMuX2xhYmVsc1Byb3ZpZGVyLnByaW1pdGl2ZXMsIChsYWJlbCkgPT4gbGFiZWwuYmFja2dyb3VuZCAhPT0gdW5kZWZpbmVkKSwgKGxhYmVsKSA9PiBsYWJlbC5iYWNrZ3JvdW5kKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUG9pbnQgbGFiZWxzIHJlbmRlcmVyLiBJdCB1c2VzIGFwcHJvcHJpYXRlIHByb2dyYW0gdG8gbGF5b3V0IGdseXBocyBvbiBHUFUuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb2ludExhYmVsUmVuZGVyVW5pdCBleHRlbmRzIExhYmVsUmVuZGVyVW5pdCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBjYW1lcmEsIHZpc2liaWxpdHlQcm92aWRlciwgcHJpbWl0aXZlUHJvdmlkZXIpIHtcclxuICAgICAgICBjb25zdCBwcm9ncmFtID0gY29udGV4dC5jcmVhdGVQcm9ncmFtKHBvaW50TGFiZWxWZXJ0ZXhTaGFkZXIsIGRmVGV4dEZyYWdtZW50U2hhZGVyLCBQUk9HUkFNX09QVElPTlMpO1xyXG4gICAgICAgIHN1cGVyKGNvbnRleHQsIHByb2dyYW0sIGNhbWVyYSwgdmlzaWJpbGl0eVByb3ZpZGVyLCBwcmltaXRpdmVQcm92aWRlcik7XHJcbiAgICAgICAgdGhpcy5fYmFja2dyb3VuZFJlbmRlcmVyID0gbmV3IEJpbGxib2FyZFJlY3RhbmdsZVJlbmRlclVuaXQoY29udGV4dCwgY2FtZXJhLCB2aXNpYmlsaXR5UHJvdmlkZXIsIG5ldyBCYWNrZ3JvdW5kUHJpbWl0aXZlUHJvdmlkZXIocHJpbWl0aXZlUHJvdmlkZXIpKTtcclxuICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kUmVuZGVyZXIub25VcGRhdGUuYWRkTGlzdGVuZXIoKCkgPT4gdGhpcy5vblVwZGF0ZS5maXJlKCkpO1xyXG4gICAgfVxyXG4gICAgcmVuZGVyKHRhcmdldCwgdmlld1Byb2pNYXRyaXgsIGNhbWVyYVBvc2l0aW9ucykge1xyXG4gICAgICAgIHRoaXMuX2JhY2tncm91bmRSZW5kZXJlci5yZW5kZXIodGFyZ2V0LCB2aWV3UHJvak1hdHJpeCwgY2FtZXJhUG9zaXRpb25zKTtcclxuICAgICAgICBzdXBlci5yZW5kZXIodGFyZ2V0LCB2aWV3UHJvak1hdHJpeCwgY2FtZXJhUG9zaXRpb25zKTtcclxuICAgIH1cclxufVxyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiI3ZlcnNpb24gMTAwXFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhJZDtcXG5cXG4vLyBwb2ludCBpbiB0aGUgd29ybGQgdGhlIGxhYmVsIGlzIGFuY2hvcmVkIHRvXFxuYXR0cmlidXRlIHZlYzIgdmVydGV4UG9zSGlnaDtcXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhQb3NMb3c7XFxuXFxuLy8gdmVjdG9yIG9mIGNvbmNyZXRlIGdseXBoIHBvaW50IGRpc3BsYWNlbWVudCAodG9wLWxlZnQsIGJvdHRvbS1sZWZ0LCAuLi4pIHJlbGF0aXZlIHRvIGxhYmVsJ3MgY2VudGVyLCBpbiBweFxcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleERpc3BsYWNlbWVudDtcXG5cXG4vLyBjb29yZGluYXRlcyBvZiB0aGUgZ2x5cGggdmVydGV4IGluIHRoZSBhdGxhc1xcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleFVWO1xcblxcbmF0dHJpYnV0ZSBmbG9hdCB2ZXJ0ZXhQcmlvcml0eTtcXG5cXG5hdHRyaWJ1dGUgbG93cCB2ZWM0IHZlcnRleENvbG9yO1xcbmF0dHJpYnV0ZSBsb3dwIHZlYzQgdmVydGV4T3V0bGluZUNvbG9yO1xcbmF0dHJpYnV0ZSBmbG9hdCB2ZXJ0ZXhTY2FsZTtcXG5cXG51bmlmb3JtIHZlYzIgbG9va0F0SGlnaDtcXG51bmlmb3JtIHZlYzIgbG9va0F0TG93O1xcbnVuaWZvcm0gbWF0NCB2aWV3UHJvak1hdHJpeDtcXG51bmlmb3JtIHZlYzIgcGl4ZWxTaXplO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHZpc2liaWxpdHk7XFxudW5pZm9ybSB2ZWMyIGlkSGFsZlB4U2l6ZTtcXG51bmlmb3JtIHZlYzIgc2hpZnQ7XFxudW5pZm9ybSBsb3dwIGZsb2F0IGN1cnJlbnRab29tO1xcblxcbnZhcnlpbmcgdmVjMiB1djtcXG52YXJ5aW5nIGxvd3AgdmVjNCBjb2xvcjtcXG52YXJ5aW5nIGxvd3AgdmVjNCBvdXRsaW5lQ29sb3I7XFxudmFyeWluZyBtZWRpdW1wIGZsb2F0IHNjYWxlO1xcblxcbmNvbnN0IHZlYzQgRElTQ0FSRF9QT1NJVElPTiA9IHZlYzQoMiwgMiwgMiwgMSk7XFxuXFxuY29uc3QgZmxvYXQgWVZfSF8xXzAgPSAxLjk5OTk2OTQ4MjQyMTg3NTtcXG5jb25zdCBmbG9hdCBZVl9MXzFfMSA9IDAuMDAwMDMwNTE3MTEyNDYzNzEyNjkyO1xcblxcbi8qKlxcbiAqIFByb2plY3RzIHNwZWNpZmljIHBvaW50IGxhYmVsIHZlcnRleCBvbnRvIHRoZSBzY3JlZW4uXFxuICovXFxudmVjNCBwcm9qZWN0UG9pbnRMYWJlbFZlcnRleF8xXzIoXFxuICAgIG1hdDQgdmlld1Byb2pNYXRyaXgsXFxuICAgIHZlYzIgbG9va0F0SGlnaCxcXG4gICAgdmVjMiBsb29rQXRMb3csXFxuICAgIHZlYzIgcG9zSGlnaCxcXG4gICAgdmVjMiBwb3NMb3csXFxuICAgIHZlYzIgZGlzcGxhY2VtZW50LFxcbiAgICB2ZWMyIHB4U2l6ZVxcbikge1xcbiAgICB2ZWM0IHBvc2l0aW9uID0gdmlld1Byb2pNYXRyaXggKiB2ZWM0KFxcbiAgICAgICAgWVZfSF8xXzAgKiAocG9zSGlnaCAtIGxvb2tBdEhpZ2gpICtcXG4gICAgICAgICAgICBZVl9MXzFfMSAqIChwb3NMb3cgLSBsb29rQXRMb3cpLFxcbiAgICAgICAgMCxcXG4gICAgICAgIDFcXG4gICAgKTtcXG4gICAgcG9zaXRpb24gPSB2ZWM0KHBvc2l0aW9uLnh5IC8gcG9zaXRpb24udywgMC4wLCAxLjApO1xcblxcbiAgICByZXR1cm4gcG9zaXRpb24gKyB2ZWM0KGRpc3BsYWNlbWVudCAqIHB4U2l6ZSwgMC4wLCAwLjApO1xcbn1cXG5cXG5cXG5cXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgICBmbG9hdCB2aXNpYmlsaXR5QWxwaGEgPSB0ZXh0dXJlMkQodmlzaWJpbGl0eSwgdmVydGV4SWQueHkgKyBpZEhhbGZQeFNpemUpLmE7XFxuICAgIGlmICh2aXNpYmlsaXR5QWxwaGEgIT0gMC4wKSB7XFxuICAgICAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3RQb2ludExhYmVsVmVydGV4XzFfMihcXG4gICAgICAgICAgICB2aWV3UHJvak1hdHJpeCxcXG4gICAgICAgICAgICBsb29rQXRIaWdoLFxcbiAgICAgICAgICAgIGxvb2tBdExvdyxcXG4gICAgICAgICAgICB2ZXJ0ZXhQb3NIaWdoLFxcbiAgICAgICAgICAgIHZlcnRleFBvc0xvdyxcXG4gICAgICAgICAgICB2ZXJ0ZXhEaXNwbGFjZW1lbnQsXFxuICAgICAgICAgICAgcGl4ZWxTaXplXFxuICAgICAgICApO1xcblxcbiAgICAgICAgdXYgPSB2ZXJ0ZXhVVjtcXG4gICAgICAgIGNvbG9yID0gdmVydGV4Q29sb3I7XFxuICAgICAgICBvdXRsaW5lQ29sb3IgPSB2ZXJ0ZXhPdXRsaW5lQ29sb3I7XFxuICAgICAgICBzY2FsZSA9IHZlcnRleFNjYWxlO1xcblxcbiAgICAgICAgY29sb3IuYSAqPSB2aXNpYmlsaXR5QWxwaGE7XFxuICAgICAgICBvdXRsaW5lQ29sb3IuYSAqPSB2aXNpYmlsaXR5QWxwaGE7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICBnbF9Qb3NpdGlvbiA9IERJU0NBUkRfUE9TSVRJT047XFxuICAgIH1cXG59XFxuXCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiI3ZlcnNpb24gMTAwXFxuXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG51bmlmb3JtIGZsb2F0IGRwcjtcXG51bmlmb3JtIHNhbXBsZXIyRCBhdGxhcztcXG51bmlmb3JtIHZlYzIgYXRsYXNTaXplO1xcblxcbnZhcnlpbmcgdmVjMiB1djtcXG52YXJ5aW5nIGxvd3AgdmVjNCBjb2xvcjtcXG52YXJ5aW5nIGxvd3AgdmVjNCBvdXRsaW5lQ29sb3I7XFxudmFyeWluZyBmbG9hdCBzY2FsZTtcXG5cXG5jb25zdCBmbG9hdCBNQVhfQ09SUkVDVEVEX0dMWVBIX1NDQUxFID0gMC41O1xcbmNvbnN0IGZsb2F0IEdMWVBIX0JBU0VfV0VJR0hUID0gMC43O1xcbmNvbnN0IGZsb2F0IEdMWVBIX0JBU0VfU01PVEhORVNTID0gMC4xO1xcbmNvbnN0IGZsb2F0IEdMWVBIX1dFSUdIVF9TQ0FMRV9JTVBBQ1QgPSAwLjE7XFxuY29uc3QgZmxvYXQgR0xZUEhfU01PT1RITkVTU19TQ0FMRV9JTVBBQ1QgPSAwLjA2O1xcbmNvbnN0IGZsb2F0IE9VVExJTkVfV0VJR0hUX1NDQUxFX0lNUEFDVCA9IDAuMTI1O1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIC8vIGxvdyBzY2FsZSBnbHlwaHMgKGxlc3MgdGhhbiAwLjUpIHNob3VsZCBiZSBhIGxpdHRsZSBiaXQgYm9sZGVyIGFuZCBzbW9vdGhlclxcbiAgICBmbG9hdCBzY2FsZUNsYW1wZWQgPSBjbGFtcChzY2FsZSwgMC4wLCBNQVhfQ09SUkVDVEVEX0dMWVBIX1NDQUxFKTtcXG4gICAgLy8gd2VpZ2h0IGlzIHJlc3BvbnNpYmxlIGZvciBnbHlwaCBib2xkbmVzcywgdGhlIGxlc3Mgd2VpZ2h0IHZhbHVlIHRoZSBib2xkZXIgdGhlIHRleHRcXG4gICAgZmxvYXQgd2VpZ2h0ID0gR0xZUEhfQkFTRV9XRUlHSFQgKyBHTFlQSF9XRUlHSFRfU0NBTEVfSU1QQUNUICogc2NhbGVDbGFtcGVkO1xcbiAgICAvLyBzbW9vdGhuZXNzIGlzIGhvdyBibHVycmVkIGdseXBocyBhcmUsIHRoZSBsZXNzIHNtb290aG5lc3MgdmFsdWUgdGhlIGxlc3MgYmx1cnJpbmdcXG4gICAgZmxvYXQgc21vb3RobmVzcyA9IChHTFlQSF9CQVNFX1NNT1RITkVTUyArIEdMWVBIX1NNT09USE5FU1NfU0NBTEVfSU1QQUNUIC8gc2NhbGVDbGFtcGVkKSAvIGRwcjtcXG5cXG4gICAgdmVjNCByZXN1bHRDb2xvciA9IGNvbG9yO1xcbiAgICBmbG9hdCBkaXN0ID0gdGV4dHVyZTJEKGF0bGFzLCB1diAvIGF0bGFzU2l6ZSkuYTtcXG4gICAgZmxvYXQgYWxwaGEgPSBzbW9vdGhzdGVwKHdlaWdodCAtIHNtb290aG5lc3MsIHdlaWdodCArIHNtb290aG5lc3MsIGRpc3QpO1xcblxcbiAgICBpZiAob3V0bGluZUNvbG9yLmEgIT0gMC4wKSB7XFxuICAgICAgICAvLyB0byByZW5kZXIgb3V0bGluZSB0aGUgZ2x5cGggaXMgcmVuZGVyZWQgYSBsaXR0bGUgYml0IGJvbGRlciB3aXRoIGRpZmZlcmVudCBjb2xvciBhdCBlZGdlc1xcbiAgICAgICAgd2VpZ2h0ID0gd2VpZ2h0IC0gT1VUTElORV9XRUlHSFRfU0NBTEVfSU1QQUNUIC8gc2NhbGU7XFxuICAgICAgICByZXN1bHRDb2xvciA9IG1peChvdXRsaW5lQ29sb3IsIGNvbG9yLCBhbHBoYSk7XFxuICAgICAgICBhbHBoYSA9IHNtb290aHN0ZXAod2VpZ2h0IC0gc21vb3RobmVzcywgd2VpZ2h0ICsgc21vb3RobmVzcywgZGlzdCk7XFxuICAgIH1cXG5cXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChyZXN1bHRDb2xvci5yZ2IsIHJlc3VsdENvbG9yLmEgKiBhbHBoYSk7XFxufVxcblwiIiwiaW1wb3J0IFdvcmxkUHJpbWl0aXZlUmVuZGVyVW5pdCBmcm9tICcuLi93b3JsZF9wcmltaXRpdmVfcmVuZGVyX3VuaXQnO1xyXG5pbXBvcnQgKiBhcyB2ZWMyIGZyb20gJy4uLy4uLy4uL21hdGgvdmVjdG9yMic7XHJcbmltcG9ydCBSZW5kZXJTdGF0ZSwgeyBCTEVORF9PVkVSX1JFTkRFUl9TVEFURSB9IGZyb20gJy4uLy4uLy4uL3JlbmRlci9zdGF0ZSc7XHJcbi8qKlxyXG4gKiBCYXNlIHJlbmRlcmVyIHRoYXQgaW5jYXBzdWxhdGVzIGFsbCB0aGUgR0wgc3BlY2lmaWNzIHRvIG1ha2UgbGFiZWxzIHJlbmRlcmVkLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGFiZWxSZW5kZXJVbml0IGV4dGVuZHMgV29ybGRQcmltaXRpdmVSZW5kZXJVbml0IHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIHByb2dyYW0sIGNhbWVyYSwgdmlzaWJpbGl0eVByb3ZpZGVyLCBwcmltaXRpdmVQcm92aWRlcikge1xyXG4gICAgICAgIHN1cGVyKGNvbnRleHQsIG5ldyBSZW5kZXJTdGF0ZShCTEVORF9PVkVSX1JFTkRFUl9TVEFURSksIHByb2dyYW0sIHByaW1pdGl2ZVByb3ZpZGVyKTtcclxuICAgICAgICB0aGlzLl9jYW1lcmEgPSBjYW1lcmE7XHJcbiAgICAgICAgdGhpcy5fdmlzaWJpbGl0eVByb3ZpZGVyID0gdmlzaWJpbGl0eVByb3ZpZGVyO1xyXG4gICAgICAgIHRoaXMuX2lkSGFsZlB4U2l6ZVVuaWZvcm0gPSB2ZWMyLmNyZWF0ZSgwLCAwKTtcclxuICAgICAgICB0aGlzLl9hdGxhc1NpemVVbmlmb3JtID0gdmVjMi5jcmVhdGUoMCwgMCk7XHJcbiAgICAgICAgY29udGV4dC5iaW5kUHJvZ3JhbShwcm9ncmFtKTtcclxuICAgICAgICBwcm9ncmFtLnNldEludFNjYWxhclVuaWZvcm0oJ3Zpc2liaWxpdHknLCAwKTtcclxuICAgIH1cclxuICAgIF9wcmVwYXJlUHJvZ3JhbShwcm9ncmFtLCB2aWV3UHJvak1hdHJpeCwgY2FtZXJhUG9zaXRpb25zKSB7XHJcbiAgICAgICAgY29uc3QgdmlzaWJpbGl0eSA9IHRoaXMuX3Zpc2liaWxpdHlQcm92aWRlcigpO1xyXG4gICAgICAgIHN1cGVyLl9wcmVwYXJlUHJvZ3JhbShwcm9ncmFtLCB2aWV3UHJvak1hdHJpeCwgY2FtZXJhUG9zaXRpb25zKTtcclxuICAgICAgICB0aGlzLl9pZEhhbGZQeFNpemVVbmlmb3JtLnggPSAwLjUgLyB2aXNpYmlsaXR5LmdldFdpZHRoKCk7XHJcbiAgICAgICAgdGhpcy5faWRIYWxmUHhTaXplVW5pZm9ybS55ID0gMC41IC8gdmlzaWJpbGl0eS5nZXRIZWlnaHQoKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRUZXh0dXJlVW5pdCgwKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRUZXh0dXJlKHZpc2liaWxpdHkpO1xyXG4gICAgICAgIHByb2dyYW0uc2V0VmVjdG9yMlVuaWZvcm0oJ2lkSGFsZlB4U2l6ZScsIHRoaXMuX2lkSGFsZlB4U2l6ZVVuaWZvcm0pO1xyXG4gICAgICAgIHByb2dyYW0uc2V0VmVjdG9yMlVuaWZvcm0oJ3BpeGVsU2l6ZScsIHRoaXMuX2NhbWVyYS5waXhlbFNpemUpO1xyXG4gICAgICAgIHByb2dyYW0uc2V0U2NhbGFyVW5pZm9ybSgnZHByJywgd2luZG93LmRldmljZVBpeGVsUmF0aW8pO1xyXG4gICAgfVxyXG4gICAgX3JlbmRlckJhdGNoKG1lbW9yeUJhdGNoKSB7XHJcbiAgICAgICAgY29uc3QgYXRsYXMgPSBtZW1vcnlCYXRjaC5maXJzdFByaW1pdGl2ZS5hdGxhcztcclxuICAgICAgICB0aGlzLl9hdGxhc1NpemVVbmlmb3JtLnggPSBhdGxhcy53aWR0aDtcclxuICAgICAgICB0aGlzLl9hdGxhc1NpemVVbmlmb3JtLnkgPSBhdGxhcy5oZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5fcHJvZ3JhbS5zZXRJbnRTY2FsYXJVbmlmb3JtKCdhdGxhcycsIDEpO1xyXG4gICAgICAgIHRoaXMuX3Byb2dyYW0uc2V0VmVjdG9yMlVuaWZvcm0oJ2F0bGFzU2l6ZScsIHRoaXMuX2F0bGFzU2l6ZVVuaWZvcm0pO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFRleHR1cmVVbml0KDEpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFRleHR1cmUoYXRsYXMudGV4dHVyZSk7XHJcbiAgICAgICAgc3VwZXIuX3JlbmRlckJhdGNoKG1lbW9yeUJhdGNoKTtcclxuICAgIH1cclxuICAgIF9jYW5CYXRjaEFkamFjZW50UHJpbWl0aXZlcyhhLCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIHN1cGVyLl9jYW5CYXRjaEFkamFjZW50UHJpbWl0aXZlcyhhLCBiKSAmJiAoYS5hdGxhcyA9PT0gYi5hdGxhcyk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHJlY3RhbmdsZVZlcnRleFNoYWRlciBmcm9tICcuL3NoYWRlci9iaWxsYm9hcmRfcmVjdGFuZ2xlLnZlcnQnO1xyXG5pbXBvcnQgcmVjdGFuZ2xlRnJhZ21lbnRTaGFkZXIgZnJvbSAnLi9zaGFkZXIvYmlsbGJvYXJkX3JlY3RhbmdsZS5mcmFnJztcclxuaW1wb3J0ICogYXMgdmVjMiBmcm9tICcuLi8uLi8uLi9tYXRoL3ZlY3RvcjInO1xyXG5pbXBvcnQgV29ybGRQcmltaXRpdmVSZW5kZXJVbml0IGZyb20gJy4uL3dvcmxkX3ByaW1pdGl2ZV9yZW5kZXJfdW5pdCc7XHJcbmltcG9ydCBSZW5kZXJTdGF0ZSBmcm9tICcuLi8uLi8uLi9yZW5kZXIvc3RhdGUnO1xyXG5pbXBvcnQgeyBCTEVORF9PVkVSX1JFTkRFUl9TVEFURSB9IGZyb20gJy4uLy4uLy4uL3JlbmRlci9zdGF0ZSc7XHJcbmNvbnN0IFJFTkRFUl9TVEFURSA9IG5ldyBSZW5kZXJTdGF0ZShCTEVORF9PVkVSX1JFTkRFUl9TVEFURSk7XHJcbi8qKlxyXG4gKiBSZW5kZXJlciBvZiBiaWxsYm9hcmQgcmVjdGFuZ2xlcy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJpbGxib2FyZFJlY3RhbmdsZVJlbmRlclVuaXQgZXh0ZW5kcyBXb3JsZFByaW1pdGl2ZVJlbmRlclVuaXQge1xyXG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgY2FtZXJhLCB2aXNpYmlsaXR5UHJvdmlkZXIsIHByaW1pdGl2ZVByb3ZpZGVyKSB7XHJcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IGNvbnRleHQuY3JlYXRlUHJvZ3JhbShyZWN0YW5nbGVWZXJ0ZXhTaGFkZXIsIHJlY3RhbmdsZUZyYWdtZW50U2hhZGVyLCB7XHJcbiAgICAgICAgICAgIGF0dHJpYk1hcDoge1xyXG4gICAgICAgICAgICAgICAgdmVydGV4SWQ6IDIgLyogSUQgKi8sXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhQb3NIaWdoOiAwIC8qIFBPU0lUSU9OX0hJR0ggKi8sXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhQb3NMb3c6IDEgLyogUE9TSVRJT05fTE9XICovLFxyXG4gICAgICAgICAgICAgICAgdmVydGV4RGlzcGxhY2VtZW50OiA2IC8qIERJU1BMQUNFTUVOVCAqLyxcclxuICAgICAgICAgICAgICAgIHZlcnRleFVWOiA0IC8qIFVWICovLFxyXG4gICAgICAgICAgICAgICAgdmVydGV4Q29sb3I6IDcgLyogQ09MT1IgKi8sXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhCb3JkZXJSYWRpaTogMTEgLyogQVVYICovXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBzdXBlcihjb250ZXh0LCBSRU5ERVJfU1RBVEUsIHByb2dyYW0sIHByaW1pdGl2ZVByb3ZpZGVyKTtcclxuICAgICAgICB0aGlzLl92aXNpYmlsaXR5UHJvdmlkZXIgPSB2aXNpYmlsaXR5UHJvdmlkZXI7XHJcbiAgICAgICAgdGhpcy5fY2FtZXJhID0gY2FtZXJhO1xyXG4gICAgICAgIHRoaXMuX3Zpc2liaWxpdHlTaXplVW5pZm9ybSA9IHZlYzIuY3JlYXRlKDAsIDApO1xyXG4gICAgICAgIGNvbnRleHQuYmluZFByb2dyYW0ocHJvZ3JhbSk7XHJcbiAgICAgICAgcHJvZ3JhbS5zZXRJbnRTY2FsYXJVbmlmb3JtKCd2aXNpYmlsaXR5JywgMCk7XHJcbiAgICB9XHJcbiAgICBfcHJlcGFyZVByb2dyYW0ocHJvZ3JhbSwgdmlld1Byb2pNYXRyaXgsIGNhbWVyYVBvc2l0aW9ucykge1xyXG4gICAgICAgIHN1cGVyLl9wcmVwYXJlUHJvZ3JhbShwcm9ncmFtLCB2aWV3UHJvak1hdHJpeCwgY2FtZXJhUG9zaXRpb25zKTtcclxuICAgICAgICBjb25zdCB2aXNpYmlsaXR5ID0gdGhpcy5fdmlzaWJpbGl0eVByb3ZpZGVyKCk7XHJcbiAgICAgICAgdGhpcy5fdmlzaWJpbGl0eVNpemVVbmlmb3JtLnggPSB2aXNpYmlsaXR5LmdldFdpZHRoKCk7XHJcbiAgICAgICAgdGhpcy5fdmlzaWJpbGl0eVNpemVVbmlmb3JtLnkgPSB2aXNpYmlsaXR5LmdldEhlaWdodCgpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFRleHR1cmVVbml0KDApO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFRleHR1cmUodmlzaWJpbGl0eSk7XHJcbiAgICAgICAgcHJvZ3JhbS5zZXRWZWN0b3IyVW5pZm9ybSgndmlzaWJpbGl0eVNpemUnLCB0aGlzLl92aXNpYmlsaXR5U2l6ZVVuaWZvcm0pO1xyXG4gICAgICAgIHByb2dyYW0uc2V0VmVjdG9yMlVuaWZvcm0oJ3BpeGVsU2l6ZScsIHRoaXMuX2NhbWVyYS5waXhlbFNpemUpO1xyXG4gICAgfVxyXG59XHJcbiIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleElkO1xcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleFBvc0hpZ2g7XFxuYXR0cmlidXRlIHZlYzIgdmVydGV4UG9zTG93O1xcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleERpc3BsYWNlbWVudDtcXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhVVjtcXG5hdHRyaWJ1dGUgdmVjNCB2ZXJ0ZXhDb2xvcjtcXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhCb3JkZXJSYWRpaTtcXG5cXG51bmlmb3JtIHZlYzIgbG9va0F0SGlnaDtcXG51bmlmb3JtIHZlYzIgbG9va0F0TG93O1xcbnVuaWZvcm0gbWF0NCB2aWV3UHJvak1hdHJpeDtcXG51bmlmb3JtIHZlYzIgcGl4ZWxTaXplO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHZpc2liaWxpdHk7XFxudW5pZm9ybSB2ZWMyIHZpc2liaWxpdHlTaXplO1xcblxcbnZhcnlpbmcgdmVjMiB1djtcXG52YXJ5aW5nIHZlYzQgY29sb3I7XFxudmFyeWluZyB2ZWMyIGJvcmRlclJhZGlpO1xcblxcbmNvbnN0IHZlYzQgRElTQ0FSRF9QT1NJVElPTiA9IHZlYzQoMiwgMiwgMiwgMSk7XFxuY29uc3QgZmxvYXQgWVZfSCA9IDEuOTk5OTY5NDgyNDIxODc1O1xcbmNvbnN0IGZsb2F0IFlWX0wgPSAwLjAwMDAzMDUxNzExMjQ2MzcxMjY5MjtcXG52ZWMyIFZJU0lCSUxJVFlfSEFMRl9QWCA9IDAuNSAvIHZpc2liaWxpdHlTaXplO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIGZsb2F0IHZpc2liaWxpdHlBbHBoYSA9IHRleHR1cmUyRCh2aXNpYmlsaXR5LCB2ZXJ0ZXhJZC54eSArIFZJU0lCSUxJVFlfSEFMRl9QWCkuYTtcXG4gICAgaWYgKHZpc2liaWxpdHlBbHBoYSA9PSAwLjApIHtcXG4gICAgICAgIGdsX1Bvc2l0aW9uID0gRElTQ0FSRF9QT1NJVElPTjtcXG4gICAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICB2ZWM0IHBvc2l0aW9uID0gdmlld1Byb2pNYXRyaXggKiB2ZWM0KFxcbiAgICAgICAgWVZfSCAqICh2ZXJ0ZXhQb3NIaWdoIC0gbG9va0F0SGlnaCkgK1xcbiAgICAgICAgICAgIFlWX0wgKiAodmVydGV4UG9zTG93IC0gbG9va0F0TG93KSxcXG4gICAgICAgIDAsXFxuICAgICAgICAxXFxuICAgICk7XFxuICAgIHBvc2l0aW9uLnh5eiAvPSBwb3NpdGlvbi53O1xcbiAgICBwb3NpdGlvbi53ID0gMS4wO1xcblxcbiAgICBnbF9Qb3NpdGlvbiA9IHBvc2l0aW9uICsgdmVjNCh2ZXJ0ZXhEaXNwbGFjZW1lbnQgKiBwaXhlbFNpemUsIDAuMCwgMC4wKTtcXG5cXG4gICAgdXYgPSB2ZXJ0ZXhVVjtcXG4gICAgY29sb3IgPSB2ZXJ0ZXhDb2xvcjtcXG4gICAgY29sb3IuYSAqPSB2aXNpYmlsaXR5QWxwaGE7XFxuICAgIGJvcmRlclJhZGlpID0gdmVydGV4Qm9yZGVyUmFkaWk7XFxufVxcblwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIiN2ZXJzaW9uIDEwMFxcblxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxudmFyeWluZyB2ZWMyIHV2O1xcbnZhcnlpbmcgdmVjNCBjb2xvcjtcXG52YXJ5aW5nIHZlYzIgYm9yZGVyUmFkaWk7XFxuXFxuZmxvYXQgcm91bmRlZFJlY3RhbmdsZShjb25zdCBpbiB2ZWMyIHV2LCBjb25zdCBpbiB2ZWMyIHJhZGlpKSB7XFxuICAgIHZlYzIgYWJzVXYgPSBhYnModXYpO1xcbiAgICB2ZWMyIHEgPSBhYnNVdiArIHJhZGlpIC0gMS4wO1xcbiAgICByZXR1cm4gbWluKHEueCwgcS55KSA+IDAuMCA/IGxlbmd0aChxIC8gcmFkaWkpIDogbWF4KGFic1V2LngsIGFic1V2LnkpO1xcbn1cXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgICBnbF9GcmFnQ29sb3IgPSBzdGVwKHJvdW5kZWRSZWN0YW5nbGUodXYsIGJvcmRlclJhZGlpKSwgMS4wKSAqIGNvbG9yO1xcbn1cXG5cIiIsImltcG9ydCBjdXJ2ZWRMYWJlbFZlcnRleFNoYWRlciBmcm9tICcuL3NoYWRlci9jdXJ2ZWRfbGFiZWwudmVydCc7XHJcbmltcG9ydCBjb2xvcklkRnJhZ21lbnRTaGFkZXIgZnJvbSAnLi9zaGFkZXIvY29sb3JfaWQuZnJhZyc7XHJcbmltcG9ydCB7IFBST0dSQU1fT1BUSU9OUyB9IGZyb20gJy4uLy4uLy4uL3JlbmRlci9wcmltaXRpdmVzL2xhYmVsL2N1cnZlZF9sYWJlbF9yZW5kZXJfdW5pdCc7XHJcbmltcG9ydCBDb2xsaWRpbmdMYWJlbENvbG9ySWRSZW5kZXJlciBmcm9tICcuL2NvbG9yX2lkX2xhYmVsX3JlbmRlcmVyJztcclxuLyoqXHJcbiAqIEN1cnZlZCBsYWJlbHMgcmVuZGVyZXIgZm9yIGNvbGxpc2lvbiByZXNvbHV0aW9uLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29sb3JJZEN1cnZlZExhYmVsUmVuZGVyZXIgZXh0ZW5kcyBDb2xsaWRpbmdMYWJlbENvbG9ySWRSZW5kZXJlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBjYW1lcmEsIHByaW1pdGl2ZVByb3ZpZGVyKSB7XHJcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IGNvbnRleHQuY3JlYXRlUHJvZ3JhbShjdXJ2ZWRMYWJlbFZlcnRleFNoYWRlciwgY29sb3JJZEZyYWdtZW50U2hhZGVyLCBQUk9HUkFNX09QVElPTlMpO1xyXG4gICAgICAgIHN1cGVyKGNvbnRleHQsIHByb2dyYW0sIHByaW1pdGl2ZVByb3ZpZGVyLCBjYW1lcmEpO1xyXG4gICAgfVxyXG59XHJcbiIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleElkO1xcblxcbi8vIHBvaW50IGluIHRoZSB3b3JsZCB0aGUgbGFiZWwgaXMgYW5jaG9yZWQgdG9cXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhQb3NIaWdoO1xcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleFBvc0xvdztcXG5cXG4vLyB2ZWN0b3Igb2YgY29uY3JldGUgZ2x5cGggcG9pbnQgZGlzcGxhY2VtZW50ICh0b3AtbGVmdCwgYm90dG9tLWxlZnQsIC4uLikgcmVsYXRpdmUgdG8gZ2x5cGgncyBjZW50ZXIgKHR3byB2YWx1ZXMpLFxcbi8vIGFuZCBkaXN0YW5jZSBvZiB0aGUgZ2x5cGggY2VudGVyIHRvIGxhYmVsJ3MgY2VudGVyICh0aGlyZCB2YWx1ZSksIGluIHB4XFxuYXR0cmlidXRlIHZlYzMgdmVydGV4RGlzcGxhY2VtZW50cztcXG5cXG4vLyBjb29yZGluYXRlcyBvZiB0aGUgZ2x5cGggdmVydGV4IGluIHRoZSBhdGxhc1xcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleFVWO1xcblxcbmF0dHJpYnV0ZSBmbG9hdCB2ZXJ0ZXhQcmlvcml0eTtcXG5cXG5hdHRyaWJ1dGUgbG93cCB2ZWM0IHZlcnRleENvbG9yO1xcbmF0dHJpYnV0ZSBsb3dwIHZlYzQgdmVydGV4T3V0bGluZUNvbG9yO1xcbmF0dHJpYnV0ZSB2ZWMyIHBvbHlsaW5lTGVuZ3RoX3ZlcnRleFNjYWxlO1xcblxcbi8vIGRlbHRhcyByZWxhdGl2ZSB0byB0aGUgd29ybGQgcG9pbnQgZW5jb2RlZCBpbiB2ZXJ0ZXhQb3NIaWdoL3ZlcnRleFBvc0xvdyBlbmNvZGVkIHZpYSBsZW5ndGhzIGFuZCBhbmQgYW5nbGVzIG9mXFxuLy8gY29ycmVzcG9uZGluZyB2ZWN0b3JzXFxuYXR0cmlidXRlIHZlYzQgbGVmdFBvbHlsaW5lUmF0aW9zO1xcbmF0dHJpYnV0ZSB2ZWM0IGxlZnRQb2x5bGluZUFuZ2xlcztcXG5hdHRyaWJ1dGUgdmVjNCByaWdodFBvbHlsaW5lUmF0aW9zO1xcbmF0dHJpYnV0ZSB2ZWM0IHJpZ2h0UG9seWxpbmVBbmdsZXM7XFxuXFxudW5pZm9ybSB2ZWMyIGxvb2tBdEhpZ2g7XFxudW5pZm9ybSB2ZWMyIGxvb2tBdExvdztcXG51bmlmb3JtIG1hdDQgdmlld1Byb2pNYXRyaXg7XFxudW5pZm9ybSB2ZWMyIHBpeGVsU2l6ZTtcXG51bmlmb3JtIHNhbXBsZXIyRCB2aXNpYmlsaXR5O1xcbnVuaWZvcm0gdmVjMiBpZEhhbGZQeFNpemU7XFxudW5pZm9ybSB2ZWMyIHNoaWZ0O1xcbnVuaWZvcm0gbG93cCBmbG9hdCBjdXJyZW50Wm9vbTtcXG5cXG52YXJ5aW5nIHZlYzIgdXY7XFxudmFyeWluZyBsb3dwIHZlYzQgY29sb3I7XFxudmFyeWluZyBsb3dwIHZlYzQgb3V0bGluZUNvbG9yO1xcbnZhcnlpbmcgZmxvYXQgc2NhbGU7XFxuXFxuY29uc3QgdmVjNCBESVNDQVJEX1BPU0lUSU9OID0gdmVjNCgyLCAyLCAyLCAxKTtcXG5cXG5jb25zdCBmbG9hdCBZVl9IXzFfMCA9IDEuOTk5OTY5NDgyNDIxODc1O1xcbmNvbnN0IGZsb2F0IFlWX0xfMV8xID0gMC4wMDAwMzA1MTcxMTI0NjM3MTI2OTI7XFxuXFxuY29uc3QgZmxvYXQgUElfMV8yID0gMy4xNDE1OTI3NDEwMTI1NzMyO1xcblxcbmNvbnN0IGludCBNQVhfUE9MWUxJTkVfUE9JTlRTXzFfMyA9IDQ7XFxuY29uc3QgZmxvYXQgSU5GSU5JVFlfMV80ID0gMTAwMDAwMC4wOyAvLyBsYXJnZSBlbm91Z2ggZm9yIGEgc2VnbWVudCBsZW5ndGggdG8gY29uc2lkZXIgaXQgaW5maW5pdHlcXG5cXG4vKipcXG4gKiBSZXR1cm5zIHdvcmxkIGNvb3JkaW5hdGUgKHBsdXMgZGVsdGEpIHByb2plY3RlZCBvbiBzY3JlZW4sIGluIHBpeGVscy5cXG4gKi9cXG52ZWMyIHByb2plY3RfMV81KFxcbiAgICBtYXQ0IHZpZXdQcm9qTWF0cml4LFxcbiAgICB2ZWMyIGxvb2tBdEhpZ2gsXFxuICAgIHZlYzIgbG9va0F0TG93LFxcbiAgICB2ZWMyIHBpeGVsU2l6ZSxcXG4gICAgdmVjMiBwb2ludEhpZ2gsXFxuICAgIHZlYzIgcG9pbnRMb3csXFxuICAgIHZlYzIgZGVsdGFcXG4pIHtcXG4gICAgdmVjNCBwb3NpdGlvbiA9IHZpZXdQcm9qTWF0cml4ICogdmVjNChcXG4gICAgICAgICAgICBZVl9IXzFfMCAqIChwb2ludEhpZ2ggLSBsb29rQXRIaWdoKSArIFlWX0xfMV8xICogKHBvaW50TG93IC0gbG9va0F0TG93KSArIGRlbHRhLFxcbiAgICAgICAgICAgIDAsXFxuICAgICAgICAgICAgMVxcbiAgICAgICAgKTtcXG4gICAgdmVjMiBwcm9qZWN0ZWQgPSBwb3NpdGlvbi54eSAvIHBvc2l0aW9uLnc7XFxuICAgIHJldHVybiBwcm9qZWN0ZWQgLyBwaXhlbFNpemU7XFxufVxcblxcbi8qKlxcbiAqIEVhY2ggcG9pbnQgb2YgdGhlIHBvbHlsaW5lIGlzIGVuY29kZWQgYXMgYSB2ZWN0b3IgZnJvbSB0aGUgcG9seWxpbmUgY2VudGVyIGJ5IGl0cyBub3JtYWxpemVkIGFuZ2xlIGFuZCB0aGUgcmF0aW8gb2ZcXG4gKiBpdHMgbGVuZ3RoIHRvIHRoZSBwb2x5bGluZSdzIGxlbmd0aC5cXG4gKi9cXG52ZWMyIGRlY29kZVBvbHlsaW5lRGVsdGFzXzFfNihmbG9hdCByYXRpbywgZmxvYXQgYW5nbGUsIGZsb2F0IHBvbHlsaW5lTGVuZ3RoKSB7XFxuICAgIC8vIGRlbm9ybWFsaXplIGFuZ2xlIGJhY2sgdG8gcmFkaWFuc1xcbiAgICBmbG9hdCBhID0gYW5nbGUgKiAyLjAgKiBQSV8xXzIgLSBQSV8xXzI7XFxuICAgIC8vIGxlbmd0aCBvZiBhIHZlY3RvclxcbiAgICBmbG9hdCBsZW4gPSByYXRpbyAqIHBvbHlsaW5lTGVuZ3RoO1xcbiAgICAvLyByZXN0b3JlZCBwb2ludCdzICh4LCB5KSBjb29yZGluYXRlc1xcbiAgICByZXR1cm4gdmVjMihjb3MoYSksIHNpbihhKSkgKiBsZW47XFxufVxcblxcbi8qKlxcbiAqIFByb2plY3RzIHNwZWNpZmljIGN1cnZlZCBsYWJlbCB2ZXJ0ZXggb250byB0aGUgc2NyZWVuLiBUaGUgbGFiZWwgaXMgbGF5b3V0ZWQgYnkgY2VudGVyaW5nIHBvbHlsaW5lIGluXFxuICogdGhlIHZlcnRleFBvc0hpZ2gvdmVydGV4UG9zTG93IGFuZCBvdGhlciBwb2ludHMgYXJlIHVzZWQgdG8gZ3VpZGUgY29uY3JldGUgZ3J5cGggdmVydGV4LlxcbiAqIE51bWJlciBvZiBwb2x5bGluZSBwb2ludHMgaXMgaGFyZGNvZGVkIHRvIHBhc3MgdGhlbSBpbiBhdHRyaWJ1dGVzLlxcbiAqL1xcbnZlYzQgcHJvamVjdEN1cnZlZExhYmVsVmVydGV4XzFfNyhcXG4gICAgbWF0NCB2aWV3UHJvak1hdHJpeCxcXG4gICAgdmVjMiBsb29rQXRIaWdoLFxcbiAgICB2ZWMyIGxvb2tBdExvdyxcXG4gICAgdmVjMiBweFNpemUsXFxuICAgIHZlYzIgcG9zSGlnaCxcXG4gICAgdmVjMiBwb3NMb3csXFxuICAgIHZlYzIgZGlzcGxhY2VtZW50LFxcbiAgICBmbG9hdCBsaW5lRGlzcGxhY2VtZW50LFxcbiAgICBmbG9hdCBwb2x5bGluZUxlbmd0aCxcXG4gICAgdmVjNCBsZWZ0UG9seWxpbmVSYXRpb3MsXFxuICAgIHZlYzQgbGVmdFBvbHlsaW5lQW5nbGVzLFxcbiAgICB2ZWM0IHJpZ2h0UG9seWxpbmVSYXRpb3MsXFxuICAgIHZlYzQgcmlnaHRQb2x5bGluZUFuZ2xlc1xcbikge1xcbiAgICB2ZWMyIHBvbHlsaW5lRGVsdGFzW01BWF9QT0xZTElORV9QT0lOVFNfMV8zXTtcXG4gICAgdmVjMiBwb3NpdGlvbiA9IHByb2plY3RfMV81KHZpZXdQcm9qTWF0cml4LCBsb29rQXRIaWdoLCBsb29rQXRMb3csIHB4U2l6ZSwgcG9zSGlnaCwgcG9zTG93LCB2ZWMyKDAsIDApKTtcXG4gICAgZmxvYXQgcmVtYWluaW5nTGVuZ3RoID0gYWJzKGxpbmVEaXNwbGFjZW1lbnQpO1xcbiAgICBmb3IgKGludCBpID0gMDsgaSA8IE1BWF9QT0xZTElORV9QT0lOVFNfMV8zOyBpKyspIHtcXG4gICAgICAgIHZlYzIgcHJvamVjdGVkUG9pbnQ7XFxuXFxuICAgICAgICAvLyBmaWd1cmUgb3V0IHRoZSBkaXJlY3Rpb24gKGxlZnQvcmlnaHQpIGF0IHRoZSBmaXJzdCBzdGVwXFxuICAgICAgICBpZiAoaSA9PSAwKSB7XFxuICAgICAgICAgICAgcHJvamVjdGVkUG9pbnQgPSBwcm9qZWN0XzFfNShcXG4gICAgICAgICAgICAgICAgdmlld1Byb2pNYXRyaXgsXFxuICAgICAgICAgICAgICAgIGxvb2tBdEhpZ2gsXFxuICAgICAgICAgICAgICAgIGxvb2tBdExvdyxcXG4gICAgICAgICAgICAgICAgcHhTaXplLFxcbiAgICAgICAgICAgICAgICBwb3NIaWdoLFxcbiAgICAgICAgICAgICAgICBwb3NMb3csXFxuICAgICAgICAgICAgICAgIGRlY29kZVBvbHlsaW5lRGVsdGFzXzFfNihyaWdodFBvbHlsaW5lUmF0aW9zWzBdLCByaWdodFBvbHlsaW5lQW5nbGVzWzBdLCBwb2x5bGluZUxlbmd0aClcXG4gICAgICAgICAgICApO1xcbiAgICAgICAgICAgIGJvb2wgaXNSaWdodFBhcnQgPSBsaW5lRGlzcGxhY2VtZW50ID4gMC4wO1xcbiAgICAgICAgICAgIGJvb2wgaXNJbnZlcnRlZCA9IHByb2plY3RlZFBvaW50LnggPCBwb3NpdGlvbi54O1xcblxcbiAgICAgICAgICAgIC8vIHRoZSBtYXAgY291bGQgYmUgcm90YXRlZCBhbmQgY3VydmVkIGxhYmVsIHNob3VsZCBjaGFuZ2UgaXRzIGRpcmVjdGlvbiBpZiB0aGV5IGdvdCB1cHNpZGUgZG93blxcbiAgICAgICAgICAgIC8vIHVzaW5nIGNlbnRlciBzZWdtZW50IHRvIGlkZW50aWZ5IHRoaXMgY2FzZSBpcyBhbiBhcHByb3hpbWF0aW9uIChpZGVhbGx5IHdlIHNob3VsZCBjaGVjayBhbGwgc2VnbWVudHMpXFxuICAgICAgICAgICAgaWYgKGlzUmlnaHRQYXJ0IF5eIGlzSW52ZXJ0ZWQpIHtcXG4gICAgICAgICAgICAgICAgcG9seWxpbmVEZWx0YXNbMF0gPSBkZWNvZGVQb2x5bGluZURlbHRhc18xXzYocmlnaHRQb2x5bGluZVJhdGlvc1swXSwgcmlnaHRQb2x5bGluZUFuZ2xlc1swXSwgcG9seWxpbmVMZW5ndGgpO1xcbiAgICAgICAgICAgICAgICBwb2x5bGluZURlbHRhc1sxXSA9IGRlY29kZVBvbHlsaW5lRGVsdGFzXzFfNihyaWdodFBvbHlsaW5lUmF0aW9zWzFdLCByaWdodFBvbHlsaW5lQW5nbGVzWzFdLCBwb2x5bGluZUxlbmd0aCk7XFxuICAgICAgICAgICAgICAgIHBvbHlsaW5lRGVsdGFzWzJdID0gZGVjb2RlUG9seWxpbmVEZWx0YXNfMV82KHJpZ2h0UG9seWxpbmVSYXRpb3NbMl0sIHJpZ2h0UG9seWxpbmVBbmdsZXNbMl0sIHBvbHlsaW5lTGVuZ3RoKTtcXG4gICAgICAgICAgICAgICAgcG9seWxpbmVEZWx0YXNbM10gPSBkZWNvZGVQb2x5bGluZURlbHRhc18xXzYocmlnaHRQb2x5bGluZVJhdGlvc1szXSwgcmlnaHRQb2x5bGluZUFuZ2xlc1szXSwgcG9seWxpbmVMZW5ndGgpO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHBvbHlsaW5lRGVsdGFzWzBdID0gZGVjb2RlUG9seWxpbmVEZWx0YXNfMV82KGxlZnRQb2x5bGluZVJhdGlvc1swXSwgbGVmdFBvbHlsaW5lQW5nbGVzWzBdLCBwb2x5bGluZUxlbmd0aCk7XFxuICAgICAgICAgICAgICAgIHBvbHlsaW5lRGVsdGFzWzFdID0gZGVjb2RlUG9seWxpbmVEZWx0YXNfMV82KGxlZnRQb2x5bGluZVJhdGlvc1sxXSwgbGVmdFBvbHlsaW5lQW5nbGVzWzFdLCBwb2x5bGluZUxlbmd0aCk7XFxuICAgICAgICAgICAgICAgIHBvbHlsaW5lRGVsdGFzWzJdID0gZGVjb2RlUG9seWxpbmVEZWx0YXNfMV82KGxlZnRQb2x5bGluZVJhdGlvc1syXSwgbGVmdFBvbHlsaW5lQW5nbGVzWzJdLCBwb2x5bGluZUxlbmd0aCk7XFxuICAgICAgICAgICAgICAgIHBvbHlsaW5lRGVsdGFzWzNdID0gZGVjb2RlUG9seWxpbmVEZWx0YXNfMV82KGxlZnRQb2x5bGluZVJhdGlvc1szXSwgbGVmdFBvbHlsaW5lQW5nbGVzWzNdLCBwb2x5bGluZUxlbmd0aCk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIC8vIHRoZSBmaXJzdCByaWdodCBwb2ludCBvZiB0aGUgc2VnbWVudCBhbHJlYWR5IGNhbGN1bGF0ZWQsXFxuICAgICAgICAgICAgLy8gcmVjYWxjdWxhdGUgdGhlIHBvaW50IGlmIHRoaXMgcGFydCBvZiB0aGUgbGFiZWwgZ29lcyBvdGhlciBkaXJlY3Rpb25cXG4gICAgICAgICAgICBpZiAoIShpc1JpZ2h0UGFydCAmJiAhaXNJbnZlcnRlZCkgJiYgISghaXNSaWdodFBhcnQgJiYgaXNJbnZlcnRlZCkpIHtcXG4gICAgICAgICAgICAgICAgcHJvamVjdGVkUG9pbnQgPSBwcm9qZWN0XzFfNSh2aWV3UHJvak1hdHJpeCwgbG9va0F0SGlnaCwgbG9va0F0TG93LCBweFNpemUsIHBvc0hpZ2gsIHBvc0xvdywgcG9seWxpbmVEZWx0YXNbaV0pO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgcHJvamVjdGVkUG9pbnQgPSBwcm9qZWN0XzFfNSh2aWV3UHJvak1hdHJpeCwgbG9va0F0SGlnaCwgbG9va0F0TG93LCBweFNpemUsIHBvc0hpZ2gsIHBvc0xvdywgcG9seWxpbmVEZWx0YXNbaV0pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdmVjMiBzZWdtZW50ID0gcHJvamVjdGVkUG9pbnQgLSBwb3NpdGlvbjtcXG4gICAgICAgIGJvb2wgaXNMYXN0ID0gaSA9PSAoTUFYX1BPTFlMSU5FX1BPSU5UU18xXzMgLSAxKTtcXG4gICAgICAgIGZsb2F0IHNlZ21lbnRMZW5ndGggPSAoaXNMYXN0IHx8IChwb2x5bGluZURlbHRhc1tpICsgMV0gPT0gdmVjMigwLCAwKSkpID8gSU5GSU5JVFlfMV80IDogbGVuZ3RoKHNlZ21lbnQpO1xcblxcbiAgICAgICAgaWYgKHNlZ21lbnRMZW5ndGggPiByZW1haW5pbmdMZW5ndGgpIHtcXG4gICAgICAgICAgICBmbG9hdCBzaWduRmFjdG9yID0gbGluZURpc3BsYWNlbWVudCA+IDAuMCA/IDEuMCA6IC0xLjA7XFxuICAgICAgICAgICAgdmVjMiBkaXJlY3Rpb24gPSBub3JtYWxpemUoc2VnbWVudCk7XFxuICAgICAgICAgICAgdmVjMiBub3JtYWwgPSB2ZWMyKC1kaXJlY3Rpb24ueSwgZGlyZWN0aW9uLngpO1xcblxcbiAgICAgICAgICAgIHBvc2l0aW9uICs9IGRpcmVjdGlvbiAqIHJlbWFpbmluZ0xlbmd0aDtcXG4gICAgICAgICAgICBwb3NpdGlvbiArPSBzaWduRmFjdG9yICogZGlyZWN0aW9uICogZGlzcGxhY2VtZW50Lng7XFxuICAgICAgICAgICAgcG9zaXRpb24gKz0gc2lnbkZhY3RvciAqIG5vcm1hbCAqIGRpc3BsYWNlbWVudC55O1xcblxcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICByZW1haW5pbmdMZW5ndGggLT0gc2VnbWVudExlbmd0aDtcXG4gICAgICAgICAgICBwb3NpdGlvbiArPSBzZWdtZW50O1xcbiAgICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHJldHVybiB2ZWM0KHBvc2l0aW9uICogcHhTaXplLCAwLjAsIDEuMCk7XFxufVxcblxcblxcblxcblxcblxcbi8qKlxcbiAqIEN1cnZlZCBsYWJlbHMgYXJlIGxheW91dGVkIGhlcmU6IHRoZSBsYWJlbCBpcyBjZW50ZXJlZCBpbiB0aGUgdmVydGV4UG9zSGlnaC92ZXJ0ZXhQb3NMb3cgYW5kIHBvbHlsaW5lIHBvaW50c1xcbiAqIGFyZSB1c2VkIHRvIGd1aWRlIGNvbmNyZXRlIGdyeXBoIHZlcnRleC4gTnVtYmVyIG9mIHBvbHlsaW5lIHBvaW50cyBpcyBoYXJkY29kZWQgdG8gcGFzcyB0aGVtIGluIGF0dHJpYnV0ZXMuXFxuICovXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gICAgdmVjMiBpZFRleENvb3JkaW5hdGUgPSB2ZXJ0ZXhJZC54eSArIGlkSGFsZlB4U2l6ZTtcXG4gICAgZmxvYXQgb3ZlcmxhcFpvb20gPSB0ZXh0dXJlMkQodmlzaWJpbGl0eSwgaWRUZXhDb29yZGluYXRlKS5iO1xcblxcbiAgICBpZiAoY3VycmVudFpvb20gPCBvdmVybGFwWm9vbSkge1xcbiAgICAgICAgZ2xfUG9zaXRpb24gPSBESVNDQVJEX1BPU0lUSU9OO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgdmVjMiB2ZXJ0ZXhEaXNwbGFjZW1lbnQgPSB2ZXJ0ZXhEaXNwbGFjZW1lbnRzLnh5O1xcbiAgICAgICAgZmxvYXQgdmVydGV4TGluZURpc3BsYWNlbWVudCA9IHZlcnRleERpc3BsYWNlbWVudHMuejtcXG4gICAgICAgIGZsb2F0IHBvbHlsaW5lTGVuZ3RoID0gcG9seWxpbmVMZW5ndGhfdmVydGV4U2NhbGVbMF07XFxuICAgICAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3RDdXJ2ZWRMYWJlbFZlcnRleF8xXzcoXFxuICAgICAgICAgICAgdmlld1Byb2pNYXRyaXgsXFxuICAgICAgICAgICAgbG9va0F0SGlnaCxcXG4gICAgICAgICAgICBsb29rQXRMb3csXFxuICAgICAgICAgICAgcGl4ZWxTaXplLFxcbiAgICAgICAgICAgIHZlcnRleFBvc0hpZ2gsXFxuICAgICAgICAgICAgdmVydGV4UG9zTG93LFxcbiAgICAgICAgICAgIHZlcnRleERpc3BsYWNlbWVudCxcXG4gICAgICAgICAgICB2ZXJ0ZXhMaW5lRGlzcGxhY2VtZW50LFxcbiAgICAgICAgICAgIHBvbHlsaW5lTGVuZ3RoLFxcbiAgICAgICAgICAgIGxlZnRQb2x5bGluZVJhdGlvcyxcXG4gICAgICAgICAgICBsZWZ0UG9seWxpbmVBbmdsZXMsXFxuICAgICAgICAgICAgcmlnaHRQb2x5bGluZVJhdGlvcyxcXG4gICAgICAgICAgICByaWdodFBvbHlsaW5lQW5nbGVzXFxuICAgICAgICApO1xcblxcbiAgICAgICAgZ2xfUG9zaXRpb24ueHkgKz0gc2hpZnQ7XFxuICAgICAgICBnbF9Qb3NpdGlvbi56ID0gdmVydGV4UHJpb3JpdHk7XFxuXFxuICAgICAgICBjb2xvciA9IHZlYzQodmVydGV4SWQsIDAsIDEpO1xcbiAgICB9XFxufVxcblwiIiwiaW1wb3J0IGN1cnZlZExhYmVsVmVydGV4U2hhZGVyIGZyb20gJy4vc2hhZGVyL2N1cnZlZF9sYWJlbC52ZXJ0JztcclxuaW1wb3J0IGRmVGV4dEZyYWdtZW50U2hhZGVyIGZyb20gJy4vc2hhZGVyL2RmX3RleHQuZnJhZyc7XHJcbmltcG9ydCBMYWJlbFJlbmRlclVuaXQgZnJvbSAnLi9sYWJlbF9yZW5kZXJfdW5pdCc7XHJcbmV4cG9ydCBjb25zdCBQUk9HUkFNX09QVElPTlMgPSB7XHJcbiAgICBhdHRyaWJNYXA6IHtcclxuICAgICAgICB2ZXJ0ZXhJZDogMiAvKiBJRCAqLyxcclxuICAgICAgICB2ZXJ0ZXhQb3NIaWdoOiAwIC8qIFBPU0lUSU9OX0hJR0ggKi8sXHJcbiAgICAgICAgdmVydGV4UG9zTG93OiAxIC8qIFBPU0lUSU9OX0xPVyAqLyxcclxuICAgICAgICB2ZXJ0ZXhEaXNwbGFjZW1lbnRzOiA2IC8qIERJU1BMQUNFTUVOVCAqLyxcclxuICAgICAgICB2ZXJ0ZXhVVjogNCAvKiBVViAqLyxcclxuICAgICAgICB2ZXJ0ZXhDb2xvcjogNyAvKiBDT0xPUiAqLyxcclxuICAgICAgICB2ZXJ0ZXhPdXRsaW5lQ29sb3I6IDggLyogT1VUTElORV9DT0xPUiAqLyxcclxuICAgICAgICB2ZXJ0ZXhQcmlvcml0eTogOSAvKiBQUklPUklUWSAqLyxcclxuICAgICAgICBsZWZ0UG9seWxpbmVSYXRpb3M6IDEyIC8qIEFVWDEgKi8sXHJcbiAgICAgICAgbGVmdFBvbHlsaW5lQW5nbGVzOiAxMyAvKiBBVVgyICovLFxyXG4gICAgICAgIHJpZ2h0UG9seWxpbmVSYXRpb3M6IDE0IC8qIEFVWDMgKi8sXHJcbiAgICAgICAgcmlnaHRQb2x5bGluZUFuZ2xlczogMTUgLyogQVVYNCAqLyxcclxuICAgICAgICBwb2x5bGluZUxlbmd0aF92ZXJ0ZXhTY2FsZTogMTEgLyogQVVYICovXHJcbiAgICB9XHJcbn07XHJcbi8qKlxyXG4gKiBDdXJ2ZWQgbGFiZWxzIHJlbmRlcmVyLiBJdCB1c2VzIGFwcHJvcHJpYXRlIHByb2dyYW0gdG8gbGF5b3V0IGdseXBocyBvbiBHUFUuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDdXJ2ZWRMYWJlbFJlbmRlclVuaXQgZXh0ZW5kcyBMYWJlbFJlbmRlclVuaXQge1xyXG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgY2FtZXJhLCB2aXNpYmlsaXR5UHJvdmlkZXIsIHByaW1pdGl2ZVByb3ZpZGVyKSB7XHJcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IGNvbnRleHQuY3JlYXRlUHJvZ3JhbShjdXJ2ZWRMYWJlbFZlcnRleFNoYWRlciwgZGZUZXh0RnJhZ21lbnRTaGFkZXIsIFBST0dSQU1fT1BUSU9OUyk7XHJcbiAgICAgICAgc3VwZXIoY29udGV4dCwgcHJvZ3JhbSwgY2FtZXJhLCB2aXNpYmlsaXR5UHJvdmlkZXIsIHByaW1pdGl2ZVByb3ZpZGVyKTtcclxuICAgIH1cclxufVxyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiI3ZlcnNpb24gMTAwXFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhJZDtcXG5cXG4vLyBwb2ludCBpbiB0aGUgd29ybGQgdGhlIGxhYmVsIGlzIGFuY2hvcmVkIHRvXFxuYXR0cmlidXRlIHZlYzIgdmVydGV4UG9zSGlnaDtcXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhQb3NMb3c7XFxuXFxuLy8gdmVjdG9yIG9mIGNvbmNyZXRlIGdseXBoIHBvaW50IGRpc3BsYWNlbWVudCAodG9wLWxlZnQsIGJvdHRvbS1sZWZ0LCAuLi4pIHJlbGF0aXZlIHRvIGdseXBoJ3MgY2VudGVyICh0d28gdmFsdWVzKSxcXG4vLyBhbmQgZGlzdGFuY2Ugb2YgdGhlIGdseXBoIGNlbnRlciB0byBsYWJlbCdzIGNlbnRlciAodGhpcmQgdmFsdWUpLCBpbiBweFxcbmF0dHJpYnV0ZSB2ZWMzIHZlcnRleERpc3BsYWNlbWVudHM7XFxuXFxuLy8gY29vcmRpbmF0ZXMgb2YgdGhlIGdseXBoIHZlcnRleCBpbiB0aGUgYXRsYXNcXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhVVjtcXG5cXG5hdHRyaWJ1dGUgZmxvYXQgdmVydGV4UHJpb3JpdHk7XFxuXFxuYXR0cmlidXRlIGxvd3AgdmVjNCB2ZXJ0ZXhDb2xvcjtcXG5hdHRyaWJ1dGUgbG93cCB2ZWM0IHZlcnRleE91dGxpbmVDb2xvcjtcXG5hdHRyaWJ1dGUgdmVjMiBwb2x5bGluZUxlbmd0aF92ZXJ0ZXhTY2FsZTtcXG5cXG4vLyBkZWx0YXMgcmVsYXRpdmUgdG8gdGhlIHdvcmxkIHBvaW50IGVuY29kZWQgaW4gdmVydGV4UG9zSGlnaC92ZXJ0ZXhQb3NMb3cgZW5jb2RlZCB2aWEgbGVuZ3RocyBhbmQgYW5kIGFuZ2xlcyBvZlxcbi8vIGNvcnJlc3BvbmRpbmcgdmVjdG9yc1xcbmF0dHJpYnV0ZSB2ZWM0IGxlZnRQb2x5bGluZVJhdGlvcztcXG5hdHRyaWJ1dGUgdmVjNCBsZWZ0UG9seWxpbmVBbmdsZXM7XFxuYXR0cmlidXRlIHZlYzQgcmlnaHRQb2x5bGluZVJhdGlvcztcXG5hdHRyaWJ1dGUgdmVjNCByaWdodFBvbHlsaW5lQW5nbGVzO1xcblxcbnVuaWZvcm0gdmVjMiBsb29rQXRIaWdoO1xcbnVuaWZvcm0gdmVjMiBsb29rQXRMb3c7XFxudW5pZm9ybSBtYXQ0IHZpZXdQcm9qTWF0cml4O1xcbnVuaWZvcm0gdmVjMiBwaXhlbFNpemU7XFxudW5pZm9ybSBzYW1wbGVyMkQgdmlzaWJpbGl0eTtcXG51bmlmb3JtIHZlYzIgaWRIYWxmUHhTaXplO1xcbnVuaWZvcm0gdmVjMiBzaGlmdDtcXG51bmlmb3JtIGxvd3AgZmxvYXQgY3VycmVudFpvb207XFxuXFxudmFyeWluZyB2ZWMyIHV2O1xcbnZhcnlpbmcgbG93cCB2ZWM0IGNvbG9yO1xcbnZhcnlpbmcgbG93cCB2ZWM0IG91dGxpbmVDb2xvcjtcXG52YXJ5aW5nIGZsb2F0IHNjYWxlO1xcblxcbmNvbnN0IHZlYzQgRElTQ0FSRF9QT1NJVElPTiA9IHZlYzQoMiwgMiwgMiwgMSk7XFxuXFxuY29uc3QgZmxvYXQgWVZfSF8xXzAgPSAxLjk5OTk2OTQ4MjQyMTg3NTtcXG5jb25zdCBmbG9hdCBZVl9MXzFfMSA9IDAuMDAwMDMwNTE3MTEyNDYzNzEyNjkyO1xcblxcbmNvbnN0IGZsb2F0IFBJXzFfMiA9IDMuMTQxNTkyNzQxMDEyNTczMjtcXG5cXG5jb25zdCBpbnQgTUFYX1BPTFlMSU5FX1BPSU5UU18xXzMgPSA0O1xcbmNvbnN0IGZsb2F0IElORklOSVRZXzFfNCA9IDEwMDAwMDAuMDsgLy8gbGFyZ2UgZW5vdWdoIGZvciBhIHNlZ21lbnQgbGVuZ3RoIHRvIGNvbnNpZGVyIGl0IGluZmluaXR5XFxuXFxuLyoqXFxuICogUmV0dXJucyB3b3JsZCBjb29yZGluYXRlIChwbHVzIGRlbHRhKSBwcm9qZWN0ZWQgb24gc2NyZWVuLCBpbiBwaXhlbHMuXFxuICovXFxudmVjMiBwcm9qZWN0XzFfNShcXG4gICAgbWF0NCB2aWV3UHJvak1hdHJpeCxcXG4gICAgdmVjMiBsb29rQXRIaWdoLFxcbiAgICB2ZWMyIGxvb2tBdExvdyxcXG4gICAgdmVjMiBwaXhlbFNpemUsXFxuICAgIHZlYzIgcG9pbnRIaWdoLFxcbiAgICB2ZWMyIHBvaW50TG93LFxcbiAgICB2ZWMyIGRlbHRhXFxuKSB7XFxuICAgIHZlYzQgcG9zaXRpb24gPSB2aWV3UHJvak1hdHJpeCAqIHZlYzQoXFxuICAgICAgICAgICAgWVZfSF8xXzAgKiAocG9pbnRIaWdoIC0gbG9va0F0SGlnaCkgKyBZVl9MXzFfMSAqIChwb2ludExvdyAtIGxvb2tBdExvdykgKyBkZWx0YSxcXG4gICAgICAgICAgICAwLFxcbiAgICAgICAgICAgIDFcXG4gICAgICAgICk7XFxuICAgIHZlYzIgcHJvamVjdGVkID0gcG9zaXRpb24ueHkgLyBwb3NpdGlvbi53O1xcbiAgICByZXR1cm4gcHJvamVjdGVkIC8gcGl4ZWxTaXplO1xcbn1cXG5cXG4vKipcXG4gKiBFYWNoIHBvaW50IG9mIHRoZSBwb2x5bGluZSBpcyBlbmNvZGVkIGFzIGEgdmVjdG9yIGZyb20gdGhlIHBvbHlsaW5lIGNlbnRlciBieSBpdHMgbm9ybWFsaXplZCBhbmdsZSBhbmQgdGhlIHJhdGlvIG9mXFxuICogaXRzIGxlbmd0aCB0byB0aGUgcG9seWxpbmUncyBsZW5ndGguXFxuICovXFxudmVjMiBkZWNvZGVQb2x5bGluZURlbHRhc18xXzYoZmxvYXQgcmF0aW8sIGZsb2F0IGFuZ2xlLCBmbG9hdCBwb2x5bGluZUxlbmd0aCkge1xcbiAgICAvLyBkZW5vcm1hbGl6ZSBhbmdsZSBiYWNrIHRvIHJhZGlhbnNcXG4gICAgZmxvYXQgYSA9IGFuZ2xlICogMi4wICogUElfMV8yIC0gUElfMV8yO1xcbiAgICAvLyBsZW5ndGggb2YgYSB2ZWN0b3JcXG4gICAgZmxvYXQgbGVuID0gcmF0aW8gKiBwb2x5bGluZUxlbmd0aDtcXG4gICAgLy8gcmVzdG9yZWQgcG9pbnQncyAoeCwgeSkgY29vcmRpbmF0ZXNcXG4gICAgcmV0dXJuIHZlYzIoY29zKGEpLCBzaW4oYSkpICogbGVuO1xcbn1cXG5cXG4vKipcXG4gKiBQcm9qZWN0cyBzcGVjaWZpYyBjdXJ2ZWQgbGFiZWwgdmVydGV4IG9udG8gdGhlIHNjcmVlbi4gVGhlIGxhYmVsIGlzIGxheW91dGVkIGJ5IGNlbnRlcmluZyBwb2x5bGluZSBpblxcbiAqIHRoZSB2ZXJ0ZXhQb3NIaWdoL3ZlcnRleFBvc0xvdyBhbmQgb3RoZXIgcG9pbnRzIGFyZSB1c2VkIHRvIGd1aWRlIGNvbmNyZXRlIGdyeXBoIHZlcnRleC5cXG4gKiBOdW1iZXIgb2YgcG9seWxpbmUgcG9pbnRzIGlzIGhhcmRjb2RlZCB0byBwYXNzIHRoZW0gaW4gYXR0cmlidXRlcy5cXG4gKi9cXG52ZWM0IHByb2plY3RDdXJ2ZWRMYWJlbFZlcnRleF8xXzcoXFxuICAgIG1hdDQgdmlld1Byb2pNYXRyaXgsXFxuICAgIHZlYzIgbG9va0F0SGlnaCxcXG4gICAgdmVjMiBsb29rQXRMb3csXFxuICAgIHZlYzIgcHhTaXplLFxcbiAgICB2ZWMyIHBvc0hpZ2gsXFxuICAgIHZlYzIgcG9zTG93LFxcbiAgICB2ZWMyIGRpc3BsYWNlbWVudCxcXG4gICAgZmxvYXQgbGluZURpc3BsYWNlbWVudCxcXG4gICAgZmxvYXQgcG9seWxpbmVMZW5ndGgsXFxuICAgIHZlYzQgbGVmdFBvbHlsaW5lUmF0aW9zLFxcbiAgICB2ZWM0IGxlZnRQb2x5bGluZUFuZ2xlcyxcXG4gICAgdmVjNCByaWdodFBvbHlsaW5lUmF0aW9zLFxcbiAgICB2ZWM0IHJpZ2h0UG9seWxpbmVBbmdsZXNcXG4pIHtcXG4gICAgdmVjMiBwb2x5bGluZURlbHRhc1tNQVhfUE9MWUxJTkVfUE9JTlRTXzFfM107XFxuICAgIHZlYzIgcG9zaXRpb24gPSBwcm9qZWN0XzFfNSh2aWV3UHJvak1hdHJpeCwgbG9va0F0SGlnaCwgbG9va0F0TG93LCBweFNpemUsIHBvc0hpZ2gsIHBvc0xvdywgdmVjMigwLCAwKSk7XFxuICAgIGZsb2F0IHJlbWFpbmluZ0xlbmd0aCA9IGFicyhsaW5lRGlzcGxhY2VtZW50KTtcXG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCBNQVhfUE9MWUxJTkVfUE9JTlRTXzFfMzsgaSsrKSB7XFxuICAgICAgICB2ZWMyIHByb2plY3RlZFBvaW50O1xcblxcbiAgICAgICAgLy8gZmlndXJlIG91dCB0aGUgZGlyZWN0aW9uIChsZWZ0L3JpZ2h0KSBhdCB0aGUgZmlyc3Qgc3RlcFxcbiAgICAgICAgaWYgKGkgPT0gMCkge1xcbiAgICAgICAgICAgIHByb2plY3RlZFBvaW50ID0gcHJvamVjdF8xXzUoXFxuICAgICAgICAgICAgICAgIHZpZXdQcm9qTWF0cml4LFxcbiAgICAgICAgICAgICAgICBsb29rQXRIaWdoLFxcbiAgICAgICAgICAgICAgICBsb29rQXRMb3csXFxuICAgICAgICAgICAgICAgIHB4U2l6ZSxcXG4gICAgICAgICAgICAgICAgcG9zSGlnaCxcXG4gICAgICAgICAgICAgICAgcG9zTG93LFxcbiAgICAgICAgICAgICAgICBkZWNvZGVQb2x5bGluZURlbHRhc18xXzYocmlnaHRQb2x5bGluZVJhdGlvc1swXSwgcmlnaHRQb2x5bGluZUFuZ2xlc1swXSwgcG9seWxpbmVMZW5ndGgpXFxuICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICBib29sIGlzUmlnaHRQYXJ0ID0gbGluZURpc3BsYWNlbWVudCA+IDAuMDtcXG4gICAgICAgICAgICBib29sIGlzSW52ZXJ0ZWQgPSBwcm9qZWN0ZWRQb2ludC54IDwgcG9zaXRpb24ueDtcXG5cXG4gICAgICAgICAgICAvLyB0aGUgbWFwIGNvdWxkIGJlIHJvdGF0ZWQgYW5kIGN1cnZlZCBsYWJlbCBzaG91bGQgY2hhbmdlIGl0cyBkaXJlY3Rpb24gaWYgdGhleSBnb3QgdXBzaWRlIGRvd25cXG4gICAgICAgICAgICAvLyB1c2luZyBjZW50ZXIgc2VnbWVudCB0byBpZGVudGlmeSB0aGlzIGNhc2UgaXMgYW4gYXBwcm94aW1hdGlvbiAoaWRlYWxseSB3ZSBzaG91bGQgY2hlY2sgYWxsIHNlZ21lbnRzKVxcbiAgICAgICAgICAgIGlmIChpc1JpZ2h0UGFydCBeXiBpc0ludmVydGVkKSB7XFxuICAgICAgICAgICAgICAgIHBvbHlsaW5lRGVsdGFzWzBdID0gZGVjb2RlUG9seWxpbmVEZWx0YXNfMV82KHJpZ2h0UG9seWxpbmVSYXRpb3NbMF0sIHJpZ2h0UG9seWxpbmVBbmdsZXNbMF0sIHBvbHlsaW5lTGVuZ3RoKTtcXG4gICAgICAgICAgICAgICAgcG9seWxpbmVEZWx0YXNbMV0gPSBkZWNvZGVQb2x5bGluZURlbHRhc18xXzYocmlnaHRQb2x5bGluZVJhdGlvc1sxXSwgcmlnaHRQb2x5bGluZUFuZ2xlc1sxXSwgcG9seWxpbmVMZW5ndGgpO1xcbiAgICAgICAgICAgICAgICBwb2x5bGluZURlbHRhc1syXSA9IGRlY29kZVBvbHlsaW5lRGVsdGFzXzFfNihyaWdodFBvbHlsaW5lUmF0aW9zWzJdLCByaWdodFBvbHlsaW5lQW5nbGVzWzJdLCBwb2x5bGluZUxlbmd0aCk7XFxuICAgICAgICAgICAgICAgIHBvbHlsaW5lRGVsdGFzWzNdID0gZGVjb2RlUG9seWxpbmVEZWx0YXNfMV82KHJpZ2h0UG9seWxpbmVSYXRpb3NbM10sIHJpZ2h0UG9seWxpbmVBbmdsZXNbM10sIHBvbHlsaW5lTGVuZ3RoKTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBwb2x5bGluZURlbHRhc1swXSA9IGRlY29kZVBvbHlsaW5lRGVsdGFzXzFfNihsZWZ0UG9seWxpbmVSYXRpb3NbMF0sIGxlZnRQb2x5bGluZUFuZ2xlc1swXSwgcG9seWxpbmVMZW5ndGgpO1xcbiAgICAgICAgICAgICAgICBwb2x5bGluZURlbHRhc1sxXSA9IGRlY29kZVBvbHlsaW5lRGVsdGFzXzFfNihsZWZ0UG9seWxpbmVSYXRpb3NbMV0sIGxlZnRQb2x5bGluZUFuZ2xlc1sxXSwgcG9seWxpbmVMZW5ndGgpO1xcbiAgICAgICAgICAgICAgICBwb2x5bGluZURlbHRhc1syXSA9IGRlY29kZVBvbHlsaW5lRGVsdGFzXzFfNihsZWZ0UG9seWxpbmVSYXRpb3NbMl0sIGxlZnRQb2x5bGluZUFuZ2xlc1syXSwgcG9seWxpbmVMZW5ndGgpO1xcbiAgICAgICAgICAgICAgICBwb2x5bGluZURlbHRhc1szXSA9IGRlY29kZVBvbHlsaW5lRGVsdGFzXzFfNihsZWZ0UG9seWxpbmVSYXRpb3NbM10sIGxlZnRQb2x5bGluZUFuZ2xlc1szXSwgcG9seWxpbmVMZW5ndGgpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAvLyB0aGUgZmlyc3QgcmlnaHQgcG9pbnQgb2YgdGhlIHNlZ21lbnQgYWxyZWFkeSBjYWxjdWxhdGVkLFxcbiAgICAgICAgICAgIC8vIHJlY2FsY3VsYXRlIHRoZSBwb2ludCBpZiB0aGlzIHBhcnQgb2YgdGhlIGxhYmVsIGdvZXMgb3RoZXIgZGlyZWN0aW9uXFxuICAgICAgICAgICAgaWYgKCEoaXNSaWdodFBhcnQgJiYgIWlzSW52ZXJ0ZWQpICYmICEoIWlzUmlnaHRQYXJ0ICYmIGlzSW52ZXJ0ZWQpKSB7XFxuICAgICAgICAgICAgICAgIHByb2plY3RlZFBvaW50ID0gcHJvamVjdF8xXzUodmlld1Byb2pNYXRyaXgsIGxvb2tBdEhpZ2gsIGxvb2tBdExvdywgcHhTaXplLCBwb3NIaWdoLCBwb3NMb3csIHBvbHlsaW5lRGVsdGFzW2ldKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHByb2plY3RlZFBvaW50ID0gcHJvamVjdF8xXzUodmlld1Byb2pNYXRyaXgsIGxvb2tBdEhpZ2gsIGxvb2tBdExvdywgcHhTaXplLCBwb3NIaWdoLCBwb3NMb3csIHBvbHlsaW5lRGVsdGFzW2ldKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZlYzIgc2VnbWVudCA9IHByb2plY3RlZFBvaW50IC0gcG9zaXRpb247XFxuICAgICAgICBib29sIGlzTGFzdCA9IGkgPT0gKE1BWF9QT0xZTElORV9QT0lOVFNfMV8zIC0gMSk7XFxuICAgICAgICBmbG9hdCBzZWdtZW50TGVuZ3RoID0gKGlzTGFzdCB8fCAocG9seWxpbmVEZWx0YXNbaSArIDFdID09IHZlYzIoMCwgMCkpKSA/IElORklOSVRZXzFfNCA6IGxlbmd0aChzZWdtZW50KTtcXG5cXG4gICAgICAgIGlmIChzZWdtZW50TGVuZ3RoID4gcmVtYWluaW5nTGVuZ3RoKSB7XFxuICAgICAgICAgICAgZmxvYXQgc2lnbkZhY3RvciA9IGxpbmVEaXNwbGFjZW1lbnQgPiAwLjAgPyAxLjAgOiAtMS4wO1xcbiAgICAgICAgICAgIHZlYzIgZGlyZWN0aW9uID0gbm9ybWFsaXplKHNlZ21lbnQpO1xcbiAgICAgICAgICAgIHZlYzIgbm9ybWFsID0gdmVjMigtZGlyZWN0aW9uLnksIGRpcmVjdGlvbi54KTtcXG5cXG4gICAgICAgICAgICBwb3NpdGlvbiArPSBkaXJlY3Rpb24gKiByZW1haW5pbmdMZW5ndGg7XFxuICAgICAgICAgICAgcG9zaXRpb24gKz0gc2lnbkZhY3RvciAqIGRpcmVjdGlvbiAqIGRpc3BsYWNlbWVudC54O1xcbiAgICAgICAgICAgIHBvc2l0aW9uICs9IHNpZ25GYWN0b3IgKiBub3JtYWwgKiBkaXNwbGFjZW1lbnQueTtcXG5cXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgcmVtYWluaW5nTGVuZ3RoIC09IHNlZ21lbnRMZW5ndGg7XFxuICAgICAgICAgICAgcG9zaXRpb24gKz0gc2VnbWVudDtcXG4gICAgICAgIH1cXG4gICAgfVxcblxcbiAgICByZXR1cm4gdmVjNChwb3NpdGlvbiAqIHB4U2l6ZSwgMC4wLCAxLjApO1xcbn1cXG5cXG5cXG5cXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgICBmbG9hdCB2aXNpYmlsaXR5QWxwaGEgPSB0ZXh0dXJlMkQodmlzaWJpbGl0eSwgdmVydGV4SWQueHkgKyBpZEhhbGZQeFNpemUpLmE7XFxuICAgIGlmICh2aXNpYmlsaXR5QWxwaGEgIT0gMC4wKSB7XFxuICAgICAgICB2ZWMyIHZlcnRleERpc3BsYWNlbWVudCA9IHZlcnRleERpc3BsYWNlbWVudHMueHk7XFxuICAgICAgICBmbG9hdCB2ZXJ0ZXhMaW5lRGlzcGxhY2VtZW50ID0gdmVydGV4RGlzcGxhY2VtZW50cy56O1xcbiAgICAgICAgZmxvYXQgcG9seWxpbmVMZW5ndGggPSBwb2x5bGluZUxlbmd0aF92ZXJ0ZXhTY2FsZVswXTtcXG4gICAgICAgIGZsb2F0IHZlcnRleFNjYWxlID0gcG9seWxpbmVMZW5ndGhfdmVydGV4U2NhbGVbMV07XFxuICAgICAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3RDdXJ2ZWRMYWJlbFZlcnRleF8xXzcoXFxuICAgICAgICAgICAgdmlld1Byb2pNYXRyaXgsXFxuICAgICAgICAgICAgbG9va0F0SGlnaCxcXG4gICAgICAgICAgICBsb29rQXRMb3csXFxuICAgICAgICAgICAgcGl4ZWxTaXplLFxcbiAgICAgICAgICAgIHZlcnRleFBvc0hpZ2gsXFxuICAgICAgICAgICAgdmVydGV4UG9zTG93LFxcbiAgICAgICAgICAgIHZlcnRleERpc3BsYWNlbWVudCxcXG4gICAgICAgICAgICB2ZXJ0ZXhMaW5lRGlzcGxhY2VtZW50LFxcbiAgICAgICAgICAgIHBvbHlsaW5lTGVuZ3RoLFxcbiAgICAgICAgICAgIGxlZnRQb2x5bGluZVJhdGlvcyxcXG4gICAgICAgICAgICBsZWZ0UG9seWxpbmVBbmdsZXMsXFxuICAgICAgICAgICAgcmlnaHRQb2x5bGluZVJhdGlvcyxcXG4gICAgICAgICAgICByaWdodFBvbHlsaW5lQW5nbGVzXFxuICAgICAgICApO1xcblxcbiAgICAgICAgdXYgPSB2ZXJ0ZXhVVjtcXG4gICAgICAgIGNvbG9yID0gdmVydGV4Q29sb3I7XFxuICAgICAgICBvdXRsaW5lQ29sb3IgPSB2ZXJ0ZXhPdXRsaW5lQ29sb3I7XFxuICAgICAgICBzY2FsZSA9IHZlcnRleFNjYWxlO1xcblxcbiAgICAgICAgY29sb3IuYSAqPSB2aXNpYmlsaXR5QWxwaGE7XFxuICAgICAgICBvdXRsaW5lQ29sb3IuYSAqPSB2aXNpYmlsaXR5QWxwaGE7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICBnbF9Qb3NpdGlvbiA9IERJU0NBUkRfUE9TSVRJT047XFxuICAgIH1cXG59XFxuXCIiLCJpbXBvcnQgaWNvblZlcnRleFNoYWRlciBmcm9tICcuL3NoYWRlci9pY29uLnZlcnQnO1xyXG5pbXBvcnQgaWNvbkZyYWdtZW50U2hhZGVyIGZyb20gJy4vc2hhZGVyL2ljb24uZnJhZyc7XHJcbmltcG9ydCBJbWFnZVJlbmRlclVuaXQgZnJvbSAnLi4vaW1hZ2UvaW1hZ2VfcmVuZGVyX3VuaXQnO1xyXG4vKipcclxuICogUmVuZGVyZXIgb2YgaWNvbiBwcmltaXRpdmVzLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSWNvblJlbmRlclVuaXQgZXh0ZW5kcyBJbWFnZVJlbmRlclVuaXQge1xyXG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgY2FtZXJhLCBwcmltaXRpdmVQcm92aWRlcikge1xyXG4gICAgICAgIGNvbnN0IHByb2dyYW0gPSBjb250ZXh0LmNyZWF0ZVByb2dyYW0oaWNvblZlcnRleFNoYWRlciwgaWNvbkZyYWdtZW50U2hhZGVyLCB7XHJcbiAgICAgICAgICAgIGF0dHJpYk1hcDoge1xyXG4gICAgICAgICAgICAgICAgdmVydGV4UG9zSGlnaDogMCAvKiBQT1NJVElPTl9ISUdIICovLFxyXG4gICAgICAgICAgICAgICAgdmVydGV4UG9zTG93OiAxIC8qIFBPU0lUSU9OX0xPVyAqLyxcclxuICAgICAgICAgICAgICAgIHZlcnRleERpc3BsYWNlbWVudDogNiAvKiBESVNQTEFDRU1FTlQgKi8sXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhVVjogNCAvKiBVViAqL1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc3VwZXIoY29udGV4dCwgcHJpbWl0aXZlUHJvdmlkZXIsIHByb2dyYW0pO1xyXG4gICAgICAgIHRoaXMuX2NhbWVyYSA9IGNhbWVyYTtcclxuICAgIH1cclxuICAgIF9wcmVwYXJlUHJvZ3JhbShwcm9ncmFtLCB2aWV3UHJvak1hdHJpeCwgY2FtZXJhUG9zaXRpb25zKSB7XHJcbiAgICAgICAgc3VwZXIuX3ByZXBhcmVQcm9ncmFtKHByb2dyYW0sIHZpZXdQcm9qTWF0cml4LCBjYW1lcmFQb3NpdGlvbnMpO1xyXG4gICAgICAgIHByb2dyYW0uc2V0VmVjdG9yMlVuaWZvcm0oJ3BpeGVsU2l6ZScsIHRoaXMuX2NhbWVyYS5waXhlbFNpemUpO1xyXG4gICAgfVxyXG59XHJcbiIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleFBvc0hpZ2g7XFxuYXR0cmlidXRlIHZlYzIgdmVydGV4UG9zTG93O1xcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleERpc3BsYWNlbWVudDtcXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhVVjtcXG5cXG51bmlmb3JtIHZlYzIgbG9va0F0SGlnaDtcXG51bmlmb3JtIHZlYzIgbG9va0F0TG93O1xcbnVuaWZvcm0gbWF0NCB2aWV3UHJvak1hdHJpeDtcXG51bmlmb3JtIHZlYzIgcGl4ZWxTaXplO1xcblxcbnZhcnlpbmcgdmVjMiB1djtcXG5cXG5jb25zdCBmbG9hdCBZVl9IID0gMS45OTk5Njk0ODI0MjE4NzU7XFxuY29uc3QgZmxvYXQgWVZfTCA9IDAuMDAwMDMwNTE3MTEyNDYzNzEyNjkyO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgdmVjNCBwb3NpdGlvbiA9IHZpZXdQcm9qTWF0cml4ICogdmVjNChcXG4gICAgICAgIFlWX0ggKiAodmVydGV4UG9zSGlnaCAtIGxvb2tBdEhpZ2gpICtcXG4gICAgICAgICAgICBZVl9MICogKHZlcnRleFBvc0xvdyAtIGxvb2tBdExvdyksXFxuICAgICAgICAwLFxcbiAgICAgICAgMVxcbiAgICApO1xcbiAgICBwb3NpdGlvbiA9IHZlYzQocG9zaXRpb24ueHkgLyBwb3NpdGlvbi53LCAwLjAsIDEuMCk7XFxuXFxuICAgIGdsX1Bvc2l0aW9uID0gcG9zaXRpb24gKyB2ZWM0KHZlcnRleERpc3BsYWNlbWVudCAqIHBpeGVsU2l6ZSwgMC4wLCAwLjApO1xcblxcbiAgICB1diA9IHZlcnRleFVWO1xcbn1cXG5cIiIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbnVuaWZvcm0gc2FtcGxlcjJEIGF0bGFzO1xcbnVuaWZvcm0gdmVjMiBhdGxhc1NpemU7XFxuXFxudmFyeWluZyB2ZWMyIHV2O1xcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKGF0bGFzLCB1diAvIGF0bGFzU2l6ZSk7XFxufVxcblwiIiwiaW1wb3J0IGltYWdlVmVydGV4U2hhZGVyIGZyb20gJy4vc2hhZGVyL2ltYWdlLnZlcnQnO1xyXG5pbXBvcnQgaW1hZ2VGcmFnbWVudFNoYWRlciBmcm9tICcuL3NoYWRlci9pbWFnZS5mcmFnJztcclxuaW1wb3J0ICogYXMgdmVjMiBmcm9tICcuLi8uLi8uLi9tYXRoL3ZlY3RvcjInO1xyXG5pbXBvcnQgV29ybGRQcmltaXRpdmVSZW5kZXJVbml0IGZyb20gJy4uL3dvcmxkX3ByaW1pdGl2ZV9yZW5kZXJfdW5pdCc7XHJcbmltcG9ydCBSZW5kZXJTdGF0ZSBmcm9tICcuLi8uLi8uLi9yZW5kZXIvc3RhdGUnO1xyXG5pbXBvcnQgeyBCTEVORF9PVkVSX1JFTkRFUl9TVEFURSB9IGZyb20gJy4uLy4uLy4uL3JlbmRlci9zdGF0ZSc7XHJcbmNvbnN0IFJFTkRFUl9TVEFURSA9IG5ldyBSZW5kZXJTdGF0ZShCTEVORF9PVkVSX1JFTkRFUl9TVEFURSk7XHJcbmZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRQcm9ncmFtKGNvbnRleHQpIHtcclxuICAgIHJldHVybiBjb250ZXh0LmNyZWF0ZVByb2dyYW0oaW1hZ2VWZXJ0ZXhTaGFkZXIsIGltYWdlRnJhZ21lbnRTaGFkZXIsIHtcclxuICAgICAgICBhdHRyaWJNYXA6IHtcclxuICAgICAgICAgICAgdmVydGV4UG9zSGlnaDogMCAvKiBQT1NJVElPTl9ISUdIICovLFxyXG4gICAgICAgICAgICB2ZXJ0ZXhQb3NMb3c6IDEgLyogUE9TSVRJT05fTE9XICovLFxyXG4gICAgICAgICAgICB2ZXJ0ZXhVVjogNCAvKiBVViAqL1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBSZW5kZXJlciBvZiBpbWFnZSBwcmltaXRpdmVzLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW1hZ2VSZW5kZXJVbml0IGV4dGVuZHMgV29ybGRQcmltaXRpdmVSZW5kZXJVbml0IHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIHByaW1pdGl2ZVByb3ZpZGVyLCBwcm9ncmFtID0gY3JlYXRlRGVmYXVsdFByb2dyYW0oY29udGV4dCkpIHtcclxuICAgICAgICBzdXBlcihjb250ZXh0LCBSRU5ERVJfU1RBVEUsIHByb2dyYW0sIHByaW1pdGl2ZVByb3ZpZGVyKTtcclxuICAgICAgICB0aGlzLl9hdGxhc1NpemVVbmlmb3JtID0gdmVjMi5jcmVhdGUoMCwgMCk7XHJcbiAgICAgICAgY29udGV4dC5iaW5kUHJvZ3JhbShwcm9ncmFtKTtcclxuICAgICAgICBwcm9ncmFtLnNldEludFNjYWxhclVuaWZvcm0oJ2F0bGFzJywgMCk7XHJcbiAgICB9XHJcbiAgICBfcmVuZGVyQmF0Y2gobWVtb3J5QmF0Y2gpIHtcclxuICAgICAgICBjb25zdCBhdGxhcyA9IG1lbW9yeUJhdGNoLmZpcnN0UHJpbWl0aXZlLmF0bGFzO1xyXG4gICAgICAgIHRoaXMuX2F0bGFzU2l6ZVVuaWZvcm0ueCA9IGF0bGFzLndpZHRoO1xyXG4gICAgICAgIHRoaXMuX2F0bGFzU2l6ZVVuaWZvcm0ueSA9IGF0bGFzLmhlaWdodDtcclxuICAgICAgICBpZiAoYXRsYXMuaXNEaXJ0eSkge1xyXG4gICAgICAgICAgICBhdGxhcy5zeW5jVGV4dHVyZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9wcm9ncmFtLnNldFZlY3RvcjJVbmlmb3JtKCdhdGxhc1NpemUnLCB0aGlzLl9hdGxhc1NpemVVbmlmb3JtKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRUZXh0dXJlVW5pdCgwKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRUZXh0dXJlKGF0bGFzLnRleHR1cmUpO1xyXG4gICAgICAgIHN1cGVyLl9yZW5kZXJCYXRjaChtZW1vcnlCYXRjaCk7XHJcbiAgICB9XHJcbiAgICBfY2FuQmF0Y2hBZGphY2VudFByaW1pdGl2ZXMoYSwgYikge1xyXG4gICAgICAgIHJldHVybiBzdXBlci5fY2FuQmF0Y2hBZGphY2VudFByaW1pdGl2ZXMoYSwgYikgJiYgKGEuYXRsYXMgPT09IGIuYXRsYXMpO1xyXG4gICAgfVxyXG59XHJcbiIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleFBvc0hpZ2g7XFxuYXR0cmlidXRlIHZlYzIgdmVydGV4UG9zTG93O1xcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleFVWO1xcblxcbnVuaWZvcm0gdmVjMiBsb29rQXRIaWdoO1xcbnVuaWZvcm0gdmVjMiBsb29rQXRMb3c7XFxudW5pZm9ybSBtYXQ0IHZpZXdQcm9qTWF0cml4O1xcblxcbnZhcnlpbmcgdmVjMiB1djtcXG5cXG5jb25zdCBmbG9hdCBZVl9IID0gMS45OTk5Njk0ODI0MjE4NzU7XFxuY29uc3QgZmxvYXQgWVZfTCA9IDAuMDAwMDMwNTE3MTEyNDYzNzEyNjkyO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgdmVjNCBwb3NpdGlvbiA9IHZpZXdQcm9qTWF0cml4ICogdmVjNChcXG4gICAgICAgIFlWX0ggKiAodmVydGV4UG9zSGlnaCAtIGxvb2tBdEhpZ2gpICtcXG4gICAgICAgICAgICBZVl9MICogKHZlcnRleFBvc0xvdyAtIGxvb2tBdExvdyksXFxuICAgICAgICAwLFxcbiAgICAgICAgMVxcbiAgICApO1xcblxcbiAgICBnbF9Qb3NpdGlvbiA9IHBvc2l0aW9uO1xcblxcbiAgICB1diA9IHZlcnRleFVWO1xcbn1cXG5cIiIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbnVuaWZvcm0gc2FtcGxlcjJEIGF0bGFzO1xcbnVuaWZvcm0gdmVjMiBhdGxhc1NpemU7XFxuXFxudmFyeWluZyB2ZWMyIHV2O1xcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKGF0bGFzLCB1diAvIGF0bGFzU2l6ZSk7XFxuXFxuICAgIGlmIChnbF9GcmFnQ29sb3IuYSA9PSAwLjApIHtcXG4gICAgICAgIGRpc2NhcmQ7XFxuICAgIH1cXG59XFxuXCIiLCJpbXBvcnQgbW9kZWxWZXJ0ZXhTaGFkZXIgZnJvbSAnLi9zaGFkZXIvbW9kZWwudmVydCc7XHJcbmltcG9ydCBtb2RlbEZyYWdtZW50U2hhZGVyIGZyb20gJy4vc2hhZGVyL21vZGVsLmZyYWcnO1xyXG5pbXBvcnQgeyBjcmVhdGVFeHRlbnQyIH0gZnJvbSAnLi4vLi4vLi4vbWF0aC92ZWN0b3IyJztcclxuaW1wb3J0IE92ZXJsYXlSZW5kZXJlciBmcm9tICcuLi9vdmVybGF5L292ZXJsYXlfcmVuZGVyZXInO1xyXG5pbXBvcnQgUmVuZGVyU3RhdGUgZnJvbSAnLi4vLi4vLi4vcmVuZGVyL3N0YXRlJztcclxuaW1wb3J0IFdvcmxkUHJpbWl0aXZlUmVuZGVyVW5pdCBmcm9tICcuLi93b3JsZF9wcmltaXRpdmVfcmVuZGVyX3VuaXQnO1xyXG5jb25zdCBSRU5ERVJfU1RBVEUgPSBuZXcgUmVuZGVyU3RhdGUoe1xyXG4gICAgZGVwdGhUZXN0OiB0cnVlXHJcbn0pO1xyXG4vKipcclxuICogUmVuZGVyZXIgb2YgbW9kZWxzLiBJdCByZW5kZXJzIG1vZGVscyBpbnRvIGEgdGV4dHVyZSB3aXRoIGRlcHRoIHRlc3QgYW5kIHRoZW4gdGhpcyB0ZXh0dXJlIGludG8gdGhlIHJlbmRlciB0YXJnZXQuXHJcbiAqIEl0IGFsbG93cyB0byBzaG93IG9ubHkgdGhlIHRvcCBmYWNldHMgb2Ygc2VtaS10cmFuc3BhcmVudCBvYmplY3RzIHdpdGhvdXQgZXhwb3NpbmcgdGhlaXIgaW5uZXIgc3RydWN0dXJlLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW9kZWxSZW5kZXJVbml0IGV4dGVuZHMgV29ybGRQcmltaXRpdmVSZW5kZXJVbml0IHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIHByaW1pdGl2ZVByb3ZpZGVyKSB7XHJcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IGNvbnRleHQuY3JlYXRlUHJvZ3JhbShtb2RlbFZlcnRleFNoYWRlciwgbW9kZWxGcmFnbWVudFNoYWRlciwge1xyXG4gICAgICAgICAgICBhdHRyaWJNYXA6IHtcclxuICAgICAgICAgICAgICAgIHZlcnRleFBvc0hpZ2g6IDAgLyogUE9TSVRJT05fSElHSCAqLyxcclxuICAgICAgICAgICAgICAgIHZlcnRleFBvc0xvdzogMSAvKiBQT1NJVElPTl9MT1cgKi8sXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhIZWlnaHQ6IDMgLyogSEVJR0hUICovLFxyXG4gICAgICAgICAgICAgICAgdmVydGV4Q29sb3I6IDcgLyogQ09MT1IgKi9cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHN1cGVyKGNvbnRleHQsIFJFTkRFUl9TVEFURSwgcHJvZ3JhbSwgcHJpbWl0aXZlUHJvdmlkZXIpO1xyXG4gICAgICAgIHRoaXMuX291dHB1dFNpemUgPSBjcmVhdGVFeHRlbnQyKC0xLCAtMSk7XHJcbiAgICAgICAgdGhpcy5fb3ZlcmxheVJlbmRlcmVyID0gbmV3IE92ZXJsYXlSZW5kZXJlcihjb250ZXh0KTtcclxuICAgIH1cclxuICAgIHJlbmRlcih0YXJnZXQsIHZpZXdQcm9qTWF0cml4LCBjYW1lcmFQb3NpdGlvbnMpIHtcclxuICAgICAgICB0aGlzLl9zeW5jT3V0cHV0QnVmZmVyKHRhcmdldCk7XHJcbiAgICAgICAgc3VwZXIucmVuZGVyKHRoaXMuX291dHB1dEJ1ZmZlciwgdmlld1Byb2pNYXRyaXgsIGNhbWVyYVBvc2l0aW9ucyk7XHJcbiAgICAgICAgLy8gZG8gbm90IHJ1biB1bm5lY2Vzc2FyeSBjb3B5aW5nIGlmIHRoaXMuX291dHB1dEJ1ZmZlciB3YXMgbm90IHVwZGF0ZWQgKG5vIG1vZGVscyBpbiBzY2VuZT8pXHJcbiAgICAgICAgaWYgKCF0aGlzLl9vdXRwdXRCdWZmZXIuaXNDbGVhcikge1xyXG4gICAgICAgICAgICAvLyBjb3B5IGludG8gdGhlIGZpbmFsIHRhcmdldFxyXG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5UmVuZGVyZXIucmVuZGVyKHRhcmdldCwgdGhpcy5fb3V0cHV0VGV4dHVyZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLl9vdmVybGF5UmVuZGVyZXIuZGVzdHJveSgpO1xyXG4gICAgICAgIGlmICh0aGlzLl9vdXRwdXRUZXh0dXJlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX291dHB1dFRleHR1cmUuZGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fb3V0cHV0RGVwdGhCdWZmZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5fb3V0cHV0RGVwdGhCdWZmZXIuZGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fb3V0cHV0QnVmZmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX291dHB1dEJ1ZmZlci5kZXN0cm95KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcclxuICAgIH1cclxuICAgIF9zeW5jT3V0cHV0QnVmZmVyKHRhcmdldCkge1xyXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgaW50ZXJtZWRpYXRlIHRleHR1cmUgZml0cyB0aGUgb3V0cHV0IHRhcmdldFxyXG4gICAgICAgIGlmICh0aGlzLl9vdXRwdXRTaXplLndpZHRoICE9PSB0YXJnZXQuZ2V0V2lkdGgoKSB8fFxyXG4gICAgICAgICAgICB0aGlzLl9vdXRwdXRTaXplLmhlaWdodCAhPT0gdGFyZ2V0LmdldEhlaWdodCgpKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9vdXRwdXRUZXh0dXJlIHx8IHRoaXMuX291dHB1dERlcHRoQnVmZmVyIHx8IHRoaXMuX291dHB1dEJ1ZmZlcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fb3V0cHV0VGV4dHVyZS5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9vdXRwdXREZXB0aEJ1ZmZlci5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9vdXRwdXRCdWZmZXIuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX291dHB1dFNpemUgPSB7IHdpZHRoOiB0YXJnZXQuZ2V0V2lkdGgoKSwgaGVpZ2h0OiB0YXJnZXQuZ2V0SGVpZ2h0KCkgfTtcclxuICAgICAgICAgICAgdGhpcy5fb3V0cHV0VGV4dHVyZSA9IHRoaXMuX2NvbnRleHQuY3JlYXRlRW1wdHkyRFRleHR1cmUodGhpcy5fb3V0cHV0U2l6ZS53aWR0aCwgdGhpcy5fb3V0cHV0U2l6ZS5oZWlnaHQsIDY0MDggLyogUkdCQSAqLywgNTEyMSAvKiBVTlNJR05FRF9CWVRFICovKTtcclxuICAgICAgICAgICAgdGhpcy5fb3V0cHV0RGVwdGhCdWZmZXIgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZVJlbmRlcmJ1ZmZlcih0aGlzLl9vdXRwdXRTaXplLndpZHRoLCB0aGlzLl9vdXRwdXRTaXplLmhlaWdodCwgMzQwNDEgLyogREVQVEhfU1RFTkNJTCAqLyk7XHJcbiAgICAgICAgICAgIHRoaXMuX291dHB1dEJ1ZmZlciA9IHRoaXMuX2NvbnRleHQuY3JlYXRlRnJhbWVidWZmZXIoe1xyXG4gICAgICAgICAgICAgICAgY29sb3I6IHRoaXMuX291dHB1dFRleHR1cmUsXHJcbiAgICAgICAgICAgICAgICBkZXB0aFN0ZW5jaWw6IHRoaXMuX291dHB1dERlcHRoQnVmZmVyXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT3ZlcnJpZGRlbiBfYmluZFJlbmRlclRhcmdldCgpIHRvIGJpbmQgaW50ZXJtZWRpYXRlIHJlbmRlciB0YXJnZXQgdG8gcmVuZGVyIG1vZGVscyBpbnRvIGFuZFxyXG4gICAgICogbGF0ZXIgcHV0IGl0cyBjb250ZW50IGludG8gdGhlIGZpbmFsIHRhcmdldC5cclxuICAgICAqL1xyXG4gICAgX3ByZXBhcmVSZW5kZXJUYXJnZXQodGFyZ2V0LCB2aWV3UHJvak1hdHJpeCwgY2FtZXJhUG9zaXRpb25zKSB7XHJcbiAgICAgICAgc3VwZXIuX3ByZXBhcmVSZW5kZXJUYXJnZXQodGFyZ2V0LCB2aWV3UHJvak1hdHJpeCwgY2FtZXJhUG9zaXRpb25zKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmNsZWFyQ3VycmVudFRhcmdldCgxNjM4NCAvKiBDT0xPUl9CVUZGRVJfQklUICovIHwgMjU2IC8qIERFUFRIX0JVRkZFUl9CSVQgKi8pO1xyXG4gICAgfVxyXG59XHJcbiIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbmF0dHJpYnV0ZSB2ZWMzIHZlcnRleFBvc0hpZ2g7XFxuYXR0cmlidXRlIHZlYzMgdmVydGV4UG9zTG93O1xcbmF0dHJpYnV0ZSBmbG9hdCB2ZXJ0ZXhIZWlnaHQ7XFxuYXR0cmlidXRlIHZlYzQgdmVydGV4Q29sb3I7XFxuXFxudW5pZm9ybSB2ZWMyIGxvb2tBdEhpZ2g7XFxudW5pZm9ybSB2ZWMyIGxvb2tBdExvdztcXG51bmlmb3JtIG1hdDQgdmlld1Byb2pNYXRyaXg7XFxuXFxudmFyeWluZyB2ZWM0IGdsb2JhbFBvcztcXG52YXJ5aW5nIHZlYzQgZGlmZnVzZUNvbG9yO1xcblxcbmNvbnN0IGZsb2F0IFlWX0ggPSAxLjk5OTk2OTQ4MjQyMTg3NTtcXG5jb25zdCBmbG9hdCBZVl9MID0gMC4wMDAwMzA1MTcxMTI0NjM3MTI2OTI7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gICAgZ2xvYmFsUG9zID0gdmVjNChcXG4gICAgICAgIFlWX0ggKiAodmVydGV4UG9zSGlnaC54eSAtIGxvb2tBdEhpZ2gpICsgWVZfTCAqICh2ZXJ0ZXhQb3NMb3cueHkgLSBsb29rQXRMb3cpLFxcbiAgICAgICAgdmVydGV4SGVpZ2h0LFxcbiAgICAgICAgMVxcbiAgICApO1xcblxcbiAgICBnbF9Qb3NpdGlvbiA9IHZpZXdQcm9qTWF0cml4ICogZ2xvYmFsUG9zO1xcbiAgICBkaWZmdXNlQ29sb3IgPSB2ZXJ0ZXhDb2xvcjtcXG59XFxuXCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiI3ZlcnNpb24gMTAwXFxuXFxuI2V4dGVuc2lvbiBHTF9PRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMgOiByZXF1aXJlXFxuXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG52YXJ5aW5nIHZlYzQgZGlmZnVzZUNvbG9yO1xcbnZhcnlpbmcgdmVjNCBnbG9iYWxQb3M7XFxuXFxuY29uc3QgdmVjMyBMSUdIVF9ESVJFQ1RJT04gPSBub3JtYWxpemUodmVjMygwLjUsIDAuNSwgMS4wKSk7XFxuY29uc3QgZmxvYXQgTElHSFRfSU5URU5TSVRZID0gMC4zO1xcbmNvbnN0IGZsb2F0IEFNQklFTlRfTElHSFRfSU5URU5TSVRZID0gMS4wIC0gTElHSFRfSU5URU5TSVRZO1xcbmNvbnN0IGZsb2F0IEhPUklaT05UQUxfUExBTkVfRElGRlVTRV9JTlRFTlNJVFkgPVxcbiAgICBBTUJJRU5UX0xJR0hUX0lOVEVOU0lUWSArIDAuNSAqIExJR0hUX0lOVEVOU0lUWSAqIChMSUdIVF9ESVJFQ1RJT04ueiArIDEuMCk7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gICAgdmVjMyBwb3MgPSBnbG9iYWxQb3MueHl6O1xcblxcbiAgICB2ZWMzIGR4cG9zID0gbm9ybWFsaXplKGRGZHgocG9zKSk7XFxuICAgIHZlYzMgZHlwb3MgPSBub3JtYWxpemUoZEZkeShwb3MpKTtcXG4gICAgdmVjMyBub3JtYWwgPSBub3JtYWxpemUoY3Jvc3MoZHhwb3MsIGR5cG9zKSk7XFxuXFxuICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoXFxuICAgICAgICBkaWZmdXNlQ29sb3IucmdiICogKEFNQklFTlRfTElHSFRfSU5URU5TSVRZICsgMC41ICogTElHSFRfSU5URU5TSVRZICogKGRvdChub3JtYWwsIExJR0hUX0RJUkVDVElPTikgKyAxLjApKSAvXFxuICAgICAgICAgICAgSE9SSVpPTlRBTF9QTEFORV9ESUZGVVNFX0lOVEVOU0lUWSxcXG4gICAgICAgIGRpZmZ1c2VDb2xvci5hXFxuICAgICk7XFxufVxcblwiIiwiaW1wb3J0IG92ZXJsYXlWZXJ0ZXhTaGFkZXIgZnJvbSAnLi9zaGFkZXIvb3ZlcmxheS52ZXJ0JztcclxuaW1wb3J0IG92ZXJsYXlGcmFnbWVudFNoYWRlciBmcm9tICcuL3NoYWRlci9vdmVybGF5LmZyYWcnO1xyXG5pbXBvcnQgeyBHbFJlbmRlcmVyIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyL2dsX3JlbmRlcmVyJztcclxuaW1wb3J0IFJlbmRlclN0YXRlIGZyb20gJy4uLy4uLy4uL3JlbmRlci9zdGF0ZSc7XHJcbmltcG9ydCB7IEJMRU5EX09WRVJfUkVOREVSX1NUQVRFIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyL3N0YXRlJztcclxuY29uc3QgUkVOREVSX1NUQVRFID0gbmV3IFJlbmRlclN0YXRlKEJMRU5EX09WRVJfUkVOREVSX1NUQVRFKTtcclxuLyoqXHJcbiAqIFJlbmRlcnMgYSB0ZXh0dXJlIGludG8gYSByZW5kZXIgdGFyZ2V0IHdpdGggT1ZFUiBjb21wb3NpdGluZy4gVGhlIHRleHR1cmUgd2lsbCBjb21wbGV0ZWx5IG92ZXJsYXkgdGhlIHRhcmdldCwgaS5lLlxyXG4gKiBpdCBpcyBzdHJldGNoZWQvc2hyaW5rZWQgdG8gZml0IHRoZSB0YXJnZXQgd2lkdGgvaGVpZ2h0LCBzbyBpZGVhbGx5IHRoZXkgc2hvdWxkIGhhdmUgdGhlIHNhbWUgZGltZW5zaW9ucy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE92ZXJsYXlSZW5kZXJlciBleHRlbmRzIEdsUmVuZGVyZXIge1xyXG4gICAgY29uc3RydWN0b3IoY29udGV4dCkge1xyXG4gICAgICAgIGNvbnN0IHByb2dyYW0gPSBjb250ZXh0LmNyZWF0ZVByb2dyYW0ob3ZlcmxheVZlcnRleFNoYWRlciwgb3ZlcmxheUZyYWdtZW50U2hhZGVyLCB7XHJcbiAgICAgICAgICAgIGF0dHJpYk1hcDoge1xyXG4gICAgICAgICAgICAgICAgdmVydGV4UG9zaXRpb246IDAgLyogUE9TSVRJT04gKi8sXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhVVjogNCAvKiBVViAqL1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc3VwZXIoY29udGV4dCwgUkVOREVSX1NUQVRFLCBwcm9ncmFtKTtcclxuICAgIH1cclxuICAgIF9yZW5kZXIodGV4dHVyZSkge1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFRleHR1cmVVbml0KDApO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFRleHR1cmUodGV4dHVyZSk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kUXVhZFZhbygpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuZHJhd1F1YWQoKTtcclxuICAgIH1cclxufVxyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiI3ZlcnNpb24gMTAwXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhQb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhVVjtcXG5cXG52YXJ5aW5nIHZlYzIgdXY7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICBnbF9Qb3NpdGlvbiA9IHZlYzQodmVydGV4UG9zaXRpb24sIDAsIDEpO1xcbiAgICB1diA9IHZlcnRleFVWO1xcbn1cXG5cIiIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHRleHR1cmU7XFxuXFxudmFyeWluZyB2ZWMyIHV2O1xcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHRleHR1cmUsIHV2KTtcXG59XFxuXCIiLCJpbXBvcnQgdGV4dHVyZWRQb2x5bGluZVZlcnRleFNoYWRlciBmcm9tICcuL3NoYWRlci90ZXh0dXJlZF9wb2x5bGluZS52ZXJ0JztcclxuaW1wb3J0IHRleHR1cmVkUG9seWxpbmVGcmFnbWVudFNoYWRlciBmcm9tICcuL3NoYWRlci90ZXh0dXJlZF9wb2x5bGluZS5mcmFnJztcclxuaW1wb3J0ICogYXMgdmVjMiBmcm9tICcuLi8uLi8uLi9tYXRoL3ZlY3RvcjInO1xyXG5pbXBvcnQgUmVuZGVyU3RhdGUsIHsgQkxFTkRfT1ZFUl9QUkVNVUxUSVBMSUVEX0FMUEhBX1JFTkRFUl9TVEFURSB9IGZyb20gJy4uLy4uLy4uL3JlbmRlci9zdGF0ZSc7XHJcbmltcG9ydCBCYXNlUG9seWxpbmVSZW5kZXJVbml0IGZyb20gJy4vYmFzZV9wb2x5bGluZV9yZW5kZXJfdW5pdCc7XHJcbmNvbnN0IEZJTFRFUl9SQURJVVMgPSAxLjAgLyBkZXZpY2VQaXhlbFJhdGlvO1xyXG5jb25zdCBSRU5ERVJfU1RBVEUgPSBuZXcgUmVuZGVyU3RhdGUoQkxFTkRfT1ZFUl9QUkVNVUxUSVBMSUVEX0FMUEhBX1JFTkRFUl9TVEFURSwge1xyXG4gICAgZGVwdGhUZXN0OiB0cnVlLFxyXG4gICAgZGVwdGhNYXNrOiBmYWxzZSxcclxuICAgIGRlcHRoRnVuYzogNTE4IC8qIEdSRUFURVJfT1JfRVFVQUwgKi9cclxufSk7XHJcbi8qKlxyXG4gKiBSZW5kZXJlciBvZiBwb2x5bGluZSBwcmltaXRpdmVzLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGV4dHVyZWRQb2x5bGluZVJlbmRlclVuaXQgZXh0ZW5kcyBCYXNlUG9seWxpbmVSZW5kZXJVbml0IHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIGNhbWVyYSwgcHJpbWl0aXZlUHJvdmlkZXIpIHtcclxuICAgICAgICBjb25zdCBwcm9ncmFtID0gY29udGV4dC5jcmVhdGVQcm9ncmFtKHRleHR1cmVkUG9seWxpbmVWZXJ0ZXhTaGFkZXIsIHRleHR1cmVkUG9seWxpbmVGcmFnbWVudFNoYWRlciwge1xyXG4gICAgICAgICAgICBkZWZpbmVzOiB7XHJcbiAgICAgICAgICAgICAgICBGSUxURVJfUkFESVVTOiBgZmxvYXQoJHtGSUxURVJfUkFESVVTfSlgXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGF0dHJpYk1hcDoge1xyXG4gICAgICAgICAgICAgICAgdmVydGV4UG9zSGlnaDogMCAvKiBQT1NJVElPTl9ISUdIICovLFxyXG4gICAgICAgICAgICAgICAgdmVydGV4UG9zTG93OiAxIC8qIFBPU0lUSU9OX0xPVyAqLyxcclxuICAgICAgICAgICAgICAgIHZlcnRleERpc3BsYWNlbWVudDogNiAvKiBESVNQTEFDRU1FTlQgKi8sXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhVVjogNCAvKiBVViAqLyxcclxuICAgICAgICAgICAgICAgIHZlcnRleFpJbmRleDogOSAvKiBQUklPUklUWSAqLyxcclxuICAgICAgICAgICAgICAgIHZlcnRleEhhbGZXaWR0aDogMTEgLyogQVVYICovLFxyXG4gICAgICAgICAgICAgICAgdmVydGV4UGF0dGVybjogMTIgLyogQVVYMSAqLyxcclxuICAgICAgICAgICAgICAgIHZlcnRleFBhdHRlcm5IYWxmSGVpZ2h0OiAxMyAvKiBBVVgyICovXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBzdXBlcihjb250ZXh0LCBSRU5ERVJfU1RBVEUsIHByb2dyYW0sIHByaW1pdGl2ZVByb3ZpZGVyLCBjYW1lcmEpO1xyXG4gICAgICAgIHRoaXMuX2F0bGFzU2l6ZVVuaWZvcm0gPSB2ZWMyLmNyZWF0ZSgwLCAwKTtcclxuICAgICAgICBjb250ZXh0LmJpbmRQcm9ncmFtKHByb2dyYW0pO1xyXG4gICAgICAgIHByb2dyYW0uc2V0SW50U2NhbGFyVW5pZm9ybSgnYXRsYXMnLCAwKTtcclxuICAgIH1cclxuICAgIF9yZW5kZXJCYXRjaChtZW1vcnlCYXRjaCkge1xyXG4gICAgICAgIGNvbnN0IGF0bGFzID0gbWVtb3J5QmF0Y2guZmlyc3RQcmltaXRpdmUuYXRsYXM7XHJcbiAgICAgICAgdGhpcy5fYXRsYXNTaXplVW5pZm9ybS54ID0gYXRsYXMud2lkdGg7XHJcbiAgICAgICAgdGhpcy5fYXRsYXNTaXplVW5pZm9ybS55ID0gYXRsYXMuaGVpZ2h0O1xyXG4gICAgICAgIGlmIChhdGxhcy5pc0RpcnR5KSB7XHJcbiAgICAgICAgICAgIGF0bGFzLnN5bmNUZXh0dXJlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3Byb2dyYW0uc2V0VmVjdG9yMlVuaWZvcm0oJ2F0bGFzU2l6ZScsIHRoaXMuX2F0bGFzU2l6ZVVuaWZvcm0pO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFRleHR1cmVVbml0KDApO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFRleHR1cmUoYXRsYXMudGV4dHVyZSk7XHJcbiAgICAgICAgc3VwZXIuX3JlbmRlckJhdGNoKG1lbW9yeUJhdGNoKTtcclxuICAgIH1cclxuICAgIF9jYW5CYXRjaEFkamFjZW50UHJpbWl0aXZlcyhhLCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIHN1cGVyLl9jYW5CYXRjaEFkamFjZW50UHJpbWl0aXZlcyhhLCBiKSAmJiAoYS5hdGxhcyA9PT0gYi5hdGxhcyk7XHJcbiAgICB9XHJcbn1cclxuIiwibW9kdWxlLmV4cG9ydHMgPSBcIiN2ZXJzaW9uIDEwMFxcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxuI2lmbmRlZiBGSUxURVJfUkFESVVTXFxuIyAgIGVycm9yIEZJTFRFUl9SQURJVVMgbXVzdCBiZSBzZXRcXG4jZW5kaWZcXG5cXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhQb3NIaWdoO1xcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleFBvc0xvdztcXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhEaXNwbGFjZW1lbnQ7XFxuYXR0cmlidXRlIHZlYzIgdmVydGV4VVY7XFxuYXR0cmlidXRlIGZsb2F0IHZlcnRleEhhbGZXaWR0aDtcXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhQYXR0ZXJuO1xcbmF0dHJpYnV0ZSBmbG9hdCB2ZXJ0ZXhQYXR0ZXJuSGFsZkhlaWdodDtcXG5hdHRyaWJ1dGUgZmxvYXQgdmVydGV4WkluZGV4O1xcblxcbnVuaWZvcm0gdmVjMiBsb29rQXRIaWdoO1xcbnVuaWZvcm0gdmVjMiBsb29rQXRMb3c7XFxudW5pZm9ybSBtYXQ0IHZpZXdQcm9qTWF0cml4O1xcbnVuaWZvcm0gZmxvYXQgd29ybGRUb1B4RmFjdG9yO1xcblxcbnZhcnlpbmcgdmVjMiB1djtcXG52YXJ5aW5nIGZsb2F0IHM7XFxudmFyeWluZyBmbG9hdCBwYXR0ZXJuTGVuZ3RoO1xcbnZhcnlpbmcgZmxvYXQgbGVuO1xcbnZhcnlpbmcgZmxvYXQgaGFsZldpZHRoO1xcbnZhcnlpbmcgZmxvYXQgZXh0SGFsZldpZHRoO1xcbnZhcnlpbmcgZmxvYXQgcGF0dGVybkhhbGZIZWlnaHQ7XFxuXFxuY29uc3QgZmxvYXQgWVZfSCA9IDEuOTk5OTY5NDgyNDIxODc1O1xcbmNvbnN0IGZsb2F0IFlWX0wgPSAwLjAwMDAzMDUxNzExMjQ2MzcxMjY5MjtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgICBoYWxmV2lkdGggPSB2ZXJ0ZXhIYWxmV2lkdGg7XFxuICAgIGV4dEhhbGZXaWR0aCA9IGhhbGZXaWR0aCArIEZJTFRFUl9SQURJVVM7XFxuXFxuICAgIHZlYzQgcG9zaXRpb24gPSB2aWV3UHJvak1hdHJpeCAqIHZlYzQoXFxuICAgICAgICBZVl9IICogKHZlcnRleFBvc0hpZ2ggLSBsb29rQXRIaWdoKSArXFxuICAgICAgICAgICAgWVZfTCAqICh2ZXJ0ZXhQb3NMb3cgLSBsb29rQXRMb3cpICtcXG4gICAgICAgICAgICAgICAgd29ybGRUb1B4RmFjdG9yICogZXh0SGFsZldpZHRoICogdmVydGV4RGlzcGxhY2VtZW50LFxcbiAgICAgICAgMCxcXG4gICAgICAgIDFcXG4gICAgKTtcXG5cXG4gICAgcG9zaXRpb24ueHkgLz0gcG9zaXRpb24udztcXG4gICAgcG9zaXRpb24ueiA9IHZlcnRleFpJbmRleDtcXG4gICAgcG9zaXRpb24udyA9IDEuMDtcXG5cXG4gICAgZ2xfUG9zaXRpb24gPSBwb3NpdGlvbjtcXG5cXG4gICAgcGF0dGVybkxlbmd0aCA9IHZlcnRleFBhdHRlcm5bMF07XFxuICAgIGxlbiA9IHZlcnRleFBhdHRlcm5bMV07XFxuICAgIC8vIERpc3RhbmNlIHRvIHRoZSBhbmFseXRpY2FsIGxpbmUgYWxvbmcgc2VnbWVudCdzIG5vcm1hbFxcbiAgICBzID0gc2lnbih2ZXJ0ZXhQYXR0ZXJuSGFsZkhlaWdodCkgKiBleHRIYWxmV2lkdGg7XFxuICAgIC8vIFRoZSB3aG9sZSB0ZXh0dXJlIGlzIGJlaW5nIHNhbXBsZWQgdG8gdGhlIG9yaWdpbmFsIGdlb21ldHJ5LiBGb3IgcGl4ZWxzIGluIHRoZSBleHRlbmRlZCBwb2x5bGluZSBwYXJ0IHRoZSB0b3Btb3N0XFxuICAgIC8vIChib3R0b21tb3N0KSB0ZXhlbHMgYXJlIHRha2VuLiBUbyBtYWtlIHRoaXMgaGFwcGVuIHRoZSBVViB0ZXh0dXJlIGNvb3JkaW5hdGVzIGFyZSBleHRlbmRlZCBpbiBwcm9wb3J0aW9uIHRvIHRoZVxcbiAgICAvLyBwb2x5bGluZSB3aWR0aCBleHRlbnNpb24uXFxuICAgIHBhdHRlcm5IYWxmSGVpZ2h0ID0gYWJzKHZlcnRleFBhdHRlcm5IYWxmSGVpZ2h0KTtcXG4gICAgdXYgPSB2ZWMyKHZlcnRleFVWLngsIHZlcnRleFVWLnkgLSB2ZXJ0ZXhQYXR0ZXJuSGFsZkhlaWdodCAqIEZJTFRFUl9SQURJVVMgLyBoYWxmV2lkdGgpO1xcbn1cXG5cIiIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG5cXG4jaWZuZGVmIEZJTFRFUl9SQURJVVNcXG4jICAgZXJyb3IgRklMVEVSX1JBRElVUyBtdXN0IGJlIHNldFxcbiNlbmRpZlxcblxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgYXRsYXM7XFxudW5pZm9ybSB2ZWMyIGF0bGFzU2l6ZTtcXG5cXG52YXJ5aW5nIHZlYzIgdXY7XFxudmFyeWluZyBmbG9hdCBzO1xcbnZhcnlpbmcgZmxvYXQgcGF0dGVybkxlbmd0aDtcXG52YXJ5aW5nIGZsb2F0IGxlbjtcXG52YXJ5aW5nIGZsb2F0IGhhbGZXaWR0aDtcXG52YXJ5aW5nIGZsb2F0IGV4dEhhbGZXaWR0aDtcXG52YXJ5aW5nIGZsb2F0IHBhdHRlcm5IYWxmSGVpZ2h0O1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIGxvd3AgZmxvYXQgYWxwaGEgPSBzbW9vdGhzdGVwKDAuMCwgRklMVEVSX1JBRElVUyArIG1pbihGSUxURVJfUkFESVVTLCBleHRIYWxmV2lkdGgpLCBleHRIYWxmV2lkdGggLSBhYnMocykpO1xcblxcbiAgICAvLyBDbGFtcCB0ZXh0dXJlIFUgY29vcmRpbmF0ZSBieSAwLjVweCBmcm9tIGJvdGggc2lkZXMgdG8gYXZvaWQgYmxlZWRpbmcuXFxuICAgIHZlYzIgdXZBZGp1c3RlZCA9IHZlYzIodXYueCArIGNsYW1wKG1vZChsZW4sIHBhdHRlcm5MZW5ndGgpLCAwLjUsIHBhdHRlcm5MZW5ndGggLSAwLjUpLCB1di55KTtcXG4gICAgLy8gVVYgdGV4dHVyZSBjb29yZGluYXRlcyBoYXZlIGJlZW4gZXh0ZW5kZWQgaW4gcHJvcG9ydGlvbiB0byB0aGUgcG9seWxpbmUgd2lkdGggZXh0ZW5zaW9uLlxcbiAgICAvLyBDbGFtcCB0ZXh0dXJlIFYgY29vcmRpbmF0ZSB0byB0aGUgb3JpZ2luYWwgZ2VvbWV0cnkgbWludXMgMC41cHggdG8gYXZvaWQgYmxlZWRpbmcuXFxuICAgIGZsb2F0IHBhdHRlcm5Ub0dlb21ldHJ5RmFjdG9yID0gaGFsZldpZHRoIC8gcGF0dGVybkhhbGZIZWlnaHQ7XFxuICAgIGZsb2F0IGNsYW1wVG8gPSBoYWxmV2lkdGggLSAwLjUgKiBwYXR0ZXJuVG9HZW9tZXRyeUZhY3RvcjtcXG4gICAgaWYgKHN0ZXAoY2xhbXBUbywgYWJzKHMpKSA9PSAxLikge1xcbiAgICAgICAgZmxvYXQgZGVsdGEgPSBzIC0gY2xhbXAocywgLWNsYW1wVG8sIGNsYW1wVG8pO1xcbiAgICAgICAgdXZBZGp1c3RlZC55ICs9IGRlbHRhIC8gcGF0dGVyblRvR2VvbWV0cnlGYWN0b3I7XFxuICAgIH1cXG5cXG4gICAgbG93cCB2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKGF0bGFzLCB1dkFkanVzdGVkIC8gYXRsYXNTaXplKTtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gY29sb3IgKiBhbHBoYTtcXG59XFxuXCIiLCJpbXBvcnQgV29ybGRQcmltaXRpdmVSZW5kZXJVbml0IGZyb20gJy4uL3dvcmxkX3ByaW1pdGl2ZV9yZW5kZXJfdW5pdCc7XHJcbi8qKlxyXG4gKiBCYXNlIHJlbmRlcmVyIG9mIHBvbHlsaW5lIHByaW1pdGl2ZXMuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNlUG9seWxpbmVSZW5kZXJVbml0IGV4dGVuZHMgV29ybGRQcmltaXRpdmVSZW5kZXJVbml0IHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIHJlbmRlclN0YXRlLCBwcm9ncmFtLCBwcmltaXRpdmVQcm92aWRlciwgY2FtZXJhKSB7XHJcbiAgICAgICAgc3VwZXIoY29udGV4dCwgcmVuZGVyU3RhdGUsIHByb2dyYW0sIHByaW1pdGl2ZVByb3ZpZGVyKTtcclxuICAgICAgICB0aGlzLl9jYW1lcmEgPSBjYW1lcmE7XHJcbiAgICB9XHJcbiAgICBfcHJlcGFyZVByb2dyYW0ocHJvZ3JhbSwgdmlld1Byb2pNYXRyaXgsIGNhbWVyYVBvc2l0aW9ucykge1xyXG4gICAgICAgIHN1cGVyLl9wcmVwYXJlUHJvZ3JhbShwcm9ncmFtLCB2aWV3UHJvak1hdHJpeCwgY2FtZXJhUG9zaXRpb25zKTtcclxuICAgICAgICBwcm9ncmFtLnNldFNjYWxhclVuaWZvcm0oJ3dvcmxkVG9QeEZhY3RvcicsIHRoaXMuX2NhbWVyYS53b3JsZFRvUHhGYWN0b3IpO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IE1BWF9IQUxGX1dJRFRILCBNQVhfRklMTF9HQVAgfSBmcm9tICcuLi8uLi8uLi9wcmltaXRpdmUvcG9seWxpbmUvcG9seWxpbmVfYnVmZmVyX3dyaXRlcic7XHJcbmltcG9ydCBwb2x5bGluZVZlcnRleFNoYWRlciBmcm9tICcuL3NoYWRlci9wb2x5bGluZS52ZXJ0JztcclxuaW1wb3J0IHBvbHlsaW5lRnJhZ21lbnRTaGFkZXIgZnJvbSAnLi9zaGFkZXIvcG9seWxpbmUuZnJhZyc7XHJcbmltcG9ydCBCYXNlUG9seWxpbmVSZW5kZXJVbml0IGZyb20gJy4vYmFzZV9wb2x5bGluZV9yZW5kZXJfdW5pdCc7XHJcbmltcG9ydCBSZW5kZXJTdGF0ZSBmcm9tICcuLi8uLi8uLi9yZW5kZXIvc3RhdGUnO1xyXG4vLyBWYWx1ZXMgd2FzIGNob3NlbiBieSB0ZWFtIGNvbnNlbnN1cyBpbiBWRUNUT1ItMTk3XHJcbmNvbnN0IEZJTFRFUl9SQURJVVMgPSAxLjAgLyBkZXZpY2VQaXhlbFJhdGlvOyAvLyBweFxyXG5leHBvcnQgY29uc3QgREVGQVVMVF9SRU5ERVJfU1RBVEVfUEFSQU1TID0ge1xyXG4gICAgYmxlbmQ6IHRydWUsXHJcbiAgICBibGVuZEZ1bmNTcmNSZ2I6IDEgLyogT05FICovLFxyXG4gICAgYmxlbmRGdW5jRHN0UmdiOiA3NzEgLyogT05FX01JTlVTX1NSQ19BTFBIQSAqLyxcclxuICAgIGJsZW5kRnVuY1NyY0FscGhhOiAxIC8qIE9ORSAqLyxcclxuICAgIGJsZW5kRnVuY0RzdEFscGhhOiA3NzEgLyogT05FX01JTlVTX1NSQ19BTFBIQSAqL1xyXG59O1xyXG4vKipcclxuICogUmVuZGVyZXIgb2YgcG9seWxpbmUgcHJpbWl0aXZlcy4gSXRzIGRlZmF1bHQgcmVuZGVyIHN0YXRlIGlzIGFpbWVkIHRvIHJlbmRlciBvcGFxdWUgcG9seWxpbmVzLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9seWxpbmVSZW5kZXJVbml0IGV4dGVuZHMgQmFzZVBvbHlsaW5lUmVuZGVyVW5pdCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBjYW1lcmEsIHByaW1pdGl2ZVByb3ZpZGVyLCByZW5kZXJTdGF0ZSA9IG5ldyBSZW5kZXJTdGF0ZShERUZBVUxUX1JFTkRFUl9TVEFURV9QQVJBTVMpKSB7XHJcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IGNvbnRleHQuY3JlYXRlUHJvZ3JhbShwb2x5bGluZVZlcnRleFNoYWRlciwgcG9seWxpbmVGcmFnbWVudFNoYWRlciwge1xyXG4gICAgICAgICAgICBkZWZpbmVzOiB7XHJcbiAgICAgICAgICAgICAgICBGSUxURVJfUkFESVVTOiBgZmxvYXQoJHtGSUxURVJfUkFESVVTfSlgLFxyXG4gICAgICAgICAgICAgICAgTUFYX0hBTEZfV0lEVEg6IGBmbG9hdCgke01BWF9IQUxGX1dJRFRIfSlgLFxyXG4gICAgICAgICAgICAgICAgTUFYX0ZJTExfR0FQOiBgZmxvYXQoJHtNQVhfRklMTF9HQVB9KWBcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYXR0cmliTWFwOiB7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhQb3M6IDAgLyogUE9TSVRJT04gKi8sXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhOb3JtYWxQYWNrZWQ6IDUgLyogTk9STUFMICovLFxyXG4gICAgICAgICAgICAgICAgdmVydGV4VXZQYWNrZWQ6IDQgLyogVVYgKi8sXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhXaWR0aEZpbGxHYXA6IDExIC8qIEFVWCAqLyxcclxuICAgICAgICAgICAgICAgIHZlcnRleENvbG9yOiA3IC8qIENPTE9SICovLFxyXG4gICAgICAgICAgICAgICAgdmVydGV4TWl0ZXI6IDEyIC8qIEFVWDEgKi8sXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhWTGltaXQ6IDEzIC8qIEFVWDIgKi8sXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhMZW5ndGg6IDE0IC8qIEFVWDMgKi9cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHN1cGVyKGNvbnRleHQsIHJlbmRlclN0YXRlLCBwcm9ncmFtLCBwcmltaXRpdmVQcm92aWRlciwgY2FtZXJhKTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgKiBhcyB2ZWMyIGZyb20gJy4uLy4uL21hdGgvdmVjdG9yMic7XHJcbmltcG9ydCB7IGVuY29kZVJnYmE4IH0gZnJvbSAnLi4vLi4vdXRpbC9jb2xvcic7XHJcbmltcG9ydCBCdWZmZXJXcml0ZXIgZnJvbSAnLi4vLi4vdXRpbC9idWZmZXJfd3JpdGVyJztcclxuaW1wb3J0IHsgUE9MWUxJTkVfQVRUUklCVVRFX01BUFBJTkcgfSBmcm9tICcuL3BvbHlsaW5lX2F0dHJpYnV0ZV9tYXBwaW5nJztcclxuaW1wb3J0IHsgZmxvYXRUb1VpbnQ4LCBmbG9hdFRvVWludDE2IH0gZnJvbSAnLi4vLi4vdXRpbC9ncHV0eXBlcyc7XHJcbmltcG9ydCB7IGludFRvWkluZGV4IH0gZnJvbSAnLi4vLi4vdXRpbC96X2luZGV4JztcclxuaW1wb3J0IHsgY2xhbXAgfSBmcm9tICcuLi8uLi9tYXRoL3NjYWxhcic7XHJcbi8qKlxyXG4gKiBDb21wdXRlcyBtaXRlciBvZiBhIGpvaW4gYmV0d2VlbiB0d28gc2VnbWVudHMuXHJcbiAqXHJcbiAqIEBwYXJhbSBuMSBOb3JtYWwgdmVjdG9yIG9mIHRoZSBmaXJzdCBzZWdtZW50LlxyXG4gKiBAcGFyYW0gbjIgTm9ybWFsIHZlY3RvciBvZiB0aGUgc2Vjb25kIHNlZ21lbnQuXHJcbiAqIEByZXR1cm5zIE1pdGVyIHZhbHVlLCBpLmUuIGJ5IGhvdyBtYXRjaCBkaXNwbGFjZW1lbnQgaXMgbG9uZ2VyIHRoYW4gYSBub3JtYWxcclxuICogICAgICBvbmUuXHJcbiAqL1xyXG5mdW5jdGlvbiBjb21wdXRlTWl0ZXIobjEsIG4yKSB7XHJcbiAgICByZXR1cm4gTWF0aC5zcXJ0KDIgLyAoMSArIHZlYzIuZG90KG4xLCBuMikpKTtcclxufVxyXG5jb25zdCBTRUdNRU5UX1ZFUlRFWF9DT1VOVCA9IDQ7XHJcbmNvbnN0IFNRVUFSRV9DQVBfVkVSVEVYX0NPVU5UID0gNTtcclxuY29uc3QgUk9VTkRfQ0FQX1ZFUlRFWF9DT1VOVCA9IDQ7XHJcbmNvbnN0IEZMT0FUX01BWCA9IDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzg7XHJcbmNvbnN0IE1JVEVSX0xJTUlUID0gNDtcclxuY29uc3QgVVZfUE9TX09ORV9QQUNLRUQgPSAyNTU7IC8vIHBhY2tlZCAxXHJcbmNvbnN0IFVWX05FR19PTkVfUEFDS0VEID0gMTsgLy8gcGFja2VkIC0xXHJcbmNvbnN0IFVWX1pFUk9fUEFDS0VEID0gMTI4O1xyXG4vKipcclxuICogUGFja3MgYSBjb21wb25lbnQgb2YgdXYgaW50byBhIHVuc2lnbmVkIDgtYml0IHZhbHVlLiBBZnRlciBwYWNraW5nIC0xIHdpbGxcclxuICogYmVjb21lIDEgYW5kIDEgd2lsbCBiZWNvbWUgMjU1LiBUaGF0J3MgbmVlZCB0byBlbXVsYXRlIHplcm8tcHJlc2VydmluZ1xyXG4gKiBub3JtYWxpemF0aW9uICh3ZSBjYW4ndCByZWx5IG9uIFdlYkdMIHRvIGRvIGl0IGZvciB1cyA6KCkuXHJcbiAqXHJcbiAqIEBwYXJhbSBjIFRoZSBjb21wb25lbnQuXHJcbiAqIEByZXR1cm5zIFBhY2tlZCBjb21wb25lbnQuXHJcbiAqL1xyXG5mdW5jdGlvbiBwYWNrVXZDb21wb25lbnQoYykge1xyXG4gICAgLy8gV2UgZG9uJ3QgdHJ1bmNhdGUgaGVyZSBiZWNhdXNlIGJ1ZmZlciB3cml0ZXIgd2lsbCBkbyB0aGF0IGZvciB1cy5cclxuICAgIHJldHVybiAxMjggKyAoMTI3ICogYyk7XHJcbn1cclxuLyoqXHJcbiAqIEhhbGYgd2lkdGggb2YgdGhlIHBvbHlsaW5lIGlzIHN0b3JlZCBpbiBhIG5vcm1hbGl6ZWQgYXR0cmlidXRlLiBUaGlzIGNvbnN0YW50XHJcbiAqIGRlZmluZXMgaGFsZiB3aWR0aCB2YWx1ZSBvZiAxIGNvcnJlc3BvbmRzIHRvLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IE1BWF9IQUxGX1dJRFRIID0gMjU1IC8gNDsgLy8gcHhcclxuLyoqXHJcbiAqIFNhbWUgYXMgZm9yIHBvbHlsaW5lIGhhbGYgd2lkdGgsIGJ1dCBmb3IgZGFzaCBwYXR0ZXJuIGRlZmluaXRpb24uXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgTUFYX0ZJTExfR0FQID0gMjU1OyAvLyBweFxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb2x5bGluZUJ1ZmZlcldyaXRlciBleHRlbmRzIEJ1ZmZlcldyaXRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcihQT0xZTElORV9BVFRSSUJVVEVfTUFQUElORy52ZXJ0ZXhCeXRlU2l6ZSk7XHJcbiAgICAgICAgdGhpcy5fZGlzcGxhY2VtZW50ID0gdmVjMi5jcmVhdGUoMCwgMCk7XHJcbiAgICAgICAgdGhpcy5fcHJldkRpc3BsYWNlbWVudCA9IHZlYzIuY3JlYXRlKDAsIDApO1xyXG4gICAgICAgIHRoaXMuX2luaXRQb2x5bGluZVN0YXRlKFt2ZWMyLlpFUk8sIHZlYzIuWkVST10sIDAsIDAsIDAsIDAsIDAgLyogTUlURVIgKi8sIDApO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZXMgYSBtZXNoIGZvciBhIHBvbHlsaW5lIHdpdGggYSBnaXZlbiBzdHlsZSwgYmFraW5nIGFsbCBuZWNlc3NhcnlcclxuICAgICAqIHBhcmFtZXRlcnMgaW50byBhdHRyaWJ1dGVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwb2x5bGluZSBUaGUgcG9seWxpbmUuXHJcbiAgICAgKiBAcGFyYW0gc3R5bGUgVGhlIHBvbHlsaW5lIHN0eWxlLlxyXG4gICAgICogQHJldHVybnMgTG9jYXRpb24gb2YgdGhlIHdyaXR0ZW4gbWVzaCBpbiB0aGUgbWFuYWdlZCBidWZmZXJzLlxyXG4gICAgICovXHJcbiAgICB3cml0ZVBvbHlsaW5lKHBvbHlsaW5lLCBzdHlsZSwgekluZGV4KSB7XHJcbiAgICAgICAgY29uc3QgeyB2ZXJ0aWNlcyB9ID0gcG9seWxpbmU7XHJcbiAgICAgICAgY29uc3QgbGFzdElkeCA9IHZlcnRpY2VzLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgaWYgKGxhc3RJZHggPCAxKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT25lIHZlcnRleCBpbiBub3QgYSBwb2x5bGluZS4gSXRcXCdzIG5vdCBldmVuIGEgbGluZS4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5faW5pdFBvbHlsaW5lU3RhdGUodmVydGljZXMsIGVuY29kZVJnYmE4KHN0eWxlLnN0cm9rZUNvbG9yKSwgc3R5bGUuc3Ryb2tlV2lkdGgsIHN0eWxlLmRhc2ggPyBzdHlsZS5kYXNoLmZpbGwgOiAwLCBzdHlsZS5kYXNoID8gc3R5bGUuZGFzaC5nYXAgOiAwLCBzdHlsZS5qb2luLCBpbnRUb1pJbmRleCh6SW5kZXgpKTtcclxuICAgICAgICB0aGlzLl93cml0ZUNhcChzdHlsZS5zdGFydENhcCwgdmVydGljZXNbMF0sIDEpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGFzdElkeDsgKytpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3dyaXRlU2VnbWVudCh2ZXJ0aWNlc1tpIC0gMV0sIHZlcnRpY2VzW2ldLCB2ZXJ0aWNlc1tpICsgMV0pO1xyXG4gICAgICAgICAgICB0aGlzLl93cml0ZUpvaW4odmVydGljZXNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl93cml0ZUxhc3RTZWdtZW50KHZlcnRpY2VzW2xhc3RJZHggLSAxXSwgdmVydGljZXNbbGFzdElkeF0pO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlQ2FwKHN0eWxlLmVuZENhcCwgdmVydGljZXNbbGFzdElkeF0sIDEpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVuZE1lc2goKTtcclxuICAgIH1cclxuICAgIF9pbml0UG9seWxpbmVTdGF0ZSh2ZXJ0aWNlcywgY29sb3JSZ2JhOCwgd2lkdGgsIGZpbGwsIGdhcCwgam9pbiwgekluZGV4KSB7XHJcbiAgICAgICAgdGhpcy5fYmFzZUluZGV4ID0gdGhpcy5fcG9seWxpbmVMZW5ndGggPSB0aGlzLl9sYXN0RGlyZWN0aW9uID0gMDtcclxuICAgICAgICB0aGlzLl9sYXN0U2lnbmVkTWl0ZXIgPSAxO1xyXG4gICAgICAgIGNvbnN0IGRpc3BsYWNlbWVudCA9IHZlYzIuc3ViKHZlcnRpY2VzWzFdLCB2ZXJ0aWNlc1swXSwgdGhpcy5fZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB0aGlzLl9zZWdtZW50TGVuZ3RoID0gdmVjMi5sZW5ndGgoZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB2ZWMyLmRpdm4oZGlzcGxhY2VtZW50LCB0aGlzLl9zZWdtZW50TGVuZ3RoLCBkaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHZlYzIucm90YXRlOTAoZGlzcGxhY2VtZW50LCBkaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHRoaXMuX2NvbG9yUmdiYTggPSBjb2xvclJnYmE4O1xyXG4gICAgICAgIHRoaXMuX2hhbGZXaWR0aEZpbGxHYXBQYWNrZWQgPVxyXG4gICAgICAgICAgICBmbG9hdFRvVWludDgoY2xhbXAoMC41ICogd2lkdGgsIDAsIE1BWF9IQUxGX1dJRFRIKSAvIE1BWF9IQUxGX1dJRFRIKSB8XHJcbiAgICAgICAgICAgICAgICBmbG9hdFRvVWludDgoY2xhbXAoZmlsbCwgMCwgTUFYX0ZJTExfR0FQKSAvIE1BWF9GSUxMX0dBUCkgPDwgOCB8XHJcbiAgICAgICAgICAgICAgICBmbG9hdFRvVWludDgoY2xhbXAoZ2FwLCAwLCBNQVhfRklMTF9HQVApIC8gTUFYX0ZJTExfR0FQKSA8PCAxNjtcclxuICAgICAgICB0aGlzLl9qb2luID0gam9pbjtcclxuICAgICAgICB0aGlzLl96SW5kZXggPSB6SW5kZXg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIHNpbmdsZSB2ZXJ0ZXggaW50byBtYW5hZ2VkIHZlcnRleCBidWZmZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBvc2l0aW9uIFZlcnRleCB3b3JsZCBwb3NpdGlvbi5cclxuICAgICAqIEBwYXJhbSBub3JtYWwgTm9ybWFsIG9mIHNlZ21lbnQgdGhlIHZlcnRleCBiZWxvbmdzIHRvLlxyXG4gICAgICogQHBhcmFtIHUgTm9ybWFsaXplZCBkaXN0YW5jZSB0byB0aGUgcG9seWxpbmUgYWxvbmcgdGhlIG5vcm1hbC5cclxuICAgICAqIEBwYXJhbSB2IE5vcm1hbGl6ZWQgZGlzdGFuY2UgdG8gdGhlIHBvbHlsaW5lIGFsb25nIHRoZSB0YW5nZW50LlxyXG4gICAgICogQHBhcmFtIHBvbHlsaW5lTGVuZ3RoIERpc3RhbmNlIHRvIHRoZSBmaXJzdCB2ZXJ0ZXggYWxvbmcgdGhlIHBvbHlsaW5lLlxyXG4gICAgICogQHBhcmFtIG1pdGVyIEpvaW4gbWl0ZXIuXHJcbiAgICAgKiBAcGFyYW0gbGVuZ3RoQ29ycmVjdGlvbkxpbWl0IExpbWl0IG9uIHRoZSB2ZXJ0ZXggZGlzcGxhY2VtZW50IGFsb25nIHRoZVxyXG4gICAgICogICAgICBwb2x5bGluZS5cclxuICAgICAqL1xyXG4gICAgX3dyaXRlVmVydGV4KHBvc2l0aW9uLCBub3JtYWwsIHVQYWNrZWQsIHZQYWNrZWQsIHBvbHlsaW5lTGVuZ3RoLCBtaXRlciwgbGVuZ3RoQ29ycmVjdGlvbkxpbWl0KSB7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVXb3JsZENvb3JkaW5hdGUocG9zaXRpb24pO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlSGFsZldvcmRzKGZsb2F0VG9VaW50MTYoMC41ICogKG5vcm1hbC54ICogTWF0aC5TUVJUMV8yICsgMSkpLCBmbG9hdFRvVWludDE2KDAuNSAqIChub3JtYWwueSAqIE1hdGguU1FSVDFfMiArIDEpKSk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVIYWxmV29yZHModVBhY2tlZCwgdlBhY2tlZCk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVXb3JkKHRoaXMuX2hhbGZXaWR0aEZpbGxHYXBQYWNrZWQpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlRmxvYXQzMihtaXRlcik7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVGbG9hdDMyKGxlbmd0aENvcnJlY3Rpb25MaW1pdCk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVGbG9hdDMyKHBvbHlsaW5lTGVuZ3RoKTtcclxuICAgICAgICB0aGlzLl93cml0ZVdvcmQodGhpcy5fY29sb3JSZ2JhOCk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVGbG9hdDMyKHRoaXMuX3pJbmRleCk7XHJcbiAgICB9XHJcbiAgICBfd3JpdGVDYXAoY2FwLCBlbmRWZXJ0ZXgsIGRpc3BsYWNlbWVudFNpZ24pIHtcclxuICAgICAgICBzd2l0Y2ggKGNhcCkge1xyXG4gICAgICAgICAgICBjYXNlIDEgLyogUk9VTkQgKi86XHJcbiAgICAgICAgICAgICAgICB0aGlzLl93cml0ZVJvdW5kQ2FwKGVuZFZlcnRleCwgZGlzcGxhY2VtZW50U2lnbik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAyIC8qIFNRVUFSRSAqLzpcclxuICAgICAgICAgICAgICAgIHRoaXMuX3dyaXRlU3F1YXJlQ2FwKGVuZFZlcnRleCwgZGlzcGxhY2VtZW50U2lnbik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfd3JpdGVSb3VuZENhcChlbmRWZXJ0ZXgsIGRpc3BsYWNlbWVudFNpZ24pIHtcclxuICAgICAgICBjb25zdCBkaXNwbGFjZW1lbnQgPSB2ZWMyLmNyZWF0ZSgwLCAwKTtcclxuICAgICAgICBjb25zdCBwb2x5bGluZUxlbmd0aCA9IHRoaXMuX3BvbHlsaW5lTGVuZ3RoO1xyXG4gICAgICAgIHZlYzIubXVsbih0aGlzLl9kaXNwbGFjZW1lbnQsIC1kaXNwbGFjZW1lbnRTaWduLCBkaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlVmVydGV4KGVuZFZlcnRleCwgZGlzcGxhY2VtZW50LCBVVl9ORUdfT05FX1BBQ0tFRCwgVVZfWkVST19QQUNLRUQsIHBvbHlsaW5lTGVuZ3RoLCAxLCBGTE9BVF9NQVgpO1xyXG4gICAgICAgIHZlYzIucm90YXRlOTAodGhpcy5fZGlzcGxhY2VtZW50LCBkaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHZlYzIuc3ViKGRpc3BsYWNlbWVudCwgdGhpcy5fZGlzcGxhY2VtZW50LCBkaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHZlYzIubXVsbihkaXNwbGFjZW1lbnQsIGRpc3BsYWNlbWVudFNpZ24sIGRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVWZXJ0ZXgoZW5kVmVydGV4LCBkaXNwbGFjZW1lbnQsIFVWX05FR19PTkVfUEFDS0VELCBVVl9QT1NfT05FX1BBQ0tFRCwgcG9seWxpbmVMZW5ndGgsIDEsIEZMT0FUX01BWCk7XHJcbiAgICAgICAgdmVjMi5tdWxuKHRoaXMuX2Rpc3BsYWNlbWVudCwgZGlzcGxhY2VtZW50U2lnbiwgZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB0aGlzLl93cml0ZVZlcnRleChlbmRWZXJ0ZXgsIGRpc3BsYWNlbWVudCwgVVZfUE9TX09ORV9QQUNLRUQsIFVWX1pFUk9fUEFDS0VELCBwb2x5bGluZUxlbmd0aCwgMSwgRkxPQVRfTUFYKTtcclxuICAgICAgICB2ZWMyLnJvdGF0ZTkwKHRoaXMuX2Rpc3BsYWNlbWVudCwgZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB2ZWMyLmFkZChkaXNwbGFjZW1lbnQsIHRoaXMuX2Rpc3BsYWNlbWVudCwgZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB2ZWMyLm11bG4oZGlzcGxhY2VtZW50LCBkaXNwbGFjZW1lbnRTaWduLCBkaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlVmVydGV4KGVuZFZlcnRleCwgZGlzcGxhY2VtZW50LCBVVl9QT1NfT05FX1BBQ0tFRCwgVVZfUE9TX09ORV9QQUNLRUQsIHBvbHlsaW5lTGVuZ3RoLCAxLCBGTE9BVF9NQVgpO1xyXG4gICAgICAgIHRoaXMud3JpdGVJbmRpY2VzRm9yQ29udGludW91c1N0cmlwKFJPVU5EX0NBUF9WRVJURVhfQ09VTlQsIHRoaXMuX2Jhc2VJbmRleCk7XHJcbiAgICAgICAgdGhpcy5fYmFzZUluZGV4ICs9IFJPVU5EX0NBUF9WRVJURVhfQ09VTlQ7XHJcbiAgICB9XHJcbiAgICBfd3JpdGVTcXVhcmVDYXAoZW5kVmVydGV4LCBkaXNwbGFjZW1lbnRTaWduKSB7XHJcbiAgICAgICAgY29uc3QgZGlzcGxhY2VtZW50ID0gdmVjMi5jcmVhdGUoMCwgMCk7XHJcbiAgICAgICAgY29uc3QgcG9seWxpbmVMZW5ndGggPSB0aGlzLl9wb2x5bGluZUxlbmd0aDtcclxuICAgICAgICB0aGlzLl93cml0ZVZlcnRleChlbmRWZXJ0ZXgsIHZlYzIuWkVSTywgVVZfWkVST19QQUNLRUQsIFVWX1pFUk9fUEFDS0VELCBwb2x5bGluZUxlbmd0aCwgMSwgMCk7XHJcbiAgICAgICAgdmVjMi5tdWxuKHRoaXMuX2Rpc3BsYWNlbWVudCwgLWRpc3BsYWNlbWVudFNpZ24sIGRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVWZXJ0ZXgoZW5kVmVydGV4LCBkaXNwbGFjZW1lbnQsIFVWX1BPU19PTkVfUEFDS0VELCBVVl9aRVJPX1BBQ0tFRCwgcG9seWxpbmVMZW5ndGgsIDEsIEZMT0FUX01BWCk7XHJcbiAgICAgICAgdmVjMi5yb3RhdGU5MCh0aGlzLl9kaXNwbGFjZW1lbnQsIGRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdmVjMi5zdWIoZGlzcGxhY2VtZW50LCB0aGlzLl9kaXNwbGFjZW1lbnQsIGRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdmVjMi5tdWxuKGRpc3BsYWNlbWVudCwgZGlzcGxhY2VtZW50U2lnbiwgZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB0aGlzLl93cml0ZVZlcnRleChlbmRWZXJ0ZXgsIGRpc3BsYWNlbWVudCwgVVZfUE9TX09ORV9QQUNLRUQsIFVWX1pFUk9fUEFDS0VELCBwb2x5bGluZUxlbmd0aCwgMSwgRkxPQVRfTUFYKTtcclxuICAgICAgICB2ZWMyLnJvdGF0ZTkwKHRoaXMuX2Rpc3BsYWNlbWVudCwgZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB2ZWMyLnN1YihkaXNwbGFjZW1lbnQsIHRoaXMuX2Rpc3BsYWNlbWVudCwgZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB2ZWMyLm11bG4oZGlzcGxhY2VtZW50LCBkaXNwbGFjZW1lbnRTaWduLCBkaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlVmVydGV4KGVuZFZlcnRleCwgZGlzcGxhY2VtZW50LCBVVl9QT1NfT05FX1BBQ0tFRCwgVVZfWkVST19QQUNLRUQsIHBvbHlsaW5lTGVuZ3RoLCAxLCBGTE9BVF9NQVgpO1xyXG4gICAgICAgIHZlYzIubXVsbih0aGlzLl9kaXNwbGFjZW1lbnQsIGRpc3BsYWNlbWVudFNpZ24sIGRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVWZXJ0ZXgoZW5kVmVydGV4LCB0aGlzLl9kaXNwbGFjZW1lbnQsIFVWX1BPU19PTkVfUEFDS0VELCBVVl9aRVJPX1BBQ0tFRCwgcG9seWxpbmVMZW5ndGgsIDEsIEZMT0FUX01BWCk7XHJcbiAgICAgICAgdGhpcy53cml0ZUluZGljZXNGb3JDb250aW51b3VzRmFuKFNRVUFSRV9DQVBfVkVSVEVYX0NPVU5ULCB0aGlzLl9iYXNlSW5kZXgpO1xyXG4gICAgICAgIHRoaXMuX2Jhc2VJbmRleCArPSBTUVVBUkVfQ0FQX1ZFUlRFWF9DT1VOVDtcclxuICAgIH1cclxuICAgIF93cml0ZVNlZ21lbnQoc3RhcnQsIGVuZCwgbmV4dEVuZCkge1xyXG4gICAgICAgIGNvbnN0IGRpc3BsYWNlbWVudCA9IHRoaXMuX2Rpc3BsYWNlbWVudDtcclxuICAgICAgICBjb25zdCBwb2x5bGluZUxlbmd0aCA9IHRoaXMuX3BvbHlsaW5lTGVuZ3RoO1xyXG4gICAgICAgIGNvbnN0IG5leHRTZWdtZW50TGVuZ3RoID0gdmVjMi5kaXN0YW5jZShuZXh0RW5kLCBlbmQpO1xyXG4gICAgICAgIGNvbnN0IG5leHRTZWdtZW50Tm9ybWFsID0gdmVjMi5zdWIobmV4dEVuZCwgZW5kKTtcclxuICAgICAgICB2ZWMyLmRpdm4obmV4dFNlZ21lbnROb3JtYWwsIG5leHRTZWdtZW50TGVuZ3RoLCBuZXh0U2VnbWVudE5vcm1hbCk7XHJcbiAgICAgICAgdmVjMi5yb3RhdGU5MChuZXh0U2VnbWVudE5vcm1hbCwgbmV4dFNlZ21lbnROb3JtYWwpO1xyXG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbjEgPSB0aGlzLl9sYXN0RGlyZWN0aW9uO1xyXG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbjIgPSBNYXRoLnNpZ24odmVjMi5jcm9zc1ooZGlzcGxhY2VtZW50LCBuZXh0U2VnbWVudE5vcm1hbCkpO1xyXG4gICAgICAgIGNvbnN0IG1pdGVyMSA9IHRoaXMuX2xhc3RTaWduZWRNaXRlcjtcclxuICAgICAgICBjb25zdCBtaXRlcjIgPSBjb21wdXRlTWl0ZXIoZGlzcGxhY2VtZW50LCBuZXh0U2VnbWVudE5vcm1hbCk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVWZXJ0ZXgoc3RhcnQsIGRpc3BsYWNlbWVudCwgVVZfUE9TX09ORV9QQUNLRUQsIFVWX1pFUk9fUEFDS0VELCBwb2x5bGluZUxlbmd0aCwgZGlyZWN0aW9uMSA9PT0gLTEgJiYgKHRoaXMuX2pvaW4gIT09IDAgLyogTUlURVIgKi8gfHwgTWF0aC5hYnMobWl0ZXIxKSA+IE1JVEVSX0xJTUlUKSA/XHJcbiAgICAgICAgICAgIDEgOlxyXG4gICAgICAgICAgICBtaXRlcjEsIGRpcmVjdGlvbjEgPT09IC0xID8gLUZMT0FUX01BWCA6IDAuNSAqIHRoaXMuX3NlZ21lbnRMZW5ndGgpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlVmVydGV4KGVuZCwgZGlzcGxhY2VtZW50LCBVVl9QT1NfT05FX1BBQ0tFRCwgVVZfWkVST19QQUNLRUQsIHBvbHlsaW5lTGVuZ3RoICsgdGhpcy5fc2VnbWVudExlbmd0aCwgZGlyZWN0aW9uMiA9PT0gLTEgJiYgKHRoaXMuX2pvaW4gIT09IDAgLyogTUlURVIgKi8gfHwgbWl0ZXIyID4gTUlURVJfTElNSVQpID9cclxuICAgICAgICAgICAgMSA6XHJcbiAgICAgICAgICAgIGRpcmVjdGlvbjIgKiBtaXRlcjIsIGRpcmVjdGlvbjIgPT09IC0xID8gRkxPQVRfTUFYIDogLTAuNSAqIHRoaXMuX3NlZ21lbnRMZW5ndGgpO1xyXG4gICAgICAgIHZlYzIuaW52ZXJ0KGRpc3BsYWNlbWVudCwgZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB0aGlzLl93cml0ZVZlcnRleChzdGFydCwgZGlzcGxhY2VtZW50LCBVVl9ORUdfT05FX1BBQ0tFRCwgVVZfWkVST19QQUNLRUQsIHBvbHlsaW5lTGVuZ3RoLCBkaXJlY3Rpb24xID09PSAxICYmICh0aGlzLl9qb2luICE9PSAwIC8qIE1JVEVSICovIHx8IE1hdGguYWJzKG1pdGVyMSkgPiBNSVRFUl9MSU1JVCkgP1xyXG4gICAgICAgICAgICAxIDpcclxuICAgICAgICAgICAgbWl0ZXIxLCBkaXJlY3Rpb24xID09PSAxID8gLUZMT0FUX01BWCA6IDAuNSAqIHRoaXMuX3NlZ21lbnRMZW5ndGgpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlVmVydGV4KGVuZCwgZGlzcGxhY2VtZW50LCBVVl9ORUdfT05FX1BBQ0tFRCwgVVZfWkVST19QQUNLRUQsIHBvbHlsaW5lTGVuZ3RoICsgdGhpcy5fc2VnbWVudExlbmd0aCwgZGlyZWN0aW9uMiA9PT0gMSAmJiAodGhpcy5fam9pbiAhPT0gMCAvKiBNSVRFUiAqLyB8fCBtaXRlcjIgPiBNSVRFUl9MSU1JVCkgP1xyXG4gICAgICAgICAgICAxIDpcclxuICAgICAgICAgICAgZGlyZWN0aW9uMiAqIG1pdGVyMiwgZGlyZWN0aW9uMiA9PT0gMSA/IEZMT0FUX01BWCA6IC0wLjUgKiB0aGlzLl9zZWdtZW50TGVuZ3RoKTtcclxuICAgICAgICB0aGlzLndyaXRlSW5kaWNlc0ZvckNvbnRpbnVvdXNTdHJpcChTRUdNRU5UX1ZFUlRFWF9DT1VOVCwgdGhpcy5fYmFzZUluZGV4KTtcclxuICAgICAgICB0aGlzLl9iYXNlSW5kZXggKz0gU0VHTUVOVF9WRVJURVhfQ09VTlQ7XHJcbiAgICAgICAgdGhpcy5fbGFzdFNpZ25lZE1pdGVyID0gLWRpcmVjdGlvbjIgKiBtaXRlcjI7XHJcbiAgICAgICAgdGhpcy5fbGFzdERpcmVjdGlvbiA9IGRpcmVjdGlvbjI7XHJcbiAgICAgICAgdmVjMi5jb3B5KGRpc3BsYWNlbWVudCwgdGhpcy5fcHJldkRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdmVjMi5jb3B5KG5leHRTZWdtZW50Tm9ybWFsLCBkaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHRoaXMuX3BvbHlsaW5lTGVuZ3RoICs9IHRoaXMuX3NlZ21lbnRMZW5ndGg7XHJcbiAgICAgICAgdGhpcy5fc2VnbWVudExlbmd0aCA9IG5leHRTZWdtZW50TGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgX3dyaXRlSm9pbihqb2luVmVydGV4KSB7XHJcbiAgICAgICAgc3dpdGNoICh0aGlzLl9qb2luKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMiAvKiBCRVZFTCAqLzpcclxuICAgICAgICAgICAgICAgIHRoaXMuX3dyaXRlQmV2ZWxKb2luKGpvaW5WZXJ0ZXgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMSAvKiBST1VORCAqLzpcclxuICAgICAgICAgICAgICAgIHRoaXMuX3dyaXRlUm91bmRKb2luKGpvaW5WZXJ0ZXgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMCAvKiBNSVRFUiAqLzpcclxuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyh0aGlzLl9sYXN0U2lnbmVkTWl0ZXIpID4gTUlURVJfTElNSVQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl93cml0ZUJldmVsSm9pbihqb2luVmVydGV4KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF93cml0ZUJldmVsSm9pbihqb2luVmVydGV4KSB7XHJcbiAgICAgICAgY29uc3QgbGFzdERpcmVjdGlvbiA9IHRoaXMuX2xhc3REaXJlY3Rpb247XHJcbiAgICAgICAgY29uc3QgZGlzcGxhY2VtZW50ID0gdmVjMi5pbnZlcnQodGhpcy5fZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB2ZWMyLmFkZChkaXNwbGFjZW1lbnQsIHRoaXMuX3ByZXZEaXNwbGFjZW1lbnQsIGRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdmVjMi5tdWxuKGRpc3BsYWNlbWVudCwgMC41ICogbGFzdERpcmVjdGlvbiwgZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB0aGlzLl93cml0ZVZlcnRleChqb2luVmVydGV4LCBkaXNwbGFjZW1lbnQsIGxhc3REaXJlY3Rpb24gPT09IC0xIC8qIExFRlQgKi8gP1xyXG4gICAgICAgICAgICBVVl9QT1NfT05FX1BBQ0tFRCA6XHJcbiAgICAgICAgICAgIFVWX05FR19PTkVfUEFDS0VELCBVVl9aRVJPX1BBQ0tFRCwgdGhpcy5fcG9seWxpbmVMZW5ndGgsIDEsIDEpO1xyXG4gICAgICAgIGNvbnN0IGJhc2VJbmRleCA9IHRoaXMuX2Jhc2VJbmRleDtcclxuICAgICAgICB0aGlzLndyaXRlSW5kaWNlcyhbXHJcbiAgICAgICAgICAgIGJhc2VJbmRleCAtIDEsXHJcbiAgICAgICAgICAgIGJhc2VJbmRleCAtIDMsXHJcbiAgICAgICAgICAgIGJhc2VJbmRleCxcclxuICAgICAgICAgICAgYmFzZUluZGV4LFxyXG4gICAgICAgICAgICBsYXN0RGlyZWN0aW9uID09PSAtMSAvKiBMRUZUICovID8gYmFzZUluZGV4ICsgMSA6IGJhc2VJbmRleCArIDMsXHJcbiAgICAgICAgICAgIGxhc3REaXJlY3Rpb24gPT09IC0xIC8qIExFRlQgKi8gPyBiYXNlSW5kZXggKyAzIDogYmFzZUluZGV4ICsgMVxyXG4gICAgICAgIF0pO1xyXG4gICAgICAgIHRoaXMuX2Jhc2VJbmRleCArPSAxO1xyXG4gICAgfVxyXG4gICAgX3dyaXRlUm91bmRKb2luKGpvaW5WZXJ0ZXgpIHtcclxuICAgICAgICBjb25zdCBwb2x5bGluZUxlbmd0aCA9IHRoaXMuX3BvbHlsaW5lTGVuZ3RoO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlVmVydGV4KGpvaW5WZXJ0ZXgsIHZlYzIuWkVSTywgVVZfWkVST19QQUNLRUQsIFVWX1pFUk9fUEFDS0VELCBwb2x5bGluZUxlbmd0aCwgMCwgMCk7XHJcbiAgICAgICAgY29uc3QgbGFzdERpcmVjdGlvbiA9IHRoaXMuX2xhc3REaXJlY3Rpb247XHJcbiAgICAgICAgY29uc3QgbWlkZGxlRGlzcGxhY2VtZW50ID0gdmVjMi5pbnZlcnQodGhpcy5fcHJldkRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdmVjMi5hZGQodGhpcy5fZGlzcGxhY2VtZW50LCBtaWRkbGVEaXNwbGFjZW1lbnQsIG1pZGRsZURpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdmVjMi5ub3JtYWxpemUobWlkZGxlRGlzcGxhY2VtZW50LCBtaWRkbGVEaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIGNvbnN0IGRpc3BsYWNlbWVudCA9IHZlYzIuaW52ZXJ0KHRoaXMuX3ByZXZEaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIGNvbnN0IG1pdGVyMSA9IGNvbXB1dGVNaXRlcihtaWRkbGVEaXNwbGFjZW1lbnQsIGRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdmVjMi5hZGQoZGlzcGxhY2VtZW50LCBtaWRkbGVEaXNwbGFjZW1lbnQsIGRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdmVjMi5ub3JtYWxpemUoZGlzcGxhY2VtZW50LCBkaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHZlYzIubXVsbihkaXNwbGFjZW1lbnQsIC1sYXN0RGlyZWN0aW9uICogbWl0ZXIxLCBkaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlVmVydGV4KGpvaW5WZXJ0ZXgsIGRpc3BsYWNlbWVudCwgbGFzdERpcmVjdGlvbiA9PT0gLTEgLyogTEVGVCAqLyA/XHJcbiAgICAgICAgICAgIFVWX1BPU19PTkVfUEFDS0VEIDpcclxuICAgICAgICAgICAgVVZfTkVHX09ORV9QQUNLRUQsIHBhY2tVdkNvbXBvbmVudChNYXRoLnNxcnQobWl0ZXIxICogbWl0ZXIxIC0gMSkpLCBwb2x5bGluZUxlbmd0aCwgMSwgRkxPQVRfTUFYKTtcclxuICAgICAgICB2ZWMyLm11bG4obWlkZGxlRGlzcGxhY2VtZW50LCAtbGFzdERpcmVjdGlvbiwgZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB0aGlzLl93cml0ZVZlcnRleChqb2luVmVydGV4LCBkaXNwbGFjZW1lbnQsIGxhc3REaXJlY3Rpb24gPT09IC0xIC8qIExFRlQgKi8gP1xyXG4gICAgICAgICAgICBVVl9QT1NfT05FX1BBQ0tFRCA6XHJcbiAgICAgICAgICAgIFVWX05FR19PTkVfUEFDS0VELCBVVl9aRVJPX1BBQ0tFRCwgcG9seWxpbmVMZW5ndGgsIDEsIEZMT0FUX01BWCk7XHJcbiAgICAgICAgY29uc3QgbWl0ZXIyID0gY29tcHV0ZU1pdGVyKG1pZGRsZURpc3BsYWNlbWVudCwgdGhpcy5fZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB2ZWMyLmFkZCh0aGlzLl9kaXNwbGFjZW1lbnQsIG1pZGRsZURpc3BsYWNlbWVudCwgZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB2ZWMyLm5vcm1hbGl6ZShkaXNwbGFjZW1lbnQsIGRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdmVjMi5tdWxuKGRpc3BsYWNlbWVudCwgLWxhc3REaXJlY3Rpb24gKiBtaXRlcjIsIGRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVWZXJ0ZXgoam9pblZlcnRleCwgZGlzcGxhY2VtZW50LCBsYXN0RGlyZWN0aW9uID09PSAtMSAvKiBMRUZUICovID9cclxuICAgICAgICAgICAgVVZfUE9TX09ORV9QQUNLRUQgOlxyXG4gICAgICAgICAgICBVVl9ORUdfT05FX1BBQ0tFRCwgcGFja1V2Q29tcG9uZW50KE1hdGguc3FydChtaXRlcjIgKiBtaXRlcjIgLSAxKSksIHBvbHlsaW5lTGVuZ3RoLCAxLCBGTE9BVF9NQVgpO1xyXG4gICAgICAgIGNvbnN0IGJhc2VJbmRleCA9IHRoaXMuX2Jhc2VJbmRleDtcclxuICAgICAgICB0aGlzLndyaXRlSW5kaWNlcyhbXHJcbiAgICAgICAgICAgIGJhc2VJbmRleCAtIDMsXHJcbiAgICAgICAgICAgIGJhc2VJbmRleCAtIDEsXHJcbiAgICAgICAgICAgIGJhc2VJbmRleCxcclxuICAgICAgICAgICAgYmFzZUluZGV4LFxyXG4gICAgICAgICAgICBsYXN0RGlyZWN0aW9uID09PSAtMSAvKiBMRUZUICovID8gYmFzZUluZGV4IC0gMyA6IGJhc2VJbmRleCAtIDEsXHJcbiAgICAgICAgICAgIGJhc2VJbmRleCArIDEsXHJcbiAgICAgICAgICAgIGJhc2VJbmRleCxcclxuICAgICAgICAgICAgYmFzZUluZGV4ICsgMSxcclxuICAgICAgICAgICAgYmFzZUluZGV4ICsgMixcclxuICAgICAgICAgICAgYmFzZUluZGV4LFxyXG4gICAgICAgICAgICBiYXNlSW5kZXggKyAyLFxyXG4gICAgICAgICAgICBiYXNlSW5kZXggKyAzLFxyXG4gICAgICAgICAgICBiYXNlSW5kZXgsXHJcbiAgICAgICAgICAgIGJhc2VJbmRleCArIDMsXHJcbiAgICAgICAgICAgIGxhc3REaXJlY3Rpb24gPT09IC0xIC8qIExFRlQgKi8gPyBiYXNlSW5kZXggKyA0IDogYmFzZUluZGV4ICsgNixcclxuICAgICAgICAgICAgYmFzZUluZGV4LFxyXG4gICAgICAgICAgICBiYXNlSW5kZXggKyA0LFxyXG4gICAgICAgICAgICBiYXNlSW5kZXggKyA2XHJcbiAgICAgICAgXSk7XHJcbiAgICAgICAgdGhpcy5fYmFzZUluZGV4ICs9IDQ7XHJcbiAgICB9XHJcbiAgICBfd3JpdGVMYXN0U2VnbWVudChzdGFydCwgZW5kKSB7XHJcbiAgICAgICAgY29uc3QgZGlzcGxhY2VtZW50ID0gdGhpcy5fZGlzcGxhY2VtZW50O1xyXG4gICAgICAgIGNvbnN0IGxhc3REaXJlY3Rpb24gPSB0aGlzLl9sYXN0RGlyZWN0aW9uO1xyXG4gICAgICAgIGNvbnN0IHBvbHlsaW5lTGVuZ3RoID0gdGhpcy5fcG9seWxpbmVMZW5ndGg7XHJcbiAgICAgICAgY29uc3QgbWl0ZXIgPSB0aGlzLl9sYXN0U2lnbmVkTWl0ZXI7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVWZXJ0ZXgoc3RhcnQsIGRpc3BsYWNlbWVudCwgVVZfUE9TX09ORV9QQUNLRUQsIFVWX1pFUk9fUEFDS0VELCBwb2x5bGluZUxlbmd0aCwgbGFzdERpcmVjdGlvbiA9PT0gLTEgLyogTEVGVCAqLyAmJiAodGhpcy5fam9pbiAhPT0gMCAvKiBNSVRFUiAqLyB8fCBNYXRoLmFicyhtaXRlcikgPiBNSVRFUl9MSU1JVCkgP1xyXG4gICAgICAgICAgICAxIDpcclxuICAgICAgICAgICAgbWl0ZXIsIGxhc3REaXJlY3Rpb24gPT09IC0xIC8qIExFRlQgKi8gPyAtRkxPQVRfTUFYIDogdGhpcy5fc2VnbWVudExlbmd0aCk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVWZXJ0ZXgoZW5kLCBkaXNwbGFjZW1lbnQsIFVWX1BPU19PTkVfUEFDS0VELCBVVl9aRVJPX1BBQ0tFRCwgcG9seWxpbmVMZW5ndGggKyB0aGlzLl9zZWdtZW50TGVuZ3RoLCAxLCBGTE9BVF9NQVgpO1xyXG4gICAgICAgIHZlYzIuaW52ZXJ0KGRpc3BsYWNlbWVudCwgZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB0aGlzLl93cml0ZVZlcnRleChzdGFydCwgZGlzcGxhY2VtZW50LCBVVl9ORUdfT05FX1BBQ0tFRCwgVVZfWkVST19QQUNLRUQsIHBvbHlsaW5lTGVuZ3RoLCBsYXN0RGlyZWN0aW9uID09PSAxIC8qIFJJR0hUICovICYmICh0aGlzLl9qb2luICE9PSAwIC8qIE1JVEVSICovIHx8IE1hdGguYWJzKG1pdGVyKSA+IE1JVEVSX0xJTUlUKSA/XHJcbiAgICAgICAgICAgIDEgOlxyXG4gICAgICAgICAgICBtaXRlciwgbGFzdERpcmVjdGlvbiA9PT0gMSAvKiBSSUdIVCAqLyA/IC1GTE9BVF9NQVggOiB0aGlzLl9zZWdtZW50TGVuZ3RoKTtcclxuICAgICAgICB0aGlzLl93cml0ZVZlcnRleChlbmQsIGRpc3BsYWNlbWVudCwgVVZfTkVHX09ORV9QQUNLRUQsIFVWX1pFUk9fUEFDS0VELCBwb2x5bGluZUxlbmd0aCArIHRoaXMuX3NlZ21lbnRMZW5ndGgsIDEsIEZMT0FUX01BWCk7XHJcbiAgICAgICAgdGhpcy53cml0ZUluZGljZXNGb3JDb250aW51b3VzU3RyaXAoU0VHTUVOVF9WRVJURVhfQ09VTlQsIHRoaXMuX2Jhc2VJbmRleCk7XHJcbiAgICAgICAgdGhpcy5fYmFzZUluZGV4ICs9IFNFR01FTlRfVkVSVEVYX0NPVU5UO1xyXG4gICAgfVxyXG59XHJcbiIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbiNpZm5kZWYgRklMVEVSX1JBRElVU1xcbiMgICBlcnJvciBGSUxURVJfUkFESVVTIG11c3QgYmUgc2V0XFxuI2VuZGlmXFxuXFxuI2lmbmRlZiBNQVhfSEFMRl9XSURUSFxcbiMgICBlcnJvciBNQVhfSEFMRl9XSURUSCBtdXN0IGJlIHNldFxcbiNlbmRpZlxcblxcbiNpZm5kZWYgTUFYX0ZJTExfR0FQXFxuIyAgIGVycm9yIE1BWF9GSUxMX0dBUCBtdXN0IGJlIHNldFxcbiNlbmRpZlxcblxcbmF0dHJpYnV0ZSB2ZWM0IHZlcnRleFBvcztcXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhOb3JtYWxQYWNrZWQ7XFxuYXR0cmlidXRlIHZlYzIgdmVydGV4VXZQYWNrZWQ7XFxuYXR0cmlidXRlIHZlYzMgdmVydGV4V2lkdGhGaWxsR2FwO1xcbmF0dHJpYnV0ZSB2ZWM0IHZlcnRleENvbG9yO1xcbmF0dHJpYnV0ZSBmbG9hdCB2ZXJ0ZXhNaXRlcjtcXG5hdHRyaWJ1dGUgZmxvYXQgdmVydGV4VkxpbWl0O1xcbmF0dHJpYnV0ZSBmbG9hdCB2ZXJ0ZXhMZW5ndGg7XFxuXFxudW5pZm9ybSB2ZWMyIGxvb2tBdEhpZ2g7XFxudW5pZm9ybSB2ZWMyIGxvb2tBdExvdztcXG51bmlmb3JtIG1hdDQgdmlld1Byb2pNYXRyaXg7XFxudW5pZm9ybSBmbG9hdCB3b3JsZFRvUHhGYWN0b3I7XFxuXFxudmFyeWluZyB2ZWMyIHV2O1xcbnZhcnlpbmcgZmxvYXQgbGVuO1xcbnZhcnlpbmcgZmxvYXQgaGFsZldpZHRoO1xcbnZhcnlpbmcgdmVjMyBkYXNoO1xcbnZhcnlpbmcgdmVjNCBjb2xvcjtcXG5cXG5jb25zdCBmbG9hdCBZVl9IID0gMS45OTk5Njk0ODI0MjE4NzU7XFxuY29uc3QgZmxvYXQgWVZfTCA9IDAuMDAwMDMwNTE3MTEyNDYzNzEyNjkyO1xcbmNvbnN0IHZlYzQgWVZfSEhMTCA9IHZlYzQoWVZfSCwgWVZfSCwgWVZfTCwgWVZfTCk7XFxuXFxuY29uc3QgZmxvYXQgU1FSVDIgPSAxLjQxNDIxMzUzODE2OTg2MDg7XFxuXFxudmVjMiB1bnBhY2tVdihjb25zdCBpbiB2ZWMyIHV2KSB7XFxuICAgIHJldHVybiAodXYgLSAxMjguKSAvIDEyNy47XFxufVxcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIHZlYzIgbm9ybWFsID0gKDIuMCAqIHZlcnRleE5vcm1hbFBhY2tlZCAtIDEuMCkgKiBTUVJUMjtcXG5cXG4gICAgaGFsZldpZHRoID0gZmxvYXQoTUFYX0hBTEZfV0lEVEgpICogdmVydGV4V2lkdGhGaWxsR2FwLng7XFxuICAgIGhhbGZXaWR0aCArPSBGSUxURVJfUkFESVVTO1xcblxcbiAgICBmbG9hdCB0YW5nZW50TGVuZ3RoID0gbWluKFxcbiAgICAgICAgc3FydCh2ZXJ0ZXhNaXRlciAqIHZlcnRleE1pdGVyIC0gMS4pICogaGFsZldpZHRoICogd29ybGRUb1B4RmFjdG9yLFxcbiAgICAgICAgYWJzKHZlcnRleFZMaW1pdClcXG4gICAgKTtcXG5cXG4gICAgdmVjNCBsb29rQXQgPSB2ZWM0KGxvb2tBdEhpZ2gsIGxvb2tBdExvdyk7XFxuICAgIHZlYzQgcmVsYXRpdmVUb0V5ZVBvc2l0aW9uID0gWVZfSEhMTCAqICh2ZXJ0ZXhQb3MgLSBsb29rQXQpO1xcblxcbiAgICBnbF9Qb3NpdGlvbiA9IHZpZXdQcm9qTWF0cml4ICogdmVjNChcXG4gICAgICAgIHJlbGF0aXZlVG9FeWVQb3NpdGlvbi54eSArIHJlbGF0aXZlVG9FeWVQb3NpdGlvbi56dyArXFxuICAgICAgICAgICAgICAgIHdvcmxkVG9QeEZhY3RvciAqIGhhbGZXaWR0aCAqIG5vcm1hbCAtXFxuICAgICAgICAgICAgICAgICAgICBzaWduKHZlcnRleE1pdGVyKSAqIHRhbmdlbnRMZW5ndGggKiB2ZWMyKG5vcm1hbC55LCAtbm9ybWFsLngpLFxcbiAgICAgICAgMCxcXG4gICAgICAgIDFcXG4gICAgKTtcXG5cXG4gICAgdXYgPSB1bnBhY2tVdih2ZXJ0ZXhVdlBhY2tlZCkgKiBoYWxmV2lkdGg7XFxuICAgIGxlbiA9ICh2ZXJ0ZXhMZW5ndGggKyBzaWduKHZlcnRleFZMaW1pdCkgKiB0YW5nZW50TGVuZ3RoKSAvIHdvcmxkVG9QeEZhY3RvcjtcXG5cXG4gICAgZGFzaC54eSA9IHZlYzIoTUFYX0ZJTExfR0FQKSAqIHZlcnRleFdpZHRoRmlsbEdhcC55ejtcXG4gICAgZGFzaC56ID0gZGFzaC54ICsgZGFzaC55O1xcblxcbiAgICBjb2xvciA9IHZlcnRleENvbG9yO1xcbiAgICBjb2xvci5yZ2IgKj0gY29sb3IuYTtcXG59XFxuXCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiI3ZlcnNpb24gMTAwXFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG4jaWZuZGVmIEZJTFRFUl9SQURJVVNcXG4jICAgZXJyb3IgRklMVEVSX1JBRElVUyBtdXN0IGJlIHNldFxcbiNlbmRpZlxcblxcbnZhcnlpbmcgaGlnaHAgdmVjMiB1djtcXG52YXJ5aW5nIGhpZ2hwIGZsb2F0IGxlbjtcXG52YXJ5aW5nIGhpZ2hwIGZsb2F0IGhhbGZXaWR0aDtcXG52YXJ5aW5nIGxvd3AgdmVjMyBkYXNoO1xcbnZhcnlpbmcgbG93cCB2ZWM0IGNvbG9yO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIGxvd3AgZmxvYXQgYWxwaGEgPVxcbiAgICAgICAgc21vb3Roc3RlcCgwLjAsIEZJTFRFUl9SQURJVVMgKyBtaW4oRklMVEVSX1JBRElVUywgaGFsZldpZHRoKSwgaGFsZldpZHRoIC0gbGVuZ3RoKHV2KSk7XFxuXFxuICAgIGlmIChkYXNoLnogPiAwLjApIHtcXG4gICAgICAgIGxvd3AgdmVjMyBoYWxmRGFzaCA9IGRhc2ggKiAwLjU7XFxuICAgICAgICBsb3dwIGZsb2F0IGRhc2hQaGFzZSA9IG1vZChsZW4gKyBoYWxmRGFzaC55LCBkYXNoLnopO1xcbiAgICAgICAgbG93cCBmbG9hdCByID0gbWluKEZJTFRFUl9SQURJVVMsIGhhbGZEYXNoLnkpO1xcblxcbiAgICAgICAgYWxwaGEgKj0gc21vb3Roc3RlcCgtciwgciwgaGFsZkRhc2gueCAtIGFicyhkYXNoUGhhc2UgLSBoYWxmRGFzaC56KSk7XFxuICAgIH1cXG5cXG4gICAgZ2xfRnJhZ0NvbG9yID0gY29sb3IgKiBhbHBoYTtcXG59XFxuXCIiLCJpbXBvcnQgdGV4dHVyZWRQb2x5Z29uVmVydGV4U2hhZGVyIGZyb20gJy4vc2hhZGVyL3RleHR1cmVkX3BvbHlnb24udmVydCc7XHJcbmltcG9ydCB0ZXh0dXJlZFBvbHlnb25GcmFnbWVudFNoYWRlciBmcm9tICcuL3NoYWRlci90ZXh0dXJlZF9wb2x5Z29uLmZyYWcnO1xyXG5pbXBvcnQgKiBhcyB2ZWMyIGZyb20gJy4uLy4uLy4uL21hdGgvdmVjdG9yMic7XHJcbmltcG9ydCBSZW5kZXJTdGF0ZSBmcm9tICcuLi8uLi8uLi9yZW5kZXIvc3RhdGUnO1xyXG5pbXBvcnQgeyBCTEVORF9PVkVSX1JFTkRFUl9TVEFURSB9IGZyb20gJy4uLy4uLy4uL3JlbmRlci9zdGF0ZSc7XHJcbmltcG9ydCBXb3JsZFByaW1pdGl2ZVJlbmRlclVuaXQgZnJvbSAnLi4vd29ybGRfcHJpbWl0aXZlX3JlbmRlcl91bml0JztcclxuY29uc3QgUkVOREVSX1NUQVRFID0gbmV3IFJlbmRlclN0YXRlKEJMRU5EX09WRVJfUkVOREVSX1NUQVRFLCB7XHJcbiAgICBkZXB0aFRlc3Q6IHRydWUsXHJcbiAgICBkZXB0aE1hc2s6IGZhbHNlLFxyXG4gICAgZGVwdGhGdW5jOiA1MTggLyogR1JFQVRFUl9PUl9FUVVBTCAqL1xyXG59KTtcclxuLyoqXHJcbiAqIFJlbmRlcmVyIG9mIHBvbHlsaW5lIHByaW1pdGl2ZXMuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXh0dXJlZFBvbHlnb25SZW5kZXJVbml0IGV4dGVuZHMgV29ybGRQcmltaXRpdmVSZW5kZXJVbml0IHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIHByaW1pdGl2ZVByb3ZpZGVyKSB7XHJcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IGNvbnRleHQuY3JlYXRlUHJvZ3JhbSh0ZXh0dXJlZFBvbHlnb25WZXJ0ZXhTaGFkZXIsIHRleHR1cmVkUG9seWdvbkZyYWdtZW50U2hhZGVyLCB7XHJcbiAgICAgICAgICAgIGF0dHJpYk1hcDoge1xyXG4gICAgICAgICAgICAgICAgdmVydGV4UG9zSGlnaDogMCAvKiBQT1NJVElPTl9ISUdIICovLFxyXG4gICAgICAgICAgICAgICAgdmVydGV4UG9zTG93OiAxIC8qIFBPU0lUSU9OX0xPVyAqLyxcclxuICAgICAgICAgICAgICAgIHZlcnRleFVWOiA0IC8qIFVWICovLFxyXG4gICAgICAgICAgICAgICAgdmVydGV4SW1hZ2VTY2FsZTogMTEgLyogQVVYICovLFxyXG4gICAgICAgICAgICAgICAgdmVydGV4WkluZGV4OiAxMCAvKiBaX0lOREVYICovXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBzdXBlcihjb250ZXh0LCBSRU5ERVJfU1RBVEUsIHByb2dyYW0sIHByaW1pdGl2ZVByb3ZpZGVyKTtcclxuICAgICAgICB0aGlzLl9hdGxhc1NpemVVbmlmb3JtID0gdmVjMi5jcmVhdGUoMCwgMCk7XHJcbiAgICAgICAgY29udGV4dC5iaW5kUHJvZ3JhbShwcm9ncmFtKTtcclxuICAgICAgICBwcm9ncmFtLnNldEludFNjYWxhclVuaWZvcm0oJ2F0bGFzJywgMCk7XHJcbiAgICB9XHJcbiAgICBfcmVuZGVyQmF0Y2gobWVtb3J5QmF0Y2gpIHtcclxuICAgICAgICBjb25zdCBhdGxhcyA9IG1lbW9yeUJhdGNoLmZpcnN0UHJpbWl0aXZlLmF0bGFzO1xyXG4gICAgICAgIHRoaXMuX2F0bGFzU2l6ZVVuaWZvcm0ueCA9IGF0bGFzLndpZHRoO1xyXG4gICAgICAgIHRoaXMuX2F0bGFzU2l6ZVVuaWZvcm0ueSA9IGF0bGFzLmhlaWdodDtcclxuICAgICAgICBpZiAoYXRsYXMuaXNEaXJ0eSkge1xyXG4gICAgICAgICAgICBhdGxhcy5zeW5jVGV4dHVyZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9wcm9ncmFtLnNldFZlY3RvcjJVbmlmb3JtKCdhdGxhc1NpemUnLCB0aGlzLl9hdGxhc1NpemVVbmlmb3JtKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRUZXh0dXJlVW5pdCgwKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRUZXh0dXJlKGF0bGFzLnRleHR1cmUpO1xyXG4gICAgICAgIHN1cGVyLl9yZW5kZXJCYXRjaChtZW1vcnlCYXRjaCk7XHJcbiAgICB9XHJcbiAgICBfY2FuQmF0Y2hBZGphY2VudFByaW1pdGl2ZXMoYSwgYikge1xyXG4gICAgICAgIHJldHVybiBzdXBlci5fY2FuQmF0Y2hBZGphY2VudFByaW1pdGl2ZXMoYSwgYikgJiYgKGEuYXRsYXMgPT09IGIuYXRsYXMpO1xyXG4gICAgfVxyXG59XHJcbiIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleFBvc0hpZ2g7XFxuYXR0cmlidXRlIHZlYzIgdmVydGV4UG9zTG93O1xcbmF0dHJpYnV0ZSB2ZWM0IHZlcnRleFVWO1xcbmF0dHJpYnV0ZSBmbG9hdCB2ZXJ0ZXhJbWFnZVNjYWxlO1xcbmF0dHJpYnV0ZSBmbG9hdCB2ZXJ0ZXhaSW5kZXg7XFxuXFxudW5pZm9ybSB2ZWMyIGxvb2tBdEhpZ2g7XFxudW5pZm9ybSB2ZWMyIGxvb2tBdExvdztcXG51bmlmb3JtIG1hdDQgdmlld1Byb2pNYXRyaXg7XFxuXFxudmFyeWluZyB2ZWMyIHV2UG9zaXRpb247XFxudmFyeWluZyB2ZWMyIHRleHR1cmVTaXplO1xcbnZhcnlpbmcgdmVjMiB1dkRpc3BsYWNlbWVudDtcXG5cXG5jb25zdCBmbG9hdCBZVl9IID0gMS45OTk5Njk0ODI0MjE4NzU7XFxuY29uc3QgZmxvYXQgWVZfTCA9IDAuMDAwMDMwNTE3MTEyNDYzNzEyNjkyO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIHV2UG9zaXRpb24gPSB2ZXJ0ZXhVVi54eTtcXG4gICAgdGV4dHVyZVNpemUgPSB2ZXJ0ZXhVVi56dztcXG5cXG4gICAgLy8gVGhlIHNhbWUgcGF0dGVybiBpbWFnZSBzaG91bGQgbWF0Y2ggYWNyb3NzIG11bHRpcGxlICh1c3VhbGx5IGFkamFjZW50KSBwb2x5Z29ucyBhbmQgaXQgc2hvdWxkIGhhdmVcXG4gICAgLy8gc3RhYmxlIHBvc2l0aW9uIHJlYWx0aXZlIHRvIHRoZSBwb2x5Z29uLiBBbHNvIHBhdHRlcm4gaXMgcmVwZWF0ZWQgYXQgYm90aCBkaXJlY3Rpb25zLlxcbiAgICAvLyBUbyBtZWV0IHRoZXNlIHJlcXVpcmVtZW50cyB0aGUgd29ybGQgaXMgY292ZXJlZCAodmlydHVhbGx5KSBieSBhIHRleHR1cmUgb2YgYXBwcm9wcmlhdGUgc2l6ZSAocmVwZWF0ZWQgaW1hZ2UpXFxuICAgIC8vIGFuZCB2ZXJ0ZXggY29vcmRpbmF0ZXMgYXJlIG1hcHBlZCB0byB0aGVzZSB0ZXh0dXJlIGNvb3JkaW5hdGVzICh1dkRpc3BsYWNlbWVudCkuXFxuICAgIC8vIEJ1dCBkdWUgdG8gbGltaXRlZCBwcmVjaXNpb24gd2UndmUgZ290IHRvIHdvcmsgd2l0aCBcXFwibmFycm93XFxcIiBmbG9hdHMgKGFzIGl0IGlzIGRvbmUgaW4gd29ybGQgcG9zaXRpb24gY2FsY3VsYXRpb24pOlxcbiAgICAvLyAgIDEuIGNhbGN1bGF0ZSBob3cgYmlnIHRleHR1cmUgcGF0dGVybiBpbiB3b3JsZCBjb29yZGluYXRlcyAoc2NhbGVkVGV4dHVyZVNpemUpXFxuICAgIC8vICAgMi4gZmluZCB0aGUgY2xvc2VzdCB0byBleWUgY29vcmRpbmF0ZXMgdGV4dHVyZSBiYXNlIHBvaW50ICh0aGUgYm90dG9tIGxlZnQgcG9pbnQgb2YgdGhlIHBhdHRlcm4pXFxuICAgIC8vICAgMy4gdXNlIHZlcnRleCBwb3NpdGlvbiBhbmQgdGV4dHVyZUJhc2VQb2ludCB2ZWN0b3JzIHRvIGZpbmQgY29vcmRpbmF0ZXMgaW4gdmlydHVhbCB0ZXh0dXJlXFxuICAgIC8vICAgNC4gZmluZCB1diBjb29yZGluYXRlcyBpbiByZWFsIHRleHR1cmUgdXNpbmcgbW9kIG9wZXJhdGlvblxcbiAgICAvL1xcbiAgICAvLyBCb3RoIHRleHR1cmVCYXNlUG9pbnQgYW5kIHBvc2l0aW9uIGFyZSByZWxhdGl2ZWxseSBzbWFsbCB2ZWN0b3JzIHNvIHRoYXQgcHJlY2lzaW9uIHJlcXVpcmVtZW50cyBhcmUgbWV0LFxcbiAgICAvLyBhbmQgY29ycmVjdCBpbnRlcnBvbGF0aW9uIG9mIHJlcGVhdGVkIGltYWdlIGlzIHBvc3NpYmxlIGJ5IHVzaW5nIHNpbmdsZSBiYXNlIHBvaW50IGluIGFsbCB2ZXJ0aWNlcy5cXG5cXG4gICAgdmVjMiBzY2FsZWRUZXh0dXJlU2l6ZSA9IHRleHR1cmVTaXplICogdmVydGV4SW1hZ2VTY2FsZTsgLy8gdGV4dHVyZSBzaXplIGluIHdvcmxkIGNvb3JkaW5hdGVzXFxuICAgIHZlYzIgdGV4dHVyZUJhc2VQb2ludCA9IG1vZChZVl9IICogbG9va0F0SGlnaCwgc2NhbGVkVGV4dHVyZVNpemUpICsgbW9kKFlWX0wgKiBsb29rQXRMb3csIHNjYWxlZFRleHR1cmVTaXplKTtcXG4gICAgdmVjMiBwb3NpdGlvbiA9IFlWX0ggKiAodmVydGV4UG9zSGlnaCAtIGxvb2tBdEhpZ2gpICsgWVZfTCAqICh2ZXJ0ZXhQb3NMb3cgLSBsb29rQXRMb3cpO1xcblxcbiAgICBnbF9Qb3NpdGlvbiA9IHZpZXdQcm9qTWF0cml4ICogdmVjNChwb3NpdGlvbiwgMCwgMSk7XFxuICAgIGdsX1Bvc2l0aW9uLnh5IC89IGdsX1Bvc2l0aW9uLnc7XFxuICAgIGdsX1Bvc2l0aW9uLnogPSB2ZXJ0ZXhaSW5kZXg7XFxuICAgIGdsX1Bvc2l0aW9uLncgPSAxLjA7XFxuXFxuICAgIC8vIGNvbnZlcnQgd29ybGQgY29vcmRpbmF0ZXMgYmFjayB0byB0ZXR1cmUgcGl4ZWxzXFxuICAgIHV2RGlzcGxhY2VtZW50ID0gKHBvc2l0aW9uICsgdGV4dHVyZUJhc2VQb2ludCkgLyB2ZXJ0ZXhJbWFnZVNjYWxlO1xcbn1cXG5cIiIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG5cXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbnVuaWZvcm0gc2FtcGxlcjJEIGF0bGFzO1xcbnVuaWZvcm0gdmVjMiBhdGxhc1NpemU7XFxuXFxudmFyeWluZyB2ZWMyIHV2UG9zaXRpb247XFxudmFyeWluZyB2ZWMyIHRleHR1cmVTaXplO1xcbnZhcnlpbmcgdmVjMiB1dkRpc3BsYWNlbWVudDtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgICB2ZWMyIHV2QWRqdXN0ZWQgPSB2ZWMyKFxcbiAgICAgICAgdXZQb3NpdGlvbi54ICsgbW9kKHV2RGlzcGxhY2VtZW50LngsIHRleHR1cmVTaXplLngpLFxcbiAgICAgICAgdXZQb3NpdGlvbi55ICsgbW9kKHV2RGlzcGxhY2VtZW50LnksIHRleHR1cmVTaXplLnkpXFxuICAgICk7XFxuXFxuICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRChhdGxhcywgdXZBZGp1c3RlZCAvIGF0bGFzU2l6ZSk7XFxufVxcblwiIiwiaW1wb3J0IFBvbHlnb25SZW5kZXJlclVuaXQgZnJvbSAnLi9wb2x5Z29uX3JlbmRlcl91bml0JztcclxuaW1wb3J0IFJlbmRlclN0YXRlIGZyb20gJy4uLy4uLy4uL3JlbmRlci9zdGF0ZSc7XHJcbmltcG9ydCB7IERFRkFVTFRfUkVOREVSX1NUQVRFX1BBUkFNUyB9IGZyb20gJy4vcG9seWdvbl9yZW5kZXJfdW5pdCc7XHJcbmltcG9ydCB7IEJMRU5EX09WRVJfUkVOREVSX1NUQVRFIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyL3N0YXRlJztcclxuLyoqXHJcbiAqIFJlbmRlcmVyIG9mIHRyYW5zcGFyZW50IHBvbHlnb24gcHJpbWl0aXZlcy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRyYW5zcGFyZW50UG9seWdvblJlbmRlclVuaXQgZXh0ZW5kcyBQb2x5Z29uUmVuZGVyZXJVbml0IHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIHByaW1pdGl2ZVByb3ZpZGVyKSB7XHJcbiAgICAgICAgc3VwZXIoY29udGV4dCwgcHJpbWl0aXZlUHJvdmlkZXIsIG5ldyBSZW5kZXJTdGF0ZShERUZBVUxUX1JFTkRFUl9TVEFURV9QQVJBTVMsIHsgZGVwdGhNYXNrOiBmYWxzZSB9LCBCTEVORF9PVkVSX1JFTkRFUl9TVEFURSkpO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCBwb2x5Z29uVmVydGV4U2hhZGVyIGZyb20gJy4vc2hhZGVyL3BvbHlnb24udmVydCc7XHJcbmltcG9ydCBwb2x5Z29uRnJhZ21lbnRTaGFkZXIgZnJvbSAnLi9zaGFkZXIvcG9seWdvbi5mcmFnJztcclxuaW1wb3J0IFJlbmRlclN0YXRlIGZyb20gJy4uLy4uLy4uL3JlbmRlci9zdGF0ZSc7XHJcbmltcG9ydCBXb3JsZFByaW1pdGl2ZVJlbmRlclVuaXQgZnJvbSAnLi4vd29ybGRfcHJpbWl0aXZlX3JlbmRlcl91bml0JztcclxuZXhwb3J0IGNvbnN0IERFRkFVTFRfUkVOREVSX1NUQVRFX1BBUkFNUyA9IHtcclxuICAgIGRlcHRoVGVzdDogdHJ1ZSxcclxuICAgIGRlcHRoRnVuYzogNTE4IC8qIEdSRUFURVJfT1JfRVFVQUwgKi9cclxufTtcclxuLyoqXHJcbiAqIFJlbmRlcmVyIG9mIHBvbHlnb24gcHJpbWl0aXZlcy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvbHlnb25SZW5kZXJVbml0IGV4dGVuZHMgV29ybGRQcmltaXRpdmVSZW5kZXJVbml0IHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIHByaW1pdGl2ZVByb3ZpZGVyLCByZW5kZXJTdGF0ZSA9IG5ldyBSZW5kZXJTdGF0ZShERUZBVUxUX1JFTkRFUl9TVEFURV9QQVJBTVMpKSB7XHJcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IGNvbnRleHQuY3JlYXRlUHJvZ3JhbShwb2x5Z29uVmVydGV4U2hhZGVyLCBwb2x5Z29uRnJhZ21lbnRTaGFkZXIsIHtcclxuICAgICAgICAgICAgYXR0cmliTWFwOiB7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhQb3NIaWdoOiAwIC8qIFBPU0lUSU9OX0hJR0ggKi8sXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhQb3NMb3c6IDEgLyogUE9TSVRJT05fTE9XICovLFxyXG4gICAgICAgICAgICAgICAgdmVydGV4Q29sb3I6IDcgLyogQ09MT1IgKi8sXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhaSW5kZXg6IDEwIC8qIFpfSU5ERVggKi9cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHN1cGVyKGNvbnRleHQsIHJlbmRlclN0YXRlLCBwcm9ncmFtLCBwcmltaXRpdmVQcm92aWRlcik7XHJcbiAgICB9XHJcbn1cclxuIiwibW9kdWxlLmV4cG9ydHMgPSBcIiN2ZXJzaW9uIDEwMFxcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxuYXR0cmlidXRlIHZlYzIgdmVydGV4UG9zSGlnaDtcXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhQb3NMb3c7XFxuYXR0cmlidXRlIHZlYzQgdmVydGV4Q29sb3I7XFxuYXR0cmlidXRlIGZsb2F0IHZlcnRleFpJbmRleDtcXG5cXG51bmlmb3JtIHZlYzIgbG9va0F0SGlnaDtcXG51bmlmb3JtIHZlYzIgbG9va0F0TG93O1xcbnVuaWZvcm0gbWF0NCB2aWV3UHJvak1hdHJpeDtcXG5cXG52YXJ5aW5nIHZlYzQgY29sb3I7XFxuXFxuY29uc3QgZmxvYXQgWVZfSCA9IDEuOTk5OTY5NDgyNDIxODc1O1xcbmNvbnN0IGZsb2F0IFlWX0wgPSAwLjAwMDAzMDUxNzExMjQ2MzcxMjY5MjtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgICB2ZWM0IHBvc2l0aW9uID0gdmlld1Byb2pNYXRyaXggKiB2ZWM0KFxcbiAgICAgICAgWVZfSCAqICh2ZXJ0ZXhQb3NIaWdoIC0gbG9va0F0SGlnaCkgK1xcbiAgICAgICAgICAgIFlWX0wgKiAodmVydGV4UG9zTG93IC0gbG9va0F0TG93KSxcXG4gICAgICAgIDAsXFxuICAgICAgICAxXFxuICAgICk7XFxuXFxuICAgIHBvc2l0aW9uLnh5IC89IHBvc2l0aW9uLnc7XFxuICAgIHBvc2l0aW9uLnogPSB2ZXJ0ZXhaSW5kZXg7XFxuICAgIHBvc2l0aW9uLncgPSAxLjA7XFxuXFxuICAgIGdsX1Bvc2l0aW9uID0gcG9zaXRpb247XFxuXFxuICAgIGNvbG9yID0gdmVydGV4Q29sb3I7XFxufVxcblwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIiN2ZXJzaW9uIDEwMFxcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxudmFyeWluZyBsb3dwIHZlYzQgY29sb3I7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxufVxcblwiIiwiaW1wb3J0IEVuZ2luZSBmcm9tICcuL2VuZ2luZSc7XHJcbmltcG9ydCBGeGFhUmVuZGVyVW5pdCBmcm9tICcuL3JlbmRlci9meGFhX3JlbmRlcl91bml0JztcclxuaW1wb3J0IEJhY2tncm91bmRSZW5kZXJVbml0IGZyb20gJy4vcmVuZGVyL2JhY2tncm91bmRfcmVuZGVyX3VuaXQnO1xyXG5pbXBvcnQgTGF5ZXJSZW5kZXJVbml0IGZyb20gJy4vcmVuZGVyL2xheWVyX3JlbmRlcl91bml0JztcclxuLyoqXHJcbiAqIEdyb3VuZCBsYXllciB3aXRoIGJhY2tncm91bmQgdGhhdCBnb2VzIHJpZ2h0IGFmdGVyIHN1YiByZW5kZXIgdW5pdHMuIEl0IGFsbG93cyB0byBhZGQgb3RoZXIgTGF5ZXJSZW5kZXJVbml0cyBhYm92ZVxyXG4gKiBncm91bmRMYXllciB3aXRob3V0IHdvcnJ5aW5nIHRoYXQgdGhleSBkZXN0cm95IGRlcHRoIGluZm9ybWF0aW9uIGNvbGxlY3RlZCBvbiBncm91bmQgYW5kIGJyb2tlIGJhY2tncm91bmQgKHRoYXQgaGFzXHJcbiAqIGEgcGVyZm9ybWFuY2Ugb3B0aW1pc2F0aW9uOiBpdCB1c2VzIGRlcHRoIGluZm9ybWF0aW9uIGZyb20gdGhlIGxheWVycyBiZWxvdyB0byBwcmV2ZW50IGV4dGVuc2l2ZSBwaXhlbCBvdmVyd3JpdGluZykuXHJcbiAqL1xyXG5jbGFzcyBCYWNrZ3JvdW5kZWRHcm91bmRMYXllciBleHRlbmRzIExheWVyUmVuZGVyVW5pdCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBkZXB0aENsZWFyU3RyYXRlZ3kgPSAwIC8qIE5PX0NMRUFSICovKSB7XHJcbiAgICAgICAgc3VwZXIoY29udGV4dCwgZGVwdGhDbGVhclN0cmF0ZWd5KTtcclxuICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kID0gbmV3IEJhY2tncm91bmRSZW5kZXJVbml0KGNvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgcmVuZGVyKHRhcmdldCwgLi4uYXJncykge1xyXG4gICAgICAgIHN1cGVyLnJlbmRlcih0YXJnZXQsIC4uLmFyZ3MpO1xyXG4gICAgICAgIHRoaXMuX2JhY2tncm91bmQucmVuZGVyKHRhcmdldCk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFwRW5naW5lIGV4dGVuZHMgRW5naW5lIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIGNhbWVyYSwgcmVuZGVyTG9vcCkge1xyXG4gICAgICAgIHN1cGVyKGNvbnRleHQsIGNhbWVyYSwgcmVuZGVyTG9vcCk7XHJcbiAgICAgICAgdGhpcy5fZGVzdHJveWFibGVzID0gW107XHJcbiAgICAgICAgY29uc3QgYW50aWFsaWFzaW5nTGF5ZXIgPSBuZXcgRnhhYVJlbmRlclVuaXQoY29udGV4dCwgdGhpcy5yZW5kZXJMb29wKTtcclxuICAgICAgICB0aGlzLmJhY2tnb3VuZExheWVyID0gbmV3IExheWVyUmVuZGVyVW5pdChjb250ZXh0KTtcclxuICAgICAgICB0aGlzLmdyb3VuZExheWVyID0gbmV3IEJhY2tncm91bmRlZEdyb3VuZExheWVyKGNvbnRleHQpO1xyXG4gICAgICAgIHRoaXMuYnVpbGRpbmdzTGF5ZXIgPSBuZXcgTGF5ZXJSZW5kZXJVbml0KGNvbnRleHQpO1xyXG4gICAgICAgIHRoaXMuaWNvbnNMYXllciA9IG5ldyBMYXllclJlbmRlclVuaXQoY29udGV4dCk7XHJcbiAgICAgICAgdGhpcy5sYWJlbHNMYXllciA9IG5ldyBMYXllclJlbmRlclVuaXQoY29udGV4dCk7XHJcbiAgICAgICAgYW50aWFsaWFzaW5nTGF5ZXIuYWRkUmVuZGVyVW5pdCh0aGlzLmJ1aWxkaW5nc0xheWVyKTtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZFJlbmRlclVuaXQodGhpcy5iYWNrZ291bmRMYXllcik7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRSZW5kZXJVbml0KHRoaXMuZ3JvdW5kTGF5ZXIpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIuYWRkUmVuZGVyVW5pdChhbnRpYWxpYXNpbmdMYXllcik7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRSZW5kZXJVbml0KHRoaXMuaWNvbnNMYXllcik7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRSZW5kZXJVbml0KHRoaXMubGFiZWxzTGF5ZXIpO1xyXG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lhYmxlcy5wdXNoKGFudGlhbGlhc2luZ0xheWVyKTtcclxuICAgICAgICAvLyBmb3JjZSBpbml0aWFsIHJlbmRlcmluZyAobm8gZGF0YSB5ZXQsIGp1c3QgYmFja2dyb3VuZCkgYXMgdGhlIGNhbnZhcyAoYmxhY2spIGNhbiBhbHJlYWR5IGJlIHZpc2libGUgdG8gdXNlcnMsXHJcbiAgICAgICAgLy8gcmVuZGVyZXIgaXMgY2FsbGVkIGRpcmVjdGx5ICh3aXRob3V0IHNjaGVkdWxpbmcgdmlhIHJlbmRlciBsb29wKSBhcyBpdCBpcyBwcmV0dHkgbXVjaCBzYWZlIHRvIGFzc3VtZVxyXG4gICAgICAgIC8vIHRoYXQgbm8gcmVuZGVyaW5nIGlzIHNjaGVkdWxlZCBmb3IgdGhpcyBmcmFtZSwgYW5kIGRlZmVycmVkIHVwZGF0ZSBjYW4gcG90ZW50aWFsbHkgY2F1c2UgYSBzaW5nbGUgZnJhbWUgYmxpbmtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbmRlcih0aGlzLl9yZW5kZXJUYXJnZXQpO1xyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICAvLyBkZXN0cm95IGluIHJldmVyc2Ugb3JkZXIgdG8gcHJldmVudCBwb3RlbnRpYWwgaXNzdWVzIGlmIGRlc3Ryb3lhYmxlcyBvd24gZWFjaCBvdGhlclxyXG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9kZXN0cm95YWJsZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgdGhpcy5fZGVzdHJveWFibGVzW2ldLmRlc3Ryb3koKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IFZvaWRFdmVudEVtaXR0ZXIgfSBmcm9tICcuL3V0aWwvZXZlbnRfZW1pdHRlcic7XHJcbmltcG9ydCBSZW5kZXJhYmxlRGZHbHlwaEF0bGFzIGZyb20gJy4vcmVuZGVyL2ZvbnQvcmVuZGVyYWJsZV9kZl9nbHlwaF9hdGxhcyc7XHJcbmltcG9ydCBEZkZvbnRSZWdpc3RyeSBmcm9tICcuL2ZvbnQvZGZfZm9udF9yZWdpc3RyeSc7XHJcbmltcG9ydCBSZW5kZXJhYmxlSW1hZ2VBdGxhcyBmcm9tICcuL3JlbmRlci9iaWxsYm9hcmQvcmVuZGVyYWJsZV9pbWFnZV9hdGxhcyc7XHJcbmltcG9ydCBWaXNpYmlsaXR5TWFuYWdlciBmcm9tICcuL3Zpc2liaWxpdHkvdmlzaWJpbGl0eV9tYW5hZ2VyJztcclxuaW1wb3J0IHsgbWVkaWFuRmlsdGVyIH0gZnJvbSAnLi91dGlsL21lZGlhbl9maWx0ZXInO1xyXG5pbXBvcnQgeyBjb3VudEZwcyB9IGZyb20gJy4vdXRpbC9zdGF0JztcclxuaW1wb3J0IE1haW5SZW5kZXJVbml0IGZyb20gJy4vcmVuZGVyL21haW5fcmVuZGVyX3VuaXQnO1xyXG5pbXBvcnQgTWVtb3J5TWFuYWdlciBmcm9tICcuL3JlbmRlci9tZW1vcnkvbWFuYWdlcic7XHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVuZ2luZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBjYW1lcmEsIHJlbmRlckxvb3ApIHtcclxuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgICAgIHRoaXMuX2NhbWVyYSA9IGNhbWVyYTtcclxuICAgICAgICB0aGlzLl9yZW5kZXJUYXJnZXQgPSBjb250ZXh0LmdldERlZmF1bHRSZW5kZXJUYXJnZXQoKTtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyID0gbmV3IE1haW5SZW5kZXJVbml0KGNvbnRleHQsIGNhbWVyYSk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJMb29wID0gcmVuZGVyTG9vcDtcclxuICAgICAgICB0aGlzLm1lbW9yeU1hbmFnZXIgPSBuZXcgTWVtb3J5TWFuYWdlcihjb250ZXh0KTtcclxuICAgICAgICB0aGlzLl9hdGxhc2VzID0gbmV3IFNldCgpO1xyXG4gICAgICAgIHRoaXMudmlzaWJpbGl0eU1hbmFnZXIgPSBuZXcgVmlzaWJpbGl0eU1hbmFnZXIoY29udGV4dCwgY2FtZXJhLCByZW5kZXJMb29wLCB0aGlzLl9yZW5kZXJUYXJnZXQuZ2V0V2lkdGgoKSwgdGhpcy5fcmVuZGVyVGFyZ2V0LmdldEhlaWdodCgpKTtcclxuICAgICAgICB0aGlzLnZpc2JpbGl0eVRleHR1cmVQcm92aWRlciA9ICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy52aXNpYmlsaXR5TWFuYWdlci51cGRhdGVWaXNpYmlsaXR5SWZOZWVkZWQoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlzaWJpbGl0eU1hbmFnZXIudmlzaWJpbGl0eVRleHR1cmU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLl9mcmFtZVRpbWluZ3NMaXN0ZW5lciA9IHRoaXMuX29uRnJhbWVUaW1lc0Z1bGwuYmluZCh0aGlzKTtcclxuICAgICAgICByZW5kZXJMb29wLm9uRnJhbWVUaW1lc0Z1bGwuYWRkTGlzdGVuZXIodGhpcy5fZnJhbWVUaW1pbmdzTGlzdGVuZXIpO1xyXG4gICAgICAgIHRoaXMuX3JlbmRlckxpc3RlbmVyID0gdGhpcy5fb25SZW5kZXIuYmluZCh0aGlzKTtcclxuICAgICAgICByZW5kZXJMb29wLm9uUmVuZGVyLmFkZExpc3RlbmVyKHRoaXMuX3JlbmRlckxpc3RlbmVyKTtcclxuICAgICAgICB0aGlzLl91cGRhdGVMaXN0ZW5lciA9ICgpID0+IHRoaXMucmVuZGVyTG9vcC51cGRhdGUoKTtcclxuICAgICAgICB0aGlzLmdseXBoQXRsYXMgPSBuZXcgUmVuZGVyYWJsZURmR2x5cGhBdGxhcyhjb250ZXh0KTtcclxuICAgICAgICB0aGlzLmZvbnRSZWdpc3RyeSA9IG5ldyBEZkZvbnRSZWdpc3RyeSgpO1xyXG4gICAgICAgIHRoaXMub25JbnRlcm5hbEVycm9yID0gbmV3IFZvaWRFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLl9jYW1lcmEub25VcGRhdGUuYWRkTGlzdGVuZXIodGhpcy5fdXBkYXRlTGlzdGVuZXIpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIub25VcGRhdGUuYWRkTGlzdGVuZXIodGhpcy5fdXBkYXRlTGlzdGVuZXIpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHRMb3N0TGlzdGVuZXIgPSAoKSA9PiB0aGlzLm9uSW50ZXJuYWxFcnJvci5maXJlKCk7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0Lm9uTG9zcy5hZGRMaXN0ZW5lcih0aGlzLl9jb250ZXh0TG9zdExpc3RlbmVyKTtcclxuICAgIH1cclxuICAgIHNldFJlbmRlclRhcmdldFNpemUod2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9yZW5kZXJUYXJnZXQuZ2V0V2lkdGgoKSAhPT0gd2lkdGggfHxcclxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyVGFyZ2V0LmdldEhlaWdodCgpICE9PSBoZWlnaHQpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyVGFyZ2V0LnNldFNpemUod2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgICAgIHRoaXMudmlzaWJpbGl0eU1hbmFnZXIuc2V0VGFyZ2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjcmVhdGVJbWFnZUF0bGFzKHBhcmFtcykge1xyXG4gICAgICAgIGNvbnN0IGF0bGFzID0gbmV3IFJlbmRlcmFibGVJbWFnZUF0bGFzKHRoaXMuY29udGV4dCwgcGFyYW1zKTtcclxuICAgICAgICBhdGxhcy5vbkNvbnRlbnRVcGRhdGUuYWRkTGlzdGVuZXIodGhpcy5fdXBkYXRlTGlzdGVuZXIpO1xyXG4gICAgICAgIHRoaXMuX2F0bGFzZXMuYWRkKGF0bGFzKTtcclxuICAgICAgICByZXR1cm4gYXRsYXM7XHJcbiAgICB9XHJcbiAgICByZW1vdmVJbWFnZUF0bGFzKGF0bGFzKSB7XHJcbiAgICAgICAgYXRsYXMuZGVzdHJveSgpO1xyXG4gICAgICAgIGF0bGFzLm9uQ29udGVudFVwZGF0ZS5yZW1vdmVMaXN0ZW5lcih0aGlzLl91cGRhdGVMaXN0ZW5lcik7XHJcbiAgICAgICAgdGhpcy5fYXRsYXNlcy5kZWxldGUoYXRsYXMpO1xyXG4gICAgfVxyXG4gICAgZ2V0Q2FtZXJhKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jYW1lcmE7XHJcbiAgICB9XHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMuX2NhbWVyYS5vblVwZGF0ZS5yZW1vdmVMaXN0ZW5lcih0aGlzLl91cGRhdGVMaXN0ZW5lcik7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5vblVwZGF0ZS5yZW1vdmVMaXN0ZW5lcih0aGlzLl91cGRhdGVMaXN0ZW5lcik7XHJcbiAgICAgICAgZm9yIChjb25zdCBhdGxhcyBvZiB0aGlzLl9hdGxhc2VzKSB7XHJcbiAgICAgICAgICAgIGF0bGFzLm9uQ29udGVudFVwZGF0ZS5yZW1vdmVMaXN0ZW5lcih0aGlzLl91cGRhdGVMaXN0ZW5lcik7XHJcbiAgICAgICAgICAgIGF0bGFzLmRlc3Ryb3koKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5nbHlwaEF0bGFzLmRlc3Ryb3koKTtcclxuICAgICAgICB0aGlzLmNvbnRleHQub25Mb3NzLnJlbW92ZUxpc3RlbmVyKHRoaXMuX2NvbnRleHRMb3N0TGlzdGVuZXIpO1xyXG4gICAgfVxyXG4gICAgX29uUmVuZGVyKCkge1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMuX3JlbmRlclRhcmdldCk7XHJcbiAgICB9XHJcbiAgICBfb25GcmFtZVRpbWVzRnVsbCh0aW1lcykge1xyXG4gICAgICAgIGNvdW50RnBzKDFlMyAqIHRpbWVzLmxlbmd0aCAvIG1lZGlhbkZpbHRlcih0aW1lcykucmVkdWNlKChzdW0sIHRpbWUpID0+IHN1bSArIHRpbWUpKTtcclxuICAgICAgICAvLyBGb3Igbm93IHdlIGFjcXVpcmUgZnJhbWUgdGltaW5nIGFuZCBsb2cgdGhlbSBvbmx5IG9uY2UgYSBzZXNzaW9uLlxyXG4gICAgICAgIHRoaXMucmVuZGVyTG9vcC5vbkZyYW1lVGltZXNGdWxsLnJlbW92ZUxpc3RlbmVyKHRoaXMuX2ZyYW1lVGltaW5nc0xpc3RlbmVyKTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgRGZHbHlwaEF0bGFzIGZyb20gJy4uLy4uL2ZvbnQvZGZfZ2x5cGhfYXRsYXMnO1xyXG4vKipcclxuICogQXRsYXMgdGhhdCBtYW5hZ2VzIGFsbG9jYXRpb24gaW4gR0wgdGV4dHVyZS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbmRlcmFibGVEZkdseXBoQXRsYXMgZXh0ZW5kcyBEZkdseXBoQXRsYXMge1xyXG4gICAgY29uc3RydWN0b3IoY29udGV4dCkge1xyXG4gICAgICAgIHN1cGVyKDAsIDAsIG5ldyBVaW50OEFycmF5KDApLCBuZXcgTWFwKCkpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgICAgIHRoaXMudGV4dHVyZSA9IHRoaXMuX2NyZWF0ZVRleHR1cmUoMCwgMCk7XHJcbiAgICB9XHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMudGV4dHVyZS5kZXN0cm95KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIHdob2xlIGNvbnRlbnQgb2YgdGhlIGdseXBoIGJpdG1hcCBhdGxhcywgdGV4dHVyZSBhbHNvIGdldCB1cGRhdGVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB3aWR0aCBuZXcgYml0bWFwIHdpZHRoXHJcbiAgICAgKiBAcGFyYW0gaGVpZ2h0IG5ldyBiaXRtYXAgaGVpZ2h0XHJcbiAgICAgKiBAcGFyYW0gZGF0YSwgbGVuZ3RoIHNob3VsZCBiZSBzdHJpY3RseSBlcXVhbCB0byB3aWR0aCAqIGhlaWdodFxyXG4gICAgICovXHJcbiAgICB1cGRhdGVDb250ZW50KHdpZHRoLCBoZWlnaHQsIGRhdGEsIGdseXBoTG9jYXRpb25zKSB7XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgdGhpcy5fZ2x5cGhMb2NhdGlvbnMgPSBnbHlwaExvY2F0aW9ucztcclxuICAgICAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy50ZXh0dXJlO1xyXG4gICAgICAgIGlmICghdGV4dHVyZSB8fCB0ZXh0dXJlLmdldFdpZHRoKCkgIT09IHdpZHRoIHx8IHRleHR1cmUuZ2V0SGVpZ2h0KCkgIT09IGhlaWdodCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy50ZXh0dXJlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRleHR1cmUuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZSA9IHRoaXMuX2NyZWF0ZVRleHR1cmUod2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuc2V0VGV4dHVyZURhdGEodGhpcy50ZXh0dXJlLCBkYXRhKTtcclxuICAgIH1cclxuICAgIF9jcmVhdGVUZXh0dXJlKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dC5jcmVhdGVFbXB0eTJEVGV4dHVyZSh3aWR0aCwgaGVpZ2h0LCA2NDA2IC8qIEFMUEhBICovLCA1MTIxIC8qIFVOU0lHTkVEX0JZVEUgKi8sIHtcclxuICAgICAgICAgICAgd3JhcFM6IDMzMDcxIC8qIENMQU1QX1RPX0VER0UgKi8sXHJcbiAgICAgICAgICAgIHdyYXBUOiAzMzA3MSAvKiBDTEFNUF9UT19FREdFICovLFxyXG4gICAgICAgICAgICBtYWduaWZpY2F0aW9uRmlsdGVyOiA5NzI5IC8qIExJTkVBUiAqLyxcclxuICAgICAgICAgICAgbWluaWZpY2F0aW9uRmlsdGVyOiA5NzI5IC8qIExJTkVBUiAqLyxcclxuICAgICAgICAgICAgcHJlbXVsdGlwbGllZEFscGhhOiBmYWxzZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbiIsImNvbnN0IFVOS05PV05fR0xZUEhfTE9DQVRJT04gPSB7XHJcbiAgICBtaW5YOiAwLFxyXG4gICAgbWF4WDogMCxcclxuICAgIG1pblk6IDAsXHJcbiAgICBtYXhZOiAwXHJcbn07XHJcbi8qKlxyXG4gKiBBYnN0cmFjdCBnbHlwaCBhdGxhcyBpbnRlcmZhY2UuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZkdseXBoQXRsYXMge1xyXG4gICAgY29uc3RydWN0b3Iod2lkdGgsIGhlaWdodCwgZGF0YSwgZ2x5cGhMb2NhdGlvbnMpIHtcclxuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgICAgICB0aGlzLl9nbHlwaExvY2F0aW9ucyA9IGdseXBoTG9jYXRpb25zO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIEdseXBoIGxvY2F0aW9uIG9yIGZha2UgbG9jYXRpb24gcG9pbnRpbmcgdG8gdGhlIG9yaWdpbiAoMCwgMCkuXHJcbiAgICAgKi9cclxuICAgIGdldEdseXBoTG9jYXRpb24oZm9udElkLCBnbHlwaElkKSB7XHJcbiAgICAgICAgY29uc3QgZ2x5cGhMb2NhdGlvbiA9IHRoaXMuX2dseXBoTG9jYXRpb25zLmdldChmb250SWQgKyBnbHlwaElkKTtcclxuICAgICAgICBpZiAoZ2x5cGhMb2NhdGlvbikge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2x5cGhMb2NhdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignV293LXdvdy13b3csIHNvbWV0aGluZyB3ZW50IHdyb25nLCB5b3Ugc2hvdWxkIG5vdCByZXF1ZXN0IG5vbmV4aXN0ZW50IGdseXBoIGxvY2F0aW9ucycpO1xyXG4gICAgICAgICAgICByZXR1cm4gVU5LTk9XTl9HTFlQSF9MT0NBVElPTjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gQWxsIGdseXBoIGxvY2F0aW9ucyBhcyBbZ2x5cGggaWQsIGdseXBoIGxvY2F0aW9uXSBhcnJheS4gR2x5cGggaWQgaXMgZm9udCBpZCBjb25jYXRlbmF0ZWQgd2l0aCBnbHlwaCBpZC5cclxuICAgICAqL1xyXG4gICAgZ2V0QWxsR2x5cGhMb2NhdGlvbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIFsuLi50aGlzLl9nbHlwaExvY2F0aW9ucy5lbnRyaWVzKCldO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCBGb250UmVnaXN0cnkgZnJvbSAnLi9mb250X3JlZ2lzdHJ5JztcclxuaW1wb3J0IERmRm9udCBmcm9tICcuL2RmX2ZvbnQnO1xyXG4vKipcclxuICogUmVnaXN0cnkgdGhhdCBzdG9yZXMgZGlzdGFuY2UgZmllbGQgZm9udHMuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZkZvbnRSZWdpc3RyeSBleHRlbmRzIEZvbnRSZWdpc3RyeSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcihuZXcgRGZGb250KCdVTktOT1dOX0RGX0ZPTlQnLCAxNCwgMCkpO1xyXG4gICAgfVxyXG59XHJcbiIsIi8qKlxyXG4gKiBBIGNlbnRyYWwgc3RvcmFnZSBvZiBhbGwgYXZhaWxhYmxlIGZvbnRzLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRm9udFJlZ2lzdHJ5IHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHVua25vd25Gb250SW5zdGFuY2UgQW4gaW5zdGFuY2Ugb2Ygc3BlY2lmaWMgZm9udCB0eXBlIHRvIGJlIHNlcnZlZCBhcyBhIHN0dWIgd2hlbiBub25leGlzdGVudCBmb250XHJcbiAgICAgKiAgICAgaXMgcmVxdWVzdGVkLiBSZXF1ZXN0aW5nIG5vbmV4aXN0ZW50IGZvbnRzIG5vcm1hbGx5IHNob3VsZCBub3QgaGFwcGVuLlxyXG4gICAgICogICAgIFRoZSBzdHViIGp1c3QgYWxsb3dzIHRvIGF2b2lkIHRlZGlvdXMgbnVsbCBjaGVja3MgaW4gcmVnaXN0cnkgY2xpZW50cy5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IodW5rbm93bkZvbnRJbnN0YW5jZSkge1xyXG4gICAgICAgIHRoaXMuX2ZvbnRzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuX3Vua25vd25Gb250SW5zdGFuY2UgPSB1bmtub3duRm9udEluc3RhbmNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIElmIGEgZm9udCB3aXRoIHNwZWNpZmllZCBpZCBpcyBpbiB0aGUgcmVnaXN0cnkuXHJcbiAgICAgKi9cclxuICAgIGNvbnRhaW5zKGZvbnRJZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9mb250cy5oYXMoZm9udElkKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiBGb250IHdpdGggc3BlY2lmaWVkIGlkIG9yIHVua25vd24gZm9udCBpbnN0YW5jZSBpZiBpdCBpcyBub3QgZm91bmQuXHJcbiAgICAgKi9cclxuICAgIGdldChmb250SWQpIHtcclxuICAgICAgICBjb25zdCBmb250ID0gdGhpcy5fZm9udHMuZ2V0KGZvbnRJZCk7XHJcbiAgICAgICAgaWYgKGZvbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZvbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1dvdy13b3ctd293LCBzb21ldGhpbmcgd2VudCB3cm9uZywgeW91IHNob3VsZCBub3QgcmVxdWVzdCBub25leGlzdGVudCBmb250cycpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdW5rbm93bkZvbnRJbnN0YW5jZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gQWxsIHN0b3JlZCBmb250cy5cclxuICAgICAqL1xyXG4gICAgZ2V0QWxsKCkge1xyXG4gICAgICAgIHJldHVybiBbLi4udGhpcy5fZm9udHMudmFsdWVzKCldO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIG5ldyBmb3IgdG8gdGhlIHJlZ2lzdHJ5LlxyXG4gICAgICovXHJcbiAgICBhZGQoZm9udCkge1xyXG4gICAgICAgIHRoaXMuX2ZvbnRzLnNldChmb250LmlkLCBmb250KTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgSW1hZ2VBdGxhcyBmcm9tICcuLi8uLi9iaWxsYm9hcmQvaW1hZ2VfYXRsYXMnO1xyXG4vKipcclxuICogQXRsYXMgdGhhdCBtYW5hZ2VzIGFsbG9jYXRpb24gaW4gR0wgdGV4dHVyZS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbmRlcmFibGVJbWFnZUF0bGFzIGV4dGVuZHMgSW1hZ2VBdGxhcyB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBwYXJhbXMpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIGNvbnN0IHsgZmlsdGVyLCBwcmVtdWx0aXBsaWVkQWxwaGEgfSA9IHBhcmFtcztcclxuICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcclxuICAgICAgICB0aGlzLl9maWx0ZXIgPSBmaWx0ZXI7XHJcbiAgICAgICAgdGhpcy5fcHJlbXVsdGlwbGllZEFscGhhID0gcHJlbXVsdGlwbGllZEFscGhhO1xyXG4gICAgICAgIHRoaXMudGV4dHVyZSA9IHRoaXMuX2NyZWF0ZVRleHR1cmUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIGZpbHRlciwgcHJlbXVsdGlwbGllZEFscGhhKTtcclxuICAgICAgICB0aGlzLmlzRGlydHkgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyBHTCB0ZXh0dXJlIHdpdGggY2hhbmdlZCBkYXRhLiBTaG91bGQgYmUgY2FsbGVkIGFmdGVyIGVhY2ggaW1hZ2UgYWRkZWQgdG8gdGFrZSBlZmZlY3QgaW4gc2hhZGVycy5cclxuICAgICAqL1xyXG4gICAgc3luY1RleHR1cmUoKSB7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5zZXRUZXh0dXJlRGF0YUZyb21Eb21FbGVtZW50KHRoaXMudGV4dHVyZSwgdGhpcy5jYW52YXMpO1xyXG4gICAgICAgIHRoaXMuaXNEaXJ0eSA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlSW1hZ2UobG9jYXRpb24sIHNvdXJjZUltYWdlLCBsb2NhdGlvblJlZ2lvbiwgc291cmNlSW1hZ2VSZWdpb24pIHtcclxuICAgICAgICBzdXBlci51cGRhdGVJbWFnZShsb2NhdGlvbiwgc291cmNlSW1hZ2UsIGxvY2F0aW9uUmVnaW9uLCBzb3VyY2VJbWFnZVJlZ2lvbik7XHJcbiAgICAgICAgdGhpcy5pc0RpcnR5ID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy50ZXh0dXJlLmRlc3Ryb3koKTtcclxuICAgIH1cclxuICAgIF9leHBhbmQobmV3V2lkdGgsIG5ld0hlaWdodCkge1xyXG4gICAgICAgIHN1cGVyLl9leHBhbmQobmV3V2lkdGgsIG5ld0hlaWdodCk7XHJcbiAgICAgICAgdGhpcy50ZXh0dXJlLmRlc3Ryb3koKTtcclxuICAgICAgICB0aGlzLnRleHR1cmUgPSB0aGlzLl9jcmVhdGVUZXh0dXJlKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB0aGlzLl9maWx0ZXIsIHRoaXMuX3ByZW11bHRpcGxpZWRBbHBoYSk7XHJcbiAgICAgICAgdGhpcy5pc0RpcnR5ID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIF9jcmVhdGVUZXh0dXJlKHdpZHRoLCBoZWlnaHQsIGZpbHRlciwgcHJlbXVsdGlwbGllZEFscGhhKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuY3JlYXRlRW1wdHkyRFRleHR1cmUod2lkdGgsIGhlaWdodCwgNjQwOCAvKiBSR0JBICovLCA1MTIxIC8qIFVOU0lHTkVEX0JZVEUgKi8sIHtcclxuICAgICAgICAgICAgbWluaWZpY2F0aW9uRmlsdGVyOiBmaWx0ZXIsXHJcbiAgICAgICAgICAgIG1hZ25pZmljYXRpb25GaWx0ZXI6IGZpbHRlcixcclxuICAgICAgICAgICAgd3JhcFM6IDMzMDcxIC8qIENMQU1QX1RPX0VER0UgKi8sXHJcbiAgICAgICAgICAgIHdyYXBUOiAzMzA3MSAvKiBDTEFNUF9UT19FREdFICovLFxyXG4gICAgICAgICAgICBwcmVtdWx0aXBsaWVkQWxwaGFcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBjcmVhdGVCQm94MiB9IGZyb20gJy4uL21hdGgvdmVjdG9yMic7XHJcbmltcG9ydCB7IFNoZWxmQWxsb2NhdG9yMkQgfSBmcm9tICcuLi91dGlsL2FsbG9jYXRvcl8yZCc7XHJcbmltcG9ydCB7IFZvaWRFdmVudEVtaXR0ZXIgfSBmcm9tICcuLi91dGlsL2V2ZW50X2VtaXR0ZXInO1xyXG5jb25zdCBJTklUX0FUTEFTX1dJRFRIID0gMjU2O1xyXG5jb25zdCBJTklUX0FUTEFTX0hFSUdIVCA9IDI1NjtcclxuY29uc3QgTUFYX0FUTEFTX1dJRFRIID0gMjA0ODtcclxuY29uc3QgTUFYX0FUTEFTX0hFSUdIVCA9IDIwNDg7XHJcbmNvbnN0IEVYUEFORF9GQUNUT1IgPSAyO1xyXG4vKipcclxuICogTWFuYWdlcyBhbGxvY2F0aW9uIG9mIGltYWdlcy4gSXQgcmVzaXplcyBpdHNlbGYgKHVwIHRvIGEgZml4ZWQgbGltaXQpIHdoZW4gdGhlcmUgaXMgbm8gcmVnaW9uXHJcbiAqIG9mIGVub3VnaCBzaXplIGZvciB0aGUgbmV4dCBpbWFnZS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEltYWdlQXRsYXMge1xyXG4gICAgY29uc3RydWN0b3IoaW5pdEF0bGFzV2lkdGggPSBJTklUX0FUTEFTX1dJRFRILCBpbml0QXRsYXNIZWlnaHQgPSBJTklUX0FUTEFTX0hFSUdIVCkge1xyXG4gICAgICAgIHRoaXMub25Db250ZW50VXBkYXRlID0gbmV3IFZvaWRFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gaW5pdEF0bGFzV2lkdGg7XHJcbiAgICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gaW5pdEF0bGFzSGVpZ2h0O1xyXG4gICAgICAgIHRoaXMuX2NhbnZhc0NvbnRleHQgPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgIHRoaXMuX2FsbG9jYXRvciA9IG5ldyBTaGVsZkFsbG9jYXRvcjJEKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuICAgIH1cclxuICAgIGdldCB3aWR0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jYW52YXMud2lkdGg7XHJcbiAgICB9XHJcbiAgICBnZXQgaGVpZ2h0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhcy5oZWlnaHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFsbG9jYXRlcyBpbWFnZSBiaXRtYXAuXHJcbiAgICAgKi9cclxuICAgIGFsbG9jYXRlSW1hZ2UoZGVzY3JpcHRvciwgaW1hZ2UpIHtcclxuICAgICAgICBjb25zdCBsb2NhdGlvbiA9IHRoaXMuX2FsbG9jYXRlKGRlc2NyaXB0b3IpO1xyXG4gICAgICAgIGlmIChsb2NhdGlvbikge1xyXG4gICAgICAgICAgICBjb25zdCByZWdpb24gPSBjcmVhdGVCQm94MigwLCBkZXNjcmlwdG9yLndpZHRoLCAwLCBkZXNjcmlwdG9yLmhlaWdodCk7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSW1hZ2UobG9jYXRpb24sIGltYWdlLCByZWdpb24sIHJlZ2lvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBsb2NhdGlvbjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVzZXJ2ZXMgc3BhY2Ugb2YgYXBwcm9wcmlhdGUgc2l6ZSB0aGF0IGNhbiBiZSB1cGRhdGVkIGxhdGVyIHdpdGggdXBkYXRlSW1hZ2UoKSBtZXRob2QuXHJcbiAgICAgKi9cclxuICAgIHJlc2VydmVMb2NhdGlvbihkZXNjcmlwdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FsbG9jYXRlKGRlc2NyaXB0b3IpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIGltYWdlIGNvbnRlbnQgaW4gYXBwcm9wcmlhdGUgbG9jYXRpb24uIEFzc3VtZXMgdGhhdCB0aGVyZSBpcyByZWFsbHkgc3VjaCBsb2NhdGlvbiByZXNlcnZlZCxcclxuICAgICAqIG5vIGNoZWNrIGZvciB0aGlzIGlzIGRvbmUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGxvY2F0aW9uIExvY2F0aW9uIGluIGF0bGFzIG9mIHRoZSBpbWFnZS5cclxuICAgICAqIEBwYXJhbSBzb3VyY2VJbWFnZSBJbWFnZSB0byB1cGRhdGUgYXRsYXMgZnJvbS5cclxuICAgICAqIEBwYXJhbSBsb2NhdGlvblJlZ2lvbiBSZWdpb24gKGJib3ggd2l0aCBjb29yZGluYXRlcyByZWxhdGl2ZSB0byB0aGUgbG9jYXRpb24ncyBiYm94KSBvZiB0aGUgbG9jYXRpb24gdG8gdXBkYXRlLlxyXG4gICAgICogQHBhcmFtIHNvdXJjZUltYWdlUmVnaW9uIFJlZ2lvbiBvZiB0aGUgaW1hZ2UgKEJCb3gyIGluIGltYWdlJ3MgY29vcmRpbmF0ZSBzcGFjZSkgdG8gYmUgY29waWVkIGludG8gYXRsYXMuXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZUltYWdlKGxvY2F0aW9uLCBzb3VyY2VJbWFnZSwgbG9jYXRpb25SZWdpb24gPSBjcmVhdGVCQm94MigwLCBsb2NhdGlvbi5tYXhYIC0gbG9jYXRpb24ubWluWCwgMCwgbG9jYXRpb24ubWF4WSAtIGxvY2F0aW9uLm1pblkpLCBzb3VyY2VJbWFnZVJlZ2lvbiA9IGNyZWF0ZUJCb3gyKDAsIHNvdXJjZUltYWdlLndpZHRoLCAwLCBzb3VyY2VJbWFnZS5oZWlnaHQpKSB7XHJcbiAgICAgICAgY29uc3Qgc3JjWCA9IHNvdXJjZUltYWdlUmVnaW9uLm1pblg7XHJcbiAgICAgICAgY29uc3Qgc3JjWSA9IHNvdXJjZUltYWdlUmVnaW9uLm1pblk7XHJcbiAgICAgICAgY29uc3Qgc3JjVyA9IHNvdXJjZUltYWdlUmVnaW9uLm1heFggLSBzb3VyY2VJbWFnZVJlZ2lvbi5taW5YO1xyXG4gICAgICAgIGNvbnN0IHNyY0ggPSBzb3VyY2VJbWFnZVJlZ2lvbi5tYXhZIC0gc291cmNlSW1hZ2VSZWdpb24ubWluWTtcclxuICAgICAgICBjb25zdCBkc3RYID0gbG9jYXRpb24ubWluWCArIGxvY2F0aW9uUmVnaW9uLm1pblg7XHJcbiAgICAgICAgY29uc3QgZHN0WSA9IGxvY2F0aW9uLm1pblkgKyBsb2NhdGlvblJlZ2lvbi5taW5ZO1xyXG4gICAgICAgIGNvbnN0IGRzdFcgPSBsb2NhdGlvblJlZ2lvbi5tYXhYIC0gbG9jYXRpb25SZWdpb24ubWluWDtcclxuICAgICAgICBjb25zdCBkc3RIID0gbG9jYXRpb25SZWdpb24ubWF4WSAtIGxvY2F0aW9uUmVnaW9uLm1pblk7XHJcbiAgICAgICAgdGhpcy5fY2FudmFzQ29udGV4dC5jbGVhclJlY3QoZHN0WCwgZHN0WSwgZHN0VywgZHN0SCk7XHJcbiAgICAgICAgdGhpcy5fY2FudmFzQ29udGV4dC5kcmF3SW1hZ2Uoc291cmNlSW1hZ2UsIHNyY1gsIHNyY1ksIHNyY1csIHNyY0gsIGRzdFgsIGRzdFksIGRzdFcsIGRzdEgpO1xyXG4gICAgICAgIHRoaXMub25Db250ZW50VXBkYXRlLmZpcmUoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGVhbGxvY2F0ZXMgaW1hZ2UgZnJvbSB0aGUgYXRsYXMuXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZUltYWdlKGltYWdlKSB7XHJcbiAgICAgICAgdGhpcy5fYWxsb2NhdG9yLmRlYWxsb2NhdGUoaW1hZ2UpO1xyXG4gICAgfVxyXG4gICAgX2FsbG9jYXRlKGRlc2NyaXB0b3IpIHtcclxuICAgICAgICBsZXQgbG9jYXRpb24gPSB0aGlzLl9hbGxvY2F0b3IuYWxsb2NhdGUoZGVzY3JpcHRvcik7XHJcbiAgICAgICAgLy8gaW5jcmVtZW50YWwgZXhwYW5kIGNhbiBiZSBpbmVmZmljaWVudCBpZiB0d28gb3IgbW9yZSBpdGVyYXRpb25zIGFyZSBuZWVkZWQgdG8gYWxsb2NhdGUgYW4gaW1hZ2UsXHJcbiAgICAgICAgLy8gYnV0IGl0IGlzIGV4cGVjdGVkIHRvIGJlIGEgcmFyZSAoaWYgYW55KSBjYXNlLCByZXdvcmsgaWYgaXQgdHVybnMgb3V0IHRvIGJlIHdyb25nXHJcbiAgICAgICAgd2hpbGUgKCFsb2NhdGlvbikge1xyXG4gICAgICAgICAgICBjb25zdCBleHBhbmRlZFdpZHRoID0gdGhpcy53aWR0aCAqIEVYUEFORF9GQUNUT1I7XHJcbiAgICAgICAgICAgIGNvbnN0IGV4cGFuZGVkSGVpZ2h0ID0gdGhpcy5oZWlnaHQgKiBFWFBBTkRfRkFDVE9SO1xyXG4gICAgICAgICAgICBpZiAoZXhwYW5kZWRXaWR0aCA8PSBNQVhfQVRMQVNfV0lEVEggJiYgZXhwYW5kZWRIZWlnaHQgPD0gTUFYX0FUTEFTX0hFSUdIVCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZXhwYW5kKGV4cGFuZGVkV2lkdGgsIGV4cGFuZGVkSGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIGxvY2F0aW9uID0gdGhpcy5fYWxsb2NhdG9yLmFsbG9jYXRlKGRlc2NyaXB0b3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGxvY2F0aW9uO1xyXG4gICAgfVxyXG4gICAgX2V4cGFuZChuZXdXaWR0aCwgbmV3SGVpZ2h0KSB7XHJcbiAgICAgICAgdGhpcy5fYWxsb2NhdG9yLnJlc2l6ZShuZXdXaWR0aCwgbmV3SGVpZ2h0KTtcclxuICAgICAgICAvLyBzZXR0aW5nIG5ldyB3aWR0aC9oZWlnaHQgdG8gY2FudmFzIHdpbGwgY2xlYXIgaXQsXHJcbiAgICAgICAgLy8gc28gY3VycmVudCBkYXRhIGlzIHNhdmVkIHRvIGJlIHJlc3RvcmVkIGltbWVkaWF0ZWx5IGFmdGVyIHJlc2l6aW5nXHJcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuX2NhbnZhc0NvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IG5ld1dpZHRoO1xyXG4gICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IG5ld0hlaWdodDtcclxuICAgICAgICB0aGlzLl9jYW52YXNDb250ZXh0LnB1dEltYWdlRGF0YShkYXRhLCAwLCAwKTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBBcmVuYUFsbG9jYXRvciwgRnJlZUxpc3RBbGxvY2F0b3IgfSBmcm9tICcuL2FsbG9jYXRvcic7XHJcbi8qKlxyXG4gKiBBIHJlY3Rhbmd1bGFyIHJlZ2lvbiB3aXRoIGZpeGVkIGhlaWdodC4gVXRpbGl0eSBjbGFzcyBmb3Igc2hlbGYgYWxsb2NhdGlvbiBkZWZpbmVkIGJlbG93LlxyXG4gKi9cclxuY2xhc3MgU2hlbGYge1xyXG4gICAgY29uc3RydWN0b3Iod2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICB0aGlzLl9hbGxvY2F0b3IgPSBuZXcgRnJlZUxpc3RBbGxvY2F0b3IodGhpcy53aWR0aCk7XHJcbiAgICB9XHJcbiAgICBhbGxvY2F0ZSh3aWR0aCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hbGxvY2F0b3IuYWxsb2NhdGUod2lkdGgpO1xyXG4gICAgfVxyXG4gICAgZGVhbGxvY2F0ZShvZmZzZXQpIHtcclxuICAgICAgICB0aGlzLl9hbGxvY2F0b3IuZGVhbGxvY2F0ZShvZmZzZXQpO1xyXG4gICAgfVxyXG4gICAgaXNBbGxvY2F0ZWQob2Zmc2V0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FsbG9jYXRvci5pc0FsbG9jYXRlZChvZmZzZXQpO1xyXG4gICAgfVxyXG4gICAgY2FuQWxsb2NhdGUod2lkdGgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWxsb2NhdG9yLm1heEFsbG9jYWJsZVNpemUgPj0gd2lkdGg7XHJcbiAgICB9XHJcbiAgICByZXNpemUod2lkdGgpIHtcclxuICAgICAgICB0aGlzLl9hbGxvY2F0b3IuZXh0ZW5kKHdpZHRoKTtcclxuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEFsbG9jYXRlcyByZWN0YW5nbGVzIGluIFwic2hlbHZlc1wiIChoZWlnaHQgZml4ZWQgcmVnaW9ucykuIFRoZXkgYXJlIGNyZWF0ZWQgb2YgbmVjZXNzaXR5IHdoZW4gdGhlIG5leHQgb2JqZWN0IGRvZXNudFxyXG4gKiBmaXQgYW55IGV4aXN0aW5nIHNoZWxmLiBUbyBvcHRpbWl6ZSBzcGFjZSB1c2FnZSBpdCB0cmllcyB0byBmaW5kIHRoZSBiZXN0IHNoZWxmIGZvciBhbGxvY2F0aW9uIChtaW4gaGVpZ2h0IGRpZmYpLlxyXG4gKiBBIHNoZWxmIHdoZW4gYWxsb2NhdGVkIGlzIG5ldmVyIGRlYWxsb2NhdGVkIGJhY2sgYW5kIGV4aXN0cyBkdXJpbmcgYWxsIHRoZSBhbGxvY2F0b3IgbGlmZXRpbWUuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgU2hlbGZBbGxvY2F0b3IyRCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMuX3NoZWx2ZXMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5fc2hlbGZBbGxvY2F0b3IgPSBuZXcgQXJlbmFBbGxvY2F0b3IoaGVpZ2h0KTsgLy8gbm8gc2hlbGYgZGVhbGxvY2F0aW9uLCB0aGF0IGlzIHdoeSBBcmVuYUFsbG9jYXRvciBpcyBmaW5lXHJcbiAgICB9XHJcbiAgICBhbGxvY2F0ZShvYmplY3QpIHtcclxuICAgICAgICBsZXQgYmVzdFNoZWxmO1xyXG4gICAgICAgIGxldCBiZXN0U2hlbGZPZmZzZXQgPSAtMTtcclxuICAgICAgICBsZXQgYmVzdFNoZWxmUmF0aW8gPSAtMTtcclxuICAgICAgICBmb3IgKGNvbnN0IFtvZmZzZXQsIHNoZWxmXSBvZiB0aGlzLl9zaGVsdmVzLmVudHJpZXMoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBzaGVsZlJhdGlvID0gb2JqZWN0LmhlaWdodCAvIHNoZWxmLmhlaWdodDtcclxuICAgICAgICAgICAgaWYgKHNoZWxmUmF0aW8gPT09IDEgJiYgc2hlbGYuY2FuQWxsb2NhdGUob2JqZWN0LndpZHRoKSkge1xyXG4gICAgICAgICAgICAgICAgYmVzdFNoZWxmID0gc2hlbGY7XHJcbiAgICAgICAgICAgICAgICBiZXN0U2hlbGZPZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzaGVsZlJhdGlvIDwgMSAmJiBzaGVsZlJhdGlvID4gYmVzdFNoZWxmUmF0aW8gJiYgc2hlbGYuY2FuQWxsb2NhdGUob2JqZWN0LndpZHRoKSkge1xyXG4gICAgICAgICAgICAgICAgYmVzdFNoZWxmID0gc2hlbGY7XHJcbiAgICAgICAgICAgICAgICBiZXN0U2hlbGZPZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICBiZXN0U2hlbGZSYXRpbyA9IHNoZWxmUmF0aW87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFiZXN0U2hlbGYgJiYgdGhpcy5fc2hlbGZBbGxvY2F0b3IubWF4QWxsb2NhYmxlU2l6ZSA+PSBvYmplY3QuaGVpZ2h0ICYmIHRoaXMud2lkdGggPj0gb2JqZWN0LndpZHRoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuX3NoZWxmQWxsb2NhdG9yLmFsbG9jYXRlKG9iamVjdC5oZWlnaHQpO1xyXG4gICAgICAgICAgICBiZXN0U2hlbGYgPSBuZXcgU2hlbGYodGhpcy53aWR0aCwgb2JqZWN0LmhlaWdodCk7XHJcbiAgICAgICAgICAgIGJlc3RTaGVsZk9mZnNldCA9IG9mZnNldDtcclxuICAgICAgICAgICAgdGhpcy5fc2hlbHZlcy5zZXQob2Zmc2V0LCBiZXN0U2hlbGYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYmVzdFNoZWxmKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBiZXN0U2hlbGYuYWxsb2NhdGUob2JqZWN0LndpZHRoKTtcclxuICAgICAgICAgICAgY29uc3QgdG9wID0gYmVzdFNoZWxmT2Zmc2V0O1xyXG4gICAgICAgICAgICBjb25zdCBsb2NhdGlvbiA9IHtcclxuICAgICAgICAgICAgICAgIG1pblg6IGxlZnQsXHJcbiAgICAgICAgICAgICAgICBtYXhYOiBsZWZ0ICsgb2JqZWN0LndpZHRoLFxyXG4gICAgICAgICAgICAgICAgbWluWTogdG9wLFxyXG4gICAgICAgICAgICAgICAgbWF4WTogdG9wICsgb2JqZWN0LmhlaWdodFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gbG9jYXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBkZWFsbG9jYXRlKG9iamVjdExvY2F0aW9uKSB7XHJcbiAgICAgICAgY29uc3Qgc2hlbGYgPSB0aGlzLl9zaGVsdmVzLmdldChvYmplY3RMb2NhdGlvbi5taW5ZKTtcclxuICAgICAgICBpZiAoc2hlbGYpIHtcclxuICAgICAgICAgICAgc2hlbGYuZGVhbGxvY2F0ZShvYmplY3RMb2NhdGlvbi5taW5YKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpc0FsbG9jYXRlZChvYmplY3RMb2NhdGlvbikge1xyXG4gICAgICAgIGNvbnN0IHNoZWxmID0gdGhpcy5fc2hlbHZlcy5nZXQob2JqZWN0TG9jYXRpb24ubWluWSk7XHJcbiAgICAgICAgcmV0dXJuICEhc2hlbGYgJiYgc2hlbGYuaXNBbGxvY2F0ZWQob2JqZWN0TG9jYXRpb24ubWluWCk7XHJcbiAgICB9XHJcbiAgICByZXNpemUod2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIHRoaXMuX3NoZWxmQWxsb2NhdG9yLmV4dGVuZChoZWlnaHQpO1xyXG4gICAgICAgIGZvciAoY29uc3Qgc2hlbGYgb2YgdGhpcy5fc2hlbHZlcy52YWx1ZXMoKSkge1xyXG4gICAgICAgICAgICBzaGVsZi5yZXNpemUod2lkdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgQmluYXJ5U2VhcmNoVHJlZSB9IGZyb20gJy4vYmluYXJ5X3RyZWUnO1xyXG5pbXBvcnQgTGlua2VkU2V0IGZyb20gJy4vbGlua2VkX3NldCc7XHJcbi8qKlxyXG4gKiBBbGlnbmVzIGFuIG9mZnNldCBzbyBpdCdzIGEgbXVsdGlwbGUgb2YgYW4gYWxpZ25tZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0gb2Zmc2V0IFRoZSBvZmZzZXQuXHJcbiAqIEBwYXJhbSBhbGlnbm1lbnQgVGhlIGFsaWdubWVudC5cclxuICogQHJldHVybnMgQWxpZ25lZCBvZmZzZXQuXHJcbiAqL1xyXG5mdW5jdGlvbiBhbGlnbihvZmZzZXQsIGFsaWdubWVudCkge1xyXG4gICAgcmV0dXJuIGFsaWdubWVudCAqIE1hdGguY2VpbChvZmZzZXQgLyBhbGlnbm1lbnQpO1xyXG59XHJcbmV4cG9ydCBjbGFzcyBBcmVuYUFsbG9jYXRvciB7XHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgZW1wdHkgYXJlbmEgYWxsb2NhdG9yLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzaXplIFNpemUgb2YgbWFuYWdlZCByZWdpb24uXHJcbiAgICAgKiBAcGFyYW0gYWxpZ25tZW50IGFsaWdubWVudCBvZiBvZmZzZXRzLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihzaXplLCBhbGlnbm1lbnQgPSAxKSB7XHJcbiAgICAgICAgdGhpcy5fc2l6ZSA9IHNpemU7XHJcbiAgICAgICAgdGhpcy5fYWxpZ25tZW50ID0gYWxpZ25tZW50O1xyXG4gICAgICAgIHRoaXMuX2ZyZWVPZmZzZXQgPSAwO1xyXG4gICAgICAgIHRoaXMuX2FsbG9jYXRlZE9mZnNldHMgPSBuZXcgU2V0KCk7XHJcbiAgICB9XHJcbiAgICBnZXQgc2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZTtcclxuICAgIH1cclxuICAgIGdldCBtYXhBbGxvY2FibGVTaXplKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zaXplIC0gdGhpcy5fZnJlZU9mZnNldDtcclxuICAgIH1cclxuICAgIGdldCBpc0VtcHR5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hbGxvY2F0ZWRPZmZzZXRzLnNpemUgPT09IDA7XHJcbiAgICB9XHJcbiAgICBhbGxvY2F0ZShzaXplKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3NpemUgPj0gdGhpcy5fZnJlZU9mZnNldCArIHNpemUpIHtcclxuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5fZnJlZU9mZnNldDtcclxuICAgICAgICAgICAgdGhpcy5fZnJlZU9mZnNldCA9IGFsaWduKG9mZnNldCArIHNpemUsIHRoaXMuX2FsaWdubWVudCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2FsbG9jYXRlZE9mZnNldHMuYWRkKG9mZnNldCk7XHJcbiAgICAgICAgICAgIHJldHVybiBvZmZzZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZGVhbGxvY2F0ZShvZmZzZXQpIHtcclxuICAgICAgICB0aGlzLl9hbGxvY2F0ZWRPZmZzZXRzLmRlbGV0ZShvZmZzZXQpO1xyXG4gICAgfVxyXG4gICAgaXNBbGxvY2F0ZWQob2Zmc2V0KSB7XHJcbiAgICAgICAgcmV0dXJuIG9mZnNldCA8IHRoaXMuX2ZyZWVPZmZzZXQ7XHJcbiAgICB9XHJcbiAgICBleHRlbmQobmV3U2l6ZSkge1xyXG4gICAgICAgIGlmIChuZXdTaXplIDwgdGhpcy5fZnJlZU9mZnNldCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCByZWR1Y2UgdGhlIHNpemUgYmVjYXVzZSBpdCBjb25mbGljdHMgd2l0aCBhbHJlYWR5IGFsbG9jYXRlZCByZWdpb24uJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3NpemUgPSBuZXdTaXplO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBbGxvY2F0b3Igb3B0aW1pc2VkIGZvciBib3RoIHByaW1hcnkgb3BlcmF0aW9uczogYWxsb2NhdGlvbiBhbmQgZGVhbGxvY2F0aW9uLiBJdCB1c2VzIEJTVCBmb3IgZWZmaWNpZW50IGxvb2t1cCBvZlxyXG4gKiBzdWl0YWJsZSBmcmVlIHJlZ2lvbiBkdXJpbmcgYWxsb2NhdGlvbiBhbmQgdHdvIHdheSBsaW5rZWQgbGlzdCBmb3IgZmFzdCBhZGphY2VudCBmcmVlIHJlZ2lvbnMgbWVyZ2UuXHJcbiAqIE1heCBhbGxvY2FibGUgc2l6ZSBpcyBhbHNvIGRldGVybWluZWQgYnkgbWVhbnMgb2YgdGhlIEJTVC5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBGcmVlTGlzdEFsbG9jYXRvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihzaXplKSB7XHJcbiAgICAgICAgdGhpcy5fc2l6ZSA9IHNpemU7XHJcbiAgICAgICAgdGhpcy5fYWxsUmVnaW9ucyA9IG5ldyBMaW5rZWRTZXQoKTtcclxuICAgICAgICB0aGlzLl9vY2N1cGllZFJlZ2lvbnMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5fZnJlZVJlZ2lvbnMgPSBuZXcgQmluYXJ5U2VhcmNoVHJlZSgocmFuZ2VBLCByYW5nZUIpID0+IHJhbmdlQS5zaXplIC0gcmFuZ2VCLnNpemUpO1xyXG4gICAgICAgIGNvbnN0IGluaXRSZWdpb24gPSB7IG9mZnNldDogMCwgc2l6ZSB9O1xyXG4gICAgICAgIHRoaXMuX2FsbFJlZ2lvbnMuaW5zZXJ0KGluaXRSZWdpb24pO1xyXG4gICAgICAgIGluaXRSZWdpb24uX2ZyZWVOb2RlID0gdGhpcy5fZnJlZVJlZ2lvbnMuaW5zZXJ0KGluaXRSZWdpb24pO1xyXG4gICAgfVxyXG4gICAgZ2V0IHNpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpemU7XHJcbiAgICB9XHJcbiAgICBnZXQgbWF4QWxsb2NhYmxlU2l6ZSgpIHtcclxuICAgICAgICBjb25zdCBtYXggPSB0aGlzLl9mcmVlUmVnaW9ucy5tYXg7XHJcbiAgICAgICAgcmV0dXJuIG1heCA/IG1heC5zaXplIDogMDtcclxuICAgIH1cclxuICAgIGdldCBpc0VtcHR5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9vY2N1cGllZFJlZ2lvbnMuc2l6ZSA9PT0gMDtcclxuICAgIH1cclxuICAgIGFsbG9jYXRlKHNpemUpIHtcclxuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5fZmluZE1pblN1aXRhYmxlKHNpemUpO1xyXG4gICAgICAgIGlmICghbm9kZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJhbmdlID0gbm9kZS52YWx1ZTtcclxuICAgICAgICAvLyBjdXJyZW50IHJlZ2lvbiBpcyBub3QgYXZhaWxhYmxlIGFueW1vcmVcclxuICAgICAgICAvLyBpdCBpcyByZW1vdmVkIGZyb20gdGhlIGZyZWUgcmVnaW9ucyBwb29sXHJcbiAgICAgICAgdGhpcy5fZnJlZVJlZ2lvbnMucmVtb3ZlKG5vZGUpO1xyXG4gICAgICAgIC8vIG5ldyBvY2N1cGllZCBvbmUgaXMgY3JlYXRlZFxyXG4gICAgICAgIGNvbnN0IG9jY3VwaWVkUmFuZ2UgPSB7IG9mZnNldDogcmFuZ2Uub2Zmc2V0LCBzaXplIH07XHJcbiAgICAgICAgdGhpcy5fb2NjdXBpZWRSZWdpb25zLnNldChyYW5nZS5vZmZzZXQsIG9jY3VwaWVkUmFuZ2UpO1xyXG4gICAgICAgIHRoaXMuX2FsbFJlZ2lvbnMuaW5zZXJ0QWZ0ZXIocmFuZ2UsIG9jY3VwaWVkUmFuZ2UpO1xyXG4gICAgICAgIHRoaXMuX2FsbFJlZ2lvbnMucmVtb3ZlKHJhbmdlKTtcclxuICAgICAgICAvLyBkb250IGxvb3NlIHJlbWFpbmluZyBpZiBhbnlcclxuICAgICAgICAvLyBpdCBzaG91bGQgYmUgcmV0dXJuZWQgYmFjayB0byB0aGUgZnJlZSByZWdpb25zIHBvb2xcclxuICAgICAgICBpZiAocmFuZ2Uuc2l6ZSA+IHNpemUpIHtcclxuICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nUmFuZ2UgPSB7IG9mZnNldDogcmFuZ2Uub2Zmc2V0ICsgc2l6ZSwgc2l6ZTogcmFuZ2Uuc2l6ZSAtIHNpemUgfTtcclxuICAgICAgICAgICAgcmVtYWluaW5nUmFuZ2UuX2ZyZWVOb2RlID0gdGhpcy5fZnJlZVJlZ2lvbnMuaW5zZXJ0KHJlbWFpbmluZ1JhbmdlKTtcclxuICAgICAgICAgICAgdGhpcy5fYWxsUmVnaW9ucy5pbnNlcnRBZnRlcihvY2N1cGllZFJhbmdlLCByZW1haW5pbmdSYW5nZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvY2N1cGllZFJhbmdlLm9mZnNldDtcclxuICAgIH1cclxuICAgIGRlYWxsb2NhdGUob2Zmc2V0KSB7XHJcbiAgICAgICAgbGV0IHJlZ2lvbiA9IHRoaXMuX29jY3VwaWVkUmVnaW9ucy5nZXQob2Zmc2V0KTtcclxuICAgICAgICBpZiAocmVnaW9uKSB7XHJcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSByZWdpb24gY2FuIGJlIG1lcmdlZCB3aXRoIGl0cyBwcmV2aW91cyBuZWlnaGJvclxyXG4gICAgICAgICAgICBjb25zdCBwcmV2ID0gdGhpcy5fYWxsUmVnaW9ucy5nZXRQcmV2KHJlZ2lvbik7XHJcbiAgICAgICAgICAgIGlmIChwcmV2ICYmIHByZXYuX2ZyZWVOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbWJyYWNpbmdSYW5nZSA9IHsgb2Zmc2V0OiBwcmV2Lm9mZnNldCwgc2l6ZTogcHJldi5zaXplICsgcmVnaW9uLnNpemUgfTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FsbFJlZ2lvbnMuaW5zZXJ0QWZ0ZXIocHJldiwgZW1icmFjaW5nUmFuZ2UpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWxsUmVnaW9ucy5yZW1vdmUocmVnaW9uKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FsbFJlZ2lvbnMucmVtb3ZlKHByZXYpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZnJlZVJlZ2lvbnMucmVtb3ZlKHByZXYuX2ZyZWVOb2RlKTtcclxuICAgICAgICAgICAgICAgIHJlZ2lvbiA9IGVtYnJhY2luZ1JhbmdlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSByZWdpb24gY2FuIGJlIG1lcmdlZCB3aXRoIGl0cyBuZXh0IG5laWdoYm9yXHJcbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLl9hbGxSZWdpb25zLmdldE5leHQocmVnaW9uKTtcclxuICAgICAgICAgICAgaWYgKG5leHQgJiYgbmV4dC5fZnJlZU5vZGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVtYnJhY2luZ1JhbmdlID0geyBvZmZzZXQ6IHJlZ2lvbi5vZmZzZXQsIHNpemU6IHJlZ2lvbi5zaXplICsgbmV4dC5zaXplIH07XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hbGxSZWdpb25zLmluc2VydEJlZm9yZShuZXh0LCBlbWJyYWNpbmdSYW5nZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hbGxSZWdpb25zLnJlbW92ZShyZWdpb24pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWxsUmVnaW9ucy5yZW1vdmUobmV4dCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9mcmVlUmVnaW9ucy5yZW1vdmUobmV4dC5fZnJlZU5vZGUpO1xyXG4gICAgICAgICAgICAgICAgcmVnaW9uID0gZW1icmFjaW5nUmFuZ2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fb2NjdXBpZWRSZWdpb25zLmRlbGV0ZShvZmZzZXQpO1xyXG4gICAgICAgICAgICByZWdpb24uX2ZyZWVOb2RlID0gdGhpcy5fZnJlZVJlZ2lvbnMuaW5zZXJ0KHJlZ2lvbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaXNBbGxvY2F0ZWQob2Zmc2V0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX29jY3VwaWVkUmVnaW9ucy5oYXMob2Zmc2V0KTtcclxuICAgIH1cclxuICAgIGV4dGVuZChuZXdTaXplKSB7XHJcbiAgICAgICAgaWYgKG5ld1NpemUgPCB0aGlzLl9zaXplKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2l6ZSByZWR1Y2luZyBpcyBub3QgYWxsb3dlZCBpbiBmcmVlIGxpc3QgYWxsb2NhdG9yJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGRpZmYgPSBuZXdTaXplIC0gdGhpcy5fc2l6ZTtcclxuICAgICAgICBjb25zdCBsYXN0ID0gdGhpcy5fYWxsUmVnaW9ucy5lbmQ7XHJcbiAgICAgICAgaWYgKGxhc3QgJiYgbGFzdC5fZnJlZU5vZGUpIHtcclxuICAgICAgICAgICAgdGhpcy5fZnJlZVJlZ2lvbnMucmVtb3ZlKGxhc3QuX2ZyZWVOb2RlKTtcclxuICAgICAgICAgICAgY29uc3QgcmVnaW9uID0geyBvZmZzZXQ6IGxhc3Qub2Zmc2V0LCBzaXplOiBsYXN0LnNpemUgKyBkaWZmLCBpc0ZyZWU6IHRydWUgfTtcclxuICAgICAgICAgICAgdGhpcy5fYWxsUmVnaW9ucy5pbnNlcnRBZnRlcihsYXN0LCByZWdpb24pO1xyXG4gICAgICAgICAgICB0aGlzLl9hbGxSZWdpb25zLnJlbW92ZShsYXN0KTtcclxuICAgICAgICAgICAgdGhpcy5fZnJlZVJlZ2lvbnMuaW5zZXJ0KHJlZ2lvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCByZWdpb24gPSB7IG9mZnNldDogdGhpcy5fc2l6ZSwgc2l6ZTogZGlmZiwgaXNGcmVlOiB0cnVlIH07XHJcbiAgICAgICAgICAgIHRoaXMuX2FsbFJlZ2lvbnMuaW5zZXJ0KHJlZ2lvbik7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZyZWVSZWdpb25zLmluc2VydChyZWdpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9zaXplID0gbmV3U2l6ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVHJhdmVyc2VzIEJTVCB0byBmaW5kIHRoZSBzbWFsbGVzdCByZWdpb24gcmVxdWlyZWQgc2l6ZSBjYW4gZml0LlxyXG4gICAgICovXHJcbiAgICBfZmluZE1pblN1aXRhYmxlKHNpemUpIHtcclxuICAgICAgICBsZXQgbm9kZSA9IHRoaXMuX2ZyZWVSZWdpb25zLnJvb3Q7XHJcbiAgICAgICAgbGV0IGJlc3Q7XHJcbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUudmFsdWUuc2l6ZSA9PT0gc2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgYmVzdCA9IG5vZGU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChub2RlLnZhbHVlLnNpemUgPCBzaXplKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGJlc3QgPSBub2RlO1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYmVzdDtcclxuICAgIH1cclxufVxyXG4iLCIvKipcclxuICogU2ltcGxlIGltcGxlbWVudGF0aW9uIG9mIEJpbmFyeSBTZWFyY2ggVHJlZS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBCaW5hcnlTZWFyY2hUcmVlIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGNvbXBhcmF0b3IgVG8gc3BlY2lmeSB0aGUgb3JkZXIgb2YgaXRlbXMsIHRoYXQgY2FuIGJlIGFueSBjb21wbGV4IG9iamVjdHMuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGNvbXBhcmF0b3IpIHtcclxuICAgICAgICB0aGlzLl9jb21wYXJhdG9yID0gY29tcGFyYXRvcjtcclxuICAgICAgICB0aGlzLl9zaXplID0gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVGhlIHJvb3QgZWxlbWVudCBvciBgdW5kZWZpbmVkYCBpZiB0aGUgdHJlZSBpcyBlbXB0eS5cclxuICAgICAqL1xyXG4gICAgZ2V0IHJvb3QoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3Q7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIHRyZWUuXHJcbiAgICAgKi9cclxuICAgIGdldCBzaXplKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zaXplO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgc21hbGxlc3QgZWxlbWVudCBpbiB0aGUgdHJlZSBvciBgdW5kZWZpbmVkYCB0aGUgdGhlIHRyZWUgaXMgZW1wdHkuXHJcbiAgICAgKi9cclxuICAgIGdldCBtaW4oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3Jvb3QpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21pbih0aGlzLl9yb290KS52YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVGhlIGJpZ2dlc3QgZWxlbWVudCBpbiB0aGUgdHJlZSBvciBgdW5kZWZpbmVkYCB0aGUgdGhlIHRyZWUgaXMgZW1wdHkuXHJcbiAgICAgKi9cclxuICAgIGdldCBtYXgoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3Jvb3QpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21heCh0aGlzLl9yb290KS52YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIGluc2VydChpdGVtKSB7XHJcbiAgICAgICAgdGhpcy5fc2l6ZSsrO1xyXG4gICAgICAgIGlmICghdGhpcy5fcm9vdCkge1xyXG4gICAgICAgICAgICB0aGlzLl9yb290ID0geyB2YWx1ZTogaXRlbSB9O1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcm9vdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLl9yb290O1xyXG4gICAgICAgIHdoaWxlIChub2RlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9jb21wYXJhdG9yKGl0ZW0sIG5vZGUudmFsdWUpIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFub2RlLmxlZnQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5sZWZ0ID0geyBwYXJlbnQ6IG5vZGUsIHZhbHVlOiBpdGVtIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFub2RlLnJpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUucmlnaHQgPSB7IHBhcmVudDogbm9kZSwgdmFsdWU6IGl0ZW0gfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGltcG9zc2libGUgdG8gZ2V0IHRoZXJlLCB0aHJvd2luZyBpcyB0byBtYWtlIFRTIGFuYWxpemF0b3IgaGFwcHlcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcclxuICAgIH1cclxuICAgIHJlbW92ZShub2RlKSB7XHJcbiAgICAgICAgdGhpcy5fc2l6ZS0tO1xyXG4gICAgICAgIGlmIChub2RlLmxlZnQgJiYgbm9kZS5yaWdodCkge1xyXG4gICAgICAgICAgICBjb25zdCBzdWNjZXNzb3IgPSB0aGlzLl9taW4obm9kZS5yaWdodCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlcGxhY2VTdWJ0cmVlKG5vZGUsIHN1Y2Nlc3Nvcik7XHJcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBsaW5rcyB0byBjaGlsZHJlbiBvZiB0aGUgcmVtb3ZlZCBub2RlXHJcbiAgICAgICAgICAgIGlmIChub2RlLmxlZnQpIHtcclxuICAgICAgICAgICAgICAgIHN1Y2Nlc3Nvci5sZWZ0ID0gbm9kZS5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgbm9kZS5sZWZ0LnBhcmVudCA9IHN1Y2Nlc3NvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobm9kZS5yaWdodCkge1xyXG4gICAgICAgICAgICAgICAgc3VjY2Vzc29yLnJpZ2h0ID0gbm9kZS5yaWdodDtcclxuICAgICAgICAgICAgICAgIG5vZGUucmlnaHQucGFyZW50ID0gc3VjY2Vzc29yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG5vZGUubGVmdCkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZXBsYWNlU3VidHJlZShub2RlLCBub2RlLmxlZnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChub2RlLnJpZ2h0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlcGxhY2VTdWJ0cmVlKG5vZGUsIG5vZGUucmlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVwbGFjZVN1YnRyZWUobm9kZSwgdW5kZWZpbmVkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEl0ZXJhdGVzIGVsZW1lbnRzIGluIGFzY2VuZGluZyBvcmRlci5cclxuICAgICAqL1xyXG4gICAgKnZhbHVlcyhub2RlKSB7XHJcbiAgICAgICAgaWYgKG5vZGUpIHtcclxuICAgICAgICAgICAgeWllbGQqIHRoaXMudmFsdWVzKG5vZGUubGVmdCk7XHJcbiAgICAgICAgICAgIHlpZWxkIG5vZGUudmFsdWU7XHJcbiAgICAgICAgICAgIHlpZWxkKiB0aGlzLnZhbHVlcyhub2RlLnJpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEl0ZXJhdGVzIGVsZW1lbnRzIGluIGFzY2VuZGluZyBvcmRlci5cclxuICAgICAqL1xyXG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzKHRoaXMuX3Jvb3QpO1xyXG4gICAgfVxyXG4gICAgX21pbihmcm9tKSB7XHJcbiAgICAgICAgbGV0IG5vZGUgPSBmcm9tO1xyXG4gICAgICAgIHdoaWxlIChub2RlLmxlZnQpIHtcclxuICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICB9XHJcbiAgICBfbWF4KGZyb20pIHtcclxuICAgICAgICBsZXQgbm9kZSA9IGZyb207XHJcbiAgICAgICAgd2hpbGUgKG5vZGUucmlnaHQpIHtcclxuICAgICAgICAgICAgbm9kZSA9IG5vZGUucmlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW9yZ2FuaXplcyB0aGUgdHJlZSBzdHJ1Y3R1cmUgc28gdGhhdCB0aGUgcmVwbGFjZW1lbnQgbm9kZSB0YWtlcyByZXBsYWNlYWJsZSdzIHBvc2l0aW9uLCB0aGUgbGF0dGVyIGlzIHJlbW92ZWQuXHJcbiAgICAgKi9cclxuICAgIF9yZXBsYWNlU3VidHJlZShyZXBsYWNlYWJsZSwgcmVwbGFjZW1lbnQpIHtcclxuICAgICAgICBpZiAocmVwbGFjZWFibGUucGFyZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChyZXBsYWNlYWJsZS5wYXJlbnQubGVmdCA9PT0gcmVwbGFjZWFibGUpIHtcclxuICAgICAgICAgICAgICAgIHJlcGxhY2VhYmxlLnBhcmVudC5sZWZ0ID0gcmVwbGFjZW1lbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocmVwbGFjZWFibGUucGFyZW50LnJpZ2h0ID09PSByZXBsYWNlYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgcmVwbGFjZWFibGUucGFyZW50LnJpZ2h0ID0gcmVwbGFjZW1lbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jvb3QgPSByZXBsYWNlbWVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlcGxhY2VtZW50KSB7XHJcbiAgICAgICAgICAgIC8vIHJlbW92ZSByZXBsYWNlbWVudCBmcm9tIGl0cyBjdXJyZW50IGxvY2F0aW9uXHJcbiAgICAgICAgICAgIGlmIChyZXBsYWNlbWVudC5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChyZXBsYWNlbWVudC5wYXJlbnQubGVmdCA9PT0gcmVwbGFjZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudC5wYXJlbnQubGVmdCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlcGxhY2VtZW50LnBhcmVudC5yaWdodCA9PT0gcmVwbGFjZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudC5wYXJlbnQucmlnaHQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVwbGFjZW1lbnQucGFyZW50ID0gcmVwbGFjZWFibGUucGFyZW50O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCIvKipcclxuICogU2V0IHdpdGggcHJlZGljdGFibGUgaXRlcmF0aW9uIG9yZGVyLiBTdG9yZXMgaXRlbXMgYXMgYSB0d28gd2F5IGxpbmtlZCBsaXN0IHRodXMgYWxsb3dpbmcgdG8gaW5zZXJ0IGl0ZW1zIGluIGJldHdlZW4uXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaW5rZWRTZXQge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5fbm9kZXMgPSBuZXcgTWFwKCk7XHJcbiAgICB9XHJcbiAgICBnZXQgYmVnaW4oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JlZ2luICYmIHRoaXMuX2JlZ2luLnZhbHVlO1xyXG4gICAgfVxyXG4gICAgZ2V0IGVuZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZW5kICYmIHRoaXMuX2VuZC52YWx1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSW5zZXJ0cyBhIG5ldyBpdGVtIGF0IHRoZSBlbmQgb2YgdGhlIHNldC5cclxuICAgICAqL1xyXG4gICAgaW5zZXJ0KGl0ZW0pIHtcclxuICAgICAgICBpZiAoIXRoaXMuX25vZGVzLmhhcyhpdGVtKSkge1xyXG4gICAgICAgICAgICBjb25zdCBub2RlID0geyB2YWx1ZTogaXRlbSB9O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fZW5kKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluc2VydEFmdGVyKHRoaXMuX2VuZC52YWx1ZSwgaXRlbSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9iZWdpbiA9IHRoaXMuX2VuZCA9IG5vZGU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9ub2Rlcy5zZXQoaXRlbSwgbm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEluc2VydHMgYSBuZXcgaXRlbSBiZWZvcmUgdGhlIHNwZWNpZmllZCBvbmUuIElmIHRoZSBiZWZvcmUgaXRlbSBpcyBub3QgaW4gdGhlIHNldCBvclxyXG4gICAgICogdGhlIGl0ZW0gaXMgYWxyZWFkeSBpbnNlcnRlZCBub3RoaW5nIGhhcHBlbnMuXHJcbiAgICAgKi9cclxuICAgIGluc2VydEJlZm9yZShiZWZvcmUsIGl0ZW0pIHtcclxuICAgICAgICBjb25zdCBiZWZvcmVOb2RlID0gdGhpcy5fbm9kZXMuZ2V0KGJlZm9yZSk7XHJcbiAgICAgICAgaWYgKGJlZm9yZU5vZGUgJiYgIXRoaXMuX25vZGVzLmhhcyhpdGVtKSkge1xyXG4gICAgICAgICAgICBjb25zdCBub2RlID0geyB2YWx1ZTogaXRlbSB9O1xyXG4gICAgICAgICAgICBpZiAoYmVmb3JlTm9kZS5wcmV2KSB7XHJcbiAgICAgICAgICAgICAgICBiZWZvcmVOb2RlLnByZXYubmV4dCA9IG5vZGU7XHJcbiAgICAgICAgICAgICAgICBub2RlLnByZXYgPSBiZWZvcmVOb2RlLnByZXY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbm9kZS5uZXh0ID0gYmVmb3JlTm9kZTtcclxuICAgICAgICAgICAgYmVmb3JlTm9kZS5wcmV2ID0gbm9kZTtcclxuICAgICAgICAgICAgdGhpcy5fbm9kZXMuc2V0KGl0ZW0sIG5vZGUpO1xyXG4gICAgICAgICAgICBpZiAoYmVmb3JlTm9kZSA9PT0gdGhpcy5fYmVnaW4pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2JlZ2luID0gbm9kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSW5zZXJ0cyBhIG5ldyBpdGVtIGFmdGVyIHRoZSBzcGVjaWZpZWQgb25lLiBJZiB0aGUgYWZ0ZXIgaXRlbSBpcyBub3QgaW4gdGhlIHNldCBvclxyXG4gICAgICogdGhlIGl0ZW0gaXMgYWxyZWFkeSBpbnNlcnRlZCBub3RoaW5nIGhhcHBlbnMuXHJcbiAgICAgKi9cclxuICAgIGluc2VydEFmdGVyKGFmdGVyLCBpdGVtKSB7XHJcbiAgICAgICAgY29uc3QgYWZ0ZXJOb2RlID0gdGhpcy5fbm9kZXMuZ2V0KGFmdGVyKTtcclxuICAgICAgICBpZiAoYWZ0ZXJOb2RlICYmICF0aGlzLl9ub2Rlcy5oYXMoaXRlbSkpIHtcclxuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHsgdmFsdWU6IGl0ZW0gfTtcclxuICAgICAgICAgICAgaWYgKGFmdGVyTm9kZS5uZXh0KSB7XHJcbiAgICAgICAgICAgICAgICBhZnRlck5vZGUubmV4dC5wcmV2ID0gbm9kZTtcclxuICAgICAgICAgICAgICAgIG5vZGUubmV4dCA9IGFmdGVyTm9kZS5uZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG5vZGUucHJldiA9IGFmdGVyTm9kZTtcclxuICAgICAgICAgICAgYWZ0ZXJOb2RlLm5leHQgPSBub2RlO1xyXG4gICAgICAgICAgICB0aGlzLl9ub2Rlcy5zZXQoaXRlbSwgbm9kZSk7XHJcbiAgICAgICAgICAgIGlmIChhZnRlck5vZGUgPT09IHRoaXMuX2VuZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZW5kID0gbm9kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBpdGVtIGZyb20gdGhlIHNldC5cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlKGl0ZW0pIHtcclxuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5fbm9kZXMuZ2V0KGl0ZW0pO1xyXG4gICAgICAgIGlmIChub2RlKSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlID09PSB0aGlzLl9iZWdpbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYmVnaW4gPSBub2RlLm5leHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG5vZGUgPT09IHRoaXMuX2VuZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZW5kID0gbm9kZS5wcmV2O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChub2RlLm5leHQpIHtcclxuICAgICAgICAgICAgICAgIG5vZGUubmV4dC5wcmV2ID0gbm9kZS5wcmV2O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChub2RlLnByZXYpIHtcclxuICAgICAgICAgICAgICAgIG5vZGUucHJldi5uZXh0ID0gbm9kZS5uZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX25vZGVzLmRlbGV0ZShpdGVtKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIGB1bmRlZmluZWRgIGlmIHRoZSBpdGVtIGlzIG5vdCBpbiB0aGUgc2V0IG9yIGl0IGlzIHRoZSBmaXJzdCBlbGVtZW50cy5cclxuICAgICAqL1xyXG4gICAgZ2V0UHJldihpdGVtKSB7XHJcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuX25vZGVzLmdldChpdGVtKTtcclxuICAgICAgICBpZiAobm9kZSAmJiBub2RlLnByZXYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5vZGUucHJldi52YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgYHVuZGVmaW5lZGAgaWYgdGhlIGl0ZW0gaXMgbm90IGluIHRoZSBzZXQgb3IgaXQgaXMgdGhlIGxhc3QgZWxlbWVudHMuXHJcbiAgICAgKi9cclxuICAgIGdldE5leHQoaXRlbSkge1xyXG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLl9ub2Rlcy5nZXQoaXRlbSk7XHJcbiAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS5uZXh0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlLm5leHQudmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEl0ZXJhdGVzIG92ZXIgdGhlIHNldCBmcm9tIHRoZSBmaXN0IGVsZW1lbnQgdG8gdGhlIGxhc3QgKGluIHRoZSBvcmRlciBvZiBpbnNlcnRpb25cclxuICAgICAqIGlmIHRoZSBpbnNlcnQgbWV0aG9kIHdhcyB1c2VkIG9ubHkpLlxyXG4gICAgICovXHJcbiAgICAqdmFsdWVzKCkge1xyXG4gICAgICAgIGxldCBub2RlID0gdGhpcy5fYmVnaW47XHJcbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcclxuICAgICAgICAgICAgeWllbGQgbm9kZS52YWx1ZTtcclxuICAgICAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEl0ZXJhdGVzIG92ZXIgdGhlIHNldCBmcm9tIHRoZSBmaXN0IGVsZW1lbnQgdG8gdGhlIGxhc3QgKGluIHRoZSBvcmRlciBvZiBpbnNlcnRpb25cclxuICAgICAqIGlmIHRoZSBpbnNlcnQgbWV0aG9kIHdhcyB1c2VkIG9ubHkpLlxyXG4gICAgICovXHJcbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZXMoKTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgUmVuZGVyU3RhdGUgZnJvbSAnLi4vcmVuZGVyL3N0YXRlJztcclxuaW1wb3J0ICogYXMgY29sb3IgZnJvbSAnLi4vdXRpbC9jb2xvcic7XHJcbmltcG9ydCAqIGFzIHZlYzIgZnJvbSAnLi4vbWF0aC92ZWN0b3IyJztcclxuaW1wb3J0ICogYXMgdmVjMyBmcm9tICcuLi9tYXRoL3ZlY3RvcjMnO1xyXG5pbXBvcnQgKiBhcyBtYXQ0IGZyb20gJy4uL21hdGgvbWF0cml4NCc7XHJcbmltcG9ydCBHcmlkU2FtcGxlckJ1ZmZlcldyaXRlciwgeyBBVFRSSUJVVEVfTUFQUElORyBhcyBHUklEX1NBTVBMRVJfQVRUUklCVVRFUyB9IGZyb20gJy4vZ3JpZF9zYW1wbGVyX2J1ZmZlcl93cml0ZXInO1xyXG5pbXBvcnQgeyBWb2lkRXZlbnRFbWl0dGVyIH0gZnJvbSAnLi4vdXRpbC9ldmVudF9lbWl0dGVyJztcclxuaW1wb3J0IEdyaWRSZW5kZXJlciBmcm9tICcuL2dyaWRfcmVuZGVyZXInO1xyXG5pbXBvcnQgUmVzZXRSZW1vdmVkUHJpbWl0aXZlcyBmcm9tICcuL3Zpc2liaWxpdHlfcmVzb2x1dGlvbl9zdGVwcy9yZXNldF9yZW1vdmVkX3ByaW1pdGl2ZXMnO1xyXG5pbXBvcnQgRmFkZW91dEFsbCBmcm9tICcuL3Zpc2liaWxpdHlfcmVzb2x1dGlvbl9zdGVwcy9mYWRlb3V0X2FsbCc7XHJcbmltcG9ydCBGYWRlaW5WaXNpYmxlIGZyb20gJy4vdmlzaWJpbGl0eV9yZXNvbHV0aW9uX3N0ZXBzL2ZhZGVpbl92aXNpYmxlJztcclxuaW1wb3J0IEZhZGVvdXRPdmVybGFwcGVkIGZyb20gJy4vdmlzaWJpbGl0eV9yZXNvbHV0aW9uX3N0ZXBzL2ZhZGVvdXRfb3ZlcmxhcHBlZCc7XHJcbmltcG9ydCB7IGNhbGN1bGF0ZUNhbWVyYVBvc2l0aW9ucyB9IGZyb20gJy4uL3JlbmRlci91dGlsL2NhbWVyYV9wb3NpdGlvbic7XHJcbmltcG9ydCBnZXREcHIgZnJvbSAnLi4vdXRpbC9oZCc7XHJcbmNvbnN0IEZBRElOR19TVE9QUEVEID0gLTE7XHJcbmNvbnN0IERFRkFVTFRfRkFERV9FRkZFQ1RfRFVSQVRJT04gPSAxNTA7XHJcbmNvbnN0IElEX0NPTVBPTkVOVF9TSVpFID0gMjU2O1xyXG5jb25zdCBWSVNJQklMSVRZX0lOSVRfU1RBVEUgPSBuZXcgUmVuZGVyU3RhdGUoe1xyXG4gICAgY2xlYXJDb2xvcjogY29sb3IuY3JlYXRlKDAsIDAsIDAsIDApLFxyXG4gICAgZGl0aGVyOiBmYWxzZVxyXG59KTtcclxuY29uc3QgRU1QVFlfR1JJRF9DRUxMID0gY29sb3IuY3JlYXRlKDAsIDAsIDAsIDEpO1xyXG5jb25zdCBESVJFQ1RfUFJJT1JJVFlfR1JJRF9TVEFURSA9IG5ldyBSZW5kZXJTdGF0ZSh7XHJcbiAgICBjbGVhckNvbG9yOiBFTVBUWV9HUklEX0NFTEwsXHJcbiAgICBkZXB0aFRlc3Q6IHRydWUsXHJcbiAgICBjbGVhckRlcHRoOiAwLFxyXG4gICAgLy8gcHJpbWl0aXZlcyB3aXRoIGVxdWFsIHByaW9yaXR5IGFyZSByZXNvbHZlZCBhcyBmb2xsb3dpbmc6IGxhdGVyIG9uZXMgb3ZlcmxhcCBwcmV2aW91c1xyXG4gICAgZGVwdGhGdW5jOiA1MTggLyogR1JFQVRFUl9PUl9FUVVBTCAqLyxcclxuICAgIGRpdGhlcjogZmFsc2VcclxufSk7XHJcbmNvbnN0IFJFVkVSU0VfUFJJT1JJVFlfR1JJRF9TVEFURSA9IG5ldyBSZW5kZXJTdGF0ZSh7XHJcbiAgICBjbGVhckNvbG9yOiBFTVBUWV9HUklEX0NFTEwsXHJcbiAgICBkZXB0aFRlc3Q6IHRydWUsXHJcbiAgICBjbGVhckRlcHRoOiAxLFxyXG4gICAgZGVwdGhGdW5jOiA1MTMgLyogTEVTUyAqLyxcclxuICAgIGRpdGhlcjogZmFsc2VcclxufSk7XHJcbi8vIHNpemUgb2YgbWluaW1hbCByZWNvZ25pemFibGUgc3F1YXJlIHNpZGUgaW4gY3NzIHBpeGVscy5cclxuY29uc3QgR1JJRF9QUkVDSVNJT05fUFggPSA2O1xyXG4vKipcclxuICogQXBhcnQgZnJvbSBiZWluZyByZW1vdmVkIGZyb20gc2NlbmUgdGhlcmUgYXJlIG90aGVyIHJlYXNvbnMgZm9yIHByaW1pdGl2ZXMgdG8gYmUgaW52aXNpYmxlOiBlLmcuIHRoZXkgYXJlXHJcbiAqIG92ZXJsYXBwZWQgYnkgcHJpbWl0aXZlcyB3aXRoIGhpZ2hlciBwcmlvcml0eS4gVGhpcyBzdGF0ZSBpcyBoaWdobHkgZHluYW1pYywgcHJpbWl0aXZlcyBtYXkgYmUgb2YgZGlmZmVyZW50IHR5cGVzLFxyXG4gKiBmcm9tIGRpZmZlcmVudCBzb3VyY2VzIGFuZCB0aGV5IGNhbiBoYXZlIHF1aXRlIG5vbi10cml2aWFsIHNoYXBlcy4gU28gdGhlcmUgc2hvdWxkIGJlIGEgc2luZ2xlIHBvaW50IG9mIGNvbGxpc2lvblxyXG4gKiByZXNvbHV0aW9uIGZvciBhbGwgcHJpbWl0aXZlcyBpbiBzY2VuZSwgdGhhdCBpcyB3aGF0IHZpc2liaWxpdHkgbWFuYWdlciBpcy5cclxuICpcclxuICogVmlzaWJpbGl0eSBvZiBwcmltaXRpdmVzIGlzIGNhbGN1bGF0ZWQgZXZlcnkgZnJhbWUuIFRvIHN1cHBvcnQgZmFkZS1pbi9vdXQgYW5pbWF0aW9uIHZpc2liaWxpdHkgdmFsdWUgaXMgYSBmYWN0b3JcclxuICogdGhlIGFscGhhIGNoYW5uZWwgb2YgYSBmaW5hbGx5IHJlbmRlcmVkIHByaW1pdGl2ZSBpcyB0byBiZSBtdWx0aXBsaWVkIGJ5ICh2YWx1ZSBmcm9tIDAuMCB0byAxLjApLiBGb3IgaW5zdGFuY2UsXHJcbiAqIGlmIGFuIG9iamVjdCBpcyBqdXN0IGFwcGVhcmVkIG9uIHRoZSBzY2VuZSwgdGhpcyBmYWN0b3Igd2lsbCBiZSBjaGFuZ2VkIGZyb20gMC4wIHRvIDEuMCBpbiBmYWRlRWZmZWN0RHVyYXRpb25NcyBtcy5cclxuICogVGhlcmUgYXJlIDQgc3RlcHMgdGhlIHdob2xlIHByb2Nlc3MgY2FuIGJlIHJvdWdobHkgc3VtbWFyaXplZCBpbnRvOlxyXG4gKiAgMS4gYWN0dWFsaXphdGlvbiAtIHJlc2V0IHZhbHVlcyBmb3IgcmVtb3ZlZCBmcm9tIHNjZW5lIHByaW1pdGl2ZXNcclxuICogIDIuIGZhZGUtb3V0IGFsbCAtIGV2ZW4gdGhvdWdoIGFsbCBwcmltaXRpdmVzIGFyZSBmYWRlZCBvdXQgYXQgdGhpcyBzdGVwLCB0aGlzIHN0ZXAgaXMgaW50ZW5kZWQgZm9yIGludmlzaWJsZVxyXG4gKiAgICAgcHJpbWl0aXZlcyB0byBhbmltYXRlIHRoZW0gZGlzYXBwZWFyaW5nLlxyXG4gKiAgMy4gZmFkZS1pbiB2aXNpYmxlIC0gY2hlY2sgd2hpY2ggcHJpbWl0aXZlIGFyZSB2aXNpYmxlIGFuZCBpbmNyZWFzZSBpdHMgYWxwaGEgdmlzaWJpbGl0eSB2YWx1ZS5cclxuICogIDQuIGZhZGUtb3V0IG92ZXJsYXBwZWQgLSBmaW5kIG92ZXJsYXBzIGJ5IGNvbXBhcmluZyBjb3JyZXNwb25kaW5nIHBpeGVscyBvZiB0aGUgc2NlbmUgcmVuZGVyZWQgaW4gZGlyZWN0IGFuZFxyXG4gKiAgICAgcmV2ZXJzZSBwcmlvcml0eSBvcmRlcnMuXHJcbiAqXHJcbiAqICBEdWUgdG8gdGhlIGZhY3QgdGhhdCB3ZSB1c2UgZ3JpZCB3aXRoIGZpbml0ZSBwcmVjaXNpb24gdGhlcmUgYXJlIHNvbWUgY2FzZXMgd2hlcmUgdGhpcyBhcHByb2FjaCBwcm9kdWNlc1xyXG4gKiAgdW5wbGVhc2FudCBhcnRpZmFjdHMgKGJsaW5raW5nKS4gVG8gY29wZSB3aXRoIGl0IHN0YWJpbGl0eSBzaGlmdCBhbmQgc3RvcmluZyB6b29tIG9mIHRoZSBmaXJzdCBvdmVybGFwIGFyZVxyXG4gKiAgaW50cm9kdWNlZCwgYnV0IGl0IHdvcmtzIHdlbGwgZm9yIG5vbi10aWx0ZWQgbWFwIG9ubHkuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWaXNpYmlsaXR5TWFuYWdlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBjYW1lcmEsIHJlbmRlckxvb3AsIHRhcmdldFdpZHRoLCB0YXJnZXRIZWlnaHQsIGZhZGVFZmZlY3REdXJhdGlvbiA9IERFRkFVTFRfRkFERV9FRkZFQ1RfRFVSQVRJT04pIHtcclxuICAgICAgICB0aGlzLm9uUmVyZW5kZXJSZXF1aXJlZCA9IG5ldyBWb2lkRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5mYWRlRWZmZWN0RHVyYXRpb24gPSBmYWRlRWZmZWN0RHVyYXRpb247XHJcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XHJcbiAgICAgICAgdGhpcy5fY2FtZXJhID0gY2FtZXJhO1xyXG4gICAgICAgIHRoaXMuX3JlbmRlckxvb3AgPSByZW5kZXJMb29wO1xyXG4gICAgICAgIHRoaXMuX2xhc3RSZW5kZXJUaW1lSW5Mb29wID0gRkFESU5HX1NUT1BQRUQ7XHJcbiAgICAgICAgdGhpcy5fcHJldlRhcmdldFNpemUgPSB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAgfTtcclxuICAgICAgICB0aGlzLl9zY2VuZVVwZGF0ZUxpc3RlbmVyID0gdGhpcy5fb25TY2VuZVVwZGF0ZS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX2NhbWVyYS5vblVwZGF0ZS5hZGRMaXN0ZW5lcih0aGlzLl9zY2VuZVVwZGF0ZUxpc3RlbmVyKTtcclxuICAgICAgICB0aGlzLl9iZWZvcmVSZW5kZXJMaXN0ZW5lciA9IHRoaXMuX29uQmVmb3JlUmVuZGVyLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyTG9vcC5vbkJlZm9yZVJlbmRlci5hZGRMaXN0ZW5lcih0aGlzLl9iZWZvcmVSZW5kZXJMaXN0ZW5lcik7XHJcbiAgICAgICAgdGhpcy5fZGlyZWN0UHJpb3JpdHlHcmlkUmVuZGVyZXIgPSBuZXcgR3JpZFJlbmRlcmVyKGNvbnRleHQsIERJUkVDVF9QUklPUklUWV9HUklEX1NUQVRFKTtcclxuICAgICAgICB0aGlzLl9yZXZlcnNlUHJpb3JpdHlHcmlkUmVuZGVyZXIgPSBuZXcgR3JpZFJlbmRlcmVyKGNvbnRleHQsIFJFVkVSU0VfUFJJT1JJVFlfR1JJRF9TVEFURSk7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudFZpc2liaWxpdHlUZXh0dXJlID0gY29udGV4dC5jcmVhdGVFbXB0eTJEVGV4dHVyZShJRF9DT01QT05FTlRfU0laRSwgSURfQ09NUE9ORU5UX1NJWkUsIDY0MDggLyogUkdCQSAqLywgNTEyMSAvKiBVTlNJR05FRF9CWVRFICovKTtcclxuICAgICAgICB0aGlzLl9wcmV2VmlzaWJpbGl0eVRleHR1cmUgPSBjb250ZXh0LmNyZWF0ZUVtcHR5MkRUZXh0dXJlKElEX0NPTVBPTkVOVF9TSVpFLCBJRF9DT01QT05FTlRfU0laRSwgNjQwOCAvKiBSR0JBICovLCA1MTIxIC8qIFVOU0lHTkVEX0JZVEUgKi8pO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRWaXNpYmlsaXR5QnVmZmVyID0gY29udGV4dC5jcmVhdGVGcmFtZWJ1ZmZlcih7IGNvbG9yOiB0aGlzLl9jdXJyZW50VmlzaWJpbGl0eVRleHR1cmUgfSk7XHJcbiAgICAgICAgdGhpcy5fcHJldlZpc2liaWxpdHlCdWZmZXIgPSBjb250ZXh0LmNyZWF0ZUZyYW1lYnVmZmVyKHsgY29sb3I6IHRoaXMuX3ByZXZWaXNpYmlsaXR5VGV4dHVyZSB9KTtcclxuICAgICAgICB0aGlzLl9zdGFiaWxpdHlTaGlmdCA9IHZlYzMuY3JlYXRlKDAsIDAsIDApO1xyXG4gICAgICAgIHRoaXMuX2dyaWRIYWxmUHhTaXplVW5pZm9ybSA9IHZlYzIuY3JlYXRlKDAsIDApO1xyXG4gICAgICAgIHRoaXMuX2lkSGFsZlB4U2l6ZVVuaWZvcm0gPSB2ZWMyLmNyZWF0ZSgwLjUgLyBJRF9DT01QT05FTlRfU0laRSwgMC41IC8gSURfQ09NUE9ORU5UX1NJWkUpO1xyXG4gICAgICAgIHRoaXMuX3N0ZXAxUmVzZXRSZW1vdmVkID0gbmV3IFJlc2V0UmVtb3ZlZFByaW1pdGl2ZXMoKTtcclxuICAgICAgICB0aGlzLl9zdGVwMkZhZGVvdXRBbGwgPSBuZXcgRmFkZW91dEFsbChjb250ZXh0KTtcclxuICAgICAgICB0aGlzLl9zdGVwM0ZhZGVpblZpc2libGUgPSBuZXcgRmFkZWluVmlzaWJsZShjb250ZXh0KTtcclxuICAgICAgICB0aGlzLl9zdGVwNEZhZGVvdXRPdmVybGFwcGVkID0gbmV3IEZhZGVvdXRPdmVybGFwcGVkKGNvbnRleHQpO1xyXG4gICAgICAgIHRoaXMuX2NsZWFyVmlzaWJpbGl0eSh0aGlzLl9jdXJyZW50VmlzaWJpbGl0eUJ1ZmZlcik7XHJcbiAgICAgICAgdGhpcy5fcHJpbWl0aXZlUHJvdmlkZXJzID0gW107XHJcbiAgICAgICAgdGhpcy5fY29sb3JJZFJlbmRlcmVycyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3Jlc2V0UmVtb3ZlZFJlbmRlcmVycyA9IFtdO1xyXG4gICAgICAgIHRoaXMuc2V0VGFyZ2V0U2l6ZSh0YXJnZXRXaWR0aCwgdGFyZ2V0SGVpZ2h0KTtcclxuICAgIH1cclxuICAgIGdldCB2aXNpYmlsaXR5VGV4dHVyZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudFZpc2liaWxpdHlUZXh0dXJlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUbyBwcm92aWRlIHByb3BlciBwcmVjaXNpb24gaW4gY29sbGlzaW9uIHJlc29sdXRpb24gc2ltcGxpZmllZCBncmlkIHNpemUgZGVwZW5kcyBvbiB0aGUgcmVuZGVyIHRhcmdldCxcclxuICAgICAqIHRoYXQgY2FuIGJlIGNoYW5nZWQgYXQgcnVuIHRpbWUgKGUuZy4gdGhlIHVzZXIgcmVzaXplcyBicm93c2VyIHdpbmRvdykuIEEgbG90IG9mIGFzc29jaWF0ZWQgR0wgcmVzb3VyY2VzIGlzIGJlXHJcbiAgICAgKiB1cGRhdGVkIGluIHRoYXQgY2FzZS5cclxuICAgICAqL1xyXG4gICAgc2V0VGFyZ2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgY29uc3QgZ3JpZFByZWNpc2lvblRhcmdldFB4ID0gR1JJRF9QUkVDSVNJT05fUFggKiBnZXREcHIoKTtcclxuICAgICAgICBjb25zdCBncmlkV2lkdGggPSBNYXRoLmNlaWwod2lkdGggLyBncmlkUHJlY2lzaW9uVGFyZ2V0UHgpO1xyXG4gICAgICAgIGNvbnN0IGdyaWRIZWlnaHQgPSBNYXRoLmNlaWwoaGVpZ2h0IC8gZ3JpZFByZWNpc2lvblRhcmdldFB4KTtcclxuICAgICAgICB0aGlzLl9kaXJlY3RQcmlvcml0eUdyaWRSZW5kZXJlci5zZXRSZXNvbHV0aW9uKGdyaWRXaWR0aCwgZ3JpZEhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5fcmV2ZXJzZVByaW9yaXR5R3JpZFJlbmRlcmVyLnNldFJlc29sdXRpb24oZ3JpZFdpZHRoLCBncmlkSGVpZ2h0KTtcclxuICAgICAgICBpZiAodGhpcy5fZ3JpZFNhbXBsZXJWZXJ0ZXhCdWZmZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5fZGVzdHJveUdyaWRSZXNvdXJjZXMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgb3ZlcmxhcFNhbXBsZXJCdWZmZXJXcml0ZXIgPSBuZXcgR3JpZFNhbXBsZXJCdWZmZXJXcml0ZXIoZ3JpZFdpZHRoLCBncmlkSGVpZ2h0KTtcclxuICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5fY29udGV4dDtcclxuICAgICAgICB0aGlzLl9ncmlkU2FtcGxlclZlcnRleEJ1ZmZlciA9IGNvbnRleHQuY3JlYXRlVmVydGV4QnVmZmVyKG92ZXJsYXBTYW1wbGVyQnVmZmVyV3JpdGVyLmRhdGEuYnl0ZUxlbmd0aCk7XHJcbiAgICAgICAgdGhpcy5fZ3JpZFNhbXBsZXJWYW8gPSBjb250ZXh0LmNyZWF0ZVZhbyhHUklEX1NBTVBMRVJfQVRUUklCVVRFUywgdGhpcy5fZ3JpZFNhbXBsZXJWZXJ0ZXhCdWZmZXIsIG51bGwpO1xyXG4gICAgICAgIHRoaXMuX251bWJlck9mR3JpZFNhbXBsZXJzID0gb3ZlcmxhcFNhbXBsZXJCdWZmZXJXcml0ZXIubnVtYmVyT2ZTYW1wbGVycztcclxuICAgICAgICB0aGlzLl9jb250ZXh0LnVwbG9hZERhdGFUb0J1ZmZlcih0aGlzLl9ncmlkU2FtcGxlclZlcnRleEJ1ZmZlciwgb3ZlcmxhcFNhbXBsZXJCdWZmZXJXcml0ZXIuZGF0YSk7XHJcbiAgICAgICAgdGhpcy5fcHJldlRhcmdldFNpemUud2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLl9wcmV2VGFyZ2V0U2l6ZS5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5fZ3JpZEhhbGZQeFNpemVVbmlmb3JtLnggPSAwLjUgLyBncmlkV2lkdGg7XHJcbiAgICAgICAgdGhpcy5fZ3JpZEhhbGZQeFNpemVVbmlmb3JtLnkgPSAwLjUgLyBncmlkSGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWNhbGN1bGF0ZXMgdmlzaWJpbGl0eSBvZiBhbGwgY29sbGlkaW5nIHByaW1pdGl2ZXMgaW4gc2NlbmUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IHRoZSBzY2VuZSBpcyB0byBiZSByZW5kZXJlZCBpbnRvLlxyXG4gICAgICogQHBhcmFtIHVuaWZvcm1zIFNldCBvZiBwcmVjYWxjdWxhdGVkIHVuaWZvcm1zIGdsb2JhbCBmb3IgY3VycmVudCBmcmFtZS5cclxuICAgICAqIEByZXR1cm5zIFVwZGF0ZWQgdGV4dHVyZSB3aXRoIHZpc2liaWxpdHkgdmFsdWVzIGZvciBhbGwgcHJpbWl0aXZlcy5cclxuICAgICAqL1xyXG4gICAgdXBkYXRlVmlzaWJpbGl0eUlmTmVlZGVkKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5faXNEaXJ0eSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2lzRGlydHkgPSBmYWxzZTtcclxuICAgICAgICAvLyBSYXN0ZXJpemF0aW9uIG1heSBiZSBub3Qgc3RhYmxlIGluIHRoZSBzZW5zZSBvZiB0aGUgc2hhcGUgb2YgcGl4ZWxzIG9jY3VwaWVkIGJ5IHBhcnRpY3VsYXIgb2JqZWN0IHdoZW4gdGhpc1xyXG4gICAgICAgIC8vIG9iamVjdCBnZXRzIHNoaWZ0ZWQgKGUuZy4gdGhlIHVzZXIgZHJhZ3MgdGhlIGNlbnRlciBvZiB0aGUgbWFwKSBhbmQgc2luY2UgY29sbGlzaW9ucyBhcmUgZGV0ZWN0ZWQgYnlcclxuICAgICAgICAvLyBvdmVybGFwcGVkIHBpeGVscyB0aGlzIGZhY3QgY2FuIGxlYWQgdG8gYmxpbmtpbmcgKGZvdW5kIG92ZXJsYXBwaW5nIGluIG9uZSBmcmFtZS9ub3QgZm91bmQgaW4gdGhlIG5leHQvZXRjKS5cclxuICAgICAgICAvLyBGb3IgdGhvc2Ugb2JqZWN0cyAoYW5kIHRoZWlyIHBvc2l0aW9ucykgdGhhdCBhcmUgbm90IGRpc3RvcnRlZCBieSBwZXJzcGVjdGl2ZSBpdCBjYW4gYmUgZml4ZWQgYnlcclxuICAgICAgICAvLyBpbnRyb2R1Y2luZyBhIHNoaWZ0IHRoYXQgdGFrZXMgaW50byBhY2NvdW50IHRoZSBhbW91bnQgb2YgZHJhZyBhbmQgZm9yY2VzIHZlcnRpY2VzIHRvIGJlIGRpc3BsYWNlZCBpbiB0aGVcclxuICAgICAgICAvLyBzYW1lIHBvc2l0aW9uIGluIGdyaWQncyBjZWxsLlxyXG4gICAgICAgIGNvbnN0IHNoaWZ0ID0gdGhpcy5fc3RhYmlsaXR5U2hpZnQ7XHJcbiAgICAgICAgdmVjMi5jb3B5KHRoaXMuX2NhbWVyYS5jZW50ZXIsIHNoaWZ0KTtcclxuICAgICAgICBzaGlmdC56ID0gMDtcclxuICAgICAgICBtYXQ0LmFwcGx5KHRoaXMuX2NhbWVyYS5nZXRWaWV3UHJvak1hdHJpeCgpLCBzaGlmdCwgc2hpZnQpO1xyXG4gICAgICAgIC8vIE5EQyAoLTEgOiAxKSBhcmUgMiB0aW1lcyBsYXJnZXIgdGhhbiB0ZXh0dXJlIGNvb3JkaW5hdGVzICgwIDogMSlcclxuICAgICAgICBzaGlmdC54ICU9IDQgKiB0aGlzLl9ncmlkSGFsZlB4U2l6ZVVuaWZvcm0ueDtcclxuICAgICAgICBzaGlmdC55ICU9IDQgKiB0aGlzLl9ncmlkSGFsZlB4U2l6ZVVuaWZvcm0ueTtcclxuICAgICAgICBjb25zdCBwcmV2VGV4dHVyZSA9IHRoaXMuX3ByZXZWaXNpYmlsaXR5VGV4dHVyZTtcclxuICAgICAgICBjb25zdCBwcmV2RnJhbWVidWZmZXIgPSB0aGlzLl9wcmV2VmlzaWJpbGl0eUJ1ZmZlcjtcclxuICAgICAgICBjb25zdCBjdXJyZW50VGV4dHVyZSA9IHRoaXMuX2N1cnJlbnRWaXNpYmlsaXR5VGV4dHVyZTtcclxuICAgICAgICBjb25zdCBjdXJyZW50RnJhbWVidWZmZXIgPSB0aGlzLl9jdXJyZW50VmlzaWJpbGl0eUJ1ZmZlcjtcclxuICAgICAgICB0aGlzLl9jbGVhclZpc2liaWxpdHkocHJldkZyYW1lYnVmZmVyKTtcclxuICAgICAgICAvLyBvbiB0aGlzIHN0ZXBcclxuICAgICAgICB0aGlzLl9zdGVwMVJlc2V0UmVtb3ZlZC5yZW5kZXIocHJldkZyYW1lYnVmZmVyLCB0aGlzLl9yZXNldFJlbW92ZWRSZW5kZXJlcnMsIGN1cnJlbnRUZXh0dXJlLCB0aGlzLl9pZEhhbGZQeFNpemVVbmlmb3JtKTtcclxuICAgICAgICAvLyBwYXNzIHpvb20gYXMgYSB2YWx1ZSBiZXR3ZWVuIDAuMCBhbmQgMS4wLCBhcyBhYnNvbHV0ZSB2YWx1ZSBpcyBub3QgaW1wb3J0YW50XHJcbiAgICAgICAgY29uc3Qgem9vbSA9IHRoaXMuX2NhbWVyYS56b29tIC8gdGhpcy5fY2FtZXJhLm9wdGlvbnMubWF4Wm9vbTtcclxuICAgICAgICBjb25zdCB2aWV3UHJvak1hdHJpeCA9IHRoaXMuX2NhbWVyYS5nZXRWaWV3UHJvak1hdHJpeCgpO1xyXG4gICAgICAgIGNvbnN0IGNhbWVyYVBvc2l0aW9ucyA9IGNhbGN1bGF0ZUNhbWVyYVBvc2l0aW9ucyh0aGlzLl9jYW1lcmEpO1xyXG4gICAgICAgIGNvbnN0IGRpcmVjdFByaW9yaXR5R3JpZCA9IHRoaXMuX2RpcmVjdFByaW9yaXR5R3JpZFJlbmRlcmVyLnVwZGF0ZUdyaWQodmlld1Byb2pNYXRyaXgsIGNhbWVyYVBvc2l0aW9ucywgdGhpcy5fY29sb3JJZFJlbmRlcmVycywgc2hpZnQsIHByZXZUZXh0dXJlLCB6b29tKTtcclxuICAgICAgICBjb25zdCByZXZlcnNlUHJpb3JpdHlHcmlkID0gdGhpcy5fcmV2ZXJzZVByaW9yaXR5R3JpZFJlbmRlcmVyLnVwZGF0ZUdyaWQodmlld1Byb2pNYXRyaXgsIGNhbWVyYVBvc2l0aW9ucywgdGhpcy5fY29sb3JJZFJlbmRlcmVycywgc2hpZnQsIHByZXZUZXh0dXJlLCB6b29tKTtcclxuICAgICAgICBjb25zdCBub3cgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgICBjb25zdCBsYXN0UmVuZGVyaW5nID0gdGhpcy5fbGFzdFJlbmRlclRpbWVJbkxvb3A7XHJcbiAgICAgICAgY29uc3QgaXNBbmltYXRpb25GaW5pc2hlZCA9IChub3cgLSB0aGlzLl9sYXN0U2NlbmVVcGRhdGVUaW1lKSA+IHRoaXMuZmFkZUVmZmVjdER1cmF0aW9uO1xyXG4gICAgICAgIGNvbnN0IHdhc0FuaW1hdGlvbkFjdGl2ZSA9IGxhc3RSZW5kZXJpbmcgIT09IEZBRElOR19TVE9QUEVEO1xyXG4gICAgICAgIGNvbnN0IGZhZGVFZmZlY3QgPSBpc0FuaW1hdGlvbkZpbmlzaGVkID9cclxuICAgICAgICAgICAgMS4wIDogd2FzQW5pbWF0aW9uQWN0aXZlID8gKG5vdyAtIGxhc3RSZW5kZXJpbmcpIC8gdGhpcy5mYWRlRWZmZWN0RHVyYXRpb24gOiAwO1xyXG4gICAgICAgIGNvbnN0IGlkSGFsZlB4ID0gdGhpcy5faWRIYWxmUHhTaXplVW5pZm9ybTtcclxuICAgICAgICBjb25zdCBzYW1wbGVyVmFvID0gdGhpcy5fZ3JpZFNhbXBsZXJWYW87XHJcbiAgICAgICAgY29uc3QgbnVtYmVyT2ZTYW1wbGVycyA9IHRoaXMuX251bWJlck9mR3JpZFNhbXBsZXJzO1xyXG4gICAgICAgIHRoaXMuX2NsZWFyVmlzaWJpbGl0eShjdXJyZW50RnJhbWVidWZmZXIpO1xyXG4gICAgICAgIHRoaXMuX3N0ZXAyRmFkZW91dEFsbC5yZW5kZXIoY3VycmVudEZyYW1lYnVmZmVyLCBwcmV2VGV4dHVyZSwgZmFkZUVmZmVjdCk7XHJcbiAgICAgICAgdGhpcy5fc3RlcDNGYWRlaW5WaXNpYmxlLnJlbmRlcihjdXJyZW50RnJhbWVidWZmZXIsIHNhbXBsZXJWYW8sIG51bWJlck9mU2FtcGxlcnMsIGRpcmVjdFByaW9yaXR5R3JpZCwgcHJldlRleHR1cmUsIGlkSGFsZlB4LCBmYWRlRWZmZWN0KTtcclxuICAgICAgICB0aGlzLl9zdGVwNEZhZGVvdXRPdmVybGFwcGVkLnJlbmRlcihjdXJyZW50RnJhbWVidWZmZXIsIHNhbXBsZXJWYW8sIG51bWJlck9mU2FtcGxlcnMsIGRpcmVjdFByaW9yaXR5R3JpZCwgcmV2ZXJzZVByaW9yaXR5R3JpZCwgcHJldlRleHR1cmUsIGlkSGFsZlB4LCBmYWRlRWZmZWN0LCB6b29tKTtcclxuICAgICAgICAvLyBjaGVjayBpZiB3ZSBuZWVkIG9uZSBtb3JlIHJlbmRlcmluZyB0byBmaW5pc2ggYW5pbWF0aW9uXHJcbiAgICAgICAgaWYgKGlzQW5pbWF0aW9uRmluaXNoZWQpIHtcclxuICAgICAgICAgICAgLy8gbm8gbW9yZSByZW5kZXJpbmdzIG5lZWRlZCBmb3IgZmFkZSBlZmZlY3QsIGl0cyB0aW1lc3RhbXAgaXMgbWFya2VkIHdpdGggc3BlY2lhbCB2YWx1ZVxyXG4gICAgICAgICAgICAvLyB0byB0YWtlIGl0IGludG8gYWNjb3VudCBkdXJpbmcgbmV4dCBmYWRlIGVmZmVjdCBhbW91bnQgY2FsY3VsYXRpb25cclxuICAgICAgICAgICAgdGhpcy5fbGFzdFJlbmRlclRpbWVJbkxvb3AgPSBGQURJTkdfU1RPUFBFRDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlckxvb3AudXBkYXRlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2xhc3RSZW5kZXJUaW1lSW5Mb29wID0gbm93O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlZ2lzdGVyQ29sbGlkaW5nUHJpbWl0aXZlcyhwcmltaXRpdmVQcm92aWRlciwgY29sb3JJZFJlbmRlcmVyLCByZXNldFJlbW92ZVJlbmRlcmVyKSB7XHJcbiAgICAgICAgdGhpcy5fcHJpbWl0aXZlUHJvdmlkZXJzLnB1c2gocHJpbWl0aXZlUHJvdmlkZXIpO1xyXG4gICAgICAgIHRoaXMuX2NvbG9ySWRSZW5kZXJlcnMucHVzaChjb2xvcklkUmVuZGVyZXIpO1xyXG4gICAgICAgIHRoaXMuX3Jlc2V0UmVtb3ZlZFJlbmRlcmVycy5wdXNoKHJlc2V0UmVtb3ZlUmVuZGVyZXIpO1xyXG4gICAgICAgIHByaW1pdGl2ZVByb3ZpZGVyLm9uVXBkYXRlLmFkZExpc3RlbmVyKHRoaXMuX3NjZW5lVXBkYXRlTGlzdGVuZXIpO1xyXG4gICAgfVxyXG4gICAgZGVyZWdpc3RlckNvbGxpZGluZ1ByaW1pdGl2ZXMocHJpbWl0aXZlUHJvdmlkZXIsIGNvbG9ySWRSZW5kZXJlciwgcmVzZXRSZW1vdmVSZW5kZXJlcikge1xyXG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMuX3ByaW1pdGl2ZVByb3ZpZGVycy5pbmRleE9mKHByaW1pdGl2ZVByb3ZpZGVyKTtcclxuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xyXG4gICAgICAgICAgICB0aGlzLl9wcmltaXRpdmVQcm92aWRlcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaW5kZXggPSB0aGlzLl9jb2xvcklkUmVuZGVyZXJzLmluZGV4T2YoY29sb3JJZFJlbmRlcmVyKTtcclxuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xyXG4gICAgICAgICAgICB0aGlzLl9jb2xvcklkUmVuZGVyZXJzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluZGV4ID0gdGhpcy5fcmVzZXRSZW1vdmVkUmVuZGVyZXJzLmluZGV4T2YocmVzZXRSZW1vdmVSZW5kZXJlcik7XHJcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVzZXRSZW1vdmVkUmVuZGVyZXJzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByaW1pdGl2ZVByb3ZpZGVyLm9uVXBkYXRlLnJlbW92ZUxpc3RlbmVyKHRoaXMuX3NjZW5lVXBkYXRlTGlzdGVuZXIpO1xyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLl9kZXN0cm95R3JpZFJlc291cmNlcygpO1xyXG4gICAgICAgIHRoaXMuX2RpcmVjdFByaW9yaXR5R3JpZFJlbmRlcmVyLmRlc3Ryb3koKTtcclxuICAgICAgICB0aGlzLl9yZXZlcnNlUHJpb3JpdHlHcmlkUmVuZGVyZXIuZGVzdHJveSgpO1xyXG4gICAgICAgIHRoaXMuX2NhbWVyYS5vblVwZGF0ZS5yZW1vdmVMaXN0ZW5lcih0aGlzLl9zY2VuZVVwZGF0ZUxpc3RlbmVyKTtcclxuICAgICAgICBmb3IgKGNvbnN0IHByaW1pdGl2ZVByb3ZpZGVyIG9mIHRoaXMuX3ByaW1pdGl2ZVByb3ZpZGVycykge1xyXG4gICAgICAgICAgICBwcmltaXRpdmVQcm92aWRlci5vblVwZGF0ZS5yZW1vdmVMaXN0ZW5lcih0aGlzLl9zY2VuZVVwZGF0ZUxpc3RlbmVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfb25TY2VuZVVwZGF0ZSgpIHtcclxuICAgICAgICB0aGlzLl9sYXN0U2NlbmVVcGRhdGVUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyTG9vcC51cGRhdGUoKTtcclxuICAgIH1cclxuICAgIF9vbkJlZm9yZVJlbmRlcigpIHtcclxuICAgICAgICB0aGlzLl9pc0RpcnR5ID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVzZXRzIHZpc2liaWxpdHkgdGV4dHVyZSB0byBpdHMgaW5pdGlhbCBzdGF0ZS5cclxuICAgICAqL1xyXG4gICAgX2NsZWFyVmlzaWJpbGl0eSh0YXJnZXQpIHtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRSZW5kZXJTdGF0ZShWSVNJQklMSVRZX0lOSVRfU1RBVEUpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFJlbmRlclRhcmdldCh0YXJnZXQpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuY2xlYXJDdXJyZW50VGFyZ2V0KDE2Mzg0IC8qIENPTE9SX0JVRkZFUl9CSVQgKi8pO1xyXG4gICAgfVxyXG4gICAgX2Rlc3Ryb3lHcmlkUmVzb3VyY2VzKCkge1xyXG4gICAgICAgIHRoaXMuX2dyaWRTYW1wbGVyVmVydGV4QnVmZmVyLmRlc3Ryb3koKTtcclxuICAgICAgICB0aGlzLl9ncmlkU2FtcGxlclZhby5kZXN0cm95KCk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgQXR0cmlidXRlTWFwcGluZyB9IGZyb20gJy4uL3JlbmRlci9hdHRyaWJfbWFwcGluZyc7XHJcbmltcG9ydCBCdWZmZXJXcml0ZXIgZnJvbSAnLi4vdXRpbC9idWZmZXJfd3JpdGVyJztcclxuaW1wb3J0IHsgZmxvYXRUb1VpbnQxNiB9IGZyb20gJy4uL3V0aWwvZ3B1dHlwZXMnO1xyXG5leHBvcnQgY29uc3QgQVRUUklCVVRFX01BUFBJTkcgPSBuZXcgQXR0cmlidXRlTWFwcGluZyhbXHJcbiAgICBbXHJcbiAgICAgICAgMCAvKiBQT1NJVElPTiAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDIsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjMgLyogVU5TSUdORURfU0hPUlQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcclxuICAgICAgICB9XHJcbiAgICBdXHJcbl0pO1xyXG4vKipcclxuICogV3JpdGVzIHNhbXBsZXIgcG9zaXRpb25zIGludG8gdmVydGV4IGJ1ZmZlciBhcyBhIHJlZ3VsYXIgZ3JpZCB3aXRoIHRoZSBzdGVwIGVxdWFsIHRvIHRoZSBzaXplIG9mIGEgZ3JpZCBjZWxsLlxyXG4gKiBUaGUgbnVtYmVyIG9mIHZlcnRpY2VzIChzYW1wbGVycykgaXMgZXF1YWwgdG8gXCJ3aWR0aCB4IGhlaWdodFwiLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR3JpZFNhbXBsZXJCdWZmZXJXcml0ZXIgZXh0ZW5kcyBCdWZmZXJXcml0ZXIge1xyXG4gICAgY29uc3RydWN0b3Iod2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIGNvbnN0IG51bWJlck9mU2FtcGxlcnMgPSB3aWR0aCAqIGhlaWdodDtcclxuICAgICAgICBzdXBlcihBVFRSSUJVVEVfTUFQUElORy52ZXJ0ZXhCeXRlU2l6ZSwgbnVtYmVyT2ZTYW1wbGVycywgdW5kZWZpbmVkLCAwKTtcclxuICAgICAgICBjb25zdCBjb2xTdGVwID0gZmxvYXRUb1VpbnQxNigxLjAgLyB3aWR0aCk7XHJcbiAgICAgICAgY29uc3Qgcm93U3RlcCA9IGZsb2F0VG9VaW50MTYoMS4wIC8gaGVpZ2h0KTtcclxuICAgICAgICBjb25zdCBjb2xIYWxmU3RlcCA9IGNvbFN0ZXAgLyAyO1xyXG4gICAgICAgIGNvbnN0IHJvd0hhbGZTdGVwID0gcm93U3RlcCAvIDI7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGNvbCA9IGNvbEhhbGZTdGVwOyBpIDwgd2lkdGg7IGkrKywgY29sICs9IGNvbFN0ZXApIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDAsIHJvdyA9IHJvd0hhbGZTdGVwOyBqIDwgaGVpZ2h0OyBqKyssIHJvdyArPSByb3dTdGVwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl93cml0ZUhhbGZXb3Jkcyhjb2wsIHJvdyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5kYXRhID0gdGhpcy5nZXRCdWZmZXJzKClbMF0udmVydGV4QnVmZmVyO1xyXG4gICAgICAgIHRoaXMubnVtYmVyT2ZTYW1wbGVycyA9IG51bWJlck9mU2FtcGxlcnM7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgR2xSZW5kZXJlciB9IGZyb20gJy4uL3JlbmRlci9nbF9yZW5kZXJlcic7XHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdyaWRSZW5kZXJlciBleHRlbmRzIEdsUmVuZGVyZXIge1xyXG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgcmVuZGVyU3RhdGUpIHtcclxuICAgICAgICBzdXBlcihjb250ZXh0LCByZW5kZXJTdGF0ZSk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVHcmlkKC4uLmFyZ3MpIHtcclxuICAgICAgICB0aGlzLnJlbmRlcih0aGlzLl90YXJnZXQsIC4uLmFyZ3MpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0dXJlO1xyXG4gICAgfVxyXG4gICAgX3JlbmRlcih2aWV3UHJvak1hdHJpeCwgY2FtZXJhUG9zaXRpb25zLCByZW5kZXJlcnMsIHN0YWJpbGl0eVNoaWZ0LCBwcmV2VmlzaWJpbGl0eSwgY3VycmVudFpvb20pIHtcclxuICAgICAgICBmb3IgKGNvbnN0IHJlbmRlcmVyIG9mIHJlbmRlcmVycykge1xyXG4gICAgICAgICAgICByZW5kZXJlci5yZW5kZXIodGhpcy5fdGFyZ2V0LCB2aWV3UHJvak1hdHJpeCwgY2FtZXJhUG9zaXRpb25zLCB0aGlzLl9yZW5kZXJTdGF0ZSwgc3RhYmlsaXR5U2hpZnQsIHByZXZWaXNpYmlsaXR5LCBjdXJyZW50Wm9vbSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHJlc29sdXRpb24gb2YgdGhlIGdyaWQuXHJcbiAgICAgKi9cclxuICAgIHNldFJlc29sdXRpb24od2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lSZXNvdXJjZXMoKTtcclxuICAgICAgICB0aGlzLl9kZXB0aEJ1ZmZlciA9IHRoaXMuX2NvbnRleHQuY3JlYXRlUmVuZGVyYnVmZmVyKHdpZHRoLCBoZWlnaHQsIDM0MDQxIC8qIERFUFRIX1NURU5DSUwgKi8pO1xyXG4gICAgICAgIHRoaXMuX3RleHR1cmUgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUVtcHR5MkRUZXh0dXJlKHdpZHRoLCBoZWlnaHQsIDY0MDggLyogUkdCQSAqLywgNTEyMSAvKiBVTlNJR05FRF9CWVRFICovKTtcclxuICAgICAgICB0aGlzLl90YXJnZXQgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUZyYW1lYnVmZmVyKHsgY29sb3I6IHRoaXMuX3RleHR1cmUsIGRlcHRoU3RlbmNpbDogdGhpcy5fZGVwdGhCdWZmZXIgfSk7XHJcbiAgICB9XHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lSZXNvdXJjZXMoKTtcclxuICAgIH1cclxuICAgIF9wcmVwYXJlUmVuZGVyVGFyZ2V0KHRhcmdldCwgLi4uYXJncykge1xyXG4gICAgICAgIHN1cGVyLl9wcmVwYXJlUmVuZGVyVGFyZ2V0KHRhcmdldCwgLi4uYXJncyk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5jbGVhckN1cnJlbnRUYXJnZXQoMTYzODQgLyogQ09MT1JfQlVGRkVSX0JJVCAqLyB8IDI1NiAvKiBERVBUSF9CVUZGRVJfQklUICovKTtcclxuICAgIH1cclxuICAgIF9kZXN0cm95UmVzb3VyY2VzKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl90YXJnZXQpIHtcclxuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0LmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgdGhpcy5fdGV4dHVyZS5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2RlcHRoQnVmZmVyLmRlc3Ryb3koKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiLyoqXHJcbiAqIE9uZSBvZiB0aGUgc3RlcHMgb2YgcHJpbWl0aXZlcyB2aXNpYmlsaXR5IHJlc29sdXRpb24gcHJvY2Vzcy4gQmFzaWNhbGx5IGl0IGRvZXMgbm90aGluZywganVzdCBjYWxsIGFwcHJvcHJpYXRlXHJcbiAqIG1ldGhvZHMgb2YgQ29sbGlkaW5nUHJpbWl0aXZlUmVuZGVyZXIncywgYnV0IGl0IGV4cGVjdHMgdGhhdCB0aGVzZSByZW5kZXJlcnMgd2lsbCBjb3B5IHZpc2liaWxpdHkgdmFsdWUgb2YgYWN0dWFsXHJcbiAqIHByaW1pdGl2ZXMgb25seSwgdGh1cyByZW1vdmVkIHByaW1pdGl2ZSdzIHZhbHVlcyB3aWxsIGJlIHJlc2V0IChvdmVybGFwIHpvb20gY2xlYXJlZCBhbmQgYWxsIHRoYXQpLiBJdCBpcyBpbXBvcnRhbnRcclxuICogZm9yIHJldXNpbmcgdGhlc2UgaWRzIGZvciBmdXR1cmUgcHJpbWl0aXZlcy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlc2V0UmVtb3ZlZFByaW1pdGl2ZXMge1xyXG4gICAgcmVuZGVyKHRhcmdldCwgcmVuZGVyZXJzLCBwcmV2VmlzaWJpbGl0eSwgaWRIYWxmUHhTaXplVW5pZm9ybSkge1xyXG4gICAgICAgIGZvciAoY29uc3QgcmVuZGVyZXIgb2YgcmVuZGVyZXJzKSB7XHJcbiAgICAgICAgICAgIHJlbmRlcmVyLnJlbmRlcih0YXJnZXQsIHByZXZWaXNpYmlsaXR5LCBpZEhhbGZQeFNpemVVbmlmb3JtKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IGZhZGVvdXRBbGxWZXJ0ZXhTaGFkZXIgZnJvbSAnLi9zaGFkZXJzL2ZhZGVvdXRfYWxsLnZlcnQnO1xyXG5pbXBvcnQgZmFkZW91dEFsbEZyYWdtZW50U2hhZGVyIGZyb20gJy4vc2hhZGVycy9mYWRlb3V0X2FsbC5mcmFnJztcclxuaW1wb3J0IHsgR2xSZW5kZXJlciB9IGZyb20gJy4uLy4uL3JlbmRlci9nbF9yZW5kZXJlcic7XHJcbmltcG9ydCBSZW5kZXJTdGF0ZSBmcm9tICcuLi8uLi9yZW5kZXIvc3RhdGUnO1xyXG5pbXBvcnQgSWRTYW1wbGVyQnVmZmVyV3JpdGVyLCB7IEFUVFJJQlVURV9NQVBQSU5HIH0gZnJvbSAnLi4vaWRfc2FtcGxlcl9idWZmZXJfd3JpdGVyJztcclxuY29uc3QgU1RBVEUgPSBuZXcgUmVuZGVyU3RhdGUoe1xyXG4gICAgZGl0aGVyOiBmYWxzZVxyXG59KTtcclxuLyoqXHJcbiAqIE9uZSBvZiB0aGUgc3RlcHMgb2YgcHJpbWl0aXZlcyB2aXNpYmlsaXR5IHJlc29sdXRpb24gcHJvY2Vzcy4gSXQgc2FtcGxlcyBhbGwgdmlzaWJpbGl0eSB2YWx1ZXMgYW5kIHN1YnRyYWN0XHJcbiAqIGRlbHRhIChmYWRlb3V0QW1vdW50KSBmcm9tIHRoZW0sIHRoZXNlIG5ldyB2YWx1ZXMgYXJlIHN0b3JlZCBpbnRvIGN1cnJlbnQgdmlzaWJpbGl0eSB0ZXh0dXJlLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmFkZW91dEFsbCBleHRlbmRzIEdsUmVuZGVyZXIge1xyXG4gICAgY29uc3RydWN0b3IoY29udGV4dCkge1xyXG4gICAgICAgIGNvbnN0IHByb2dyYW0gPSBjb250ZXh0LmNyZWF0ZVByb2dyYW0oZmFkZW91dEFsbFZlcnRleFNoYWRlciwgZmFkZW91dEFsbEZyYWdtZW50U2hhZGVyLCB7XHJcbiAgICAgICAgICAgIGF0dHJpYk1hcDoge1xyXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IDAgLyogUE9TSVRJT04gKi9cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHN1cGVyKGNvbnRleHQsIFNUQVRFLCBwcm9ncmFtKTtcclxuICAgICAgICBjb25zdCBpZFNhbXBsZXJCdWZmZXJXcml0ZXIgPSBuZXcgSWRTYW1wbGVyQnVmZmVyV3JpdGVyKCk7XHJcbiAgICAgICAgdGhpcy5faWRTYW1wbGVyVmVydGV4QnVmZmVyID0gdGhpcy5fY29udGV4dC5jcmVhdGVWZXJ0ZXhCdWZmZXIoaWRTYW1wbGVyQnVmZmVyV3JpdGVyLnZlcnRleERhdGEuYnl0ZUxlbmd0aCk7XHJcbiAgICAgICAgdGhpcy5faWRTYW1wbGVySW5kZXhCdWZmZXIgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZUluZGV4QnVmZmVyKGlkU2FtcGxlckJ1ZmZlcldyaXRlci5pbmRleERhdGEuYnl0ZUxlbmd0aCk7XHJcbiAgICAgICAgdGhpcy5faWRTYW1wbGVyVmFvID0gdGhpcy5fY29udGV4dC5jcmVhdGVWYW8oQVRUUklCVVRFX01BUFBJTkcsIHRoaXMuX2lkU2FtcGxlclZlcnRleEJ1ZmZlciwgdGhpcy5faWRTYW1wbGVySW5kZXhCdWZmZXIpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQudXBsb2FkRGF0YVRvQnVmZmVyKHRoaXMuX2lkU2FtcGxlclZlcnRleEJ1ZmZlciwgaWRTYW1wbGVyQnVmZmVyV3JpdGVyLnZlcnRleERhdGEpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQudXBsb2FkRGF0YVRvQnVmZmVyKHRoaXMuX2lkU2FtcGxlckluZGV4QnVmZmVyLCBpZFNhbXBsZXJCdWZmZXJXcml0ZXIuaW5kZXhEYXRhKTtcclxuICAgICAgICBjb250ZXh0LmJpbmRQcm9ncmFtKHByb2dyYW0pO1xyXG4gICAgICAgIHByb2dyYW0uc2V0SW50U2NhbGFyVW5pZm9ybSgncHJldlZpc2liaWxpdHknLCAwKTtcclxuICAgIH1cclxuICAgIF9wcmVwYXJlUHJvZ3JhbShwcm9ncmFtLCBwcmV2VmlzaWJpbGl0eSwgZmFkZW91dEFtb3VudCkge1xyXG4gICAgICAgIHN1cGVyLl9wcmVwYXJlUHJvZ3JhbShwcm9ncmFtLCBwcmV2VmlzaWJpbGl0eSwgZmFkZW91dEFtb3VudCk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kVGV4dHVyZVVuaXQoMCk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kVGV4dHVyZShwcmV2VmlzaWJpbGl0eSk7XHJcbiAgICAgICAgcHJvZ3JhbS5zZXRTY2FsYXJVbmlmb3JtKCdmYWRlb3V0QW1vdW50JywgZmFkZW91dEFtb3VudCk7XHJcbiAgICB9XHJcbiAgICBfcmVuZGVyKCkge1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFZhbyh0aGlzLl9pZFNhbXBsZXJWYW8pO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuZHJhd0luZGV4ZWRNZXNoKDAsIDYsIDQgLyogVFJJQU5HTEVTICovKTtcclxuICAgIH1cclxufVxyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiI3ZlcnNpb24gMTAwXFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG5hdHRyaWJ1dGUgdmVjNCBwb3NpdGlvbjtcXG5cXG52YXJ5aW5nIHZlYzIgaWRUZXhDb29yZGluYXRlcztcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIGdsX1Bvc2l0aW9uID0gdmVjNChwb3NpdGlvbi54eSwgMCwgMSk7XFxuICAgIGlkVGV4Q29vcmRpbmF0ZXMgPSBwb3NpdGlvbi56dztcXG59XFxuXCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiI3ZlcnNpb24gMTAwXFxuXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCBwcmV2VmlzaWJpbGl0eTtcXG51bmlmb3JtIGZsb2F0IGZhZGVvdXRBbW91bnQ7XFxuXFxudmFyeWluZyB2ZWMyIGlkVGV4Q29vcmRpbmF0ZXM7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICB2ZWM0IHZpc2liaWxpdHlWYWx1ZSA9IHRleHR1cmUyRChwcmV2VmlzaWJpbGl0eSwgaWRUZXhDb29yZGluYXRlcyk7XFxuICAgIHZpc2liaWxpdHlWYWx1ZS5hID0gY2xhbXAodmlzaWJpbGl0eVZhbHVlLmEgLSBmYWRlb3V0QW1vdW50LCAwLjAsIDEuMCk7XFxuXFxuICAgIGdsX0ZyYWdDb2xvciA9IHZpc2liaWxpdHlWYWx1ZTtcXG59XFxuXCIiLCJpbXBvcnQgeyBBdHRyaWJ1dGVNYXBwaW5nIH0gZnJvbSAnLi4vcmVuZGVyL2F0dHJpYl9tYXBwaW5nJztcclxuaW1wb3J0IEJ1ZmZlcldyaXRlciBmcm9tICcuLi91dGlsL2J1ZmZlcl93cml0ZXInO1xyXG5leHBvcnQgY29uc3QgQVRUUklCVVRFX01BUFBJTkcgPSBuZXcgQXR0cmlidXRlTWFwcGluZyhbXHJcbiAgICBbXHJcbiAgICAgICAgMCAvKiBQT1NJVElPTiAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDQsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjAgLyogQllURSAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICBdXHJcbl0pO1xyXG4vKipcclxuICogV3JpdGUgdmVydGljZXMgb2YgdHdvIHRyaWFuZ2xlcyB0aGF0IGZ1bGx5IGNvdmVyIHZpc2liaWxpdHkgdGV4dHVyZSwgaXRzIHZhbHVlcyBjYW4gYmUgc2FtcGxlZCBpbiBmcmFnbWVudCBzaGFkZXJzLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSWRTYW1wbGVyQnVmZmVyV3JpdGVyIGV4dGVuZHMgQnVmZmVyV3JpdGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKEFUVFJJQlVURV9NQVBQSU5HLnZlcnRleEJ5dGVTaXplLCA0LCA0LCA2KTtcclxuICAgICAgICAvLyB3aW5kb3cgeCwgd2luZG93IHksIHRleHR1cmUgeCwgdGV4dHVyZSB5XHJcbiAgICAgICAgdGhpcy5fd3JpdGVCeXRlcygtMSwgLTEsIDAsIDApO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlQnl0ZXMoLTEsIDEsIDAsIDEpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlQnl0ZXMoMSwgMSwgMSwgMSk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVCeXRlcygxLCAtMSwgMSwgMCk7XHJcbiAgICAgICAgdGhpcy53cml0ZUluZGljZXNGb3JGYW4oWzAsIDEsIDIsIDNdKTtcclxuICAgICAgICB0aGlzLnZlcnRleERhdGEgPSB0aGlzLmdldEJ1ZmZlcnMoKVswXS52ZXJ0ZXhCdWZmZXI7XHJcbiAgICAgICAgdGhpcy5pbmRleERhdGEgPSB0aGlzLmdldEJ1ZmZlcnMoKVswXS5pbmRleEJ1ZmZlcjtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBHbFJlbmRlcmVyIH0gZnJvbSAnLi4vLi4vcmVuZGVyL2dsX3JlbmRlcmVyJztcclxuaW1wb3J0IGZhZGVpblZpc2libGVWZXJ0ZXhTaGFkZXIgZnJvbSAnLi9zaGFkZXJzL2ZhZGVpbl92aXNpYmxlLnZlcnQnO1xyXG5pbXBvcnQgZmFkZWluVmlzaWJsZUZyYWdtZW50U2hhZGVyIGZyb20gJy4vc2hhZGVycy9mYWRlaW5fdmlzaWJsZS5mcmFnJztcclxuaW1wb3J0IFJlbmRlclN0YXRlIGZyb20gJy4uLy4uL3JlbmRlci9zdGF0ZSc7XHJcbmNvbnN0IFNUQVRFID0gbmV3IFJlbmRlclN0YXRlKHtcclxuICAgIGRpdGhlcjogZmFsc2VcclxufSk7XHJcbi8qKlxyXG4gKiBPbmUgb2YgdGhlIHN0ZXBzIG9mIHByaW1pdGl2ZXMgdmlzaWJpbGl0eSByZXNvbHV0aW9uIHByb2Nlc3MuIEl0IHNhbXBsZXMgYWxsIHBpeGVscyBvZiB0aGUgc2NlbmUgKHJlbmRlcmVkIGluIGRpcmVjdFxyXG4gKiBwcmlvcml0eSBvcmRlciBpbnRvIHNpbXBsaWZpZWQgZ3JpZCkgYW5kIGFkZHMgZGVsdGEgKGZhZGVpbkFtb3VudCkgdG8gYWxwaGEgdmlzaWJpbGl0eSBvZiBwcmltaXRpdmUgd2l0aFxyXG4gKiBpZCBpbiB0aGlzIHBpeGVsLiBUaG9zZSBwcmltaXRpdmVzIGFyZSBjb25zaWRlcmVkIHZpc2libGUuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGYWRlaW5WaXNpYmxlIGV4dGVuZHMgR2xSZW5kZXJlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XHJcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IGNvbnRleHQuY3JlYXRlUHJvZ3JhbShmYWRlaW5WaXNpYmxlVmVydGV4U2hhZGVyLCBmYWRlaW5WaXNpYmxlRnJhZ21lbnRTaGFkZXIsIHtcclxuICAgICAgICAgICAgYXR0cmliTWFwOiB7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogMCAvKiBQT1NJVElPTiAqL1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc3VwZXIoY29udGV4dCwgU1RBVEUsIHByb2dyYW0pO1xyXG4gICAgICAgIGNvbnRleHQuYmluZFByb2dyYW0ocHJvZ3JhbSk7XHJcbiAgICAgICAgcHJvZ3JhbS5zZXRJbnRTY2FsYXJVbmlmb3JtKCdkaXJlY3RQcmlvcml0eUdyaWQnLCAwKTtcclxuICAgICAgICBwcm9ncmFtLnNldEludFNjYWxhclVuaWZvcm0oJ3ByZXZWaXNpYmlsaXR5JywgMSk7XHJcbiAgICB9XHJcbiAgICBfcHJlcGFyZVByb2dyYW0ocHJvZ3JhbSwgZGF0YSwgc2FtcGxlcnMsIGRpcmVjdFByaW9yaXR5R3JpZCwgcHJldlZpc2liaWxpdHksIGlkSGFsZlB4U2l6ZSwgZmFkZWluQW1vdW50KSB7XHJcbiAgICAgICAgc3VwZXIuX3ByZXBhcmVQcm9ncmFtKHByb2dyYW0sIGRhdGEsIHNhbXBsZXJzLCBkaXJlY3RQcmlvcml0eUdyaWQsIHByZXZWaXNpYmlsaXR5LCBpZEhhbGZQeFNpemUsIGZhZGVpbkFtb3VudCk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kVGV4dHVyZVVuaXQoMCk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kVGV4dHVyZShkaXJlY3RQcmlvcml0eUdyaWQpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFRleHR1cmVVbml0KDEpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFRleHR1cmUocHJldlZpc2liaWxpdHkpO1xyXG4gICAgICAgIHByb2dyYW0uc2V0VmVjdG9yMlVuaWZvcm0oJ2lkSGFsZlB4U2l6ZScsIGlkSGFsZlB4U2l6ZSk7XHJcbiAgICAgICAgcHJvZ3JhbS5zZXRTY2FsYXJVbmlmb3JtKCdmYWRlaW5BbW91bnQnLCBmYWRlaW5BbW91bnQpO1xyXG4gICAgfVxyXG4gICAgX3JlbmRlcihkYXRhLCBudW1iZXJPZlNhbXBsZXJzKSB7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kVmFvKGRhdGEpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuZHJhd01lc2goMCwgbnVtYmVyT2ZTYW1wbGVycywgMCAvKiBQT0lOVFMgKi8pO1xyXG4gICAgfVxyXG59XHJcbiIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbmF0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uO1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIGRpcmVjdFByaW9yaXR5R3JpZDtcXG51bmlmb3JtIHNhbXBsZXIyRCBwcmV2VmlzaWJpbGl0eTtcXG51bmlmb3JtIHZlYzIgaWRIYWxmUHhTaXplO1xcbnVuaWZvcm0gZmxvYXQgZmFkZWluQW1vdW50O1xcblxcbnZhcnlpbmcgbG93cCB2ZWM0IHZpc2liaWxpdHlWYWx1ZTtcXG5cXG5jb25zdCB2ZWMyIE5PX0lEID0gdmVjMigwLCAwKTtcXG5jb25zdCB2ZWM0IERJU0NBUkRfUE9TSVRJT04gPSB2ZWM0KDIsIDIsIDIsIDEpO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgdmVjMiBwcmltaXRpdmVJZCA9IHRleHR1cmUyRChkaXJlY3RQcmlvcml0eUdyaWQsIHBvc2l0aW9uKS5yZztcXG5cXG4gICAgaWYgKHByaW1pdGl2ZUlkICE9IE5PX0lEKSB7XFxuICAgICAgICB2ZWMyIGlkVGV4Q29vcmRpbmF0ZXMgPSBwcmltaXRpdmVJZCArIGlkSGFsZlB4U2l6ZTtcXG4gICAgICAgIHZlYzQgaWRXaW5kb3dDb29yZGluYXRlcyA9IHZlYzQoaWRUZXhDb29yZGluYXRlcyAqIDIuMCAtIDEuMCwgMCwgMSk7XFxuICAgICAgICBnbF9Qb3NpdGlvbiA9IGlkV2luZG93Q29vcmRpbmF0ZXM7XFxuICAgICAgICBnbF9Qb2ludFNpemUgPSAxLjA7XFxuXFxuICAgICAgICB2aXNpYmlsaXR5VmFsdWUgPSB0ZXh0dXJlMkQocHJldlZpc2liaWxpdHksIGlkVGV4Q29vcmRpbmF0ZXMpO1xcbiAgICAgICAgdmlzaWJpbGl0eVZhbHVlLmEgPSBjbGFtcCh2aXNpYmlsaXR5VmFsdWUuYSArIGZhZGVpbkFtb3VudCwgMC4wLCAxLjApO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgZ2xfUG9zaXRpb24gPSBESVNDQVJEX1BPU0lUSU9OO1xcbiAgICB9XFxufVxcblwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIiN2ZXJzaW9uIDEwMFxcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxudmFyeWluZyBsb3dwIHZlYzQgdmlzaWJpbGl0eVZhbHVlO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmlzaWJpbGl0eVZhbHVlO1xcbn1cXG5cIiIsImltcG9ydCB7IEdsUmVuZGVyZXIgfSBmcm9tICcuLi8uLi9yZW5kZXIvZ2xfcmVuZGVyZXInO1xyXG5pbXBvcnQgZmFkZW91dE92ZXJsYXBwZWRWZXJ0ZXhTaGFkZXIgZnJvbSAnLi9zaGFkZXJzL2ZhZGVvdXRfb3ZlcmxhcHBlZC52ZXJ0JztcclxuaW1wb3J0IGZhZGVvdXRPdmVybGFwcGVkRnJhZ21lbnRTaGFkZXIgZnJvbSAnLi9zaGFkZXJzL2ZhZGVvdXRfb3ZlcmxhcHBlZC5mcmFnJztcclxuaW1wb3J0IFJlbmRlclN0YXRlIGZyb20gJy4uLy4uL3JlbmRlci9zdGF0ZSc7XHJcbmNvbnN0IFNUQVRFID0gbmV3IFJlbmRlclN0YXRlKHsgZGl0aGVyOiBmYWxzZSB9KTtcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmFkZW91dE92ZXJsYXBwZWQgZXh0ZW5kcyBHbFJlbmRlcmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcclxuICAgICAgICBjb25zdCBwcm9ncmFtID0gY29udGV4dC5jcmVhdGVQcm9ncmFtKGZhZGVvdXRPdmVybGFwcGVkVmVydGV4U2hhZGVyLCBmYWRlb3V0T3ZlcmxhcHBlZEZyYWdtZW50U2hhZGVyLCB7XHJcbiAgICAgICAgICAgIGF0dHJpYk1hcDoge1xyXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IDAgLyogUE9TSVRJT04gKi9cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHN1cGVyKGNvbnRleHQsIFNUQVRFLCBwcm9ncmFtKTtcclxuICAgICAgICBjb250ZXh0LmJpbmRQcm9ncmFtKHByb2dyYW0pO1xyXG4gICAgICAgIHByb2dyYW0uc2V0SW50U2NhbGFyVW5pZm9ybSgnZGlyZWN0UHJpb3JpdHlHcmlkJywgMCk7XHJcbiAgICAgICAgcHJvZ3JhbS5zZXRJbnRTY2FsYXJVbmlmb3JtKCdyZXZlcnNlUHJpb3JpdHlHcmlkJywgMSk7XHJcbiAgICAgICAgcHJvZ3JhbS5zZXRJbnRTY2FsYXJVbmlmb3JtKCdwcmV2VmlzaWJpbGl0eScsIDIpO1xyXG4gICAgfVxyXG4gICAgX3ByZXBhcmVQcm9ncmFtKHByb2dyYW0sIGRhdGEsIHNhbXBsZXJzLCBkaXJlY3RQcmlvcml0eSwgcmV2ZXJzZVByaW9yaXR5LCBwcmV2VmlzaWJpbGl0eSwgaWRIYWxmUHhTaXplLCBmYWRlb3V0QW1vdW50LCBjdXJyZW50Wm9vbSkge1xyXG4gICAgICAgIHN1cGVyLl9wcmVwYXJlUHJvZ3JhbShwcm9ncmFtLCBkYXRhLCBzYW1wbGVycywgZGlyZWN0UHJpb3JpdHksIHJldmVyc2VQcmlvcml0eSwgcHJldlZpc2liaWxpdHksIGlkSGFsZlB4U2l6ZSwgZmFkZW91dEFtb3VudCwgY3VycmVudFpvb20pO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFRleHR1cmVVbml0KDApO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFRleHR1cmUoZGlyZWN0UHJpb3JpdHkpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFRleHR1cmVVbml0KDEpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFRleHR1cmUocmV2ZXJzZVByaW9yaXR5KTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRUZXh0dXJlVW5pdCgyKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRUZXh0dXJlKHByZXZWaXNpYmlsaXR5KTtcclxuICAgICAgICBwcm9ncmFtLnNldFZlY3RvcjJVbmlmb3JtKCdpZEhhbGZQeFNpemUnLCBpZEhhbGZQeFNpemUpO1xyXG4gICAgICAgIHByb2dyYW0uc2V0U2NhbGFyVW5pZm9ybSgnZmFkZW91dEFtb3VudCcsIGZhZGVvdXRBbW91bnQpO1xyXG4gICAgICAgIHByb2dyYW0uc2V0U2NhbGFyVW5pZm9ybSgnY3VycmVudFpvb20nLCBjdXJyZW50Wm9vbSk7XHJcbiAgICB9XHJcbiAgICBfcmVuZGVyKGRhdGEsIG51bWJlck9mU2FtcGxlcnMpIHtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRWYW8oZGF0YSk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5kcmF3TWVzaCgwLCBudW1iZXJPZlNhbXBsZXJzLCAwIC8qIFBPSU5UUyAqLyk7XHJcbiAgICB9XHJcbn1cclxuIiwibW9kdWxlLmV4cG9ydHMgPSBcIiN2ZXJzaW9uIDEwMFxcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxuYXR0cmlidXRlIHZlYzIgcG9zaXRpb247XFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgZGlyZWN0UHJpb3JpdHlHcmlkO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHJldmVyc2VQcmlvcml0eUdyaWQ7XFxudW5pZm9ybSBzYW1wbGVyMkQgcHJldlZpc2liaWxpdHk7XFxudW5pZm9ybSB2ZWMyIGlkSGFsZlB4U2l6ZTtcXG51bmlmb3JtIGZsb2F0IGZhZGVvdXRBbW91bnQ7XFxudW5pZm9ybSBmbG9hdCBjdXJyZW50Wm9vbTtcXG5cXG52YXJ5aW5nIHZlYzQgdmlzaWJpbGl0eVZhbHVlO1xcblxcbmNvbnN0IHZlYzIgTk9fSUQgPSB2ZWMyKDAsIDApO1xcbmNvbnN0IHZlYzQgRElTQ0FSRF9QT1NJVElPTiA9IHZlYzQoMiwgMiwgMiwgMSk7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICB2ZWMyIHByaW1pdGl2ZUlkUmV2ZXJzZVByaW9yaXR5ID0gdGV4dHVyZTJEKHJldmVyc2VQcmlvcml0eUdyaWQsIHBvc2l0aW9uKS5yZztcXG5cXG4gICAgaWYgKFxcbiAgICAgICAgcHJpbWl0aXZlSWRSZXZlcnNlUHJpb3JpdHkgIT0gTk9fSUQgJiZcXG4gICAgICAgIHByaW1pdGl2ZUlkUmV2ZXJzZVByaW9yaXR5ICE9IHRleHR1cmUyRChkaXJlY3RQcmlvcml0eUdyaWQsIHBvc2l0aW9uKS5yZ1xcbiAgICApIHtcXG4gICAgICAgIHZlYzIgaWRUZXhDb29yZGluYXRlcyA9IHByaW1pdGl2ZUlkUmV2ZXJzZVByaW9yaXR5ICsgaWRIYWxmUHhTaXplO1xcbiAgICAgICAgdmVjNCBpZFdpbmRvd0Nvb3JkaW5hdGVzID0gdmVjNChpZFRleENvb3JkaW5hdGVzICogMi4wIC0gMS4wLCAwLCAxKTtcXG5cXG4gICAgICAgIGdsX1Bvc2l0aW9uID0gaWRXaW5kb3dDb29yZGluYXRlcztcXG4gICAgICAgIGdsX1BvaW50U2l6ZSA9IDEuMDtcXG5cXG4gICAgICAgIHZpc2liaWxpdHlWYWx1ZSA9IHRleHR1cmUyRChwcmV2VmlzaWJpbGl0eSwgaWRUZXhDb29yZGluYXRlcyk7XFxuICAgICAgICB2aXNpYmlsaXR5VmFsdWUuYiA9IGN1cnJlbnRab29tO1xcbiAgICAgICAgdmlzaWJpbGl0eVZhbHVlLmEgPSBjbGFtcCh2aXNpYmlsaXR5VmFsdWUuYSAtIGZhZGVvdXRBbW91bnQsIDAuMCwgMS4wKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIGdsX1Bvc2l0aW9uID0gRElTQ0FSRF9QT1NJVElPTjtcXG4gICAgfVxcbn1cXG5cIiIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbnZhcnlpbmcgbG93cCB2ZWM0IHZpc2liaWxpdHlWYWx1ZTtcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIGdsX0ZyYWdDb2xvciA9IHZpc2liaWxpdHlWYWx1ZTtcXG59XFxuXCIiLCJpbXBvcnQgKiBhcyB2ZWMyIGZyb20gJy4uLy4uL21hdGgvdmVjdG9yMic7XHJcbmltcG9ydCB7IHVpbnQxNlRvRmxvYXQgfSBmcm9tICcuLi8uLi91dGlsL2dwdXR5cGVzJztcclxuaW1wb3J0IHsgY29tcHV0ZVNxdWFyZXNDb3ZlcmVkQnlDb252ZXhQb2x5Z29uIH0gZnJvbSAnLi4vLi4vdXRpbC9jYXJ0ZXNpYW5fZ3JpZCc7XHJcbmltcG9ydCAqIGFzIGFycmF5IGZyb20gJy4uLy4uL3V0aWwvYXJyYXknO1xyXG4vLyBNYXBzIHdvcmxkIGNvb3JkaW5hdGVzIHRvIGNvcnJlc3BvbmRpbmcgcG9pbnRzIG9uIHRoZSBjYXJ0ZXNpYW4gZ3JpZC5cclxuY29uc3QgV09STERfTUlOX0NPT1JESU5BVEUgPSB2ZWMyLmNyZWF0ZSgtMSwgLTEpO1xyXG5jb25zdCBHUklEX1dPUkxEX1JBVElPID0gMC41O1xyXG5jb25zdCBHUklEX0NPT1JESU5BVEVTX0NPTlZFUlRFUiA9IChwb2ludCkgPT4ge1xyXG4gICAgY29uc3QgZ3JpZENvb3JkaW5hdGVzID0gdmVjMi5jb3B5KHBvaW50KTtcclxuICAgIHZlYzIuc3ViKGdyaWRDb29yZGluYXRlcywgV09STERfTUlOX0NPT1JESU5BVEUsIGdyaWRDb29yZGluYXRlcyk7XHJcbiAgICB2ZWMyLm11bG4oZ3JpZENvb3JkaW5hdGVzLCBHUklEX1dPUkxEX1JBVElPLCBncmlkQ29vcmRpbmF0ZXMpO1xyXG4gICAgcmV0dXJuIGdyaWRDb29yZGluYXRlcztcclxufTtcclxuY29uc3QgQ0FNRVJBX1BPU0lUSU9OX1VJTlQzMl9DT05WRVJURVIgPSAoY29tcG9uZW50KSA9PiAwLjUgKiAoY29tcG9uZW50ICsgMSkgKiAweGZmZmZmZmZmO1xyXG5jb25zdCBISUdIX0NPTVBPTkVOVF9FWFRSQUNUT1IgPSAoY29tcG9uZW50KSA9PiB1aW50MTZUb0Zsb2F0KE1hdGgudHJ1bmMoY29tcG9uZW50IC8gMHgxMDAwMCkpO1xyXG5jb25zdCBMT1dfQ09NUE9ORU5UX0VYVFJBQ1RPUiA9IChjb21wb25lbnQpID0+IHVpbnQxNlRvRmxvYXQoY29tcG9uZW50ICYgMHhmZmZmKTtcclxuY29uc3QgUkVHSU9OX0NPTVBBUkFUT1IgPSAoYSwgYikgPT4gYS54IC0gYi54IHx8IGEueSAtIGIueTtcclxuY29uc3QgdG1wQ2FtZXJhUG9zaXRpb24gPSB2ZWMyLmNyZWF0ZSgwLCAwKTtcclxuLyoqXHJcbiAqIElmIHRoZXJlIGFyZSBtdWx0aXBsZSB3b3JsZHMgdmlzaWJsZSAobGFyZ2UgbW9uaXRvcnMvbG93IHpvb20pIHByaW1pdGl2ZXMgYXJlIHJlbmRlcmVkIGluIG11bHRpcGxlIHBhc3NlcyBmcm9tXHJcbiAqIGRpZmZlcmVudCBwb3NpdGlvbnMgKGlmIHRoZSB3cmFwIG1vZGUgb2YgY29ycmVzcG9uZGluZyBkaXJlY3Rpb24gaXMgUkVQRUFUKSB0byBnZXQgY29ycmVjdCBmaW5hbCBwaWN0dXJlLlxyXG4gKiBUaGlzIG1ldGhvZCBjYWxjdWxhdGVzIGNhbWVyYSBwb3NpdGlvbnMgYW5kIHByZXBhcmUgdGhlbSB0byBiZSBwYXNzZWQgdG8gdGhlIHJlbmRlcigpIG1ldGhvZC5cclxuICovXHJcbmNvbnN0IGNhY2hlZFJlZ2lvbiA9IFtdO1xyXG5jb25zdCBjYWNoZWRQb3NpdGlvbnMgPSBbXTtcclxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZUNhbWVyYVBvc2l0aW9ucyhjYW1lcmEpIHtcclxuICAgIGNvbnN0IHZpc2libGVSZWdpb24gPSBjYW1lcmEuZ2V0VmlzaWJsZVJlZ2lvbigpO1xyXG4gICAgaWYgKGFycmF5LmNvbXBhcmUoUkVHSU9OX0NPTVBBUkFUT1IsIGNhY2hlZFJlZ2lvbiwgdmlzaWJsZVJlZ2lvbikgPT09IDApIHtcclxuICAgICAgICByZXR1cm4gY2FjaGVkUG9zaXRpb25zO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcG9zaXRpb25zID0gW107XHJcbiAgICBmb3IgKGNvbnN0IHdvcmxkUG9zaXRpb24gb2YgY29tcHV0ZVNxdWFyZXNDb3ZlcmVkQnlDb252ZXhQb2x5Z29uKHZpc2libGVSZWdpb24ubWFwKEdSSURfQ09PUkRJTkFURVNfQ09OVkVSVEVSKSkpIHtcclxuICAgICAgICBpZiAoKGNhbWVyYS5vcHRpb25zLndyYXBNb2RlWCA9PT0gMiAvKiBSRVBFQVQgKi8gfHwgd29ybGRQb3NpdGlvbi54ID09PSAwKSAmJlxyXG4gICAgICAgICAgICAoY2FtZXJhLm9wdGlvbnMud3JhcE1vZGVZID09PSAyIC8qIFJFUEVBVCAqLyB8fCB3b3JsZFBvc2l0aW9uLnkgPT09IDApKSB7XHJcbiAgICAgICAgICAgIC8vIDIuMCBjb252ZXJ0cyBjb3ZlcmVkIHNxdWFyZSBwb3NpdGlvbiB0byB0aGUgd29ybGQncyBjZW50ZXIgY29vcmRpbmF0ZXNcclxuICAgICAgICAgICAgLy8gLTEuMCByZXZlcnNlcyB0aGUgcG9zaXRpb24gb2YgdGhlIGNhbWVyYSB0byBzaG90IHRoZSB3b3JsZCBmcm9tXHJcbiAgICAgICAgICAgIHZlYzIubXVsbih3b3JsZFBvc2l0aW9uLCAtMS4wICogMi4wLCB0bXBDYW1lcmFQb3NpdGlvbik7XHJcbiAgICAgICAgICAgIHZlYzIuYWRkKGNhbWVyYS5jZW50ZXIsIHRtcENhbWVyYVBvc2l0aW9uLCB0bXBDYW1lcmFQb3NpdGlvbik7XHJcbiAgICAgICAgICAgIHZlYzIuY29udmVydCh0bXBDYW1lcmFQb3NpdGlvbiwgQ0FNRVJBX1BPU0lUSU9OX1VJTlQzMl9DT05WRVJURVIsIHRtcENhbWVyYVBvc2l0aW9uKTtcclxuICAgICAgICAgICAgcG9zaXRpb25zLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgbG9va0F0SGlnaDogdmVjMi5jb252ZXJ0KHRtcENhbWVyYVBvc2l0aW9uLCBISUdIX0NPTVBPTkVOVF9FWFRSQUNUT1IpLFxyXG4gICAgICAgICAgICAgICAgbG9va0F0TG93OiB2ZWMyLmNvbnZlcnQodG1wQ2FtZXJhUG9zaXRpb24sIExPV19DT01QT05FTlRfRVhUUkFDVE9SKVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBhcnJheS5jb3B5KHBvc2l0aW9ucywgY2FjaGVkUG9zaXRpb25zKTtcclxuICAgIGNhY2hlZFBvc2l0aW9ucy5sZW5ndGggPSBwb3NpdGlvbnMubGVuZ3RoO1xyXG4gICAgY2FjaGVkUmVnaW9uLmxlbmd0aCA9IHZpc2libGVSZWdpb24ubGVuZ3RoO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2aXNpYmxlUmVnaW9uLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY2FjaGVkUmVnaW9uW2ldID0gdmVjMi5jb3B5KHZpc2libGVSZWdpb25baV0sIGNhY2hlZFJlZ2lvbltpXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcG9zaXRpb25zO1xyXG59XHJcbiIsImltcG9ydCAqIGFzIHZlYzIgZnJvbSAnLi4vbWF0aC92ZWN0b3IyJztcclxuaW1wb3J0IHsgY29tcHV0ZUJCb3hGb3JQb2ludHMgfSBmcm9tICcuLi9tYXRoL3ZlY3RvcjInO1xyXG4vKipcclxuICogQ29udGFpbmVyIG9mIGluZGV4ZWQgbWluL21heCB2YWx1ZXMgd2l0aCBhIHNpbmdsZSB1cGRhdGUgbWV0aG9kLlxyXG4gKi9cclxuY2xhc3MgRXh0cmVtdW1TdG9yYWdlIHtcclxuICAgIGNvbnN0cnVjdG9yKGxlbmd0aCkge1xyXG4gICAgICAgIHRoaXMuX21pbnMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcclxuICAgICAgICB0aGlzLl9tYXhzID0gbmV3IEFycmF5KGxlbmd0aCk7XHJcbiAgICAgICAgdGhpcy5fbWlucy5maWxsKE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XHJcbiAgICAgICAgdGhpcy5fbWF4cy5maWxsKE51bWJlci5ORUdBVElWRV9JTkZJTklUWSk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVWYWx1ZShpbmRleCwgdmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9taW5zW2luZGV4XSA9IE1hdGgubWluKHRoaXMuX21pbnNbaW5kZXhdLCB2YWx1ZSk7XHJcbiAgICAgICAgdGhpcy5fbWF4c1tpbmRleF0gPSBNYXRoLm1heCh0aGlzLl9tYXhzW2luZGV4XSwgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgKnZhbHVlcygpIHtcclxuICAgICAgICBjb25zdCBpdGVtID0geyBtaW46IDAsIG1heDogMCwgaW5kZXg6IC0xIH07XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9taW5zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGl0ZW0ubWluID0gdGhpcy5fbWluc1tpXTtcclxuICAgICAgICAgICAgaXRlbS5tYXggPSB0aGlzLl9tYXhzW2ldO1xyXG4gICAgICAgICAgICBpdGVtLmluZGV4ID0gaTtcclxuICAgICAgICAgICAgeWllbGQgaXRlbTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFNxdWFyZXMgdGhhdCBhcmUgb255IHRvdWNoZWQgYnkgYSBsaW5lICh3aXRoIG5vIHNpZ25pZmljYW50IGNyb3NzaW5nIGFuIGVkZ2UpIHNob3VsZCBub3QgYmUgY29uc2lkZXJlZCBcImNvdmVyZWRcIi5cclxuICogSXQgaGFwcGVucyB3aGVuIGEgcG9pbnQgbWF0Y2hlcyB0aGUgbWF4IGNvb3JkaW5hdGUgKGludGVnZXIpIGFuZCB0aGlzIGNhc2UgaXMgaGFuZGxlZCBoZXJlLlxyXG4gKi9cclxuZnVuY3Rpb24gZmxvb3JUb0NlbGxDb29yZGluYXRlKHZhbHVlLCBtYXhWYWx1ZSkge1xyXG4gICAgcmV0dXJuIE51bWJlci5pc0ludGVnZXIodmFsdWUpICYmIG1heFZhbHVlID09PSB2YWx1ZSA/IHZhbHVlIC0gMSA6IE1hdGguZmxvb3IodmFsdWUpO1xyXG59XHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHNxdWFyZXMgY292ZXJlZCAoYXQgbGVhc3QgcGFydGlhbGx5KSBieSBhIGNvbnZleCBwb2x5Z29uLlxyXG4gKlxyXG4gKiBAcGFyYW0gcG9pbnRzIENvbnZleCBwb2x5Z29uIHBvaW50IGNvb3JkaW5hdGVzIChvbiB0aGUgZ3JpZCkuXHJcbiAqIEByZXR1cm5zIExpc3Qgb2YgdW5pdCBzcXVhcmUgY29vcmRpbmF0ZXMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZVNxdWFyZXNDb3ZlcmVkQnlDb252ZXhQb2x5Z29uKHBvaW50cykge1xyXG4gICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICBjb25zdCBiYm94ID0gY29tcHV0ZUJCb3hGb3JQb2ludHMocG9pbnRzKTtcclxuICAgIGNvbnN0IG1pblggPSBNYXRoLmZsb29yKGJib3gubWluWCk7XHJcbiAgICBjb25zdCB4TGVuZ3RoID0gTWF0aC5jZWlsKGJib3gubWF4WCkgLSBtaW5YO1xyXG4gICAgY29uc3QgZXh0cmVtdW1zID0gbmV3IEV4dHJlbXVtU3RvcmFnZSh4TGVuZ3RoKTtcclxuICAgIGZvciAobGV0IGkgPSBwb2ludHMubGVuZ3RoIC0gMSwgaiA9IDA7IGogPCBwb2ludHMubGVuZ3RoOyBpID0gaisrKSB7XHJcbiAgICAgICAgbGV0IHAxID0gcG9pbnRzW2ldO1xyXG4gICAgICAgIGxldCBwMiA9IHBvaW50c1tqXTtcclxuICAgICAgICAvLyBnbyBmcm9tIGxlZnQgdG8gcmlnaHQgYWx3YXlzIHRvIG5vdCBoYW5kbGUgdGhlIG9wcG9zaXRlIGNhc2VcclxuICAgICAgICBpZiAocDEueCA+IHAyLngpIHtcclxuICAgICAgICAgICAgY29uc3QgdG1wID0gcDE7XHJcbiAgICAgICAgICAgIHAxID0gcDI7XHJcbiAgICAgICAgICAgIHAyID0gdG1wO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjYWxjdWxhdGUgZnJvbS90byBpbnRlcnZhbCBzbyB0aGF0IG9ubHkgXCJpbnRlcm5hbFwiIGludGVnZXIgeC1lcyBhcmUgY2FwdHVyZWRcclxuICAgICAgICBjb25zdCBmcm9tWCA9IE1hdGguZmxvb3IocDEueCArIDEpO1xyXG4gICAgICAgIGNvbnN0IHRvWCA9IE1hdGguY2VpbChwMi54IC0gMSk7XHJcbiAgICAgICAgY29uc3Qgc2xvcGUgPSAocDEueSAtIHAyLnkpIC8gKHAxLnggLSBwMi54KTtcclxuICAgICAgICAvLyBoYW5kbGUgdGVybWluYWwgcG9pbnRzIHNlcGFyYXRlbHkgZnJvbSB0aGUgXCJpbnRlcm5hbFwiIG9uZXNcclxuICAgICAgICBleHRyZW11bXMudXBkYXRlVmFsdWUoZmxvb3JUb0NlbGxDb29yZGluYXRlKHAxLngsIGJib3gubWF4WCkgLSBtaW5YLCBmbG9vclRvQ2VsbENvb3JkaW5hdGUocDEueSwgYmJveC5tYXhZKSk7XHJcbiAgICAgICAgZXh0cmVtdW1zLnVwZGF0ZVZhbHVlKGZsb29yVG9DZWxsQ29vcmRpbmF0ZShwMi54LCBiYm94Lm1heFgpIC0gbWluWCwgZmxvb3JUb0NlbGxDb29yZGluYXRlKHAyLnksIGJib3gubWF4WSkpO1xyXG4gICAgICAgIGZvciAobGV0IHggPSBmcm9tWDsgeCA8PSB0b1g7IHgrKykge1xyXG4gICAgICAgICAgICBjb25zdCB5SW50ZXJjZXB0ID0gKGlzRmluaXRlKHNsb3BlKSA/IHNsb3BlICogKHggLSBwMS54KSA6IDApICsgcDEueTtcclxuICAgICAgICAgICAgY29uc3QgbmV4dFggPSB4IC0gbWluWDtcclxuICAgICAgICAgICAgY29uc3QgcHJldlggPSBuZXh0WCAtIDE7XHJcbiAgICAgICAgICAgIGNvbnN0IHkgPSBNYXRoLmZsb29yKHlJbnRlcmNlcHQpO1xyXG4gICAgICAgICAgICAvLyBjaGVjayBpZiB3ZSBoaXQgZXhhY3RseSB0aGUgaW50ZXJzZWN0aW9uIG9mIHR3byBpbnRlZ2VyIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKHlJbnRlcmNlcHQpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoeUludGVyY2VwdCA9PT0gYmJveC5tYXhZKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXh0cmVtdW1zLnVwZGF0ZVZhbHVlKHByZXZYLCB5IC0gMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXh0cmVtdW1zLnVwZGF0ZVZhbHVlKG5leHRYLCB5IC0gMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzbG9wZSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB0d28gZGlhZ29uYWwgc3F1YXJlcyBpbnRlcnNlY3RlZCBieSBhIGxpbmUgd2l0aCBwb3NpdGl2ZSBzbG9wZVxyXG4gICAgICAgICAgICAgICAgICAgIGV4dHJlbXVtcy51cGRhdGVWYWx1ZShwcmV2WCwgeSAtIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGV4dHJlbXVtcy51cGRhdGVWYWx1ZShuZXh0WCwgeSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzbG9wZSA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB0d28gZGlhZ29uYWwgc3F1YXJlcyBpbnRlcnNlY3RlZCBieSBhIGxpbmUgd2l0aCBuZWdhdGl2ZSBzbG9wZVxyXG4gICAgICAgICAgICAgICAgICAgIGV4dHJlbXVtcy51cGRhdGVWYWx1ZShwcmV2WCwgeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXh0cmVtdW1zLnVwZGF0ZVZhbHVlKG5leHRYLCB5IC0gMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBleHRyZW11bXMudXBkYXRlVmFsdWUocHJldlgsIHkpO1xyXG4gICAgICAgICAgICAgICAgZXh0cmVtdW1zLnVwZGF0ZVZhbHVlKG5leHRYLCB5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZvciAoY29uc3QgeyBtaW4sIG1heCwgaW5kZXggfSBvZiBleHRyZW11bXMudmFsdWVzKCkpIHtcclxuICAgICAgICBjb25zdCB4ID0gbWluWCArIGluZGV4O1xyXG4gICAgICAgIGZvciAobGV0IHkgPSBtaW47IHkgPD0gbWF4OyB5KyspIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2godmVjMi5jcmVhdGUoeCwgeSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuIiwiaW1wb3J0IHsgY29weSB9IGZyb20gJy4vYXJyYXknO1xyXG5pbXBvcnQgeyBOVU1FUklDQUxfQ09NUEFSQVRPUiB9IGZyb20gJy4vY29tcGFyYXRvcic7XHJcbi8qKlxyXG4gKiBGaWx0ZXJzIGFuIGFycmF5IG9mIHZhbHVlcyB3aXRoIG1lZGlhbiBmaWx0ZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB2YWx1ZXMgVmFsdWVzIHRvIGJlIGZpbHRlcmVkLlxyXG4gKiBAcGFyYW0gd2luZG93UmFkaXVzIEhvdyBtYW55IHZhbHVlcyBhcm91bmQgYSBzYW1wbGUgZ2V0IGludG8gZmlsdGVyIHdpbmRvdy5cclxuICogQHJldHVybnMgQXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG1lZGlhbkZpbHRlcih2YWx1ZXMsIHdpbmRvd1JhZGl1cyA9IDMpIHtcclxuICAgIGNvbnN0IHdpbmRvdyA9IG5ldyBBcnJheSgyICogd2luZG93UmFkaXVzICsgMSk7XHJcbiAgICB3aW5kb3cuZmlsbCh2YWx1ZXNbMF0pO1xyXG4gICAgY29uc3QgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aDtcclxuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheShsZW5ndGgpO1xyXG4gICAgY29uc3QgZmlyc3QgPSB2YWx1ZXNbMF07XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdpbmRvd1JhZGl1czsgKytpKSB7XHJcbiAgICAgICAgd2luZG93LmZpbGwoZmlyc3QsIDAsIHdpbmRvd1JhZGl1cyAtIGkgKyAxKTtcclxuICAgICAgICBjb3B5KHZhbHVlcywgd2luZG93LCAwLCBpICsgd2luZG93UmFkaXVzICsgMSwgd2luZG93UmFkaXVzIC0gaSArIDEpO1xyXG4gICAgICAgIHdpbmRvdy5zb3J0KE5VTUVSSUNBTF9DT01QQVJBVE9SKTtcclxuICAgICAgICByZXN1bHRbaV0gPSB3aW5kb3dbd2luZG93UmFkaXVzXTtcclxuICAgIH1cclxuICAgIGZvciAobGV0IGkgPSB3aW5kb3dSYWRpdXM7IGkgPCBsZW5ndGggLSB3aW5kb3dSYWRpdXM7ICsraSkge1xyXG4gICAgICAgIGNvcHkodmFsdWVzLCB3aW5kb3csIGkgLSB3aW5kb3dSYWRpdXMsIGkgKyB3aW5kb3dSYWRpdXMgKyAxKTtcclxuICAgICAgICB3aW5kb3cuc29ydChOVU1FUklDQUxfQ09NUEFSQVRPUik7XHJcbiAgICAgICAgcmVzdWx0W2ldID0gd2luZG93W3dpbmRvd1JhZGl1c107XHJcbiAgICB9XHJcbiAgICBjb25zdCBsYXN0ID0gdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXTtcclxuICAgIGZvciAobGV0IGkgPSBsZW5ndGggLSB3aW5kb3dSYWRpdXM7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgIGNvcHkodmFsdWVzLCB3aW5kb3csIGkgLSB3aW5kb3dSYWRpdXMsIGxlbmd0aCk7XHJcbiAgICAgICAgd2luZG93LmZpbGwobGFzdCwgdmFsdWVzLmxlbmd0aCAtIGkgKyB3aW5kb3dSYWRpdXMpO1xyXG4gICAgICAgIHdpbmRvdy5zb3J0KE5VTUVSSUNBTF9DT01QQVJBVE9SKTtcclxuICAgICAgICByZXN1bHRbaV0gPSB3aW5kb3dbd2luZG93UmFkaXVzXTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuIiwiaW1wb3J0IExpc3RSZW5kZXJVbml0IGZyb20gJy4vbGlzdF9yZW5kZXJfdW5pdCc7XHJcbmltcG9ydCB7IFZvaWRFdmVudEVtaXR0ZXIgfSBmcm9tICcuLi91dGlsL2V2ZW50X2VtaXR0ZXInO1xyXG5pbXBvcnQgUmVuZGVyU3RhdGUgZnJvbSAnLi9zdGF0ZSc7XHJcbmltcG9ydCB7IGNhbGN1bGF0ZUNhbWVyYVBvc2l0aW9ucyB9IGZyb20gJy4vdXRpbC9jYW1lcmFfcG9zaXRpb24nO1xyXG5jb25zdCBGSU5BTF9SRU5ERVJfU1RBVEUgPSBuZXcgUmVuZGVyU3RhdGUoe1xyXG4gICAgY2xlYXJEZXB0aDogMCxcclxuICAgIGRlcHRoVGVzdDogdHJ1ZSxcclxuICAgIGRlcHRoRnVuYzogNTE4IC8qIEdSRUFURVJfT1JfRVFVQUwgKi9cclxufSk7XHJcbi8qKlxyXG4gKiBSb290IHNjZW5lIHJlbmRlcmVyLiBJdCBnZW5lcmF0ZXMgZmluYWwgY2FudmFzIGltYWdlIGNvbXBvc2luZyBpdCBmcm9tIGluZGVwZW5kZW50IGxheWVycyAoTGF5ZXJSZW5kZXJVbml0KS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1haW5SZW5kZXJVbml0IGV4dGVuZHMgTGlzdFJlbmRlclVuaXQge1xyXG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgY2FtZXJhKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcclxuICAgICAgICB0aGlzLl9jYW1lcmEgPSBjYW1lcmE7XHJcbiAgICAgICAgdGhpcy5vblJlbmRlciA9IG5ldyBWb2lkRXZlbnRFbWl0dGVyKCk7XHJcbiAgICB9XHJcbiAgICByZW5kZXIodGFyZ2V0KSB7XHJcbiAgICAgICAgY29uc3Qgdmlld1Byb2pNYXRpeCA9IHRoaXMuX2NhbWVyYS5nZXRWaWV3UHJvak1hdHJpeCgpO1xyXG4gICAgICAgIGNvbnN0IGNhbWVyYVBvc2l0aW9ucyA9IGNhbGN1bGF0ZUNhbWVyYVBvc2l0aW9ucyh0aGlzLl9jYW1lcmEpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFJlbmRlclRhcmdldCh0YXJnZXQpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFJlbmRlclN0YXRlKEZJTkFMX1JFTkRFUl9TVEFURSk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5jbGVhckN1cnJlbnRUYXJnZXQoMTc2NjQgLyogQUxMICovKTtcclxuICAgICAgICBmb3IgKGNvbnN0IHJlbmRlcmVyIG9mIHRoaXMuX3N1YlJlbmRlclVuaXRzKSB7XHJcbiAgICAgICAgICAgIHJlbmRlcmVyLnJlbmRlcih0YXJnZXQsIHZpZXdQcm9qTWF0aXgsIGNhbWVyYVBvc2l0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMub25SZW5kZXIuZmlyZSgpO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IFZvaWRFdmVudEVtaXR0ZXIgfSBmcm9tICcuLi91dGlsL2V2ZW50X2VtaXR0ZXInO1xyXG5jbGFzcyBOb0Jhc2VSZW5kZXJVbml0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcignQmFzZSByZW5kZXIgdW5pdCBpcyBub3QgaW4gdGhlIGxpc3QnKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogU2ltcGxlIGltcGxlbWVudGF0aW9uIG9mIENvbXBvc2l0ZVJlbmRlclVuaXQgdGhhdCBqdXN0IHJ1bnMgc3ViIHVuaXRzIGluIHRoZSBvcmRlciBvZiBhZGRpdGlvbi5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpc3RSZW5kZXJVbml0IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMub25VcGRhdGUgPSBuZXcgVm9pZEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMuX3N1YlJlbmRlclVuaXRzID0gW107XHJcbiAgICAgICAgdGhpcy5fc3ViUmVuZGVyVW5pdFVwZGF0ZUxpc3RlbmVyID0gdGhpcy5fb25TdWJSZW5kZXJVbml0VXBkYXRlLmJpbmQodGhpcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgUmVuZGVyVW5pdCB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LlxyXG4gICAgICovXHJcbiAgICBhZGRSZW5kZXJVbml0KHN1YlJlbmRlclVuaXQpIHtcclxuICAgICAgICB0aGlzLl9zdWJSZW5kZXJVbml0cy5wdXNoKHN1YlJlbmRlclVuaXQpO1xyXG4gICAgICAgIHN1YlJlbmRlclVuaXQub25VcGRhdGUuYWRkTGlzdGVuZXIodGhpcy5fc3ViUmVuZGVyVW5pdFVwZGF0ZUxpc3RlbmVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBSZW5kZXJVbml0IGZyb20gdGhlIGxpc3QuXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZVJlbmRlclVuaXQoc3ViUmVuZGVyVW5pdCkge1xyXG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fc3ViUmVuZGVyVW5pdHMuaW5kZXhPZihzdWJSZW5kZXJVbml0KTtcclxuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N1YlJlbmRlclVuaXRzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIHN1YlJlbmRlclVuaXQub25VcGRhdGUucmVtb3ZlTGlzdGVuZXIodGhpcy5fc3ViUmVuZGVyVW5pdFVwZGF0ZUxpc3RlbmVyKTtcclxuICAgICAgICAgICAgdGhpcy5vblVwZGF0ZS5maXJlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIFJlbmRlclVuaXQgYWJvdmUgdGhlIGJhc2Ugb25lLiBcIkFib3ZlXCIgbWVhbnMgdGhhdCBpdHMgcmVuZGVyKCkgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRoZSBiYXNlJ3Mgb25lLlxyXG4gICAgICovXHJcbiAgICBhZGRSZW5kZXJVbml0QWJvdmUoYmFzZSwgc3ViUmVuZGVyVW5pdCkge1xyXG4gICAgICAgIGNvbnN0IGJhc2VJbmRleCA9IHRoaXMuX3N1YlJlbmRlclVuaXRzLmluZGV4T2YoYmFzZSk7XHJcbiAgICAgICAgaWYgKGJhc2VJbmRleCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3ViUmVuZGVyVW5pdHMuc3BsaWNlKGJhc2VJbmRleCArIDEsIDAsIHN1YlJlbmRlclVuaXQpO1xyXG4gICAgICAgICAgICBzdWJSZW5kZXJVbml0Lm9uVXBkYXRlLmFkZExpc3RlbmVyKHRoaXMuX3N1YlJlbmRlclVuaXRVcGRhdGVMaXN0ZW5lcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgTm9CYXNlUmVuZGVyVW5pdEVycm9yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIFJlbmRlclVuaXQgYmVsb3cgdGhlIGJhc2Ugb25lLiBcIkJlbG93XCIgbWVhbnMgdGhhdCBpdHMgcmVuZGVyKCkgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIGJlZm9yZSB0aGUgYmFzZSdzIG9uZS5cclxuICAgICAqL1xyXG4gICAgYWRkUmVuZGVyVW5pdEJlbG93KGJhc2UsIHN1YlJlbmRlclVuaXQpIHtcclxuICAgICAgICBjb25zdCBiYXNlSW5kZXggPSB0aGlzLl9zdWJSZW5kZXJVbml0cy5pbmRleE9mKGJhc2UpO1xyXG4gICAgICAgIGlmIChiYXNlSW5kZXggIT09IC0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N1YlJlbmRlclVuaXRzLnNwbGljZShiYXNlSW5kZXgsIDAsIHN1YlJlbmRlclVuaXQpO1xyXG4gICAgICAgICAgICBzdWJSZW5kZXJVbml0Lm9uVXBkYXRlLmFkZExpc3RlbmVyKHRoaXMuX3N1YlJlbmRlclVuaXRVcGRhdGVMaXN0ZW5lcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgTm9CYXNlUmVuZGVyVW5pdEVycm9yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVuZGVyKHRhcmdldCwgLi4uYXJncykge1xyXG4gICAgICAgIGZvciAoY29uc3QgcmVuZGVyZXIgb2YgdGhpcy5fc3ViUmVuZGVyVW5pdHMpIHtcclxuICAgICAgICAgICAgcmVuZGVyZXIucmVuZGVyKHRhcmdldCwgLi4uYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX29uU3ViUmVuZGVyVW5pdFVwZGF0ZSgpIHtcclxuICAgICAgICB0aGlzLm9uVXBkYXRlLmZpcmUoKTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgTWVtb3J5UGFnZSBmcm9tICcuL3BhZ2UnO1xyXG5pbXBvcnQgeyBjb3VudFZlcnRpY2VzIH0gZnJvbSAnLi9jb3VudF92ZXJ0aWNlcyc7XHJcbmltcG9ydCB7IEFyZW5hQWxsb2NhdG9yIH0gZnJvbSAnLi4vLi4vdXRpbC9hbGxvY2F0b3InO1xyXG5jb25zdCBNQVhfVkVSVEVYX0NPVU5UID0gMHgxMDAwMDtcclxuLy8gRklYTUUoZG1pa2lzKSBMZXQncyB1c2Ugb3ZlcnNpemVkIGluZGV4IGJ1ZmZlciB0aWwgd2Ugc29ydCBvdXQgaW5kaWNlcyBhbGxvY2F0aW9uXHJcbi8vIGJvdGggaW4gd3JpdGVycyBhbmQgdGhlIG1hbmFnZXIuXHJcbmNvbnN0IFBBR0VfSU5ERVhfQlVGRkVSX0JZVEVfU0laRSA9IDB4MTAwMDAwO1xyXG4vKipcclxuICogTWVtb3J5IHBhZ2Ugd2l0aCB0aGUgZm9sbG93aW5nIHBlY3VsaWFyaXR5OiBvbmNlIGFsbG9jYXRpb24gaXMgZmFpbGVkIGl0IGdldHMgY2xvc2VkIGZvciBhbnkgc3Vic2VxdWVudFxyXG4gKiBhbGxvY2F0aW9ucy4gSXQgYWxsb3cgdG8ga2VlcCByZWxhdGVkIHByaW1pdGl2ZXMgY2xvc2VyIGluIG1lbW9yeS5cclxuICovXHJcbmNsYXNzIFNpbmdsZVBhc3NNZW1vcnlQYWdlIGV4dGVuZHMgTWVtb3J5UGFnZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih2ZXJ0ZXhCdWZmZXIsIGluZGV4QnVmZmVyLCB2YW8sIGluZGV4VHlwZSkge1xyXG4gICAgICAgIHN1cGVyKHZlcnRleEJ1ZmZlciwgaW5kZXhCdWZmZXIsIHZhbywgaW5kZXhUeXBlLCBuZXcgQXJlbmFBbGxvY2F0b3IodmVydGV4QnVmZmVyLmdldFNpemUoKSksIG5ldyBBcmVuYUFsbG9jYXRvcihpbmRleEJ1ZmZlci5nZXRTaXplKCkpKTtcclxuICAgICAgICB0aGlzLl9mYWlsZWRBbGxvY2F0aW9uID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBhbGxvY2F0ZSh2ZXJ0ZXhCeXRlTGVuZ3RoLCBpbmRleEJ5dGVMZW5ndGgpIHtcclxuICAgICAgICBpZiAodGhpcy5fZmFpbGVkQWxsb2NhdGlvbikge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY2h1bmsgPSBzdXBlci5hbGxvY2F0ZSh2ZXJ0ZXhCeXRlTGVuZ3RoLCBpbmRleEJ5dGVMZW5ndGgpO1xyXG4gICAgICAgIHRoaXMuX2ZhaWxlZEFsbG9jYXRpb24gPSAoY2h1bmsgPT09IG51bGwpO1xyXG4gICAgICAgIHJldHVybiBjaHVuaztcclxuICAgIH1cclxufVxyXG4vKipcclxuICogTWFuYWdlciB0aGF0IGNvbnRyb2xzIEdMIG1lbW9yeSBhbGxvY2F0aW9ucyBhbmQgcGFnaW5hdGlvbi5bXVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWVtb3J5TWFuYWdlciB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgbWVtb3J5IG1hbmFnZXIgdGhhdCB3aWxsIGFsbG9jYXRlIG1lbW9yeSBpbiBhIGdpdmVuIGNvbnRleHQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGhlIGNvbnRleHQuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcclxuICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcclxuICAgICAgICB0aGlzLl9wYWdlcyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLl9lbXB0eVBhZ2VzQ2xlYXJUaW1lb3V0ID0gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWxsb2NhdGVzIG1lbW9yeSBmb3IgYSBnaXZlbiBkYXRhIGluIHRoZSBtYW5hZ2VyIGFuZCB1cGxvYWRzIGdpdmVuIGRhdGEuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZlcnRleERhdGEgQnVmZmVyIHdpdGggdmVydGljZXMgdGhhdCBuZWVkcyB0byBiZSBhbGxvY2F0ZWQuXHJcbiAgICAgKiBAcGFyYW0gaW5kZXhEYXRhIEJ1ZmZlciB3aXRoIGluZGljZXMgdGhhdCBuZWVkcyB0byBiZSBhbGxvY2F0ZWQuXHJcbiAgICAgKiBAcGFyYW0gYXR0cmlidXRlTWFwcGluZyBNYXBwaW5nIG9mIHZlcnRleCBhdHRyaWJ1dGVzLlxyXG4gICAgICogQHJldHVybnMgRGVzY3JpcHRvciBvZiB0aGUgYWxsb2NhdGVkIG1lbW9yeSByZWdpb24uXHJcbiAgICAgKi9cclxuICAgIGFsbG9jYXRlKHZlcnRleERhdGEsIGluZGV4RGF0YSwgYXR0cmlidXRlTWFwcGluZykge1xyXG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLl9jb250ZXh0O1xyXG4gICAgICAgIGxldCBwYWdlU2V0ID0gdGhpcy5fcGFnZXMuZ2V0KGF0dHJpYnV0ZU1hcHBpbmcpO1xyXG4gICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gcGFnZXMgZm9yIHRoZSBnaXZlbiBhdHRyaWJ1dGUgbWFwcGluZywgY3JlYXRlIGEgbmV3IHNldC5cclxuICAgICAgICBpZiAoIXBhZ2VTZXQpIHtcclxuICAgICAgICAgICAgcGFnZVNldCA9IG5ldyBTZXQoKTtcclxuICAgICAgICAgICAgdGhpcy5fcGFnZXMuc2V0KGF0dHJpYnV0ZU1hcHBpbmcsIHBhZ2VTZXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUcnkgdG8gYWxsb2NhdGUgZGF0YSBpbiB0aGUgZXhpc3RpbmcgcGFnZXMuXHJcbiAgICAgICAgZm9yIChjb25zdCBwYWdlIG9mIHBhZ2VTZXQpIHtcclxuICAgICAgICAgICAgY29uc3QgbWVtb3J5Q2h1bmsgPSBwYWdlLmFsbG9jYXRlKHZlcnRleERhdGEuYnl0ZUxlbmd0aCwgaW5kZXhEYXRhLmJ5dGVMZW5ndGgpO1xyXG4gICAgICAgICAgICBpZiAobWVtb3J5Q2h1bmspIHtcclxuICAgICAgICAgICAgICAgIC8vIFN1Y2Nlc3MhIE5vdyB3ZSBqdXN0IHVwbG9hZCB0aGUgZGF0YS5cclxuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVBhZ2UocGFnZSwgbWVtb3J5Q2h1bmssIHZlcnRleERhdGEsIGluZGV4RGF0YSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVtb3J5Q2h1bms7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gV2UndmUgZmFpbGVkIHRvIGFsbG9jYXRlIHRoZSBkYXRhIGluIGFueSBvZiBleGlzdGluZyBwYWdlcy4gTm8gd29ycmllc1xyXG4gICAgICAgIC8vIHRob3VnaCwgd2UganVzdCBjcmVhdGUgYSBuZXcgb25lOilcclxuICAgICAgICBjb25zdCB2ZXJ0ZXhCdWZmZXIgPSBjb250ZXh0LmNyZWF0ZVZlcnRleEJ1ZmZlcihcclxuICAgICAgICAvLyBzb21lIGJ1ZmZlciB3cml0ZXJzIGRvbid0IHVzZSBpbmRpY2VzIGFuZCBNQVhfVkVSVEVYX0NPVU5UIHJlc3RyaWN0aW9uIGlzIG5vdCBhcHBsaWVkIGluIHN1Y2ggY2FzZXNcclxuICAgICAgICBNYXRoLm1heChNQVhfVkVSVEVYX0NPVU5UICogYXR0cmlidXRlTWFwcGluZy52ZXJ0ZXhCeXRlU2l6ZSwgdmVydGV4RGF0YS5ieXRlTGVuZ3RoKSk7XHJcbiAgICAgICAgY29uc3QgaW5kZXhCdWZmZXIgPSBjb250ZXh0LmNyZWF0ZUluZGV4QnVmZmVyKFBBR0VfSU5ERVhfQlVGRkVSX0JZVEVfU0laRSk7XHJcbiAgICAgICAgY29uc3QgdmFvID0gY29udGV4dC5jcmVhdGVWYW8oYXR0cmlidXRlTWFwcGluZywgdmVydGV4QnVmZmVyLCBpbmRleEJ1ZmZlcik7XHJcbiAgICAgICAgY29uc3QgcGFnZSA9IG5ldyBTaW5nbGVQYXNzTWVtb3J5UGFnZSh2ZXJ0ZXhCdWZmZXIsIGluZGV4QnVmZmVyLCB2YW8sIDUxMjMgLyogVU5TSUdORURfU0hPUlQgKi8pO1xyXG4gICAgICAgIHBhZ2Uuc2V0RGVsZWdhdGUodGhpcyk7XHJcbiAgICAgICAgcGFnZVNldC5hZGQocGFnZSk7XHJcbiAgICAgICAgLy8gSGVyZSB3ZSBhc3N1bWUgd2UgYWx3YXlzIGNhbiBhbGxvY2F0ZSBkYXRhIGluIGFuIGVtcHR5IHBhZ2UuXHJcbiAgICAgICAgY29uc3QgbWVtb3J5Q2h1bmsgPSBwYWdlLmFsbG9jYXRlKHZlcnRleERhdGEuYnl0ZUxlbmd0aCwgaW5kZXhEYXRhLmJ5dGVMZW5ndGgpO1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZVBhZ2UocGFnZSwgbWVtb3J5Q2h1bmssIHZlcnRleERhdGEsIGluZGV4RGF0YSk7XHJcbiAgICAgICAgcmV0dXJuIG1lbW9yeUNodW5rO1xyXG4gICAgfVxyXG4gICAgb25QYWdlRW1wdHkoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9lbXB0eVBhZ2VzQ2xlYXJUaW1lb3V0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2VtcHR5UGFnZXNDbGVhclRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NsZWFyRW1wdHlQYWdlcygpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZW1wdHlQYWdlc0NsZWFyVGltZW91dCA9IDA7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGVzdHJveXMgdGhlIG1hbmFnZXIgYW5kIGFsbCBpdHMgbWVtb3J5IHBhZ2VzLiBBbGwgbWVtb3J5IGNodW5rcyB0aGF0IHdlcmVcclxuICAgICAqIGFsbG9jYXRlZCBpbiB0aGUgbWFuYWdlciBiZWNvbWUgaW52YWxpZC5cclxuICAgICAqL1xyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICBpZiAodGhpcy5fZW1wdHlQYWdlc0NsZWFyVGltZW91dCkge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fZW1wdHlQYWdlc0NsZWFyVGltZW91dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3QgWywgcGFnZVNldF0gb2YgdGhpcy5fcGFnZXMpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBwYWdlIG9mIHBhZ2VTZXQpIHtcclxuICAgICAgICAgICAgICAgIHBhZ2UuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3VwZGF0ZVBhZ2UocGFnZSwgbWVtb3J5Q2h1bmssIHZlcnRleERhdGEsIGluZGV4RGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLl9jb250ZXh0O1xyXG4gICAgICAgIC8vIExldCdzIGVuc3VyZSB0aGF0IHdlIHdvbid0IGJyZWFrIGFueSBib3VuZCBWQU9zLlxyXG4gICAgICAgIGNvbnRleHQuYmluZFZhbyhudWxsKTtcclxuICAgICAgICBjb250ZXh0LnVwbG9hZERhdGFUb0J1ZmZlcihwYWdlLnZlcnRleEJ1ZmZlciwgdmVydGV4RGF0YSwgbWVtb3J5Q2h1bmsudmVydGV4Qnl0ZU9mZnNldCk7XHJcbiAgICAgICAgLy8gU2hpZnQgaW5kaWNlcy5cclxuICAgICAgICBjb25zdCBiYXNlSW5kZXggPSBjb3VudFZlcnRpY2VzKG1lbW9yeUNodW5rLnZlcnRleEJ5dGVPZmZzZXQsIHBhZ2UudmFvLmF0dHJpYnV0ZU1hcHBpbmcpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kZXhEYXRhLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIGluZGV4RGF0YVtpXSArPSBiYXNlSW5kZXg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnRleHQudXBsb2FkRGF0YVRvQnVmZmVyKHBhZ2UuaW5kZXhCdWZmZXIsIGluZGV4RGF0YSwgbWVtb3J5Q2h1bmsuaW5kZXhCeXRlT2Zmc2V0KTtcclxuICAgIH1cclxuICAgIF9jbGVhckVtcHR5UGFnZXMoKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBwYWdlU2V0IG9mIHRoaXMuX3BhZ2VzLnZhbHVlcygpKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGFnZSBvZiBwYWdlU2V0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFnZS5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYWdlU2V0LmRlbGV0ZShwYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICBwYWdlLnNldERlbGVnYXRlKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhZ2UuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCBDaHVuayBmcm9tICcuL2NodW5rJztcclxuaW1wb3J0IHsgRGVsZWdhdG9yQmFzZSB9IGZyb20gJy4uLy4uL3V0aWwvZGVsZWdhdG9yJztcclxuLyoqXHJcbiAqIEEgXCJwYWdlXCIgb2YgR1BVIG1lbW9yeS4gQ29tcHJpc2VzIHZlcnRleCBhbmQgaW5kZXggYnVmZmVycyBvZiBhIGZpeGVkIHNpemUuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNZW1vcnlQYWdlIGV4dGVuZHMgRGVsZWdhdG9yQmFzZSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgcGFnZSB0byBtYW5hZ2UgZ2l2ZW4gdmVydGV4IGFuZCBpbmRleCBidWZmZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB2ZXJ0ZXhCdWZmZXIgVGhlIHZlcnRleCBidWZmZXIgdGhlIHBhZ2Ugd2lsbCBtYW5hZ2UuXHJcbiAgICAgKiBAcGFyYW0gaW5kZXhCdWZmZXIgVGhlIGluZGV4IGJ1ZmZlciB0aGUgcGFnZSB3aWxsIG1hbmFnZXIuXHJcbiAgICAgKiBAcGFyYW0gdmFvIFRoZSBWQU8gb2YgdGhlIHBhZ2UuXHJcbiAgICAgKiBAcGFyYW0gaW5kZXhUeXBlIFR5cGUgb2YgZWxlbWVudHMgb2YgaW5kZXhCdWZmZXIuXHJcbiAgICAgKiBAcGFyYW0gdmVydGV4QWxsb2NhdG9yIEFsbG9jYXRvciBvZiB2ZXJ0ZXggZGF0YSwgbG9naWMgb2YgYWxsb2NhdGlvbiBkaXJlY3RseSBpbXBhY3RzIHRoZSBsaWZlY3ljbGUgb2YgdGhlIHBhZ2UuXHJcbiAgICAgKiBAcGFyYW0gaW5kZXhBbGxvY2F0b3IgQWxsb2NhdG9yIG9mIGluZGV4IGRhdGEsIGxvZ2ljIG9mIGFsbG9jYXRpb24gZGlyZWN0bHkgaW1wYWN0cyB0aGUgbGlmZWN5Y2xlIG9mIHRoZSBwYWdlLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcih2ZXJ0ZXhCdWZmZXIsIGluZGV4QnVmZmVyLCB2YW8sIGluZGV4VHlwZSwgdmVydGV4QWxsb2NhdG9yLCBpbmRleEFsbG9jYXRvcikge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhCdWZmZXIgPSB2ZXJ0ZXhCdWZmZXI7XHJcbiAgICAgICAgdGhpcy5pbmRleEJ1ZmZlciA9IGluZGV4QnVmZmVyO1xyXG4gICAgICAgIHRoaXMudmFvID0gdmFvO1xyXG4gICAgICAgIHRoaXMuaW5kZXhUeXBlID0gaW5kZXhUeXBlO1xyXG4gICAgICAgIHRoaXMuX3ZlcnRleEFsbG9jYXRvciA9IHZlcnRleEFsbG9jYXRvcjtcclxuICAgICAgICB0aGlzLl9pbmRleEFsbG9jYXRvciA9IGluZGV4QWxsb2NhdG9yO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBbGxvY2F0ZXMgYW5kIHdyaXRlcyB2ZXJ0ZXggYW5kIGluZGV4IGRhdGEgdG8gdGhlIHBhZ2UuIE9mZnNldHMgaW5kaWNlc1xyXG4gICAgICogaW4gYW4gaW5kZXggYXJyYXkgdG8gYXBwcm9wcmlhdGVseSB0YWtlIGludG8gYWNjb3VudCBvZmZzZXQgb2YgdGhlIHZlcnRleFxyXG4gICAgICogZGF0YS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmVydGV4Qnl0ZUxlbmd0aCByZXF1aXJlZCBudW1iZXIgb2YgYnl0ZXMgaW4gdmVydGV4IGJ1ZmZlclxyXG4gICAgICogQHBhcmFtIGluZGV4Qnl0ZUxlbmd0aCByZXF1aXJlZCBudW1iZXIgb2YgYnl0ZXMgaW4gaW5kZXggYnVmZmVyXHJcbiAgICAgKiBAcmV0dXJucyBtZW1vcnkgY2h1bmsgYWxsb2NhdGVkIG9yIGBudWxsYCBpZiBhbGxvY2F0aW9uJ3MgZmFpbGVkXHJcbiAgICAgKi9cclxuICAgIGFsbG9jYXRlKHZlcnRleEJ5dGVMZW5ndGgsIGluZGV4Qnl0ZUxlbmd0aCkge1xyXG4gICAgICAgIGlmICh0aGlzLl92ZXJ0ZXhBbGxvY2F0b3IubWF4QWxsb2NhYmxlU2l6ZSA+PSB2ZXJ0ZXhCeXRlTGVuZ3RoICYmXHJcbiAgICAgICAgICAgIHRoaXMuX2luZGV4QWxsb2NhdG9yLm1heEFsbG9jYWJsZVNpemUgPj0gaW5kZXhCeXRlTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2h1bmsodGhpcywge1xyXG4gICAgICAgICAgICAgICAgdmVydGV4Qnl0ZU9mZnNldDogdGhpcy5fdmVydGV4QWxsb2NhdG9yLmFsbG9jYXRlKHZlcnRleEJ5dGVMZW5ndGgpLFxyXG4gICAgICAgICAgICAgICAgdmVydGV4Qnl0ZUxlbmd0aDogdmVydGV4Qnl0ZUxlbmd0aCxcclxuICAgICAgICAgICAgICAgIGluZGV4Qnl0ZU9mZnNldDogdGhpcy5faW5kZXhBbGxvY2F0b3IuYWxsb2NhdGUoaW5kZXhCeXRlTGVuZ3RoKSxcclxuICAgICAgICAgICAgICAgIGluZGV4Qnl0ZUxlbmd0aDogaW5kZXhCeXRlTGVuZ3RoXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGcmVlcyBhIHByZXZpb3VzbHkgYWxsb2NhdGVkIG1lbW9yeSBjaHVuay5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY2h1bmsgVGhlIGNodW5rIHRvIGJlIGZyZWVkLlxyXG4gICAgICovXHJcbiAgICBmcmVlKGNodW5rKSB7XHJcbiAgICAgICAgdGhpcy5fdmVydGV4QWxsb2NhdG9yLmRlYWxsb2NhdGUoY2h1bmsudmVydGV4Qnl0ZU9mZnNldCk7XHJcbiAgICAgICAgdGhpcy5faW5kZXhBbGxvY2F0b3IuZGVhbGxvY2F0ZShjaHVuay5pbmRleEJ5dGVPZmZzZXQpO1xyXG4gICAgICAgIGlmICh0aGlzLmlzRW1wdHkoKSAmJiB0aGlzLl9kZWxlZ2F0ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9kZWxlZ2F0ZS5vblBhZ2VFbXB0eSh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBwYWdlIGRvZXMgbm90IGNvbnRhaW4gYW55IHByZXZpb3VzbHkgYWxsb2NhdGVkIGRhdGFcclxuICAgICAqIGFuZCBgZmFsc2VgIG90aGVyd2lzZS5cclxuICAgICAqL1xyXG4gICAgaXNFbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdmVydGV4QWxsb2NhdG9yLmlzRW1wdHkgJiYgdGhpcy5faW5kZXhBbGxvY2F0b3IuaXNFbXB0eTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGVzdHJveXMgdGhlIHBhZ2UgYW5kIGFsbCBpdHMgcmVzb3VyY2VzLlxyXG4gICAgICovXHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMudmVydGV4QnVmZmVyLmRlc3Ryb3koKTtcclxuICAgICAgICB0aGlzLmluZGV4QnVmZmVyLmRlc3Ryb3koKTtcclxuICAgICAgICB0aGlzLnZhby5kZXN0cm95KCk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IFJlZkNvdW50ZWQgZnJvbSAnLi4vLi4vdXRpbC9yZWZfY291bnRlZCc7XHJcbi8qKiBIYW5kbGVyIHRvIGEgYWxsb2NhdGVkIG1lbW9yeSBjaHVuay4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWVtb3J5Q2h1bmsgZXh0ZW5kcyBSZWZDb3VudGVkIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBoYW5kbGVyIHRvIGEgbWVtb3J5IGNodW5rIHdpdGggZ2l2ZW4gb2Zmc2V0cyBhbGxvY2F0ZWQgaW5cclxuICAgICAqIGEgZ2l2ZW4gbWVtb3J5IHBhZ2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBhZ2UgVGhlIHBhZ2UgdGhlIGNodW5rIHdhcyBhbGxvY2F0ZWQgaW4uXHJcbiAgICAgKiBAcGFyYW0gdmVydGV4T2Zmc2V0IFRoZSBvZmZzZXQgb2YgY2h1bmsncyB2ZXJ0ZXggZGF0YS5cclxuICAgICAqIEBwYXJhbSBpbmRleE9mZnNldCBUaGUgb2Zmc2V0IG9mIGNodW5rJ3MgaW5kZXggZGF0YS5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocGFnZSwgbG9jYXRpb24pIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMucGFnZSA9IHBhZ2U7XHJcbiAgICAgICAgdGhpcy5fbG9jYXRpb24gPSBsb2NhdGlvbjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBvZmZzZXQgb2YgdmVydGV4IGRhdGEgb2YgdGhlIGNodW5rIGluIGJ5dGVzLlxyXG4gICAgICovXHJcbiAgICBnZXQgdmVydGV4Qnl0ZU9mZnNldCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYXRpb24udmVydGV4Qnl0ZU9mZnNldDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBvZmZzZXQgb2YgaW5kZXggZGF0YSBvZiB0aGUgY2h1bmsgaW4gYnl0ZXMuXHJcbiAgICAgKi9cclxuICAgIGdldCBpbmRleEJ5dGVPZmZzZXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2F0aW9uLmluZGV4Qnl0ZU9mZnNldDtcclxuICAgIH1cclxuICAgIF9kZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMucGFnZS5mcmVlKHRoaXMpO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCAqIGFzIHZlY3RvcjIgZnJvbSAnLi4vbWF0aC92ZWN0b3IyJztcclxuaW1wb3J0IFJlbmRlclN0YXRlIGZyb20gJy4vc3RhdGUnO1xyXG5pbXBvcnQgZnhhYUZyYWdtZW50U2hhZGVyIGZyb20gJy4vc2hhZGVycy9meGFhLmZyYWcnO1xyXG5pbXBvcnQgZnhhYVZlcnRleFNoYWRlciBmcm9tICcuL3NoYWRlcnMvcXVhZC52ZXJ0JztcclxuaW1wb3J0IGdldERwciBmcm9tICcuLi91dGlsL2hkJztcclxuaW1wb3J0IHsgR2xSZW5kZXJlciB9IGZyb20gJy4vZ2xfcmVuZGVyZXInO1xyXG5pbXBvcnQgTGlzdFJlbmRlclVuaXQgZnJvbSAnLi9saXN0X3JlbmRlcl91bml0JztcclxuaW1wb3J0IHsgQkxFTkRfT1ZFUl9SRU5ERVJfU1RBVEUgfSBmcm9tICcuL3N0YXRlJztcclxuY29uc3QgU1RBVEUgPSBuZXcgUmVuZGVyU3RhdGUoQkxFTkRfT1ZFUl9SRU5ERVJfU1RBVEUpO1xyXG4vKipcclxuICogUmVuZGVyZXIgb2YgRlhBQSBwb3N0cHJvY2Vzc2luZyBwYXNzLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRnhhYVJlbmRlclVuaXQgZXh0ZW5kcyBHbFJlbmRlcmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIHJlbmRlckxvb3ApIHtcclxuICAgICAgICBzdXBlcihjb250ZXh0LCBTVEFURSwgY29udGV4dC5jcmVhdGVQcm9ncmFtKGZ4YWFWZXJ0ZXhTaGFkZXIsIGZ4YWFGcmFnbWVudFNoYWRlciwge1xyXG4gICAgICAgICAgICBhdHRyaWJNYXA6IHtcclxuICAgICAgICAgICAgICAgIHZlcnRleFBvc2l0aW9uOiAwIC8qIFBPU0lUSU9OICovXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyZXJzID0gbmV3IExpc3RSZW5kZXJVbml0KCk7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyTG9vcCA9IHJlbmRlckxvb3A7XHJcbiAgICAgICAgdGhpcy5vblVwZGF0ZSA9IHRoaXMuX3JlbmRlcmVycy5vblVwZGF0ZTtcclxuICAgICAgICB0aGlzLl9waXhlbFNpemUgPSB2ZWN0b3IyLmNyZWF0ZSgwLCAwKTtcclxuICAgIH1cclxuICAgIGFkZFJlbmRlclVuaXQodW5pdCkge1xyXG4gICAgICAgIHRoaXMuX3JlbmRlcmVycy5hZGRSZW5kZXJVbml0KHVuaXQpO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlUmVuZGVyVW5pdCh1bml0KSB7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyZXJzLnJlbW92ZVJlbmRlclVuaXQodW5pdCk7XHJcbiAgICB9XHJcbiAgICByZW5kZXIodGFyZ2V0LCAuLi5hcmdzKSB7XHJcbiAgICAgICAgLy8gc2tpcCBhbnRpYWxpYXNpbmcgaWYgdGhlc2UgaXMgYWN0aW9uIGluIHRoZSBzY2VuZVxyXG4gICAgICAgIGlmICh0aGlzLl9yZW5kZXJMb29wLmlzQWN0aXZlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVycy5yZW5kZXIodGFyZ2V0LCAuLi5hcmdzKTtcclxuICAgICAgICAgICAgLy8gc2NoZWR1bGUgYXQgbGVhc3Qgb25lIG1vcmUgcmVuZGVyaW5nIHRvIG5vdCBsZWF2ZSBzdGF0aWMgKHN0b3BwZWQpIHNjZW5lIGluIG5vbi1hbnRpYWxpYXNlZCBzdGF0ZVxyXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJMb29wLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5faW50ZXJtZWRpYXRlUmVuZGVyZUJ1ZmZlcikge1xyXG4gICAgICAgICAgICB0aGlzLl9pbml0SW50ZXJtZWRpYXRlUmVuZGVyVGFyZ2V0cyh0YXJnZXQuZ2V0V2lkdGgoKSwgdGFyZ2V0LmdldEhlaWdodCgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5faW50ZXJtZWRpYXRlUmVuZGVyZUJ1ZmZlci5nZXRXaWR0aCgpICE9PSB0YXJnZXQuZ2V0V2lkdGgoKSB8fFxyXG4gICAgICAgICAgICB0aGlzLl9pbnRlcm1lZGlhdGVSZW5kZXJlQnVmZmVyLmdldEhlaWdodCgpICE9PSB0YXJnZXQuZ2V0SGVpZ2h0KCkpIHtcclxuICAgICAgICAgICAgdGhpcy5fZGVzdHJveUludGVybmFsUmVuZGVyVGFyZ2V0cygpO1xyXG4gICAgICAgICAgICB0aGlzLl9pbml0SW50ZXJtZWRpYXRlUmVuZGVyVGFyZ2V0cyh0YXJnZXQuZ2V0V2lkdGgoKSwgdGFyZ2V0LmdldEhlaWdodCgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kUmVuZGVyVGFyZ2V0KHRoaXMuX2ludGVybWVkaWF0ZVJlbmRlcmVCdWZmZXIpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuY2xlYXJDdXJyZW50VGFyZ2V0KDE3NjY0IC8qIEFMTCAqLyk7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyZXJzLnJlbmRlcih0aGlzLl9pbnRlcm1lZGlhdGVSZW5kZXJlQnVmZmVyLCAuLi5hcmdzKTtcclxuICAgICAgICAvLyBkbyBub3QgcnVuIGFudGlhbGlhc2luZyBvbiBlbXB0eSB0aGlzLl9pbnRlcm1lZGlhdGVSZW5kZXJlQnVmZmVyXHJcbiAgICAgICAgaWYgKCF0aGlzLl9pbnRlcm1lZGlhdGVSZW5kZXJlQnVmZmVyLmlzQ2xlYXIpIHtcclxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlRnJhbWVVbmlmb3JtU3RhdGUodGFyZ2V0KTtcclxuICAgICAgICAgICAgc3VwZXIucmVuZGVyKHRhcmdldCwgLi4uYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICBpZiAodGhpcy5faW50ZXJtZWRpYXRlUmVuZGVyZUJ1ZmZlcikge1xyXG4gICAgICAgICAgICB0aGlzLl9kZXN0cm95SW50ZXJuYWxSZW5kZXJUYXJnZXRzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3JlbmRlcigpIHtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRRdWFkVmFvKCk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5kcmF3UXVhZCgpO1xyXG4gICAgfVxyXG4gICAgX3ByZXBhcmVQcm9ncmFtKHByb2dyYW0sIC4uLmFyZ3MpIHtcclxuICAgICAgICBzdXBlci5fcHJlcGFyZVByb2dyYW0ocHJvZ3JhbSwgLi4uYXJncyk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kVGV4dHVyZVVuaXQoMCk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kVGV4dHVyZSh0aGlzLl9pbnRlcm1lZGlhdGVDb2xvckJ1ZmZlcik7XHJcbiAgICAgICAgcHJvZ3JhbS5zZXRJbnRTY2FsYXJVbmlmb3JtKCd0ZXh0dXJlJywgMCk7XHJcbiAgICAgICAgcHJvZ3JhbS5zZXRWZWN0b3IyVW5pZm9ybSgncGl4ZWxTaXplJywgdGhpcy5fcGl4ZWxTaXplKTtcclxuICAgICAgICBwcm9ncmFtLnNldFNjYWxhclVuaWZvcm0oJ2RwcicsIGdldERwcigpKTtcclxuICAgIH1cclxuICAgIF91cGRhdGVGcmFtZVVuaWZvcm1TdGF0ZSh0YXJnZXQpIHtcclxuICAgICAgICB0aGlzLl9waXhlbFNpemUueCA9IDEgLyB0YXJnZXQuZ2V0V2lkdGgoKTtcclxuICAgICAgICB0aGlzLl9waXhlbFNpemUueSA9IDEgLyB0YXJnZXQuZ2V0SGVpZ2h0KCk7XHJcbiAgICB9XHJcbiAgICBfaW5pdEludGVybWVkaWF0ZVJlbmRlclRhcmdldHMod2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLl9jb250ZXh0O1xyXG4gICAgICAgIGNvbnN0IGludGVybWVkaWF0ZUNvbG9yQnVmZmVyID0gdGhpcy5faW50ZXJtZWRpYXRlQ29sb3JCdWZmZXIgPVxyXG4gICAgICAgICAgICBjb250ZXh0LmNyZWF0ZUVtcHR5MkRUZXh0dXJlKHdpZHRoLCBoZWlnaHQsIDY0MDggLyogUkdCQSAqLywgNTEyMSAvKiBVTlNJR05FRF9CWVRFICovKTtcclxuICAgICAgICBjb25zdCBpbnRlcm1lZGlhdGVEZXB0aFN0ZW5jaWxCdWZmZXIgPSB0aGlzLl9pbnRlcm1lZGlhdGVEZXB0aFN0ZW5jaWxCdWZmZXIgPVxyXG4gICAgICAgICAgICBjb250ZXh0LmNyZWF0ZVJlbmRlcmJ1ZmZlcih3aWR0aCwgaGVpZ2h0LCAzNDA0MSAvKiBERVBUSF9TVEVOQ0lMICovKTtcclxuICAgICAgICB0aGlzLl9pbnRlcm1lZGlhdGVSZW5kZXJlQnVmZmVyID0gY29udGV4dC5jcmVhdGVGcmFtZWJ1ZmZlcih7XHJcbiAgICAgICAgICAgIGNvbG9yOiBpbnRlcm1lZGlhdGVDb2xvckJ1ZmZlcixcclxuICAgICAgICAgICAgZGVwdGhTdGVuY2lsOiBpbnRlcm1lZGlhdGVEZXB0aFN0ZW5jaWxCdWZmZXJcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIF9kZXN0cm95SW50ZXJuYWxSZW5kZXJUYXJnZXRzKCkge1xyXG4gICAgICAgIHRoaXMuX2ludGVybWVkaWF0ZVJlbmRlcmVCdWZmZXIuZGVzdHJveSgpO1xyXG4gICAgICAgIHRoaXMuX2ludGVybWVkaWF0ZUNvbG9yQnVmZmVyLmRlc3Ryb3koKTtcclxuICAgICAgICB0aGlzLl9pbnRlcm1lZGlhdGVEZXB0aFN0ZW5jaWxCdWZmZXIuZGVzdHJveSgpO1xyXG4gICAgfVxyXG59XHJcbiIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG5cXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbnVuaWZvcm0gdmVjMiBwaXhlbFNpemU7XFxudW5pZm9ybSBzYW1wbGVyMkQgdGV4dHVyZTtcXG51bmlmb3JtIGZsb2F0IGRwcjtcXG5cXG5jb25zdCBmbG9hdCBGWEFBX1FVQUxJVFlfU1VCUElYID0gMC43NTtcXG5jb25zdCBmbG9hdCBGWEFBX1FVQUxJVFlfRURHRV9USFJFU0hPTEQgPSAwLjA2MztcXG5jb25zdCBmbG9hdCBGWEFBX1FVQUxJVFlfRURHRV9USFJFU0hPTERfTUlOID0gMC4wNjI1O1xcbmNvbnN0IGZsb2F0IEVQU0lMT04gPSAwLjAwMDE7XFxuXFxuZmxvYXQgbHVtYSh2ZWM0IHJnYmEpIHtcXG4gICAgcmV0dXJuIGRvdChyZ2JhLnh5eiwgdmVjMygwLjI5OSwgMC41ODcsIDAuMTE0KSk7XFxufVxcblxcbnZlYzQgZnhhYShcXG4gICAgdmVjMiBwb3MsXFxuICAgIHNhbXBsZXIyRCB0ZXgsXFxuICAgIHZlYzIgZnhhYVF1YWxpdHlSY3BGcmFtZSxcXG4gICAgLy8gVGhpcyB1c2VkIHRvIGJlIHRoZSBGWEFBX1FVQUxJVFlfU1VCUElYIGRlZmluZS5cXG4gICAgLy8gQ2hvb3NlIHRoZSBhbW91bnQgb2Ygc3ViLXBpeGVsIGFsaWFzaW5nIHJlbW92YWwuXFxuICAgIC8vIFRoaXMgY2FuIGVmZmVjdCBzaGFycG5lc3MuXFxuICAgIC8vICAgMS4wMCAtIHVwcGVyIGxpbWl0IChzb2Z0ZXIpXFxuICAgIC8vICAgMC43NSAtIGRlZmF1bHQgYW1vdW50IG9mIGZpbHRlcmluZ1xcbiAgICAvLyAgIDAuNTAgLSBsb3dlciBsaW1pdCAoc2hhcnBlciwgbGVzcyBzdWItcGl4ZWwgYWxpYXNpbmcgcmVtb3ZhbClcXG4gICAgLy8gICAwLjI1IC0gYWxtb3N0IG9mZlxcbiAgICAvLyAgIDAuMDAgLSBjb21wbGV0ZWx5IG9mZlxcbiAgICBmbG9hdCBmeGFhUXVhbGl0eVN1YnBpeCxcXG4gICAgLy8gVGhpcyB1c2VkIHRvIGJlIHRoZSBGWEFBX1FVQUxJVFlfRURHRV9USFJFU0hPTEQgZGVmaW5lLlxcbiAgICAvLyBUaGUgbWluaW11bSBhbW91bnQgb2YgbG9jYWwgY29udHJhc3QgcmVxdWlyZWQgdG8gYXBwbHkgYWxnb3JpdGhtLlxcbiAgICAvLyAgIDAuMzMzIC0gdG9vIGxpdHRsZSAoZmFzdGVyKVxcbiAgICAvLyAgIDAuMjUwIC0gbG93IHF1YWxpdHlcXG4gICAgLy8gICAwLjE2NiAtIGRlZmF1bHRcXG4gICAgLy8gICAwLjEyNSAtIGhpZ2ggcXVhbGl0eVxcbiAgICAvLyAgIDAuMDYzIC0gb3ZlcmtpbGwgKHNsb3dlcilcXG4gICAgZmxvYXQgZnhhYVF1YWxpdHlFZGdlVGhyZXNob2xkLFxcbiAgICAvLyBUaGlzIHVzZWQgdG8gYmUgdGhlIEZYQUFfUVVBTElUWV9FREdFX1RIUkVTSE9MRF9NSU4gZGVmaW5lLlxcbiAgICAvLyBUcmltcyB0aGUgYWxnb3JpdGhtIGZyb20gcHJvY2Vzc2luZyBkYXJrcy5cXG4gICAgLy8gICAwLjA4MzMgLSB1cHBlciBsaW1pdCAoZGVmYXVsdCwgdGhlIHN0YXJ0IG9mIHZpc2libGUgdW5maWx0ZXJlZCBlZGdlcylcXG4gICAgLy8gICAwLjA2MjUgLSBoaWdoIHF1YWxpdHkgKGZhc3RlcilcXG4gICAgLy8gICAwLjAzMTIgLSB2aXNpYmxlIGxpbWl0IChzbG93ZXIpXFxuICAgIGZsb2F0IGZ4YWFRdWFsaXR5RWRnZVRocmVzaG9sZE1pblxcbikge1xcbiAgICB2ZWMyIHBvc007XFxuICAgIHBvc00ueCA9IHBvcy54O1xcbiAgICBwb3NNLnkgPSBwb3MueTtcXG4gICAgdmVjNCByZ2J5TSA9IHRleHR1cmUyRCh0ZXgsIHBvc00pO1xcbiAgICBmbG9hdCBsdW1hTSA9IGx1bWEocmdieU0pO1xcblxcbiAgICBmbG9hdCBsdW1hUyA9IGx1bWEodGV4dHVyZTJEKHRleCwgcG9zTSArIHZlYzIoIDAsIDEpICogZnhhYVF1YWxpdHlSY3BGcmFtZS54eSkpO1xcbiAgICBmbG9hdCBsdW1hRSA9IGx1bWEodGV4dHVyZTJEKHRleCwgcG9zTSArIHZlYzIoIDEsIDApICogZnhhYVF1YWxpdHlSY3BGcmFtZS54eSkpO1xcbiAgICBmbG9hdCBsdW1hTiA9IGx1bWEodGV4dHVyZTJEKHRleCwgcG9zTSArIHZlYzIoIDAsLTEpICogZnhhYVF1YWxpdHlSY3BGcmFtZS54eSkpO1xcbiAgICBmbG9hdCBsdW1hVyA9IGx1bWEodGV4dHVyZTJEKHRleCwgcG9zTSArIHZlYzIoLTEsIDApICogZnhhYVF1YWxpdHlSY3BGcmFtZS54eSkpO1xcblxcbiAgICBmbG9hdCBtYXhTTSA9IG1heChsdW1hUywgbHVtYU0pO1xcbiAgICBmbG9hdCBtaW5TTSA9IG1pbihsdW1hUywgbHVtYU0pO1xcbiAgICBmbG9hdCBtYXhFU00gPSBtYXgobHVtYUUsIG1heFNNKTtcXG4gICAgZmxvYXQgbWluRVNNID0gbWluKGx1bWFFLCBtaW5TTSk7XFxuICAgIGZsb2F0IG1heFdOID0gbWF4KGx1bWFOLCBsdW1hVyk7XFxuICAgIGZsb2F0IG1pbldOID0gbWluKGx1bWFOLCBsdW1hVyk7XFxuICAgIGZsb2F0IHJhbmdlTWF4ID0gbWF4KG1heFdOLCBtYXhFU00pO1xcbiAgICBmbG9hdCByYW5nZU1pbiA9IG1pbihtaW5XTiwgbWluRVNNKTtcXG4gICAgZmxvYXQgcmFuZ2VNYXhTY2FsZWQgPSByYW5nZU1heCAqIGZ4YWFRdWFsaXR5RWRnZVRocmVzaG9sZDtcXG4gICAgZmxvYXQgcmFuZ2UgPSByYW5nZU1heCAtIHJhbmdlTWluO1xcbiAgICBmbG9hdCByYW5nZU1heENsYW1wZWQgPSBtYXgoZnhhYVF1YWxpdHlFZGdlVGhyZXNob2xkTWluLCByYW5nZU1heFNjYWxlZCk7XFxuICAgIGJvb2wgZWFybHlFeGl0ID0gcmFuZ2UgPCByYW5nZU1heENsYW1wZWQ7XFxuXFxuICAgIGlmIChlYXJseUV4aXQpXFxuICAgICAgICByZXR1cm4gcmdieU07XFxuXFxuICAgIGZsb2F0IGx1bWFOVyA9IGx1bWEodGV4dHVyZTJEKHRleCwgcG9zTSArIHZlYzIoLTEsLTEpICogZnhhYVF1YWxpdHlSY3BGcmFtZS54eSkpO1xcbiAgICBmbG9hdCBsdW1hU0UgPSBsdW1hKHRleHR1cmUyRCh0ZXgsIHBvc00gKyB2ZWMyKCAxLCAxKSAqIGZ4YWFRdWFsaXR5UmNwRnJhbWUueHkpKTtcXG4gICAgZmxvYXQgbHVtYU5FID0gbHVtYSh0ZXh0dXJlMkQodGV4LCBwb3NNICsgdmVjMiggMSwtMSkgKiBmeGFhUXVhbGl0eVJjcEZyYW1lLnh5KSk7XFxuICAgIGZsb2F0IGx1bWFTVyA9IGx1bWEodGV4dHVyZTJEKHRleCwgcG9zTSArIHZlYzIoLTEsIDEpICogZnhhYVF1YWxpdHlSY3BGcmFtZS54eSkpO1xcblxcbiAgICBmbG9hdCBsdW1hTlMgPSBsdW1hTiArIGx1bWFTO1xcbiAgICBmbG9hdCBsdW1hV0UgPSBsdW1hVyArIGx1bWFFO1xcbiAgICBmbG9hdCBzdWJwaXhSY3BSYW5nZSA9IDEuMC9yYW5nZTtcXG4gICAgZmxvYXQgc3VicGl4TlNXRSA9IGx1bWFOUyArIGx1bWFXRTtcXG4gICAgZmxvYXQgZWRnZUhvcnoxID0gKC0yLjAgKiBsdW1hTSkgKyBsdW1hTlM7XFxuICAgIGZsb2F0IGVkZ2VWZXJ0MSA9ICgtMi4wICogbHVtYU0pICsgbHVtYVdFO1xcblxcbiAgICBmbG9hdCBsdW1hTkVTRSA9IGx1bWFORSArIGx1bWFTRTtcXG4gICAgZmxvYXQgbHVtYU5XTkUgPSBsdW1hTlcgKyBsdW1hTkU7XFxuICAgIGZsb2F0IGVkZ2VIb3J6MiA9ICgtMi4wICogbHVtYUUpICsgbHVtYU5FU0U7XFxuICAgIGZsb2F0IGVkZ2VWZXJ0MiA9ICgtMi4wICogbHVtYU4pICsgbHVtYU5XTkU7XFxuXFxuICAgIGZsb2F0IGx1bWFOV1NXID0gbHVtYU5XICsgbHVtYVNXO1xcbiAgICBmbG9hdCBsdW1hU1dTRSA9IGx1bWFTVyArIGx1bWFTRTtcXG4gICAgZmxvYXQgZWRnZUhvcno0ID0gKGFicyhlZGdlSG9yejEpICogMi4wKSArIGFicyhlZGdlSG9yejIpO1xcbiAgICBmbG9hdCBlZGdlVmVydDQgPSAoYWJzKGVkZ2VWZXJ0MSkgKiAyLjApICsgYWJzKGVkZ2VWZXJ0Mik7XFxuICAgIGZsb2F0IGVkZ2VIb3J6MyA9ICgtMi4wICogbHVtYVcpICsgbHVtYU5XU1c7XFxuICAgIGZsb2F0IGVkZ2VWZXJ0MyA9ICgtMi4wICogbHVtYVMpICsgbHVtYVNXU0U7XFxuICAgIGZsb2F0IGVkZ2VIb3J6ID0gYWJzKGVkZ2VIb3J6MykgKyBlZGdlSG9yejQ7XFxuICAgIGZsb2F0IGVkZ2VWZXJ0ID0gYWJzKGVkZ2VWZXJ0MykgKyBlZGdlVmVydDQ7XFxuXFxuICAgIGZsb2F0IHN1YnBpeE5XU1dORVNFID0gbHVtYU5XU1cgKyBsdW1hTkVTRTtcXG4gICAgZmxvYXQgbGVuZ3RoU2lnbiA9IGZ4YWFRdWFsaXR5UmNwRnJhbWUueDtcXG4gICAgYm9vbCBob3J6U3BhbiA9IGVkZ2VIb3J6ID49IGVkZ2VWZXJ0O1xcbiAgICBmbG9hdCBzdWJwaXhBID0gc3VicGl4TlNXRSAqIDIuMCArIHN1YnBpeE5XU1dORVNFO1xcblxcbiAgICBpZiAoaG9yelNwYW4pIHtcXG4gICAgICAgIGxlbmd0aFNpZ24gPSBmeGFhUXVhbGl0eVJjcEZyYW1lLnk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICBsdW1hTiA9IGx1bWFXO1xcbiAgICAgICAgbHVtYVMgPSBsdW1hRTtcXG4gICAgfVxcbiAgICBmbG9hdCBzdWJwaXhCID0gKHN1YnBpeEEgKiAoMS4wLzEyLjApKSAtIGx1bWFNO1xcblxcbiAgICBmbG9hdCBncmFkaWVudE4gPSBsdW1hTiAtIGx1bWFNO1xcbiAgICBmbG9hdCBncmFkaWVudFMgPSBsdW1hUyAtIGx1bWFNO1xcbiAgICBmbG9hdCBsdW1hTk4gPSBsdW1hTiArIGx1bWFNO1xcbiAgICBmbG9hdCBsdW1hU1MgPSBsdW1hUyArIGx1bWFNO1xcbiAgICBib29sIHBhaXJOID0gYWJzKGdyYWRpZW50TikgPj0gYWJzKGdyYWRpZW50Uyk7XFxuICAgIGZsb2F0IGdyYWRpZW50ID0gbWF4KGFicyhncmFkaWVudE4pLCBhYnMoZ3JhZGllbnRTKSk7XFxuICAgIGlmIChwYWlyTikge1xcbiAgICAgICAgbGVuZ3RoU2lnbiA9IC1sZW5ndGhTaWduO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgbHVtYU5OID0gbHVtYVNTO1xcbiAgICB9XFxuICAgIGZsb2F0IHN1YnBpeEMgPSBjbGFtcChhYnMoc3VicGl4QikgKiBzdWJwaXhSY3BSYW5nZSwgMC4wLCAxLjApO1xcblxcbiAgICB2ZWMyIHBvc0IgPSBwb3NNO1xcbiAgICB2ZWMyIG9mZk5QO1xcblxcbiAgICB2ZWMyIG9mZkhNO1xcbiAgICBpZiAoaG9yelNwYW4pIHtcXG4gICAgICAgIG9mZk5QID0gdmVjMihmeGFhUXVhbGl0eVJjcEZyYW1lLngsIDAuMCk7XFxuICAgICAgICBvZmZITSA9IHZlYzIoMC4wLCBsZW5ndGhTaWduKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIG9mZk5QID0gdmVjMigwLjAsIGZ4YWFRdWFsaXR5UmNwRnJhbWUueSk7XFxuICAgICAgICBvZmZITSA9IHZlYzIobGVuZ3RoU2lnbiwgMC4wKTtcXG4gICAgfVxcblxcbiAgICB2ZWMyIHBvc04gPSBwb3NCIC0gb2ZmTlAgKiAyLjtcXG4gICAgdmVjMiBwb3NQID0gcG9zQiArIG9mZk5QICogMi47XFxuXFxuICAgIGZsb2F0IHN1YnBpeEQgPSAoKC0yLjApKnN1YnBpeEMpICsgMy4wO1xcbiAgICBmbG9hdCBsdW1hRW5kTiA9IGx1bWEoXFxuICAgICAgICBtaXgoXFxuICAgICAgICAgICAgdGV4dHVyZTJEKHRleCwgcG9zTiksXFxuICAgICAgICAgICAgdGV4dHVyZTJEKHRleCwgcG9zTiArIG9mZkhNKSxcXG4gICAgICAgICAgICAwLjVcXG4gICAgICAgIClcXG4gICAgKTtcXG4gICAgZmxvYXQgc3VicGl4RSA9IHN1YnBpeEMgKiBzdWJwaXhDO1xcbiAgICBmbG9hdCBsdW1hRW5kUCA9IGx1bWEoXFxuICAgICAgICBtaXgoXFxuICAgICAgICAgICAgdGV4dHVyZTJEKHRleCwgcG9zUCksXFxuICAgICAgICAgICAgdGV4dHVyZTJEKHRleCwgcG9zUCArIG9mZkhNKSxcXG4gICAgICAgICAgICAwLjVcXG4gICAgICAgIClcXG4gICAgKTtcXG5cXG4gICAgZmxvYXQgZ3JhZGllbnRTY2FsZWQgPSBncmFkaWVudCAqIDAuMjU7XFxuICAgIGZsb2F0IGx1bWFNTSA9IGx1bWFNIC0gbHVtYU5OICogMC41O1xcbiAgICBmbG9hdCBzdWJwaXhGID0gc3VicGl4RCAqIHN1YnBpeEU7XFxuICAgIGJvb2wgbHVtYU1MVFplcm8gPSBsdW1hTU0gPCAwLjA7XFxuXFxuICAgIGx1bWFFbmROIC09IGx1bWFOTiAqIDAuNTtcXG4gICAgbHVtYUVuZFAgLT0gbHVtYU5OICogMC41O1xcbiAgICBib29sIGRvbmVOID0gYWJzKGx1bWFFbmROKSA+PSBncmFkaWVudFNjYWxlZDtcXG4gICAgYm9vbCBkb25lUCA9IGFicyhsdW1hRW5kUCkgPj0gZ3JhZGllbnRTY2FsZWQ7XFxuICAgIGlmICghZG9uZU4pIHtcXG4gICAgICAgIHBvc04gLT0gb2ZmTlAgKiAzLjA7XFxuICAgIH1cXG4gICAgYm9vbCBkb25lTlAgPSAoIWRvbmVOKSB8fCAoIWRvbmVQKTtcXG4gICAgaWYgKCFkb25lUCkge1xcbiAgICAgICAgcG9zUCArPSBvZmZOUCAqIDMuMDtcXG4gICAgfVxcblxcbiAgICBpZiAoZG9uZU5QKSB7XFxuICAgICAgICBpZiAoIWRvbmVOKSB7XFxuICAgICAgICAgICAgbHVtYUVuZE4gPSBsdW1hKFxcbiAgICAgICAgICAgICAgICBtaXgoXFxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlMkQodGV4LCBwb3NOKSxcXG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmUyRCh0ZXgsIHBvc04gKyBvZmZITSksXFxuICAgICAgICAgICAgICAgICAgICAwLjVcXG4gICAgICAgICAgICAgICAgKVxcbiAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgbHVtYUVuZE4gPSBsdW1hRW5kTiAtIGx1bWFOTiAqIDAuNTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICghZG9uZVApIHtcXG4gICAgICAgICAgICBsdW1hRW5kUCA9IGx1bWEoXFxuICAgICAgICAgICAgICAgIG1peChcXG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmUyRCh0ZXgsIHBvc1AueHkpLFxcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZTJEKHRleCwgcG9zUC54eSArIG9mZkhNKSxcXG4gICAgICAgICAgICAgICAgICAgIDAuNVxcbiAgICAgICAgICAgICAgICApXFxuICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICBsdW1hRW5kUCA9IGx1bWFFbmRQIC0gbHVtYU5OICogMC41O1xcbiAgICAgICAgfVxcbiAgICAgICAgZG9uZU4gPSBhYnMobHVtYUVuZE4pID49IGdyYWRpZW50U2NhbGVkO1xcbiAgICAgICAgZG9uZVAgPSBhYnMobHVtYUVuZFApID49IGdyYWRpZW50U2NhbGVkO1xcbiAgICAgICAgaWYgKCFkb25lTikge1xcbiAgICAgICAgICAgIHBvc04gLT0gb2ZmTlAgKiAxMi4wO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKCFkb25lUCkge1xcbiAgICAgICAgICAgIHBvc1AgKz0gb2ZmTlAgKiAxMi4wO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIGZsb2F0IGRzdE4gPSBwb3NNLnggLSBwb3NOLng7XFxuICAgIGZsb2F0IGRzdFAgPSBwb3NQLnggLSBwb3NNLng7XFxuICAgIGlmICghaG9yelNwYW4pIHtcXG4gICAgICAgIGRzdE4gPSBwb3NNLnkgLSBwb3NOLnk7XFxuICAgICAgICBkc3RQID0gcG9zUC55IC0gcG9zTS55O1xcbiAgICB9XFxuICAgIGJvb2wgZ29vZFNwYW5OID0gKGx1bWFFbmROIDwgMC4wKSAhPSBsdW1hTUxUWmVybztcXG4gICAgZmxvYXQgc3Bhbkxlbmd0aCA9IChkc3RQICsgZHN0Tik7XFxuICAgIGJvb2wgZ29vZFNwYW5QID0gKGx1bWFFbmRQIDwgMC4wKSAhPSBsdW1hTUxUWmVybztcXG4gICAgZmxvYXQgc3Bhbkxlbmd0aFJjcCA9IDEuMC9zcGFuTGVuZ3RoO1xcbiAgICBib29sIGRpcmVjdGlvbk4gPSBkc3ROIDwgZHN0UDtcXG4gICAgZmxvYXQgZHN0ID0gbWluKGRzdE4sIGRzdFApO1xcbiAgICBib29sIGdvb2RTcGFuID0gZGlyZWN0aW9uTiA/IGdvb2RTcGFuTiA6IGdvb2RTcGFuUDtcXG4gICAgZmxvYXQgc3VicGl4RyA9IHN1YnBpeEYgKiBzdWJwaXhGO1xcbiAgICBmbG9hdCBwaXhlbE9mZnNldCA9IChkc3QgKiAoLXNwYW5MZW5ndGhSY3ApKSArIDAuNTtcXG4gICAgZmxvYXQgc3VicGl4SCA9IHN1YnBpeEcgKiBmeGFhUXVhbGl0eVN1YnBpeDtcXG4gICAgZmxvYXQgcGl4ZWxPZmZzZXRHb29kID0gZ29vZFNwYW4gPyBwaXhlbE9mZnNldCA6IDAuMDtcXG4gICAgZmxvYXQgcGl4ZWxPZmZzZXRTdWJwaXggPSBtYXgocGl4ZWxPZmZzZXRHb29kLCBzdWJwaXhIKTtcXG4gICAgdmVjNCBjb2xvcjtcXG4gICAgZmxvYXQgZmFjdG9yID0gcGl4ZWxPZmZzZXRTdWJwaXg7XFxuICAgIGlmIChob3J6U3Bhbikge1xcbiAgICAgICAgY29sb3IgPSBtaXgoXFxuICAgICAgICAgICAgdGV4dHVyZTJEKHRleCwgcG9zTSksXFxuICAgICAgICAgICAgdGV4dHVyZTJEKHRleCwgcG9zTSArIHZlYzIoMC4wLCBsZW5ndGhTaWduKSksXFxuICAgICAgICAgICAgZmFjdG9yXFxuICAgICAgICApO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgY29sb3IgPSBtaXgoXFxuICAgICAgICAgICAgdGV4dHVyZTJEKHRleCwgcG9zTSksXFxuICAgICAgICAgICAgdGV4dHVyZTJEKHRleCwgcG9zTSArIHZlYzIobGVuZ3RoU2lnbiwgMC4wKSksXFxuICAgICAgICAgICAgZmFjdG9yXFxuICAgICAgICApO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBjb2xvcjtcXG59XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICB2ZWMyIHBvcyA9IGdsX0ZyYWdDb29yZC54eSAqIHBpeGVsU2l6ZTtcXG4gICAgdmVjNCBjb2xvciA9IGZ4YWEoXFxuICAgICAgICBwb3MsXFxuICAgICAgICB0ZXh0dXJlLFxcbiAgICAgICAgcGl4ZWxTaXplLFxcbiAgICAgICAgRlhBQV9RVUFMSVRZX1NVQlBJWCxcXG4gICAgICAgIEZYQUFfUVVBTElUWV9FREdFX1RIUkVTSE9MRCxcXG4gICAgICAgIEZYQUFfUVVBTElUWV9FREdFX1RIUkVTSE9MRF9NSU5cXG4gICAgKTtcXG5cXG4gICAgLy8gSWYgY29sb3IuYSBpcyBsZXNzIHRoYW4gb25lLCB0aGVuIHRoZSBjb2xvciBoYXMgYmVlbiBibGVuZGVkIHdpdGggYSBibGFjayBiYWNrZ3JvdW5kIGJlZm9yZS5cXG4gICAgLy8gQW4gb3JpZ2luYWwgY29sb3Igb2YgdHJhbnNwYXJlbnQgb2JqZWN0cyBpcyB2ZWM0KGNvbG9yLnh5eiAvIGNvbG9yLmEsIGNvbG9yLmEpLlxcbiAgICAvLyBXZSBoYXZlIHRvIGJsZW5kIGFuIG9yaWdpbmFsIGNvbG9yIHdpdGggYmFja2dyb3VuZCBwYXR0ZXJuLlxcbiAgICAvLyBjb2xvci5hIGNhbiBiZSB0b28gY2xvc2UgdG8gemVyby4gQ2hlY2sgaXQuXFxuICAgIGlmIChjb2xvci5hID4gRVBTSUxPTikge1xcbiAgICAgICAgY29sb3IueHl6IC89IGNvbG9yLmE7XFxuICAgIH1cXG4gICAgZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxufVxcblwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIiN2ZXJzaW9uIDEwMFxcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxuYXR0cmlidXRlIHZlYzIgdmVydGV4UG9zaXRpb247XFxuYXR0cmlidXRlIHZlYzIgdmVydGV4VXY7XFxuXFxudW5pZm9ybSBmbG9hdCB6SW5kZXg7XFxuXFxuI2lmbmRlZiBZVl9MRUFTVF8xNmJfUFxcbiMgICBpZmRlZiBHTF9GUkFHTUVOVF9QUkVDSVNJT05fSElHSFxcbiMgICAgICAgZGVmaW5lIFlWX0xFQVNUXzE2Yl9QIGhpZ2hwXFxuIyAgIGVsc2VcXG4jICAgICAgIGRlZmluZSBZVl9MRUFTVF8xNmJfUCBtZWRpdW1wXFxuIyAgIGVuZGlmXFxuI2VuZGlmXFxuXFxudmFyeWluZyBZVl9MRUFTVF8xNmJfUCB2ZWMyIHV2O1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIGdsX1Bvc2l0aW9uID0gdmVjNCh2ZXJ0ZXhQb3NpdGlvbiwgekluZGV4LCAxKTtcXG4gICAgdXYgPSB2ZXJ0ZXhVdjtcXG59XFxuXCIiLCJpbXBvcnQgeyBHbFJlbmRlcmVyIH0gZnJvbSAnLi9nbF9yZW5kZXJlcic7XHJcbmltcG9ydCBSZW5kZXJTdGF0ZSBmcm9tICcuL3N0YXRlJztcclxuaW1wb3J0IHsgVm9pZEV2ZW50RW1pdHRlciB9IGZyb20gJy4vLi4vdXRpbC9ldmVudF9lbWl0dGVyJztcclxuaW1wb3J0IHF1YWRWZXJ0ZXhTaGFkZXIgZnJvbSAnLi9zaGFkZXJzL3F1YWQudmVydCc7XHJcbmltcG9ydCBiYWNrZ3JvdW5kRnJhZ21lbnRTaGFkZXIgZnJvbSAnLi9zaGFkZXJzL2JhY2tncm91bmQuZnJhZyc7XHJcbmltcG9ydCBnZXREcHIgZnJvbSAnLi4vdXRpbC9oZCc7XHJcbmNvbnN0IFNUQVRFID0gbmV3IFJlbmRlclN0YXRlKHtcclxuICAgIGRlcHRoVGVzdDogdHJ1ZSxcclxuICAgIGRlcHRoRnVuYzogNTE4IC8qIEdSRUFURVJfT1JfRVFVQUwgKi9cclxufSk7XHJcbi8qKlxyXG4gKiBGaWxscyBtYXAncyBjYW52YXMgd2l0aCBiYWNrZ3JvdW5kIHBhdHRlcm4gb24gcmVnaW9ucyB0aGF0IGhhdmUgbm8gZGF0YSB5ZXQuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYWNrZ3JvdW5kUmVuZGVyVW5pdCBleHRlbmRzIEdsUmVuZGVyZXIge1xyXG4gICAgY29uc3RydWN0b3IoY29udGV4dCkge1xyXG4gICAgICAgIGNvbnN0IHByb2dyYW0gPSBjb250ZXh0LmNyZWF0ZVByb2dyYW0ocXVhZFZlcnRleFNoYWRlciwgYmFja2dyb3VuZEZyYWdtZW50U2hhZGVyLCB7XHJcbiAgICAgICAgICAgIGF0dHJpYk1hcDoge1xyXG4gICAgICAgICAgICAgICAgdmVydGV4UG9zaXRpb246IDAgLyogUE9TSVRJT04gKi8sXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhVdjogNCAvKiBVViAqL1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc3VwZXIoY29udGV4dCwgU1RBVEUsIHByb2dyYW0pO1xyXG4gICAgICAgIGNvbnRleHQuYmluZFByb2dyYW0ocHJvZ3JhbSk7XHJcbiAgICAgICAgcHJvZ3JhbS5zZXRTY2FsYXJVbmlmb3JtKCd6SW5kZXgnLCAtMSk7XHJcbiAgICAgICAgdGhpcy5vblVwZGF0ZSA9IG5ldyBWb2lkRXZlbnRFbWl0dGVyKCk7XHJcbiAgICB9XHJcbiAgICBfcmVuZGVyKCkge1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFF1YWRWYW8oKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmRyYXdRdWFkKCk7XHJcbiAgICB9XHJcbiAgICBfcHJlcGFyZVByb2dyYW0ocHJvZ3JhbSkge1xyXG4gICAgICAgIHN1cGVyLl9wcmVwYXJlUHJvZ3JhbShwcm9ncmFtKTtcclxuICAgICAgICBwcm9ncmFtLnNldFNjYWxhclVuaWZvcm0oJ2RwcicsIGdldERwcigpKTtcclxuICAgIH1cclxufVxyXG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiI3ZlcnNpb24gMTAwXFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIC8vIEJhY2tncm91bmQgY29sb3Igc2hvdWxkIG1hdGNoIG1haW4gbWFwIGxheWVyIGNvbG9yLlxcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuOTgsIDAuOTcsIDAuOTQsIDEpO1xcbn1cXG5cIiIsImltcG9ydCBMaXN0UmVuZGVyVW5pdCBmcm9tICcuL2xpc3RfcmVuZGVyX3VuaXQnO1xyXG5pbXBvcnQgUmVuZGVyU3RhdGUgZnJvbSAnLi9zdGF0ZSc7XHJcbmNvbnN0IERFUFRIX0NMRUFSX1NUQVRFID0gbmV3IFJlbmRlclN0YXRlKHtcclxuICAgIGRlcHRoVGVzdDogdHJ1ZSxcclxuICAgIGNsZWFyRGVwdGg6IDBcclxufSk7XHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExheWVyUmVuZGVyVW5pdCBleHRlbmRzIExpc3RSZW5kZXJVbml0IHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIGRlcHRoQ2xlYXJTdHJhdGVneSA9IDAgLyogTk9fQ0xFQVIgKi8pIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX2RlcHRoQ2xlYXJTdHJhdGVneSA9IGRlcHRoQ2xlYXJTdHJhdGVneTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcclxuICAgIH1cclxuICAgIHJlbmRlcih0YXJnZXQsIC4uLmFyZ3MpIHtcclxuICAgICAgICBpZiAodGhpcy5fZGVwdGhDbGVhclN0cmF0ZWd5ID09PSAxIC8qIEJFRk9SRV9SRU5ERVIgKi8pIHtcclxuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kUmVuZGVyU3RhdGUoREVQVEhfQ0xFQVJfU1RBVEUpO1xyXG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRSZW5kZXJUYXJnZXQodGFyZ2V0KTtcclxuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5jbGVhckN1cnJlbnRUYXJnZXQoMjU2IC8qIERFUFRIX0JVRkZFUl9CSVQgKi8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdXBlci5yZW5kZXIodGFyZ2V0LCAuLi5hcmdzKTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgUmVuZGVyU3RhdGUgZnJvbSAnLi4vLi4vcmVuZGVyL3N0YXRlJztcclxuaW1wb3J0IHsgY291bnRJbmRpY2VzIH0gZnJvbSAnLi4vLi4vcmVuZGVyL21lbW9yeS9jb3VudF92ZXJ0aWNlcyc7XHJcbmltcG9ydCByZXNldFJlbW92ZWRWZXJ0ZXhTaGFkZXIgZnJvbSAnLi9zaGFkZXJzL3Jlc2V0X3JlbW92ZWQudmVydCc7XHJcbmltcG9ydCByZXNldFJlbW92ZWRGcmFnbWVudFNoYWRlciBmcm9tICcuL3NoYWRlcnMvcmVzZXRfcmVtb3ZlZC5mcmFnJztcclxuaW1wb3J0IHsgR2xSZW5kZXJlciB9IGZyb20gJy4uLy4uL3JlbmRlci9nbF9yZW5kZXJlcic7XHJcbmltcG9ydCB7IGJhdGNoUHJpbWl0aXZlcyB9IGZyb20gJy4uLy4uL3JlbmRlci9wcmltaXRpdmVzL3ByaW1pdGl2ZV9iYXRjaCc7XHJcbmV4cG9ydCBjbGFzcyBDb2xsaWRpbmdQcmltaXRpdmVzUmVzZXRSZW1vdmVkUmVuZGVyZXIgZXh0ZW5kcyBHbFJlbmRlcmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIHByaW1pdGl2ZVByb3ZpZGVyKSB7XHJcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IGNvbnRleHQuY3JlYXRlUHJvZ3JhbShyZXNldFJlbW92ZWRWZXJ0ZXhTaGFkZXIsIHJlc2V0UmVtb3ZlZEZyYWdtZW50U2hhZGVyLCB7XHJcbiAgICAgICAgICAgIGF0dHJpYk1hcDoge1xyXG4gICAgICAgICAgICAgICAgdmVydGV4SWQ6IDIgLyogSUQgKi9cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHN1cGVyKGNvbnRleHQsIG5ldyBSZW5kZXJTdGF0ZSgpLCBwcm9ncmFtKTtcclxuICAgICAgICB0aGlzLl9wcmltaXRpdmVQcm92aWRlciA9IHByaW1pdGl2ZVByb3ZpZGVyO1xyXG4gICAgICAgIGNvbnRleHQuYmluZFByb2dyYW0ocHJvZ3JhbSk7XHJcbiAgICAgICAgcHJvZ3JhbS5zZXRJbnRTY2FsYXJVbmlmb3JtKCdwcmV2VmlzaWJpbGl0eScsIDApO1xyXG4gICAgfVxyXG4gICAgX3JlbmRlcigpIHtcclxuICAgICAgICBjb25zdCBwcmltaXRpdmVzID0gdGhpcy5fcHJpbWl0aXZlUHJvdmlkZXIucHJpbWl0aXZlcztcclxuICAgICAgICBmb3IgKGNvbnN0IG1lbW9yeUJhdGNoIG9mIGJhdGNoUHJpbWl0aXZlcyhwcmltaXRpdmVzKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRWYW8obWVtb3J5QmF0Y2gucGFnZS52YW8pO1xyXG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmRyYXdJbmRleGVkTWVzaChtZW1vcnlCYXRjaC5pbmRleEJ5dGVPZmZzZXQsIGNvdW50SW5kaWNlcyhtZW1vcnlCYXRjaC5pbmRleEJ5dGVMZW5ndGgsIG1lbW9yeUJhdGNoLnBhZ2UuaW5kZXhUeXBlKSwgMCAvKiBQT0lOVFMgKi8pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9wcmVwYXJlUHJvZ3JhbShwcm9ncmFtLCBwcmV2VmlzaWJpbGl0eSwgaWRIYWxmUHhTaXplKSB7XHJcbiAgICAgICAgc3VwZXIuX3ByZXBhcmVQcm9ncmFtKHByb2dyYW0sIHByZXZWaXNpYmlsaXR5LCBpZEhhbGZQeFNpemUpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFRleHR1cmVVbml0KDApO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFRleHR1cmUocHJldlZpc2liaWxpdHkpO1xyXG4gICAgICAgIHByb2dyYW0uc2V0VmVjdG9yMlVuaWZvcm0oJ2lkSGFsZlB4U2l6ZScsIGlkSGFsZlB4U2l6ZSk7XHJcbiAgICB9XHJcbn1cclxuIiwibW9kdWxlLmV4cG9ydHMgPSBcIiN2ZXJzaW9uIDEwMFxcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxuYXR0cmlidXRlIHZlYzIgdmVydGV4SWQ7XFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgcHJldlZpc2liaWxpdHk7XFxudW5pZm9ybSB2ZWMyIGlkSGFsZlB4U2l6ZTtcXG5cXG52YXJ5aW5nIGxvd3AgdmVjNCB2aXNpYmlsaXR5VmFsdWU7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICB2ZWMyIGlkVGV4Q29vcmRpbmF0ZXMgPSB2ZXJ0ZXhJZCArIGlkSGFsZlB4U2l6ZTtcXG4gICAgdmVjNCBpZFdpbmRvd0Nvb3JkaW5hdGVzID0gdmVjNChpZFRleENvb3JkaW5hdGVzICogMi4wIC0gMS4wLCAwLCAxKTtcXG4gICAgZ2xfUG9zaXRpb24gPSBpZFdpbmRvd0Nvb3JkaW5hdGVzO1xcbiAgICBnbF9Qb2ludFNpemUgPSAxLjA7XFxuXFxuICAgIHZpc2liaWxpdHlWYWx1ZSA9IHRleHR1cmUyRChwcmV2VmlzaWJpbGl0eSwgaWRUZXhDb29yZGluYXRlcyk7XFxufVxcblwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIiN2ZXJzaW9uIDEwMFxcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxudmFyeWluZyBsb3dwIHZlYzQgdmlzaWJpbGl0eVZhbHVlO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmlzaWJpbGl0eVZhbHVlO1xcbn1cXG5cIiIsImltcG9ydCB7IEV2ZW50RW1pdHRlciwgVm9pZEV2ZW50RW1pdHRlciB9IGZyb20gJy4vdXRpbC9ldmVudF9lbWl0dGVyJztcclxuY29uc3QgTUFYX0ZSQU1FX1RJTUVfQ09VTlQgPSAxMDA7XHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbmRlckxvb3Age1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBuZXcgcmVuZGVyIGxvb3AsIGJ1dCBkb2Vzbid0IHNjaGVkdWxlIGFueSBhbmltYXRpb24gZnJhbWVzLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLm9uRnJhbWVUaW1lc0Z1bGwgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5vbkJlZm9yZVJlbmRlciA9IG5ldyBWb2lkRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5vblJlbmRlciA9IG5ldyBWb2lkRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5faXNSdW5uaW5nID0gdGhpcy5fdXBkYXRlSXNSZXF1ZXN0ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9sYXN0RnJhbWVUaW1lID0gMDtcclxuICAgICAgICB0aGlzLl9mcmFtZVRpbWVzID0gbmV3IEFycmF5KE1BWF9GUkFNRV9USU1FX0NPVU5UKTtcclxuICAgICAgICB0aGlzLl9mcmFtZVRpbWVzLmZpbGwoMCk7XHJcbiAgICAgICAgdGhpcy5fbmV4dEZyYW1lVGltZUlkeCA9IDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGxvb3AgaXMgcnVubmluZyBhIGNoYWluIG9mIGNvbnNlY3V0aXZlIGFuaW1hdGlvblxyXG4gICAgICogICAgICBmcmFtZXMgb3Igbm90LlxyXG4gICAgICovXHJcbiAgICBnZXQgaXNBY3RpdmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzUnVubmluZztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3RhcnRzIGEgY2hhaW4gb2YgY29uc2VjdXRpdmUgYW5pbWF0aW9uIGZyYW1lcy5cclxuICAgICAqL1xyXG4gICAgc3RhcnQoKSB7XHJcbiAgICAgICAgdGhpcy5faXNSdW5uaW5nID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9yZXF1ZXN0RnJhbWUoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3RvcHMgcHJldmlvdXNseSBzdGFydGVkIGNoYWluIG9mIGNvbnNlY3V0aXZlIGFuaW1hdGlvbiBmcmFtZXMuIElmIGFuXHJcbiAgICAgKiB1cGRhdGUgd2FzIHJlcXVlc3RlZCBiZWZvcmUgc3RvcHBpbmcsIG9uZSBtb3JlIGFuaW1hdGlvbiBmcmFtZSB3aWxsIGJlXHJcbiAgICAgKiBmaXJlZC5cclxuICAgICAqL1xyXG4gICAgc3RvcCgpIHtcclxuICAgICAgICBpZiAodGhpcy5faXNSdW5uaW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzUnVubmluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3VwZGF0ZUlzUmVxdWVzdGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jYW5jZWxGcmFtZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTY2hlZHVsZXMgYSBzaW5nbGVcclxuICAgICAqL1xyXG4gICAgdXBkYXRlKCkge1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZUlzUmVxdWVzdGVkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9yZXF1ZXN0RnJhbWUoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3RvcHMgYWxsIHRoZSByZW5kZXJpbmcgYWN0aXZpdGllcy5cclxuICAgICAqL1xyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLl9jYW5jZWxGcmFtZSgpO1xyXG4gICAgfVxyXG4gICAgX3JlbmRlckZyYW1lKHRpbWUpIHtcclxuICAgICAgICB0aGlzLl9yYWZJZCA9IDA7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlSXNSZXF1ZXN0ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLm9uQmVmb3JlUmVuZGVyLmZpcmUoKTtcclxuICAgICAgICB0aGlzLm9uUmVuZGVyLmZpcmUoKTtcclxuICAgICAgICBpZiAodGhpcy5fbGFzdEZyYW1lVGltZSA+IDApIHtcclxuICAgICAgICAgICAgY29uc3QgbmV4dEZyYW1lVGltZUlkeCA9IHRoaXMuX25leHRGcmFtZVRpbWVJZHg7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZyYW1lVGltZXNbbmV4dEZyYW1lVGltZUlkeF0gPSB0aW1lIC0gdGhpcy5fbGFzdEZyYW1lVGltZTtcclxuICAgICAgICAgICAgdGhpcy5fbmV4dEZyYW1lVGltZUlkeCA9IChuZXh0RnJhbWVUaW1lSWR4ICsgMSkgJSBNQVhfRlJBTUVfVElNRV9DT1VOVDtcclxuICAgICAgICAgICAgLy8gTmV4dCB0aW1lIGluZGV4IGJlaW5nIDAgbWVhbnMgdGhhdCB0aGUgYXJyYXkgaXMgZnVsbCBhbmQgaXQnc1xyXG4gICAgICAgICAgICAvLyB0aW1lIHRvIG5vdGlmeSBsaXN0ZW5lcnMgYWJvdXQgdGhhdCBiZWZvcmUgd2Ugc3RhcnQgdG8gcmV3cml0ZVxyXG4gICAgICAgICAgICAvLyB2YWx1ZXMuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9uZXh0RnJhbWVUaW1lSWR4ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uRnJhbWVUaW1lc0Z1bGwuZmlyZSh0aGlzLl9mcmFtZVRpbWVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5faXNSdW5uaW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xhc3RGcmFtZVRpbWUgPSB0aW1lO1xyXG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0RnJhbWUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIElmIHdlIGRvbid0IHNjaGVkdWxlIG5leHQgZnJhbWUgaW1tZWRpYXRlbHkgdGhlcmUncyBubyB3YXkgdG9cclxuICAgICAgICAgICAgLy8gdGVsbCB0aGF0IGl0IHdpbGwgYmUgY29uc2VjdXRpdmUgdG8gdGhlIGN1cnJlbnQgb25lLiBIZW5jZSB0aGVyZSdzXHJcbiAgICAgICAgICAgIC8vIG5vIHBvaW50IGluIHJlY29yZGluZyBhIHRpbWUgZGVsdGEgaW4gaXQuXHJcbiAgICAgICAgICAgIHRoaXMuX2xhc3RGcmFtZVRpbWUgPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9yZXF1ZXN0RnJhbWUoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9yYWZJZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9yYWZJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKHRpbWUpID0+IHRoaXMuX3JlbmRlckZyYW1lKHRpbWUpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2NhbmNlbEZyYW1lKCkge1xyXG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX3JhZklkKTtcclxuICAgICAgICB0aGlzLl9yYWZJZCA9IDA7XHJcbiAgICB9XHJcbn1cclxuIl0sInNvdXJjZVJvb3QiOiIifQ==