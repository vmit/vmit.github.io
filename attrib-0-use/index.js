/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 53);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_color__ = __webpack_require__(11);

/**
 * Preset of render state for OVER compositing,
 * @see T. Porter and T. Duff, "Compositing Digital Images", Proceedings of
 *      SIGGRAPH'84, 18 (1984).
 */
const BLEND_OVER_RENDER_STATE = {
    blend: true,
    blendFuncSrcRgb: 770 /* SRC_ALPHA */,
    blendFuncDstRgb: 771 /* ONE_MINUS_SRC_ALPHA */,
    blendFuncSrcAlpha: 1 /* ONE */,
    blendFuncDstAlpha: 771 /* ONE_MINUS_SRC_ALPHA */
};
/* harmony export (immutable) */ __webpack_exports__["b"] = BLEND_OVER_RENDER_STATE;

const BLEND_OVER_PREMULTIPLIED_ALPHA_RENDER_STATE = {
    blend: true,
    blendFuncSrcRgb: 1 /* ONE */,
    blendFuncDstRgb: 771 /* ONE_MINUS_SRC_ALPHA */,
    blendFuncSrcAlpha: 1 /* ONE */,
    blendFuncDstAlpha: 771 /* ONE_MINUS_SRC_ALPHA */
};
/* harmony export (immutable) */ __webpack_exports__["a"] = BLEND_OVER_PREMULTIPLIED_ALPHA_RENDER_STATE;

/**
 * State of the WebGL rendering pipeline. Doesn't include object bindings since
 * the context handles them.
 */
class RenderState {
    /**
     * Creates a new render state object.
     *
     * @param state Object with state properties that values differ from default
     *      ones.
     */
    constructor(...state) {
        this.clearColor = __WEBPACK_IMPORTED_MODULE_0__util_color__["c" /* create */](0, 0, 0, 0);
        this.clearDepth = 1;
        this.clearStencil = 0;
        this.colorMaskR = true;
        this.colorMaskG = true;
        this.colorMaskB = true;
        this.colorMaskAlpha = true;
        this.blend = false;
        this.blendEquationRgb = 32774 /* ADD */;
        this.blendEquationAlpha = 32774 /* ADD */;
        this.blendFuncSrcRgb = 1 /* ONE */;
        this.blendFuncDstRgb = 0 /* ZERO */;
        this.blendFuncSrcAlpha = 1 /* ONE */;
        this.blendFuncDstAlpha = 0 /* ZERO */;
        this.cullFace = false;
        this.cullFaceMode = 1029 /* BACK */;
        this.frontFaceMode = 2305 /* COUNTERCLOCKWISE */;
        this.depthTest = false;
        this.depthFunc = 513 /* LESS */;
        this.depthRangeNear = 0;
        this.depthRangeFar = 1;
        this.depthMask = true;
        this.dither = true;
        this.drawBuffers = [36064 /* COLOR_ATTACHMENT0 */];
        this.polygonOffset = false;
        this.polygonOffsetFactor = 0;
        this.polygonOffsetUnits = 0;
        this.sampleAlphaToCoverage = false;
        this.sampleCoverage = false;
        this.sampleCoverageValue = 1;
        this.sampleCoverageInvert = false;
        this.scissorTest = false;
        this.scissorX = 0;
        this.scissorY = 0;
        // Actual defaults aren't known here since they depend upon context. -1's
        // as "do not change" values.
        this.scissorWidth = -1;
        this.scissorHeight = -1;
        this.stencilTest = false;
        this.stencilReference = 0;
        this.stencilMask = 0xff;
        this.stencilWriteMask = 0xff;
        this.stencilFrontFunc = 519 /* ALWAYS */;
        this.stencilFrontFailOp = 7680 /* KEEP */;
        this.stencilFrontDepthFailOp = 7680 /* KEEP */;
        this.stencilFrontDepthPassOp = 7680 /* KEEP */;
        this.stencilBackFunc = 519 /* ALWAYS */;
        this.stencilBackFailOp = 7680 /* KEEP */;
        this.stencilBackDepthFailOp = 7680 /* KEEP */;
        this.stencilBackDepthPassOp = 7680 /* KEEP */;
        this.viewportX = 0;
        this.viewportY = 0;
        // Actual defaults aren't known here since they depend upon context. -1's
        // as "do not change" values.
        this.viewportWidth = -1;
        this.viewportHeight = -1;
        Object.assign(this, ...state);
    }
}
/* harmony export (immutable) */ __webpack_exports__["c"] = RenderState;



/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["f"] = create;
/* harmony export (immutable) */ __webpack_exports__["e"] = copy;
/* unused harmony export areEqual */
/* unused harmony export areCollinear */
/* unused harmony export areFuzzyEqual */
/* harmony export (immutable) */ __webpack_exports__["b"] = add;
/* harmony export (immutable) */ __webpack_exports__["s"] = sub;
/* unused harmony export mulv */
/* harmony export (immutable) */ __webpack_exports__["p"] = muln;
/* harmony export (immutable) */ __webpack_exports__["l"] = divv;
/* harmony export (immutable) */ __webpack_exports__["k"] = divn;
/* unused harmony export mod */
/* unused harmony export mix */
/* unused harmony export rotate */
/* unused harmony export rotate45 */
/* harmony export (immutable) */ __webpack_exports__["r"] = rotate90;
/* unused harmony export rotateNeg90 */
/* harmony export (immutable) */ __webpack_exports__["n"] = invert;
/* harmony export (immutable) */ __webpack_exports__["o"] = length;
/* harmony export (immutable) */ __webpack_exports__["j"] = distance;
/* harmony export (immutable) */ __webpack_exports__["q"] = normalize;
/* harmony export (immutable) */ __webpack_exports__["d"] = convert;
/* harmony export (immutable) */ __webpack_exports__["m"] = dot;
/* harmony export (immutable) */ __webpack_exports__["i"] = crossZ;
/* harmony export (immutable) */ __webpack_exports__["g"] = createBBox2;
/* unused harmony export copyBBox2 */
/* unused harmony export bboxesOverlap */
/* unused harmony export pointIsInBBox */
/* harmony export (immutable) */ __webpack_exports__["c"] = computeBBoxForPoints;
/* unused harmony export getLineFromPoints */
/* unused harmony export getSignedDistanceToLine */
/* harmony export (immutable) */ __webpack_exports__["h"] = createExtent2;
/* unused harmony export copyExtent2 */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_fuzzy_equal__ = __webpack_require__(25);

/**
 * Creates a new vector and initializes it with given components.
 *
 * @param x X component of the vector.
 * @param y Y component of the vector.
 * @returns The vector.
 */
function create(x, y) {
    return { x, y };
}
const ZERO = create(0, 0);
/* harmony export (immutable) */ __webpack_exports__["a"] = ZERO;

const ORIGIN = ZERO;
/* unused harmony export ORIGIN */

const POSITIVE_X = create(1, 0);
/* unused harmony export POSITIVE_X */

const NEGATIVE_X = create(-1, 0);
/* unused harmony export NEGATIVE_X */

const POSITIVE_Y = create(0, 1);
/* unused harmony export POSITIVE_Y */

const NEGATIVE_Y = create(0, -1);
/* unused harmony export NEGATIVE_Y */

/**
 * Copies a vector to another one.
 *
 * @param src The source vector.
 * @param dst The vector the source vector will be copied to.
 * @returns `dst`.
 */
function copy(src, dst = create(0, 0)) {
    dst.x = src.x;
    dst.y = src.y;
    return dst;
}
/**
 * Checks if two vectors are strictly equal component-wise.
 *
 * @param v1 The first vector.
 * @param v2 The second vector.
 * @returns `true` if the vectors are equal and `false` otherwise.
 */
function areEqual(v1, v2) {
    return v1.x === v2.x && v1.y === v2.y;
}
/**
 * Checks if two vectors are collinear.
 *
 * @param v1 The first vector.
 * @param v2 The second vector.
 * @returns `true` if the vectors are collinear and `false` otherwise.
 */
function areCollinear(v1, v2) {
    return v1.x / v2.x === v1.y / v2.y;
}
/**
 * Checks if corresponding components of two vectors are all within given
 * tolerance from each other.
 *
 * @param v1 The first vector.
 * @param v2 The second vector.
 * @param tolerance The tolerance.
 * @returns `true` if the vectors are "fuzzy" equal and `false` otherwise.
 */
function areFuzzyEqual(v1, v2, tolerance = __WEBPACK_IMPORTED_MODULE_0__util_fuzzy_equal__["a" /* DEFAULT_TOLERANCE */]) {
    return (Object(__WEBPACK_IMPORTED_MODULE_0__util_fuzzy_equal__["b" /* default */])(v1.x, v2.x, tolerance) &&
        Object(__WEBPACK_IMPORTED_MODULE_0__util_fuzzy_equal__["b" /* default */])(v1.y, v2.y, tolerance));
}
/**
 * Adds two vector and stores the result into a third one, i.e. `dst = a + b`.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function add(a, b, dst = create(0, 0)) {
    dst.x = a.x + b.x;
    dst.y = a.y + b.y;
    return dst;
}
/**
 * Subtracts a vector from another one and stores the result to a third one, i.e.
 * `dst = a - b`.
 *
 * @param a The minuend vector.
 * @param b The subtrahend vector.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function sub(a, b, dst = create(0, 0)) {
    dst.x = a.x - b.x;
    dst.y = a.y - b.y;
    return dst;
}
/**
 * Multiplies two vectors component-wise and stores the result into a third one.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function mulv(a, b, dst = create(0, 0)) {
    dst.x = a.x * b.x;
    dst.y = a.y * b.y;
    return dst;
}
/**
 * Multiplies a vector by a scalar and stores the result into a third vector.
 *
 * @param a The vector.
 * @param n The scalar.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function muln(a, n, dst = create(0, 0)) {
    dst.x = a.x * n;
    dst.y = a.y * n;
    return dst;
}
/**
 * Divides a vector by another one component wise and stores the result into a
 * third one.
 *
 * @param a The dividend vector.
 * @param b The divisor vector.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function divv(a, b, dst = create(0, 0)) {
    dst.x = a.x / b.x;
    dst.y = a.y / b.y;
    return dst;
}
/**
 * Divides a vector by a scalar and stores the result into a third vector.
 *
 * @param a The dividend vector.
 * @param n The scalar.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function divn(a, n, dst = create(0, 0)) {
    dst.x = a.x / n;
    dst.y = a.y / n;
    return dst;
}
/**
 * Calculates the reminder after division of a's components by n and stores the result into a third vector.
 *
 * @param a The dividend vector.
 * @param n The scalar.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function mod(a, n, dst = create(0, 0)) {
    dst.x = a.x % n;
    dst.y = a.y % n;
    return dst;
}
/**
 * Linearly interpolates between two vectors, i.e. computes
 * `(1 - factor) * a + factor * b`, and writes the result into a third vector.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @param factor The interpolation factor.
 * @param dst The vector the result will be written to.
 * @returns `dst`.
 */
function mix(a, b, factor, dst = create(0, 0)) {
    dst.x = (1 - factor) * a.x + factor * b.x;
    dst.y = (1 - factor) * a.y + factor * b.y;
    return dst;
}
/**
 * Rotates a vector by a given angle and stores the result into a second vector.
 * Positive direction is from +X to +Y.
 *
 * @param v The vector to rotate.
 * @param angle The angle of rotation.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function rotate(v, angle, dst = create(0, 0)) {
    const x = v.x;
    const y = v.y;
    const angleCos = Math.cos(angle);
    const angleSin = Math.sin(angle);
    dst.x = angleCos * x - angleSin * y;
    dst.y = angleSin * x + angleCos * y;
    return dst;
}
/**
 * Rotates a vector by 45 degrees and stores the result into a second vector.
 * Analogous to `rotate(v, Math.PI / 4, dst)`, but faster.
 *
 * @param v The vector to rotate.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function rotate45(v, dst = create(0, 0)) {
    const y = v.y;
    const s = Math.SQRT1_2;
    dst.y = s * v.x + s * v.y;
    dst.x = s * v.x - s * y;
    return dst;
}
/**
 * Rotates a vector by 90 degrees and stores the result into a second vector.
 * Analogous to `rotate(v, Math.PI / 2, dst)`, but faster.
 *
 * @param v The vector to rotate.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function rotate90(v, dst = create(0, 0)) {
    const y = v.y;
    dst.y = v.x;
    dst.x = -y;
    return dst;
}
/**
 * Rotates a vector by -90 degrees and stores the result into a second vector.
 * Analogous to `rotate(v, -Math.PI / 2, dst)`, but faster.
 *
 * @param v The vector to rotate.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function rotateNeg90(v, dst = create(0, 0)) {
    const y = v.y;
    dst.y = -v.x;
    dst.x = y;
    return dst;
}
/**
 * Inverts signs of components of a vector and stores the result into a second
 * vector. Analogous to `rotate(v, Math.PI, dst)` (or `rotate(v, -Math.PI, dst)`,
 * which is the same), but faster.
 *
 * @param v The vector to invert.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function invert(v, dst = create(0, 0)) {
    dst.x = -v.x;
    dst.y = -v.y;
    return dst;
}
/**
 * Computes length of a vector.
 *
 * @param v The vector.
 * @returns The length.
 */
function length(v) {
    return Math.hypot(v.x, v.y);
}
/**
 * Computes distance between ends of two vectors.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @returns The distance, i.e. `length(sub(a, b))`.
 */
function distance(a, b) {
    return Math.hypot(a.x - b.x, a.y - b.y);
}
/**
 * Divides a vector by its length (thus making it a unit vector) and stores the
 * result to another one.
 *
 * @param v The vector to be normalized.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function normalize(v, dst = create(0, 0)) {
    return divn(v, length(v), dst);
}
/**
 * Converts each component of vector.
 *
 * @param v The vector to be converted.
 * @param converter The component converter.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function convert(v, converter, dst = create(0, 0)) {
    dst.x = converter(v.x);
    dst.y = converter(v.y);
    return dst;
}
/**
 * Computes dot product of two vectors.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @returns The dot product.
 */
function dot(a, b) {
    return a.x * b.x + a.y * b.y;
}
/**
 * Computes Z-component of a cross product of two vectors.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @returns Z-component of the cross product.
 */
function crossZ(a, b) {
    return a.x * b.y - a.y * b.x;
}
const EMPTY = {
    minX: 0,
    maxX: 0,
    minY: 0,
    maxY: 0
};
/* unused harmony export EMPTY */

const UNIT_BBOX = {
    minX: -1,
    maxX: 1,
    minY: -1,
    maxY: 1
};
/* unused harmony export UNIT_BBOX */

/**
 * Creates a new bbox and initializes it with given components.
 *
 * @param minX Left border of the bbox.
 * @param maxX Right border of the bbox.
 * @param minY Lower border of the bbox.
 * @param maxY Upper border of the bbox.
 * @returns The bbox.
 */
function createBBox2(minX, maxX, minY, maxY) {
    return { minX, maxX, minY, maxY };
}
/**
 * Copies a bbox to another one.
 *
 * @param src The source bbox.
 * @param dst The bbox the source bbox will be copied to.
 * @returns `dst`.
 */
function copyBBox2(src, dst = createBBox2(0, 0, 0, 0)) {
    dst.minX = src.minX;
    dst.maxX = src.maxX;
    dst.minY = src.minY;
    dst.maxY = src.maxY;
    return dst;
}
/**
 * Checks if two bounding boxes overlap.
 *
 * @param bbox1 A bounding box.
 * @param bbox2 Another bounding box.
 * @returns `true` if given bounding boxes do overlap and `false` otherwise.
 */
function bboxesOverlap(bbox1, bbox2) {
    let leftBBox;
    let rightBBox;
    if (bbox1.minX < bbox2.minX) {
        leftBBox = bbox1;
        rightBBox = bbox2;
    }
    else {
        leftBBox = bbox2;
        rightBBox = bbox1;
    }
    let topBBox;
    let bottomBBox;
    if (bbox1.maxY > bbox2.maxY) {
        topBBox = bbox1;
        bottomBBox = bbox2;
    }
    else {
        topBBox = bbox2;
        bottomBBox = bbox1;
    }
    return rightBBox.minX < leftBBox.maxX && bottomBBox.maxY > topBBox.minY;
}
/**
 * Checks if a 2D point lies inside a bounding box or on its border.
 *
 * @param point The point.
 * @param bbox The bounding box.
 * @returns `true` if the point is inside of the box and `false` otherwise.
 */
function pointIsInBBox(point, bbox) {
    return bbox.minX <= point.x && point.x <= bbox.maxX &&
        bbox.minY <= point.y && point.y <= bbox.maxY;
}
/**
 * Computes bounding box of an array of points and stores it to a given object.
 *
 * @param points The array of points.
 * @param dst The bbox the result will be written to. Left unmodified if the array
 *      of points is empty.
 * @returns `dst`.
 */
function computeBBoxForPoints(points, dst = { minX: 0, maxX: 0, minY: 0, maxY: 0 }) {
    if (points.length === 0) {
        return dst;
    }
    dst.minX = dst.maxX = points[0].x;
    dst.minY = dst.maxY = points[0].y;
    for (let i = 1; i < points.length; ++i) {
        const { x, y } = points[i];
        if (x < dst.minX) {
            dst.minX = x;
        }
        if (x > dst.maxX) {
            dst.maxX = x;
        }
        if (y < dst.minY) {
            dst.minY = y;
        }
        if (y > dst.maxY) {
            dst.maxY = y;
        }
    }
    return dst;
}
const X_AXIS = {
    origin: ORIGIN,
    tangent: POSITIVE_X
};
/* unused harmony export X_AXIS */

const Y_AXIS = {
    origin: ORIGIN,
    tangent: POSITIVE_Y
};
/* unused harmony export Y_AXIS */

function getLineFromPoints(p1, p2, dst = {
    origin: create(0, 0),
    tangent: create(0, 0)
}) {
    copy(p1, dst.origin);
    sub(p2, p1, dst.tangent);
    return dst;
}
/**
 * Computes signed distance from a point to a line.
 *
 * @param p The point.
 * @param l1 Start point of the line.
 * @param l2 End point of the line.
 * @returns Distance from the point to the line. It'll be greater than 0 if the
 *      point lies to the left of the line and less than 0 otherwise.
 */
function getSignedDistanceToLine(p, l) {
    const tangent = l.tangent;
    return dot(sub(p, l.origin), create(-tangent.y, tangent.x)) / length(tangent);
}
/**
 * Creates a new extent and initializes it with given components.
 *
 * @param width Width of the extent.
 * @param Height Height of the extent.
 * @returns The extent.
 */
function createExtent2(width, height) {
    return { width, height };
}
/**
 * Copies an extent to another one.
 *
 * @param src The source bbox.
 * @param dst The extent the source extent will be copied to.
 * @returns `dst`.
 */
function copyExtent2(src, dst = createExtent2(0, 0)) {
    dst.width = src.width;
    dst.height = src.height;
    return dst;
}


/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Simple pub/sub implementation. The emitter is supposed to emit only one type of event,
 * if someone has to emit events of different types, multiple emitters should be created.
 */
class EventEmitter {
    constructor() {
        this._listeners = new Set();
    }
    /**
     * Adds listener.
     */
    addListener(listener) {
        this._listeners.add(listener);
    }
    /**
     * Removes listener.
     */
    removeListener(listener) {
        this._listeners.delete(listener);
    }
    /**
     * Calls all the added listeners, the order (e.g. of adding) is not guaranteed.
     */
    fire(data) {
        this._listeners.forEach((listener) => {
            listener(data);
        });
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = EventEmitter;

/**
 * Event emitter with no payload emitted.
 */
class VoidEventEmitter extends EventEmitter {
    fire() {
        super.fire(undefined);
    }
}
/* harmony export (immutable) */ __webpack_exports__["b"] = VoidEventEmitter;



/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_iterable__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_pow_of_2__ = __webpack_require__(55);


/**
 * Gives size of a GL type.
 *
 * @param type The type.
 * @returns Size of the type in bytes.
 */
function getTypeSize(type) {
    switch (type) {
        case 5120 /* BYTE */:
        case 5121 /* UNSIGNED_BYTE */:
            return 1;
        case 5122 /* SHORT */:
        case 5123 /* UNSIGNED_SHORT */:
            return 2;
        case 5124 /* INT */:
        case 5125 /* UNSIGNED_INT */:
        case 5126 /* FLOAT */:
            return 4;
    }
}
/**
 * Description of how particular attributes of a vertex are packed into a vertex
 * buffer.
 */
class AttributeMapping extends Map {
    /**
     * Creates a new attribute mapping with a set of attributes of given types and
     * sizes. Automatically computes offsets of the attributes.
     *
     * @param mapping The mapping from attribute IDs to types and sizes.
     * @param alignment Desired alignment of attributes in the vertex data
     *      structure. Must be a power of 2.
     */
    constructor(mapping, alignment = 4 /* ALIGN_4_BYTES */) {
        let offset = 0;
        super(Object(__WEBPACK_IMPORTED_MODULE_0__util_iterable__["c" /* mapIterable */])(mapping, ([idx, { type, size, normalized }]) => {
            const pointer = [
                idx,
                {
                    type,
                    size,
                    normalized,
                    offset
                }
            ];
            const attributeSize = size * getTypeSize(type);
            const newOffset = Object(__WEBPACK_IMPORTED_MODULE_1__util_pow_of_2__["a" /* align */])(offset + attributeSize, -alignment);
            // TODO(dmikis) Check this in debug mode.
            // if (newOffset - offset > attributeSize) {
            //    console.warn(`${newOffset - offset} byte padding's inserted`);
            // }
            offset = newOffset;
            return pointer;
        }));
        this.vertexByteSize = offset;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = AttributeMapping;



/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Base class for any WebGL renderer, it just defines basic structure of GL-calls allowing to override any part.
 * A specific renderer may need any number of additional arguments to perform rendering, they are provided in
 * additionalParams in the render() method.
 */
class GlRenderer {
    constructor(context, renderState, program) {
        this._context = context;
        this._renderState = renderState;
        this._program = program;
    }
    render(target, ...args) {
        if (this._program) {
            this._prepareProgram(this._program, ...args);
        }
        this._prepareRenderTarget(target, ...args);
        this._render(...args);
    }
    destroy() {
        if (this._program) {
            this._program.destroy();
        }
    }
    /**
     * Binds program and sets required uniforms. Subclasses are supposed to override
     * this method to add their own uniforms.
     */
    _prepareProgram(program, ..._args) {
        this._context.bindProgram(program);
    }
    /**
     * Binds render state and render target, no clear happens here, but this method
     * can be overridden in subclasses to add any setups they need.
     */
    _prepareRenderTarget(target, ..._args) {
        this._context.bindRenderState(this._renderState);
        this._context.bindRenderTarget(target);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = GlRenderer;



/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__gl_renderer__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__memory_count_vertices__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__primitive_batch__ = __webpack_require__(44);



/**
 * Base class for rendering visible primitives. Being visible in the world means that they all need view-projection
 * matrix and camera positions (multiple positions are used for rendering repeated world). These parameters are
 * predefined as external requirements for render() method.
 */
class WorldPrimitiveRenderUnit extends __WEBPACK_IMPORTED_MODULE_0__gl_renderer__["a" /* GlRenderer */] {
    constructor(context, renderState, program, primitiveProvider) {
        super(context, renderState, program);
        this.primitiveProvider = primitiveProvider;
        this.onUpdate = primitiveProvider.onUpdate;
    }
    render(target, viewProjMatrix, cameraPositions, ...args) {
        super.render(target, viewProjMatrix, cameraPositions, ...args);
    }
    _render(_viewProjMatrix, cameraPositions) {
        for (const cameraPosition of cameraPositions) {
            this._program.setVector2Uniform('lookAtHigh', cameraPosition.lookAtHigh);
            this._program.setVector2Uniform('lookAtLow', cameraPosition.lookAtLow);
            for (const memoryBatch of Object(__WEBPACK_IMPORTED_MODULE_2__primitive_batch__["a" /* batchPrimitives */])(this._getPrimitives(), this._canBatchAdjacentPrimitives)) {
                this._renderBatch(memoryBatch);
            }
        }
    }
    _getPrimitives() {
        return this.primitiveProvider.primitives;
    }
    _prepareProgram(program, viewProjMatrix, cameraPositions, ...args) {
        super._prepareProgram(program, viewProjMatrix, cameraPositions, ...args);
        program.setMatrix4Uniform('viewProjMatrix', viewProjMatrix);
    }
    _renderBatch(memoryBatch) {
        this._context.bindVao(memoryBatch.page.vao);
        this._context.drawIndexedMesh(memoryBatch.indexByteOffset, Object(__WEBPACK_IMPORTED_MODULE_1__memory_count_vertices__["a" /* countIndices */])(memoryBatch.indexByteLength, memoryBatch.page.indexType));
    }
    /**
     * Determines if two adjacent primitives can be rendered in one batch (by a single draw call). They already
     * lay successively in memory, but there could be other reasons that forbid batching, like using different textures.
     * The method should be overridden in subclasses if their primitives have such complex rules of batching.
     */
    _canBatchAdjacentPrimitives(_a, _b) {
        return true;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = WorldPrimitiveRenderUnit;



/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__gputypes__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__array__ = __webpack_require__(14);


const WORD_BYTE_SIZE = 4;
/* harmony export (immutable) */ __webpack_exports__["a"] = WORD_BYTE_SIZE;

/**
 * Generates triangles of a fan of a given length as if it is continuous and
 * starts with 0.
 *
 * @param count Number of vertices in the fan.
 * @returns Iterator over indices of triangles.
 */
function* generateFan(count) {
    for (let i = 2; i < count; ++i) {
        yield 0;
        yield i - 1;
        yield i;
    }
}
/**
 * Generates triangles of a strip of a given length as if it is continuous and
 * starts with 0.
 *
 * @param count Number of vertices in the fan.
 * @returns Iterator over indices of triangles.
 */
function* generateStrip(count) {
    yield 0;
    yield 1;
    yield 2;
    let offset0 = 1;
    let offset1 = 2;
    for (let i = 3; i < count; ++i) {
        yield i - offset0;
        yield i - offset1;
        yield i;
        const tmp = offset0;
        offset0 = offset1;
        offset1 = tmp;
    }
}
/**
 * Vertex buffer helper class, that supports sequential writing interface and takes over some single-buffer operations.
 * It is an integral part of the buffer writer class and its main purpose is to make the writer's code easier.
 */
class VertexBuffer {
    /**
     * @param byteSize Initial size of the buffer in bytes. As it gets filled by words
     *      the size must be a multiply of 4.
     */
    constructor(byteSize) {
        this._nextWordOffset = 0;
        this._initBuffers(byteSize);
    }
    /**
     * @returns true if there is no free space remaining in buffer.
     */
    get isFull() {
        return this._nextWordOffset >= this._uint32View.length;
    }
    /**
     * @returns The number of words (4 bytes values) already written.
     */
    get occupiedSize() {
        return this._nextWordOffset;
    }
    /**
     * @return Max number of bytes this buffer is able to store. It can be increased by the extend() method.
     */
    get byteSize() {
        return this._uint32View.byteLength;
    }
    /**
     * Extends buffer to the new size. The new size must be not less than current one and it must be a multiply of 4.
     */
    extend(newByteSize) {
        // TODO assert newByteLength is larger than current _arrayBuffer and its is a multiply of the word size.
        const oldUint32View = this._uint32View;
        this._initBuffers(newByteSize);
        this._uint32View.set(oldUint32View);
    }
    /**
     * Appends value as a uint32 number.
     */
    pushUint32(value) {
        this._uint32View[this._nextWordOffset++] = value;
    }
    /**
     * Appends value as a float32 number.
     */
    pushFloat32(value) {
        this._float32View[this._nextWordOffset++] = value;
    }
    /**
     * @returns uint8 view of this buffer. The size of the view matches the amount of written data.
     */
    asUint32Array() {
        return this._uint32View.subarray(0, this.occupiedSize);
    }
    _initBuffers(byteLength) {
        const arrayBuffer = new ArrayBuffer(byteLength);
        this._uint32View = new Uint32Array(arrayBuffer);
        this._float32View = new Float32Array(arrayBuffer);
    }
    /**
     * Moves "tail" data (from the offset specified to the end of the buffer) of one buffer to another. The cursors of
     * buffers will be appropriately updated to reflect data changes.
     */
    static transferDataTail(src, dst, srcWordOffset, dstOffset = 0) {
        const tailLength = src.occupiedSize - srcWordOffset;
        const srcTail = src._uint32View.subarray(srcWordOffset, src.occupiedSize);
        dst._uint32View.set(srcTail, dstOffset);
        dst._nextWordOffset = tailLength;
        src._nextWordOffset = srcWordOffset;
    }
}
/**
 * Index buffer helper class, that supports sequential writing interface and takes over some single-buffer operations.
 * It is an integral part of the buffer writer class and its main purpose is to make the writer's code easier.
 */
class IndexBuffer {
    /**
     * @param size Initial size of the buffer.
     */
    constructor(size) {
        this._nextIndexOffset = 0;
        this._uint16View = new Uint16Array(size);
    }
    /**
     * @returns The number of indices already written.
     */
    get occupiedSize() {
        return this._nextIndexOffset;
    }
    /**
     * @return Max number of indices this buffer is able to store. It can be increased by the extend() method.
     */
    get size() {
        return this._uint16View.length;
    }
    /**
     * Extends buffer to the new size.
     */
    extend(newSize) {
        // TODO assert newByteLength is larger than current _arrayBuffer
        const oldUint16View = this._uint16View;
        this._uint16View = new Uint16Array(newSize);
        this._uint16View.set(oldUint16View);
    }
    /**
     * Appends index to the end of the buffer.
     */
    push(index) {
        this._uint16View[this._nextIndexOffset++] = index;
    }
    /**
     * @returns uint16 view of this buffer. The size of the view matches the amount of written data.
     */
    asUint16Array() {
        return new Uint16Array(this._uint16View.buffer, 0, this.occupiedSize);
    }
    /**
     * Moves "tail" data (from the offset specified to the end of the buffer) of one buffer to another. The offsets of
     * buffers will be appropriately updated to reflect data changes.
     * baseIndex will be deducted from all moved indices.
     */
    static transferDataTail(src, dst, baseIndex, srcOffset, dstOffset = 0) {
        for (let i = srcOffset, j = dstOffset; i < src.occupiedSize; i++, j++) {
            dst._uint16View[j] = src._uint16View[i] - baseIndex;
        }
        dst._nextIndexOffset = src.occupiedSize - srcOffset;
        src._nextIndexOffset = srcOffset;
    }
}
/**
 * Base buffer writer implementation. Can write unsigned short indices and
 * provides facilities for child classes to handle writing vertex data. Defines
 * a concept of current mesh. Basically, it mean that all vertices and indices
 * written to a writer between two `endMesh` calls (or construction of the writer
 * and an `endMesh` call) must be considered belonging to one atomic piece of
 * geometry and should not be spitted between separate buffers.
 */
class BufferWriter {
    /**
     * Creates a new writer and allocates initial amount of memory to store data.
     * Also implicitly "start" a mesh.
     *
     * @param vertexByteSize
     * @param initVertexBufferSize Init size (in vertices) of growing vertex buffers.
     * @param maxVertexBufferSize Max size (in vertices) of vertex buffers.
     * @param initIndexBufferUint16Size Init size (in uint16 number) of growing index buffers.
     */
    constructor(vertexByteSize, initVertexBufferSize = 0x400, maxVertexBufferSize = 0x10000, initIndexBufferUint16Size = 0xc00) {
        this._vertexByteSize = vertexByteSize;
        this._initVertexBufferByteSize = vertexByteSize * initVertexBufferSize;
        this._maxVertexBufferByteSize = vertexByteSize * maxVertexBufferSize;
        this._initIndexBufferUint16Size = initIndexBufferUint16Size;
        this._vertexBuffer = new VertexBuffer(this._initVertexBufferByteSize);
        this._vertexBuffers = [this._vertexBuffer];
        this._indexBuffer = new IndexBuffer(this._initIndexBufferUint16Size);
        this._indexBuffers = [this._indexBuffer];
        this._currentMeshVertexOffset = 0;
        this._currentMeshIndexOffset = 0;
        this._currentMeshBaseIndex = 0;
    }
    /**
     * Writes a bunch of indices to the underlying storage as unsigned short
     * numbers. If current storage doesn't have enough space to accommodate
     * given indices, the writer will automatically resize it. The writer
     * automatically adds base index to the supplied values, so from a user
     * point of view first vertex of a mesh has index 0 and there's no need
     * to take into account it's offset while generating mesh's topology.
     *
     * @param indices Array of indices to write.
     */
    writeIndices(indices) {
        this._ensureEnoughIndexBufferSpace(indices.length);
        const buffer = this._indexBuffer;
        const baseIndex = this._currentMeshBaseIndex;
        for (let i = 0; i < indices.length; ++i) {
            buffer.push(baseIndex + indices[i]);
        }
    }
    /**
     * Generates triangle indices from an array of indices of a triangle strip
     * (as in GL) and writes generated triplets to the managed index buffer.
     * @see OpenGL ES 2.0 Spec, §2.6.1
     *
     * @param indices Indices of the strip.
     */
    writeIndicesForStrip(indices) {
        this._ensureEnoughIndexBufferSpace(3 * (indices.length - 2));
        const buffer = this._indexBuffer;
        const baseIndex = this._currentMeshBaseIndex;
        for (const i of generateStrip(indices.length)) {
            buffer.push(baseIndex + indices[i]);
        }
    }
    /**
     * Generates triangle indices from a continuous triangle strip of a given
     * length and writes generated triplets to managed index buffer.
     * @see OpenGL ES 2.0 Spec, §2.6.1
     *
     * @param indexCount
     * @param baseIndexInMesh
     */
    writeIndicesForContinuousStrip(indexCount, baseIndexInMesh = 0) {
        this._ensureEnoughIndexBufferSpace(3 * (indexCount - 2));
        const buffer = this._indexBuffer;
        const baseIndex = this._currentMeshBaseIndex + baseIndexInMesh;
        for (const i of generateStrip(indexCount)) {
            buffer.push(baseIndex + i);
        }
    }
    /**
     * Generates triangle indices from an array of indices of a triangle fan (as
     * in GL) and writes generated triplets to the managed index buffer.
     * @see OpenGL ES 2.0 Spec, §2.6.1
     *
     * @param indices Indices of the strip.
     */
    writeIndicesForFan(indices) {
        this._ensureEnoughIndexBufferSpace(3 * (indices.length - 2));
        const buffer = this._indexBuffer;
        const baseIndex = this._currentMeshBaseIndex;
        for (const i of generateFan(indices.length)) {
            buffer.push(baseIndex + indices[i]);
        }
    }
    /**
     * Generates triangle indices from a continuous triangle fan of a given length
     * and writes generated triplets to managed index buffer.
     * @see OpenGL ES 2.0 Spec, §2.6.1
     *
     * @param indexCount
     * @param baseIndexInMesh
     */
    writeIndicesForContinuousFan(indexCount, baseIndexInMesh = 0) {
        this._ensureEnoughIndexBufferSpace(3 * (indexCount - 2));
        const buffer = this._indexBuffer;
        const baseIndex = baseIndexInMesh + this._currentMeshBaseIndex;
        for (const i of generateFan(indexCount)) {
            buffer.push(baseIndex + i);
        }
    }
    /**
     * Ends current mesh and implicitly starts a new one.
     *
     * @returns Internal index of vertex and index buffers the mesh was written
     *      to and its memory location in them.
     */
    endMesh() {
        const currentMeshVertexOffset = this._currentMeshVertexOffset;
        const vertexOccupiedSize = this._vertexBuffer.occupiedSize;
        this._currentMeshVertexOffset = vertexOccupiedSize;
        this._currentMeshBaseIndex = (vertexOccupiedSize << 2) / this._vertexByteSize;
        const currentMeshIndexOffset = this._currentMeshIndexOffset;
        const indexOccupiedSize = this._indexBuffer.occupiedSize;
        this._currentMeshIndexOffset = indexOccupiedSize;
        return {
            vertexByteOffset: currentMeshVertexOffset << 2,
            vertexByteLength: vertexOccupiedSize - currentMeshVertexOffset << 2,
            indexByteOffset: currentMeshIndexOffset << 1,
            indexByteLength: indexOccupiedSize - currentMeshIndexOffset << 1,
            // We can't return actual buffer reference since it can change if
            // the buffer gets reallocated.
            bufferIndex: this._vertexBuffers.length - 1
        };
    }
    /**
     * Returns an array of currently owned buffer data. This call's better
     * made when you're done with the writer since if the writer decides to
     * resize any of the buffers some of the references in the returned array
     * may become outdated.
     */
    getBuffers() {
        return Object(__WEBPACK_IMPORTED_MODULE_1__array__["d" /* zip */])(this._vertexBuffers, this._indexBuffers, (vertexBuffer, indexBuffer) => ({
            vertexBuffer: vertexBuffer.asUint32Array(),
            indexBuffer: indexBuffer.asUint16Array()
        }));
    }
    /**
     * Returns an offset in the current vertex buffer to the location where next
     * piece of data will be written.
     */
    getCurrentVertexBufferByteOffset() {
        return this._vertexBuffer.occupiedSize << 2;
    }
    /**
     * Returns index of currently written vertex structure in the current vertex
     * buffer.
     */
    getCurrentVertexIdx() {
        return ((this._vertexBuffer.occupiedSize << 2) / this._vertexByteSize | 0) - this._currentMeshBaseIndex;
    }
    /**
     * Writes a floating point value to the current vertex buffer and advances
     * the offset by 4 bytes.
     *
     * @param value The value to be written.
     */
    _writeFloat32(value) {
        this._ensureEnoughVertexBufferSpace();
        this._vertexBuffer.pushFloat32(value);
    }
    /**
     * Writes an unsigned integer value to the current vertex buffer and advances
     * the offset by 4 bytes.
     *
     * @param value The value to be written.
     */
    _writeWord(value) {
        this._ensureEnoughVertexBufferSpace();
        this._vertexBuffer.pushUint32(value);
    }
    /**
     * Writes an unsigned short value to the current vertex buffer and advances
     * the offset by 2 bytes. Passed values will be truncated to 16 bits.
     *
     * @param value The value to be written.
     */
    _writeHalfWords(v1, v2) {
        this._writeWord(v2 << 16 | v1 & 0xffff);
    }
    /**
     * Writes an unsigned byte value to the current vertex buffer and advances
     * the offset by 1 byte. Passed values will be truncated to 8 bits.
     *
     * @param value The value to be written.
     */
    _writeBytes(v1, v2, v3, v4) {
        this._writeWord(v4 << 24 |
            (v3 & 0xff) << 16 |
            (v2 & 0xff) << 8 |
            v1 & 0xff);
    }
    /**
     * Encodes a world coordinate vector as a pair of 32-bit integers (splitting
     * them in turn into to 16-bit ones).
     *
     * @param c The world coordinate.
     */
    _writeWorldCoordinate(c) {
        // To avoid using GPU singed integer conversions we shift and scale world
        // coordinates so they're in [0, 1] range (instead of [-1, 1]) and then
        // encoded as unsigned 32 bit integers split into to 16 bit ones.
        const xUint32 = Object(__WEBPACK_IMPORTED_MODULE_0__gputypes__["b" /* floatToUint32 */])(0.5 * (c.x + 1));
        const yUint32 = Object(__WEBPACK_IMPORTED_MODULE_0__gputypes__["b" /* floatToUint32 */])(0.5 * (c.y + 1));
        this._writeHalfWords(xUint32 >>> 16, yUint32 >>> 16);
        this._writeHalfWords(xUint32, yUint32);
    }
    /**
     * Computes new bigger size of a vertex buffer based on its current size. By
     * default just double the current size.
     *
     * @param currentByteSize Current size of the index buffer in bytes.
     * @returns The new size.
     */
    _getNextVertexBufferByteSize(currentByteSize) {
        return currentByteSize << 1;
    }
    /**
     * Computes new bigger size of an index buffer based on its current size. By
     * default just double the current size.
     *
     * @param currentUint16Size Current size of the index buffer in shorts.
     * @returns The new size.
     */
    _getNextIndexBufferUint16Size(currentUint16Size) {
        return currentUint16Size << 1;
    }
    /**
     * Ensures that the managed vertex buffer has enough space to fit in a chunk
     * of data of a given size. Either does nothing, resizes the current vertex
     * buffer or creates entirely new pair of vertex and index buffers.
     *
     * @param valueSize Byte size of the data that needs to be accommodated by
     *      the vertex buffer.
     */
    _ensureEnoughVertexBufferSpace() {
        const vertexBuffer = this._vertexBuffer;
        if (!vertexBuffer.isFull) {
            // We have enough space, so nothing to be done.
            return;
        }
        if (vertexBuffer.byteSize < this._maxVertexBufferByteSize) {
            // If we can just resize the current vertex buffer, do that.
            this._vertexBuffer.extend(this._getNextVertexBufferByteSize(vertexBuffer.byteSize));
            return;
        }
        // If there's no enough space in the current vertex buffer and it's
        // already of maximum size, allocate new vertex and index buffers and
        // copy data of the current mesh to them from the current buffers.
        // Then make those buffer the current ones.
        const currentMeshVertexOffset = this._currentMeshVertexOffset;
        const currentMeshVertexByteSize = (vertexBuffer.occupiedSize - currentMeshVertexOffset) * 4;
        const maxVertexBufferByteSize = this._maxVertexBufferByteSize;
        if (currentMeshVertexByteSize === maxVertexBufferByteSize) {
            throw new Error('Mesh is too big to fit in.');
        }
        let newVertexBufferByteSize = this._initVertexBufferByteSize;
        // Initial vertex buffer size may be too small to accommodate the current
        // mesh, so we find next bigger size that is sufficient.
        while (newVertexBufferByteSize <= currentMeshVertexByteSize) {
            newVertexBufferByteSize = this._getNextVertexBufferByteSize(newVertexBufferByteSize);
        }
        const newVertexBuffer = new VertexBuffer(newVertexBufferByteSize);
        VertexBuffer.transferDataTail(vertexBuffer, newVertexBuffer, currentMeshVertexOffset);
        this._vertexBuffer = newVertexBuffer;
        this._vertexBuffers.push(newVertexBuffer);
        this._currentMeshVertexOffset = 0;
        const indexBuffer = this._indexBuffer;
        const currentMeshIndexOffset = this._currentMeshIndexOffset;
        const currentMeshIndexSize = indexBuffer.occupiedSize - currentMeshIndexOffset;
        let newIndexBufferSize = this._initIndexBufferUint16Size;
        // Initial index buffer size may be too small to accommodate the current
        // mesh, so we find next bigger size that is sufficient.
        while (newIndexBufferSize <= currentMeshIndexSize) {
            newIndexBufferSize = this._getNextIndexBufferUint16Size(newIndexBufferSize);
        }
        const newIndexBuffer = new IndexBuffer(newIndexBufferSize);
        // Since the current mesh's copied to the beginning of the new vertex
        // buffer, it's base index now is 0. If the mesh has any written indices,
        // they're already offset by the old base index.
        IndexBuffer.transferDataTail(indexBuffer, newIndexBuffer, this._currentMeshBaseIndex, currentMeshIndexOffset);
        this._currentMeshBaseIndex = 0;
        this._currentMeshIndexOffset = 0;
        this._indexBuffer = newIndexBuffer;
        this._indexBuffers.push(newIndexBuffer);
    }
    /**
     * Ensures that the managed index buffer has enough space to fit in a given
     * number of indices. Either does nothing or resizes the current index
     * buffer.
     *
     * @param indexCount Number of indices client wants to write to the managed
     *      index buffer.
     */
    _ensureEnoughIndexBufferSpace(indexCount) {
        const buffer = this._indexBuffer;
        const requiredSize = buffer.occupiedSize + indexCount;
        if (requiredSize <= buffer.size) {
            // We have enough space so nothing to be done.
            return;
        }
        let newBufferSize = buffer.size;
        // Let's compute new larger size of the index buffer until we can
        // accommodate incoming data.
        while (requiredSize > newBufferSize) {
            newBufferSize = this._getNextIndexBufferUint16Size(newBufferSize);
        }
        this._indexBuffer.extend(newBufferSize);
    }
}
/* harmony export (immutable) */ __webpack_exports__["b"] = BufferWriter;



/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_ref_counted__ = __webpack_require__(20);

/**
 * Base class for primitive objects that are ready to be fed to the renderer.
 */
class RenderablePrimitive extends __WEBPACK_IMPORTED_MODULE_0__util_ref_counted__["a" /* default */] {
    constructor(memorySubChunk) {
        super();
        this.memorySubChunk = memorySubChunk;
    }
    _destroy() {
        this.memorySubChunk.destroy();
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RenderablePrimitive;



/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export findInIterable */
/* harmony export (immutable) */ __webpack_exports__["c"] = mapIterable;
/* harmony export (immutable) */ __webpack_exports__["b"] = filterIterable;
/* unused harmony export reduceIterable */
/* harmony export (immutable) */ __webpack_exports__["d"] = oneOfIterable;
/* harmony export (immutable) */ __webpack_exports__["a"] = allOfIterable;
/* unused harmony export rangeIterable */
/* unused harmony export zipIterables */
/**
 * Searches for the first collection item satisfying a predicate.
 *
 * @param collection The collection.
 * @param predicate The predicate.
 * @returns The first item satisfying the predicate or `undefined` if none found.
 */
function findInIterable(collection, predicate) {
    for (const item of collection) {
        if (predicate(item)) {
            return item;
        }
    }
    return;
}
/**
 * Transforms a collection to another one.
 *
 * @param collection The source collection.
 * @param mapper A function producing items for destination collection.
 * @returns Collection of produced items.
 */
function* mapIterable(collection, mapper) {
    for (const item of collection) {
        yield mapper(item);
    }
}
/**
 * Chooses items of a collection satisfying a predicate.
 *
 * @param collection The collection.
 * @param predicate The predicate.
 * @returns Collection of chosen items.
 */
function* filterIterable(collection, predicate) {
    for (const item of collection) {
        if (predicate(item)) {
            yield item;
        }
    }
}
/**
 * Traverses a collection from left to right recomputing an accumulator on every
 * iteration.
 *
 * @param collection The collection.
 * @param reducer The function used to compute next value of the accumulator.
 * @param initial
 * @returns Value of the accumulator.
 */
function reduceIterable(collection, reducer, initial) {
    let result = initial;
    for (const item of collection) {
        result = reducer(result, item);
    }
    return result;
}
/**
 * Checks if there's at least one item in a collection satisfying a predicate.
 *
 * @param collection The collection.
 * @param predicate The predicate.
 * @returns `true` if for at least one item in the collection the predicate returns
 *      `true` and `false` otherwise.
 */
function oneOfIterable(collection, predicate) {
    for (const item of collection) {
        if (predicate(item)) {
            return true;
        }
    }
    return false;
}
/**
 * Checks if all items of a collection satisfy a predicate.
 *
 * @param collection The collection.
 * @param predicate The predicate.
 * @returns `false` if for at least one item in the collection the predicate returns
 *      `false` and `true` otherwise.
 */
function allOfIterable(collection, predicate) {
    for (const item of collection) {
        if (!predicate(item)) {
            return false;
        }
    }
    return true;
}
/**
 * Creates an iterator for [startIndex, startIndex+length) range.
 */
function* rangeIterable(length, startIndex = 0) {
    const endIndex = startIndex + length;
    for (let i = startIndex; i < endIndex; i++) {
        yield i;
    }
}
function* zipIterables(ts, us, zipper = (t, u) => [t, u]) {
    const tIterator = ts[Symbol.iterator]();
    const uIterator = us[Symbol.iterator]();
    for (let t = tIterator.next(), u = uIterator.next(); !(t.done || u.done); t = tIterator.next(), u = uIterator.next()) {
        yield zipper(t.value, u.value);
    }
}


/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = clamp;
/* harmony export (immutable) */ __webpack_exports__["b"] = cycleRestrict;
/* unused harmony export mix */
/* harmony export (immutable) */ __webpack_exports__["c"] = smoothStep;
/**
 * Clamps a value to a given range.
 *
 * @param x The value.
 * @param min Start of the range.
 * @param max End of the range.
 * @returns Clamped value.
 */
function clamp(x, min, max) {
    return min < x ? x < max ? x : max : min;
}
/**
 * Restricts a value to a given cycled range, i.e. ends of the range are
 * equivalent. E.g. like angles can be restricted to any range of size `2 * PI`.
 *
 * @param x The value.
 * @param min Start of the range.
 * @param max End of the range.
 * @returns Restricted value.
 */
function cycleRestrict(x, min, max) {
    const d = max - min;
    const s = (x - min) / (max - min);
    return min + d * (s - Math.floor(s));
}
/**
 * Linear interpolation.
 *
 * @param min Value that correspond to 0% progress.
 * @param max Value that correspond to 100% progress.
 * @param progress In 0..1.0 range that maps to 0..100% progress. It is allowed to pass a value
 *      outside of this range, that means progress greater then 100% or negative progress.
 */
function mix(min, max, progress) {
    return (1 - progress) * min + progress * max;
}
/**
 * A step function with a smooth transition between given edges. Completely
 * analogous to `smoothstep` in GLSL (GLSL ES 1.0 §8.3).
 *
 * @param edge1 The smaller edge.
 * @param edge2
 * @param x `0` if `x < edge1`, `1` if `x > edge2` and an interpolated value for
 *      `edge1 < x < edge2`.
 */
function smoothStep(edge1, edge2, x) {
    const factor = clamp((x - edge1) / (edge2 - edge1), 0, 1);
    return factor * factor * (3 - 2 * factor);
}


/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = getDpr;
/**
 * Gives the device pixel ration if it's greater than 1 and 1 otherwise. This's
 * here purely to be compatible with jsapi which does the same thing for reasons
 * unknows (thanks, kashey).
 *
 * @returns Capped device pixel ratio.
 */
function getDpr() {
    return devicePixelRatio > 1 ? devicePixelRatio : 1;
}


/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["c"] = create;
/* harmony export (immutable) */ __webpack_exports__["b"] = copy;
/* harmony export (immutable) */ __webpack_exports__["a"] = areEqual;
/* unused harmony export decodeAbgr8 */
/* harmony export (immutable) */ __webpack_exports__["d"] = encodeRgba8;
/* unused harmony export isOpaque */
const OPAQUE_BLACK = create(0, 0, 0, 1);
/* unused harmony export OPAQUE_BLACK */

const TRANSPARENT_BLACK = create(0, 0, 0, 0);
/* unused harmony export TRANSPARENT_BLACK */

/**
 * @param r Red component as a normalized value [0..1]
 * @param g Green component as a normalized value [0..1]
 * @param b Blue component as a normalized value [0..1]
 * @param a Alpha component as a normalized value [0..1]
 *
 * @returns A color with given values assigned to components.
 */
function create(r, g, b, a = 1) {
    return { r, g, b, a };
}
/**
 * Copies a color to another one.
 *
 * @param src The source color.
 * @param dst The color the source color will be copied to.
 * @returns `dst`.
 */
function copy(src, dst = create(0, 0, 0, 0)) {
    dst.r = src.r;
    dst.g = src.g;
    dst.b = src.b;
    dst.a = src.a;
    return dst;
}
function areEqual(c1, c2) {
    return c1.r === c2.r && c1.g === c2.g && c1.b === c2.b && c1.a === c2.a;
}
/**
 * Decodes a color represented as four 8-bit channels encoded into a 32-bit
 * number in ABGR order (from MSB to LSB).
 *
 * @param color Color encoded into unsigned 32-bit integer.
 * @returns Decoded color.
 */
function decodeAbgr8(color) {
    return {
        r: (color >>> 24) / 0xff,
        g: (color >>> 16 & 0xff) / 0xff,
        b: (color >>> 8 & 0xff) / 0xff,
        a: (color & 0xff) / 0xff
    };
}
/**
 * Encodes a color components into four 8 bit numbers packed into 32-bit one.
 *
 * @param c The color to be encoded.
 * @returns The color as 32-bit integer.
 */
function encodeRgba8(c) {
    return (c.r * 0xff |
        (c.g * 0xff << 8) |
        (c.b * 0xff << 16) |
        (c.a * 0xff << 24));
}
/**
 * Checks if a color is completely opaque.
 *
 * @param color The color to be checked.
 * @returns `true` if the color is opaque and `false` otherwise.
 */
function isOpaque(color) {
    return color.a === 1;
}


/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["e"] = create;
/* unused harmony export copy */
/* unused harmony export areEqual */
/* unused harmony export areFuzzyEqual */
/* unused harmony export areCollinear */
/* unused harmony export add */
/* harmony export (immutable) */ __webpack_exports__["n"] = sub;
/* harmony export (immutable) */ __webpack_exports__["j"] = mulv;
/* harmony export (immutable) */ __webpack_exports__["i"] = muln;
/* unused harmony export divv */
/* unused harmony export divn */
/* unused harmony export length */
/* unused harmony export distance */
/* harmony export (immutable) */ __webpack_exports__["k"] = normalize;
/* harmony export (immutable) */ __webpack_exports__["g"] = dot;
/* harmony export (immutable) */ __webpack_exports__["f"] = cross;
/* harmony export (immutable) */ __webpack_exports__["l"] = rotateX;
/* unused harmony export rotateY */
/* harmony export (immutable) */ __webpack_exports__["m"] = rotateZ;
/* unused harmony export getPlaneLineIntersection */
/* harmony export (immutable) */ __webpack_exports__["h"] = getPlaneRayIntersection;
/* unused harmony export getPlanePlaneIntersection */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__matrix3__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_fuzzy_equal__ = __webpack_require__(25);


/**
 * Creates a new vector and initializes it with given components.
 *
 * @param x X component of the vector.
 * @param y Y component of the vector.
 * @param z Z component of the vector.
 * @returns The vector.
 */
function create(x, y, z) {
    return { x, y, z };
}
const ORIGIN = create(0, 0, 0);
/* harmony export (immutable) */ __webpack_exports__["a"] = ORIGIN;

const POSITIVE_X = create(1, 0, 0);
/* unused harmony export POSITIVE_X */

const NEGATIVE_X = create(-1, 0, 0);
/* unused harmony export NEGATIVE_X */

const POSITIVE_Y = create(0, 1, 0);
/* harmony export (immutable) */ __webpack_exports__["b"] = POSITIVE_Y;

const NEGATIVE_Y = create(0, -1, 0);
/* unused harmony export NEGATIVE_Y */

const POSITIVE_Z = create(0, 0, 1);
/* harmony export (immutable) */ __webpack_exports__["c"] = POSITIVE_Z;

const NEGATIVE_Z = create(0, 0, -1);
/* unused harmony export NEGATIVE_Z */

/**
 * Copies a vector to another one.
 *
 * @param src The source vector.
 * @param dst The vector the source vector will be copied to.
 * @returns `dst`.
 */
function copy(src, dst = create(0, 0, 0)) {
    dst.x = src.x;
    dst.y = src.y;
    dst.z = src.z;
    return dst;
}
/**
 * Checks if two vectors are strictly equal component-wise.
 *
 * @param v1 The first vector.
 * @param v2 The second vector.
 * @returns `true` if the vectors are equal and `false` otherwise.
 */
function areEqual(v1, v2) {
    return v1.x === v2.x && v1.y === v2.y && v1.z === v2.z;
}
/**
 * Checks if corresponding components of two vectors are all within given
 * tolerance from each other.
 *
 * @param v1 The first vector.
 * @param v2 The second vector.
 * @param tolerance The tolerance.
 * @returns `true` if the vectors are "fuzzy" equal and `false` otherwise.
 */
function areFuzzyEqual(v1, v2, tolerance = __WEBPACK_IMPORTED_MODULE_1__util_fuzzy_equal__["a" /* DEFAULT_TOLERANCE */]) {
    return (Object(__WEBPACK_IMPORTED_MODULE_1__util_fuzzy_equal__["b" /* default */])(v1.x, v2.x, tolerance) &&
        Object(__WEBPACK_IMPORTED_MODULE_1__util_fuzzy_equal__["b" /* default */])(v1.y, v2.y, tolerance) &&
        Object(__WEBPACK_IMPORTED_MODULE_1__util_fuzzy_equal__["b" /* default */])(v1.z, v2.z, tolerance));
}
/**
 * Checks if two vectors are collinear.
 *
 * @param v1 The first vector.
 * @param v2 The second vector.
 * @returns `true` if the vectors are collinear and `false` otherwise.
 */
function areCollinear(v1, v2) {
    const lambdaX = v1.x / v2.x;
    const lambdaY = v1.y / v2.y;
    const lambdaZ = v1.z / v2.z;
    return lambdaX === lambdaY && lambdaY === lambdaZ;
}
/**
 * Adds two vector and stores the result into a third one, i.e. `dst = a + b`.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function add(a, b, dst = create(0, 0, 0)) {
    dst.x = a.x + b.x;
    dst.y = a.y + b.y;
    dst.z = a.z + b.z;
    return dst;
}
/**
 * Subtracts a vector from another one and stores the result to a third one, i.e.
 * `dst = a - b`.
 *
 * @param a The minuend vector.
 * @param b The subtrahend vector.
 * @param dst The vector the result will be stored to.
 */
function sub(a, b, dst = create(0, 0, 0)) {
    dst.x = a.x - b.x;
    dst.y = a.y - b.y;
    dst.z = a.z - b.z;
    return dst;
}
/**
 * Multiplies two vectors component-wise and stores the result into a third one.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function mulv(a, b, dst = create(0, 0, 0)) {
    dst.x = a.x * b.x;
    dst.y = a.y * b.y;
    dst.z = a.z * b.z;
    return dst;
}
/**
 * Multiplies a vector by a scalar and stores the result into a third vector.
 *
 * @param a The vector.
 * @param n The scalar.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function muln(a, n, dst = create(0, 0, 0)) {
    dst.x = a.x * n;
    dst.y = a.y * n;
    dst.z = a.z * n;
    return dst;
}
/**
 * Divides a vector by another one component wise and stores the result into a
 * third one.
 *
 * @param a The dividend vector.
 * @param b The divisor vector.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function divv(a, b, dst = create(0, 0, 0)) {
    dst.x = a.x / b.x;
    dst.y = a.y / b.y;
    dst.z = a.z / b.z;
    return dst;
}
/**
 * Divides a vector by a scalar and stores the result into a third vector.
 *
 * @param a The dividend vector.
 * @param n The scalar.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function divn(a, n, dst = create(0, 0, 0)) {
    dst.x = a.x / n;
    dst.y = a.y / n;
    dst.z = a.z / n;
    return dst;
}
/**
 * Computes length of a vector.
 *
 * @param v The vector.
 * @returns The length.
 */
function length(v) {
    return Math.hypot(v.x, v.y, v.z);
}
/**
 * Computes distance between ends of two vectors.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @returns The distance, i.e. `length(sub(a, b))`.
 */
function distance(a, b) {
    return Math.hypot(a.x - b.x, a.y - b.y, a.z - b.z);
}
/**
 * Divides a vector by its length (thus making it a unit vector) and stores the
 * result to another one.
 *
 * @param v The vector to be normalized.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function normalize(v, dst = create(0, 0, 0)) {
    return divn(v, length(v), dst);
}
/**
 * Computes dot product of two vectors.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @returns The dot product.
 */
function dot(a, b) {
    return a.x * b.x + a.y * b.y + a.z * b.z;
}
/**
 * Computes cross product of two vectors and stores it to a third one.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function cross(a, b, dst = create(0, 0, 0)) {
    // Write components to a separate variables so we don't produce incorrect
    // results in cases when a == dst or b == dst.
    const x = a.y * b.z - a.z * b.y;
    const y = a.z * b.x - a.x * b.z;
    const z = a.x * b.y - a.y * b.x;
    dst.x = x;
    dst.y = y;
    dst.z = z;
    return dst;
}
/**
 * Rotates vector about the X axis.
 *
 * @param v The vector to be rotated.
 * @param angle The angle of rotation (in radians), positive values rotates from +Y to +Z
 * @param dst The vector the result will be stored to.
 */
function rotateX(v, angle, dst = create(0, 0, 0)) {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    const y = v.y;
    dst.x = v.x;
    dst.y = y * cos - v.z * sin;
    dst.z = y * sin + v.z * cos;
    return dst;
}
/**
 * Rotates vector about the Y axis.
 *
 * @param v The vector to be rotated.
 * @param angle The angle of rotation (in radians), positive values rotates from +X to +Z
 * @param dst The vector the result will be stored to.
 */
function rotateY(v, angle, dst = create(0, 0, 0)) {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    // handle the case when source and destination are the same object: related components can break each other
    v = (v === dst) ? copy(v) : v;
    dst.x = v.x * cos + v.z * sin;
    dst.y = v.y;
    dst.z = -v.x * sin + v.z * cos;
    return dst;
}
/**
 * Rotates vector about the Z axis.
 *
 * @param v The vector to be rotated.
 * @param angle The angle of rotation (in radians), positive values rotates from +X to +Y
 * @param dst The vector the result will be stored to.
 */
function rotateZ(v, angle, dst = create(0, 0, 0)) {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    // handle the case when source and destination are the same object: related components can break each other
    v = (v === dst) ? copy(v) : v;
    dst.x = v.x * cos - v.y * sin;
    dst.y = v.x * sin + v.y * cos;
    dst.z = v.z;
    return dst;
}
const X_AXIS = {
    origin: ORIGIN,
    tangent: POSITIVE_X
};
/* unused harmony export X_AXIS */

const Y_AXIS = {
    origin: ORIGIN,
    tangent: POSITIVE_Y
};
/* unused harmony export Y_AXIS */

const Z_AXIS = {
    origin: ORIGIN,
    tangent: POSITIVE_Z
};
/* unused harmony export Z_AXIS */

const XY = {
    normal: POSITIVE_Z,
    distance: 0
};
/* harmony export (immutable) */ __webpack_exports__["d"] = XY;

const YZ = {
    normal: POSITIVE_X,
    distance: 0
};
/* unused harmony export YZ */

const ZX = {
    normal: POSITIVE_Y,
    distance: 0
};
/* unused harmony export ZX */

/**
 * Computes intersection of a plane and a line.
 *
 * @param p The plane.
 * @param l The line.
 * @returns The point or `null` if the line is parallel to the plane.
 */
function getPlaneLineIntersection(p, l) {
    const dotLP = dot(l.tangent, p.normal);
    // If plane normal and line tangent vector are perpendicular intersection is
    // either an empty set or the line itself.
    if (dotLP === 0) {
        return null;
    }
    const intersection = copy(l.tangent);
    muln(intersection, (p.distance - dot(p.normal, l.origin)) / dotLP, intersection);
    add(intersection, l.origin, intersection);
    return intersection;
}
/**
 * Computes an intersection of a plane and a ray and stores it into a given
 * vector.
 *
 * @param plane The plane.
 * @param ray The ray.
 * @param dst The vector the intersection point will be stored to. If there's no
 *      intersection, this vector will be left unmodified.
 * @returns The `dst` or `null` if the ray doesn't have a common point with the
 *      plane.
 */
function getPlaneRayIntersection(plane, ray, dst = create(0, 0, 0)) {
    const dotRP = dot(ray.direction, plane.normal);
    if (dotRP === 0) {
        // The plane normal and the ray direction vector are perpendicular, so
        // intersection is either an empty set or the ray itself.
        return null;
    }
    const lambda = (plane.distance - dot(plane.normal, ray.origin)) / dotRP;
    if (lambda < 0) {
        // The intersection point is on a line that contains the ray, but not on
        // the ray itself.
        return null;
    }
    copy(ray.direction, dst);
    muln(dst, lambda, dst);
    add(dst, ray.origin, dst);
    return dst;
}
/**
 * Computes intersection of two planes.
 *
 * @param p1 The first plane.
 * @param p2 The second plane.
 * @returns The line or `null` if the planes are parallel to each other.
 */
function getPlanePlaneIntersection(p1, p2) {
    const n1 = p1.normal;
    const n2 = p2.normal;
    if (areCollinear(n1, n2)) {
        return null;
    }
    const tangent = cross(n1, n2);
    normalize(tangent);
    return {
        tangent,
        origin: __WEBPACK_IMPORTED_MODULE_0__matrix3__["b" /* solve */](__WEBPACK_IMPORTED_MODULE_0__matrix3__["a" /* fromRows */](n1, n2, tangent), create(p1.distance, p2.distance, 0))
    };
}


/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["c"] = floatToUint8;
/* harmony export (immutable) */ __webpack_exports__["a"] = floatToUint16;
/* unused harmony export floatToInt16 */
/* harmony export (immutable) */ __webpack_exports__["b"] = floatToUint32;
/* unused harmony export floatToInt32 */
/* unused harmony export int32ToFloat */
/* unused harmony export uint32ToFloat */
/* unused harmony export int16ToFloat */
/* harmony export (immutable) */ __webpack_exports__["d"] = uint16ToFloat;
/* unused harmony export uint8ToFloat */
const UINT8_MAX = 0xff;
const UINT16_MAX = 0xffff;
const UINT32_MAX = 0xffffffff;
function floatToUint8(x) {
    return UINT8_MAX * x | 0;
}
function floatToUint16(x) {
    return x * UINT16_MAX | 0;
}
function floatToInt16(x) {
    return (x * UINT16_MAX - 1) / 2 | 0;
}
function floatToUint32(x) {
    return x * UINT32_MAX | 0;
}
function floatToInt32(x) {
    return (x * UINT32_MAX - 1) / 2 | 0;
}
function int32ToFloat(x) {
    return (2 * x + 1) / UINT32_MAX;
}
function uint32ToFloat(x) {
    return x / UINT32_MAX;
}
function int16ToFloat(x) {
    return (2 * x + 1) / UINT16_MAX;
}
function uint16ToFloat(x) {
    return x / UINT16_MAX;
}
function uint8ToFloat(x) {
    return x / UINT8_MAX;
}


/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["c"] = swap;
/* unused harmony export reverse */
/* unused harmony export rotate */
/* harmony export (immutable) */ __webpack_exports__["b"] = copy;
/* unused harmony export shuffle */
/* harmony export (immutable) */ __webpack_exports__["d"] = zip;
/* harmony export (immutable) */ __webpack_exports__["a"] = compare;
/* unused harmony export insertionSort */
/* unused harmony export mergeSort */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__comparator__ = __webpack_require__(19);

/**
 * Swaps two values in an array.
 *
 * @param array The array.
 * @param i Index of a value to be swapped.
 * @param j Index of a value to be swapped.
 */
function swap(array, i, j) {
    const t = array[i];
    array[i] = array[j];
    array[j] = t;
}
/**
 * Reverses order of elements in a range in an array.
 *
 * @param array The array.
 * @param start The start of the range.
 * @param end The end of the range.
 */
function reverse(array, start = 0, end = array.length) {
    for (let i = start, j = end - 1; i < j; ++i, --j) {
        swap(array, i, j);
    }
}
/**
 * Rotates a range of elements in an array by given amount.
 *
 * @param array The array.
 * @param amount The amount.
 * @param start The start of the range.
 * @param end The end of the range.
 */
function rotate(array, amount = 1, start = 0, end = array.length) {
    reverse(array, start, end);
    reverse(array, start, start + amount);
    reverse(array, start + amount, end);
}
/**
 * Copies a range of elements from a source array to a range in a destination
 * array.
 *
 * @param src The source array.
 * @param dst The destination array.
 * @param srcStart The start of the source range.
 * @param srcStart The start of the source range.
 * @param dstStart The start of the destination range.
 */
function copy(src, dst, srcStart = 0, srcEnd = src.length, dstStart = 0) {
    for (let i = srcStart, j = dstStart; i < srcEnd; ++i, ++j) {
        dst[j] = src[i];
    }
}
/**
 * Shuffles randomly a range of elements in an array.
 *
 * @param array The array.
 * @param start The start of the range.
 * @param end The end of the range.
 */
function shuffle(array, start = 0, end = array.length) {
    for (let i = start, j = i + 1; i < end; ++i, ++j) {
        swap(array, i, j + (Math.random() * (end - j) | 0));
    }
}
function zip(ts, us, zipper = (t, u) => [t, u]) {
    const l = Math.min(ts.length, us.length);
    const vs = new Array(l);
    for (let i = 0; i < l; ++i) {
        vs[i] = zipper(ts[i], us[i]);
    }
    return vs;
}
/**
 * Compares two arrays lexicographically. The order is specified be the comparator parameter.
 *
 * @param comparator Elements comparator with standard signature.
 * @param a The first array to compare.
 * @param b The second array to compare.
 * @returns 0 if all elements and lengths are equal,
 *      negative number if the first element is less then the second (lexicographically),
 *      positive number if the first element is greater then the second,
 *      if all the elements are equal the lengths are being compared.
 */
function compare(comparator, a, b) {
    const length = Math.min(a.length, b.length);
    for (let i = 0; i < length; i++) {
        const result = comparator(a[i], b[i]);
        if (result) {
            return result;
        }
    }
    return a.length - b.length;
}
/**
 * Sorts a range of elements of an array in place with insertion sort.
 *
 * @param array The array to be sorted.
 * @param comparator Comparator for array elements.
 * @param start Index of the first element in the range to be sorted.
 * @param end Index of an element behind the last element in the range to be
 *      sorted.
 */
function insertionSort(array, comparator = __WEBPACK_IMPORTED_MODULE_0__comparator__["a" /* DEFAULT_COMPARATOR */], start = 0, end = array.length) {
    for (let i = start; i < end; ++i) {
        for (let j = i; j > start && comparator(array[j - 1], array[j]) > 0; --j) {
            swap(array, j - 1, j);
        }
    }
}
const BLOCK_SIZE = 32;
/**
 * Merges two sorted ranges of an array. Stores the result into another one.
 *
 * @param src The array with the ranges to be merged.
 * @param dst The array the resulting range will be stored to.
 * @param comparator The comparator for array elements.
 * @param start Start of the first range to be merged.
 * @param middle End of the first and simultaneously start of the second range
 *      to be merged.
 * @param end End of the second range to be merged.
 * @param dstOffset Offset of merged range in the result array.
 */
function merge(src, dst, comparator, start, middle, end, dstOffset) {
    let i = dstOffset;
    let j = start;
    let k = middle;
    while (j < middle && k < end) {
        dst[i++] = comparator(src[j], src[k]) > 0 ? src[k++] : src[j++];
    }
    copy(src, dst, j, middle, i);
    copy(src, dst, k, end, i);
}
/**
 * Sorts a range of elements of an array with merge sort.
 *
 * @param array  The array to be sorted.
 * @param comparator Comparator for array elements.
 * @param end Index of an element behind the last element in the range to be
 *      sorted.
 */
function mergeSort(array, comparator = __WEBPACK_IMPORTED_MODULE_0__comparator__["a" /* DEFAULT_COMPARATOR */], start = 0, end = array.length) {
    // First and foremost: if the range is smaller than the block size, just
    // perform insertion sort on it.
    if (end - start <= BLOCK_SIZE) {
        insertionSort(array, comparator, start, end);
        return;
    }
    // First we split the given range into subranges of size BLOCK_SIZE and
    // sort every range with insertion sort.
    {
        let s = start;
        let e = s + BLOCK_SIZE;
        while (e < end) {
            insertionSort(array, comparator, s, e);
            s = e;
            e += BLOCK_SIZE;
        }
        insertionSort(array, comparator, s, end);
    }
    // TODO(dmikis): Implement in-place merge. It seems there're reasonably
    //      complex solutions out there.
    const auxArray = new Array(end - start);
    // Then we merge blocks pairs, increase block size by 2 and repeat.
    for (let blockSize = BLOCK_SIZE; blockSize < end - start; blockSize += blockSize) {
        // TODO(dmikis): Before aforementioned todo maybe implement array
        // pingponging to cut down amount of full copies.
        copy(array, auxArray, start, end);
        let i = start;
        let s = 0;
        let m = blockSize;
        let e = m + blockSize;
        while (e < end - start) {
            merge(auxArray, array, comparator, s, m, e, i);
            s = e;
            m = s + blockSize;
            e = m + blockSize;
            i += 2 * blockSize;
        }
        merge(auxArray, array, comparator, s, Math.min(m, end - start), end - start, i);
    }
}


/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = countVertices;
/* harmony export (immutable) */ __webpack_exports__["a"] = countIndices;
/**
 * @returns Integer number of vertices that fit into a region of specified in bytes size.
 */
function countVertices(vertexByteSize, attribMapping) {
    return vertexByteSize / attribMapping.vertexByteSize | 0;
}
/**
 * @returns Integer number of indices that fit into a region of specified in bytes size.
 */
function countIndices(indexByteSize, type) {
    switch (type) {
        case 5123 /* UNSIGNED_SHORT */:
            return indexByteSize >> 1;
        case 5125 /* UNSIGNED_INT */:
            return indexByteSize >> 2;
        default:
            return -1;
    }
}


/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = getTileIdByRawValues;
/* harmony export (immutable) */ __webpack_exports__["a"] = getTileId;
function getTileIdByRawValues(x, y, zoom) {
    return `${x}:${y}:${zoom}`;
}
function getTileId(tile) {
    return getTileIdByRawValues(tile.x, tile.y, tile.zoom);
}


/***/ }),
/* 17 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export messageIs */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__event_emitter__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__unique_id__ = __webpack_require__(26);
/**
 * Base interface for webworker messages, both incoming and outgoing ones.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Transferable
 */


const MESSAGE_BATCH_MAX_SIZE = 50;
const FLUSH_TIMEOUT = 50;
// each subsequent message debounces postMessage call, that can lead to infinite delay, this const limits it
const MAX_FLUSH_TIMEOUT = 250;
const NO_ID = -1;
/* harmony export (immutable) */ __webpack_exports__["a"] = NO_ID;

/**
 * Checks message type with type guarding. It gives a little bit more elegant alternative
 * to tagged type unions providing the same type safety.
 *
 * @param message to be checked
 * @param type the value of the "type" property
 * @return {boolean}
 */
function messageIs(message, type) {
    return message.type === type;
}
/**
 * Base class for both sides of a webworker: its implementation (separate js that is run in a worker thread) and
 * a controller for the main thread. They have similar mechanism of sending/receiving messages that is implement here.
 */
class WebWorkerCommunicator {
    constructor(addressee) {
        this._addressee = addressee;
        this._events = new __WEBPACK_IMPORTED_MODULE_0__event_emitter__["a" /* EventEmitter */]();
        this._listeners = new Map();
        this._transferableExtractors = new Map();
        this._messages = [];
        this._transferables = [];
        this._timeoutHandle = 0;
        this._flushMessagesBinded = this._flushMessages.bind(this);
    }
    setTransferableExtractor(type, extractor) {
        this._transferableExtractors.set(type, extractor);
    }
    /**
     * Send a message to the opposite side of the web worker communication channel.
     * Messages are batched by delaying postMessage call to group messages that come during this delay and minimize
     * the number of interprocess communications that badly affect performance.
     *
     * @param message Message to be sent.
     * @param urgency IMMEDIATE forces message to be sent immediately (synchronous call) with no batching delay,
     *                DEFAULT debounces sending for another FLUSH_TIMEOUT.
     */
    sendMessage(message, urgency = 0 /* DEFAULT */) {
        const transferableExtractor = this._transferableExtractors.get(message.type);
        const transferables = transferableExtractor ? transferableExtractor(message) : undefined;
        const isFirstMessageInBatch = (this._messages.length === 0);
        if (isFirstMessageInBatch) {
            this._firstMessageTime = performance.now();
        }
        // Send messages asynchronously packing them into one message.
        // We don't want to abuse the web worker communication channel and
        // send messages asynchronously in short period of time or many messages synchronously.
        this._messages.push(message);
        if (transferables) {
            this._transferables = this._transferables.concat(transferables);
        }
        clearTimeout(this._timeoutHandle);
        if (this._messages.length > MESSAGE_BATCH_MAX_SIZE ||
            urgency === 1 /* IMMEDIATE */ ||
            (!isFirstMessageInBatch && (performance.now() - this._firstMessageTime) > MAX_FLUSH_TIMEOUT)) {
            this._flushMessages();
        }
        else {
            this._timeoutHandle = setTimeout(this._flushMessagesBinded, FLUSH_TIMEOUT);
        }
    }
    /**
     * Sends request message to/from worker as promise, the other side can respond and the promise is resolved.
     * Request/response is synchronized by the requestId field.
     */
    request(request, urgency) {
        return new Promise((resolve, reject) => {
            if (request.requestId === NO_ID) {
                request.requestId = Object(__WEBPACK_IMPORTED_MODULE_1__unique_id__["a" /* uniqueId */])();
            }
            const listener = (message) => {
                if (messageIs(message, request.responseType) &&
                    message.requestId === request.requestId) {
                    resolve(message);
                    this._events.removeListener(listener);
                }
                if (messageIs(message, request.errorType) &&
                    message.requestId === request.requestId) {
                    reject();
                    this.off(listener);
                }
            };
            this._events.addListener(listener);
            this.sendMessage(request, urgency);
        });
    }
    /**
     * Responds to provided request.
     */
    respond(request, response, urgency) {
        response.requestId = request.requestId;
        this.sendMessage(response, urgency);
    }
    /**
     * Sets a listener to specific type of incoming messages.
     */
    on(type, listener) {
        const typeSafeListener = (message) => {
            if (messageIs(message, type)) {
                listener(message);
            }
        };
        this._listeners.set(listener, typeSafeListener);
        this._events.addListener(typeSafeListener);
    }
    /**
     * Removes incoming messages listener.
     */
    off(listener) {
        const typeSafeListener = this._listeners.get(listener);
        if (typeSafeListener) {
            this._events.removeListener(typeSafeListener);
        }
    }
    /**
     * Starts listening for incoming messages.
     */
    listen() {
        this._addressee.onmessage = ({ data: messages }) => {
            for (const message of messages) {
                this.onMessage(message);
            }
        };
    }
    /**
     * Handler of incoming messages.
     */
    onMessage(message) {
        this._events.fire(message);
    }
    _flushMessages() {
        this._addressee.postMessage(this._messages, this._transferables);
        this._messages.length = 0;
        this._transferables.length = 0;
    }
}
/* unused harmony export WebWorkerCommunicator */

/**
 * Base class for a webworker controller for the main thread code.
 * It also wraps creation of a native Worker.
 */
class WebWorkerClient extends WebWorkerCommunicator {
    /**
     * @param url URL of webworker's deployed js file
     */
    constructor(url) {
        const worker = new Worker(url);
        super(worker);
        this._worker = worker;
        this.listen();
    }
    destroy() {
        this._worker.terminate();
    }
}
/* harmony export (immutable) */ __webpack_exports__["b"] = WebWorkerClient;

/**
 * Base class for a webworker thread implementation. Concrete class should be the entry point for a webworker js build:
 *     new ConcreteWebWorkerImplementation(<DedicatedWorkerGlobalScope>self).run();
 */
class WebWorkerImplementation extends WebWorkerCommunicator {
    run() {
        this.listen();
    }
}
/* unused harmony export WebWorkerImplementation */



/***/ }),
/* 18 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = countFps;
/* harmony export (immutable) */ __webpack_exports__["b"] = countTileParseTime;
/* harmony export (immutable) */ __webpack_exports__["c"] = countTileProcessingTime;
const PROJECT_ID = 443;
function chooseStatUrl() {
    // FIXME(dmikis) Ideally we should be get this URLs from config.
    const STAT_URLS = {
        ru: 'https://yandex.ru/clck',
        com: 'https://yandex.com/clck',
        tr: 'https://yandex.com.tr/clck'
    };
    const tld = location.hostname.split('.').pop();
    switch (tld) {
        case 'tr':
            return STAT_URLS.tr;
        case 'com':
        case 'fr':
            return STAT_URLS.com;
        default:
            return STAT_URLS.ru;
    }
}
const STAT_URL = chooseStatUrl();
function stringifyVars(vars) {
    return Object.keys(vars).map((key) => `${key}=${vars[key]}`).join(',');
}
function count(pid, cid, path, vars) {
    const url = `${STAT_URL}/counter`;
    const data = `/dtype=stred/pid=${pid}/cid=${cid}` +
        `/path=${path.join('.')}/${vars ? `vars=${stringifyVars(vars)}/` : ''}`;
    if (!(navigator.sendBeacon && navigator.sendBeacon(url, data + '*'))) {
        const image = new Image();
        image.src = url + data + `rnd=${Date.now()}${Math.random() * 100 | 0}/*`;
    }
}
const PERF_COUNTER_ID = 73323;
/**
 * Log user's rendering perf to statface.
 *
 * @param fps FPS
 */
function countFps(fps) {
    const roundedFps = Math.floor(fps / 10) * 10;
    count(PROJECT_ID, PERF_COUNTER_ID, ['fps', `${roundedFps}-${roundedFps + 10}`, (fps * 100).toFixed()]);
}
function encodeTileItem(tileItem) {
    return `${tileItem.x}.${tileItem.y}.${tileItem.zoom}`;
}
function countTileParseTime(layer, minTimeTile, minTime, maxTimeTile, maxTime, medianTimeTile, medianTime) {
    count(PROJECT_ID, PERF_COUNTER_ID, [
        'tile_parse',
        layer
    ], {
        minTime: minTime.toFixed(),
        medianTime: medianTime.toFixed(),
        maxTime: maxTime.toFixed(),
        minTileItem: encodeTileItem(minTimeTile),
        medianTileItem: encodeTileItem(medianTimeTile),
        maxTileItem: encodeTileItem(maxTimeTile)
    });
}
function countTileProcessingTime(layer, items) {
    const varsToLog = {};
    items.forEach((item) => {
        if (item.zoom === 'average') {
            count(PROJECT_ID, PERF_COUNTER_ID, [
                'tile_processing_average',
                layer,
                (Math.ceil(item.time / 250) * 250).toString()
            ]);
        }
        varsToLog[item.zoom] = item.time.toFixed();
    });
    count(PROJECT_ID, PERF_COUNTER_ID, ['tile_processing', layer], varsToLog);
}


/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = DEFAULT_COMPARATOR;
/* harmony export (immutable) */ __webpack_exports__["b"] = NUMERICAL_COMPARATOR;
function DEFAULT_COMPARATOR(a, b) {
    if (a > b) {
        return 1;
    }
    if (a < b) {
        return -1;
    }
    return 0;
}
function NUMERICAL_COMPARATOR(a, b) {
    return a - b;
}


/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Simple reference counting for shared entities that need explicit destruction.
 */
class ReferenceCounted {
    /**
     * Initializes reference count to 1.
     */
    constructor() {
        this._refCount = 1;
    }
    /**
     * Increments reference count.
     */
    retain() {
        if (this._refCount === 0) {
            throw new Error('Tried to retain a destroyed object.');
        }
        this._refCount++;
    }
    /**
     * Decrements reference count and, if it's reached 0, destroys the object.
     */
    release() {
        if (this._refCount === 0) {
            throw new Error('Tried to release a destroyed object.');
        }
        this._refCount--;
        if (this._refCount === 0) {
            this._destroy();
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ReferenceCounted;



/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__primitive_manager__ = __webpack_require__(38);

/**
 * Manager of primitives that have a single assiciated renderable primitive. The "management" is pretty straightforward:
 * it directly adds/removes associated primitives into the storage.
 */
class RenderablePrimitiveManager extends __WEBPACK_IMPORTED_MODULE_0__primitive_manager__["a" /* default */] {
    constructor(primitivesStorage) {
        super();
        this._primitivesStorage = primitivesStorage;
    }
    updateScene(toShow, toHide) {
        this._primitivesStorage.add(...toShow);
        this._primitivesStorage.delete(...toHide);
    }
    destroyPrimitives(_toDestroy) {
        // no need to destroy anything, RenderablePrimitive are released when removed from primmitive storage
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RenderablePrimitiveManager;



/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_polygon_vert__ = __webpack_require__(144);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_polygon_vert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__shader_polygon_vert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_polygon_frag__ = __webpack_require__(145);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_polygon_frag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__shader_polygon_frag__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__render_state__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__world_primitive_render_unit__ = __webpack_require__(5);




const DEFAULT_RENDER_STATE_PARAMS = {
    depthTest: true,
    depthFunc: 518 /* GREATER_OR_EQUAL */
};
/* harmony export (immutable) */ __webpack_exports__["a"] = DEFAULT_RENDER_STATE_PARAMS;

/**
 * Renderer of polygon primitives.
 */
class PolygonRenderUnit extends __WEBPACK_IMPORTED_MODULE_3__world_primitive_render_unit__["a" /* default */] {
    constructor(context, primitiveProvider, renderState = new __WEBPACK_IMPORTED_MODULE_2__render_state__["c" /* default */](DEFAULT_RENDER_STATE_PARAMS)) {
        const program = context.createProgram(__WEBPACK_IMPORTED_MODULE_0__shader_polygon_vert___default.a, __WEBPACK_IMPORTED_MODULE_1__shader_polygon_frag___default.a, {
            attribMap: {
                vertexPosHigh: 0 /* POSITION_HIGH */,
                vertexPosLow: 1 /* POSITION_LOW */,
                vertexColor: 7 /* COLOR */,
                vertexZIndex: 10 /* Z_INDEX */
            }
        });
        super(context, renderState, program, primitiveProvider);
    }
}
/* harmony export (immutable) */ __webpack_exports__["b"] = PolygonRenderUnit;



/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_event_emitter__ = __webpack_require__(2);

class NoBaseRenderUnitError extends Error {
    constructor() {
        super('Base render unit is not in the list');
    }
}
/**
 * Simple implementation of CompositeRenderUnit that just runs sub units in the order of addition.
 */
class ListRenderUnit {
    constructor() {
        this.onUpdate = new __WEBPACK_IMPORTED_MODULE_0__util_event_emitter__["b" /* VoidEventEmitter */]();
        this._subRenderUnits = [];
        this._subRenderUnitUpdateListener = this._onSubRenderUnitUpdate.bind(this);
    }
    /**
     * Adds RenderUnit to the end of the list.
     */
    addRenderUnit(subRenderUnit) {
        this._subRenderUnits.push(subRenderUnit);
        subRenderUnit.onUpdate.addListener(this._subRenderUnitUpdateListener);
    }
    /**
     * Removes RenderUnit from the list.
     */
    removeRenderUnit(subRenderUnit) {
        const index = this._subRenderUnits.indexOf(subRenderUnit);
        if (index !== -1) {
            this._subRenderUnits.splice(index, 1);
            subRenderUnit.onUpdate.removeListener(this._subRenderUnitUpdateListener);
            this.onUpdate.fire();
        }
    }
    /**
     * Adds RenderUnit above the base one. "Above" means that its render() method will be called after the base's one.
     */
    addRenderUnitAbove(base, subRenderUnit) {
        const baseIndex = this._subRenderUnits.indexOf(base);
        if (baseIndex !== -1) {
            this._subRenderUnits.splice(baseIndex + 1, 0, subRenderUnit);
            subRenderUnit.onUpdate.addListener(this._subRenderUnitUpdateListener);
        }
        else {
            throw new NoBaseRenderUnitError();
        }
    }
    /**
     * Adds RenderUnit below the base one. "Below" means that its render() method will be called before the base's one.
     */
    addRenderUnitBelow(base, subRenderUnit) {
        const baseIndex = this._subRenderUnits.indexOf(base);
        if (baseIndex !== -1) {
            this._subRenderUnits.splice(baseIndex, 0, subRenderUnit);
            subRenderUnit.onUpdate.addListener(this._subRenderUnitUpdateListener);
        }
        else {
            throw new NoBaseRenderUnitError();
        }
    }
    render(target, ...args) {
        for (const renderer of this._subRenderUnits) {
            renderer.render(target, ...args);
        }
    }
    _onSubRenderUnitUpdate() {
        this.onUpdate.fire();
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ListRenderUnit;



/***/ }),
/* 24 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export create */
/* unused harmony export zero */
/* harmony export (immutable) */ __webpack_exports__["c"] = copy;
/* unused harmony export rotateX */
/* unused harmony export rotateY */
/* unused harmony export rotateZ */
/* unused harmony export translate */
/* unused harmony export scale */
/* harmony export (immutable) */ __webpack_exports__["d"] = lookAt;
/* harmony export (immutable) */ __webpack_exports__["e"] = perspective;
/* unused harmony export mul */
/* harmony export (immutable) */ __webpack_exports__["b"] = apply;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__vector3__ = __webpack_require__(12);

// TODO(dmikis) RoMatrix4?
const IDENTITY = [
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    0, 0, 0, 1
];
/* harmony export (immutable) */ __webpack_exports__["a"] = IDENTITY;

const ZERO = [
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0
];
/* unused harmony export ZERO */

const MATRIX_SIZE = 16;
/**
 * Creates and returns a new **uninitialized** matrix.
 */
function create() {
    return new Array(MATRIX_SIZE);
}
/**
 * Zeroes a matrix.
 *
 * @param dst The matrix.
 * @returns `dst`.
 */
function zero(dst = create()) {
    for (let i = 0; i < MATRIX_SIZE; ++i) {
        dst[i] = 0;
    }
    return dst;
}
/**
 * Copies a matrix to another one.
 *
 * @param src The matrix to be copied.
 * @param dst The matrix the `src` will be copied to.
 * @returns `dst`.
 */
function copy(src, dst = create()) {
    for (let i = 0; i < MATRIX_SIZE; ++i) {
        dst[i] = src[i];
    }
    return dst;
}
/**
 * Applies a rotation around the X axis by a given angle to a given matrix.
 * Positive direction is from positive Y to positive Z.
 *
 * @param src The matrix to be multiplied by the rotation matrix.
 * @param angle The angle of rotation.
 * @param dst The matrix the product will be stored to. Can be the same as `src`.
 * @returns `dst`.
 */
function rotateX(src, angle, dst = create()) {
    const angleCos = Math.cos(angle);
    const angleSin = Math.sin(angle);
    // The rotation matrix:
    //
    // 1   0    0 0
    // 0 cos -sin 0
    // 0 sin  cos 0
    // 0   0    0 1
    for (let i = 0; i < MATRIX_SIZE; i += 4) {
        dst[i] = src[i];
        const m1i = src[i + 1];
        const m2i = src[i + 2];
        dst[i + 1] = m1i * angleCos - m2i * angleSin;
        dst[i + 2] = m1i * angleSin + m2i * angleCos;
        dst[i + 3] = src[i + 3];
    }
    return dst;
}
/**
 * Applies a rotation around the Y axis by a given angle to a given matrix.
 * Positive direction is from positive X to positive Z.
 *
 * @param src The matrix to be multiplied by the rotation matrix.
 * @param angle The angle of rotation.
 * @param dst The matrix the product will be stored to. Can be the same as `src`.
 * @returns `dst`.
 */
function rotateY(src, angle, dst = create()) {
    const angleCos = Math.cos(angle);
    const angleSin = Math.sin(angle);
    // The rotation matrix:
    //
    // cos 0 -sin 0
    // 0   1    0 0
    // sin 0  cos 0
    // 0    0   0 1
    for (let i = 0; i < MATRIX_SIZE; i += 4) {
        const m0i = src[i];
        const m2i = src[i + 2];
        dst[i] = m0i * angleCos - m2i * angleSin;
        dst[i + 1] = src[i + 1];
        dst[i + 2] = m0i * angleSin + m2i * angleCos;
        dst[i + 3] = src[i + 3];
    }
    return dst;
}
/**
 * Applies a rotation around the X axis by a given angle to a given matrix.
 * Positive direction is from positive X to positive Y.
 *
 * @param src The matrix to be multiplied by the rotation matrix.
 * @param angle The angle of rotation.
 * @param dst The matrix the product will be stored to. Can be the same as `src`.
 * @returns `dst`.
 */
function rotateZ(src, angle, dst = create()) {
    const angleCos = Math.cos(angle);
    const angleSin = Math.sin(angle);
    // The rotation matrix:
    // cos -sin 0 0
    // sin  cos 0 0
    //   0    0 1 0
    //   0    0 0 1
    for (let i = 0; i < MATRIX_SIZE; i += 4) {
        const m0i = src[i];
        const m1i = src[i + 1];
        dst[i] = m0i * angleCos - m1i * angleSin;
        dst[i + 1] = m0i * angleSin + m1i * angleCos;
        dst[i + 2] = src[i + 2];
        dst[i + 3] = src[i + 3];
    }
    return dst;
}
/**
 * Applies a translation by a given vector to a given matrix.
 *
 * @param src The matrix to be multiplied by the translation matrix.
 * @param translation The translation vector.
 * @param dst The matrix the product will be stored to. Can be the same as `src`.
 * @returns `dst`.
 */
function translate(src, translation, dst = create()) {
    for (let i = 0; i < MATRIX_SIZE; i += 4) {
        const m4i = dst[i + 3] = src[i + 3];
        dst[i] = src[i] + m4i * translation.x;
        dst[i + 1] = src[i + 1] + m4i * translation.y;
        dst[i + 2] = src[i + 2] + m4i * translation.z;
    }
    return dst;
}
/**
 * Applies a scale matrix by given factors (packed into a vector) to a given
 * matrix.
 *
 * @param src The matrix to be multiplied by the scale matrix.
 * @param factor The vector the scale factors packed into.
 * @param dst The matrix the product will be stored to. Can be the same as `src`.
 * @returns `dst`.
 */
function scale(src, factor, dst = create()) {
    for (let i = 0; i < MATRIX_SIZE; i += 4) {
        dst[i] = src[i] * factor.x;
        dst[i + 1] = src[i + 1] * factor.y;
        dst[i + 2] = src[i + 2] * factor.z;
        dst[i + 3] = src[i + 3];
    }
    return dst;
}
// The matrix:
// xAxis.x yAxis.x zAxis.x -eye.x
// xAxis.y yAxis.y zAxis.y -eye.y
// xAxis.z yAxis.z zAxis.z -eye.z
//       0       0       0 1
// where xAxis, yAxis and zAxis — axes of the eye coordinate system, eye —
// origin of the eye coordinate system.
const lookAtMatrix = copy(IDENTITY);
/**
 * Applies a matrix of transformation into a coordinate system of a camera
 * defined by its position, a point it's looking at and an up direction vector.
 *
 * @param src The matrix to be multiplied by the scale matrix.
 * @param eye The position of the camera.
 * @param center The point the camera's looking at.
 * @param up The up vector.
 * @param dst The matrix the product will be stored to. Can be the same as `src`.
 * @returns `dst`.
 */
function lookAt(src, eye, center, up, dst = create()) {
    const zAxis = __WEBPACK_IMPORTED_MODULE_0__vector3__["n" /* sub */](eye, center);
    __WEBPACK_IMPORTED_MODULE_0__vector3__["k" /* normalize */](zAxis, zAxis);
    const xAxis = __WEBPACK_IMPORTED_MODULE_0__vector3__["f" /* cross */](up, zAxis);
    __WEBPACK_IMPORTED_MODULE_0__vector3__["k" /* normalize */](xAxis, xAxis);
    const yAxis = __WEBPACK_IMPORTED_MODULE_0__vector3__["f" /* cross */](zAxis, xAxis);
    lookAtMatrix[0] = xAxis.x;
    lookAtMatrix[1] = yAxis.x;
    lookAtMatrix[2] = zAxis.x;
    lookAtMatrix[4] = xAxis.y;
    lookAtMatrix[5] = yAxis.y;
    lookAtMatrix[6] = zAxis.y;
    lookAtMatrix[8] = xAxis.z;
    lookAtMatrix[9] = yAxis.z;
    lookAtMatrix[10] = zAxis.z;
    lookAtMatrix[12] = -__WEBPACK_IMPORTED_MODULE_0__vector3__["g" /* dot */](xAxis, eye);
    lookAtMatrix[13] = -__WEBPACK_IMPORTED_MODULE_0__vector3__["g" /* dot */](yAxis, eye);
    lookAtMatrix[14] = -__WEBPACK_IMPORTED_MODULE_0__vector3__["g" /* dot */](zAxis, eye);
    return mul(src, lookAtMatrix, dst);
}
/**
 * Applies a perspective matrix to a given one.
 *
 * @param src The matrix to be multiplied by the perspective matrix.
 * @param fov Vertical field of view angle.
 * @param aspectRatio Screen aspect ratio.
 * @param zNear Z-coordinate of near clipping plane.
 * @param zFar Z-coordinate of far clipping plane.
 * @param dst The matrix the product will be stored to. Can be the same as `src`.
 * @returns `dst`.
 */
function perspective(src, fov, aspect, zNear, zFar, dst = create()) {
    const p11 = 1 / Math.tan(0.5 * fov);
    const p00 = p11 / aspect;
    const p22 = (zNear + zFar) / (zNear - zFar);
    const p32 = 2 * zNear * zFar / (zNear - zFar);
    for (let i = 0; i < MATRIX_SIZE; i += 4) {
        dst[i] = src[i] * p00;
        dst[i + 1] = src[i + 1] * p11;
        const m2i = src[i + 2];
        const m3i = src[i + 3];
        dst[i + 2] = m2i * p22 + m3i * p32;
        dst[i + 3] = -m2i;
    }
    return dst;
}
/**
 * Multiplies a matrix by another one, i.e. `dst = m * src`.
 *
 * @param src The right matrix.
 * @param m The left matrix.
 * @param dst The matrix the product will be stored to. Can be the same as `src`.
 * @returns `dst`.
 */
function mul(src, m, dst = create()) {
    for (let i = 0; i < MATRIX_SIZE; i += 4) {
        const m0i = src[i];
        const m1i = src[i + 1];
        const m2i = src[i + 2];
        const m3i = src[i + 3];
        for (let j = 0; j < 4; ++j) {
            dst[i + j] = m0i * m[j] + m1i * m[4 + j] + m2i * m[8 + j] +
                m3i * m[12 + j];
        }
    }
    return dst;
}
/**
 * Applies a matrix to a vector.
 *
 * @param m The matrix.
 * @param v The vector.
 * @returns Normalized product of multiplying the vector by the matrix.
 */
function apply(m, v, dst = __WEBPACK_IMPORTED_MODULE_0__vector3__["e" /* create */](0, 0, 0)) {
    const w = m[3] * v.x + m[7] * v.y + m[11] * v.z + m[15];
    const x = (m[0] * v.x + m[4] * v.y + m[8] * v.z + m[12]) / w;
    const y = (m[1] * v.x + m[5] * v.y + m[9] * v.z + m[13]) / w;
    const z = (m[2] * v.x + m[6] * v.y + m[10] * v.z + m[14]) / w;
    dst.x = x;
    dst.y = y;
    dst.z = z;
    return dst;
}


/***/ }),
/* 25 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = areFuzzyEqual;
const DEFAULT_TOLERANCE = 1e-6;
/* harmony export (immutable) */ __webpack_exports__["a"] = DEFAULT_TOLERANCE;

/**
 * Checks if two floating point number are within a tolerance from each other.
 *
 * @param a The first number.
 * @param b The second number.
 * @param tolerance The tolerance.
 * @returns `true` if the number are within the tolerance and `false` otherwise.
 */
function areFuzzyEqual(a, b, tolerance = DEFAULT_TOLERANCE) {
    const d = a - b;
    return -tolerance < d && d < tolerance;
}


/***/ }),
/* 26 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = uniqueId;
let id = 1;
/**
 * Generates unique id
*/
function uniqueId() {
    return id++;
}


/***/ }),
/* 27 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__count_vertices__ = __webpack_require__(15);

/**
 * Represents a region in a memory chunk. Memory is allocated by big chunks for performance reasons,
 * and we need a mechanism to control those chunk's suballocation to properly free
 * the occupied memory - that is what this class is for.
 */
class MemorySubChunk {
    constructor(chunk, location) {
        this.memoryChunk = chunk;
        this._location = location;
        chunk.retain();
    }
    /**
     * @returns Offset of vertex data of the chunk in bytes.
     */
    get vertexByteOffset() {
        return this.memoryChunk.vertexByteOffset + this._location.vertexByteOffset;
    }
    /**
     * @returns Offset of index data of the chunk in bytes.
     */
    get indexByteOffset() {
        return this.memoryChunk.indexByteOffset + this._location.indexByteOffset;
    }
    /**
     * @returns Number of indexes occupied by this chunk.
     */
    get indexCount() {
        return Object(__WEBPACK_IMPORTED_MODULE_0__count_vertices__["a" /* countIndices */])(this._location.indexByteLength, this.memoryChunk.page.indexType);
    }
    /**
     * @returns Number of bytes occupied by this chunk for vertex data.
     */
    get vertexByteLength() {
        return this._location.vertexByteLength;
    }
    /**
     * @returns Number of bytes occupied by this chunk for index data.
     */
    get indexByteLength() {
        return this._location.indexByteLength;
    }
    destroy() {
        this.memoryChunk.release();
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = MemorySubChunk;



/***/ }),
/* 28 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__font__ = __webpack_require__(76);

const UNKNOWN_GLYPH = {
    id: -1,
    width: 0,
    height: 0,
    bearingX: 0,
    bearingY: 0,
    advance: 18
};
/**
 * Font whose glyphs are specified in distance field bitmaps. It's "margin" metric specifies glyph bitmap inner padding,
 * that is required to fit a "blurred" glyph image. This margin should be considered during layouting to draw glyphs of
 * proper sizes.
 */
class DfFont extends __WEBPACK_IMPORTED_MODULE_0__font__["a" /* default */] {
    constructor(id, xheight, margin) {
        super(id, xheight, UNKNOWN_GLYPH);
        this.margin = margin;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = DfFont;



/***/ }),
/* 29 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_buffer_writer__ = __webpack_require__(6);


/**
 * Base class for 3D models buffer writers. It is not supposed to write indices, instead it writes vertices (possibly
 * duplicated) in order that correspond to triangular facets of the mesh.
 */
class ModelBufferWriter extends __WEBPACK_IMPORTED_MODULE_1__util_buffer_writer__["b" /* default */] {
    constructor() {
        super(ModelBufferWriter.ATTRIBUTE_MAPPING.vertexByteSize);
    }
    /**
     * Writes a vertex to the vertex buffer.
     */
    _writeVertex(v, colorRgba8) {
        const vertexIdx = this.getCurrentVertexIdx();
        this._writeWorldCoordinate(v);
        this._writeFloat32(v.z);
        this._writeWord(colorRgba8);
        return vertexIdx;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ModelBufferWriter;

/**
 * Description of how attributes of vertices are packed into a vertex buffer.
 */
ModelBufferWriter.ATTRIBUTE_MAPPING = new __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__["a" /* AttributeMapping */]([
    [
        0 /* POSITION_HIGH */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        1 /* POSITION_LOW */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        3 /* HEIGHT */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        7 /* COLOR */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ]
]);


/***/ }),
/* 30 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = intToZIndex;
const MIN_ZINDEX = -1 + Math.pow(2, 1 - 24); // epsilon is added (for normalized 24-bit value) to free up reserved value
function intToZIndex(x) {
    return Math.max(MIN_ZINDEX, x / 0x7fffff);
}


/***/ }),
/* 31 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__ = __webpack_require__(3);

/**
 * Description of how attributes of vertices are packed into a vertex buffer.
 */
const TEXTURED_POLYGON_ATTRIBUTE_MAPPING = new __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__["a" /* AttributeMapping */]([
    [
        0 /* POSITION_HIGH */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        1 /* POSITION_LOW */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        4 /* UV */,
        {
            size: 4,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: false
        }
    ],
    [
        11 /* AUX */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        10 /* Z_INDEX */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ]
]);
/* harmony export (immutable) */ __webpack_exports__["a"] = TEXTURED_POLYGON_ATTRIBUTE_MAPPING;



/***/ }),
/* 32 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__ = __webpack_require__(3);

/**
 * Description of how attributes of vertices are packed into a vertex buffer.
 */
const POLYGON_ATTRIBUTE_MAPPING = new __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__["a" /* AttributeMapping */]([
    [
        0 /* POSITION_HIGH */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        1 /* POSITION_LOW */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        7 /* COLOR */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        10 /* Z_INDEX */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ]
]);
/* harmony export (immutable) */ __webpack_exports__["a"] = POLYGON_ATTRIBUTE_MAPPING;



/***/ }),
/* 33 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__ = __webpack_require__(3);

/**
 * Description of how attributes of vertices are packed into a vertex buffer.
 */
const POLYLINE_ATTRIBUTE_MAPPING = new __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__["a" /* AttributeMapping */]([
    /** Vertex world position. */
    [
        0 /* POSITION */,
        {
            size: 4,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    /** Normal to polyline segment the vertex belong to. */
    [
        5 /* NORMAL */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    /**
     * "UV" vertex that used to compute stroke and dashes. It's components:
     *
     *   - distance to the analytical polyline along segment's normal;
     *   - distance to the analytical polyline along segment.
     */
    [
        4 /* UV */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: false
        }
    ],
    /**
     * Vector with polyline's half width and dash style. It's components:
     *
     *   - half width;
     *   - length of a dash;
     *   - distance between dashes.
     */
    [
        11 /* AUX */,
        {
            size: 3,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    /**
     * Miter (i.e. how much displacement of the vertex is longer then the
     * normal).
     */
    [
        12 /* AUX1 */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    /**
     * Limit on displacement tangent component.Applied to avoid geometry
     * glitches in over-degenerative cases.
     */
    [
        13 /* AUX2 */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    /**
     * Distance to the first vertex along the polyline.
     */
    [
        14 /* AUX3 */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    /** Polyline's color. */
    [
        7 /* COLOR */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    /** Polyline's Z index. */
    [
        10 /* Z_INDEX */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ]
]);
/* harmony export (immutable) */ __webpack_exports__["a"] = POLYLINE_ATTRIBUTE_MAPPING;



/***/ }),
/* 34 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TileProviderMessageType; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__primitive_provider_worker_messages__ = __webpack_require__(89);

var TileProviderMessageType;
(function (TileProviderMessageType) {
    TileProviderMessageType[TileProviderMessageType["INIT"] = 0] = "INIT";
    TileProviderMessageType[TileProviderMessageType["TILE_URL_UPDATE"] = 1] = "TILE_URL_UPDATE";
    TileProviderMessageType[TileProviderMessageType["TILE_REQUEST_BATCH"] = 2] = "TILE_REQUEST_BATCH";
    TileProviderMessageType[TileProviderMessageType["TILE_REQUEST_CANCEL_BATCH"] = 3] = "TILE_REQUEST_CANCEL_BATCH";
    TileProviderMessageType[TileProviderMessageType["TILE_RESPONSE"] = 4] = "TILE_RESPONSE";
    TileProviderMessageType[TileProviderMessageType["TILE_ERROR"] = 5] = "TILE_ERROR";
    TileProviderMessageType[TileProviderMessageType["GEOMETRY_RESPONSE"] = 6] = "GEOMETRY_RESPONSE";
    TileProviderMessageType[TileProviderMessageType["LABELS_RESPONSE"] = 7] = "LABELS_RESPONSE";
    TileProviderMessageType[TileProviderMessageType["MESH_REQUEST"] = 8] = "MESH_REQUEST";
    TileProviderMessageType[TileProviderMessageType["MESH_REQUEST_CANCEL"] = 9] = "MESH_REQUEST_CANCEL";
    TileProviderMessageType[TileProviderMessageType["MESH_RESPONSE"] = 10] = "MESH_RESPONSE";
    TileProviderMessageType[TileProviderMessageType["MESH_ERROR"] = 11] = "MESH_ERROR";
})(TileProviderMessageType || (TileProviderMessageType = {}));
const geometryTransferableExtractor = function (message, transferables = []) {
    Object(__WEBPACK_IMPORTED_MODULE_0__primitive_provider_worker_messages__["a" /* extractTransferables */])(message.polygonPages, transferables);
    Object(__WEBPACK_IMPORTED_MODULE_0__primitive_provider_worker_messages__["a" /* extractTransferables */])(message.transparentPolygonPages, transferables);
    Object(__WEBPACK_IMPORTED_MODULE_0__primitive_provider_worker_messages__["a" /* extractTransferables */])(message.texturedPolygonPages, transferables);
    Object(__WEBPACK_IMPORTED_MODULE_0__primitive_provider_worker_messages__["a" /* extractTransferables */])(message.meshPages, transferables);
    Object(__WEBPACK_IMPORTED_MODULE_0__primitive_provider_worker_messages__["a" /* extractTransferables */])(message.polylinePages, transferables);
    return transferables;
};
/* unused harmony export geometryTransferableExtractor */

const meshTransferableExtractor = function (message) {
    const transferables = [];
    Object(__WEBPACK_IMPORTED_MODULE_0__primitive_provider_worker_messages__["a" /* extractTransferables */])(message.pages, transferables);
    return transferables;
};
/* unused harmony export meshTransferableExtractor */

const labelTransferableExtractor = function (message, transferables = []) {
    Object(__WEBPACK_IMPORTED_MODULE_0__primitive_provider_worker_messages__["a" /* extractTransferables */])(message.pointLabelPages, transferables);
    Object(__WEBPACK_IMPORTED_MODULE_0__primitive_provider_worker_messages__["a" /* extractTransferables */])(message.pointLabelBackgroundPages, transferables);
    Object(__WEBPACK_IMPORTED_MODULE_0__primitive_provider_worker_messages__["a" /* extractTransferables */])(message.curvedLabelPages, transferables);
    return transferables;
};
/* unused harmony export labelTransferableExtractor */

const tileTransferableExtractor = function (message) {
    const transferables = [];
    geometryTransferableExtractor(message, transferables);
    labelTransferableExtractor(message, transferables);
    return transferables;
};
/* unused harmony export tileTransferableExtractor */



/***/ }),
/* 35 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__binary_heap__ = __webpack_require__(92);

function itemComparator(a, b) {
    return a.priority - b.priority;
}
/**
 * Priority queue based on a heap.
 */
class PriorityQueue {
    /**
     * Constructs new empty priority queue.
     */
    constructor() {
        this._heap = new __WEBPACK_IMPORTED_MODULE_0__binary_heap__["a" /* default */](itemComparator);
    }
    /**
     * Adds an item into the queue.
     *
     * @param item The item.
     */
    enqueue(item) {
        this._heap.insert(item);
    }
    /**
     * Removes next item from the queue.
     *
     * @returns The next item or `undefined` if the queue's empty.
     */
    dequeue() {
        return this._heap.pop();
    }
    /**
     * Checks if the queue has no items in it.
     *
     * @returns `true` if there're no items it the queue and `false` otherwise.
     */
    isEmpty() {
        return this._heap.size === 0;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = PriorityQueue;



/***/ }),
/* 36 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__renderable_primitive__ = __webpack_require__(7);

class RenderablePolyline extends __WEBPACK_IMPORTED_MODULE_0__renderable_primitive__["a" /* default */] {
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RenderablePolyline;



/***/ }),
/* 37 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__renderable_primitive__ = __webpack_require__(7);

/**
 * A general primitive that is best suitable for storing simple colored 3D models.
 */
class RenderableModel extends __WEBPACK_IMPORTED_MODULE_0__renderable_primitive__["a" /* default */] {
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RenderableModel;



/***/ }),
/* 38 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Often primitives can't be dirrectly added into or removed from scene, there can be some specific (business) logic
 * associated with these operations. This class provides basic methods for such implementations that
 * allows to manage primitives of all types in the same manner.
 */
class PrimitiveManager {
    destroy() { }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = PrimitiveManager;



/***/ }),
/* 39 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_event_emitter__ = __webpack_require__(2);

/**
 * Primitive storage that stores primitive in a set. It acts as a primitive provider as well.
 */
class PrimitiveSetStorage {
    constructor() {
        this._primitiveSet = new Set();
        this.onUpdate = new __WEBPACK_IMPORTED_MODULE_0__util_event_emitter__["b" /* VoidEventEmitter */]();
    }
    get primitives() {
        return this._primitiveSet;
    }
    add(...primitives) {
        for (const primitive of primitives) {
            primitive.retain();
            this._primitiveSet.add(primitive);
        }
        if (primitives.length > 0) {
            this.onUpdate.fire();
        }
    }
    delete(...primitives) {
        for (const primitive of primitives) {
            if (this._primitiveSet.delete(primitive)) {
                primitive.release();
            }
        }
        if (primitives.length > 0) {
            this.onUpdate.fire();
        }
    }
    clear() {
        this._primitiveSet.clear();
        this.onUpdate.fire();
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = PrimitiveSetStorage;



/***/ }),
/* 40 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__primitive_set_storage__ = __webpack_require__(39);

/**
 * Simple primitive set storage that distinguish visible/hidden primitives. It also acts as a primitive provider.
 */
class DisappearingPrimitiveSetStorage extends __WEBPACK_IMPORTED_MODULE_0__primitive_set_storage__["a" /* default */] {
    constructor() {
        super();
        this._visiblePrimitives = new Set();
    }
    get primitives() {
        return this.visiblePrimitives;
    }
    get visiblePrimitives() {
        return this._visiblePrimitives;
    }
    add(...primitives) {
        super.add(...primitives);
        this.show(...primitives);
    }
    delete(...primitives) {
        this.hide(...primitives);
        super.delete(...primitives);
    }
    show(...primitives) {
        for (const primitive of primitives) {
            if (this._primitiveSet.has(primitive)) {
                this._visiblePrimitives.add(primitive);
            }
        }
    }
    hide(...primitives) {
        for (const primitive of primitives) {
            this._visiblePrimitives.delete(primitive);
        }
    }
    _isAllowedToShowPrimitive(primitive) {
        return this._primitiveSet.has(primitive);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = DisappearingPrimitiveSetStorage;



/***/ }),
/* 41 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
class DelegatorBase {
    constructor() {
        this._delegate = null;
    }
    setDelegate(delegate) {
        this._delegate = delegate;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = DelegatorBase;



/***/ }),
/* 42 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nvarying lowp vec4 color;\n\nvoid main(void) {\n    gl_FragColor = color;\n}\n"

/***/ }),
/* 43 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__colliding_primitive_color_id_renderer__ = __webpack_require__(112);

/**
 * "color id" renderer for labels, both for point and curved ones.
 */
class ColorIdLabelRenderer extends __WEBPACK_IMPORTED_MODULE_0__colliding_primitive_color_id_renderer__["a" /* CollidingPrimitiveColorIdRenderer */] {
    constructor(context, program, primitiveProvider, camera) {
        super(context, program, primitiveProvider);
        this._camera = camera;
    }
    _prepareProgram(program, viewProjMatrix, cameraPositions, state, stabilityShift, visibility, currentZoom) {
        super._prepareProgram(program, viewProjMatrix, cameraPositions, state, stabilityShift, visibility, currentZoom);
        program.setVector2Uniform('pixelSize', this._camera.pixelSize);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ColorIdLabelRenderer;



/***/ }),
/* 44 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = batchPrimitives;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__memory_relative_location__ = __webpack_require__(113);

/**
 * Creates batch from first primitives.
 */
function initBatch(primitive) {
    const subChunk = primitive.memorySubChunk;
    return {
        firstPrimitive: primitive,
        page: subChunk.memoryChunk.page,
        vertexByteOffset: subChunk.vertexByteOffset,
        vertexByteLength: subChunk.vertexByteLength,
        indexByteOffset: subChunk.indexByteOffset,
        indexByteLength: subChunk.indexByteLength
    };
}
/**
 * Batches primitives that can be rendered by a single draw call, that is critical for performance.
 * Performance gain from this method is possible (while it is not strictly required) if primitives
 * are sorted by memory offset and there are no many "holes" between them.
 * Minimal requiremets for batching is location in the same buffer (memory page), additional
 * requirements (such as having shared texture or similar) can be imposed in canBatchPridicate.
 */
function batchPrimitives(primitives, canBatchPridicate) {
    const canBatch = (a, b) => {
        if (
        // minimal requirements for batching is that primitives lay in the same page
        (a.memorySubChunk.memoryChunk.page !== b.memorySubChunk.memoryChunk.page) ||
            // chack external requirements if specified
            (canBatchPridicate && !canBatchPridicate(a, b))) {
            return false;
        }
        else {
            return true;
        }
    };
    return Object(__WEBPACK_IMPORTED_MODULE_0__memory_relative_location__["a" /* batchAllocatedObjects */])(primitives, (primitive) => primitive.memorySubChunk, initBatch, canBatch);
}


/***/ }),
/* 45 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_point_label_vert__ = __webpack_require__(114);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_point_label_vert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__shader_point_label_vert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_df_text_frag__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_df_text_frag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__shader_df_text_frag__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__label_render_unit__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__billboard_rectangle_billboard_rectangle_render_unit__ = __webpack_require__(115);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__util_event_emitter__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__util_iterable__ = __webpack_require__(8);






const PROGRAM_OPTIONS = {
    attribMap: {
        vertexId: 2 /* ID */,
        vertexPosHigh: 0 /* POSITION_HIGH */,
        vertexPosLow: 1 /* POSITION_LOW */,
        vertexDisplacement: 6 /* DISPLACEMENT */,
        vertexUV: 4 /* UV */,
        vertexPriority: 9 /* PRIORITY */,
        vertexColor: 7 /* COLOR */,
        vertexOutlineColor: 8 /* OUTLINE_COLOR */,
        vertexScale: 11 /* AUX */
    }
};
/* harmony export (immutable) */ __webpack_exports__["a"] = PROGRAM_OPTIONS;

/**
 * Renders backgrounds extracted from point labels.
 */
class BackgroundPrimitiveProvider {
    constructor(labelsProvider) {
        this.onUpdate = new __WEBPACK_IMPORTED_MODULE_4__util_event_emitter__["b" /* VoidEventEmitter */]();
        this._labelsProvider = labelsProvider;
    }
    get primitives() {
        return Object(__WEBPACK_IMPORTED_MODULE_5__util_iterable__["c" /* mapIterable */])(Object(__WEBPACK_IMPORTED_MODULE_5__util_iterable__["b" /* filterIterable */])(this._labelsProvider.primitives, (label) => label.background !== undefined), (label) => label.background);
    }
}
/**
 * Point labels renderer. It uses appropriate program to layout glyphs on GPU.
 */
class PointLabelRenderUnit extends __WEBPACK_IMPORTED_MODULE_2__label_render_unit__["a" /* default */] {
    constructor(context, camera, visibilityProvider, primitiveProvider) {
        const program = context.createProgram(__WEBPACK_IMPORTED_MODULE_0__shader_point_label_vert___default.a, __WEBPACK_IMPORTED_MODULE_1__shader_df_text_frag___default.a, PROGRAM_OPTIONS);
        super(context, program, camera, visibilityProvider, primitiveProvider);
        this._backgroundRenderer = new __WEBPACK_IMPORTED_MODULE_3__billboard_rectangle_billboard_rectangle_render_unit__["a" /* default */](context, camera, visibilityProvider, new BackgroundPrimitiveProvider(primitiveProvider));
        this._backgroundRenderer.onUpdate.addListener(() => this.onUpdate.fire());
    }
    render(target, viewProjMatrix, cameraPositions) {
        this._backgroundRenderer.render(target, viewProjMatrix, cameraPositions);
        super.render(target, viewProjMatrix, cameraPositions);
    }
}
/* harmony export (immutable) */ __webpack_exports__["b"] = PointLabelRenderUnit;



/***/ }),
/* 46 */
/***/ (function(module, exports) {

module.exports = "#version 100\n\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform float dpr;\nuniform sampler2D atlas;\nuniform vec2 atlasSize;\n\nvarying vec2 uv;\nvarying lowp vec4 color;\nvarying lowp vec4 outlineColor;\nvarying float scale;\n\nconst float MAX_CORRECTED_GLYPH_SCALE = 0.5;\nconst float GLYPH_BASE_WEIGHT = 0.7;\nconst float GLYPH_BASE_SMOTHNESS = 0.1;\nconst float GLYPH_WEIGHT_SCALE_IMPACT = 0.1;\nconst float GLYPH_SMOOTHNESS_SCALE_IMPACT = 0.06;\nconst float OUTLINE_WEIGHT_SCALE_IMPACT = 0.125;\n\nvoid main(void) {\n    // low scale glyphs (less than 0.5) should be a little bit bolder and smoother\n    float scaleClamped = clamp(scale, 0.0, MAX_CORRECTED_GLYPH_SCALE);\n    // weight is responsible for glyph boldness, the less weight value the bolder the text\n    float weight = GLYPH_BASE_WEIGHT + GLYPH_WEIGHT_SCALE_IMPACT * scaleClamped;\n    // smoothness is how blurred glyphs are, the less smoothness value the less blurring\n    float smoothness = (GLYPH_BASE_SMOTHNESS + GLYPH_SMOOTHNESS_SCALE_IMPACT / scaleClamped) / dpr;\n\n    vec4 resultColor = color;\n    float dist = texture2D(atlas, uv / atlasSize).a;\n    float alpha = smoothstep(weight - smoothness, weight + smoothness, dist);\n\n    if (outlineColor.a != 0.0) {\n        // to render outline the glyph is rendered a little bit bolder with different color at edges\n        weight = weight - OUTLINE_WEIGHT_SCALE_IMPACT / scale;\n        resultColor = mix(outlineColor, color, alpha);\n        alpha = smoothstep(weight - smoothness, weight + smoothness, dist);\n    }\n\n    gl_FragColor = vec4(resultColor.rgb, resultColor.a * alpha);\n}\n"

/***/ }),
/* 47 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__world_primitive_render_unit__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math_vector2__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__render_state__ = __webpack_require__(0);



/**
 * Base renderer that incapsulates all the GL specifics to make labels rendered.
 */
class LabelRenderUnit extends __WEBPACK_IMPORTED_MODULE_0__world_primitive_render_unit__["a" /* default */] {
    constructor(context, program, camera, visibilityProvider, primitiveProvider) {
        super(context, new __WEBPACK_IMPORTED_MODULE_2__render_state__["c" /* default */](__WEBPACK_IMPORTED_MODULE_2__render_state__["b" /* BLEND_OVER_RENDER_STATE */]), program, primitiveProvider);
        this._camera = camera;
        this._visibilityProvider = visibilityProvider;
        this._idHalfPxSizeUniform = __WEBPACK_IMPORTED_MODULE_1__math_vector2__["f" /* create */](0, 0);
        this._atlasSizeUniform = __WEBPACK_IMPORTED_MODULE_1__math_vector2__["f" /* create */](0, 0);
        context.bindProgram(program);
        program.setIntScalarUniform('visibility', 0);
    }
    _prepareProgram(program, viewProjMatrix, cameraPositions) {
        const visibility = this._visibilityProvider();
        super._prepareProgram(program, viewProjMatrix, cameraPositions);
        this._idHalfPxSizeUniform.x = 0.5 / visibility.getWidth();
        this._idHalfPxSizeUniform.y = 0.5 / visibility.getHeight();
        this._context.bindTextureUnit(0);
        this._context.bindTexture(visibility);
        program.setVector2Uniform('idHalfPxSize', this._idHalfPxSizeUniform);
        program.setVector2Uniform('pixelSize', this._camera.pixelSize);
        program.setScalarUniform('dpr', window.devicePixelRatio);
    }
    _renderBatch(memoryBatch) {
        const atlas = memoryBatch.firstPrimitive.atlas;
        this._atlasSizeUniform.x = atlas.width;
        this._atlasSizeUniform.y = atlas.height;
        this._program.setIntScalarUniform('atlas', 1);
        this._program.setVector2Uniform('atlasSize', this._atlasSizeUniform);
        this._context.bindTextureUnit(1);
        this._context.bindTexture(atlas.texture);
        super._renderBatch(memoryBatch);
    }
    _canBatchAdjacentPrimitives(a, b) {
        return super._canBatchAdjacentPrimitives(a, b) && (a.atlas === b.atlas);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = LabelRenderUnit;



/***/ }),
/* 48 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_curved_label_vert__ = __webpack_require__(120);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_curved_label_vert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__shader_curved_label_vert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_df_text_frag__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_df_text_frag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__shader_df_text_frag__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__label_render_unit__ = __webpack_require__(47);



const PROGRAM_OPTIONS = {
    attribMap: {
        vertexId: 2 /* ID */,
        vertexPosHigh: 0 /* POSITION_HIGH */,
        vertexPosLow: 1 /* POSITION_LOW */,
        vertexDisplacements: 6 /* DISPLACEMENT */,
        vertexUV: 4 /* UV */,
        vertexColor: 7 /* COLOR */,
        vertexOutlineColor: 8 /* OUTLINE_COLOR */,
        vertexPriority: 9 /* PRIORITY */,
        leftPolylineRatios: 12 /* AUX1 */,
        leftPolylineAngles: 13 /* AUX2 */,
        rightPolylineRatios: 14 /* AUX3 */,
        rightPolylineAngles: 15 /* AUX4 */,
        polylineLength_vertexScale: 11 /* AUX */
    }
};
/* harmony export (immutable) */ __webpack_exports__["a"] = PROGRAM_OPTIONS;

/**
 * Curved labels renderer. It uses appropriate program to layout glyphs on GPU.
 */
class CurvedLabelRenderUnit extends __WEBPACK_IMPORTED_MODULE_2__label_render_unit__["a" /* default */] {
    constructor(context, camera, visibilityProvider, primitiveProvider) {
        const program = context.createProgram(__WEBPACK_IMPORTED_MODULE_0__shader_curved_label_vert___default.a, __WEBPACK_IMPORTED_MODULE_1__shader_df_text_frag___default.a, PROGRAM_OPTIONS);
        super(context, program, camera, visibilityProvider, primitiveProvider);
    }
}
/* harmony export (immutable) */ __webpack_exports__["b"] = CurvedLabelRenderUnit;



/***/ }),
/* 49 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__world_primitive_render_unit__ = __webpack_require__(5);

/**
 * Base renderer of polyline primitives.
 */
class BasePolylineRenderUnit extends __WEBPACK_IMPORTED_MODULE_0__world_primitive_render_unit__["a" /* default */] {
    constructor(context, renderState, program, primitiveProvider, camera) {
        super(context, renderState, program, primitiveProvider);
        this._camera = camera;
    }
    _prepareProgram(program, viewProjMatrix, cameraPositions) {
        super._prepareProgram(program, viewProjMatrix, cameraPositions);
        program.setScalarUniform('worldToPxFactor', this._camera.worldToPxFactor);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = BasePolylineRenderUnit;



/***/ }),
/* 50 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__binary_tree__ = __webpack_require__(155);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__linked_set__ = __webpack_require__(156);


/**
 * Alignes an offset so it's a multiple of an alignment.
 *
 * @param offset The offset.
 * @param alignment The alignment.
 * @returns Aligned offset.
 */
function align(offset, alignment) {
    return alignment * Math.ceil(offset / alignment);
}
class ArenaAllocator {
    /**
     * Constructs a new empty arena allocator.
     *
     * @param size Size of managed region.
     * @param alignment alignment of offsets.
     */
    constructor(size, alignment = 1) {
        this._size = size;
        this._alignment = alignment;
        this._freeOffset = 0;
        this._allocatedOffsets = new Set();
    }
    get size() {
        return this._size;
    }
    get maxAllocableSize() {
        return this._size - this._freeOffset;
    }
    get isEmpty() {
        return this._allocatedOffsets.size === 0;
    }
    allocate(size) {
        if (this._size >= this._freeOffset + size) {
            const offset = this._freeOffset;
            this._freeOffset = align(offset + size, this._alignment);
            this._allocatedOffsets.add(offset);
            return offset;
        }
        else {
            return -1;
        }
    }
    deallocate(offset) {
        this._allocatedOffsets.delete(offset);
    }
    isAllocated(offset) {
        return offset < this._freeOffset;
    }
    extend(newSize) {
        if (newSize < this._freeOffset) {
            throw new Error('Could not reduce the size because it conflicts with already allocated region.');
        }
        this._size = newSize;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ArenaAllocator;

/**
 * Allocator optimised for both primary operations: allocation and deallocation. It uses BST for efficient lookup of
 * suitable free region during allocation and two way linked list for fast adjacent free regions merge.
 * Max allocable size is also determined by means of the BST.
 */
class FreeListAllocator {
    constructor(size) {
        this._size = size;
        this._allRegions = new __WEBPACK_IMPORTED_MODULE_1__linked_set__["a" /* default */]();
        this._occupiedRegions = new Map();
        this._freeRegions = new __WEBPACK_IMPORTED_MODULE_0__binary_tree__["a" /* BinarySearchTree */]((rangeA, rangeB) => rangeA.size - rangeB.size);
        const initRegion = { offset: 0, size };
        this._allRegions.insert(initRegion);
        initRegion._freeNode = this._freeRegions.insert(initRegion);
    }
    get size() {
        return this._size;
    }
    get maxAllocableSize() {
        const max = this._freeRegions.max;
        return max ? max.size : 0;
    }
    get isEmpty() {
        return this._occupiedRegions.size === 0;
    }
    allocate(size) {
        const node = this._findMinSuitable(size);
        if (!node) {
            return -1;
        }
        const range = node.value;
        // current region is not available anymore
        // it is removed from the free regions pool
        this._freeRegions.remove(node);
        // new occupied one is created
        const occupiedRange = { offset: range.offset, size };
        this._occupiedRegions.set(range.offset, occupiedRange);
        this._allRegions.insertAfter(range, occupiedRange);
        this._allRegions.remove(range);
        // dont loose remaining if any
        // it should be returned back to the free regions pool
        if (range.size > size) {
            const remainingRange = { offset: range.offset + size, size: range.size - size };
            remainingRange._freeNode = this._freeRegions.insert(remainingRange);
            this._allRegions.insertAfter(occupiedRange, remainingRange);
        }
        return occupiedRange.offset;
    }
    deallocate(offset) {
        let region = this._occupiedRegions.get(offset);
        if (region) {
            // check if the region can be merged with its previous neighbor
            const prev = this._allRegions.getPrev(region);
            if (prev && prev._freeNode) {
                const embracingRange = { offset: prev.offset, size: prev.size + region.size };
                this._allRegions.insertAfter(prev, embracingRange);
                this._allRegions.remove(region);
                this._allRegions.remove(prev);
                this._freeRegions.remove(prev._freeNode);
                region = embracingRange;
            }
            // check if the region can be merged with its next neighbor
            const next = this._allRegions.getNext(region);
            if (next && next._freeNode) {
                const embracingRange = { offset: region.offset, size: region.size + next.size };
                this._allRegions.insertBefore(next, embracingRange);
                this._allRegions.remove(region);
                this._allRegions.remove(next);
                this._freeRegions.remove(next._freeNode);
                region = embracingRange;
            }
            this._occupiedRegions.delete(offset);
            region._freeNode = this._freeRegions.insert(region);
        }
    }
    isAllocated(offset) {
        return this._occupiedRegions.has(offset);
    }
    extend(newSize) {
        if (newSize < this._size) {
            throw new Error('Size reducing is not allowed in free list allocator');
        }
        const diff = newSize - this._size;
        const last = this._allRegions.end;
        if (last && last._freeNode) {
            this._freeRegions.remove(last._freeNode);
            const region = { offset: last.offset, size: last.size + diff, isFree: true };
            this._allRegions.insertAfter(last, region);
            this._allRegions.remove(last);
            this._freeRegions.insert(region);
        }
        else {
            const region = { offset: this._size, size: diff, isFree: true };
            this._allRegions.insert(region);
            this._freeRegions.insert(region);
        }
        this._size = newSize;
    }
    /**
     * Traverses BST to find the smallest region required size can fit.
     */
    _findMinSuitable(size) {
        let node = this._freeRegions.root;
        let best;
        while (node) {
            if (node.value.size === size) {
                best = node;
                break;
            }
            else if (node.value.size < size) {
                node = node.right;
            }
            else {
                best = node;
                node = node.left;
            }
        }
        return best;
    }
}
/* harmony export (immutable) */ __webpack_exports__["b"] = FreeListAllocator;



/***/ }),
/* 51 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = calculateCameraPositions;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_vector2__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_gputypes__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_cartesian_grid__ = __webpack_require__(171);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__util_array__ = __webpack_require__(14);




// Maps world coordinates to corresponding points on the cartesian grid.
const WORLD_MIN_COORDINATE = __WEBPACK_IMPORTED_MODULE_0__math_vector2__["f" /* create */](-1, -1);
const GRID_WORLD_RATIO = 0.5;
const GRID_COORDINATES_CONVERTER = (point) => {
    const gridCoordinates = __WEBPACK_IMPORTED_MODULE_0__math_vector2__["e" /* copy */](point);
    __WEBPACK_IMPORTED_MODULE_0__math_vector2__["s" /* sub */](gridCoordinates, WORLD_MIN_COORDINATE, gridCoordinates);
    __WEBPACK_IMPORTED_MODULE_0__math_vector2__["p" /* muln */](gridCoordinates, GRID_WORLD_RATIO, gridCoordinates);
    return gridCoordinates;
};
const CAMERA_POSITION_UINT32_CONVERTER = (component) => 0.5 * (component + 1) * 0xffffffff;
const HIGH_COMPONENT_EXTRACTOR = (component) => Object(__WEBPACK_IMPORTED_MODULE_1__util_gputypes__["d" /* uint16ToFloat */])(Math.trunc(component / 0x10000));
const LOW_COMPONENT_EXTRACTOR = (component) => Object(__WEBPACK_IMPORTED_MODULE_1__util_gputypes__["d" /* uint16ToFloat */])(component & 0xffff);
const REGION_COMPARATOR = (a, b) => a.x - b.x || a.y - b.y;
const tmpCameraPosition = __WEBPACK_IMPORTED_MODULE_0__math_vector2__["f" /* create */](0, 0);
/**
 * If there are multiple worlds visible (large monitors/low zoom) primitives are rendered in multiple passes from
 * different positions (if the wrap mode of corresponding direction is REPEAT) to get correct final picture.
 * This method calculates camera positions and prepare them to be passed to the render() method.
 */
const cachedRegion = [];
const cachedPositions = [];
function calculateCameraPositions(camera) {
    const visibleRegion = camera.getVisibleRegion();
    if (__WEBPACK_IMPORTED_MODULE_3__util_array__["a" /* compare */](REGION_COMPARATOR, cachedRegion, visibleRegion) === 0) {
        return cachedPositions;
    }
    const positions = [];
    for (const worldPosition of Object(__WEBPACK_IMPORTED_MODULE_2__util_cartesian_grid__["a" /* computeSquaresCoveredByConvexPolygon */])(visibleRegion.map(GRID_COORDINATES_CONVERTER))) {
        if ((camera.options.wrapModeX === 2 /* REPEAT */ || worldPosition.x === 0) &&
            (camera.options.wrapModeY === 2 /* REPEAT */ || worldPosition.y === 0)) {
            // 2.0 converts covered square position to the world's center coordinates
            // -1.0 reverses the position of the camera to shot the world from
            __WEBPACK_IMPORTED_MODULE_0__math_vector2__["p" /* muln */](worldPosition, -1.0 * 2.0, tmpCameraPosition);
            __WEBPACK_IMPORTED_MODULE_0__math_vector2__["b" /* add */](camera.center, tmpCameraPosition, tmpCameraPosition);
            __WEBPACK_IMPORTED_MODULE_0__math_vector2__["d" /* convert */](tmpCameraPosition, CAMERA_POSITION_UINT32_CONVERTER, tmpCameraPosition);
            positions.push({
                lookAtHigh: __WEBPACK_IMPORTED_MODULE_0__math_vector2__["d" /* convert */](tmpCameraPosition, HIGH_COMPONENT_EXTRACTOR),
                lookAtLow: __WEBPACK_IMPORTED_MODULE_0__math_vector2__["d" /* convert */](tmpCameraPosition, LOW_COMPONENT_EXTRACTOR)
            });
        }
    }
    __WEBPACK_IMPORTED_MODULE_3__util_array__["b" /* copy */](positions, cachedPositions);
    cachedPositions.length = positions.length;
    cachedRegion.length = visibleRegion.length;
    for (let i = 0; i < visibleRegion.length; i++) {
        cachedRegion[i] = __WEBPACK_IMPORTED_MODULE_0__math_vector2__["e" /* copy */](visibleRegion[i], cachedRegion[i]);
    }
    return positions;
}


/***/ }),
/* 52 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec2 vertexPosition;\nattribute vec2 vertexUv;\n\nuniform float zIndex;\n\n#ifndef YV_LEAST_16b_P\n#   ifdef GL_FRAGMENT_PRECISION_HIGH\n#       define YV_LEAST_16b_P highp\n#   else\n#       define YV_LEAST_16b_P mediump\n#   endif\n#endif\n\nvarying YV_LEAST_16b_P vec2 uv;\n\nvoid main(void) {\n    gl_Position = vec4(vertexPosition, zIndex, 1);\n    uv = vertexUv;\n}\n"

/***/ }),
/* 53 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_vector_render_engine_render_context__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_vector_render_engine_camera__ = __webpack_require__(63);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_vector_render_engine_adapters_vector_api_adapter__ = __webpack_require__(67);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__camera_stuff__ = __webpack_require__(109);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__src_vector_render_engine_visibility_primitives_label_color_id_point_label_renderer__ = __webpack_require__(110);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__src_vector_render_engine_visibility_primitives_label_color_id_curved_label_renderer__ = __webpack_require__(118);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__src_vector_render_engine_render_primitives_label_point_label_render_unit__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__src_vector_render_engine_render_primitives_label_curved_label_render_unit__ = __webpack_require__(48);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__src_vector_render_engine_render_primitives_icon_icon_render_unit__ = __webpack_require__(121);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__src_vector_render_engine_render_primitives_model_model_render_unit__ = __webpack_require__(127);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__src_vector_render_engine_render_primitives_polyline_textured_polyline_render_unit__ = __webpack_require__(133);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__src_vector_render_engine_render_primitives_polyline_polyline_render_unit__ = __webpack_require__(136);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__src_vector_render_engine_render_primitives_polygon_textured_polygon_render_unit__ = __webpack_require__(140);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__src_vector_render_engine_render_primitives_polygon_transparent_polygon_render_unit__ = __webpack_require__(143);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__src_vector_render_engine_render_primitives_polygon_polygon_render_unit__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__src_vector_render_engine_map_engine__ = __webpack_require__(146);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__src_vector_render_engine_util_hd__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__src_vector_render_engine_visibility_primitives_colliding_primitive_reset_removed_renderer__ = __webpack_require__(182);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__src_vector_render_engine_render_loop__ = __webpack_require__(185);



















// import ImageRenderUnit from '../../src/vector_render_engine/render/primitives/image/image_render_unit';
// import RasterTilesAdapter from '../../src/vector_render_engine/adapters/raster_tiles/adapter';
// import {TileItem} from '../../src/vector_render_engine/adapters/tile_based_adapter/util/tile_system';
const GL_CONTEXT_ATTRIBS = {
    alpha: false,
    depth: true,
    stencil: false,
    antialias: false,
    failIfMajorPerformanceCaveat: true
};
const camera = new __WEBPACK_IMPORTED_MODULE_1__src_vector_render_engine_camera__["a" /* default */]({
    wrapModeX: 2 /* REPEAT */,
    wrapModeY: 0 /* NONE */
});
camera.onUpdate.addListener(() => Object(__WEBPACK_IMPORTED_MODULE_3__camera_stuff__["d" /* renderCameraState */])(camera));
camera.center.x = 0.20898437;
camera.center.y = 0.37304687;
camera.zoom = 14;
const canvas = document.querySelector('#canvas');
{
    const { width, height } = canvas.getBoundingClientRect();
    const dpr = Object(__WEBPACK_IMPORTED_MODULE_16__src_vector_render_engine_util_hd__["a" /* default */])();
    canvas.width = dpr * width;
    canvas.height = dpr * height;
    camera.screenSize.width = width;
    camera.screenSize.height = height;
}
const cameraMouseController = new __WEBPACK_IMPORTED_MODULE_3__camera_stuff__["a" /* CameraMouseController */](canvas, camera);
const mouseDragController = new __WEBPACK_IMPORTED_MODULE_3__camera_stuff__["b" /* MouseDragController */](canvas);
mouseDragController.setDelegate(cameraMouseController);
const scrollZoomController = new __WEBPACK_IMPORTED_MODULE_3__camera_stuff__["c" /* ScrollZoomController */](canvas);
scrollZoomController.setDelegate(cameraMouseController);
const context = __WEBPACK_IMPORTED_MODULE_0__src_vector_render_engine_render_context__["a" /* default */].createFromCanvas(canvas, GL_CONTEXT_ATTRIBS);
const engine = new __WEBPACK_IMPORTED_MODULE_15__src_vector_render_engine_map_engine__["a" /* default */](context, camera, new __WEBPACK_IMPORTED_MODULE_18__src_vector_render_engine_render_loop__["a" /* default */]());
const vectorAdapter = new __WEBPACK_IMPORTED_MODULE_2__src_vector_render_engine_adapters_vector_api_adapter__["a" /* default */](engine, camera, './tile_provider_worker.js?worker', 'map', 
// {
//     tileUrlTemplate: 'https://vec-rdr01e.tst.maps.yandex.ru/vmap2/tiles?l=vmap2&lang=ru_RU&x={{x}}&y={{y}}&z={{z}}&zmin={{zmin}}&zmax={{zmax}}',
//     imageUrlTemplate: 'https://vec-rdr01e.tst.maps.yandex.ru/resources?id={{id}}&scale={{scale}}',
//     meshUrlTemplate: 'https://vec-rdr01e.tst.maps.yandex.ru/meshes?id={{id}}',
//     glyphRangeUrlTemplate: 'https://vec-rdr01e.tst.maps.yandex.ru/glyphs?lang=ru_RU&font_id={{fontId}}&range={{range}}'
// }
{
    tileUrlTemplate: 'https://vec0{{hostAlias}}.maps.yandex.net/vmap2/tiles?l=vmap2&lang=RU_ru&x={{x}}&y={{y}}&z={{z}}&zmin={{zmin}}&zmax={{zmax}}',
    imageUrlTemplate: 'https://vec0{{hostAlias}}.maps.yandex.net/resources?id={{id}}&scale={{scale}}',
    meshUrlTemplate: 'https://vec0{{hostAlias}}.maps.yandex.net/vmap2/meshes?id={{id}}',
    glyphRangeUrlTemplate: 'https://vec0{{hostAlias}}.maps.yandex.net/glyphs?lang=RU_ru&font_id={{fontId}}&range={{range}}'
}, 1 /* X4 */);
// class TrafficLayerAdapter extends RasterTilesAdapter {
//     public _getImageUrl(tile: TileItem): string {
//         return `https://jgo.maps.yandex.net/1.1/tiles?trf&l=trf,trfe&lang=ru_UA&x=${tile.x}&y=${tile.y}&z=${tile.zoom}&scale=${window.devicePixelRatio}&tm=${Math.floor(Date.now() / 1000)}`
//         // return `https://sat03.maps.yandex.net/tiles?l=sat&v=3.419.0&x=${tile.x}&y=${tile.y}&z=${tile.zoom}&scale=${window.devicePixelRatio}&lang=ru_UA`
//     }
// }
// const trafficAdapter = new TrafficLayerAdapter(
//     engine,
//     camera,
//     {width: 256 * window.devicePixelRatio, height: 256 * window.devicePixelRatio}
// );
engine.groundLayer.addRenderUnit(new __WEBPACK_IMPORTED_MODULE_14__src_vector_render_engine_render_primitives_polygon_polygon_render_unit__["b" /* default */](context, vectorAdapter.opaquePolygonsProvider));
engine.groundLayer.addRenderUnit(new __WEBPACK_IMPORTED_MODULE_13__src_vector_render_engine_render_primitives_polygon_transparent_polygon_render_unit__["a" /* default */](context, vectorAdapter.transparentPolygonsProvider));
engine.groundLayer.addRenderUnit(new __WEBPACK_IMPORTED_MODULE_12__src_vector_render_engine_render_primitives_polygon_textured_polygon_render_unit__["a" /* default */](context, vectorAdapter.texturedPolygonsProvider));
engine.groundLayer.addRenderUnit(new __WEBPACK_IMPORTED_MODULE_11__src_vector_render_engine_render_primitives_polyline_polyline_render_unit__["a" /* default */](context, camera, vectorAdapter.polylinesProvider));
engine.groundLayer.addRenderUnit(new __WEBPACK_IMPORTED_MODULE_10__src_vector_render_engine_render_primitives_polyline_textured_polyline_render_unit__["a" /* default */](context, camera, vectorAdapter.texturedPolylinesProvider));
engine.buildingsLayer.addRenderUnit(new __WEBPACK_IMPORTED_MODULE_9__src_vector_render_engine_render_primitives_model_model_render_unit__["a" /* default */](context, vectorAdapter.modelsProvider));
// engine.iconsLayer.addRenderUnit(new ImageRenderUnit(context, trafficAdapter.imagesProvider));
engine.iconsLayer.addRenderUnit(new __WEBPACK_IMPORTED_MODULE_8__src_vector_render_engine_render_primitives_icon_icon_render_unit__["a" /* default */](context, camera, vectorAdapter.iconsProvider));
engine.labelsLayer.addRenderUnit(new __WEBPACK_IMPORTED_MODULE_7__src_vector_render_engine_render_primitives_label_curved_label_render_unit__["b" /* default */](context, camera, engine.visbilityTextureProvider, vectorAdapter.curvedLabelsProvider));
engine.labelsLayer.addRenderUnit(new __WEBPACK_IMPORTED_MODULE_6__src_vector_render_engine_render_primitives_label_point_label_render_unit__["b" /* default */](context, camera, engine.visbilityTextureProvider, vectorAdapter.pointLabelsProvider));
engine.visibilityManager.registerCollidingPrimitives(vectorAdapter.curvedLabelsProvider, new __WEBPACK_IMPORTED_MODULE_5__src_vector_render_engine_visibility_primitives_label_color_id_curved_label_renderer__["a" /* default */](context, camera, vectorAdapter.curvedLabelsProvider), new __WEBPACK_IMPORTED_MODULE_17__src_vector_render_engine_visibility_primitives_colliding_primitive_reset_removed_renderer__["a" /* CollidingPrimitivesResetRemovedRenderer */](context, vectorAdapter.curvedLabelsProvider));
engine.visibilityManager.registerCollidingPrimitives(vectorAdapter.pointLabelsProvider, new __WEBPACK_IMPORTED_MODULE_4__src_vector_render_engine_visibility_primitives_label_color_id_point_label_renderer__["a" /* default */](context, camera, vectorAdapter.pointLabelsProvider), new __WEBPACK_IMPORTED_MODULE_17__src_vector_render_engine_visibility_primitives_colliding_primitive_reset_removed_renderer__["a" /* CollidingPrimitivesResetRemovedRenderer */](context, vectorAdapter.pointLabelsProvider));
document.getElementById('plus').addEventListener('click', () => {
    camera.zoom += 0.1;
});
document.getElementById('minus').addEventListener('click', () => {
    camera.zoom -= 0.1;
});
// setTimeout(() => {
//     console.log('Setting new tile url template');
//     vectorAdapter.setTileUrlTemplate('https://vec-rdr01e.tst.maps.yandex.ru/vmap2/tiles?l=vmap2&lang=ru_RU&x={{x}}&y={{y}}&z={{z}}&zmin={{zmin}}&zmax={{zmax}}');
// }, 4000);


/***/ }),
/* 54 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__attrib_mapping__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__gl_buffer__ = __webpack_require__(56);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__gl_framebuffer__ = __webpack_require__(57);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__gl_program__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__gl_renderbuffer__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__capabilities__ = __webpack_require__(60);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__state__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__gl_texture__ = __webpack_require__(61);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__gl_vao__ = __webpack_require__(62);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__util_color__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__util_event_emitter__ = __webpack_require__(2);











const QUAD_VERTEX_DATA = new Float32Array([
    // tslint:disable
    // x   y  u  v
    -1, -1, 0, 0,
    1, 1, 1, 1,
    -1, 1, 0, 1,
    -1, -1, 0, 0,
    1, -1, 1, 0,
    1, 1, 1, 1
    // tslint:enable
]);
const QUAD_ATTRIB_MAPPING = new __WEBPACK_IMPORTED_MODULE_0__attrib_mapping__["a" /* AttributeMapping */]([
    [
        0 /* POSITION */,
        {
            size: 2,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        4 /* UV */,
        {
            size: 2,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ]
]);
/**
 * Default render target of a WebGL context, which is canvas element of the
 * context.
 */
class DefaultRenderTarget {
    constructor(gl) {
        this.isClear = false;
        this._gl = gl;
    }
    bind() {
        const gl = this._gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }
    setSize(width, height) {
        const canvas = this._gl.canvas;
        canvas.width = width;
        canvas.height = height;
    }
    getWidth() {
        return this._gl.drawingBufferWidth;
    }
    getHeight() {
        return this._gl.drawingBufferHeight;
    }
    destroy() {
        // We can't destroy default render target, so do nothing.
        // TODO(dmikis) Throw an exception?
    }
}
/* unused harmony export DefaultRenderTarget */

/**
 * Wrapper around WebGL context. Serves to localize all GL calls to minimum set
 * of objects.
 */
class RenderContext {
    /**
     * Creates a new wrapper for a given WebGL context.
     *
     * @param gl The context to be wrapped.
     */
    constructor(gl) {
        this._gl = gl;
        this.onLoss = new __WEBPACK_IMPORTED_MODULE_10__util_event_emitter__["b" /* VoidEventEmitter */]();
        this._contextLostListener = (e) => {
            e.preventDefault();
            this.onLoss.fire();
        };
        gl.canvas.addEventListener('webglcontextlost', this._contextLostListener);
        this._capabilities = new __WEBPACK_IMPORTED_MODULE_5__capabilities__["a" /* default */](gl);
        const vaoExt = gl.getExtension('OES_vertex_array_object');
        if (!vaoExt) {
            throw new Error('OES_vertex_array_object is required.');
        }
        this._vaoExt = vaoExt;
        if (!gl.getExtension('OES_standard_derivatives')) {
            throw new Error('OES_standard_derivatives is required.');
        }
        const defaultRenderTarget = this._boundRenderTarget =
            this._defaultRenderTarget =
                new DefaultRenderTarget(gl);
        const boundState = this._boundRenderState = new __WEBPACK_IMPORTED_MODULE_6__state__["c" /* default */]();
        this._unpackPremultiplyAlpha = false;
        // Default viewport and scissor rectangle sizes are equal to the size of
        // the canvas of the WebGL context. But we have no way of knowing them in
        // RenderState's constructor. So we're fixing them here.
        boundState.scissorWidth = boundState.viewportWidth =
            defaultRenderTarget.getWidth();
        boundState.scissorHeight = boundState.viewportHeight =
            defaultRenderTarget.getHeight();
        const quadBuffer = this._quadVertexBuffer =
            new __WEBPACK_IMPORTED_MODULE_1__gl_buffer__["a" /* default */](gl, gl.ARRAY_BUFFER, gl.STATIC_DRAW);
        quadBuffer.bind();
        gl.bufferData(gl.ARRAY_BUFFER, QUAD_VERTEX_DATA, gl.STATIC_DRAW);
        this._quadVao = this.createVao(QUAD_ATTRIB_MAPPING, quadBuffer, null);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        this._boundProgram = null;
        this._boundVao = null;
        this._boundTextures = new Array(this._capabilities.getMaxCombinedTextureImageUnits());
        this._boundTextures.fill(null);
        this._boundTextureUnit = 0;
    }
    /**
     * Returns object to request capabilities of the context such as maximum
     * texture size or maximum number of uniform vectors allowed in shaders.
     */
    getCapabilities() {
        return this._capabilities;
    }
    /**
     * Creates a new framebuffer with given attachments.
     *
     * @param descriptor Object containing framebuffer attachments.
     * @returns Created framebuffer object.
     */
    createFramebuffer({ color, depth, stencil, depthStencil }) {
        // TODO Uncomment and put under debug flag (when implemented)
        // if (depthStencil && (depth || stencil)) {
        //     throw new Error(
        //         'Framebuffer can\'t have DEPTH_STENCIL and DEPTH or STENCIL ' +
        //             'attachment simultaneously.'
        //     );
        // }
        const gl = this._gl;
        let width = 0;
        let height = 0;
        if (color) {
            width = color.getWidth();
            height = color.getHeight();
        }
        else if (depth) {
            width = depth.getWidth();
            height = depth.getHeight();
        }
        else if (stencil) {
            width = stencil.getWidth();
            height = stencil.getHeight();
        }
        else if (depthStencil) {
            width = depthStencil.getWidth();
            height = depthStencil.getHeight();
        }
        const framebuffer = new __WEBPACK_IMPORTED_MODULE_2__gl_framebuffer__["a" /* default */](gl, width, height);
        this.bindRenderTarget(framebuffer);
        if (color) {
            color.attachToFramebuffer(gl.COLOR_ATTACHMENT0);
        }
        if (depth) {
            depth.attachToFramebuffer(gl.DEPTH_ATTACHMENT);
        }
        if (stencil) {
            stencil.attachToFramebuffer(gl.STENCIL_ATTACHMENT);
        }
        if (depthStencil) {
            depthStencil.attachToFramebuffer(gl.DEPTH_STENCIL_ATTACHMENT);
        }
        // TODO Uncomment and put under debug flag (when implemented)
        // switch (gl.checkFramebufferStatus(gl.FRAMEBUFFER)) {
        //     case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
        //         throw new Error('Framebuffer attachments are not renderable');
        //     case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
        //         throw new Error('Framebuffer attachments are not same size');
        //     case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
        //         throw new Error('Framebuffer has no attachments');
        //     case gl.FRAMEBUFFER_UNSUPPORTED:
        //         throw new Error('Framebuffer has unsupported attachment');
        // }
        return framebuffer;
    }
    /**
     * Allocates a new renderbuffer with given size and format.
     *
     * @param width Width of the renderbuffer.
     * @param height Height of the renderbuffer.
     * @param format Format of the renderbuffer.
     * @return The allocated renderbuffer.
     *
     */
    createRenderbuffer(width, height, format) {
        const gl = this._gl;
        const renderbuffer = new __WEBPACK_IMPORTED_MODULE_4__gl_renderbuffer__["a" /* default */](gl, width, height);
        renderbuffer.bind();
        gl.renderbufferStorage(gl.RENDERBUFFER, format, width, height);
        return renderbuffer;
    }
    /**
     * Allocates a new texture with given size, format, type and parameters and
     * fills it with zeroes.
     *
     * @param width Width of the texture.
     * @param height Height of the texture.
     * @param format Pixel format of the texture.
     * @param type Pixel type of the texture.
     * @param params Parameters of the texture.
     * @returns Newly allocated texture.
     */
    createEmpty2DTexture(width, height, format, type, params = __WEBPACK_IMPORTED_MODULE_7__gl_texture__["a" /* DEFAULT_TEXTURE_PARAMS */]) {
        const texture = new __WEBPACK_IMPORTED_MODULE_7__gl_texture__["b" /* default */](this._gl, width, height, format, type, params);
        return texture;
    }
    /**
     * Creates a new shader program. Uses cache, i.e. if a program with same
     * source string and options is already created, returns it.
     *
     * @param vertexShaderSource Source code of vertex shader of the program.
     * @param fragmentShaderSource Source code of fragment shader of the program.
     * @param options Options.
     * @returns Newly created program or one from the cache.
     */
    createProgram(vertexShaderSource, fragmentShaderSource, options) {
        return new __WEBPACK_IMPORTED_MODULE_3__gl_program__["a" /* default */](this._gl, vertexShaderSource, fragmentShaderSource, options);
    }
    createVertexBuffer(size, usage = 35044 /* STATIC_DRAW */) {
        return this._createBuffer(this._gl.ARRAY_BUFFER, size, usage);
    }
    createIndexBuffer(size, usage = 35044 /* STATIC_DRAW */) {
        return this._createBuffer(this._gl.ELEMENT_ARRAY_BUFFER, size, usage);
    }
    // TODO: check https://github.com/Microsoft/TypeScript/issues/24195 to update narrowed data type according
    uploadDataToBuffer(buffer, data, offset = 0) {
        buffer.bind();
        this._gl.bufferSubData(buffer.getTarget(), offset, data);
    }
    /**
     * Creates a new vertex array object in the context.
     *
     * @param attributeMapping Mapping of vertex attrbiutes for the VAO.
     * @param vertexBuffer Vertex buffer to be bound to the VAO.
     * @param indexBuffer Index buffer to be bound to the VAO.
     * @returns The new VAO.
     */
    createVao(attributeMapping, vertexBuffer, indexBuffer) {
        const gl = this._gl;
        const vao = new __WEBPACK_IMPORTED_MODULE_8__gl_vao__["a" /* default */](gl, this._vaoExt, attributeMapping);
        vao.bind();
        if (indexBuffer) {
            indexBuffer.bind();
        }
        else {
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
        }
        vertexBuffer.bind();
        const vertexByteSize = attributeMapping.vertexByteSize;
        for (const [idx, pointer] of attributeMapping) {
            gl.enableVertexAttribArray(idx);
            gl.vertexAttribPointer(idx, pointer.size, pointer.type, pointer.normalized, vertexByteSize, pointer.offset);
        }
        this._vaoExt.bindVertexArrayOES(null);
        return vao;
    }
    /**
     * Sets new content of texture, provided data must be of length equal to "width * height" and its type
     * must correspond to texture's type {@see PixelType}.
     */
    setTextureData(texture, data) {
        const gl = this._gl;
        const width = texture.getWidth();
        const height = texture.getHeight();
        const format = texture.getFormat();
        const type = texture.getType();
        const params = texture.getParams();
        this._setTextureDataUnpackParams(params);
        this.bindTexture(texture);
        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, height, format, type, data);
        this._onTextureDataUpdated(texture);
    }
    /**
     * Sets new texture content from canvas element.
     */
    setTextureDataFromDomElement(texture, element) {
        const gl = this._gl;
        const format = texture.getFormat();
        const type = texture.getType();
        const params = texture.getParams();
        this._setTextureDataUnpackParams(params);
        this.bindTexture(texture);
        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, format, type, element);
        this._onTextureDataUpdated(texture);
    }
    /**
     * Returns default render target associated with canvas on which the WebGL
     * context operates.
     */
    getDefaultRenderTarget() {
        return this._defaultRenderTarget;
    }
    /**
     * Clears currently bound render target according to a mask.
     *
     * @param mask Bitwise OR of marks, i.e.
     *      `ClearMask.COLOR_BUFFER_BIT | ClearMask.DEPTH_BUFFER_BIT`.
     */
    clearCurrentTarget(mask) {
        if (mask) {
            this._gl.clear(mask);
            this._boundRenderTarget.isClear = true;
        }
    }
    /**
     * Binds a render target to the WebGL context if it's not already bound.
     *
     * @param target The render target to be bound.
     */
    bindRenderTarget(target) {
        if (this._boundRenderTarget !== target) {
            target.bind();
            this._boundRenderTarget = target;
        }
        // Target size could change even if target is already bound.
        // VECTOR-190
        this._setViewportState(new __WEBPACK_IMPORTED_MODULE_6__state__["c" /* default */]({
            viewportWidth: target.getWidth(),
            viewportHeight: target.getHeight()
        }));
    }
    /**
     * Binds a render state to the WebGL context with minimum amount of actual
     * state switching.
     *
     * @param state The state to be bound.
     */
    bindRenderState(state) {
        this._setColorBufferState(state);
        this._setBlendState(state);
        this._setCullFaceState(state);
        this._setFrontFaceState(state);
        this._setDepthTestState(state);
        this._setDitherState(state);
        this._setDrawBuffersState(state);
        this._setPolygonOffsetState(state);
        this._setAlphaToCoverageState(state);
        this._setSampleCoverageState(state);
        this._setStencilTestState(state);
        this._setScissorTestState(state);
        this._setViewportState(state);
    }
    /**
     * Binds a program to the WebGL context if it's not already bound.
     *
     * @param program The program to be bound.
     */
    bindProgram(program) {
        if (this._boundProgram !== program) {
            program.bind();
            this._boundProgram = program;
        }
    }
    /**
     * Binds a vertex array object to the context if it's not already bound.
     *
     * @param vao The vertex array object to bind. Passing `null` will unbind
     *      any currently bound VAO.
     */
    bindVao(vao) {
        if (this._boundVao !== vao) {
            if (vao) {
                vao.bind();
            }
            else {
                this._vaoExt.bindVertexArrayOES(null);
            }
            this._boundVao = vao;
        }
    }
    bindQuadVao() {
        this.bindVao(this._quadVao);
    }
    bindTextureUnit(unit) {
        const gl = this._gl;
        if (this._boundTextureUnit !== unit) {
            gl.activeTexture(gl.TEXTURE0 + unit);
            this._boundTextureUnit = unit;
        }
    }
    bindTexture(texture) {
        const boundUnit = this._boundTextureUnit;
        if (this._boundTextures[boundUnit] !== texture) {
            texture.bind();
            this._boundTextures[boundUnit] = texture;
        }
    }
    /**
     * Draws a quad to currently bound render target with currently bound render
     * state, program and uniform state.
     */
    drawQuad() {
        this.drawMesh(0, 6, 4 /* TRIANGLES */);
    }
    /**
     * Draws a mesh from currently bound to ARRAY_BUFFER buffer.
     *
     * @param offset Index of the vertex to start drawing from.
     * @param count Number of vertices to process.
     * @param primitiveType
     */
    drawMesh(offset, count, primitiveType = 4 /* TRIANGLES */) {
        this._gl.drawArrays(primitiveType, offset, count);
        this._boundRenderTarget.isClear = false;
    }
    /**
     * Draws a mesh to currently bound render target with currently bound render
     * state, program and uniform state.
     *
     * @param offset Offset of indices of the mesh in currently bound memory page.
     * @param indexCount Number of indices in the mesh.
     */
    drawIndexedMesh(offset, indexCount, primitiveType = 4 /* TRIANGLES */) {
        const gl = this._gl;
        gl.drawElements(primitiveType, indexCount, gl.UNSIGNED_SHORT, offset);
        this._boundRenderTarget.isClear = false;
    }
    /**
     * Destroys the context and resources owned by it. Note that resources that
     * were created with `create*` method of the context aren't exactly belong
     * to the context, entities that created them have to destroy them.
     */
    destroy() {
        this._quadVao.destroy();
        this._quadVertexBuffer.destroy();
        this._gl.canvas.removeEventListener('webglcontextlost', this._contextLostListener);
    }
    /**
     * Creates a new context from a canvas.
     *
     * @throws An error if fails to create `webgl` context for the canvas.
     * @param canvas The canvas.
     * @param attribs Attributes of the context.
     */
    static createFromCanvas(canvas, attribs) {
        const gl = canvas.getContext('webgl', attribs);
        if (!gl) {
            throw new Error('Failed to create GL context from canvas.');
        }
        return new RenderContext(gl);
    }
    /**
     * Enables or disables a WebGL capability.
     * @see https://www.khronos.org/registry/OpenGL-Refpages/es2.0/xhtml/glEnable.xml
     *
     * @param capability The capability to be enabled of disabled.
     * @param enabled New state of the capability;
     */
    _setCapabilityEnabled(capability, enabled) {
        if (enabled) {
            this._gl.enable(capability);
        }
        else {
            this._gl.disable(capability);
        }
    }
    /**
     * Sets new clear color and color mask from a state if they're different from
     * currently set ones.
     *
     * @param state The state that contains new clear color and color masks.
     */
    _setColorBufferState(state) {
        const gl = this._gl;
        const boundState = this._boundRenderState;
        const newClearColor = state.clearColor;
        if (!__WEBPACK_IMPORTED_MODULE_9__util_color__["a" /* areEqual */](boundState.clearColor, newClearColor)) {
            gl.clearColor(newClearColor.r, newClearColor.g, newClearColor.b, newClearColor.a);
            __WEBPACK_IMPORTED_MODULE_9__util_color__["b" /* copy */](newClearColor, boundState.clearColor);
        }
        if (boundState.colorMaskR !== state.colorMaskR ||
            boundState.colorMaskG !== state.colorMaskG ||
            boundState.colorMaskB !== state.colorMaskB ||
            boundState.colorMaskAlpha !== state.colorMaskAlpha) {
            this._gl.colorMask(state.colorMaskR, state.colorMaskG, state.colorMaskB, state.colorMaskAlpha);
            boundState.colorMaskR = state.colorMaskR;
            boundState.colorMaskG = state.colorMaskG;
            boundState.colorMaskB = state.colorMaskB;
            boundState.colorMaskAlpha = state.colorMaskAlpha;
        }
    }
    /**
     * Sets blend state and params.
     *
     * @param state The state that contains new blend params.
     */
    _setBlendState(state) {
        const gl = this._gl;
        const boundState = this._boundRenderState;
        if (boundState.blend !== state.blend) {
            this._setCapabilityEnabled(gl.BLEND, state.blend);
            boundState.blend = state.blend;
        }
        if (state.blend) {
            if (boundState.blendEquationRgb !== state.blendEquationRgb ||
                boundState.blendEquationAlpha !== state.blendEquationAlpha) {
                gl.blendEquationSeparate(state.blendEquationRgb, state.blendEquationAlpha);
                boundState.blendEquationRgb = state.blendEquationRgb;
                boundState.blendEquationAlpha = state.blendEquationAlpha;
            }
            if (boundState.blendFuncDstRgb !== state.blendFuncDstRgb ||
                boundState.blendFuncSrcRgb !== state.blendFuncSrcRgb ||
                boundState.blendFuncDstAlpha !== state.blendFuncDstAlpha ||
                boundState.blendFuncSrcAlpha !== state.blendFuncSrcAlpha) {
                gl.blendFuncSeparate(state.blendFuncSrcRgb, state.blendFuncDstRgb, state.blendFuncSrcAlpha, state.blendFuncDstAlpha);
                boundState.blendFuncSrcRgb = state.blendFuncSrcRgb;
                boundState.blendFuncDstRgb = state.blendFuncDstRgb;
                boundState.blendFuncSrcAlpha = state.blendFuncSrcAlpha;
                boundState.blendFuncDstAlpha = state.blendFuncDstAlpha;
            }
        }
    }
    /**
     * Sets cull face state and params.
     *
     * @param state The state that contains new cull face state and mode.
     */
    _setCullFaceState(state) {
        const gl = this._gl;
        const boundState = this._boundRenderState;
        if (boundState.cullFace !== state.cullFace) {
            this._setCapabilityEnabled(gl.CULL_FACE, state.cullFace);
            boundState.cullFace = state.cullFace;
        }
        if (state.cullFace &&
            boundState.cullFaceMode !== state.cullFaceMode) {
            gl.cullFace(state.cullFaceMode);
            boundState.cullFaceMode = state.cullFaceMode;
        }
    }
    /**
     * Sets front face mode.
     *
     * @param state The state that contains new front face mode.
     */
    _setFrontFaceState(state) {
        const boundState = this._boundRenderState;
        if (boundState.frontFaceMode !== state.frontFaceMode) {
            this._gl.frontFace(state.frontFaceMode);
            boundState.frontFaceMode = state.frontFaceMode;
        }
    }
    /**
     * Sets depth test state and params.
     *
     * @param state The state that contains new depth test state and params.
     */
    _setDepthTestState(state) {
        const gl = this._gl;
        const boundState = this._boundRenderState;
        if (boundState.depthTest !== state.depthTest) {
            this._setCapabilityEnabled(gl.DEPTH_TEST, state.depthTest);
            boundState.depthTest = state.depthTest;
        }
        if (state.depthTest) {
            if (boundState.clearDepth !== state.clearDepth) {
                gl.clearDepth(state.clearDepth);
                boundState.clearDepth = state.clearDepth;
            }
            if (boundState.depthMask !== state.depthMask) {
                gl.depthMask(state.depthMask);
                boundState.depthMask = state.depthMask;
            }
            if (boundState.depthFunc !== state.depthFunc) {
                gl.depthFunc(state.depthFunc);
                boundState.depthFunc = state.depthFunc;
            }
            if (boundState.depthRangeNear !== state.depthRangeNear ||
                boundState.depthRangeFar !== state.depthRangeFar) {
                gl.depthRange(state.depthRangeNear, state.depthRangeFar);
                boundState.depthRangeNear = state.depthRangeNear;
                boundState.depthRangeFar = state.depthRangeFar;
            }
        }
    }
    /**
     * Sets dither state.
     *
     * @param state The state that contains new dither state.
     */
    _setDitherState(state) {
        const boundState = this._boundRenderState;
        if (boundState.dither !== state.dither) {
            this._setCapabilityEnabled(this._gl.DITHER, state.dither);
            boundState.dither = state.dither;
        }
    }
    /**
     * Sets draw buffers.
     *
     * @param state The state that contains array of draw buffers.
     */
    _setDrawBuffersState(state) {
        const boundDrawBuffers = this._boundRenderState.drawBuffers;
        if (boundDrawBuffers.length !== state.drawBuffers.length ||
            boundDrawBuffers
                .some((attachment, i) => attachment !== state.drawBuffers[i])) {
            this._boundRenderState.drawBuffers = state.drawBuffers.slice();
        }
    }
    /**
     * Sets polygon offset state and params.
     *
     * @param state The state that contains new polygon offset state and params.
     */
    _setPolygonOffsetState(state) {
        const gl = this._gl;
        const boundState = this._boundRenderState;
        if (boundState.polygonOffset !== state.polygonOffset) {
            this._setCapabilityEnabled(gl.POLYGON_OFFSET_FILL, state.polygonOffset);
            boundState.polygonOffset = state.polygonOffset;
        }
        if (state.polygonOffset &&
            (boundState.polygonOffsetFactor !== state.polygonOffsetFactor ||
                boundState.polygonOffsetUnits !== state.polygonOffsetUnits)) {
            gl.polygonOffset(state.polygonOffsetFactor, state.polygonOffsetUnits);
            boundState.polygonOffsetFactor = state.polygonOffsetFactor;
            boundState.polygonOffsetUnits = state.polygonOffsetUnits;
        }
    }
    /**
     * Sets alpha-to-coverage state.
     *
     * @param state The state that contains new alpha-to-coverage state.
     */
    _setAlphaToCoverageState(state) {
        const boundState = this._boundRenderState;
        if (boundState.sampleAlphaToCoverage !== state.sampleAlphaToCoverage) {
            this._setCapabilityEnabled(this._gl.SAMPLE_ALPHA_TO_COVERAGE, state.sampleAlphaToCoverage);
            boundState.sampleAlphaToCoverage = state.sampleAlphaToCoverage;
        }
    }
    /**
     * Sets sample coverage state.
     *
     * @param state The state that contains new sample coverage state and params.
     */
    _setSampleCoverageState(state) {
        const gl = this._gl;
        const boundState = this._boundRenderState;
        if (boundState.sampleCoverage !== state.sampleCoverage) {
            this._setCapabilityEnabled(gl.SAMPLE_COVERAGE, state.sampleCoverage);
            boundState.sampleCoverage = state.sampleCoverage;
        }
        if (state.sampleCoverage &&
            (boundState.sampleCoverageValue !== state.sampleCoverageValue ||
                boundState.sampleCoverageInvert !== state.sampleCoverageInvert)) {
            gl.sampleCoverage(state.sampleCoverageValue, state.sampleCoverageInvert);
            boundState.sampleCoverageValue = state.sampleCoverageValue;
            boundState.sampleCoverageInvert = state.sampleCoverageInvert;
        }
    }
    /**
     * Sets stencil test state and params.
     *
     * @param state The state that contains new stencil test state and params.
     */
    _setStencilTestState(state) {
        const gl = this._gl;
        const boundState = this._boundRenderState;
        if (boundState.stencilTest !== state.stencilTest) {
            this._setCapabilityEnabled(gl.STENCIL_TEST, state.stencilTest);
            boundState.stencilTest = state.stencilTest;
        }
        if (state.stencilTest) {
            if (boundState.clearStencil !== state.clearStencil) {
                gl.clearStencil(state.clearStencil);
                boundState.clearStencil = state.clearStencil;
            }
            if (boundState.stencilWriteMask !== state.stencilWriteMask) {
                gl.stencilMask(state.stencilWriteMask);
                boundState.stencilWriteMask = state.stencilWriteMask;
            }
            const refOrMaskIsDifferent = (boundState.stencilMask !== state.stencilMask ||
                boundState.stencilReference !== state.stencilReference);
            if (refOrMaskIsDifferent) {
                boundState.stencilMask = state.stencilMask;
                boundState.stencilReference = state.stencilReference;
            }
            if (boundState.stencilFrontFunc !== state.stencilFrontFunc ||
                refOrMaskIsDifferent) {
                gl.stencilFuncSeparate(gl.FRONT, state.stencilFrontFunc, state.stencilReference, state.stencilMask);
                boundState.stencilFrontFunc = state.stencilFrontFunc;
            }
            if (boundState.stencilBackFunc !== state.stencilBackFunc ||
                refOrMaskIsDifferent) {
                gl.stencilFuncSeparate(gl.BACK, state.stencilBackFunc, state.stencilReference, state.stencilMask);
                boundState.stencilBackFunc = state.stencilBackFunc;
            }
            if (boundState.stencilFrontFailOp !== state.stencilFrontFailOp ||
                boundState.stencilFrontDepthFailOp !== state.stencilFrontDepthFailOp ||
                boundState.stencilFrontDepthPassOp !== state.stencilFrontDepthPassOp) {
                gl.stencilOpSeparate(gl.FRONT, state.stencilFrontFailOp, state.stencilFrontDepthFailOp, state.stencilFrontDepthPassOp);
                boundState.stencilFrontFailOp = state.stencilFrontFailOp;
                boundState.stencilFrontDepthFailOp = state.stencilFrontDepthFailOp;
                boundState.stencilFrontDepthPassOp = state.stencilFrontDepthPassOp;
            }
            if (boundState.stencilBackFailOp !== state.stencilBackFailOp ||
                boundState.stencilBackDepthFailOp !== state.stencilBackDepthFailOp ||
                boundState.stencilBackDepthPassOp !== state.stencilBackDepthPassOp) {
                gl.stencilOpSeparate(gl.BACK, state.stencilBackFailOp, state.stencilBackDepthFailOp, state.stencilBackDepthPassOp);
                boundState.stencilBackFailOp = state.stencilBackFailOp;
                boundState.stencilBackDepthFailOp = state.stencilBackDepthFailOp;
                boundState.stencilBackDepthPassOp = state.stencilBackDepthPassOp;
            }
        }
    }
    /**
     * Sets scissor test state and scissor rectangle.
     *
     * @param state The state that contains new scissor test state and scissor
     *      rectangle.
     */
    _setScissorTestState(state) {
        const gl = this._gl;
        const boundState = this._boundRenderState;
        if (boundState.scissorTest !== state.scissorTest) {
            this._setCapabilityEnabled(gl.SCISSOR_TEST, state.scissorTest);
            boundState.scissorTest = state.scissorTest;
        }
        if (state.scissorTest &&
            state.scissorWidth >= 0 &&
            state.scissorHeight >= 0 &&
            (boundState.scissorX !== state.scissorX ||
                boundState.scissorY !== state.scissorY ||
                boundState.scissorWidth !== state.scissorWidth ||
                boundState.scissorHeight !== state.scissorHeight)) {
            gl.scissor(state.scissorX, state.scissorY, state.scissorWidth, state.scissorHeight);
            boundState.scissorX = state.scissorX;
            boundState.scissorY = state.scissorY;
            boundState.scissorWidth = state.scissorWidth;
            boundState.scissorHeight = state.scissorHeight;
        }
    }
    /**
     * Sets viewport.
     *
     * @param state The state that contains new viewport.
     */
    _setViewportState(state) {
        const boundState = this._boundRenderState;
        if (state.viewportWidth >= 0 &&
            state.viewportHeight >= 0 &&
            (boundState.viewportX !== state.viewportX ||
                boundState.viewportY !== state.viewportY ||
                boundState.viewportWidth !== state.viewportWidth ||
                boundState.viewportHeight !== state.viewportHeight)) {
            this._gl.viewport(state.viewportX, state.viewportY, state.viewportWidth, state.viewportHeight);
            boundState.viewportX = state.viewportX;
            boundState.viewportY = state.viewportY;
            boundState.viewportWidth = state.viewportWidth;
            boundState.viewportHeight = state.viewportHeight;
        }
    }
    /**
     * Sets texture data unpack params.
     *
     * @param params Texture params to be set.
     */
    _setTextureDataUnpackParams(params) {
        const gl = this._gl;
        if (this._unpackPremultiplyAlpha !== params.premultipliedAlpha) {
            gl.pixelStorei(37441 /* UNPACK_PREMULTIPLY_ALPHA_WEBGL */, +params.premultipliedAlpha);
            this._unpackPremultiplyAlpha = params.premultipliedAlpha;
        }
    }
    _onTextureDataUpdated(texture) {
        const gl = this._gl;
        const params = texture.getParams();
        if (params.minificationFilter >= 9984 /* NEAREST_MIPMAP_NEAREST */) {
            gl.generateMipmap(gl.TEXTURE_2D);
        }
    }
    /**
     * Creates a new zeroed buffer with a given size and a target.
     *
     * @param target The target of the new buffer, `ARRAY_BUFFER` or
     *      `ELEMENT_ARRAY_BUFFER`.
     * @param size The size of the buffer.
     * @param usage Usage of the buffer.
     * @returns The buffer.
     */
    _createBuffer(target, size, usage = this._gl.STATIC_DRAW) {
        const gl = this._gl;
        const buffer = new __WEBPACK_IMPORTED_MODULE_1__gl_buffer__["a" /* default */](gl, target, size);
        // TODO(dmikis) a cleverer way not to break currently bound VAO;
        this.bindVao(null);
        buffer.bind();
        gl.bufferData(target, size, usage);
        return buffer;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RenderContext;



/***/ }),
/* 55 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export isPowOf2 */
/* harmony export (immutable) */ __webpack_exports__["a"] = align;
/**
 * Checks if a number is a power of 2.
 *
 * @param x The number to check.
 * @returns `true` if the number is an integer power of 2 and `false` otherwise.
 */
function isPowOf2(x) {
    return x > 0 && !(x & (x - 1));
}
/**
 * Aligns an offset by an alignment given by a mask.
 *
 * @param offset The offset.
 * @param alignmentMask The alignment mask — a bit field that has `log2(alignment)`
 *      of least significant bits unset and other set, e.g. if `alignment` is 4
 *      then the `alignmentMask` will be `0xffffffc`
 * @returns Aligned offset.
 */
function align(offset, alignmentMask) {
    return (offset - 1 & alignmentMask) - alignmentMask;
}


/***/ }),
/* 56 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/** Wrapper around WebGLBuffer object. */
class Buffer {
    /**
     * Creates a new empty buffer in a WebGL context.
     *
     * @param gl The context the buffer will be created in.
     * @param target Binding target of the buffer. Since in WebGL once you've
     *      bound a buffer to a given target you can't bind it any other one,
     *      we "tie" the buffer and it's binding point together.
     * @param size Size of the buffer. We don't do actual allocation in the
     *      wrapper, it's context's responsibility. But it's convenient to be
     *      able to get the size from the wrapper object.
     */
    constructor(gl, target, size) {
        this._gl = gl;
        this._target = target;
        this._handle = gl.createBuffer();
        this._size = size;
    }
    /** Binds the buffer to the context to its binding target. */
    bind() {
        this._gl.bindBuffer(this._target, this._handle);
    }
    /**
     * Returns `true` if the buffer is currently bound to the context to its
     * binding target and `false` otherwise.
     */
    isBound() {
        const gl = this._gl;
        const handle = this._handle;
        switch (this._target) {
            case gl.ARRAY_BUFFER:
                return gl.getParameter(gl.ARRAY_BUFFER_BINDING) === handle;
            case gl.ELEMENT_ARRAY_BUFFER:
                return gl.getParameter(gl.ELEMENT_ARRAY_BUFFER_BINDING) === handle;
        }
        return false;
    }
    /** Returns binding target of the buffer. */
    getTarget() {
        return this._target;
    }
    /** Returns size of the buffer. */
    getSize() {
        return this._size;
    }
    /**
     * Destroys the buffer.
     */
    destroy() {
        this._gl.deleteBuffer(this._handle);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Buffer;



/***/ }),
/* 57 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/** Wrapper around WebGLFramebuffer object. */
class Framebuffer {
    /**
     * Creates a new framebuffer in a WebGL context.
     *
     * @param gl The context the framebuffer will be created in.
     * @param width Width of the framebuffer.
     * @param height Height of the framebuffer.
     */
    constructor(gl, width, height) {
        this.isClear = false;
        this._gl = gl;
        this._handle = gl.createFramebuffer();
        this._width = width;
        this._height = height;
    }
    /**
     * Binds the framebuffer to the WebGL context.
     */
    bind() {
        const gl = this._gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._handle);
    }
    /**
     * Checks if the framebuffer is bound to the WebGL context.
     *
     * @returns `true` if the framebuffer is currently bound to the WebGL context
     *      and `false` otherwise.
     */
    isBound() {
        const gl = this._gl;
        return gl.getParameter(gl.FRAMEBUFFER_BINDING) === this._handle;
    }
    /**
     * Returns width of the framebuffer.
     */
    getWidth() {
        return this._width;
    }
    /**
     * Returns height of the framebuffer.
     */
    getHeight() {
        return this._height;
    }
    /**
     * Reads content of the color attachment as an RGBA bitmap.
     */
    readPixels() {
        const data = new Uint8Array(this.getWidth() * this.getHeight() * 4);
        this._gl.readPixels(0, 0, this._width, this._height, 6408 /* RGBA */, 5121 /* UNSIGNED_BYTE */, data);
        return data;
    }
    /**
     * Destroys the framebuffer.
     */
    destroy() {
        this._gl.deleteFramebuffer(this._handle);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Framebuffer;



/***/ }),
/* 58 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Inserts given parameters as preprocessor define directives into shader source.
 *
 * @param source Shader source.
 * @param defines Dictionary with parameters to define with preprocessor directives.
 * @returns Shader source with preprocessor directives inserted.
 */
function insertDefines(source, defines) {
    const definesString = Object.keys(defines)
        .map((defineName) => '#define ' + defineName + ' ' +
        defines[defineName])
        .join('\n');
    const versionIdx = source.indexOf('#version');
    if (versionIdx === -1) {
        return definesString + '\n' + source;
    }
    const nextLineIdx = source.indexOf('\n', versionIdx) + 1;
    return source.slice(0, nextLineIdx) + definesString + '\n' +
        source.slice(nextLineIdx);
}
/**
 * Creates a new shader of a given type out of a given source string.
 *
 * @param gl WebGL context the shader will be created in.
 * @param type The type of the shader, VERTEX_SHADER or FRAGMENT_SHADER.
 * @param source The source string.
 * @throws An error if compilation of the shader fails.
 * @returns The shader WebGL handle.
 */
function compileShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    // TODO Uncomment and put under debug flag (when implemented)
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        throw new Error('Failed to compile shader:\n' + gl.getShaderInfoLog(shader));
    }
    return shader;
}
/** Wrapper around WebGLProgram objects. */
class Program {
    /**
     * Constructs a new program.
     *
     * @param gl WebGL context the program will be created in.
     * @param vertexShaderSource Source code of vertex shader of the program.
     * @param fragmentShaderSource Source code of fragment shader of the program.
     * @param options Options.
     * @throws An error if shader compilation or program linking fails.
     */
    constructor(gl, vertexShaderSource, fragmentShaderSource, options) {
        this._gl = gl;
        const handle = this._handle = gl.createProgram();
        if (options && options.defines) {
            vertexShaderSource = insertDefines(vertexShaderSource, options.defines);
            fragmentShaderSource = insertDefines(fragmentShaderSource, options.defines);
        }
        const vertexShader = compileShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        gl.attachShader(handle, vertexShader);
        gl.attachShader(handle, fragmentShader);
        gl.deleteShader(vertexShader);
        gl.deleteShader(fragmentShader);
        if (options && options.attribMap) {
            Object.keys(options.attribMap)
                .forEach((attributeName) => gl.bindAttribLocation(handle, options.attribMap[attributeName], attributeName));
        }
        gl.linkProgram(handle);
        // TODO Uncomment and put under debug flag (when implemented)
        if (!gl.getProgramParameter(handle, gl.LINK_STATUS)) {
            throw new Error(`Failed to link program:\n${gl.getProgramInfoLog(handle)}`);
        }
        this._uniformCache = new Map();
    }
    /**
     * Binds the program to the WebGL context.
     */
    bind() {
        const gl = this._gl;
        const handle = this._handle;
        // TODO Uncomment and put under debug flag (when implemented)
        // gl.validateProgram(handle);
        // if (!gl.getProgramParameter(handle, gl.VALIDATE_STATUS)) {
        //     throw new Error(
        //         'Failed to validate program:\n' + gl.getProgramInfoLog(handle)
        //     );
        // }
        gl.useProgram(handle);
    }
    /**
     * Checks if the program is bound to the WebGL context.
     *
     * @returns `true` if the program if currently bound to the WebGL context and
     *      `false` otherwise.
     */
    isBound() {
        const gl = this._gl;
        return gl.getParameter(gl.CURRENT_PROGRAM) === this._handle;
    }
    /**
     * Sets an integer scalar value to a uniform. If there's no uniform with
     * given name in the program, silently does nothing.
     *
     * @param uniformName Name of the uniform.
     * @param value The scalar value.
     */
    setIntScalarUniform(uniformName, value) {
        const location = this._getUniformLocation(uniformName);
        if (location) {
            this._gl.uniform1i(location, value);
        }
    }
    /**
     * Sets a scalar value to a uniform. If there's no uniform with
     * given name in the program, silently does nothing.
     *
     * @param uniformName Name of the uniform.
     * @param value The scalar value.
     */
    setScalarUniform(uniformName, value) {
        const location = this._getUniformLocation(uniformName);
        if (location) {
            this._gl.uniform1f(location, value);
        }
    }
    /**
     * Sets a 2D vector to a uniform. If there's no uniform with given name in
     * the program, silently does nothing.
     *
     * @param uniformName Name of the uniform.
     * @param value The vector.
     */
    setVector2Uniform(uniformName, value) {
        const location = this._getUniformLocation(uniformName);
        if (location) {
            this._gl.uniform2f(location, value.x, value.y);
        }
    }
    /**
     * Sets a 3D vector to a uniform. If there's no uniform with given name in
     * the program, silently does nothing.
     *
     * @param uniformName Name of the uniform.
     * @param value The vector.
     */
    setVector3Uniform(uniformName, value) {
        const location = this._getUniformLocation(uniformName);
        if (location) {
            this._gl.uniform3f(location, value.x, value.y, value.z);
        }
    }
    /**
     * Sets a 4D vector to a uniform. If there's no uniform with given name in
     * the program, silently does nothing.
     *
     * @param uniformName Name of the uniform.
     * @param value The vector.
     */
    setVector4Uniform(uniformName, value) {
        const location = this._getUniformLocation(uniformName);
        if (location) {
            this._gl.uniform4f(location, value.x, value.y, value.z, value.w);
        }
    }
    /**
     * Sets a color to a uniform. If there's no uniform with given name in the
     * program, silently does nothing.
     *
     * @param uniformName Name of the uniform.
     * @param value The color.
     */
    setColorUniform(uniformName, value) {
        const location = this._getUniformLocation(uniformName);
        if (location) {
            this._gl.uniform4f(location, value.r, value.g, value.b, value.a);
        }
    }
    /**
     * Sets a 3x3 matrix to a uniform. If there's no uniform with given name in
     * the program, silently does nothing.
     *
     * @param uniformName Name of the uniform.
     * @param value The matrix.
     */
    setMatrix3Uniform(uniformName, value) {
        const location = this._getUniformLocation(uniformName);
        if (location) {
            this._gl.uniformMatrix3fv(location, false, value);
        }
    }
    /**
     * Sets a 4x4 matrix to a uniform. If there's no uniform with given name in
     * the program, silently does nothing.
     *
     * @param uniformName Name of the uniform.
     * @param value The matrix.
     */
    setMatrix4Uniform(uniformName, value) {
        const location = this._getUniformLocation(uniformName);
        if (location) {
            this._gl.uniformMatrix4fv(location, false, value);
        }
    }
    /**
     * Destroys the program.
     */
    destroy() {
        this._gl.deleteProgram(this._handle);
    }
    _getUniformLocation(name) {
        const cache = this._uniformCache;
        let location = cache.get(name);
        if (!location) {
            location = this._gl.getUniformLocation(this._handle, name);
            if (!location) {
                // TODO Uncomment and put under debug flag (when implemented)
                // console.warn(`Uniform ${name} doesn't exist in program.`);
                return null;
            }
            cache.set(name, location);
        }
        return location;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Program;



/***/ }),
/* 59 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/** Wrapper around WebGLRenderbuffer objects. */
class Renderbuffer {
    /**
     * Creates a new renderbuffer in a WebGL context.
     *
     * @param gl The context the renderbuffer will be created in.
     */
    constructor(gl, width, height) {
        this._gl = gl;
        this._handle = gl.createRenderbuffer();
        this._width = width;
        this._height = height;
    }
    /**
     * Binds the renderbuffer to the WebGL context.
     */
    bind() {
        const gl = this._gl;
        gl.bindRenderbuffer(gl.RENDERBUFFER, this._handle);
    }
    /**
     * Checks if the renderbuffer is bound to the WebGL context.
     *
     * @returns `true` if the renderbuffer is currently bound to the WebGL context
     *      and `false` otherwise.
     */
    isBound() {
        const gl = this._gl;
        return gl.getParameter(gl.RENDERBUFFER_BINDING) === this._handle;
    }
    /**
     * Attaches the renderbuffer to a currently bound to the WebGL context
     * framebuffer.
     *
     * @param attachmentPoint Attachment point the renderbuffer will be attached
     *      to.
     */
    attachToFramebuffer(attachmentPoint) {
        const gl = this._gl;
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachmentPoint, gl.RENDERBUFFER, this._handle);
    }
    getWidth() {
        return this._width;
    }
    getHeight() {
        return this._height;
    }
    /**
     * Destroys the renderbuffer.
     */
    destroy() {
        this._gl.deleteRenderbuffer(this._handle);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Renderbuffer;



/***/ }),
/* 60 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// tslint:disable
/*
    This is automatically generated by /tools/gl_gen/gen_capabilities.js script.
    Instead of modifying it edit the script and regenerate this file.
*/
class RenderContextCapabilitiesManager {
    constructor(gl) {
        this._gl = gl;
        this._paramValues = new Map();
    }
    getAliasedLineWidthRange() { return this._getParam(33902 /* ALIASED_LINE_WIDTH_RANGE */); }
    getAliasedPointSizeRange() { return this._getParam(33901 /* ALIASED_POINT_SIZE_RANGE */); }
    getMaxCombinedTextureImageUnits() { return this._getParam(35661 /* MAX_COMBINED_TEXTURE_IMAGE_UNITS */); }
    getMaxCubeMapTextureSize() { return this._getParam(34076 /* MAX_CUBE_MAP_TEXTURE_SIZE */); }
    getMaxFragmentUniformVectors() { return this._getParam(36349 /* MAX_FRAGMENT_UNIFORM_VECTORS */); }
    getMaxRenderbufferSize() { return this._getParam(34024 /* MAX_RENDERBUFFER_SIZE */); }
    getMaxTextureImageUnits() { return this._getParam(34930 /* MAX_TEXTURE_IMAGE_UNITS */); }
    getMaxTextureSize() { return this._getParam(3379 /* MAX_TEXTURE_SIZE */); }
    getMaxVaryingVectors() { return this._getParam(36348 /* MAX_VARYING_VECTORS */); }
    getMaxVertexAttribs() { return this._getParam(34921 /* MAX_VERTEX_ATTRIBS */); }
    getMaxVertexTextureImageUnits() { return this._getParam(35660 /* MAX_VERTEX_TEXTURE_IMAGE_UNITS */); }
    getMaxVertexUniformVectors() { return this._getParam(36347 /* MAX_VERTEX_UNIFORM_VECTORS */); }
    getMaxViewportDims() { return this._getParam(3386 /* MAX_VIEWPORT_DIMS */); }
    getRenderer() { return this._getParam(7937 /* RENDERER */); }
    getSubpixelBits() { return this._getParam(3408 /* SUBPIXEL_BITS */); }
    getVendor() { return this._getParam(7936 /* VENDOR */); }
    getVersion() { return this._getParam(7938 /* VERSION */); }
    /** Calling this method w/o `WEBGL_debug_renderer_info` enabled will return `null`! */
    getUnmaskedVendor() { return this._getParam(37445 /* UNMASKED_VENDOR */); }
    /** Calling this method w/o `WEBGL_debug_renderer_info` enabled will return `null`! */
    getUnmaskedRenderer() { return this._getParam(37446 /* UNMASKED_RENDERER */); }
    _getParam(param) {
        const paramValues = this._paramValues;
        let paramValue = paramValues.get(param);
        if (!paramValue) {
            paramValue = this._gl.getParameter(param);
            paramValues.set(param, paramValue);
        }
        return paramValue;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RenderContextCapabilitiesManager;



/***/ }),
/* 61 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Our defaults for textures are different from ones in WebGL for two reasons:
 * 1. default minification filter in WebGL is NEAREST_MIPMAP_LINEAR which requires
 *    texture to have all mip levels specified;
 * 2. default wrap modes are REPEAT which isn't supported for NPOT textures.
 */
const DEFAULT_TEXTURE_PARAMS = {
    wrapS: 33071 /* CLAMP_TO_EDGE */,
    wrapT: 33071 /* CLAMP_TO_EDGE */,
    magnificationFilter: 9728 /* NEAREST */,
    minificationFilter: 9728 /* NEAREST */,
    premultipliedAlpha: false
};
/* harmony export (immutable) */ __webpack_exports__["a"] = DEFAULT_TEXTURE_PARAMS;

/** Wrapper around WebGLTexture objects. For now only works with 2D textures. */
class Texture {
    /**
     * Creates a new texture in a WebGL context.
     *
     * @param gl The context the texture will be created in.
     */
    constructor(gl, width, height, format, type, params = DEFAULT_TEXTURE_PARAMS) {
        this._gl = gl;
        this._format = format;
        this._type = type;
        this._params = params;
        this._width = width;
        this._height = height;
        this._handle = gl.createTexture();
        this.bind();
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, params.wrapS);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, params.wrapT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, params.magnificationFilter);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, params.minificationFilter);
        gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, 0, format, type, null);
    }
    /**
     * Binds the texture to the WebGL context as a 2D texture.
     */
    bind() {
        const gl = this._gl;
        gl.bindTexture(gl.TEXTURE_2D, this._handle);
    }
    /**
     * Checks if the texture is bound to the WebGL context.
     *
     * @returns `true` if the texture is currently bound to the WebGL context
     *      and `false` otherwise.
     */
    isBound() {
        const gl = this._gl;
        return gl.getParameter(gl.TEXTURE_BINDING_2D) === this._handle;
    }
    /**
     * Attaches the texture to a currently bound to the WebGL context framebuffer.
     *
     * @param attachmentPoint Attachment point the texture will be attached to.
     */
    attachToFramebuffer(attachmentPoint) {
        const gl = this._gl;
        gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentPoint, gl.TEXTURE_2D, this._handle, 0);
    }
    /** Returns width of the texture. */
    getWidth() {
        return this._width;
    }
    /** Returns height of the texture. */
    getHeight() {
        return this._height;
    }
    /** Returns pixel format of the texture. */
    getFormat() {
        return this._format;
    }
    /** Return pixel type of the texture. */
    getType() {
        return this._type;
    }
    /** Return params of the texture. */
    getParams() {
        return this._params;
    }
    /**
     * Destroys the texture.
     */
    destroy() {
        this._gl.deleteTexture(this._handle);
    }
}
/* harmony export (immutable) */ __webpack_exports__["b"] = Texture;



/***/ }),
/* 62 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Wrapper around vertex array (VAO) object from `OES_vertex_array_object`
 * extension.
 */
class VertexArrayObject {
    /**
     * Creates new VAO in a given WebGL context.
     *
     * @param gl The context.
     * @param vaoExt Instance of `OES_vertex_array_object` extension.
     * @param attributeMapping Mapping of attributes.
     */
    constructor(gl, vaoExt, attributeMapping) {
        this._gl = gl;
        this._vaoExt = vaoExt;
        this._handle = vaoExt.createVertexArrayOES();
        this.attributeMapping = attributeMapping;
    }
    /**
     * Binds the VAO to the context.
     */
    bind() {
        this._vaoExt.bindVertexArrayOES(this._handle);
    }
    /**
     * Checks if the VAO is currently bound to the context.
     *
     * @returns `true` if the VAO is currently bound to the WebGL context and
     *      `false` otherwise.
     */
    isBound() {
        return this._gl.getParameter(this._vaoExt.VERTEX_ARRAY_BINDING_OES) ===
            this._handle;
    }
    /**
     * Destroys the VAO.
     */
    destroy() {
        this._vaoExt.deleteVertexArrayOES(this._handle);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = VertexArrayObject;



/***/ }),
/* 63 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_scalar__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_rad_deg__ = __webpack_require__(64);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_options__ = __webpack_require__(65);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__math_matrix4__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__math_vector2__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__math_vector3__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__util_event_emitter__ = __webpack_require__(2);








// TODO(dmikis) We want to constraint coordinates so visible region doesn't extend
//      out of world boundaries. However, in current implementation it doesn't
//      work properly for aspect ratios >1 on zoom 0 since visible region is
//      larger that the world itself (so there's no way to squeeze it in). For
//      the current case (i.e. cycled in horizontal direction) it is not a problem.
const MAX_TILT = Object(__WEBPACK_IMPORTED_MODULE_1__util_rad_deg__["a" /* deg2rad */])(40);
/**
 * If a camera has zoom less than of equal to `NO_TILT_MAX_ZOOM`, tilt won't be
 * allowed.
 */
const NO_TILT_MAX_ZOOM = 1;
/**
 * If a camera has zoom greater than of equal to `FULL_TILT_MIN_ZOOM`, tilt will
 * be allowed up to `MAX_TILT`.
 */
const FULL_TILT_MIN_ZOOM = NO_TILT_MAX_ZOOM + 1;
const FRUSTUM_DIRECTIONS = [
    // tslint:disable
    __WEBPACK_IMPORTED_MODULE_5__math_vector3__["e" /* create */](-1, 1, -1),
    __WEBPACK_IMPORTED_MODULE_5__math_vector3__["e" /* create */](1, 1, -1),
    __WEBPACK_IMPORTED_MODULE_5__math_vector3__["e" /* create */](1, -1, -1),
    __WEBPACK_IMPORTED_MODULE_5__math_vector3__["e" /* create */](-1, -1, -1)
    // tslint:enable
];
/**
 * How big the world sould be on a screen if zoom is 0, in device independent pixels
 */
const ZOOM_0_WORLD_CSS_PIXEL_SIZE = 256;
const DEFAULT_OPTIONS = {
    wrapModeX: 1 /* CLAMP_TO_EDGE */,
    wrapModeY: 1 /* CLAMP_TO_EDGE */,
    minZoom: 0,
    maxZoom: 24,
    fov: Object(__WEBPACK_IMPORTED_MODULE_1__util_rad_deg__["a" /* deg2rad */])(30)
};
/**
 * Restricts a new value for a center's coordinate according to given wrap mode.
 *
 * @param wrapMode The wrap mode.
 * @param newCoordinate The new value.
 * @param oldCoordinate Current value of the coordinate.
 * @param bboxMin Minimum corresponding coordinate of bounding box of the
 *      visible quadrilateral.
 * @param bboxMax Maximum corresponding coordinate of bounding box of the
 *      visible quadrilateral.
 * @returns Restricted value for the coordinate.
 */
function restrictCoordinate(wrapMode, newCoordinate) {
    switch (wrapMode) {
        case 0 /* NONE */:
            return newCoordinate;
        case 1 /* CLAMP_TO_EDGE */:
            return Object(__WEBPACK_IMPORTED_MODULE_0__math_scalar__["a" /* clamp */])(newCoordinate, -1, 1);
        case 2 /* REPEAT */:
            return Object(__WEBPACK_IMPORTED_MODULE_0__math_scalar__["b" /* cycleRestrict */])(newCoordinate, -1, 1);
    }
}
/**
 * Camera represents user's point of view in the world space, as a real camera it has restricted field of view,
 * it can move and rotate (with or without animation).
 */
class Camera {
    /**
     * Creates a new camera.
     *
     * @param options Options.
     */
    constructor(options) {
        this.options = Object(__WEBPACK_IMPORTED_MODULE_2__util_options__["a" /* default */])(DEFAULT_OPTIONS, options);
        this.center = new Camera._Center(this);
        this.onUpdate = new __WEBPACK_IMPORTED_MODULE_6__util_event_emitter__["b" /* VoidEventEmitter */]();
        const screenSize = new Camera._ScreenSize(this);
        this.screenSize = screenSize;
        this._distanceToCenter = 1;
        this._zoom = this.options.minZoom;
        this._tilt = this._azimuth = 0;
        this._dirtyBits = -1 /* ALL */;
        this._viewProjMatrix = __WEBPACK_IMPORTED_MODULE_3__math_matrix4__["c" /* copy */](__WEBPACK_IMPORTED_MODULE_3__math_matrix4__["a" /* IDENTITY */]);
        this._visibleQuadrilateral = [
            __WEBPACK_IMPORTED_MODULE_5__math_vector3__["e" /* create */](0, 0, 0),
            __WEBPACK_IMPORTED_MODULE_5__math_vector3__["e" /* create */](0, 0, 0),
            __WEBPACK_IMPORTED_MODULE_5__math_vector3__["e" /* create */](0, 0, 0),
            __WEBPACK_IMPORTED_MODULE_5__math_vector3__["e" /* create */](0, 0, 0)
        ];
        this._visibleQuadrilateralBBox =
            __WEBPACK_IMPORTED_MODULE_4__math_vector2__["c" /* computeBBoxForPoints */](this._visibleQuadrilateral);
        this._pixelSize = __WEBPACK_IMPORTED_MODULE_4__math_vector2__["f" /* create */](0, 0);
    }
    get aspectRatio() {
        const { width, height } = this.screenSize;
        if (height !== 0) {
            return width / height;
        }
        else {
            // when height == 0 we cannot compute viewProj matrix or visible region, 1 allows to handle this case with
            // no exceptions thrown, but technically it is not correct and should be reconsidered if any issue is found
            return 1;
        }
    }
    get zoom() {
        return this._zoom;
    }
    get worldToPxFactor() {
        return this._worldToPxFactor;
    }
    /**
     * Sets new zoom to the camera with respect to provided limits in the options.
     */
    set zoom(newZoom) {
        newZoom = Object(__WEBPACK_IMPORTED_MODULE_0__math_scalar__["a" /* clamp */])(newZoom, this.options.minZoom, this.options.maxZoom);
        if (newZoom !== this._zoom) {
            this._zoom = newZoom;
            this._computeDistanceToCenter();
            // Constraints on tilt may have changed, we need to recompute it.
            this._tilt = this._constrainTilt(this._tilt);
            this._worldToPxFactor = 2.0 / (ZOOM_0_WORLD_CSS_PIXEL_SIZE * Math.pow(2, newZoom));
            this._setDirtyBits(1 /* VIEW_PROJ_MATRIX */ | 2 /* VISIBLE_QUADRILATERAL */);
        }
    }
    get tilt() {
        return this._tilt;
    }
    set tilt(newTilt) {
        newTilt = this._constrainTilt(newTilt);
        if (this._tilt !== newTilt) {
            this._tilt = newTilt;
            this._setDirtyBits(1 /* VIEW_PROJ_MATRIX */ | 2 /* VISIBLE_QUADRILATERAL */);
        }
    }
    get azimuth() {
        return this._azimuth;
    }
    set azimuth(newAzimuth) {
        newAzimuth = Object(__WEBPACK_IMPORTED_MODULE_0__math_scalar__["b" /* cycleRestrict */])(newAzimuth, 0, 2 * Math.PI);
        if (this._azimuth !== newAzimuth) {
            this._azimuth = newAzimuth;
            this._setDirtyBits(1 /* VIEW_PROJ_MATRIX */ | 2 /* VISIBLE_QUADRILATERAL */);
        }
    }
    /**
     * Size of a pixel in NDC.
     */
    get pixelSize() {
        return this._pixelSize;
    }
    /**
     * Invalidate all internally cached values (e.g. view matrix).
     */
    setDirty() {
        this._setDirtyBits(-1 /* ALL */);
    }
    /**
     * Recomputes (if needed) the view projection matrix.
     *
     * @returns The view-projection matrix.
     */
    getViewProjMatrix() {
        const viewProjMatrix = this._viewProjMatrix;
        if (this._dirtyBits & 1 /* VIEW_PROJ_MATRIX */) {
            __WEBPACK_IMPORTED_MODULE_3__math_matrix4__["c" /* copy */](__WEBPACK_IMPORTED_MODULE_3__math_matrix4__["a" /* IDENTITY */], viewProjMatrix);
            __WEBPACK_IMPORTED_MODULE_3__math_matrix4__["d" /* lookAt */](viewProjMatrix, this._computeCenterToCameraVector(), __WEBPACK_IMPORTED_MODULE_5__math_vector3__["a" /* ORIGIN */], __WEBPACK_IMPORTED_MODULE_5__math_vector3__["m" /* rotateZ */](__WEBPACK_IMPORTED_MODULE_5__math_vector3__["b" /* POSITIVE_Y */], this._azimuth), viewProjMatrix);
            const { fov } = this.options;
            const tanFactors = Math.tan(this._tilt) * Math.tan(0.5 * fov);
            __WEBPACK_IMPORTED_MODULE_3__math_matrix4__["e" /* perspective */](viewProjMatrix, fov, this.aspectRatio, Math.min(this._distanceToCenter * 0.01, this._distanceToCenter / (1 + tanFactors)), this._distanceToCenter / (1 - tanFactors), viewProjMatrix);
            this._dirtyBits &= ~1 /* VIEW_PROJ_MATRIX */;
        }
        return viewProjMatrix;
    }
    /**
     * Recomputes (if needed) and returns quadrilateral cut on the world plane
     * by frustum of the camera.
     *
     * @return The quadrilateral enclosing visible part of the world plane.
     */
    getVisibleRegion() {
        this._computeVisibleQuadrilateral();
        return this._visibleQuadrilateral;
    }
    /**
     * Recomputes (if needed) and returns bounding box of the visible region.
     *
     * @return Bounding box of the visible quadrilateral.
     */
    getVisibleRegionBBox() {
        this._computeVisibleQuadrilateral();
        return this._visibleQuadrilateralBBox;
    }
    _constrainTilt(tilt) {
        return Object(__WEBPACK_IMPORTED_MODULE_0__math_scalar__["a" /* clamp */])(tilt, 0, MAX_TILT * Object(__WEBPACK_IMPORTED_MODULE_0__math_scalar__["c" /* smoothStep */])(NO_TILT_MAX_ZOOM, FULL_TILT_MIN_ZOOM, this._zoom));
    }
    _setDirtyBits(bits) {
        if (bits ^ (bits & this._dirtyBits)) {
            this._dirtyBits |= bits;
            this.onUpdate.fire();
        }
    }
    _computeDistanceToCenter() {
        this._distanceToCenter =
            this.screenSize.height * Math.pow(2, -this._zoom) /
                (Math.tan(0.5 * this.options.fov) * ZOOM_0_WORLD_CSS_PIXEL_SIZE);
    }
    _computeCenterToCameraVector(dst = __WEBPACK_IMPORTED_MODULE_5__math_vector3__["e" /* create */](0, 0, 0)) {
        __WEBPACK_IMPORTED_MODULE_5__math_vector3__["i" /* muln */](__WEBPACK_IMPORTED_MODULE_5__math_vector3__["c" /* POSITIVE_Z */], this._distanceToCenter, dst);
        __WEBPACK_IMPORTED_MODULE_5__math_vector3__["l" /* rotateX */](dst, this._tilt, dst);
        __WEBPACK_IMPORTED_MODULE_5__math_vector3__["m" /* rotateZ */](dst, this._azimuth, dst);
        return dst;
    }
    _computeVisibleQuadrilateral() {
        if (this._dirtyBits & 2 /* VISIBLE_QUADRILATERAL */) {
            const visibleQuadrilateral = this._visibleQuadrilateral;
            const halfFovTan = Math.tan(0.5 * this.options.fov);
            const origin = this._computeCenterToCameraVector();
            __WEBPACK_IMPORTED_MODULE_4__math_vector2__["b" /* add */](origin, this.center, origin);
            const scale = __WEBPACK_IMPORTED_MODULE_5__math_vector3__["e" /* create */](halfFovTan * this.aspectRatio, halfFovTan, 1);
            const direction = __WEBPACK_IMPORTED_MODULE_5__math_vector3__["e" /* create */](0, 0, 0);
            const ray = { origin, direction };
            for (let i = 0; i < 4; ++i) {
                __WEBPACK_IMPORTED_MODULE_5__math_vector3__["j" /* mulv */](FRUSTUM_DIRECTIONS[i], scale, direction);
                __WEBPACK_IMPORTED_MODULE_5__math_vector3__["l" /* rotateX */](direction, this._tilt, direction);
                __WEBPACK_IMPORTED_MODULE_5__math_vector3__["m" /* rotateZ */](direction, this._azimuth, direction);
                if (!__WEBPACK_IMPORTED_MODULE_5__math_vector3__["h" /* getPlaneRayIntersection */](__WEBPACK_IMPORTED_MODULE_5__math_vector3__["d" /* XY */], ray, visibleQuadrilateral[i])) {
                    throw new Error('Visible quadrilateral is unbounded, engine can\'t handle that case (yet)');
                }
            }
            __WEBPACK_IMPORTED_MODULE_4__math_vector2__["c" /* computeBBoxForPoints */](visibleQuadrilateral, this._visibleQuadrilateralBBox);
            this._dirtyBits &= ~2 /* VISIBLE_QUADRILATERAL */;
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Camera;

/**
 * Implementation of a center vector of a camera. Takes into account wrapping
 * modes and updates camera's dirty flags.
 */
Camera._Center = class {
    /**
     * Creates new center vector for a camera.
     *
     * @param camera The camera.
     */
    constructor(camera) {
        this._camera = camera;
        this._x = this._y = 0;
    }
    /**
     * @returns Values of abscissa of the center vector.
     */
    get x() {
        return this._x;
    }
    /**
     * Properly clamps or wraps new abscissa value and sets it to the vector.
     *
     * @param newX The new
     */
    set x(newX) {
        const camera = this._camera;
        newX = restrictCoordinate(camera.options.wrapModeX, newX);
        if (this._x !== newX) {
            this._x = newX;
            camera._setDirtyBits(2 /* VISIBLE_QUADRILATERAL */);
        }
    }
    /**
     * @returns Values of ordinate of the center vector.
     */
    get y() {
        return this._y;
    }
    /**
     * Properly clamps or wraps new ordinate value and sets it to the vector.
     */
    set y(newY) {
        const camera = this._camera;
        newY = restrictCoordinate(camera.options.wrapModeY, newY);
        if (this._y !== newY) {
            this._y = newY;
            camera._setDirtyBits(2 /* VISIBLE_QUADRILATERAL */);
        }
    }
};
Camera._ScreenSize = class {
    constructor(camera) {
        this._camera = camera;
        this._width = this._height = 0;
    }
    get width() {
        return this._width;
    }
    set width(newWidth) {
        if (this._width !== newWidth) {
            this._width = newWidth;
            const camera = this._camera;
            camera._setDirtyBits(1 /* VIEW_PROJ_MATRIX */ | 2 /* VISIBLE_QUADRILATERAL */);
            camera._pixelSize.x = 2.0 / this._width;
        }
    }
    get height() {
        return this._height;
    }
    set height(newHeight) {
        if (this._height !== newHeight) {
            this._height = newHeight;
            const camera = this._camera;
            camera._computeDistanceToCenter();
            camera._setDirtyBits(1 /* VIEW_PROJ_MATRIX */ | 2 /* VISIBLE_QUADRILATERAL */);
            camera._pixelSize.y = 2.0 / this._height;
        }
    }
};


/***/ }),
/* 64 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = deg2rad;
/* unused harmony export rad2deg */
const DEG_TO_RAD = Math.PI / 180;
function deg2rad(x) {
    return x * DEG_TO_RAD;
}
function rad2deg(x) {
    return x / DEG_TO_RAD;
}


/***/ }),
/* 65 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = getFullOptions;
/**
 * Resolves options.
 *
 * @param defaultOptions Object with default values.
 * @param options Object with custom values for options. Later objects "override"
 *      former ones.
 * @returns New object containing resolved options.
 */
function getFullOptions(defaultOptions, ...options) {
    return Object.assign({}, defaultOptions, ...options);
}


/***/ }),
/* 66 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export create */
/* unused harmony export zero */
/* harmony export (immutable) */ __webpack_exports__["a"] = fromRows;
/* unused harmony export columns */
/* unused harmony export fromColumns */
/* unused harmony export determinant */
/* harmony export (immutable) */ __webpack_exports__["b"] = solve;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__vector3__ = __webpack_require__(12);

const MATRIX_SIZE = 9;
/**
 * Creates and returns a new **uninitialized** matrix.
 */
function create() {
    return new Array(MATRIX_SIZE);
}
/**
 * Zeroes a matrix.
 *
 * @param dst The matrix.
 * @returns `dst`.
 */
function zero(dst = create()) {
    for (let i = 0; i < MATRIX_SIZE; ++i) {
        dst[i] = 0;
    }
    return dst;
}
/**
 * Copies three vectors to a matrix as rows.
 *
 * @param r0 The first row.
 * @param r1 The second row.
 * @param r2 The third row.
 * @param dst The matrix the rows will be written to.
 * @returns `dst`.
 */
function fromRows(r0, r1, r2, dst = create()) {
    dst[0] = r0.x;
    dst[1] = r1.x;
    dst[2] = r2.x;
    dst[3] = r0.y;
    dst[4] = r1.y;
    dst[5] = r2.y;
    dst[6] = r0.z;
    dst[7] = r1.z;
    dst[8] = r2.z;
    return dst;
}
/**
 * Returns array of columns of a matrix.
 *
 * @param m The matrix.
 * @param dst The array columns of the matrix will be written to.
 * @returns `dst`.
 */
function columns(m, dst = [
    __WEBPACK_IMPORTED_MODULE_0__vector3__["e" /* create */](0, 0, 0),
    __WEBPACK_IMPORTED_MODULE_0__vector3__["e" /* create */](0, 0, 0),
    __WEBPACK_IMPORTED_MODULE_0__vector3__["e" /* create */](0, 0, 0)
]) {
    for (let i = 0, j = 0; i < 3; ++i, j += 3) {
        dst[i].x = m[j];
        dst[i].y = m[j + 1];
        dst[i].z = m[j + 2];
    }
    return dst;
}
/**
 * Copies three vectors to a matrix as columns.
 *
 * @param c0 The first column.
 * @param c1 The second column.
 * @param c2 The third column.
 * @param dst The matrix the columns will be written to.
 * @returns `dst`.
 */
function fromColumns(c0, c1, c2, dst = create()) {
    dst[0] = c0.x;
    dst[1] = c0.y;
    dst[2] = c0.z;
    dst[3] = c1.x;
    dst[4] = c1.y;
    dst[5] = c1.z;
    dst[6] = c2.x;
    dst[7] = c2.y;
    dst[8] = c2.z;
    return dst;
}
/**
 * Computes determinant of a matrix.
 *
 * @param m The matrix.
 * @returns The determinant.
 */
function determinant(m) {
    return m[0] * (m[4] * m[8] - m[7] * m[5]) +
        m[3] * (m[1] * m[8] - m[7] * m[2]) +
        m[6] * (m[1] * m[5] - m[4] * m[2]);
}
const staticMatrixColumns = [
    // Not using vector3.create here due to circular dependency.
    { x: 0, y: 0, z: 0 },
    { x: 0, y: 0, z: 0 },
    { x: 0, y: 0, z: 0 }
];
const staticMatrix = create();
/**
 * Solves a system of linear equations represented with a matrix and a vector,
 * i.e.:
 *
 * ```
 * m * (x, y ,z)^T = v
 * ```
 *
 * Uses Cramer's rule.
 * @see https://en.wikipedia.org/wiki/Cramer's_rule
 *
 * @param m The matrix of the system.
 * @param v The vector of the system.
 * @param dst The vector solution of the system will be written to.
 * @return `dst`.
 */
function solve(m, v, dst = __WEBPACK_IMPORTED_MODULE_0__vector3__["e" /* create */](0, 0, 0)) {
    const revDet = 1 / determinant(m);
    const [c0, c1, c2] = columns(m, staticMatrixColumns);
    dst.x = revDet * determinant(fromColumns(v, c1, c2, staticMatrix));
    dst.y = revDet * determinant(fromColumns(c0, v, c2, staticMatrix));
    dst.z = revDet * determinant(fromColumns(c0, c1, v, staticMatrix));
    return dst;
}


/***/ }),
/* 67 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__tile_based_adapter_adapter__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__primitive_icon_icon_buffer_writer__ = __webpack_require__(74);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__render_memory_sub_chunk__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__billboard_identified_image_atlas_manager__ = __webpack_require__(75);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__font_df_font__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__api_image_provider__ = __webpack_require__(77);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__primitive_model_model_buffer_writer__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__primitive_polyline_textured_polyline_buffer_writer__ = __webpack_require__(80);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__billboard_image_manager__ = __webpack_require__(82);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__primitive_polygon_textured_polygon_buffer_rewiter__ = __webpack_require__(83);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__primitive_polygon_polygon_attribute_mapping__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__primitive_polygon_textured_polygon_attribute_mapping__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__primitive_billboard_rectangle_attribute_mapping__ = __webpack_require__(85);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__primitive_label_point_label_attribute_mapping__ = __webpack_require__(86);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__primitive_label_curved_label_attribute_mapping__ = __webpack_require__(87);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__primitive_polyline_polyline_attribute_mapping__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__worker_tile_provider_worker_client__ = __webpack_require__(88);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__worker_tile_provider_worker_messages__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__primitive_polygon_transparent_polygon_attribute_mapping__ = __webpack_require__(90);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__tile_based_adapter_tile_id__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__util_idle_task_queue__ = __webpack_require__(91);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__util_stat__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__util_unique_id__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__primitive_polygon_renderable_polygon__ = __webpack_require__(93);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__primitive_polygon_renderable_textured_polygon__ = __webpack_require__(94);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__primitive_polyline_renderable_polyline__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__primitive_polyline_renderable_textured_polyline__ = __webpack_require__(95);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__primitive_model_renderable_model__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28__tile_data__ = __webpack_require__(96);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29__primitive_manager_renderable_primitive_manager__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_30__render_primitives_primitive_set_storage__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_31__primitive_manager_polygon_manager__ = __webpack_require__(97);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_32__render_primitives_disappearing_primitive_set_storage__ = __webpack_require__(40);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_33__render_primitives_delayed_disappearing_primitive_set_storage__ = __webpack_require__(98);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_34__primitive_manager_zoom_filterable_primitive_manager__ = __webpack_require__(99);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_35__primitive_manager_external_mesh_manager__ = __webpack_require__(100);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_36__primitive_billboard_rectangle_renderable_billboard_rectangle__ = __webpack_require__(101);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_37__primitive_zoom_restricted_label__ = __webpack_require__(102);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_38__primitive_zoom_restricted_icon__ = __webpack_require__(104);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_39__util_task_queue__ = __webpack_require__(108);








































const WORLD_SIZE = 2.0;
const NORMAL_TILE_SIDE_SIZE_PX = 256; // tiles of normal size are optimized for displaying in a 256x256 css px square
function getTileSideSizePx(tileSize) {
    switch (tileSize) {
        case 1 /* X4 */:
            return NORMAL_TILE_SIDE_SIZE_PX * 2;
        case 2 /* X16 */:
            return NORMAL_TILE_SIDE_SIZE_PX * 4;
        default:
            return NORMAL_TILE_SIDE_SIZE_PX;
    }
}
const MAX_PERF_LOG_ITEMS_COUNT = 1024;
const QUEUE_TASK_PRIORITIES = {
    firstTilePortion: 20,
    secondTilePortion: 10
};
const DEFAULT_IDLE_TASK_PRIORITY = 0;
// The values are chosen empirically: https://st.yandex-team.ru/VECTOR-300#5be5b638523211001b9bd941
const MINZOOM_DELTAS = {
    pointLabels: 1,
    curvedLabels: 1,
    icons: 0.75
};
class VectorApiAdapter extends __WEBPACK_IMPORTED_MODULE_0__tile_based_adapter_adapter__["a" /* default */] {
    constructor(engine, camera, tileProviderWorkerUrl, layerName, { imageUrlTemplate, tileUrlTemplate, meshUrlTemplate, glyphRangeUrlTemplate }, tileSize = 0 /* X1 */, preloadedTilesBeltSize = 0) {
        super(engine, camera, tileSize, preloadedTilesBeltSize, layerName);
        this._tileSideSizePx = getTileSideSizePx(tileSize);
        this._perfLogItems = [];
        this._destroyables = [];
        this._tileProvider = new __WEBPACK_IMPORTED_MODULE_16__worker_tile_provider_worker_client__["a" /* TileProviderWorkerClient */](tileProviderWorkerUrl);
        this._tileProvider.sendMessage({
            type: __WEBPACK_IMPORTED_MODULE_17__worker_tile_provider_worker_messages__["a" /* TileProviderMessageType */].INIT,
            tileUrlTemplate,
            meshUrlTemplate,
            glyphRangeUrlTemplate
        }, 1 /* IMMEDIATE */);
        this._memoryManager = engine.memoryManager;
        this._glyphAtlas = engine.glyphAtlas;
        this._fontRegistry = engine.fontRegistry;
        this._imageManagerNearest = new __WEBPACK_IMPORTED_MODULE_8__billboard_image_manager__["a" /* ImageManager */](new __WEBPACK_IMPORTED_MODULE_3__billboard_identified_image_atlas_manager__["a" /* default */](engine.createImageAtlas({
            filter: 9728 /* NEAREST */,
            premultipliedAlpha: false
        })), new __WEBPACK_IMPORTED_MODULE_5__api_image_provider__["a" /* ApiImageProvider */](imageUrlTemplate));
        this._imageManagerLinear = new __WEBPACK_IMPORTED_MODULE_8__billboard_image_manager__["a" /* ImageManager */](new __WEBPACK_IMPORTED_MODULE_3__billboard_identified_image_atlas_manager__["a" /* default */](engine.createImageAtlas({
            filter: 9729 /* LINEAR */,
            premultipliedAlpha: true
        })), new __WEBPACK_IMPORTED_MODULE_5__api_image_provider__["a" /* ApiImageProvider */](imageUrlTemplate));
        const fadeEffect = engine.visibilityManager.fadeEffectDuration;
        const opaquePolygonsProvider = this.opaquePolygonsProvider = new __WEBPACK_IMPORTED_MODULE_30__render_primitives_primitive_set_storage__["a" /* default */]();
        const transparentPolygonsProvider = this.transparentPolygonsProvider = new __WEBPACK_IMPORTED_MODULE_30__render_primitives_primitive_set_storage__["a" /* default */]();
        const texturedPolygonsProvider = this.texturedPolygonsProvider = new __WEBPACK_IMPORTED_MODULE_30__render_primitives_primitive_set_storage__["a" /* default */]();
        const polylinesProvider = this.polylinesProvider = new __WEBPACK_IMPORTED_MODULE_30__render_primitives_primitive_set_storage__["a" /* default */]();
        const texturedPolylinesProvider = this.texturedPolylinesProvider = new __WEBPACK_IMPORTED_MODULE_30__render_primitives_primitive_set_storage__["a" /* default */]();
        const iconsProvider = this.iconsProvider = new __WEBPACK_IMPORTED_MODULE_32__render_primitives_disappearing_primitive_set_storage__["a" /* default */]();
        const pointLabelsProvider = this.pointLabelsProvider = new __WEBPACK_IMPORTED_MODULE_33__render_primitives_delayed_disappearing_primitive_set_storage__["a" /* default */](fadeEffect);
        const curvedLabelsProvider = this.curvedLabelsProvider = new __WEBPACK_IMPORTED_MODULE_33__render_primitives_delayed_disappearing_primitive_set_storage__["a" /* default */](fadeEffect);
        const modelsProvider = this.modelsProvider = new __WEBPACK_IMPORTED_MODULE_30__render_primitives_primitive_set_storage__["a" /* default */]();
        this._destroyables.push(pointLabelsProvider, curvedLabelsProvider);
        this._tileDataManagers = [
            new TileDataManager(new __WEBPACK_IMPORTED_MODULE_31__primitive_manager_polygon_manager__["a" /* default */](opaquePolygonsProvider, transparentPolygonsProvider), __WEBPACK_IMPORTED_MODULE_28__tile_data__["f" /* POLYGON_EXTRACTOR */]),
            new TileDataManager(new __WEBPACK_IMPORTED_MODULE_29__primitive_manager_renderable_primitive_manager__["a" /* default */](texturedPolygonsProvider), __WEBPACK_IMPORTED_MODULE_28__tile_data__["h" /* TEXTURED_POLYGON_EXTRACTOR */]),
            new TileDataManager(new __WEBPACK_IMPORTED_MODULE_29__primitive_manager_renderable_primitive_manager__["a" /* default */](polylinesProvider), __WEBPACK_IMPORTED_MODULE_28__tile_data__["g" /* POLYLINE_EXTRACTOR */]),
            new TileDataManager(new __WEBPACK_IMPORTED_MODULE_29__primitive_manager_renderable_primitive_manager__["a" /* default */](texturedPolylinesProvider), __WEBPACK_IMPORTED_MODULE_28__tile_data__["i" /* TEXTURED_POLYLINE_EXTRACTOR */]),
            new TileDataManager(new __WEBPACK_IMPORTED_MODULE_34__primitive_manager_zoom_filterable_primitive_manager__["a" /* default */](iconsProvider, camera), __WEBPACK_IMPORTED_MODULE_28__tile_data__["d" /* POINT_EXTRACTOR */]),
            new TileDataManager(new __WEBPACK_IMPORTED_MODULE_34__primitive_manager_zoom_filterable_primitive_manager__["a" /* default */](pointLabelsProvider, camera), __WEBPACK_IMPORTED_MODULE_28__tile_data__["e" /* POINT_LABEL_EXTRACTOR */]),
            new TileDataManager(new __WEBPACK_IMPORTED_MODULE_34__primitive_manager_zoom_filterable_primitive_manager__["a" /* default */](curvedLabelsProvider, camera), __WEBPACK_IMPORTED_MODULE_28__tile_data__["a" /* CURVED_LABEL_EXTRACTOR */]),
            new TileDataManager(new __WEBPACK_IMPORTED_MODULE_29__primitive_manager_renderable_primitive_manager__["a" /* default */](modelsProvider), __WEBPACK_IMPORTED_MODULE_28__tile_data__["c" /* MODEL_EXTRACTOR */]),
            new TileDataManager(new __WEBPACK_IMPORTED_MODULE_35__primitive_manager_external_mesh_manager__["a" /* default */](modelsProvider, this._tileProvider, this.engine.memoryManager), __WEBPACK_IMPORTED_MODULE_28__tile_data__["b" /* EXTERNAL_MESH_EXTRACTOR */])
        ];
        this._requestedTilesState = new Map();
        this._taskQueue = new __WEBPACK_IMPORTED_MODULE_39__util_task_queue__["a" /* default */]();
        this._minorTaskQueue = new __WEBPACK_IMPORTED_MODULE_20__util_idle_task_queue__["a" /* default */]();
        this._tileProvider.on(__WEBPACK_IMPORTED_MODULE_17__worker_tile_provider_worker_messages__["a" /* TileProviderMessageType */].TILE_RESPONSE, (response) => this._onTileProviderResponse(response));
        this._tileProvider.on(__WEBPACK_IMPORTED_MODULE_17__worker_tile_provider_worker_messages__["a" /* TileProviderMessageType */].TILE_ERROR, (response) => this._onTileError(response.tile));
        this._onCameraUpdate();
    }
    destroy() {
        this._tileProvider.destroy();
        for (const destroyable of this._destroyables) {
            destroyable.destroy();
        }
        super.destroy();
    }
    setTileUrlTemplate(tileUrlTemplate) {
        this._tileProvider.sendMessage({
            type: __WEBPACK_IMPORTED_MODULE_17__worker_tile_provider_worker_messages__["a" /* TileProviderMessageType */].TILE_URL_UPDATE,
            tileUrlTemplate
        }, 1 /* IMMEDIATE */);
        this._refreshCurrentTiles();
    }
    _createTileRequest(tileItem, priority) {
        const targetZoom = this._getTargetZoom();
        return Object.assign({}, tileItem, { priority, isVisible: this._isTileVisible(tileItem), zoomMin: targetZoom, zoomMax: targetZoom });
    }
    _requestTiles(requests) {
        const requestId = Object(__WEBPACK_IMPORTED_MODULE_22__util_unique_id__["a" /* uniqueId */])();
        this._onTilesRequest(requests, requestId);
        for (const request of requests) {
            const requestedTileData = {
                isGeometryReady: false,
                areLabelsReady: false
            };
            this._requestedTilesState.set(Object(__WEBPACK_IMPORTED_MODULE_19__tile_based_adapter_tile_id__["a" /* getTileId */])(request), requestedTileData);
        }
        const request = {
            type: __WEBPACK_IMPORTED_MODULE_17__worker_tile_provider_worker_messages__["a" /* TileProviderMessageType */].TILE_REQUEST_BATCH,
            responseType: __WEBPACK_IMPORTED_MODULE_17__worker_tile_provider_worker_messages__["a" /* TileProviderMessageType */].TILE_RESPONSE,
            errorType: __WEBPACK_IMPORTED_MODULE_17__worker_tile_provider_worker_messages__["a" /* TileProviderMessageType */].TILE_ERROR,
            requestId,
            requests
        };
        this._tileProvider.sendMessage(request, 1 /* IMMEDIATE */);
    }
    _cancelTileRequests(requests) {
        for (const request of requests) {
            this._requestedTilesState.delete(Object(__WEBPACK_IMPORTED_MODULE_19__tile_based_adapter_tile_id__["a" /* getTileId */])(request.tile));
        }
        this._onCancelTileRequests(requests);
        this._tileProvider.sendMessage({
            type: __WEBPACK_IMPORTED_MODULE_17__worker_tile_provider_worker_messages__["a" /* TileProviderMessageType */].TILE_REQUEST_CANCEL_BATCH,
            requests
        });
    }
    _onTileDataUpdate(dataToShow, dataToHide) {
        for (const primitiveManager of this._tileDataManagers) {
            primitiveManager.updatePrimitives(dataToShow, dataToHide);
        }
    }
    _onTileDestroy(_tileItem, data) {
        // release primitives that we've created in allocators
        for (const portion of data) {
            (portion.polygons || []).forEach(releasePrimitive);
            (portion.texturedPolygons || []).forEach(releasePrimitive);
            (portion.polylines || []).forEach(releasePrimitive);
            (portion.texturedPolylines || []).forEach(releasePrimitive);
            (portion.points || []).forEach(releasePrimitive);
            (portion.pointLabels || []).forEach(releasePrimitive);
            (portion.curvedLabels || []).forEach(releasePrimitive);
            (portion.models || []).forEach(releasePrimitive);
        }
    }
    _sendStatisticsBeforeDestroy() {
        super._sendStatisticsBeforeDestroy();
        if (this._perfLogItems.length === 0) {
            return;
        }
        const items = this._perfLogItems;
        items.sort((a, b) => a.parseTime - b.parseTime);
        const min = items[0];
        const max = items[items.length - 1];
        const median = items[Math.floor(items.length / 2)];
        Object(__WEBPACK_IMPORTED_MODULE_21__util_stat__["b" /* countTileParseTime */])(this._layerName, min.tile, min.parseTime, max.tile, max.parseTime, median.tile, median.parseTime);
    }
    _onTileProviderResponse(response) {
        this._pushPerfLogItem(response.tile, response.parseTime);
        const tile = response.tile;
        const taskPriority = QUEUE_TASK_PRIORITIES.firstTilePortion +
            this._getTilePriority(tile, this._isTileVisible(tile));
        this._taskQueue.enqueue({
            priority: taskPriority,
            execute: () => {
                // atlas must be updated notwithstanding the tile is active or not
                // as these new glyphs will be used in next tiles
                const atlas = response.glyphAtlasToUpdate;
                if (atlas) {
                    this._glyphAtlas.updateContent(atlas.width, atlas.height, atlas.data, new Map(atlas.glyphLocations));
                }
                const registry = response.fontRegistryToUpdate;
                if (registry) {
                    for (const fontData of registry) {
                        let font;
                        if (this._fontRegistry.contains(fontData.id)) {
                            font = this._fontRegistry.get(fontData.id);
                        }
                        else {
                            font = new __WEBPACK_IMPORTED_MODULE_4__font_df_font__["a" /* default */](fontData.id, fontData.xheight, fontData.margin);
                            this._fontRegistry.add(font);
                        }
                        font.addAllGlyphs(fontData.glyphs);
                    }
                }
                const requestId = response.requestId;
                if (!this._isTileStillActive(tile, requestId)) {
                    return;
                }
                // If tile is being refreshed don't visualize any portions until all of them are loaded to avoid a blink
                const isRefreshing = this._isTileRefreshing(tile);
                const iconsSplitted = splitImageDependantPrimitives(response.points, this._imageManagerNearest, (point) => point.styles[0].imageId);
                const texturedPolylinesSplitted = splitImageDependantPrimitives(response.texturedPolylines, this._imageManagerLinear, (polyline) => polyline.styles[0].inline.pattern.imageId);
                const texturedPolygonsImages = getImagesIfAllAllocated(response.texturedPolygons, this._imageManagerNearest, (polygon) => polygon.styles[0].pattern.imageId);
                this._taskQueue.enqueue({
                    priority: QUEUE_TASK_PRIORITIES.secondTilePortion +
                        this._getTilePriority(tile, this._isTileVisible(tile)),
                    execute: () => {
                        if (this._isTileStillActive(tile, response.requestId)) {
                            this._putTileData(tile, {
                                polygons: this._allocatePolygons(response),
                                models: this._allocateMeshes(response),
                                externalMeshes: response.externalMeshes,
                                polylines: this._allocatePolylines(response),
                                pointLabels: this._allocatePointLabels(response),
                                curvedLabels: this._allocateCurvedLabels(response),
                                points: this._allocateIcons(tile, iconsSplitted.primitivesWithAllocatedImages, iconsSplitted.allocatedImages),
                                texturedPolylines: this._allocateTexturedPolylines(tile, texturedPolylinesSplitted.primitivesWithAllocatedImages, texturedPolylinesSplitted.allocatedImages),
                                texturedPolygons: !texturedPolygonsImages.allocatedImages ?
                                    [] :
                                    this._allocateTexturedPolygons(tile, response.texturedPolygons, texturedPolygonsImages.allocatedImages, response.texturedPolygonPages)
                            }, requestId, !isRefreshing);
                            iconsSplitted.allocatedImages.forEach(releasePrimitive);
                            texturedPolylinesSplitted.allocatedImages.forEach(releasePrimitive);
                            if (texturedPolygonsImages.allocatedImages) {
                                texturedPolygonsImages.allocatedImages.forEach(releasePrimitive);
                            }
                            const requestedTileData = this._requestedTilesState.get(Object(__WEBPACK_IMPORTED_MODULE_19__tile_based_adapter_tile_id__["a" /* getTileId */])(tile));
                            if (requestedTileData !== undefined) {
                                // TODO: the data is synced on these two properties
                                //       and this code doesn't make much sense for now,
                                //       but it is left "as is" since it is not clear
                                //       how it will be changed in nearest future
                                requestedTileData.isGeometryReady = true;
                                requestedTileData.areLabelsReady = true;
                                this._onTileDataReady(tile, response.url);
                            }
                        }
                    }
                });
                const putDataPromises = [];
                putDataPromises.push(iconsSplitted.missingImages.then((images) => {
                    this._onMissingIconImagesReady(response, iconsSplitted, images);
                }));
                putDataPromises.push(texturedPolylinesSplitted.missingImages.then((images) => {
                    this._onMissingPolylineImagesReady(response, texturedPolylinesSplitted, images);
                }));
                if (texturedPolygonsImages.missingImages) {
                    putDataPromises.push(texturedPolygonsImages.missingImages.then((images) => this._onMissingPolygonImagesReady(response, images)));
                }
                if (isRefreshing) {
                    // When all the portions are loaded, put empty data to visuazlize it
                    Promise.all(putDataPromises).then(() => this._putTileData(tile, {}, requestId, true));
                }
            }
        });
    }
    _onMissingIconImagesReady(response, iconsSplitted, images) {
        const tile = response.tile;
        this._minorTaskQueue.enqueue({
            priority: DEFAULT_IDLE_TASK_PRIORITY +
                this._getTilePriority(tile, this._isTileVisible(tile)),
            execute: () => {
                if (this._isTileStillActive(tile, response.requestId)) {
                    const points = this._allocateIcons(tile, iconsSplitted.primitivesWithMissingImages, images);
                    this._putTileData(tile, { points }, response.requestId, false);
                }
                images.forEach(releasePrimitive);
            }
        });
    }
    _onMissingPolylineImagesReady(response, texturedPolylinesSplitted, images) {
        const tile = response.tile;
        this._minorTaskQueue.enqueue({
            priority: DEFAULT_IDLE_TASK_PRIORITY + this._getTilePriority(tile, this._isTileVisible(tile)),
            execute: () => {
                if (this._isTileStillActive(tile, response.requestId)) {
                    const texturedPolylines = this._allocateTexturedPolylines(tile, texturedPolylinesSplitted.primitivesWithMissingImages, images);
                    this._putTileData(tile, { texturedPolylines }, response.requestId, false);
                }
                images.forEach(releasePrimitive);
            }
        });
    }
    _onMissingPolygonImagesReady(response, images) {
        const tile = response.tile;
        this._minorTaskQueue.enqueue({
            priority: DEFAULT_IDLE_TASK_PRIORITY +
                this._getTilePriority(tile, this._isTileVisible(tile)),
            execute: () => {
                if (this._isTileStillActive(tile, response.requestId)) {
                    const texturedPolygons = this._allocateTexturedPolygons(tile, response.texturedPolygons, images, response.texturedPolygonPages);
                    this._putTileData(tile, { texturedPolygons }, response.requestId, false);
                }
                images.forEach(releasePrimitive);
            }
        });
    }
    _onTileError(tile) {
        super._onTileError(tile);
        this._requestedTilesState.delete(Object(__WEBPACK_IMPORTED_MODULE_19__tile_based_adapter_tile_id__["a" /* getTileId */])(tile));
    }
    _isTileVisible(tile) {
        return this._currentTiles.has(Object(__WEBPACK_IMPORTED_MODULE_19__tile_based_adapter_tile_id__["a" /* getTileId */])(tile));
    }
    _allocatePolygons(response) {
        const polygonPrimitives = new Array(response.polygons.length + response.transparentPolygons.length);
        const memoryChunks = new MemoryChunks(response.polygonPages, this._memoryManager, __WEBPACK_IMPORTED_MODULE_10__primitive_polygon_polygon_attribute_mapping__["a" /* POLYGON_ATTRIBUTE_MAPPING */]);
        const transparentPolygonsMemoryChunks = new MemoryChunks(response.transparentPolygonPages, this._memoryManager, __WEBPACK_IMPORTED_MODULE_18__primitive_polygon_transparent_polygon_attribute_mapping__["a" /* TRANSPARENT_POLYGON_ATTRIBUTE_MAPPING */]);
        let index = 0;
        for (let i = 0; i < response.polygons.length; i++, index++) {
            const { bufferLocation } = response.polygons[i];
            polygonPrimitives[index] = new __WEBPACK_IMPORTED_MODULE_23__primitive_polygon_renderable_polygon__["a" /* default */](new __WEBPACK_IMPORTED_MODULE_2__render_memory_sub_chunk__["a" /* default */](memoryChunks[bufferLocation.bufferIndex], bufferLocation), true);
        }
        for (let i = 0; i < response.transparentPolygons.length; i++, index++) {
            const { bufferLocation } = response.transparentPolygons[i];
            polygonPrimitives[index] = new __WEBPACK_IMPORTED_MODULE_23__primitive_polygon_renderable_polygon__["a" /* default */](new __WEBPACK_IMPORTED_MODULE_2__render_memory_sub_chunk__["a" /* default */](transparentPolygonsMemoryChunks[bufferLocation.bufferIndex], bufferLocation), false);
        }
        memoryChunks.forEach((chunk) => chunk.release());
        transparentPolygonsMemoryChunks.forEach((chunk) => chunk.release());
        return polygonPrimitives;
    }
    _allocateTexturedPolygons(tile, polygonDescriptions, images, texturedPolygonPages) {
        const texturedPolygonRewriter = new __WEBPACK_IMPORTED_MODULE_9__primitive_polygon_textured_polygon_buffer_rewiter__["a" /* default */](texturedPolygonPages);
        const worldToPxFactor = WORLD_SIZE / (this._tileSideSizePx * Math.pow(2, tile.zoom));
        const locations = polygonDescriptions.map((parsedPolygon, index) => {
            const image = images[index];
            if (image) {
                const allocatedImage = image;
                const pattern = parsedPolygon.styles[0].pattern;
                const imageScale = pattern.width / allocatedImage.descriptor.width;
                texturedPolygonRewriter.rewriteUV(parsedPolygon.bufferLocation, allocatedImage.bbox, worldToPxFactor * imageScale);
                return parsedPolygon.bufferLocation;
            }
            else {
                return null;
            }
        });
        const memoryChunks = new MemoryChunks(texturedPolygonPages, this._memoryManager, __WEBPACK_IMPORTED_MODULE_11__primitive_polygon_textured_polygon_attribute_mapping__["a" /* TEXTURED_POLYGON_ATTRIBUTE_MAPPING */]);
        const texturedPolygonPrimitives = [];
        for (let i = 0; i < locations.length; i++) {
            const location = locations[i];
            const image = images[i];
            if (location && image) {
                const texturedPolygonPrimitive = new __WEBPACK_IMPORTED_MODULE_24__primitive_polygon_renderable_textured_polygon__["a" /* default */](new __WEBPACK_IMPORTED_MODULE_2__render_memory_sub_chunk__["a" /* default */](memoryChunks[location.bufferIndex], location), image);
                texturedPolygonPrimitives.push(texturedPolygonPrimitive);
            }
        }
        memoryChunks.forEach((chunk) => chunk.release());
        return texturedPolygonPrimitives;
    }
    _allocateMeshes(tileResponse) {
        const memoryChunks = tileResponse.meshPages.map((page) => this._memoryManager.allocate(page.vertexBuffer, page.indexBuffer, __WEBPACK_IMPORTED_MODULE_6__primitive_model_model_buffer_writer__["a" /* default */].ATTRIBUTE_MAPPING));
        const meshPrimitives = tileResponse.meshes.map((mesh) => new __WEBPACK_IMPORTED_MODULE_27__primitive_model_renderable_model__["a" /* default */](new __WEBPACK_IMPORTED_MODULE_2__render_memory_sub_chunk__["a" /* default */](memoryChunks[mesh.bufferLocation.bufferIndex], mesh.bufferLocation)));
        memoryChunks.forEach((chunk) => chunk.release());
        return meshPrimitives;
    }
    _allocatePolylines(response) {
        const polylinePrimitives = new Array(response.polylines.length);
        const memoryChunks = new MemoryChunks(response.polylinePages, this._memoryManager, __WEBPACK_IMPORTED_MODULE_15__primitive_polyline_polyline_attribute_mapping__["a" /* POLYLINE_ATTRIBUTE_MAPPING */]);
        let index = 0;
        for (let i = 0; i < response.polylines.length; i++, index++) {
            const { bufferLocation } = response.polylines[i];
            polylinePrimitives[index] = new __WEBPACK_IMPORTED_MODULE_25__primitive_polyline_renderable_polyline__["a" /* default */](new __WEBPACK_IMPORTED_MODULE_2__render_memory_sub_chunk__["a" /* default */](memoryChunks[bufferLocation.bufferIndex], bufferLocation));
        }
        memoryChunks.forEach((chunk) => chunk.release());
        return polylinePrimitives;
    }
    _allocateTexturedPolylines(tile, parsedPolylines, images) {
        const texturedPolylineWriter = new __WEBPACK_IMPORTED_MODULE_7__primitive_polyline_textured_polyline_buffer_writer__["a" /* default */]();
        const worldToPxFactor = WORLD_SIZE / (this._tileSideSizePx * Math.pow(2, tile.zoom));
        const locations = parsedPolylines.map((parsedPolyline, index) => {
            const image = images[index];
            if (image) {
                const style = parsedPolyline.styles[0];
                const width = (style.inline || style.outline).strokeWidth;
                const imageLocation = image.bbox;
                // image size may not match polyline's strokeWidth, so it must be scaled accordingly in
                // both directions, this factor can be passed to the writer in worldToPxFactor updated.
                const pixelRatio = width / (imageLocation.maxY - imageLocation.minY);
                return texturedPolylineWriter.writeTexturedPolyline(parsedPolyline, width, worldToPxFactor * pixelRatio, imageLocation, style.zIndex);
            }
            else {
                return null;
            }
        });
        const pages = texturedPolylineWriter.getBuffers();
        const memoryChunks = new MemoryChunks(pages, this._memoryManager, __WEBPACK_IMPORTED_MODULE_7__primitive_polyline_textured_polyline_buffer_writer__["a" /* default */].ATTRIBUTE_MAPPING);
        const texturedPolylinePrimitives = [];
        for (let i = 0; i < locations.length; i++) {
            const location = locations[i];
            const image = images[i];
            if (location && image) {
                const texturedPolylinePrimitive = new __WEBPACK_IMPORTED_MODULE_26__primitive_polyline_renderable_textured_polyline__["a" /* default */](new __WEBPACK_IMPORTED_MODULE_2__render_memory_sub_chunk__["a" /* default */](memoryChunks[location.bufferIndex], location), image);
                texturedPolylinePrimitives.push(texturedPolylinePrimitive);
            }
        }
        memoryChunks.forEach((chunk) => chunk.release());
        return texturedPolylinePrimitives;
    }
    _allocatePointLabels(response) {
        const memoryChunks = new MemoryChunks(response.pointLabelPages, this._memoryManager, __WEBPACK_IMPORTED_MODULE_13__primitive_label_point_label_attribute_mapping__["a" /* POINT_LABEL_ATTRIBUTE_MAPPING */]);
        const backgroundMemoryChunks = new MemoryChunks(response.pointLabelBackgroundPages, this._memoryManager, __WEBPACK_IMPORTED_MODULE_12__primitive_billboard_rectangle_attribute_mapping__["a" /* BILLBOARD_RECTANGLE_ATTRIBUTE_MAPPING */]);
        const pointLabels = response.pointLabels.map(({ bufferLocation, backgroundBufferLocation }) => {
            const backgroundPrimitive = backgroundBufferLocation ?
                new __WEBPACK_IMPORTED_MODULE_36__primitive_billboard_rectangle_renderable_billboard_rectangle__["a" /* default */](new __WEBPACK_IMPORTED_MODULE_2__render_memory_sub_chunk__["a" /* default */](backgroundMemoryChunks[backgroundBufferLocation.bufferIndex], backgroundBufferLocation)) :
                undefined;
            const labelPrimitive = new __WEBPACK_IMPORTED_MODULE_37__primitive_zoom_restricted_label__["a" /* ZoomRestrictedLabel */](new __WEBPACK_IMPORTED_MODULE_2__render_memory_sub_chunk__["a" /* default */](memoryChunks[bufferLocation.bufferIndex], bufferLocation), this._glyphAtlas, this._computeMinZoom(response.tile, MINZOOM_DELTAS.pointLabels), backgroundPrimitive);
            if (backgroundPrimitive) {
                backgroundPrimitive.release();
            }
            return labelPrimitive;
        });
        backgroundMemoryChunks.forEach((chunk) => chunk.release());
        memoryChunks.forEach((chunk) => chunk.release());
        return pointLabels;
    }
    _allocateCurvedLabels(response) {
        const memoryChunks = new MemoryChunks(response.curvedLabelPages, this._memoryManager, __WEBPACK_IMPORTED_MODULE_14__primitive_label_curved_label_attribute_mapping__["a" /* CURVED_LABEL_ATTRIBUTE_MAPPING */]);
        const curvedLabelPrimitives = response.curvedLabels.map(({ bufferLocation }) => new __WEBPACK_IMPORTED_MODULE_37__primitive_zoom_restricted_label__["a" /* ZoomRestrictedLabel */](new __WEBPACK_IMPORTED_MODULE_2__render_memory_sub_chunk__["a" /* default */](memoryChunks[bufferLocation.bufferIndex], bufferLocation), this._glyphAtlas, this._computeMinZoom(response.tile, MINZOOM_DELTAS.curvedLabels)));
        memoryChunks.forEach((chunk) => chunk.release());
        return curvedLabelPrimitives;
    }
    _allocateIcons(tile, parsedIcons, images) {
        const iconWriter = new __WEBPACK_IMPORTED_MODULE_1__primitive_icon_icon_buffer_writer__["a" /* default */]();
        const locations = parsedIcons.map((parsedIcon, index) => {
            const image = images[index];
            if (image) {
                const style = parsedIcon.styles[0];
                const size = image.descriptor;
                const pixelRatio = style.width / size.width;
                return iconWriter.writeIcon(parsedIcon, image.bbox, size, style.offset, pixelRatio);
            }
            else {
                return null;
            }
        });
        const pages = iconWriter.getBuffers();
        const memoryChunks = new MemoryChunks(pages, this._memoryManager, __WEBPACK_IMPORTED_MODULE_1__primitive_icon_icon_buffer_writer__["a" /* default */].ATTRIBUTE_MAPPING);
        const iconPrimitives = [];
        for (let i = 0; i < locations.length; i++) {
            const location = locations[i];
            const image = images[i];
            if (location && image) {
                const iconPrimitive = new __WEBPACK_IMPORTED_MODULE_38__primitive_zoom_restricted_icon__["a" /* ZoomRestrictedIcon */](new __WEBPACK_IMPORTED_MODULE_2__render_memory_sub_chunk__["a" /* default */](memoryChunks[location.bufferIndex], location), image, this._computeMinZoom(tile, MINZOOM_DELTAS.icons));
                iconPrimitives.push(iconPrimitive);
            }
        }
        memoryChunks.forEach((chunk) => chunk.release());
        return iconPrimitives;
    }
    /**
     * Computes a minimum zoom an object should be still displayed on.
     *
     * @param tile Tile the object belongs to.
     * @param delta Tolerance of the visibility to zooming out, default value was empirically chosen.
     * @returns Minimum zoom for the object.
     */
    _computeMinZoom(tile, delta = 1) {
        return tile.zoom - this._zoomShift - this._targetZoomShift - delta;
    }
    _pushPerfLogItem(tile, parseTime) {
        if (this._perfLogItems.length < MAX_PERF_LOG_ITEMS_COUNT) {
            this._perfLogItems.push({ tile, parseTime });
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = VectorApiAdapter;

/**
 * Helper class for allocation of an array of memory chunks.
 */
class MemoryChunks extends Array {
    constructor(pages, memoryManager, attribMapping) {
        super(pages.length);
        for (let i = 0; i < pages.length; i++) {
            this[i] = memoryManager.allocate(pages[i].vertexBuffer, pages[i].indexBuffer, attribMapping);
        }
    }
}
/**
 * Data managers responsible for specific type of primitives. It just extracts them from TileData and
 * updates appropriate primitive provider.
 */
class TileDataManager {
    constructor(primitiveManager, primitveExtractor) {
        this._primitiveManager = primitiveManager;
        this._primitiveExtractor = primitveExtractor;
    }
    updatePrimitives(toShow, toHide) {
        this._primitiveManager.updateScene(this._primitiveExtractor(toShow), this._primitiveExtractor(toHide));
    }
}
function releasePrimitive(primitive) {
    if (primitive) {
        primitive.release();
    }
}
/**
 * Turns rejection of original promise into null-value resolution. Nulls on appropriate places
 * are required in allocation of textured primitives.
 */
function nullifyRejection(promise) {
    return new Promise((resolve) => promise.then(resolve, () => resolve(null)));
}
/**
 * Splits primitives into two lists: those that have required images allocated and those which images are to be
 * requested. Required images returned in corresponing arrays (requested images as promises).
 */
function splitImageDependantPrimitives(primitives, imageManager, idMapper) {
    const primitivesWithAllocatedImages = [];
    const allocatedImages = [];
    const primitivesWithMissingImages = [];
    const missingImageIds = [];
    for (const primitive of primitives) {
        const id = idMapper(primitive);
        const allocatedImage = imageManager.getImage(id);
        if (allocatedImage) {
            primitivesWithAllocatedImages.push(primitive);
            allocatedImages.push(allocatedImage);
        }
        else {
            primitivesWithMissingImages.push(primitive);
            missingImageIds.push(nullifyRejection(imageManager.requestImage(id)));
        }
    }
    return {
        primitivesWithAllocatedImages,
        allocatedImages,
        primitivesWithMissingImages,
        missingImages: Promise.all(missingImageIds)
    };
}
/**
 * Returns either array of allocated images (if all required images are on the spot) or promises for them (if at least
 * one required image is not yet allocated).
 */
function getImagesIfAllAllocated(primitives, imageManager, idMapper) {
    let isAnyMissing = false;
    const allocatedImages = new Array(primitives.length);
    const missingImages = new Array(primitives.length);
    for (let i = 0; i < primitives.length; i++) {
        const primitive = primitives[i];
        const id = idMapper(primitive);
        const allocatedImage = imageManager.getImage(id);
        if (allocatedImage) {
            allocatedImages[i] = allocatedImage;
        }
        else {
            isAnyMissing = true;
            missingImages[i] = nullifyRejection(imageManager.requestImage(id));
        }
    }
    if (isAnyMissing) {
        for (let i = 0; i < primitives.length; i++) {
            if (allocatedImages[i]) {
                missingImages[i] = Promise.resolve(allocatedImages[i]);
            }
        }
        return { missingImages: Promise.all(missingImages) };
    }
    else {
        return { allocatedImages };
    }
}


/***/ }),
/* 68 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__adapter__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_tile_system__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_iterable__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__tile_id__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__util_event_emitter__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__math_vector2__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__util_worker__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__util_visible_tile__ = __webpack_require__(72);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__belt_tiles__ = __webpack_require__(73);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__util_stat__ = __webpack_require__(18);










const NO_TILES_TO_HANDLE = [];
const MAX_PERF_LOG_ITEMS_COUNT = 1024;
// To select which tile to load camera zoom is rounded so the shift is 0.5.
const TARGET_ZOOM_SHIFT = 0.25;
const VISIBLE_TILE_PRIORITY = 200;
function* flattenVisibleDataPortions(tiles) {
    for (const tile of tiles) {
        yield* tile.data.visible;
    }
}
function getZoomShift(tileSize) {
    switch (tileSize) {
        case 1 /* X4 */:
            return -1;
        case 2 /* X16 */:
            return -2;
        default:
            return 0;
    }
}
/**
 * Base class for adapters that get their data in tiles. Content of tiles that come into field of view should
 * be requested, as well as content of invisible tiles should be removed, also tiles on different zoom levels can
 * overlap each other. Managing of all these cases and other tile-specific logic is the responsibility of this class.
 */
class TileBasedAdapter extends __WEBPACK_IMPORTED_MODULE_0__adapter__["a" /* default */] {
    constructor(engine, camera, tileSize = 0 /* X1 */, preloadedTilesBeltSize = 0, layerName = '') {
        super(engine, camera);
        this._layerName = layerName;
        this._zoomShift = getZoomShift(tileSize);
        this._targetZoomShift = TARGET_ZOOM_SHIFT;
        this._engineRenderListener = () => this._onEngineRenderEvent();
        this.engine.renderer.onRender.addListener(this._engineRenderListener);
        this._currentTiles = new Map();
        this._allTiles = new Map();
        this._readyForRenderTiles = [];
        this.onTileReady = new __WEBPACK_IMPORTED_MODULE_4__util_event_emitter__["a" /* EventEmitter */]();
        this.onTileLoadChange = new __WEBPACK_IMPORTED_MODULE_4__util_event_emitter__["a" /* EventEmitter */]();
        this._requestedTiles = new Map();
        this._tilesToRefresh = new Set();
        this._beltSize = preloadedTilesBeltSize;
        // Sometimes the adapter isn't destroyed, just the page closes. Listen
        // for that and send measurements to the statface.
        window.addEventListener('beforeunload', this._onBeforeUnloadListener = this._sendStatisticsBeforeDestroy.bind(this));
        this._tileLoadLogs = [];
    }
    destroy() {
        window.removeEventListener('beforeunload', this._onBeforeUnloadListener);
        this._sendStatisticsBeforeDestroy();
        this.engine.renderer.onRender.removeListener(this._engineRenderListener);
        super.destroy();
    }
    getVisibleTilesNumber() {
        return this._currentTiles.size;
    }
    getPendingTilesNumber() {
        let pendingCounter = 0;
        this._requestedTiles.forEach((requestedTile) => {
            if (this._currentTiles.get(Object(__WEBPACK_IMPORTED_MODULE_3__tile_id__["a" /* getTileId */])(requestedTile.tileItem))) {
                pendingCounter++;
            }
        });
        return pendingCounter;
    }
    _getTargetZoom() {
        return Math.floor(this.camera.zoom + this._targetZoomShift);
    }
    /**
     * @param tileItem The tile to which the data belongs.
     * @param data Data portion to be shown in tile once it is ready to visualize.
     * @param requestId ID of the request data was requested with. Based on this the data is being displayed, stored for
     * future use or discarded.
     * @param visualize Is this data portion enough to render this tile and replace overlapped ones if any.
     */
    _putTileData(tileItem, data, requestId = __WEBPACK_IMPORTED_MODULE_6__util_worker__["a" /* NO_ID */], visualize = true) {
        const tile = this._allTiles.get(Object(__WEBPACK_IMPORTED_MODULE_3__tile_id__["a" /* getTileId */])(tileItem));
        if (!tile) {
            // Data recieved late and probably the tile had been destroyed.
            // Destroy data too.
            this._onTileDestroy(tileItem, [data]);
            return;
        }
        // NO_ID passed here means concrete adapter doesn't care to label tile data with a requestId which most likely
        // means adapter keeps its data as a whole, not splitting it into portions and, therefore, doesn't need its data
        // to be maintained separately as visible/actual. In this case the data is always treated like an actual data.
        if (requestId === tile.data.visibleRequestId && requestId !== __WEBPACK_IMPORTED_MODULE_6__util_worker__["a" /* NO_ID */]) {
            tile.data.visible.push(data);
            if (tile.isVisible) {
                // The data is currently displayed so the new portion is added to the scene.
                this._updateTileDataPortions([data], []);
            }
        }
        else if (requestId === tile.data.actualRequestId) {
            // The data is actual and either is just being put into the tile or visualizes all `actual` tile data.
            this._putActualTileData(tile, data, visualize);
        }
        else {
            // The data is neither visible nor actual. Destroy data.
            this._onTileDestroy(tileItem, [data]);
        }
    }
    _onCameraUpdate() {
        const camera = this.camera;
        const zoom = this._getTargetZoom();
        const newCurrent = new Set(Object(__WEBPACK_IMPORTED_MODULE_7__util_visible_tile__["a" /* computeVisibleTiles */])(camera.getVisibleRegion(), camera.getVisibleRegionBBox(), camera.options.wrapModeX, camera.options.wrapModeY, Math.max(0, zoom + this._zoomShift)));
        // this._currentTiles contains currently visible tiles, newCurrent contains set of tiles visible from updated
        // camera position, compare these two sets and call this._onVisibleTilesChanged() if there is a difference.
        if (newCurrent.size !== this._currentTiles.size ||
            Object(__WEBPACK_IMPORTED_MODULE_2__util_iterable__["d" /* oneOfIterable */])(newCurrent, (tile) => !this._currentTiles.has(Object(__WEBPACK_IMPORTED_MODULE_3__tile_id__["a" /* getTileId */])(tile)))) {
            this._onVisibleTilesChanged(newCurrent);
        }
        // this checks prevents leaks of tiles when quick zoom-in/zoom-out happens
        for (const tile of this._currentTiles.values()) {
            if (tile.isReadyToVisualize) {
                this._checkTileReplacements(tile);
            }
        }
    }
    _onTilesRequest(requests, requestId = __WEBPACK_IMPORTED_MODULE_6__util_worker__["a" /* NO_ID */]) {
        for (const tileRequest of requests) {
            const requestedTileData = {
                info: {
                    priority: tileRequest.priority
                },
                loadTimestamps: {
                    queued: performance.now(),
                    loaded: 0,
                    rendered: 0,
                    ready: 0
                },
                tileItem: tileRequest
            };
            const tileId = Object(__WEBPACK_IMPORTED_MODULE_3__tile_id__["a" /* getTileId */])(tileRequest);
            this._requestedTiles.set(tileId, requestedTileData);
            this._readyTilesChange = true;
            const tile = this._allTiles.get(tileId);
            if (tile) {
                tile.data.actualRequestId = requestId;
            }
        }
    }
    _onCancelTileRequests(requests) {
        for (const request of requests) {
            const tileId = Object(__WEBPACK_IMPORTED_MODULE_3__tile_id__["a" /* getTileId */])(request.tile);
            if (this._requestedTiles.delete(tileId)) {
                this._readyTilesChange = true;
                this._tilesToRefresh.delete(tileId);
            }
        }
    }
    _onTileError(tileItem) {
        const tileId = Object(__WEBPACK_IMPORTED_MODULE_3__tile_id__["a" /* getTileId */])(tileItem);
        if (this._requestedTiles.delete(tileId)) {
            this._readyTilesChange = true;
            this._tilesToRefresh.delete(tileId);
        }
    }
    /**
     * This method is where the whole magic happens, it manages replacement of current set of visible/preloaded tiles
     * with a new one.
     */
    _onVisibleTilesChanged(visibleTiles) {
        this._currentTiles.clear();
        const tilesToRequest = [];
        for (const tileItem of visibleTiles) {
            let tile = this._allTiles.get(Object(__WEBPACK_IMPORTED_MODULE_3__tile_id__["a" /* getTileId */])(tileItem));
            if (!tile) {
                tile = new Tile(tileItem);
                this._allTiles.set(tile.id, tile);
                this._currentTiles.set(tile.id, tile);
                tilesToRequest.push(this._createTileRequest(tileItem, this._getTilePriority(tile.tileItem, true)));
            }
            else {
                this._currentTiles.set(tile.id, tile);
            }
        }
        if (tilesToRequest.length > 0) {
            this._requestTiles(tilesToRequest);
        }
        const beltTiles = new Map();
        for (const beltTileItem of Object(__WEBPACK_IMPORTED_MODULE_8__belt_tiles__["a" /* calculateBeltTiles */])(visibleTiles, this._beltSize, this.camera.options.wrapModeX === 2 /* REPEAT */, this.camera.options.wrapModeY === 2 /* REPEAT */)) {
            beltTiles.set(Object(__WEBPACK_IMPORTED_MODULE_3__tile_id__["a" /* getTileId */])(beltTileItem), beltTileItem);
        }
        const beltTilesToRequest = [];
        for (const beltTileItem of beltTiles.values()) {
            const tileId = Object(__WEBPACK_IMPORTED_MODULE_3__tile_id__["a" /* getTileId */])(beltTileItem);
            let tile = this._allTiles.get(tileId);
            if (!tile) {
                tile = new Tile(beltTileItem);
                this._allTiles.set(tileId, tile);
                beltTilesToRequest.push(this._createTileRequest(beltTileItem, this._getTilePriority(beltTileItem, false)));
            }
        }
        if (beltTilesToRequest.length) {
            this._requestTiles(beltTilesToRequest);
        }
        // broke current relationships to set them up again but with new set of visible tiles
        for (const tile of this._allTiles.values()) {
            tile.toBeReplacedBy.clear();
            tile.replacementFor.clear();
        }
        // TODO: optimize this n^2 relationships resolver
        for (const currentTile of this._currentTiles.values()) {
            for (const tile of this._allTiles.values()) {
                if (tile.isReadyToVisualize &&
                    (Object(__WEBPACK_IMPORTED_MODULE_1__util_tile_system__["b" /* isParent */])(tile.tileItem, currentTile.tileItem) || Object(__WEBPACK_IMPORTED_MODULE_1__util_tile_system__["b" /* isParent */])(currentTile.tileItem, tile.tileItem))) {
                    tile.toBeReplacedBy.add(currentTile);
                    currentTile.replacementFor.add(tile);
                }
            }
        }
        // remove invisible
        const tilesToCancel = [];
        for (const tile of this._allTiles.values()) {
            if (!this._currentTiles.has(tile.id) && tile.toBeReplacedBy.size === 0) {
                if (tile.isVisible) {
                    this._updateTileData(NO_TILES_TO_HANDLE, [tile]);
                }
                if (!beltTiles.get(tile.id)) {
                    this._destroyTile(tile);
                    tilesToCancel.push(tile);
                }
            }
        }
        if (tilesToCancel.length) {
            // issue cancellation also in case there are non processed data enqueued to try to save some efforts
            this._cancelTileRequests(tilesToCancelations(tilesToCancel));
        }
    }
    _refreshCurrentTiles() {
        const tilesToRequest = [];
        for (const tile of this._currentTiles.values()) {
            const tileItem = tile.tileItem;
            const tileRequest = this._createTileRequest(tileItem, this._getTilePriority(tile.tileItem, true));
            tilesToRequest.push(tileRequest);
            this._tilesToRefresh.add(Object(__WEBPACK_IMPORTED_MODULE_3__tile_id__["a" /* getTileId */])(tile.tileItem));
        }
        this._cancelTileRequests(tilesToCancelations(this._currentTiles.values()));
        this._requestTiles(tilesToRequest);
    }
    _onTileDataReady(tileItem, url) {
        const tileId = Object(__WEBPACK_IMPORTED_MODULE_3__tile_id__["a" /* getTileId */])(tileItem);
        const tileData = this._requestedTiles.get(tileId);
        this._requestedTiles.delete(tileId);
        this._tilesToRefresh.delete(tileId);
        tileData.info.url = url;
        tileData.loadTimestamps.loaded = performance.now();
        if (this._tileLoadLogs.length < MAX_PERF_LOG_ITEMS_COUNT) {
            this._tileLoadLogs.push({
                tileItem,
                processingTime: tileData.loadTimestamps.loaded - tileData.loadTimestamps.queued
            });
        }
        this._readyForRenderTiles.push(tileData);
        if (this._currentTiles.get(tileId)) {
            this._readyTilesChange = true;
        }
    }
    _isTileStillActive(tileItem, requestId = __WEBPACK_IMPORTED_MODULE_6__util_worker__["a" /* NO_ID */]) {
        const tile = this._allTiles.get(Object(__WEBPACK_IMPORTED_MODULE_3__tile_id__["a" /* getTileId */])(tileItem));
        if (!tile) {
            return false;
        }
        const isRequestActive = tile.data.actualRequestId === requestId || tile.data.visibleRequestId === requestId;
        return isRequestActive;
    }
    _isTileRefreshing(tile) {
        return this._tilesToRefresh.has(Object(__WEBPACK_IMPORTED_MODULE_3__tile_id__["a" /* getTileId */])(tile));
    }
    _getTilePriority(tile, isVisible) {
        const center = this._createTileCoordinateSystem().toTileCoordinates(this.camera.center);
        const zoomDiff = Math.ceil(this.camera.zoom) - tile.zoom;
        const distance = __WEBPACK_IMPORTED_MODULE_5__math_vector2__["j" /* distance */](tile, {
            x: Math.floor(center.x / Math.pow(2, zoomDiff)),
            y: Math.floor(center.y / Math.pow(2, zoomDiff))
        });
        return (isVisible ? VISIBLE_TILE_PRIORITY : 0) + 1 / (distance + 1);
    }
    _sendStatisticsBeforeDestroy() {
        if (this._tileLoadLogs.length === 0) {
            return;
        }
        const accumulatedTimings = new Map();
        accumulatedTimings.set('average', {
            sum: 0,
            number: 0
        });
        this._tileLoadLogs.forEach((logItem) => {
            accumulatedTimings.get('average').sum += logItem.processingTime;
            accumulatedTimings.get('average').number++;
            const zoom = logItem.tileItem.zoom.toString();
            if (!accumulatedTimings.has(zoom)) {
                accumulatedTimings.set(zoom, {
                    sum: 0,
                    number: 0
                });
            }
            accumulatedTimings.get(zoom).sum += logItem.processingTime;
            accumulatedTimings.get(zoom).number++;
        });
        const result = [];
        for (const item of accumulatedTimings) {
            result.push({
                zoom: item[0],
                time: (item[1].sum / item[1].number)
            });
        }
        Object(__WEBPACK_IMPORTED_MODULE_9__util_stat__["c" /* countTileProcessingTime */])(this._layerName, result);
    }
    /**
     * Puts actual data into the tile and optionally visualizes it.
     *
     * @param tile Tile to put data into.
     * @param data Data to be stored in the tile until visualization.
     * @param visualize If `true` replaces `visible` tile data with `actual` tile data and updates the scene.
     */
    _putActualTileData(tile, data, visualize) {
        tile.data.actual.push(data);
        if (visualize) {
            this._visualizeTile(tile);
        }
    }
    /**
     * Visualizes tile `actual` data: replaces tile `visible` data with tile `actual` data, adds it to the scene,
     * removes old visible data from the scene and destroys it, checks tile replacements and updates `visibleRequestId`.
     * @param tile Tile to visualize.
     */
    _visualizeTile(tile) {
        const toDestroy = tile.data.visible;
        tile.data.visible = tile.data.actual;
        tile.data.actual = [];
        tile.data.visibleRequestId = tile.data.actualRequestId;
        if (!tile.isReadyToVisualize) {
            tile.isReadyToVisualize = true;
            this._checkTileReplacements(tile);
        }
        else if (tile.isVisible) {
            this._updateTileDataPortions(tile.data.visible, []);
        }
        if (toDestroy.length > 0) {
            this._updateTileDataPortions([], toDestroy);
            this._onTileDestroy(tile.tileItem, toDestroy);
        }
    }
    _createTileCoordinateSystem() {
        return new __WEBPACK_IMPORTED_MODULE_1__util_tile_system__["a" /* default */](this.camera.zoom);
    }
    // We need do detect when tile is rendered to collect perfomance metrics.
    // We expect that tile will be rendered with first render event after
    // tile data is added to scene.
    _onEngineRenderEvent() {
        if (this._readyForRenderTiles.length) {
            this._readyForRenderTiles.forEach((tileData) => {
                if (this._currentTiles.has(Object(__WEBPACK_IMPORTED_MODULE_3__tile_id__["a" /* getTileId */])(tileData.tileItem))) {
                    tileData.loadTimestamps.rendered = performance.now();
                    tileData.loadTimestamps.ready = performance.now();
                    this.onTileReady.fire(tileData);
                }
            });
            this._readyForRenderTiles.length = 0;
        }
        if (this._readyTilesChange) {
            this.onTileLoadChange.fire({
                totalTileNumber: this.getVisibleTilesNumber(),
                readyTileNumber: this.getVisibleTilesNumber() - this.getPendingTilesNumber()
            });
            this._readyTilesChange = false;
        }
    }
    /**
     * Shows/hides tiles if they are not shown/hidden yet. It notifies subclasses by calling appropriate
     * abstract method. Even though visible/invisible tiles are not supposed to be shown/hidden again,
     * there are cases where it simplifies tile visualization logic.
     * It is important to have exactly "update", not "add"/"remove" separately, as some business logic may rely on it,
     * e.g. morphing visible data or managing shared resources.
     */
    _updateTileData(toShow, toRemove) {
        const dataToShow = Array.from(flattenVisibleDataPortions(toShow));
        const dataToRemove = Array.from(flattenVisibleDataPortions(toRemove));
        this._updateTileDataPortions(dataToShow, dataToRemove);
        for (const tile of toShow) {
            tile.isVisible = true;
        }
        for (const tile of toRemove) {
            tile.isVisible = false;
        }
    }
    _updateTileDataPortions(toShow, toRemove) {
        this._onTileDataUpdate(toShow, toRemove);
    }
    /**
     * Removes tile if is not removed with calling all appropriate callbacks (abstract methods)
     * to notify descendant classes. Even though removed tile is not supposed to be removed again,
     * allowing this makes much simpler tile management, especially in tile replacements logic where multiple
     * tiles can have links to the same tile (that is to be removed).
     */
    _destroyTile(tile) {
        if (!tile.isRemoved) {
            tile.isRemoved = true;
            this._allTiles.delete(tile.id);
            this._currentTiles.delete(tile.id);
            this._onTileDestroy(tile.tileItem, [...tile.data.actual, ...tile.data.visible]);
        }
    }
    /**
     * Checks tiles that could be replaced by this one, should be called when tile becomes ready to visualize.
     * As overlapping relationships can happen in both directions (children by parents / parent by children) this
     * method goes one step deeper, i.e. it check not only tiles that should be replaced (to remove them),
     * but also all tiles that cover the replaced ones (to show them).
     */
    _checkTileReplacements(tile) {
        const toDestroy = new Set();
        const toShow = new Set();
        const toHide = new Set();
        for (const tileToReplace of tile.replacementFor) {
            if (Object(__WEBPACK_IMPORTED_MODULE_2__util_iterable__["a" /* allOfIterable */])(tileToReplace.toBeReplacedBy, (tile) => tile.isReadyToVisualize)) {
                if (tileToReplace.isVisible) {
                    toHide.add(tileToReplace);
                }
                if (!tileToReplace.isRemoved) {
                    toDestroy.add(tileToReplace);
                }
                for (const tileToShow of tileToReplace.toBeReplacedBy) {
                    if (!tileToShow.isVisible) {
                        toShow.add(tileToShow);
                    }
                }
            }
        }
        if (tile.replacementFor.size === 0 && !tile.isVisible) {
            toShow.add(tile);
        }
        if (toShow.size > 0 || toHide.size > 0) {
            this._updateTileData(toShow, toHide);
        }
        for (const tileToDestroy of toDestroy) {
            this._destroyTile(tileToDestroy);
        }
        if (toDestroy.size > 0) {
            this._cancelTileRequests(tilesToCancelations(toDestroy));
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = TileBasedAdapter;

/**
 * This class is the main unit of the whole process of tile management. It stores visualizable data and links to
 * dependant tiles (for parent/child overlapping cases).
 */
class Tile {
    constructor(tileItem) {
        this.data = {
            actual: [],
            visible: [],
            actualRequestId: __WEBPACK_IMPORTED_MODULE_6__util_worker__["a" /* NO_ID */],
            visibleRequestId: __WEBPACK_IMPORTED_MODULE_6__util_worker__["a" /* NO_ID */]
        };
        this.tileItem = tileItem;
        this.id = `${tileItem.x}:${tileItem.y}:${tileItem.zoom}`;
        this.isReadyToVisualize = false;
        this.isVisible = false;
        this.isRemoved = false;
        this.toBeReplacedBy = new Set();
        this.replacementFor = new Set();
    }
}
function tilesToCancelations(tiles) {
    return Array.from(tiles, (tile) => ({
        tile: tile.tileItem,
        requestId: tile.data.actualRequestId
    }));
}


/***/ }),
/* 69 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_function__ = __webpack_require__(70);

class Adapter {
    constructor(engine, camera, cameraUpdateDelay = 5) {
        this.engine = engine;
        this.camera = camera;
        this._cameraUpdateListener = Object(__WEBPACK_IMPORTED_MODULE_0__util_function__["a" /* debounce */])(this._onCameraUpdate.bind(this), cameraUpdateDelay);
        camera.onUpdate.addListener(this._cameraUpdateListener);
    }
    destroy() {
        this.camera.onUpdate.removeListener(this._cameraUpdateListener);
    }
    /**
     * Camera update handler, by default do nothing.
     */
    _onCameraUpdate() { }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Adapter;



/***/ }),
/* 70 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = debounce;
/**
 * Creates new function which execution is "debounced".
 */
function debounce(func, wait) {
    let timeout = 0;
    return (...args) => {
        const later = () => {
            timeout = 0;
            func(...args);
        };
        if (timeout) {
            clearTimeout(timeout);
        }
        timeout = setTimeout(later, wait);
    };
}


/***/ }),
/* 71 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = isParent;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_scalar__ = __webpack_require__(9);

/**
 * @return `true` if the first param overlaps the second in tile hierarchy.
 */
function isParent(potentialParent, possibleChild) {
    const zoomDiff = possibleChild.zoom - potentialParent.zoom;
    return zoomDiff > 0 &&
        possibleChild.x >> zoomDiff === potentialParent.x &&
        possibleChild.y >> zoomDiff === potentialParent.y;
}
class TileCoordinateSystem {
    constructor(zoom) {
        this._zoom = Math.ceil(Object(__WEBPACK_IMPORTED_MODULE_0__math_scalar__["a" /* clamp */])(zoom, 0, 31));
        this._tileSize = 2 / (1 << this._zoom);
    }
    getZoom() {
        return this._zoom;
    }
    /**
     * @return Tile side length in units of the world coordinate system.
     */
    getTileSize() {
        return this._tileSize;
    }
    /**
     * @return Top left corner coordinates of the tile.
     */
    getTileOffset(tile) {
        return {
            x: this.getTileSize() * tile.x - 1,
            y: 1 - this.getTileSize() * tile.y
        };
    }
    toTileCoordinates(worldCoordinates) {
        return {
            x: (worldCoordinates.x + 1) / this._tileSize,
            y: (1 - worldCoordinates.y) / this._tileSize
        };
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = TileCoordinateSystem;



/***/ }),
/* 72 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = computeVisibleTiles;
const TILE_0_0_0 = { x: 0, y: 0, zoom: 0 };
/**
 * Computes set of tiles visible through a camera. Tiles in the set are guaranteed
 * to be unique.
 *
 * FIXME(dmikis) The uniqueness guarantee is broken currently, but code that uses
 *      this function doesn't suffer from that.
 *
 * @param camera The camera.
 * @returns An iterator over visible tile items.
 */
function* computeVisibleTiles(visibleRegion, visibleRegionBBox, wrapModeX, wrapModeY, zoom) {
    if (zoom === 0) {
        // The only tile on zoom 0 encompasses the whole world. Thus there's
        // little to no point computing that camera sees it: we can tell that
        // right away.
        yield TILE_0_0_0;
        return;
    }
    const tileCount = 1 << zoom;
    const tileIdxMask = tileCount - 1;
    // The idea behind the code below is quite simple: determine columns of the
    // tile grid that are visible to the camera, then for each column find
    // range of row indices that are visible.
    // Here's how we approach computing tile indices from world coordinates.
    // First, we transform world coordinates from [-1, 1] range to [0, 2],
    // dealing with inconsistency with Y axis direction in world and tile grid
    // coordinate system. Let's designate such a coordinate as C (for either X
    // or Y). Size of a tile is 2 / tileCount. Thus,
    //
    //      tileIdx = Math.floor(C / (2 / tileCount))
    //              = Math.floor(C * tileCount / 2)
    //
    const { minX, maxX, minY, maxY } = visibleRegionBBox;
    const minTX = Math.floor((minX + 1) * tileCount / 2);
    const maxTX = Math.floor((maxX + 1) * tileCount / 2);
    const columnCount = maxTX - minTX + 1;
    // Arrays of indices of bottommost and topmost tiles correspondingly for
    // each column.
    // FIXME(dmikis) If number of columns is too large, we'll consume a lot of
    //      memory here. There's a method to do without the arrays, but it's a
    //      bit more complicated to implement.
    const minYs = new Array(columnCount);
    const maxYs = new Array(columnCount);
    // Common sense suggests that those indices can't be greater (less) than the
    // index of a tile row intersected by a line y = minY (y = maxY). Note that
    // maxY corresponds to a tile row with lesser index, not other way around.
    minYs.fill(Math.floor((1 - minY) * tileCount / 2));
    maxYs.fill(Math.floor((1 - maxY) * tileCount / 2));
    const visiblePolygonLength = visibleRegion.length;
    let prevX = visibleRegion[visiblePolygonLength - 1].x + 1;
    let prevY = 1 - visibleRegion[visiblePolygonLength - 1].y;
    let prevTX = Math.floor(prevX * tileCount / 2);
    let prevTY = Math.floor(prevY * tileCount / 2);
    // Iterate over edges of visible polygon of the camera to compute index of
    // topmost and bottommost tiles for each column.
    for (let i = 0; i < visiblePolygonLength; ++i) {
        const x = visibleRegion[i].x + 1;
        const y = 1 - visibleRegion[i].y;
        const tx = Math.floor(x * tileCount / 2);
        const ty = Math.floor(y * tileCount / 2);
        // For each edge we compute 4-connected line of tiles on the tile grid.
        // Length of a 4-connected line always equals Manhattan distance between
        // its ends. However, to avoid unnecessary computation, we omit last tile
        // for every edge. But, since the polygon is closed, we'll iterate over
        // all tiles intersected by edges anyway.
        const l = Math.abs(tx - prevTX) + Math.abs(ty - prevTY);
        const lx = x - prevX;
        const ly = y - prevY;
        const dtx = lx > 0 ? 1 : -1;
        const dty = ly > 0 ? 1 : -1;
        const a = 2 * dtx * ly;
        const b = -2 * dtx * lx;
        const c = dtx * tileCount * (lx * prevY - ly * prevX) + a * (~dtx >>> 31);
        for (let i = 0, tx = prevTX, ty = prevTY; i < l; ++i) {
            const intercept = a * tx + b * ty + c;
            // The math here is somewhat cumbersome to avoid divisions, but the
            // essence is that we try to check through which side the edge of
            // visible polygon exits the tile. Depending on that we "move" to
            // next tile in either vertical or horizontal direction.
            if (0 <= intercept && intercept <= -b) {
                tx += dtx;
            }
            else {
                ty += dty;
            }
            const yIdx = tx - minTX;
            if (maxYs[yIdx] < ty) {
                maxYs[yIdx] = ty;
            }
            if (minYs[yIdx] > ty) {
                minYs[yIdx] = ty;
            }
        }
        prevX = x;
        prevY = y;
        prevTX = tx;
        prevTY = ty;
    }
    // If the world is repeated along X axis, we need to "fold" the array of columns,
    // i.e. compute union of row intervals for columns tileCount indices apart.
    if (wrapModeX === 2 /* REPEAT */ && columnCount > tileCount) {
        for (let i = 0; i < tileCount; ++i) {
            for (let j = i + tileCount; j < columnCount; j += tileCount) {
                if (maxYs[i] < maxYs[j]) {
                    maxYs[i] = maxYs[j];
                }
                if (minYs[i] > minYs[j]) {
                    minYs[i] = minYs[j];
                }
            }
        }
    }
    // If the world is repeated along Y axis, we need to wrap indices in minYs
    // and maxYs arrays to [0, tileCount) interval.
    if (wrapModeY === 2 /* REPEAT */) {
        for (let i = 0; i < columnCount && i < tileCount; ++i) {
            const dy = maxYs[i] - minYs[i];
            // If there's more than tileCount rows between maxY and minY, then the
            // world is encompassed somewhere within visible region.
            if (dy > tileCount) {
                minYs[i] = 0;
                maxYs[i] = tileIdxMask;
            }
            else {
                const minY = minYs[i] &= tileIdxMask;
                maxYs[i] = minY + dy;
            }
        }
    }
    else {
        for (let i = 0; i < columnCount && i < tileCount; ++i) {
            minYs[i] = Math.max(minYs[i], 0);
            maxYs[i] = Math.min(maxYs[i], tileIdxMask);
        }
    }
    if (wrapModeX === 2 /* REPEAT */) {
        for (let i = 0; i < columnCount && i < tileCount; ++i) {
            const tx = (i + minTX) & tileIdxMask;
            for (let ty = minYs[i]; ty <= maxYs[i]; ++ty) {
                yield {
                    x: tx,
                    y: ty & tileIdxMask,
                    zoom
                };
            }
        }
    }
    else {
        for (let tx = Math.max(minTX, 0), txEnd = Math.min(maxTX, tileIdxMask); tx <= txEnd; ++tx) {
            const i = tx - minTX;
            for (let ty = minYs[i]; ty <= maxYs[i]; ++ty) {
                yield {
                    x: tx,
                    y: ty & tileIdxMask,
                    zoom
                };
            }
        }
    }
}


/***/ }),
/* 73 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = calculateBeltTiles;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__tile_id__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math_vector2__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math_scalar__ = __webpack_require__(9);



const LEFT_SIDE = {
    direction: __WEBPACK_IMPORTED_MODULE_1__math_vector2__["f" /* create */](0, -1),
    normal: __WEBPACK_IMPORTED_MODULE_1__math_vector2__["f" /* create */](-1, 0),
    diagonal: __WEBPACK_IMPORTED_MODULE_1__math_vector2__["f" /* create */](-1, -1),
    prevSide: () => BOTTOM_SIDE,
    nextSide: () => TOP_SIDE
};
const RIGHT_SIDE = {
    direction: __WEBPACK_IMPORTED_MODULE_1__math_vector2__["f" /* create */](0, +1),
    normal: __WEBPACK_IMPORTED_MODULE_1__math_vector2__["f" /* create */](+1, 0),
    diagonal: __WEBPACK_IMPORTED_MODULE_1__math_vector2__["f" /* create */](+1, +1),
    prevSide: () => TOP_SIDE,
    nextSide: () => BOTTOM_SIDE
};
const TOP_SIDE = {
    direction: __WEBPACK_IMPORTED_MODULE_1__math_vector2__["f" /* create */](+1, 0),
    normal: __WEBPACK_IMPORTED_MODULE_1__math_vector2__["f" /* create */](0, -1),
    diagonal: __WEBPACK_IMPORTED_MODULE_1__math_vector2__["f" /* create */](+1, -1),
    prevSide: () => LEFT_SIDE,
    nextSide: () => RIGHT_SIDE
};
const BOTTOM_SIDE = {
    direction: __WEBPACK_IMPORTED_MODULE_1__math_vector2__["f" /* create */](-1, 0),
    normal: __WEBPACK_IMPORTED_MODULE_1__math_vector2__["f" /* create */](0, +1),
    diagonal: __WEBPACK_IMPORTED_MODULE_1__math_vector2__["f" /* create */](-1, +1),
    prevSide: () => RIGHT_SIDE,
    nextSide: () => LEFT_SIDE
};
/**
 * Adds tile to belt tiles if it doesn't fall out of the world. Cycling coordinates can't fall out,
 * they just got adjusted directly in tile item.
 */
function addTileIfAppropriate(tile, beltTiles, maxCoordinate, isXCycled, isYCycled) {
    tile.x = isXCycled ? Object(__WEBPACK_IMPORTED_MODULE_2__math_scalar__["b" /* cycleRestrict */])(tile.x, 0, maxCoordinate) : tile.x;
    tile.y = isYCycled ? Object(__WEBPACK_IMPORTED_MODULE_2__math_scalar__["b" /* cycleRestrict */])(tile.y, 0, maxCoordinate) : tile.y;
    if ((0 <= tile.x) && (tile.x < maxCoordinate) &&
        (0 <= tile.y) && (tile.y < maxCoordinate)) {
        beltTiles.set(Object(__WEBPACK_IMPORTED_MODULE_0__tile_id__["a" /* getTileId */])(tile), tile);
    }
}
/**
 * The algorithm is implemented as a state machine, this method produces belt tiles and sets appropriate state.
 * How to change this state (determine current tile and its side) is described in four TileSide implementations:
 * left, right, top and bottom.
 */
function move(tiles, state, size, maxCoordinate, isXCycled, isYCycled) {
    // add tiles outward in the direction of the normal
    for (let i = 1; i <= size; i++) {
        addTileIfAppropriate({
            x: state.currentTile.x + i * state.currentTileSide.normal.x,
            y: state.currentTile.y + i * state.currentTileSide.normal.y,
            zoom: state.currentTile.zoom
        }, state.beltTiles, maxCoordinate, isXCycled, isYCycled);
    }
    // check diagonal tile
    const diagonalNeighbour = tiles.get(Object(__WEBPACK_IMPORTED_MODULE_0__tile_id__["b" /* getTileIdByRawValues */])(state.currentTile.x + state.currentTileSide.diagonal.x, state.currentTile.y + state.currentTileSide.diagonal.y, state.currentTile.zoom));
    if (diagonalNeighbour) {
        state.currentTile = diagonalNeighbour;
        state.currentTileSide = state.currentTileSide.prevSide();
        return;
    }
    // check neighbour in the same direction
    const neighbour = tiles.get(Object(__WEBPACK_IMPORTED_MODULE_0__tile_id__["b" /* getTileIdByRawValues */])(state.currentTile.x + state.currentTileSide.direction.x, state.currentTile.y + state.currentTileSide.direction.y, state.currentTile.zoom));
    if (neighbour) {
        state.currentTile = neighbour;
        return;
    }
    // handle corner tiles
    for (let i = 1; i <= size; i++) {
        for (let j = 1; j <= size; j++) {
            addTileIfAppropriate({
                x: state.currentTile.x + i * state.currentTileSide.diagonal.x,
                y: state.currentTile.y + j * state.currentTileSide.diagonal.y,
                zoom: state.currentTile.zoom
            }, state.beltTiles, maxCoordinate, isXCycled, isYCycled);
        }
    }
    state.currentTileSide = state.currentTileSide.nextSide();
}
/**
 * Calculates tiles that surround provided region (set of tiles), the region must be one or more convex polygons
 * with no holes, otherwise correctness is not guaranteed. Multiple polygons can happen when the camera looks
 * at the edge of the world capturing cycled tiles from different sides.
 * The logic of including tiles in the "belt" is as follows: shortest distance from "outside" to any point
 * in the original region should be not less than tileSize * beltSize.
 *
 * @param tiles Set of tiles that cover a convex polygon.
 * @param beltSize "thickness" (in tiles) of the surrounding area.
 */
function calculateBeltTiles(tiles, beltSize, isXCycled, isYCycled) {
    // the algorithm in simple words:
    //   1. find a tile on an edge of the polygon (e.g. one of the leftmost ones)
    //   2. go around the polygon tile-by-tile adding surrounding tiles outwardly
    const indexedTiles = new Map();
    const beltTiles = new Map();
    // index tiles
    for (const tileItem of tiles) {
        indexedTiles.set(Object(__WEBPACK_IMPORTED_MODULE_0__tile_id__["a" /* getTileId */])(tileItem), tileItem);
    }
    // tiles are grouped into one or more convex polygons, process these polygons one by one
    const tilesToProcess = new Map(indexedTiles);
    while (tilesToProcess.size > 0) {
        let leftmostTile = { x: Number.POSITIVE_INFINITY, y: 0, zoom: 0 };
        // find the leftmost tile to start walking from
        for (const tileItem of tilesToProcess.values()) {
            if (tileItem.x < leftmostTile.x) {
                leftmostTile = tileItem;
            }
        }
        // save min/max y value per x coordinate to be able
        // to mark these tiles as processed (remove from tilesToProcess)
        const maxY = [];
        const minY = [];
        const initState = { currentTile: leftmostTile, currentTileSide: LEFT_SIDE, beltTiles };
        const state = Object.assign({}, initState);
        const maxCoordinate = Math.pow(2, leftmostTile.zoom);
        do {
            // move around while we don't reach the init position
            move(tilesToProcess, state, beltSize, maxCoordinate, isXCycled, isYCycled);
            const index = state.currentTile.x - initState.currentTile.x;
            maxY[index] = maxY[index] === undefined ? state.currentTile.y : Math.max(maxY[index], state.currentTile.y);
            minY[index] = minY[index] === undefined ? state.currentTile.y : Math.min(minY[index], state.currentTile.y);
        } while (state.currentTile !== initState.currentTile ||
            state.currentTileSide !== initState.currentTileSide);
        // mark tiles from current polygon as processed
        const zoom = leftmostTile.zoom;
        for (let i = 0; i < maxY.length; i++) {
            const x = leftmostTile.x + i;
            for (let y = minY[i]; y <= maxY[i]; y++) {
                tilesToProcess.delete(Object(__WEBPACK_IMPORTED_MODULE_0__tile_id__["b" /* getTileIdByRawValues */])(x, y, zoom));
            }
        }
    }
    // remove belt tiles that overlaps to avoid duplications
    for (const tileId of beltTiles.keys()) {
        if (indexedTiles.has(tileId)) {
            beltTiles.delete(tileId);
        }
    }
    return beltTiles.values();
}


/***/ }),
/* 74 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_buffer_writer__ = __webpack_require__(6);


/**
 * Writer of geometry data of icons.
 */
class IconBufferWriter extends __WEBPACK_IMPORTED_MODULE_1__util_buffer_writer__["b" /* default */] {
    constructor() {
        super(IconBufferWriter.ATTRIBUTE_MAPPING.vertexByteSize);
    }
    /**
     * Writes an icon to buffers.
     *
     * @param icon Icon to be written to buffer.
     * @param location Image location in atlas.
     * @param size Image size in atlas.
     * @param offset Offset of image points in CSS pixels.
     * @param pixelRatio Ratio of image size in CSS pixels to the size in atlas pixels.
     *
     * @returns Location of the icon data in buffers.
     */
    writeIcon(icon, location, size, offset, pixelRatio) {
        const top = offset.y;
        const bottom = offset.y + size.height * pixelRatio;
        const left = offset.x;
        const right = offset.x + size.width * pixelRatio;
        this.writeVertex(icon.position, left, bottom, location.minX, location.minY);
        this.writeVertex(icon.position, left, top, location.minX, location.maxY);
        this.writeVertex(icon.position, right, bottom, location.maxX, location.minY);
        this.writeVertex(icon.position, right, top, location.maxX, location.maxY);
        this.writeIndicesForContinuousStrip(4);
        return this.endMesh();
    }
    /**
     * Writes a vertex to the vertex buffer.
     *
     * @param position Position of the vertex in display coordinates.
     * @param uv UVs of the vertex.
     * @return Index of the written vertex.
     */
    writeVertex(position, displacementX, displacementY, uvX, uvY) {
        const vertexIdx = this.getCurrentVertexIdx();
        this._writeWorldCoordinate(position);
        this._writeHalfWords(displacementX, displacementY);
        this._writeHalfWords(uvX, uvY);
        return vertexIdx;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = IconBufferWriter;

/** Description of how a writer stores vertex data. */
IconBufferWriter.ATTRIBUTE_MAPPING = new __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__["a" /* AttributeMapping */]([
    [
        0 /* POSITION_HIGH */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        1 /* POSITION_LOW */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        6 /* DISPLACEMENT */,
        {
            size: 2,
            type: 5122 /* SHORT */,
            normalized: false
        }
    ],
    [
        4 /* UV */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: false
        }
    ]
]);


/***/ }),
/* 75 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_ref_counted__ = __webpack_require__(20);

/**
 * Represents an allocated image. Allocated image is a shareable resource that should be resealed
 * when there are no clients use it. As it is not possible to rely on the GC, clients should
 * manually retain their required images and release them when they are not required anymore.
 */
class AllocatedImage extends __WEBPACK_IMPORTED_MODULE_0__util_ref_counted__["a" /* default */] {
    constructor(descriptor, bbox, atlasManager) {
        super();
        this.descriptor = descriptor;
        this.bbox = bbox;
        this.atlasManager = atlasManager;
    }
    updateImage(sourceImage, locationRegion, sourceImageRegion) {
        this.atlasManager.atlas.updateImage(this.bbox, sourceImage, locationRegion, sourceImageRegion);
    }
    _destroy() {
        this.atlasManager.removeImage(this.descriptor);
    }
}
/* unused harmony export AllocatedImage */

/**
 * Manages allocation of images by id.
 */
class IdentifiedImageAtlasManager {
    constructor(imageAtlas) {
        this.atlas = imageAtlas;
        this._locations = new Map();
    }
    get size() {
        return this._locations.size;
    }
    getImage(id, retain = false) {
        const imageLocation = this._locations.get(id);
        if (retain && imageLocation) {
            imageLocation.retain();
        }
        return imageLocation || null;
    }
    allocateImage(descriptor, image) {
        const location = this.atlas.allocateImage(descriptor, image);
        if (location) {
            const image = new AllocatedImage(descriptor, location, this);
            this._locations.set(descriptor.id, image);
            return image;
        }
        return null;
    }
    removeImage(image) {
        const location = this._locations.get(image.id);
        if (location) {
            this.atlas.removeImage(location.bbox);
            this._locations.delete(image.id);
        }
    }
    contains(id) {
        return this._locations.has(id);
    }
    reserveLocation(descriptor) {
        const location = this.atlas.reserveLocation(descriptor);
        if (location) {
            const image = new AllocatedImage(descriptor, location, this);
            this._locations.set(descriptor.id, image);
            return image;
        }
        return null;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = IdentifiedImageAtlasManager;



/***/ }),
/* 76 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Font is just a collection of glyph descriptions.
 */
class Font {
    /**
     * @param id Font id.
     * @param xheight The height of the "x" char in abstract points, in fact is used a the font size.
     * @param unknownGlyphInstance An instance of glyph to be served as a stub when nonexistent glyph
     *     is requested. Requesting nonexistent glyphs normally should not happen.
     *     The stub just allows to avoid tedious null checks in font clients.
     */
    constructor(id, xheight, unknownGlyphInstance) {
        this.id = id;
        this.xheight = xheight;
        this._unknownGlyphInstance = unknownGlyphInstance;
        this._glyphs = new Map();
    }
    /**
     * @return Glyph with specified id or unknown glyph instance.
     */
    getGlyph(glyphId) {
        const glyph = this._glyphs.get(glyphId);
        if (glyph) {
            return glyph;
        }
        else {
            console.warn('Wow-wow-wow, something went wrong, you should not request nonexistent glyphs');
            return this._unknownGlyphInstance;
        }
    }
    /**
     * @returns All stored glyphs.
     */
    getAllGlyphs() {
        return [...this._glyphs.values()];
    }
    /**
     * Adds glyph description.
     */
    addGlyph(glyph) {
        this._glyphs.set(glyph.id, glyph);
    }
    /**
     * Adds glyph descriptions from the iterable.
     */
    addAllGlyphs(glyphs) {
        for (const glyph of glyphs) {
            this.addGlyph(glyph);
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Font;



/***/ }),
/* 77 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__billboard_image_provider__ = __webpack_require__(78);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_hd__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_hosts__ = __webpack_require__(79);



/**
 * Image provider that gets images from specific API entry point.
 */
class ApiImageProvider extends __WEBPACK_IMPORTED_MODULE_0__billboard_image_provider__["a" /* ImageProvider */] {
    constructor(imageUrlTemplate) {
        super();
        this._imageUrlTemplate = imageUrlTemplate;
    }
    getImageUrl(id) {
        // API can return scaled images that allows us to request images according
        // to user's DPI and render them properly, non-integer numbers are accepted.
        return this._imageUrlTemplate
            .replace('{{hostAlias}}', Object(__WEBPACK_IMPORTED_MODULE_2__util_hosts__["a" /* getHostAliasByUid */])(id))
            .replace(/\{\{id\}\}/g, id)
            .replace('{{scale}}', Object(__WEBPACK_IMPORTED_MODULE_1__util_hd__["a" /* default */])().toString());
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ApiImageProvider;



/***/ }),
/* 78 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Abstract image content provider, concrete implementations should specify the entry point in getImageUrl().
 */
class ImageProvider {
    /**
     * Gets image bitmap via an HTMLImageElement and a canvas.
     */
    getImage(id) {
        return new Promise((resolve, reject) => {
            const imageElement = new Image();
            imageElement.crossOrigin = 'anonymous';
            imageElement.onload = () => resolve(imageElement);
            imageElement.onerror = reject;
            imageElement.src = this.getImageUrl(id);
        });
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ImageProvider;



/***/ }),
/* 79 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = getHostAliasByUid;
const HOST_ALIASES_N = 4;
function getHostAliasByUid(uid) {
    let sum = 0;
    for (let i = 0; i < uid.length; i++) {
        sum += uid.charCodeAt(i);
    }
    return (sum % HOST_ALIASES_N + 1).toString();
}


/***/ }),
/* 80 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_buffer_writer__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__textured_polyline_geometry__ = __webpack_require__(81);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__util_z_index__ = __webpack_require__(30);




/**
 * Writer of geometry data of polyline hulls.
 */
class TexturedPolylineBufferWriter extends __WEBPACK_IMPORTED_MODULE_1__util_buffer_writer__["b" /* default */] {
    constructor() {
        super(TexturedPolylineBufferWriter.ATTRIBUTE_MAPPING.vertexByteSize);
    }
    /**
     * Generates a hull for a polyline and writes it to the writer.
     *
     * @param polyline The polyline to be written.
     * @param width Thickness of the polyline.
     * @param worldToPxFactor Ratio of world coordinates to pixels.
     * @param imageLocation Image location in atlas.
     * @param zIndex Z-index of the polyline.
     */
    writeTexturedPolyline(polyline, width, worldToPxFactor, imageLocation, zIndex) {
        Object(__WEBPACK_IMPORTED_MODULE_2__textured_polyline_geometry__["a" /* default */])(this, polyline.vertices, worldToPxFactor, imageLocation, width, Object(__WEBPACK_IMPORTED_MODULE_3__util_z_index__["a" /* intToZIndex */])(zIndex + 1));
        return this.endMesh();
    }
    /**
     * Writes a vertex to the vertex buffer.
     *
     * @param position Position of the vertex in world coordinates.
     * @param displacement Displacement vector, in most cases must be normalized, the width is considered in shaders.
     * @param halfWidth Thickness of the polyline.
     * @param patterWidth Width of the image that is repeated along the polyline.
     * @param patternHalfHeight Image half height multiplied by `sign(s)`, where `s` is a [-1; 1] distance to the
     * analytical polyline along segment's normal.
     * @param length Length of the polyline for current vertex, needed to correctly calculate image uv x coordinate.
     * @param uv UV coordinates of the image.
     * @param zIndex Z-index of the polyline.
     *
     * @return Index of the written vertex.
     */
    writeVertex(position, displacement, halfWidth, patternWidth, patternHalfHeight, length, uv, zIndex) {
        const vertexIdx = this.getCurrentVertexIdx();
        this._writeWorldCoordinate(position);
        this._writeFloat32(displacement.x);
        this._writeFloat32(displacement.y);
        this._writeHalfWords(uv.x, uv.y);
        this._writeFloat32(zIndex);
        this._writeFloat32(halfWidth);
        this._writeHalfWords(patternWidth, length);
        this._writeFloat32(patternHalfHeight);
        return vertexIdx;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = TexturedPolylineBufferWriter;

/** Description of how a writer stores vertex data. */
TexturedPolylineBufferWriter.ATTRIBUTE_MAPPING = new __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__["a" /* AttributeMapping */]([
    [
        0 /* POSITION_HIGH */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        1 /* POSITION_LOW */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        6 /* DISPLACEMENT */,
        {
            size: 2,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        4 /* UV */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: false
        }
    ],
    [
        9 /* PRIORITY */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        11 /* AUX */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        12 /* AUX1 */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: false
        }
    ],
    [
        13 /* AUX2 */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ]
]);


/***/ }),
/* 81 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = writeTexturedPolylineGeometry;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_vector2__ = __webpack_require__(1);

/**
 * Writes polyline image geometry (set of triangles that draw up a solid thick polyline) into a buffer writer.
 *
 * @param writer Output buffer writer.
 * @param polyline Polyline to be written.
 * @param worldToPxFactor Ratio of world coordinates to pixels.
 * @param imageLocation Image location in atlas.
 * @param width Thickness of the polyline.
 * @param z Z-index of the polyline.
 */
function writeTexturedPolylineGeometry(writer, polyline, worldToPxFactor, imageLocation, width, z) {
    const hWidth = width / 2;
    const patternWidth = imageLocation.maxX - imageLocation.minX;
    const patternHalfHeight = (imageLocation.maxY - imageLocation.minY) / 2;
    const segment = __WEBPACK_IMPORTED_MODULE_0__math_vector2__["f" /* create */](0, 0);
    const dir = __WEBPACK_IMPORTED_MODULE_0__math_vector2__["f" /* create */](0, 0);
    const prevDir = __WEBPACK_IMPORTED_MODULE_0__math_vector2__["f" /* create */](0, 0);
    const norm = __WEBPACK_IMPORTED_MODULE_0__math_vector2__["f" /* create */](0, 0);
    const normInv = __WEBPACK_IMPORTED_MODULE_0__math_vector2__["f" /* create */](0, 0);
    const uv = __WEBPACK_IMPORTED_MODULE_0__math_vector2__["f" /* create */](imageLocation.minX, 0);
    let prevBottomRight = -1;
    let prevTopRight = -1;
    let length = 0;
    let prevLength = 0;
    for (let i = 1; i < polyline.length; i++) {
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["s" /* sub */](polyline[i], polyline[i - 1], segment);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["q" /* normalize */](segment, dir);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["r" /* rotate90 */](dir, norm);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["p" /* muln */](norm, -1, normInv);
        // segment is written as a rectangle (two triangles)
        uv.y = imageLocation.minY;
        const topLeft = writer.writeVertex(polyline[i - 1], norm, hWidth, patternWidth, patternHalfHeight, length, uv, z);
        uv.y = imageLocation.maxY;
        const bottomLeft = writer.writeVertex(polyline[i - 1], normInv, hWidth, patternWidth, -patternHalfHeight, length, uv, z);
        // update length of the polyline in pixels
        length += __WEBPACK_IMPORTED_MODULE_0__math_vector2__["o" /* length */](segment) / worldToPxFactor;
        uv.y = imageLocation.minY;
        const topRight = writer.writeVertex(polyline[i], norm, hWidth, patternWidth, patternHalfHeight, length, uv, z);
        uv.y = imageLocation.maxY;
        const bottomRight = writer.writeVertex(polyline[i], normInv, hWidth, patternWidth, -patternHalfHeight, length, uv, z);
        // write line join that fills an empty space on corners
        if (1 < i && i < polyline.length) {
            uv.y = (imageLocation.maxY + imageLocation.minY) / 2;
            const joinPointIndex = writer.writeVertex(polyline[i - 1], __WEBPACK_IMPORTED_MODULE_0__math_vector2__["a" /* ZERO */], hWidth, patternWidth, 0, prevLength, uv, z);
            // find out where the fracture of segments is located to create correct join with minimum overdraw
            const turnLeft = __WEBPACK_IMPORTED_MODULE_0__math_vector2__["i" /* crossZ */](prevDir, dir) > 0;
            if (turnLeft) {
                writer.writeIndices([
                    joinPointIndex, bottomLeft, prevBottomRight
                ]);
            }
            else {
                writer.writeIndices([
                    joinPointIndex, prevTopRight, topLeft
                ]);
            }
        }
        writer.writeIndices([
            topLeft, topRight, bottomLeft,
            topRight, bottomRight, bottomLeft
        ]);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["e" /* copy */](dir, prevDir);
        prevBottomRight = bottomRight;
        prevTopRight = topRight;
        prevLength = length;
    }
}


/***/ }),
/* 82 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Manages allocation of requested images. The same images can be requested multiple times from different places,
 * this class takes over duplication of HTTP requests/atlas allocations providing simple async interface for
 * getting allocated images.
 */
class ImageManager {
    constructor(atlas, provider) {
        this._atlas = atlas;
        this._provider = provider;
        this._requests = new Map();
    }
    /**
     * Returns image if it is already allocated. Pay attention that resulted allocated image is "retained",
     * so it must be released once it is passed to a responsible client.
     */
    getImage(id) {
        const image = this._atlas.getImage(id, true);
        if (image) {
            image.retain();
        }
        return image;
    }
    /**
     * Request image from image provider, if it is already allocated no request is made, but it is returned
     * wrapped into a resolved promise. Pay attention that resulted allocated image is "retained", so it must be
     * released once it is passed to a responsible client.
     */
    requestImage(id) {
        const allocatedImage = this._atlas.getImage(id, true);
        if (allocatedImage) {
            return Promise.resolve(allocatedImage);
        }
        else {
            const request = this._requests.get(id);
            if (request) {
                request.then((allocatedImage) => allocatedImage && allocatedImage.retain());
                return request;
            }
            else {
                const request = this._provider
                    .getImage(id)
                    .then((image) => {
                    this._requests.delete(id);
                    const { width, height } = image;
                    const allocatedImage = this._atlas.allocateImage({ id, width, height }, image);
                    if (!allocatedImage) {
                        throw new Error('Couldn\' allocated image');
                    }
                    else {
                        return allocatedImage;
                    }
                }, () => {
                    this._requests.delete(id);
                    throw new Error('Image request failed');
                });
                this._requests.set(id, request);
                return request;
            }
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ImageManager;



/***/ }),
/* 83 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_buffer_rewriter__ = __webpack_require__(84);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__textured_polygon_attribute_mapping__ = __webpack_require__(31);


class TexturedPolygonBufferRewriter extends __WEBPACK_IMPORTED_MODULE_0__util_buffer_rewriter__["a" /* default */] {
    constructor(buffers) {
        super(__WEBPACK_IMPORTED_MODULE_1__textured_polygon_attribute_mapping__["a" /* TEXTURED_POLYGON_ATTRIBUTE_MAPPING */], buffers);
    }
    /**
     * @param location Location of the polygon in memory.
     * @param imageLocation Location of the pattern in atlas.
     * @param imageScale How world coordinates relate to the image size.
     */
    rewriteUV(location, imageLocation, imageScale) {
        const uvOffset = this._getAttribOffset(4 /* UV */);
        const scaleOffset = this._getAttribOffset(11 /* AUX */);
        this._forEachVertex(location, (writer) => {
            writer.writeHalfWords(uvOffset, imageLocation.minX, imageLocation.minY);
            writer.writeHalfWords(uvOffset + 1, imageLocation.maxX - imageLocation.minX, imageLocation.maxY - imageLocation.minY);
            writer.writeFloat32(scaleOffset, imageScale);
        });
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = TexturedPolygonBufferRewriter;



/***/ }),
/* 84 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__buffer_writer__ = __webpack_require__(6);

/**
 * Class that is exposed as an interface for writing to a specific vertex attribute.
 */
class VertexWriter {
    constructor(vertexBuffer) {
        this._vertexBuffer = new Uint32Array(vertexBuffer.buffer, 0, vertexBuffer.length);
        this._vertexBufferFloat32View = new Float32Array(vertexBuffer.buffer, 0, vertexBuffer.length);
    }
    /**
     * Writes float attribute into specific position in buffer.
     *
     * @param attribOffset Offset of an attribute in words (4 bytes), get it from BufferRewriter#_getAttribOffset().
     * @param value Value to be written.
     */
    writeFloat32(attribOffset, value) {
        this._vertexBufferFloat32View[this.vertexOffset + attribOffset] = value;
    }
    /**
     * Writes a word attribute into specific position in buffer.
     *
     * @param attribOffset Offset of an attribute in words (4 bytes), get it from BufferRewriter#_getAttribOffset().
     * @param value Value to be written.
     */
    writeWord(attribOffset, value) {
        this._vertexBuffer[this.vertexOffset + attribOffset] = value;
    }
    /**
     * Writes two half word attribute values into specific position in buffer.
     *
     * @param attribOffset Offset of an attribute in words (4 bytes), get it from BufferRewriter#_getAttribOffset().
     * @param value Value to be written.
     */
    writeHalfWords(attribOffset, v1, v2) {
        this.writeWord(attribOffset, v2 << 16 | v1 & 0xffff);
    }
}
/**
 * Provides some utils for rewriting vertex attribute values, see VertexWriter and tests for some tips of how to do it.
 * TODO: consider supporting of separate buffers for different attributes, that will make this class less useful
 */
class BufferRewriter {
    constructor(attribMapping, buffers) {
        this._attribMapping = attribMapping;
        this._buffers = buffers;
    }
    /**
     * Walks over all vertices exposing VertexWriter for each one by calling the handler argument.
     */
    _forEachVertex(location, handler) {
        const vertexWriter = new VertexWriter(this._buffers[location.bufferIndex].vertexBuffer);
        const vertexByteSize = this._attribMapping.vertexByteSize;
        for (let i = 0; i < location.vertexByteLength; i += vertexByteSize) {
            vertexWriter.vertexOffset = (location.vertexByteOffset + i) / __WEBPACK_IMPORTED_MODULE_0__buffer_writer__["a" /* WORD_BYTE_SIZE */];
            handler(vertexWriter);
        }
    }
    /**
     * @returns Offset in words (4 bytes) of specific attribute in a vertex (format is defined by AttributeMapping).
     */
    _getAttribOffset(attrib) {
        const attribPointer = this._attribMapping.get(attrib);
        return attribPointer ? attribPointer.offset / __WEBPACK_IMPORTED_MODULE_0__buffer_writer__["a" /* WORD_BYTE_SIZE */] : -1;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = BufferRewriter;



/***/ }),
/* 85 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__ = __webpack_require__(3);

/** Description of how a writer stores vertex data. */
const BILLBOARD_RECTANGLE_ATTRIBUTE_MAPPING = new __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__["a" /* AttributeMapping */]([
    [
        2 /* ID */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        0 /* POSITION_HIGH */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        1 /* POSITION_LOW */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        6 /* DISPLACEMENT */,
        {
            size: 2,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        4 /* UV */,
        {
            size: 2,
            type: 5122 /* SHORT */,
            normalized: true
        }
    ],
    [
        7 /* COLOR */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        11 /* AUX */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ]
]);
/* harmony export (immutable) */ __webpack_exports__["a"] = BILLBOARD_RECTANGLE_ATTRIBUTE_MAPPING;



/***/ }),
/* 86 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__ = __webpack_require__(3);

/** Description of how a writer stores vertex data. */
const POINT_LABEL_ATTRIBUTE_MAPPING = new __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__["a" /* AttributeMapping */]([
    [
        2 /* ID */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        0 /* POSITION_HIGH */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        1 /* POSITION_LOW */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        6 /* DISPLACEMENT */,
        {
            size: 2,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        4 /* UV */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: false
        }
    ],
    [
        7 /* COLOR */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        8 /* OUTLINE_COLOR */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        9 /* PRIORITY */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        11 /* AUX */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ]
]);
/* harmony export (immutable) */ __webpack_exports__["a"] = POINT_LABEL_ATTRIBUTE_MAPPING;



/***/ }),
/* 87 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__ = __webpack_require__(3);

/** Description of how a writer stores vertex data. */
const CURVED_LABEL_ATTRIBUTE_MAPPING = new __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__["a" /* AttributeMapping */]([
    [
        2 /* ID */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        0 /* POSITION_HIGH */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        1 /* POSITION_LOW */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        6 /* DISPLACEMENT */,
        {
            size: 3,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        4 /* UV */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: false
        }
    ],
    [
        7 /* COLOR */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        8 /* OUTLINE_COLOR */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        9 /* PRIORITY */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        12 /* AUX1 */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        13 /* AUX2 */,
        {
            size: 4,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        14 /* AUX3 */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        15 /* AUX4 */,
        {
            size: 4,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        11 /* AUX */,
        {
            size: 2,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ]
]);
/* harmony export (immutable) */ __webpack_exports__["a"] = CURVED_LABEL_ATTRIBUTE_MAPPING;



/***/ }),
/* 88 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_worker__ = __webpack_require__(17);

class TileProviderWorkerClient extends __WEBPACK_IMPORTED_MODULE_0__util_worker__["b" /* WebWorkerClient */] {
}
/* harmony export (immutable) */ __webpack_exports__["a"] = TileProviderWorkerClient;



/***/ }),
/* 89 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = extractTransferables;
/**
 * Extract ArrayBuffers (that are tansferable) from pages.
 */
function extractTransferables(pages, output) {
    for (const page of pages) {
        output.push(page.vertexBuffer.buffer, page.indexBuffer.buffer);
    }
}


/***/ }),
/* 90 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__polygon_attribute_mapping__ = __webpack_require__(32);


/**
 * Description of how attributes of vertices are packed into a vertex buffer.
 */
const TRANSPARENT_POLYGON_ATTRIBUTE_MAPPING = new __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__["a" /* AttributeMapping */](__WEBPACK_IMPORTED_MODULE_1__polygon_attribute_mapping__["a" /* POLYGON_ATTRIBUTE_MAPPING */]);
/* harmony export (immutable) */ __webpack_exports__["a"] = TRANSPARENT_POLYGON_ATTRIBUTE_MAPPING;



/***/ }),
/* 91 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__priority_queue__ = __webpack_require__(35);

const MAX_DEQUEUE_TIMEOUT = 1000; // ms
// TODO: remove this shim when all supported browsers implement it
const SHIMMED_PROCESSING_DURATION_MS = 25;
window.cancelIdleCallback = window.cancelIdleCallback || window.clearTimeout;
window.requestIdleCallback = window.requestIdleCallback || function (handler) {
    const startTime = performance.now();
    return setTimeout(() => {
        handler({
            didTimeout: false,
            timeRemaining: () => Math.max(0, SHIMMED_PROCESSING_DURATION_MS - (performance.now() - startTime))
        });
    });
};
/**
 * It is a task queue. Tasks are dequeued during idle period.
 */
class IdleTaskQueue {
    constructor() {
        this._queue = new __WEBPACK_IMPORTED_MODULE_0__priority_queue__["a" /* default */]();
        this._dequeueIdleHandle = 0;
    }
    destroy() {
        cancelIdleCallback(this._dequeueIdleHandle);
    }
    /**
     * Enqueues a task to the queue.
     *
     * @param task The task.
     */
    enqueue(task) {
        this._queue.enqueue(task);
        this._run();
    }
    _dequeue(deadline) {
        const queue = this._queue;
        if (queue.isEmpty()) {
            return;
        }
        if (deadline.didTimeout) {
            queue.dequeue().execute();
        }
        else {
            while (deadline.timeRemaining() && !queue.isEmpty()) {
                queue.dequeue().execute();
            }
        }
        this._dequeueIdleHandle = 0;
        if (!this._queue.isEmpty()) {
            this._run();
        }
    }
    _run() {
        if (!this._dequeueIdleHandle) {
            this._dequeueIdleHandle = requestIdleCallback((deadline) => {
                this._dequeue(deadline);
            }, { timeout: MAX_DEQUEUE_TIMEOUT });
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = IdleTaskQueue;



/***/ }),
/* 92 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__array__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__comparator__ = __webpack_require__(19);


/**
 * Computes index of the parent of an item.
 *
 * @param idx Index of the item.
 * @returns Index of the parent.
 */
function getParentIdx(idx) {
    return (idx + 1 >> 1) - 1;
}
/**
 * Computes index of the left child of an item.
 *
 * @param idx Index of the item.
 * @returns Index of the child.
 */
function getFirstChildIdx(idx) {
    return (idx + 1 << 1) - 1;
}
class BinaryHeap {
    /**
     * Constructs a new empty heap. Order of items in the heap will be defined
     * by a given comparator.
     *
     * @param comparator The comparator.
     */
    constructor(comparator = __WEBPACK_IMPORTED_MODULE_1__comparator__["a" /* DEFAULT_COMPARATOR */]) {
        // TODO(dmikis) Investigate preallocation.
        this._items = [];
        this._comparator = comparator;
    }
    /**
     * Inserts an item into the heap.
     *
     * @param item The item to be inserted.
     */
    insert(item) {
        const items = this._items;
        const comparator = this._comparator;
        // Insert the new item as bottom right-most child of the heap.
        let idx = items.push(item) - 1;
        let parentIdx = getParentIdx(idx);
        // Walk the heap upward and restore heap property on the way.
        while (parentIdx > -1 &&
            comparator(items[idx], items[parentIdx]) > 0) {
            Object(__WEBPACK_IMPORTED_MODULE_0__array__["c" /* swap */])(items, idx, parentIdx);
            idx = parentIdx;
            parentIdx = getParentIdx(idx);
        }
    }
    /**
     * Removes "maximum" item from the head.
     *
     * @returns The removed item or `undefined` is the heap's empty.
     */
    pop() {
        const items = this._items;
        if (items.length === 0) {
            return undefined;
        }
        const newSize = items.length - 1;
        // Place max item at the end of the items array.
        Object(__WEBPACK_IMPORTED_MODULE_0__array__["c" /* swap */])(items, 0, newSize);
        // Walk downward from the new root to restore heap property.
        let idx = 0;
        let childIdx = 1;
        const comparator = this._comparator;
        while (childIdx < newSize) {
            if (childIdx + 1 < newSize &&
                comparator(items[childIdx], items[childIdx + 1]) < 0) {
                childIdx += 1;
            }
            if (comparator(items[idx], items[childIdx]) > 0) {
                break;
            }
            Object(__WEBPACK_IMPORTED_MODULE_0__array__["c" /* swap */])(items, idx, childIdx);
            idx = childIdx;
            childIdx = getFirstChildIdx(childIdx);
        }
        // Remove previously placed at the end previous max item.
        return items.pop();
    }
    /**
     * @returns "Maximum" item in the heap or `undefined` if the head is empty.
     */
    peek() {
        return this._items[0];
    }
    /**
     * @returns Iterator over all items in the heap. Note that order of items
     *      is undefined.
     */
    *[Symbol.iterator]() {
        for (const item of this._items) {
            yield item;
        }
    }
    /**
     * @returns Number of items in the heap.
     */
    get size() {
        return this._items.length;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = BinaryHeap;



/***/ }),
/* 93 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__renderable_primitive__ = __webpack_require__(7);

/**
 * Allocated in GPU memory polygon.
 */
class RenderablePolygon extends __WEBPACK_IMPORTED_MODULE_0__renderable_primitive__["a" /* default */] {
    constructor(memorySubChunk, isOpaque) {
        super(memorySubChunk);
        this.isOpaque = isOpaque;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RenderablePolygon;



/***/ }),
/* 94 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__renderable_primitive__ = __webpack_require__(7);

class RenderableTexturedPolygon extends __WEBPACK_IMPORTED_MODULE_0__renderable_primitive__["a" /* default */] {
    constructor(memoryChunk, allocatedImage) {
        super(memoryChunk);
        this._allocatedImage = allocatedImage;
        this.atlas = allocatedImage.atlasManager.atlas;
        allocatedImage.retain();
    }
    _destroy() {
        this._allocatedImage.release();
        super._destroy();
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RenderableTexturedPolygon;



/***/ }),
/* 95 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__renderable_polyline__ = __webpack_require__(36);

class RenderableTexturedPolyline extends __WEBPACK_IMPORTED_MODULE_0__renderable_polyline__["a" /* default */] {
    constructor(memoryChunk, allocatedImage) {
        super(memoryChunk);
        this._allocatedImage = allocatedImage;
        this.atlas = allocatedImage.atlasManager.atlas;
        allocatedImage.retain();
    }
    _destroy() {
        this._allocatedImage.release();
        super._destroy();
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RenderableTexturedPolyline;



/***/ }),
/* 96 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
const POLYGON_EXTRACTOR = (data) => flat(map('polygons', data));
/* harmony export (immutable) */ __webpack_exports__["f"] = POLYGON_EXTRACTOR;

const TEXTURED_POLYGON_EXTRACTOR = (data) => flat(map('texturedPolygons', data));
/* harmony export (immutable) */ __webpack_exports__["h"] = TEXTURED_POLYGON_EXTRACTOR;

const POLYLINE_EXTRACTOR = (data) => flat(map('polylines', data));
/* harmony export (immutable) */ __webpack_exports__["g"] = POLYLINE_EXTRACTOR;

const TEXTURED_POLYLINE_EXTRACTOR = (data) => flat(map('texturedPolylines', data));
/* harmony export (immutable) */ __webpack_exports__["i"] = TEXTURED_POLYLINE_EXTRACTOR;

const POINT_EXTRACTOR = (data) => flat(map('points', data));
/* harmony export (immutable) */ __webpack_exports__["d"] = POINT_EXTRACTOR;

const POINT_LABEL_EXTRACTOR = (data) => flat(map('pointLabels', data));
/* harmony export (immutable) */ __webpack_exports__["e"] = POINT_LABEL_EXTRACTOR;

const CURVED_LABEL_EXTRACTOR = (data) => flat(map('curvedLabels', data));
/* harmony export (immutable) */ __webpack_exports__["a"] = CURVED_LABEL_EXTRACTOR;

const MODEL_EXTRACTOR = (data) => flat(map('models', data));
/* harmony export (immutable) */ __webpack_exports__["c"] = MODEL_EXTRACTOR;

const EXTERNAL_MESH_EXTRACTOR = (data) => flat(map('externalMeshes', data));
/* harmony export (immutable) */ __webpack_exports__["b"] = EXTERNAL_MESH_EXTRACTOR;

/**
 * Maps list of TileData's into list of specified primitives.
 */
function* map(type, data) {
    for (const portion of data) {
        yield portion[type];
    }
}
/**
 * Flatten two dimensional list of primitives in a single dimensional one.
 */
function* flat(primitives) {
    for (const portion of primitives) {
        if (portion) {
            yield* portion;
        }
    }
}


/***/ }),
/* 97 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__renderable_primitive_manager__ = __webpack_require__(21);

/**
 * Polygons should be separated by opaqueness and there are two distinct primitive providers
 * for them: opaque and tansparent. That is what this manager takes care of.
 */
class PolygonManager extends __WEBPACK_IMPORTED_MODULE_0__renderable_primitive_manager__["a" /* default */] {
    constructor(opaquePolygonStorage, transparentPolygonStorage) {
        super(opaquePolygonStorage);
        this._opaquePolygonStorage = opaquePolygonStorage;
        this._transparentPolygonStorage = transparentPolygonStorage;
    }
    updateScene(toShow, toHide) {
        for (const primitive of toShow) {
            if (primitive.isOpaque) {
                this._opaquePolygonStorage.add(primitive);
            }
            else {
                this._transparentPolygonStorage.add(primitive);
            }
        }
        for (const primitive of toHide) {
            if (primitive.isOpaque) {
                this._opaquePolygonStorage.delete(primitive);
            }
            else {
                this._transparentPolygonStorage.delete(primitive);
            }
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = PolygonManager;



/***/ }),
/* 98 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_iterable__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__disappearing_primitive_set_storage__ = __webpack_require__(40);


/**
 * Primitive storage that stores primitive in a set. It acts as a primitive provider as well.
 */
class DelayedDisappearingPrimitiveSetStorage extends __WEBPACK_IMPORTED_MODULE_1__disappearing_primitive_set_storage__["a" /* default */] {
    constructor(appearingEffectDuration) {
        super();
        this._appearingEffectDuration = appearingEffectDuration;
        this._scheduledRemoves = new Map();
        this._timeoutIds = new Set();
    }
    get primitives() {
        return this._primitiveSet;
    }
    add(...primitives) {
        // primitives that are scheduled for removing was not removed "physically", that is why
        // they should be filtered out to prevent multiple adding of the same primitive in parent
        const notScheduledForRemovePrimitives = [];
        for (const primitive of primitives) {
            const primitivesToDelete = this._scheduledRemoves.get(primitive);
            if (primitivesToDelete) {
                // if this primitive is scheduled for removing it is deleted from its batch,
                // thus canceling the removing in the callback
                primitivesToDelete.delete(primitive);
                this._scheduledRemoves.delete(primitive);
            }
            else {
                notScheduledForRemovePrimitives.push(primitive);
            }
        }
        super.add(...notScheduledForRemovePrimitives);
        this.show(...notScheduledForRemovePrimitives);
    }
    delete(...primitives) {
        this.hide(...primitives);
        // primitives are batched in a set to be deleted in one setTimeout callback for performance,
        // filter out primitives which removing was already scheduled
        const primitivesToDelete = new Set(Object(__WEBPACK_IMPORTED_MODULE_0__util_iterable__["b" /* filterIterable */])(primitives, (primitive) => !this._scheduledRemoves.has(primitive)));
        if (primitivesToDelete.size > 0) {
            const timeoutId = setTimeout(() => {
                // primitivesToDelete contains relevant for removing primitives, it can be updated in the add() method
                // if a primitive is added back, thus, in fact, canceling removing of this specific primitive
                super.delete(...primitivesToDelete);
                for (const primitive of primitivesToDelete) {
                    this._scheduledRemoves.delete(primitive);
                }
                this._timeoutIds.delete(timeoutId);
            }, this._appearingEffectDuration);
            for (const primitive of primitivesToDelete) {
                this._scheduledRemoves.set(primitive, primitivesToDelete);
            }
            this._timeoutIds.add(timeoutId);
        }
    }
    destroy() {
        for (const timeoutId of this._timeoutIds) {
            clearTimeout(timeoutId);
        }
    }
    _isAllowedToShowPrimitive(primitive) {
        return super._isAllowedToShowPrimitive(primitive) && !this._scheduledRemoves.has(primitive);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = DelayedDisappearingPrimitiveSetStorage;



/***/ }),
/* 99 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__renderable_primitive_manager__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_iterable__ = __webpack_require__(8);


/**
 * It is required to hide some primitives (that don't scale with zoom, e.g. labels or icons) by "too irrelevant" zoom,
 * to prevent mess of collapsed objects on the screen. This primitive manager is a temporary solution,
 * proper handling of zoom slices will replace it.
 */
// TODO: this manager is a tmp solution, correct handling of zoom slices is going to replace it
class ZoomFilterablePrimitiveManager extends __WEBPACK_IMPORTED_MODULE_0__renderable_primitive_manager__["a" /* default */] {
    constructor(primitivesStorage, camera) {
        super(primitivesStorage);
        this._disappearingPrimitivesStorage = primitivesStorage;
        this._camera = camera;
        this._primitives = new Set();
        this._prevZoom = camera.zoom;
        this._zoomUpdateListener = this._onZoomUpdated.bind(this);
        this._camera.onUpdate.addListener(this._zoomUpdateListener);
    }
    updateScene(toShow, toHide) {
        // save primitives to filter them later
        super.updateScene(Object(__WEBPACK_IMPORTED_MODULE_1__util_iterable__["c" /* mapIterable */])(toShow, (primitive) => {
            this._primitives.add(primitive);
            return primitive;
        }), Object(__WEBPACK_IMPORTED_MODULE_1__util_iterable__["c" /* mapIterable */])(toHide, (primitive) => {
            this._primitives.delete(primitive);
            return primitive;
        }));
        // check if there are added primitives that could be removed by zoom restrictions
        this._updateZoomVisibility();
    }
    _onZoomUpdated() {
        if (this._prevZoom !== this._camera.zoom) {
            this._updateZoomVisibility();
            this._prevZoom = this._camera.zoom;
        }
    }
    _updateZoomVisibility() {
        const zoom = this._camera.zoom;
        this._disappearingPrimitivesStorage.show(...Object(__WEBPACK_IMPORTED_MODULE_1__util_iterable__["b" /* filterIterable */])(this._primitives, ({ minZoom }) => zoom >= minZoom));
        this._disappearingPrimitivesStorage.hide(...Object(__WEBPACK_IMPORTED_MODULE_1__util_iterable__["b" /* filterIterable */])(this._primitives, ({ minZoom }) => zoom < minZoom));
    }
    destroy() {
        this._camera.onUpdate.removeListener(this._zoomUpdateListener);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ZoomFilterablePrimitiveManager;



/***/ }),
/* 100 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__worker_tile_provider_worker_messages__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__render_memory_sub_chunk__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__primitive_model_model_buffer_writer__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__primitive_manager__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__primitive_model_renderable_model__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__util_worker__ = __webpack_require__(17);






/**
 * External meshes come in polygons (kind of building outlines). This manager controls quering external meshes
 * according to added polygons, as many of them can share the same mesh (usually across multiple tiles).
 */
class ExternalMeshPrimitiveManager extends __WEBPACK_IMPORTED_MODULE_3__primitive_manager__["a" /* default */] {
    constructor(primitivesStorage, geometryProvider, memoryManager) {
        super();
        this._primitivesStorage = primitivesStorage;
        this._tileProvider = geometryProvider;
        this._memoryManager = memoryManager;
        this._externalMeshes = new Map();
    }
    updateScene(toShow, toHide) {
        for (const primitive of toShow) {
            this._addPrimitive(primitive);
        }
        for (const primitive of toHide) {
            this._removePrimitive(primitive);
        }
    }
    _addPrimitive(primitive) {
        const id = getFullMeshId(primitive);
        let external = this._externalMeshes.get(id);
        if (!external) {
            external = {
                visiblePolygons: new Set(),
                isVisible: false
            };
            this._externalMeshes.set(id, external);
            this._tileProvider.request({
                type: __WEBPACK_IMPORTED_MODULE_0__worker_tile_provider_worker_messages__["a" /* TileProviderMessageType */].MESH_REQUEST,
                responseType: __WEBPACK_IMPORTED_MODULE_0__worker_tile_provider_worker_messages__["a" /* TileProviderMessageType */].MESH_RESPONSE,
                errorType: __WEBPACK_IMPORTED_MODULE_0__worker_tile_provider_worker_messages__["a" /* TileProviderMessageType */].MESH_ERROR,
                mesh: primitive,
                requestId: __WEBPACK_IMPORTED_MODULE_5__util_worker__["a" /* NO_ID */]
            }).then((response) => {
                const external = this._externalMeshes.get(id);
                if (external && !external.isVisible) {
                    const location = response.location;
                    const chunks = response.pages.map((page) => this._memoryManager.allocate(page.vertexBuffer, page.indexBuffer, __WEBPACK_IMPORTED_MODULE_2__primitive_model_model_buffer_writer__["a" /* default */].ATTRIBUTE_MAPPING));
                    external.mesh = new __WEBPACK_IMPORTED_MODULE_4__primitive_model_renderable_model__["a" /* default */](new __WEBPACK_IMPORTED_MODULE_1__render_memory_sub_chunk__["a" /* default */](chunks[location.bufferIndex], location));
                    external.isVisible = true;
                    this._primitivesStorage.add(external.mesh);
                    chunks.forEach((chunk) => chunk.release());
                }
            });
        }
        external.visiblePolygons.add(primitive);
    }
    _removePrimitive(primitive) {
        const id = getFullMeshId(primitive);
        const external = this._externalMeshes.get(id);
        if (external) {
            external.visiblePolygons.delete(primitive);
            // destroy external mesh if there is no visible polygons remaining
            if (external.visiblePolygons.size === 0) {
                this._externalMeshes.delete(id);
                if (external.mesh) {
                    external.mesh.release();
                    this._primitivesStorage.delete(external.mesh);
                    external.isVisible = false;
                }
                else {
                    // if no mesh yet returned cancel request
                    this._tileProvider.sendMessage({
                        type: __WEBPACK_IMPORTED_MODULE_0__worker_tile_provider_worker_messages__["a" /* TileProviderMessageType */].MESH_REQUEST_CANCEL,
                        mesh: primitive
                    });
                }
            }
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ExternalMeshPrimitiveManager;

function getFullMeshId(mesh) {
    return mesh.objectId + mesh.meshId;
}


/***/ }),
/* 101 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__renderable_primitive__ = __webpack_require__(7);

class RenderableBillboardRectangle extends __WEBPACK_IMPORTED_MODULE_0__renderable_primitive__["a" /* default */] {
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RenderableBillboardRectangle;



/***/ }),
/* 102 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__primitive_label_renderable_label__ = __webpack_require__(103);

class ZoomRestrictedLabel extends __WEBPACK_IMPORTED_MODULE_0__primitive_label_renderable_label__["a" /* default */] {
    constructor(memorySubChunk, atlas, minZoom, background) {
        super(memorySubChunk, atlas, background);
        this.minZoom = minZoom;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ZoomRestrictedLabel;



/***/ }),
/* 103 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__renderable_primitive__ = __webpack_require__(7);

/**
 * Allocated in GPU memory label.
 */
class RenderableLabel extends __WEBPACK_IMPORTED_MODULE_0__renderable_primitive__["a" /* default */] {
    /**
     * Constructs a new renderable label.
     *
     * @param memorySubChunk
     * @param atlas
     * @param background
     */
    constructor(memorySubChunk, atlas, background) {
        super(memorySubChunk);
        this.atlas = atlas;
        this.background = background;
        if (background) {
            background.retain();
        }
    }
    _destroy() {
        if (this.background) {
            this.background.release();
        }
        super._destroy();
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RenderableLabel;



/***/ }),
/* 104 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__primitive_icon_renderable_icon__ = __webpack_require__(105);

class ZoomRestrictedIcon extends __WEBPACK_IMPORTED_MODULE_0__primitive_icon_renderable_icon__["a" /* default */] {
    constructor(memorySubChunk, allocatedImage, minZoom) {
        super(memorySubChunk, allocatedImage);
        this.minZoom = minZoom;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ZoomRestrictedIcon;



/***/ }),
/* 105 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__image_renderable_image__ = __webpack_require__(106);

class RenderableIcon extends __WEBPACK_IMPORTED_MODULE_0__image_renderable_image__["a" /* default */] {
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RenderableIcon;



/***/ }),
/* 106 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__textured_renderable_primitive__ = __webpack_require__(107);

class RenderableImage extends __WEBPACK_IMPORTED_MODULE_0__textured_renderable_primitive__["a" /* default */] {
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RenderableImage;



/***/ }),
/* 107 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__renderable_primitive__ = __webpack_require__(7);

class TexturedRenderablePrimitive extends __WEBPACK_IMPORTED_MODULE_0__renderable_primitive__["a" /* default */] {
    constructor(memoryChunk, allocatedImage) {
        super(memoryChunk);
        this._allocatedImage = allocatedImage;
        this.atlas = allocatedImage.atlasManager.atlas;
        this._allocatedImage.retain();
    }
    _destroy() {
        this._allocatedImage.release();
        super._destroy();
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = TexturedRenderablePrimitive;



/***/ }),
/* 108 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__priority_queue__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_event_emitter__ = __webpack_require__(2);


const DEQUEUE_TIMEOUT = 1; // ms
/**
 * Prioritized task queue.
 */
class TaskQueue {
    /**
     * Constructs an empty task queue.
     */
    constructor() {
        this._queue = new __WEBPACK_IMPORTED_MODULE_0__priority_queue__["a" /* default */]();
        this._frozen = false;
        this._dequeueTimeoutHandle = 0;
        this.onEmpty = new __WEBPACK_IMPORTED_MODULE_1__util_event_emitter__["b" /* VoidEventEmitter */]();
    }
    /**
     * Destroys the queue. Any remaining tasks won't be executed.
     */
    destroy() {
        clearTimeout(this._dequeueTimeoutHandle);
    }
    /**
     * Enqueues a task to the queue and schedules processing of the queue.
     *
     * @param task The task.
     * @returns Promise that will be fullfilled when the task successfully
     *      finishes or rejected if there's an error.
     */
    enqueue(task) {
        if (!this._frozen) {
            this._setDequeueTimeout();
        }
        return new Promise((resolve, reject) => {
            this._queue.enqueue({
                execute() {
                    try {
                        task.execute();
                        resolve();
                    }
                    catch (error) {
                        reject(error);
                    }
                },
                priority: task.priority
            });
        });
    }
    isEmpty() {
        return this._queue.isEmpty();
    }
    freeze() {
        if (this._dequeueTimeoutHandle) {
            clearTimeout(this._dequeueTimeoutHandle);
            this._dequeueTimeoutHandle = 0;
        }
        this._frozen = true;
    }
    unfreeze() {
        this._frozen = false;
        if (!this._queue.isEmpty()) {
            this._setDequeueTimeout();
        }
    }
    _dequeue() {
        const task = this._queue.dequeue();
        if (task) {
            task.execute();
        }
        if (this._queue.isEmpty()) {
            this._dequeueTimeoutHandle = 0;
            this.onEmpty.fire();
        }
        else {
            this._dequeueTimeoutHandle = setTimeout(() => this._dequeue(), DEQUEUE_TIMEOUT);
        }
    }
    _setDequeueTimeout() {
        if (!this._dequeueTimeoutHandle) {
            this._dequeueTimeoutHandle = setTimeout(() => this._dequeue(), DEQUEUE_TIMEOUT);
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = TaskQueue;



/***/ }),
/* 109 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["d"] = renderCameraState;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_vector_render_engine_util_delegator__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_vector_render_engine_math_vector2__ = __webpack_require__(1);


class MouseDragController extends __WEBPACK_IMPORTED_MODULE_0__src_vector_render_engine_util_delegator__["a" /* DelegatorBase */] {
    constructor(target) {
        super();
        this._target = target;
        this._pressedButton = -1 /* NONE */;
        this._prevMouseCoords = __WEBPACK_IMPORTED_MODULE_1__src_vector_render_engine_math_vector2__["f" /* create */](0, 0);
        target.addEventListener('mousedown', this);
        target.addEventListener('click', this);
        target.addEventListener('contextmenu', this);
    }
    handleEvent(e) {
        switch (e.type) {
            case 'click':
            case 'contextmenu':
                e.preventDefault();
                break;
            case 'mousedown':
                if (this._pressedButton === -1 /* NONE */) {
                    this._pressedButton = e.button;
                    this._prevMouseCoords.x = e.clientX;
                    this._prevMouseCoords.y = e.clientY;
                    document.body.addEventListener('mousemove', this);
                    document.body.addEventListener('mouseup', this);
                }
                e.preventDefault();
                break;
            case 'mousemove':
                if (this._delegate === null) {
                    break;
                }
                const mouseCoords = __WEBPACK_IMPORTED_MODULE_1__src_vector_render_engine_math_vector2__["f" /* create */](e.clientX, e.clientY);
                const delta = __WEBPACK_IMPORTED_MODULE_1__src_vector_render_engine_math_vector2__["s" /* sub */](mouseCoords, this._prevMouseCoords);
                switch (this._pressedButton) {
                    case 0 /* LEFT */:
                        this._delegate.onLeftButtonDrag(delta);
                        break;
                    case 1 /* MIDDLE */:
                        this._delegate.onMiddleButtonDrag(delta);
                        break;
                    case 2 /* RIGHT */:
                        this._delegate.onRightButtonDrag(delta);
                        break;
                }
                __WEBPACK_IMPORTED_MODULE_1__src_vector_render_engine_math_vector2__["e" /* copy */](mouseCoords, this._prevMouseCoords);
                e.preventDefault();
                break;
            case 'mouseup':
                if (this._pressedButton === e.button) {
                    document.body.removeEventListener('mouseup', this);
                    document.body.removeEventListener('mousemove', this);
                    this._pressedButton = -1 /* NONE */;
                }
                e.preventDefault();
                break;
        }
    }
    destroy() {
        this._target.removeEventListener('contextmenu', this);
        this._target.removeEventListener('click', this);
        this._target.removeEventListener('mousedown', this);
    }
}
/* harmony export (immutable) */ __webpack_exports__["b"] = MouseDragController;

class ScrollZoomController extends __WEBPACK_IMPORTED_MODULE_0__src_vector_render_engine_util_delegator__["a" /* DelegatorBase */] {
    constructor(target) {
        super();
        this._target = target;
        target.addEventListener('wheel', this);
    }
    handleEvent(e) {
        const delegate = this._delegate;
        if (!delegate) {
            return;
        }
        if (e.deltaY < 0) {
            delegate.onScrollIn();
        }
        else {
            delegate.onScrollOut();
        }
        e.preventDefault();
    }
    destroy() {
        this._target.removeEventListener('wheel', this);
    }
}
/* harmony export (immutable) */ __webpack_exports__["c"] = ScrollZoomController;

const ZOOM_STEP = 0.1;
const TILT_AZIMUTH_FACTOR = Math.PI / 1024;
class CameraMouseController {
    constructor(canvas, camera) {
        this._camera = camera;
        this._canvasSize = __WEBPACK_IMPORTED_MODULE_1__src_vector_render_engine_math_vector2__["f" /* create */](canvas.width, canvas.height);
        this.dragFactor = 1;
    }
    onLeftButtonDrag(delta) {
        // That's not exact, but good enough for now.
        __WEBPACK_IMPORTED_MODULE_1__src_vector_render_engine_math_vector2__["l" /* divv */](delta, this._canvasSize, delta);
        const camera = this._camera;
        __WEBPACK_IMPORTED_MODULE_1__src_vector_render_engine_math_vector2__["p" /* muln */](delta, this.dragFactor * camera.screenSize.height * Math.pow(2, -camera.zoom) /
            (Math.tan(0.5 * camera.options.fov) * 64), delta);
        const center = this._camera.center;
        center.x -= delta.x;
        center.y += delta.y;
        this._camera.setDirty();
    }
    onMiddleButtonDrag() { }
    onRightButtonDrag(delta) {
        const camera = this._camera;
        camera.tilt += delta.y * TILT_AZIMUTH_FACTOR;
        camera.azimuth += delta.x * TILT_AZIMUTH_FACTOR;
        this._camera.setDirty();
    }
    onScrollIn() {
        this._camera.zoom += ZOOM_STEP;
        this._camera.setDirty();
    }
    onScrollOut() {
        this._camera.zoom -= ZOOM_STEP;
        this._camera.setDirty();
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = CameraMouseController;

const cameraStateElement = document.querySelector('#camera_state');
const cameraStateText = cameraStateElement && cameraStateElement.firstChild;
function renderCameraState(camera) {
    const { center: { x, y }, zoom, tilt, azimuth } = camera;
    cameraStateText.replaceData(0, cameraStateText.length, `center: (${x.toFixed(8)},${y.toFixed(8)}); zoom: ${zoom.toFixed(4)}; ` +
        `tilt: ${tilt.toFixed(4)}; azimuth: ${azimuth.toFixed(4)}`);
}


/***/ }),
/* 110 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_point_label_vert__ = __webpack_require__(111);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_point_label_vert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__shader_point_label_vert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_color_id_frag__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_color_id_frag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__shader_color_id_frag__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__color_id_label_renderer__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__render_primitives_label_point_label_render_unit__ = __webpack_require__(45);




/**
 * Point labels renderer for collision resolution.
 */
class ColorIdPointLabelRenderer extends __WEBPACK_IMPORTED_MODULE_2__color_id_label_renderer__["a" /* default */] {
    constructor(context, camera, primitiveProvider) {
        const program = context.createProgram(__WEBPACK_IMPORTED_MODULE_0__shader_point_label_vert___default.a, __WEBPACK_IMPORTED_MODULE_1__shader_color_id_frag___default.a, __WEBPACK_IMPORTED_MODULE_3__render_primitives_label_point_label_render_unit__["a" /* PROGRAM_OPTIONS */]);
        super(context, program, primitiveProvider, camera);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ColorIdPointLabelRenderer;



/***/ }),
/* 111 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec2 vertexId;\n\n// point in the world the label is anchored to\nattribute vec2 vertexPosHigh;\nattribute vec2 vertexPosLow;\n\n// vector of concrete glyph point displacement (top-left, bottom-left, ...) relative to label's center, in px\nattribute vec2 vertexDisplacement;\n\n// coordinates of the glyph vertex in the atlas\nattribute vec2 vertexUV;\n\nattribute float vertexPriority;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\nuniform vec2 pixelSize;\nuniform sampler2D visibility;\nuniform vec2 idHalfPxSize;\nuniform vec2 shift;\nuniform lowp float currentZoom;\n\nvarying vec2 uv;\nvarying lowp vec4 color;\nvarying lowp vec4 outlineColor;\nvarying mediump float scale;\n\nconst vec4 DISCARD_POSITION = vec4(2, 2, 2, 1);\n\nconst float YV_H_1_0 = 1.999969482421875;\nconst float YV_L_1_1 = 0.000030517112463712692;\n\n/**\n * Projects specific point label vertex onto the screen.\n */\nvec4 projectPointLabelVertex_1_2(\n    mat4 viewProjMatrix,\n    vec2 lookAtHigh,\n    vec2 lookAtLow,\n    vec2 posHigh,\n    vec2 posLow,\n    vec2 displacement,\n    vec2 pxSize\n) {\n    vec4 position = viewProjMatrix * vec4(\n        YV_H_1_0 * (posHigh - lookAtHigh) +\n            YV_L_1_1 * (posLow - lookAtLow),\n        0,\n        1\n    );\n    position = vec4(position.xy / position.w, 0.0, 1.0);\n\n    return position + vec4(displacement * pxSize, 0.0, 0.0);\n}\n\n\n\n\nvoid main(void) {\n    vec2 idTexCoordinate = vertexId.xy + idHalfPxSize;\n    float overlapZoom = texture2D(visibility, idTexCoordinate).b;\n    if (currentZoom < overlapZoom) {\n        gl_Position = DISCARD_POSITION;\n    } else {\n        gl_Position = projectPointLabelVertex_1_2(\n            viewProjMatrix,\n            lookAtHigh,\n            lookAtLow,\n            vertexPosHigh,\n            vertexPosLow,\n            vertexDisplacement,\n            pixelSize\n        );\n        gl_Position.xy += shift;\n        gl_Position.z = vertexPriority;\n        color = vec4(vertexId, 0, 1);\n    }\n\n}\n"

/***/ }),
/* 112 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__render_state__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math_vector2__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__render_primitives_world_primitive_render_unit__ = __webpack_require__(5);



class CollidingPrimitiveColorIdRenderer extends __WEBPACK_IMPORTED_MODULE_2__render_primitives_world_primitive_render_unit__["a" /* default */] {
    constructor(context, program, primitiveProvider) {
        super(context, new __WEBPACK_IMPORTED_MODULE_0__render_state__["c" /* default */](), program, primitiveProvider);
        this._idHalfPxSizeUniform = __WEBPACK_IMPORTED_MODULE_1__math_vector2__["f" /* create */](0, 0);
    }
    _getPrimitives() {
        return this.primitiveProvider.visiblePrimitives;
    }
    _prepareProgram(program, viewProjMatrix, cameraPositions, state, stabilityShift, visibility, currentZoom) {
        super._prepareProgram(program, viewProjMatrix, cameraPositions, state, stabilityShift, visibility, currentZoom);
        this._idHalfPxSizeUniform.x = 0.5 / visibility.getWidth();
        this._idHalfPxSizeUniform.y = 0.5 / visibility.getHeight();
        this._context.bindTextureUnit(0);
        this._context.bindTexture(visibility);
        program.setIntScalarUniform('visibility', 0);
        program.setVector2Uniform('idHalfPxSize', this._idHalfPxSizeUniform);
        program.setVector2Uniform('shift', stabilityShift);
        program.setScalarUniform('currentZoom', currentZoom);
    }
    _prepareRenderTarget(target, _viewProjMatrix, _cameraPositions, state, _stabilityShift, _visibility, _currentZoom) {
        this._context.bindRenderState(state);
        this._context.bindRenderTarget(target);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = CollidingPrimitiveColorIdRenderer;



/***/ }),
/* 113 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export appendToBatch */
/* harmony export (immutable) */ __webpack_exports__["a"] = batchAllocatedObjects;
/**
 * Appends portion of memory to batch if they are adjacent.
 *
 * @returns `true` if both params are adjacent and the batch was successfully updated, `false` otherwise.
 */
function appendToBatch(memoryLocation, batch) {
    if (batch.vertexByteOffset + batch.vertexByteLength === memoryLocation.vertexByteOffset &&
        batch.indexByteOffset + batch.indexByteLength === memoryLocation.indexByteOffset) {
        batch.vertexByteLength += memoryLocation.vertexByteLength;
        batch.indexByteLength += memoryLocation.indexByteLength;
        return true;
    }
    return false;
}
/**
 * Combines objects allocated in memory into batches. No sorting is done in this method, the objects are supposed
 * to be sorted by index/vertex offsets to make batching effective. The batch is created by factory since it can
 * contains problem specific information.
 *
 * @param objects List of allocated objects.
 * @param getMemoryLocation Returns memory location of specific object.
 * @param createBatch Initiates batch by the first object.
 * @param canBatch Checks if two objects can be allocated.
 * @returns Iterable list of batches.
 */
function* batchAllocatedObjects(objects, getMemoryLocation, createBatch, canBatch = () => true) {
    const iterator = objects[Symbol.iterator]();
    let primitive = iterator.next().value;
    if (!primitive) {
        return;
    }
    let prev = primitive;
    let batch = createBatch(prev);
    primitive = iterator.next().value;
    while (primitive) {
        const primitiveMemoryLocation = getMemoryLocation(primitive);
        if (!canBatch(prev, primitive, batch) || !appendToBatch(primitiveMemoryLocation, batch)) {
            yield batch;
            batch = createBatch(primitive);
        }
        prev = primitive;
        primitive = iterator.next().value;
    }
    yield batch;
}


/***/ }),
/* 114 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec2 vertexId;\n\n// point in the world the label is anchored to\nattribute vec2 vertexPosHigh;\nattribute vec2 vertexPosLow;\n\n// vector of concrete glyph point displacement (top-left, bottom-left, ...) relative to label's center, in px\nattribute vec2 vertexDisplacement;\n\n// coordinates of the glyph vertex in the atlas\nattribute vec2 vertexUV;\n\nattribute float vertexPriority;\n\nattribute lowp vec4 vertexColor;\nattribute lowp vec4 vertexOutlineColor;\nattribute float vertexScale;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\nuniform vec2 pixelSize;\nuniform sampler2D visibility;\nuniform vec2 idHalfPxSize;\nuniform vec2 shift;\nuniform lowp float currentZoom;\n\nvarying vec2 uv;\nvarying lowp vec4 color;\nvarying lowp vec4 outlineColor;\nvarying mediump float scale;\n\nconst vec4 DISCARD_POSITION = vec4(2, 2, 2, 1);\n\nconst float YV_H_1_0 = 1.999969482421875;\nconst float YV_L_1_1 = 0.000030517112463712692;\n\n/**\n * Projects specific point label vertex onto the screen.\n */\nvec4 projectPointLabelVertex_1_2(\n    mat4 viewProjMatrix,\n    vec2 lookAtHigh,\n    vec2 lookAtLow,\n    vec2 posHigh,\n    vec2 posLow,\n    vec2 displacement,\n    vec2 pxSize\n) {\n    vec4 position = viewProjMatrix * vec4(\n        YV_H_1_0 * (posHigh - lookAtHigh) +\n            YV_L_1_1 * (posLow - lookAtLow),\n        0,\n        1\n    );\n    position = vec4(position.xy / position.w, 0.0, 1.0);\n\n    return position + vec4(displacement * pxSize, 0.0, 0.0);\n}\n\n\n\n\nvoid main(void) {\n    float visibilityAlpha = texture2D(visibility, vertexId.xy + idHalfPxSize).a;\n    if (visibilityAlpha != 0.0) {\n        gl_Position = projectPointLabelVertex_1_2(\n            viewProjMatrix,\n            lookAtHigh,\n            lookAtLow,\n            vertexPosHigh,\n            vertexPosLow,\n            vertexDisplacement,\n            pixelSize\n        );\n\n        uv = vertexUV;\n        color = vertexColor;\n        outlineColor = vertexOutlineColor;\n        scale = vertexScale;\n\n        color.a *= visibilityAlpha;\n        outlineColor.a *= visibilityAlpha;\n    } else {\n        gl_Position = DISCARD_POSITION;\n    }\n}\n"

/***/ }),
/* 115 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_billboard_rectangle_vert__ = __webpack_require__(116);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_billboard_rectangle_vert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__shader_billboard_rectangle_vert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_billboard_rectangle_frag__ = __webpack_require__(117);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_billboard_rectangle_frag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__shader_billboard_rectangle_frag__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math_vector2__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__world_primitive_render_unit__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__render_state__ = __webpack_require__(0);






const RENDER_STATE = new __WEBPACK_IMPORTED_MODULE_4__render_state__["c" /* default */](__WEBPACK_IMPORTED_MODULE_4__render_state__["b" /* BLEND_OVER_RENDER_STATE */]);
/**
 * Renderer of billboard rectangles.
 */
class BillboardRectangleRenderUnit extends __WEBPACK_IMPORTED_MODULE_3__world_primitive_render_unit__["a" /* default */] {
    constructor(context, camera, visibilityProvider, primitiveProvider) {
        const program = context.createProgram(__WEBPACK_IMPORTED_MODULE_0__shader_billboard_rectangle_vert___default.a, __WEBPACK_IMPORTED_MODULE_1__shader_billboard_rectangle_frag___default.a, {
            attribMap: {
                vertexId: 2 /* ID */,
                vertexPosHigh: 0 /* POSITION_HIGH */,
                vertexPosLow: 1 /* POSITION_LOW */,
                vertexDisplacement: 6 /* DISPLACEMENT */,
                vertexUV: 4 /* UV */,
                vertexColor: 7 /* COLOR */,
                vertexBorderRadii: 11 /* AUX */
            }
        });
        super(context, RENDER_STATE, program, primitiveProvider);
        this._visibilityProvider = visibilityProvider;
        this._camera = camera;
        this._visibilitySizeUniform = __WEBPACK_IMPORTED_MODULE_2__math_vector2__["f" /* create */](0, 0);
        context.bindProgram(program);
        program.setIntScalarUniform('visibility', 0);
    }
    _prepareProgram(program, viewProjMatrix, cameraPositions) {
        super._prepareProgram(program, viewProjMatrix, cameraPositions);
        const visibility = this._visibilityProvider();
        this._visibilitySizeUniform.x = visibility.getWidth();
        this._visibilitySizeUniform.y = visibility.getHeight();
        this._context.bindTextureUnit(0);
        this._context.bindTexture(visibility);
        program.setVector2Uniform('visibilitySize', this._visibilitySizeUniform);
        program.setVector2Uniform('pixelSize', this._camera.pixelSize);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = BillboardRectangleRenderUnit;



/***/ }),
/* 116 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec2 vertexId;\nattribute vec2 vertexPosHigh;\nattribute vec2 vertexPosLow;\nattribute vec2 vertexDisplacement;\nattribute vec2 vertexUV;\nattribute vec4 vertexColor;\nattribute vec2 vertexBorderRadii;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\nuniform vec2 pixelSize;\nuniform sampler2D visibility;\nuniform vec2 visibilitySize;\n\nvarying vec2 uv;\nvarying vec4 color;\nvarying vec2 borderRadii;\n\nconst vec4 DISCARD_POSITION = vec4(2, 2, 2, 1);\nconst float YV_H = 1.999969482421875;\nconst float YV_L = 0.000030517112463712692;\nvec2 VISIBILITY_HALF_PX = 0.5 / visibilitySize;\n\nvoid main(void) {\n    float visibilityAlpha = texture2D(visibility, vertexId.xy + VISIBILITY_HALF_PX).a;\n    if (visibilityAlpha == 0.0) {\n        gl_Position = DISCARD_POSITION;\n        return;\n    }\n\n    vec4 position = viewProjMatrix * vec4(\n        YV_H * (vertexPosHigh - lookAtHigh) +\n            YV_L * (vertexPosLow - lookAtLow),\n        0,\n        1\n    );\n    position.xyz /= position.w;\n    position.w = 1.0;\n\n    gl_Position = position + vec4(vertexDisplacement * pixelSize, 0.0, 0.0);\n\n    uv = vertexUV;\n    color = vertexColor;\n    color.a *= visibilityAlpha;\n    borderRadii = vertexBorderRadii;\n}\n"

/***/ }),
/* 117 */
/***/ (function(module, exports) {

module.exports = "#version 100\n\nprecision mediump float;\n#define GLSLIFY 1\n\nvarying vec2 uv;\nvarying vec4 color;\nvarying vec2 borderRadii;\n\nfloat roundedRectangle(const in vec2 uv, const in vec2 radii) {\n    vec2 absUv = abs(uv);\n    vec2 q = absUv + radii - 1.0;\n    return min(q.x, q.y) > 0.0 ? length(q / radii) : max(absUv.x, absUv.y);\n}\n\nvoid main(void) {\n    gl_FragColor = step(roundedRectangle(uv, borderRadii), 1.0) * color;\n}\n"

/***/ }),
/* 118 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_curved_label_vert__ = __webpack_require__(119);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_curved_label_vert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__shader_curved_label_vert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_color_id_frag__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_color_id_frag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__shader_color_id_frag__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__render_primitives_label_curved_label_render_unit__ = __webpack_require__(48);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__color_id_label_renderer__ = __webpack_require__(43);




/**
 * Curved labels renderer for collision resolution.
 */
class ColorIdCurvedLabelRenderer extends __WEBPACK_IMPORTED_MODULE_3__color_id_label_renderer__["a" /* default */] {
    constructor(context, camera, primitiveProvider) {
        const program = context.createProgram(__WEBPACK_IMPORTED_MODULE_0__shader_curved_label_vert___default.a, __WEBPACK_IMPORTED_MODULE_1__shader_color_id_frag___default.a, __WEBPACK_IMPORTED_MODULE_2__render_primitives_label_curved_label_render_unit__["a" /* PROGRAM_OPTIONS */]);
        super(context, program, primitiveProvider, camera);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ColorIdCurvedLabelRenderer;



/***/ }),
/* 119 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec2 vertexId;\n\n// point in the world the label is anchored to\nattribute vec2 vertexPosHigh;\nattribute vec2 vertexPosLow;\n\n// vector of concrete glyph point displacement (top-left, bottom-left, ...) relative to glyph's center (two values),\n// and distance of the glyph center to label's center (third value), in px\nattribute vec3 vertexDisplacements;\n\n// coordinates of the glyph vertex in the atlas\nattribute vec2 vertexUV;\n\nattribute float vertexPriority;\n\nattribute lowp vec4 vertexColor;\nattribute lowp vec4 vertexOutlineColor;\nattribute vec2 polylineLength_vertexScale;\n\n// deltas relative to the world point encoded in vertexPosHigh/vertexPosLow encoded via lengths and and angles of\n// corresponding vectors\nattribute vec4 leftPolylineRatios;\nattribute vec4 leftPolylineAngles;\nattribute vec4 rightPolylineRatios;\nattribute vec4 rightPolylineAngles;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\nuniform vec2 pixelSize;\nuniform sampler2D visibility;\nuniform vec2 idHalfPxSize;\nuniform vec2 shift;\nuniform lowp float currentZoom;\n\nvarying vec2 uv;\nvarying lowp vec4 color;\nvarying lowp vec4 outlineColor;\nvarying float scale;\n\nconst vec4 DISCARD_POSITION = vec4(2, 2, 2, 1);\n\nconst float YV_H_1_0 = 1.999969482421875;\nconst float YV_L_1_1 = 0.000030517112463712692;\n\nconst float PI_1_2 = 3.1415927410125732;\n\nconst int MAX_POLYLINE_POINTS_1_3 = 4;\nconst float INFINITY_1_4 = 1000000.0; // large enough for a segment length to consider it infinity\n\n/**\n * Returns world coordinate (plus delta) projected on screen, in pixels.\n */\nvec2 project_1_5(\n    mat4 viewProjMatrix,\n    vec2 lookAtHigh,\n    vec2 lookAtLow,\n    vec2 pixelSize,\n    vec2 pointHigh,\n    vec2 pointLow,\n    vec2 delta\n) {\n    vec4 position = viewProjMatrix * vec4(\n            YV_H_1_0 * (pointHigh - lookAtHigh) + YV_L_1_1 * (pointLow - lookAtLow) + delta,\n            0,\n            1\n        );\n    vec2 projected = position.xy / position.w;\n    return projected / pixelSize;\n}\n\n/**\n * Each point of the polyline is encoded as a vector from the polyline center by its normalized angle and the ratio of\n * its length to the polyline's length.\n */\nvec2 decodePolylineDeltas_1_6(float ratio, float angle, float polylineLength) {\n    // denormalize angle back to radians\n    float a = angle * 2.0 * PI_1_2 - PI_1_2;\n    // length of a vector\n    float len = ratio * polylineLength;\n    // restored point's (x, y) coordinates\n    return vec2(cos(a), sin(a)) * len;\n}\n\n/**\n * Projects specific curved label vertex onto the screen. The label is layouted by centering polyline in\n * the vertexPosHigh/vertexPosLow and other points are used to guide concrete gryph vertex.\n * Number of polyline points is hardcoded to pass them in attributes.\n */\nvec4 projectCurvedLabelVertex_1_7(\n    mat4 viewProjMatrix,\n    vec2 lookAtHigh,\n    vec2 lookAtLow,\n    vec2 pxSize,\n    vec2 posHigh,\n    vec2 posLow,\n    vec2 displacement,\n    float lineDisplacement,\n    float polylineLength,\n    vec4 leftPolylineRatios,\n    vec4 leftPolylineAngles,\n    vec4 rightPolylineRatios,\n    vec4 rightPolylineAngles\n) {\n    vec2 polylineDeltas[MAX_POLYLINE_POINTS_1_3];\n    vec2 position = project_1_5(viewProjMatrix, lookAtHigh, lookAtLow, pxSize, posHigh, posLow, vec2(0, 0));\n    float remainingLength = abs(lineDisplacement);\n    for (int i = 0; i < MAX_POLYLINE_POINTS_1_3; i++) {\n        vec2 projectedPoint;\n\n        // figure out the direction (left/right) at the first step\n        if (i == 0) {\n            projectedPoint = project_1_5(\n                viewProjMatrix,\n                lookAtHigh,\n                lookAtLow,\n                pxSize,\n                posHigh,\n                posLow,\n                decodePolylineDeltas_1_6(rightPolylineRatios[0], rightPolylineAngles[0], polylineLength)\n            );\n            bool isRightPart = lineDisplacement > 0.0;\n            bool isInverted = projectedPoint.x < position.x;\n\n            // the map could be rotated and curved label should change its direction if they got upside down\n            // using center segment to identify this case is an approximation (ideally we should check all segments)\n            if (isRightPart ^^ isInverted) {\n                polylineDeltas[0] = decodePolylineDeltas_1_6(rightPolylineRatios[0], rightPolylineAngles[0], polylineLength);\n                polylineDeltas[1] = decodePolylineDeltas_1_6(rightPolylineRatios[1], rightPolylineAngles[1], polylineLength);\n                polylineDeltas[2] = decodePolylineDeltas_1_6(rightPolylineRatios[2], rightPolylineAngles[2], polylineLength);\n                polylineDeltas[3] = decodePolylineDeltas_1_6(rightPolylineRatios[3], rightPolylineAngles[3], polylineLength);\n            } else {\n                polylineDeltas[0] = decodePolylineDeltas_1_6(leftPolylineRatios[0], leftPolylineAngles[0], polylineLength);\n                polylineDeltas[1] = decodePolylineDeltas_1_6(leftPolylineRatios[1], leftPolylineAngles[1], polylineLength);\n                polylineDeltas[2] = decodePolylineDeltas_1_6(leftPolylineRatios[2], leftPolylineAngles[2], polylineLength);\n                polylineDeltas[3] = decodePolylineDeltas_1_6(leftPolylineRatios[3], leftPolylineAngles[3], polylineLength);\n            }\n\n            // the first right point of the segment already calculated,\n            // recalculate the point if this part of the label goes other direction\n            if (!(isRightPart && !isInverted) && !(!isRightPart && isInverted)) {\n                projectedPoint = project_1_5(viewProjMatrix, lookAtHigh, lookAtLow, pxSize, posHigh, posLow, polylineDeltas[i]);\n            }\n        } else {\n            projectedPoint = project_1_5(viewProjMatrix, lookAtHigh, lookAtLow, pxSize, posHigh, posLow, polylineDeltas[i]);\n        }\n\n        vec2 segment = projectedPoint - position;\n        bool isLast = i == (MAX_POLYLINE_POINTS_1_3 - 1);\n        float segmentLength = (isLast || (polylineDeltas[i + 1] == vec2(0, 0))) ? INFINITY_1_4 : length(segment);\n\n        if (segmentLength > remainingLength) {\n            float signFactor = lineDisplacement > 0.0 ? 1.0 : -1.0;\n            vec2 direction = normalize(segment);\n            vec2 normal = vec2(-direction.y, direction.x);\n\n            position += direction * remainingLength;\n            position += signFactor * direction * displacement.x;\n            position += signFactor * normal * displacement.y;\n\n            break;\n        } else {\n            remainingLength -= segmentLength;\n            position += segment;\n        }\n    }\n\n    return vec4(position * pxSize, 0.0, 1.0);\n}\n\n\n\n\n\n/**\n * Curved labels are layouted here: the label is centered in the vertexPosHigh/vertexPosLow and polyline points\n * are used to guide concrete gryph vertex. Number of polyline points is hardcoded to pass them in attributes.\n */\nvoid main(void) {\n    vec2 idTexCoordinate = vertexId.xy + idHalfPxSize;\n    float overlapZoom = texture2D(visibility, idTexCoordinate).b;\n\n    if (currentZoom < overlapZoom) {\n        gl_Position = DISCARD_POSITION;\n    } else {\n        vec2 vertexDisplacement = vertexDisplacements.xy;\n        float vertexLineDisplacement = vertexDisplacements.z;\n        float polylineLength = polylineLength_vertexScale[0];\n        gl_Position = projectCurvedLabelVertex_1_7(\n            viewProjMatrix,\n            lookAtHigh,\n            lookAtLow,\n            pixelSize,\n            vertexPosHigh,\n            vertexPosLow,\n            vertexDisplacement,\n            vertexLineDisplacement,\n            polylineLength,\n            leftPolylineRatios,\n            leftPolylineAngles,\n            rightPolylineRatios,\n            rightPolylineAngles\n        );\n\n        gl_Position.xy += shift;\n        gl_Position.z = vertexPriority;\n\n        color = vec4(vertexId, 0, 1);\n    }\n}\n"

/***/ }),
/* 120 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec2 vertexId;\n\n// point in the world the label is anchored to\nattribute vec2 vertexPosHigh;\nattribute vec2 vertexPosLow;\n\n// vector of concrete glyph point displacement (top-left, bottom-left, ...) relative to glyph's center (two values),\n// and distance of the glyph center to label's center (third value), in px\nattribute vec3 vertexDisplacements;\n\n// coordinates of the glyph vertex in the atlas\nattribute vec2 vertexUV;\n\nattribute float vertexPriority;\n\nattribute lowp vec4 vertexColor;\nattribute lowp vec4 vertexOutlineColor;\nattribute vec2 polylineLength_vertexScale;\n\n// deltas relative to the world point encoded in vertexPosHigh/vertexPosLow encoded via lengths and and angles of\n// corresponding vectors\nattribute vec4 leftPolylineRatios;\nattribute vec4 leftPolylineAngles;\nattribute vec4 rightPolylineRatios;\nattribute vec4 rightPolylineAngles;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\nuniform vec2 pixelSize;\nuniform sampler2D visibility;\nuniform vec2 idHalfPxSize;\nuniform vec2 shift;\nuniform lowp float currentZoom;\n\nvarying vec2 uv;\nvarying lowp vec4 color;\nvarying lowp vec4 outlineColor;\nvarying float scale;\n\nconst vec4 DISCARD_POSITION = vec4(2, 2, 2, 1);\n\nconst float YV_H_1_0 = 1.999969482421875;\nconst float YV_L_1_1 = 0.000030517112463712692;\n\nconst float PI_1_2 = 3.1415927410125732;\n\nconst int MAX_POLYLINE_POINTS_1_3 = 4;\nconst float INFINITY_1_4 = 1000000.0; // large enough for a segment length to consider it infinity\n\n/**\n * Returns world coordinate (plus delta) projected on screen, in pixels.\n */\nvec2 project_1_5(\n    mat4 viewProjMatrix,\n    vec2 lookAtHigh,\n    vec2 lookAtLow,\n    vec2 pixelSize,\n    vec2 pointHigh,\n    vec2 pointLow,\n    vec2 delta\n) {\n    vec4 position = viewProjMatrix * vec4(\n            YV_H_1_0 * (pointHigh - lookAtHigh) + YV_L_1_1 * (pointLow - lookAtLow) + delta,\n            0,\n            1\n        );\n    vec2 projected = position.xy / position.w;\n    return projected / pixelSize;\n}\n\n/**\n * Each point of the polyline is encoded as a vector from the polyline center by its normalized angle and the ratio of\n * its length to the polyline's length.\n */\nvec2 decodePolylineDeltas_1_6(float ratio, float angle, float polylineLength) {\n    // denormalize angle back to radians\n    float a = angle * 2.0 * PI_1_2 - PI_1_2;\n    // length of a vector\n    float len = ratio * polylineLength;\n    // restored point's (x, y) coordinates\n    return vec2(cos(a), sin(a)) * len;\n}\n\n/**\n * Projects specific curved label vertex onto the screen. The label is layouted by centering polyline in\n * the vertexPosHigh/vertexPosLow and other points are used to guide concrete gryph vertex.\n * Number of polyline points is hardcoded to pass them in attributes.\n */\nvec4 projectCurvedLabelVertex_1_7(\n    mat4 viewProjMatrix,\n    vec2 lookAtHigh,\n    vec2 lookAtLow,\n    vec2 pxSize,\n    vec2 posHigh,\n    vec2 posLow,\n    vec2 displacement,\n    float lineDisplacement,\n    float polylineLength,\n    vec4 leftPolylineRatios,\n    vec4 leftPolylineAngles,\n    vec4 rightPolylineRatios,\n    vec4 rightPolylineAngles\n) {\n    vec2 polylineDeltas[MAX_POLYLINE_POINTS_1_3];\n    vec2 position = project_1_5(viewProjMatrix, lookAtHigh, lookAtLow, pxSize, posHigh, posLow, vec2(0, 0));\n    float remainingLength = abs(lineDisplacement);\n    for (int i = 0; i < MAX_POLYLINE_POINTS_1_3; i++) {\n        vec2 projectedPoint;\n\n        // figure out the direction (left/right) at the first step\n        if (i == 0) {\n            projectedPoint = project_1_5(\n                viewProjMatrix,\n                lookAtHigh,\n                lookAtLow,\n                pxSize,\n                posHigh,\n                posLow,\n                decodePolylineDeltas_1_6(rightPolylineRatios[0], rightPolylineAngles[0], polylineLength)\n            );\n            bool isRightPart = lineDisplacement > 0.0;\n            bool isInverted = projectedPoint.x < position.x;\n\n            // the map could be rotated and curved label should change its direction if they got upside down\n            // using center segment to identify this case is an approximation (ideally we should check all segments)\n            if (isRightPart ^^ isInverted) {\n                polylineDeltas[0] = decodePolylineDeltas_1_6(rightPolylineRatios[0], rightPolylineAngles[0], polylineLength);\n                polylineDeltas[1] = decodePolylineDeltas_1_6(rightPolylineRatios[1], rightPolylineAngles[1], polylineLength);\n                polylineDeltas[2] = decodePolylineDeltas_1_6(rightPolylineRatios[2], rightPolylineAngles[2], polylineLength);\n                polylineDeltas[3] = decodePolylineDeltas_1_6(rightPolylineRatios[3], rightPolylineAngles[3], polylineLength);\n            } else {\n                polylineDeltas[0] = decodePolylineDeltas_1_6(leftPolylineRatios[0], leftPolylineAngles[0], polylineLength);\n                polylineDeltas[1] = decodePolylineDeltas_1_6(leftPolylineRatios[1], leftPolylineAngles[1], polylineLength);\n                polylineDeltas[2] = decodePolylineDeltas_1_6(leftPolylineRatios[2], leftPolylineAngles[2], polylineLength);\n                polylineDeltas[3] = decodePolylineDeltas_1_6(leftPolylineRatios[3], leftPolylineAngles[3], polylineLength);\n            }\n\n            // the first right point of the segment already calculated,\n            // recalculate the point if this part of the label goes other direction\n            if (!(isRightPart && !isInverted) && !(!isRightPart && isInverted)) {\n                projectedPoint = project_1_5(viewProjMatrix, lookAtHigh, lookAtLow, pxSize, posHigh, posLow, polylineDeltas[i]);\n            }\n        } else {\n            projectedPoint = project_1_5(viewProjMatrix, lookAtHigh, lookAtLow, pxSize, posHigh, posLow, polylineDeltas[i]);\n        }\n\n        vec2 segment = projectedPoint - position;\n        bool isLast = i == (MAX_POLYLINE_POINTS_1_3 - 1);\n        float segmentLength = (isLast || (polylineDeltas[i + 1] == vec2(0, 0))) ? INFINITY_1_4 : length(segment);\n\n        if (segmentLength > remainingLength) {\n            float signFactor = lineDisplacement > 0.0 ? 1.0 : -1.0;\n            vec2 direction = normalize(segment);\n            vec2 normal = vec2(-direction.y, direction.x);\n\n            position += direction * remainingLength;\n            position += signFactor * direction * displacement.x;\n            position += signFactor * normal * displacement.y;\n\n            break;\n        } else {\n            remainingLength -= segmentLength;\n            position += segment;\n        }\n    }\n\n    return vec4(position * pxSize, 0.0, 1.0);\n}\n\n\n\n\nvoid main(void) {\n    float visibilityAlpha = texture2D(visibility, vertexId.xy + idHalfPxSize).a;\n    if (visibilityAlpha != 0.0) {\n        vec2 vertexDisplacement = vertexDisplacements.xy;\n        float vertexLineDisplacement = vertexDisplacements.z;\n        float polylineLength = polylineLength_vertexScale[0];\n        float vertexScale = polylineLength_vertexScale[1];\n        gl_Position = projectCurvedLabelVertex_1_7(\n            viewProjMatrix,\n            lookAtHigh,\n            lookAtLow,\n            pixelSize,\n            vertexPosHigh,\n            vertexPosLow,\n            vertexDisplacement,\n            vertexLineDisplacement,\n            polylineLength,\n            leftPolylineRatios,\n            leftPolylineAngles,\n            rightPolylineRatios,\n            rightPolylineAngles\n        );\n\n        uv = vertexUV;\n        color = vertexColor;\n        outlineColor = vertexOutlineColor;\n        scale = vertexScale;\n\n        color.a *= visibilityAlpha;\n        outlineColor.a *= visibilityAlpha;\n    } else {\n        gl_Position = DISCARD_POSITION;\n    }\n}\n"

/***/ }),
/* 121 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_icon_vert__ = __webpack_require__(122);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_icon_vert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__shader_icon_vert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_icon_frag__ = __webpack_require__(123);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_icon_frag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__shader_icon_frag__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__image_image_render_unit__ = __webpack_require__(124);



/**
 * Renderer of icon primitives.
 */
class IconRenderUnit extends __WEBPACK_IMPORTED_MODULE_2__image_image_render_unit__["a" /* default */] {
    constructor(context, camera, primitiveProvider) {
        const program = context.createProgram(__WEBPACK_IMPORTED_MODULE_0__shader_icon_vert___default.a, __WEBPACK_IMPORTED_MODULE_1__shader_icon_frag___default.a, {
            attribMap: {
                vertexPosHigh: 0 /* POSITION_HIGH */,
                vertexPosLow: 1 /* POSITION_LOW */,
                vertexDisplacement: 6 /* DISPLACEMENT */,
                vertexUV: 4 /* UV */
            }
        });
        super(context, primitiveProvider, program);
        this._camera = camera;
    }
    _prepareProgram(program, viewProjMatrix, cameraPositions) {
        super._prepareProgram(program, viewProjMatrix, cameraPositions);
        program.setVector2Uniform('pixelSize', this._camera.pixelSize);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = IconRenderUnit;



/***/ }),
/* 122 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec2 vertexPosHigh;\nattribute vec2 vertexPosLow;\nattribute vec2 vertexDisplacement;\nattribute vec2 vertexUV;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\nuniform vec2 pixelSize;\n\nvarying vec2 uv;\n\nconst float YV_H = 1.999969482421875;\nconst float YV_L = 0.000030517112463712692;\n\nvoid main() {\n    vec4 position = viewProjMatrix * vec4(\n        YV_H * (vertexPosHigh - lookAtHigh) +\n            YV_L * (vertexPosLow - lookAtLow),\n        0,\n        1\n    );\n    position = vec4(position.xy / position.w, 0.0, 1.0);\n\n    gl_Position = position + vec4(vertexDisplacement * pixelSize, 0.0, 0.0);\n\n    uv = vertexUV;\n}\n"

/***/ }),
/* 123 */
/***/ (function(module, exports) {

module.exports = "#version 100\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform sampler2D atlas;\nuniform vec2 atlasSize;\n\nvarying vec2 uv;\n\nvoid main() {\n    gl_FragColor = texture2D(atlas, uv / atlasSize);\n}\n"

/***/ }),
/* 124 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_image_vert__ = __webpack_require__(125);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_image_vert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__shader_image_vert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_image_frag__ = __webpack_require__(126);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_image_frag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__shader_image_frag__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math_vector2__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__world_primitive_render_unit__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__render_state__ = __webpack_require__(0);






const RENDER_STATE = new __WEBPACK_IMPORTED_MODULE_4__render_state__["c" /* default */](__WEBPACK_IMPORTED_MODULE_4__render_state__["b" /* BLEND_OVER_RENDER_STATE */]);
function createDefaultProgram(context) {
    return context.createProgram(__WEBPACK_IMPORTED_MODULE_0__shader_image_vert___default.a, __WEBPACK_IMPORTED_MODULE_1__shader_image_frag___default.a, {
        attribMap: {
            vertexPosHigh: 0 /* POSITION_HIGH */,
            vertexPosLow: 1 /* POSITION_LOW */,
            vertexUV: 4 /* UV */
        }
    });
}
/**
 * Renderer of image primitives.
 */
class ImageRenderUnit extends __WEBPACK_IMPORTED_MODULE_3__world_primitive_render_unit__["a" /* default */] {
    constructor(context, primitiveProvider, program = createDefaultProgram(context)) {
        super(context, RENDER_STATE, program, primitiveProvider);
        this._atlasSizeUniform = __WEBPACK_IMPORTED_MODULE_2__math_vector2__["f" /* create */](0, 0);
        context.bindProgram(program);
        program.setIntScalarUniform('atlas', 0);
    }
    _renderBatch(memoryBatch) {
        const atlas = memoryBatch.firstPrimitive.atlas;
        this._atlasSizeUniform.x = atlas.width;
        this._atlasSizeUniform.y = atlas.height;
        if (atlas.isDirty) {
            atlas.syncTexture();
        }
        this._program.setVector2Uniform('atlasSize', this._atlasSizeUniform);
        this._context.bindTextureUnit(0);
        this._context.bindTexture(atlas.texture);
        super._renderBatch(memoryBatch);
    }
    _canBatchAdjacentPrimitives(a, b) {
        return super._canBatchAdjacentPrimitives(a, b) && (a.atlas === b.atlas);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ImageRenderUnit;



/***/ }),
/* 125 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec2 vertexPosHigh;\nattribute vec2 vertexPosLow;\nattribute vec2 vertexUV;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\n\nvarying vec2 uv;\n\nconst float YV_H = 1.999969482421875;\nconst float YV_L = 0.000030517112463712692;\n\nvoid main() {\n    vec4 position = viewProjMatrix * vec4(\n        YV_H * (vertexPosHigh - lookAtHigh) +\n            YV_L * (vertexPosLow - lookAtLow),\n        0,\n        1\n    );\n\n    gl_Position = position;\n\n    uv = vertexUV;\n}\n"

/***/ }),
/* 126 */
/***/ (function(module, exports) {

module.exports = "#version 100\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform sampler2D atlas;\nuniform vec2 atlasSize;\n\nvarying vec2 uv;\n\nvoid main() {\n    gl_FragColor = texture2D(atlas, uv / atlasSize);\n\n    if (gl_FragColor.a == 0.0) {\n        discard;\n    }\n}\n"

/***/ }),
/* 127 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_model_vert__ = __webpack_require__(128);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_model_vert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__shader_model_vert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_model_frag__ = __webpack_require__(129);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_model_frag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__shader_model_frag__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math_vector2__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__overlay_overlay_renderer__ = __webpack_require__(130);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__render_state__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__world_primitive_render_unit__ = __webpack_require__(5);






const RENDER_STATE = new __WEBPACK_IMPORTED_MODULE_4__render_state__["c" /* default */]({
    depthTest: true
});
/**
 * Renderer of models. It renders models into a texture with depth test and then this texture into the render target.
 * It allows to show only the top facets of semi-transparent objects without exposing their inner structure.
 */
class ModelRenderUnit extends __WEBPACK_IMPORTED_MODULE_5__world_primitive_render_unit__["a" /* default */] {
    constructor(context, primitiveProvider) {
        const program = context.createProgram(__WEBPACK_IMPORTED_MODULE_0__shader_model_vert___default.a, __WEBPACK_IMPORTED_MODULE_1__shader_model_frag___default.a, {
            attribMap: {
                vertexPosHigh: 0 /* POSITION_HIGH */,
                vertexPosLow: 1 /* POSITION_LOW */,
                vertexHeight: 3 /* HEIGHT */,
                vertexColor: 7 /* COLOR */
            }
        });
        super(context, RENDER_STATE, program, primitiveProvider);
        this._outputSize = Object(__WEBPACK_IMPORTED_MODULE_2__math_vector2__["h" /* createExtent2 */])(-1, -1);
        this._overlayRenderer = new __WEBPACK_IMPORTED_MODULE_3__overlay_overlay_renderer__["a" /* default */](context);
    }
    render(target, viewProjMatrix, cameraPositions) {
        this._syncOutputBuffer(target);
        super.render(this._outputBuffer, viewProjMatrix, cameraPositions);
        // do not run unnecessary copying if this._outputBuffer was not updated (no models in scene?)
        if (!this._outputBuffer.isClear) {
            // copy into the final target
            this._overlayRenderer.render(target, this._outputTexture);
        }
    }
    destroy() {
        this._overlayRenderer.destroy();
        if (this._outputTexture) {
            this._outputTexture.destroy();
        }
        if (this._outputDepthBuffer) {
            this._outputDepthBuffer.destroy();
        }
        if (this._outputBuffer) {
            this._outputBuffer.destroy();
        }
        super.destroy();
    }
    _syncOutputBuffer(target) {
        // make sure the intermediate texture fits the output target
        if (this._outputSize.width !== target.getWidth() ||
            this._outputSize.height !== target.getHeight()) {
            if (this._outputTexture || this._outputDepthBuffer || this._outputBuffer) {
                this._outputTexture.destroy();
                this._outputDepthBuffer.destroy();
                this._outputBuffer.destroy();
            }
            this._outputSize = { width: target.getWidth(), height: target.getHeight() };
            this._outputTexture = this._context.createEmpty2DTexture(this._outputSize.width, this._outputSize.height, 6408 /* RGBA */, 5121 /* UNSIGNED_BYTE */);
            this._outputDepthBuffer = this._context.createRenderbuffer(this._outputSize.width, this._outputSize.height, 34041 /* DEPTH_STENCIL */);
            this._outputBuffer = this._context.createFramebuffer({
                color: this._outputTexture,
                depthStencil: this._outputDepthBuffer
            });
        }
    }
    /**
     * Overridden _bindRenderTarget() to bind intermediate render target to render models into and
     * later put its content into the final target.
     */
    _prepareRenderTarget(target, viewProjMatrix, cameraPositions) {
        super._prepareRenderTarget(target, viewProjMatrix, cameraPositions);
        this._context.clearCurrentTarget(16384 /* COLOR_BUFFER_BIT */ | 256 /* DEPTH_BUFFER_BIT */);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ModelRenderUnit;



/***/ }),
/* 128 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec3 vertexPosHigh;\nattribute vec3 vertexPosLow;\nattribute float vertexHeight;\nattribute vec4 vertexColor;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\n\nvarying vec4 globalPos;\nvarying vec4 diffuseColor;\n\nconst float YV_H = 1.999969482421875;\nconst float YV_L = 0.000030517112463712692;\n\nvoid main(void) {\n    globalPos = vec4(\n        YV_H * (vertexPosHigh.xy - lookAtHigh) + YV_L * (vertexPosLow.xy - lookAtLow),\n        vertexHeight,\n        1\n    );\n\n    gl_Position = viewProjMatrix * globalPos;\n    diffuseColor = vertexColor;\n}\n"

/***/ }),
/* 129 */
/***/ (function(module, exports) {

module.exports = "#version 100\n\n#extension GL_OES_standard_derivatives : require\n\nprecision mediump float;\n#define GLSLIFY 1\n\nvarying vec4 diffuseColor;\nvarying vec4 globalPos;\n\nconst vec3 LIGHT_DIRECTION = normalize(vec3(0.5, 0.5, 1.0));\nconst float LIGHT_INTENSITY = 0.3;\nconst float AMBIENT_LIGHT_INTENSITY = 1.0 - LIGHT_INTENSITY;\nconst float HORIZONTAL_PLANE_DIFFUSE_INTENSITY =\n    AMBIENT_LIGHT_INTENSITY + 0.5 * LIGHT_INTENSITY * (LIGHT_DIRECTION.z + 1.0);\n\nvoid main(void) {\n    vec3 pos = globalPos.xyz;\n\n    vec3 dxpos = normalize(dFdx(pos));\n    vec3 dypos = normalize(dFdy(pos));\n    vec3 normal = normalize(cross(dxpos, dypos));\n\n    gl_FragColor = vec4(\n        diffuseColor.rgb * (AMBIENT_LIGHT_INTENSITY + 0.5 * LIGHT_INTENSITY * (dot(normal, LIGHT_DIRECTION) + 1.0)) /\n            HORIZONTAL_PLANE_DIFFUSE_INTENSITY,\n        diffuseColor.a\n    );\n}\n"

/***/ }),
/* 130 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_overlay_vert__ = __webpack_require__(131);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_overlay_vert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__shader_overlay_vert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_overlay_frag__ = __webpack_require__(132);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_overlay_frag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__shader_overlay_frag__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__render_gl_renderer__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__render_state__ = __webpack_require__(0);





const RENDER_STATE = new __WEBPACK_IMPORTED_MODULE_3__render_state__["c" /* default */](__WEBPACK_IMPORTED_MODULE_3__render_state__["b" /* BLEND_OVER_RENDER_STATE */]);
/**
 * Renders a texture into a render target with OVER compositing. The texture will completely overlay the target, i.e.
 * it is stretched/shrinked to fit the target width/height, so ideally they should have the same dimensions.
 */
class OverlayRenderer extends __WEBPACK_IMPORTED_MODULE_2__render_gl_renderer__["a" /* GlRenderer */] {
    constructor(context) {
        const program = context.createProgram(__WEBPACK_IMPORTED_MODULE_0__shader_overlay_vert___default.a, __WEBPACK_IMPORTED_MODULE_1__shader_overlay_frag___default.a, {
            attribMap: {
                vertexPosition: 0 /* POSITION */,
                vertexUV: 4 /* UV */
            }
        });
        super(context, RENDER_STATE, program);
    }
    _render(texture) {
        this._context.bindTextureUnit(0);
        this._context.bindTexture(texture);
        this._context.bindQuadVao();
        this._context.drawQuad();
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = OverlayRenderer;



/***/ }),
/* 131 */
/***/ (function(module, exports) {

module.exports = "#version 100\nprecision mediump float;\n#define GLSLIFY 1\n\nattribute vec2 vertexPosition;\nattribute vec2 vertexUV;\n\nvarying vec2 uv;\n\nvoid main() {\n    gl_Position = vec4(vertexPosition, 0, 1);\n    uv = vertexUV;\n}\n"

/***/ }),
/* 132 */
/***/ (function(module, exports) {

module.exports = "#version 100\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform sampler2D texture;\n\nvarying vec2 uv;\n\nvoid main() {\n    gl_FragColor = texture2D(texture, uv);\n}\n"

/***/ }),
/* 133 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_textured_polyline_vert__ = __webpack_require__(134);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_textured_polyline_vert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__shader_textured_polyline_vert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_textured_polyline_frag__ = __webpack_require__(135);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_textured_polyline_frag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__shader_textured_polyline_frag__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math_vector2__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__render_state__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__base_polyline_render_unit__ = __webpack_require__(49);





const FILTER_RADIUS = 1.0 / devicePixelRatio;
const RENDER_STATE = new __WEBPACK_IMPORTED_MODULE_3__render_state__["c" /* default */](__WEBPACK_IMPORTED_MODULE_3__render_state__["a" /* BLEND_OVER_PREMULTIPLIED_ALPHA_RENDER_STATE */], {
    depthTest: true,
    depthMask: false,
    depthFunc: 518 /* GREATER_OR_EQUAL */
});
/**
 * Renderer of polyline primitives.
 */
class TexturedPolylineRenderUnit extends __WEBPACK_IMPORTED_MODULE_4__base_polyline_render_unit__["a" /* default */] {
    constructor(context, camera, primitiveProvider) {
        const program = context.createProgram(__WEBPACK_IMPORTED_MODULE_0__shader_textured_polyline_vert___default.a, __WEBPACK_IMPORTED_MODULE_1__shader_textured_polyline_frag___default.a, {
            defines: {
                FILTER_RADIUS: `float(${FILTER_RADIUS})`
            },
            attribMap: {
                vertexPosHigh: 0 /* POSITION_HIGH */,
                vertexPosLow: 1 /* POSITION_LOW */,
                vertexDisplacement: 6 /* DISPLACEMENT */,
                vertexUV: 4 /* UV */,
                vertexZIndex: 9 /* PRIORITY */,
                vertexHalfWidth: 11 /* AUX */,
                vertexPattern: 12 /* AUX1 */,
                vertexPatternHalfHeight: 13 /* AUX2 */
            }
        });
        super(context, RENDER_STATE, program, primitiveProvider, camera);
        this._atlasSizeUniform = __WEBPACK_IMPORTED_MODULE_2__math_vector2__["f" /* create */](0, 0);
        context.bindProgram(program);
        program.setIntScalarUniform('atlas', 0);
    }
    _renderBatch(memoryBatch) {
        const atlas = memoryBatch.firstPrimitive.atlas;
        this._atlasSizeUniform.x = atlas.width;
        this._atlasSizeUniform.y = atlas.height;
        if (atlas.isDirty) {
            atlas.syncTexture();
        }
        this._program.setVector2Uniform('atlasSize', this._atlasSizeUniform);
        this._context.bindTextureUnit(0);
        this._context.bindTexture(atlas.texture);
        super._renderBatch(memoryBatch);
    }
    _canBatchAdjacentPrimitives(a, b) {
        return super._canBatchAdjacentPrimitives(a, b) && (a.atlas === b.atlas);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = TexturedPolylineRenderUnit;



/***/ }),
/* 134 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\n#ifndef FILTER_RADIUS\n#   error FILTER_RADIUS must be set\n#endif\n\nattribute vec2 vertexPosHigh;\nattribute vec2 vertexPosLow;\nattribute vec2 vertexDisplacement;\nattribute vec2 vertexUV;\nattribute float vertexHalfWidth;\nattribute vec2 vertexPattern;\nattribute float vertexPatternHalfHeight;\nattribute float vertexZIndex;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\nuniform float worldToPxFactor;\n\nvarying vec2 uv;\nvarying float s;\nvarying float patternLength;\nvarying float len;\nvarying float halfWidth;\nvarying float extHalfWidth;\nvarying float patternHalfHeight;\n\nconst float YV_H = 1.999969482421875;\nconst float YV_L = 0.000030517112463712692;\n\nvoid main(void) {\n    halfWidth = vertexHalfWidth;\n    extHalfWidth = halfWidth + FILTER_RADIUS;\n\n    vec4 position = viewProjMatrix * vec4(\n        YV_H * (vertexPosHigh - lookAtHigh) +\n            YV_L * (vertexPosLow - lookAtLow) +\n                worldToPxFactor * extHalfWidth * vertexDisplacement,\n        0,\n        1\n    );\n\n    position.xy /= position.w;\n    position.z = vertexZIndex;\n    position.w = 1.0;\n\n    gl_Position = position;\n\n    patternLength = vertexPattern[0];\n    len = vertexPattern[1];\n    // Distance to the analytical line along segment's normal\n    s = sign(vertexPatternHalfHeight) * extHalfWidth;\n    // The whole texture is being sampled to the original geometry. For pixels in the extended polyline part the topmost\n    // (bottommost) texels are taken. To make this happen the UV texture coordinates are extended in proportion to the\n    // polyline width extension.\n    patternHalfHeight = abs(vertexPatternHalfHeight);\n    uv = vec2(vertexUV.x, vertexUV.y - vertexPatternHalfHeight * FILTER_RADIUS / halfWidth);\n}\n"

/***/ }),
/* 135 */
/***/ (function(module, exports) {

module.exports = "#version 100\n\n#ifndef FILTER_RADIUS\n#   error FILTER_RADIUS must be set\n#endif\n\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform sampler2D atlas;\nuniform vec2 atlasSize;\n\nvarying vec2 uv;\nvarying float s;\nvarying float patternLength;\nvarying float len;\nvarying float halfWidth;\nvarying float extHalfWidth;\nvarying float patternHalfHeight;\n\nvoid main(void) {\n    lowp float alpha = smoothstep(0.0, FILTER_RADIUS + min(FILTER_RADIUS, extHalfWidth), extHalfWidth - abs(s));\n\n    // Clamp texture U coordinate by 0.5px from both sides to avoid bleeding.\n    vec2 uvAdjusted = vec2(uv.x + clamp(mod(len, patternLength), 0.5, patternLength - 0.5), uv.y);\n    // UV texture coordinates have been extended in proportion to the polyline width extension.\n    // Clamp texture V coordinate to the original geometry minus 0.5px to avoid bleeding.\n    float patternToGeometryFactor = halfWidth / patternHalfHeight;\n    float clampTo = halfWidth - 0.5 * patternToGeometryFactor;\n    if (step(clampTo, abs(s)) == 1.) {\n        float delta = s - clamp(s, -clampTo, clampTo);\n        uvAdjusted.y += delta / patternToGeometryFactor;\n    }\n\n    lowp vec4 color = texture2D(atlas, uvAdjusted / atlasSize);\n    gl_FragColor = color * alpha;\n}\n"

/***/ }),
/* 136 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__primitive_polyline_polyline_buffer_writer__ = __webpack_require__(137);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_polyline_vert__ = __webpack_require__(138);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_polyline_vert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__shader_polyline_vert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shader_polyline_frag__ = __webpack_require__(139);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shader_polyline_frag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__shader_polyline_frag__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__base_polyline_render_unit__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__render_state__ = __webpack_require__(0);





// Values was chosen by team consensus in VECTOR-197
const FILTER_RADIUS = 1.0 / devicePixelRatio; // px
const DEFAULT_RENDER_STATE_PARAMS = {
    blend: true,
    blendFuncSrcRgb: 1 /* ONE */,
    blendFuncDstRgb: 771 /* ONE_MINUS_SRC_ALPHA */,
    blendFuncSrcAlpha: 1 /* ONE */,
    blendFuncDstAlpha: 771 /* ONE_MINUS_SRC_ALPHA */
};
/* unused harmony export DEFAULT_RENDER_STATE_PARAMS */

/**
 * Renderer of polyline primitives. Its default render state is aimed to render opaque polylines.
 */
class PolylineRenderUnit extends __WEBPACK_IMPORTED_MODULE_3__base_polyline_render_unit__["a" /* default */] {
    constructor(context, camera, primitiveProvider, renderState = new __WEBPACK_IMPORTED_MODULE_4__render_state__["c" /* default */](DEFAULT_RENDER_STATE_PARAMS)) {
        const program = context.createProgram(__WEBPACK_IMPORTED_MODULE_1__shader_polyline_vert___default.a, __WEBPACK_IMPORTED_MODULE_2__shader_polyline_frag___default.a, {
            defines: {
                FILTER_RADIUS: `float(${FILTER_RADIUS})`,
                MAX_HALF_WIDTH: `float(${__WEBPACK_IMPORTED_MODULE_0__primitive_polyline_polyline_buffer_writer__["b" /* MAX_HALF_WIDTH */]})`,
                MAX_FILL_GAP: `float(${__WEBPACK_IMPORTED_MODULE_0__primitive_polyline_polyline_buffer_writer__["a" /* MAX_FILL_GAP */]})`
            },
            attribMap: {
                vertexPos: 0 /* POSITION */,
                vertexNormalPacked: 5 /* NORMAL */,
                vertexUvPacked: 4 /* UV */,
                vertexWidthFillGap: 11 /* AUX */,
                vertexColor: 7 /* COLOR */,
                vertexMiter: 12 /* AUX1 */,
                vertexVLimit: 13 /* AUX2 */,
                vertexLength: 14 /* AUX3 */
            }
        });
        super(context, renderState, program, primitiveProvider, camera);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = PolylineRenderUnit;



/***/ }),
/* 137 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_vector2__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_color__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_buffer_writer__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__polyline_attribute_mapping__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__util_gputypes__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__util_z_index__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__math_scalar__ = __webpack_require__(9);







/**
 * Computes miter of a join between two segments.
 *
 * @param n1 Normal vector of the first segment.
 * @param n2 Normal vector of the second segment.
 * @returns Miter value, i.e. by how match displacement is longer than a normal
 *      one.
 */
function computeMiter(n1, n2) {
    return Math.sqrt(2 / (1 + __WEBPACK_IMPORTED_MODULE_0__math_vector2__["m" /* dot */](n1, n2)));
}
const SEGMENT_VERTEX_COUNT = 4;
const SQUARE_CAP_VERTEX_COUNT = 5;
const ROUND_CAP_VERTEX_COUNT = 4;
const FLOAT_MAX = 3.4028234663852886e+38;
const MITER_LIMIT = 4;
const UV_POS_ONE_PACKED = 255; // packed 1
const UV_NEG_ONE_PACKED = 1; // packed -1
const UV_ZERO_PACKED = 128;
/**
 * Packs a component of uv into a unsigned 8-bit value. After packing -1 will
 * become 1 and 1 will become 255. That's need to emulate zero-preserving
 * normalization (we can't rely on WebGL to do it for us :().
 *
 * @param c The component.
 * @returns Packed component.
 */
function packUvComponent(c) {
    // We don't truncate here because buffer writer will do that for us.
    return 128 + (127 * c);
}
/**
 * Half width of the polyline is stored in a normalized attribute. This constant
 * defines half width value of 1 corresponds to.
 */
const MAX_HALF_WIDTH = 255 / 4;
/* harmony export (immutable) */ __webpack_exports__["b"] = MAX_HALF_WIDTH;
 // px
/**
 * Same as for polyline half width, but for dash pattern definition.
 */
const MAX_FILL_GAP = 255;
/* harmony export (immutable) */ __webpack_exports__["a"] = MAX_FILL_GAP;
 // px
class PolylineBufferWriter extends __WEBPACK_IMPORTED_MODULE_2__util_buffer_writer__["b" /* default */] {
    constructor() {
        super(__WEBPACK_IMPORTED_MODULE_3__polyline_attribute_mapping__["a" /* POLYLINE_ATTRIBUTE_MAPPING */].vertexByteSize);
        this._displacement = __WEBPACK_IMPORTED_MODULE_0__math_vector2__["f" /* create */](0, 0);
        this._prevDisplacement = __WEBPACK_IMPORTED_MODULE_0__math_vector2__["f" /* create */](0, 0);
        this._initPolylineState([__WEBPACK_IMPORTED_MODULE_0__math_vector2__["a" /* ZERO */], __WEBPACK_IMPORTED_MODULE_0__math_vector2__["a" /* ZERO */]], 0, 0, 0, 0, 0 /* MITER */, 0);
    }
    /**
     * Generates a mesh for a polyline with a given style, baking all necessary
     * parameters into attributes.
     *
     * @param polyline The polyline.
     * @param style The polyline style.
     * @returns Location of the written mesh in the managed buffers.
     */
    writePolyline(polyline, style, zIndex) {
        const { vertices } = polyline;
        const lastIdx = vertices.length - 1;
        if (lastIdx < 1) {
            throw new Error('One vertex in not a polyline. It\'s not even a line.');
        }
        this._initPolylineState(vertices, Object(__WEBPACK_IMPORTED_MODULE_1__util_color__["d" /* encodeRgba8 */])(style.strokeColor), style.strokeWidth, style.dash ? style.dash.fill : 0, style.dash ? style.dash.gap : 0, style.join, Object(__WEBPACK_IMPORTED_MODULE_5__util_z_index__["a" /* intToZIndex */])(zIndex));
        this._writeCap(style.startCap, vertices[0], 1);
        for (let i = 1; i < lastIdx; ++i) {
            this._writeSegment(vertices[i - 1], vertices[i], vertices[i + 1]);
            this._writeJoin(vertices[i]);
        }
        this._writeLastSegment(vertices[lastIdx - 1], vertices[lastIdx]);
        this._writeCap(style.endCap, vertices[lastIdx], 1);
        return this.endMesh();
    }
    _initPolylineState(vertices, colorRgba8, width, fill, gap, join, zIndex) {
        this._baseIndex = this._polylineLength = this._lastDirection = 0;
        this._lastSignedMiter = 1;
        const displacement = __WEBPACK_IMPORTED_MODULE_0__math_vector2__["s" /* sub */](vertices[1], vertices[0], this._displacement);
        this._segmentLength = __WEBPACK_IMPORTED_MODULE_0__math_vector2__["o" /* length */](displacement);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["k" /* divn */](displacement, this._segmentLength, displacement);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["r" /* rotate90 */](displacement, displacement);
        this._colorRgba8 = colorRgba8;
        this._halfWidthFillGapPacked =
            Object(__WEBPACK_IMPORTED_MODULE_4__util_gputypes__["c" /* floatToUint8 */])(Object(__WEBPACK_IMPORTED_MODULE_6__math_scalar__["a" /* clamp */])(0.5 * width, 0, MAX_HALF_WIDTH) / MAX_HALF_WIDTH) |
                Object(__WEBPACK_IMPORTED_MODULE_4__util_gputypes__["c" /* floatToUint8 */])(Object(__WEBPACK_IMPORTED_MODULE_6__math_scalar__["a" /* clamp */])(fill, 0, MAX_FILL_GAP) / MAX_FILL_GAP) << 8 |
                Object(__WEBPACK_IMPORTED_MODULE_4__util_gputypes__["c" /* floatToUint8 */])(Object(__WEBPACK_IMPORTED_MODULE_6__math_scalar__["a" /* clamp */])(gap, 0, MAX_FILL_GAP) / MAX_FILL_GAP) << 16;
        this._join = join;
        this._zIndex = zIndex;
    }
    /**
     * Writes a single vertex into managed vertex buffer.
     *
     * @param position Vertex world position.
     * @param normal Normal of segment the vertex belongs to.
     * @param u Normalized distance to the polyline along the normal.
     * @param v Normalized distance to the polyline along the tangent.
     * @param polylineLength Distance to the first vertex along the polyline.
     * @param miter Join miter.
     * @param lengthCorrectionLimit Limit on the vertex displacement along the
     *      polyline.
     */
    _writeVertex(position, normal, uPacked, vPacked, polylineLength, miter, lengthCorrectionLimit) {
        this._writeWorldCoordinate(position);
        this._writeHalfWords(Object(__WEBPACK_IMPORTED_MODULE_4__util_gputypes__["a" /* floatToUint16 */])(0.5 * (normal.x * Math.SQRT1_2 + 1)), Object(__WEBPACK_IMPORTED_MODULE_4__util_gputypes__["a" /* floatToUint16 */])(0.5 * (normal.y * Math.SQRT1_2 + 1)));
        this._writeHalfWords(uPacked, vPacked);
        this._writeWord(this._halfWidthFillGapPacked);
        this._writeFloat32(miter);
        this._writeFloat32(lengthCorrectionLimit);
        this._writeFloat32(polylineLength);
        this._writeWord(this._colorRgba8);
        this._writeFloat32(this._zIndex);
    }
    _writeCap(cap, endVertex, displacementSign) {
        switch (cap) {
            case 1 /* ROUND */:
                this._writeRoundCap(endVertex, displacementSign);
                break;
            case 2 /* SQUARE */:
                this._writeSquareCap(endVertex, displacementSign);
                break;
        }
    }
    _writeRoundCap(endVertex, displacementSign) {
        const displacement = __WEBPACK_IMPORTED_MODULE_0__math_vector2__["f" /* create */](0, 0);
        const polylineLength = this._polylineLength;
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["p" /* muln */](this._displacement, -displacementSign, displacement);
        this._writeVertex(endVertex, displacement, UV_NEG_ONE_PACKED, UV_ZERO_PACKED, polylineLength, 1, FLOAT_MAX);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["r" /* rotate90 */](this._displacement, displacement);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["s" /* sub */](displacement, this._displacement, displacement);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["p" /* muln */](displacement, displacementSign, displacement);
        this._writeVertex(endVertex, displacement, UV_NEG_ONE_PACKED, UV_POS_ONE_PACKED, polylineLength, 1, FLOAT_MAX);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["p" /* muln */](this._displacement, displacementSign, displacement);
        this._writeVertex(endVertex, displacement, UV_POS_ONE_PACKED, UV_ZERO_PACKED, polylineLength, 1, FLOAT_MAX);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["r" /* rotate90 */](this._displacement, displacement);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["b" /* add */](displacement, this._displacement, displacement);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["p" /* muln */](displacement, displacementSign, displacement);
        this._writeVertex(endVertex, displacement, UV_POS_ONE_PACKED, UV_POS_ONE_PACKED, polylineLength, 1, FLOAT_MAX);
        this.writeIndicesForContinuousStrip(ROUND_CAP_VERTEX_COUNT, this._baseIndex);
        this._baseIndex += ROUND_CAP_VERTEX_COUNT;
    }
    _writeSquareCap(endVertex, displacementSign) {
        const displacement = __WEBPACK_IMPORTED_MODULE_0__math_vector2__["f" /* create */](0, 0);
        const polylineLength = this._polylineLength;
        this._writeVertex(endVertex, __WEBPACK_IMPORTED_MODULE_0__math_vector2__["a" /* ZERO */], UV_ZERO_PACKED, UV_ZERO_PACKED, polylineLength, 1, 0);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["p" /* muln */](this._displacement, -displacementSign, displacement);
        this._writeVertex(endVertex, displacement, UV_POS_ONE_PACKED, UV_ZERO_PACKED, polylineLength, 1, FLOAT_MAX);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["r" /* rotate90 */](this._displacement, displacement);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["s" /* sub */](displacement, this._displacement, displacement);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["p" /* muln */](displacement, displacementSign, displacement);
        this._writeVertex(endVertex, displacement, UV_POS_ONE_PACKED, UV_ZERO_PACKED, polylineLength, 1, FLOAT_MAX);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["r" /* rotate90 */](this._displacement, displacement);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["s" /* sub */](displacement, this._displacement, displacement);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["p" /* muln */](displacement, displacementSign, displacement);
        this._writeVertex(endVertex, displacement, UV_POS_ONE_PACKED, UV_ZERO_PACKED, polylineLength, 1, FLOAT_MAX);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["p" /* muln */](this._displacement, displacementSign, displacement);
        this._writeVertex(endVertex, this._displacement, UV_POS_ONE_PACKED, UV_ZERO_PACKED, polylineLength, 1, FLOAT_MAX);
        this.writeIndicesForContinuousFan(SQUARE_CAP_VERTEX_COUNT, this._baseIndex);
        this._baseIndex += SQUARE_CAP_VERTEX_COUNT;
    }
    _writeSegment(start, end, nextEnd) {
        const displacement = this._displacement;
        const polylineLength = this._polylineLength;
        const nextSegmentLength = __WEBPACK_IMPORTED_MODULE_0__math_vector2__["j" /* distance */](nextEnd, end);
        const nextSegmentNormal = __WEBPACK_IMPORTED_MODULE_0__math_vector2__["s" /* sub */](nextEnd, end);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["k" /* divn */](nextSegmentNormal, nextSegmentLength, nextSegmentNormal);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["r" /* rotate90 */](nextSegmentNormal, nextSegmentNormal);
        const direction1 = this._lastDirection;
        const direction2 = Math.sign(__WEBPACK_IMPORTED_MODULE_0__math_vector2__["i" /* crossZ */](displacement, nextSegmentNormal));
        const miter1 = this._lastSignedMiter;
        const miter2 = computeMiter(displacement, nextSegmentNormal);
        this._writeVertex(start, displacement, UV_POS_ONE_PACKED, UV_ZERO_PACKED, polylineLength, direction1 === -1 && (this._join !== 0 /* MITER */ || Math.abs(miter1) > MITER_LIMIT) ?
            1 :
            miter1, direction1 === -1 ? -FLOAT_MAX : 0.5 * this._segmentLength);
        this._writeVertex(end, displacement, UV_POS_ONE_PACKED, UV_ZERO_PACKED, polylineLength + this._segmentLength, direction2 === -1 && (this._join !== 0 /* MITER */ || miter2 > MITER_LIMIT) ?
            1 :
            direction2 * miter2, direction2 === -1 ? FLOAT_MAX : -0.5 * this._segmentLength);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["n" /* invert */](displacement, displacement);
        this._writeVertex(start, displacement, UV_NEG_ONE_PACKED, UV_ZERO_PACKED, polylineLength, direction1 === 1 && (this._join !== 0 /* MITER */ || Math.abs(miter1) > MITER_LIMIT) ?
            1 :
            miter1, direction1 === 1 ? -FLOAT_MAX : 0.5 * this._segmentLength);
        this._writeVertex(end, displacement, UV_NEG_ONE_PACKED, UV_ZERO_PACKED, polylineLength + this._segmentLength, direction2 === 1 && (this._join !== 0 /* MITER */ || miter2 > MITER_LIMIT) ?
            1 :
            direction2 * miter2, direction2 === 1 ? FLOAT_MAX : -0.5 * this._segmentLength);
        this.writeIndicesForContinuousStrip(SEGMENT_VERTEX_COUNT, this._baseIndex);
        this._baseIndex += SEGMENT_VERTEX_COUNT;
        this._lastSignedMiter = -direction2 * miter2;
        this._lastDirection = direction2;
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["e" /* copy */](displacement, this._prevDisplacement);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["e" /* copy */](nextSegmentNormal, displacement);
        this._polylineLength += this._segmentLength;
        this._segmentLength = nextSegmentLength;
    }
    _writeJoin(joinVertex) {
        switch (this._join) {
            case 2 /* BEVEL */:
                this._writeBevelJoin(joinVertex);
                break;
            case 1 /* ROUND */:
                this._writeRoundJoin(joinVertex);
                break;
            case 0 /* MITER */:
                if (Math.abs(this._lastSignedMiter) > MITER_LIMIT) {
                    this._writeBevelJoin(joinVertex);
                }
                break;
        }
    }
    _writeBevelJoin(joinVertex) {
        const lastDirection = this._lastDirection;
        const displacement = __WEBPACK_IMPORTED_MODULE_0__math_vector2__["n" /* invert */](this._displacement);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["b" /* add */](displacement, this._prevDisplacement, displacement);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["p" /* muln */](displacement, 0.5 * lastDirection, displacement);
        this._writeVertex(joinVertex, displacement, lastDirection === -1 /* LEFT */ ?
            UV_POS_ONE_PACKED :
            UV_NEG_ONE_PACKED, UV_ZERO_PACKED, this._polylineLength, 1, 1);
        const baseIndex = this._baseIndex;
        this.writeIndices([
            baseIndex - 1,
            baseIndex - 3,
            baseIndex,
            baseIndex,
            lastDirection === -1 /* LEFT */ ? baseIndex + 1 : baseIndex + 3,
            lastDirection === -1 /* LEFT */ ? baseIndex + 3 : baseIndex + 1
        ]);
        this._baseIndex += 1;
    }
    _writeRoundJoin(joinVertex) {
        const polylineLength = this._polylineLength;
        this._writeVertex(joinVertex, __WEBPACK_IMPORTED_MODULE_0__math_vector2__["a" /* ZERO */], UV_ZERO_PACKED, UV_ZERO_PACKED, polylineLength, 0, 0);
        const lastDirection = this._lastDirection;
        const middleDisplacement = __WEBPACK_IMPORTED_MODULE_0__math_vector2__["n" /* invert */](this._prevDisplacement);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["b" /* add */](this._displacement, middleDisplacement, middleDisplacement);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["q" /* normalize */](middleDisplacement, middleDisplacement);
        const displacement = __WEBPACK_IMPORTED_MODULE_0__math_vector2__["n" /* invert */](this._prevDisplacement);
        const miter1 = computeMiter(middleDisplacement, displacement);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["b" /* add */](displacement, middleDisplacement, displacement);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["q" /* normalize */](displacement, displacement);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["p" /* muln */](displacement, -lastDirection * miter1, displacement);
        this._writeVertex(joinVertex, displacement, lastDirection === -1 /* LEFT */ ?
            UV_POS_ONE_PACKED :
            UV_NEG_ONE_PACKED, packUvComponent(Math.sqrt(miter1 * miter1 - 1)), polylineLength, 1, FLOAT_MAX);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["p" /* muln */](middleDisplacement, -lastDirection, displacement);
        this._writeVertex(joinVertex, displacement, lastDirection === -1 /* LEFT */ ?
            UV_POS_ONE_PACKED :
            UV_NEG_ONE_PACKED, UV_ZERO_PACKED, polylineLength, 1, FLOAT_MAX);
        const miter2 = computeMiter(middleDisplacement, this._displacement);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["b" /* add */](this._displacement, middleDisplacement, displacement);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["q" /* normalize */](displacement, displacement);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["p" /* muln */](displacement, -lastDirection * miter2, displacement);
        this._writeVertex(joinVertex, displacement, lastDirection === -1 /* LEFT */ ?
            UV_POS_ONE_PACKED :
            UV_NEG_ONE_PACKED, packUvComponent(Math.sqrt(miter2 * miter2 - 1)), polylineLength, 1, FLOAT_MAX);
        const baseIndex = this._baseIndex;
        this.writeIndices([
            baseIndex - 3,
            baseIndex - 1,
            baseIndex,
            baseIndex,
            lastDirection === -1 /* LEFT */ ? baseIndex - 3 : baseIndex - 1,
            baseIndex + 1,
            baseIndex,
            baseIndex + 1,
            baseIndex + 2,
            baseIndex,
            baseIndex + 2,
            baseIndex + 3,
            baseIndex,
            baseIndex + 3,
            lastDirection === -1 /* LEFT */ ? baseIndex + 4 : baseIndex + 6,
            baseIndex,
            baseIndex + 4,
            baseIndex + 6
        ]);
        this._baseIndex += 4;
    }
    _writeLastSegment(start, end) {
        const displacement = this._displacement;
        const lastDirection = this._lastDirection;
        const polylineLength = this._polylineLength;
        const miter = this._lastSignedMiter;
        this._writeVertex(start, displacement, UV_POS_ONE_PACKED, UV_ZERO_PACKED, polylineLength, lastDirection === -1 /* LEFT */ && (this._join !== 0 /* MITER */ || Math.abs(miter) > MITER_LIMIT) ?
            1 :
            miter, lastDirection === -1 /* LEFT */ ? -FLOAT_MAX : this._segmentLength);
        this._writeVertex(end, displacement, UV_POS_ONE_PACKED, UV_ZERO_PACKED, polylineLength + this._segmentLength, 1, FLOAT_MAX);
        __WEBPACK_IMPORTED_MODULE_0__math_vector2__["n" /* invert */](displacement, displacement);
        this._writeVertex(start, displacement, UV_NEG_ONE_PACKED, UV_ZERO_PACKED, polylineLength, lastDirection === 1 /* RIGHT */ && (this._join !== 0 /* MITER */ || Math.abs(miter) > MITER_LIMIT) ?
            1 :
            miter, lastDirection === 1 /* RIGHT */ ? -FLOAT_MAX : this._segmentLength);
        this._writeVertex(end, displacement, UV_NEG_ONE_PACKED, UV_ZERO_PACKED, polylineLength + this._segmentLength, 1, FLOAT_MAX);
        this.writeIndicesForContinuousStrip(SEGMENT_VERTEX_COUNT, this._baseIndex);
        this._baseIndex += SEGMENT_VERTEX_COUNT;
    }
}
/* unused harmony export default */



/***/ }),
/* 138 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\n#ifndef FILTER_RADIUS\n#   error FILTER_RADIUS must be set\n#endif\n\n#ifndef MAX_HALF_WIDTH\n#   error MAX_HALF_WIDTH must be set\n#endif\n\n#ifndef MAX_FILL_GAP\n#   error MAX_FILL_GAP must be set\n#endif\n\nattribute vec4 vertexPos;\nattribute vec2 vertexNormalPacked;\nattribute vec2 vertexUvPacked;\nattribute vec3 vertexWidthFillGap;\nattribute vec4 vertexColor;\nattribute float vertexMiter;\nattribute float vertexVLimit;\nattribute float vertexLength;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\nuniform float worldToPxFactor;\n\nvarying vec2 uv;\nvarying float len;\nvarying float halfWidth;\nvarying vec3 dash;\nvarying vec4 color;\n\nconst float YV_H = 1.999969482421875;\nconst float YV_L = 0.000030517112463712692;\nconst vec4 YV_HHLL = vec4(YV_H, YV_H, YV_L, YV_L);\n\nconst float SQRT2 = 1.4142135381698608;\n\nvec2 unpackUv(const in vec2 uv) {\n    return (uv - 128.) / 127.;\n}\n\nvoid main(void) {\n    vec2 normal = (2.0 * vertexNormalPacked - 1.0) * SQRT2;\n\n    halfWidth = float(MAX_HALF_WIDTH) * vertexWidthFillGap.x;\n    halfWidth += FILTER_RADIUS;\n\n    float tangentLength = min(\n        sqrt(vertexMiter * vertexMiter - 1.) * halfWidth * worldToPxFactor,\n        abs(vertexVLimit)\n    );\n\n    vec4 lookAt = vec4(lookAtHigh, lookAtLow);\n    vec4 relativeToEyePosition = YV_HHLL * (vertexPos - lookAt);\n\n    gl_Position = viewProjMatrix * vec4(\n        relativeToEyePosition.xy + relativeToEyePosition.zw +\n                worldToPxFactor * halfWidth * normal -\n                    sign(vertexMiter) * tangentLength * vec2(normal.y, -normal.x),\n        0,\n        1\n    );\n\n    uv = unpackUv(vertexUvPacked) * halfWidth;\n    len = (vertexLength + sign(vertexVLimit) * tangentLength) / worldToPxFactor;\n\n    dash.xy = vec2(MAX_FILL_GAP) * vertexWidthFillGap.yz;\n    dash.z = dash.x + dash.y;\n\n    color = vertexColor;\n    color.rgb *= color.a;\n}\n"

/***/ }),
/* 139 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\n#ifndef FILTER_RADIUS\n#   error FILTER_RADIUS must be set\n#endif\n\nvarying highp vec2 uv;\nvarying highp float len;\nvarying highp float halfWidth;\nvarying lowp vec3 dash;\nvarying lowp vec4 color;\n\nvoid main(void) {\n    lowp float alpha =\n        smoothstep(0.0, FILTER_RADIUS + min(FILTER_RADIUS, halfWidth), halfWidth - length(uv));\n\n    if (dash.z > 0.0) {\n        lowp vec3 halfDash = dash * 0.5;\n        lowp float dashPhase = mod(len + halfDash.y, dash.z);\n        lowp float r = min(FILTER_RADIUS, halfDash.y);\n\n        alpha *= smoothstep(-r, r, halfDash.x - abs(dashPhase - halfDash.z));\n    }\n\n    gl_FragColor = color * alpha;\n}\n"

/***/ }),
/* 140 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_textured_polygon_vert__ = __webpack_require__(141);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shader_textured_polygon_vert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__shader_textured_polygon_vert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_textured_polygon_frag__ = __webpack_require__(142);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shader_textured_polygon_frag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__shader_textured_polygon_frag__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math_vector2__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__render_state__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__world_primitive_render_unit__ = __webpack_require__(5);






const RENDER_STATE = new __WEBPACK_IMPORTED_MODULE_3__render_state__["c" /* default */](__WEBPACK_IMPORTED_MODULE_3__render_state__["b" /* BLEND_OVER_RENDER_STATE */], {
    depthTest: true,
    depthMask: false,
    depthFunc: 518 /* GREATER_OR_EQUAL */
});
/**
 * Renderer of polyline primitives.
 */
class TexturedPolygonRenderUnit extends __WEBPACK_IMPORTED_MODULE_4__world_primitive_render_unit__["a" /* default */] {
    constructor(context, primitiveProvider) {
        const program = context.createProgram(__WEBPACK_IMPORTED_MODULE_0__shader_textured_polygon_vert___default.a, __WEBPACK_IMPORTED_MODULE_1__shader_textured_polygon_frag___default.a, {
            attribMap: {
                vertexPosHigh: 0 /* POSITION_HIGH */,
                vertexPosLow: 1 /* POSITION_LOW */,
                vertexUV: 4 /* UV */,
                vertexImageScale: 11 /* AUX */,
                vertexZIndex: 10 /* Z_INDEX */
            }
        });
        super(context, RENDER_STATE, program, primitiveProvider);
        this._atlasSizeUniform = __WEBPACK_IMPORTED_MODULE_2__math_vector2__["f" /* create */](0, 0);
        context.bindProgram(program);
        program.setIntScalarUniform('atlas', 0);
    }
    _renderBatch(memoryBatch) {
        const atlas = memoryBatch.firstPrimitive.atlas;
        this._atlasSizeUniform.x = atlas.width;
        this._atlasSizeUniform.y = atlas.height;
        if (atlas.isDirty) {
            atlas.syncTexture();
        }
        this._program.setVector2Uniform('atlasSize', this._atlasSizeUniform);
        this._context.bindTextureUnit(0);
        this._context.bindTexture(atlas.texture);
        super._renderBatch(memoryBatch);
    }
    _canBatchAdjacentPrimitives(a, b) {
        return super._canBatchAdjacentPrimitives(a, b) && (a.atlas === b.atlas);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = TexturedPolygonRenderUnit;



/***/ }),
/* 141 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec2 vertexPosHigh;\nattribute vec2 vertexPosLow;\nattribute vec4 vertexUV;\nattribute float vertexImageScale;\nattribute float vertexZIndex;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\n\nvarying vec2 uvPosition;\nvarying vec2 textureSize;\nvarying vec2 uvDisplacement;\n\nconst float YV_H = 1.999969482421875;\nconst float YV_L = 0.000030517112463712692;\n\nvoid main(void) {\n    uvPosition = vertexUV.xy;\n    textureSize = vertexUV.zw;\n\n    // The same pattern image should match across multiple (usually adjacent) polygons and it should have\n    // stable position realtive to the polygon. Also pattern is repeated at both directions.\n    // To meet these requirements the world is covered (virtually) by a texture of appropriate size (repeated image)\n    // and vertex coordinates are mapped to these texture coordinates (uvDisplacement).\n    // But due to limited precision we've got to work with \"narrow\" floats (as it is done in world position calculation):\n    //   1. calculate how big texture pattern in world coordinates (scaledTextureSize)\n    //   2. find the closest to eye coordinates texture base point (the bottom left point of the pattern)\n    //   3. use vertex position and textureBasePoint vectors to find coordinates in virtual texture\n    //   4. find uv coordinates in real texture using mod operation\n    //\n    // Both textureBasePoint and position are relativelly small vectors so that precision requirements are met,\n    // and correct interpolation of repeated image is possible by using single base point in all vertices.\n\n    vec2 scaledTextureSize = textureSize * vertexImageScale; // texture size in world coordinates\n    vec2 textureBasePoint = mod(YV_H * lookAtHigh, scaledTextureSize) + mod(YV_L * lookAtLow, scaledTextureSize);\n    vec2 position = YV_H * (vertexPosHigh - lookAtHigh) + YV_L * (vertexPosLow - lookAtLow);\n\n    gl_Position = viewProjMatrix * vec4(position, 0, 1);\n    gl_Position.xy /= gl_Position.w;\n    gl_Position.z = vertexZIndex;\n    gl_Position.w = 1.0;\n\n    // convert world coordinates back to teture pixels\n    uvDisplacement = (position + textureBasePoint) / vertexImageScale;\n}\n"

/***/ }),
/* 142 */
/***/ (function(module, exports) {

module.exports = "#version 100\n\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform sampler2D atlas;\nuniform vec2 atlasSize;\n\nvarying vec2 uvPosition;\nvarying vec2 textureSize;\nvarying vec2 uvDisplacement;\n\nvoid main(void) {\n    vec2 uvAdjusted = vec2(\n        uvPosition.x + mod(uvDisplacement.x, textureSize.x),\n        uvPosition.y + mod(uvDisplacement.y, textureSize.y)\n    );\n\n    gl_FragColor = texture2D(atlas, uvAdjusted / atlasSize);\n}\n"

/***/ }),
/* 143 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polygon_render_unit__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__render_state__ = __webpack_require__(0);




/**
 * Renderer of transparent polygon primitives.
 */
class TransparentPolygonRenderUnit extends __WEBPACK_IMPORTED_MODULE_0__polygon_render_unit__["b" /* default */] {
    constructor(context, primitiveProvider) {
        super(context, primitiveProvider, new __WEBPACK_IMPORTED_MODULE_1__render_state__["c" /* default */](__WEBPACK_IMPORTED_MODULE_0__polygon_render_unit__["a" /* DEFAULT_RENDER_STATE_PARAMS */], { depthMask: false }, __WEBPACK_IMPORTED_MODULE_1__render_state__["b" /* BLEND_OVER_RENDER_STATE */]));
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = TransparentPolygonRenderUnit;



/***/ }),
/* 144 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec2 vertexPosHigh;\nattribute vec2 vertexPosLow;\nattribute vec4 vertexColor;\nattribute float vertexZIndex;\n\nuniform vec2 lookAtHigh;\nuniform vec2 lookAtLow;\nuniform mat4 viewProjMatrix;\n\nvarying vec4 color;\n\nconst float YV_H = 1.999969482421875;\nconst float YV_L = 0.000030517112463712692;\n\nvoid main(void) {\n    vec4 position = viewProjMatrix * vec4(\n        YV_H * (vertexPosHigh - lookAtHigh) +\n            YV_L * (vertexPosLow - lookAtLow),\n        0,\n        1\n    );\n\n    position.xy /= position.w;\n    position.z = vertexZIndex;\n    position.w = 1.0;\n\n    gl_Position = position;\n\n    color = vertexColor;\n}\n"

/***/ }),
/* 145 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nvarying lowp vec4 color;\n\nvoid main(void) {\n    gl_FragColor = color;\n}\n"

/***/ }),
/* 146 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__engine__ = __webpack_require__(147);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__render_fxaa_render_unit__ = __webpack_require__(177);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__render_background_render_unit__ = __webpack_require__(179);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__render_layer_render_unit__ = __webpack_require__(181);




/**
 * Ground layer with background that goes right after sub render units. It allows to add other LayerRenderUnits above
 * groundLayer without worrying that they destroy depth information collected on ground and broke background (that has
 * a performance optimisation: it uses depth information from the layers below to prevent extensive pixel overwriting).
 */
class BackgroundedGroundLayer extends __WEBPACK_IMPORTED_MODULE_3__render_layer_render_unit__["a" /* default */] {
    constructor(context, depthClearStrategy = 0 /* NO_CLEAR */) {
        super(context, depthClearStrategy);
        this._background = new __WEBPACK_IMPORTED_MODULE_2__render_background_render_unit__["a" /* default */](context);
    }
    render(target, ...args) {
        super.render(target, ...args);
        this._background.render(target);
    }
}
class MapEngine extends __WEBPACK_IMPORTED_MODULE_0__engine__["a" /* default */] {
    constructor(context, camera, renderLoop) {
        super(context, camera, renderLoop);
        this._destroyables = [];
        const antialiasingLayer = new __WEBPACK_IMPORTED_MODULE_1__render_fxaa_render_unit__["a" /* default */](context, this.renderLoop);
        this.backgoundLayer = new __WEBPACK_IMPORTED_MODULE_3__render_layer_render_unit__["a" /* default */](context);
        this.groundLayer = new BackgroundedGroundLayer(context);
        this.buildingsLayer = new __WEBPACK_IMPORTED_MODULE_3__render_layer_render_unit__["a" /* default */](context);
        this.iconsLayer = new __WEBPACK_IMPORTED_MODULE_3__render_layer_render_unit__["a" /* default */](context);
        this.labelsLayer = new __WEBPACK_IMPORTED_MODULE_3__render_layer_render_unit__["a" /* default */](context);
        antialiasingLayer.addRenderUnit(this.buildingsLayer);
        this.renderer.addRenderUnit(this.backgoundLayer);
        this.renderer.addRenderUnit(this.groundLayer);
        this.renderer.addRenderUnit(antialiasingLayer);
        this.renderer.addRenderUnit(this.iconsLayer);
        this.renderer.addRenderUnit(this.labelsLayer);
        this._destroyables.push(antialiasingLayer);
        // force initial rendering (no data yet, just background) as the canvas (black) can already be visible to users,
        // renderer is called directly (without scheduling via render loop) as it is pretty much safe to assume
        // that no rendering is scheduled for this frame, and deferred update can potentially cause a single frame blink
        this.renderer.render(this._renderTarget);
    }
    destroy() {
        // destroy in reverse order to prevent potential issues if destroyables own each other
        for (let i = this._destroyables.length - 1; i >= 0; i--) {
            this._destroyables[i].destroy();
        }
        super.destroy();
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = MapEngine;



/***/ }),
/* 147 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_event_emitter__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__render_font_renderable_df_glyph_atlas__ = __webpack_require__(148);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__font_df_font_registry__ = __webpack_require__(150);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__render_billboard_renderable_image_atlas__ = __webpack_require__(152);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__visibility_visibility_manager__ = __webpack_require__(157);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__util_median_filter__ = __webpack_require__(172);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__util_stat__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__render_main_render_unit__ = __webpack_require__(173);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__render_memory_manager__ = __webpack_require__(174);









class Engine {
    constructor(context, camera, renderLoop) {
        this.context = context;
        this._camera = camera;
        this._renderTarget = context.getDefaultRenderTarget();
        this.renderer = new __WEBPACK_IMPORTED_MODULE_7__render_main_render_unit__["a" /* default */](context, camera);
        this.renderLoop = renderLoop;
        this.memoryManager = new __WEBPACK_IMPORTED_MODULE_8__render_memory_manager__["a" /* default */](context);
        this._atlases = new Set();
        this.visibilityManager = new __WEBPACK_IMPORTED_MODULE_4__visibility_visibility_manager__["a" /* default */](context, camera, renderLoop, this._renderTarget.getWidth(), this._renderTarget.getHeight());
        this.visbilityTextureProvider = () => {
            this.visibilityManager.updateVisibilityIfNeeded();
            return this.visibilityManager.visibilityTexture;
        };
        this._frameTimingsListener = this._onFrameTimesFull.bind(this);
        renderLoop.onFrameTimesFull.addListener(this._frameTimingsListener);
        this._renderListener = this._onRender.bind(this);
        renderLoop.onRender.addListener(this._renderListener);
        this._updateListener = () => this.renderLoop.update();
        this.glyphAtlas = new __WEBPACK_IMPORTED_MODULE_1__render_font_renderable_df_glyph_atlas__["a" /* default */](context);
        this.fontRegistry = new __WEBPACK_IMPORTED_MODULE_2__font_df_font_registry__["a" /* default */]();
        this.onInternalError = new __WEBPACK_IMPORTED_MODULE_0__util_event_emitter__["b" /* VoidEventEmitter */]();
        this._camera.onUpdate.addListener(this._updateListener);
        this.renderer.onUpdate.addListener(this._updateListener);
        this._contextLostListener = () => this.onInternalError.fire();
        this.context.onLoss.addListener(this._contextLostListener);
    }
    setRenderTargetSize(width, height) {
        if (this._renderTarget.getWidth() !== width ||
            this._renderTarget.getHeight() !== height) {
            this._renderTarget.setSize(width, height);
            this.visibilityManager.setTargetSize(width, height);
        }
    }
    createImageAtlas(params) {
        const atlas = new __WEBPACK_IMPORTED_MODULE_3__render_billboard_renderable_image_atlas__["a" /* default */](this.context, params);
        atlas.onContentUpdate.addListener(this._updateListener);
        this._atlases.add(atlas);
        return atlas;
    }
    removeImageAtlas(atlas) {
        atlas.destroy();
        atlas.onContentUpdate.removeListener(this._updateListener);
        this._atlases.delete(atlas);
    }
    getCamera() {
        return this._camera;
    }
    destroy() {
        this._camera.onUpdate.removeListener(this._updateListener);
        this.renderer.onUpdate.removeListener(this._updateListener);
        for (const atlas of this._atlases) {
            atlas.onContentUpdate.removeListener(this._updateListener);
            atlas.destroy();
        }
        this.glyphAtlas.destroy();
        this.context.onLoss.removeListener(this._contextLostListener);
    }
    _onRender() {
        this.renderer.render(this._renderTarget);
    }
    _onFrameTimesFull(times) {
        Object(__WEBPACK_IMPORTED_MODULE_6__util_stat__["a" /* countFps */])(1e3 * times.length / Object(__WEBPACK_IMPORTED_MODULE_5__util_median_filter__["a" /* medianFilter */])(times).reduce((sum, time) => sum + time));
        // For now we acquire frame timing and log them only once a session.
        this.renderLoop.onFrameTimesFull.removeListener(this._frameTimingsListener);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Engine;



/***/ }),
/* 148 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__font_df_glyph_atlas__ = __webpack_require__(149);

/**
 * Atlas that manages allocation in GL texture.
 */
class RenderableDfGlyphAtlas extends __WEBPACK_IMPORTED_MODULE_0__font_df_glyph_atlas__["a" /* default */] {
    constructor(context) {
        super(0, 0, new Uint8Array(0), new Map());
        this._context = context;
        this.texture = this._createTexture(0, 0);
    }
    destroy() {
        this.texture.destroy();
    }
    /**
     * Updates the whole content of the glyph bitmap atlas, texture also get updated.
     *
     * @param width new bitmap width
     * @param height new bitmap height
     * @param data, length should be strictly equal to width * height
     */
    updateContent(width, height, data, glyphLocations) {
        this.width = width;
        this.height = height;
        this.data = data;
        this._glyphLocations = glyphLocations;
        const texture = this.texture;
        if (!texture || texture.getWidth() !== width || texture.getHeight() !== height) {
            if (this.texture) {
                this.texture.destroy();
            }
            this.texture = this._createTexture(width, height);
        }
        this._context.setTextureData(this.texture, data);
    }
    _createTexture(width, height) {
        return this._context.createEmpty2DTexture(width, height, 6406 /* ALPHA */, 5121 /* UNSIGNED_BYTE */, {
            wrapS: 33071 /* CLAMP_TO_EDGE */,
            wrapT: 33071 /* CLAMP_TO_EDGE */,
            magnificationFilter: 9729 /* LINEAR */,
            minificationFilter: 9729 /* LINEAR */,
            premultipliedAlpha: false
        });
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RenderableDfGlyphAtlas;



/***/ }),
/* 149 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
const UNKNOWN_GLYPH_LOCATION = {
    minX: 0,
    maxX: 0,
    minY: 0,
    maxY: 0
};
/**
 * Abstract glyph atlas interface.
 */
class DfGlyphAtlas {
    constructor(width, height, data, glyphLocations) {
        this.width = width;
        this.height = height;
        this.data = data;
        this._glyphLocations = glyphLocations;
    }
    /**
     * @return Glyph location or fake location pointing to the origin (0, 0).
     */
    getGlyphLocation(fontId, glyphId) {
        const glyphLocation = this._glyphLocations.get(fontId + glyphId);
        if (glyphLocation) {
            return glyphLocation;
        }
        else {
            console.warn('Wow-wow-wow, something went wrong, you should not request nonexistent glyph locations');
            return UNKNOWN_GLYPH_LOCATION;
        }
    }
    /**
     * @return All glyph locations as [glyph id, glyph location] array. Glyph id is font id concatenated with glyph id.
     */
    getAllGlyphLocations() {
        return [...this._glyphLocations.entries()];
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = DfGlyphAtlas;



/***/ }),
/* 150 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__font_registry__ = __webpack_require__(151);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__df_font__ = __webpack_require__(28);


/**
 * Registry that stores distance field fonts.
 */
class DfFontRegistry extends __WEBPACK_IMPORTED_MODULE_0__font_registry__["a" /* default */] {
    constructor() {
        super(new __WEBPACK_IMPORTED_MODULE_1__df_font__["a" /* default */]('UNKNOWN_DF_FONT', 14, 0));
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = DfFontRegistry;



/***/ }),
/* 151 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * A central storage of all available fonts.
 */
class FontRegistry {
    /**
     * @param unknownFontInstance An instance of specific font type to be served as a stub when nonexistent font
     *     is requested. Requesting nonexistent fonts normally should not happen.
     *     The stub just allows to avoid tedious null checks in registry clients.
     */
    constructor(unknownFontInstance) {
        this._fonts = new Map();
        this._unknownFontInstance = unknownFontInstance;
    }
    /**
     * @return If a font with specified id is in the registry.
     */
    contains(fontId) {
        return this._fonts.has(fontId);
    }
    /**
     * @return Font with specified id or unknown font instance if it is not found.
     */
    get(fontId) {
        const font = this._fonts.get(fontId);
        if (font) {
            return font;
        }
        else {
            console.warn('Wow-wow-wow, something went wrong, you should not request nonexistent fonts');
            return this._unknownFontInstance;
        }
    }
    /**
     * @return All stored fonts.
     */
    getAll() {
        return [...this._fonts.values()];
    }
    /**
     * Adds new for to the registry.
     */
    add(font) {
        this._fonts.set(font.id, font);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = FontRegistry;



/***/ }),
/* 152 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__billboard_image_atlas__ = __webpack_require__(153);

/**
 * Atlas that manages allocation in GL texture.
 */
class RenderableImageAtlas extends __WEBPACK_IMPORTED_MODULE_0__billboard_image_atlas__["a" /* default */] {
    constructor(context, params) {
        super();
        const { filter, premultipliedAlpha } = params;
        this._context = context;
        this._filter = filter;
        this._premultipliedAlpha = premultipliedAlpha;
        this.texture = this._createTexture(this.width, this.height, filter, premultipliedAlpha);
        this.isDirty = false;
    }
    /**
     * Updates GL texture with changed data. Should be called after each image added to take effect in shaders.
     */
    syncTexture() {
        this._context.setTextureDataFromDomElement(this.texture, this.canvas);
        this.isDirty = false;
    }
    updateImage(location, sourceImage, locationRegion, sourceImageRegion) {
        super.updateImage(location, sourceImage, locationRegion, sourceImageRegion);
        this.isDirty = true;
    }
    destroy() {
        this.texture.destroy();
    }
    _expand(newWidth, newHeight) {
        super._expand(newWidth, newHeight);
        this.texture.destroy();
        this.texture = this._createTexture(this.width, this.height, this._filter, this._premultipliedAlpha);
        this.isDirty = true;
    }
    _createTexture(width, height, filter, premultipliedAlpha) {
        return this._context.createEmpty2DTexture(width, height, 6408 /* RGBA */, 5121 /* UNSIGNED_BYTE */, {
            minificationFilter: filter,
            magnificationFilter: filter,
            wrapS: 33071 /* CLAMP_TO_EDGE */,
            wrapT: 33071 /* CLAMP_TO_EDGE */,
            premultipliedAlpha
        });
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RenderableImageAtlas;



/***/ }),
/* 153 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_vector2__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_allocator_2d__ = __webpack_require__(154);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_event_emitter__ = __webpack_require__(2);



const INIT_ATLAS_WIDTH = 256;
const INIT_ATLAS_HEIGHT = 256;
const MAX_ATLAS_WIDTH = 2048;
const MAX_ATLAS_HEIGHT = 2048;
const EXPAND_FACTOR = 2;
/**
 * Manages allocation of images. It resizes itself (up to a fixed limit) when there is no region
 * of enough size for the next image.
 */
class ImageAtlas {
    constructor(initAtlasWidth = INIT_ATLAS_WIDTH, initAtlasHeight = INIT_ATLAS_HEIGHT) {
        this.onContentUpdate = new __WEBPACK_IMPORTED_MODULE_2__util_event_emitter__["b" /* VoidEventEmitter */]();
        this.canvas = document.createElement('canvas');
        this.canvas.width = initAtlasWidth;
        this.canvas.height = initAtlasHeight;
        this._canvasContext = this.canvas.getContext('2d');
        this._allocator = new __WEBPACK_IMPORTED_MODULE_1__util_allocator_2d__["a" /* ShelfAllocator2D */](this.width, this.height);
    }
    get width() {
        return this.canvas.width;
    }
    get height() {
        return this.canvas.height;
    }
    /**
     * Allocates image bitmap.
     */
    allocateImage(descriptor, image) {
        const location = this._allocate(descriptor);
        if (location) {
            const region = Object(__WEBPACK_IMPORTED_MODULE_0__math_vector2__["g" /* createBBox2 */])(0, descriptor.width, 0, descriptor.height);
            this.updateImage(location, image, region, region);
        }
        return location;
    }
    /**
     * Reserves space of appropriate size that can be updated later with updateImage() method.
     */
    reserveLocation(descriptor) {
        return this._allocate(descriptor);
    }
    /**
     * Updates image content in appropriate location. Assumes that there is really such location reserved,
     * no check for this is done.
     *
     * @param location Location in atlas of the image.
     * @param sourceImage Image to update atlas from.
     * @param locationRegion Region (bbox with coordinates relative to the location's bbox) of the location to update.
     * @param sourceImageRegion Region of the image (BBox2 in image's coordinate space) to be copied into atlas.
     */
    updateImage(location, sourceImage, locationRegion = Object(__WEBPACK_IMPORTED_MODULE_0__math_vector2__["g" /* createBBox2 */])(0, location.maxX - location.minX, 0, location.maxY - location.minY), sourceImageRegion = Object(__WEBPACK_IMPORTED_MODULE_0__math_vector2__["g" /* createBBox2 */])(0, sourceImage.width, 0, sourceImage.height)) {
        const srcX = sourceImageRegion.minX;
        const srcY = sourceImageRegion.minY;
        const srcW = sourceImageRegion.maxX - sourceImageRegion.minX;
        const srcH = sourceImageRegion.maxY - sourceImageRegion.minY;
        const dstX = location.minX + locationRegion.minX;
        const dstY = location.minY + locationRegion.minY;
        const dstW = locationRegion.maxX - locationRegion.minX;
        const dstH = locationRegion.maxY - locationRegion.minY;
        this._canvasContext.clearRect(dstX, dstY, dstW, dstH);
        this._canvasContext.drawImage(sourceImage, srcX, srcY, srcW, srcH, dstX, dstY, dstW, dstH);
        this.onContentUpdate.fire();
    }
    /**
     * Deallocates image from the atlas.
     */
    removeImage(image) {
        this._allocator.deallocate(image);
    }
    _allocate(descriptor) {
        let location = this._allocator.allocate(descriptor);
        // incremental expand can be inefficient if two or more iterations are needed to allocate an image,
        // but it is expected to be a rare (if any) case, rework if it turns out to be wrong
        while (!location) {
            const expandedWidth = this.width * EXPAND_FACTOR;
            const expandedHeight = this.height * EXPAND_FACTOR;
            if (expandedWidth <= MAX_ATLAS_WIDTH && expandedHeight <= MAX_ATLAS_HEIGHT) {
                this._expand(expandedWidth, expandedHeight);
                location = this._allocator.allocate(descriptor);
            }
            else {
                break;
            }
        }
        return location;
    }
    _expand(newWidth, newHeight) {
        this._allocator.resize(newWidth, newHeight);
        // setting new width/height to canvas will clear it,
        // so current data is saved to be restored immediately after resizing
        const data = this._canvasContext.getImageData(0, 0, this.width, this.height);
        this.canvas.width = newWidth;
        this.canvas.height = newHeight;
        this._canvasContext.putImageData(data, 0, 0);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ImageAtlas;



/***/ }),
/* 154 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__allocator__ = __webpack_require__(50);

/**
 * A rectangular region with fixed height. Utility class for shelf allocation defined below.
 */
class Shelf {
    constructor(width, height) {
        this.width = width;
        this.height = height;
        this._allocator = new __WEBPACK_IMPORTED_MODULE_0__allocator__["b" /* FreeListAllocator */](this.width);
    }
    allocate(width) {
        return this._allocator.allocate(width);
    }
    deallocate(offset) {
        this._allocator.deallocate(offset);
    }
    isAllocated(offset) {
        return this._allocator.isAllocated(offset);
    }
    canAllocate(width) {
        return this._allocator.maxAllocableSize >= width;
    }
    resize(width) {
        this._allocator.extend(width);
        this.width = width;
    }
}
/**
 * Allocates rectangles in "shelves" (height fixed regions). They are created of necessity when the next object doesnt
 * fit any existing shelf. To optimize space usage it tries to find the best shelf for allocation (min height diff).
 * A shelf when allocated is never deallocated back and exists during all the allocator lifetime.
 */
class ShelfAllocator2D {
    constructor(width, height) {
        this.width = width;
        this.height = height;
        this._shelves = new Map();
        this._shelfAllocator = new __WEBPACK_IMPORTED_MODULE_0__allocator__["a" /* ArenaAllocator */](height); // no shelf deallocation, that is why ArenaAllocator is fine
    }
    allocate(object) {
        let bestShelf;
        let bestShelfOffset = -1;
        let bestShelfRatio = -1;
        for (const [offset, shelf] of this._shelves.entries()) {
            const shelfRatio = object.height / shelf.height;
            if (shelfRatio === 1 && shelf.canAllocate(object.width)) {
                bestShelf = shelf;
                bestShelfOffset = offset;
                break;
            }
            else if (shelfRatio < 1 && shelfRatio > bestShelfRatio && shelf.canAllocate(object.width)) {
                bestShelf = shelf;
                bestShelfOffset = offset;
                bestShelfRatio = shelfRatio;
            }
        }
        if (!bestShelf && this._shelfAllocator.maxAllocableSize >= object.height && this.width >= object.width) {
            const offset = this._shelfAllocator.allocate(object.height);
            bestShelf = new Shelf(this.width, object.height);
            bestShelfOffset = offset;
            this._shelves.set(offset, bestShelf);
        }
        if (bestShelf) {
            const left = bestShelf.allocate(object.width);
            const top = bestShelfOffset;
            const location = {
                minX: left,
                maxX: left + object.width,
                minY: top,
                maxY: top + object.height
            };
            return location;
        }
        else {
            return null;
        }
    }
    deallocate(objectLocation) {
        const shelf = this._shelves.get(objectLocation.minY);
        if (shelf) {
            shelf.deallocate(objectLocation.minX);
        }
    }
    isAllocated(objectLocation) {
        const shelf = this._shelves.get(objectLocation.minY);
        return !!shelf && shelf.isAllocated(objectLocation.minX);
    }
    resize(width, height) {
        this._shelfAllocator.extend(height);
        for (const shelf of this._shelves.values()) {
            shelf.resize(width);
        }
        this.width = width;
        this.height = height;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ShelfAllocator2D;



/***/ }),
/* 155 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Simple implementation of Binary Search Tree.
 */
class BinarySearchTree {
    /**
     * @param comparator To specify the order of items, that can be any complex objects.
     */
    constructor(comparator) {
        this._comparator = comparator;
        this._size = 0;
    }
    /**
     * @returns The root element or `undefined` if the tree is empty.
     */
    get root() {
        return this._root;
    }
    /**
     * @returns The number of items in the tree.
     */
    get size() {
        return this._size;
    }
    /**
     * @returns The smallest element in the tree or `undefined` the the tree is empty.
     */
    get min() {
        if (this._root) {
            return this._min(this._root).value;
        }
        return undefined;
    }
    /**
     * @returns The biggest element in the tree or `undefined` the the tree is empty.
     */
    get max() {
        if (this._root) {
            return this._max(this._root).value;
        }
        return undefined;
    }
    insert(item) {
        this._size++;
        if (!this._root) {
            this._root = { value: item };
            return this._root;
        }
        let node = this._root;
        while (node) {
            if (this._comparator(item, node.value) < 0) {
                if (!node.left) {
                    return node.left = { parent: node, value: item };
                }
                node = node.left;
            }
            else {
                if (!node.right) {
                    return node.right = { parent: node, value: item };
                }
                node = node.right;
            }
        }
        // impossible to get there, throwing is to make TS analizator happy
        throw new Error();
    }
    remove(node) {
        this._size--;
        if (node.left && node.right) {
            const successor = this._min(node.right);
            this._replaceSubtree(node, successor);
            // update links to children of the removed node
            if (node.left) {
                successor.left = node.left;
                node.left.parent = successor;
            }
            if (node.right) {
                successor.right = node.right;
                node.right.parent = successor;
            }
        }
        else if (node.left) {
            this._replaceSubtree(node, node.left);
        }
        else if (node.right) {
            this._replaceSubtree(node, node.right);
        }
        else {
            this._replaceSubtree(node, undefined);
        }
    }
    /**
     * Iterates elements in ascending order.
     */
    *values(node) {
        if (node) {
            yield* this.values(node.left);
            yield node.value;
            yield* this.values(node.right);
        }
    }
    /**
     * Iterates elements in ascending order.
     */
    [Symbol.iterator]() {
        return this.values(this._root);
    }
    _min(from) {
        let node = from;
        while (node.left) {
            node = node.left;
        }
        return node;
    }
    _max(from) {
        let node = from;
        while (node.right) {
            node = node.right;
        }
        return node;
    }
    /**
     * Reorganizes the tree structure so that the replacement node takes replaceable's position, the latter is removed.
     */
    _replaceSubtree(replaceable, replacement) {
        if (replaceable.parent) {
            if (replaceable.parent.left === replaceable) {
                replaceable.parent.left = replacement;
            }
            else if (replaceable.parent.right === replaceable) {
                replaceable.parent.right = replacement;
            }
        }
        else {
            this._root = replacement;
        }
        if (replacement) {
            // remove replacement from its current location
            if (replacement.parent) {
                if (replacement.parent.left === replacement) {
                    replacement.parent.left = undefined;
                }
                else if (replacement.parent.right === replacement) {
                    replacement.parent.right = undefined;
                }
            }
            replacement.parent = replaceable.parent;
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = BinarySearchTree;



/***/ }),
/* 156 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Set with predictable iteration order. Stores items as a two way linked list thus allowing to insert items in between.
 */
class LinkedSet {
    constructor() {
        this._nodes = new Map();
    }
    get begin() {
        return this._begin && this._begin.value;
    }
    get end() {
        return this._end && this._end.value;
    }
    /**
     * Inserts a new item at the end of the set.
     */
    insert(item) {
        if (!this._nodes.has(item)) {
            const node = { value: item };
            if (this._end) {
                this.insertAfter(this._end.value, item);
            }
            else {
                this._begin = this._end = node;
                this._nodes.set(item, node);
            }
        }
    }
    /**
     * Inserts a new item before the specified one. If the before item is not in the set or
     * the item is already inserted nothing happens.
     */
    insertBefore(before, item) {
        const beforeNode = this._nodes.get(before);
        if (beforeNode && !this._nodes.has(item)) {
            const node = { value: item };
            if (beforeNode.prev) {
                beforeNode.prev.next = node;
                node.prev = beforeNode.prev;
            }
            node.next = beforeNode;
            beforeNode.prev = node;
            this._nodes.set(item, node);
            if (beforeNode === this._begin) {
                this._begin = node;
            }
        }
    }
    /**
     * Inserts a new item after the specified one. If the after item is not in the set or
     * the item is already inserted nothing happens.
     */
    insertAfter(after, item) {
        const afterNode = this._nodes.get(after);
        if (afterNode && !this._nodes.has(item)) {
            const node = { value: item };
            if (afterNode.next) {
                afterNode.next.prev = node;
                node.next = afterNode.next;
            }
            node.prev = afterNode;
            afterNode.next = node;
            this._nodes.set(item, node);
            if (afterNode === this._end) {
                this._end = node;
            }
        }
    }
    /**
     * Removes item from the set.
     */
    remove(item) {
        const node = this._nodes.get(item);
        if (node) {
            if (node === this._begin) {
                this._begin = node.next;
            }
            if (node === this._end) {
                this._end = node.prev;
            }
            if (node.next) {
                node.next.prev = node.prev;
            }
            if (node.prev) {
                node.prev.next = node.next;
            }
            this._nodes.delete(item);
        }
    }
    /**
     * @returns `undefined` if the item is not in the set or it is the first elements.
     */
    getPrev(item) {
        const node = this._nodes.get(item);
        if (node && node.prev) {
            return node.prev.value;
        }
        return undefined;
    }
    /**
     * @returns `undefined` if the item is not in the set or it is the last elements.
     */
    getNext(item) {
        const node = this._nodes.get(item);
        if (node && node.next) {
            return node.next.value;
        }
        return undefined;
    }
    /**
     * Iterates over the set from the fist element to the last (in the order of insertion
     * if the insert method was used only).
     */
    *values() {
        let node = this._begin;
        while (node) {
            yield node.value;
            node = node.next;
        }
    }
    /**
     * Iterates over the set from the fist element to the last (in the order of insertion
     * if the insert method was used only).
     */
    [Symbol.iterator]() {
        return this.values();
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = LinkedSet;



/***/ }),
/* 157 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__render_state__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_color__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__math_vector2__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__math_vector3__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__math_matrix4__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__grid_sampler_buffer_writer__ = __webpack_require__(158);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__util_event_emitter__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__grid_renderer__ = __webpack_require__(159);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__visibility_resolution_steps_reset_removed_primitives__ = __webpack_require__(160);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__visibility_resolution_steps_fadeout_all__ = __webpack_require__(161);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__visibility_resolution_steps_fadein_visible__ = __webpack_require__(165);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__visibility_resolution_steps_fadeout_overlapped__ = __webpack_require__(168);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__render_util_camera_position__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__util_hd__ = __webpack_require__(10);














const FADING_STOPPED = -1;
const DEFAULT_FADE_EFFECT_DURATION = 150;
const ID_COMPONENT_SIZE = 256;
const VISIBILITY_INIT_STATE = new __WEBPACK_IMPORTED_MODULE_0__render_state__["c" /* default */]({
    clearColor: __WEBPACK_IMPORTED_MODULE_1__util_color__["c" /* create */](0, 0, 0, 0),
    dither: false
});
const EMPTY_GRID_CELL = __WEBPACK_IMPORTED_MODULE_1__util_color__["c" /* create */](0, 0, 0, 1);
const DIRECT_PRIORITY_GRID_STATE = new __WEBPACK_IMPORTED_MODULE_0__render_state__["c" /* default */]({
    clearColor: EMPTY_GRID_CELL,
    depthTest: true,
    clearDepth: 0,
    // primitives with equal priority are resolved as following: later ones overlap previous
    depthFunc: 518 /* GREATER_OR_EQUAL */,
    dither: false
});
const REVERSE_PRIORITY_GRID_STATE = new __WEBPACK_IMPORTED_MODULE_0__render_state__["c" /* default */]({
    clearColor: EMPTY_GRID_CELL,
    depthTest: true,
    clearDepth: 1,
    depthFunc: 513 /* LESS */,
    dither: false
});
// size of minimal recognizable square side in css pixels.
const GRID_PRECISION_PX = 6;
/**
 * Apart from being removed from scene there are other reasons for primitives to be invisible: e.g. they are
 * overlapped by primitives with higher priority. This state is highly dynamic, primitives may be of different types,
 * from different sources and they can have quite non-trivial shapes. So there should be a single point of collision
 * resolution for all primitives in scene, that is what visibility manager is.
 *
 * Visibility of primitives is calculated every frame. To support fade-in/out animation visibility value is a factor
 * the alpha channel of a finally rendered primitive is to be multiplied by (value from 0.0 to 1.0). For instance,
 * if an object is just appeared on the scene, this factor will be changed from 0.0 to 1.0 in fadeEffectDurationMs ms.
 * There are 4 steps the whole process can be roughly summarized into:
 *  1. actualization - reset values for removed from scene primitives
 *  2. fade-out all - even though all primitives are faded out at this step, this step is intended for invisible
 *     primitives to animate them disappearing.
 *  3. fade-in visible - check which primitive are visible and increase its alpha visibility value.
 *  4. fade-out overlapped - find overlaps by comparing corresponding pixels of the scene rendered in direct and
 *     reverse priority orders.
 *
 *  Due to the fact that we use grid with finite precision there are some cases where this approach produces
 *  unpleasant artifacts (blinking). To cope with it stability shift and storing zoom of the first overlap are
 *  introduced, but it works well for non-tilted map only.
 */
class VisibilityManager {
    constructor(context, camera, renderLoop, targetWidth, targetHeight, fadeEffectDuration = DEFAULT_FADE_EFFECT_DURATION) {
        this.onRerenderRequired = new __WEBPACK_IMPORTED_MODULE_6__util_event_emitter__["b" /* VoidEventEmitter */]();
        this.fadeEffectDuration = fadeEffectDuration;
        this._context = context;
        this._camera = camera;
        this._renderLoop = renderLoop;
        this._lastRenderTimeInLoop = FADING_STOPPED;
        this._prevTargetSize = { width: 0, height: 0 };
        this._sceneUpdateListener = this._onSceneUpdate.bind(this);
        this._camera.onUpdate.addListener(this._sceneUpdateListener);
        this._beforeRenderListener = this._onBeforeRender.bind(this);
        this._renderLoop.onBeforeRender.addListener(this._beforeRenderListener);
        this._directPriorityGridRenderer = new __WEBPACK_IMPORTED_MODULE_7__grid_renderer__["a" /* default */](context, DIRECT_PRIORITY_GRID_STATE);
        this._reversePriorityGridRenderer = new __WEBPACK_IMPORTED_MODULE_7__grid_renderer__["a" /* default */](context, REVERSE_PRIORITY_GRID_STATE);
        this._currentVisibilityTexture = context.createEmpty2DTexture(ID_COMPONENT_SIZE, ID_COMPONENT_SIZE, 6408 /* RGBA */, 5121 /* UNSIGNED_BYTE */);
        this._prevVisibilityTexture = context.createEmpty2DTexture(ID_COMPONENT_SIZE, ID_COMPONENT_SIZE, 6408 /* RGBA */, 5121 /* UNSIGNED_BYTE */);
        this._currentVisibilityBuffer = context.createFramebuffer({ color: this._currentVisibilityTexture });
        this._prevVisibilityBuffer = context.createFramebuffer({ color: this._prevVisibilityTexture });
        this._stabilityShift = __WEBPACK_IMPORTED_MODULE_3__math_vector3__["e" /* create */](0, 0, 0);
        this._gridHalfPxSizeUniform = __WEBPACK_IMPORTED_MODULE_2__math_vector2__["f" /* create */](0, 0);
        this._idHalfPxSizeUniform = __WEBPACK_IMPORTED_MODULE_2__math_vector2__["f" /* create */](0.5 / ID_COMPONENT_SIZE, 0.5 / ID_COMPONENT_SIZE);
        this._step1ResetRemoved = new __WEBPACK_IMPORTED_MODULE_8__visibility_resolution_steps_reset_removed_primitives__["a" /* default */]();
        this._step2FadeoutAll = new __WEBPACK_IMPORTED_MODULE_9__visibility_resolution_steps_fadeout_all__["a" /* default */](context);
        this._step3FadeinVisible = new __WEBPACK_IMPORTED_MODULE_10__visibility_resolution_steps_fadein_visible__["a" /* default */](context);
        this._step4FadeoutOverlapped = new __WEBPACK_IMPORTED_MODULE_11__visibility_resolution_steps_fadeout_overlapped__["a" /* default */](context);
        this._clearVisibility(this._currentVisibilityBuffer);
        this._primitiveProviders = [];
        this._colorIdRenderers = [];
        this._resetRemovedRenderers = [];
        this.setTargetSize(targetWidth, targetHeight);
    }
    get visibilityTexture() {
        return this._currentVisibilityTexture;
    }
    /**
     * To provide proper precision in collision resolution simplified grid size depends on the render target,
     * that can be changed at run time (e.g. the user resizes browser window). A lot of associated GL resources is be
     * updated in that case.
     */
    setTargetSize(width, height) {
        const gridPrecisionTargetPx = GRID_PRECISION_PX * Object(__WEBPACK_IMPORTED_MODULE_13__util_hd__["a" /* default */])();
        const gridWidth = Math.ceil(width / gridPrecisionTargetPx);
        const gridHeight = Math.ceil(height / gridPrecisionTargetPx);
        this._directPriorityGridRenderer.setResolution(gridWidth, gridHeight);
        this._reversePriorityGridRenderer.setResolution(gridWidth, gridHeight);
        if (this._gridSamplerVertexBuffer) {
            this._destroyGridResources();
        }
        const overlapSamplerBufferWriter = new __WEBPACK_IMPORTED_MODULE_5__grid_sampler_buffer_writer__["b" /* default */](gridWidth, gridHeight);
        const context = this._context;
        this._gridSamplerVertexBuffer = context.createVertexBuffer(overlapSamplerBufferWriter.data.byteLength);
        this._gridSamplerVao = context.createVao(__WEBPACK_IMPORTED_MODULE_5__grid_sampler_buffer_writer__["a" /* ATTRIBUTE_MAPPING */], this._gridSamplerVertexBuffer, null);
        this._numberOfGridSamplers = overlapSamplerBufferWriter.numberOfSamplers;
        this._context.uploadDataToBuffer(this._gridSamplerVertexBuffer, overlapSamplerBufferWriter.data);
        this._prevTargetSize.width = width;
        this._prevTargetSize.height = height;
        this._gridHalfPxSizeUniform.x = 0.5 / gridWidth;
        this._gridHalfPxSizeUniform.y = 0.5 / gridHeight;
    }
    /**
     * Recalculates visibility of all colliding primitives in scene.
     *
     * @param target The target the scene is to be rendered into.
     * @param uniforms Set of precalculated uniforms global for current frame.
     * @returns Updated texture with visibility values for all primitives.
     */
    updateVisibilityIfNeeded() {
        if (!this._isDirty) {
            return;
        }
        this._isDirty = false;
        // Rasterization may be not stable in the sense of the shape of pixels occupied by particular object when this
        // object gets shifted (e.g. the user drags the center of the map) and since collisions are detected by
        // overlapped pixels this fact can lead to blinking (found overlapping in one frame/not found in the next/etc).
        // For those objects (and their positions) that are not distorted by perspective it can be fixed by
        // introducing a shift that takes into account the amount of drag and forces vertices to be displaced in the
        // same position in grid's cell.
        const shift = this._stabilityShift;
        __WEBPACK_IMPORTED_MODULE_2__math_vector2__["e" /* copy */](this._camera.center, shift);
        shift.z = 0;
        __WEBPACK_IMPORTED_MODULE_4__math_matrix4__["b" /* apply */](this._camera.getViewProjMatrix(), shift, shift);
        // NDC (-1 : 1) are 2 times larger than texture coordinates (0 : 1)
        shift.x %= 4 * this._gridHalfPxSizeUniform.x;
        shift.y %= 4 * this._gridHalfPxSizeUniform.y;
        const prevTexture = this._prevVisibilityTexture;
        const prevFramebuffer = this._prevVisibilityBuffer;
        const currentTexture = this._currentVisibilityTexture;
        const currentFramebuffer = this._currentVisibilityBuffer;
        this._clearVisibility(prevFramebuffer);
        // on this step
        this._step1ResetRemoved.render(prevFramebuffer, this._resetRemovedRenderers, currentTexture, this._idHalfPxSizeUniform);
        // pass zoom as a value between 0.0 and 1.0, as absolute value is not important
        const zoom = this._camera.zoom / this._camera.options.maxZoom;
        const viewProjMatrix = this._camera.getViewProjMatrix();
        const cameraPositions = Object(__WEBPACK_IMPORTED_MODULE_12__render_util_camera_position__["a" /* calculateCameraPositions */])(this._camera);
        const directPriorityGrid = this._directPriorityGridRenderer.updateGrid(viewProjMatrix, cameraPositions, this._colorIdRenderers, shift, prevTexture, zoom);
        const reversePriorityGrid = this._reversePriorityGridRenderer.updateGrid(viewProjMatrix, cameraPositions, this._colorIdRenderers, shift, prevTexture, zoom);
        const now = performance.now();
        const lastRendering = this._lastRenderTimeInLoop;
        const isAnimationFinished = (now - this._lastSceneUpdateTime) > this.fadeEffectDuration;
        const wasAnimationActive = lastRendering !== FADING_STOPPED;
        const fadeEffect = isAnimationFinished ?
            1.0 : wasAnimationActive ? (now - lastRendering) / this.fadeEffectDuration : 0;
        const idHalfPx = this._idHalfPxSizeUniform;
        const samplerVao = this._gridSamplerVao;
        const numberOfSamplers = this._numberOfGridSamplers;
        this._clearVisibility(currentFramebuffer);
        this._step2FadeoutAll.render(currentFramebuffer, prevTexture, fadeEffect);
        this._step3FadeinVisible.render(currentFramebuffer, samplerVao, numberOfSamplers, directPriorityGrid, prevTexture, idHalfPx, fadeEffect);
        this._step4FadeoutOverlapped.render(currentFramebuffer, samplerVao, numberOfSamplers, directPriorityGrid, reversePriorityGrid, prevTexture, idHalfPx, fadeEffect, zoom);
        // check if we need one more rendering to finish animation
        if (isAnimationFinished) {
            // no more renderings needed for fade effect, its timestamp is marked with special value
            // to take it into account during next fade effect amount calculation
            this._lastRenderTimeInLoop = FADING_STOPPED;
        }
        else {
            this._renderLoop.update();
            this._lastRenderTimeInLoop = now;
        }
    }
    registerCollidingPrimitives(primitiveProvider, colorIdRenderer, resetRemoveRenderer) {
        this._primitiveProviders.push(primitiveProvider);
        this._colorIdRenderers.push(colorIdRenderer);
        this._resetRemovedRenderers.push(resetRemoveRenderer);
        primitiveProvider.onUpdate.addListener(this._sceneUpdateListener);
    }
    deregisterCollidingPrimitives(primitiveProvider, colorIdRenderer, resetRemoveRenderer) {
        let index = this._primitiveProviders.indexOf(primitiveProvider);
        if (index > -1) {
            this._primitiveProviders.splice(index, 1);
        }
        index = this._colorIdRenderers.indexOf(colorIdRenderer);
        if (index > -1) {
            this._colorIdRenderers.splice(index, 1);
        }
        index = this._resetRemovedRenderers.indexOf(resetRemoveRenderer);
        if (index > -1) {
            this._resetRemovedRenderers.splice(index, 1);
        }
        primitiveProvider.onUpdate.removeListener(this._sceneUpdateListener);
    }
    destroy() {
        this._destroyGridResources();
        this._directPriorityGridRenderer.destroy();
        this._reversePriorityGridRenderer.destroy();
        this._camera.onUpdate.removeListener(this._sceneUpdateListener);
        for (const primitiveProvider of this._primitiveProviders) {
            primitiveProvider.onUpdate.removeListener(this._sceneUpdateListener);
        }
    }
    _onSceneUpdate() {
        this._lastSceneUpdateTime = performance.now();
        this._renderLoop.update();
    }
    _onBeforeRender() {
        this._isDirty = true;
    }
    /**
     * Resets visibility texture to its initial state.
     */
    _clearVisibility(target) {
        this._context.bindRenderState(VISIBILITY_INIT_STATE);
        this._context.bindRenderTarget(target);
        this._context.clearCurrentTarget(16384 /* COLOR_BUFFER_BIT */);
    }
    _destroyGridResources() {
        this._gridSamplerVertexBuffer.destroy();
        this._gridSamplerVao.destroy();
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = VisibilityManager;



/***/ }),
/* 158 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_buffer_writer__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_gputypes__ = __webpack_require__(13);



const ATTRIBUTE_MAPPING = new __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__["a" /* AttributeMapping */]([
    [
        0 /* POSITION */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ]
]);
/* harmony export (immutable) */ __webpack_exports__["a"] = ATTRIBUTE_MAPPING;

/**
 * Writes sampler positions into vertex buffer as a regular grid with the step equal to the size of a grid cell.
 * The number of vertices (samplers) is equal to "width x height".
 */
class GridSamplerBufferWriter extends __WEBPACK_IMPORTED_MODULE_1__util_buffer_writer__["b" /* default */] {
    constructor(width, height) {
        const numberOfSamplers = width * height;
        super(ATTRIBUTE_MAPPING.vertexByteSize, numberOfSamplers, undefined, 0);
        const colStep = Object(__WEBPACK_IMPORTED_MODULE_2__util_gputypes__["a" /* floatToUint16 */])(1.0 / width);
        const rowStep = Object(__WEBPACK_IMPORTED_MODULE_2__util_gputypes__["a" /* floatToUint16 */])(1.0 / height);
        const colHalfStep = colStep / 2;
        const rowHalfStep = rowStep / 2;
        for (let i = 0, col = colHalfStep; i < width; i++, col += colStep) {
            for (let j = 0, row = rowHalfStep; j < height; j++, row += rowStep) {
                this._writeHalfWords(col, row);
            }
        }
        this.data = this.getBuffers()[0].vertexBuffer;
        this.numberOfSamplers = numberOfSamplers;
    }
}
/* harmony export (immutable) */ __webpack_exports__["b"] = GridSamplerBufferWriter;



/***/ }),
/* 159 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__render_gl_renderer__ = __webpack_require__(4);

class GridRenderer extends __WEBPACK_IMPORTED_MODULE_0__render_gl_renderer__["a" /* GlRenderer */] {
    constructor(context, renderState) {
        super(context, renderState);
    }
    updateGrid(...args) {
        this.render(this._target, ...args);
        return this._texture;
    }
    _render(viewProjMatrix, cameraPositions, renderers, stabilityShift, prevVisibility, currentZoom) {
        for (const renderer of renderers) {
            renderer.render(this._target, viewProjMatrix, cameraPositions, this._renderState, stabilityShift, prevVisibility, currentZoom);
        }
    }
    /**
     * Updates resolution of the grid.
     */
    setResolution(width, height) {
        this._destroyResources();
        this._depthBuffer = this._context.createRenderbuffer(width, height, 34041 /* DEPTH_STENCIL */);
        this._texture = this._context.createEmpty2DTexture(width, height, 6408 /* RGBA */, 5121 /* UNSIGNED_BYTE */);
        this._target = this._context.createFramebuffer({ color: this._texture, depthStencil: this._depthBuffer });
    }
    destroy() {
        this._destroyResources();
    }
    _prepareRenderTarget(target, ...args) {
        super._prepareRenderTarget(target, ...args);
        this._context.clearCurrentTarget(16384 /* COLOR_BUFFER_BIT */ | 256 /* DEPTH_BUFFER_BIT */);
    }
    _destroyResources() {
        if (this._target) {
            this._target.destroy();
            this._texture.destroy();
            this._depthBuffer.destroy();
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = GridRenderer;



/***/ }),
/* 160 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * One of the steps of primitives visibility resolution process. Basically it does nothing, just call appropriate
 * methods of CollidingPrimitiveRenderer's, but it expects that these renderers will copy visibility value of actual
 * primitives only, thus removed primitive's values will be reset (overlap zoom cleared and all that). It is important
 * for reusing these ids for future primitives.
 */
class ResetRemovedPrimitives {
    render(target, renderers, prevVisibility, idHalfPxSizeUniform) {
        for (const renderer of renderers) {
            renderer.render(target, prevVisibility, idHalfPxSizeUniform);
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = ResetRemovedPrimitives;



/***/ }),
/* 161 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shaders_fadeout_all_vert__ = __webpack_require__(162);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__shaders_fadeout_all_vert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__shaders_fadeout_all_vert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shaders_fadeout_all_frag__ = __webpack_require__(163);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shaders_fadeout_all_frag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__shaders_fadeout_all_frag__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__render_gl_renderer__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__render_state__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__id_sampler_buffer_writer__ = __webpack_require__(164);





const STATE = new __WEBPACK_IMPORTED_MODULE_3__render_state__["c" /* default */]({
    dither: false
});
/**
 * One of the steps of primitives visibility resolution process. It samples all visibility values and subtract
 * delta (fadeoutAmount) from them, these new values are stored into current visibility texture.
 */
class FadeoutAll extends __WEBPACK_IMPORTED_MODULE_2__render_gl_renderer__["a" /* GlRenderer */] {
    constructor(context) {
        const program = context.createProgram(__WEBPACK_IMPORTED_MODULE_0__shaders_fadeout_all_vert___default.a, __WEBPACK_IMPORTED_MODULE_1__shaders_fadeout_all_frag___default.a, {
            attribMap: {
                position: 0 /* POSITION */
            }
        });
        super(context, STATE, program);
        const idSamplerBufferWriter = new __WEBPACK_IMPORTED_MODULE_4__id_sampler_buffer_writer__["b" /* default */]();
        this._idSamplerVertexBuffer = this._context.createVertexBuffer(idSamplerBufferWriter.vertexData.byteLength);
        this._idSamplerIndexBuffer = this._context.createIndexBuffer(idSamplerBufferWriter.indexData.byteLength);
        this._idSamplerVao = this._context.createVao(__WEBPACK_IMPORTED_MODULE_4__id_sampler_buffer_writer__["a" /* ATTRIBUTE_MAPPING */], this._idSamplerVertexBuffer, this._idSamplerIndexBuffer);
        this._context.uploadDataToBuffer(this._idSamplerVertexBuffer, idSamplerBufferWriter.vertexData);
        this._context.uploadDataToBuffer(this._idSamplerIndexBuffer, idSamplerBufferWriter.indexData);
        context.bindProgram(program);
        program.setIntScalarUniform('prevVisibility', 0);
    }
    _prepareProgram(program, prevVisibility, fadeoutAmount) {
        super._prepareProgram(program, prevVisibility, fadeoutAmount);
        this._context.bindTextureUnit(0);
        this._context.bindTexture(prevVisibility);
        program.setScalarUniform('fadeoutAmount', fadeoutAmount);
    }
    _render() {
        this._context.bindVao(this._idSamplerVao);
        this._context.drawIndexedMesh(0, 6, 4 /* TRIANGLES */);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = FadeoutAll;



/***/ }),
/* 162 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec4 position;\n\nvarying vec2 idTexCoordinates;\n\nvoid main() {\n    gl_Position = vec4(position.xy, 0, 1);\n    idTexCoordinates = position.zw;\n}\n"

/***/ }),
/* 163 */
/***/ (function(module, exports) {

module.exports = "#version 100\n\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform sampler2D prevVisibility;\nuniform float fadeoutAmount;\n\nvarying vec2 idTexCoordinates;\n\nvoid main() {\n    vec4 visibilityValue = texture2D(prevVisibility, idTexCoordinates);\n    visibilityValue.a = clamp(visibilityValue.a - fadeoutAmount, 0.0, 1.0);\n\n    gl_FragColor = visibilityValue;\n}\n"

/***/ }),
/* 164 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_buffer_writer__ = __webpack_require__(6);


const ATTRIBUTE_MAPPING = new __WEBPACK_IMPORTED_MODULE_0__render_attrib_mapping__["a" /* AttributeMapping */]([
    [
        0 /* POSITION */,
        {
            size: 4,
            type: 5120 /* BYTE */,
            normalized: false
        }
    ]
]);
/* harmony export (immutable) */ __webpack_exports__["a"] = ATTRIBUTE_MAPPING;

/**
 * Write vertices of two triangles that fully cover visibility texture, its values can be sampled in fragment shaders.
 */
class IdSamplerBufferWriter extends __WEBPACK_IMPORTED_MODULE_1__util_buffer_writer__["b" /* default */] {
    constructor() {
        super(ATTRIBUTE_MAPPING.vertexByteSize, 4, 4, 6);
        // window x, window y, texture x, texture y
        this._writeBytes(-1, -1, 0, 0);
        this._writeBytes(-1, 1, 0, 1);
        this._writeBytes(1, 1, 1, 1);
        this._writeBytes(1, -1, 1, 0);
        this.writeIndicesForFan([0, 1, 2, 3]);
        this.vertexData = this.getBuffers()[0].vertexBuffer;
        this.indexData = this.getBuffers()[0].indexBuffer;
    }
}
/* harmony export (immutable) */ __webpack_exports__["b"] = IdSamplerBufferWriter;



/***/ }),
/* 165 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__render_gl_renderer__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shaders_fadein_visible_vert__ = __webpack_require__(166);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shaders_fadein_visible_vert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__shaders_fadein_visible_vert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shaders_fadein_visible_frag__ = __webpack_require__(167);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shaders_fadein_visible_frag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__shaders_fadein_visible_frag__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__render_state__ = __webpack_require__(0);




const STATE = new __WEBPACK_IMPORTED_MODULE_3__render_state__["c" /* default */]({
    dither: false
});
/**
 * One of the steps of primitives visibility resolution process. It samples all pixels of the scene (rendered in direct
 * priority order into simplified grid) and adds delta (fadeinAmount) to alpha visibility of primitive with
 * id in this pixel. Those primitives are considered visible.
 */
class FadeinVisible extends __WEBPACK_IMPORTED_MODULE_0__render_gl_renderer__["a" /* GlRenderer */] {
    constructor(context) {
        const program = context.createProgram(__WEBPACK_IMPORTED_MODULE_1__shaders_fadein_visible_vert___default.a, __WEBPACK_IMPORTED_MODULE_2__shaders_fadein_visible_frag___default.a, {
            attribMap: {
                position: 0 /* POSITION */
            }
        });
        super(context, STATE, program);
        context.bindProgram(program);
        program.setIntScalarUniform('directPriorityGrid', 0);
        program.setIntScalarUniform('prevVisibility', 1);
    }
    _prepareProgram(program, data, samplers, directPriorityGrid, prevVisibility, idHalfPxSize, fadeinAmount) {
        super._prepareProgram(program, data, samplers, directPriorityGrid, prevVisibility, idHalfPxSize, fadeinAmount);
        this._context.bindTextureUnit(0);
        this._context.bindTexture(directPriorityGrid);
        this._context.bindTextureUnit(1);
        this._context.bindTexture(prevVisibility);
        program.setVector2Uniform('idHalfPxSize', idHalfPxSize);
        program.setScalarUniform('fadeinAmount', fadeinAmount);
    }
    _render(data, numberOfSamplers) {
        this._context.bindVao(data);
        this._context.drawMesh(0, numberOfSamplers, 0 /* POINTS */);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = FadeinVisible;



/***/ }),
/* 166 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec2 position;\n\nuniform sampler2D directPriorityGrid;\nuniform sampler2D prevVisibility;\nuniform vec2 idHalfPxSize;\nuniform float fadeinAmount;\n\nvarying lowp vec4 visibilityValue;\n\nconst vec2 NO_ID = vec2(0, 0);\nconst vec4 DISCARD_POSITION = vec4(2, 2, 2, 1);\n\nvoid main() {\n    vec2 primitiveId = texture2D(directPriorityGrid, position).rg;\n\n    if (primitiveId != NO_ID) {\n        vec2 idTexCoordinates = primitiveId + idHalfPxSize;\n        vec4 idWindowCoordinates = vec4(idTexCoordinates * 2.0 - 1.0, 0, 1);\n        gl_Position = idWindowCoordinates;\n        gl_PointSize = 1.0;\n\n        visibilityValue = texture2D(prevVisibility, idTexCoordinates);\n        visibilityValue.a = clamp(visibilityValue.a + fadeinAmount, 0.0, 1.0);\n    } else {\n        gl_Position = DISCARD_POSITION;\n    }\n}\n"

/***/ }),
/* 167 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nvarying lowp vec4 visibilityValue;\n\nvoid main() {\n    gl_FragColor = visibilityValue;\n}\n"

/***/ }),
/* 168 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__render_gl_renderer__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shaders_fadeout_overlapped_vert__ = __webpack_require__(169);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shaders_fadeout_overlapped_vert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__shaders_fadeout_overlapped_vert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shaders_fadeout_overlapped_frag__ = __webpack_require__(170);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shaders_fadeout_overlapped_frag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__shaders_fadeout_overlapped_frag__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__render_state__ = __webpack_require__(0);




const STATE = new __WEBPACK_IMPORTED_MODULE_3__render_state__["c" /* default */]({ dither: false });
class FadeoutOverlapped extends __WEBPACK_IMPORTED_MODULE_0__render_gl_renderer__["a" /* GlRenderer */] {
    constructor(context) {
        const program = context.createProgram(__WEBPACK_IMPORTED_MODULE_1__shaders_fadeout_overlapped_vert___default.a, __WEBPACK_IMPORTED_MODULE_2__shaders_fadeout_overlapped_frag___default.a, {
            attribMap: {
                position: 0 /* POSITION */
            }
        });
        super(context, STATE, program);
        context.bindProgram(program);
        program.setIntScalarUniform('directPriorityGrid', 0);
        program.setIntScalarUniform('reversePriorityGrid', 1);
        program.setIntScalarUniform('prevVisibility', 2);
    }
    _prepareProgram(program, data, samplers, directPriority, reversePriority, prevVisibility, idHalfPxSize, fadeoutAmount, currentZoom) {
        super._prepareProgram(program, data, samplers, directPriority, reversePriority, prevVisibility, idHalfPxSize, fadeoutAmount, currentZoom);
        this._context.bindTextureUnit(0);
        this._context.bindTexture(directPriority);
        this._context.bindTextureUnit(1);
        this._context.bindTexture(reversePriority);
        this._context.bindTextureUnit(2);
        this._context.bindTexture(prevVisibility);
        program.setVector2Uniform('idHalfPxSize', idHalfPxSize);
        program.setScalarUniform('fadeoutAmount', fadeoutAmount);
        program.setScalarUniform('currentZoom', currentZoom);
    }
    _render(data, numberOfSamplers) {
        this._context.bindVao(data);
        this._context.drawMesh(0, numberOfSamplers, 0 /* POINTS */);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = FadeoutOverlapped;



/***/ }),
/* 169 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec2 position;\n\nuniform sampler2D directPriorityGrid;\nuniform sampler2D reversePriorityGrid;\nuniform sampler2D prevVisibility;\nuniform vec2 idHalfPxSize;\nuniform float fadeoutAmount;\nuniform float currentZoom;\n\nvarying vec4 visibilityValue;\n\nconst vec2 NO_ID = vec2(0, 0);\nconst vec4 DISCARD_POSITION = vec4(2, 2, 2, 1);\n\nvoid main() {\n    vec2 primitiveIdReversePriority = texture2D(reversePriorityGrid, position).rg;\n\n    if (\n        primitiveIdReversePriority != NO_ID &&\n        primitiveIdReversePriority != texture2D(directPriorityGrid, position).rg\n    ) {\n        vec2 idTexCoordinates = primitiveIdReversePriority + idHalfPxSize;\n        vec4 idWindowCoordinates = vec4(idTexCoordinates * 2.0 - 1.0, 0, 1);\n\n        gl_Position = idWindowCoordinates;\n        gl_PointSize = 1.0;\n\n        visibilityValue = texture2D(prevVisibility, idTexCoordinates);\n        visibilityValue.b = currentZoom;\n        visibilityValue.a = clamp(visibilityValue.a - fadeoutAmount, 0.0, 1.0);\n    } else {\n        gl_Position = DISCARD_POSITION;\n    }\n}\n"

/***/ }),
/* 170 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nvarying lowp vec4 visibilityValue;\n\nvoid main() {\n    gl_FragColor = visibilityValue;\n}\n"

/***/ }),
/* 171 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = computeSquaresCoveredByConvexPolygon;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_vector2__ = __webpack_require__(1);


/**
 * Container of indexed min/max values with a single update method.
 */
class ExtremumStorage {
    constructor(length) {
        this._mins = new Array(length);
        this._maxs = new Array(length);
        this._mins.fill(Number.POSITIVE_INFINITY);
        this._maxs.fill(Number.NEGATIVE_INFINITY);
    }
    updateValue(index, value) {
        this._mins[index] = Math.min(this._mins[index], value);
        this._maxs[index] = Math.max(this._maxs[index], value);
    }
    *values() {
        const item = { min: 0, max: 0, index: -1 };
        for (let i = 0; i < this._mins.length; i++) {
            item.min = this._mins[i];
            item.max = this._maxs[i];
            item.index = i;
            yield item;
        }
    }
}
/**
 * Squares that are ony touched by a line (with no significant crossing an edge) should not be considered "covered".
 * It happens when a point matches the max coordinate (integer) and this case is handled here.
 */
function floorToCellCoordinate(value, maxValue) {
    return Number.isInteger(value) && maxValue === value ? value - 1 : Math.floor(value);
}
/**
 * Calculates squares covered (at least partially) by a convex polygon.
 *
 * @param points Convex polygon point coordinates (on the grid).
 * @returns List of unit square coordinates.
 */
function computeSquaresCoveredByConvexPolygon(points) {
    const result = [];
    const bbox = Object(__WEBPACK_IMPORTED_MODULE_0__math_vector2__["c" /* computeBBoxForPoints */])(points);
    const minX = Math.floor(bbox.minX);
    const xLength = Math.ceil(bbox.maxX) - minX;
    const extremums = new ExtremumStorage(xLength);
    for (let i = points.length - 1, j = 0; j < points.length; i = j++) {
        let p1 = points[i];
        let p2 = points[j];
        // go from left to right always to not handle the opposite case
        if (p1.x > p2.x) {
            const tmp = p1;
            p1 = p2;
            p2 = tmp;
        }
        // calculate from/to interval so that only "internal" integer x-es are captured
        const fromX = Math.floor(p1.x + 1);
        const toX = Math.ceil(p2.x - 1);
        const slope = (p1.y - p2.y) / (p1.x - p2.x);
        // handle terminal points separately from the "internal" ones
        extremums.updateValue(floorToCellCoordinate(p1.x, bbox.maxX) - minX, floorToCellCoordinate(p1.y, bbox.maxY));
        extremums.updateValue(floorToCellCoordinate(p2.x, bbox.maxX) - minX, floorToCellCoordinate(p2.y, bbox.maxY));
        for (let x = fromX; x <= toX; x++) {
            const yIntercept = (isFinite(slope) ? slope * (x - p1.x) : 0) + p1.y;
            const nextX = x - minX;
            const prevX = nextX - 1;
            const y = Math.floor(yIntercept);
            // check if we hit exactly the intersection of two integer coordinates
            if (Number.isInteger(yIntercept)) {
                if (yIntercept === bbox.maxY) {
                    extremums.updateValue(prevX, y - 1);
                    extremums.updateValue(nextX, y - 1);
                }
                else if (slope > 0) {
                    // two diagonal squares intersected by a line with positive slope
                    extremums.updateValue(prevX, y - 1);
                    extremums.updateValue(nextX, y);
                }
                else if (slope < 0) {
                    // two diagonal squares intersected by a line with negative slope
                    extremums.updateValue(prevX, y);
                    extremums.updateValue(nextX, y - 1);
                }
            }
            else {
                extremums.updateValue(prevX, y);
                extremums.updateValue(nextX, y);
            }
        }
    }
    for (const { min, max, index } of extremums.values()) {
        const x = minX + index;
        for (let y = min; y <= max; y++) {
            result.push(__WEBPACK_IMPORTED_MODULE_0__math_vector2__["f" /* create */](x, y));
        }
    }
    return result;
}


/***/ }),
/* 172 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = medianFilter;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__array__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__comparator__ = __webpack_require__(19);


/**
 * Filters an array of values with median filter.
 *
 * @param values Values to be filtered.
 * @param windowRadius How many values around a sample get into filter window.
 * @returns Array of filtered values.
 */
function medianFilter(values, windowRadius = 3) {
    const window = new Array(2 * windowRadius + 1);
    window.fill(values[0]);
    const length = values.length;
    const result = new Array(length);
    const first = values[0];
    for (let i = 0; i < windowRadius; ++i) {
        window.fill(first, 0, windowRadius - i + 1);
        Object(__WEBPACK_IMPORTED_MODULE_0__array__["b" /* copy */])(values, window, 0, i + windowRadius + 1, windowRadius - i + 1);
        window.sort(__WEBPACK_IMPORTED_MODULE_1__comparator__["b" /* NUMERICAL_COMPARATOR */]);
        result[i] = window[windowRadius];
    }
    for (let i = windowRadius; i < length - windowRadius; ++i) {
        Object(__WEBPACK_IMPORTED_MODULE_0__array__["b" /* copy */])(values, window, i - windowRadius, i + windowRadius + 1);
        window.sort(__WEBPACK_IMPORTED_MODULE_1__comparator__["b" /* NUMERICAL_COMPARATOR */]);
        result[i] = window[windowRadius];
    }
    const last = values[values.length - 1];
    for (let i = length - windowRadius; i < length; ++i) {
        Object(__WEBPACK_IMPORTED_MODULE_0__array__["b" /* copy */])(values, window, i - windowRadius, length);
        window.fill(last, values.length - i + windowRadius);
        window.sort(__WEBPACK_IMPORTED_MODULE_1__comparator__["b" /* NUMERICAL_COMPARATOR */]);
        result[i] = window[windowRadius];
    }
    return result;
}


/***/ }),
/* 173 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__list_render_unit__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_event_emitter__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__state__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__util_camera_position__ = __webpack_require__(51);




const FINAL_RENDER_STATE = new __WEBPACK_IMPORTED_MODULE_2__state__["c" /* default */]({
    clearDepth: 0,
    depthTest: true,
    depthFunc: 518 /* GREATER_OR_EQUAL */
});
/**
 * Root scene renderer. It generates final canvas image composing it from independent layers (LayerRenderUnit).
 */
class MainRenderUnit extends __WEBPACK_IMPORTED_MODULE_0__list_render_unit__["a" /* default */] {
    constructor(context, camera) {
        super();
        this._context = context;
        this._camera = camera;
        this.onRender = new __WEBPACK_IMPORTED_MODULE_1__util_event_emitter__["b" /* VoidEventEmitter */]();
    }
    render(target) {
        const viewProjMatix = this._camera.getViewProjMatrix();
        const cameraPositions = Object(__WEBPACK_IMPORTED_MODULE_3__util_camera_position__["a" /* calculateCameraPositions */])(this._camera);
        this._context.bindRenderTarget(target);
        this._context.bindRenderState(FINAL_RENDER_STATE);
        this._context.clearCurrentTarget(17664 /* ALL */);
        for (const renderer of this._subRenderUnits) {
            renderer.render(target, viewProjMatix, cameraPositions);
        }
        this.onRender.fire();
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = MainRenderUnit;



/***/ }),
/* 174 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__page__ = __webpack_require__(175);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__count_vertices__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_allocator__ = __webpack_require__(50);



const MAX_VERTEX_COUNT = 0x10000;
// FIXME(dmikis) Let's use oversized index buffer til we sort out indices allocation
// both in writers and the manager.
const PAGE_INDEX_BUFFER_BYTE_SIZE = 0x100000;
/**
 * Memory page with the following peculiarity: once allocation is failed it gets closed for any subsequent
 * allocations. It allow to keep related primitives closer in memory.
 */
class SinglePassMemoryPage extends __WEBPACK_IMPORTED_MODULE_0__page__["a" /* default */] {
    constructor(vertexBuffer, indexBuffer, vao, indexType) {
        super(vertexBuffer, indexBuffer, vao, indexType, new __WEBPACK_IMPORTED_MODULE_2__util_allocator__["a" /* ArenaAllocator */](vertexBuffer.getSize()), new __WEBPACK_IMPORTED_MODULE_2__util_allocator__["a" /* ArenaAllocator */](indexBuffer.getSize()));
        this._failedAllocation = false;
    }
    allocate(vertexByteLength, indexByteLength) {
        if (this._failedAllocation) {
            return null;
        }
        const chunk = super.allocate(vertexByteLength, indexByteLength);
        this._failedAllocation = (chunk === null);
        return chunk;
    }
}
/**
 * Manager that controls GL memory allocations and pagination.[]
 */
class MemoryManager {
    /**
     * Creates a new memory manager that will allocate memory in a given context.
     *
     * @param context The context.
     */
    constructor(context) {
        this._context = context;
        this._pages = new Map();
        this._emptyPagesClearTimeout = 0;
    }
    /**
     * Allocates memory for a given data in the manager and uploads given data.
     *
     * @param vertexData Buffer with vertices that needs to be allocated.
     * @param indexData Buffer with indices that needs to be allocated.
     * @param attributeMapping Mapping of vertex attributes.
     * @returns Descriptor of the allocated memory region.
     */
    allocate(vertexData, indexData, attributeMapping) {
        const context = this._context;
        let pageSet = this._pages.get(attributeMapping);
        // If there's no pages for the given attribute mapping, create a new set.
        if (!pageSet) {
            pageSet = new Set();
            this._pages.set(attributeMapping, pageSet);
        }
        // Try to allocate data in the existing pages.
        for (const page of pageSet) {
            const memoryChunk = page.allocate(vertexData.byteLength, indexData.byteLength);
            if (memoryChunk) {
                // Success! Now we just upload the data.
                this._updatePage(page, memoryChunk, vertexData, indexData);
                return memoryChunk;
            }
        }
        // We've failed to allocate the data in any of existing pages. No worries
        // though, we just create a new one:)
        const vertexBuffer = context.createVertexBuffer(
        // some buffer writers don't use indices and MAX_VERTEX_COUNT restriction is not applied in such cases
        Math.max(MAX_VERTEX_COUNT * attributeMapping.vertexByteSize, vertexData.byteLength));
        const indexBuffer = context.createIndexBuffer(PAGE_INDEX_BUFFER_BYTE_SIZE);
        const vao = context.createVao(attributeMapping, vertexBuffer, indexBuffer);
        const page = new SinglePassMemoryPage(vertexBuffer, indexBuffer, vao, 5123 /* UNSIGNED_SHORT */);
        page.setDelegate(this);
        pageSet.add(page);
        // Here we assume we always can allocate data in an empty page.
        const memoryChunk = page.allocate(vertexData.byteLength, indexData.byteLength);
        this._updatePage(page, memoryChunk, vertexData, indexData);
        return memoryChunk;
    }
    onPageEmpty() {
        if (!this._emptyPagesClearTimeout) {
            this._emptyPagesClearTimeout = setTimeout(() => {
                this._clearEmptyPages();
                this._emptyPagesClearTimeout = 0;
            });
        }
    }
    /**
     * Destroys the manager and all its memory pages. All memory chunks that were
     * allocated in the manager become invalid.
     */
    destroy() {
        if (this._emptyPagesClearTimeout) {
            clearTimeout(this._emptyPagesClearTimeout);
        }
        for (const [, pageSet] of this._pages) {
            for (const page of pageSet) {
                page.destroy();
            }
        }
    }
    _updatePage(page, memoryChunk, vertexData, indexData) {
        const context = this._context;
        // Let's ensure that we won't break any bound VAOs.
        context.bindVao(null);
        context.uploadDataToBuffer(page.vertexBuffer, vertexData, memoryChunk.vertexByteOffset);
        // Shift indices.
        const baseIndex = Object(__WEBPACK_IMPORTED_MODULE_1__count_vertices__["b" /* countVertices */])(memoryChunk.vertexByteOffset, page.vao.attributeMapping);
        for (let i = 0; i < indexData.length; ++i) {
            indexData[i] += baseIndex;
        }
        context.uploadDataToBuffer(page.indexBuffer, indexData, memoryChunk.indexByteOffset);
    }
    _clearEmptyPages() {
        for (const pageSet of this._pages.values()) {
            for (const page of pageSet) {
                if (page.isEmpty()) {
                    pageSet.delete(page);
                    page.setDelegate(null);
                    page.destroy();
                }
            }
        }
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = MemoryManager;



/***/ }),
/* 175 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__chunk__ = __webpack_require__(176);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_delegator__ = __webpack_require__(41);


/**
 * A "page" of GPU memory. Comprises vertex and index buffers of a fixed size.
 */
class MemoryPage extends __WEBPACK_IMPORTED_MODULE_1__util_delegator__["a" /* DelegatorBase */] {
    /**
     * Creates a new page to manage given vertex and index buffers.
     *
     * @param vertexBuffer The vertex buffer the page will manage.
     * @param indexBuffer The index buffer the page will manager.
     * @param vao The VAO of the page.
     * @param indexType Type of elements of indexBuffer.
     * @param vertexAllocator Allocator of vertex data, logic of allocation directly impacts the lifecycle of the page.
     * @param indexAllocator Allocator of index data, logic of allocation directly impacts the lifecycle of the page.
     */
    constructor(vertexBuffer, indexBuffer, vao, indexType, vertexAllocator, indexAllocator) {
        super();
        this.vertexBuffer = vertexBuffer;
        this.indexBuffer = indexBuffer;
        this.vao = vao;
        this.indexType = indexType;
        this._vertexAllocator = vertexAllocator;
        this._indexAllocator = indexAllocator;
    }
    /**
     * Allocates and writes vertex and index data to the page. Offsets indices
     * in an index array to appropriately take into account offset of the vertex
     * data.
     *
     * @param vertexByteLength required number of bytes in vertex buffer
     * @param indexByteLength required number of bytes in index buffer
     * @returns memory chunk allocated or `null` if allocation's failed
     */
    allocate(vertexByteLength, indexByteLength) {
        if (this._vertexAllocator.maxAllocableSize >= vertexByteLength &&
            this._indexAllocator.maxAllocableSize >= indexByteLength) {
            return new __WEBPACK_IMPORTED_MODULE_0__chunk__["a" /* default */](this, {
                vertexByteOffset: this._vertexAllocator.allocate(vertexByteLength),
                vertexByteLength: vertexByteLength,
                indexByteOffset: this._indexAllocator.allocate(indexByteLength),
                indexByteLength: indexByteLength
            });
        }
        else {
            return null;
        }
    }
    /**
     * Frees a previously allocated memory chunk.
     *
     * @param chunk The chunk to be freed.
     */
    free(chunk) {
        this._vertexAllocator.deallocate(chunk.vertexByteOffset);
        this._indexAllocator.deallocate(chunk.indexByteOffset);
        if (this.isEmpty() && this._delegate) {
            this._delegate.onPageEmpty(this);
        }
    }
    /**
     * Returns `true` if the page does not contain any previously allocated data
     * and `false` otherwise.
     */
    isEmpty() {
        return this._vertexAllocator.isEmpty && this._indexAllocator.isEmpty;
    }
    /**
     * Destroys the page and all its resources.
     */
    destroy() {
        this.vertexBuffer.destroy();
        this.indexBuffer.destroy();
        this.vao.destroy();
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = MemoryPage;



/***/ }),
/* 176 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_ref_counted__ = __webpack_require__(20);

/** Handler to a allocated memory chunk. */
class MemoryChunk extends __WEBPACK_IMPORTED_MODULE_0__util_ref_counted__["a" /* default */] {
    /**
     * Creates a new handler to a memory chunk with given offsets allocated in
     * a given memory page.
     *
     * @param page The page the chunk was allocated in.
     * @param vertexOffset The offset of chunk's vertex data.
     * @param indexOffset The offset of chunk's index data.
     */
    constructor(page, location) {
        super();
        this.page = page;
        this._location = location;
    }
    /**
     * Returns offset of vertex data of the chunk in bytes.
     */
    get vertexByteOffset() {
        return this._location.vertexByteOffset;
    }
    /**
     * Returns offset of index data of the chunk in bytes.
     */
    get indexByteOffset() {
        return this._location.indexByteOffset;
    }
    _destroy() {
        this.page.free(this);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = MemoryChunk;



/***/ }),
/* 177 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_vector2__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__state__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shaders_fxaa_frag__ = __webpack_require__(178);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shaders_fxaa_frag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__shaders_fxaa_frag__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__shaders_quad_vert__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__shaders_quad_vert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__shaders_quad_vert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__util_hd__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__gl_renderer__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__list_render_unit__ = __webpack_require__(23);








const STATE = new __WEBPACK_IMPORTED_MODULE_1__state__["c" /* default */](__WEBPACK_IMPORTED_MODULE_1__state__["b" /* BLEND_OVER_RENDER_STATE */]);
/**
 * Renderer of FXAA postprocessing pass.
 */
class FxaaRenderUnit extends __WEBPACK_IMPORTED_MODULE_5__gl_renderer__["a" /* GlRenderer */] {
    constructor(context, renderLoop) {
        super(context, STATE, context.createProgram(__WEBPACK_IMPORTED_MODULE_3__shaders_quad_vert___default.a, __WEBPACK_IMPORTED_MODULE_2__shaders_fxaa_frag___default.a, {
            attribMap: {
                vertexPosition: 0 /* POSITION */
            }
        }));
        this._renderers = new __WEBPACK_IMPORTED_MODULE_6__list_render_unit__["a" /* default */]();
        this._renderLoop = renderLoop;
        this.onUpdate = this._renderers.onUpdate;
        this._pixelSize = __WEBPACK_IMPORTED_MODULE_0__math_vector2__["f" /* create */](0, 0);
    }
    addRenderUnit(unit) {
        this._renderers.addRenderUnit(unit);
    }
    removeRenderUnit(unit) {
        this._renderers.removeRenderUnit(unit);
    }
    render(target, ...args) {
        // skip antialiasing if these is action in the scene
        if (this._renderLoop.isActive) {
            this._renderers.render(target, ...args);
            // schedule at least one more rendering to not leave static (stopped) scene in non-antialiased state
            this._renderLoop.update();
            return;
        }
        if (!this._intermediateRendereBuffer) {
            this._initIntermediateRenderTargets(target.getWidth(), target.getHeight());
        }
        else if (this._intermediateRendereBuffer.getWidth() !== target.getWidth() ||
            this._intermediateRendereBuffer.getHeight() !== target.getHeight()) {
            this._destroyInternalRenderTargets();
            this._initIntermediateRenderTargets(target.getWidth(), target.getHeight());
        }
        this._context.bindRenderTarget(this._intermediateRendereBuffer);
        this._context.clearCurrentTarget(17664 /* ALL */);
        this._renderers.render(this._intermediateRendereBuffer, ...args);
        // do not run antialiasing on empty this._intermediateRendereBuffer
        if (!this._intermediateRendereBuffer.isClear) {
            this._updateFrameUniformState(target);
            super.render(target, ...args);
        }
    }
    destroy() {
        if (this._intermediateRendereBuffer) {
            this._destroyInternalRenderTargets();
        }
    }
    _render() {
        this._context.bindQuadVao();
        this._context.drawQuad();
    }
    _prepareProgram(program, ...args) {
        super._prepareProgram(program, ...args);
        this._context.bindTextureUnit(0);
        this._context.bindTexture(this._intermediateColorBuffer);
        program.setIntScalarUniform('texture', 0);
        program.setVector2Uniform('pixelSize', this._pixelSize);
        program.setScalarUniform('dpr', Object(__WEBPACK_IMPORTED_MODULE_4__util_hd__["a" /* default */])());
    }
    _updateFrameUniformState(target) {
        this._pixelSize.x = 1 / target.getWidth();
        this._pixelSize.y = 1 / target.getHeight();
    }
    _initIntermediateRenderTargets(width, height) {
        const context = this._context;
        const intermediateColorBuffer = this._intermediateColorBuffer =
            context.createEmpty2DTexture(width, height, 6408 /* RGBA */, 5121 /* UNSIGNED_BYTE */);
        const intermediateDepthStencilBuffer = this._intermediateDepthStencilBuffer =
            context.createRenderbuffer(width, height, 34041 /* DEPTH_STENCIL */);
        this._intermediateRendereBuffer = context.createFramebuffer({
            color: intermediateColorBuffer,
            depthStencil: intermediateDepthStencilBuffer
        });
    }
    _destroyInternalRenderTargets() {
        this._intermediateRendereBuffer.destroy();
        this._intermediateColorBuffer.destroy();
        this._intermediateDepthStencilBuffer.destroy();
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = FxaaRenderUnit;



/***/ }),
/* 178 */
/***/ (function(module, exports) {

module.exports = "#version 100\n\nprecision mediump float;\n#define GLSLIFY 1\n\nuniform vec2 pixelSize;\nuniform sampler2D texture;\nuniform float dpr;\n\nconst float FXAA_QUALITY_SUBPIX = 0.75;\nconst float FXAA_QUALITY_EDGE_THRESHOLD = 0.063;\nconst float FXAA_QUALITY_EDGE_THRESHOLD_MIN = 0.0625;\nconst float EPSILON = 0.0001;\n\nfloat luma(vec4 rgba) {\n    return dot(rgba.xyz, vec3(0.299, 0.587, 0.114));\n}\n\nvec4 fxaa(\n    vec2 pos,\n    sampler2D tex,\n    vec2 fxaaQualityRcpFrame,\n    // This used to be the FXAA_QUALITY_SUBPIX define.\n    // Choose the amount of sub-pixel aliasing removal.\n    // This can effect sharpness.\n    //   1.00 - upper limit (softer)\n    //   0.75 - default amount of filtering\n    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)\n    //   0.25 - almost off\n    //   0.00 - completely off\n    float fxaaQualitySubpix,\n    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.\n    // The minimum amount of local contrast required to apply algorithm.\n    //   0.333 - too little (faster)\n    //   0.250 - low quality\n    //   0.166 - default\n    //   0.125 - high quality\n    //   0.063 - overkill (slower)\n    float fxaaQualityEdgeThreshold,\n    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.\n    // Trims the algorithm from processing darks.\n    //   0.0833 - upper limit (default, the start of visible unfiltered edges)\n    //   0.0625 - high quality (faster)\n    //   0.0312 - visible limit (slower)\n    float fxaaQualityEdgeThresholdMin\n) {\n    vec2 posM;\n    posM.x = pos.x;\n    posM.y = pos.y;\n    vec4 rgbyM = texture2D(tex, posM);\n    float lumaM = luma(rgbyM);\n\n    float lumaS = luma(texture2D(tex, posM + vec2( 0, 1) * fxaaQualityRcpFrame.xy));\n    float lumaE = luma(texture2D(tex, posM + vec2( 1, 0) * fxaaQualityRcpFrame.xy));\n    float lumaN = luma(texture2D(tex, posM + vec2( 0,-1) * fxaaQualityRcpFrame.xy));\n    float lumaW = luma(texture2D(tex, posM + vec2(-1, 0) * fxaaQualityRcpFrame.xy));\n\n    float maxSM = max(lumaS, lumaM);\n    float minSM = min(lumaS, lumaM);\n    float maxESM = max(lumaE, maxSM);\n    float minESM = min(lumaE, minSM);\n    float maxWN = max(lumaN, lumaW);\n    float minWN = min(lumaN, lumaW);\n    float rangeMax = max(maxWN, maxESM);\n    float rangeMin = min(minWN, minESM);\n    float rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\n    float range = rangeMax - rangeMin;\n    float rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\n    bool earlyExit = range < rangeMaxClamped;\n\n    if (earlyExit)\n        return rgbyM;\n\n    float lumaNW = luma(texture2D(tex, posM + vec2(-1,-1) * fxaaQualityRcpFrame.xy));\n    float lumaSE = luma(texture2D(tex, posM + vec2( 1, 1) * fxaaQualityRcpFrame.xy));\n    float lumaNE = luma(texture2D(tex, posM + vec2( 1,-1) * fxaaQualityRcpFrame.xy));\n    float lumaSW = luma(texture2D(tex, posM + vec2(-1, 1) * fxaaQualityRcpFrame.xy));\n\n    float lumaNS = lumaN + lumaS;\n    float lumaWE = lumaW + lumaE;\n    float subpixRcpRange = 1.0/range;\n    float subpixNSWE = lumaNS + lumaWE;\n    float edgeHorz1 = (-2.0 * lumaM) + lumaNS;\n    float edgeVert1 = (-2.0 * lumaM) + lumaWE;\n\n    float lumaNESE = lumaNE + lumaSE;\n    float lumaNWNE = lumaNW + lumaNE;\n    float edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\n    float edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\n\n    float lumaNWSW = lumaNW + lumaSW;\n    float lumaSWSE = lumaSW + lumaSE;\n    float edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\n    float edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\n    float edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\n    float edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\n    float edgeHorz = abs(edgeHorz3) + edgeHorz4;\n    float edgeVert = abs(edgeVert3) + edgeVert4;\n\n    float subpixNWSWNESE = lumaNWSW + lumaNESE;\n    float lengthSign = fxaaQualityRcpFrame.x;\n    bool horzSpan = edgeHorz >= edgeVert;\n    float subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\n\n    if (horzSpan) {\n        lengthSign = fxaaQualityRcpFrame.y;\n    } else {\n        lumaN = lumaW;\n        lumaS = lumaE;\n    }\n    float subpixB = (subpixA * (1.0/12.0)) - lumaM;\n\n    float gradientN = lumaN - lumaM;\n    float gradientS = lumaS - lumaM;\n    float lumaNN = lumaN + lumaM;\n    float lumaSS = lumaS + lumaM;\n    bool pairN = abs(gradientN) >= abs(gradientS);\n    float gradient = max(abs(gradientN), abs(gradientS));\n    if (pairN) {\n        lengthSign = -lengthSign;\n    } else {\n        lumaNN = lumaSS;\n    }\n    float subpixC = clamp(abs(subpixB) * subpixRcpRange, 0.0, 1.0);\n\n    vec2 posB = posM;\n    vec2 offNP;\n\n    vec2 offHM;\n    if (horzSpan) {\n        offNP = vec2(fxaaQualityRcpFrame.x, 0.0);\n        offHM = vec2(0.0, lengthSign);\n    } else {\n        offNP = vec2(0.0, fxaaQualityRcpFrame.y);\n        offHM = vec2(lengthSign, 0.0);\n    }\n\n    vec2 posN = posB - offNP * 2.;\n    vec2 posP = posB + offNP * 2.;\n\n    float subpixD = ((-2.0)*subpixC) + 3.0;\n    float lumaEndN = luma(\n        mix(\n            texture2D(tex, posN),\n            texture2D(tex, posN + offHM),\n            0.5\n        )\n    );\n    float subpixE = subpixC * subpixC;\n    float lumaEndP = luma(\n        mix(\n            texture2D(tex, posP),\n            texture2D(tex, posP + offHM),\n            0.5\n        )\n    );\n\n    float gradientScaled = gradient * 0.25;\n    float lumaMM = lumaM - lumaNN * 0.5;\n    float subpixF = subpixD * subpixE;\n    bool lumaMLTZero = lumaMM < 0.0;\n\n    lumaEndN -= lumaNN * 0.5;\n    lumaEndP -= lumaNN * 0.5;\n    bool doneN = abs(lumaEndN) >= gradientScaled;\n    bool doneP = abs(lumaEndP) >= gradientScaled;\n    if (!doneN) {\n        posN -= offNP * 3.0;\n    }\n    bool doneNP = (!doneN) || (!doneP);\n    if (!doneP) {\n        posP += offNP * 3.0;\n    }\n\n    if (doneNP) {\n        if (!doneN) {\n            lumaEndN = luma(\n                mix(\n                    texture2D(tex, posN),\n                    texture2D(tex, posN + offHM),\n                    0.5\n                )\n            );\n            lumaEndN = lumaEndN - lumaNN * 0.5;\n        }\n        if (!doneP) {\n            lumaEndP = luma(\n                mix(\n                    texture2D(tex, posP.xy),\n                    texture2D(tex, posP.xy + offHM),\n                    0.5\n                )\n            );\n            lumaEndP = lumaEndP - lumaNN * 0.5;\n        }\n        doneN = abs(lumaEndN) >= gradientScaled;\n        doneP = abs(lumaEndP) >= gradientScaled;\n        if (!doneN) {\n            posN -= offNP * 12.0;\n        }\n        if (!doneP) {\n            posP += offNP * 12.0;\n        }\n    }\n    float dstN = posM.x - posN.x;\n    float dstP = posP.x - posM.x;\n    if (!horzSpan) {\n        dstN = posM.y - posN.y;\n        dstP = posP.y - posM.y;\n    }\n    bool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\n    float spanLength = (dstP + dstN);\n    bool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\n    float spanLengthRcp = 1.0/spanLength;\n    bool directionN = dstN < dstP;\n    float dst = min(dstN, dstP);\n    bool goodSpan = directionN ? goodSpanN : goodSpanP;\n    float subpixG = subpixF * subpixF;\n    float pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\n    float subpixH = subpixG * fxaaQualitySubpix;\n    float pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\n    float pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\n    vec4 color;\n    float factor = pixelOffsetSubpix;\n    if (horzSpan) {\n        color = mix(\n            texture2D(tex, posM),\n            texture2D(tex, posM + vec2(0.0, lengthSign)),\n            factor\n        );\n    } else {\n        color = mix(\n            texture2D(tex, posM),\n            texture2D(tex, posM + vec2(lengthSign, 0.0)),\n            factor\n        );\n    }\n\n    return color;\n}\n\nvoid main() {\n    vec2 pos = gl_FragCoord.xy * pixelSize;\n    vec4 color = fxaa(\n        pos,\n        texture,\n        pixelSize,\n        FXAA_QUALITY_SUBPIX,\n        FXAA_QUALITY_EDGE_THRESHOLD,\n        FXAA_QUALITY_EDGE_THRESHOLD_MIN\n    );\n\n    // If color.a is less than one, then the color has been blended with a black background before.\n    // An original color of transparent objects is vec4(color.xyz / color.a, color.a).\n    // We have to blend an original color with background pattern.\n    // color.a can be too close to zero. Check it.\n    if (color.a > EPSILON) {\n        color.xyz /= color.a;\n    }\n    gl_FragColor = color;\n}\n"

/***/ }),
/* 179 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__gl_renderer__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__state__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__util_event_emitter__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__shaders_quad_vert__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__shaders_quad_vert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__shaders_quad_vert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__shaders_background_frag__ = __webpack_require__(180);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__shaders_background_frag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4__shaders_background_frag__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__util_hd__ = __webpack_require__(10);






const STATE = new __WEBPACK_IMPORTED_MODULE_1__state__["c" /* default */]({
    depthTest: true,
    depthFunc: 518 /* GREATER_OR_EQUAL */
});
/**
 * Fills map's canvas with background pattern on regions that have no data yet.
 */
class BackgroundRenderUnit extends __WEBPACK_IMPORTED_MODULE_0__gl_renderer__["a" /* GlRenderer */] {
    constructor(context) {
        const program = context.createProgram(__WEBPACK_IMPORTED_MODULE_3__shaders_quad_vert___default.a, __WEBPACK_IMPORTED_MODULE_4__shaders_background_frag___default.a, {
            attribMap: {
                vertexPosition: 0 /* POSITION */,
                vertexUv: 4 /* UV */
            }
        });
        super(context, STATE, program);
        context.bindProgram(program);
        program.setScalarUniform('zIndex', -1);
        this.onUpdate = new __WEBPACK_IMPORTED_MODULE_2__util_event_emitter__["b" /* VoidEventEmitter */]();
    }
    _render() {
        this._context.bindQuadVao();
        this._context.drawQuad();
    }
    _prepareProgram(program) {
        super._prepareProgram(program);
        program.setScalarUniform('dpr', Object(__WEBPACK_IMPORTED_MODULE_5__util_hd__["a" /* default */])());
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = BackgroundRenderUnit;



/***/ }),
/* 180 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nvoid main() {\n    // Background color should match main map layer color.\n    gl_FragColor = vec4(0.98, 0.97, 0.94, 1);\n}\n"

/***/ }),
/* 181 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__list_render_unit__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__state__ = __webpack_require__(0);


const DEPTH_CLEAR_STATE = new __WEBPACK_IMPORTED_MODULE_1__state__["c" /* default */]({
    depthTest: true,
    clearDepth: 0
});
class LayerRenderUnit extends __WEBPACK_IMPORTED_MODULE_0__list_render_unit__["a" /* default */] {
    constructor(context, depthClearStrategy = 0 /* NO_CLEAR */) {
        super();
        this._depthClearStrategy = depthClearStrategy;
        this._context = context;
    }
    render(target, ...args) {
        if (this._depthClearStrategy === 1 /* BEFORE_RENDER */) {
            this._context.bindRenderState(DEPTH_CLEAR_STATE);
            this._context.bindRenderTarget(target);
            this._context.clearCurrentTarget(256 /* DEPTH_BUFFER_BIT */);
        }
        super.render(target, ...args);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = LayerRenderUnit;



/***/ }),
/* 182 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__render_state__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__render_memory_count_vertices__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shaders_reset_removed_vert__ = __webpack_require__(183);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__shaders_reset_removed_vert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__shaders_reset_removed_vert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__shaders_reset_removed_frag__ = __webpack_require__(184);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__shaders_reset_removed_frag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__shaders_reset_removed_frag__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__render_gl_renderer__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__render_primitives_primitive_batch__ = __webpack_require__(44);






class CollidingPrimitivesResetRemovedRenderer extends __WEBPACK_IMPORTED_MODULE_4__render_gl_renderer__["a" /* GlRenderer */] {
    constructor(context, primitiveProvider) {
        const program = context.createProgram(__WEBPACK_IMPORTED_MODULE_2__shaders_reset_removed_vert___default.a, __WEBPACK_IMPORTED_MODULE_3__shaders_reset_removed_frag___default.a, {
            attribMap: {
                vertexPosHigh: 0 /* POSITION_HIGH */,
                vertexId: 2 /* ID */
            }
        });
        super(context, new __WEBPACK_IMPORTED_MODULE_0__render_state__["c" /* default */](), program);
        this._primitiveProvider = primitiveProvider;
        context.bindProgram(program);
        program.setIntScalarUniform('prevVisibility', 0);
    }
    _render() {
        const primitives = this._primitiveProvider.primitives;
        for (const memoryBatch of Object(__WEBPACK_IMPORTED_MODULE_5__render_primitives_primitive_batch__["a" /* batchPrimitives */])(primitives)) {
            this._context.bindVao(memoryBatch.page.vao);
            this._context.drawIndexedMesh(memoryBatch.indexByteOffset, Object(__WEBPACK_IMPORTED_MODULE_1__render_memory_count_vertices__["a" /* countIndices */])(memoryBatch.indexByteLength, memoryBatch.page.indexType), 0 /* POINTS */);
        }
    }
    _prepareProgram(program, prevVisibility, idHalfPxSize) {
        super._prepareProgram(program, prevVisibility, idHalfPxSize);
        this._context.bindTextureUnit(0);
        this._context.bindTexture(prevVisibility);
        program.setVector2Uniform('idHalfPxSize', idHalfPxSize);
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = CollidingPrimitivesResetRemovedRenderer;



/***/ }),
/* 183 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nattribute vec2 vertexPosHigh;\nattribute vec2 vertexId;\n\nuniform sampler2D prevVisibility;\nuniform vec2 idHalfPxSize;\n\nvarying lowp vec4 visibilityValue;\n\nvoid main() {\n    vec2 idTexCoordinates = vertexId + idHalfPxSize;\n    vec4 idWindowCoordinates = vec4(idTexCoordinates * 2.0 - 1.0, 0, 1);\n    gl_Position = idWindowCoordinates;\n    gl_PointSize = 1.0 + vertexPosHigh.x * 0.0;\n\n    visibilityValue = texture2D(prevVisibility, idTexCoordinates);\n}\n"

/***/ }),
/* 184 */
/***/ (function(module, exports) {

module.exports = "#version 100\n#define GLSLIFY 1\n\nvarying lowp vec4 visibilityValue;\n\nvoid main() {\n    gl_FragColor = visibilityValue;\n}\n"

/***/ }),
/* 185 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__util_event_emitter__ = __webpack_require__(2);

const MAX_FRAME_TIME_COUNT = 100;
class RenderLoop {
    /**
     * Create a new render loop, but doesn't schedule any animation frames.
     */
    constructor() {
        this.onFrameTimesFull = new __WEBPACK_IMPORTED_MODULE_0__util_event_emitter__["a" /* EventEmitter */]();
        this.onBeforeRender = new __WEBPACK_IMPORTED_MODULE_0__util_event_emitter__["b" /* VoidEventEmitter */]();
        this.onRender = new __WEBPACK_IMPORTED_MODULE_0__util_event_emitter__["b" /* VoidEventEmitter */]();
        this._isRunning = this._updateIsRequested = false;
        this._lastFrameTime = 0;
        this._frameTimes = new Array(MAX_FRAME_TIME_COUNT);
        this._frameTimes.fill(0);
        this._nextFrameTimeIdx = 0;
    }
    /**
     * @returns Whether the loop is running a chain of consecutive animation
     *      frames or not.
     */
    get isActive() {
        return this._isRunning;
    }
    /**
     * Starts a chain of consecutive animation frames.
     */
    start() {
        this._isRunning = true;
        this._requestFrame();
    }
    /**
     * Stops previously started chain of consecutive animation frames. If an
     * update was requested before stopping, one more animation frame will be
     * fired.
     */
    stop() {
        if (this._isRunning) {
            this._isRunning = false;
            if (!this._updateIsRequested) {
                this._cancelFrame();
            }
        }
    }
    /**
     * Schedules a single
     */
    update() {
        this._updateIsRequested = true;
        this._requestFrame();
    }
    /**
     * Stops all the rendering activities.
     */
    destroy() {
        this._cancelFrame();
    }
    _renderFrame(time) {
        this._rafId = 0;
        this._updateIsRequested = false;
        this.onBeforeRender.fire();
        this.onRender.fire();
        if (this._lastFrameTime > 0) {
            const nextFrameTimeIdx = this._nextFrameTimeIdx;
            this._frameTimes[nextFrameTimeIdx] = time - this._lastFrameTime;
            this._nextFrameTimeIdx = (nextFrameTimeIdx + 1) % MAX_FRAME_TIME_COUNT;
            // Next time index being 0 means that the array is full and it's
            // time to notify listeners about that before we start to rewrite
            // values.
            if (this._nextFrameTimeIdx === 0) {
                this.onFrameTimesFull.fire(this._frameTimes);
            }
        }
        if (this._isRunning) {
            this._lastFrameTime = time;
            this._requestFrame();
        }
        else {
            // If we don't schedule next frame immediately there's no way to
            // tell that it will be consecutive to the current one. Hence there's
            // no point in recording a time delta in it.
            this._lastFrameTime = 0;
        }
    }
    _requestFrame() {
        if (!this._rafId) {
            this._rafId = requestAnimationFrame(((time) => this._renderFrame(time)));
        }
    }
    _cancelFrame() {
        cancelAnimationFrame(this._rafId);
        this._rafId = 0;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = RenderLoop;



/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYWFjNzUzYTg3NTUzNjMyNjQ4NzAiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9zdGF0ZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvbWF0aC92ZWN0b3IyLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL2V2ZW50X2VtaXR0ZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9hdHRyaWJfbWFwcGluZy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL2dsX3JlbmRlcmVyLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy93b3JsZF9wcmltaXRpdmVfcmVuZGVyX3VuaXQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvYnVmZmVyX3dyaXRlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL3JlbmRlcmFibGVfcHJpbWl0aXZlLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL2l0ZXJhYmxlLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9tYXRoL3NjYWxhci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9oZC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9jb2xvci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvbWF0aC92ZWN0b3IzLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL2dwdXR5cGVzLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL2FycmF5LnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvbWVtb3J5L2NvdW50X3ZlcnRpY2VzLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9hZGFwdGVycy90aWxlX2Jhc2VkX2FkYXB0ZXIvdGlsZV9pZC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC93b3JrZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvc3RhdC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9jb21wYXJhdG9yLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL3JlZl9jb3VudGVkLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9hZGFwdGVycy92ZWN0b3JfYXBpL3ByaW1pdGl2ZV9tYW5hZ2VyL3JlbmRlcmFibGVfcHJpbWl0aXZlX21hbmFnZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL3BvbHlnb24vcG9seWdvbl9yZW5kZXJfdW5pdC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL2xpc3RfcmVuZGVyX3VuaXQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL21hdGgvbWF0cml4NC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9mdXp6eV9lcXVhbC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC91bmlxdWVfaWQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9tZW1vcnkvc3ViX2NodW5rLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9mb250L2RmX2ZvbnQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3ByaW1pdGl2ZS9tb2RlbC9tb2RlbF9idWZmZXJfd3JpdGVyLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL3pfaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3ByaW1pdGl2ZS9wb2x5Z29uL3RleHR1cmVkX3BvbHlnb25fYXR0cmlidXRlX21hcHBpbmcudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3ByaW1pdGl2ZS9wb2x5Z29uL3BvbHlnb25fYXR0cmlidXRlX21hcHBpbmcudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3ByaW1pdGl2ZS9wb2x5bGluZS9wb2x5bGluZV9hdHRyaWJ1dGVfbWFwcGluZy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdmVjdG9yX2FwaS93b3JrZXIvdGlsZV9wcm92aWRlcl93b3JrZXJfbWVzc2FnZXMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvcHJpb3JpdHlfcXVldWUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3ByaW1pdGl2ZS9wb2x5bGluZS9yZW5kZXJhYmxlX3BvbHlsaW5lLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9wcmltaXRpdmUvbW9kZWwvcmVuZGVyYWJsZV9tb2RlbC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdmVjdG9yX2FwaS9wcmltaXRpdmVfbWFuYWdlci9wcmltaXRpdmVfbWFuYWdlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvcHJpbWl0aXZlX3NldF9zdG9yYWdlLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9kaXNhcHBlYXJpbmdfcHJpbWl0aXZlX3NldF9zdG9yYWdlLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL2RlbGVnYXRvci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdmlzaWJpbGl0eS9wcmltaXRpdmVzL2xhYmVsL3NoYWRlci9jb2xvcl9pZC5mcmFnIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS92aXNpYmlsaXR5L3ByaW1pdGl2ZXMvbGFiZWwvY29sb3JfaWRfbGFiZWxfcmVuZGVyZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL3ByaW1pdGl2ZV9iYXRjaC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvbGFiZWwvcG9pbnRfbGFiZWxfcmVuZGVyX3VuaXQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL2xhYmVsL3NoYWRlci9kZl90ZXh0LmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL2xhYmVsL2xhYmVsX3JlbmRlcl91bml0LnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9sYWJlbC9jdXJ2ZWRfbGFiZWxfcmVuZGVyX3VuaXQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL3BvbHlsaW5lL2Jhc2VfcG9seWxpbmVfcmVuZGVyX3VuaXQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvYWxsb2NhdG9yLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvdXRpbC9jYW1lcmFfcG9zaXRpb24udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9zaGFkZXJzL3F1YWQudmVydCIsIndlYnBhY2s6Ly8vLi90b29scy9zdGFuZC9pbmRleC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL2NvbnRleHQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvcG93X29mXzIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9nbC9idWZmZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9nbC9mcmFtZWJ1ZmZlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL2dsL3Byb2dyYW0udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9nbC9yZW5kZXJidWZmZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9jYXBhYmlsaXRpZXMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9nbC90ZXh0dXJlLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvZ2wvdmFvLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9jYW1lcmEudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvcmFkX2RlZy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9vcHRpb25zLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9tYXRoL21hdHJpeDMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2FkYXB0ZXJzL3ZlY3Rvcl9hcGkvYWRhcHRlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdGlsZV9iYXNlZF9hZGFwdGVyL2FkYXB0ZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2FkYXB0ZXJzL2FkYXB0ZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvZnVuY3Rpb24udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2FkYXB0ZXJzL3RpbGVfYmFzZWRfYWRhcHRlci91dGlsL3RpbGVfc3lzdGVtLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9hZGFwdGVycy90aWxlX2Jhc2VkX2FkYXB0ZXIvdXRpbC92aXNpYmxlX3RpbGUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2FkYXB0ZXJzL3RpbGVfYmFzZWRfYWRhcHRlci9iZWx0X3RpbGVzLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9wcmltaXRpdmUvaWNvbi9pY29uX2J1ZmZlcl93cml0ZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2JpbGxib2FyZC9pZGVudGlmaWVkX2ltYWdlX2F0bGFzX21hbmFnZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2ZvbnQvZm9udC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdmVjdG9yX2FwaS9hcGlfaW1hZ2VfcHJvdmlkZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2JpbGxib2FyZC9pbWFnZV9wcm92aWRlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdmVjdG9yX2FwaS91dGlsL2hvc3RzLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9wcmltaXRpdmUvcG9seWxpbmUvdGV4dHVyZWRfcG9seWxpbmVfYnVmZmVyX3dyaXRlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL3BvbHlsaW5lL3RleHR1cmVkX3BvbHlsaW5lX2dlb21ldHJ5LnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9iaWxsYm9hcmQvaW1hZ2VfbWFuYWdlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL3BvbHlnb24vdGV4dHVyZWRfcG9seWdvbl9idWZmZXJfcmV3aXRlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9idWZmZXJfcmV3cml0ZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3ByaW1pdGl2ZS9iaWxsYm9hcmRfcmVjdGFuZ2xlL2F0dHJpYnV0ZV9tYXBwaW5nLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9wcmltaXRpdmUvbGFiZWwvcG9pbnRfbGFiZWxfYXR0cmlidXRlX21hcHBpbmcudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3ByaW1pdGl2ZS9sYWJlbC9jdXJ2ZWRfbGFiZWxfYXR0cmlidXRlX21hcHBpbmcudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2FkYXB0ZXJzL3ZlY3Rvcl9hcGkvd29ya2VyL3RpbGVfcHJvdmlkZXJfd29ya2VyX2NsaWVudC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdmVjdG9yX2FwaS93b3JrZXIvcHJpbWl0aXZlX3Byb3ZpZGVyX3dvcmtlcl9tZXNzYWdlcy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL3BvbHlnb24vdHJhbnNwYXJlbnRfcG9seWdvbl9hdHRyaWJ1dGVfbWFwcGluZy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9pZGxlX3Rhc2tfcXVldWUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvYmluYXJ5X2hlYXAudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3ByaW1pdGl2ZS9wb2x5Z29uL3JlbmRlcmFibGVfcG9seWdvbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL3BvbHlnb24vcmVuZGVyYWJsZV90ZXh0dXJlZF9wb2x5Z29uLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9wcmltaXRpdmUvcG9seWxpbmUvcmVuZGVyYWJsZV90ZXh0dXJlZF9wb2x5bGluZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdmVjdG9yX2FwaS90aWxlX2RhdGEudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2FkYXB0ZXJzL3ZlY3Rvcl9hcGkvcHJpbWl0aXZlX21hbmFnZXIvcG9seWdvbl9tYW5hZ2VyLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9kZWxheWVkX2Rpc2FwcGVhcmluZ19wcmltaXRpdmVfc2V0X3N0b3JhZ2UudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2FkYXB0ZXJzL3ZlY3Rvcl9hcGkvcHJpbWl0aXZlX21hbmFnZXIvem9vbV9maWx0ZXJhYmxlX3ByaW1pdGl2ZV9tYW5hZ2VyLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9hZGFwdGVycy92ZWN0b3JfYXBpL3ByaW1pdGl2ZV9tYW5hZ2VyL2V4dGVybmFsX21lc2hfbWFuYWdlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL2JpbGxib2FyZF9yZWN0YW5nbGUvcmVuZGVyYWJsZV9iaWxsYm9hcmRfcmVjdGFuZ2xlLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9hZGFwdGVycy92ZWN0b3JfYXBpL3ByaW1pdGl2ZS96b29tX3Jlc3RyaWN0ZWRfbGFiZWwudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3ByaW1pdGl2ZS9sYWJlbC9yZW5kZXJhYmxlX2xhYmVsLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9hZGFwdGVycy92ZWN0b3JfYXBpL3ByaW1pdGl2ZS96b29tX3Jlc3RyaWN0ZWRfaWNvbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL2ljb24vcmVuZGVyYWJsZV9pY29uLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9wcmltaXRpdmUvaW1hZ2UvcmVuZGVyYWJsZV9pbWFnZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL3RleHR1cmVkX3JlbmRlcmFibGVfcHJpbWl0aXZlLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL3Rhc2tfcXVldWUudHMiLCJ3ZWJwYWNrOi8vLy4vdG9vbHMvc3RhbmQvY2FtZXJhX3N0dWZmLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS92aXNpYmlsaXR5L3ByaW1pdGl2ZXMvbGFiZWwvY29sb3JfaWRfcG9pbnRfbGFiZWxfcmVuZGVyZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3Zpc2liaWxpdHkvcHJpbWl0aXZlcy9sYWJlbC9zaGFkZXIvcG9pbnRfbGFiZWwudmVydCIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdmlzaWJpbGl0eS9wcmltaXRpdmVzL2NvbGxpZGluZ19wcmltaXRpdmVfY29sb3JfaWRfcmVuZGVyZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9tZW1vcnkvcmVsYXRpdmVfbG9jYXRpb24udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL2xhYmVsL3NoYWRlci9wb2ludF9sYWJlbC52ZXJ0Iiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9iaWxsYm9hcmRfcmVjdGFuZ2xlL2JpbGxib2FyZF9yZWN0YW5nbGVfcmVuZGVyX3VuaXQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL2JpbGxib2FyZF9yZWN0YW5nbGUvc2hhZGVyL2JpbGxib2FyZF9yZWN0YW5nbGUudmVydCIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvYmlsbGJvYXJkX3JlY3RhbmdsZS9zaGFkZXIvYmlsbGJvYXJkX3JlY3RhbmdsZS5mcmFnIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS92aXNpYmlsaXR5L3ByaW1pdGl2ZXMvbGFiZWwvY29sb3JfaWRfY3VydmVkX2xhYmVsX3JlbmRlcmVyLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS92aXNpYmlsaXR5L3ByaW1pdGl2ZXMvbGFiZWwvc2hhZGVyL2N1cnZlZF9sYWJlbC52ZXJ0Iiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9sYWJlbC9zaGFkZXIvY3VydmVkX2xhYmVsLnZlcnQiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL2ljb24vaWNvbl9yZW5kZXJfdW5pdC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvaWNvbi9zaGFkZXIvaWNvbi52ZXJ0Iiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9pY29uL3NoYWRlci9pY29uLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL2ltYWdlL2ltYWdlX3JlbmRlcl91bml0LnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9pbWFnZS9zaGFkZXIvaW1hZ2UudmVydCIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvaW1hZ2Uvc2hhZGVyL2ltYWdlLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL21vZGVsL21vZGVsX3JlbmRlcl91bml0LnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9tb2RlbC9zaGFkZXIvbW9kZWwudmVydCIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvbW9kZWwvc2hhZGVyL21vZGVsLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL292ZXJsYXkvb3ZlcmxheV9yZW5kZXJlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvb3ZlcmxheS9zaGFkZXIvb3ZlcmxheS52ZXJ0Iiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9vdmVybGF5L3NoYWRlci9vdmVybGF5LmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL3BvbHlsaW5lL3RleHR1cmVkX3BvbHlsaW5lX3JlbmRlcl91bml0LnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9wb2x5bGluZS9zaGFkZXIvdGV4dHVyZWRfcG9seWxpbmUudmVydCIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvcG9seWxpbmUvc2hhZGVyL3RleHR1cmVkX3BvbHlsaW5lLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL3BvbHlsaW5lL3BvbHlsaW5lX3JlbmRlcl91bml0LnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9wcmltaXRpdmUvcG9seWxpbmUvcG9seWxpbmVfYnVmZmVyX3dyaXRlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvcG9seWxpbmUvc2hhZGVyL3BvbHlsaW5lLnZlcnQiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL3BvbHlsaW5lL3NoYWRlci9wb2x5bGluZS5mcmFnIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9wb2x5Z29uL3RleHR1cmVkX3BvbHlnb25fcmVuZGVyX3VuaXQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL3BvbHlnb24vc2hhZGVyL3RleHR1cmVkX3BvbHlnb24udmVydCIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvcG9seWdvbi9zaGFkZXIvdGV4dHVyZWRfcG9seWdvbi5mcmFnIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9wb2x5Z29uL3RyYW5zcGFyZW50X3BvbHlnb25fcmVuZGVyX3VuaXQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL3BvbHlnb24vc2hhZGVyL3BvbHlnb24udmVydCIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvcG9seWdvbi9zaGFkZXIvcG9seWdvbi5mcmFnIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9tYXBfZW5naW5lLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9lbmdpbmUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9mb250L3JlbmRlcmFibGVfZGZfZ2x5cGhfYXRsYXMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2ZvbnQvZGZfZ2x5cGhfYXRsYXMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2ZvbnQvZGZfZm9udF9yZWdpc3RyeS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvZm9udC9mb250X3JlZ2lzdHJ5LnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvYmlsbGJvYXJkL3JlbmRlcmFibGVfaW1hZ2VfYXRsYXMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2JpbGxib2FyZC9pbWFnZV9hdGxhcy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9hbGxvY2F0b3JfMmQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvYmluYXJ5X3RyZWUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvbGlua2VkX3NldC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdmlzaWJpbGl0eS92aXNpYmlsaXR5X21hbmFnZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3Zpc2liaWxpdHkvZ3JpZF9zYW1wbGVyX2J1ZmZlcl93cml0ZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3Zpc2liaWxpdHkvZ3JpZF9yZW5kZXJlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdmlzaWJpbGl0eS92aXNpYmlsaXR5X3Jlc29sdXRpb25fc3RlcHMvcmVzZXRfcmVtb3ZlZF9wcmltaXRpdmVzLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS92aXNpYmlsaXR5L3Zpc2liaWxpdHlfcmVzb2x1dGlvbl9zdGVwcy9mYWRlb3V0X2FsbC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdmlzaWJpbGl0eS92aXNpYmlsaXR5X3Jlc29sdXRpb25fc3RlcHMvc2hhZGVycy9mYWRlb3V0X2FsbC52ZXJ0Iiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS92aXNpYmlsaXR5L3Zpc2liaWxpdHlfcmVzb2x1dGlvbl9zdGVwcy9zaGFkZXJzL2ZhZGVvdXRfYWxsLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3Zpc2liaWxpdHkvaWRfc2FtcGxlcl9idWZmZXJfd3JpdGVyLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS92aXNpYmlsaXR5L3Zpc2liaWxpdHlfcmVzb2x1dGlvbl9zdGVwcy9mYWRlaW5fdmlzaWJsZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdmlzaWJpbGl0eS92aXNpYmlsaXR5X3Jlc29sdXRpb25fc3RlcHMvc2hhZGVycy9mYWRlaW5fdmlzaWJsZS52ZXJ0Iiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS92aXNpYmlsaXR5L3Zpc2liaWxpdHlfcmVzb2x1dGlvbl9zdGVwcy9zaGFkZXJzL2ZhZGVpbl92aXNpYmxlLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3Zpc2liaWxpdHkvdmlzaWJpbGl0eV9yZXNvbHV0aW9uX3N0ZXBzL2ZhZGVvdXRfb3ZlcmxhcHBlZC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdmlzaWJpbGl0eS92aXNpYmlsaXR5X3Jlc29sdXRpb25fc3RlcHMvc2hhZGVycy9mYWRlb3V0X292ZXJsYXBwZWQudmVydCIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdmlzaWJpbGl0eS92aXNpYmlsaXR5X3Jlc29sdXRpb25fc3RlcHMvc2hhZGVycy9mYWRlb3V0X292ZXJsYXBwZWQuZnJhZyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9jYXJ0ZXNpYW5fZ3JpZC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9tZWRpYW5fZmlsdGVyLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvbWFpbl9yZW5kZXJfdW5pdC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL21lbW9yeS9tYW5hZ2VyLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvbWVtb3J5L3BhZ2UudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9tZW1vcnkvY2h1bmsudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9meGFhX3JlbmRlcl91bml0LnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvc2hhZGVycy9meGFhLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9iYWNrZ3JvdW5kX3JlbmRlcl91bml0LnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvc2hhZGVycy9iYWNrZ3JvdW5kLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9sYXllcl9yZW5kZXJfdW5pdC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdmlzaWJpbGl0eS9wcmltaXRpdmVzL2NvbGxpZGluZ19wcmltaXRpdmVfcmVzZXRfcmVtb3ZlZF9yZW5kZXJlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdmlzaWJpbGl0eS9wcmltaXRpdmVzL3NoYWRlcnMvcmVzZXRfcmVtb3ZlZC52ZXJ0Iiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS92aXNpYmlsaXR5L3ByaW1pdGl2ZXMvc2hhZGVycy9yZXNldF9yZW1vdmVkLmZyYWciLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlcl9sb29wLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7QUM3REE7QUFBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFBQTtBQUFBO0FBQ0s7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUFBO0FBQUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMkRBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUFBO0FBQUE7Ozs7Ozs7O0FDMUZEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQTZFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZO0FBQ1o7QUFDTywwQkFBMEI7QUFBQTtBQUFBO0FBQzFCLG9CQUFvQjtBQUFBO0FBQUE7QUFDcEIsZ0NBQWdDO0FBQUE7QUFBQTtBQUNoQyxpQ0FBaUM7QUFBQTtBQUFBO0FBQ2pDLGdDQUFnQztBQUFBO0FBQUE7QUFDaEMsaUNBQWlDO0FBQUE7QUFBQTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sMkNBQTJDLDRFQUFpQjtBQUNuRSxZQUFZLDBFQUFtQjtBQUMvQixRQUFRLDBFQUFtQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQUE7QUFBQTtBQUNLO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQUE7QUFBQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sNkNBQTZDLHFDQUFxQztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QyxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0Es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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxzQkFBc0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9CQUFvQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDJEQUFHO0FBQ2xCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdFQUFhO0FBQ3JDLHdCQUF3Qix3RUFBYTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQUE7QUFBQTs7Ozs7Ozs7QUMzZUQ7QUFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ2Usa0NBQWtDLGtFQUFnQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFBQTtBQUFBOzs7Ozs7OztBQ1pEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLHdEQUF3RCxxQkFBcUI7QUFDN0U7QUFDQTtBQUNBOzs7Ozs7OztBQ3hHQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBOzs7Ozs7OztBQ2hEQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2U7QUFDZjtBQUNBOzs7Ozs7OztBQ1RBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFPLHdDQUF3QztBQUFBO0FBQUE7QUFDeEMsNkNBQTZDO0FBQUE7QUFBQTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBOzs7Ozs7OztBQ2pFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBcUM7QUFDd0M7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsWUFBWTtBQUNaO0FBQ08sK0JBQStCO0FBQUE7QUFBQTtBQUMvQixtQ0FBbUM7QUFBQTtBQUFBO0FBQ25DLG9DQUFvQztBQUFBO0FBQUE7QUFDcEMsbUNBQW1DO0FBQUE7QUFBQTtBQUNuQyxvQ0FBb0M7QUFBQTtBQUFBO0FBQ3BDLG1DQUFtQztBQUFBO0FBQUE7QUFDbkMsb0NBQW9DO0FBQUE7QUFBQTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sMkNBQTJDLDRFQUFpQjtBQUNuRSxZQUFZLDBFQUFtQjtBQUMvQixRQUFRLDBFQUFtQjtBQUMzQixRQUFRLDBFQUFtQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLEVBQUU7QUFBQTtBQUFBO0FBQ0s7QUFDUDtBQUNBO0FBQ0EsRUFBRTtBQUFBO0FBQUE7QUFDSztBQUNQO0FBQ0E7QUFDQSxFQUFFO0FBQUE7QUFBQTtBQUNLO0FBQ1A7QUFDQTtBQUNBLEVBQUU7QUFBQTtBQUFBO0FBQ0s7QUFDUDtBQUNBO0FBQ0EsRUFBRTtBQUFBO0FBQUE7QUFDSztBQUNQO0FBQ0E7QUFDQSxFQUFFO0FBQUE7QUFBQTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdURBQWEsQ0FBQywwREFBZ0I7QUFDOUM7QUFDQTs7Ozs7Ozs7QUNuV0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7Ozs7Ozs7O0FDaENBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxvQ0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQUE7QUFBQTs7Ozs7Ozs7QUNuRUQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBcUM7QUFDckM7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUFBO0FBQUE7QUFDSztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUFBO0FBQUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3pEQTtBQUFBLDRDQUE0QztBQUNyQztBQUNQO0FBQ0E7Ozs7Ozs7O0FDSEE7QUFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ08sK0NBQStDLGdGQUFnQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFBQTtBQUFBOzs7Ozs7OztBQzdDSDtBQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDTyxzQ0FBc0MsZ0ZBQWdCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQUE7QUFBQTs7Ozs7Ozs7QUNyQ0g7QUFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ08sdUNBQXVDLGdGQUFnQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx1REFBVztBQUM5QztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDZEQUFjO0FBQzNCO0FBQ0EsWUFBWSx5REFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMkRBQU07QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUFBO0FBQUE7Ozs7Ozs7O0FDbnlCRDtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBOzs7Ozs7OztBQ3BCQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFBQTtBQUFBOzs7Ozs7OztBQ3BERDtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUFBO0FBQUE7Ozs7Ozs7O0FDM0REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2U7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELDZCQUE2QjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFBQTtBQUFBO0FBQ0Q7QUFDQSx5Q0FBeUMsZ0ZBQWdCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNqRkE7QUFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDZCQUE2QixrRUFBZ0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUFBO0FBQUE7QUFDRDtBQUNBO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFBQTtBQUFBOzs7Ozs7OztBQ2xFRDtBQUNBO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUFBO0FBQUE7Ozs7Ozs7O0FDL0ZEO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUFBO0FBQUE7Ozs7Ozs7O0FDcEpEO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUFBO0FBQUE7Ozs7Ozs7O0FDL0hEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBMEM7QUFDSDtBQUNDO0FBQ0E7QUFDQTtBQUM2RTtBQUM1RDtBQUNkO0FBQ2lEO0FBQ3pCO0FBQ007QUFDUTtBQUNQO0FBQzFDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyw4REFBVztBQUM3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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQUE7QUFBQTs7Ozs7OztBQ2hDRCxrRkFBa0YsMEJBQTBCLHFDQUFxQyw0QkFBNEIsc0NBQXNDLGlCQUFpQixzREFBc0QsMEVBQTBFLHdDQUF3QyxpREFBaUQsc0VBQXNFLEdBQUcsRzs7Ozs7O0FDQXRnQix1RkFBdUYsaUJBQWlCLHFDQUFxQyxHQUFHLEc7Ozs7Ozs7QUNBaEo7QUFBc0U7QUFDdEU7QUFDZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHlFQUFZO0FBQ2hELGtDQUFrQyw2RUFBZ0I7QUFDbEQsNEJBQTRCLDZFQUFnQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFBQTtBQUFBIiwiZmlsZSI6ImluZGV4LnRzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gNTMpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIGFhYzc1M2E4NzU1MzYzMjY0ODcwIiwiaW1wb3J0ICogYXMgY29sb3IgZnJvbSAnLi4vdXRpbC9jb2xvcic7XHJcbi8qKlxyXG4gKiBQcmVzZXQgb2YgcmVuZGVyIHN0YXRlIGZvciBPVkVSIGNvbXBvc2l0aW5nLFxyXG4gKiBAc2VlIFQuIFBvcnRlciBhbmQgVC4gRHVmZiwgXCJDb21wb3NpdGluZyBEaWdpdGFsIEltYWdlc1wiLCBQcm9jZWVkaW5ncyBvZlxyXG4gKiAgICAgIFNJR0dSQVBIJzg0LCAxOCAoMTk4NCkuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgQkxFTkRfT1ZFUl9SRU5ERVJfU1RBVEUgPSB7XHJcbiAgICBibGVuZDogdHJ1ZSxcclxuICAgIGJsZW5kRnVuY1NyY1JnYjogNzcwIC8qIFNSQ19BTFBIQSAqLyxcclxuICAgIGJsZW5kRnVuY0RzdFJnYjogNzcxIC8qIE9ORV9NSU5VU19TUkNfQUxQSEEgKi8sXHJcbiAgICBibGVuZEZ1bmNTcmNBbHBoYTogMSAvKiBPTkUgKi8sXHJcbiAgICBibGVuZEZ1bmNEc3RBbHBoYTogNzcxIC8qIE9ORV9NSU5VU19TUkNfQUxQSEEgKi9cclxufTtcclxuZXhwb3J0IGNvbnN0IEJMRU5EX09WRVJfUFJFTVVMVElQTElFRF9BTFBIQV9SRU5ERVJfU1RBVEUgPSB7XHJcbiAgICBibGVuZDogdHJ1ZSxcclxuICAgIGJsZW5kRnVuY1NyY1JnYjogMSAvKiBPTkUgKi8sXHJcbiAgICBibGVuZEZ1bmNEc3RSZ2I6IDc3MSAvKiBPTkVfTUlOVVNfU1JDX0FMUEhBICovLFxyXG4gICAgYmxlbmRGdW5jU3JjQWxwaGE6IDEgLyogT05FICovLFxyXG4gICAgYmxlbmRGdW5jRHN0QWxwaGE6IDc3MSAvKiBPTkVfTUlOVVNfU1JDX0FMUEhBICovXHJcbn07XHJcbi8qKlxyXG4gKiBTdGF0ZSBvZiB0aGUgV2ViR0wgcmVuZGVyaW5nIHBpcGVsaW5lLiBEb2Vzbid0IGluY2x1ZGUgb2JqZWN0IGJpbmRpbmdzIHNpbmNlXHJcbiAqIHRoZSBjb250ZXh0IGhhbmRsZXMgdGhlbS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbmRlclN0YXRlIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyByZW5kZXIgc3RhdGUgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzdGF0ZSBPYmplY3Qgd2l0aCBzdGF0ZSBwcm9wZXJ0aWVzIHRoYXQgdmFsdWVzIGRpZmZlciBmcm9tIGRlZmF1bHRcclxuICAgICAqICAgICAgb25lcy5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoLi4uc3RhdGUpIHtcclxuICAgICAgICB0aGlzLmNsZWFyQ29sb3IgPSBjb2xvci5jcmVhdGUoMCwgMCwgMCwgMCk7XHJcbiAgICAgICAgdGhpcy5jbGVhckRlcHRoID0gMTtcclxuICAgICAgICB0aGlzLmNsZWFyU3RlbmNpbCA9IDA7XHJcbiAgICAgICAgdGhpcy5jb2xvck1hc2tSID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmNvbG9yTWFza0cgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuY29sb3JNYXNrQiA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5jb2xvck1hc2tBbHBoYSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5ibGVuZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuYmxlbmRFcXVhdGlvblJnYiA9IDMyNzc0IC8qIEFERCAqLztcclxuICAgICAgICB0aGlzLmJsZW5kRXF1YXRpb25BbHBoYSA9IDMyNzc0IC8qIEFERCAqLztcclxuICAgICAgICB0aGlzLmJsZW5kRnVuY1NyY1JnYiA9IDEgLyogT05FICovO1xyXG4gICAgICAgIHRoaXMuYmxlbmRGdW5jRHN0UmdiID0gMCAvKiBaRVJPICovO1xyXG4gICAgICAgIHRoaXMuYmxlbmRGdW5jU3JjQWxwaGEgPSAxIC8qIE9ORSAqLztcclxuICAgICAgICB0aGlzLmJsZW5kRnVuY0RzdEFscGhhID0gMCAvKiBaRVJPICovO1xyXG4gICAgICAgIHRoaXMuY3VsbEZhY2UgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmN1bGxGYWNlTW9kZSA9IDEwMjkgLyogQkFDSyAqLztcclxuICAgICAgICB0aGlzLmZyb250RmFjZU1vZGUgPSAyMzA1IC8qIENPVU5URVJDTE9DS1dJU0UgKi87XHJcbiAgICAgICAgdGhpcy5kZXB0aFRlc3QgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmRlcHRoRnVuYyA9IDUxMyAvKiBMRVNTICovO1xyXG4gICAgICAgIHRoaXMuZGVwdGhSYW5nZU5lYXIgPSAwO1xyXG4gICAgICAgIHRoaXMuZGVwdGhSYW5nZUZhciA9IDE7XHJcbiAgICAgICAgdGhpcy5kZXB0aE1hc2sgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuZGl0aGVyID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmRyYXdCdWZmZXJzID0gWzM2MDY0IC8qIENPTE9SX0FUVEFDSE1FTlQwICovXTtcclxuICAgICAgICB0aGlzLnBvbHlnb25PZmZzZXQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnBvbHlnb25PZmZzZXRGYWN0b3IgPSAwO1xyXG4gICAgICAgIHRoaXMucG9seWdvbk9mZnNldFVuaXRzID0gMDtcclxuICAgICAgICB0aGlzLnNhbXBsZUFscGhhVG9Db3ZlcmFnZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuc2FtcGxlQ292ZXJhZ2UgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnNhbXBsZUNvdmVyYWdlVmFsdWUgPSAxO1xyXG4gICAgICAgIHRoaXMuc2FtcGxlQ292ZXJhZ2VJbnZlcnQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnNjaXNzb3JUZXN0ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5zY2lzc29yWCA9IDA7XHJcbiAgICAgICAgdGhpcy5zY2lzc29yWSA9IDA7XHJcbiAgICAgICAgLy8gQWN0dWFsIGRlZmF1bHRzIGFyZW4ndCBrbm93biBoZXJlIHNpbmNlIHRoZXkgZGVwZW5kIHVwb24gY29udGV4dC4gLTEnc1xyXG4gICAgICAgIC8vIGFzIFwiZG8gbm90IGNoYW5nZVwiIHZhbHVlcy5cclxuICAgICAgICB0aGlzLnNjaXNzb3JXaWR0aCA9IC0xO1xyXG4gICAgICAgIHRoaXMuc2Npc3NvckhlaWdodCA9IC0xO1xyXG4gICAgICAgIHRoaXMuc3RlbmNpbFRlc3QgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnN0ZW5jaWxSZWZlcmVuY2UgPSAwO1xyXG4gICAgICAgIHRoaXMuc3RlbmNpbE1hc2sgPSAweGZmO1xyXG4gICAgICAgIHRoaXMuc3RlbmNpbFdyaXRlTWFzayA9IDB4ZmY7XHJcbiAgICAgICAgdGhpcy5zdGVuY2lsRnJvbnRGdW5jID0gNTE5IC8qIEFMV0FZUyAqLztcclxuICAgICAgICB0aGlzLnN0ZW5jaWxGcm9udEZhaWxPcCA9IDc2ODAgLyogS0VFUCAqLztcclxuICAgICAgICB0aGlzLnN0ZW5jaWxGcm9udERlcHRoRmFpbE9wID0gNzY4MCAvKiBLRUVQICovO1xyXG4gICAgICAgIHRoaXMuc3RlbmNpbEZyb250RGVwdGhQYXNzT3AgPSA3NjgwIC8qIEtFRVAgKi87XHJcbiAgICAgICAgdGhpcy5zdGVuY2lsQmFja0Z1bmMgPSA1MTkgLyogQUxXQVlTICovO1xyXG4gICAgICAgIHRoaXMuc3RlbmNpbEJhY2tGYWlsT3AgPSA3NjgwIC8qIEtFRVAgKi87XHJcbiAgICAgICAgdGhpcy5zdGVuY2lsQmFja0RlcHRoRmFpbE9wID0gNzY4MCAvKiBLRUVQICovO1xyXG4gICAgICAgIHRoaXMuc3RlbmNpbEJhY2tEZXB0aFBhc3NPcCA9IDc2ODAgLyogS0VFUCAqLztcclxuICAgICAgICB0aGlzLnZpZXdwb3J0WCA9IDA7XHJcbiAgICAgICAgdGhpcy52aWV3cG9ydFkgPSAwO1xyXG4gICAgICAgIC8vIEFjdHVhbCBkZWZhdWx0cyBhcmVuJ3Qga25vd24gaGVyZSBzaW5jZSB0aGV5IGRlcGVuZCB1cG9uIGNvbnRleHQuIC0xJ3NcclxuICAgICAgICAvLyBhcyBcImRvIG5vdCBjaGFuZ2VcIiB2YWx1ZXMuXHJcbiAgICAgICAgdGhpcy52aWV3cG9ydFdpZHRoID0gLTE7XHJcbiAgICAgICAgdGhpcy52aWV3cG9ydEhlaWdodCA9IC0xO1xyXG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgLi4uc3RhdGUpO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9zdGF0ZS50c1xuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgYXJlRnV6enlFcXVhbFNjYWxhciwgeyBERUZBVUxUX1RPTEVSQU5DRSB9IGZyb20gJy4uL3V0aWwvZnV6enlfZXF1YWwnO1xyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyB2ZWN0b3IgYW5kIGluaXRpYWxpemVzIGl0IHdpdGggZ2l2ZW4gY29tcG9uZW50cy5cclxuICpcclxuICogQHBhcmFtIHggWCBjb21wb25lbnQgb2YgdGhlIHZlY3Rvci5cclxuICogQHBhcmFtIHkgWSBjb21wb25lbnQgb2YgdGhlIHZlY3Rvci5cclxuICogQHJldHVybnMgVGhlIHZlY3Rvci5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoeCwgeSkge1xyXG4gICAgcmV0dXJuIHsgeCwgeSB9O1xyXG59XHJcbmV4cG9ydCBjb25zdCBaRVJPID0gY3JlYXRlKDAsIDApO1xyXG5leHBvcnQgY29uc3QgT1JJR0lOID0gWkVSTztcclxuZXhwb3J0IGNvbnN0IFBPU0lUSVZFX1ggPSBjcmVhdGUoMSwgMCk7XHJcbmV4cG9ydCBjb25zdCBORUdBVElWRV9YID0gY3JlYXRlKC0xLCAwKTtcclxuZXhwb3J0IGNvbnN0IFBPU0lUSVZFX1kgPSBjcmVhdGUoMCwgMSk7XHJcbmV4cG9ydCBjb25zdCBORUdBVElWRV9ZID0gY3JlYXRlKDAsIC0xKTtcclxuLyoqXHJcbiAqIENvcGllcyBhIHZlY3RvciB0byBhbm90aGVyIG9uZS5cclxuICpcclxuICogQHBhcmFtIHNyYyBUaGUgc291cmNlIHZlY3Rvci5cclxuICogQHBhcmFtIGRzdCBUaGUgdmVjdG9yIHRoZSBzb3VyY2UgdmVjdG9yIHdpbGwgYmUgY29waWVkIHRvLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb3B5KHNyYywgZHN0ID0gY3JlYXRlKDAsIDApKSB7XHJcbiAgICBkc3QueCA9IHNyYy54O1xyXG4gICAgZHN0LnkgPSBzcmMueTtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIENoZWNrcyBpZiB0d28gdmVjdG9ycyBhcmUgc3RyaWN0bHkgZXF1YWwgY29tcG9uZW50LXdpc2UuXHJcbiAqXHJcbiAqIEBwYXJhbSB2MSBUaGUgZmlyc3QgdmVjdG9yLlxyXG4gKiBAcGFyYW0gdjIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGFyZUVxdWFsKHYxLCB2Mikge1xyXG4gICAgcmV0dXJuIHYxLnggPT09IHYyLnggJiYgdjEueSA9PT0gdjIueTtcclxufVxyXG4vKipcclxuICogQ2hlY2tzIGlmIHR3byB2ZWN0b3JzIGFyZSBjb2xsaW5lYXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB2MSBUaGUgZmlyc3QgdmVjdG9yLlxyXG4gKiBAcGFyYW0gdjIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmVjdG9ycyBhcmUgY29sbGluZWFyIGFuZCBgZmFsc2VgIG90aGVyd2lzZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBhcmVDb2xsaW5lYXIodjEsIHYyKSB7XHJcbiAgICByZXR1cm4gdjEueCAvIHYyLnggPT09IHYxLnkgLyB2Mi55O1xyXG59XHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgY29ycmVzcG9uZGluZyBjb21wb25lbnRzIG9mIHR3byB2ZWN0b3JzIGFyZSBhbGwgd2l0aGluIGdpdmVuXHJcbiAqIHRvbGVyYW5jZSBmcm9tIGVhY2ggb3RoZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB2MSBUaGUgZmlyc3QgdmVjdG9yLlxyXG4gKiBAcGFyYW0gdjIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSB0b2xlcmFuY2UgVGhlIHRvbGVyYW5jZS5cclxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB2ZWN0b3JzIGFyZSBcImZ1enp5XCIgZXF1YWwgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGFyZUZ1enp5RXF1YWwodjEsIHYyLCB0b2xlcmFuY2UgPSBERUZBVUxUX1RPTEVSQU5DRSkge1xyXG4gICAgcmV0dXJuIChhcmVGdXp6eUVxdWFsU2NhbGFyKHYxLngsIHYyLngsIHRvbGVyYW5jZSkgJiZcclxuICAgICAgICBhcmVGdXp6eUVxdWFsU2NhbGFyKHYxLnksIHYyLnksIHRvbGVyYW5jZSkpO1xyXG59XHJcbi8qKlxyXG4gKiBBZGRzIHR3byB2ZWN0b3IgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGludG8gYSB0aGlyZCBvbmUsIGkuZS4gYGRzdCA9IGEgKyBiYC5cclxuICpcclxuICogQHBhcmFtIGEgVGhlIGZpcnN0IHZlY3Rvci5cclxuICogQHBhcmFtIGIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBkc3QgVGhlIHZlY3RvciB0aGUgcmVzdWx0IHdpbGwgYmUgc3RvcmVkIHRvLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBhZGQoYSwgYiwgZHN0ID0gY3JlYXRlKDAsIDApKSB7XHJcbiAgICBkc3QueCA9IGEueCArIGIueDtcclxuICAgIGRzdC55ID0gYS55ICsgYi55O1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogU3VidHJhY3RzIGEgdmVjdG9yIGZyb20gYW5vdGhlciBvbmUgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IHRvIGEgdGhpcmQgb25lLCBpLmUuXHJcbiAqIGBkc3QgPSBhIC0gYmAuXHJcbiAqXHJcbiAqIEBwYXJhbSBhIFRoZSBtaW51ZW5kIHZlY3Rvci5cclxuICogQHBhcmFtIGIgVGhlIHN1YnRyYWhlbmQgdmVjdG9yLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSB2ZWN0b3IgdGhlIHJlc3VsdCB3aWxsIGJlIHN0b3JlZCB0by5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc3ViKGEsIGIsIGRzdCA9IGNyZWF0ZSgwLCAwKSkge1xyXG4gICAgZHN0LnggPSBhLnggLSBiLng7XHJcbiAgICBkc3QueSA9IGEueSAtIGIueTtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIE11bHRpcGxpZXMgdHdvIHZlY3RvcnMgY29tcG9uZW50LXdpc2UgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGludG8gYSB0aGlyZCBvbmUuXHJcbiAqXHJcbiAqIEBwYXJhbSBhIFRoZSBmaXJzdCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSB2ZWN0b3IgdGhlIHJlc3VsdCB3aWxsIGJlIHN0b3JlZCB0by5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbXVsdihhLCBiLCBkc3QgPSBjcmVhdGUoMCwgMCkpIHtcclxuICAgIGRzdC54ID0gYS54ICogYi54O1xyXG4gICAgZHN0LnkgPSBhLnkgKiBiLnk7XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbi8qKlxyXG4gKiBNdWx0aXBsaWVzIGEgdmVjdG9yIGJ5IGEgc2NhbGFyIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbnRvIGEgdGhpcmQgdmVjdG9yLlxyXG4gKlxyXG4gKiBAcGFyYW0gYSBUaGUgdmVjdG9yLlxyXG4gKiBAcGFyYW0gbiBUaGUgc2NhbGFyLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSB2ZWN0b3IgdGhlIHJlc3VsdCB3aWxsIGJlIHN0b3JlZCB0by5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbXVsbihhLCBuLCBkc3QgPSBjcmVhdGUoMCwgMCkpIHtcclxuICAgIGRzdC54ID0gYS54ICogbjtcclxuICAgIGRzdC55ID0gYS55ICogbjtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIERpdmlkZXMgYSB2ZWN0b3IgYnkgYW5vdGhlciBvbmUgY29tcG9uZW50IHdpc2UgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGludG8gYVxyXG4gKiB0aGlyZCBvbmUuXHJcbiAqXHJcbiAqIEBwYXJhbSBhIFRoZSBkaXZpZGVuZCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBiIFRoZSBkaXZpc29yIHZlY3Rvci5cclxuICogQHBhcmFtIGRzdCBUaGUgdmVjdG9yIHRoZSByZXN1bHQgd2lsbCBiZSBzdG9yZWQgdG8uXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRpdnYoYSwgYiwgZHN0ID0gY3JlYXRlKDAsIDApKSB7XHJcbiAgICBkc3QueCA9IGEueCAvIGIueDtcclxuICAgIGRzdC55ID0gYS55IC8gYi55O1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogRGl2aWRlcyBhIHZlY3RvciBieSBhIHNjYWxhciBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW50byBhIHRoaXJkIHZlY3Rvci5cclxuICpcclxuICogQHBhcmFtIGEgVGhlIGRpdmlkZW5kIHZlY3Rvci5cclxuICogQHBhcmFtIG4gVGhlIHNjYWxhci5cclxuICogQHBhcmFtIGRzdCBUaGUgdmVjdG9yIHRoZSByZXN1bHQgd2lsbCBiZSBzdG9yZWQgdG8uXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRpdm4oYSwgbiwgZHN0ID0gY3JlYXRlKDAsIDApKSB7XHJcbiAgICBkc3QueCA9IGEueCAvIG47XHJcbiAgICBkc3QueSA9IGEueSAvIG47XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSByZW1pbmRlciBhZnRlciBkaXZpc2lvbiBvZiBhJ3MgY29tcG9uZW50cyBieSBuIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbnRvIGEgdGhpcmQgdmVjdG9yLlxyXG4gKlxyXG4gKiBAcGFyYW0gYSBUaGUgZGl2aWRlbmQgdmVjdG9yLlxyXG4gKiBAcGFyYW0gbiBUaGUgc2NhbGFyLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSB2ZWN0b3IgdGhlIHJlc3VsdCB3aWxsIGJlIHN0b3JlZCB0by5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbW9kKGEsIG4sIGRzdCA9IGNyZWF0ZSgwLCAwKSkge1xyXG4gICAgZHN0LnggPSBhLnggJSBuO1xyXG4gICAgZHN0LnkgPSBhLnkgJSBuO1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogTGluZWFybHkgaW50ZXJwb2xhdGVzIGJldHdlZW4gdHdvIHZlY3RvcnMsIGkuZS4gY29tcHV0ZXNcclxuICogYCgxIC0gZmFjdG9yKSAqIGEgKyBmYWN0b3IgKiBiYCwgYW5kIHdyaXRlcyB0aGUgcmVzdWx0IGludG8gYSB0aGlyZCB2ZWN0b3IuXHJcbiAqXHJcbiAqIEBwYXJhbSBhIFRoZSBmaXJzdCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBAcGFyYW0gZmFjdG9yIFRoZSBpbnRlcnBvbGF0aW9uIGZhY3Rvci5cclxuICogQHBhcmFtIGRzdCBUaGUgdmVjdG9yIHRoZSByZXN1bHQgd2lsbCBiZSB3cml0dGVuIHRvLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBtaXgoYSwgYiwgZmFjdG9yLCBkc3QgPSBjcmVhdGUoMCwgMCkpIHtcclxuICAgIGRzdC54ID0gKDEgLSBmYWN0b3IpICogYS54ICsgZmFjdG9yICogYi54O1xyXG4gICAgZHN0LnkgPSAoMSAtIGZhY3RvcikgKiBhLnkgKyBmYWN0b3IgKiBiLnk7XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbi8qKlxyXG4gKiBSb3RhdGVzIGEgdmVjdG9yIGJ5IGEgZ2l2ZW4gYW5nbGUgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGludG8gYSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBQb3NpdGl2ZSBkaXJlY3Rpb24gaXMgZnJvbSArWCB0byArWS5cclxuICpcclxuICogQHBhcmFtIHYgVGhlIHZlY3RvciB0byByb3RhdGUuXHJcbiAqIEBwYXJhbSBhbmdsZSBUaGUgYW5nbGUgb2Ygcm90YXRpb24uXHJcbiAqIEBwYXJhbSBkc3QgVGhlIHZlY3RvciB0aGUgcmVzdWx0IHdpbGwgYmUgc3RvcmVkIHRvLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiByb3RhdGUodiwgYW5nbGUsIGRzdCA9IGNyZWF0ZSgwLCAwKSkge1xyXG4gICAgY29uc3QgeCA9IHYueDtcclxuICAgIGNvbnN0IHkgPSB2Lnk7XHJcbiAgICBjb25zdCBhbmdsZUNvcyA9IE1hdGguY29zKGFuZ2xlKTtcclxuICAgIGNvbnN0IGFuZ2xlU2luID0gTWF0aC5zaW4oYW5nbGUpO1xyXG4gICAgZHN0LnggPSBhbmdsZUNvcyAqIHggLSBhbmdsZVNpbiAqIHk7XHJcbiAgICBkc3QueSA9IGFuZ2xlU2luICogeCArIGFuZ2xlQ29zICogeTtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIFJvdGF0ZXMgYSB2ZWN0b3IgYnkgNDUgZGVncmVlcyBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW50byBhIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEFuYWxvZ291cyB0byBgcm90YXRlKHYsIE1hdGguUEkgLyA0LCBkc3QpYCwgYnV0IGZhc3Rlci5cclxuICpcclxuICogQHBhcmFtIHYgVGhlIHZlY3RvciB0byByb3RhdGUuXHJcbiAqIEBwYXJhbSBkc3QgVGhlIHZlY3RvciB0aGUgcmVzdWx0IHdpbGwgYmUgc3RvcmVkIHRvLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiByb3RhdGU0NSh2LCBkc3QgPSBjcmVhdGUoMCwgMCkpIHtcclxuICAgIGNvbnN0IHkgPSB2Lnk7XHJcbiAgICBjb25zdCBzID0gTWF0aC5TUVJUMV8yO1xyXG4gICAgZHN0LnkgPSBzICogdi54ICsgcyAqIHYueTtcclxuICAgIGRzdC54ID0gcyAqIHYueCAtIHMgKiB5O1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogUm90YXRlcyBhIHZlY3RvciBieSA5MCBkZWdyZWVzIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbnRvIGEgc2Vjb25kIHZlY3Rvci5cclxuICogQW5hbG9nb3VzIHRvIGByb3RhdGUodiwgTWF0aC5QSSAvIDIsIGRzdClgLCBidXQgZmFzdGVyLlxyXG4gKlxyXG4gKiBAcGFyYW0gdiBUaGUgdmVjdG9yIHRvIHJvdGF0ZS5cclxuICogQHBhcmFtIGRzdCBUaGUgdmVjdG9yIHRoZSByZXN1bHQgd2lsbCBiZSBzdG9yZWQgdG8uXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZTkwKHYsIGRzdCA9IGNyZWF0ZSgwLCAwKSkge1xyXG4gICAgY29uc3QgeSA9IHYueTtcclxuICAgIGRzdC55ID0gdi54O1xyXG4gICAgZHN0LnggPSAteTtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIFJvdGF0ZXMgYSB2ZWN0b3IgYnkgLTkwIGRlZ3JlZXMgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGludG8gYSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBBbmFsb2dvdXMgdG8gYHJvdGF0ZSh2LCAtTWF0aC5QSSAvIDIsIGRzdClgLCBidXQgZmFzdGVyLlxyXG4gKlxyXG4gKiBAcGFyYW0gdiBUaGUgdmVjdG9yIHRvIHJvdGF0ZS5cclxuICogQHBhcmFtIGRzdCBUaGUgdmVjdG9yIHRoZSByZXN1bHQgd2lsbCBiZSBzdG9yZWQgdG8uXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZU5lZzkwKHYsIGRzdCA9IGNyZWF0ZSgwLCAwKSkge1xyXG4gICAgY29uc3QgeSA9IHYueTtcclxuICAgIGRzdC55ID0gLXYueDtcclxuICAgIGRzdC54ID0geTtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIEludmVydHMgc2lnbnMgb2YgY29tcG9uZW50cyBvZiBhIHZlY3RvciBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW50byBhIHNlY29uZFxyXG4gKiB2ZWN0b3IuIEFuYWxvZ291cyB0byBgcm90YXRlKHYsIE1hdGguUEksIGRzdClgIChvciBgcm90YXRlKHYsIC1NYXRoLlBJLCBkc3QpYCxcclxuICogd2hpY2ggaXMgdGhlIHNhbWUpLCBidXQgZmFzdGVyLlxyXG4gKlxyXG4gKiBAcGFyYW0gdiBUaGUgdmVjdG9yIHRvIGludmVydC5cclxuICogQHBhcmFtIGRzdCBUaGUgdmVjdG9yIHRoZSByZXN1bHQgd2lsbCBiZSBzdG9yZWQgdG8uXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGludmVydCh2LCBkc3QgPSBjcmVhdGUoMCwgMCkpIHtcclxuICAgIGRzdC54ID0gLXYueDtcclxuICAgIGRzdC55ID0gLXYueTtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIENvbXB1dGVzIGxlbmd0aCBvZiBhIHZlY3Rvci5cclxuICpcclxuICogQHBhcmFtIHYgVGhlIHZlY3Rvci5cclxuICogQHJldHVybnMgVGhlIGxlbmd0aC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBsZW5ndGgodikge1xyXG4gICAgcmV0dXJuIE1hdGguaHlwb3Qodi54LCB2LnkpO1xyXG59XHJcbi8qKlxyXG4gKiBDb21wdXRlcyBkaXN0YW5jZSBiZXR3ZWVuIGVuZHMgb2YgdHdvIHZlY3RvcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSBhIFRoZSBmaXJzdCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBAcmV0dXJucyBUaGUgZGlzdGFuY2UsIGkuZS4gYGxlbmd0aChzdWIoYSwgYikpYC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XHJcbiAgICByZXR1cm4gTWF0aC5oeXBvdChhLnggLSBiLngsIGEueSAtIGIueSk7XHJcbn1cclxuLyoqXHJcbiAqIERpdmlkZXMgYSB2ZWN0b3IgYnkgaXRzIGxlbmd0aCAodGh1cyBtYWtpbmcgaXQgYSB1bml0IHZlY3RvcikgYW5kIHN0b3JlcyB0aGVcclxuICogcmVzdWx0IHRvIGFub3RoZXIgb25lLlxyXG4gKlxyXG4gKiBAcGFyYW0gdiBUaGUgdmVjdG9yIHRvIGJlIG5vcm1hbGl6ZWQuXHJcbiAqIEBwYXJhbSBkc3QgVGhlIHZlY3RvciB0aGUgcmVzdWx0IHdpbGwgYmUgc3RvcmVkIHRvLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUodiwgZHN0ID0gY3JlYXRlKDAsIDApKSB7XHJcbiAgICByZXR1cm4gZGl2bih2LCBsZW5ndGgodiksIGRzdCk7XHJcbn1cclxuLyoqXHJcbiAqIENvbnZlcnRzIGVhY2ggY29tcG9uZW50IG9mIHZlY3Rvci5cclxuICpcclxuICogQHBhcmFtIHYgVGhlIHZlY3RvciB0byBiZSBjb252ZXJ0ZWQuXHJcbiAqIEBwYXJhbSBjb252ZXJ0ZXIgVGhlIGNvbXBvbmVudCBjb252ZXJ0ZXIuXHJcbiAqIEBwYXJhbSBkc3QgVGhlIHZlY3RvciB0aGUgcmVzdWx0IHdpbGwgYmUgc3RvcmVkIHRvLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0KHYsIGNvbnZlcnRlciwgZHN0ID0gY3JlYXRlKDAsIDApKSB7XHJcbiAgICBkc3QueCA9IGNvbnZlcnRlcih2LngpO1xyXG4gICAgZHN0LnkgPSBjb252ZXJ0ZXIodi55KTtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIENvbXB1dGVzIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWN0b3JzLlxyXG4gKlxyXG4gKiBAcGFyYW0gYSBUaGUgZmlyc3QgdmVjdG9yLlxyXG4gKiBAcGFyYW0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cclxuICogQHJldHVybnMgVGhlIGRvdCBwcm9kdWN0LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRvdChhLCBiKSB7XHJcbiAgICByZXR1cm4gYS54ICogYi54ICsgYS55ICogYi55O1xyXG59XHJcbi8qKlxyXG4gKiBDb21wdXRlcyBaLWNvbXBvbmVudCBvZiBhIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIHZlY3RvcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSBhIFRoZSBmaXJzdCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBAcmV0dXJucyBaLWNvbXBvbmVudCBvZiB0aGUgY3Jvc3MgcHJvZHVjdC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjcm9zc1ooYSwgYikge1xyXG4gICAgcmV0dXJuIGEueCAqIGIueSAtIGEueSAqIGIueDtcclxufVxyXG5leHBvcnQgY29uc3QgRU1QVFkgPSB7XHJcbiAgICBtaW5YOiAwLFxyXG4gICAgbWF4WDogMCxcclxuICAgIG1pblk6IDAsXHJcbiAgICBtYXhZOiAwXHJcbn07XHJcbmV4cG9ydCBjb25zdCBVTklUX0JCT1ggPSB7XHJcbiAgICBtaW5YOiAtMSxcclxuICAgIG1heFg6IDEsXHJcbiAgICBtaW5ZOiAtMSxcclxuICAgIG1heFk6IDFcclxufTtcclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgYmJveCBhbmQgaW5pdGlhbGl6ZXMgaXQgd2l0aCBnaXZlbiBjb21wb25lbnRzLlxyXG4gKlxyXG4gKiBAcGFyYW0gbWluWCBMZWZ0IGJvcmRlciBvZiB0aGUgYmJveC5cclxuICogQHBhcmFtIG1heFggUmlnaHQgYm9yZGVyIG9mIHRoZSBiYm94LlxyXG4gKiBAcGFyYW0gbWluWSBMb3dlciBib3JkZXIgb2YgdGhlIGJib3guXHJcbiAqIEBwYXJhbSBtYXhZIFVwcGVyIGJvcmRlciBvZiB0aGUgYmJveC5cclxuICogQHJldHVybnMgVGhlIGJib3guXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQkJveDIobWluWCwgbWF4WCwgbWluWSwgbWF4WSkge1xyXG4gICAgcmV0dXJuIHsgbWluWCwgbWF4WCwgbWluWSwgbWF4WSB9O1xyXG59XHJcbi8qKlxyXG4gKiBDb3BpZXMgYSBiYm94IHRvIGFub3RoZXIgb25lLlxyXG4gKlxyXG4gKiBAcGFyYW0gc3JjIFRoZSBzb3VyY2UgYmJveC5cclxuICogQHBhcmFtIGRzdCBUaGUgYmJveCB0aGUgc291cmNlIGJib3ggd2lsbCBiZSBjb3BpZWQgdG8uXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvcHlCQm94MihzcmMsIGRzdCA9IGNyZWF0ZUJCb3gyKDAsIDAsIDAsIDApKSB7XHJcbiAgICBkc3QubWluWCA9IHNyYy5taW5YO1xyXG4gICAgZHN0Lm1heFggPSBzcmMubWF4WDtcclxuICAgIGRzdC5taW5ZID0gc3JjLm1pblk7XHJcbiAgICBkc3QubWF4WSA9IHNyYy5tYXhZO1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogQ2hlY2tzIGlmIHR3byBib3VuZGluZyBib3hlcyBvdmVybGFwLlxyXG4gKlxyXG4gKiBAcGFyYW0gYmJveDEgQSBib3VuZGluZyBib3guXHJcbiAqIEBwYXJhbSBiYm94MiBBbm90aGVyIGJvdW5kaW5nIGJveC5cclxuICogQHJldHVybnMgYHRydWVgIGlmIGdpdmVuIGJvdW5kaW5nIGJveGVzIGRvIG92ZXJsYXAgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGJib3hlc092ZXJsYXAoYmJveDEsIGJib3gyKSB7XHJcbiAgICBsZXQgbGVmdEJCb3g7XHJcbiAgICBsZXQgcmlnaHRCQm94O1xyXG4gICAgaWYgKGJib3gxLm1pblggPCBiYm94Mi5taW5YKSB7XHJcbiAgICAgICAgbGVmdEJCb3ggPSBiYm94MTtcclxuICAgICAgICByaWdodEJCb3ggPSBiYm94MjtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGxlZnRCQm94ID0gYmJveDI7XHJcbiAgICAgICAgcmlnaHRCQm94ID0gYmJveDE7XHJcbiAgICB9XHJcbiAgICBsZXQgdG9wQkJveDtcclxuICAgIGxldCBib3R0b21CQm94O1xyXG4gICAgaWYgKGJib3gxLm1heFkgPiBiYm94Mi5tYXhZKSB7XHJcbiAgICAgICAgdG9wQkJveCA9IGJib3gxO1xyXG4gICAgICAgIGJvdHRvbUJCb3ggPSBiYm94MjtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRvcEJCb3ggPSBiYm94MjtcclxuICAgICAgICBib3R0b21CQm94ID0gYmJveDE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmlnaHRCQm94Lm1pblggPCBsZWZ0QkJveC5tYXhYICYmIGJvdHRvbUJCb3gubWF4WSA+IHRvcEJCb3gubWluWTtcclxufVxyXG4vKipcclxuICogQ2hlY2tzIGlmIGEgMkQgcG9pbnQgbGllcyBpbnNpZGUgYSBib3VuZGluZyBib3ggb3Igb24gaXRzIGJvcmRlci5cclxuICpcclxuICogQHBhcmFtIHBvaW50IFRoZSBwb2ludC5cclxuICogQHBhcmFtIGJib3ggVGhlIGJvdW5kaW5nIGJveC5cclxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBwb2ludCBpcyBpbnNpZGUgb2YgdGhlIGJveCBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcG9pbnRJc0luQkJveChwb2ludCwgYmJveCkge1xyXG4gICAgcmV0dXJuIGJib3gubWluWCA8PSBwb2ludC54ICYmIHBvaW50LnggPD0gYmJveC5tYXhYICYmXHJcbiAgICAgICAgYmJveC5taW5ZIDw9IHBvaW50LnkgJiYgcG9pbnQueSA8PSBiYm94Lm1heFk7XHJcbn1cclxuLyoqXHJcbiAqIENvbXB1dGVzIGJvdW5kaW5nIGJveCBvZiBhbiBhcnJheSBvZiBwb2ludHMgYW5kIHN0b3JlcyBpdCB0byBhIGdpdmVuIG9iamVjdC5cclxuICpcclxuICogQHBhcmFtIHBvaW50cyBUaGUgYXJyYXkgb2YgcG9pbnRzLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSBiYm94IHRoZSByZXN1bHQgd2lsbCBiZSB3cml0dGVuIHRvLiBMZWZ0IHVubW9kaWZpZWQgaWYgdGhlIGFycmF5XHJcbiAqICAgICAgb2YgcG9pbnRzIGlzIGVtcHR5LlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlQkJveEZvclBvaW50cyhwb2ludHMsIGRzdCA9IHsgbWluWDogMCwgbWF4WDogMCwgbWluWTogMCwgbWF4WTogMCB9KSB7XHJcbiAgICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBkc3Q7XHJcbiAgICB9XHJcbiAgICBkc3QubWluWCA9IGRzdC5tYXhYID0gcG9pbnRzWzBdLng7XHJcbiAgICBkc3QubWluWSA9IGRzdC5tYXhZID0gcG9pbnRzWzBdLnk7XHJcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHBvaW50cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gcG9pbnRzW2ldO1xyXG4gICAgICAgIGlmICh4IDwgZHN0Lm1pblgpIHtcclxuICAgICAgICAgICAgZHN0Lm1pblggPSB4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoeCA+IGRzdC5tYXhYKSB7XHJcbiAgICAgICAgICAgIGRzdC5tYXhYID0geDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHkgPCBkc3QubWluWSkge1xyXG4gICAgICAgICAgICBkc3QubWluWSA9IHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh5ID4gZHN0Lm1heFkpIHtcclxuICAgICAgICAgICAgZHN0Lm1heFkgPSB5O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuZXhwb3J0IGNvbnN0IFhfQVhJUyA9IHtcclxuICAgIG9yaWdpbjogT1JJR0lOLFxyXG4gICAgdGFuZ2VudDogUE9TSVRJVkVfWFxyXG59O1xyXG5leHBvcnQgY29uc3QgWV9BWElTID0ge1xyXG4gICAgb3JpZ2luOiBPUklHSU4sXHJcbiAgICB0YW5nZW50OiBQT1NJVElWRV9ZXHJcbn07XHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRMaW5lRnJvbVBvaW50cyhwMSwgcDIsIGRzdCA9IHtcclxuICAgIG9yaWdpbjogY3JlYXRlKDAsIDApLFxyXG4gICAgdGFuZ2VudDogY3JlYXRlKDAsIDApXHJcbn0pIHtcclxuICAgIGNvcHkocDEsIGRzdC5vcmlnaW4pO1xyXG4gICAgc3ViKHAyLCBwMSwgZHN0LnRhbmdlbnQpO1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogQ29tcHV0ZXMgc2lnbmVkIGRpc3RhbmNlIGZyb20gYSBwb2ludCB0byBhIGxpbmUuXHJcbiAqXHJcbiAqIEBwYXJhbSBwIFRoZSBwb2ludC5cclxuICogQHBhcmFtIGwxIFN0YXJ0IHBvaW50IG9mIHRoZSBsaW5lLlxyXG4gKiBAcGFyYW0gbDIgRW5kIHBvaW50IG9mIHRoZSBsaW5lLlxyXG4gKiBAcmV0dXJucyBEaXN0YW5jZSBmcm9tIHRoZSBwb2ludCB0byB0aGUgbGluZS4gSXQnbGwgYmUgZ3JlYXRlciB0aGFuIDAgaWYgdGhlXHJcbiAqICAgICAgcG9pbnQgbGllcyB0byB0aGUgbGVmdCBvZiB0aGUgbGluZSBhbmQgbGVzcyB0aGFuIDAgb3RoZXJ3aXNlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFNpZ25lZERpc3RhbmNlVG9MaW5lKHAsIGwpIHtcclxuICAgIGNvbnN0IHRhbmdlbnQgPSBsLnRhbmdlbnQ7XHJcbiAgICByZXR1cm4gZG90KHN1YihwLCBsLm9yaWdpbiksIGNyZWF0ZSgtdGFuZ2VudC55LCB0YW5nZW50LngpKSAvIGxlbmd0aCh0YW5nZW50KTtcclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBleHRlbnQgYW5kIGluaXRpYWxpemVzIGl0IHdpdGggZ2l2ZW4gY29tcG9uZW50cy5cclxuICpcclxuICogQHBhcmFtIHdpZHRoIFdpZHRoIG9mIHRoZSBleHRlbnQuXHJcbiAqIEBwYXJhbSBIZWlnaHQgSGVpZ2h0IG9mIHRoZSBleHRlbnQuXHJcbiAqIEByZXR1cm5zIFRoZSBleHRlbnQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRXh0ZW50Mih3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICByZXR1cm4geyB3aWR0aCwgaGVpZ2h0IH07XHJcbn1cclxuLyoqXHJcbiAqIENvcGllcyBhbiBleHRlbnQgdG8gYW5vdGhlciBvbmUuXHJcbiAqXHJcbiAqIEBwYXJhbSBzcmMgVGhlIHNvdXJjZSBiYm94LlxyXG4gKiBAcGFyYW0gZHN0IFRoZSBleHRlbnQgdGhlIHNvdXJjZSBleHRlbnQgd2lsbCBiZSBjb3BpZWQgdG8uXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvcHlFeHRlbnQyKHNyYywgZHN0ID0gY3JlYXRlRXh0ZW50MigwLCAwKSkge1xyXG4gICAgZHN0LndpZHRoID0gc3JjLndpZHRoO1xyXG4gICAgZHN0LmhlaWdodCA9IHNyYy5oZWlnaHQ7XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL21hdGgvdmVjdG9yMi50c1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICogU2ltcGxlIHB1Yi9zdWIgaW1wbGVtZW50YXRpb24uIFRoZSBlbWl0dGVyIGlzIHN1cHBvc2VkIHRvIGVtaXQgb25seSBvbmUgdHlwZSBvZiBldmVudCxcclxuICogaWYgc29tZW9uZSBoYXMgdG8gZW1pdCBldmVudHMgb2YgZGlmZmVyZW50IHR5cGVzLCBtdWx0aXBsZSBlbWl0dGVycyBzaG91bGQgYmUgY3JlYXRlZC5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBFdmVudEVtaXR0ZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gbmV3IFNldCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGxpc3RlbmVyLlxyXG4gICAgICovXHJcbiAgICBhZGRMaXN0ZW5lcihsaXN0ZW5lcikge1xyXG4gICAgICAgIHRoaXMuX2xpc3RlbmVycy5hZGQobGlzdGVuZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGxpc3RlbmVyLlxyXG4gICAgICovXHJcbiAgICByZW1vdmVMaXN0ZW5lcihsaXN0ZW5lcikge1xyXG4gICAgICAgIHRoaXMuX2xpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxscyBhbGwgdGhlIGFkZGVkIGxpc3RlbmVycywgdGhlIG9yZGVyIChlLmcuIG9mIGFkZGluZykgaXMgbm90IGd1YXJhbnRlZWQuXHJcbiAgICAgKi9cclxuICAgIGZpcmUoZGF0YSkge1xyXG4gICAgICAgIHRoaXMuX2xpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lcikgPT4ge1xyXG4gICAgICAgICAgICBsaXN0ZW5lcihkYXRhKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogRXZlbnQgZW1pdHRlciB3aXRoIG5vIHBheWxvYWQgZW1pdHRlZC5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBWb2lkRXZlbnRFbWl0dGVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcclxuICAgIGZpcmUoKSB7XHJcbiAgICAgICAgc3VwZXIuZmlyZSh1bmRlZmluZWQpO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvZXZlbnRfZW1pdHRlci50c1xuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBtYXBJdGVyYWJsZSB9IGZyb20gJy4uL3V0aWwvaXRlcmFibGUnO1xyXG5pbXBvcnQgeyBhbGlnbiB9IGZyb20gJy4uL3V0aWwvcG93X29mXzInO1xyXG4vKipcclxuICogR2l2ZXMgc2l6ZSBvZiBhIEdMIHR5cGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB0eXBlIFRoZSB0eXBlLlxyXG4gKiBAcmV0dXJucyBTaXplIG9mIHRoZSB0eXBlIGluIGJ5dGVzLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0VHlwZVNpemUodHlwZSkge1xyXG4gICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgY2FzZSA1MTIwIC8qIEJZVEUgKi86XHJcbiAgICAgICAgY2FzZSA1MTIxIC8qIFVOU0lHTkVEX0JZVEUgKi86XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIGNhc2UgNTEyMiAvKiBTSE9SVCAqLzpcclxuICAgICAgICBjYXNlIDUxMjMgLyogVU5TSUdORURfU0hPUlQgKi86XHJcbiAgICAgICAgICAgIHJldHVybiAyO1xyXG4gICAgICAgIGNhc2UgNTEyNCAvKiBJTlQgKi86XHJcbiAgICAgICAgY2FzZSA1MTI1IC8qIFVOU0lHTkVEX0lOVCAqLzpcclxuICAgICAgICBjYXNlIDUxMjYgLyogRkxPQVQgKi86XHJcbiAgICAgICAgICAgIHJldHVybiA0O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBEZXNjcmlwdGlvbiBvZiBob3cgcGFydGljdWxhciBhdHRyaWJ1dGVzIG9mIGEgdmVydGV4IGFyZSBwYWNrZWQgaW50byBhIHZlcnRleFxyXG4gKiBidWZmZXIuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQXR0cmlidXRlTWFwcGluZyBleHRlbmRzIE1hcCB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgYXR0cmlidXRlIG1hcHBpbmcgd2l0aCBhIHNldCBvZiBhdHRyaWJ1dGVzIG9mIGdpdmVuIHR5cGVzIGFuZFxyXG4gICAgICogc2l6ZXMuIEF1dG9tYXRpY2FsbHkgY29tcHV0ZXMgb2Zmc2V0cyBvZiB0aGUgYXR0cmlidXRlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbWFwcGluZyBUaGUgbWFwcGluZyBmcm9tIGF0dHJpYnV0ZSBJRHMgdG8gdHlwZXMgYW5kIHNpemVzLlxyXG4gICAgICogQHBhcmFtIGFsaWdubWVudCBEZXNpcmVkIGFsaWdubWVudCBvZiBhdHRyaWJ1dGVzIGluIHRoZSB2ZXJ0ZXggZGF0YVxyXG4gICAgICogICAgICBzdHJ1Y3R1cmUuIE11c3QgYmUgYSBwb3dlciBvZiAyLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihtYXBwaW5nLCBhbGlnbm1lbnQgPSA0IC8qIEFMSUdOXzRfQllURVMgKi8pIHtcclxuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcclxuICAgICAgICBzdXBlcihtYXBJdGVyYWJsZShtYXBwaW5nLCAoW2lkeCwgeyB0eXBlLCBzaXplLCBub3JtYWxpemVkIH1dKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBvaW50ZXIgPSBbXHJcbiAgICAgICAgICAgICAgICBpZHgsXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZSxcclxuICAgICAgICAgICAgICAgICAgICBzaXplLFxyXG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZVNpemUgPSBzaXplICogZ2V0VHlwZVNpemUodHlwZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld09mZnNldCA9IGFsaWduKG9mZnNldCArIGF0dHJpYnV0ZVNpemUsIC1hbGlnbm1lbnQpO1xyXG4gICAgICAgICAgICAvLyBUT0RPKGRtaWtpcykgQ2hlY2sgdGhpcyBpbiBkZWJ1ZyBtb2RlLlxyXG4gICAgICAgICAgICAvLyBpZiAobmV3T2Zmc2V0IC0gb2Zmc2V0ID4gYXR0cmlidXRlU2l6ZSkge1xyXG4gICAgICAgICAgICAvLyAgICBjb25zb2xlLndhcm4oYCR7bmV3T2Zmc2V0IC0gb2Zmc2V0fSBieXRlIHBhZGRpbmcncyBpbnNlcnRlZGApO1xyXG4gICAgICAgICAgICAvLyB9XHJcbiAgICAgICAgICAgIG9mZnNldCA9IG5ld09mZnNldDtcclxuICAgICAgICAgICAgcmV0dXJuIHBvaW50ZXI7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIHRoaXMudmVydGV4Qnl0ZVNpemUgPSBvZmZzZXQ7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL2F0dHJpYl9tYXBwaW5nLnRzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiBCYXNlIGNsYXNzIGZvciBhbnkgV2ViR0wgcmVuZGVyZXIsIGl0IGp1c3QgZGVmaW5lcyBiYXNpYyBzdHJ1Y3R1cmUgb2YgR0wtY2FsbHMgYWxsb3dpbmcgdG8gb3ZlcnJpZGUgYW55IHBhcnQuXHJcbiAqIEEgc3BlY2lmaWMgcmVuZGVyZXIgbWF5IG5lZWQgYW55IG51bWJlciBvZiBhZGRpdGlvbmFsIGFyZ3VtZW50cyB0byBwZXJmb3JtIHJlbmRlcmluZywgdGhleSBhcmUgcHJvdmlkZWQgaW5cclxuICogYWRkaXRpb25hbFBhcmFtcyBpbiB0aGUgcmVuZGVyKCkgbWV0aG9kLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEdsUmVuZGVyZXIge1xyXG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgcmVuZGVyU3RhdGUsIHByb2dyYW0pIHtcclxuICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcclxuICAgICAgICB0aGlzLl9yZW5kZXJTdGF0ZSA9IHJlbmRlclN0YXRlO1xyXG4gICAgICAgIHRoaXMuX3Byb2dyYW0gPSBwcm9ncmFtO1xyXG4gICAgfVxyXG4gICAgcmVuZGVyKHRhcmdldCwgLi4uYXJncykge1xyXG4gICAgICAgIGlmICh0aGlzLl9wcm9ncmFtKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3ByZXBhcmVQcm9ncmFtKHRoaXMuX3Byb2dyYW0sIC4uLmFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9wcmVwYXJlUmVuZGVyVGFyZ2V0KHRhcmdldCwgLi4uYXJncyk7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyKC4uLmFyZ3MpO1xyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICBpZiAodGhpcy5fcHJvZ3JhbSkge1xyXG4gICAgICAgICAgICB0aGlzLl9wcm9ncmFtLmRlc3Ryb3koKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEJpbmRzIHByb2dyYW0gYW5kIHNldHMgcmVxdWlyZWQgdW5pZm9ybXMuIFN1YmNsYXNzZXMgYXJlIHN1cHBvc2VkIHRvIG92ZXJyaWRlXHJcbiAgICAgKiB0aGlzIG1ldGhvZCB0byBhZGQgdGhlaXIgb3duIHVuaWZvcm1zLlxyXG4gICAgICovXHJcbiAgICBfcHJlcGFyZVByb2dyYW0ocHJvZ3JhbSwgLi4uX2FyZ3MpIHtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRQcm9ncmFtKHByb2dyYW0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBCaW5kcyByZW5kZXIgc3RhdGUgYW5kIHJlbmRlciB0YXJnZXQsIG5vIGNsZWFyIGhhcHBlbnMgaGVyZSwgYnV0IHRoaXMgbWV0aG9kXHJcbiAgICAgKiBjYW4gYmUgb3ZlcnJpZGRlbiBpbiBzdWJjbGFzc2VzIHRvIGFkZCBhbnkgc2V0dXBzIHRoZXkgbmVlZC5cclxuICAgICAqL1xyXG4gICAgX3ByZXBhcmVSZW5kZXJUYXJnZXQodGFyZ2V0LCAuLi5fYXJncykge1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFJlbmRlclN0YXRlKHRoaXMuX3JlbmRlclN0YXRlKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRSZW5kZXJUYXJnZXQodGFyZ2V0KTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvZ2xfcmVuZGVyZXIudHNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgR2xSZW5kZXJlciB9IGZyb20gJy4uL2dsX3JlbmRlcmVyJztcclxuaW1wb3J0IHsgY291bnRJbmRpY2VzIH0gZnJvbSAnLi4vbWVtb3J5L2NvdW50X3ZlcnRpY2VzJztcclxuaW1wb3J0IHsgYmF0Y2hQcmltaXRpdmVzIH0gZnJvbSAnLi9wcmltaXRpdmVfYmF0Y2gnO1xyXG4vKipcclxuICogQmFzZSBjbGFzcyBmb3IgcmVuZGVyaW5nIHZpc2libGUgcHJpbWl0aXZlcy4gQmVpbmcgdmlzaWJsZSBpbiB0aGUgd29ybGQgbWVhbnMgdGhhdCB0aGV5IGFsbCBuZWVkIHZpZXctcHJvamVjdGlvblxyXG4gKiBtYXRyaXggYW5kIGNhbWVyYSBwb3NpdGlvbnMgKG11bHRpcGxlIHBvc2l0aW9ucyBhcmUgdXNlZCBmb3IgcmVuZGVyaW5nIHJlcGVhdGVkIHdvcmxkKS4gVGhlc2UgcGFyYW1ldGVycyBhcmVcclxuICogcHJlZGVmaW5lZCBhcyBleHRlcm5hbCByZXF1aXJlbWVudHMgZm9yIHJlbmRlcigpIG1ldGhvZC5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdvcmxkUHJpbWl0aXZlUmVuZGVyVW5pdCBleHRlbmRzIEdsUmVuZGVyZXIge1xyXG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgcmVuZGVyU3RhdGUsIHByb2dyYW0sIHByaW1pdGl2ZVByb3ZpZGVyKSB7XHJcbiAgICAgICAgc3VwZXIoY29udGV4dCwgcmVuZGVyU3RhdGUsIHByb2dyYW0pO1xyXG4gICAgICAgIHRoaXMucHJpbWl0aXZlUHJvdmlkZXIgPSBwcmltaXRpdmVQcm92aWRlcjtcclxuICAgICAgICB0aGlzLm9uVXBkYXRlID0gcHJpbWl0aXZlUHJvdmlkZXIub25VcGRhdGU7XHJcbiAgICB9XHJcbiAgICByZW5kZXIodGFyZ2V0LCB2aWV3UHJvak1hdHJpeCwgY2FtZXJhUG9zaXRpb25zLCAuLi5hcmdzKSB7XHJcbiAgICAgICAgc3VwZXIucmVuZGVyKHRhcmdldCwgdmlld1Byb2pNYXRyaXgsIGNhbWVyYVBvc2l0aW9ucywgLi4uYXJncyk7XHJcbiAgICB9XHJcbiAgICBfcmVuZGVyKF92aWV3UHJvak1hdHJpeCwgY2FtZXJhUG9zaXRpb25zKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBjYW1lcmFQb3NpdGlvbiBvZiBjYW1lcmFQb3NpdGlvbnMpIHtcclxuICAgICAgICAgICAgdGhpcy5fcHJvZ3JhbS5zZXRWZWN0b3IyVW5pZm9ybSgnbG9va0F0SGlnaCcsIGNhbWVyYVBvc2l0aW9uLmxvb2tBdEhpZ2gpO1xyXG4gICAgICAgICAgICB0aGlzLl9wcm9ncmFtLnNldFZlY3RvcjJVbmlmb3JtKCdsb29rQXRMb3cnLCBjYW1lcmFQb3NpdGlvbi5sb29rQXRMb3cpO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG1lbW9yeUJhdGNoIG9mIGJhdGNoUHJpbWl0aXZlcyh0aGlzLl9nZXRQcmltaXRpdmVzKCksIHRoaXMuX2NhbkJhdGNoQWRqYWNlbnRQcmltaXRpdmVzKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyQmF0Y2gobWVtb3J5QmF0Y2gpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2dldFByaW1pdGl2ZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHJpbWl0aXZlUHJvdmlkZXIucHJpbWl0aXZlcztcclxuICAgIH1cclxuICAgIF9wcmVwYXJlUHJvZ3JhbShwcm9ncmFtLCB2aWV3UHJvak1hdHJpeCwgY2FtZXJhUG9zaXRpb25zLCAuLi5hcmdzKSB7XHJcbiAgICAgICAgc3VwZXIuX3ByZXBhcmVQcm9ncmFtKHByb2dyYW0sIHZpZXdQcm9qTWF0cml4LCBjYW1lcmFQb3NpdGlvbnMsIC4uLmFyZ3MpO1xyXG4gICAgICAgIHByb2dyYW0uc2V0TWF0cml4NFVuaWZvcm0oJ3ZpZXdQcm9qTWF0cml4Jywgdmlld1Byb2pNYXRyaXgpO1xyXG4gICAgfVxyXG4gICAgX3JlbmRlckJhdGNoKG1lbW9yeUJhdGNoKSB7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kVmFvKG1lbW9yeUJhdGNoLnBhZ2UudmFvKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmRyYXdJbmRleGVkTWVzaChtZW1vcnlCYXRjaC5pbmRleEJ5dGVPZmZzZXQsIGNvdW50SW5kaWNlcyhtZW1vcnlCYXRjaC5pbmRleEJ5dGVMZW5ndGgsIG1lbW9yeUJhdGNoLnBhZ2UuaW5kZXhUeXBlKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERldGVybWluZXMgaWYgdHdvIGFkamFjZW50IHByaW1pdGl2ZXMgY2FuIGJlIHJlbmRlcmVkIGluIG9uZSBiYXRjaCAoYnkgYSBzaW5nbGUgZHJhdyBjYWxsKS4gVGhleSBhbHJlYWR5XHJcbiAgICAgKiBsYXkgc3VjY2Vzc2l2ZWx5IGluIG1lbW9yeSwgYnV0IHRoZXJlIGNvdWxkIGJlIG90aGVyIHJlYXNvbnMgdGhhdCBmb3JiaWQgYmF0Y2hpbmcsIGxpa2UgdXNpbmcgZGlmZmVyZW50IHRleHR1cmVzLlxyXG4gICAgICogVGhlIG1ldGhvZCBzaG91bGQgYmUgb3ZlcnJpZGRlbiBpbiBzdWJjbGFzc2VzIGlmIHRoZWlyIHByaW1pdGl2ZXMgaGF2ZSBzdWNoIGNvbXBsZXggcnVsZXMgb2YgYmF0Y2hpbmcuXHJcbiAgICAgKi9cclxuICAgIF9jYW5CYXRjaEFkamFjZW50UHJpbWl0aXZlcyhfYSwgX2IpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy93b3JsZF9wcmltaXRpdmVfcmVuZGVyX3VuaXQudHNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgZmxvYXRUb1VpbnQzMiB9IGZyb20gJy4vZ3B1dHlwZXMnO1xyXG5pbXBvcnQgeyB6aXAgfSBmcm9tICcuL2FycmF5JztcclxuZXhwb3J0IGNvbnN0IFdPUkRfQllURV9TSVpFID0gNDtcclxuLyoqXHJcbiAqIEdlbmVyYXRlcyB0cmlhbmdsZXMgb2YgYSBmYW4gb2YgYSBnaXZlbiBsZW5ndGggYXMgaWYgaXQgaXMgY29udGludW91cyBhbmRcclxuICogc3RhcnRzIHdpdGggMC5cclxuICpcclxuICogQHBhcmFtIGNvdW50IE51bWJlciBvZiB2ZXJ0aWNlcyBpbiB0aGUgZmFuLlxyXG4gKiBAcmV0dXJucyBJdGVyYXRvciBvdmVyIGluZGljZXMgb2YgdHJpYW5nbGVzLlxyXG4gKi9cclxuZnVuY3Rpb24qIGdlbmVyYXRlRmFuKGNvdW50KSB7XHJcbiAgICBmb3IgKGxldCBpID0gMjsgaSA8IGNvdW50OyArK2kpIHtcclxuICAgICAgICB5aWVsZCAwO1xyXG4gICAgICAgIHlpZWxkIGkgLSAxO1xyXG4gICAgICAgIHlpZWxkIGk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEdlbmVyYXRlcyB0cmlhbmdsZXMgb2YgYSBzdHJpcCBvZiBhIGdpdmVuIGxlbmd0aCBhcyBpZiBpdCBpcyBjb250aW51b3VzIGFuZFxyXG4gKiBzdGFydHMgd2l0aCAwLlxyXG4gKlxyXG4gKiBAcGFyYW0gY291bnQgTnVtYmVyIG9mIHZlcnRpY2VzIGluIHRoZSBmYW4uXHJcbiAqIEByZXR1cm5zIEl0ZXJhdG9yIG92ZXIgaW5kaWNlcyBvZiB0cmlhbmdsZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiogZ2VuZXJhdGVTdHJpcChjb3VudCkge1xyXG4gICAgeWllbGQgMDtcclxuICAgIHlpZWxkIDE7XHJcbiAgICB5aWVsZCAyO1xyXG4gICAgbGV0IG9mZnNldDAgPSAxO1xyXG4gICAgbGV0IG9mZnNldDEgPSAyO1xyXG4gICAgZm9yIChsZXQgaSA9IDM7IGkgPCBjb3VudDsgKytpKSB7XHJcbiAgICAgICAgeWllbGQgaSAtIG9mZnNldDA7XHJcbiAgICAgICAgeWllbGQgaSAtIG9mZnNldDE7XHJcbiAgICAgICAgeWllbGQgaTtcclxuICAgICAgICBjb25zdCB0bXAgPSBvZmZzZXQwO1xyXG4gICAgICAgIG9mZnNldDAgPSBvZmZzZXQxO1xyXG4gICAgICAgIG9mZnNldDEgPSB0bXA7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFZlcnRleCBidWZmZXIgaGVscGVyIGNsYXNzLCB0aGF0IHN1cHBvcnRzIHNlcXVlbnRpYWwgd3JpdGluZyBpbnRlcmZhY2UgYW5kIHRha2VzIG92ZXIgc29tZSBzaW5nbGUtYnVmZmVyIG9wZXJhdGlvbnMuXHJcbiAqIEl0IGlzIGFuIGludGVncmFsIHBhcnQgb2YgdGhlIGJ1ZmZlciB3cml0ZXIgY2xhc3MgYW5kIGl0cyBtYWluIHB1cnBvc2UgaXMgdG8gbWFrZSB0aGUgd3JpdGVyJ3MgY29kZSBlYXNpZXIuXHJcbiAqL1xyXG5jbGFzcyBWZXJ0ZXhCdWZmZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gYnl0ZVNpemUgSW5pdGlhbCBzaXplIG9mIHRoZSBidWZmZXIgaW4gYnl0ZXMuIEFzIGl0IGdldHMgZmlsbGVkIGJ5IHdvcmRzXHJcbiAgICAgKiAgICAgIHRoZSBzaXplIG11c3QgYmUgYSBtdWx0aXBseSBvZiA0LlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihieXRlU2l6ZSkge1xyXG4gICAgICAgIHRoaXMuX25leHRXb3JkT2Zmc2V0ID0gMDtcclxuICAgICAgICB0aGlzLl9pbml0QnVmZmVycyhieXRlU2l6ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlcmUgaXMgbm8gZnJlZSBzcGFjZSByZW1haW5pbmcgaW4gYnVmZmVyLlxyXG4gICAgICovXHJcbiAgICBnZXQgaXNGdWxsKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9uZXh0V29yZE9mZnNldCA+PSB0aGlzLl91aW50MzJWaWV3Lmxlbmd0aDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVGhlIG51bWJlciBvZiB3b3JkcyAoNCBieXRlcyB2YWx1ZXMpIGFscmVhZHkgd3JpdHRlbi5cclxuICAgICAqL1xyXG4gICAgZ2V0IG9jY3VwaWVkU2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbmV4dFdvcmRPZmZzZXQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gTWF4IG51bWJlciBvZiBieXRlcyB0aGlzIGJ1ZmZlciBpcyBhYmxlIHRvIHN0b3JlLiBJdCBjYW4gYmUgaW5jcmVhc2VkIGJ5IHRoZSBleHRlbmQoKSBtZXRob2QuXHJcbiAgICAgKi9cclxuICAgIGdldCBieXRlU2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdWludDMyVmlldy5ieXRlTGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFeHRlbmRzIGJ1ZmZlciB0byB0aGUgbmV3IHNpemUuIFRoZSBuZXcgc2l6ZSBtdXN0IGJlIG5vdCBsZXNzIHRoYW4gY3VycmVudCBvbmUgYW5kIGl0IG11c3QgYmUgYSBtdWx0aXBseSBvZiA0LlxyXG4gICAgICovXHJcbiAgICBleHRlbmQobmV3Qnl0ZVNpemUpIHtcclxuICAgICAgICAvLyBUT0RPIGFzc2VydCBuZXdCeXRlTGVuZ3RoIGlzIGxhcmdlciB0aGFuIGN1cnJlbnQgX2FycmF5QnVmZmVyIGFuZCBpdHMgaXMgYSBtdWx0aXBseSBvZiB0aGUgd29yZCBzaXplLlxyXG4gICAgICAgIGNvbnN0IG9sZFVpbnQzMlZpZXcgPSB0aGlzLl91aW50MzJWaWV3O1xyXG4gICAgICAgIHRoaXMuX2luaXRCdWZmZXJzKG5ld0J5dGVTaXplKTtcclxuICAgICAgICB0aGlzLl91aW50MzJWaWV3LnNldChvbGRVaW50MzJWaWV3KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXBwZW5kcyB2YWx1ZSBhcyBhIHVpbnQzMiBudW1iZXIuXHJcbiAgICAgKi9cclxuICAgIHB1c2hVaW50MzIodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl91aW50MzJWaWV3W3RoaXMuX25leHRXb3JkT2Zmc2V0KytdID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFwcGVuZHMgdmFsdWUgYXMgYSBmbG9hdDMyIG51bWJlci5cclxuICAgICAqL1xyXG4gICAgcHVzaEZsb2F0MzIodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9mbG9hdDMyVmlld1t0aGlzLl9uZXh0V29yZE9mZnNldCsrXSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyB1aW50OCB2aWV3IG9mIHRoaXMgYnVmZmVyLiBUaGUgc2l6ZSBvZiB0aGUgdmlldyBtYXRjaGVzIHRoZSBhbW91bnQgb2Ygd3JpdHRlbiBkYXRhLlxyXG4gICAgICovXHJcbiAgICBhc1VpbnQzMkFycmF5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl91aW50MzJWaWV3LnN1YmFycmF5KDAsIHRoaXMub2NjdXBpZWRTaXplKTtcclxuICAgIH1cclxuICAgIF9pbml0QnVmZmVycyhieXRlTGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3QgYXJyYXlCdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnl0ZUxlbmd0aCk7XHJcbiAgICAgICAgdGhpcy5fdWludDMyVmlldyA9IG5ldyBVaW50MzJBcnJheShhcnJheUJ1ZmZlcik7XHJcbiAgICAgICAgdGhpcy5fZmxvYXQzMlZpZXcgPSBuZXcgRmxvYXQzMkFycmF5KGFycmF5QnVmZmVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTW92ZXMgXCJ0YWlsXCIgZGF0YSAoZnJvbSB0aGUgb2Zmc2V0IHNwZWNpZmllZCB0byB0aGUgZW5kIG9mIHRoZSBidWZmZXIpIG9mIG9uZSBidWZmZXIgdG8gYW5vdGhlci4gVGhlIGN1cnNvcnMgb2ZcclxuICAgICAqIGJ1ZmZlcnMgd2lsbCBiZSBhcHByb3ByaWF0ZWx5IHVwZGF0ZWQgdG8gcmVmbGVjdCBkYXRhIGNoYW5nZXMuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyB0cmFuc2ZlckRhdGFUYWlsKHNyYywgZHN0LCBzcmNXb3JkT2Zmc2V0LCBkc3RPZmZzZXQgPSAwKSB7XHJcbiAgICAgICAgY29uc3QgdGFpbExlbmd0aCA9IHNyYy5vY2N1cGllZFNpemUgLSBzcmNXb3JkT2Zmc2V0O1xyXG4gICAgICAgIGNvbnN0IHNyY1RhaWwgPSBzcmMuX3VpbnQzMlZpZXcuc3ViYXJyYXkoc3JjV29yZE9mZnNldCwgc3JjLm9jY3VwaWVkU2l6ZSk7XHJcbiAgICAgICAgZHN0Ll91aW50MzJWaWV3LnNldChzcmNUYWlsLCBkc3RPZmZzZXQpO1xyXG4gICAgICAgIGRzdC5fbmV4dFdvcmRPZmZzZXQgPSB0YWlsTGVuZ3RoO1xyXG4gICAgICAgIHNyYy5fbmV4dFdvcmRPZmZzZXQgPSBzcmNXb3JkT2Zmc2V0O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBJbmRleCBidWZmZXIgaGVscGVyIGNsYXNzLCB0aGF0IHN1cHBvcnRzIHNlcXVlbnRpYWwgd3JpdGluZyBpbnRlcmZhY2UgYW5kIHRha2VzIG92ZXIgc29tZSBzaW5nbGUtYnVmZmVyIG9wZXJhdGlvbnMuXHJcbiAqIEl0IGlzIGFuIGludGVncmFsIHBhcnQgb2YgdGhlIGJ1ZmZlciB3cml0ZXIgY2xhc3MgYW5kIGl0cyBtYWluIHB1cnBvc2UgaXMgdG8gbWFrZSB0aGUgd3JpdGVyJ3MgY29kZSBlYXNpZXIuXHJcbiAqL1xyXG5jbGFzcyBJbmRleEJ1ZmZlciB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBzaXplIEluaXRpYWwgc2l6ZSBvZiB0aGUgYnVmZmVyLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihzaXplKSB7XHJcbiAgICAgICAgdGhpcy5fbmV4dEluZGV4T2Zmc2V0ID0gMDtcclxuICAgICAgICB0aGlzLl91aW50MTZWaWV3ID0gbmV3IFVpbnQxNkFycmF5KHNpemUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIGluZGljZXMgYWxyZWFkeSB3cml0dGVuLlxyXG4gICAgICovXHJcbiAgICBnZXQgb2NjdXBpZWRTaXplKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9uZXh0SW5kZXhPZmZzZXQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gTWF4IG51bWJlciBvZiBpbmRpY2VzIHRoaXMgYnVmZmVyIGlzIGFibGUgdG8gc3RvcmUuIEl0IGNhbiBiZSBpbmNyZWFzZWQgYnkgdGhlIGV4dGVuZCgpIG1ldGhvZC5cclxuICAgICAqL1xyXG4gICAgZ2V0IHNpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VpbnQxNlZpZXcubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFeHRlbmRzIGJ1ZmZlciB0byB0aGUgbmV3IHNpemUuXHJcbiAgICAgKi9cclxuICAgIGV4dGVuZChuZXdTaXplKSB7XHJcbiAgICAgICAgLy8gVE9ETyBhc3NlcnQgbmV3Qnl0ZUxlbmd0aCBpcyBsYXJnZXIgdGhhbiBjdXJyZW50IF9hcnJheUJ1ZmZlclxyXG4gICAgICAgIGNvbnN0IG9sZFVpbnQxNlZpZXcgPSB0aGlzLl91aW50MTZWaWV3O1xyXG4gICAgICAgIHRoaXMuX3VpbnQxNlZpZXcgPSBuZXcgVWludDE2QXJyYXkobmV3U2l6ZSk7XHJcbiAgICAgICAgdGhpcy5fdWludDE2Vmlldy5zZXQob2xkVWludDE2Vmlldyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFwcGVuZHMgaW5kZXggdG8gdGhlIGVuZCBvZiB0aGUgYnVmZmVyLlxyXG4gICAgICovXHJcbiAgICBwdXNoKGluZGV4KSB7XHJcbiAgICAgICAgdGhpcy5fdWludDE2Vmlld1t0aGlzLl9uZXh0SW5kZXhPZmZzZXQrK10gPSBpbmRleDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgdWludDE2IHZpZXcgb2YgdGhpcyBidWZmZXIuIFRoZSBzaXplIG9mIHRoZSB2aWV3IG1hdGNoZXMgdGhlIGFtb3VudCBvZiB3cml0dGVuIGRhdGEuXHJcbiAgICAgKi9cclxuICAgIGFzVWludDE2QXJyYXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50MTZBcnJheSh0aGlzLl91aW50MTZWaWV3LmJ1ZmZlciwgMCwgdGhpcy5vY2N1cGllZFNpemUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBNb3ZlcyBcInRhaWxcIiBkYXRhIChmcm9tIHRoZSBvZmZzZXQgc3BlY2lmaWVkIHRvIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlcikgb2Ygb25lIGJ1ZmZlciB0byBhbm90aGVyLiBUaGUgb2Zmc2V0cyBvZlxyXG4gICAgICogYnVmZmVycyB3aWxsIGJlIGFwcHJvcHJpYXRlbHkgdXBkYXRlZCB0byByZWZsZWN0IGRhdGEgY2hhbmdlcy5cclxuICAgICAqIGJhc2VJbmRleCB3aWxsIGJlIGRlZHVjdGVkIGZyb20gYWxsIG1vdmVkIGluZGljZXMuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyB0cmFuc2ZlckRhdGFUYWlsKHNyYywgZHN0LCBiYXNlSW5kZXgsIHNyY09mZnNldCwgZHN0T2Zmc2V0ID0gMCkge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBzcmNPZmZzZXQsIGogPSBkc3RPZmZzZXQ7IGkgPCBzcmMub2NjdXBpZWRTaXplOyBpKyssIGorKykge1xyXG4gICAgICAgICAgICBkc3QuX3VpbnQxNlZpZXdbal0gPSBzcmMuX3VpbnQxNlZpZXdbaV0gLSBiYXNlSW5kZXg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRzdC5fbmV4dEluZGV4T2Zmc2V0ID0gc3JjLm9jY3VwaWVkU2l6ZSAtIHNyY09mZnNldDtcclxuICAgICAgICBzcmMuX25leHRJbmRleE9mZnNldCA9IHNyY09mZnNldDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQmFzZSBidWZmZXIgd3JpdGVyIGltcGxlbWVudGF0aW9uLiBDYW4gd3JpdGUgdW5zaWduZWQgc2hvcnQgaW5kaWNlcyBhbmRcclxuICogcHJvdmlkZXMgZmFjaWxpdGllcyBmb3IgY2hpbGQgY2xhc3NlcyB0byBoYW5kbGUgd3JpdGluZyB2ZXJ0ZXggZGF0YS4gRGVmaW5lc1xyXG4gKiBhIGNvbmNlcHQgb2YgY3VycmVudCBtZXNoLiBCYXNpY2FsbHksIGl0IG1lYW4gdGhhdCBhbGwgdmVydGljZXMgYW5kIGluZGljZXNcclxuICogd3JpdHRlbiB0byBhIHdyaXRlciBiZXR3ZWVuIHR3byBgZW5kTWVzaGAgY2FsbHMgKG9yIGNvbnN0cnVjdGlvbiBvZiB0aGUgd3JpdGVyXHJcbiAqIGFuZCBhbiBgZW5kTWVzaGAgY2FsbCkgbXVzdCBiZSBjb25zaWRlcmVkIGJlbG9uZ2luZyB0byBvbmUgYXRvbWljIHBpZWNlIG9mXHJcbiAqIGdlb21ldHJ5IGFuZCBzaG91bGQgbm90IGJlIHNwaXR0ZWQgYmV0d2VlbiBzZXBhcmF0ZSBidWZmZXJzLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQnVmZmVyV3JpdGVyIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyB3cml0ZXIgYW5kIGFsbG9jYXRlcyBpbml0aWFsIGFtb3VudCBvZiBtZW1vcnkgdG8gc3RvcmUgZGF0YS5cclxuICAgICAqIEFsc28gaW1wbGljaXRseSBcInN0YXJ0XCIgYSBtZXNoLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB2ZXJ0ZXhCeXRlU2l6ZVxyXG4gICAgICogQHBhcmFtIGluaXRWZXJ0ZXhCdWZmZXJTaXplIEluaXQgc2l6ZSAoaW4gdmVydGljZXMpIG9mIGdyb3dpbmcgdmVydGV4IGJ1ZmZlcnMuXHJcbiAgICAgKiBAcGFyYW0gbWF4VmVydGV4QnVmZmVyU2l6ZSBNYXggc2l6ZSAoaW4gdmVydGljZXMpIG9mIHZlcnRleCBidWZmZXJzLlxyXG4gICAgICogQHBhcmFtIGluaXRJbmRleEJ1ZmZlclVpbnQxNlNpemUgSW5pdCBzaXplIChpbiB1aW50MTYgbnVtYmVyKSBvZiBncm93aW5nIGluZGV4IGJ1ZmZlcnMuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHZlcnRleEJ5dGVTaXplLCBpbml0VmVydGV4QnVmZmVyU2l6ZSA9IDB4NDAwLCBtYXhWZXJ0ZXhCdWZmZXJTaXplID0gMHgxMDAwMCwgaW5pdEluZGV4QnVmZmVyVWludDE2U2l6ZSA9IDB4YzAwKSB7XHJcbiAgICAgICAgdGhpcy5fdmVydGV4Qnl0ZVNpemUgPSB2ZXJ0ZXhCeXRlU2l6ZTtcclxuICAgICAgICB0aGlzLl9pbml0VmVydGV4QnVmZmVyQnl0ZVNpemUgPSB2ZXJ0ZXhCeXRlU2l6ZSAqIGluaXRWZXJ0ZXhCdWZmZXJTaXplO1xyXG4gICAgICAgIHRoaXMuX21heFZlcnRleEJ1ZmZlckJ5dGVTaXplID0gdmVydGV4Qnl0ZVNpemUgKiBtYXhWZXJ0ZXhCdWZmZXJTaXplO1xyXG4gICAgICAgIHRoaXMuX2luaXRJbmRleEJ1ZmZlclVpbnQxNlNpemUgPSBpbml0SW5kZXhCdWZmZXJVaW50MTZTaXplO1xyXG4gICAgICAgIHRoaXMuX3ZlcnRleEJ1ZmZlciA9IG5ldyBWZXJ0ZXhCdWZmZXIodGhpcy5faW5pdFZlcnRleEJ1ZmZlckJ5dGVTaXplKTtcclxuICAgICAgICB0aGlzLl92ZXJ0ZXhCdWZmZXJzID0gW3RoaXMuX3ZlcnRleEJ1ZmZlcl07XHJcbiAgICAgICAgdGhpcy5faW5kZXhCdWZmZXIgPSBuZXcgSW5kZXhCdWZmZXIodGhpcy5faW5pdEluZGV4QnVmZmVyVWludDE2U2l6ZSk7XHJcbiAgICAgICAgdGhpcy5faW5kZXhCdWZmZXJzID0gW3RoaXMuX2luZGV4QnVmZmVyXTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50TWVzaFZlcnRleE9mZnNldCA9IDA7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudE1lc2hJbmRleE9mZnNldCA9IDA7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudE1lc2hCYXNlSW5kZXggPSAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYSBidW5jaCBvZiBpbmRpY2VzIHRvIHRoZSB1bmRlcmx5aW5nIHN0b3JhZ2UgYXMgdW5zaWduZWQgc2hvcnRcclxuICAgICAqIG51bWJlcnMuIElmIGN1cnJlbnQgc3RvcmFnZSBkb2Vzbid0IGhhdmUgZW5vdWdoIHNwYWNlIHRvIGFjY29tbW9kYXRlXHJcbiAgICAgKiBnaXZlbiBpbmRpY2VzLCB0aGUgd3JpdGVyIHdpbGwgYXV0b21hdGljYWxseSByZXNpemUgaXQuIFRoZSB3cml0ZXJcclxuICAgICAqIGF1dG9tYXRpY2FsbHkgYWRkcyBiYXNlIGluZGV4IHRvIHRoZSBzdXBwbGllZCB2YWx1ZXMsIHNvIGZyb20gYSB1c2VyXHJcbiAgICAgKiBwb2ludCBvZiB2aWV3IGZpcnN0IHZlcnRleCBvZiBhIG1lc2ggaGFzIGluZGV4IDAgYW5kIHRoZXJlJ3Mgbm8gbmVlZFxyXG4gICAgICogdG8gdGFrZSBpbnRvIGFjY291bnQgaXQncyBvZmZzZXQgd2hpbGUgZ2VuZXJhdGluZyBtZXNoJ3MgdG9wb2xvZ3kuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGluZGljZXMgQXJyYXkgb2YgaW5kaWNlcyB0byB3cml0ZS5cclxuICAgICAqL1xyXG4gICAgd3JpdGVJbmRpY2VzKGluZGljZXMpIHtcclxuICAgICAgICB0aGlzLl9lbnN1cmVFbm91Z2hJbmRleEJ1ZmZlclNwYWNlKGluZGljZXMubGVuZ3RoKTtcclxuICAgICAgICBjb25zdCBidWZmZXIgPSB0aGlzLl9pbmRleEJ1ZmZlcjtcclxuICAgICAgICBjb25zdCBiYXNlSW5kZXggPSB0aGlzLl9jdXJyZW50TWVzaEJhc2VJbmRleDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGljZXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgYnVmZmVyLnB1c2goYmFzZUluZGV4ICsgaW5kaWNlc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZXMgdHJpYW5nbGUgaW5kaWNlcyBmcm9tIGFuIGFycmF5IG9mIGluZGljZXMgb2YgYSB0cmlhbmdsZSBzdHJpcFxyXG4gICAgICogKGFzIGluIEdMKSBhbmQgd3JpdGVzIGdlbmVyYXRlZCB0cmlwbGV0cyB0byB0aGUgbWFuYWdlZCBpbmRleCBidWZmZXIuXHJcbiAgICAgKiBAc2VlIE9wZW5HTCBFUyAyLjAgU3BlYywgwqcyLjYuMVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpbmRpY2VzIEluZGljZXMgb2YgdGhlIHN0cmlwLlxyXG4gICAgICovXHJcbiAgICB3cml0ZUluZGljZXNGb3JTdHJpcChpbmRpY2VzKSB7XHJcbiAgICAgICAgdGhpcy5fZW5zdXJlRW5vdWdoSW5kZXhCdWZmZXJTcGFjZSgzICogKGluZGljZXMubGVuZ3RoIC0gMikpO1xyXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuX2luZGV4QnVmZmVyO1xyXG4gICAgICAgIGNvbnN0IGJhc2VJbmRleCA9IHRoaXMuX2N1cnJlbnRNZXNoQmFzZUluZGV4O1xyXG4gICAgICAgIGZvciAoY29uc3QgaSBvZiBnZW5lcmF0ZVN0cmlwKGluZGljZXMubGVuZ3RoKSkge1xyXG4gICAgICAgICAgICBidWZmZXIucHVzaChiYXNlSW5kZXggKyBpbmRpY2VzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlcyB0cmlhbmdsZSBpbmRpY2VzIGZyb20gYSBjb250aW51b3VzIHRyaWFuZ2xlIHN0cmlwIG9mIGEgZ2l2ZW5cclxuICAgICAqIGxlbmd0aCBhbmQgd3JpdGVzIGdlbmVyYXRlZCB0cmlwbGV0cyB0byBtYW5hZ2VkIGluZGV4IGJ1ZmZlci5cclxuICAgICAqIEBzZWUgT3BlbkdMIEVTIDIuMCBTcGVjLCDCpzIuNi4xXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGluZGV4Q291bnRcclxuICAgICAqIEBwYXJhbSBiYXNlSW5kZXhJbk1lc2hcclxuICAgICAqL1xyXG4gICAgd3JpdGVJbmRpY2VzRm9yQ29udGludW91c1N0cmlwKGluZGV4Q291bnQsIGJhc2VJbmRleEluTWVzaCA9IDApIHtcclxuICAgICAgICB0aGlzLl9lbnN1cmVFbm91Z2hJbmRleEJ1ZmZlclNwYWNlKDMgKiAoaW5kZXhDb3VudCAtIDIpKTtcclxuICAgICAgICBjb25zdCBidWZmZXIgPSB0aGlzLl9pbmRleEJ1ZmZlcjtcclxuICAgICAgICBjb25zdCBiYXNlSW5kZXggPSB0aGlzLl9jdXJyZW50TWVzaEJhc2VJbmRleCArIGJhc2VJbmRleEluTWVzaDtcclxuICAgICAgICBmb3IgKGNvbnN0IGkgb2YgZ2VuZXJhdGVTdHJpcChpbmRleENvdW50KSkge1xyXG4gICAgICAgICAgICBidWZmZXIucHVzaChiYXNlSW5kZXggKyBpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlcyB0cmlhbmdsZSBpbmRpY2VzIGZyb20gYW4gYXJyYXkgb2YgaW5kaWNlcyBvZiBhIHRyaWFuZ2xlIGZhbiAoYXNcclxuICAgICAqIGluIEdMKSBhbmQgd3JpdGVzIGdlbmVyYXRlZCB0cmlwbGV0cyB0byB0aGUgbWFuYWdlZCBpbmRleCBidWZmZXIuXHJcbiAgICAgKiBAc2VlIE9wZW5HTCBFUyAyLjAgU3BlYywgwqcyLjYuMVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpbmRpY2VzIEluZGljZXMgb2YgdGhlIHN0cmlwLlxyXG4gICAgICovXHJcbiAgICB3cml0ZUluZGljZXNGb3JGYW4oaW5kaWNlcykge1xyXG4gICAgICAgIHRoaXMuX2Vuc3VyZUVub3VnaEluZGV4QnVmZmVyU3BhY2UoMyAqIChpbmRpY2VzLmxlbmd0aCAtIDIpKTtcclxuICAgICAgICBjb25zdCBidWZmZXIgPSB0aGlzLl9pbmRleEJ1ZmZlcjtcclxuICAgICAgICBjb25zdCBiYXNlSW5kZXggPSB0aGlzLl9jdXJyZW50TWVzaEJhc2VJbmRleDtcclxuICAgICAgICBmb3IgKGNvbnN0IGkgb2YgZ2VuZXJhdGVGYW4oaW5kaWNlcy5sZW5ndGgpKSB7XHJcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoKGJhc2VJbmRleCArIGluZGljZXNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJhdGVzIHRyaWFuZ2xlIGluZGljZXMgZnJvbSBhIGNvbnRpbnVvdXMgdHJpYW5nbGUgZmFuIG9mIGEgZ2l2ZW4gbGVuZ3RoXHJcbiAgICAgKiBhbmQgd3JpdGVzIGdlbmVyYXRlZCB0cmlwbGV0cyB0byBtYW5hZ2VkIGluZGV4IGJ1ZmZlci5cclxuICAgICAqIEBzZWUgT3BlbkdMIEVTIDIuMCBTcGVjLCDCpzIuNi4xXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGluZGV4Q291bnRcclxuICAgICAqIEBwYXJhbSBiYXNlSW5kZXhJbk1lc2hcclxuICAgICAqL1xyXG4gICAgd3JpdGVJbmRpY2VzRm9yQ29udGludW91c0ZhbihpbmRleENvdW50LCBiYXNlSW5kZXhJbk1lc2ggPSAwKSB7XHJcbiAgICAgICAgdGhpcy5fZW5zdXJlRW5vdWdoSW5kZXhCdWZmZXJTcGFjZSgzICogKGluZGV4Q291bnQgLSAyKSk7XHJcbiAgICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5faW5kZXhCdWZmZXI7XHJcbiAgICAgICAgY29uc3QgYmFzZUluZGV4ID0gYmFzZUluZGV4SW5NZXNoICsgdGhpcy5fY3VycmVudE1lc2hCYXNlSW5kZXg7XHJcbiAgICAgICAgZm9yIChjb25zdCBpIG9mIGdlbmVyYXRlRmFuKGluZGV4Q291bnQpKSB7XHJcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoKGJhc2VJbmRleCArIGkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRW5kcyBjdXJyZW50IG1lc2ggYW5kIGltcGxpY2l0bHkgc3RhcnRzIGEgbmV3IG9uZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBJbnRlcm5hbCBpbmRleCBvZiB2ZXJ0ZXggYW5kIGluZGV4IGJ1ZmZlcnMgdGhlIG1lc2ggd2FzIHdyaXR0ZW5cclxuICAgICAqICAgICAgdG8gYW5kIGl0cyBtZW1vcnkgbG9jYXRpb24gaW4gdGhlbS5cclxuICAgICAqL1xyXG4gICAgZW5kTWVzaCgpIHtcclxuICAgICAgICBjb25zdCBjdXJyZW50TWVzaFZlcnRleE9mZnNldCA9IHRoaXMuX2N1cnJlbnRNZXNoVmVydGV4T2Zmc2V0O1xyXG4gICAgICAgIGNvbnN0IHZlcnRleE9jY3VwaWVkU2l6ZSA9IHRoaXMuX3ZlcnRleEJ1ZmZlci5vY2N1cGllZFNpemU7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudE1lc2hWZXJ0ZXhPZmZzZXQgPSB2ZXJ0ZXhPY2N1cGllZFNpemU7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudE1lc2hCYXNlSW5kZXggPSAodmVydGV4T2NjdXBpZWRTaXplIDw8IDIpIC8gdGhpcy5fdmVydGV4Qnl0ZVNpemU7XHJcbiAgICAgICAgY29uc3QgY3VycmVudE1lc2hJbmRleE9mZnNldCA9IHRoaXMuX2N1cnJlbnRNZXNoSW5kZXhPZmZzZXQ7XHJcbiAgICAgICAgY29uc3QgaW5kZXhPY2N1cGllZFNpemUgPSB0aGlzLl9pbmRleEJ1ZmZlci5vY2N1cGllZFNpemU7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudE1lc2hJbmRleE9mZnNldCA9IGluZGV4T2NjdXBpZWRTaXplO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHZlcnRleEJ5dGVPZmZzZXQ6IGN1cnJlbnRNZXNoVmVydGV4T2Zmc2V0IDw8IDIsXHJcbiAgICAgICAgICAgIHZlcnRleEJ5dGVMZW5ndGg6IHZlcnRleE9jY3VwaWVkU2l6ZSAtIGN1cnJlbnRNZXNoVmVydGV4T2Zmc2V0IDw8IDIsXHJcbiAgICAgICAgICAgIGluZGV4Qnl0ZU9mZnNldDogY3VycmVudE1lc2hJbmRleE9mZnNldCA8PCAxLFxyXG4gICAgICAgICAgICBpbmRleEJ5dGVMZW5ndGg6IGluZGV4T2NjdXBpZWRTaXplIC0gY3VycmVudE1lc2hJbmRleE9mZnNldCA8PCAxLFxyXG4gICAgICAgICAgICAvLyBXZSBjYW4ndCByZXR1cm4gYWN0dWFsIGJ1ZmZlciByZWZlcmVuY2Ugc2luY2UgaXQgY2FuIGNoYW5nZSBpZlxyXG4gICAgICAgICAgICAvLyB0aGUgYnVmZmVyIGdldHMgcmVhbGxvY2F0ZWQuXHJcbiAgICAgICAgICAgIGJ1ZmZlckluZGV4OiB0aGlzLl92ZXJ0ZXhCdWZmZXJzLmxlbmd0aCAtIDFcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGN1cnJlbnRseSBvd25lZCBidWZmZXIgZGF0YS4gVGhpcyBjYWxsJ3MgYmV0dGVyXHJcbiAgICAgKiBtYWRlIHdoZW4geW91J3JlIGRvbmUgd2l0aCB0aGUgd3JpdGVyIHNpbmNlIGlmIHRoZSB3cml0ZXIgZGVjaWRlcyB0b1xyXG4gICAgICogcmVzaXplIGFueSBvZiB0aGUgYnVmZmVycyBzb21lIG9mIHRoZSByZWZlcmVuY2VzIGluIHRoZSByZXR1cm5lZCBhcnJheVxyXG4gICAgICogbWF5IGJlY29tZSBvdXRkYXRlZC5cclxuICAgICAqL1xyXG4gICAgZ2V0QnVmZmVycygpIHtcclxuICAgICAgICByZXR1cm4gemlwKHRoaXMuX3ZlcnRleEJ1ZmZlcnMsIHRoaXMuX2luZGV4QnVmZmVycywgKHZlcnRleEJ1ZmZlciwgaW5kZXhCdWZmZXIpID0+ICh7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlcjogdmVydGV4QnVmZmVyLmFzVWludDMyQXJyYXkoKSxcclxuICAgICAgICAgICAgaW5kZXhCdWZmZXI6IGluZGV4QnVmZmVyLmFzVWludDE2QXJyYXkoKVxyXG4gICAgICAgIH0pKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBvZmZzZXQgaW4gdGhlIGN1cnJlbnQgdmVydGV4IGJ1ZmZlciB0byB0aGUgbG9jYXRpb24gd2hlcmUgbmV4dFxyXG4gICAgICogcGllY2Ugb2YgZGF0YSB3aWxsIGJlIHdyaXR0ZW4uXHJcbiAgICAgKi9cclxuICAgIGdldEN1cnJlbnRWZXJ0ZXhCdWZmZXJCeXRlT2Zmc2V0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl92ZXJ0ZXhCdWZmZXIub2NjdXBpZWRTaXplIDw8IDI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgaW5kZXggb2YgY3VycmVudGx5IHdyaXR0ZW4gdmVydGV4IHN0cnVjdHVyZSBpbiB0aGUgY3VycmVudCB2ZXJ0ZXhcclxuICAgICAqIGJ1ZmZlci5cclxuICAgICAqL1xyXG4gICAgZ2V0Q3VycmVudFZlcnRleElkeCgpIHtcclxuICAgICAgICByZXR1cm4gKCh0aGlzLl92ZXJ0ZXhCdWZmZXIub2NjdXBpZWRTaXplIDw8IDIpIC8gdGhpcy5fdmVydGV4Qnl0ZVNpemUgfCAwKSAtIHRoaXMuX2N1cnJlbnRNZXNoQmFzZUluZGV4O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYSBmbG9hdGluZyBwb2ludCB2YWx1ZSB0byB0aGUgY3VycmVudCB2ZXJ0ZXggYnVmZmVyIGFuZCBhZHZhbmNlc1xyXG4gICAgICogdGhlIG9mZnNldCBieSA0IGJ5dGVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgd3JpdHRlbi5cclxuICAgICAqL1xyXG4gICAgX3dyaXRlRmxvYXQzMih2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX2Vuc3VyZUVub3VnaFZlcnRleEJ1ZmZlclNwYWNlKCk7XHJcbiAgICAgICAgdGhpcy5fdmVydGV4QnVmZmVyLnB1c2hGbG9hdDMyKHZhbHVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGFuIHVuc2lnbmVkIGludGVnZXIgdmFsdWUgdG8gdGhlIGN1cnJlbnQgdmVydGV4IGJ1ZmZlciBhbmQgYWR2YW5jZXNcclxuICAgICAqIHRoZSBvZmZzZXQgYnkgNCBieXRlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIHdyaXR0ZW4uXHJcbiAgICAgKi9cclxuICAgIF93cml0ZVdvcmQodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9lbnN1cmVFbm91Z2hWZXJ0ZXhCdWZmZXJTcGFjZSgpO1xyXG4gICAgICAgIHRoaXMuX3ZlcnRleEJ1ZmZlci5wdXNoVWludDMyKHZhbHVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGFuIHVuc2lnbmVkIHNob3J0IHZhbHVlIHRvIHRoZSBjdXJyZW50IHZlcnRleCBidWZmZXIgYW5kIGFkdmFuY2VzXHJcbiAgICAgKiB0aGUgb2Zmc2V0IGJ5IDIgYnl0ZXMuIFBhc3NlZCB2YWx1ZXMgd2lsbCBiZSB0cnVuY2F0ZWQgdG8gMTYgYml0cy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIHdyaXR0ZW4uXHJcbiAgICAgKi9cclxuICAgIF93cml0ZUhhbGZXb3Jkcyh2MSwgdjIpIHtcclxuICAgICAgICB0aGlzLl93cml0ZVdvcmQodjIgPDwgMTYgfCB2MSAmIDB4ZmZmZik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhbiB1bnNpZ25lZCBieXRlIHZhbHVlIHRvIHRoZSBjdXJyZW50IHZlcnRleCBidWZmZXIgYW5kIGFkdmFuY2VzXHJcbiAgICAgKiB0aGUgb2Zmc2V0IGJ5IDEgYnl0ZS4gUGFzc2VkIHZhbHVlcyB3aWxsIGJlIHRydW5jYXRlZCB0byA4IGJpdHMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBiZSB3cml0dGVuLlxyXG4gICAgICovXHJcbiAgICBfd3JpdGVCeXRlcyh2MSwgdjIsIHYzLCB2NCkge1xyXG4gICAgICAgIHRoaXMuX3dyaXRlV29yZCh2NCA8PCAyNCB8XHJcbiAgICAgICAgICAgICh2MyAmIDB4ZmYpIDw8IDE2IHxcclxuICAgICAgICAgICAgKHYyICYgMHhmZikgPDwgOCB8XHJcbiAgICAgICAgICAgIHYxICYgMHhmZik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVuY29kZXMgYSB3b3JsZCBjb29yZGluYXRlIHZlY3RvciBhcyBhIHBhaXIgb2YgMzItYml0IGludGVnZXJzIChzcGxpdHRpbmdcclxuICAgICAqIHRoZW0gaW4gdHVybiBpbnRvIHRvIDE2LWJpdCBvbmVzKS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYyBUaGUgd29ybGQgY29vcmRpbmF0ZS5cclxuICAgICAqL1xyXG4gICAgX3dyaXRlV29ybGRDb29yZGluYXRlKGMpIHtcclxuICAgICAgICAvLyBUbyBhdm9pZCB1c2luZyBHUFUgc2luZ2VkIGludGVnZXIgY29udmVyc2lvbnMgd2Ugc2hpZnQgYW5kIHNjYWxlIHdvcmxkXHJcbiAgICAgICAgLy8gY29vcmRpbmF0ZXMgc28gdGhleSdyZSBpbiBbMCwgMV0gcmFuZ2UgKGluc3RlYWQgb2YgWy0xLCAxXSkgYW5kIHRoZW5cclxuICAgICAgICAvLyBlbmNvZGVkIGFzIHVuc2lnbmVkIDMyIGJpdCBpbnRlZ2VycyBzcGxpdCBpbnRvIHRvIDE2IGJpdCBvbmVzLlxyXG4gICAgICAgIGNvbnN0IHhVaW50MzIgPSBmbG9hdFRvVWludDMyKDAuNSAqIChjLnggKyAxKSk7XHJcbiAgICAgICAgY29uc3QgeVVpbnQzMiA9IGZsb2F0VG9VaW50MzIoMC41ICogKGMueSArIDEpKTtcclxuICAgICAgICB0aGlzLl93cml0ZUhhbGZXb3Jkcyh4VWludDMyID4+PiAxNiwgeVVpbnQzMiA+Pj4gMTYpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlSGFsZldvcmRzKHhVaW50MzIsIHlVaW50MzIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlcyBuZXcgYmlnZ2VyIHNpemUgb2YgYSB2ZXJ0ZXggYnVmZmVyIGJhc2VkIG9uIGl0cyBjdXJyZW50IHNpemUuIEJ5XHJcbiAgICAgKiBkZWZhdWx0IGp1c3QgZG91YmxlIHRoZSBjdXJyZW50IHNpemUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGN1cnJlbnRCeXRlU2l6ZSBDdXJyZW50IHNpemUgb2YgdGhlIGluZGV4IGJ1ZmZlciBpbiBieXRlcy5cclxuICAgICAqIEByZXR1cm5zIFRoZSBuZXcgc2l6ZS5cclxuICAgICAqL1xyXG4gICAgX2dldE5leHRWZXJ0ZXhCdWZmZXJCeXRlU2l6ZShjdXJyZW50Qnl0ZVNpemUpIHtcclxuICAgICAgICByZXR1cm4gY3VycmVudEJ5dGVTaXplIDw8IDE7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbXB1dGVzIG5ldyBiaWdnZXIgc2l6ZSBvZiBhbiBpbmRleCBidWZmZXIgYmFzZWQgb24gaXRzIGN1cnJlbnQgc2l6ZS4gQnlcclxuICAgICAqIGRlZmF1bHQganVzdCBkb3VibGUgdGhlIGN1cnJlbnQgc2l6ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3VycmVudFVpbnQxNlNpemUgQ3VycmVudCBzaXplIG9mIHRoZSBpbmRleCBidWZmZXIgaW4gc2hvcnRzLlxyXG4gICAgICogQHJldHVybnMgVGhlIG5ldyBzaXplLlxyXG4gICAgICovXHJcbiAgICBfZ2V0TmV4dEluZGV4QnVmZmVyVWludDE2U2l6ZShjdXJyZW50VWludDE2U2l6ZSkge1xyXG4gICAgICAgIHJldHVybiBjdXJyZW50VWludDE2U2l6ZSA8PCAxO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFbnN1cmVzIHRoYXQgdGhlIG1hbmFnZWQgdmVydGV4IGJ1ZmZlciBoYXMgZW5vdWdoIHNwYWNlIHRvIGZpdCBpbiBhIGNodW5rXHJcbiAgICAgKiBvZiBkYXRhIG9mIGEgZ2l2ZW4gc2l6ZS4gRWl0aGVyIGRvZXMgbm90aGluZywgcmVzaXplcyB0aGUgY3VycmVudCB2ZXJ0ZXhcclxuICAgICAqIGJ1ZmZlciBvciBjcmVhdGVzIGVudGlyZWx5IG5ldyBwYWlyIG9mIHZlcnRleCBhbmQgaW5kZXggYnVmZmVycy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmFsdWVTaXplIEJ5dGUgc2l6ZSBvZiB0aGUgZGF0YSB0aGF0IG5lZWRzIHRvIGJlIGFjY29tbW9kYXRlZCBieVxyXG4gICAgICogICAgICB0aGUgdmVydGV4IGJ1ZmZlci5cclxuICAgICAqL1xyXG4gICAgX2Vuc3VyZUVub3VnaFZlcnRleEJ1ZmZlclNwYWNlKCkge1xyXG4gICAgICAgIGNvbnN0IHZlcnRleEJ1ZmZlciA9IHRoaXMuX3ZlcnRleEJ1ZmZlcjtcclxuICAgICAgICBpZiAoIXZlcnRleEJ1ZmZlci5pc0Z1bGwpIHtcclxuICAgICAgICAgICAgLy8gV2UgaGF2ZSBlbm91Z2ggc3BhY2UsIHNvIG5vdGhpbmcgdG8gYmUgZG9uZS5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodmVydGV4QnVmZmVyLmJ5dGVTaXplIDwgdGhpcy5fbWF4VmVydGV4QnVmZmVyQnl0ZVNpemUpIHtcclxuICAgICAgICAgICAgLy8gSWYgd2UgY2FuIGp1c3QgcmVzaXplIHRoZSBjdXJyZW50IHZlcnRleCBidWZmZXIsIGRvIHRoYXQuXHJcbiAgICAgICAgICAgIHRoaXMuX3ZlcnRleEJ1ZmZlci5leHRlbmQodGhpcy5fZ2V0TmV4dFZlcnRleEJ1ZmZlckJ5dGVTaXplKHZlcnRleEJ1ZmZlci5ieXRlU2l6ZSkpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gZW5vdWdoIHNwYWNlIGluIHRoZSBjdXJyZW50IHZlcnRleCBidWZmZXIgYW5kIGl0J3NcclxuICAgICAgICAvLyBhbHJlYWR5IG9mIG1heGltdW0gc2l6ZSwgYWxsb2NhdGUgbmV3IHZlcnRleCBhbmQgaW5kZXggYnVmZmVycyBhbmRcclxuICAgICAgICAvLyBjb3B5IGRhdGEgb2YgdGhlIGN1cnJlbnQgbWVzaCB0byB0aGVtIGZyb20gdGhlIGN1cnJlbnQgYnVmZmVycy5cclxuICAgICAgICAvLyBUaGVuIG1ha2UgdGhvc2UgYnVmZmVyIHRoZSBjdXJyZW50IG9uZXMuXHJcbiAgICAgICAgY29uc3QgY3VycmVudE1lc2hWZXJ0ZXhPZmZzZXQgPSB0aGlzLl9jdXJyZW50TWVzaFZlcnRleE9mZnNldDtcclxuICAgICAgICBjb25zdCBjdXJyZW50TWVzaFZlcnRleEJ5dGVTaXplID0gKHZlcnRleEJ1ZmZlci5vY2N1cGllZFNpemUgLSBjdXJyZW50TWVzaFZlcnRleE9mZnNldCkgKiA0O1xyXG4gICAgICAgIGNvbnN0IG1heFZlcnRleEJ1ZmZlckJ5dGVTaXplID0gdGhpcy5fbWF4VmVydGV4QnVmZmVyQnl0ZVNpemU7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRNZXNoVmVydGV4Qnl0ZVNpemUgPT09IG1heFZlcnRleEJ1ZmZlckJ5dGVTaXplKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWVzaCBpcyB0b28gYmlnIHRvIGZpdCBpbi4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IG5ld1ZlcnRleEJ1ZmZlckJ5dGVTaXplID0gdGhpcy5faW5pdFZlcnRleEJ1ZmZlckJ5dGVTaXplO1xyXG4gICAgICAgIC8vIEluaXRpYWwgdmVydGV4IGJ1ZmZlciBzaXplIG1heSBiZSB0b28gc21hbGwgdG8gYWNjb21tb2RhdGUgdGhlIGN1cnJlbnRcclxuICAgICAgICAvLyBtZXNoLCBzbyB3ZSBmaW5kIG5leHQgYmlnZ2VyIHNpemUgdGhhdCBpcyBzdWZmaWNpZW50LlxyXG4gICAgICAgIHdoaWxlIChuZXdWZXJ0ZXhCdWZmZXJCeXRlU2l6ZSA8PSBjdXJyZW50TWVzaFZlcnRleEJ5dGVTaXplKSB7XHJcbiAgICAgICAgICAgIG5ld1ZlcnRleEJ1ZmZlckJ5dGVTaXplID0gdGhpcy5fZ2V0TmV4dFZlcnRleEJ1ZmZlckJ5dGVTaXplKG5ld1ZlcnRleEJ1ZmZlckJ5dGVTaXplKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbmV3VmVydGV4QnVmZmVyID0gbmV3IFZlcnRleEJ1ZmZlcihuZXdWZXJ0ZXhCdWZmZXJCeXRlU2l6ZSk7XHJcbiAgICAgICAgVmVydGV4QnVmZmVyLnRyYW5zZmVyRGF0YVRhaWwodmVydGV4QnVmZmVyLCBuZXdWZXJ0ZXhCdWZmZXIsIGN1cnJlbnRNZXNoVmVydGV4T2Zmc2V0KTtcclxuICAgICAgICB0aGlzLl92ZXJ0ZXhCdWZmZXIgPSBuZXdWZXJ0ZXhCdWZmZXI7XHJcbiAgICAgICAgdGhpcy5fdmVydGV4QnVmZmVycy5wdXNoKG5ld1ZlcnRleEJ1ZmZlcik7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudE1lc2hWZXJ0ZXhPZmZzZXQgPSAwO1xyXG4gICAgICAgIGNvbnN0IGluZGV4QnVmZmVyID0gdGhpcy5faW5kZXhCdWZmZXI7XHJcbiAgICAgICAgY29uc3QgY3VycmVudE1lc2hJbmRleE9mZnNldCA9IHRoaXMuX2N1cnJlbnRNZXNoSW5kZXhPZmZzZXQ7XHJcbiAgICAgICAgY29uc3QgY3VycmVudE1lc2hJbmRleFNpemUgPSBpbmRleEJ1ZmZlci5vY2N1cGllZFNpemUgLSBjdXJyZW50TWVzaEluZGV4T2Zmc2V0O1xyXG4gICAgICAgIGxldCBuZXdJbmRleEJ1ZmZlclNpemUgPSB0aGlzLl9pbml0SW5kZXhCdWZmZXJVaW50MTZTaXplO1xyXG4gICAgICAgIC8vIEluaXRpYWwgaW5kZXggYnVmZmVyIHNpemUgbWF5IGJlIHRvbyBzbWFsbCB0byBhY2NvbW1vZGF0ZSB0aGUgY3VycmVudFxyXG4gICAgICAgIC8vIG1lc2gsIHNvIHdlIGZpbmQgbmV4dCBiaWdnZXIgc2l6ZSB0aGF0IGlzIHN1ZmZpY2llbnQuXHJcbiAgICAgICAgd2hpbGUgKG5ld0luZGV4QnVmZmVyU2l6ZSA8PSBjdXJyZW50TWVzaEluZGV4U2l6ZSkge1xyXG4gICAgICAgICAgICBuZXdJbmRleEJ1ZmZlclNpemUgPSB0aGlzLl9nZXROZXh0SW5kZXhCdWZmZXJVaW50MTZTaXplKG5ld0luZGV4QnVmZmVyU2l6ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG5ld0luZGV4QnVmZmVyID0gbmV3IEluZGV4QnVmZmVyKG5ld0luZGV4QnVmZmVyU2l6ZSk7XHJcbiAgICAgICAgLy8gU2luY2UgdGhlIGN1cnJlbnQgbWVzaCdzIGNvcGllZCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBuZXcgdmVydGV4XHJcbiAgICAgICAgLy8gYnVmZmVyLCBpdCdzIGJhc2UgaW5kZXggbm93IGlzIDAuIElmIHRoZSBtZXNoIGhhcyBhbnkgd3JpdHRlbiBpbmRpY2VzLFxyXG4gICAgICAgIC8vIHRoZXkncmUgYWxyZWFkeSBvZmZzZXQgYnkgdGhlIG9sZCBiYXNlIGluZGV4LlxyXG4gICAgICAgIEluZGV4QnVmZmVyLnRyYW5zZmVyRGF0YVRhaWwoaW5kZXhCdWZmZXIsIG5ld0luZGV4QnVmZmVyLCB0aGlzLl9jdXJyZW50TWVzaEJhc2VJbmRleCwgY3VycmVudE1lc2hJbmRleE9mZnNldCk7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudE1lc2hCYXNlSW5kZXggPSAwO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRNZXNoSW5kZXhPZmZzZXQgPSAwO1xyXG4gICAgICAgIHRoaXMuX2luZGV4QnVmZmVyID0gbmV3SW5kZXhCdWZmZXI7XHJcbiAgICAgICAgdGhpcy5faW5kZXhCdWZmZXJzLnB1c2gobmV3SW5kZXhCdWZmZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFbnN1cmVzIHRoYXQgdGhlIG1hbmFnZWQgaW5kZXggYnVmZmVyIGhhcyBlbm91Z2ggc3BhY2UgdG8gZml0IGluIGEgZ2l2ZW5cclxuICAgICAqIG51bWJlciBvZiBpbmRpY2VzLiBFaXRoZXIgZG9lcyBub3RoaW5nIG9yIHJlc2l6ZXMgdGhlIGN1cnJlbnQgaW5kZXhcclxuICAgICAqIGJ1ZmZlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaW5kZXhDb3VudCBOdW1iZXIgb2YgaW5kaWNlcyBjbGllbnQgd2FudHMgdG8gd3JpdGUgdG8gdGhlIG1hbmFnZWRcclxuICAgICAqICAgICAgaW5kZXggYnVmZmVyLlxyXG4gICAgICovXHJcbiAgICBfZW5zdXJlRW5vdWdoSW5kZXhCdWZmZXJTcGFjZShpbmRleENvdW50KSB7XHJcbiAgICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5faW5kZXhCdWZmZXI7XHJcbiAgICAgICAgY29uc3QgcmVxdWlyZWRTaXplID0gYnVmZmVyLm9jY3VwaWVkU2l6ZSArIGluZGV4Q291bnQ7XHJcbiAgICAgICAgaWYgKHJlcXVpcmVkU2l6ZSA8PSBidWZmZXIuc2l6ZSkge1xyXG4gICAgICAgICAgICAvLyBXZSBoYXZlIGVub3VnaCBzcGFjZSBzbyBub3RoaW5nIHRvIGJlIGRvbmUuXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IG5ld0J1ZmZlclNpemUgPSBidWZmZXIuc2l6ZTtcclxuICAgICAgICAvLyBMZXQncyBjb21wdXRlIG5ldyBsYXJnZXIgc2l6ZSBvZiB0aGUgaW5kZXggYnVmZmVyIHVudGlsIHdlIGNhblxyXG4gICAgICAgIC8vIGFjY29tbW9kYXRlIGluY29taW5nIGRhdGEuXHJcbiAgICAgICAgd2hpbGUgKHJlcXVpcmVkU2l6ZSA+IG5ld0J1ZmZlclNpemUpIHtcclxuICAgICAgICAgICAgbmV3QnVmZmVyU2l6ZSA9IHRoaXMuX2dldE5leHRJbmRleEJ1ZmZlclVpbnQxNlNpemUobmV3QnVmZmVyU2l6ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2luZGV4QnVmZmVyLmV4dGVuZChuZXdCdWZmZXJTaXplKTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL2J1ZmZlcl93cml0ZXIudHNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IFJlZmVyZW5jZUNvdW50ZWQgZnJvbSAnLi4vdXRpbC9yZWZfY291bnRlZCc7XHJcbi8qKlxyXG4gKiBCYXNlIGNsYXNzIGZvciBwcmltaXRpdmUgb2JqZWN0cyB0aGF0IGFyZSByZWFkeSB0byBiZSBmZWQgdG8gdGhlIHJlbmRlcmVyLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVuZGVyYWJsZVByaW1pdGl2ZSBleHRlbmRzIFJlZmVyZW5jZUNvdW50ZWQge1xyXG4gICAgY29uc3RydWN0b3IobWVtb3J5U3ViQ2h1bmspIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMubWVtb3J5U3ViQ2h1bmsgPSBtZW1vcnlTdWJDaHVuaztcclxuICAgIH1cclxuICAgIF9kZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMubWVtb3J5U3ViQ2h1bmsuZGVzdHJveSgpO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3ByaW1pdGl2ZS9yZW5kZXJhYmxlX3ByaW1pdGl2ZS50c1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICogU2VhcmNoZXMgZm9yIHRoZSBmaXJzdCBjb2xsZWN0aW9uIGl0ZW0gc2F0aXNmeWluZyBhIHByZWRpY2F0ZS5cclxuICpcclxuICogQHBhcmFtIGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24uXHJcbiAqIEBwYXJhbSBwcmVkaWNhdGUgVGhlIHByZWRpY2F0ZS5cclxuICogQHJldHVybnMgVGhlIGZpcnN0IGl0ZW0gc2F0aXNmeWluZyB0aGUgcHJlZGljYXRlIG9yIGB1bmRlZmluZWRgIGlmIG5vbmUgZm91bmQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZmluZEluSXRlcmFibGUoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XHJcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgY29sbGVjdGlvbikge1xyXG4gICAgICAgIGlmIChwcmVkaWNhdGUoaXRlbSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGl0ZW07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuO1xyXG59XHJcbi8qKlxyXG4gKiBUcmFuc2Zvcm1zIGEgY29sbGVjdGlvbiB0byBhbm90aGVyIG9uZS5cclxuICpcclxuICogQHBhcmFtIGNvbGxlY3Rpb24gVGhlIHNvdXJjZSBjb2xsZWN0aW9uLlxyXG4gKiBAcGFyYW0gbWFwcGVyIEEgZnVuY3Rpb24gcHJvZHVjaW5nIGl0ZW1zIGZvciBkZXN0aW5hdGlvbiBjb2xsZWN0aW9uLlxyXG4gKiBAcmV0dXJucyBDb2xsZWN0aW9uIG9mIHByb2R1Y2VkIGl0ZW1zLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uKiBtYXBJdGVyYWJsZShjb2xsZWN0aW9uLCBtYXBwZXIpIHtcclxuICAgIGZvciAoY29uc3QgaXRlbSBvZiBjb2xsZWN0aW9uKSB7XHJcbiAgICAgICAgeWllbGQgbWFwcGVyKGl0ZW0pO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDaG9vc2VzIGl0ZW1zIG9mIGEgY29sbGVjdGlvbiBzYXRpc2Z5aW5nIGEgcHJlZGljYXRlLlxyXG4gKlxyXG4gKiBAcGFyYW0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbi5cclxuICogQHBhcmFtIHByZWRpY2F0ZSBUaGUgcHJlZGljYXRlLlxyXG4gKiBAcmV0dXJucyBDb2xsZWN0aW9uIG9mIGNob3NlbiBpdGVtcy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiogZmlsdGVySXRlcmFibGUoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XHJcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgY29sbGVjdGlvbikge1xyXG4gICAgICAgIGlmIChwcmVkaWNhdGUoaXRlbSkpIHtcclxuICAgICAgICAgICAgeWllbGQgaXRlbTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFRyYXZlcnNlcyBhIGNvbGxlY3Rpb24gZnJvbSBsZWZ0IHRvIHJpZ2h0IHJlY29tcHV0aW5nIGFuIGFjY3VtdWxhdG9yIG9uIGV2ZXJ5XHJcbiAqIGl0ZXJhdGlvbi5cclxuICpcclxuICogQHBhcmFtIGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24uXHJcbiAqIEBwYXJhbSByZWR1Y2VyIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGNvbXB1dGUgbmV4dCB2YWx1ZSBvZiB0aGUgYWNjdW11bGF0b3IuXHJcbiAqIEBwYXJhbSBpbml0aWFsXHJcbiAqIEByZXR1cm5zIFZhbHVlIG9mIHRoZSBhY2N1bXVsYXRvci5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiByZWR1Y2VJdGVyYWJsZShjb2xsZWN0aW9uLCByZWR1Y2VyLCBpbml0aWFsKSB7XHJcbiAgICBsZXQgcmVzdWx0ID0gaW5pdGlhbDtcclxuICAgIGZvciAoY29uc3QgaXRlbSBvZiBjb2xsZWN0aW9uKSB7XHJcbiAgICAgICAgcmVzdWx0ID0gcmVkdWNlcihyZXN1bHQsIGl0ZW0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG4vKipcclxuICogQ2hlY2tzIGlmIHRoZXJlJ3MgYXQgbGVhc3Qgb25lIGl0ZW0gaW4gYSBjb2xsZWN0aW9uIHNhdGlzZnlpbmcgYSBwcmVkaWNhdGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uLlxyXG4gKiBAcGFyYW0gcHJlZGljYXRlIFRoZSBwcmVkaWNhdGUuXHJcbiAqIEByZXR1cm5zIGB0cnVlYCBpZiBmb3IgYXQgbGVhc3Qgb25lIGl0ZW0gaW4gdGhlIGNvbGxlY3Rpb24gdGhlIHByZWRpY2F0ZSByZXR1cm5zXHJcbiAqICAgICAgYHRydWVgIGFuZCBgZmFsc2VgIG90aGVyd2lzZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBvbmVPZkl0ZXJhYmxlKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xyXG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGNvbGxlY3Rpb24pIHtcclxuICAgICAgICBpZiAocHJlZGljYXRlKGl0ZW0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG4vKipcclxuICogQ2hlY2tzIGlmIGFsbCBpdGVtcyBvZiBhIGNvbGxlY3Rpb24gc2F0aXNmeSBhIHByZWRpY2F0ZS5cclxuICpcclxuICogQHBhcmFtIGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24uXHJcbiAqIEBwYXJhbSBwcmVkaWNhdGUgVGhlIHByZWRpY2F0ZS5cclxuICogQHJldHVybnMgYGZhbHNlYCBpZiBmb3IgYXQgbGVhc3Qgb25lIGl0ZW0gaW4gdGhlIGNvbGxlY3Rpb24gdGhlIHByZWRpY2F0ZSByZXR1cm5zXHJcbiAqICAgICAgYGZhbHNlYCBhbmQgYHRydWVgIG90aGVyd2lzZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBhbGxPZkl0ZXJhYmxlKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xyXG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGNvbGxlY3Rpb24pIHtcclxuICAgICAgICBpZiAoIXByZWRpY2F0ZShpdGVtKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZXMgYW4gaXRlcmF0b3IgZm9yIFtzdGFydEluZGV4LCBzdGFydEluZGV4K2xlbmd0aCkgcmFuZ2UuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24qIHJhbmdlSXRlcmFibGUobGVuZ3RoLCBzdGFydEluZGV4ID0gMCkge1xyXG4gICAgY29uc3QgZW5kSW5kZXggPSBzdGFydEluZGV4ICsgbGVuZ3RoO1xyXG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXg7IGkgPCBlbmRJbmRleDsgaSsrKSB7XHJcbiAgICAgICAgeWllbGQgaTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgZnVuY3Rpb24qIHppcEl0ZXJhYmxlcyh0cywgdXMsIHppcHBlciA9ICh0LCB1KSA9PiBbdCwgdV0pIHtcclxuICAgIGNvbnN0IHRJdGVyYXRvciA9IHRzW1N5bWJvbC5pdGVyYXRvcl0oKTtcclxuICAgIGNvbnN0IHVJdGVyYXRvciA9IHVzW1N5bWJvbC5pdGVyYXRvcl0oKTtcclxuICAgIGZvciAobGV0IHQgPSB0SXRlcmF0b3IubmV4dCgpLCB1ID0gdUl0ZXJhdG9yLm5leHQoKTsgISh0LmRvbmUgfHwgdS5kb25lKTsgdCA9IHRJdGVyYXRvci5uZXh0KCksIHUgPSB1SXRlcmF0b3IubmV4dCgpKSB7XHJcbiAgICAgICAgeWllbGQgemlwcGVyKHQudmFsdWUsIHUudmFsdWUpO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvaXRlcmFibGUudHNcbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIENsYW1wcyBhIHZhbHVlIHRvIGEgZ2l2ZW4gcmFuZ2UuXHJcbiAqXHJcbiAqIEBwYXJhbSB4IFRoZSB2YWx1ZS5cclxuICogQHBhcmFtIG1pbiBTdGFydCBvZiB0aGUgcmFuZ2UuXHJcbiAqIEBwYXJhbSBtYXggRW5kIG9mIHRoZSByYW5nZS5cclxuICogQHJldHVybnMgQ2xhbXBlZCB2YWx1ZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjbGFtcCh4LCBtaW4sIG1heCkge1xyXG4gICAgcmV0dXJuIG1pbiA8IHggPyB4IDwgbWF4ID8geCA6IG1heCA6IG1pbjtcclxufVxyXG4vKipcclxuICogUmVzdHJpY3RzIGEgdmFsdWUgdG8gYSBnaXZlbiBjeWNsZWQgcmFuZ2UsIGkuZS4gZW5kcyBvZiB0aGUgcmFuZ2UgYXJlXHJcbiAqIGVxdWl2YWxlbnQuIEUuZy4gbGlrZSBhbmdsZXMgY2FuIGJlIHJlc3RyaWN0ZWQgdG8gYW55IHJhbmdlIG9mIHNpemUgYDIgKiBQSWAuXHJcbiAqXHJcbiAqIEBwYXJhbSB4IFRoZSB2YWx1ZS5cclxuICogQHBhcmFtIG1pbiBTdGFydCBvZiB0aGUgcmFuZ2UuXHJcbiAqIEBwYXJhbSBtYXggRW5kIG9mIHRoZSByYW5nZS5cclxuICogQHJldHVybnMgUmVzdHJpY3RlZCB2YWx1ZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjeWNsZVJlc3RyaWN0KHgsIG1pbiwgbWF4KSB7XHJcbiAgICBjb25zdCBkID0gbWF4IC0gbWluO1xyXG4gICAgY29uc3QgcyA9ICh4IC0gbWluKSAvIChtYXggLSBtaW4pO1xyXG4gICAgcmV0dXJuIG1pbiArIGQgKiAocyAtIE1hdGguZmxvb3IocykpO1xyXG59XHJcbi8qKlxyXG4gKiBMaW5lYXIgaW50ZXJwb2xhdGlvbi5cclxuICpcclxuICogQHBhcmFtIG1pbiBWYWx1ZSB0aGF0IGNvcnJlc3BvbmQgdG8gMCUgcHJvZ3Jlc3MuXHJcbiAqIEBwYXJhbSBtYXggVmFsdWUgdGhhdCBjb3JyZXNwb25kIHRvIDEwMCUgcHJvZ3Jlc3MuXHJcbiAqIEBwYXJhbSBwcm9ncmVzcyBJbiAwLi4xLjAgcmFuZ2UgdGhhdCBtYXBzIHRvIDAuLjEwMCUgcHJvZ3Jlc3MuIEl0IGlzIGFsbG93ZWQgdG8gcGFzcyBhIHZhbHVlXHJcbiAqICAgICAgb3V0c2lkZSBvZiB0aGlzIHJhbmdlLCB0aGF0IG1lYW5zIHByb2dyZXNzIGdyZWF0ZXIgdGhlbiAxMDAlIG9yIG5lZ2F0aXZlIHByb2dyZXNzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG1peChtaW4sIG1heCwgcHJvZ3Jlc3MpIHtcclxuICAgIHJldHVybiAoMSAtIHByb2dyZXNzKSAqIG1pbiArIHByb2dyZXNzICogbWF4O1xyXG59XHJcbi8qKlxyXG4gKiBBIHN0ZXAgZnVuY3Rpb24gd2l0aCBhIHNtb290aCB0cmFuc2l0aW9uIGJldHdlZW4gZ2l2ZW4gZWRnZXMuIENvbXBsZXRlbHlcclxuICogYW5hbG9nb3VzIHRvIGBzbW9vdGhzdGVwYCBpbiBHTFNMIChHTFNMIEVTIDEuMCDCpzguMykuXHJcbiAqXHJcbiAqIEBwYXJhbSBlZGdlMSBUaGUgc21hbGxlciBlZGdlLlxyXG4gKiBAcGFyYW0gZWRnZTJcclxuICogQHBhcmFtIHggYDBgIGlmIGB4IDwgZWRnZTFgLCBgMWAgaWYgYHggPiBlZGdlMmAgYW5kIGFuIGludGVycG9sYXRlZCB2YWx1ZSBmb3JcclxuICogICAgICBgZWRnZTEgPCB4IDwgZWRnZTJgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNtb290aFN0ZXAoZWRnZTEsIGVkZ2UyLCB4KSB7XHJcbiAgICBjb25zdCBmYWN0b3IgPSBjbGFtcCgoeCAtIGVkZ2UxKSAvIChlZGdlMiAtIGVkZ2UxKSwgMCwgMSk7XHJcbiAgICByZXR1cm4gZmFjdG9yICogZmFjdG9yICogKDMgLSAyICogZmFjdG9yKTtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9tYXRoL3NjYWxhci50c1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICogR2l2ZXMgdGhlIGRldmljZSBwaXhlbCByYXRpb24gaWYgaXQncyBncmVhdGVyIHRoYW4gMSBhbmQgMSBvdGhlcndpc2UuIFRoaXMnc1xyXG4gKiBoZXJlIHB1cmVseSB0byBiZSBjb21wYXRpYmxlIHdpdGgganNhcGkgd2hpY2ggZG9lcyB0aGUgc2FtZSB0aGluZyBmb3IgcmVhc29uc1xyXG4gKiB1bmtub3dzICh0aGFua3MsIGthc2hleSkuXHJcbiAqXHJcbiAqIEByZXR1cm5zIENhcHBlZCBkZXZpY2UgcGl4ZWwgcmF0aW8uXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXREcHIoKSB7XHJcbiAgICByZXR1cm4gZGV2aWNlUGl4ZWxSYXRpbyA+IDEgPyBkZXZpY2VQaXhlbFJhdGlvIDogMTtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL2hkLnRzXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnQgY29uc3QgT1BBUVVFX0JMQUNLID0gY3JlYXRlKDAsIDAsIDAsIDEpO1xyXG5leHBvcnQgY29uc3QgVFJBTlNQQVJFTlRfQkxBQ0sgPSBjcmVhdGUoMCwgMCwgMCwgMCk7XHJcbi8qKlxyXG4gKiBAcGFyYW0gciBSZWQgY29tcG9uZW50IGFzIGEgbm9ybWFsaXplZCB2YWx1ZSBbMC4uMV1cclxuICogQHBhcmFtIGcgR3JlZW4gY29tcG9uZW50IGFzIGEgbm9ybWFsaXplZCB2YWx1ZSBbMC4uMV1cclxuICogQHBhcmFtIGIgQmx1ZSBjb21wb25lbnQgYXMgYSBub3JtYWxpemVkIHZhbHVlIFswLi4xXVxyXG4gKiBAcGFyYW0gYSBBbHBoYSBjb21wb25lbnQgYXMgYSBub3JtYWxpemVkIHZhbHVlIFswLi4xXVxyXG4gKlxyXG4gKiBAcmV0dXJucyBBIGNvbG9yIHdpdGggZ2l2ZW4gdmFsdWVzIGFzc2lnbmVkIHRvIGNvbXBvbmVudHMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKHIsIGcsIGIsIGEgPSAxKSB7XHJcbiAgICByZXR1cm4geyByLCBnLCBiLCBhIH07XHJcbn1cclxuLyoqXHJcbiAqIENvcGllcyBhIGNvbG9yIHRvIGFub3RoZXIgb25lLlxyXG4gKlxyXG4gKiBAcGFyYW0gc3JjIFRoZSBzb3VyY2UgY29sb3IuXHJcbiAqIEBwYXJhbSBkc3QgVGhlIGNvbG9yIHRoZSBzb3VyY2UgY29sb3Igd2lsbCBiZSBjb3BpZWQgdG8uXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvcHkoc3JjLCBkc3QgPSBjcmVhdGUoMCwgMCwgMCwgMCkpIHtcclxuICAgIGRzdC5yID0gc3JjLnI7XHJcbiAgICBkc3QuZyA9IHNyYy5nO1xyXG4gICAgZHN0LmIgPSBzcmMuYjtcclxuICAgIGRzdC5hID0gc3JjLmE7XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBhcmVFcXVhbChjMSwgYzIpIHtcclxuICAgIHJldHVybiBjMS5yID09PSBjMi5yICYmIGMxLmcgPT09IGMyLmcgJiYgYzEuYiA9PT0gYzIuYiAmJiBjMS5hID09PSBjMi5hO1xyXG59XHJcbi8qKlxyXG4gKiBEZWNvZGVzIGEgY29sb3IgcmVwcmVzZW50ZWQgYXMgZm91ciA4LWJpdCBjaGFubmVscyBlbmNvZGVkIGludG8gYSAzMi1iaXRcclxuICogbnVtYmVyIGluIEFCR1Igb3JkZXIgKGZyb20gTVNCIHRvIExTQikuXHJcbiAqXHJcbiAqIEBwYXJhbSBjb2xvciBDb2xvciBlbmNvZGVkIGludG8gdW5zaWduZWQgMzItYml0IGludGVnZXIuXHJcbiAqIEByZXR1cm5zIERlY29kZWQgY29sb3IuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlQWJncjgoY29sb3IpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcjogKGNvbG9yID4+PiAyNCkgLyAweGZmLFxyXG4gICAgICAgIGc6IChjb2xvciA+Pj4gMTYgJiAweGZmKSAvIDB4ZmYsXHJcbiAgICAgICAgYjogKGNvbG9yID4+PiA4ICYgMHhmZikgLyAweGZmLFxyXG4gICAgICAgIGE6IChjb2xvciAmIDB4ZmYpIC8gMHhmZlxyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogRW5jb2RlcyBhIGNvbG9yIGNvbXBvbmVudHMgaW50byBmb3VyIDggYml0IG51bWJlcnMgcGFja2VkIGludG8gMzItYml0IG9uZS5cclxuICpcclxuICogQHBhcmFtIGMgVGhlIGNvbG9yIHRvIGJlIGVuY29kZWQuXHJcbiAqIEByZXR1cm5zIFRoZSBjb2xvciBhcyAzMi1iaXQgaW50ZWdlci5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVSZ2JhOChjKSB7XHJcbiAgICByZXR1cm4gKGMuciAqIDB4ZmYgfFxyXG4gICAgICAgIChjLmcgKiAweGZmIDw8IDgpIHxcclxuICAgICAgICAoYy5iICogMHhmZiA8PCAxNikgfFxyXG4gICAgICAgIChjLmEgKiAweGZmIDw8IDI0KSk7XHJcbn1cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBhIGNvbG9yIGlzIGNvbXBsZXRlbHkgb3BhcXVlLlxyXG4gKlxyXG4gKiBAcGFyYW0gY29sb3IgVGhlIGNvbG9yIHRvIGJlIGNoZWNrZWQuXHJcbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgY29sb3IgaXMgb3BhcXVlIGFuZCBgZmFsc2VgIG90aGVyd2lzZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc09wYXF1ZShjb2xvcikge1xyXG4gICAgcmV0dXJuIGNvbG9yLmEgPT09IDE7XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9jb2xvci50c1xuLy8gbW9kdWxlIGlkID0gMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICogYXMgbWF0cml4MyBmcm9tICcuL21hdHJpeDMnO1xyXG5pbXBvcnQgYXJlRnV6enlFcXVhbFNjYWxhciwgeyBERUZBVUxUX1RPTEVSQU5DRSB9IGZyb20gJy4uL3V0aWwvZnV6enlfZXF1YWwnO1xyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyB2ZWN0b3IgYW5kIGluaXRpYWxpemVzIGl0IHdpdGggZ2l2ZW4gY29tcG9uZW50cy5cclxuICpcclxuICogQHBhcmFtIHggWCBjb21wb25lbnQgb2YgdGhlIHZlY3Rvci5cclxuICogQHBhcmFtIHkgWSBjb21wb25lbnQgb2YgdGhlIHZlY3Rvci5cclxuICogQHBhcmFtIHogWiBjb21wb25lbnQgb2YgdGhlIHZlY3Rvci5cclxuICogQHJldHVybnMgVGhlIHZlY3Rvci5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoeCwgeSwgeikge1xyXG4gICAgcmV0dXJuIHsgeCwgeSwgeiB9O1xyXG59XHJcbmV4cG9ydCBjb25zdCBPUklHSU4gPSBjcmVhdGUoMCwgMCwgMCk7XHJcbmV4cG9ydCBjb25zdCBQT1NJVElWRV9YID0gY3JlYXRlKDEsIDAsIDApO1xyXG5leHBvcnQgY29uc3QgTkVHQVRJVkVfWCA9IGNyZWF0ZSgtMSwgMCwgMCk7XHJcbmV4cG9ydCBjb25zdCBQT1NJVElWRV9ZID0gY3JlYXRlKDAsIDEsIDApO1xyXG5leHBvcnQgY29uc3QgTkVHQVRJVkVfWSA9IGNyZWF0ZSgwLCAtMSwgMCk7XHJcbmV4cG9ydCBjb25zdCBQT1NJVElWRV9aID0gY3JlYXRlKDAsIDAsIDEpO1xyXG5leHBvcnQgY29uc3QgTkVHQVRJVkVfWiA9IGNyZWF0ZSgwLCAwLCAtMSk7XHJcbi8qKlxyXG4gKiBDb3BpZXMgYSB2ZWN0b3IgdG8gYW5vdGhlciBvbmUuXHJcbiAqXHJcbiAqIEBwYXJhbSBzcmMgVGhlIHNvdXJjZSB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBkc3QgVGhlIHZlY3RvciB0aGUgc291cmNlIHZlY3RvciB3aWxsIGJlIGNvcGllZCB0by5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29weShzcmMsIGRzdCA9IGNyZWF0ZSgwLCAwLCAwKSkge1xyXG4gICAgZHN0LnggPSBzcmMueDtcclxuICAgIGRzdC55ID0gc3JjLnk7XHJcbiAgICBkc3QueiA9IHNyYy56O1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogQ2hlY2tzIGlmIHR3byB2ZWN0b3JzIGFyZSBzdHJpY3RseSBlcXVhbCBjb21wb25lbnQtd2lzZS5cclxuICpcclxuICogQHBhcmFtIHYxIFRoZSBmaXJzdCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSB2MiBUaGUgc2Vjb25kIHZlY3Rvci5cclxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYXJlRXF1YWwodjEsIHYyKSB7XHJcbiAgICByZXR1cm4gdjEueCA9PT0gdjIueCAmJiB2MS55ID09PSB2Mi55ICYmIHYxLnogPT09IHYyLno7XHJcbn1cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBjb3JyZXNwb25kaW5nIGNvbXBvbmVudHMgb2YgdHdvIHZlY3RvcnMgYXJlIGFsbCB3aXRoaW4gZ2l2ZW5cclxuICogdG9sZXJhbmNlIGZyb20gZWFjaCBvdGhlci5cclxuICpcclxuICogQHBhcmFtIHYxIFRoZSBmaXJzdCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSB2MiBUaGUgc2Vjb25kIHZlY3Rvci5cclxuICogQHBhcmFtIHRvbGVyYW5jZSBUaGUgdG9sZXJhbmNlLlxyXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZlY3RvcnMgYXJlIFwiZnV6enlcIiBlcXVhbCBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYXJlRnV6enlFcXVhbCh2MSwgdjIsIHRvbGVyYW5jZSA9IERFRkFVTFRfVE9MRVJBTkNFKSB7XHJcbiAgICByZXR1cm4gKGFyZUZ1enp5RXF1YWxTY2FsYXIodjEueCwgdjIueCwgdG9sZXJhbmNlKSAmJlxyXG4gICAgICAgIGFyZUZ1enp5RXF1YWxTY2FsYXIodjEueSwgdjIueSwgdG9sZXJhbmNlKSAmJlxyXG4gICAgICAgIGFyZUZ1enp5RXF1YWxTY2FsYXIodjEueiwgdjIueiwgdG9sZXJhbmNlKSk7XHJcbn1cclxuLyoqXHJcbiAqIENoZWNrcyBpZiB0d28gdmVjdG9ycyBhcmUgY29sbGluZWFyLlxyXG4gKlxyXG4gKiBAcGFyYW0gdjEgVGhlIGZpcnN0IHZlY3Rvci5cclxuICogQHBhcmFtIHYyIFRoZSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZlY3RvcnMgYXJlIGNvbGxpbmVhciBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYXJlQ29sbGluZWFyKHYxLCB2Mikge1xyXG4gICAgY29uc3QgbGFtYmRhWCA9IHYxLnggLyB2Mi54O1xyXG4gICAgY29uc3QgbGFtYmRhWSA9IHYxLnkgLyB2Mi55O1xyXG4gICAgY29uc3QgbGFtYmRhWiA9IHYxLnogLyB2Mi56O1xyXG4gICAgcmV0dXJuIGxhbWJkYVggPT09IGxhbWJkYVkgJiYgbGFtYmRhWSA9PT0gbGFtYmRhWjtcclxufVxyXG4vKipcclxuICogQWRkcyB0d28gdmVjdG9yIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbnRvIGEgdGhpcmQgb25lLCBpLmUuIGBkc3QgPSBhICsgYmAuXHJcbiAqXHJcbiAqIEBwYXJhbSBhIFRoZSBmaXJzdCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSB2ZWN0b3IgdGhlIHJlc3VsdCB3aWxsIGJlIHN0b3JlZCB0by5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYWRkKGEsIGIsIGRzdCA9IGNyZWF0ZSgwLCAwLCAwKSkge1xyXG4gICAgZHN0LnggPSBhLnggKyBiLng7XHJcbiAgICBkc3QueSA9IGEueSArIGIueTtcclxuICAgIGRzdC56ID0gYS56ICsgYi56O1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogU3VidHJhY3RzIGEgdmVjdG9yIGZyb20gYW5vdGhlciBvbmUgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IHRvIGEgdGhpcmQgb25lLCBpLmUuXHJcbiAqIGBkc3QgPSBhIC0gYmAuXHJcbiAqXHJcbiAqIEBwYXJhbSBhIFRoZSBtaW51ZW5kIHZlY3Rvci5cclxuICogQHBhcmFtIGIgVGhlIHN1YnRyYWhlbmQgdmVjdG9yLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSB2ZWN0b3IgdGhlIHJlc3VsdCB3aWxsIGJlIHN0b3JlZCB0by5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzdWIoYSwgYiwgZHN0ID0gY3JlYXRlKDAsIDAsIDApKSB7XHJcbiAgICBkc3QueCA9IGEueCAtIGIueDtcclxuICAgIGRzdC55ID0gYS55IC0gYi55O1xyXG4gICAgZHN0LnogPSBhLnogLSBiLno7XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbi8qKlxyXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWN0b3JzIGNvbXBvbmVudC13aXNlIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbnRvIGEgdGhpcmQgb25lLlxyXG4gKlxyXG4gKiBAcGFyYW0gYSBUaGUgZmlyc3QgdmVjdG9yLlxyXG4gKiBAcGFyYW0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cclxuICogQHBhcmFtIGRzdCBUaGUgdmVjdG9yIHRoZSByZXN1bHQgd2lsbCBiZSBzdG9yZWQgdG8uXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG11bHYoYSwgYiwgZHN0ID0gY3JlYXRlKDAsIDAsIDApKSB7XHJcbiAgICBkc3QueCA9IGEueCAqIGIueDtcclxuICAgIGRzdC55ID0gYS55ICogYi55O1xyXG4gICAgZHN0LnogPSBhLnogKiBiLno7XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbi8qKlxyXG4gKiBNdWx0aXBsaWVzIGEgdmVjdG9yIGJ5IGEgc2NhbGFyIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbnRvIGEgdGhpcmQgdmVjdG9yLlxyXG4gKlxyXG4gKiBAcGFyYW0gYSBUaGUgdmVjdG9yLlxyXG4gKiBAcGFyYW0gbiBUaGUgc2NhbGFyLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSB2ZWN0b3IgdGhlIHJlc3VsdCB3aWxsIGJlIHN0b3JlZCB0by5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbXVsbihhLCBuLCBkc3QgPSBjcmVhdGUoMCwgMCwgMCkpIHtcclxuICAgIGRzdC54ID0gYS54ICogbjtcclxuICAgIGRzdC55ID0gYS55ICogbjtcclxuICAgIGRzdC56ID0gYS56ICogbjtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIERpdmlkZXMgYSB2ZWN0b3IgYnkgYW5vdGhlciBvbmUgY29tcG9uZW50IHdpc2UgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGludG8gYVxyXG4gKiB0aGlyZCBvbmUuXHJcbiAqXHJcbiAqIEBwYXJhbSBhIFRoZSBkaXZpZGVuZCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBiIFRoZSBkaXZpc29yIHZlY3Rvci5cclxuICogQHBhcmFtIGRzdCBUaGUgdmVjdG9yIHRoZSByZXN1bHQgd2lsbCBiZSBzdG9yZWQgdG8uXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRpdnYoYSwgYiwgZHN0ID0gY3JlYXRlKDAsIDAsIDApKSB7XHJcbiAgICBkc3QueCA9IGEueCAvIGIueDtcclxuICAgIGRzdC55ID0gYS55IC8gYi55O1xyXG4gICAgZHN0LnogPSBhLnogLyBiLno7XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbi8qKlxyXG4gKiBEaXZpZGVzIGEgdmVjdG9yIGJ5IGEgc2NhbGFyIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbnRvIGEgdGhpcmQgdmVjdG9yLlxyXG4gKlxyXG4gKiBAcGFyYW0gYSBUaGUgZGl2aWRlbmQgdmVjdG9yLlxyXG4gKiBAcGFyYW0gbiBUaGUgc2NhbGFyLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSB2ZWN0b3IgdGhlIHJlc3VsdCB3aWxsIGJlIHN0b3JlZCB0by5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZGl2bihhLCBuLCBkc3QgPSBjcmVhdGUoMCwgMCwgMCkpIHtcclxuICAgIGRzdC54ID0gYS54IC8gbjtcclxuICAgIGRzdC55ID0gYS55IC8gbjtcclxuICAgIGRzdC56ID0gYS56IC8gbjtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIENvbXB1dGVzIGxlbmd0aCBvZiBhIHZlY3Rvci5cclxuICpcclxuICogQHBhcmFtIHYgVGhlIHZlY3Rvci5cclxuICogQHJldHVybnMgVGhlIGxlbmd0aC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBsZW5ndGgodikge1xyXG4gICAgcmV0dXJuIE1hdGguaHlwb3Qodi54LCB2LnksIHYueik7XHJcbn1cclxuLyoqXHJcbiAqIENvbXB1dGVzIGRpc3RhbmNlIGJldHdlZW4gZW5kcyBvZiB0d28gdmVjdG9ycy5cclxuICpcclxuICogQHBhcmFtIGEgVGhlIGZpcnN0IHZlY3Rvci5cclxuICogQHBhcmFtIGIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEByZXR1cm5zIFRoZSBkaXN0YW5jZSwgaS5lLiBgbGVuZ3RoKHN1YihhLCBiKSlgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRpc3RhbmNlKGEsIGIpIHtcclxuICAgIHJldHVybiBNYXRoLmh5cG90KGEueCAtIGIueCwgYS55IC0gYi55LCBhLnogLSBiLnopO1xyXG59XHJcbi8qKlxyXG4gKiBEaXZpZGVzIGEgdmVjdG9yIGJ5IGl0cyBsZW5ndGggKHRodXMgbWFraW5nIGl0IGEgdW5pdCB2ZWN0b3IpIGFuZCBzdG9yZXMgdGhlXHJcbiAqIHJlc3VsdCB0byBhbm90aGVyIG9uZS5cclxuICpcclxuICogQHBhcmFtIHYgVGhlIHZlY3RvciB0byBiZSBub3JtYWxpemVkLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSB2ZWN0b3IgdGhlIHJlc3VsdCB3aWxsIGJlIHN0b3JlZCB0by5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplKHYsIGRzdCA9IGNyZWF0ZSgwLCAwLCAwKSkge1xyXG4gICAgcmV0dXJuIGRpdm4odiwgbGVuZ3RoKHYpLCBkc3QpO1xyXG59XHJcbi8qKlxyXG4gKiBDb21wdXRlcyBkb3QgcHJvZHVjdCBvZiB0d28gdmVjdG9ycy5cclxuICpcclxuICogQHBhcmFtIGEgVGhlIGZpcnN0IHZlY3Rvci5cclxuICogQHBhcmFtIGIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEByZXR1cm5zIFRoZSBkb3QgcHJvZHVjdC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBkb3QoYSwgYikge1xyXG4gICAgcmV0dXJuIGEueCAqIGIueCArIGEueSAqIGIueSArIGEueiAqIGIuejtcclxufVxyXG4vKipcclxuICogQ29tcHV0ZXMgY3Jvc3MgcHJvZHVjdCBvZiB0d28gdmVjdG9ycyBhbmQgc3RvcmVzIGl0IHRvIGEgdGhpcmQgb25lLlxyXG4gKlxyXG4gKiBAcGFyYW0gYSBUaGUgZmlyc3QgdmVjdG9yLlxyXG4gKiBAcGFyYW0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cclxuICogQHBhcmFtIGRzdCBUaGUgdmVjdG9yIHRoZSByZXN1bHQgd2lsbCBiZSBzdG9yZWQgdG8uXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNyb3NzKGEsIGIsIGRzdCA9IGNyZWF0ZSgwLCAwLCAwKSkge1xyXG4gICAgLy8gV3JpdGUgY29tcG9uZW50cyB0byBhIHNlcGFyYXRlIHZhcmlhYmxlcyBzbyB3ZSBkb24ndCBwcm9kdWNlIGluY29ycmVjdFxyXG4gICAgLy8gcmVzdWx0cyBpbiBjYXNlcyB3aGVuIGEgPT0gZHN0IG9yIGIgPT0gZHN0LlxyXG4gICAgY29uc3QgeCA9IGEueSAqIGIueiAtIGEueiAqIGIueTtcclxuICAgIGNvbnN0IHkgPSBhLnogKiBiLnggLSBhLnggKiBiLno7XHJcbiAgICBjb25zdCB6ID0gYS54ICogYi55IC0gYS55ICogYi54O1xyXG4gICAgZHN0LnggPSB4O1xyXG4gICAgZHN0LnkgPSB5O1xyXG4gICAgZHN0LnogPSB6O1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogUm90YXRlcyB2ZWN0b3IgYWJvdXQgdGhlIFggYXhpcy5cclxuICpcclxuICogQHBhcmFtIHYgVGhlIHZlY3RvciB0byBiZSByb3RhdGVkLlxyXG4gKiBAcGFyYW0gYW5nbGUgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uIChpbiByYWRpYW5zKSwgcG9zaXRpdmUgdmFsdWVzIHJvdGF0ZXMgZnJvbSArWSB0byArWlxyXG4gKiBAcGFyYW0gZHN0IFRoZSB2ZWN0b3IgdGhlIHJlc3VsdCB3aWxsIGJlIHN0b3JlZCB0by5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVYKHYsIGFuZ2xlLCBkc3QgPSBjcmVhdGUoMCwgMCwgMCkpIHtcclxuICAgIGNvbnN0IGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcclxuICAgIGNvbnN0IHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcclxuICAgIGNvbnN0IHkgPSB2Lnk7XHJcbiAgICBkc3QueCA9IHYueDtcclxuICAgIGRzdC55ID0geSAqIGNvcyAtIHYueiAqIHNpbjtcclxuICAgIGRzdC56ID0geSAqIHNpbiArIHYueiAqIGNvcztcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIFJvdGF0ZXMgdmVjdG9yIGFib3V0IHRoZSBZIGF4aXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB2IFRoZSB2ZWN0b3IgdG8gYmUgcm90YXRlZC5cclxuICogQHBhcmFtIGFuZ2xlIFRoZSBhbmdsZSBvZiByb3RhdGlvbiAoaW4gcmFkaWFucyksIHBvc2l0aXZlIHZhbHVlcyByb3RhdGVzIGZyb20gK1ggdG8gK1pcclxuICogQHBhcmFtIGRzdCBUaGUgdmVjdG9yIHRoZSByZXN1bHQgd2lsbCBiZSBzdG9yZWQgdG8uXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWSh2LCBhbmdsZSwgZHN0ID0gY3JlYXRlKDAsIDAsIDApKSB7XHJcbiAgICBjb25zdCBjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XHJcbiAgICBjb25zdCBzaW4gPSBNYXRoLnNpbihhbmdsZSk7XHJcbiAgICAvLyBoYW5kbGUgdGhlIGNhc2Ugd2hlbiBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGFyZSB0aGUgc2FtZSBvYmplY3Q6IHJlbGF0ZWQgY29tcG9uZW50cyBjYW4gYnJlYWsgZWFjaCBvdGhlclxyXG4gICAgdiA9ICh2ID09PSBkc3QpID8gY29weSh2KSA6IHY7XHJcbiAgICBkc3QueCA9IHYueCAqIGNvcyArIHYueiAqIHNpbjtcclxuICAgIGRzdC55ID0gdi55O1xyXG4gICAgZHN0LnogPSAtdi54ICogc2luICsgdi56ICogY29zO1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogUm90YXRlcyB2ZWN0b3IgYWJvdXQgdGhlIFogYXhpcy5cclxuICpcclxuICogQHBhcmFtIHYgVGhlIHZlY3RvciB0byBiZSByb3RhdGVkLlxyXG4gKiBAcGFyYW0gYW5nbGUgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uIChpbiByYWRpYW5zKSwgcG9zaXRpdmUgdmFsdWVzIHJvdGF0ZXMgZnJvbSArWCB0byArWVxyXG4gKiBAcGFyYW0gZHN0IFRoZSB2ZWN0b3IgdGhlIHJlc3VsdCB3aWxsIGJlIHN0b3JlZCB0by5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVaKHYsIGFuZ2xlLCBkc3QgPSBjcmVhdGUoMCwgMCwgMCkpIHtcclxuICAgIGNvbnN0IGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcclxuICAgIGNvbnN0IHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcclxuICAgIC8vIGhhbmRsZSB0aGUgY2FzZSB3aGVuIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gYXJlIHRoZSBzYW1lIG9iamVjdDogcmVsYXRlZCBjb21wb25lbnRzIGNhbiBicmVhayBlYWNoIG90aGVyXHJcbiAgICB2ID0gKHYgPT09IGRzdCkgPyBjb3B5KHYpIDogdjtcclxuICAgIGRzdC54ID0gdi54ICogY29zIC0gdi55ICogc2luO1xyXG4gICAgZHN0LnkgPSB2LnggKiBzaW4gKyB2LnkgKiBjb3M7XHJcbiAgICBkc3QueiA9IHYuejtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuZXhwb3J0IGNvbnN0IFhfQVhJUyA9IHtcclxuICAgIG9yaWdpbjogT1JJR0lOLFxyXG4gICAgdGFuZ2VudDogUE9TSVRJVkVfWFxyXG59O1xyXG5leHBvcnQgY29uc3QgWV9BWElTID0ge1xyXG4gICAgb3JpZ2luOiBPUklHSU4sXHJcbiAgICB0YW5nZW50OiBQT1NJVElWRV9ZXHJcbn07XHJcbmV4cG9ydCBjb25zdCBaX0FYSVMgPSB7XHJcbiAgICBvcmlnaW46IE9SSUdJTixcclxuICAgIHRhbmdlbnQ6IFBPU0lUSVZFX1pcclxufTtcclxuZXhwb3J0IGNvbnN0IFhZID0ge1xyXG4gICAgbm9ybWFsOiBQT1NJVElWRV9aLFxyXG4gICAgZGlzdGFuY2U6IDBcclxufTtcclxuZXhwb3J0IGNvbnN0IFlaID0ge1xyXG4gICAgbm9ybWFsOiBQT1NJVElWRV9YLFxyXG4gICAgZGlzdGFuY2U6IDBcclxufTtcclxuZXhwb3J0IGNvbnN0IFpYID0ge1xyXG4gICAgbm9ybWFsOiBQT1NJVElWRV9ZLFxyXG4gICAgZGlzdGFuY2U6IDBcclxufTtcclxuLyoqXHJcbiAqIENvbXB1dGVzIGludGVyc2VjdGlvbiBvZiBhIHBsYW5lIGFuZCBhIGxpbmUuXHJcbiAqXHJcbiAqIEBwYXJhbSBwIFRoZSBwbGFuZS5cclxuICogQHBhcmFtIGwgVGhlIGxpbmUuXHJcbiAqIEByZXR1cm5zIFRoZSBwb2ludCBvciBgbnVsbGAgaWYgdGhlIGxpbmUgaXMgcGFyYWxsZWwgdG8gdGhlIHBsYW5lLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFBsYW5lTGluZUludGVyc2VjdGlvbihwLCBsKSB7XHJcbiAgICBjb25zdCBkb3RMUCA9IGRvdChsLnRhbmdlbnQsIHAubm9ybWFsKTtcclxuICAgIC8vIElmIHBsYW5lIG5vcm1hbCBhbmQgbGluZSB0YW5nZW50IHZlY3RvciBhcmUgcGVycGVuZGljdWxhciBpbnRlcnNlY3Rpb24gaXNcclxuICAgIC8vIGVpdGhlciBhbiBlbXB0eSBzZXQgb3IgdGhlIGxpbmUgaXRzZWxmLlxyXG4gICAgaWYgKGRvdExQID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBjb25zdCBpbnRlcnNlY3Rpb24gPSBjb3B5KGwudGFuZ2VudCk7XHJcbiAgICBtdWxuKGludGVyc2VjdGlvbiwgKHAuZGlzdGFuY2UgLSBkb3QocC5ub3JtYWwsIGwub3JpZ2luKSkgLyBkb3RMUCwgaW50ZXJzZWN0aW9uKTtcclxuICAgIGFkZChpbnRlcnNlY3Rpb24sIGwub3JpZ2luLCBpbnRlcnNlY3Rpb24pO1xyXG4gICAgcmV0dXJuIGludGVyc2VjdGlvbjtcclxufVxyXG4vKipcclxuICogQ29tcHV0ZXMgYW4gaW50ZXJzZWN0aW9uIG9mIGEgcGxhbmUgYW5kIGEgcmF5IGFuZCBzdG9yZXMgaXQgaW50byBhIGdpdmVuXHJcbiAqIHZlY3Rvci5cclxuICpcclxuICogQHBhcmFtIHBsYW5lIFRoZSBwbGFuZS5cclxuICogQHBhcmFtIHJheSBUaGUgcmF5LlxyXG4gKiBAcGFyYW0gZHN0IFRoZSB2ZWN0b3IgdGhlIGludGVyc2VjdGlvbiBwb2ludCB3aWxsIGJlIHN0b3JlZCB0by4gSWYgdGhlcmUncyBub1xyXG4gKiAgICAgIGludGVyc2VjdGlvbiwgdGhpcyB2ZWN0b3Igd2lsbCBiZSBsZWZ0IHVubW9kaWZpZWQuXHJcbiAqIEByZXR1cm5zIFRoZSBgZHN0YCBvciBgbnVsbGAgaWYgdGhlIHJheSBkb2Vzbid0IGhhdmUgYSBjb21tb24gcG9pbnQgd2l0aCB0aGVcclxuICogICAgICBwbGFuZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRQbGFuZVJheUludGVyc2VjdGlvbihwbGFuZSwgcmF5LCBkc3QgPSBjcmVhdGUoMCwgMCwgMCkpIHtcclxuICAgIGNvbnN0IGRvdFJQID0gZG90KHJheS5kaXJlY3Rpb24sIHBsYW5lLm5vcm1hbCk7XHJcbiAgICBpZiAoZG90UlAgPT09IDApIHtcclxuICAgICAgICAvLyBUaGUgcGxhbmUgbm9ybWFsIGFuZCB0aGUgcmF5IGRpcmVjdGlvbiB2ZWN0b3IgYXJlIHBlcnBlbmRpY3VsYXIsIHNvXHJcbiAgICAgICAgLy8gaW50ZXJzZWN0aW9uIGlzIGVpdGhlciBhbiBlbXB0eSBzZXQgb3IgdGhlIHJheSBpdHNlbGYuXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBjb25zdCBsYW1iZGEgPSAocGxhbmUuZGlzdGFuY2UgLSBkb3QocGxhbmUubm9ybWFsLCByYXkub3JpZ2luKSkgLyBkb3RSUDtcclxuICAgIGlmIChsYW1iZGEgPCAwKSB7XHJcbiAgICAgICAgLy8gVGhlIGludGVyc2VjdGlvbiBwb2ludCBpcyBvbiBhIGxpbmUgdGhhdCBjb250YWlucyB0aGUgcmF5LCBidXQgbm90IG9uXHJcbiAgICAgICAgLy8gdGhlIHJheSBpdHNlbGYuXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBjb3B5KHJheS5kaXJlY3Rpb24sIGRzdCk7XHJcbiAgICBtdWxuKGRzdCwgbGFtYmRhLCBkc3QpO1xyXG4gICAgYWRkKGRzdCwgcmF5Lm9yaWdpbiwgZHN0KTtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIENvbXB1dGVzIGludGVyc2VjdGlvbiBvZiB0d28gcGxhbmVzLlxyXG4gKlxyXG4gKiBAcGFyYW0gcDEgVGhlIGZpcnN0IHBsYW5lLlxyXG4gKiBAcGFyYW0gcDIgVGhlIHNlY29uZCBwbGFuZS5cclxuICogQHJldHVybnMgVGhlIGxpbmUgb3IgYG51bGxgIGlmIHRoZSBwbGFuZXMgYXJlIHBhcmFsbGVsIHRvIGVhY2ggb3RoZXIuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGxhbmVQbGFuZUludGVyc2VjdGlvbihwMSwgcDIpIHtcclxuICAgIGNvbnN0IG4xID0gcDEubm9ybWFsO1xyXG4gICAgY29uc3QgbjIgPSBwMi5ub3JtYWw7XHJcbiAgICBpZiAoYXJlQ29sbGluZWFyKG4xLCBuMikpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGNvbnN0IHRhbmdlbnQgPSBjcm9zcyhuMSwgbjIpO1xyXG4gICAgbm9ybWFsaXplKHRhbmdlbnQpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0YW5nZW50LFxyXG4gICAgICAgIG9yaWdpbjogbWF0cml4My5zb2x2ZShtYXRyaXgzLmZyb21Sb3dzKG4xLCBuMiwgdGFuZ2VudCksIGNyZWF0ZShwMS5kaXN0YW5jZSwgcDIuZGlzdGFuY2UsIDApKVxyXG4gICAgfTtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9tYXRoL3ZlY3RvcjMudHNcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImNvbnN0IFVJTlQ4X01BWCA9IDB4ZmY7XHJcbmNvbnN0IFVJTlQxNl9NQVggPSAweGZmZmY7XHJcbmNvbnN0IFVJTlQzMl9NQVggPSAweGZmZmZmZmZmO1xyXG5leHBvcnQgZnVuY3Rpb24gZmxvYXRUb1VpbnQ4KHgpIHtcclxuICAgIHJldHVybiBVSU5UOF9NQVggKiB4IHwgMDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gZmxvYXRUb1VpbnQxNih4KSB7XHJcbiAgICByZXR1cm4geCAqIFVJTlQxNl9NQVggfCAwO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBmbG9hdFRvSW50MTYoeCkge1xyXG4gICAgcmV0dXJuICh4ICogVUlOVDE2X01BWCAtIDEpIC8gMiB8IDA7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGZsb2F0VG9VaW50MzIoeCkge1xyXG4gICAgcmV0dXJuIHggKiBVSU5UMzJfTUFYIHwgMDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gZmxvYXRUb0ludDMyKHgpIHtcclxuICAgIHJldHVybiAoeCAqIFVJTlQzMl9NQVggLSAxKSAvIDIgfCAwO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBpbnQzMlRvRmxvYXQoeCkge1xyXG4gICAgcmV0dXJuICgyICogeCArIDEpIC8gVUlOVDMyX01BWDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gdWludDMyVG9GbG9hdCh4KSB7XHJcbiAgICByZXR1cm4geCAvIFVJTlQzMl9NQVg7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGludDE2VG9GbG9hdCh4KSB7XHJcbiAgICByZXR1cm4gKDIgKiB4ICsgMSkgLyBVSU5UMTZfTUFYO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiB1aW50MTZUb0Zsb2F0KHgpIHtcclxuICAgIHJldHVybiB4IC8gVUlOVDE2X01BWDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gdWludDhUb0Zsb2F0KHgpIHtcclxuICAgIHJldHVybiB4IC8gVUlOVDhfTUFYO1xyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvZ3B1dHlwZXMudHNcbi8vIG1vZHVsZSBpZCA9IDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IERFRkFVTFRfQ09NUEFSQVRPUiB9IGZyb20gJy4vY29tcGFyYXRvcic7XHJcbi8qKlxyXG4gKiBTd2FwcyB0d28gdmFsdWVzIGluIGFuIGFycmF5LlxyXG4gKlxyXG4gKiBAcGFyYW0gYXJyYXkgVGhlIGFycmF5LlxyXG4gKiBAcGFyYW0gaSBJbmRleCBvZiBhIHZhbHVlIHRvIGJlIHN3YXBwZWQuXHJcbiAqIEBwYXJhbSBqIEluZGV4IG9mIGEgdmFsdWUgdG8gYmUgc3dhcHBlZC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzd2FwKGFycmF5LCBpLCBqKSB7XHJcbiAgICBjb25zdCB0ID0gYXJyYXlbaV07XHJcbiAgICBhcnJheVtpXSA9IGFycmF5W2pdO1xyXG4gICAgYXJyYXlbal0gPSB0O1xyXG59XHJcbi8qKlxyXG4gKiBSZXZlcnNlcyBvcmRlciBvZiBlbGVtZW50cyBpbiBhIHJhbmdlIGluIGFuIGFycmF5LlxyXG4gKlxyXG4gKiBAcGFyYW0gYXJyYXkgVGhlIGFycmF5LlxyXG4gKiBAcGFyYW0gc3RhcnQgVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cclxuICogQHBhcmFtIGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiByZXZlcnNlKGFycmF5LCBzdGFydCA9IDAsIGVuZCA9IGFycmF5Lmxlbmd0aCkge1xyXG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0LCBqID0gZW5kIC0gMTsgaSA8IGo7ICsraSwgLS1qKSB7XHJcbiAgICAgICAgc3dhcChhcnJheSwgaSwgaik7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJvdGF0ZXMgYSByYW5nZSBvZiBlbGVtZW50cyBpbiBhbiBhcnJheSBieSBnaXZlbiBhbW91bnQuXHJcbiAqXHJcbiAqIEBwYXJhbSBhcnJheSBUaGUgYXJyYXkuXHJcbiAqIEBwYXJhbSBhbW91bnQgVGhlIGFtb3VudC5cclxuICogQHBhcmFtIHN0YXJ0IFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXHJcbiAqIEBwYXJhbSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlKGFycmF5LCBhbW91bnQgPSAxLCBzdGFydCA9IDAsIGVuZCA9IGFycmF5Lmxlbmd0aCkge1xyXG4gICAgcmV2ZXJzZShhcnJheSwgc3RhcnQsIGVuZCk7XHJcbiAgICByZXZlcnNlKGFycmF5LCBzdGFydCwgc3RhcnQgKyBhbW91bnQpO1xyXG4gICAgcmV2ZXJzZShhcnJheSwgc3RhcnQgKyBhbW91bnQsIGVuZCk7XHJcbn1cclxuLyoqXHJcbiAqIENvcGllcyBhIHJhbmdlIG9mIGVsZW1lbnRzIGZyb20gYSBzb3VyY2UgYXJyYXkgdG8gYSByYW5nZSBpbiBhIGRlc3RpbmF0aW9uXHJcbiAqIGFycmF5LlxyXG4gKlxyXG4gKiBAcGFyYW0gc3JjIFRoZSBzb3VyY2UgYXJyYXkuXHJcbiAqIEBwYXJhbSBkc3QgVGhlIGRlc3RpbmF0aW9uIGFycmF5LlxyXG4gKiBAcGFyYW0gc3JjU3RhcnQgVGhlIHN0YXJ0IG9mIHRoZSBzb3VyY2UgcmFuZ2UuXHJcbiAqIEBwYXJhbSBzcmNTdGFydCBUaGUgc3RhcnQgb2YgdGhlIHNvdXJjZSByYW5nZS5cclxuICogQHBhcmFtIGRzdFN0YXJ0IFRoZSBzdGFydCBvZiB0aGUgZGVzdGluYXRpb24gcmFuZ2UuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29weShzcmMsIGRzdCwgc3JjU3RhcnQgPSAwLCBzcmNFbmQgPSBzcmMubGVuZ3RoLCBkc3RTdGFydCA9IDApIHtcclxuICAgIGZvciAobGV0IGkgPSBzcmNTdGFydCwgaiA9IGRzdFN0YXJ0OyBpIDwgc3JjRW5kOyArK2ksICsraikge1xyXG4gICAgICAgIGRzdFtqXSA9IHNyY1tpXTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogU2h1ZmZsZXMgcmFuZG9tbHkgYSByYW5nZSBvZiBlbGVtZW50cyBpbiBhbiBhcnJheS5cclxuICpcclxuICogQHBhcmFtIGFycmF5IFRoZSBhcnJheS5cclxuICogQHBhcmFtIHN0YXJ0IFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXHJcbiAqIEBwYXJhbSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2h1ZmZsZShhcnJheSwgc3RhcnQgPSAwLCBlbmQgPSBhcnJheS5sZW5ndGgpIHtcclxuICAgIGZvciAobGV0IGkgPSBzdGFydCwgaiA9IGkgKyAxOyBpIDwgZW5kOyArK2ksICsraikge1xyXG4gICAgICAgIHN3YXAoYXJyYXksIGksIGogKyAoTWF0aC5yYW5kb20oKSAqIChlbmQgLSBqKSB8IDApKTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgZnVuY3Rpb24gemlwKHRzLCB1cywgemlwcGVyID0gKHQsIHUpID0+IFt0LCB1XSkge1xyXG4gICAgY29uc3QgbCA9IE1hdGgubWluKHRzLmxlbmd0aCwgdXMubGVuZ3RoKTtcclxuICAgIGNvbnN0IHZzID0gbmV3IEFycmF5KGwpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyArK2kpIHtcclxuICAgICAgICB2c1tpXSA9IHppcHBlcih0c1tpXSwgdXNbaV0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZzO1xyXG59XHJcbi8qKlxyXG4gKiBDb21wYXJlcyB0d28gYXJyYXlzIGxleGljb2dyYXBoaWNhbGx5LiBUaGUgb3JkZXIgaXMgc3BlY2lmaWVkIGJlIHRoZSBjb21wYXJhdG9yIHBhcmFtZXRlci5cclxuICpcclxuICogQHBhcmFtIGNvbXBhcmF0b3IgRWxlbWVudHMgY29tcGFyYXRvciB3aXRoIHN0YW5kYXJkIHNpZ25hdHVyZS5cclxuICogQHBhcmFtIGEgVGhlIGZpcnN0IGFycmF5IHRvIGNvbXBhcmUuXHJcbiAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgYXJyYXkgdG8gY29tcGFyZS5cclxuICogQHJldHVybnMgMCBpZiBhbGwgZWxlbWVudHMgYW5kIGxlbmd0aHMgYXJlIGVxdWFsLFxyXG4gKiAgICAgIG5lZ2F0aXZlIG51bWJlciBpZiB0aGUgZmlyc3QgZWxlbWVudCBpcyBsZXNzIHRoZW4gdGhlIHNlY29uZCAobGV4aWNvZ3JhcGhpY2FsbHkpLFxyXG4gKiAgICAgIHBvc2l0aXZlIG51bWJlciBpZiB0aGUgZmlyc3QgZWxlbWVudCBpcyBncmVhdGVyIHRoZW4gdGhlIHNlY29uZCxcclxuICogICAgICBpZiBhbGwgdGhlIGVsZW1lbnRzIGFyZSBlcXVhbCB0aGUgbGVuZ3RocyBhcmUgYmVpbmcgY29tcGFyZWQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZShjb21wYXJhdG9yLCBhLCBiKSB7XHJcbiAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1pbihhLmxlbmd0aCwgYi5sZW5ndGgpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbXBhcmF0b3IoYVtpXSwgYltpXSk7XHJcbiAgICAgICAgaWYgKHJlc3VsdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBhLmxlbmd0aCAtIGIubGVuZ3RoO1xyXG59XHJcbi8qKlxyXG4gKiBTb3J0cyBhIHJhbmdlIG9mIGVsZW1lbnRzIG9mIGFuIGFycmF5IGluIHBsYWNlIHdpdGggaW5zZXJ0aW9uIHNvcnQuXHJcbiAqXHJcbiAqIEBwYXJhbSBhcnJheSBUaGUgYXJyYXkgdG8gYmUgc29ydGVkLlxyXG4gKiBAcGFyYW0gY29tcGFyYXRvciBDb21wYXJhdG9yIGZvciBhcnJheSBlbGVtZW50cy5cclxuICogQHBhcmFtIHN0YXJ0IEluZGV4IG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSByYW5nZSB0byBiZSBzb3J0ZWQuXHJcbiAqIEBwYXJhbSBlbmQgSW5kZXggb2YgYW4gZWxlbWVudCBiZWhpbmQgdGhlIGxhc3QgZWxlbWVudCBpbiB0aGUgcmFuZ2UgdG8gYmVcclxuICogICAgICBzb3J0ZWQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaW5zZXJ0aW9uU29ydChhcnJheSwgY29tcGFyYXRvciA9IERFRkFVTFRfQ09NUEFSQVRPUiwgc3RhcnQgPSAwLCBlbmQgPSBhcnJheS5sZW5ndGgpIHtcclxuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaiA9IGk7IGogPiBzdGFydCAmJiBjb21wYXJhdG9yKGFycmF5W2ogLSAxXSwgYXJyYXlbal0pID4gMDsgLS1qKSB7XHJcbiAgICAgICAgICAgIHN3YXAoYXJyYXksIGogLSAxLCBqKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuY29uc3QgQkxPQ0tfU0laRSA9IDMyO1xyXG4vKipcclxuICogTWVyZ2VzIHR3byBzb3J0ZWQgcmFuZ2VzIG9mIGFuIGFycmF5LiBTdG9yZXMgdGhlIHJlc3VsdCBpbnRvIGFub3RoZXIgb25lLlxyXG4gKlxyXG4gKiBAcGFyYW0gc3JjIFRoZSBhcnJheSB3aXRoIHRoZSByYW5nZXMgdG8gYmUgbWVyZ2VkLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSBhcnJheSB0aGUgcmVzdWx0aW5nIHJhbmdlIHdpbGwgYmUgc3RvcmVkIHRvLlxyXG4gKiBAcGFyYW0gY29tcGFyYXRvciBUaGUgY29tcGFyYXRvciBmb3IgYXJyYXkgZWxlbWVudHMuXHJcbiAqIEBwYXJhbSBzdGFydCBTdGFydCBvZiB0aGUgZmlyc3QgcmFuZ2UgdG8gYmUgbWVyZ2VkLlxyXG4gKiBAcGFyYW0gbWlkZGxlIEVuZCBvZiB0aGUgZmlyc3QgYW5kIHNpbXVsdGFuZW91c2x5IHN0YXJ0IG9mIHRoZSBzZWNvbmQgcmFuZ2VcclxuICogICAgICB0byBiZSBtZXJnZWQuXHJcbiAqIEBwYXJhbSBlbmQgRW5kIG9mIHRoZSBzZWNvbmQgcmFuZ2UgdG8gYmUgbWVyZ2VkLlxyXG4gKiBAcGFyYW0gZHN0T2Zmc2V0IE9mZnNldCBvZiBtZXJnZWQgcmFuZ2UgaW4gdGhlIHJlc3VsdCBhcnJheS5cclxuICovXHJcbmZ1bmN0aW9uIG1lcmdlKHNyYywgZHN0LCBjb21wYXJhdG9yLCBzdGFydCwgbWlkZGxlLCBlbmQsIGRzdE9mZnNldCkge1xyXG4gICAgbGV0IGkgPSBkc3RPZmZzZXQ7XHJcbiAgICBsZXQgaiA9IHN0YXJ0O1xyXG4gICAgbGV0IGsgPSBtaWRkbGU7XHJcbiAgICB3aGlsZSAoaiA8IG1pZGRsZSAmJiBrIDwgZW5kKSB7XHJcbiAgICAgICAgZHN0W2krK10gPSBjb21wYXJhdG9yKHNyY1tqXSwgc3JjW2tdKSA+IDAgPyBzcmNbaysrXSA6IHNyY1tqKytdO1xyXG4gICAgfVxyXG4gICAgY29weShzcmMsIGRzdCwgaiwgbWlkZGxlLCBpKTtcclxuICAgIGNvcHkoc3JjLCBkc3QsIGssIGVuZCwgaSk7XHJcbn1cclxuLyoqXHJcbiAqIFNvcnRzIGEgcmFuZ2Ugb2YgZWxlbWVudHMgb2YgYW4gYXJyYXkgd2l0aCBtZXJnZSBzb3J0LlxyXG4gKlxyXG4gKiBAcGFyYW0gYXJyYXkgIFRoZSBhcnJheSB0byBiZSBzb3J0ZWQuXHJcbiAqIEBwYXJhbSBjb21wYXJhdG9yIENvbXBhcmF0b3IgZm9yIGFycmF5IGVsZW1lbnRzLlxyXG4gKiBAcGFyYW0gZW5kIEluZGV4IG9mIGFuIGVsZW1lbnQgYmVoaW5kIHRoZSBsYXN0IGVsZW1lbnQgaW4gdGhlIHJhbmdlIHRvIGJlXHJcbiAqICAgICAgc29ydGVkLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlU29ydChhcnJheSwgY29tcGFyYXRvciA9IERFRkFVTFRfQ09NUEFSQVRPUiwgc3RhcnQgPSAwLCBlbmQgPSBhcnJheS5sZW5ndGgpIHtcclxuICAgIC8vIEZpcnN0IGFuZCBmb3JlbW9zdDogaWYgdGhlIHJhbmdlIGlzIHNtYWxsZXIgdGhhbiB0aGUgYmxvY2sgc2l6ZSwganVzdFxyXG4gICAgLy8gcGVyZm9ybSBpbnNlcnRpb24gc29ydCBvbiBpdC5cclxuICAgIGlmIChlbmQgLSBzdGFydCA8PSBCTE9DS19TSVpFKSB7XHJcbiAgICAgICAgaW5zZXJ0aW9uU29ydChhcnJheSwgY29tcGFyYXRvciwgc3RhcnQsIGVuZCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgLy8gRmlyc3Qgd2Ugc3BsaXQgdGhlIGdpdmVuIHJhbmdlIGludG8gc3VicmFuZ2VzIG9mIHNpemUgQkxPQ0tfU0laRSBhbmRcclxuICAgIC8vIHNvcnQgZXZlcnkgcmFuZ2Ugd2l0aCBpbnNlcnRpb24gc29ydC5cclxuICAgIHtcclxuICAgICAgICBsZXQgcyA9IHN0YXJ0O1xyXG4gICAgICAgIGxldCBlID0gcyArIEJMT0NLX1NJWkU7XHJcbiAgICAgICAgd2hpbGUgKGUgPCBlbmQpIHtcclxuICAgICAgICAgICAgaW5zZXJ0aW9uU29ydChhcnJheSwgY29tcGFyYXRvciwgcywgZSk7XHJcbiAgICAgICAgICAgIHMgPSBlO1xyXG4gICAgICAgICAgICBlICs9IEJMT0NLX1NJWkU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluc2VydGlvblNvcnQoYXJyYXksIGNvbXBhcmF0b3IsIHMsIGVuZCk7XHJcbiAgICB9XHJcbiAgICAvLyBUT0RPKGRtaWtpcyk6IEltcGxlbWVudCBpbi1wbGFjZSBtZXJnZS4gSXQgc2VlbXMgdGhlcmUncmUgcmVhc29uYWJseVxyXG4gICAgLy8gICAgICBjb21wbGV4IHNvbHV0aW9ucyBvdXQgdGhlcmUuXHJcbiAgICBjb25zdCBhdXhBcnJheSA9IG5ldyBBcnJheShlbmQgLSBzdGFydCk7XHJcbiAgICAvLyBUaGVuIHdlIG1lcmdlIGJsb2NrcyBwYWlycywgaW5jcmVhc2UgYmxvY2sgc2l6ZSBieSAyIGFuZCByZXBlYXQuXHJcbiAgICBmb3IgKGxldCBibG9ja1NpemUgPSBCTE9DS19TSVpFOyBibG9ja1NpemUgPCBlbmQgLSBzdGFydDsgYmxvY2tTaXplICs9IGJsb2NrU2l6ZSkge1xyXG4gICAgICAgIC8vIFRPRE8oZG1pa2lzKTogQmVmb3JlIGFmb3JlbWVudGlvbmVkIHRvZG8gbWF5YmUgaW1wbGVtZW50IGFycmF5XHJcbiAgICAgICAgLy8gcGluZ3BvbmdpbmcgdG8gY3V0IGRvd24gYW1vdW50IG9mIGZ1bGwgY29waWVzLlxyXG4gICAgICAgIGNvcHkoYXJyYXksIGF1eEFycmF5LCBzdGFydCwgZW5kKTtcclxuICAgICAgICBsZXQgaSA9IHN0YXJ0O1xyXG4gICAgICAgIGxldCBzID0gMDtcclxuICAgICAgICBsZXQgbSA9IGJsb2NrU2l6ZTtcclxuICAgICAgICBsZXQgZSA9IG0gKyBibG9ja1NpemU7XHJcbiAgICAgICAgd2hpbGUgKGUgPCBlbmQgLSBzdGFydCkge1xyXG4gICAgICAgICAgICBtZXJnZShhdXhBcnJheSwgYXJyYXksIGNvbXBhcmF0b3IsIHMsIG0sIGUsIGkpO1xyXG4gICAgICAgICAgICBzID0gZTtcclxuICAgICAgICAgICAgbSA9IHMgKyBibG9ja1NpemU7XHJcbiAgICAgICAgICAgIGUgPSBtICsgYmxvY2tTaXplO1xyXG4gICAgICAgICAgICBpICs9IDIgKiBibG9ja1NpemU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1lcmdlKGF1eEFycmF5LCBhcnJheSwgY29tcGFyYXRvciwgcywgTWF0aC5taW4obSwgZW5kIC0gc3RhcnQpLCBlbmQgLSBzdGFydCwgaSk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9hcnJheS50c1xuLy8gbW9kdWxlIGlkID0gMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIEByZXR1cm5zIEludGVnZXIgbnVtYmVyIG9mIHZlcnRpY2VzIHRoYXQgZml0IGludG8gYSByZWdpb24gb2Ygc3BlY2lmaWVkIGluIGJ5dGVzIHNpemUuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY291bnRWZXJ0aWNlcyh2ZXJ0ZXhCeXRlU2l6ZSwgYXR0cmliTWFwcGluZykge1xyXG4gICAgcmV0dXJuIHZlcnRleEJ5dGVTaXplIC8gYXR0cmliTWFwcGluZy52ZXJ0ZXhCeXRlU2l6ZSB8IDA7XHJcbn1cclxuLyoqXHJcbiAqIEByZXR1cm5zIEludGVnZXIgbnVtYmVyIG9mIGluZGljZXMgdGhhdCBmaXQgaW50byBhIHJlZ2lvbiBvZiBzcGVjaWZpZWQgaW4gYnl0ZXMgc2l6ZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb3VudEluZGljZXMoaW5kZXhCeXRlU2l6ZSwgdHlwZSkge1xyXG4gICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgY2FzZSA1MTIzIC8qIFVOU0lHTkVEX1NIT1JUICovOlxyXG4gICAgICAgICAgICByZXR1cm4gaW5kZXhCeXRlU2l6ZSA+PiAxO1xyXG4gICAgICAgIGNhc2UgNTEyNSAvKiBVTlNJR05FRF9JTlQgKi86XHJcbiAgICAgICAgICAgIHJldHVybiBpbmRleEJ5dGVTaXplID4+IDI7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9tZW1vcnkvY291bnRfdmVydGljZXMudHNcbi8vIG1vZHVsZSBpZCA9IDE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydCBmdW5jdGlvbiBnZXRUaWxlSWRCeVJhd1ZhbHVlcyh4LCB5LCB6b29tKSB7XHJcbiAgICByZXR1cm4gYCR7eH06JHt5fToke3pvb219YDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0VGlsZUlkKHRpbGUpIHtcclxuICAgIHJldHVybiBnZXRUaWxlSWRCeVJhd1ZhbHVlcyh0aWxlLngsIHRpbGUueSwgdGlsZS56b29tKTtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9hZGFwdGVycy90aWxlX2Jhc2VkX2FkYXB0ZXIvdGlsZV9pZC50c1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIEJhc2UgaW50ZXJmYWNlIGZvciB3ZWJ3b3JrZXIgbWVzc2FnZXMsIGJvdGggaW5jb21pbmcgYW5kIG91dGdvaW5nIG9uZXMuXHJcbiAqXHJcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1RyYW5zZmVyYWJsZVxyXG4gKi9cclxuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnLi9ldmVudF9lbWl0dGVyJztcclxuaW1wb3J0IHsgdW5pcXVlSWQgfSBmcm9tICcuL3VuaXF1ZV9pZCc7XHJcbmNvbnN0IE1FU1NBR0VfQkFUQ0hfTUFYX1NJWkUgPSA1MDtcclxuY29uc3QgRkxVU0hfVElNRU9VVCA9IDUwO1xyXG4vLyBlYWNoIHN1YnNlcXVlbnQgbWVzc2FnZSBkZWJvdW5jZXMgcG9zdE1lc3NhZ2UgY2FsbCwgdGhhdCBjYW4gbGVhZCB0byBpbmZpbml0ZSBkZWxheSwgdGhpcyBjb25zdCBsaW1pdHMgaXRcclxuY29uc3QgTUFYX0ZMVVNIX1RJTUVPVVQgPSAyNTA7XHJcbmV4cG9ydCBjb25zdCBOT19JRCA9IC0xO1xyXG4vKipcclxuICogQ2hlY2tzIG1lc3NhZ2UgdHlwZSB3aXRoIHR5cGUgZ3VhcmRpbmcuIEl0IGdpdmVzIGEgbGl0dGxlIGJpdCBtb3JlIGVsZWdhbnQgYWx0ZXJuYXRpdmVcclxuICogdG8gdGFnZ2VkIHR5cGUgdW5pb25zIHByb3ZpZGluZyB0aGUgc2FtZSB0eXBlIHNhZmV0eS5cclxuICpcclxuICogQHBhcmFtIG1lc3NhZ2UgdG8gYmUgY2hlY2tlZFxyXG4gKiBAcGFyYW0gdHlwZSB0aGUgdmFsdWUgb2YgdGhlIFwidHlwZVwiIHByb3BlcnR5XHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbWVzc2FnZUlzKG1lc3NhZ2UsIHR5cGUpIHtcclxuICAgIHJldHVybiBtZXNzYWdlLnR5cGUgPT09IHR5cGU7XHJcbn1cclxuLyoqXHJcbiAqIEJhc2UgY2xhc3MgZm9yIGJvdGggc2lkZXMgb2YgYSB3ZWJ3b3JrZXI6IGl0cyBpbXBsZW1lbnRhdGlvbiAoc2VwYXJhdGUganMgdGhhdCBpcyBydW4gaW4gYSB3b3JrZXIgdGhyZWFkKSBhbmRcclxuICogYSBjb250cm9sbGVyIGZvciB0aGUgbWFpbiB0aHJlYWQuIFRoZXkgaGF2ZSBzaW1pbGFyIG1lY2hhbmlzbSBvZiBzZW5kaW5nL3JlY2VpdmluZyBtZXNzYWdlcyB0aGF0IGlzIGltcGxlbWVudCBoZXJlLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFdlYldvcmtlckNvbW11bmljYXRvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihhZGRyZXNzZWUpIHtcclxuICAgICAgICB0aGlzLl9hZGRyZXNzZWUgPSBhZGRyZXNzZWU7XHJcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLl90cmFuc2ZlcmFibGVFeHRyYWN0b3JzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuX21lc3NhZ2VzID0gW107XHJcbiAgICAgICAgdGhpcy5fdHJhbnNmZXJhYmxlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3RpbWVvdXRIYW5kbGUgPSAwO1xyXG4gICAgICAgIHRoaXMuX2ZsdXNoTWVzc2FnZXNCaW5kZWQgPSB0aGlzLl9mbHVzaE1lc3NhZ2VzLmJpbmQodGhpcyk7XHJcbiAgICB9XHJcbiAgICBzZXRUcmFuc2ZlcmFibGVFeHRyYWN0b3IodHlwZSwgZXh0cmFjdG9yKSB7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNmZXJhYmxlRXh0cmFjdG9ycy5zZXQodHlwZSwgZXh0cmFjdG9yKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2VuZCBhIG1lc3NhZ2UgdG8gdGhlIG9wcG9zaXRlIHNpZGUgb2YgdGhlIHdlYiB3b3JrZXIgY29tbXVuaWNhdGlvbiBjaGFubmVsLlxyXG4gICAgICogTWVzc2FnZXMgYXJlIGJhdGNoZWQgYnkgZGVsYXlpbmcgcG9zdE1lc3NhZ2UgY2FsbCB0byBncm91cCBtZXNzYWdlcyB0aGF0IGNvbWUgZHVyaW5nIHRoaXMgZGVsYXkgYW5kIG1pbmltaXplXHJcbiAgICAgKiB0aGUgbnVtYmVyIG9mIGludGVycHJvY2VzcyBjb21tdW5pY2F0aW9ucyB0aGF0IGJhZGx5IGFmZmVjdCBwZXJmb3JtYW5jZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSBNZXNzYWdlIHRvIGJlIHNlbnQuXHJcbiAgICAgKiBAcGFyYW0gdXJnZW5jeSBJTU1FRElBVEUgZm9yY2VzIG1lc3NhZ2UgdG8gYmUgc2VudCBpbW1lZGlhdGVseSAoc3luY2hyb25vdXMgY2FsbCkgd2l0aCBubyBiYXRjaGluZyBkZWxheSxcclxuICAgICAqICAgICAgICAgICAgICAgIERFRkFVTFQgZGVib3VuY2VzIHNlbmRpbmcgZm9yIGFub3RoZXIgRkxVU0hfVElNRU9VVC5cclxuICAgICAqL1xyXG4gICAgc2VuZE1lc3NhZ2UobWVzc2FnZSwgdXJnZW5jeSA9IDAgLyogREVGQVVMVCAqLykge1xyXG4gICAgICAgIGNvbnN0IHRyYW5zZmVyYWJsZUV4dHJhY3RvciA9IHRoaXMuX3RyYW5zZmVyYWJsZUV4dHJhY3RvcnMuZ2V0KG1lc3NhZ2UudHlwZSk7XHJcbiAgICAgICAgY29uc3QgdHJhbnNmZXJhYmxlcyA9IHRyYW5zZmVyYWJsZUV4dHJhY3RvciA/IHRyYW5zZmVyYWJsZUV4dHJhY3RvcihtZXNzYWdlKSA6IHVuZGVmaW5lZDtcclxuICAgICAgICBjb25zdCBpc0ZpcnN0TWVzc2FnZUluQmF0Y2ggPSAodGhpcy5fbWVzc2FnZXMubGVuZ3RoID09PSAwKTtcclxuICAgICAgICBpZiAoaXNGaXJzdE1lc3NhZ2VJbkJhdGNoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZpcnN0TWVzc2FnZVRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU2VuZCBtZXNzYWdlcyBhc3luY2hyb25vdXNseSBwYWNraW5nIHRoZW0gaW50byBvbmUgbWVzc2FnZS5cclxuICAgICAgICAvLyBXZSBkb24ndCB3YW50IHRvIGFidXNlIHRoZSB3ZWIgd29ya2VyIGNvbW11bmljYXRpb24gY2hhbm5lbCBhbmRcclxuICAgICAgICAvLyBzZW5kIG1lc3NhZ2VzIGFzeW5jaHJvbm91c2x5IGluIHNob3J0IHBlcmlvZCBvZiB0aW1lIG9yIG1hbnkgbWVzc2FnZXMgc3luY2hyb25vdXNseS5cclxuICAgICAgICB0aGlzLl9tZXNzYWdlcy5wdXNoKG1lc3NhZ2UpO1xyXG4gICAgICAgIGlmICh0cmFuc2ZlcmFibGVzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zZmVyYWJsZXMgPSB0aGlzLl90cmFuc2ZlcmFibGVzLmNvbmNhdCh0cmFuc2ZlcmFibGVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXRIYW5kbGUpO1xyXG4gICAgICAgIGlmICh0aGlzLl9tZXNzYWdlcy5sZW5ndGggPiBNRVNTQUdFX0JBVENIX01BWF9TSVpFIHx8XHJcbiAgICAgICAgICAgIHVyZ2VuY3kgPT09IDEgLyogSU1NRURJQVRFICovIHx8XHJcbiAgICAgICAgICAgICghaXNGaXJzdE1lc3NhZ2VJbkJhdGNoICYmIChwZXJmb3JtYW5jZS5ub3coKSAtIHRoaXMuX2ZpcnN0TWVzc2FnZVRpbWUpID4gTUFYX0ZMVVNIX1RJTUVPVVQpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZsdXNoTWVzc2FnZXMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RpbWVvdXRIYW5kbGUgPSBzZXRUaW1lb3V0KHRoaXMuX2ZsdXNoTWVzc2FnZXNCaW5kZWQsIEZMVVNIX1RJTUVPVVQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2VuZHMgcmVxdWVzdCBtZXNzYWdlIHRvL2Zyb20gd29ya2VyIGFzIHByb21pc2UsIHRoZSBvdGhlciBzaWRlIGNhbiByZXNwb25kIGFuZCB0aGUgcHJvbWlzZSBpcyByZXNvbHZlZC5cclxuICAgICAqIFJlcXVlc3QvcmVzcG9uc2UgaXMgc3luY2hyb25pemVkIGJ5IHRoZSByZXF1ZXN0SWQgZmllbGQuXHJcbiAgICAgKi9cclxuICAgIHJlcXVlc3QocmVxdWVzdCwgdXJnZW5jeSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0LnJlcXVlc3RJZCA9PT0gTk9fSUQpIHtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3QucmVxdWVzdElkID0gdW5pcXVlSWQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBsaXN0ZW5lciA9IChtZXNzYWdlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZUlzKG1lc3NhZ2UsIHJlcXVlc3QucmVzcG9uc2VUeXBlKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucmVxdWVzdElkID09PSByZXF1ZXN0LnJlcXVlc3RJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUobWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKGxpc3RlbmVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlSXMobWVzc2FnZSwgcmVxdWVzdC5lcnJvclR5cGUpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yZXF1ZXN0SWQgPT09IHJlcXVlc3QucmVxdWVzdElkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vZmYobGlzdGVuZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMuYWRkTGlzdGVuZXIobGlzdGVuZXIpO1xyXG4gICAgICAgICAgICB0aGlzLnNlbmRNZXNzYWdlKHJlcXVlc3QsIHVyZ2VuY3kpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNwb25kcyB0byBwcm92aWRlZCByZXF1ZXN0LlxyXG4gICAgICovXHJcbiAgICByZXNwb25kKHJlcXVlc3QsIHJlc3BvbnNlLCB1cmdlbmN5KSB7XHJcbiAgICAgICAgcmVzcG9uc2UucmVxdWVzdElkID0gcmVxdWVzdC5yZXF1ZXN0SWQ7XHJcbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZShyZXNwb25zZSwgdXJnZW5jeSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgYSBsaXN0ZW5lciB0byBzcGVjaWZpYyB0eXBlIG9mIGluY29taW5nIG1lc3NhZ2VzLlxyXG4gICAgICovXHJcbiAgICBvbih0eXBlLCBsaXN0ZW5lcikge1xyXG4gICAgICAgIGNvbnN0IHR5cGVTYWZlTGlzdGVuZXIgPSAobWVzc2FnZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAobWVzc2FnZUlzKG1lc3NhZ2UsIHR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcihtZXNzYWdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzLnNldChsaXN0ZW5lciwgdHlwZVNhZmVMaXN0ZW5lcik7XHJcbiAgICAgICAgdGhpcy5fZXZlbnRzLmFkZExpc3RlbmVyKHR5cGVTYWZlTGlzdGVuZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGluY29taW5nIG1lc3NhZ2VzIGxpc3RlbmVyLlxyXG4gICAgICovXHJcbiAgICBvZmYobGlzdGVuZXIpIHtcclxuICAgICAgICBjb25zdCB0eXBlU2FmZUxpc3RlbmVyID0gdGhpcy5fbGlzdGVuZXJzLmdldChsaXN0ZW5lcik7XHJcbiAgICAgICAgaWYgKHR5cGVTYWZlTGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKHR5cGVTYWZlTGlzdGVuZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3RhcnRzIGxpc3RlbmluZyBmb3IgaW5jb21pbmcgbWVzc2FnZXMuXHJcbiAgICAgKi9cclxuICAgIGxpc3RlbigpIHtcclxuICAgICAgICB0aGlzLl9hZGRyZXNzZWUub25tZXNzYWdlID0gKHsgZGF0YTogbWVzc2FnZXMgfSkgPT4ge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgbWVzc2FnZXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub25NZXNzYWdlKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlciBvZiBpbmNvbWluZyBtZXNzYWdlcy5cclxuICAgICAqL1xyXG4gICAgb25NZXNzYWdlKG1lc3NhZ2UpIHtcclxuICAgICAgICB0aGlzLl9ldmVudHMuZmlyZShtZXNzYWdlKTtcclxuICAgIH1cclxuICAgIF9mbHVzaE1lc3NhZ2VzKCkge1xyXG4gICAgICAgIHRoaXMuX2FkZHJlc3NlZS5wb3N0TWVzc2FnZSh0aGlzLl9tZXNzYWdlcywgdGhpcy5fdHJhbnNmZXJhYmxlcyk7XHJcbiAgICAgICAgdGhpcy5fbWVzc2FnZXMubGVuZ3RoID0gMDtcclxuICAgICAgICB0aGlzLl90cmFuc2ZlcmFibGVzLmxlbmd0aCA9IDA7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEJhc2UgY2xhc3MgZm9yIGEgd2Vid29ya2VyIGNvbnRyb2xsZXIgZm9yIHRoZSBtYWluIHRocmVhZCBjb2RlLlxyXG4gKiBJdCBhbHNvIHdyYXBzIGNyZWF0aW9uIG9mIGEgbmF0aXZlIFdvcmtlci5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBXZWJXb3JrZXJDbGllbnQgZXh0ZW5kcyBXZWJXb3JrZXJDb21tdW5pY2F0b3Ige1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gdXJsIFVSTCBvZiB3ZWJ3b3JrZXIncyBkZXBsb3llZCBqcyBmaWxlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHVybCkge1xyXG4gICAgICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIodXJsKTtcclxuICAgICAgICBzdXBlcih3b3JrZXIpO1xyXG4gICAgICAgIHRoaXMuX3dvcmtlciA9IHdvcmtlcjtcclxuICAgICAgICB0aGlzLmxpc3RlbigpO1xyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLl93b3JrZXIudGVybWluYXRlKCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEJhc2UgY2xhc3MgZm9yIGEgd2Vid29ya2VyIHRocmVhZCBpbXBsZW1lbnRhdGlvbi4gQ29uY3JldGUgY2xhc3Mgc2hvdWxkIGJlIHRoZSBlbnRyeSBwb2ludCBmb3IgYSB3ZWJ3b3JrZXIganMgYnVpbGQ6XHJcbiAqICAgICBuZXcgQ29uY3JldGVXZWJXb3JrZXJJbXBsZW1lbnRhdGlvbig8RGVkaWNhdGVkV29ya2VyR2xvYmFsU2NvcGU+c2VsZikucnVuKCk7XHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgV2ViV29ya2VySW1wbGVtZW50YXRpb24gZXh0ZW5kcyBXZWJXb3JrZXJDb21tdW5pY2F0b3Ige1xyXG4gICAgcnVuKCkge1xyXG4gICAgICAgIHRoaXMubGlzdGVuKCk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC93b3JrZXIudHNcbi8vIG1vZHVsZSBpZCA9IDE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImNvbnN0IFBST0pFQ1RfSUQgPSA0NDM7XHJcbmZ1bmN0aW9uIGNob29zZVN0YXRVcmwoKSB7XHJcbiAgICAvLyBGSVhNRShkbWlraXMpIElkZWFsbHkgd2Ugc2hvdWxkIGJlIGdldCB0aGlzIFVSTHMgZnJvbSBjb25maWcuXHJcbiAgICBjb25zdCBTVEFUX1VSTFMgPSB7XHJcbiAgICAgICAgcnU6ICdodHRwczovL3lhbmRleC5ydS9jbGNrJyxcclxuICAgICAgICBjb206ICdodHRwczovL3lhbmRleC5jb20vY2xjaycsXHJcbiAgICAgICAgdHI6ICdodHRwczovL3lhbmRleC5jb20udHIvY2xjaydcclxuICAgIH07XHJcbiAgICBjb25zdCB0bGQgPSBsb2NhdGlvbi5ob3N0bmFtZS5zcGxpdCgnLicpLnBvcCgpO1xyXG4gICAgc3dpdGNoICh0bGQpIHtcclxuICAgICAgICBjYXNlICd0cic6XHJcbiAgICAgICAgICAgIHJldHVybiBTVEFUX1VSTFMudHI7XHJcbiAgICAgICAgY2FzZSAnY29tJzpcclxuICAgICAgICBjYXNlICdmcic6XHJcbiAgICAgICAgICAgIHJldHVybiBTVEFUX1VSTFMuY29tO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiBTVEFUX1VSTFMucnU7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgU1RBVF9VUkwgPSBjaG9vc2VTdGF0VXJsKCk7XHJcbmZ1bmN0aW9uIHN0cmluZ2lmeVZhcnModmFycykge1xyXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHZhcnMpLm1hcCgoa2V5KSA9PiBgJHtrZXl9PSR7dmFyc1trZXldfWApLmpvaW4oJywnKTtcclxufVxyXG5mdW5jdGlvbiBjb3VudChwaWQsIGNpZCwgcGF0aCwgdmFycykge1xyXG4gICAgY29uc3QgdXJsID0gYCR7U1RBVF9VUkx9L2NvdW50ZXJgO1xyXG4gICAgY29uc3QgZGF0YSA9IGAvZHR5cGU9c3RyZWQvcGlkPSR7cGlkfS9jaWQ9JHtjaWR9YCArXHJcbiAgICAgICAgYC9wYXRoPSR7cGF0aC5qb2luKCcuJyl9LyR7dmFycyA/IGB2YXJzPSR7c3RyaW5naWZ5VmFycyh2YXJzKX0vYCA6ICcnfWA7XHJcbiAgICBpZiAoIShuYXZpZ2F0b3Iuc2VuZEJlYWNvbiAmJiBuYXZpZ2F0b3Iuc2VuZEJlYWNvbih1cmwsIGRhdGEgKyAnKicpKSkge1xyXG4gICAgICAgIGNvbnN0IGltYWdlID0gbmV3IEltYWdlKCk7XHJcbiAgICAgICAgaW1hZ2Uuc3JjID0gdXJsICsgZGF0YSArIGBybmQ9JHtEYXRlLm5vdygpfSR7TWF0aC5yYW5kb20oKSAqIDEwMCB8IDB9LypgO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IFBFUkZfQ09VTlRFUl9JRCA9IDczMzIzO1xyXG4vKipcclxuICogTG9nIHVzZXIncyByZW5kZXJpbmcgcGVyZiB0byBzdGF0ZmFjZS5cclxuICpcclxuICogQHBhcmFtIGZwcyBGUFNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb3VudEZwcyhmcHMpIHtcclxuICAgIGNvbnN0IHJvdW5kZWRGcHMgPSBNYXRoLmZsb29yKGZwcyAvIDEwKSAqIDEwO1xyXG4gICAgY291bnQoUFJPSkVDVF9JRCwgUEVSRl9DT1VOVEVSX0lELCBbJ2ZwcycsIGAke3JvdW5kZWRGcHN9LSR7cm91bmRlZEZwcyArIDEwfWAsIChmcHMgKiAxMDApLnRvRml4ZWQoKV0pO1xyXG59XHJcbmZ1bmN0aW9uIGVuY29kZVRpbGVJdGVtKHRpbGVJdGVtKSB7XHJcbiAgICByZXR1cm4gYCR7dGlsZUl0ZW0ueH0uJHt0aWxlSXRlbS55fS4ke3RpbGVJdGVtLnpvb219YDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gY291bnRUaWxlUGFyc2VUaW1lKGxheWVyLCBtaW5UaW1lVGlsZSwgbWluVGltZSwgbWF4VGltZVRpbGUsIG1heFRpbWUsIG1lZGlhblRpbWVUaWxlLCBtZWRpYW5UaW1lKSB7XHJcbiAgICBjb3VudChQUk9KRUNUX0lELCBQRVJGX0NPVU5URVJfSUQsIFtcclxuICAgICAgICAndGlsZV9wYXJzZScsXHJcbiAgICAgICAgbGF5ZXJcclxuICAgIF0sIHtcclxuICAgICAgICBtaW5UaW1lOiBtaW5UaW1lLnRvRml4ZWQoKSxcclxuICAgICAgICBtZWRpYW5UaW1lOiBtZWRpYW5UaW1lLnRvRml4ZWQoKSxcclxuICAgICAgICBtYXhUaW1lOiBtYXhUaW1lLnRvRml4ZWQoKSxcclxuICAgICAgICBtaW5UaWxlSXRlbTogZW5jb2RlVGlsZUl0ZW0obWluVGltZVRpbGUpLFxyXG4gICAgICAgIG1lZGlhblRpbGVJdGVtOiBlbmNvZGVUaWxlSXRlbShtZWRpYW5UaW1lVGlsZSksXHJcbiAgICAgICAgbWF4VGlsZUl0ZW06IGVuY29kZVRpbGVJdGVtKG1heFRpbWVUaWxlKVxyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGNvdW50VGlsZVByb2Nlc3NpbmdUaW1lKGxheWVyLCBpdGVtcykge1xyXG4gICAgY29uc3QgdmFyc1RvTG9nID0ge307XHJcbiAgICBpdGVtcy5mb3JFYWNoKChpdGVtKSA9PiB7XHJcbiAgICAgICAgaWYgKGl0ZW0uem9vbSA9PT0gJ2F2ZXJhZ2UnKSB7XHJcbiAgICAgICAgICAgIGNvdW50KFBST0pFQ1RfSUQsIFBFUkZfQ09VTlRFUl9JRCwgW1xyXG4gICAgICAgICAgICAgICAgJ3RpbGVfcHJvY2Vzc2luZ19hdmVyYWdlJyxcclxuICAgICAgICAgICAgICAgIGxheWVyLFxyXG4gICAgICAgICAgICAgICAgKE1hdGguY2VpbChpdGVtLnRpbWUgLyAyNTApICogMjUwKS50b1N0cmluZygpXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXJzVG9Mb2dbaXRlbS56b29tXSA9IGl0ZW0udGltZS50b0ZpeGVkKCk7XHJcbiAgICB9KTtcclxuICAgIGNvdW50KFBST0pFQ1RfSUQsIFBFUkZfQ09VTlRFUl9JRCwgWyd0aWxlX3Byb2Nlc3NpbmcnLCBsYXllcl0sIHZhcnNUb0xvZyk7XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9zdGF0LnRzXG4vLyBtb2R1bGUgaWQgPSAxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnQgZnVuY3Rpb24gREVGQVVMVF9DT01QQVJBVE9SKGEsIGIpIHtcclxuICAgIGlmIChhID4gYikge1xyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgfVxyXG4gICAgaWYgKGEgPCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIDA7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIE5VTUVSSUNBTF9DT01QQVJBVE9SKGEsIGIpIHtcclxuICAgIHJldHVybiBhIC0gYjtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL2NvbXBhcmF0b3IudHNcbi8vIG1vZHVsZSBpZCA9IDE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiBTaW1wbGUgcmVmZXJlbmNlIGNvdW50aW5nIGZvciBzaGFyZWQgZW50aXRpZXMgdGhhdCBuZWVkIGV4cGxpY2l0IGRlc3RydWN0aW9uLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVmZXJlbmNlQ291bnRlZCB7XHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemVzIHJlZmVyZW5jZSBjb3VudCB0byAxLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLl9yZWZDb3VudCA9IDE7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEluY3JlbWVudHMgcmVmZXJlbmNlIGNvdW50LlxyXG4gICAgICovXHJcbiAgICByZXRhaW4oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3JlZkNvdW50ID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVHJpZWQgdG8gcmV0YWluIGEgZGVzdHJveWVkIG9iamVjdC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcmVmQ291bnQrKztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGVjcmVtZW50cyByZWZlcmVuY2UgY291bnQgYW5kLCBpZiBpdCdzIHJlYWNoZWQgMCwgZGVzdHJveXMgdGhlIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgcmVsZWFzZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5fcmVmQ291bnQgPT09IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmllZCB0byByZWxlYXNlIGEgZGVzdHJveWVkIG9iamVjdC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcmVmQ291bnQtLTtcclxuICAgICAgICBpZiAodGhpcy5fcmVmQ291bnQgPT09IDApIHtcclxuICAgICAgICAgICAgdGhpcy5fZGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL3JlZl9jb3VudGVkLnRzXG4vLyBtb2R1bGUgaWQgPSAyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgUHJpbWl0aXZlTWFuYWdlciBmcm9tICcuL3ByaW1pdGl2ZV9tYW5hZ2VyJztcclxuLyoqXHJcbiAqIE1hbmFnZXIgb2YgcHJpbWl0aXZlcyB0aGF0IGhhdmUgYSBzaW5nbGUgYXNzaWNpYXRlZCByZW5kZXJhYmxlIHByaW1pdGl2ZS4gVGhlIFwibWFuYWdlbWVudFwiIGlzIHByZXR0eSBzdHJhaWdodGZvcndhcmQ6XHJcbiAqIGl0IGRpcmVjdGx5IGFkZHMvcmVtb3ZlcyBhc3NvY2lhdGVkIHByaW1pdGl2ZXMgaW50byB0aGUgc3RvcmFnZS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbmRlcmFibGVQcmltaXRpdmVNYW5hZ2VyIGV4dGVuZHMgUHJpbWl0aXZlTWFuYWdlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihwcmltaXRpdmVzU3RvcmFnZSkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fcHJpbWl0aXZlc1N0b3JhZ2UgPSBwcmltaXRpdmVzU3RvcmFnZTtcclxuICAgIH1cclxuICAgIHVwZGF0ZVNjZW5lKHRvU2hvdywgdG9IaWRlKSB7XHJcbiAgICAgICAgdGhpcy5fcHJpbWl0aXZlc1N0b3JhZ2UuYWRkKC4uLnRvU2hvdyk7XHJcbiAgICAgICAgdGhpcy5fcHJpbWl0aXZlc1N0b3JhZ2UuZGVsZXRlKC4uLnRvSGlkZSk7XHJcbiAgICB9XHJcbiAgICBkZXN0cm95UHJpbWl0aXZlcyhfdG9EZXN0cm95KSB7XHJcbiAgICAgICAgLy8gbm8gbmVlZCB0byBkZXN0cm95IGFueXRoaW5nLCBSZW5kZXJhYmxlUHJpbWl0aXZlIGFyZSByZWxlYXNlZCB3aGVuIHJlbW92ZWQgZnJvbSBwcmltbWl0aXZlIHN0b3JhZ2VcclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9hZGFwdGVycy92ZWN0b3JfYXBpL3ByaW1pdGl2ZV9tYW5hZ2VyL3JlbmRlcmFibGVfcHJpbWl0aXZlX21hbmFnZXIudHNcbi8vIG1vZHVsZSBpZCA9IDIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBwb2x5Z29uVmVydGV4U2hhZGVyIGZyb20gJy4vc2hhZGVyL3BvbHlnb24udmVydCc7XHJcbmltcG9ydCBwb2x5Z29uRnJhZ21lbnRTaGFkZXIgZnJvbSAnLi9zaGFkZXIvcG9seWdvbi5mcmFnJztcclxuaW1wb3J0IFJlbmRlclN0YXRlIGZyb20gJy4uLy4uLy4uL3JlbmRlci9zdGF0ZSc7XHJcbmltcG9ydCBXb3JsZFByaW1pdGl2ZVJlbmRlclVuaXQgZnJvbSAnLi4vd29ybGRfcHJpbWl0aXZlX3JlbmRlcl91bml0JztcclxuZXhwb3J0IGNvbnN0IERFRkFVTFRfUkVOREVSX1NUQVRFX1BBUkFNUyA9IHtcclxuICAgIGRlcHRoVGVzdDogdHJ1ZSxcclxuICAgIGRlcHRoRnVuYzogNTE4IC8qIEdSRUFURVJfT1JfRVFVQUwgKi9cclxufTtcclxuLyoqXHJcbiAqIFJlbmRlcmVyIG9mIHBvbHlnb24gcHJpbWl0aXZlcy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvbHlnb25SZW5kZXJVbml0IGV4dGVuZHMgV29ybGRQcmltaXRpdmVSZW5kZXJVbml0IHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIHByaW1pdGl2ZVByb3ZpZGVyLCByZW5kZXJTdGF0ZSA9IG5ldyBSZW5kZXJTdGF0ZShERUZBVUxUX1JFTkRFUl9TVEFURV9QQVJBTVMpKSB7XHJcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IGNvbnRleHQuY3JlYXRlUHJvZ3JhbShwb2x5Z29uVmVydGV4U2hhZGVyLCBwb2x5Z29uRnJhZ21lbnRTaGFkZXIsIHtcclxuICAgICAgICAgICAgYXR0cmliTWFwOiB7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhQb3NIaWdoOiAwIC8qIFBPU0lUSU9OX0hJR0ggKi8sXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhQb3NMb3c6IDEgLyogUE9TSVRJT05fTE9XICovLFxyXG4gICAgICAgICAgICAgICAgdmVydGV4Q29sb3I6IDcgLyogQ09MT1IgKi8sXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhaSW5kZXg6IDEwIC8qIFpfSU5ERVggKi9cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHN1cGVyKGNvbnRleHQsIHJlbmRlclN0YXRlLCBwcm9ncmFtLCBwcmltaXRpdmVQcm92aWRlcik7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvcG9seWdvbi9wb2x5Z29uX3JlbmRlcl91bml0LnRzXG4vLyBtb2R1bGUgaWQgPSAyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBWb2lkRXZlbnRFbWl0dGVyIH0gZnJvbSAnLi4vdXRpbC9ldmVudF9lbWl0dGVyJztcclxuY2xhc3MgTm9CYXNlUmVuZGVyVW5pdEVycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoJ0Jhc2UgcmVuZGVyIHVuaXQgaXMgbm90IGluIHRoZSBsaXN0Jyk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFNpbXBsZSBpbXBsZW1lbnRhdGlvbiBvZiBDb21wb3NpdGVSZW5kZXJVbml0IHRoYXQganVzdCBydW5zIHN1YiB1bml0cyBpbiB0aGUgb3JkZXIgb2YgYWRkaXRpb24uXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMaXN0UmVuZGVyVW5pdCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLm9uVXBkYXRlID0gbmV3IFZvaWRFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLl9zdWJSZW5kZXJVbml0cyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3N1YlJlbmRlclVuaXRVcGRhdGVMaXN0ZW5lciA9IHRoaXMuX29uU3ViUmVuZGVyVW5pdFVwZGF0ZS5iaW5kKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIFJlbmRlclVuaXQgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdC5cclxuICAgICAqL1xyXG4gICAgYWRkUmVuZGVyVW5pdChzdWJSZW5kZXJVbml0KSB7XHJcbiAgICAgICAgdGhpcy5fc3ViUmVuZGVyVW5pdHMucHVzaChzdWJSZW5kZXJVbml0KTtcclxuICAgICAgICBzdWJSZW5kZXJVbml0Lm9uVXBkYXRlLmFkZExpc3RlbmVyKHRoaXMuX3N1YlJlbmRlclVuaXRVcGRhdGVMaXN0ZW5lcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgUmVuZGVyVW5pdCBmcm9tIHRoZSBsaXN0LlxyXG4gICAgICovXHJcbiAgICByZW1vdmVSZW5kZXJVbml0KHN1YlJlbmRlclVuaXQpIHtcclxuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuX3N1YlJlbmRlclVuaXRzLmluZGV4T2Yoc3ViUmVuZGVyVW5pdCk7XHJcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdWJSZW5kZXJVbml0cy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICBzdWJSZW5kZXJVbml0Lm9uVXBkYXRlLnJlbW92ZUxpc3RlbmVyKHRoaXMuX3N1YlJlbmRlclVuaXRVcGRhdGVMaXN0ZW5lcik7XHJcbiAgICAgICAgICAgIHRoaXMub25VcGRhdGUuZmlyZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBSZW5kZXJVbml0IGFib3ZlIHRoZSBiYXNlIG9uZS4gXCJBYm92ZVwiIG1lYW5zIHRoYXQgaXRzIHJlbmRlcigpIG1ldGhvZCB3aWxsIGJlIGNhbGxlZCBhZnRlciB0aGUgYmFzZSdzIG9uZS5cclxuICAgICAqL1xyXG4gICAgYWRkUmVuZGVyVW5pdEFib3ZlKGJhc2UsIHN1YlJlbmRlclVuaXQpIHtcclxuICAgICAgICBjb25zdCBiYXNlSW5kZXggPSB0aGlzLl9zdWJSZW5kZXJVbml0cy5pbmRleE9mKGJhc2UpO1xyXG4gICAgICAgIGlmIChiYXNlSW5kZXggIT09IC0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N1YlJlbmRlclVuaXRzLnNwbGljZShiYXNlSW5kZXggKyAxLCAwLCBzdWJSZW5kZXJVbml0KTtcclxuICAgICAgICAgICAgc3ViUmVuZGVyVW5pdC5vblVwZGF0ZS5hZGRMaXN0ZW5lcih0aGlzLl9zdWJSZW5kZXJVbml0VXBkYXRlTGlzdGVuZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vQmFzZVJlbmRlclVuaXRFcnJvcigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBSZW5kZXJVbml0IGJlbG93IHRoZSBiYXNlIG9uZS4gXCJCZWxvd1wiIG1lYW5zIHRoYXQgaXRzIHJlbmRlcigpIG1ldGhvZCB3aWxsIGJlIGNhbGxlZCBiZWZvcmUgdGhlIGJhc2UncyBvbmUuXHJcbiAgICAgKi9cclxuICAgIGFkZFJlbmRlclVuaXRCZWxvdyhiYXNlLCBzdWJSZW5kZXJVbml0KSB7XHJcbiAgICAgICAgY29uc3QgYmFzZUluZGV4ID0gdGhpcy5fc3ViUmVuZGVyVW5pdHMuaW5kZXhPZihiYXNlKTtcclxuICAgICAgICBpZiAoYmFzZUluZGV4ICE9PSAtMSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdWJSZW5kZXJVbml0cy5zcGxpY2UoYmFzZUluZGV4LCAwLCBzdWJSZW5kZXJVbml0KTtcclxuICAgICAgICAgICAgc3ViUmVuZGVyVW5pdC5vblVwZGF0ZS5hZGRMaXN0ZW5lcih0aGlzLl9zdWJSZW5kZXJVbml0VXBkYXRlTGlzdGVuZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vQmFzZVJlbmRlclVuaXRFcnJvcigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlbmRlcih0YXJnZXQsIC4uLmFyZ3MpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IHJlbmRlcmVyIG9mIHRoaXMuX3N1YlJlbmRlclVuaXRzKSB7XHJcbiAgICAgICAgICAgIHJlbmRlcmVyLnJlbmRlcih0YXJnZXQsIC4uLmFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9vblN1YlJlbmRlclVuaXRVcGRhdGUoKSB7XHJcbiAgICAgICAgdGhpcy5vblVwZGF0ZS5maXJlKCk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL2xpc3RfcmVuZGVyX3VuaXQudHNcbi8vIG1vZHVsZSBpZCA9IDIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAqIGFzIHZlY3RvcjMgZnJvbSAnLi92ZWN0b3IzJztcclxuLy8gVE9ETyhkbWlraXMpIFJvTWF0cml4ND9cclxuZXhwb3J0IGNvbnN0IElERU5USVRZID0gW1xyXG4gICAgMSwgMCwgMCwgMCxcclxuICAgIDAsIDEsIDAsIDAsXHJcbiAgICAwLCAwLCAxLCAwLFxyXG4gICAgMCwgMCwgMCwgMVxyXG5dO1xyXG5leHBvcnQgY29uc3QgWkVSTyA9IFtcclxuICAgIDAsIDAsIDAsIDAsXHJcbiAgICAwLCAwLCAwLCAwLFxyXG4gICAgMCwgMCwgMCwgMCxcclxuICAgIDAsIDAsIDAsIDBcclxuXTtcclxuY29uc3QgTUFUUklYX1NJWkUgPSAxNjtcclxuLyoqXHJcbiAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBuZXcgKip1bmluaXRpYWxpemVkKiogbWF0cml4LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcclxuICAgIHJldHVybiBuZXcgQXJyYXkoTUFUUklYX1NJWkUpO1xyXG59XHJcbi8qKlxyXG4gKiBaZXJvZXMgYSBtYXRyaXguXHJcbiAqXHJcbiAqIEBwYXJhbSBkc3QgVGhlIG1hdHJpeC5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gemVybyhkc3QgPSBjcmVhdGUoKSkge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNQVRSSVhfU0laRTsgKytpKSB7XHJcbiAgICAgICAgZHN0W2ldID0gMDtcclxuICAgIH1cclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIENvcGllcyBhIG1hdHJpeCB0byBhbm90aGVyIG9uZS5cclxuICpcclxuICogQHBhcmFtIHNyYyBUaGUgbWF0cml4IHRvIGJlIGNvcGllZC5cclxuICogQHBhcmFtIGRzdCBUaGUgbWF0cml4IHRoZSBgc3JjYCB3aWxsIGJlIGNvcGllZCB0by5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29weShzcmMsIGRzdCA9IGNyZWF0ZSgpKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1BVFJJWF9TSVpFOyArK2kpIHtcclxuICAgICAgICBkc3RbaV0gPSBzcmNbaV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbi8qKlxyXG4gKiBBcHBsaWVzIGEgcm90YXRpb24gYXJvdW5kIHRoZSBYIGF4aXMgYnkgYSBnaXZlbiBhbmdsZSB0byBhIGdpdmVuIG1hdHJpeC5cclxuICogUG9zaXRpdmUgZGlyZWN0aW9uIGlzIGZyb20gcG9zaXRpdmUgWSB0byBwb3NpdGl2ZSBaLlxyXG4gKlxyXG4gKiBAcGFyYW0gc3JjIFRoZSBtYXRyaXggdG8gYmUgbXVsdGlwbGllZCBieSB0aGUgcm90YXRpb24gbWF0cml4LlxyXG4gKiBAcGFyYW0gYW5nbGUgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSBtYXRyaXggdGhlIHByb2R1Y3Qgd2lsbCBiZSBzdG9yZWQgdG8uIENhbiBiZSB0aGUgc2FtZSBhcyBgc3JjYC5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWChzcmMsIGFuZ2xlLCBkc3QgPSBjcmVhdGUoKSkge1xyXG4gICAgY29uc3QgYW5nbGVDb3MgPSBNYXRoLmNvcyhhbmdsZSk7XHJcbiAgICBjb25zdCBhbmdsZVNpbiA9IE1hdGguc2luKGFuZ2xlKTtcclxuICAgIC8vIFRoZSByb3RhdGlvbiBtYXRyaXg6XHJcbiAgICAvL1xyXG4gICAgLy8gMSAgIDAgICAgMCAwXHJcbiAgICAvLyAwIGNvcyAtc2luIDBcclxuICAgIC8vIDAgc2luICBjb3MgMFxyXG4gICAgLy8gMCAgIDAgICAgMCAxXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1BVFJJWF9TSVpFOyBpICs9IDQpIHtcclxuICAgICAgICBkc3RbaV0gPSBzcmNbaV07XHJcbiAgICAgICAgY29uc3QgbTFpID0gc3JjW2kgKyAxXTtcclxuICAgICAgICBjb25zdCBtMmkgPSBzcmNbaSArIDJdO1xyXG4gICAgICAgIGRzdFtpICsgMV0gPSBtMWkgKiBhbmdsZUNvcyAtIG0yaSAqIGFuZ2xlU2luO1xyXG4gICAgICAgIGRzdFtpICsgMl0gPSBtMWkgKiBhbmdsZVNpbiArIG0yaSAqIGFuZ2xlQ29zO1xyXG4gICAgICAgIGRzdFtpICsgM10gPSBzcmNbaSArIDNdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogQXBwbGllcyBhIHJvdGF0aW9uIGFyb3VuZCB0aGUgWSBheGlzIGJ5IGEgZ2l2ZW4gYW5nbGUgdG8gYSBnaXZlbiBtYXRyaXguXHJcbiAqIFBvc2l0aXZlIGRpcmVjdGlvbiBpcyBmcm9tIHBvc2l0aXZlIFggdG8gcG9zaXRpdmUgWi5cclxuICpcclxuICogQHBhcmFtIHNyYyBUaGUgbWF0cml4IHRvIGJlIG11bHRpcGxpZWQgYnkgdGhlIHJvdGF0aW9uIG1hdHJpeC5cclxuICogQHBhcmFtIGFuZ2xlIFRoZSBhbmdsZSBvZiByb3RhdGlvbi5cclxuICogQHBhcmFtIGRzdCBUaGUgbWF0cml4IHRoZSBwcm9kdWN0IHdpbGwgYmUgc3RvcmVkIHRvLiBDYW4gYmUgdGhlIHNhbWUgYXMgYHNyY2AuXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVkoc3JjLCBhbmdsZSwgZHN0ID0gY3JlYXRlKCkpIHtcclxuICAgIGNvbnN0IGFuZ2xlQ29zID0gTWF0aC5jb3MoYW5nbGUpO1xyXG4gICAgY29uc3QgYW5nbGVTaW4gPSBNYXRoLnNpbihhbmdsZSk7XHJcbiAgICAvLyBUaGUgcm90YXRpb24gbWF0cml4OlxyXG4gICAgLy9cclxuICAgIC8vIGNvcyAwIC1zaW4gMFxyXG4gICAgLy8gMCAgIDEgICAgMCAwXHJcbiAgICAvLyBzaW4gMCAgY29zIDBcclxuICAgIC8vIDAgICAgMCAgIDAgMVxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNQVRSSVhfU0laRTsgaSArPSA0KSB7XHJcbiAgICAgICAgY29uc3QgbTBpID0gc3JjW2ldO1xyXG4gICAgICAgIGNvbnN0IG0yaSA9IHNyY1tpICsgMl07XHJcbiAgICAgICAgZHN0W2ldID0gbTBpICogYW5nbGVDb3MgLSBtMmkgKiBhbmdsZVNpbjtcclxuICAgICAgICBkc3RbaSArIDFdID0gc3JjW2kgKyAxXTtcclxuICAgICAgICBkc3RbaSArIDJdID0gbTBpICogYW5nbGVTaW4gKyBtMmkgKiBhbmdsZUNvcztcclxuICAgICAgICBkc3RbaSArIDNdID0gc3JjW2kgKyAzXTtcclxuICAgIH1cclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIEFwcGxpZXMgYSByb3RhdGlvbiBhcm91bmQgdGhlIFggYXhpcyBieSBhIGdpdmVuIGFuZ2xlIHRvIGEgZ2l2ZW4gbWF0cml4LlxyXG4gKiBQb3NpdGl2ZSBkaXJlY3Rpb24gaXMgZnJvbSBwb3NpdGl2ZSBYIHRvIHBvc2l0aXZlIFkuXHJcbiAqXHJcbiAqIEBwYXJhbSBzcmMgVGhlIG1hdHJpeCB0byBiZSBtdWx0aXBsaWVkIGJ5IHRoZSByb3RhdGlvbiBtYXRyaXguXHJcbiAqIEBwYXJhbSBhbmdsZSBUaGUgYW5nbGUgb2Ygcm90YXRpb24uXHJcbiAqIEBwYXJhbSBkc3QgVGhlIG1hdHJpeCB0aGUgcHJvZHVjdCB3aWxsIGJlIHN0b3JlZCB0by4gQ2FuIGJlIHRoZSBzYW1lIGFzIGBzcmNgLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVaKHNyYywgYW5nbGUsIGRzdCA9IGNyZWF0ZSgpKSB7XHJcbiAgICBjb25zdCBhbmdsZUNvcyA9IE1hdGguY29zKGFuZ2xlKTtcclxuICAgIGNvbnN0IGFuZ2xlU2luID0gTWF0aC5zaW4oYW5nbGUpO1xyXG4gICAgLy8gVGhlIHJvdGF0aW9uIG1hdHJpeDpcclxuICAgIC8vIGNvcyAtc2luIDAgMFxyXG4gICAgLy8gc2luICBjb3MgMCAwXHJcbiAgICAvLyAgIDAgICAgMCAxIDBcclxuICAgIC8vICAgMCAgICAwIDAgMVxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNQVRSSVhfU0laRTsgaSArPSA0KSB7XHJcbiAgICAgICAgY29uc3QgbTBpID0gc3JjW2ldO1xyXG4gICAgICAgIGNvbnN0IG0xaSA9IHNyY1tpICsgMV07XHJcbiAgICAgICAgZHN0W2ldID0gbTBpICogYW5nbGVDb3MgLSBtMWkgKiBhbmdsZVNpbjtcclxuICAgICAgICBkc3RbaSArIDFdID0gbTBpICogYW5nbGVTaW4gKyBtMWkgKiBhbmdsZUNvcztcclxuICAgICAgICBkc3RbaSArIDJdID0gc3JjW2kgKyAyXTtcclxuICAgICAgICBkc3RbaSArIDNdID0gc3JjW2kgKyAzXTtcclxuICAgIH1cclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIEFwcGxpZXMgYSB0cmFuc2xhdGlvbiBieSBhIGdpdmVuIHZlY3RvciB0byBhIGdpdmVuIG1hdHJpeC5cclxuICpcclxuICogQHBhcmFtIHNyYyBUaGUgbWF0cml4IHRvIGJlIG11bHRpcGxpZWQgYnkgdGhlIHRyYW5zbGF0aW9uIG1hdHJpeC5cclxuICogQHBhcmFtIHRyYW5zbGF0aW9uIFRoZSB0cmFuc2xhdGlvbiB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBkc3QgVGhlIG1hdHJpeCB0aGUgcHJvZHVjdCB3aWxsIGJlIHN0b3JlZCB0by4gQ2FuIGJlIHRoZSBzYW1lIGFzIGBzcmNgLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2xhdGUoc3JjLCB0cmFuc2xhdGlvbiwgZHN0ID0gY3JlYXRlKCkpIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTUFUUklYX1NJWkU7IGkgKz0gNCkge1xyXG4gICAgICAgIGNvbnN0IG00aSA9IGRzdFtpICsgM10gPSBzcmNbaSArIDNdO1xyXG4gICAgICAgIGRzdFtpXSA9IHNyY1tpXSArIG00aSAqIHRyYW5zbGF0aW9uLng7XHJcbiAgICAgICAgZHN0W2kgKyAxXSA9IHNyY1tpICsgMV0gKyBtNGkgKiB0cmFuc2xhdGlvbi55O1xyXG4gICAgICAgIGRzdFtpICsgMl0gPSBzcmNbaSArIDJdICsgbTRpICogdHJhbnNsYXRpb24uejtcclxuICAgIH1cclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIEFwcGxpZXMgYSBzY2FsZSBtYXRyaXggYnkgZ2l2ZW4gZmFjdG9ycyAocGFja2VkIGludG8gYSB2ZWN0b3IpIHRvIGEgZ2l2ZW5cclxuICogbWF0cml4LlxyXG4gKlxyXG4gKiBAcGFyYW0gc3JjIFRoZSBtYXRyaXggdG8gYmUgbXVsdGlwbGllZCBieSB0aGUgc2NhbGUgbWF0cml4LlxyXG4gKiBAcGFyYW0gZmFjdG9yIFRoZSB2ZWN0b3IgdGhlIHNjYWxlIGZhY3RvcnMgcGFja2VkIGludG8uXHJcbiAqIEBwYXJhbSBkc3QgVGhlIG1hdHJpeCB0aGUgcHJvZHVjdCB3aWxsIGJlIHN0b3JlZCB0by4gQ2FuIGJlIHRoZSBzYW1lIGFzIGBzcmNgLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzY2FsZShzcmMsIGZhY3RvciwgZHN0ID0gY3JlYXRlKCkpIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTUFUUklYX1NJWkU7IGkgKz0gNCkge1xyXG4gICAgICAgIGRzdFtpXSA9IHNyY1tpXSAqIGZhY3Rvci54O1xyXG4gICAgICAgIGRzdFtpICsgMV0gPSBzcmNbaSArIDFdICogZmFjdG9yLnk7XHJcbiAgICAgICAgZHN0W2kgKyAyXSA9IHNyY1tpICsgMl0gKiBmYWN0b3IuejtcclxuICAgICAgICBkc3RbaSArIDNdID0gc3JjW2kgKyAzXTtcclxuICAgIH1cclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLy8gVGhlIG1hdHJpeDpcclxuLy8geEF4aXMueCB5QXhpcy54IHpBeGlzLnggLWV5ZS54XHJcbi8vIHhBeGlzLnkgeUF4aXMueSB6QXhpcy55IC1leWUueVxyXG4vLyB4QXhpcy56IHlBeGlzLnogekF4aXMueiAtZXllLnpcclxuLy8gICAgICAgMCAgICAgICAwICAgICAgIDAgMVxyXG4vLyB3aGVyZSB4QXhpcywgeUF4aXMgYW5kIHpBeGlzIOKAlCBheGVzIG9mIHRoZSBleWUgY29vcmRpbmF0ZSBzeXN0ZW0sIGV5ZSDigJRcclxuLy8gb3JpZ2luIG9mIHRoZSBleWUgY29vcmRpbmF0ZSBzeXN0ZW0uXHJcbmNvbnN0IGxvb2tBdE1hdHJpeCA9IGNvcHkoSURFTlRJVFkpO1xyXG4vKipcclxuICogQXBwbGllcyBhIG1hdHJpeCBvZiB0cmFuc2Zvcm1hdGlvbiBpbnRvIGEgY29vcmRpbmF0ZSBzeXN0ZW0gb2YgYSBjYW1lcmFcclxuICogZGVmaW5lZCBieSBpdHMgcG9zaXRpb24sIGEgcG9pbnQgaXQncyBsb29raW5nIGF0IGFuZCBhbiB1cCBkaXJlY3Rpb24gdmVjdG9yLlxyXG4gKlxyXG4gKiBAcGFyYW0gc3JjIFRoZSBtYXRyaXggdG8gYmUgbXVsdGlwbGllZCBieSB0aGUgc2NhbGUgbWF0cml4LlxyXG4gKiBAcGFyYW0gZXllIFRoZSBwb3NpdGlvbiBvZiB0aGUgY2FtZXJhLlxyXG4gKiBAcGFyYW0gY2VudGVyIFRoZSBwb2ludCB0aGUgY2FtZXJhJ3MgbG9va2luZyBhdC5cclxuICogQHBhcmFtIHVwIFRoZSB1cCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBkc3QgVGhlIG1hdHJpeCB0aGUgcHJvZHVjdCB3aWxsIGJlIHN0b3JlZCB0by4gQ2FuIGJlIHRoZSBzYW1lIGFzIGBzcmNgLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBsb29rQXQoc3JjLCBleWUsIGNlbnRlciwgdXAsIGRzdCA9IGNyZWF0ZSgpKSB7XHJcbiAgICBjb25zdCB6QXhpcyA9IHZlY3RvcjMuc3ViKGV5ZSwgY2VudGVyKTtcclxuICAgIHZlY3RvcjMubm9ybWFsaXplKHpBeGlzLCB6QXhpcyk7XHJcbiAgICBjb25zdCB4QXhpcyA9IHZlY3RvcjMuY3Jvc3ModXAsIHpBeGlzKTtcclxuICAgIHZlY3RvcjMubm9ybWFsaXplKHhBeGlzLCB4QXhpcyk7XHJcbiAgICBjb25zdCB5QXhpcyA9IHZlY3RvcjMuY3Jvc3MoekF4aXMsIHhBeGlzKTtcclxuICAgIGxvb2tBdE1hdHJpeFswXSA9IHhBeGlzLng7XHJcbiAgICBsb29rQXRNYXRyaXhbMV0gPSB5QXhpcy54O1xyXG4gICAgbG9va0F0TWF0cml4WzJdID0gekF4aXMueDtcclxuICAgIGxvb2tBdE1hdHJpeFs0XSA9IHhBeGlzLnk7XHJcbiAgICBsb29rQXRNYXRyaXhbNV0gPSB5QXhpcy55O1xyXG4gICAgbG9va0F0TWF0cml4WzZdID0gekF4aXMueTtcclxuICAgIGxvb2tBdE1hdHJpeFs4XSA9IHhBeGlzLno7XHJcbiAgICBsb29rQXRNYXRyaXhbOV0gPSB5QXhpcy56O1xyXG4gICAgbG9va0F0TWF0cml4WzEwXSA9IHpBeGlzLno7XHJcbiAgICBsb29rQXRNYXRyaXhbMTJdID0gLXZlY3RvcjMuZG90KHhBeGlzLCBleWUpO1xyXG4gICAgbG9va0F0TWF0cml4WzEzXSA9IC12ZWN0b3IzLmRvdCh5QXhpcywgZXllKTtcclxuICAgIGxvb2tBdE1hdHJpeFsxNF0gPSAtdmVjdG9yMy5kb3QoekF4aXMsIGV5ZSk7XHJcbiAgICByZXR1cm4gbXVsKHNyYywgbG9va0F0TWF0cml4LCBkc3QpO1xyXG59XHJcbi8qKlxyXG4gKiBBcHBsaWVzIGEgcGVyc3BlY3RpdmUgbWF0cml4IHRvIGEgZ2l2ZW4gb25lLlxyXG4gKlxyXG4gKiBAcGFyYW0gc3JjIFRoZSBtYXRyaXggdG8gYmUgbXVsdGlwbGllZCBieSB0aGUgcGVyc3BlY3RpdmUgbWF0cml4LlxyXG4gKiBAcGFyYW0gZm92IFZlcnRpY2FsIGZpZWxkIG9mIHZpZXcgYW5nbGUuXHJcbiAqIEBwYXJhbSBhc3BlY3RSYXRpbyBTY3JlZW4gYXNwZWN0IHJhdGlvLlxyXG4gKiBAcGFyYW0gek5lYXIgWi1jb29yZGluYXRlIG9mIG5lYXIgY2xpcHBpbmcgcGxhbmUuXHJcbiAqIEBwYXJhbSB6RmFyIFotY29vcmRpbmF0ZSBvZiBmYXIgY2xpcHBpbmcgcGxhbmUuXHJcbiAqIEBwYXJhbSBkc3QgVGhlIG1hdHJpeCB0aGUgcHJvZHVjdCB3aWxsIGJlIHN0b3JlZCB0by4gQ2FuIGJlIHRoZSBzYW1lIGFzIGBzcmNgLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBwZXJzcGVjdGl2ZShzcmMsIGZvdiwgYXNwZWN0LCB6TmVhciwgekZhciwgZHN0ID0gY3JlYXRlKCkpIHtcclxuICAgIGNvbnN0IHAxMSA9IDEgLyBNYXRoLnRhbigwLjUgKiBmb3YpO1xyXG4gICAgY29uc3QgcDAwID0gcDExIC8gYXNwZWN0O1xyXG4gICAgY29uc3QgcDIyID0gKHpOZWFyICsgekZhcikgLyAoek5lYXIgLSB6RmFyKTtcclxuICAgIGNvbnN0IHAzMiA9IDIgKiB6TmVhciAqIHpGYXIgLyAoek5lYXIgLSB6RmFyKTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTUFUUklYX1NJWkU7IGkgKz0gNCkge1xyXG4gICAgICAgIGRzdFtpXSA9IHNyY1tpXSAqIHAwMDtcclxuICAgICAgICBkc3RbaSArIDFdID0gc3JjW2kgKyAxXSAqIHAxMTtcclxuICAgICAgICBjb25zdCBtMmkgPSBzcmNbaSArIDJdO1xyXG4gICAgICAgIGNvbnN0IG0zaSA9IHNyY1tpICsgM107XHJcbiAgICAgICAgZHN0W2kgKyAyXSA9IG0yaSAqIHAyMiArIG0zaSAqIHAzMjtcclxuICAgICAgICBkc3RbaSArIDNdID0gLW0yaTtcclxuICAgIH1cclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIE11bHRpcGxpZXMgYSBtYXRyaXggYnkgYW5vdGhlciBvbmUsIGkuZS4gYGRzdCA9IG0gKiBzcmNgLlxyXG4gKlxyXG4gKiBAcGFyYW0gc3JjIFRoZSByaWdodCBtYXRyaXguXHJcbiAqIEBwYXJhbSBtIFRoZSBsZWZ0IG1hdHJpeC5cclxuICogQHBhcmFtIGRzdCBUaGUgbWF0cml4IHRoZSBwcm9kdWN0IHdpbGwgYmUgc3RvcmVkIHRvLiBDYW4gYmUgdGhlIHNhbWUgYXMgYHNyY2AuXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG11bChzcmMsIG0sIGRzdCA9IGNyZWF0ZSgpKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1BVFJJWF9TSVpFOyBpICs9IDQpIHtcclxuICAgICAgICBjb25zdCBtMGkgPSBzcmNbaV07XHJcbiAgICAgICAgY29uc3QgbTFpID0gc3JjW2kgKyAxXTtcclxuICAgICAgICBjb25zdCBtMmkgPSBzcmNbaSArIDJdO1xyXG4gICAgICAgIGNvbnN0IG0zaSA9IHNyY1tpICsgM107XHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCA0OyArK2opIHtcclxuICAgICAgICAgICAgZHN0W2kgKyBqXSA9IG0waSAqIG1bal0gKyBtMWkgKiBtWzQgKyBqXSArIG0yaSAqIG1bOCArIGpdICtcclxuICAgICAgICAgICAgICAgIG0zaSAqIG1bMTIgKyBqXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbi8qKlxyXG4gKiBBcHBsaWVzIGEgbWF0cml4IHRvIGEgdmVjdG9yLlxyXG4gKlxyXG4gKiBAcGFyYW0gbSBUaGUgbWF0cml4LlxyXG4gKiBAcGFyYW0gdiBUaGUgdmVjdG9yLlxyXG4gKiBAcmV0dXJucyBOb3JtYWxpemVkIHByb2R1Y3Qgb2YgbXVsdGlwbHlpbmcgdGhlIHZlY3RvciBieSB0aGUgbWF0cml4LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5KG0sIHYsIGRzdCA9IHZlY3RvcjMuY3JlYXRlKDAsIDAsIDApKSB7XHJcbiAgICBjb25zdCB3ID0gbVszXSAqIHYueCArIG1bN10gKiB2LnkgKyBtWzExXSAqIHYueiArIG1bMTVdO1xyXG4gICAgY29uc3QgeCA9IChtWzBdICogdi54ICsgbVs0XSAqIHYueSArIG1bOF0gKiB2LnogKyBtWzEyXSkgLyB3O1xyXG4gICAgY29uc3QgeSA9IChtWzFdICogdi54ICsgbVs1XSAqIHYueSArIG1bOV0gKiB2LnogKyBtWzEzXSkgLyB3O1xyXG4gICAgY29uc3QgeiA9IChtWzJdICogdi54ICsgbVs2XSAqIHYueSArIG1bMTBdICogdi56ICsgbVsxNF0pIC8gdztcclxuICAgIGRzdC54ID0geDtcclxuICAgIGRzdC55ID0geTtcclxuICAgIGRzdC56ID0gejtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvbWF0aC9tYXRyaXg0LnRzXG4vLyBtb2R1bGUgaWQgPSAyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnQgY29uc3QgREVGQVVMVF9UT0xFUkFOQ0UgPSAxZS02O1xyXG4vKipcclxuICogQ2hlY2tzIGlmIHR3byBmbG9hdGluZyBwb2ludCBudW1iZXIgYXJlIHdpdGhpbiBhIHRvbGVyYW5jZSBmcm9tIGVhY2ggb3RoZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSBhIFRoZSBmaXJzdCBudW1iZXIuXHJcbiAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgbnVtYmVyLlxyXG4gKiBAcGFyYW0gdG9sZXJhbmNlIFRoZSB0b2xlcmFuY2UuXHJcbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgbnVtYmVyIGFyZSB3aXRoaW4gdGhlIHRvbGVyYW5jZSBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhcmVGdXp6eUVxdWFsKGEsIGIsIHRvbGVyYW5jZSA9IERFRkFVTFRfVE9MRVJBTkNFKSB7XHJcbiAgICBjb25zdCBkID0gYSAtIGI7XHJcbiAgICByZXR1cm4gLXRvbGVyYW5jZSA8IGQgJiYgZCA8IHRvbGVyYW5jZTtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL2Z1enp5X2VxdWFsLnRzXG4vLyBtb2R1bGUgaWQgPSAyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJsZXQgaWQgPSAxO1xyXG4vKipcclxuICogR2VuZXJhdGVzIHVuaXF1ZSBpZFxyXG4qL1xyXG5leHBvcnQgZnVuY3Rpb24gdW5pcXVlSWQoKSB7XHJcbiAgICByZXR1cm4gaWQrKztcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL3VuaXF1ZV9pZC50c1xuLy8gbW9kdWxlIGlkID0gMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgY291bnRJbmRpY2VzIH0gZnJvbSAnLi9jb3VudF92ZXJ0aWNlcyc7XHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIGEgcmVnaW9uIGluIGEgbWVtb3J5IGNodW5rLiBNZW1vcnkgaXMgYWxsb2NhdGVkIGJ5IGJpZyBjaHVua3MgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsXHJcbiAqIGFuZCB3ZSBuZWVkIGEgbWVjaGFuaXNtIHRvIGNvbnRyb2wgdGhvc2UgY2h1bmsncyBzdWJhbGxvY2F0aW9uIHRvIHByb3Blcmx5IGZyZWVcclxuICogdGhlIG9jY3VwaWVkIG1lbW9yeSAtIHRoYXQgaXMgd2hhdCB0aGlzIGNsYXNzIGlzIGZvci5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1lbW9yeVN1YkNodW5rIHtcclxuICAgIGNvbnN0cnVjdG9yKGNodW5rLCBsb2NhdGlvbikge1xyXG4gICAgICAgIHRoaXMubWVtb3J5Q2h1bmsgPSBjaHVuaztcclxuICAgICAgICB0aGlzLl9sb2NhdGlvbiA9IGxvY2F0aW9uO1xyXG4gICAgICAgIGNodW5rLnJldGFpbigpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBPZmZzZXQgb2YgdmVydGV4IGRhdGEgb2YgdGhlIGNodW5rIGluIGJ5dGVzLlxyXG4gICAgICovXHJcbiAgICBnZXQgdmVydGV4Qnl0ZU9mZnNldCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tZW1vcnlDaHVuay52ZXJ0ZXhCeXRlT2Zmc2V0ICsgdGhpcy5fbG9jYXRpb24udmVydGV4Qnl0ZU9mZnNldDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgT2Zmc2V0IG9mIGluZGV4IGRhdGEgb2YgdGhlIGNodW5rIGluIGJ5dGVzLlxyXG4gICAgICovXHJcbiAgICBnZXQgaW5kZXhCeXRlT2Zmc2V0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1lbW9yeUNodW5rLmluZGV4Qnl0ZU9mZnNldCArIHRoaXMuX2xvY2F0aW9uLmluZGV4Qnl0ZU9mZnNldDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgTnVtYmVyIG9mIGluZGV4ZXMgb2NjdXBpZWQgYnkgdGhpcyBjaHVuay5cclxuICAgICAqL1xyXG4gICAgZ2V0IGluZGV4Q291bnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvdW50SW5kaWNlcyh0aGlzLl9sb2NhdGlvbi5pbmRleEJ5dGVMZW5ndGgsIHRoaXMubWVtb3J5Q2h1bmsucGFnZS5pbmRleFR5cGUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBOdW1iZXIgb2YgYnl0ZXMgb2NjdXBpZWQgYnkgdGhpcyBjaHVuayBmb3IgdmVydGV4IGRhdGEuXHJcbiAgICAgKi9cclxuICAgIGdldCB2ZXJ0ZXhCeXRlTGVuZ3RoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhdGlvbi52ZXJ0ZXhCeXRlTGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBOdW1iZXIgb2YgYnl0ZXMgb2NjdXBpZWQgYnkgdGhpcyBjaHVuayBmb3IgaW5kZXggZGF0YS5cclxuICAgICAqL1xyXG4gICAgZ2V0IGluZGV4Qnl0ZUxlbmd0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYXRpb24uaW5kZXhCeXRlTGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLm1lbW9yeUNodW5rLnJlbGVhc2UoKTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvbWVtb3J5L3N1Yl9jaHVuay50c1xuLy8gbW9kdWxlIGlkID0gMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IEZvbnQgZnJvbSAnLi9mb250JztcclxuY29uc3QgVU5LTk9XTl9HTFlQSCA9IHtcclxuICAgIGlkOiAtMSxcclxuICAgIHdpZHRoOiAwLFxyXG4gICAgaGVpZ2h0OiAwLFxyXG4gICAgYmVhcmluZ1g6IDAsXHJcbiAgICBiZWFyaW5nWTogMCxcclxuICAgIGFkdmFuY2U6IDE4XHJcbn07XHJcbi8qKlxyXG4gKiBGb250IHdob3NlIGdseXBocyBhcmUgc3BlY2lmaWVkIGluIGRpc3RhbmNlIGZpZWxkIGJpdG1hcHMuIEl0J3MgXCJtYXJnaW5cIiBtZXRyaWMgc3BlY2lmaWVzIGdseXBoIGJpdG1hcCBpbm5lciBwYWRkaW5nLFxyXG4gKiB0aGF0IGlzIHJlcXVpcmVkIHRvIGZpdCBhIFwiYmx1cnJlZFwiIGdseXBoIGltYWdlLiBUaGlzIG1hcmdpbiBzaG91bGQgYmUgY29uc2lkZXJlZCBkdXJpbmcgbGF5b3V0aW5nIHRvIGRyYXcgZ2x5cGhzIG9mXHJcbiAqIHByb3BlciBzaXplcy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERmRm9udCBleHRlbmRzIEZvbnQge1xyXG4gICAgY29uc3RydWN0b3IoaWQsIHhoZWlnaHQsIG1hcmdpbikge1xyXG4gICAgICAgIHN1cGVyKGlkLCB4aGVpZ2h0LCBVTktOT1dOX0dMWVBIKTtcclxuICAgICAgICB0aGlzLm1hcmdpbiA9IG1hcmdpbjtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9mb250L2RmX2ZvbnQudHNcbi8vIG1vZHVsZSBpZCA9IDI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IEF0dHJpYnV0ZU1hcHBpbmcgfSBmcm9tICcuLi8uLi9yZW5kZXIvYXR0cmliX21hcHBpbmcnO1xyXG5pbXBvcnQgQnVmZmVyV3JpdGVyIGZyb20gJy4uLy4uL3V0aWwvYnVmZmVyX3dyaXRlcic7XHJcbi8qKlxyXG4gKiBCYXNlIGNsYXNzIGZvciAzRCBtb2RlbHMgYnVmZmVyIHdyaXRlcnMuIEl0IGlzIG5vdCBzdXBwb3NlZCB0byB3cml0ZSBpbmRpY2VzLCBpbnN0ZWFkIGl0IHdyaXRlcyB2ZXJ0aWNlcyAocG9zc2libHlcclxuICogZHVwbGljYXRlZCkgaW4gb3JkZXIgdGhhdCBjb3JyZXNwb25kIHRvIHRyaWFuZ3VsYXIgZmFjZXRzIG9mIHRoZSBtZXNoLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW9kZWxCdWZmZXJXcml0ZXIgZXh0ZW5kcyBCdWZmZXJXcml0ZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoTW9kZWxCdWZmZXJXcml0ZXIuQVRUUklCVVRFX01BUFBJTkcudmVydGV4Qnl0ZVNpemUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYSB2ZXJ0ZXggdG8gdGhlIHZlcnRleCBidWZmZXIuXHJcbiAgICAgKi9cclxuICAgIF93cml0ZVZlcnRleCh2LCBjb2xvclJnYmE4KSB7XHJcbiAgICAgICAgY29uc3QgdmVydGV4SWR4ID0gdGhpcy5nZXRDdXJyZW50VmVydGV4SWR4KCk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVXb3JsZENvb3JkaW5hdGUodik7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVGbG9hdDMyKHYueik7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVXb3JkKGNvbG9yUmdiYTgpO1xyXG4gICAgICAgIHJldHVybiB2ZXJ0ZXhJZHg7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIERlc2NyaXB0aW9uIG9mIGhvdyBhdHRyaWJ1dGVzIG9mIHZlcnRpY2VzIGFyZSBwYWNrZWQgaW50byBhIHZlcnRleCBidWZmZXIuXHJcbiAqL1xyXG5Nb2RlbEJ1ZmZlcldyaXRlci5BVFRSSUJVVEVfTUFQUElORyA9IG5ldyBBdHRyaWJ1dGVNYXBwaW5nKFtcclxuICAgIFtcclxuICAgICAgICAwIC8qIFBPU0lUSU9OX0hJR0ggKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIzIC8qIFVOU0lHTkVEX1NIT1JUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICAxIC8qIFBPU0lUSU9OX0xPVyAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDIsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjMgLyogVU5TSUdORURfU0hPUlQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDMgLyogSEVJR0hUICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMSxcclxuICAgICAgICAgICAgdHlwZTogNTEyNiAvKiBGTE9BVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDcgLyogQ09MT1IgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiA0LFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIxIC8qIFVOU0lHTkVEX0JZVEUgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcclxuICAgICAgICB9XHJcbiAgICBdXHJcbl0pO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9wcmltaXRpdmUvbW9kZWwvbW9kZWxfYnVmZmVyX3dyaXRlci50c1xuLy8gbW9kdWxlIGlkID0gMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiY29uc3QgTUlOX1pJTkRFWCA9IC0xICsgTWF0aC5wb3coMiwgMSAtIDI0KTsgLy8gZXBzaWxvbiBpcyBhZGRlZCAoZm9yIG5vcm1hbGl6ZWQgMjQtYml0IHZhbHVlKSB0byBmcmVlIHVwIHJlc2VydmVkIHZhbHVlXHJcbmV4cG9ydCBmdW5jdGlvbiBpbnRUb1pJbmRleCh4KSB7XHJcbiAgICByZXR1cm4gTWF0aC5tYXgoTUlOX1pJTkRFWCwgeCAvIDB4N2ZmZmZmKTtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL3pfaW5kZXgudHNcbi8vIG1vZHVsZSBpZCA9IDMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IEF0dHJpYnV0ZU1hcHBpbmcgfSBmcm9tICcuLi8uLi9yZW5kZXIvYXR0cmliX21hcHBpbmcnO1xyXG4vKipcclxuICogRGVzY3JpcHRpb24gb2YgaG93IGF0dHJpYnV0ZXMgb2YgdmVydGljZXMgYXJlIHBhY2tlZCBpbnRvIGEgdmVydGV4IGJ1ZmZlci5cclxuICovXHJcbmV4cG9ydCBjb25zdCBURVhUVVJFRF9QT0xZR09OX0FUVFJJQlVURV9NQVBQSU5HID0gbmV3IEF0dHJpYnV0ZU1hcHBpbmcoW1xyXG4gICAgW1xyXG4gICAgICAgIDAgLyogUE9TSVRJT05fSElHSCAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDIsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjMgLyogVU5TSUdORURfU0hPUlQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDEgLyogUE9TSVRJT05fTE9XICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMixcclxuICAgICAgICAgICAgdHlwZTogNTEyMyAvKiBVTlNJR05FRF9TSE9SVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgNCAvKiBVViAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDQsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjMgLyogVU5TSUdORURfU0hPUlQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICAxMSAvKiBBVVggKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAxLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTI2IC8qIEZMT0FUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgMTAgLyogWl9JTkRFWCAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDEsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjYgLyogRkxPQVQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgXVxyXG5dKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL3BvbHlnb24vdGV4dHVyZWRfcG9seWdvbl9hdHRyaWJ1dGVfbWFwcGluZy50c1xuLy8gbW9kdWxlIGlkID0gMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgQXR0cmlidXRlTWFwcGluZyB9IGZyb20gJy4uLy4uL3JlbmRlci9hdHRyaWJfbWFwcGluZyc7XHJcbi8qKlxyXG4gKiBEZXNjcmlwdGlvbiBvZiBob3cgYXR0cmlidXRlcyBvZiB2ZXJ0aWNlcyBhcmUgcGFja2VkIGludG8gYSB2ZXJ0ZXggYnVmZmVyLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IFBPTFlHT05fQVRUUklCVVRFX01BUFBJTkcgPSBuZXcgQXR0cmlidXRlTWFwcGluZyhbXHJcbiAgICBbXHJcbiAgICAgICAgMCAvKiBQT1NJVElPTl9ISUdIICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMixcclxuICAgICAgICAgICAgdHlwZTogNTEyMyAvKiBVTlNJR05FRF9TSE9SVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgMSAvKiBQT1NJVElPTl9MT1cgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIzIC8qIFVOU0lHTkVEX1NIT1JUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICA3IC8qIENPTE9SICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogNCxcclxuICAgICAgICAgICAgdHlwZTogNTEyMSAvKiBVTlNJR05FRF9CWVRFICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICAxMCAvKiBaX0lOREVYICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMSxcclxuICAgICAgICAgICAgdHlwZTogNTEyNiAvKiBGTE9BVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICBdXHJcbl0pO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9wcmltaXRpdmUvcG9seWdvbi9wb2x5Z29uX2F0dHJpYnV0ZV9tYXBwaW5nLnRzXG4vLyBtb2R1bGUgaWQgPSAzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBBdHRyaWJ1dGVNYXBwaW5nIH0gZnJvbSAnLi4vLi4vcmVuZGVyL2F0dHJpYl9tYXBwaW5nJztcclxuLyoqXHJcbiAqIERlc2NyaXB0aW9uIG9mIGhvdyBhdHRyaWJ1dGVzIG9mIHZlcnRpY2VzIGFyZSBwYWNrZWQgaW50byBhIHZlcnRleCBidWZmZXIuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgUE9MWUxJTkVfQVRUUklCVVRFX01BUFBJTkcgPSBuZXcgQXR0cmlidXRlTWFwcGluZyhbXHJcbiAgICAvKiogVmVydGV4IHdvcmxkIHBvc2l0aW9uLiAqL1xyXG4gICAgW1xyXG4gICAgICAgIDAgLyogUE9TSVRJT04gKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiA0LFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIzIC8qIFVOU0lHTkVEX1NIT1JUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIC8qKiBOb3JtYWwgdG8gcG9seWxpbmUgc2VnbWVudCB0aGUgdmVydGV4IGJlbG9uZyB0by4gKi9cclxuICAgIFtcclxuICAgICAgICA1IC8qIE5PUk1BTCAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDIsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjMgLyogVU5TSUdORURfU0hPUlQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgLyoqXHJcbiAgICAgKiBcIlVWXCIgdmVydGV4IHRoYXQgdXNlZCB0byBjb21wdXRlIHN0cm9rZSBhbmQgZGFzaGVzLiBJdCdzIGNvbXBvbmVudHM6XHJcbiAgICAgKlxyXG4gICAgICogICAtIGRpc3RhbmNlIHRvIHRoZSBhbmFseXRpY2FsIHBvbHlsaW5lIGFsb25nIHNlZ21lbnQncyBub3JtYWw7XHJcbiAgICAgKiAgIC0gZGlzdGFuY2UgdG8gdGhlIGFuYWx5dGljYWwgcG9seWxpbmUgYWxvbmcgc2VnbWVudC5cclxuICAgICAqL1xyXG4gICAgW1xyXG4gICAgICAgIDQgLyogVVYgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIzIC8qIFVOU0lHTkVEX1NIT1JUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICAvKipcclxuICAgICAqIFZlY3RvciB3aXRoIHBvbHlsaW5lJ3MgaGFsZiB3aWR0aCBhbmQgZGFzaCBzdHlsZS4gSXQncyBjb21wb25lbnRzOlxyXG4gICAgICpcclxuICAgICAqICAgLSBoYWxmIHdpZHRoO1xyXG4gICAgICogICAtIGxlbmd0aCBvZiBhIGRhc2g7XHJcbiAgICAgKiAgIC0gZGlzdGFuY2UgYmV0d2VlbiBkYXNoZXMuXHJcbiAgICAgKi9cclxuICAgIFtcclxuICAgICAgICAxMSAvKiBBVVggKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAzLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIxIC8qIFVOU0lHTkVEX0JZVEUgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgLyoqXHJcbiAgICAgKiBNaXRlciAoaS5lLiBob3cgbXVjaCBkaXNwbGFjZW1lbnQgb2YgdGhlIHZlcnRleCBpcyBsb25nZXIgdGhlbiB0aGVcclxuICAgICAqIG5vcm1hbCkuXHJcbiAgICAgKi9cclxuICAgIFtcclxuICAgICAgICAxMiAvKiBBVVgxICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMSxcclxuICAgICAgICAgICAgdHlwZTogNTEyNiAvKiBGTE9BVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgLyoqXHJcbiAgICAgKiBMaW1pdCBvbiBkaXNwbGFjZW1lbnQgdGFuZ2VudCBjb21wb25lbnQuQXBwbGllZCB0byBhdm9pZCBnZW9tZXRyeVxyXG4gICAgICogZ2xpdGNoZXMgaW4gb3Zlci1kZWdlbmVyYXRpdmUgY2FzZXMuXHJcbiAgICAgKi9cclxuICAgIFtcclxuICAgICAgICAxMyAvKiBBVVgyICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMSxcclxuICAgICAgICAgICAgdHlwZTogNTEyNiAvKiBGTE9BVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgLyoqXHJcbiAgICAgKiBEaXN0YW5jZSB0byB0aGUgZmlyc3QgdmVydGV4IGFsb25nIHRoZSBwb2x5bGluZS5cclxuICAgICAqL1xyXG4gICAgW1xyXG4gICAgICAgIDE0IC8qIEFVWDMgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAxLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTI2IC8qIEZMT0FUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICAvKiogUG9seWxpbmUncyBjb2xvci4gKi9cclxuICAgIFtcclxuICAgICAgICA3IC8qIENPTE9SICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogNCxcclxuICAgICAgICAgICAgdHlwZTogNTEyMSAvKiBVTlNJR05FRF9CWVRFICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIC8qKiBQb2x5bGluZSdzIFogaW5kZXguICovXHJcbiAgICBbXHJcbiAgICAgICAgMTAgLyogWl9JTkRFWCAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDEsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjYgLyogRkxPQVQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgXVxyXG5dKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL3BvbHlsaW5lL3BvbHlsaW5lX2F0dHJpYnV0ZV9tYXBwaW5nLnRzXG4vLyBtb2R1bGUgaWQgPSAzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBleHRyYWN0VHJhbnNmZXJhYmxlcyB9IGZyb20gJy4vcHJpbWl0aXZlX3Byb3ZpZGVyX3dvcmtlcl9tZXNzYWdlcyc7XHJcbmV4cG9ydCB2YXIgVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGU7XHJcbihmdW5jdGlvbiAoVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGUpIHtcclxuICAgIFRpbGVQcm92aWRlck1lc3NhZ2VUeXBlW1RpbGVQcm92aWRlck1lc3NhZ2VUeXBlW1wiSU5JVFwiXSA9IDBdID0gXCJJTklUXCI7XHJcbiAgICBUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZVtUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZVtcIlRJTEVfVVJMX1VQREFURVwiXSA9IDFdID0gXCJUSUxFX1VSTF9VUERBVEVcIjtcclxuICAgIFRpbGVQcm92aWRlck1lc3NhZ2VUeXBlW1RpbGVQcm92aWRlck1lc3NhZ2VUeXBlW1wiVElMRV9SRVFVRVNUX0JBVENIXCJdID0gMl0gPSBcIlRJTEVfUkVRVUVTVF9CQVRDSFwiO1xyXG4gICAgVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGVbVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGVbXCJUSUxFX1JFUVVFU1RfQ0FOQ0VMX0JBVENIXCJdID0gM10gPSBcIlRJTEVfUkVRVUVTVF9DQU5DRUxfQkFUQ0hcIjtcclxuICAgIFRpbGVQcm92aWRlck1lc3NhZ2VUeXBlW1RpbGVQcm92aWRlck1lc3NhZ2VUeXBlW1wiVElMRV9SRVNQT05TRVwiXSA9IDRdID0gXCJUSUxFX1JFU1BPTlNFXCI7XHJcbiAgICBUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZVtUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZVtcIlRJTEVfRVJST1JcIl0gPSA1XSA9IFwiVElMRV9FUlJPUlwiO1xyXG4gICAgVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGVbVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGVbXCJHRU9NRVRSWV9SRVNQT05TRVwiXSA9IDZdID0gXCJHRU9NRVRSWV9SRVNQT05TRVwiO1xyXG4gICAgVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGVbVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGVbXCJMQUJFTFNfUkVTUE9OU0VcIl0gPSA3XSA9IFwiTEFCRUxTX1JFU1BPTlNFXCI7XHJcbiAgICBUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZVtUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZVtcIk1FU0hfUkVRVUVTVFwiXSA9IDhdID0gXCJNRVNIX1JFUVVFU1RcIjtcclxuICAgIFRpbGVQcm92aWRlck1lc3NhZ2VUeXBlW1RpbGVQcm92aWRlck1lc3NhZ2VUeXBlW1wiTUVTSF9SRVFVRVNUX0NBTkNFTFwiXSA9IDldID0gXCJNRVNIX1JFUVVFU1RfQ0FOQ0VMXCI7XHJcbiAgICBUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZVtUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZVtcIk1FU0hfUkVTUE9OU0VcIl0gPSAxMF0gPSBcIk1FU0hfUkVTUE9OU0VcIjtcclxuICAgIFRpbGVQcm92aWRlck1lc3NhZ2VUeXBlW1RpbGVQcm92aWRlck1lc3NhZ2VUeXBlW1wiTUVTSF9FUlJPUlwiXSA9IDExXSA9IFwiTUVTSF9FUlJPUlwiO1xyXG59KShUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZSB8fCAoVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGUgPSB7fSkpO1xyXG5leHBvcnQgY29uc3QgZ2VvbWV0cnlUcmFuc2ZlcmFibGVFeHRyYWN0b3IgPSBmdW5jdGlvbiAobWVzc2FnZSwgdHJhbnNmZXJhYmxlcyA9IFtdKSB7XHJcbiAgICBleHRyYWN0VHJhbnNmZXJhYmxlcyhtZXNzYWdlLnBvbHlnb25QYWdlcywgdHJhbnNmZXJhYmxlcyk7XHJcbiAgICBleHRyYWN0VHJhbnNmZXJhYmxlcyhtZXNzYWdlLnRyYW5zcGFyZW50UG9seWdvblBhZ2VzLCB0cmFuc2ZlcmFibGVzKTtcclxuICAgIGV4dHJhY3RUcmFuc2ZlcmFibGVzKG1lc3NhZ2UudGV4dHVyZWRQb2x5Z29uUGFnZXMsIHRyYW5zZmVyYWJsZXMpO1xyXG4gICAgZXh0cmFjdFRyYW5zZmVyYWJsZXMobWVzc2FnZS5tZXNoUGFnZXMsIHRyYW5zZmVyYWJsZXMpO1xyXG4gICAgZXh0cmFjdFRyYW5zZmVyYWJsZXMobWVzc2FnZS5wb2x5bGluZVBhZ2VzLCB0cmFuc2ZlcmFibGVzKTtcclxuICAgIHJldHVybiB0cmFuc2ZlcmFibGVzO1xyXG59O1xyXG5leHBvcnQgY29uc3QgbWVzaFRyYW5zZmVyYWJsZUV4dHJhY3RvciA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XHJcbiAgICBjb25zdCB0cmFuc2ZlcmFibGVzID0gW107XHJcbiAgICBleHRyYWN0VHJhbnNmZXJhYmxlcyhtZXNzYWdlLnBhZ2VzLCB0cmFuc2ZlcmFibGVzKTtcclxuICAgIHJldHVybiB0cmFuc2ZlcmFibGVzO1xyXG59O1xyXG5leHBvcnQgY29uc3QgbGFiZWxUcmFuc2ZlcmFibGVFeHRyYWN0b3IgPSBmdW5jdGlvbiAobWVzc2FnZSwgdHJhbnNmZXJhYmxlcyA9IFtdKSB7XHJcbiAgICBleHRyYWN0VHJhbnNmZXJhYmxlcyhtZXNzYWdlLnBvaW50TGFiZWxQYWdlcywgdHJhbnNmZXJhYmxlcyk7XHJcbiAgICBleHRyYWN0VHJhbnNmZXJhYmxlcyhtZXNzYWdlLnBvaW50TGFiZWxCYWNrZ3JvdW5kUGFnZXMsIHRyYW5zZmVyYWJsZXMpO1xyXG4gICAgZXh0cmFjdFRyYW5zZmVyYWJsZXMobWVzc2FnZS5jdXJ2ZWRMYWJlbFBhZ2VzLCB0cmFuc2ZlcmFibGVzKTtcclxuICAgIHJldHVybiB0cmFuc2ZlcmFibGVzO1xyXG59O1xyXG5leHBvcnQgY29uc3QgdGlsZVRyYW5zZmVyYWJsZUV4dHJhY3RvciA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XHJcbiAgICBjb25zdCB0cmFuc2ZlcmFibGVzID0gW107XHJcbiAgICBnZW9tZXRyeVRyYW5zZmVyYWJsZUV4dHJhY3RvcihtZXNzYWdlLCB0cmFuc2ZlcmFibGVzKTtcclxuICAgIGxhYmVsVHJhbnNmZXJhYmxlRXh0cmFjdG9yKG1lc3NhZ2UsIHRyYW5zZmVyYWJsZXMpO1xyXG4gICAgcmV0dXJuIHRyYW5zZmVyYWJsZXM7XHJcbn07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2FkYXB0ZXJzL3ZlY3Rvcl9hcGkvd29ya2VyL3RpbGVfcHJvdmlkZXJfd29ya2VyX21lc3NhZ2VzLnRzXG4vLyBtb2R1bGUgaWQgPSAzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgQmluYXJ5SGVhcCBmcm9tICcuL2JpbmFyeV9oZWFwJztcclxuZnVuY3Rpb24gaXRlbUNvbXBhcmF0b3IoYSwgYikge1xyXG4gICAgcmV0dXJuIGEucHJpb3JpdHkgLSBiLnByaW9yaXR5O1xyXG59XHJcbi8qKlxyXG4gKiBQcmlvcml0eSBxdWV1ZSBiYXNlZCBvbiBhIGhlYXAuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcmlvcml0eVF1ZXVlIHtcclxuICAgIC8qKlxyXG4gICAgICogQ29uc3RydWN0cyBuZXcgZW1wdHkgcHJpb3JpdHkgcXVldWUuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuX2hlYXAgPSBuZXcgQmluYXJ5SGVhcChpdGVtQ29tcGFyYXRvcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYW4gaXRlbSBpbnRvIHRoZSBxdWV1ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaXRlbSBUaGUgaXRlbS5cclxuICAgICAqL1xyXG4gICAgZW5xdWV1ZShpdGVtKSB7XHJcbiAgICAgICAgdGhpcy5faGVhcC5pbnNlcnQoaXRlbSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgbmV4dCBpdGVtIGZyb20gdGhlIHF1ZXVlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFRoZSBuZXh0IGl0ZW0gb3IgYHVuZGVmaW5lZGAgaWYgdGhlIHF1ZXVlJ3MgZW1wdHkuXHJcbiAgICAgKi9cclxuICAgIGRlcXVldWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlYXAucG9wKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyBpZiB0aGUgcXVldWUgaGFzIG5vIGl0ZW1zIGluIGl0LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGVyZSdyZSBubyBpdGVtcyBpdCB0aGUgcXVldWUgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxyXG4gICAgICovXHJcbiAgICBpc0VtcHR5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9oZWFwLnNpemUgPT09IDA7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9wcmlvcml0eV9xdWV1ZS50c1xuLy8gbW9kdWxlIGlkID0gMzVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IFJlbmRlcmFibGVQcmltaXRpdmUgZnJvbSAnLi4vcmVuZGVyYWJsZV9wcmltaXRpdmUnO1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW5kZXJhYmxlUG9seWxpbmUgZXh0ZW5kcyBSZW5kZXJhYmxlUHJpbWl0aXZlIHtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9wcmltaXRpdmUvcG9seWxpbmUvcmVuZGVyYWJsZV9wb2x5bGluZS50c1xuLy8gbW9kdWxlIGlkID0gMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IFJlbmRlcmFibGVQcmltaXRpdmUgZnJvbSAnLi4vcmVuZGVyYWJsZV9wcmltaXRpdmUnO1xyXG4vKipcclxuICogQSBnZW5lcmFsIHByaW1pdGl2ZSB0aGF0IGlzIGJlc3Qgc3VpdGFibGUgZm9yIHN0b3Jpbmcgc2ltcGxlIGNvbG9yZWQgM0QgbW9kZWxzLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVuZGVyYWJsZU1vZGVsIGV4dGVuZHMgUmVuZGVyYWJsZVByaW1pdGl2ZSB7XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL21vZGVsL3JlbmRlcmFibGVfbW9kZWwudHNcbi8vIG1vZHVsZSBpZCA9IDM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiBPZnRlbiBwcmltaXRpdmVzIGNhbid0IGJlIGRpcnJlY3RseSBhZGRlZCBpbnRvIG9yIHJlbW92ZWQgZnJvbSBzY2VuZSwgdGhlcmUgY2FuIGJlIHNvbWUgc3BlY2lmaWMgKGJ1c2luZXNzKSBsb2dpY1xyXG4gKiBhc3NvY2lhdGVkIHdpdGggdGhlc2Ugb3BlcmF0aW9ucy4gVGhpcyBjbGFzcyBwcm92aWRlcyBiYXNpYyBtZXRob2RzIGZvciBzdWNoIGltcGxlbWVudGF0aW9ucyB0aGF0XHJcbiAqIGFsbG93cyB0byBtYW5hZ2UgcHJpbWl0aXZlcyBvZiBhbGwgdHlwZXMgaW4gdGhlIHNhbWUgbWFubmVyLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJpbWl0aXZlTWFuYWdlciB7XHJcbiAgICBkZXN0cm95KCkgeyB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdmVjdG9yX2FwaS9wcmltaXRpdmVfbWFuYWdlci9wcmltaXRpdmVfbWFuYWdlci50c1xuLy8gbW9kdWxlIGlkID0gMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgVm9pZEV2ZW50RW1pdHRlciB9IGZyb20gJy4uLy4uL3V0aWwvZXZlbnRfZW1pdHRlcic7XHJcbi8qKlxyXG4gKiBQcmltaXRpdmUgc3RvcmFnZSB0aGF0IHN0b3JlcyBwcmltaXRpdmUgaW4gYSBzZXQuIEl0IGFjdHMgYXMgYSBwcmltaXRpdmUgcHJvdmlkZXIgYXMgd2VsbC5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByaW1pdGl2ZVNldFN0b3JhZ2Uge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5fcHJpbWl0aXZlU2V0ID0gbmV3IFNldCgpO1xyXG4gICAgICAgIHRoaXMub25VcGRhdGUgPSBuZXcgVm9pZEV2ZW50RW1pdHRlcigpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHByaW1pdGl2ZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaW1pdGl2ZVNldDtcclxuICAgIH1cclxuICAgIGFkZCguLi5wcmltaXRpdmVzKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBwcmltaXRpdmUgb2YgcHJpbWl0aXZlcykge1xyXG4gICAgICAgICAgICBwcmltaXRpdmUucmV0YWluKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3ByaW1pdGl2ZVNldC5hZGQocHJpbWl0aXZlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHByaW1pdGl2ZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICB0aGlzLm9uVXBkYXRlLmZpcmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBkZWxldGUoLi4ucHJpbWl0aXZlcykge1xyXG4gICAgICAgIGZvciAoY29uc3QgcHJpbWl0aXZlIG9mIHByaW1pdGl2ZXMpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3ByaW1pdGl2ZVNldC5kZWxldGUocHJpbWl0aXZlKSkge1xyXG4gICAgICAgICAgICAgICAgcHJpbWl0aXZlLnJlbGVhc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocHJpbWl0aXZlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25VcGRhdGUuZmlyZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNsZWFyKCkge1xyXG4gICAgICAgIHRoaXMuX3ByaW1pdGl2ZVNldC5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMub25VcGRhdGUuZmlyZSgpO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL3ByaW1pdGl2ZV9zZXRfc3RvcmFnZS50c1xuLy8gbW9kdWxlIGlkID0gMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IFByaW1pdGl2ZVNldFN0b3JhZ2UgZnJvbSAnLi9wcmltaXRpdmVfc2V0X3N0b3JhZ2UnO1xyXG4vKipcclxuICogU2ltcGxlIHByaW1pdGl2ZSBzZXQgc3RvcmFnZSB0aGF0IGRpc3Rpbmd1aXNoIHZpc2libGUvaGlkZGVuIHByaW1pdGl2ZXMuIEl0IGFsc28gYWN0cyBhcyBhIHByaW1pdGl2ZSBwcm92aWRlci5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERpc2FwcGVhcmluZ1ByaW1pdGl2ZVNldFN0b3JhZ2UgZXh0ZW5kcyBQcmltaXRpdmVTZXRTdG9yYWdlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fdmlzaWJsZVByaW1pdGl2ZXMgPSBuZXcgU2V0KCk7XHJcbiAgICB9XHJcbiAgICBnZXQgcHJpbWl0aXZlcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52aXNpYmxlUHJpbWl0aXZlcztcclxuICAgIH1cclxuICAgIGdldCB2aXNpYmxlUHJpbWl0aXZlcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaWJsZVByaW1pdGl2ZXM7XHJcbiAgICB9XHJcbiAgICBhZGQoLi4ucHJpbWl0aXZlcykge1xyXG4gICAgICAgIHN1cGVyLmFkZCguLi5wcmltaXRpdmVzKTtcclxuICAgICAgICB0aGlzLnNob3coLi4ucHJpbWl0aXZlcyk7XHJcbiAgICB9XHJcbiAgICBkZWxldGUoLi4ucHJpbWl0aXZlcykge1xyXG4gICAgICAgIHRoaXMuaGlkZSguLi5wcmltaXRpdmVzKTtcclxuICAgICAgICBzdXBlci5kZWxldGUoLi4ucHJpbWl0aXZlcyk7XHJcbiAgICB9XHJcbiAgICBzaG93KC4uLnByaW1pdGl2ZXMpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IHByaW1pdGl2ZSBvZiBwcmltaXRpdmVzKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9wcmltaXRpdmVTZXQuaGFzKHByaW1pdGl2ZSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Zpc2libGVQcmltaXRpdmVzLmFkZChwcmltaXRpdmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaGlkZSguLi5wcmltaXRpdmVzKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBwcmltaXRpdmUgb2YgcHJpbWl0aXZlcykge1xyXG4gICAgICAgICAgICB0aGlzLl92aXNpYmxlUHJpbWl0aXZlcy5kZWxldGUocHJpbWl0aXZlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfaXNBbGxvd2VkVG9TaG93UHJpbWl0aXZlKHByaW1pdGl2ZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wcmltaXRpdmVTZXQuaGFzKHByaW1pdGl2ZSk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvZGlzYXBwZWFyaW5nX3ByaW1pdGl2ZV9zZXRfc3RvcmFnZS50c1xuLy8gbW9kdWxlIGlkID0gNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0IGNsYXNzIERlbGVnYXRvckJhc2Uge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5fZGVsZWdhdGUgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgc2V0RGVsZWdhdGUoZGVsZWdhdGUpIHtcclxuICAgICAgICB0aGlzLl9kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvZGVsZWdhdG9yLnRzXG4vLyBtb2R1bGUgaWQgPSA0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwiI3ZlcnNpb24gMTAwXFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG52YXJ5aW5nIGxvd3AgdmVjNCBjb2xvcjtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgICBnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG59XFxuXCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS92aXNpYmlsaXR5L3ByaW1pdGl2ZXMvbGFiZWwvc2hhZGVyL2NvbG9yX2lkLmZyYWdcbi8vIG1vZHVsZSBpZCA9IDQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IENvbGxpZGluZ1ByaW1pdGl2ZUNvbG9ySWRSZW5kZXJlciB9IGZyb20gJy4uL2NvbGxpZGluZ19wcmltaXRpdmVfY29sb3JfaWRfcmVuZGVyZXInO1xyXG4vKipcclxuICogXCJjb2xvciBpZFwiIHJlbmRlcmVyIGZvciBsYWJlbHMsIGJvdGggZm9yIHBvaW50IGFuZCBjdXJ2ZWQgb25lcy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbG9ySWRMYWJlbFJlbmRlcmVyIGV4dGVuZHMgQ29sbGlkaW5nUHJpbWl0aXZlQ29sb3JJZFJlbmRlcmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIHByb2dyYW0sIHByaW1pdGl2ZVByb3ZpZGVyLCBjYW1lcmEpIHtcclxuICAgICAgICBzdXBlcihjb250ZXh0LCBwcm9ncmFtLCBwcmltaXRpdmVQcm92aWRlcik7XHJcbiAgICAgICAgdGhpcy5fY2FtZXJhID0gY2FtZXJhO1xyXG4gICAgfVxyXG4gICAgX3ByZXBhcmVQcm9ncmFtKHByb2dyYW0sIHZpZXdQcm9qTWF0cml4LCBjYW1lcmFQb3NpdGlvbnMsIHN0YXRlLCBzdGFiaWxpdHlTaGlmdCwgdmlzaWJpbGl0eSwgY3VycmVudFpvb20pIHtcclxuICAgICAgICBzdXBlci5fcHJlcGFyZVByb2dyYW0ocHJvZ3JhbSwgdmlld1Byb2pNYXRyaXgsIGNhbWVyYVBvc2l0aW9ucywgc3RhdGUsIHN0YWJpbGl0eVNoaWZ0LCB2aXNpYmlsaXR5LCBjdXJyZW50Wm9vbSk7XHJcbiAgICAgICAgcHJvZ3JhbS5zZXRWZWN0b3IyVW5pZm9ybSgncGl4ZWxTaXplJywgdGhpcy5fY2FtZXJhLnBpeGVsU2l6ZSk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdmlzaWJpbGl0eS9wcmltaXRpdmVzL2xhYmVsL2NvbG9yX2lkX2xhYmVsX3JlbmRlcmVyLnRzXG4vLyBtb2R1bGUgaWQgPSA0M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBiYXRjaEFsbG9jYXRlZE9iamVjdHMgfSBmcm9tICcuLi9tZW1vcnkvcmVsYXRpdmVfbG9jYXRpb24nO1xyXG4vKipcclxuICogQ3JlYXRlcyBiYXRjaCBmcm9tIGZpcnN0IHByaW1pdGl2ZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBpbml0QmF0Y2gocHJpbWl0aXZlKSB7XHJcbiAgICBjb25zdCBzdWJDaHVuayA9IHByaW1pdGl2ZS5tZW1vcnlTdWJDaHVuaztcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZmlyc3RQcmltaXRpdmU6IHByaW1pdGl2ZSxcclxuICAgICAgICBwYWdlOiBzdWJDaHVuay5tZW1vcnlDaHVuay5wYWdlLFxyXG4gICAgICAgIHZlcnRleEJ5dGVPZmZzZXQ6IHN1YkNodW5rLnZlcnRleEJ5dGVPZmZzZXQsXHJcbiAgICAgICAgdmVydGV4Qnl0ZUxlbmd0aDogc3ViQ2h1bmsudmVydGV4Qnl0ZUxlbmd0aCxcclxuICAgICAgICBpbmRleEJ5dGVPZmZzZXQ6IHN1YkNodW5rLmluZGV4Qnl0ZU9mZnNldCxcclxuICAgICAgICBpbmRleEJ5dGVMZW5ndGg6IHN1YkNodW5rLmluZGV4Qnl0ZUxlbmd0aFxyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogQmF0Y2hlcyBwcmltaXRpdmVzIHRoYXQgY2FuIGJlIHJlbmRlcmVkIGJ5IGEgc2luZ2xlIGRyYXcgY2FsbCwgdGhhdCBpcyBjcml0aWNhbCBmb3IgcGVyZm9ybWFuY2UuXHJcbiAqIFBlcmZvcm1hbmNlIGdhaW4gZnJvbSB0aGlzIG1ldGhvZCBpcyBwb3NzaWJsZSAod2hpbGUgaXQgaXMgbm90IHN0cmljdGx5IHJlcXVpcmVkKSBpZiBwcmltaXRpdmVzXHJcbiAqIGFyZSBzb3J0ZWQgYnkgbWVtb3J5IG9mZnNldCBhbmQgdGhlcmUgYXJlIG5vIG1hbnkgXCJob2xlc1wiIGJldHdlZW4gdGhlbS5cclxuICogTWluaW1hbCByZXF1aXJlbWV0cyBmb3IgYmF0Y2hpbmcgaXMgbG9jYXRpb24gaW4gdGhlIHNhbWUgYnVmZmVyIChtZW1vcnkgcGFnZSksIGFkZGl0aW9uYWxcclxuICogcmVxdWlyZW1lbnRzIChzdWNoIGFzIGhhdmluZyBzaGFyZWQgdGV4dHVyZSBvciBzaW1pbGFyKSBjYW4gYmUgaW1wb3NlZCBpbiBjYW5CYXRjaFByaWRpY2F0ZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBiYXRjaFByaW1pdGl2ZXMocHJpbWl0aXZlcywgY2FuQmF0Y2hQcmlkaWNhdGUpIHtcclxuICAgIGNvbnN0IGNhbkJhdGNoID0gKGEsIGIpID0+IHtcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgLy8gbWluaW1hbCByZXF1aXJlbWVudHMgZm9yIGJhdGNoaW5nIGlzIHRoYXQgcHJpbWl0aXZlcyBsYXkgaW4gdGhlIHNhbWUgcGFnZVxyXG4gICAgICAgIChhLm1lbW9yeVN1YkNodW5rLm1lbW9yeUNodW5rLnBhZ2UgIT09IGIubWVtb3J5U3ViQ2h1bmsubWVtb3J5Q2h1bmsucGFnZSkgfHxcclxuICAgICAgICAgICAgLy8gY2hhY2sgZXh0ZXJuYWwgcmVxdWlyZW1lbnRzIGlmIHNwZWNpZmllZFxyXG4gICAgICAgICAgICAoY2FuQmF0Y2hQcmlkaWNhdGUgJiYgIWNhbkJhdGNoUHJpZGljYXRlKGEsIGIpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGJhdGNoQWxsb2NhdGVkT2JqZWN0cyhwcmltaXRpdmVzLCAocHJpbWl0aXZlKSA9PiBwcmltaXRpdmUubWVtb3J5U3ViQ2h1bmssIGluaXRCYXRjaCwgY2FuQmF0Y2gpO1xyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL3ByaW1pdGl2ZV9iYXRjaC50c1xuLy8gbW9kdWxlIGlkID0gNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHBvaW50TGFiZWxWZXJ0ZXhTaGFkZXIgZnJvbSAnLi9zaGFkZXIvcG9pbnRfbGFiZWwudmVydCc7XHJcbmltcG9ydCBkZlRleHRGcmFnbWVudFNoYWRlciBmcm9tICcuL3NoYWRlci9kZl90ZXh0LmZyYWcnO1xyXG5pbXBvcnQgTGFiZWxSZW5kZXJVbml0IGZyb20gJy4vbGFiZWxfcmVuZGVyX3VuaXQnO1xyXG5pbXBvcnQgQmlsbGJvYXJkUmVjdGFuZ2xlUmVuZGVyVW5pdCBmcm9tICcuLi9iaWxsYm9hcmRfcmVjdGFuZ2xlL2JpbGxib2FyZF9yZWN0YW5nbGVfcmVuZGVyX3VuaXQnO1xyXG5pbXBvcnQgeyBWb2lkRXZlbnRFbWl0dGVyIH0gZnJvbSAnLi4vLi4vLi4vdXRpbC9ldmVudF9lbWl0dGVyJztcclxuaW1wb3J0IHsgbWFwSXRlcmFibGUsIGZpbHRlckl0ZXJhYmxlIH0gZnJvbSAnLi4vLi4vLi4vdXRpbC9pdGVyYWJsZSc7XHJcbmV4cG9ydCBjb25zdCBQUk9HUkFNX09QVElPTlMgPSB7XHJcbiAgICBhdHRyaWJNYXA6IHtcclxuICAgICAgICB2ZXJ0ZXhJZDogMiAvKiBJRCAqLyxcclxuICAgICAgICB2ZXJ0ZXhQb3NIaWdoOiAwIC8qIFBPU0lUSU9OX0hJR0ggKi8sXHJcbiAgICAgICAgdmVydGV4UG9zTG93OiAxIC8qIFBPU0lUSU9OX0xPVyAqLyxcclxuICAgICAgICB2ZXJ0ZXhEaXNwbGFjZW1lbnQ6IDYgLyogRElTUExBQ0VNRU5UICovLFxyXG4gICAgICAgIHZlcnRleFVWOiA0IC8qIFVWICovLFxyXG4gICAgICAgIHZlcnRleFByaW9yaXR5OiA5IC8qIFBSSU9SSVRZICovLFxyXG4gICAgICAgIHZlcnRleENvbG9yOiA3IC8qIENPTE9SICovLFxyXG4gICAgICAgIHZlcnRleE91dGxpbmVDb2xvcjogOCAvKiBPVVRMSU5FX0NPTE9SICovLFxyXG4gICAgICAgIHZlcnRleFNjYWxlOiAxMSAvKiBBVVggKi9cclxuICAgIH1cclxufTtcclxuLyoqXHJcbiAqIFJlbmRlcnMgYmFja2dyb3VuZHMgZXh0cmFjdGVkIGZyb20gcG9pbnQgbGFiZWxzLlxyXG4gKi9cclxuY2xhc3MgQmFja2dyb3VuZFByaW1pdGl2ZVByb3ZpZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGxhYmVsc1Byb3ZpZGVyKSB7XHJcbiAgICAgICAgdGhpcy5vblVwZGF0ZSA9IG5ldyBWb2lkRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5fbGFiZWxzUHJvdmlkZXIgPSBsYWJlbHNQcm92aWRlcjtcclxuICAgIH1cclxuICAgIGdldCBwcmltaXRpdmVzKCkge1xyXG4gICAgICAgIHJldHVybiBtYXBJdGVyYWJsZShmaWx0ZXJJdGVyYWJsZSh0aGlzLl9sYWJlbHNQcm92aWRlci5wcmltaXRpdmVzLCAobGFiZWwpID0+IGxhYmVsLmJhY2tncm91bmQgIT09IHVuZGVmaW5lZCksIChsYWJlbCkgPT4gbGFiZWwuYmFja2dyb3VuZCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFBvaW50IGxhYmVscyByZW5kZXJlci4gSXQgdXNlcyBhcHByb3ByaWF0ZSBwcm9ncmFtIHRvIGxheW91dCBnbHlwaHMgb24gR1BVLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9pbnRMYWJlbFJlbmRlclVuaXQgZXh0ZW5kcyBMYWJlbFJlbmRlclVuaXQge1xyXG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgY2FtZXJhLCB2aXNpYmlsaXR5UHJvdmlkZXIsIHByaW1pdGl2ZVByb3ZpZGVyKSB7XHJcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IGNvbnRleHQuY3JlYXRlUHJvZ3JhbShwb2ludExhYmVsVmVydGV4U2hhZGVyLCBkZlRleHRGcmFnbWVudFNoYWRlciwgUFJPR1JBTV9PUFRJT05TKTtcclxuICAgICAgICBzdXBlcihjb250ZXh0LCBwcm9ncmFtLCBjYW1lcmEsIHZpc2liaWxpdHlQcm92aWRlciwgcHJpbWl0aXZlUHJvdmlkZXIpO1xyXG4gICAgICAgIHRoaXMuX2JhY2tncm91bmRSZW5kZXJlciA9IG5ldyBCaWxsYm9hcmRSZWN0YW5nbGVSZW5kZXJVbml0KGNvbnRleHQsIGNhbWVyYSwgdmlzaWJpbGl0eVByb3ZpZGVyLCBuZXcgQmFja2dyb3VuZFByaW1pdGl2ZVByb3ZpZGVyKHByaW1pdGl2ZVByb3ZpZGVyKSk7XHJcbiAgICAgICAgdGhpcy5fYmFja2dyb3VuZFJlbmRlcmVyLm9uVXBkYXRlLmFkZExpc3RlbmVyKCgpID0+IHRoaXMub25VcGRhdGUuZmlyZSgpKTtcclxuICAgIH1cclxuICAgIHJlbmRlcih0YXJnZXQsIHZpZXdQcm9qTWF0cml4LCBjYW1lcmFQb3NpdGlvbnMpIHtcclxuICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kUmVuZGVyZXIucmVuZGVyKHRhcmdldCwgdmlld1Byb2pNYXRyaXgsIGNhbWVyYVBvc2l0aW9ucyk7XHJcbiAgICAgICAgc3VwZXIucmVuZGVyKHRhcmdldCwgdmlld1Byb2pNYXRyaXgsIGNhbWVyYVBvc2l0aW9ucyk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvbGFiZWwvcG9pbnRfbGFiZWxfcmVuZGVyX3VuaXQudHNcbi8vIG1vZHVsZSBpZCA9IDQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG5cXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbnVuaWZvcm0gZmxvYXQgZHByO1xcbnVuaWZvcm0gc2FtcGxlcjJEIGF0bGFzO1xcbnVuaWZvcm0gdmVjMiBhdGxhc1NpemU7XFxuXFxudmFyeWluZyB2ZWMyIHV2O1xcbnZhcnlpbmcgbG93cCB2ZWM0IGNvbG9yO1xcbnZhcnlpbmcgbG93cCB2ZWM0IG91dGxpbmVDb2xvcjtcXG52YXJ5aW5nIGZsb2F0IHNjYWxlO1xcblxcbmNvbnN0IGZsb2F0IE1BWF9DT1JSRUNURURfR0xZUEhfU0NBTEUgPSAwLjU7XFxuY29uc3QgZmxvYXQgR0xZUEhfQkFTRV9XRUlHSFQgPSAwLjc7XFxuY29uc3QgZmxvYXQgR0xZUEhfQkFTRV9TTU9USE5FU1MgPSAwLjE7XFxuY29uc3QgZmxvYXQgR0xZUEhfV0VJR0hUX1NDQUxFX0lNUEFDVCA9IDAuMTtcXG5jb25zdCBmbG9hdCBHTFlQSF9TTU9PVEhORVNTX1NDQUxFX0lNUEFDVCA9IDAuMDY7XFxuY29uc3QgZmxvYXQgT1VUTElORV9XRUlHSFRfU0NBTEVfSU1QQUNUID0gMC4xMjU7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gICAgLy8gbG93IHNjYWxlIGdseXBocyAobGVzcyB0aGFuIDAuNSkgc2hvdWxkIGJlIGEgbGl0dGxlIGJpdCBib2xkZXIgYW5kIHNtb290aGVyXFxuICAgIGZsb2F0IHNjYWxlQ2xhbXBlZCA9IGNsYW1wKHNjYWxlLCAwLjAsIE1BWF9DT1JSRUNURURfR0xZUEhfU0NBTEUpO1xcbiAgICAvLyB3ZWlnaHQgaXMgcmVzcG9uc2libGUgZm9yIGdseXBoIGJvbGRuZXNzLCB0aGUgbGVzcyB3ZWlnaHQgdmFsdWUgdGhlIGJvbGRlciB0aGUgdGV4dFxcbiAgICBmbG9hdCB3ZWlnaHQgPSBHTFlQSF9CQVNFX1dFSUdIVCArIEdMWVBIX1dFSUdIVF9TQ0FMRV9JTVBBQ1QgKiBzY2FsZUNsYW1wZWQ7XFxuICAgIC8vIHNtb290aG5lc3MgaXMgaG93IGJsdXJyZWQgZ2x5cGhzIGFyZSwgdGhlIGxlc3Mgc21vb3RobmVzcyB2YWx1ZSB0aGUgbGVzcyBibHVycmluZ1xcbiAgICBmbG9hdCBzbW9vdGhuZXNzID0gKEdMWVBIX0JBU0VfU01PVEhORVNTICsgR0xZUEhfU01PT1RITkVTU19TQ0FMRV9JTVBBQ1QgLyBzY2FsZUNsYW1wZWQpIC8gZHByO1xcblxcbiAgICB2ZWM0IHJlc3VsdENvbG9yID0gY29sb3I7XFxuICAgIGZsb2F0IGRpc3QgPSB0ZXh0dXJlMkQoYXRsYXMsIHV2IC8gYXRsYXNTaXplKS5hO1xcbiAgICBmbG9hdCBhbHBoYSA9IHNtb290aHN0ZXAod2VpZ2h0IC0gc21vb3RobmVzcywgd2VpZ2h0ICsgc21vb3RobmVzcywgZGlzdCk7XFxuXFxuICAgIGlmIChvdXRsaW5lQ29sb3IuYSAhPSAwLjApIHtcXG4gICAgICAgIC8vIHRvIHJlbmRlciBvdXRsaW5lIHRoZSBnbHlwaCBpcyByZW5kZXJlZCBhIGxpdHRsZSBiaXQgYm9sZGVyIHdpdGggZGlmZmVyZW50IGNvbG9yIGF0IGVkZ2VzXFxuICAgICAgICB3ZWlnaHQgPSB3ZWlnaHQgLSBPVVRMSU5FX1dFSUdIVF9TQ0FMRV9JTVBBQ1QgLyBzY2FsZTtcXG4gICAgICAgIHJlc3VsdENvbG9yID0gbWl4KG91dGxpbmVDb2xvciwgY29sb3IsIGFscGhhKTtcXG4gICAgICAgIGFscGhhID0gc21vb3Roc3RlcCh3ZWlnaHQgLSBzbW9vdGhuZXNzLCB3ZWlnaHQgKyBzbW9vdGhuZXNzLCBkaXN0KTtcXG4gICAgfVxcblxcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHJlc3VsdENvbG9yLnJnYiwgcmVzdWx0Q29sb3IuYSAqIGFscGhhKTtcXG59XFxuXCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9sYWJlbC9zaGFkZXIvZGZfdGV4dC5mcmFnXG4vLyBtb2R1bGUgaWQgPSA0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgV29ybGRQcmltaXRpdmVSZW5kZXJVbml0IGZyb20gJy4uL3dvcmxkX3ByaW1pdGl2ZV9yZW5kZXJfdW5pdCc7XHJcbmltcG9ydCAqIGFzIHZlYzIgZnJvbSAnLi4vLi4vLi4vbWF0aC92ZWN0b3IyJztcclxuaW1wb3J0IFJlbmRlclN0YXRlLCB7IEJMRU5EX09WRVJfUkVOREVSX1NUQVRFIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyL3N0YXRlJztcclxuLyoqXHJcbiAqIEJhc2UgcmVuZGVyZXIgdGhhdCBpbmNhcHN1bGF0ZXMgYWxsIHRoZSBHTCBzcGVjaWZpY3MgdG8gbWFrZSBsYWJlbHMgcmVuZGVyZWQuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMYWJlbFJlbmRlclVuaXQgZXh0ZW5kcyBXb3JsZFByaW1pdGl2ZVJlbmRlclVuaXQge1xyXG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgcHJvZ3JhbSwgY2FtZXJhLCB2aXNpYmlsaXR5UHJvdmlkZXIsIHByaW1pdGl2ZVByb3ZpZGVyKSB7XHJcbiAgICAgICAgc3VwZXIoY29udGV4dCwgbmV3IFJlbmRlclN0YXRlKEJMRU5EX09WRVJfUkVOREVSX1NUQVRFKSwgcHJvZ3JhbSwgcHJpbWl0aXZlUHJvdmlkZXIpO1xyXG4gICAgICAgIHRoaXMuX2NhbWVyYSA9IGNhbWVyYTtcclxuICAgICAgICB0aGlzLl92aXNpYmlsaXR5UHJvdmlkZXIgPSB2aXNpYmlsaXR5UHJvdmlkZXI7XHJcbiAgICAgICAgdGhpcy5faWRIYWxmUHhTaXplVW5pZm9ybSA9IHZlYzIuY3JlYXRlKDAsIDApO1xyXG4gICAgICAgIHRoaXMuX2F0bGFzU2l6ZVVuaWZvcm0gPSB2ZWMyLmNyZWF0ZSgwLCAwKTtcclxuICAgICAgICBjb250ZXh0LmJpbmRQcm9ncmFtKHByb2dyYW0pO1xyXG4gICAgICAgIHByb2dyYW0uc2V0SW50U2NhbGFyVW5pZm9ybSgndmlzaWJpbGl0eScsIDApO1xyXG4gICAgfVxyXG4gICAgX3ByZXBhcmVQcm9ncmFtKHByb2dyYW0sIHZpZXdQcm9qTWF0cml4LCBjYW1lcmFQb3NpdGlvbnMpIHtcclxuICAgICAgICBjb25zdCB2aXNpYmlsaXR5ID0gdGhpcy5fdmlzaWJpbGl0eVByb3ZpZGVyKCk7XHJcbiAgICAgICAgc3VwZXIuX3ByZXBhcmVQcm9ncmFtKHByb2dyYW0sIHZpZXdQcm9qTWF0cml4LCBjYW1lcmFQb3NpdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuX2lkSGFsZlB4U2l6ZVVuaWZvcm0ueCA9IDAuNSAvIHZpc2liaWxpdHkuZ2V0V2lkdGgoKTtcclxuICAgICAgICB0aGlzLl9pZEhhbGZQeFNpemVVbmlmb3JtLnkgPSAwLjUgLyB2aXNpYmlsaXR5LmdldEhlaWdodCgpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFRleHR1cmVVbml0KDApO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFRleHR1cmUodmlzaWJpbGl0eSk7XHJcbiAgICAgICAgcHJvZ3JhbS5zZXRWZWN0b3IyVW5pZm9ybSgnaWRIYWxmUHhTaXplJywgdGhpcy5faWRIYWxmUHhTaXplVW5pZm9ybSk7XHJcbiAgICAgICAgcHJvZ3JhbS5zZXRWZWN0b3IyVW5pZm9ybSgncGl4ZWxTaXplJywgdGhpcy5fY2FtZXJhLnBpeGVsU2l6ZSk7XHJcbiAgICAgICAgcHJvZ3JhbS5zZXRTY2FsYXJVbmlmb3JtKCdkcHInLCB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyk7XHJcbiAgICB9XHJcbiAgICBfcmVuZGVyQmF0Y2gobWVtb3J5QmF0Y2gpIHtcclxuICAgICAgICBjb25zdCBhdGxhcyA9IG1lbW9yeUJhdGNoLmZpcnN0UHJpbWl0aXZlLmF0bGFzO1xyXG4gICAgICAgIHRoaXMuX2F0bGFzU2l6ZVVuaWZvcm0ueCA9IGF0bGFzLndpZHRoO1xyXG4gICAgICAgIHRoaXMuX2F0bGFzU2l6ZVVuaWZvcm0ueSA9IGF0bGFzLmhlaWdodDtcclxuICAgICAgICB0aGlzLl9wcm9ncmFtLnNldEludFNjYWxhclVuaWZvcm0oJ2F0bGFzJywgMSk7XHJcbiAgICAgICAgdGhpcy5fcHJvZ3JhbS5zZXRWZWN0b3IyVW5pZm9ybSgnYXRsYXNTaXplJywgdGhpcy5fYXRsYXNTaXplVW5pZm9ybSk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kVGV4dHVyZVVuaXQoMSk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kVGV4dHVyZShhdGxhcy50ZXh0dXJlKTtcclxuICAgICAgICBzdXBlci5fcmVuZGVyQmF0Y2gobWVtb3J5QmF0Y2gpO1xyXG4gICAgfVxyXG4gICAgX2NhbkJhdGNoQWRqYWNlbnRQcmltaXRpdmVzKGEsIGIpIHtcclxuICAgICAgICByZXR1cm4gc3VwZXIuX2NhbkJhdGNoQWRqYWNlbnRQcmltaXRpdmVzKGEsIGIpICYmIChhLmF0bGFzID09PSBiLmF0bGFzKTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9sYWJlbC9sYWJlbF9yZW5kZXJfdW5pdC50c1xuLy8gbW9kdWxlIGlkID0gNDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IGN1cnZlZExhYmVsVmVydGV4U2hhZGVyIGZyb20gJy4vc2hhZGVyL2N1cnZlZF9sYWJlbC52ZXJ0JztcclxuaW1wb3J0IGRmVGV4dEZyYWdtZW50U2hhZGVyIGZyb20gJy4vc2hhZGVyL2RmX3RleHQuZnJhZyc7XHJcbmltcG9ydCBMYWJlbFJlbmRlclVuaXQgZnJvbSAnLi9sYWJlbF9yZW5kZXJfdW5pdCc7XHJcbmV4cG9ydCBjb25zdCBQUk9HUkFNX09QVElPTlMgPSB7XHJcbiAgICBhdHRyaWJNYXA6IHtcclxuICAgICAgICB2ZXJ0ZXhJZDogMiAvKiBJRCAqLyxcclxuICAgICAgICB2ZXJ0ZXhQb3NIaWdoOiAwIC8qIFBPU0lUSU9OX0hJR0ggKi8sXHJcbiAgICAgICAgdmVydGV4UG9zTG93OiAxIC8qIFBPU0lUSU9OX0xPVyAqLyxcclxuICAgICAgICB2ZXJ0ZXhEaXNwbGFjZW1lbnRzOiA2IC8qIERJU1BMQUNFTUVOVCAqLyxcclxuICAgICAgICB2ZXJ0ZXhVVjogNCAvKiBVViAqLyxcclxuICAgICAgICB2ZXJ0ZXhDb2xvcjogNyAvKiBDT0xPUiAqLyxcclxuICAgICAgICB2ZXJ0ZXhPdXRsaW5lQ29sb3I6IDggLyogT1VUTElORV9DT0xPUiAqLyxcclxuICAgICAgICB2ZXJ0ZXhQcmlvcml0eTogOSAvKiBQUklPUklUWSAqLyxcclxuICAgICAgICBsZWZ0UG9seWxpbmVSYXRpb3M6IDEyIC8qIEFVWDEgKi8sXHJcbiAgICAgICAgbGVmdFBvbHlsaW5lQW5nbGVzOiAxMyAvKiBBVVgyICovLFxyXG4gICAgICAgIHJpZ2h0UG9seWxpbmVSYXRpb3M6IDE0IC8qIEFVWDMgKi8sXHJcbiAgICAgICAgcmlnaHRQb2x5bGluZUFuZ2xlczogMTUgLyogQVVYNCAqLyxcclxuICAgICAgICBwb2x5bGluZUxlbmd0aF92ZXJ0ZXhTY2FsZTogMTEgLyogQVVYICovXHJcbiAgICB9XHJcbn07XHJcbi8qKlxyXG4gKiBDdXJ2ZWQgbGFiZWxzIHJlbmRlcmVyLiBJdCB1c2VzIGFwcHJvcHJpYXRlIHByb2dyYW0gdG8gbGF5b3V0IGdseXBocyBvbiBHUFUuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDdXJ2ZWRMYWJlbFJlbmRlclVuaXQgZXh0ZW5kcyBMYWJlbFJlbmRlclVuaXQge1xyXG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgY2FtZXJhLCB2aXNpYmlsaXR5UHJvdmlkZXIsIHByaW1pdGl2ZVByb3ZpZGVyKSB7XHJcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IGNvbnRleHQuY3JlYXRlUHJvZ3JhbShjdXJ2ZWRMYWJlbFZlcnRleFNoYWRlciwgZGZUZXh0RnJhZ21lbnRTaGFkZXIsIFBST0dSQU1fT1BUSU9OUyk7XHJcbiAgICAgICAgc3VwZXIoY29udGV4dCwgcHJvZ3JhbSwgY2FtZXJhLCB2aXNpYmlsaXR5UHJvdmlkZXIsIHByaW1pdGl2ZVByb3ZpZGVyKTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9sYWJlbC9jdXJ2ZWRfbGFiZWxfcmVuZGVyX3VuaXQudHNcbi8vIG1vZHVsZSBpZCA9IDQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBXb3JsZFByaW1pdGl2ZVJlbmRlclVuaXQgZnJvbSAnLi4vd29ybGRfcHJpbWl0aXZlX3JlbmRlcl91bml0JztcclxuLyoqXHJcbiAqIEJhc2UgcmVuZGVyZXIgb2YgcG9seWxpbmUgcHJpbWl0aXZlcy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhc2VQb2x5bGluZVJlbmRlclVuaXQgZXh0ZW5kcyBXb3JsZFByaW1pdGl2ZVJlbmRlclVuaXQge1xyXG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgcmVuZGVyU3RhdGUsIHByb2dyYW0sIHByaW1pdGl2ZVByb3ZpZGVyLCBjYW1lcmEpIHtcclxuICAgICAgICBzdXBlcihjb250ZXh0LCByZW5kZXJTdGF0ZSwgcHJvZ3JhbSwgcHJpbWl0aXZlUHJvdmlkZXIpO1xyXG4gICAgICAgIHRoaXMuX2NhbWVyYSA9IGNhbWVyYTtcclxuICAgIH1cclxuICAgIF9wcmVwYXJlUHJvZ3JhbShwcm9ncmFtLCB2aWV3UHJvak1hdHJpeCwgY2FtZXJhUG9zaXRpb25zKSB7XHJcbiAgICAgICAgc3VwZXIuX3ByZXBhcmVQcm9ncmFtKHByb2dyYW0sIHZpZXdQcm9qTWF0cml4LCBjYW1lcmFQb3NpdGlvbnMpO1xyXG4gICAgICAgIHByb2dyYW0uc2V0U2NhbGFyVW5pZm9ybSgnd29ybGRUb1B4RmFjdG9yJywgdGhpcy5fY2FtZXJhLndvcmxkVG9QeEZhY3Rvcik7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvcG9seWxpbmUvYmFzZV9wb2x5bGluZV9yZW5kZXJfdW5pdC50c1xuLy8gbW9kdWxlIGlkID0gNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgQmluYXJ5U2VhcmNoVHJlZSB9IGZyb20gJy4vYmluYXJ5X3RyZWUnO1xyXG5pbXBvcnQgTGlua2VkU2V0IGZyb20gJy4vbGlua2VkX3NldCc7XHJcbi8qKlxyXG4gKiBBbGlnbmVzIGFuIG9mZnNldCBzbyBpdCdzIGEgbXVsdGlwbGUgb2YgYW4gYWxpZ25tZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0gb2Zmc2V0IFRoZSBvZmZzZXQuXHJcbiAqIEBwYXJhbSBhbGlnbm1lbnQgVGhlIGFsaWdubWVudC5cclxuICogQHJldHVybnMgQWxpZ25lZCBvZmZzZXQuXHJcbiAqL1xyXG5mdW5jdGlvbiBhbGlnbihvZmZzZXQsIGFsaWdubWVudCkge1xyXG4gICAgcmV0dXJuIGFsaWdubWVudCAqIE1hdGguY2VpbChvZmZzZXQgLyBhbGlnbm1lbnQpO1xyXG59XHJcbmV4cG9ydCBjbGFzcyBBcmVuYUFsbG9jYXRvciB7XHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgZW1wdHkgYXJlbmEgYWxsb2NhdG9yLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzaXplIFNpemUgb2YgbWFuYWdlZCByZWdpb24uXHJcbiAgICAgKiBAcGFyYW0gYWxpZ25tZW50IGFsaWdubWVudCBvZiBvZmZzZXRzLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihzaXplLCBhbGlnbm1lbnQgPSAxKSB7XHJcbiAgICAgICAgdGhpcy5fc2l6ZSA9IHNpemU7XHJcbiAgICAgICAgdGhpcy5fYWxpZ25tZW50ID0gYWxpZ25tZW50O1xyXG4gICAgICAgIHRoaXMuX2ZyZWVPZmZzZXQgPSAwO1xyXG4gICAgICAgIHRoaXMuX2FsbG9jYXRlZE9mZnNldHMgPSBuZXcgU2V0KCk7XHJcbiAgICB9XHJcbiAgICBnZXQgc2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZTtcclxuICAgIH1cclxuICAgIGdldCBtYXhBbGxvY2FibGVTaXplKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zaXplIC0gdGhpcy5fZnJlZU9mZnNldDtcclxuICAgIH1cclxuICAgIGdldCBpc0VtcHR5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hbGxvY2F0ZWRPZmZzZXRzLnNpemUgPT09IDA7XHJcbiAgICB9XHJcbiAgICBhbGxvY2F0ZShzaXplKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3NpemUgPj0gdGhpcy5fZnJlZU9mZnNldCArIHNpemUpIHtcclxuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5fZnJlZU9mZnNldDtcclxuICAgICAgICAgICAgdGhpcy5fZnJlZU9mZnNldCA9IGFsaWduKG9mZnNldCArIHNpemUsIHRoaXMuX2FsaWdubWVudCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2FsbG9jYXRlZE9mZnNldHMuYWRkKG9mZnNldCk7XHJcbiAgICAgICAgICAgIHJldHVybiBvZmZzZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZGVhbGxvY2F0ZShvZmZzZXQpIHtcclxuICAgICAgICB0aGlzLl9hbGxvY2F0ZWRPZmZzZXRzLmRlbGV0ZShvZmZzZXQpO1xyXG4gICAgfVxyXG4gICAgaXNBbGxvY2F0ZWQob2Zmc2V0KSB7XHJcbiAgICAgICAgcmV0dXJuIG9mZnNldCA8IHRoaXMuX2ZyZWVPZmZzZXQ7XHJcbiAgICB9XHJcbiAgICBleHRlbmQobmV3U2l6ZSkge1xyXG4gICAgICAgIGlmIChuZXdTaXplIDwgdGhpcy5fZnJlZU9mZnNldCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCByZWR1Y2UgdGhlIHNpemUgYmVjYXVzZSBpdCBjb25mbGljdHMgd2l0aCBhbHJlYWR5IGFsbG9jYXRlZCByZWdpb24uJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3NpemUgPSBuZXdTaXplO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBbGxvY2F0b3Igb3B0aW1pc2VkIGZvciBib3RoIHByaW1hcnkgb3BlcmF0aW9uczogYWxsb2NhdGlvbiBhbmQgZGVhbGxvY2F0aW9uLiBJdCB1c2VzIEJTVCBmb3IgZWZmaWNpZW50IGxvb2t1cCBvZlxyXG4gKiBzdWl0YWJsZSBmcmVlIHJlZ2lvbiBkdXJpbmcgYWxsb2NhdGlvbiBhbmQgdHdvIHdheSBsaW5rZWQgbGlzdCBmb3IgZmFzdCBhZGphY2VudCBmcmVlIHJlZ2lvbnMgbWVyZ2UuXHJcbiAqIE1heCBhbGxvY2FibGUgc2l6ZSBpcyBhbHNvIGRldGVybWluZWQgYnkgbWVhbnMgb2YgdGhlIEJTVC5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBGcmVlTGlzdEFsbG9jYXRvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihzaXplKSB7XHJcbiAgICAgICAgdGhpcy5fc2l6ZSA9IHNpemU7XHJcbiAgICAgICAgdGhpcy5fYWxsUmVnaW9ucyA9IG5ldyBMaW5rZWRTZXQoKTtcclxuICAgICAgICB0aGlzLl9vY2N1cGllZFJlZ2lvbnMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5fZnJlZVJlZ2lvbnMgPSBuZXcgQmluYXJ5U2VhcmNoVHJlZSgocmFuZ2VBLCByYW5nZUIpID0+IHJhbmdlQS5zaXplIC0gcmFuZ2VCLnNpemUpO1xyXG4gICAgICAgIGNvbnN0IGluaXRSZWdpb24gPSB7IG9mZnNldDogMCwgc2l6ZSB9O1xyXG4gICAgICAgIHRoaXMuX2FsbFJlZ2lvbnMuaW5zZXJ0KGluaXRSZWdpb24pO1xyXG4gICAgICAgIGluaXRSZWdpb24uX2ZyZWVOb2RlID0gdGhpcy5fZnJlZVJlZ2lvbnMuaW5zZXJ0KGluaXRSZWdpb24pO1xyXG4gICAgfVxyXG4gICAgZ2V0IHNpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpemU7XHJcbiAgICB9XHJcbiAgICBnZXQgbWF4QWxsb2NhYmxlU2l6ZSgpIHtcclxuICAgICAgICBjb25zdCBtYXggPSB0aGlzLl9mcmVlUmVnaW9ucy5tYXg7XHJcbiAgICAgICAgcmV0dXJuIG1heCA/IG1heC5zaXplIDogMDtcclxuICAgIH1cclxuICAgIGdldCBpc0VtcHR5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9vY2N1cGllZFJlZ2lvbnMuc2l6ZSA9PT0gMDtcclxuICAgIH1cclxuICAgIGFsbG9jYXRlKHNpemUpIHtcclxuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5fZmluZE1pblN1aXRhYmxlKHNpemUpO1xyXG4gICAgICAgIGlmICghbm9kZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJhbmdlID0gbm9kZS52YWx1ZTtcclxuICAgICAgICAvLyBjdXJyZW50IHJlZ2lvbiBpcyBub3QgYXZhaWxhYmxlIGFueW1vcmVcclxuICAgICAgICAvLyBpdCBpcyByZW1vdmVkIGZyb20gdGhlIGZyZWUgcmVnaW9ucyBwb29sXHJcbiAgICAgICAgdGhpcy5fZnJlZVJlZ2lvbnMucmVtb3ZlKG5vZGUpO1xyXG4gICAgICAgIC8vIG5ldyBvY2N1cGllZCBvbmUgaXMgY3JlYXRlZFxyXG4gICAgICAgIGNvbnN0IG9jY3VwaWVkUmFuZ2UgPSB7IG9mZnNldDogcmFuZ2Uub2Zmc2V0LCBzaXplIH07XHJcbiAgICAgICAgdGhpcy5fb2NjdXBpZWRSZWdpb25zLnNldChyYW5nZS5vZmZzZXQsIG9jY3VwaWVkUmFuZ2UpO1xyXG4gICAgICAgIHRoaXMuX2FsbFJlZ2lvbnMuaW5zZXJ0QWZ0ZXIocmFuZ2UsIG9jY3VwaWVkUmFuZ2UpO1xyXG4gICAgICAgIHRoaXMuX2FsbFJlZ2lvbnMucmVtb3ZlKHJhbmdlKTtcclxuICAgICAgICAvLyBkb250IGxvb3NlIHJlbWFpbmluZyBpZiBhbnlcclxuICAgICAgICAvLyBpdCBzaG91bGQgYmUgcmV0dXJuZWQgYmFjayB0byB0aGUgZnJlZSByZWdpb25zIHBvb2xcclxuICAgICAgICBpZiAocmFuZ2Uuc2l6ZSA+IHNpemUpIHtcclxuICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nUmFuZ2UgPSB7IG9mZnNldDogcmFuZ2Uub2Zmc2V0ICsgc2l6ZSwgc2l6ZTogcmFuZ2Uuc2l6ZSAtIHNpemUgfTtcclxuICAgICAgICAgICAgcmVtYWluaW5nUmFuZ2UuX2ZyZWVOb2RlID0gdGhpcy5fZnJlZVJlZ2lvbnMuaW5zZXJ0KHJlbWFpbmluZ1JhbmdlKTtcclxuICAgICAgICAgICAgdGhpcy5fYWxsUmVnaW9ucy5pbnNlcnRBZnRlcihvY2N1cGllZFJhbmdlLCByZW1haW5pbmdSYW5nZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvY2N1cGllZFJhbmdlLm9mZnNldDtcclxuICAgIH1cclxuICAgIGRlYWxsb2NhdGUob2Zmc2V0KSB7XHJcbiAgICAgICAgbGV0IHJlZ2lvbiA9IHRoaXMuX29jY3VwaWVkUmVnaW9ucy5nZXQob2Zmc2V0KTtcclxuICAgICAgICBpZiAocmVnaW9uKSB7XHJcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSByZWdpb24gY2FuIGJlIG1lcmdlZCB3aXRoIGl0cyBwcmV2aW91cyBuZWlnaGJvclxyXG4gICAgICAgICAgICBjb25zdCBwcmV2ID0gdGhpcy5fYWxsUmVnaW9ucy5nZXRQcmV2KHJlZ2lvbik7XHJcbiAgICAgICAgICAgIGlmIChwcmV2ICYmIHByZXYuX2ZyZWVOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbWJyYWNpbmdSYW5nZSA9IHsgb2Zmc2V0OiBwcmV2Lm9mZnNldCwgc2l6ZTogcHJldi5zaXplICsgcmVnaW9uLnNpemUgfTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FsbFJlZ2lvbnMuaW5zZXJ0QWZ0ZXIocHJldiwgZW1icmFjaW5nUmFuZ2UpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWxsUmVnaW9ucy5yZW1vdmUocmVnaW9uKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FsbFJlZ2lvbnMucmVtb3ZlKHByZXYpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZnJlZVJlZ2lvbnMucmVtb3ZlKHByZXYuX2ZyZWVOb2RlKTtcclxuICAgICAgICAgICAgICAgIHJlZ2lvbiA9IGVtYnJhY2luZ1JhbmdlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSByZWdpb24gY2FuIGJlIG1lcmdlZCB3aXRoIGl0cyBuZXh0IG5laWdoYm9yXHJcbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLl9hbGxSZWdpb25zLmdldE5leHQocmVnaW9uKTtcclxuICAgICAgICAgICAgaWYgKG5leHQgJiYgbmV4dC5fZnJlZU5vZGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVtYnJhY2luZ1JhbmdlID0geyBvZmZzZXQ6IHJlZ2lvbi5vZmZzZXQsIHNpemU6IHJlZ2lvbi5zaXplICsgbmV4dC5zaXplIH07XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hbGxSZWdpb25zLmluc2VydEJlZm9yZShuZXh0LCBlbWJyYWNpbmdSYW5nZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hbGxSZWdpb25zLnJlbW92ZShyZWdpb24pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWxsUmVnaW9ucy5yZW1vdmUobmV4dCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9mcmVlUmVnaW9ucy5yZW1vdmUobmV4dC5fZnJlZU5vZGUpO1xyXG4gICAgICAgICAgICAgICAgcmVnaW9uID0gZW1icmFjaW5nUmFuZ2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fb2NjdXBpZWRSZWdpb25zLmRlbGV0ZShvZmZzZXQpO1xyXG4gICAgICAgICAgICByZWdpb24uX2ZyZWVOb2RlID0gdGhpcy5fZnJlZVJlZ2lvbnMuaW5zZXJ0KHJlZ2lvbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaXNBbGxvY2F0ZWQob2Zmc2V0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX29jY3VwaWVkUmVnaW9ucy5oYXMob2Zmc2V0KTtcclxuICAgIH1cclxuICAgIGV4dGVuZChuZXdTaXplKSB7XHJcbiAgICAgICAgaWYgKG5ld1NpemUgPCB0aGlzLl9zaXplKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2l6ZSByZWR1Y2luZyBpcyBub3QgYWxsb3dlZCBpbiBmcmVlIGxpc3QgYWxsb2NhdG9yJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGRpZmYgPSBuZXdTaXplIC0gdGhpcy5fc2l6ZTtcclxuICAgICAgICBjb25zdCBsYXN0ID0gdGhpcy5fYWxsUmVnaW9ucy5lbmQ7XHJcbiAgICAgICAgaWYgKGxhc3QgJiYgbGFzdC5fZnJlZU5vZGUpIHtcclxuICAgICAgICAgICAgdGhpcy5fZnJlZVJlZ2lvbnMucmVtb3ZlKGxhc3QuX2ZyZWVOb2RlKTtcclxuICAgICAgICAgICAgY29uc3QgcmVnaW9uID0geyBvZmZzZXQ6IGxhc3Qub2Zmc2V0LCBzaXplOiBsYXN0LnNpemUgKyBkaWZmLCBpc0ZyZWU6IHRydWUgfTtcclxuICAgICAgICAgICAgdGhpcy5fYWxsUmVnaW9ucy5pbnNlcnRBZnRlcihsYXN0LCByZWdpb24pO1xyXG4gICAgICAgICAgICB0aGlzLl9hbGxSZWdpb25zLnJlbW92ZShsYXN0KTtcclxuICAgICAgICAgICAgdGhpcy5fZnJlZVJlZ2lvbnMuaW5zZXJ0KHJlZ2lvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCByZWdpb24gPSB7IG9mZnNldDogdGhpcy5fc2l6ZSwgc2l6ZTogZGlmZiwgaXNGcmVlOiB0cnVlIH07XHJcbiAgICAgICAgICAgIHRoaXMuX2FsbFJlZ2lvbnMuaW5zZXJ0KHJlZ2lvbik7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZyZWVSZWdpb25zLmluc2VydChyZWdpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9zaXplID0gbmV3U2l6ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVHJhdmVyc2VzIEJTVCB0byBmaW5kIHRoZSBzbWFsbGVzdCByZWdpb24gcmVxdWlyZWQgc2l6ZSBjYW4gZml0LlxyXG4gICAgICovXHJcbiAgICBfZmluZE1pblN1aXRhYmxlKHNpemUpIHtcclxuICAgICAgICBsZXQgbm9kZSA9IHRoaXMuX2ZyZWVSZWdpb25zLnJvb3Q7XHJcbiAgICAgICAgbGV0IGJlc3Q7XHJcbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUudmFsdWUuc2l6ZSA9PT0gc2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgYmVzdCA9IG5vZGU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChub2RlLnZhbHVlLnNpemUgPCBzaXplKSB7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGJlc3QgPSBub2RlO1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYmVzdDtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL2FsbG9jYXRvci50c1xuLy8gbW9kdWxlIGlkID0gNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICogYXMgdmVjMiBmcm9tICcuLi8uLi9tYXRoL3ZlY3RvcjInO1xyXG5pbXBvcnQgeyB1aW50MTZUb0Zsb2F0IH0gZnJvbSAnLi4vLi4vdXRpbC9ncHV0eXBlcyc7XHJcbmltcG9ydCB7IGNvbXB1dGVTcXVhcmVzQ292ZXJlZEJ5Q29udmV4UG9seWdvbiB9IGZyb20gJy4uLy4uL3V0aWwvY2FydGVzaWFuX2dyaWQnO1xyXG5pbXBvcnQgKiBhcyBhcnJheSBmcm9tICcuLi8uLi91dGlsL2FycmF5JztcclxuLy8gTWFwcyB3b3JsZCBjb29yZGluYXRlcyB0byBjb3JyZXNwb25kaW5nIHBvaW50cyBvbiB0aGUgY2FydGVzaWFuIGdyaWQuXHJcbmNvbnN0IFdPUkxEX01JTl9DT09SRElOQVRFID0gdmVjMi5jcmVhdGUoLTEsIC0xKTtcclxuY29uc3QgR1JJRF9XT1JMRF9SQVRJTyA9IDAuNTtcclxuY29uc3QgR1JJRF9DT09SRElOQVRFU19DT05WRVJURVIgPSAocG9pbnQpID0+IHtcclxuICAgIGNvbnN0IGdyaWRDb29yZGluYXRlcyA9IHZlYzIuY29weShwb2ludCk7XHJcbiAgICB2ZWMyLnN1YihncmlkQ29vcmRpbmF0ZXMsIFdPUkxEX01JTl9DT09SRElOQVRFLCBncmlkQ29vcmRpbmF0ZXMpO1xyXG4gICAgdmVjMi5tdWxuKGdyaWRDb29yZGluYXRlcywgR1JJRF9XT1JMRF9SQVRJTywgZ3JpZENvb3JkaW5hdGVzKTtcclxuICAgIHJldHVybiBncmlkQ29vcmRpbmF0ZXM7XHJcbn07XHJcbmNvbnN0IENBTUVSQV9QT1NJVElPTl9VSU5UMzJfQ09OVkVSVEVSID0gKGNvbXBvbmVudCkgPT4gMC41ICogKGNvbXBvbmVudCArIDEpICogMHhmZmZmZmZmZjtcclxuY29uc3QgSElHSF9DT01QT05FTlRfRVhUUkFDVE9SID0gKGNvbXBvbmVudCkgPT4gdWludDE2VG9GbG9hdChNYXRoLnRydW5jKGNvbXBvbmVudCAvIDB4MTAwMDApKTtcclxuY29uc3QgTE9XX0NPTVBPTkVOVF9FWFRSQUNUT1IgPSAoY29tcG9uZW50KSA9PiB1aW50MTZUb0Zsb2F0KGNvbXBvbmVudCAmIDB4ZmZmZik7XHJcbmNvbnN0IFJFR0lPTl9DT01QQVJBVE9SID0gKGEsIGIpID0+IGEueCAtIGIueCB8fCBhLnkgLSBiLnk7XHJcbmNvbnN0IHRtcENhbWVyYVBvc2l0aW9uID0gdmVjMi5jcmVhdGUoMCwgMCk7XHJcbi8qKlxyXG4gKiBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgd29ybGRzIHZpc2libGUgKGxhcmdlIG1vbml0b3JzL2xvdyB6b29tKSBwcmltaXRpdmVzIGFyZSByZW5kZXJlZCBpbiBtdWx0aXBsZSBwYXNzZXMgZnJvbVxyXG4gKiBkaWZmZXJlbnQgcG9zaXRpb25zIChpZiB0aGUgd3JhcCBtb2RlIG9mIGNvcnJlc3BvbmRpbmcgZGlyZWN0aW9uIGlzIFJFUEVBVCkgdG8gZ2V0IGNvcnJlY3QgZmluYWwgcGljdHVyZS5cclxuICogVGhpcyBtZXRob2QgY2FsY3VsYXRlcyBjYW1lcmEgcG9zaXRpb25zIGFuZCBwcmVwYXJlIHRoZW0gdG8gYmUgcGFzc2VkIHRvIHRoZSByZW5kZXIoKSBtZXRob2QuXHJcbiAqL1xyXG5jb25zdCBjYWNoZWRSZWdpb24gPSBbXTtcclxuY29uc3QgY2FjaGVkUG9zaXRpb25zID0gW107XHJcbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVDYW1lcmFQb3NpdGlvbnMoY2FtZXJhKSB7XHJcbiAgICBjb25zdCB2aXNpYmxlUmVnaW9uID0gY2FtZXJhLmdldFZpc2libGVSZWdpb24oKTtcclxuICAgIGlmIChhcnJheS5jb21wYXJlKFJFR0lPTl9DT01QQVJBVE9SLCBjYWNoZWRSZWdpb24sIHZpc2libGVSZWdpb24pID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGNhY2hlZFBvc2l0aW9ucztcclxuICAgIH1cclxuICAgIGNvbnN0IHBvc2l0aW9ucyA9IFtdO1xyXG4gICAgZm9yIChjb25zdCB3b3JsZFBvc2l0aW9uIG9mIGNvbXB1dGVTcXVhcmVzQ292ZXJlZEJ5Q29udmV4UG9seWdvbih2aXNpYmxlUmVnaW9uLm1hcChHUklEX0NPT1JESU5BVEVTX0NPTlZFUlRFUikpKSB7XHJcbiAgICAgICAgaWYgKChjYW1lcmEub3B0aW9ucy53cmFwTW9kZVggPT09IDIgLyogUkVQRUFUICovIHx8IHdvcmxkUG9zaXRpb24ueCA9PT0gMCkgJiZcclxuICAgICAgICAgICAgKGNhbWVyYS5vcHRpb25zLndyYXBNb2RlWSA9PT0gMiAvKiBSRVBFQVQgKi8gfHwgd29ybGRQb3NpdGlvbi55ID09PSAwKSkge1xyXG4gICAgICAgICAgICAvLyAyLjAgY29udmVydHMgY292ZXJlZCBzcXVhcmUgcG9zaXRpb24gdG8gdGhlIHdvcmxkJ3MgY2VudGVyIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgICAgIC8vIC0xLjAgcmV2ZXJzZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBjYW1lcmEgdG8gc2hvdCB0aGUgd29ybGQgZnJvbVxyXG4gICAgICAgICAgICB2ZWMyLm11bG4od29ybGRQb3NpdGlvbiwgLTEuMCAqIDIuMCwgdG1wQ2FtZXJhUG9zaXRpb24pO1xyXG4gICAgICAgICAgICB2ZWMyLmFkZChjYW1lcmEuY2VudGVyLCB0bXBDYW1lcmFQb3NpdGlvbiwgdG1wQ2FtZXJhUG9zaXRpb24pO1xyXG4gICAgICAgICAgICB2ZWMyLmNvbnZlcnQodG1wQ2FtZXJhUG9zaXRpb24sIENBTUVSQV9QT1NJVElPTl9VSU5UMzJfQ09OVkVSVEVSLCB0bXBDYW1lcmFQb3NpdGlvbik7XHJcbiAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKHtcclxuICAgICAgICAgICAgICAgIGxvb2tBdEhpZ2g6IHZlYzIuY29udmVydCh0bXBDYW1lcmFQb3NpdGlvbiwgSElHSF9DT01QT05FTlRfRVhUUkFDVE9SKSxcclxuICAgICAgICAgICAgICAgIGxvb2tBdExvdzogdmVjMi5jb252ZXJ0KHRtcENhbWVyYVBvc2l0aW9uLCBMT1dfQ09NUE9ORU5UX0VYVFJBQ1RPUilcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYXJyYXkuY29weShwb3NpdGlvbnMsIGNhY2hlZFBvc2l0aW9ucyk7XHJcbiAgICBjYWNoZWRQb3NpdGlvbnMubGVuZ3RoID0gcG9zaXRpb25zLmxlbmd0aDtcclxuICAgIGNhY2hlZFJlZ2lvbi5sZW5ndGggPSB2aXNpYmxlUmVnaW9uLmxlbmd0aDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmlzaWJsZVJlZ2lvbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNhY2hlZFJlZ2lvbltpXSA9IHZlYzIuY29weSh2aXNpYmxlUmVnaW9uW2ldLCBjYWNoZWRSZWdpb25baV0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBvc2l0aW9ucztcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvdXRpbC9jYW1lcmFfcG9zaXRpb24udHNcbi8vIG1vZHVsZSBpZCA9IDUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleFBvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleFV2O1xcblxcbnVuaWZvcm0gZmxvYXQgekluZGV4O1xcblxcbiNpZm5kZWYgWVZfTEVBU1RfMTZiX1BcXG4jICAgaWZkZWYgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0hcXG4jICAgICAgIGRlZmluZSBZVl9MRUFTVF8xNmJfUCBoaWdocFxcbiMgICBlbHNlXFxuIyAgICAgICBkZWZpbmUgWVZfTEVBU1RfMTZiX1AgbWVkaXVtcFxcbiMgICBlbmRpZlxcbiNlbmRpZlxcblxcbnZhcnlpbmcgWVZfTEVBU1RfMTZiX1AgdmVjMiB1djtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgICBnbF9Qb3NpdGlvbiA9IHZlYzQodmVydGV4UG9zaXRpb24sIHpJbmRleCwgMSk7XFxuICAgIHV2ID0gdmVydGV4VXY7XFxufVxcblwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3NoYWRlcnMvcXVhZC52ZXJ0XG4vLyBtb2R1bGUgaWQgPSA1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgQ29udGV4dCBmcm9tICcuLi8uLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL2NvbnRleHQnO1xyXG5pbXBvcnQgQ2FtZXJhIGZyb20gJy4uLy4uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9jYW1lcmEnO1xyXG5pbXBvcnQgVmVjdG9yQXBpQWRhcHRlciBmcm9tICcuLi8uLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdmVjdG9yX2FwaS9hZGFwdGVyJztcclxuaW1wb3J0IHsgQ2FtZXJhTW91c2VDb250cm9sbGVyLCBNb3VzZURyYWdDb250cm9sbGVyLCBTY3JvbGxab29tQ29udHJvbGxlciwgcmVuZGVyQ2FtZXJhU3RhdGUgfSBmcm9tICcuL2NhbWVyYV9zdHVmZic7XHJcbmltcG9ydCBDb2xvcklkUG9pbnRMYWJlbFJlbmRlcmVyIGZyb20gJy4uLy4uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS92aXNpYmlsaXR5L3ByaW1pdGl2ZXMvbGFiZWwvY29sb3JfaWRfcG9pbnRfbGFiZWxfcmVuZGVyZXInO1xyXG5pbXBvcnQgQ29sb3JJZEN1cnZlZExhYmVsUmVuZGVyZXIgZnJvbSAnLi4vLi4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3Zpc2liaWxpdHkvcHJpbWl0aXZlcy9sYWJlbC9jb2xvcl9pZF9jdXJ2ZWRfbGFiZWxfcmVuZGVyZXInO1xyXG5pbXBvcnQgUG9pbnRMYWJlbFJlbmRlclVuaXQgZnJvbSAnLi4vLi4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL2xhYmVsL3BvaW50X2xhYmVsX3JlbmRlcl91bml0JztcclxuaW1wb3J0IEN1cnZlZExhYmVsUmVuZGVyVW5pdCBmcm9tICcuLi8uLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvbGFiZWwvY3VydmVkX2xhYmVsX3JlbmRlcl91bml0JztcclxuaW1wb3J0IEljb25SZW5kZXJVbml0IGZyb20gJy4uLy4uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9pY29uL2ljb25fcmVuZGVyX3VuaXQnO1xyXG5pbXBvcnQgTW9kZWxSZW5kZXJVbml0IGZyb20gJy4uLy4uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9tb2RlbC9tb2RlbF9yZW5kZXJfdW5pdCc7XHJcbmltcG9ydCBUZXh0dXJlZFBvbHlsaW5lUmVuZGVyVW5pdCBmcm9tICcuLi8uLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvcG9seWxpbmUvdGV4dHVyZWRfcG9seWxpbmVfcmVuZGVyX3VuaXQnO1xyXG5pbXBvcnQgUG9seWxpbmVSZW5kZXJVbml0IGZyb20gJy4uLy4uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9wb2x5bGluZS9wb2x5bGluZV9yZW5kZXJfdW5pdCc7XHJcbmltcG9ydCBUZXh0dXJlZFBvbHlnb25SZW5kZXJVbml0IGZyb20gJy4uLy4uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9wb2x5Z29uL3RleHR1cmVkX3BvbHlnb25fcmVuZGVyX3VuaXQnO1xyXG5pbXBvcnQgVHJhbnNwYXJlbnRQb2x5Z29uUmVuZGVyVW5pdCBmcm9tICcuLi8uLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvcG9seWdvbi90cmFuc3BhcmVudF9wb2x5Z29uX3JlbmRlcl91bml0JztcclxuaW1wb3J0IFBvbHlnb25SZW5kZXJVbml0IGZyb20gJy4uLy4uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9wb2x5Z29uL3BvbHlnb25fcmVuZGVyX3VuaXQnO1xyXG5pbXBvcnQgTWFwRW5naW5lIGZyb20gJy4uLy4uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9tYXBfZW5naW5lJztcclxuaW1wb3J0IGdldERwciBmcm9tICcuLi8uLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9oZCc7XHJcbmltcG9ydCB7IENvbGxpZGluZ1ByaW1pdGl2ZXNSZXNldFJlbW92ZWRSZW5kZXJlciB9IGZyb20gJy4uLy4uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS92aXNpYmlsaXR5L3ByaW1pdGl2ZXMvY29sbGlkaW5nX3ByaW1pdGl2ZV9yZXNldF9yZW1vdmVkX3JlbmRlcmVyJztcclxuaW1wb3J0IFJlbmRlckxvb3AgZnJvbSAnLi4vLi4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlcl9sb29wJztcclxuLy8gaW1wb3J0IEltYWdlUmVuZGVyVW5pdCBmcm9tICcuLi8uLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvaW1hZ2UvaW1hZ2VfcmVuZGVyX3VuaXQnO1xyXG4vLyBpbXBvcnQgUmFzdGVyVGlsZXNBZGFwdGVyIGZyb20gJy4uLy4uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9hZGFwdGVycy9yYXN0ZXJfdGlsZXMvYWRhcHRlcic7XHJcbi8vIGltcG9ydCB7VGlsZUl0ZW19IGZyb20gJy4uLy4uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9hZGFwdGVycy90aWxlX2Jhc2VkX2FkYXB0ZXIvdXRpbC90aWxlX3N5c3RlbSc7XHJcbmNvbnN0IEdMX0NPTlRFWFRfQVRUUklCUyA9IHtcclxuICAgIGFscGhhOiBmYWxzZSxcclxuICAgIGRlcHRoOiB0cnVlLFxyXG4gICAgc3RlbmNpbDogZmFsc2UsXHJcbiAgICBhbnRpYWxpYXM6IGZhbHNlLFxyXG4gICAgZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdDogdHJ1ZVxyXG59O1xyXG5jb25zdCBjYW1lcmEgPSBuZXcgQ2FtZXJhKHtcclxuICAgIHdyYXBNb2RlWDogMiAvKiBSRVBFQVQgKi8sXHJcbiAgICB3cmFwTW9kZVk6IDAgLyogTk9ORSAqL1xyXG59KTtcclxuY2FtZXJhLm9uVXBkYXRlLmFkZExpc3RlbmVyKCgpID0+IHJlbmRlckNhbWVyYVN0YXRlKGNhbWVyYSkpO1xyXG5jYW1lcmEuY2VudGVyLnggPSAwLjIwODk4NDM3O1xyXG5jYW1lcmEuY2VudGVyLnkgPSAwLjM3MzA0Njg3O1xyXG5jYW1lcmEuem9vbSA9IDE0O1xyXG5jb25zdCBjYW52YXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjY2FudmFzJyk7XHJcbntcclxuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgY29uc3QgZHByID0gZ2V0RHByKCk7XHJcbiAgICBjYW52YXMud2lkdGggPSBkcHIgKiB3aWR0aDtcclxuICAgIGNhbnZhcy5oZWlnaHQgPSBkcHIgKiBoZWlnaHQ7XHJcbiAgICBjYW1lcmEuc2NyZWVuU2l6ZS53aWR0aCA9IHdpZHRoO1xyXG4gICAgY2FtZXJhLnNjcmVlblNpemUuaGVpZ2h0ID0gaGVpZ2h0O1xyXG59XHJcbmNvbnN0IGNhbWVyYU1vdXNlQ29udHJvbGxlciA9IG5ldyBDYW1lcmFNb3VzZUNvbnRyb2xsZXIoY2FudmFzLCBjYW1lcmEpO1xyXG5jb25zdCBtb3VzZURyYWdDb250cm9sbGVyID0gbmV3IE1vdXNlRHJhZ0NvbnRyb2xsZXIoY2FudmFzKTtcclxubW91c2VEcmFnQ29udHJvbGxlci5zZXREZWxlZ2F0ZShjYW1lcmFNb3VzZUNvbnRyb2xsZXIpO1xyXG5jb25zdCBzY3JvbGxab29tQ29udHJvbGxlciA9IG5ldyBTY3JvbGxab29tQ29udHJvbGxlcihjYW52YXMpO1xyXG5zY3JvbGxab29tQ29udHJvbGxlci5zZXREZWxlZ2F0ZShjYW1lcmFNb3VzZUNvbnRyb2xsZXIpO1xyXG5jb25zdCBjb250ZXh0ID0gQ29udGV4dC5jcmVhdGVGcm9tQ2FudmFzKGNhbnZhcywgR0xfQ09OVEVYVF9BVFRSSUJTKTtcclxuY29uc3QgZW5naW5lID0gbmV3IE1hcEVuZ2luZShjb250ZXh0LCBjYW1lcmEsIG5ldyBSZW5kZXJMb29wKCkpO1xyXG5jb25zdCB2ZWN0b3JBZGFwdGVyID0gbmV3IFZlY3RvckFwaUFkYXB0ZXIoZW5naW5lLCBjYW1lcmEsICcuL3RpbGVfcHJvdmlkZXJfd29ya2VyLmpzP3dvcmtlcicsICdtYXAnLCBcclxuLy8ge1xyXG4vLyAgICAgdGlsZVVybFRlbXBsYXRlOiAnaHR0cHM6Ly92ZWMtcmRyMDFlLnRzdC5tYXBzLnlhbmRleC5ydS92bWFwMi90aWxlcz9sPXZtYXAyJmxhbmc9cnVfUlUmeD17e3h9fSZ5PXt7eX19Jno9e3t6fX0mem1pbj17e3ptaW59fSZ6bWF4PXt7em1heH19JyxcclxuLy8gICAgIGltYWdlVXJsVGVtcGxhdGU6ICdodHRwczovL3ZlYy1yZHIwMWUudHN0Lm1hcHMueWFuZGV4LnJ1L3Jlc291cmNlcz9pZD17e2lkfX0mc2NhbGU9e3tzY2FsZX19JyxcclxuLy8gICAgIG1lc2hVcmxUZW1wbGF0ZTogJ2h0dHBzOi8vdmVjLXJkcjAxZS50c3QubWFwcy55YW5kZXgucnUvbWVzaGVzP2lkPXt7aWR9fScsXHJcbi8vICAgICBnbHlwaFJhbmdlVXJsVGVtcGxhdGU6ICdodHRwczovL3ZlYy1yZHIwMWUudHN0Lm1hcHMueWFuZGV4LnJ1L2dseXBocz9sYW5nPXJ1X1JVJmZvbnRfaWQ9e3tmb250SWR9fSZyYW5nZT17e3JhbmdlfX0nXHJcbi8vIH1cclxue1xyXG4gICAgdGlsZVVybFRlbXBsYXRlOiAnaHR0cHM6Ly92ZWMwe3tob3N0QWxpYXN9fS5tYXBzLnlhbmRleC5uZXQvdm1hcDIvdGlsZXM/bD12bWFwMiZsYW5nPVJVX3J1Jng9e3t4fX0meT17e3l9fSZ6PXt7en19JnptaW49e3t6bWlufX0mem1heD17e3ptYXh9fScsXHJcbiAgICBpbWFnZVVybFRlbXBsYXRlOiAnaHR0cHM6Ly92ZWMwe3tob3N0QWxpYXN9fS5tYXBzLnlhbmRleC5uZXQvcmVzb3VyY2VzP2lkPXt7aWR9fSZzY2FsZT17e3NjYWxlfX0nLFxyXG4gICAgbWVzaFVybFRlbXBsYXRlOiAnaHR0cHM6Ly92ZWMwe3tob3N0QWxpYXN9fS5tYXBzLnlhbmRleC5uZXQvdm1hcDIvbWVzaGVzP2lkPXt7aWR9fScsXHJcbiAgICBnbHlwaFJhbmdlVXJsVGVtcGxhdGU6ICdodHRwczovL3ZlYzB7e2hvc3RBbGlhc319Lm1hcHMueWFuZGV4Lm5ldC9nbHlwaHM/bGFuZz1SVV9ydSZmb250X2lkPXt7Zm9udElkfX0mcmFuZ2U9e3tyYW5nZX19J1xyXG59LCAxIC8qIFg0ICovKTtcclxuLy8gY2xhc3MgVHJhZmZpY0xheWVyQWRhcHRlciBleHRlbmRzIFJhc3RlclRpbGVzQWRhcHRlciB7XHJcbi8vICAgICBwdWJsaWMgX2dldEltYWdlVXJsKHRpbGU6IFRpbGVJdGVtKTogc3RyaW5nIHtcclxuLy8gICAgICAgICByZXR1cm4gYGh0dHBzOi8vamdvLm1hcHMueWFuZGV4Lm5ldC8xLjEvdGlsZXM/dHJmJmw9dHJmLHRyZmUmbGFuZz1ydV9VQSZ4PSR7dGlsZS54fSZ5PSR7dGlsZS55fSZ6PSR7dGlsZS56b29tfSZzY2FsZT0ke3dpbmRvdy5kZXZpY2VQaXhlbFJhdGlvfSZ0bT0ke01hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApfWBcclxuLy8gICAgICAgICAvLyByZXR1cm4gYGh0dHBzOi8vc2F0MDMubWFwcy55YW5kZXgubmV0L3RpbGVzP2w9c2F0JnY9My40MTkuMCZ4PSR7dGlsZS54fSZ5PSR7dGlsZS55fSZ6PSR7dGlsZS56b29tfSZzY2FsZT0ke3dpbmRvdy5kZXZpY2VQaXhlbFJhdGlvfSZsYW5nPXJ1X1VBYFxyXG4vLyAgICAgfVxyXG4vLyB9XHJcbi8vIGNvbnN0IHRyYWZmaWNBZGFwdGVyID0gbmV3IFRyYWZmaWNMYXllckFkYXB0ZXIoXHJcbi8vICAgICBlbmdpbmUsXHJcbi8vICAgICBjYW1lcmEsXHJcbi8vICAgICB7d2lkdGg6IDI1NiAqIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvLCBoZWlnaHQ6IDI1NiAqIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvfVxyXG4vLyApO1xyXG5lbmdpbmUuZ3JvdW5kTGF5ZXIuYWRkUmVuZGVyVW5pdChuZXcgUG9seWdvblJlbmRlclVuaXQoY29udGV4dCwgdmVjdG9yQWRhcHRlci5vcGFxdWVQb2x5Z29uc1Byb3ZpZGVyKSk7XHJcbmVuZ2luZS5ncm91bmRMYXllci5hZGRSZW5kZXJVbml0KG5ldyBUcmFuc3BhcmVudFBvbHlnb25SZW5kZXJVbml0KGNvbnRleHQsIHZlY3RvckFkYXB0ZXIudHJhbnNwYXJlbnRQb2x5Z29uc1Byb3ZpZGVyKSk7XHJcbmVuZ2luZS5ncm91bmRMYXllci5hZGRSZW5kZXJVbml0KG5ldyBUZXh0dXJlZFBvbHlnb25SZW5kZXJVbml0KGNvbnRleHQsIHZlY3RvckFkYXB0ZXIudGV4dHVyZWRQb2x5Z29uc1Byb3ZpZGVyKSk7XHJcbmVuZ2luZS5ncm91bmRMYXllci5hZGRSZW5kZXJVbml0KG5ldyBQb2x5bGluZVJlbmRlclVuaXQoY29udGV4dCwgY2FtZXJhLCB2ZWN0b3JBZGFwdGVyLnBvbHlsaW5lc1Byb3ZpZGVyKSk7XHJcbmVuZ2luZS5ncm91bmRMYXllci5hZGRSZW5kZXJVbml0KG5ldyBUZXh0dXJlZFBvbHlsaW5lUmVuZGVyVW5pdChjb250ZXh0LCBjYW1lcmEsIHZlY3RvckFkYXB0ZXIudGV4dHVyZWRQb2x5bGluZXNQcm92aWRlcikpO1xyXG5lbmdpbmUuYnVpbGRpbmdzTGF5ZXIuYWRkUmVuZGVyVW5pdChuZXcgTW9kZWxSZW5kZXJVbml0KGNvbnRleHQsIHZlY3RvckFkYXB0ZXIubW9kZWxzUHJvdmlkZXIpKTtcclxuLy8gZW5naW5lLmljb25zTGF5ZXIuYWRkUmVuZGVyVW5pdChuZXcgSW1hZ2VSZW5kZXJVbml0KGNvbnRleHQsIHRyYWZmaWNBZGFwdGVyLmltYWdlc1Byb3ZpZGVyKSk7XHJcbmVuZ2luZS5pY29uc0xheWVyLmFkZFJlbmRlclVuaXQobmV3IEljb25SZW5kZXJVbml0KGNvbnRleHQsIGNhbWVyYSwgdmVjdG9yQWRhcHRlci5pY29uc1Byb3ZpZGVyKSk7XHJcbmVuZ2luZS5sYWJlbHNMYXllci5hZGRSZW5kZXJVbml0KG5ldyBDdXJ2ZWRMYWJlbFJlbmRlclVuaXQoY29udGV4dCwgY2FtZXJhLCBlbmdpbmUudmlzYmlsaXR5VGV4dHVyZVByb3ZpZGVyLCB2ZWN0b3JBZGFwdGVyLmN1cnZlZExhYmVsc1Byb3ZpZGVyKSk7XHJcbmVuZ2luZS5sYWJlbHNMYXllci5hZGRSZW5kZXJVbml0KG5ldyBQb2ludExhYmVsUmVuZGVyVW5pdChjb250ZXh0LCBjYW1lcmEsIGVuZ2luZS52aXNiaWxpdHlUZXh0dXJlUHJvdmlkZXIsIHZlY3RvckFkYXB0ZXIucG9pbnRMYWJlbHNQcm92aWRlcikpO1xyXG5lbmdpbmUudmlzaWJpbGl0eU1hbmFnZXIucmVnaXN0ZXJDb2xsaWRpbmdQcmltaXRpdmVzKHZlY3RvckFkYXB0ZXIuY3VydmVkTGFiZWxzUHJvdmlkZXIsIG5ldyBDb2xvcklkQ3VydmVkTGFiZWxSZW5kZXJlcihjb250ZXh0LCBjYW1lcmEsIHZlY3RvckFkYXB0ZXIuY3VydmVkTGFiZWxzUHJvdmlkZXIpLCBuZXcgQ29sbGlkaW5nUHJpbWl0aXZlc1Jlc2V0UmVtb3ZlZFJlbmRlcmVyKGNvbnRleHQsIHZlY3RvckFkYXB0ZXIuY3VydmVkTGFiZWxzUHJvdmlkZXIpKTtcclxuZW5naW5lLnZpc2liaWxpdHlNYW5hZ2VyLnJlZ2lzdGVyQ29sbGlkaW5nUHJpbWl0aXZlcyh2ZWN0b3JBZGFwdGVyLnBvaW50TGFiZWxzUHJvdmlkZXIsIG5ldyBDb2xvcklkUG9pbnRMYWJlbFJlbmRlcmVyKGNvbnRleHQsIGNhbWVyYSwgdmVjdG9yQWRhcHRlci5wb2ludExhYmVsc1Byb3ZpZGVyKSwgbmV3IENvbGxpZGluZ1ByaW1pdGl2ZXNSZXNldFJlbW92ZWRSZW5kZXJlcihjb250ZXh0LCB2ZWN0b3JBZGFwdGVyLnBvaW50TGFiZWxzUHJvdmlkZXIpKTtcclxuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BsdXMnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcclxuICAgIGNhbWVyYS56b29tICs9IDAuMTtcclxufSk7XHJcbmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtaW51cycpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xyXG4gICAgY2FtZXJhLnpvb20gLT0gMC4xO1xyXG59KTtcclxuLy8gc2V0VGltZW91dCgoKSA9PiB7XHJcbi8vICAgICBjb25zb2xlLmxvZygnU2V0dGluZyBuZXcgdGlsZSB1cmwgdGVtcGxhdGUnKTtcclxuLy8gICAgIHZlY3RvckFkYXB0ZXIuc2V0VGlsZVVybFRlbXBsYXRlKCdodHRwczovL3ZlYy1yZHIwMWUudHN0Lm1hcHMueWFuZGV4LnJ1L3ZtYXAyL3RpbGVzP2w9dm1hcDImbGFuZz1ydV9SVSZ4PXt7eH19Jnk9e3t5fX0mej17e3p9fSZ6bWluPXt7em1pbn19JnptYXg9e3t6bWF4fX0nKTtcclxuLy8gfSwgNDAwMCk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vdG9vbHMvc3RhbmQvaW5kZXgudHNcbi8vIG1vZHVsZSBpZCA9IDUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IEF0dHJpYnV0ZU1hcHBpbmcgfSBmcm9tICcuL2F0dHJpYl9tYXBwaW5nJztcclxuaW1wb3J0IEJ1ZmZlciBmcm9tICcuL2dsL2J1ZmZlcic7XHJcbmltcG9ydCBGcmFtZWJ1ZmZlciBmcm9tICcuL2dsL2ZyYW1lYnVmZmVyJztcclxuaW1wb3J0IFByb2dyYW0gZnJvbSAnLi9nbC9wcm9ncmFtJztcclxuaW1wb3J0IFJlbmRlcmJ1ZmZlciBmcm9tICcuL2dsL3JlbmRlcmJ1ZmZlcic7XHJcbmltcG9ydCBSZW5kZXJDb250ZXh0Q2FwYWJpbGl0aWVzTWFuYWdlciBmcm9tICcuL2NhcGFiaWxpdGllcyc7XHJcbmltcG9ydCBSZW5kZXJTdGF0ZSBmcm9tICcuL3N0YXRlJztcclxuaW1wb3J0IFRleHR1cmUsIHsgREVGQVVMVF9URVhUVVJFX1BBUkFNUyB9IGZyb20gJy4vZ2wvdGV4dHVyZSc7XHJcbmltcG9ydCBWZXJ0ZXhBcnJheU9iamVjdCBmcm9tICcuL2dsL3Zhbyc7XHJcbmltcG9ydCAqIGFzIGNvbG9yIGZyb20gJy4uL3V0aWwvY29sb3InO1xyXG5pbXBvcnQgeyBWb2lkRXZlbnRFbWl0dGVyIH0gZnJvbSAnLi4vdXRpbC9ldmVudF9lbWl0dGVyJztcclxuY29uc3QgUVVBRF9WRVJURVhfREFUQSA9IG5ldyBGbG9hdDMyQXJyYXkoW1xyXG4gICAgLy8gdHNsaW50OmRpc2FibGVcclxuICAgIC8vIHggICB5ICB1ICB2XHJcbiAgICAtMSwgLTEsIDAsIDAsXHJcbiAgICAxLCAxLCAxLCAxLFxyXG4gICAgLTEsIDEsIDAsIDEsXHJcbiAgICAtMSwgLTEsIDAsIDAsXHJcbiAgICAxLCAtMSwgMSwgMCxcclxuICAgIDEsIDEsIDEsIDFcclxuICAgIC8vIHRzbGludDplbmFibGVcclxuXSk7XHJcbmNvbnN0IFFVQURfQVRUUklCX01BUFBJTkcgPSBuZXcgQXR0cmlidXRlTWFwcGluZyhbXHJcbiAgICBbXHJcbiAgICAgICAgMCAvKiBQT1NJVElPTiAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDIsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjYgLyogRkxPQVQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICA0IC8qIFVWICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMixcclxuICAgICAgICAgICAgdHlwZTogNTEyNiAvKiBGTE9BVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICBdXHJcbl0pO1xyXG4vKipcclxuICogRGVmYXVsdCByZW5kZXIgdGFyZ2V0IG9mIGEgV2ViR0wgY29udGV4dCwgd2hpY2ggaXMgY2FudmFzIGVsZW1lbnQgb2YgdGhlXHJcbiAqIGNvbnRleHQuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgRGVmYXVsdFJlbmRlclRhcmdldCB7XHJcbiAgICBjb25zdHJ1Y3RvcihnbCkge1xyXG4gICAgICAgIHRoaXMuaXNDbGVhciA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2dsID0gZ2w7XHJcbiAgICB9XHJcbiAgICBiaW5kKCkge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XHJcbiAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcclxuICAgIH1cclxuICAgIHNldFNpemUod2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuX2dsLmNhbnZhcztcclxuICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcclxuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgZ2V0V2lkdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dsLmRyYXdpbmdCdWZmZXJXaWR0aDtcclxuICAgIH1cclxuICAgIGdldEhlaWdodCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2wuZHJhd2luZ0J1ZmZlckhlaWdodDtcclxuICAgIH1cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgLy8gV2UgY2FuJ3QgZGVzdHJveSBkZWZhdWx0IHJlbmRlciB0YXJnZXQsIHNvIGRvIG5vdGhpbmcuXHJcbiAgICAgICAgLy8gVE9ETyhkbWlraXMpIFRocm93IGFuIGV4Y2VwdGlvbj9cclxuICAgIH1cclxufVxyXG4vKipcclxuICogV3JhcHBlciBhcm91bmQgV2ViR0wgY29udGV4dC4gU2VydmVzIHRvIGxvY2FsaXplIGFsbCBHTCBjYWxscyB0byBtaW5pbXVtIHNldFxyXG4gKiBvZiBvYmplY3RzLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVuZGVyQ29udGV4dCB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgd3JhcHBlciBmb3IgYSBnaXZlbiBXZWJHTCBjb250ZXh0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBnbCBUaGUgY29udGV4dCB0byBiZSB3cmFwcGVkLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihnbCkge1xyXG4gICAgICAgIHRoaXMuX2dsID0gZ2w7XHJcbiAgICAgICAgdGhpcy5vbkxvc3MgPSBuZXcgVm9pZEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHRMb3N0TGlzdGVuZXIgPSAoZSkgPT4ge1xyXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIHRoaXMub25Mb3NzLmZpcmUoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGdsLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRsb3N0JywgdGhpcy5fY29udGV4dExvc3RMaXN0ZW5lcik7XHJcbiAgICAgICAgdGhpcy5fY2FwYWJpbGl0aWVzID0gbmV3IFJlbmRlckNvbnRleHRDYXBhYmlsaXRpZXNNYW5hZ2VyKGdsKTtcclxuICAgICAgICBjb25zdCB2YW9FeHQgPSBnbC5nZXRFeHRlbnNpb24oJ09FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0Jyk7XHJcbiAgICAgICAgaWYgKCF2YW9FeHQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPRVNfdmVydGV4X2FycmF5X29iamVjdCBpcyByZXF1aXJlZC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fdmFvRXh0ID0gdmFvRXh0O1xyXG4gICAgICAgIGlmICghZ2wuZ2V0RXh0ZW5zaW9uKCdPRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMnKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcyBpcyByZXF1aXJlZC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZGVmYXVsdFJlbmRlclRhcmdldCA9IHRoaXMuX2JvdW5kUmVuZGVyVGFyZ2V0ID1cclxuICAgICAgICAgICAgdGhpcy5fZGVmYXVsdFJlbmRlclRhcmdldCA9XHJcbiAgICAgICAgICAgICAgICBuZXcgRGVmYXVsdFJlbmRlclRhcmdldChnbCk7XHJcbiAgICAgICAgY29uc3QgYm91bmRTdGF0ZSA9IHRoaXMuX2JvdW5kUmVuZGVyU3RhdGUgPSBuZXcgUmVuZGVyU3RhdGUoKTtcclxuICAgICAgICB0aGlzLl91bnBhY2tQcmVtdWx0aXBseUFscGhhID0gZmFsc2U7XHJcbiAgICAgICAgLy8gRGVmYXVsdCB2aWV3cG9ydCBhbmQgc2Npc3NvciByZWN0YW5nbGUgc2l6ZXMgYXJlIGVxdWFsIHRvIHRoZSBzaXplIG9mXHJcbiAgICAgICAgLy8gdGhlIGNhbnZhcyBvZiB0aGUgV2ViR0wgY29udGV4dC4gQnV0IHdlIGhhdmUgbm8gd2F5IG9mIGtub3dpbmcgdGhlbSBpblxyXG4gICAgICAgIC8vIFJlbmRlclN0YXRlJ3MgY29uc3RydWN0b3IuIFNvIHdlJ3JlIGZpeGluZyB0aGVtIGhlcmUuXHJcbiAgICAgICAgYm91bmRTdGF0ZS5zY2lzc29yV2lkdGggPSBib3VuZFN0YXRlLnZpZXdwb3J0V2lkdGggPVxyXG4gICAgICAgICAgICBkZWZhdWx0UmVuZGVyVGFyZ2V0LmdldFdpZHRoKCk7XHJcbiAgICAgICAgYm91bmRTdGF0ZS5zY2lzc29ySGVpZ2h0ID0gYm91bmRTdGF0ZS52aWV3cG9ydEhlaWdodCA9XHJcbiAgICAgICAgICAgIGRlZmF1bHRSZW5kZXJUYXJnZXQuZ2V0SGVpZ2h0KCk7XHJcbiAgICAgICAgY29uc3QgcXVhZEJ1ZmZlciA9IHRoaXMuX3F1YWRWZXJ0ZXhCdWZmZXIgPVxyXG4gICAgICAgICAgICBuZXcgQnVmZmVyKGdsLCBnbC5BUlJBWV9CVUZGRVIsIGdsLlNUQVRJQ19EUkFXKTtcclxuICAgICAgICBxdWFkQnVmZmVyLmJpbmQoKTtcclxuICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgUVVBRF9WRVJURVhfREFUQSwgZ2wuU1RBVElDX0RSQVcpO1xyXG4gICAgICAgIHRoaXMuX3F1YWRWYW8gPSB0aGlzLmNyZWF0ZVZhbyhRVUFEX0FUVFJJQl9NQVBQSU5HLCBxdWFkQnVmZmVyLCBudWxsKTtcclxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgbnVsbCk7XHJcbiAgICAgICAgdGhpcy5fYm91bmRQcm9ncmFtID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9ib3VuZFZhbyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fYm91bmRUZXh0dXJlcyA9IG5ldyBBcnJheSh0aGlzLl9jYXBhYmlsaXRpZXMuZ2V0TWF4Q29tYmluZWRUZXh0dXJlSW1hZ2VVbml0cygpKTtcclxuICAgICAgICB0aGlzLl9ib3VuZFRleHR1cmVzLmZpbGwobnVsbCk7XHJcbiAgICAgICAgdGhpcy5fYm91bmRUZXh0dXJlVW5pdCA9IDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgb2JqZWN0IHRvIHJlcXVlc3QgY2FwYWJpbGl0aWVzIG9mIHRoZSBjb250ZXh0IHN1Y2ggYXMgbWF4aW11bVxyXG4gICAgICogdGV4dHVyZSBzaXplIG9yIG1heGltdW0gbnVtYmVyIG9mIHVuaWZvcm0gdmVjdG9ycyBhbGxvd2VkIGluIHNoYWRlcnMuXHJcbiAgICAgKi9cclxuICAgIGdldENhcGFiaWxpdGllcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY2FwYWJpbGl0aWVzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGZyYW1lYnVmZmVyIHdpdGggZ2l2ZW4gYXR0YWNobWVudHMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGRlc2NyaXB0b3IgT2JqZWN0IGNvbnRhaW5pbmcgZnJhbWVidWZmZXIgYXR0YWNobWVudHMuXHJcbiAgICAgKiBAcmV0dXJucyBDcmVhdGVkIGZyYW1lYnVmZmVyIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgY3JlYXRlRnJhbWVidWZmZXIoeyBjb2xvciwgZGVwdGgsIHN0ZW5jaWwsIGRlcHRoU3RlbmNpbCB9KSB7XHJcbiAgICAgICAgLy8gVE9ETyBVbmNvbW1lbnQgYW5kIHB1dCB1bmRlciBkZWJ1ZyBmbGFnICh3aGVuIGltcGxlbWVudGVkKVxyXG4gICAgICAgIC8vIGlmIChkZXB0aFN0ZW5jaWwgJiYgKGRlcHRoIHx8IHN0ZW5jaWwpKSB7XHJcbiAgICAgICAgLy8gICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAvLyAgICAgICAgICdGcmFtZWJ1ZmZlciBjYW5cXCd0IGhhdmUgREVQVEhfU1RFTkNJTCBhbmQgREVQVEggb3IgU1RFTkNJTCAnICtcclxuICAgICAgICAvLyAgICAgICAgICAgICAnYXR0YWNobWVudCBzaW11bHRhbmVvdXNseS4nXHJcbiAgICAgICAgLy8gICAgICk7XHJcbiAgICAgICAgLy8gfVxyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XHJcbiAgICAgICAgbGV0IHdpZHRoID0gMDtcclxuICAgICAgICBsZXQgaGVpZ2h0ID0gMDtcclxuICAgICAgICBpZiAoY29sb3IpIHtcclxuICAgICAgICAgICAgd2lkdGggPSBjb2xvci5nZXRXaWR0aCgpO1xyXG4gICAgICAgICAgICBoZWlnaHQgPSBjb2xvci5nZXRIZWlnaHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZGVwdGgpIHtcclxuICAgICAgICAgICAgd2lkdGggPSBkZXB0aC5nZXRXaWR0aCgpO1xyXG4gICAgICAgICAgICBoZWlnaHQgPSBkZXB0aC5nZXRIZWlnaHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc3RlbmNpbCkge1xyXG4gICAgICAgICAgICB3aWR0aCA9IHN0ZW5jaWwuZ2V0V2lkdGgoKTtcclxuICAgICAgICAgICAgaGVpZ2h0ID0gc3RlbmNpbC5nZXRIZWlnaHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZGVwdGhTdGVuY2lsKSB7XHJcbiAgICAgICAgICAgIHdpZHRoID0gZGVwdGhTdGVuY2lsLmdldFdpZHRoKCk7XHJcbiAgICAgICAgICAgIGhlaWdodCA9IGRlcHRoU3RlbmNpbC5nZXRIZWlnaHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZnJhbWVidWZmZXIgPSBuZXcgRnJhbWVidWZmZXIoZ2wsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuYmluZFJlbmRlclRhcmdldChmcmFtZWJ1ZmZlcik7XHJcbiAgICAgICAgaWYgKGNvbG9yKSB7XHJcbiAgICAgICAgICAgIGNvbG9yLmF0dGFjaFRvRnJhbWVidWZmZXIoZ2wuQ09MT1JfQVRUQUNITUVOVDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGVwdGgpIHtcclxuICAgICAgICAgICAgZGVwdGguYXR0YWNoVG9GcmFtZWJ1ZmZlcihnbC5ERVBUSF9BVFRBQ0hNRU5UKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0ZW5jaWwpIHtcclxuICAgICAgICAgICAgc3RlbmNpbC5hdHRhY2hUb0ZyYW1lYnVmZmVyKGdsLlNURU5DSUxfQVRUQUNITUVOVCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkZXB0aFN0ZW5jaWwpIHtcclxuICAgICAgICAgICAgZGVwdGhTdGVuY2lsLmF0dGFjaFRvRnJhbWVidWZmZXIoZ2wuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5UKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVE9ETyBVbmNvbW1lbnQgYW5kIHB1dCB1bmRlciBkZWJ1ZyBmbGFnICh3aGVuIGltcGxlbWVudGVkKVxyXG4gICAgICAgIC8vIHN3aXRjaCAoZ2wuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyhnbC5GUkFNRUJVRkZFUikpIHtcclxuICAgICAgICAvLyAgICAgY2FzZSBnbC5GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0FUVEFDSE1FTlQ6XHJcbiAgICAgICAgLy8gICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZyYW1lYnVmZmVyIGF0dGFjaG1lbnRzIGFyZSBub3QgcmVuZGVyYWJsZScpO1xyXG4gICAgICAgIC8vICAgICBjYXNlIGdsLkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfRElNRU5TSU9OUzpcclxuICAgICAgICAvLyAgICAgICAgIHRocm93IG5ldyBFcnJvcignRnJhbWVidWZmZXIgYXR0YWNobWVudHMgYXJlIG5vdCBzYW1lIHNpemUnKTtcclxuICAgICAgICAvLyAgICAgY2FzZSBnbC5GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX01JU1NJTkdfQVRUQUNITUVOVDpcclxuICAgICAgICAvLyAgICAgICAgIHRocm93IG5ldyBFcnJvcignRnJhbWVidWZmZXIgaGFzIG5vIGF0dGFjaG1lbnRzJyk7XHJcbiAgICAgICAgLy8gICAgIGNhc2UgZ2wuRlJBTUVCVUZGRVJfVU5TVVBQT1JURUQ6XHJcbiAgICAgICAgLy8gICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZyYW1lYnVmZmVyIGhhcyB1bnN1cHBvcnRlZCBhdHRhY2htZW50Jyk7XHJcbiAgICAgICAgLy8gfVxyXG4gICAgICAgIHJldHVybiBmcmFtZWJ1ZmZlcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWxsb2NhdGVzIGEgbmV3IHJlbmRlcmJ1ZmZlciB3aXRoIGdpdmVuIHNpemUgYW5kIGZvcm1hdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gd2lkdGggV2lkdGggb2YgdGhlIHJlbmRlcmJ1ZmZlci5cclxuICAgICAqIEBwYXJhbSBoZWlnaHQgSGVpZ2h0IG9mIHRoZSByZW5kZXJidWZmZXIuXHJcbiAgICAgKiBAcGFyYW0gZm9ybWF0IEZvcm1hdCBvZiB0aGUgcmVuZGVyYnVmZmVyLlxyXG4gICAgICogQHJldHVybiBUaGUgYWxsb2NhdGVkIHJlbmRlcmJ1ZmZlci5cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIGNyZWF0ZVJlbmRlcmJ1ZmZlcih3aWR0aCwgaGVpZ2h0LCBmb3JtYXQpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xyXG4gICAgICAgIGNvbnN0IHJlbmRlcmJ1ZmZlciA9IG5ldyBSZW5kZXJidWZmZXIoZ2wsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIHJlbmRlcmJ1ZmZlci5iaW5kKCk7XHJcbiAgICAgICAgZ2wucmVuZGVyYnVmZmVyU3RvcmFnZShnbC5SRU5ERVJCVUZGRVIsIGZvcm1hdCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgcmV0dXJuIHJlbmRlcmJ1ZmZlcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWxsb2NhdGVzIGEgbmV3IHRleHR1cmUgd2l0aCBnaXZlbiBzaXplLCBmb3JtYXQsIHR5cGUgYW5kIHBhcmFtZXRlcnMgYW5kXHJcbiAgICAgKiBmaWxscyBpdCB3aXRoIHplcm9lcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gd2lkdGggV2lkdGggb2YgdGhlIHRleHR1cmUuXHJcbiAgICAgKiBAcGFyYW0gaGVpZ2h0IEhlaWdodCBvZiB0aGUgdGV4dHVyZS5cclxuICAgICAqIEBwYXJhbSBmb3JtYXQgUGl4ZWwgZm9ybWF0IG9mIHRoZSB0ZXh0dXJlLlxyXG4gICAgICogQHBhcmFtIHR5cGUgUGl4ZWwgdHlwZSBvZiB0aGUgdGV4dHVyZS5cclxuICAgICAqIEBwYXJhbSBwYXJhbXMgUGFyYW1ldGVycyBvZiB0aGUgdGV4dHVyZS5cclxuICAgICAqIEByZXR1cm5zIE5ld2x5IGFsbG9jYXRlZCB0ZXh0dXJlLlxyXG4gICAgICovXHJcbiAgICBjcmVhdGVFbXB0eTJEVGV4dHVyZSh3aWR0aCwgaGVpZ2h0LCBmb3JtYXQsIHR5cGUsIHBhcmFtcyA9IERFRkFVTFRfVEVYVFVSRV9QQVJBTVMpIHtcclxuICAgICAgICBjb25zdCB0ZXh0dXJlID0gbmV3IFRleHR1cmUodGhpcy5fZ2wsIHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgdHlwZSwgcGFyYW1zKTtcclxuICAgICAgICByZXR1cm4gdGV4dHVyZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBzaGFkZXIgcHJvZ3JhbS4gVXNlcyBjYWNoZSwgaS5lLiBpZiBhIHByb2dyYW0gd2l0aCBzYW1lXHJcbiAgICAgKiBzb3VyY2Ugc3RyaW5nIGFuZCBvcHRpb25zIGlzIGFscmVhZHkgY3JlYXRlZCwgcmV0dXJucyBpdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmVydGV4U2hhZGVyU291cmNlIFNvdXJjZSBjb2RlIG9mIHZlcnRleCBzaGFkZXIgb2YgdGhlIHByb2dyYW0uXHJcbiAgICAgKiBAcGFyYW0gZnJhZ21lbnRTaGFkZXJTb3VyY2UgU291cmNlIGNvZGUgb2YgZnJhZ21lbnQgc2hhZGVyIG9mIHRoZSBwcm9ncmFtLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucy5cclxuICAgICAqIEByZXR1cm5zIE5ld2x5IGNyZWF0ZWQgcHJvZ3JhbSBvciBvbmUgZnJvbSB0aGUgY2FjaGUuXHJcbiAgICAgKi9cclxuICAgIGNyZWF0ZVByb2dyYW0odmVydGV4U2hhZGVyU291cmNlLCBmcmFnbWVudFNoYWRlclNvdXJjZSwgb3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvZ3JhbSh0aGlzLl9nbCwgdmVydGV4U2hhZGVyU291cmNlLCBmcmFnbWVudFNoYWRlclNvdXJjZSwgb3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICBjcmVhdGVWZXJ0ZXhCdWZmZXIoc2l6ZSwgdXNhZ2UgPSAzNTA0NCAvKiBTVEFUSUNfRFJBVyAqLykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVCdWZmZXIodGhpcy5fZ2wuQVJSQVlfQlVGRkVSLCBzaXplLCB1c2FnZSk7XHJcbiAgICB9XHJcbiAgICBjcmVhdGVJbmRleEJ1ZmZlcihzaXplLCB1c2FnZSA9IDM1MDQ0IC8qIFNUQVRJQ19EUkFXICovKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZUJ1ZmZlcih0aGlzLl9nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgc2l6ZSwgdXNhZ2UpO1xyXG4gICAgfVxyXG4gICAgLy8gVE9ETzogY2hlY2sgaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8yNDE5NSB0byB1cGRhdGUgbmFycm93ZWQgZGF0YSB0eXBlIGFjY29yZGluZ1xyXG4gICAgdXBsb2FkRGF0YVRvQnVmZmVyKGJ1ZmZlciwgZGF0YSwgb2Zmc2V0ID0gMCkge1xyXG4gICAgICAgIGJ1ZmZlci5iaW5kKCk7XHJcbiAgICAgICAgdGhpcy5fZ2wuYnVmZmVyU3ViRGF0YShidWZmZXIuZ2V0VGFyZ2V0KCksIG9mZnNldCwgZGF0YSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgdmVydGV4IGFycmF5IG9iamVjdCBpbiB0aGUgY29udGV4dC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYXR0cmlidXRlTWFwcGluZyBNYXBwaW5nIG9mIHZlcnRleCBhdHRyYml1dGVzIGZvciB0aGUgVkFPLlxyXG4gICAgICogQHBhcmFtIHZlcnRleEJ1ZmZlciBWZXJ0ZXggYnVmZmVyIHRvIGJlIGJvdW5kIHRvIHRoZSBWQU8uXHJcbiAgICAgKiBAcGFyYW0gaW5kZXhCdWZmZXIgSW5kZXggYnVmZmVyIHRvIGJlIGJvdW5kIHRvIHRoZSBWQU8uXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgbmV3IFZBTy5cclxuICAgICAqL1xyXG4gICAgY3JlYXRlVmFvKGF0dHJpYnV0ZU1hcHBpbmcsIHZlcnRleEJ1ZmZlciwgaW5kZXhCdWZmZXIpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xyXG4gICAgICAgIGNvbnN0IHZhbyA9IG5ldyBWZXJ0ZXhBcnJheU9iamVjdChnbCwgdGhpcy5fdmFvRXh0LCBhdHRyaWJ1dGVNYXBwaW5nKTtcclxuICAgICAgICB2YW8uYmluZCgpO1xyXG4gICAgICAgIGlmIChpbmRleEJ1ZmZlcikge1xyXG4gICAgICAgICAgICBpbmRleEJ1ZmZlci5iaW5kKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmVydGV4QnVmZmVyLmJpbmQoKTtcclxuICAgICAgICBjb25zdCB2ZXJ0ZXhCeXRlU2l6ZSA9IGF0dHJpYnV0ZU1hcHBpbmcudmVydGV4Qnl0ZVNpemU7XHJcbiAgICAgICAgZm9yIChjb25zdCBbaWR4LCBwb2ludGVyXSBvZiBhdHRyaWJ1dGVNYXBwaW5nKSB7XHJcbiAgICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGlkeCk7XHJcbiAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoaWR4LCBwb2ludGVyLnNpemUsIHBvaW50ZXIudHlwZSwgcG9pbnRlci5ub3JtYWxpemVkLCB2ZXJ0ZXhCeXRlU2l6ZSwgcG9pbnRlci5vZmZzZXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl92YW9FeHQuYmluZFZlcnRleEFycmF5T0VTKG51bGwpO1xyXG4gICAgICAgIHJldHVybiB2YW87XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgbmV3IGNvbnRlbnQgb2YgdGV4dHVyZSwgcHJvdmlkZWQgZGF0YSBtdXN0IGJlIG9mIGxlbmd0aCBlcXVhbCB0byBcIndpZHRoICogaGVpZ2h0XCIgYW5kIGl0cyB0eXBlXHJcbiAgICAgKiBtdXN0IGNvcnJlc3BvbmQgdG8gdGV4dHVyZSdzIHR5cGUge0BzZWUgUGl4ZWxUeXBlfS5cclxuICAgICAqL1xyXG4gICAgc2V0VGV4dHVyZURhdGEodGV4dHVyZSwgZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XHJcbiAgICAgICAgY29uc3Qgd2lkdGggPSB0ZXh0dXJlLmdldFdpZHRoKCk7XHJcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gdGV4dHVyZS5nZXRIZWlnaHQoKTtcclxuICAgICAgICBjb25zdCBmb3JtYXQgPSB0ZXh0dXJlLmdldEZvcm1hdCgpO1xyXG4gICAgICAgIGNvbnN0IHR5cGUgPSB0ZXh0dXJlLmdldFR5cGUoKTtcclxuICAgICAgICBjb25zdCBwYXJhbXMgPSB0ZXh0dXJlLmdldFBhcmFtcygpO1xyXG4gICAgICAgIHRoaXMuX3NldFRleHR1cmVEYXRhVW5wYWNrUGFyYW1zKHBhcmFtcyk7XHJcbiAgICAgICAgdGhpcy5iaW5kVGV4dHVyZSh0ZXh0dXJlKTtcclxuICAgICAgICBnbC50ZXhTdWJJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIDAsIDAsIHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgdHlwZSwgZGF0YSk7XHJcbiAgICAgICAgdGhpcy5fb25UZXh0dXJlRGF0YVVwZGF0ZWQodGV4dHVyZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgbmV3IHRleHR1cmUgY29udGVudCBmcm9tIGNhbnZhcyBlbGVtZW50LlxyXG4gICAgICovXHJcbiAgICBzZXRUZXh0dXJlRGF0YUZyb21Eb21FbGVtZW50KHRleHR1cmUsIGVsZW1lbnQpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xyXG4gICAgICAgIGNvbnN0IGZvcm1hdCA9IHRleHR1cmUuZ2V0Rm9ybWF0KCk7XHJcbiAgICAgICAgY29uc3QgdHlwZSA9IHRleHR1cmUuZ2V0VHlwZSgpO1xyXG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHRleHR1cmUuZ2V0UGFyYW1zKCk7XHJcbiAgICAgICAgdGhpcy5fc2V0VGV4dHVyZURhdGFVbnBhY2tQYXJhbXMocGFyYW1zKTtcclxuICAgICAgICB0aGlzLmJpbmRUZXh0dXJlKHRleHR1cmUpO1xyXG4gICAgICAgIGdsLnRleFN1YkltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgMCwgMCwgZm9ybWF0LCB0eXBlLCBlbGVtZW50KTtcclxuICAgICAgICB0aGlzLl9vblRleHR1cmVEYXRhVXBkYXRlZCh0ZXh0dXJlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBkZWZhdWx0IHJlbmRlciB0YXJnZXQgYXNzb2NpYXRlZCB3aXRoIGNhbnZhcyBvbiB3aGljaCB0aGUgV2ViR0xcclxuICAgICAqIGNvbnRleHQgb3BlcmF0ZXMuXHJcbiAgICAgKi9cclxuICAgIGdldERlZmF1bHRSZW5kZXJUYXJnZXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRSZW5kZXJUYXJnZXQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENsZWFycyBjdXJyZW50bHkgYm91bmQgcmVuZGVyIHRhcmdldCBhY2NvcmRpbmcgdG8gYSBtYXNrLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtYXNrIEJpdHdpc2UgT1Igb2YgbWFya3MsIGkuZS5cclxuICAgICAqICAgICAgYENsZWFyTWFzay5DT0xPUl9CVUZGRVJfQklUIHwgQ2xlYXJNYXNrLkRFUFRIX0JVRkZFUl9CSVRgLlxyXG4gICAgICovXHJcbiAgICBjbGVhckN1cnJlbnRUYXJnZXQobWFzaykge1xyXG4gICAgICAgIGlmIChtYXNrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsLmNsZWFyKG1hc2spO1xyXG4gICAgICAgICAgICB0aGlzLl9ib3VuZFJlbmRlclRhcmdldC5pc0NsZWFyID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEJpbmRzIGEgcmVuZGVyIHRhcmdldCB0byB0aGUgV2ViR0wgY29udGV4dCBpZiBpdCdzIG5vdCBhbHJlYWR5IGJvdW5kLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0YXJnZXQgVGhlIHJlbmRlciB0YXJnZXQgdG8gYmUgYm91bmQuXHJcbiAgICAgKi9cclxuICAgIGJpbmRSZW5kZXJUYXJnZXQodGFyZ2V0KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2JvdW5kUmVuZGVyVGFyZ2V0ICE9PSB0YXJnZXQpIHtcclxuICAgICAgICAgICAgdGFyZ2V0LmJpbmQoKTtcclxuICAgICAgICAgICAgdGhpcy5fYm91bmRSZW5kZXJUYXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRhcmdldCBzaXplIGNvdWxkIGNoYW5nZSBldmVuIGlmIHRhcmdldCBpcyBhbHJlYWR5IGJvdW5kLlxyXG4gICAgICAgIC8vIFZFQ1RPUi0xOTBcclxuICAgICAgICB0aGlzLl9zZXRWaWV3cG9ydFN0YXRlKG5ldyBSZW5kZXJTdGF0ZSh7XHJcbiAgICAgICAgICAgIHZpZXdwb3J0V2lkdGg6IHRhcmdldC5nZXRXaWR0aCgpLFxyXG4gICAgICAgICAgICB2aWV3cG9ydEhlaWdodDogdGFyZ2V0LmdldEhlaWdodCgpXHJcbiAgICAgICAgfSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBCaW5kcyBhIHJlbmRlciBzdGF0ZSB0byB0aGUgV2ViR0wgY29udGV4dCB3aXRoIG1pbmltdW0gYW1vdW50IG9mIGFjdHVhbFxyXG4gICAgICogc3RhdGUgc3dpdGNoaW5nLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzdGF0ZSBUaGUgc3RhdGUgdG8gYmUgYm91bmQuXHJcbiAgICAgKi9cclxuICAgIGJpbmRSZW5kZXJTdGF0ZShzdGF0ZSkge1xyXG4gICAgICAgIHRoaXMuX3NldENvbG9yQnVmZmVyU3RhdGUoc3RhdGUpO1xyXG4gICAgICAgIHRoaXMuX3NldEJsZW5kU3RhdGUoc3RhdGUpO1xyXG4gICAgICAgIHRoaXMuX3NldEN1bGxGYWNlU3RhdGUoc3RhdGUpO1xyXG4gICAgICAgIHRoaXMuX3NldEZyb250RmFjZVN0YXRlKHN0YXRlKTtcclxuICAgICAgICB0aGlzLl9zZXREZXB0aFRlc3RTdGF0ZShzdGF0ZSk7XHJcbiAgICAgICAgdGhpcy5fc2V0RGl0aGVyU3RhdGUoc3RhdGUpO1xyXG4gICAgICAgIHRoaXMuX3NldERyYXdCdWZmZXJzU3RhdGUoc3RhdGUpO1xyXG4gICAgICAgIHRoaXMuX3NldFBvbHlnb25PZmZzZXRTdGF0ZShzdGF0ZSk7XHJcbiAgICAgICAgdGhpcy5fc2V0QWxwaGFUb0NvdmVyYWdlU3RhdGUoc3RhdGUpO1xyXG4gICAgICAgIHRoaXMuX3NldFNhbXBsZUNvdmVyYWdlU3RhdGUoc3RhdGUpO1xyXG4gICAgICAgIHRoaXMuX3NldFN0ZW5jaWxUZXN0U3RhdGUoc3RhdGUpO1xyXG4gICAgICAgIHRoaXMuX3NldFNjaXNzb3JUZXN0U3RhdGUoc3RhdGUpO1xyXG4gICAgICAgIHRoaXMuX3NldFZpZXdwb3J0U3RhdGUoc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBCaW5kcyBhIHByb2dyYW0gdG8gdGhlIFdlYkdMIGNvbnRleHQgaWYgaXQncyBub3QgYWxyZWFkeSBib3VuZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcHJvZ3JhbSBUaGUgcHJvZ3JhbSB0byBiZSBib3VuZC5cclxuICAgICAqL1xyXG4gICAgYmluZFByb2dyYW0ocHJvZ3JhbSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9ib3VuZFByb2dyYW0gIT09IHByb2dyYW0pIHtcclxuICAgICAgICAgICAgcHJvZ3JhbS5iaW5kKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2JvdW5kUHJvZ3JhbSA9IHByb2dyYW07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBCaW5kcyBhIHZlcnRleCBhcnJheSBvYmplY3QgdG8gdGhlIGNvbnRleHQgaWYgaXQncyBub3QgYWxyZWFkeSBib3VuZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmFvIFRoZSB2ZXJ0ZXggYXJyYXkgb2JqZWN0IHRvIGJpbmQuIFBhc3NpbmcgYG51bGxgIHdpbGwgdW5iaW5kXHJcbiAgICAgKiAgICAgIGFueSBjdXJyZW50bHkgYm91bmQgVkFPLlxyXG4gICAgICovXHJcbiAgICBiaW5kVmFvKHZhbykge1xyXG4gICAgICAgIGlmICh0aGlzLl9ib3VuZFZhbyAhPT0gdmFvKSB7XHJcbiAgICAgICAgICAgIGlmICh2YW8pIHtcclxuICAgICAgICAgICAgICAgIHZhby5iaW5kKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl92YW9FeHQuYmluZFZlcnRleEFycmF5T0VTKG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2JvdW5kVmFvID0gdmFvO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGJpbmRRdWFkVmFvKCkge1xyXG4gICAgICAgIHRoaXMuYmluZFZhbyh0aGlzLl9xdWFkVmFvKTtcclxuICAgIH1cclxuICAgIGJpbmRUZXh0dXJlVW5pdCh1bml0KSB7XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcclxuICAgICAgICBpZiAodGhpcy5fYm91bmRUZXh0dXJlVW5pdCAhPT0gdW5pdCkge1xyXG4gICAgICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgdW5pdCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2JvdW5kVGV4dHVyZVVuaXQgPSB1bml0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGJpbmRUZXh0dXJlKHRleHR1cmUpIHtcclxuICAgICAgICBjb25zdCBib3VuZFVuaXQgPSB0aGlzLl9ib3VuZFRleHR1cmVVbml0O1xyXG4gICAgICAgIGlmICh0aGlzLl9ib3VuZFRleHR1cmVzW2JvdW5kVW5pdF0gIT09IHRleHR1cmUpIHtcclxuICAgICAgICAgICAgdGV4dHVyZS5iaW5kKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2JvdW5kVGV4dHVyZXNbYm91bmRVbml0XSA9IHRleHR1cmU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3cyBhIHF1YWQgdG8gY3VycmVudGx5IGJvdW5kIHJlbmRlciB0YXJnZXQgd2l0aCBjdXJyZW50bHkgYm91bmQgcmVuZGVyXHJcbiAgICAgKiBzdGF0ZSwgcHJvZ3JhbSBhbmQgdW5pZm9ybSBzdGF0ZS5cclxuICAgICAqL1xyXG4gICAgZHJhd1F1YWQoKSB7XHJcbiAgICAgICAgdGhpcy5kcmF3TWVzaCgwLCA2LCA0IC8qIFRSSUFOR0xFUyAqLyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERyYXdzIGEgbWVzaCBmcm9tIGN1cnJlbnRseSBib3VuZCB0byBBUlJBWV9CVUZGRVIgYnVmZmVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvZmZzZXQgSW5kZXggb2YgdGhlIHZlcnRleCB0byBzdGFydCBkcmF3aW5nIGZyb20uXHJcbiAgICAgKiBAcGFyYW0gY291bnQgTnVtYmVyIG9mIHZlcnRpY2VzIHRvIHByb2Nlc3MuXHJcbiAgICAgKiBAcGFyYW0gcHJpbWl0aXZlVHlwZVxyXG4gICAgICovXHJcbiAgICBkcmF3TWVzaChvZmZzZXQsIGNvdW50LCBwcmltaXRpdmVUeXBlID0gNCAvKiBUUklBTkdMRVMgKi8pIHtcclxuICAgICAgICB0aGlzLl9nbC5kcmF3QXJyYXlzKHByaW1pdGl2ZVR5cGUsIG9mZnNldCwgY291bnQpO1xyXG4gICAgICAgIHRoaXMuX2JvdW5kUmVuZGVyVGFyZ2V0LmlzQ2xlYXIgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRHJhd3MgYSBtZXNoIHRvIGN1cnJlbnRseSBib3VuZCByZW5kZXIgdGFyZ2V0IHdpdGggY3VycmVudGx5IGJvdW5kIHJlbmRlclxyXG4gICAgICogc3RhdGUsIHByb2dyYW0gYW5kIHVuaWZvcm0gc3RhdGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG9mZnNldCBPZmZzZXQgb2YgaW5kaWNlcyBvZiB0aGUgbWVzaCBpbiBjdXJyZW50bHkgYm91bmQgbWVtb3J5IHBhZ2UuXHJcbiAgICAgKiBAcGFyYW0gaW5kZXhDb3VudCBOdW1iZXIgb2YgaW5kaWNlcyBpbiB0aGUgbWVzaC5cclxuICAgICAqL1xyXG4gICAgZHJhd0luZGV4ZWRNZXNoKG9mZnNldCwgaW5kZXhDb3VudCwgcHJpbWl0aXZlVHlwZSA9IDQgLyogVFJJQU5HTEVTICovKSB7XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcclxuICAgICAgICBnbC5kcmF3RWxlbWVudHMocHJpbWl0aXZlVHlwZSwgaW5kZXhDb3VudCwgZ2wuVU5TSUdORURfU0hPUlQsIG9mZnNldCk7XHJcbiAgICAgICAgdGhpcy5fYm91bmRSZW5kZXJUYXJnZXQuaXNDbGVhciA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXN0cm95cyB0aGUgY29udGV4dCBhbmQgcmVzb3VyY2VzIG93bmVkIGJ5IGl0LiBOb3RlIHRoYXQgcmVzb3VyY2VzIHRoYXRcclxuICAgICAqIHdlcmUgY3JlYXRlZCB3aXRoIGBjcmVhdGUqYCBtZXRob2Qgb2YgdGhlIGNvbnRleHQgYXJlbid0IGV4YWN0bHkgYmVsb25nXHJcbiAgICAgKiB0byB0aGUgY29udGV4dCwgZW50aXRpZXMgdGhhdCBjcmVhdGVkIHRoZW0gaGF2ZSB0byBkZXN0cm95IHRoZW0uXHJcbiAgICAgKi9cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5fcXVhZFZhby5kZXN0cm95KCk7XHJcbiAgICAgICAgdGhpcy5fcXVhZFZlcnRleEJ1ZmZlci5kZXN0cm95KCk7XHJcbiAgICAgICAgdGhpcy5fZ2wuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dGxvc3QnLCB0aGlzLl9jb250ZXh0TG9zdExpc3RlbmVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBjb250ZXh0IGZyb20gYSBjYW52YXMuXHJcbiAgICAgKlxyXG4gICAgICogQHRocm93cyBBbiBlcnJvciBpZiBmYWlscyB0byBjcmVhdGUgYHdlYmdsYCBjb250ZXh0IGZvciB0aGUgY2FudmFzLlxyXG4gICAgICogQHBhcmFtIGNhbnZhcyBUaGUgY2FudmFzLlxyXG4gICAgICogQHBhcmFtIGF0dHJpYnMgQXR0cmlidXRlcyBvZiB0aGUgY29udGV4dC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWF0ZUZyb21DYW52YXMoY2FudmFzLCBhdHRyaWJzKSB7XHJcbiAgICAgICAgY29uc3QgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnLCBhdHRyaWJzKTtcclxuICAgICAgICBpZiAoIWdsKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGNyZWF0ZSBHTCBjb250ZXh0IGZyb20gY2FudmFzLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFJlbmRlckNvbnRleHQoZ2wpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmFibGVzIG9yIGRpc2FibGVzIGEgV2ViR0wgY2FwYWJpbGl0eS5cclxuICAgICAqIEBzZWUgaHR0cHM6Ly93d3cua2hyb25vcy5vcmcvcmVnaXN0cnkvT3BlbkdMLVJlZnBhZ2VzL2VzMi4wL3hodG1sL2dsRW5hYmxlLnhtbFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjYXBhYmlsaXR5IFRoZSBjYXBhYmlsaXR5IHRvIGJlIGVuYWJsZWQgb2YgZGlzYWJsZWQuXHJcbiAgICAgKiBAcGFyYW0gZW5hYmxlZCBOZXcgc3RhdGUgb2YgdGhlIGNhcGFiaWxpdHk7XHJcbiAgICAgKi9cclxuICAgIF9zZXRDYXBhYmlsaXR5RW5hYmxlZChjYXBhYmlsaXR5LCBlbmFibGVkKSB7XHJcbiAgICAgICAgaWYgKGVuYWJsZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fZ2wuZW5hYmxlKGNhcGFiaWxpdHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fZ2wuZGlzYWJsZShjYXBhYmlsaXR5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgbmV3IGNsZWFyIGNvbG9yIGFuZCBjb2xvciBtYXNrIGZyb20gYSBzdGF0ZSBpZiB0aGV5J3JlIGRpZmZlcmVudCBmcm9tXHJcbiAgICAgKiBjdXJyZW50bHkgc2V0IG9uZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHN0YXRlIFRoZSBzdGF0ZSB0aGF0IGNvbnRhaW5zIG5ldyBjbGVhciBjb2xvciBhbmQgY29sb3IgbWFza3MuXHJcbiAgICAgKi9cclxuICAgIF9zZXRDb2xvckJ1ZmZlclN0YXRlKHN0YXRlKSB7XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcclxuICAgICAgICBjb25zdCBib3VuZFN0YXRlID0gdGhpcy5fYm91bmRSZW5kZXJTdGF0ZTtcclxuICAgICAgICBjb25zdCBuZXdDbGVhckNvbG9yID0gc3RhdGUuY2xlYXJDb2xvcjtcclxuICAgICAgICBpZiAoIWNvbG9yLmFyZUVxdWFsKGJvdW5kU3RhdGUuY2xlYXJDb2xvciwgbmV3Q2xlYXJDb2xvcikpIHtcclxuICAgICAgICAgICAgZ2wuY2xlYXJDb2xvcihuZXdDbGVhckNvbG9yLnIsIG5ld0NsZWFyQ29sb3IuZywgbmV3Q2xlYXJDb2xvci5iLCBuZXdDbGVhckNvbG9yLmEpO1xyXG4gICAgICAgICAgICBjb2xvci5jb3B5KG5ld0NsZWFyQ29sb3IsIGJvdW5kU3RhdGUuY2xlYXJDb2xvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChib3VuZFN0YXRlLmNvbG9yTWFza1IgIT09IHN0YXRlLmNvbG9yTWFza1IgfHxcclxuICAgICAgICAgICAgYm91bmRTdGF0ZS5jb2xvck1hc2tHICE9PSBzdGF0ZS5jb2xvck1hc2tHIHx8XHJcbiAgICAgICAgICAgIGJvdW5kU3RhdGUuY29sb3JNYXNrQiAhPT0gc3RhdGUuY29sb3JNYXNrQiB8fFxyXG4gICAgICAgICAgICBib3VuZFN0YXRlLmNvbG9yTWFza0FscGhhICE9PSBzdGF0ZS5jb2xvck1hc2tBbHBoYSkge1xyXG4gICAgICAgICAgICB0aGlzLl9nbC5jb2xvck1hc2soc3RhdGUuY29sb3JNYXNrUiwgc3RhdGUuY29sb3JNYXNrRywgc3RhdGUuY29sb3JNYXNrQiwgc3RhdGUuY29sb3JNYXNrQWxwaGEpO1xyXG4gICAgICAgICAgICBib3VuZFN0YXRlLmNvbG9yTWFza1IgPSBzdGF0ZS5jb2xvck1hc2tSO1xyXG4gICAgICAgICAgICBib3VuZFN0YXRlLmNvbG9yTWFza0cgPSBzdGF0ZS5jb2xvck1hc2tHO1xyXG4gICAgICAgICAgICBib3VuZFN0YXRlLmNvbG9yTWFza0IgPSBzdGF0ZS5jb2xvck1hc2tCO1xyXG4gICAgICAgICAgICBib3VuZFN0YXRlLmNvbG9yTWFza0FscGhhID0gc3RhdGUuY29sb3JNYXNrQWxwaGE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIGJsZW5kIHN0YXRlIGFuZCBwYXJhbXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHN0YXRlIFRoZSBzdGF0ZSB0aGF0IGNvbnRhaW5zIG5ldyBibGVuZCBwYXJhbXMuXHJcbiAgICAgKi9cclxuICAgIF9zZXRCbGVuZFN0YXRlKHN0YXRlKSB7XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcclxuICAgICAgICBjb25zdCBib3VuZFN0YXRlID0gdGhpcy5fYm91bmRSZW5kZXJTdGF0ZTtcclxuICAgICAgICBpZiAoYm91bmRTdGF0ZS5ibGVuZCAhPT0gc3RhdGUuYmxlbmQpIHtcclxuICAgICAgICAgICAgdGhpcy5fc2V0Q2FwYWJpbGl0eUVuYWJsZWQoZ2wuQkxFTkQsIHN0YXRlLmJsZW5kKTtcclxuICAgICAgICAgICAgYm91bmRTdGF0ZS5ibGVuZCA9IHN0YXRlLmJsZW5kO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RhdGUuYmxlbmQpIHtcclxuICAgICAgICAgICAgaWYgKGJvdW5kU3RhdGUuYmxlbmRFcXVhdGlvblJnYiAhPT0gc3RhdGUuYmxlbmRFcXVhdGlvblJnYiB8fFxyXG4gICAgICAgICAgICAgICAgYm91bmRTdGF0ZS5ibGVuZEVxdWF0aW9uQWxwaGEgIT09IHN0YXRlLmJsZW5kRXF1YXRpb25BbHBoYSkge1xyXG4gICAgICAgICAgICAgICAgZ2wuYmxlbmRFcXVhdGlvblNlcGFyYXRlKHN0YXRlLmJsZW5kRXF1YXRpb25SZ2IsIHN0YXRlLmJsZW5kRXF1YXRpb25BbHBoYSk7XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLmJsZW5kRXF1YXRpb25SZ2IgPSBzdGF0ZS5ibGVuZEVxdWF0aW9uUmdiO1xyXG4gICAgICAgICAgICAgICAgYm91bmRTdGF0ZS5ibGVuZEVxdWF0aW9uQWxwaGEgPSBzdGF0ZS5ibGVuZEVxdWF0aW9uQWxwaGE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGJvdW5kU3RhdGUuYmxlbmRGdW5jRHN0UmdiICE9PSBzdGF0ZS5ibGVuZEZ1bmNEc3RSZ2IgfHxcclxuICAgICAgICAgICAgICAgIGJvdW5kU3RhdGUuYmxlbmRGdW5jU3JjUmdiICE9PSBzdGF0ZS5ibGVuZEZ1bmNTcmNSZ2IgfHxcclxuICAgICAgICAgICAgICAgIGJvdW5kU3RhdGUuYmxlbmRGdW5jRHN0QWxwaGEgIT09IHN0YXRlLmJsZW5kRnVuY0RzdEFscGhhIHx8XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLmJsZW5kRnVuY1NyY0FscGhhICE9PSBzdGF0ZS5ibGVuZEZ1bmNTcmNBbHBoYSkge1xyXG4gICAgICAgICAgICAgICAgZ2wuYmxlbmRGdW5jU2VwYXJhdGUoc3RhdGUuYmxlbmRGdW5jU3JjUmdiLCBzdGF0ZS5ibGVuZEZ1bmNEc3RSZ2IsIHN0YXRlLmJsZW5kRnVuY1NyY0FscGhhLCBzdGF0ZS5ibGVuZEZ1bmNEc3RBbHBoYSk7XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLmJsZW5kRnVuY1NyY1JnYiA9IHN0YXRlLmJsZW5kRnVuY1NyY1JnYjtcclxuICAgICAgICAgICAgICAgIGJvdW5kU3RhdGUuYmxlbmRGdW5jRHN0UmdiID0gc3RhdGUuYmxlbmRGdW5jRHN0UmdiO1xyXG4gICAgICAgICAgICAgICAgYm91bmRTdGF0ZS5ibGVuZEZ1bmNTcmNBbHBoYSA9IHN0YXRlLmJsZW5kRnVuY1NyY0FscGhhO1xyXG4gICAgICAgICAgICAgICAgYm91bmRTdGF0ZS5ibGVuZEZ1bmNEc3RBbHBoYSA9IHN0YXRlLmJsZW5kRnVuY0RzdEFscGhhO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIGN1bGwgZmFjZSBzdGF0ZSBhbmQgcGFyYW1zLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzdGF0ZSBUaGUgc3RhdGUgdGhhdCBjb250YWlucyBuZXcgY3VsbCBmYWNlIHN0YXRlIGFuZCBtb2RlLlxyXG4gICAgICovXHJcbiAgICBfc2V0Q3VsbEZhY2VTdGF0ZShzdGF0ZSkge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XHJcbiAgICAgICAgY29uc3QgYm91bmRTdGF0ZSA9IHRoaXMuX2JvdW5kUmVuZGVyU3RhdGU7XHJcbiAgICAgICAgaWYgKGJvdW5kU3RhdGUuY3VsbEZhY2UgIT09IHN0YXRlLmN1bGxGYWNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldENhcGFiaWxpdHlFbmFibGVkKGdsLkNVTExfRkFDRSwgc3RhdGUuY3VsbEZhY2UpO1xyXG4gICAgICAgICAgICBib3VuZFN0YXRlLmN1bGxGYWNlID0gc3RhdGUuY3VsbEZhY2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdGF0ZS5jdWxsRmFjZSAmJlxyXG4gICAgICAgICAgICBib3VuZFN0YXRlLmN1bGxGYWNlTW9kZSAhPT0gc3RhdGUuY3VsbEZhY2VNb2RlKSB7XHJcbiAgICAgICAgICAgIGdsLmN1bGxGYWNlKHN0YXRlLmN1bGxGYWNlTW9kZSk7XHJcbiAgICAgICAgICAgIGJvdW5kU3RhdGUuY3VsbEZhY2VNb2RlID0gc3RhdGUuY3VsbEZhY2VNb2RlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBmcm9udCBmYWNlIG1vZGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHN0YXRlIFRoZSBzdGF0ZSB0aGF0IGNvbnRhaW5zIG5ldyBmcm9udCBmYWNlIG1vZGUuXHJcbiAgICAgKi9cclxuICAgIF9zZXRGcm9udEZhY2VTdGF0ZShzdGF0ZSkge1xyXG4gICAgICAgIGNvbnN0IGJvdW5kU3RhdGUgPSB0aGlzLl9ib3VuZFJlbmRlclN0YXRlO1xyXG4gICAgICAgIGlmIChib3VuZFN0YXRlLmZyb250RmFjZU1vZGUgIT09IHN0YXRlLmZyb250RmFjZU1vZGUpIHtcclxuICAgICAgICAgICAgdGhpcy5fZ2wuZnJvbnRGYWNlKHN0YXRlLmZyb250RmFjZU1vZGUpO1xyXG4gICAgICAgICAgICBib3VuZFN0YXRlLmZyb250RmFjZU1vZGUgPSBzdGF0ZS5mcm9udEZhY2VNb2RlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBkZXB0aCB0ZXN0IHN0YXRlIGFuZCBwYXJhbXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHN0YXRlIFRoZSBzdGF0ZSB0aGF0IGNvbnRhaW5zIG5ldyBkZXB0aCB0ZXN0IHN0YXRlIGFuZCBwYXJhbXMuXHJcbiAgICAgKi9cclxuICAgIF9zZXREZXB0aFRlc3RTdGF0ZShzdGF0ZSkge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XHJcbiAgICAgICAgY29uc3QgYm91bmRTdGF0ZSA9IHRoaXMuX2JvdW5kUmVuZGVyU3RhdGU7XHJcbiAgICAgICAgaWYgKGJvdW5kU3RhdGUuZGVwdGhUZXN0ICE9PSBzdGF0ZS5kZXB0aFRlc3QpIHtcclxuICAgICAgICAgICAgdGhpcy5fc2V0Q2FwYWJpbGl0eUVuYWJsZWQoZ2wuREVQVEhfVEVTVCwgc3RhdGUuZGVwdGhUZXN0KTtcclxuICAgICAgICAgICAgYm91bmRTdGF0ZS5kZXB0aFRlc3QgPSBzdGF0ZS5kZXB0aFRlc3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdGF0ZS5kZXB0aFRlc3QpIHtcclxuICAgICAgICAgICAgaWYgKGJvdW5kU3RhdGUuY2xlYXJEZXB0aCAhPT0gc3RhdGUuY2xlYXJEZXB0aCkge1xyXG4gICAgICAgICAgICAgICAgZ2wuY2xlYXJEZXB0aChzdGF0ZS5jbGVhckRlcHRoKTtcclxuICAgICAgICAgICAgICAgIGJvdW5kU3RhdGUuY2xlYXJEZXB0aCA9IHN0YXRlLmNsZWFyRGVwdGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGJvdW5kU3RhdGUuZGVwdGhNYXNrICE9PSBzdGF0ZS5kZXB0aE1hc2spIHtcclxuICAgICAgICAgICAgICAgIGdsLmRlcHRoTWFzayhzdGF0ZS5kZXB0aE1hc2spO1xyXG4gICAgICAgICAgICAgICAgYm91bmRTdGF0ZS5kZXB0aE1hc2sgPSBzdGF0ZS5kZXB0aE1hc2s7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGJvdW5kU3RhdGUuZGVwdGhGdW5jICE9PSBzdGF0ZS5kZXB0aEZ1bmMpIHtcclxuICAgICAgICAgICAgICAgIGdsLmRlcHRoRnVuYyhzdGF0ZS5kZXB0aEZ1bmMpO1xyXG4gICAgICAgICAgICAgICAgYm91bmRTdGF0ZS5kZXB0aEZ1bmMgPSBzdGF0ZS5kZXB0aEZ1bmM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGJvdW5kU3RhdGUuZGVwdGhSYW5nZU5lYXIgIT09IHN0YXRlLmRlcHRoUmFuZ2VOZWFyIHx8XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLmRlcHRoUmFuZ2VGYXIgIT09IHN0YXRlLmRlcHRoUmFuZ2VGYXIpIHtcclxuICAgICAgICAgICAgICAgIGdsLmRlcHRoUmFuZ2Uoc3RhdGUuZGVwdGhSYW5nZU5lYXIsIHN0YXRlLmRlcHRoUmFuZ2VGYXIpO1xyXG4gICAgICAgICAgICAgICAgYm91bmRTdGF0ZS5kZXB0aFJhbmdlTmVhciA9IHN0YXRlLmRlcHRoUmFuZ2VOZWFyO1xyXG4gICAgICAgICAgICAgICAgYm91bmRTdGF0ZS5kZXB0aFJhbmdlRmFyID0gc3RhdGUuZGVwdGhSYW5nZUZhcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBkaXRoZXIgc3RhdGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHN0YXRlIFRoZSBzdGF0ZSB0aGF0IGNvbnRhaW5zIG5ldyBkaXRoZXIgc3RhdGUuXHJcbiAgICAgKi9cclxuICAgIF9zZXREaXRoZXJTdGF0ZShzdGF0ZSkge1xyXG4gICAgICAgIGNvbnN0IGJvdW5kU3RhdGUgPSB0aGlzLl9ib3VuZFJlbmRlclN0YXRlO1xyXG4gICAgICAgIGlmIChib3VuZFN0YXRlLmRpdGhlciAhPT0gc3RhdGUuZGl0aGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldENhcGFiaWxpdHlFbmFibGVkKHRoaXMuX2dsLkRJVEhFUiwgc3RhdGUuZGl0aGVyKTtcclxuICAgICAgICAgICAgYm91bmRTdGF0ZS5kaXRoZXIgPSBzdGF0ZS5kaXRoZXI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIGRyYXcgYnVmZmVycy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3RhdGUgVGhlIHN0YXRlIHRoYXQgY29udGFpbnMgYXJyYXkgb2YgZHJhdyBidWZmZXJzLlxyXG4gICAgICovXHJcbiAgICBfc2V0RHJhd0J1ZmZlcnNTdGF0ZShzdGF0ZSkge1xyXG4gICAgICAgIGNvbnN0IGJvdW5kRHJhd0J1ZmZlcnMgPSB0aGlzLl9ib3VuZFJlbmRlclN0YXRlLmRyYXdCdWZmZXJzO1xyXG4gICAgICAgIGlmIChib3VuZERyYXdCdWZmZXJzLmxlbmd0aCAhPT0gc3RhdGUuZHJhd0J1ZmZlcnMubGVuZ3RoIHx8XHJcbiAgICAgICAgICAgIGJvdW5kRHJhd0J1ZmZlcnNcclxuICAgICAgICAgICAgICAgIC5zb21lKChhdHRhY2htZW50LCBpKSA9PiBhdHRhY2htZW50ICE9PSBzdGF0ZS5kcmF3QnVmZmVyc1tpXSkpIHtcclxuICAgICAgICAgICAgdGhpcy5fYm91bmRSZW5kZXJTdGF0ZS5kcmF3QnVmZmVycyA9IHN0YXRlLmRyYXdCdWZmZXJzLnNsaWNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHBvbHlnb24gb2Zmc2V0IHN0YXRlIGFuZCBwYXJhbXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHN0YXRlIFRoZSBzdGF0ZSB0aGF0IGNvbnRhaW5zIG5ldyBwb2x5Z29uIG9mZnNldCBzdGF0ZSBhbmQgcGFyYW1zLlxyXG4gICAgICovXHJcbiAgICBfc2V0UG9seWdvbk9mZnNldFN0YXRlKHN0YXRlKSB7XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcclxuICAgICAgICBjb25zdCBib3VuZFN0YXRlID0gdGhpcy5fYm91bmRSZW5kZXJTdGF0ZTtcclxuICAgICAgICBpZiAoYm91bmRTdGF0ZS5wb2x5Z29uT2Zmc2V0ICE9PSBzdGF0ZS5wb2x5Z29uT2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldENhcGFiaWxpdHlFbmFibGVkKGdsLlBPTFlHT05fT0ZGU0VUX0ZJTEwsIHN0YXRlLnBvbHlnb25PZmZzZXQpO1xyXG4gICAgICAgICAgICBib3VuZFN0YXRlLnBvbHlnb25PZmZzZXQgPSBzdGF0ZS5wb2x5Z29uT2Zmc2V0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RhdGUucG9seWdvbk9mZnNldCAmJlxyXG4gICAgICAgICAgICAoYm91bmRTdGF0ZS5wb2x5Z29uT2Zmc2V0RmFjdG9yICE9PSBzdGF0ZS5wb2x5Z29uT2Zmc2V0RmFjdG9yIHx8XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLnBvbHlnb25PZmZzZXRVbml0cyAhPT0gc3RhdGUucG9seWdvbk9mZnNldFVuaXRzKSkge1xyXG4gICAgICAgICAgICBnbC5wb2x5Z29uT2Zmc2V0KHN0YXRlLnBvbHlnb25PZmZzZXRGYWN0b3IsIHN0YXRlLnBvbHlnb25PZmZzZXRVbml0cyk7XHJcbiAgICAgICAgICAgIGJvdW5kU3RhdGUucG9seWdvbk9mZnNldEZhY3RvciA9IHN0YXRlLnBvbHlnb25PZmZzZXRGYWN0b3I7XHJcbiAgICAgICAgICAgIGJvdW5kU3RhdGUucG9seWdvbk9mZnNldFVuaXRzID0gc3RhdGUucG9seWdvbk9mZnNldFVuaXRzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBhbHBoYS10by1jb3ZlcmFnZSBzdGF0ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3RhdGUgVGhlIHN0YXRlIHRoYXQgY29udGFpbnMgbmV3IGFscGhhLXRvLWNvdmVyYWdlIHN0YXRlLlxyXG4gICAgICovXHJcbiAgICBfc2V0QWxwaGFUb0NvdmVyYWdlU3RhdGUoc3RhdGUpIHtcclxuICAgICAgICBjb25zdCBib3VuZFN0YXRlID0gdGhpcy5fYm91bmRSZW5kZXJTdGF0ZTtcclxuICAgICAgICBpZiAoYm91bmRTdGF0ZS5zYW1wbGVBbHBoYVRvQ292ZXJhZ2UgIT09IHN0YXRlLnNhbXBsZUFscGhhVG9Db3ZlcmFnZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zZXRDYXBhYmlsaXR5RW5hYmxlZCh0aGlzLl9nbC5TQU1QTEVfQUxQSEFfVE9fQ09WRVJBR0UsIHN0YXRlLnNhbXBsZUFscGhhVG9Db3ZlcmFnZSk7XHJcbiAgICAgICAgICAgIGJvdW5kU3RhdGUuc2FtcGxlQWxwaGFUb0NvdmVyYWdlID0gc3RhdGUuc2FtcGxlQWxwaGFUb0NvdmVyYWdlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBzYW1wbGUgY292ZXJhZ2Ugc3RhdGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHN0YXRlIFRoZSBzdGF0ZSB0aGF0IGNvbnRhaW5zIG5ldyBzYW1wbGUgY292ZXJhZ2Ugc3RhdGUgYW5kIHBhcmFtcy5cclxuICAgICAqL1xyXG4gICAgX3NldFNhbXBsZUNvdmVyYWdlU3RhdGUoc3RhdGUpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xyXG4gICAgICAgIGNvbnN0IGJvdW5kU3RhdGUgPSB0aGlzLl9ib3VuZFJlbmRlclN0YXRlO1xyXG4gICAgICAgIGlmIChib3VuZFN0YXRlLnNhbXBsZUNvdmVyYWdlICE9PSBzdGF0ZS5zYW1wbGVDb3ZlcmFnZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zZXRDYXBhYmlsaXR5RW5hYmxlZChnbC5TQU1QTEVfQ09WRVJBR0UsIHN0YXRlLnNhbXBsZUNvdmVyYWdlKTtcclxuICAgICAgICAgICAgYm91bmRTdGF0ZS5zYW1wbGVDb3ZlcmFnZSA9IHN0YXRlLnNhbXBsZUNvdmVyYWdlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RhdGUuc2FtcGxlQ292ZXJhZ2UgJiZcclxuICAgICAgICAgICAgKGJvdW5kU3RhdGUuc2FtcGxlQ292ZXJhZ2VWYWx1ZSAhPT0gc3RhdGUuc2FtcGxlQ292ZXJhZ2VWYWx1ZSB8fFxyXG4gICAgICAgICAgICAgICAgYm91bmRTdGF0ZS5zYW1wbGVDb3ZlcmFnZUludmVydCAhPT0gc3RhdGUuc2FtcGxlQ292ZXJhZ2VJbnZlcnQpKSB7XHJcbiAgICAgICAgICAgIGdsLnNhbXBsZUNvdmVyYWdlKHN0YXRlLnNhbXBsZUNvdmVyYWdlVmFsdWUsIHN0YXRlLnNhbXBsZUNvdmVyYWdlSW52ZXJ0KTtcclxuICAgICAgICAgICAgYm91bmRTdGF0ZS5zYW1wbGVDb3ZlcmFnZVZhbHVlID0gc3RhdGUuc2FtcGxlQ292ZXJhZ2VWYWx1ZTtcclxuICAgICAgICAgICAgYm91bmRTdGF0ZS5zYW1wbGVDb3ZlcmFnZUludmVydCA9IHN0YXRlLnNhbXBsZUNvdmVyYWdlSW52ZXJ0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBzdGVuY2lsIHRlc3Qgc3RhdGUgYW5kIHBhcmFtcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3RhdGUgVGhlIHN0YXRlIHRoYXQgY29udGFpbnMgbmV3IHN0ZW5jaWwgdGVzdCBzdGF0ZSBhbmQgcGFyYW1zLlxyXG4gICAgICovXHJcbiAgICBfc2V0U3RlbmNpbFRlc3RTdGF0ZShzdGF0ZSkge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XHJcbiAgICAgICAgY29uc3QgYm91bmRTdGF0ZSA9IHRoaXMuX2JvdW5kUmVuZGVyU3RhdGU7XHJcbiAgICAgICAgaWYgKGJvdW5kU3RhdGUuc3RlbmNpbFRlc3QgIT09IHN0YXRlLnN0ZW5jaWxUZXN0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldENhcGFiaWxpdHlFbmFibGVkKGdsLlNURU5DSUxfVEVTVCwgc3RhdGUuc3RlbmNpbFRlc3QpO1xyXG4gICAgICAgICAgICBib3VuZFN0YXRlLnN0ZW5jaWxUZXN0ID0gc3RhdGUuc3RlbmNpbFRlc3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdGF0ZS5zdGVuY2lsVGVzdCkge1xyXG4gICAgICAgICAgICBpZiAoYm91bmRTdGF0ZS5jbGVhclN0ZW5jaWwgIT09IHN0YXRlLmNsZWFyU3RlbmNpbCkge1xyXG4gICAgICAgICAgICAgICAgZ2wuY2xlYXJTdGVuY2lsKHN0YXRlLmNsZWFyU3RlbmNpbCk7XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLmNsZWFyU3RlbmNpbCA9IHN0YXRlLmNsZWFyU3RlbmNpbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYm91bmRTdGF0ZS5zdGVuY2lsV3JpdGVNYXNrICE9PSBzdGF0ZS5zdGVuY2lsV3JpdGVNYXNrKSB7XHJcbiAgICAgICAgICAgICAgICBnbC5zdGVuY2lsTWFzayhzdGF0ZS5zdGVuY2lsV3JpdGVNYXNrKTtcclxuICAgICAgICAgICAgICAgIGJvdW5kU3RhdGUuc3RlbmNpbFdyaXRlTWFzayA9IHN0YXRlLnN0ZW5jaWxXcml0ZU1hc2s7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgcmVmT3JNYXNrSXNEaWZmZXJlbnQgPSAoYm91bmRTdGF0ZS5zdGVuY2lsTWFzayAhPT0gc3RhdGUuc3RlbmNpbE1hc2sgfHxcclxuICAgICAgICAgICAgICAgIGJvdW5kU3RhdGUuc3RlbmNpbFJlZmVyZW5jZSAhPT0gc3RhdGUuc3RlbmNpbFJlZmVyZW5jZSk7XHJcbiAgICAgICAgICAgIGlmIChyZWZPck1hc2tJc0RpZmZlcmVudCkge1xyXG4gICAgICAgICAgICAgICAgYm91bmRTdGF0ZS5zdGVuY2lsTWFzayA9IHN0YXRlLnN0ZW5jaWxNYXNrO1xyXG4gICAgICAgICAgICAgICAgYm91bmRTdGF0ZS5zdGVuY2lsUmVmZXJlbmNlID0gc3RhdGUuc3RlbmNpbFJlZmVyZW5jZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYm91bmRTdGF0ZS5zdGVuY2lsRnJvbnRGdW5jICE9PSBzdGF0ZS5zdGVuY2lsRnJvbnRGdW5jIHx8XHJcbiAgICAgICAgICAgICAgICByZWZPck1hc2tJc0RpZmZlcmVudCkge1xyXG4gICAgICAgICAgICAgICAgZ2wuc3RlbmNpbEZ1bmNTZXBhcmF0ZShnbC5GUk9OVCwgc3RhdGUuc3RlbmNpbEZyb250RnVuYywgc3RhdGUuc3RlbmNpbFJlZmVyZW5jZSwgc3RhdGUuc3RlbmNpbE1hc2spO1xyXG4gICAgICAgICAgICAgICAgYm91bmRTdGF0ZS5zdGVuY2lsRnJvbnRGdW5jID0gc3RhdGUuc3RlbmNpbEZyb250RnVuYztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYm91bmRTdGF0ZS5zdGVuY2lsQmFja0Z1bmMgIT09IHN0YXRlLnN0ZW5jaWxCYWNrRnVuYyB8fFxyXG4gICAgICAgICAgICAgICAgcmVmT3JNYXNrSXNEaWZmZXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIGdsLnN0ZW5jaWxGdW5jU2VwYXJhdGUoZ2wuQkFDSywgc3RhdGUuc3RlbmNpbEJhY2tGdW5jLCBzdGF0ZS5zdGVuY2lsUmVmZXJlbmNlLCBzdGF0ZS5zdGVuY2lsTWFzayk7XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLnN0ZW5jaWxCYWNrRnVuYyA9IHN0YXRlLnN0ZW5jaWxCYWNrRnVuYztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYm91bmRTdGF0ZS5zdGVuY2lsRnJvbnRGYWlsT3AgIT09IHN0YXRlLnN0ZW5jaWxGcm9udEZhaWxPcCB8fFxyXG4gICAgICAgICAgICAgICAgYm91bmRTdGF0ZS5zdGVuY2lsRnJvbnREZXB0aEZhaWxPcCAhPT0gc3RhdGUuc3RlbmNpbEZyb250RGVwdGhGYWlsT3AgfHxcclxuICAgICAgICAgICAgICAgIGJvdW5kU3RhdGUuc3RlbmNpbEZyb250RGVwdGhQYXNzT3AgIT09IHN0YXRlLnN0ZW5jaWxGcm9udERlcHRoUGFzc09wKSB7XHJcbiAgICAgICAgICAgICAgICBnbC5zdGVuY2lsT3BTZXBhcmF0ZShnbC5GUk9OVCwgc3RhdGUuc3RlbmNpbEZyb250RmFpbE9wLCBzdGF0ZS5zdGVuY2lsRnJvbnREZXB0aEZhaWxPcCwgc3RhdGUuc3RlbmNpbEZyb250RGVwdGhQYXNzT3ApO1xyXG4gICAgICAgICAgICAgICAgYm91bmRTdGF0ZS5zdGVuY2lsRnJvbnRGYWlsT3AgPSBzdGF0ZS5zdGVuY2lsRnJvbnRGYWlsT3A7XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLnN0ZW5jaWxGcm9udERlcHRoRmFpbE9wID0gc3RhdGUuc3RlbmNpbEZyb250RGVwdGhGYWlsT3A7XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLnN0ZW5jaWxGcm9udERlcHRoUGFzc09wID0gc3RhdGUuc3RlbmNpbEZyb250RGVwdGhQYXNzT3A7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGJvdW5kU3RhdGUuc3RlbmNpbEJhY2tGYWlsT3AgIT09IHN0YXRlLnN0ZW5jaWxCYWNrRmFpbE9wIHx8XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLnN0ZW5jaWxCYWNrRGVwdGhGYWlsT3AgIT09IHN0YXRlLnN0ZW5jaWxCYWNrRGVwdGhGYWlsT3AgfHxcclxuICAgICAgICAgICAgICAgIGJvdW5kU3RhdGUuc3RlbmNpbEJhY2tEZXB0aFBhc3NPcCAhPT0gc3RhdGUuc3RlbmNpbEJhY2tEZXB0aFBhc3NPcCkge1xyXG4gICAgICAgICAgICAgICAgZ2wuc3RlbmNpbE9wU2VwYXJhdGUoZ2wuQkFDSywgc3RhdGUuc3RlbmNpbEJhY2tGYWlsT3AsIHN0YXRlLnN0ZW5jaWxCYWNrRGVwdGhGYWlsT3AsIHN0YXRlLnN0ZW5jaWxCYWNrRGVwdGhQYXNzT3ApO1xyXG4gICAgICAgICAgICAgICAgYm91bmRTdGF0ZS5zdGVuY2lsQmFja0ZhaWxPcCA9IHN0YXRlLnN0ZW5jaWxCYWNrRmFpbE9wO1xyXG4gICAgICAgICAgICAgICAgYm91bmRTdGF0ZS5zdGVuY2lsQmFja0RlcHRoRmFpbE9wID0gc3RhdGUuc3RlbmNpbEJhY2tEZXB0aEZhaWxPcDtcclxuICAgICAgICAgICAgICAgIGJvdW5kU3RhdGUuc3RlbmNpbEJhY2tEZXB0aFBhc3NPcCA9IHN0YXRlLnN0ZW5jaWxCYWNrRGVwdGhQYXNzT3A7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgc2Npc3NvciB0ZXN0IHN0YXRlIGFuZCBzY2lzc29yIHJlY3RhbmdsZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3RhdGUgVGhlIHN0YXRlIHRoYXQgY29udGFpbnMgbmV3IHNjaXNzb3IgdGVzdCBzdGF0ZSBhbmQgc2Npc3NvclxyXG4gICAgICogICAgICByZWN0YW5nbGUuXHJcbiAgICAgKi9cclxuICAgIF9zZXRTY2lzc29yVGVzdFN0YXRlKHN0YXRlKSB7XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcclxuICAgICAgICBjb25zdCBib3VuZFN0YXRlID0gdGhpcy5fYm91bmRSZW5kZXJTdGF0ZTtcclxuICAgICAgICBpZiAoYm91bmRTdGF0ZS5zY2lzc29yVGVzdCAhPT0gc3RhdGUuc2Npc3NvclRlc3QpIHtcclxuICAgICAgICAgICAgdGhpcy5fc2V0Q2FwYWJpbGl0eUVuYWJsZWQoZ2wuU0NJU1NPUl9URVNULCBzdGF0ZS5zY2lzc29yVGVzdCk7XHJcbiAgICAgICAgICAgIGJvdW5kU3RhdGUuc2Npc3NvclRlc3QgPSBzdGF0ZS5zY2lzc29yVGVzdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0YXRlLnNjaXNzb3JUZXN0ICYmXHJcbiAgICAgICAgICAgIHN0YXRlLnNjaXNzb3JXaWR0aCA+PSAwICYmXHJcbiAgICAgICAgICAgIHN0YXRlLnNjaXNzb3JIZWlnaHQgPj0gMCAmJlxyXG4gICAgICAgICAgICAoYm91bmRTdGF0ZS5zY2lzc29yWCAhPT0gc3RhdGUuc2Npc3NvclggfHxcclxuICAgICAgICAgICAgICAgIGJvdW5kU3RhdGUuc2Npc3NvclkgIT09IHN0YXRlLnNjaXNzb3JZIHx8XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLnNjaXNzb3JXaWR0aCAhPT0gc3RhdGUuc2Npc3NvcldpZHRoIHx8XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLnNjaXNzb3JIZWlnaHQgIT09IHN0YXRlLnNjaXNzb3JIZWlnaHQpKSB7XHJcbiAgICAgICAgICAgIGdsLnNjaXNzb3Ioc3RhdGUuc2Npc3NvclgsIHN0YXRlLnNjaXNzb3JZLCBzdGF0ZS5zY2lzc29yV2lkdGgsIHN0YXRlLnNjaXNzb3JIZWlnaHQpO1xyXG4gICAgICAgICAgICBib3VuZFN0YXRlLnNjaXNzb3JYID0gc3RhdGUuc2Npc3Nvclg7XHJcbiAgICAgICAgICAgIGJvdW5kU3RhdGUuc2Npc3NvclkgPSBzdGF0ZS5zY2lzc29yWTtcclxuICAgICAgICAgICAgYm91bmRTdGF0ZS5zY2lzc29yV2lkdGggPSBzdGF0ZS5zY2lzc29yV2lkdGg7XHJcbiAgICAgICAgICAgIGJvdW5kU3RhdGUuc2Npc3NvckhlaWdodCA9IHN0YXRlLnNjaXNzb3JIZWlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHZpZXdwb3J0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzdGF0ZSBUaGUgc3RhdGUgdGhhdCBjb250YWlucyBuZXcgdmlld3BvcnQuXHJcbiAgICAgKi9cclxuICAgIF9zZXRWaWV3cG9ydFN0YXRlKHN0YXRlKSB7XHJcbiAgICAgICAgY29uc3QgYm91bmRTdGF0ZSA9IHRoaXMuX2JvdW5kUmVuZGVyU3RhdGU7XHJcbiAgICAgICAgaWYgKHN0YXRlLnZpZXdwb3J0V2lkdGggPj0gMCAmJlxyXG4gICAgICAgICAgICBzdGF0ZS52aWV3cG9ydEhlaWdodCA+PSAwICYmXHJcbiAgICAgICAgICAgIChib3VuZFN0YXRlLnZpZXdwb3J0WCAhPT0gc3RhdGUudmlld3BvcnRYIHx8XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLnZpZXdwb3J0WSAhPT0gc3RhdGUudmlld3BvcnRZIHx8XHJcbiAgICAgICAgICAgICAgICBib3VuZFN0YXRlLnZpZXdwb3J0V2lkdGggIT09IHN0YXRlLnZpZXdwb3J0V2lkdGggfHxcclxuICAgICAgICAgICAgICAgIGJvdW5kU3RhdGUudmlld3BvcnRIZWlnaHQgIT09IHN0YXRlLnZpZXdwb3J0SGVpZ2h0KSkge1xyXG4gICAgICAgICAgICB0aGlzLl9nbC52aWV3cG9ydChzdGF0ZS52aWV3cG9ydFgsIHN0YXRlLnZpZXdwb3J0WSwgc3RhdGUudmlld3BvcnRXaWR0aCwgc3RhdGUudmlld3BvcnRIZWlnaHQpO1xyXG4gICAgICAgICAgICBib3VuZFN0YXRlLnZpZXdwb3J0WCA9IHN0YXRlLnZpZXdwb3J0WDtcclxuICAgICAgICAgICAgYm91bmRTdGF0ZS52aWV3cG9ydFkgPSBzdGF0ZS52aWV3cG9ydFk7XHJcbiAgICAgICAgICAgIGJvdW5kU3RhdGUudmlld3BvcnRXaWR0aCA9IHN0YXRlLnZpZXdwb3J0V2lkdGg7XHJcbiAgICAgICAgICAgIGJvdW5kU3RhdGUudmlld3BvcnRIZWlnaHQgPSBzdGF0ZS52aWV3cG9ydEhlaWdodDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGV4dHVyZSBkYXRhIHVucGFjayBwYXJhbXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBhcmFtcyBUZXh0dXJlIHBhcmFtcyB0byBiZSBzZXQuXHJcbiAgICAgKi9cclxuICAgIF9zZXRUZXh0dXJlRGF0YVVucGFja1BhcmFtcyhwYXJhbXMpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xyXG4gICAgICAgIGlmICh0aGlzLl91bnBhY2tQcmVtdWx0aXBseUFscGhhICE9PSBwYXJhbXMucHJlbXVsdGlwbGllZEFscGhhKSB7XHJcbiAgICAgICAgICAgIGdsLnBpeGVsU3RvcmVpKDM3NDQxIC8qIFVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCAqLywgK3BhcmFtcy5wcmVtdWx0aXBsaWVkQWxwaGEpO1xyXG4gICAgICAgICAgICB0aGlzLl91bnBhY2tQcmVtdWx0aXBseUFscGhhID0gcGFyYW1zLnByZW11bHRpcGxpZWRBbHBoYTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfb25UZXh0dXJlRGF0YVVwZGF0ZWQodGV4dHVyZSkge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XHJcbiAgICAgICAgY29uc3QgcGFyYW1zID0gdGV4dHVyZS5nZXRQYXJhbXMoKTtcclxuICAgICAgICBpZiAocGFyYW1zLm1pbmlmaWNhdGlvbkZpbHRlciA+PSA5OTg0IC8qIE5FQVJFU1RfTUlQTUFQX05FQVJFU1QgKi8pIHtcclxuICAgICAgICAgICAgZ2wuZ2VuZXJhdGVNaXBtYXAoZ2wuVEVYVFVSRV8yRCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHplcm9lZCBidWZmZXIgd2l0aCBhIGdpdmVuIHNpemUgYW5kIGEgdGFyZ2V0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0YXJnZXQgVGhlIHRhcmdldCBvZiB0aGUgbmV3IGJ1ZmZlciwgYEFSUkFZX0JVRkZFUmAgb3JcclxuICAgICAqICAgICAgYEVMRU1FTlRfQVJSQVlfQlVGRkVSYC5cclxuICAgICAqIEBwYXJhbSBzaXplIFRoZSBzaXplIG9mIHRoZSBidWZmZXIuXHJcbiAgICAgKiBAcGFyYW0gdXNhZ2UgVXNhZ2Ugb2YgdGhlIGJ1ZmZlci5cclxuICAgICAqIEByZXR1cm5zIFRoZSBidWZmZXIuXHJcbiAgICAgKi9cclxuICAgIF9jcmVhdGVCdWZmZXIodGFyZ2V0LCBzaXplLCB1c2FnZSA9IHRoaXMuX2dsLlNUQVRJQ19EUkFXKSB7XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcclxuICAgICAgICBjb25zdCBidWZmZXIgPSBuZXcgQnVmZmVyKGdsLCB0YXJnZXQsIHNpemUpO1xyXG4gICAgICAgIC8vIFRPRE8oZG1pa2lzKSBhIGNsZXZlcmVyIHdheSBub3QgdG8gYnJlYWsgY3VycmVudGx5IGJvdW5kIFZBTztcclxuICAgICAgICB0aGlzLmJpbmRWYW8obnVsbCk7XHJcbiAgICAgICAgYnVmZmVyLmJpbmQoKTtcclxuICAgICAgICBnbC5idWZmZXJEYXRhKHRhcmdldCwgc2l6ZSwgdXNhZ2UpO1xyXG4gICAgICAgIHJldHVybiBidWZmZXI7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL2NvbnRleHQudHNcbi8vIG1vZHVsZSBpZCA9IDU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiBDaGVja3MgaWYgYSBudW1iZXIgaXMgYSBwb3dlciBvZiAyLlxyXG4gKlxyXG4gKiBAcGFyYW0geCBUaGUgbnVtYmVyIHRvIGNoZWNrLlxyXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG51bWJlciBpcyBhbiBpbnRlZ2VyIHBvd2VyIG9mIDIgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzUG93T2YyKHgpIHtcclxuICAgIHJldHVybiB4ID4gMCAmJiAhKHggJiAoeCAtIDEpKTtcclxufVxyXG4vKipcclxuICogQWxpZ25zIGFuIG9mZnNldCBieSBhbiBhbGlnbm1lbnQgZ2l2ZW4gYnkgYSBtYXNrLlxyXG4gKlxyXG4gKiBAcGFyYW0gb2Zmc2V0IFRoZSBvZmZzZXQuXHJcbiAqIEBwYXJhbSBhbGlnbm1lbnRNYXNrIFRoZSBhbGlnbm1lbnQgbWFzayDigJQgYSBiaXQgZmllbGQgdGhhdCBoYXMgYGxvZzIoYWxpZ25tZW50KWBcclxuICogICAgICBvZiBsZWFzdCBzaWduaWZpY2FudCBiaXRzIHVuc2V0IGFuZCBvdGhlciBzZXQsIGUuZy4gaWYgYGFsaWdubWVudGAgaXMgNFxyXG4gKiAgICAgIHRoZW4gdGhlIGBhbGlnbm1lbnRNYXNrYCB3aWxsIGJlIGAweGZmZmZmZmNgXHJcbiAqIEByZXR1cm5zIEFsaWduZWQgb2Zmc2V0LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGFsaWduKG9mZnNldCwgYWxpZ25tZW50TWFzaykge1xyXG4gICAgcmV0dXJuIChvZmZzZXQgLSAxICYgYWxpZ25tZW50TWFzaykgLSBhbGlnbm1lbnRNYXNrO1xyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvcG93X29mXzIudHNcbi8vIG1vZHVsZSBpZCA9IDU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKiBXcmFwcGVyIGFyb3VuZCBXZWJHTEJ1ZmZlciBvYmplY3QuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJ1ZmZlciB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgZW1wdHkgYnVmZmVyIGluIGEgV2ViR0wgY29udGV4dC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZ2wgVGhlIGNvbnRleHQgdGhlIGJ1ZmZlciB3aWxsIGJlIGNyZWF0ZWQgaW4uXHJcbiAgICAgKiBAcGFyYW0gdGFyZ2V0IEJpbmRpbmcgdGFyZ2V0IG9mIHRoZSBidWZmZXIuIFNpbmNlIGluIFdlYkdMIG9uY2UgeW91J3ZlXHJcbiAgICAgKiAgICAgIGJvdW5kIGEgYnVmZmVyIHRvIGEgZ2l2ZW4gdGFyZ2V0IHlvdSBjYW4ndCBiaW5kIGl0IGFueSBvdGhlciBvbmUsXHJcbiAgICAgKiAgICAgIHdlIFwidGllXCIgdGhlIGJ1ZmZlciBhbmQgaXQncyBiaW5kaW5nIHBvaW50IHRvZ2V0aGVyLlxyXG4gICAgICogQHBhcmFtIHNpemUgU2l6ZSBvZiB0aGUgYnVmZmVyLiBXZSBkb24ndCBkbyBhY3R1YWwgYWxsb2NhdGlvbiBpbiB0aGVcclxuICAgICAqICAgICAgd3JhcHBlciwgaXQncyBjb250ZXh0J3MgcmVzcG9uc2liaWxpdHkuIEJ1dCBpdCdzIGNvbnZlbmllbnQgdG8gYmVcclxuICAgICAqICAgICAgYWJsZSB0byBnZXQgdGhlIHNpemUgZnJvbSB0aGUgd3JhcHBlciBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGdsLCB0YXJnZXQsIHNpemUpIHtcclxuICAgICAgICB0aGlzLl9nbCA9IGdsO1xyXG4gICAgICAgIHRoaXMuX3RhcmdldCA9IHRhcmdldDtcclxuICAgICAgICB0aGlzLl9oYW5kbGUgPSBnbC5jcmVhdGVCdWZmZXIoKTtcclxuICAgICAgICB0aGlzLl9zaXplID0gc2l6ZTtcclxuICAgIH1cclxuICAgIC8qKiBCaW5kcyB0aGUgYnVmZmVyIHRvIHRoZSBjb250ZXh0IHRvIGl0cyBiaW5kaW5nIHRhcmdldC4gKi9cclxuICAgIGJpbmQoKSB7XHJcbiAgICAgICAgdGhpcy5fZ2wuYmluZEJ1ZmZlcih0aGlzLl90YXJnZXQsIHRoaXMuX2hhbmRsZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBidWZmZXIgaXMgY3VycmVudGx5IGJvdW5kIHRvIHRoZSBjb250ZXh0IHRvIGl0c1xyXG4gICAgICogYmluZGluZyB0YXJnZXQgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxyXG4gICAgICovXHJcbiAgICBpc0JvdW5kKCkge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XHJcbiAgICAgICAgY29uc3QgaGFuZGxlID0gdGhpcy5faGFuZGxlO1xyXG4gICAgICAgIHN3aXRjaCAodGhpcy5fdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIGNhc2UgZ2wuQVJSQVlfQlVGRkVSOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdsLmdldFBhcmFtZXRlcihnbC5BUlJBWV9CVUZGRVJfQklORElORykgPT09IGhhbmRsZTtcclxuICAgICAgICAgICAgY2FzZSBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBnbC5nZXRQYXJhbWV0ZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVJfQklORElORykgPT09IGhhbmRsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqIFJldHVybnMgYmluZGluZyB0YXJnZXQgb2YgdGhlIGJ1ZmZlci4gKi9cclxuICAgIGdldFRhcmdldCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdGFyZ2V0O1xyXG4gICAgfVxyXG4gICAgLyoqIFJldHVybnMgc2l6ZSBvZiB0aGUgYnVmZmVyLiAqL1xyXG4gICAgZ2V0U2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGVzdHJveXMgdGhlIGJ1ZmZlci5cclxuICAgICAqL1xyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLl9nbC5kZWxldGVCdWZmZXIodGhpcy5faGFuZGxlKTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvZ2wvYnVmZmVyLnRzXG4vLyBtb2R1bGUgaWQgPSA1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiogV3JhcHBlciBhcm91bmQgV2ViR0xGcmFtZWJ1ZmZlciBvYmplY3QuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZyYW1lYnVmZmVyIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBmcmFtZWJ1ZmZlciBpbiBhIFdlYkdMIGNvbnRleHQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGdsIFRoZSBjb250ZXh0IHRoZSBmcmFtZWJ1ZmZlciB3aWxsIGJlIGNyZWF0ZWQgaW4uXHJcbiAgICAgKiBAcGFyYW0gd2lkdGggV2lkdGggb2YgdGhlIGZyYW1lYnVmZmVyLlxyXG4gICAgICogQHBhcmFtIGhlaWdodCBIZWlnaHQgb2YgdGhlIGZyYW1lYnVmZmVyLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihnbCwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIHRoaXMuaXNDbGVhciA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2dsID0gZ2w7XHJcbiAgICAgICAgdGhpcy5faGFuZGxlID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcclxuICAgICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQmluZHMgdGhlIGZyYW1lYnVmZmVyIHRvIHRoZSBXZWJHTCBjb250ZXh0LlxyXG4gICAgICovXHJcbiAgICBiaW5kKCkge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XHJcbiAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLl9oYW5kbGUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgdGhlIGZyYW1lYnVmZmVyIGlzIGJvdW5kIHRvIHRoZSBXZWJHTCBjb250ZXh0LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgZnJhbWVidWZmZXIgaXMgY3VycmVudGx5IGJvdW5kIHRvIHRoZSBXZWJHTCBjb250ZXh0XHJcbiAgICAgKiAgICAgIGFuZCBgZmFsc2VgIG90aGVyd2lzZS5cclxuICAgICAqL1xyXG4gICAgaXNCb3VuZCgpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xyXG4gICAgICAgIHJldHVybiBnbC5nZXRQYXJhbWV0ZXIoZ2wuRlJBTUVCVUZGRVJfQklORElORykgPT09IHRoaXMuX2hhbmRsZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB3aWR0aCBvZiB0aGUgZnJhbWVidWZmZXIuXHJcbiAgICAgKi9cclxuICAgIGdldFdpZHRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl93aWR0aDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBoZWlnaHQgb2YgdGhlIGZyYW1lYnVmZmVyLlxyXG4gICAgICovXHJcbiAgICBnZXRIZWlnaHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlaWdodDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgY29udGVudCBvZiB0aGUgY29sb3IgYXR0YWNobWVudCBhcyBhbiBSR0JBIGJpdG1hcC5cclxuICAgICAqL1xyXG4gICAgcmVhZFBpeGVscygpIHtcclxuICAgICAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5nZXRXaWR0aCgpICogdGhpcy5nZXRIZWlnaHQoKSAqIDQpO1xyXG4gICAgICAgIHRoaXMuX2dsLnJlYWRQaXhlbHMoMCwgMCwgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCwgNjQwOCAvKiBSR0JBICovLCA1MTIxIC8qIFVOU0lHTkVEX0JZVEUgKi8sIGRhdGEpO1xyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXN0cm95cyB0aGUgZnJhbWVidWZmZXIuXHJcbiAgICAgKi9cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5fZ2wuZGVsZXRlRnJhbWVidWZmZXIodGhpcy5faGFuZGxlKTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvZ2wvZnJhbWVidWZmZXIudHNcbi8vIG1vZHVsZSBpZCA9IDU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiBJbnNlcnRzIGdpdmVuIHBhcmFtZXRlcnMgYXMgcHJlcHJvY2Vzc29yIGRlZmluZSBkaXJlY3RpdmVzIGludG8gc2hhZGVyIHNvdXJjZS5cclxuICpcclxuICogQHBhcmFtIHNvdXJjZSBTaGFkZXIgc291cmNlLlxyXG4gKiBAcGFyYW0gZGVmaW5lcyBEaWN0aW9uYXJ5IHdpdGggcGFyYW1ldGVycyB0byBkZWZpbmUgd2l0aCBwcmVwcm9jZXNzb3IgZGlyZWN0aXZlcy5cclxuICogQHJldHVybnMgU2hhZGVyIHNvdXJjZSB3aXRoIHByZXByb2Nlc3NvciBkaXJlY3RpdmVzIGluc2VydGVkLlxyXG4gKi9cclxuZnVuY3Rpb24gaW5zZXJ0RGVmaW5lcyhzb3VyY2UsIGRlZmluZXMpIHtcclxuICAgIGNvbnN0IGRlZmluZXNTdHJpbmcgPSBPYmplY3Qua2V5cyhkZWZpbmVzKVxyXG4gICAgICAgIC5tYXAoKGRlZmluZU5hbWUpID0+ICcjZGVmaW5lICcgKyBkZWZpbmVOYW1lICsgJyAnICtcclxuICAgICAgICBkZWZpbmVzW2RlZmluZU5hbWVdKVxyXG4gICAgICAgIC5qb2luKCdcXG4nKTtcclxuICAgIGNvbnN0IHZlcnNpb25JZHggPSBzb3VyY2UuaW5kZXhPZignI3ZlcnNpb24nKTtcclxuICAgIGlmICh2ZXJzaW9uSWR4ID09PSAtMSkge1xyXG4gICAgICAgIHJldHVybiBkZWZpbmVzU3RyaW5nICsgJ1xcbicgKyBzb3VyY2U7XHJcbiAgICB9XHJcbiAgICBjb25zdCBuZXh0TGluZUlkeCA9IHNvdXJjZS5pbmRleE9mKCdcXG4nLCB2ZXJzaW9uSWR4KSArIDE7XHJcbiAgICByZXR1cm4gc291cmNlLnNsaWNlKDAsIG5leHRMaW5lSWR4KSArIGRlZmluZXNTdHJpbmcgKyAnXFxuJyArXHJcbiAgICAgICAgc291cmNlLnNsaWNlKG5leHRMaW5lSWR4KTtcclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBzaGFkZXIgb2YgYSBnaXZlbiB0eXBlIG91dCBvZiBhIGdpdmVuIHNvdXJjZSBzdHJpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSBnbCBXZWJHTCBjb250ZXh0IHRoZSBzaGFkZXIgd2lsbCBiZSBjcmVhdGVkIGluLlxyXG4gKiBAcGFyYW0gdHlwZSBUaGUgdHlwZSBvZiB0aGUgc2hhZGVyLCBWRVJURVhfU0hBREVSIG9yIEZSQUdNRU5UX1NIQURFUi5cclxuICogQHBhcmFtIHNvdXJjZSBUaGUgc291cmNlIHN0cmluZy5cclxuICogQHRocm93cyBBbiBlcnJvciBpZiBjb21waWxhdGlvbiBvZiB0aGUgc2hhZGVyIGZhaWxzLlxyXG4gKiBAcmV0dXJucyBUaGUgc2hhZGVyIFdlYkdMIGhhbmRsZS5cclxuICovXHJcbmZ1bmN0aW9uIGNvbXBpbGVTaGFkZXIoZ2wsIHR5cGUsIHNvdXJjZSkge1xyXG4gICAgY29uc3Qgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHR5cGUpO1xyXG4gICAgZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc291cmNlKTtcclxuICAgIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcclxuICAgIC8vIFRPRE8gVW5jb21tZW50IGFuZCBwdXQgdW5kZXIgZGVidWcgZmxhZyAod2hlbiBpbXBsZW1lbnRlZClcclxuICAgIGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gY29tcGlsZSBzaGFkZXI6XFxuJyArIGdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc2hhZGVyO1xyXG59XHJcbi8qKiBXcmFwcGVyIGFyb3VuZCBXZWJHTFByb2dyYW0gb2JqZWN0cy4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJvZ3JhbSB7XHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgcHJvZ3JhbS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZ2wgV2ViR0wgY29udGV4dCB0aGUgcHJvZ3JhbSB3aWxsIGJlIGNyZWF0ZWQgaW4uXHJcbiAgICAgKiBAcGFyYW0gdmVydGV4U2hhZGVyU291cmNlIFNvdXJjZSBjb2RlIG9mIHZlcnRleCBzaGFkZXIgb2YgdGhlIHByb2dyYW0uXHJcbiAgICAgKiBAcGFyYW0gZnJhZ21lbnRTaGFkZXJTb3VyY2UgU291cmNlIGNvZGUgb2YgZnJhZ21lbnQgc2hhZGVyIG9mIHRoZSBwcm9ncmFtLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucy5cclxuICAgICAqIEB0aHJvd3MgQW4gZXJyb3IgaWYgc2hhZGVyIGNvbXBpbGF0aW9uIG9yIHByb2dyYW0gbGlua2luZyBmYWlscy5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZ2wsIHZlcnRleFNoYWRlclNvdXJjZSwgZnJhZ21lbnRTaGFkZXJTb3VyY2UsIG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLl9nbCA9IGdsO1xyXG4gICAgICAgIGNvbnN0IGhhbmRsZSA9IHRoaXMuX2hhbmRsZSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcclxuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmRlZmluZXMpIHtcclxuICAgICAgICAgICAgdmVydGV4U2hhZGVyU291cmNlID0gaW5zZXJ0RGVmaW5lcyh2ZXJ0ZXhTaGFkZXJTb3VyY2UsIG9wdGlvbnMuZGVmaW5lcyk7XHJcbiAgICAgICAgICAgIGZyYWdtZW50U2hhZGVyU291cmNlID0gaW5zZXJ0RGVmaW5lcyhmcmFnbWVudFNoYWRlclNvdXJjZSwgb3B0aW9ucy5kZWZpbmVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdmVydGV4U2hhZGVyID0gY29tcGlsZVNoYWRlcihnbCwgZ2wuVkVSVEVYX1NIQURFUiwgdmVydGV4U2hhZGVyU291cmNlKTtcclxuICAgICAgICBjb25zdCBmcmFnbWVudFNoYWRlciA9IGNvbXBpbGVTaGFkZXIoZ2wsIGdsLkZSQUdNRU5UX1NIQURFUiwgZnJhZ21lbnRTaGFkZXJTb3VyY2UpO1xyXG4gICAgICAgIGdsLmF0dGFjaFNoYWRlcihoYW5kbGUsIHZlcnRleFNoYWRlcik7XHJcbiAgICAgICAgZ2wuYXR0YWNoU2hhZGVyKGhhbmRsZSwgZnJhZ21lbnRTaGFkZXIpO1xyXG4gICAgICAgIGdsLmRlbGV0ZVNoYWRlcih2ZXJ0ZXhTaGFkZXIpO1xyXG4gICAgICAgIGdsLmRlbGV0ZVNoYWRlcihmcmFnbWVudFNoYWRlcik7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hdHRyaWJNYXApIHtcclxuICAgICAgICAgICAgT2JqZWN0LmtleXMob3B0aW9ucy5hdHRyaWJNYXApXHJcbiAgICAgICAgICAgICAgICAuZm9yRWFjaCgoYXR0cmlidXRlTmFtZSkgPT4gZ2wuYmluZEF0dHJpYkxvY2F0aW9uKGhhbmRsZSwgb3B0aW9ucy5hdHRyaWJNYXBbYXR0cmlidXRlTmFtZV0sIGF0dHJpYnV0ZU5hbWUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2wubGlua1Byb2dyYW0oaGFuZGxlKTtcclxuICAgICAgICAvLyBUT0RPIFVuY29tbWVudCBhbmQgcHV0IHVuZGVyIGRlYnVnIGZsYWcgKHdoZW4gaW1wbGVtZW50ZWQpXHJcbiAgICAgICAgaWYgKCFnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKGhhbmRsZSwgZ2wuTElOS19TVEFUVVMpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxpbmsgcHJvZ3JhbTpcXG4ke2dsLmdldFByb2dyYW1JbmZvTG9nKGhhbmRsZSl9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3VuaWZvcm1DYWNoZSA9IG5ldyBNYXAoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQmluZHMgdGhlIHByb2dyYW0gdG8gdGhlIFdlYkdMIGNvbnRleHQuXHJcbiAgICAgKi9cclxuICAgIGJpbmQoKSB7XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcclxuICAgICAgICBjb25zdCBoYW5kbGUgPSB0aGlzLl9oYW5kbGU7XHJcbiAgICAgICAgLy8gVE9ETyBVbmNvbW1lbnQgYW5kIHB1dCB1bmRlciBkZWJ1ZyBmbGFnICh3aGVuIGltcGxlbWVudGVkKVxyXG4gICAgICAgIC8vIGdsLnZhbGlkYXRlUHJvZ3JhbShoYW5kbGUpO1xyXG4gICAgICAgIC8vIGlmICghZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihoYW5kbGUsIGdsLlZBTElEQVRFX1NUQVRVUykpIHtcclxuICAgICAgICAvLyAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgIC8vICAgICAgICAgJ0ZhaWxlZCB0byB2YWxpZGF0ZSBwcm9ncmFtOlxcbicgKyBnbC5nZXRQcm9ncmFtSW5mb0xvZyhoYW5kbGUpXHJcbiAgICAgICAgLy8gICAgICk7XHJcbiAgICAgICAgLy8gfVxyXG4gICAgICAgIGdsLnVzZVByb2dyYW0oaGFuZGxlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIHRoZSBwcm9ncmFtIGlzIGJvdW5kIHRvIHRoZSBXZWJHTCBjb250ZXh0LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgcHJvZ3JhbSBpZiBjdXJyZW50bHkgYm91bmQgdG8gdGhlIFdlYkdMIGNvbnRleHQgYW5kXHJcbiAgICAgKiAgICAgIGBmYWxzZWAgb3RoZXJ3aXNlLlxyXG4gICAgICovXHJcbiAgICBpc0JvdW5kKCkge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XHJcbiAgICAgICAgcmV0dXJuIGdsLmdldFBhcmFtZXRlcihnbC5DVVJSRU5UX1BST0dSQU0pID09PSB0aGlzLl9oYW5kbGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgYW4gaW50ZWdlciBzY2FsYXIgdmFsdWUgdG8gYSB1bmlmb3JtLiBJZiB0aGVyZSdzIG5vIHVuaWZvcm0gd2l0aFxyXG4gICAgICogZ2l2ZW4gbmFtZSBpbiB0aGUgcHJvZ3JhbSwgc2lsZW50bHkgZG9lcyBub3RoaW5nLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB1bmlmb3JtTmFtZSBOYW1lIG9mIHRoZSB1bmlmb3JtLlxyXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSBzY2FsYXIgdmFsdWUuXHJcbiAgICAgKi9cclxuICAgIHNldEludFNjYWxhclVuaWZvcm0odW5pZm9ybU5hbWUsIHZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgbG9jYXRpb24gPSB0aGlzLl9nZXRVbmlmb3JtTG9jYXRpb24odW5pZm9ybU5hbWUpO1xyXG4gICAgICAgIGlmIChsb2NhdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLl9nbC51bmlmb3JtMWkobG9jYXRpb24sIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgYSBzY2FsYXIgdmFsdWUgdG8gYSB1bmlmb3JtLiBJZiB0aGVyZSdzIG5vIHVuaWZvcm0gd2l0aFxyXG4gICAgICogZ2l2ZW4gbmFtZSBpbiB0aGUgcHJvZ3JhbSwgc2lsZW50bHkgZG9lcyBub3RoaW5nLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB1bmlmb3JtTmFtZSBOYW1lIG9mIHRoZSB1bmlmb3JtLlxyXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSBzY2FsYXIgdmFsdWUuXHJcbiAgICAgKi9cclxuICAgIHNldFNjYWxhclVuaWZvcm0odW5pZm9ybU5hbWUsIHZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgbG9jYXRpb24gPSB0aGlzLl9nZXRVbmlmb3JtTG9jYXRpb24odW5pZm9ybU5hbWUpO1xyXG4gICAgICAgIGlmIChsb2NhdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLl9nbC51bmlmb3JtMWYobG9jYXRpb24sIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgYSAyRCB2ZWN0b3IgdG8gYSB1bmlmb3JtLiBJZiB0aGVyZSdzIG5vIHVuaWZvcm0gd2l0aCBnaXZlbiBuYW1lIGluXHJcbiAgICAgKiB0aGUgcHJvZ3JhbSwgc2lsZW50bHkgZG9lcyBub3RoaW5nLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB1bmlmb3JtTmFtZSBOYW1lIG9mIHRoZSB1bmlmb3JtLlxyXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSB2ZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIHNldFZlY3RvcjJVbmlmb3JtKHVuaWZvcm1OYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IGxvY2F0aW9uID0gdGhpcy5fZ2V0VW5pZm9ybUxvY2F0aW9uKHVuaWZvcm1OYW1lKTtcclxuICAgICAgICBpZiAobG9jYXRpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5fZ2wudW5pZm9ybTJmKGxvY2F0aW9uLCB2YWx1ZS54LCB2YWx1ZS55KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgYSAzRCB2ZWN0b3IgdG8gYSB1bmlmb3JtLiBJZiB0aGVyZSdzIG5vIHVuaWZvcm0gd2l0aCBnaXZlbiBuYW1lIGluXHJcbiAgICAgKiB0aGUgcHJvZ3JhbSwgc2lsZW50bHkgZG9lcyBub3RoaW5nLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB1bmlmb3JtTmFtZSBOYW1lIG9mIHRoZSB1bmlmb3JtLlxyXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSB2ZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIHNldFZlY3RvcjNVbmlmb3JtKHVuaWZvcm1OYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IGxvY2F0aW9uID0gdGhpcy5fZ2V0VW5pZm9ybUxvY2F0aW9uKHVuaWZvcm1OYW1lKTtcclxuICAgICAgICBpZiAobG9jYXRpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5fZ2wudW5pZm9ybTNmKGxvY2F0aW9uLCB2YWx1ZS54LCB2YWx1ZS55LCB2YWx1ZS56KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgYSA0RCB2ZWN0b3IgdG8gYSB1bmlmb3JtLiBJZiB0aGVyZSdzIG5vIHVuaWZvcm0gd2l0aCBnaXZlbiBuYW1lIGluXHJcbiAgICAgKiB0aGUgcHJvZ3JhbSwgc2lsZW50bHkgZG9lcyBub3RoaW5nLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB1bmlmb3JtTmFtZSBOYW1lIG9mIHRoZSB1bmlmb3JtLlxyXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSB2ZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIHNldFZlY3RvcjRVbmlmb3JtKHVuaWZvcm1OYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IGxvY2F0aW9uID0gdGhpcy5fZ2V0VW5pZm9ybUxvY2F0aW9uKHVuaWZvcm1OYW1lKTtcclxuICAgICAgICBpZiAobG9jYXRpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5fZ2wudW5pZm9ybTRmKGxvY2F0aW9uLCB2YWx1ZS54LCB2YWx1ZS55LCB2YWx1ZS56LCB2YWx1ZS53KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgYSBjb2xvciB0byBhIHVuaWZvcm0uIElmIHRoZXJlJ3Mgbm8gdW5pZm9ybSB3aXRoIGdpdmVuIG5hbWUgaW4gdGhlXHJcbiAgICAgKiBwcm9ncmFtLCBzaWxlbnRseSBkb2VzIG5vdGhpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHVuaWZvcm1OYW1lIE5hbWUgb2YgdGhlIHVuaWZvcm0uXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIGNvbG9yLlxyXG4gICAgICovXHJcbiAgICBzZXRDb2xvclVuaWZvcm0odW5pZm9ybU5hbWUsIHZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgbG9jYXRpb24gPSB0aGlzLl9nZXRVbmlmb3JtTG9jYXRpb24odW5pZm9ybU5hbWUpO1xyXG4gICAgICAgIGlmIChsb2NhdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLl9nbC51bmlmb3JtNGYobG9jYXRpb24sIHZhbHVlLnIsIHZhbHVlLmcsIHZhbHVlLmIsIHZhbHVlLmEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBhIDN4MyBtYXRyaXggdG8gYSB1bmlmb3JtLiBJZiB0aGVyZSdzIG5vIHVuaWZvcm0gd2l0aCBnaXZlbiBuYW1lIGluXHJcbiAgICAgKiB0aGUgcHJvZ3JhbSwgc2lsZW50bHkgZG9lcyBub3RoaW5nLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB1bmlmb3JtTmFtZSBOYW1lIG9mIHRoZSB1bmlmb3JtLlxyXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSBtYXRyaXguXHJcbiAgICAgKi9cclxuICAgIHNldE1hdHJpeDNVbmlmb3JtKHVuaWZvcm1OYW1lLCB2YWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IGxvY2F0aW9uID0gdGhpcy5fZ2V0VW5pZm9ybUxvY2F0aW9uKHVuaWZvcm1OYW1lKTtcclxuICAgICAgICBpZiAobG9jYXRpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5fZ2wudW5pZm9ybU1hdHJpeDNmdihsb2NhdGlvbiwgZmFsc2UsIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgYSA0eDQgbWF0cml4IHRvIGEgdW5pZm9ybS4gSWYgdGhlcmUncyBubyB1bmlmb3JtIHdpdGggZ2l2ZW4gbmFtZSBpblxyXG4gICAgICogdGhlIHByb2dyYW0sIHNpbGVudGx5IGRvZXMgbm90aGluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdW5pZm9ybU5hbWUgTmFtZSBvZiB0aGUgdW5pZm9ybS5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgbWF0cml4LlxyXG4gICAgICovXHJcbiAgICBzZXRNYXRyaXg0VW5pZm9ybSh1bmlmb3JtTmFtZSwgdmFsdWUpIHtcclxuICAgICAgICBjb25zdCBsb2NhdGlvbiA9IHRoaXMuX2dldFVuaWZvcm1Mb2NhdGlvbih1bmlmb3JtTmFtZSk7XHJcbiAgICAgICAgaWYgKGxvY2F0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2dsLnVuaWZvcm1NYXRyaXg0ZnYobG9jYXRpb24sIGZhbHNlLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXN0cm95cyB0aGUgcHJvZ3JhbS5cclxuICAgICAqL1xyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLl9nbC5kZWxldGVQcm9ncmFtKHRoaXMuX2hhbmRsZSk7XHJcbiAgICB9XHJcbiAgICBfZ2V0VW5pZm9ybUxvY2F0aW9uKG5hbWUpIHtcclxuICAgICAgICBjb25zdCBjYWNoZSA9IHRoaXMuX3VuaWZvcm1DYWNoZTtcclxuICAgICAgICBsZXQgbG9jYXRpb24gPSBjYWNoZS5nZXQobmFtZSk7XHJcbiAgICAgICAgaWYgKCFsb2NhdGlvbikge1xyXG4gICAgICAgICAgICBsb2NhdGlvbiA9IHRoaXMuX2dsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl9oYW5kbGUsIG5hbWUpO1xyXG4gICAgICAgICAgICBpZiAoIWxvY2F0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPIFVuY29tbWVudCBhbmQgcHV0IHVuZGVyIGRlYnVnIGZsYWcgKHdoZW4gaW1wbGVtZW50ZWQpXHJcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oYFVuaWZvcm0gJHtuYW1lfSBkb2Vzbid0IGV4aXN0IGluIHByb2dyYW0uYCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYWNoZS5zZXQobmFtZSwgbG9jYXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbG9jYXRpb247XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL2dsL3Byb2dyYW0udHNcbi8vIG1vZHVsZSBpZCA9IDU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKiBXcmFwcGVyIGFyb3VuZCBXZWJHTFJlbmRlcmJ1ZmZlciBvYmplY3RzLiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW5kZXJidWZmZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHJlbmRlcmJ1ZmZlciBpbiBhIFdlYkdMIGNvbnRleHQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGdsIFRoZSBjb250ZXh0IHRoZSByZW5kZXJidWZmZXIgd2lsbCBiZSBjcmVhdGVkIGluLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihnbCwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIHRoaXMuX2dsID0gZ2w7XHJcbiAgICAgICAgdGhpcy5faGFuZGxlID0gZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XHJcbiAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEJpbmRzIHRoZSByZW5kZXJidWZmZXIgdG8gdGhlIFdlYkdMIGNvbnRleHQuXHJcbiAgICAgKi9cclxuICAgIGJpbmQoKSB7XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcclxuICAgICAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgdGhpcy5faGFuZGxlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIHRoZSByZW5kZXJidWZmZXIgaXMgYm91bmQgdG8gdGhlIFdlYkdMIGNvbnRleHQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSByZW5kZXJidWZmZXIgaXMgY3VycmVudGx5IGJvdW5kIHRvIHRoZSBXZWJHTCBjb250ZXh0XHJcbiAgICAgKiAgICAgIGFuZCBgZmFsc2VgIG90aGVyd2lzZS5cclxuICAgICAqL1xyXG4gICAgaXNCb3VuZCgpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xyXG4gICAgICAgIHJldHVybiBnbC5nZXRQYXJhbWV0ZXIoZ2wuUkVOREVSQlVGRkVSX0JJTkRJTkcpID09PSB0aGlzLl9oYW5kbGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEF0dGFjaGVzIHRoZSByZW5kZXJidWZmZXIgdG8gYSBjdXJyZW50bHkgYm91bmQgdG8gdGhlIFdlYkdMIGNvbnRleHRcclxuICAgICAqIGZyYW1lYnVmZmVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhdHRhY2htZW50UG9pbnQgQXR0YWNobWVudCBwb2ludCB0aGUgcmVuZGVyYnVmZmVyIHdpbGwgYmUgYXR0YWNoZWRcclxuICAgICAqICAgICAgdG8uXHJcbiAgICAgKi9cclxuICAgIGF0dGFjaFRvRnJhbWVidWZmZXIoYXR0YWNobWVudFBvaW50KSB7XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcclxuICAgICAgICBnbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgYXR0YWNobWVudFBvaW50LCBnbC5SRU5ERVJCVUZGRVIsIHRoaXMuX2hhbmRsZSk7XHJcbiAgICB9XHJcbiAgICBnZXRXaWR0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fd2lkdGg7XHJcbiAgICB9XHJcbiAgICBnZXRIZWlnaHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlaWdodDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGVzdHJveXMgdGhlIHJlbmRlcmJ1ZmZlci5cclxuICAgICAqL1xyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLl9nbC5kZWxldGVSZW5kZXJidWZmZXIodGhpcy5faGFuZGxlKTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvZ2wvcmVuZGVyYnVmZmVyLnRzXG4vLyBtb2R1bGUgaWQgPSA1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyB0c2xpbnQ6ZGlzYWJsZVxyXG4vKlxyXG4gICAgVGhpcyBpcyBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBieSAvdG9vbHMvZ2xfZ2VuL2dlbl9jYXBhYmlsaXRpZXMuanMgc2NyaXB0LlxyXG4gICAgSW5zdGVhZCBvZiBtb2RpZnlpbmcgaXQgZWRpdCB0aGUgc2NyaXB0IGFuZCByZWdlbmVyYXRlIHRoaXMgZmlsZS5cclxuKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVuZGVyQ29udGV4dENhcGFiaWxpdGllc01hbmFnZXIge1xyXG4gICAgY29uc3RydWN0b3IoZ2wpIHtcclxuICAgICAgICB0aGlzLl9nbCA9IGdsO1xyXG4gICAgICAgIHRoaXMuX3BhcmFtVmFsdWVzID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG4gICAgZ2V0QWxpYXNlZExpbmVXaWR0aFJhbmdlKCkgeyByZXR1cm4gdGhpcy5fZ2V0UGFyYW0oMzM5MDIgLyogQUxJQVNFRF9MSU5FX1dJRFRIX1JBTkdFICovKTsgfVxyXG4gICAgZ2V0QWxpYXNlZFBvaW50U2l6ZVJhbmdlKCkgeyByZXR1cm4gdGhpcy5fZ2V0UGFyYW0oMzM5MDEgLyogQUxJQVNFRF9QT0lOVF9TSVpFX1JBTkdFICovKTsgfVxyXG4gICAgZ2V0TWF4Q29tYmluZWRUZXh0dXJlSW1hZ2VVbml0cygpIHsgcmV0dXJuIHRoaXMuX2dldFBhcmFtKDM1NjYxIC8qIE1BWF9DT01CSU5FRF9URVhUVVJFX0lNQUdFX1VOSVRTICovKTsgfVxyXG4gICAgZ2V0TWF4Q3ViZU1hcFRleHR1cmVTaXplKCkgeyByZXR1cm4gdGhpcy5fZ2V0UGFyYW0oMzQwNzYgLyogTUFYX0NVQkVfTUFQX1RFWFRVUkVfU0laRSAqLyk7IH1cclxuICAgIGdldE1heEZyYWdtZW50VW5pZm9ybVZlY3RvcnMoKSB7IHJldHVybiB0aGlzLl9nZXRQYXJhbSgzNjM0OSAvKiBNQVhfRlJBR01FTlRfVU5JRk9STV9WRUNUT1JTICovKTsgfVxyXG4gICAgZ2V0TWF4UmVuZGVyYnVmZmVyU2l6ZSgpIHsgcmV0dXJuIHRoaXMuX2dldFBhcmFtKDM0MDI0IC8qIE1BWF9SRU5ERVJCVUZGRVJfU0laRSAqLyk7IH1cclxuICAgIGdldE1heFRleHR1cmVJbWFnZVVuaXRzKCkgeyByZXR1cm4gdGhpcy5fZ2V0UGFyYW0oMzQ5MzAgLyogTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMgKi8pOyB9XHJcbiAgICBnZXRNYXhUZXh0dXJlU2l6ZSgpIHsgcmV0dXJuIHRoaXMuX2dldFBhcmFtKDMzNzkgLyogTUFYX1RFWFRVUkVfU0laRSAqLyk7IH1cclxuICAgIGdldE1heFZhcnlpbmdWZWN0b3JzKCkgeyByZXR1cm4gdGhpcy5fZ2V0UGFyYW0oMzYzNDggLyogTUFYX1ZBUllJTkdfVkVDVE9SUyAqLyk7IH1cclxuICAgIGdldE1heFZlcnRleEF0dHJpYnMoKSB7IHJldHVybiB0aGlzLl9nZXRQYXJhbSgzNDkyMSAvKiBNQVhfVkVSVEVYX0FUVFJJQlMgKi8pOyB9XHJcbiAgICBnZXRNYXhWZXJ0ZXhUZXh0dXJlSW1hZ2VVbml0cygpIHsgcmV0dXJuIHRoaXMuX2dldFBhcmFtKDM1NjYwIC8qIE1BWF9WRVJURVhfVEVYVFVSRV9JTUFHRV9VTklUUyAqLyk7IH1cclxuICAgIGdldE1heFZlcnRleFVuaWZvcm1WZWN0b3JzKCkgeyByZXR1cm4gdGhpcy5fZ2V0UGFyYW0oMzYzNDcgLyogTUFYX1ZFUlRFWF9VTklGT1JNX1ZFQ1RPUlMgKi8pOyB9XHJcbiAgICBnZXRNYXhWaWV3cG9ydERpbXMoKSB7IHJldHVybiB0aGlzLl9nZXRQYXJhbSgzMzg2IC8qIE1BWF9WSUVXUE9SVF9ESU1TICovKTsgfVxyXG4gICAgZ2V0UmVuZGVyZXIoKSB7IHJldHVybiB0aGlzLl9nZXRQYXJhbSg3OTM3IC8qIFJFTkRFUkVSICovKTsgfVxyXG4gICAgZ2V0U3VicGl4ZWxCaXRzKCkgeyByZXR1cm4gdGhpcy5fZ2V0UGFyYW0oMzQwOCAvKiBTVUJQSVhFTF9CSVRTICovKTsgfVxyXG4gICAgZ2V0VmVuZG9yKCkgeyByZXR1cm4gdGhpcy5fZ2V0UGFyYW0oNzkzNiAvKiBWRU5ET1IgKi8pOyB9XHJcbiAgICBnZXRWZXJzaW9uKCkgeyByZXR1cm4gdGhpcy5fZ2V0UGFyYW0oNzkzOCAvKiBWRVJTSU9OICovKTsgfVxyXG4gICAgLyoqIENhbGxpbmcgdGhpcyBtZXRob2Qgdy9vIGBXRUJHTF9kZWJ1Z19yZW5kZXJlcl9pbmZvYCBlbmFibGVkIHdpbGwgcmV0dXJuIGBudWxsYCEgKi9cclxuICAgIGdldFVubWFza2VkVmVuZG9yKCkgeyByZXR1cm4gdGhpcy5fZ2V0UGFyYW0oMzc0NDUgLyogVU5NQVNLRURfVkVORE9SICovKTsgfVxyXG4gICAgLyoqIENhbGxpbmcgdGhpcyBtZXRob2Qgdy9vIGBXRUJHTF9kZWJ1Z19yZW5kZXJlcl9pbmZvYCBlbmFibGVkIHdpbGwgcmV0dXJuIGBudWxsYCEgKi9cclxuICAgIGdldFVubWFza2VkUmVuZGVyZXIoKSB7IHJldHVybiB0aGlzLl9nZXRQYXJhbSgzNzQ0NiAvKiBVTk1BU0tFRF9SRU5ERVJFUiAqLyk7IH1cclxuICAgIF9nZXRQYXJhbShwYXJhbSkge1xyXG4gICAgICAgIGNvbnN0IHBhcmFtVmFsdWVzID0gdGhpcy5fcGFyYW1WYWx1ZXM7XHJcbiAgICAgICAgbGV0IHBhcmFtVmFsdWUgPSBwYXJhbVZhbHVlcy5nZXQocGFyYW0pO1xyXG4gICAgICAgIGlmICghcGFyYW1WYWx1ZSkge1xyXG4gICAgICAgICAgICBwYXJhbVZhbHVlID0gdGhpcy5fZ2wuZ2V0UGFyYW1ldGVyKHBhcmFtKTtcclxuICAgICAgICAgICAgcGFyYW1WYWx1ZXMuc2V0KHBhcmFtLCBwYXJhbVZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhcmFtVmFsdWU7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL2NhcGFiaWxpdGllcy50c1xuLy8gbW9kdWxlIGlkID0gNjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIE91ciBkZWZhdWx0cyBmb3IgdGV4dHVyZXMgYXJlIGRpZmZlcmVudCBmcm9tIG9uZXMgaW4gV2ViR0wgZm9yIHR3byByZWFzb25zOlxyXG4gKiAxLiBkZWZhdWx0IG1pbmlmaWNhdGlvbiBmaWx0ZXIgaW4gV2ViR0wgaXMgTkVBUkVTVF9NSVBNQVBfTElORUFSIHdoaWNoIHJlcXVpcmVzXHJcbiAqICAgIHRleHR1cmUgdG8gaGF2ZSBhbGwgbWlwIGxldmVscyBzcGVjaWZpZWQ7XHJcbiAqIDIuIGRlZmF1bHQgd3JhcCBtb2RlcyBhcmUgUkVQRUFUIHdoaWNoIGlzbid0IHN1cHBvcnRlZCBmb3IgTlBPVCB0ZXh0dXJlcy5cclxuICovXHJcbmV4cG9ydCBjb25zdCBERUZBVUxUX1RFWFRVUkVfUEFSQU1TID0ge1xyXG4gICAgd3JhcFM6IDMzMDcxIC8qIENMQU1QX1RPX0VER0UgKi8sXHJcbiAgICB3cmFwVDogMzMwNzEgLyogQ0xBTVBfVE9fRURHRSAqLyxcclxuICAgIG1hZ25pZmljYXRpb25GaWx0ZXI6IDk3MjggLyogTkVBUkVTVCAqLyxcclxuICAgIG1pbmlmaWNhdGlvbkZpbHRlcjogOTcyOCAvKiBORUFSRVNUICovLFxyXG4gICAgcHJlbXVsdGlwbGllZEFscGhhOiBmYWxzZVxyXG59O1xyXG4vKiogV3JhcHBlciBhcm91bmQgV2ViR0xUZXh0dXJlIG9iamVjdHMuIEZvciBub3cgb25seSB3b3JrcyB3aXRoIDJEIHRleHR1cmVzLiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXh0dXJlIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyB0ZXh0dXJlIGluIGEgV2ViR0wgY29udGV4dC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZ2wgVGhlIGNvbnRleHQgdGhlIHRleHR1cmUgd2lsbCBiZSBjcmVhdGVkIGluLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihnbCwgd2lkdGgsIGhlaWdodCwgZm9ybWF0LCB0eXBlLCBwYXJhbXMgPSBERUZBVUxUX1RFWFRVUkVfUEFSQU1TKSB7XHJcbiAgICAgICAgdGhpcy5fZ2wgPSBnbDtcclxuICAgICAgICB0aGlzLl9mb3JtYXQgPSBmb3JtYXQ7XHJcbiAgICAgICAgdGhpcy5fdHlwZSA9IHR5cGU7XHJcbiAgICAgICAgdGhpcy5fcGFyYW1zID0gcGFyYW1zO1xyXG4gICAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMuX2hhbmRsZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcclxuICAgICAgICB0aGlzLmJpbmQoKTtcclxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBwYXJhbXMud3JhcFMpO1xyXG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIHBhcmFtcy53cmFwVCk7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIHBhcmFtcy5tYWduaWZpY2F0aW9uRmlsdGVyKTtcclxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgcGFyYW1zLm1pbmlmaWNhdGlvbkZpbHRlcik7XHJcbiAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBmb3JtYXQsIHdpZHRoLCBoZWlnaHQsIDAsIGZvcm1hdCwgdHlwZSwgbnVsbCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEJpbmRzIHRoZSB0ZXh0dXJlIHRvIHRoZSBXZWJHTCBjb250ZXh0IGFzIGEgMkQgdGV4dHVyZS5cclxuICAgICAqL1xyXG4gICAgYmluZCgpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xyXG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMuX2hhbmRsZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyBpZiB0aGUgdGV4dHVyZSBpcyBib3VuZCB0byB0aGUgV2ViR0wgY29udGV4dC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHRleHR1cmUgaXMgY3VycmVudGx5IGJvdW5kIHRvIHRoZSBXZWJHTCBjb250ZXh0XHJcbiAgICAgKiAgICAgIGFuZCBgZmFsc2VgIG90aGVyd2lzZS5cclxuICAgICAqL1xyXG4gICAgaXNCb3VuZCgpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xyXG4gICAgICAgIHJldHVybiBnbC5nZXRQYXJhbWV0ZXIoZ2wuVEVYVFVSRV9CSU5ESU5HXzJEKSA9PT0gdGhpcy5faGFuZGxlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBdHRhY2hlcyB0aGUgdGV4dHVyZSB0byBhIGN1cnJlbnRseSBib3VuZCB0byB0aGUgV2ViR0wgY29udGV4dCBmcmFtZWJ1ZmZlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYXR0YWNobWVudFBvaW50IEF0dGFjaG1lbnQgcG9pbnQgdGhlIHRleHR1cmUgd2lsbCBiZSBhdHRhY2hlZCB0by5cclxuICAgICAqL1xyXG4gICAgYXR0YWNoVG9GcmFtZWJ1ZmZlcihhdHRhY2htZW50UG9pbnQpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xyXG4gICAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBhdHRhY2htZW50UG9pbnQsIGdsLlRFWFRVUkVfMkQsIHRoaXMuX2hhbmRsZSwgMCk7XHJcbiAgICB9XHJcbiAgICAvKiogUmV0dXJucyB3aWR0aCBvZiB0aGUgdGV4dHVyZS4gKi9cclxuICAgIGdldFdpZHRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl93aWR0aDtcclxuICAgIH1cclxuICAgIC8qKiBSZXR1cm5zIGhlaWdodCBvZiB0aGUgdGV4dHVyZS4gKi9cclxuICAgIGdldEhlaWdodCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgLyoqIFJldHVybnMgcGl4ZWwgZm9ybWF0IG9mIHRoZSB0ZXh0dXJlLiAqL1xyXG4gICAgZ2V0Rm9ybWF0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9mb3JtYXQ7XHJcbiAgICB9XHJcbiAgICAvKiogUmV0dXJuIHBpeGVsIHR5cGUgb2YgdGhlIHRleHR1cmUuICovXHJcbiAgICBnZXRUeXBlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90eXBlO1xyXG4gICAgfVxyXG4gICAgLyoqIFJldHVybiBwYXJhbXMgb2YgdGhlIHRleHR1cmUuICovXHJcbiAgICBnZXRQYXJhbXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmFtcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGVzdHJveXMgdGhlIHRleHR1cmUuXHJcbiAgICAgKi9cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5fZ2wuZGVsZXRlVGV4dHVyZSh0aGlzLl9oYW5kbGUpO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9nbC90ZXh0dXJlLnRzXG4vLyBtb2R1bGUgaWQgPSA2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICogV3JhcHBlciBhcm91bmQgdmVydGV4IGFycmF5IChWQU8pIG9iamVjdCBmcm9tIGBPRVNfdmVydGV4X2FycmF5X29iamVjdGBcclxuICogZXh0ZW5zaW9uLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmVydGV4QXJyYXlPYmplY3Qge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIG5ldyBWQU8gaW4gYSBnaXZlbiBXZWJHTCBjb250ZXh0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBnbCBUaGUgY29udGV4dC5cclxuICAgICAqIEBwYXJhbSB2YW9FeHQgSW5zdGFuY2Ugb2YgYE9FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0YCBleHRlbnNpb24uXHJcbiAgICAgKiBAcGFyYW0gYXR0cmlidXRlTWFwcGluZyBNYXBwaW5nIG9mIGF0dHJpYnV0ZXMuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGdsLCB2YW9FeHQsIGF0dHJpYnV0ZU1hcHBpbmcpIHtcclxuICAgICAgICB0aGlzLl9nbCA9IGdsO1xyXG4gICAgICAgIHRoaXMuX3Zhb0V4dCA9IHZhb0V4dDtcclxuICAgICAgICB0aGlzLl9oYW5kbGUgPSB2YW9FeHQuY3JlYXRlVmVydGV4QXJyYXlPRVMoKTtcclxuICAgICAgICB0aGlzLmF0dHJpYnV0ZU1hcHBpbmcgPSBhdHRyaWJ1dGVNYXBwaW5nO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBCaW5kcyB0aGUgVkFPIHRvIHRoZSBjb250ZXh0LlxyXG4gICAgICovXHJcbiAgICBiaW5kKCkge1xyXG4gICAgICAgIHRoaXMuX3Zhb0V4dC5iaW5kVmVydGV4QXJyYXlPRVModGhpcy5faGFuZGxlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIHRoZSBWQU8gaXMgY3VycmVudGx5IGJvdW5kIHRvIHRoZSBjb250ZXh0LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgVkFPIGlzIGN1cnJlbnRseSBib3VuZCB0byB0aGUgV2ViR0wgY29udGV4dCBhbmRcclxuICAgICAqICAgICAgYGZhbHNlYCBvdGhlcndpc2UuXHJcbiAgICAgKi9cclxuICAgIGlzQm91bmQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dsLmdldFBhcmFtZXRlcih0aGlzLl92YW9FeHQuVkVSVEVYX0FSUkFZX0JJTkRJTkdfT0VTKSA9PT1cclxuICAgICAgICAgICAgdGhpcy5faGFuZGxlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXN0cm95cyB0aGUgVkFPLlxyXG4gICAgICovXHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMuX3Zhb0V4dC5kZWxldGVWZXJ0ZXhBcnJheU9FUyh0aGlzLl9oYW5kbGUpO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9nbC92YW8udHNcbi8vIG1vZHVsZSBpZCA9IDYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IGNsYW1wLCBjeWNsZVJlc3RyaWN0IH0gZnJvbSAnLi9tYXRoL3NjYWxhcic7XHJcbmltcG9ydCB7IGRlZzJyYWQgfSBmcm9tICcuL3V0aWwvcmFkX2RlZyc7XHJcbmltcG9ydCBnZXRGdWxsT3B0aW9ucyBmcm9tICcuL3V0aWwvb3B0aW9ucyc7XHJcbmltcG9ydCAqIGFzIG1hdDQgZnJvbSAnLi9tYXRoL21hdHJpeDQnO1xyXG5pbXBvcnQgeyBzbW9vdGhTdGVwIH0gZnJvbSAnLi9tYXRoL3NjYWxhcic7XHJcbmltcG9ydCAqIGFzIHZlYzIgZnJvbSAnLi9tYXRoL3ZlY3RvcjInO1xyXG5pbXBvcnQgKiBhcyB2ZWMzIGZyb20gJy4vbWF0aC92ZWN0b3IzJztcclxuaW1wb3J0IHsgVm9pZEV2ZW50RW1pdHRlciB9IGZyb20gJy4vdXRpbC9ldmVudF9lbWl0dGVyJztcclxuLy8gVE9ETyhkbWlraXMpIFdlIHdhbnQgdG8gY29uc3RyYWludCBjb29yZGluYXRlcyBzbyB2aXNpYmxlIHJlZ2lvbiBkb2Vzbid0IGV4dGVuZFxyXG4vLyAgICAgIG91dCBvZiB3b3JsZCBib3VuZGFyaWVzLiBIb3dldmVyLCBpbiBjdXJyZW50IGltcGxlbWVudGF0aW9uIGl0IGRvZXNuJ3RcclxuLy8gICAgICB3b3JrIHByb3Blcmx5IGZvciBhc3BlY3QgcmF0aW9zID4xIG9uIHpvb20gMCBzaW5jZSB2aXNpYmxlIHJlZ2lvbiBpc1xyXG4vLyAgICAgIGxhcmdlciB0aGF0IHRoZSB3b3JsZCBpdHNlbGYgKHNvIHRoZXJlJ3Mgbm8gd2F5IHRvIHNxdWVlemUgaXQgaW4pLiBGb3JcclxuLy8gICAgICB0aGUgY3VycmVudCBjYXNlIChpLmUuIGN5Y2xlZCBpbiBob3Jpem9udGFsIGRpcmVjdGlvbikgaXQgaXMgbm90IGEgcHJvYmxlbS5cclxuY29uc3QgTUFYX1RJTFQgPSBkZWcycmFkKDQwKTtcclxuLyoqXHJcbiAqIElmIGEgY2FtZXJhIGhhcyB6b29tIGxlc3MgdGhhbiBvZiBlcXVhbCB0byBgTk9fVElMVF9NQVhfWk9PTWAsIHRpbHQgd29uJ3QgYmVcclxuICogYWxsb3dlZC5cclxuICovXHJcbmNvbnN0IE5PX1RJTFRfTUFYX1pPT00gPSAxO1xyXG4vKipcclxuICogSWYgYSBjYW1lcmEgaGFzIHpvb20gZ3JlYXRlciB0aGFuIG9mIGVxdWFsIHRvIGBGVUxMX1RJTFRfTUlOX1pPT01gLCB0aWx0IHdpbGxcclxuICogYmUgYWxsb3dlZCB1cCB0byBgTUFYX1RJTFRgLlxyXG4gKi9cclxuY29uc3QgRlVMTF9USUxUX01JTl9aT09NID0gTk9fVElMVF9NQVhfWk9PTSArIDE7XHJcbmNvbnN0IEZSVVNUVU1fRElSRUNUSU9OUyA9IFtcclxuICAgIC8vIHRzbGludDpkaXNhYmxlXHJcbiAgICB2ZWMzLmNyZWF0ZSgtMSwgMSwgLTEpLFxyXG4gICAgdmVjMy5jcmVhdGUoMSwgMSwgLTEpLFxyXG4gICAgdmVjMy5jcmVhdGUoMSwgLTEsIC0xKSxcclxuICAgIHZlYzMuY3JlYXRlKC0xLCAtMSwgLTEpXHJcbiAgICAvLyB0c2xpbnQ6ZW5hYmxlXHJcbl07XHJcbi8qKlxyXG4gKiBIb3cgYmlnIHRoZSB3b3JsZCBzb3VsZCBiZSBvbiBhIHNjcmVlbiBpZiB6b29tIGlzIDAsIGluIGRldmljZSBpbmRlcGVuZGVudCBwaXhlbHNcclxuICovXHJcbmNvbnN0IFpPT01fMF9XT1JMRF9DU1NfUElYRUxfU0laRSA9IDI1NjtcclxuY29uc3QgREVGQVVMVF9PUFRJT05TID0ge1xyXG4gICAgd3JhcE1vZGVYOiAxIC8qIENMQU1QX1RPX0VER0UgKi8sXHJcbiAgICB3cmFwTW9kZVk6IDEgLyogQ0xBTVBfVE9fRURHRSAqLyxcclxuICAgIG1pblpvb206IDAsXHJcbiAgICBtYXhab29tOiAyNCxcclxuICAgIGZvdjogZGVnMnJhZCgzMClcclxufTtcclxuLyoqXHJcbiAqIFJlc3RyaWN0cyBhIG5ldyB2YWx1ZSBmb3IgYSBjZW50ZXIncyBjb29yZGluYXRlIGFjY29yZGluZyB0byBnaXZlbiB3cmFwIG1vZGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB3cmFwTW9kZSBUaGUgd3JhcCBtb2RlLlxyXG4gKiBAcGFyYW0gbmV3Q29vcmRpbmF0ZSBUaGUgbmV3IHZhbHVlLlxyXG4gKiBAcGFyYW0gb2xkQ29vcmRpbmF0ZSBDdXJyZW50IHZhbHVlIG9mIHRoZSBjb29yZGluYXRlLlxyXG4gKiBAcGFyYW0gYmJveE1pbiBNaW5pbXVtIGNvcnJlc3BvbmRpbmcgY29vcmRpbmF0ZSBvZiBib3VuZGluZyBib3ggb2YgdGhlXHJcbiAqICAgICAgdmlzaWJsZSBxdWFkcmlsYXRlcmFsLlxyXG4gKiBAcGFyYW0gYmJveE1heCBNYXhpbXVtIGNvcnJlc3BvbmRpbmcgY29vcmRpbmF0ZSBvZiBib3VuZGluZyBib3ggb2YgdGhlXHJcbiAqICAgICAgdmlzaWJsZSBxdWFkcmlsYXRlcmFsLlxyXG4gKiBAcmV0dXJucyBSZXN0cmljdGVkIHZhbHVlIGZvciB0aGUgY29vcmRpbmF0ZS5cclxuICovXHJcbmZ1bmN0aW9uIHJlc3RyaWN0Q29vcmRpbmF0ZSh3cmFwTW9kZSwgbmV3Q29vcmRpbmF0ZSkge1xyXG4gICAgc3dpdGNoICh3cmFwTW9kZSkge1xyXG4gICAgICAgIGNhc2UgMCAvKiBOT05FICovOlxyXG4gICAgICAgICAgICByZXR1cm4gbmV3Q29vcmRpbmF0ZTtcclxuICAgICAgICBjYXNlIDEgLyogQ0xBTVBfVE9fRURHRSAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIGNsYW1wKG5ld0Nvb3JkaW5hdGUsIC0xLCAxKTtcclxuICAgICAgICBjYXNlIDIgLyogUkVQRUFUICovOlxyXG4gICAgICAgICAgICByZXR1cm4gY3ljbGVSZXN0cmljdChuZXdDb29yZGluYXRlLCAtMSwgMSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENhbWVyYSByZXByZXNlbnRzIHVzZXIncyBwb2ludCBvZiB2aWV3IGluIHRoZSB3b3JsZCBzcGFjZSwgYXMgYSByZWFsIGNhbWVyYSBpdCBoYXMgcmVzdHJpY3RlZCBmaWVsZCBvZiB2aWV3LFxyXG4gKiBpdCBjYW4gbW92ZSBhbmQgcm90YXRlICh3aXRoIG9yIHdpdGhvdXQgYW5pbWF0aW9uKS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENhbWVyYSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgY2FtZXJhLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBnZXRGdWxsT3B0aW9ucyhERUZBVUxUX09QVElPTlMsIG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuY2VudGVyID0gbmV3IENhbWVyYS5fQ2VudGVyKHRoaXMpO1xyXG4gICAgICAgIHRoaXMub25VcGRhdGUgPSBuZXcgVm9pZEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIGNvbnN0IHNjcmVlblNpemUgPSBuZXcgQ2FtZXJhLl9TY3JlZW5TaXplKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuc2NyZWVuU2l6ZSA9IHNjcmVlblNpemU7XHJcbiAgICAgICAgdGhpcy5fZGlzdGFuY2VUb0NlbnRlciA9IDE7XHJcbiAgICAgICAgdGhpcy5fem9vbSA9IHRoaXMub3B0aW9ucy5taW5ab29tO1xyXG4gICAgICAgIHRoaXMuX3RpbHQgPSB0aGlzLl9hemltdXRoID0gMDtcclxuICAgICAgICB0aGlzLl9kaXJ0eUJpdHMgPSAtMSAvKiBBTEwgKi87XHJcbiAgICAgICAgdGhpcy5fdmlld1Byb2pNYXRyaXggPSBtYXQ0LmNvcHkobWF0NC5JREVOVElUWSk7XHJcbiAgICAgICAgdGhpcy5fdmlzaWJsZVF1YWRyaWxhdGVyYWwgPSBbXHJcbiAgICAgICAgICAgIHZlYzMuY3JlYXRlKDAsIDAsIDApLFxyXG4gICAgICAgICAgICB2ZWMzLmNyZWF0ZSgwLCAwLCAwKSxcclxuICAgICAgICAgICAgdmVjMy5jcmVhdGUoMCwgMCwgMCksXHJcbiAgICAgICAgICAgIHZlYzMuY3JlYXRlKDAsIDAsIDApXHJcbiAgICAgICAgXTtcclxuICAgICAgICB0aGlzLl92aXNpYmxlUXVhZHJpbGF0ZXJhbEJCb3ggPVxyXG4gICAgICAgICAgICB2ZWMyLmNvbXB1dGVCQm94Rm9yUG9pbnRzKHRoaXMuX3Zpc2libGVRdWFkcmlsYXRlcmFsKTtcclxuICAgICAgICB0aGlzLl9waXhlbFNpemUgPSB2ZWMyLmNyZWF0ZSgwLCAwKTtcclxuICAgIH1cclxuICAgIGdldCBhc3BlY3RSYXRpbygpIHtcclxuICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHRoaXMuc2NyZWVuU2l6ZTtcclxuICAgICAgICBpZiAoaGVpZ2h0ICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB3aWR0aCAvIGhlaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHdoZW4gaGVpZ2h0ID09IDAgd2UgY2Fubm90IGNvbXB1dGUgdmlld1Byb2ogbWF0cml4IG9yIHZpc2libGUgcmVnaW9uLCAxIGFsbG93cyB0byBoYW5kbGUgdGhpcyBjYXNlIHdpdGhcclxuICAgICAgICAgICAgLy8gbm8gZXhjZXB0aW9ucyB0aHJvd24sIGJ1dCB0ZWNobmljYWxseSBpdCBpcyBub3QgY29ycmVjdCBhbmQgc2hvdWxkIGJlIHJlY29uc2lkZXJlZCBpZiBhbnkgaXNzdWUgaXMgZm91bmRcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0IHpvb20oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3pvb207XHJcbiAgICB9XHJcbiAgICBnZXQgd29ybGRUb1B4RmFjdG9yKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl93b3JsZFRvUHhGYWN0b3I7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgbmV3IHpvb20gdG8gdGhlIGNhbWVyYSB3aXRoIHJlc3BlY3QgdG8gcHJvdmlkZWQgbGltaXRzIGluIHRoZSBvcHRpb25zLlxyXG4gICAgICovXHJcbiAgICBzZXQgem9vbShuZXdab29tKSB7XHJcbiAgICAgICAgbmV3Wm9vbSA9IGNsYW1wKG5ld1pvb20sIHRoaXMub3B0aW9ucy5taW5ab29tLCB0aGlzLm9wdGlvbnMubWF4Wm9vbSk7XHJcbiAgICAgICAgaWYgKG5ld1pvb20gIT09IHRoaXMuX3pvb20pIHtcclxuICAgICAgICAgICAgdGhpcy5fem9vbSA9IG5ld1pvb207XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbXB1dGVEaXN0YW5jZVRvQ2VudGVyKCk7XHJcbiAgICAgICAgICAgIC8vIENvbnN0cmFpbnRzIG9uIHRpbHQgbWF5IGhhdmUgY2hhbmdlZCwgd2UgbmVlZCB0byByZWNvbXB1dGUgaXQuXHJcbiAgICAgICAgICAgIHRoaXMuX3RpbHQgPSB0aGlzLl9jb25zdHJhaW5UaWx0KHRoaXMuX3RpbHQpO1xyXG4gICAgICAgICAgICB0aGlzLl93b3JsZFRvUHhGYWN0b3IgPSAyLjAgLyAoWk9PTV8wX1dPUkxEX0NTU19QSVhFTF9TSVpFICogTWF0aC5wb3coMiwgbmV3Wm9vbSkpO1xyXG4gICAgICAgICAgICB0aGlzLl9zZXREaXJ0eUJpdHMoMSAvKiBWSUVXX1BST0pfTUFUUklYICovIHwgMiAvKiBWSVNJQkxFX1FVQURSSUxBVEVSQUwgKi8pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCB0aWx0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90aWx0O1xyXG4gICAgfVxyXG4gICAgc2V0IHRpbHQobmV3VGlsdCkge1xyXG4gICAgICAgIG5ld1RpbHQgPSB0aGlzLl9jb25zdHJhaW5UaWx0KG5ld1RpbHQpO1xyXG4gICAgICAgIGlmICh0aGlzLl90aWx0ICE9PSBuZXdUaWx0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RpbHQgPSBuZXdUaWx0O1xyXG4gICAgICAgICAgICB0aGlzLl9zZXREaXJ0eUJpdHMoMSAvKiBWSUVXX1BST0pfTUFUUklYICovIHwgMiAvKiBWSVNJQkxFX1FVQURSSUxBVEVSQUwgKi8pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCBhemltdXRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hemltdXRoO1xyXG4gICAgfVxyXG4gICAgc2V0IGF6aW11dGgobmV3QXppbXV0aCkge1xyXG4gICAgICAgIG5ld0F6aW11dGggPSBjeWNsZVJlc3RyaWN0KG5ld0F6aW11dGgsIDAsIDIgKiBNYXRoLlBJKTtcclxuICAgICAgICBpZiAodGhpcy5fYXppbXV0aCAhPT0gbmV3QXppbXV0aCkge1xyXG4gICAgICAgICAgICB0aGlzLl9hemltdXRoID0gbmV3QXppbXV0aDtcclxuICAgICAgICAgICAgdGhpcy5fc2V0RGlydHlCaXRzKDEgLyogVklFV19QUk9KX01BVFJJWCAqLyB8IDIgLyogVklTSUJMRV9RVUFEUklMQVRFUkFMICovKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNpemUgb2YgYSBwaXhlbCBpbiBOREMuXHJcbiAgICAgKi9cclxuICAgIGdldCBwaXhlbFNpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BpeGVsU2l6ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSW52YWxpZGF0ZSBhbGwgaW50ZXJuYWxseSBjYWNoZWQgdmFsdWVzIChlLmcuIHZpZXcgbWF0cml4KS5cclxuICAgICAqL1xyXG4gICAgc2V0RGlydHkoKSB7XHJcbiAgICAgICAgdGhpcy5fc2V0RGlydHlCaXRzKC0xIC8qIEFMTCAqLyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlY29tcHV0ZXMgKGlmIG5lZWRlZCkgdGhlIHZpZXcgcHJvamVjdGlvbiBtYXRyaXguXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVGhlIHZpZXctcHJvamVjdGlvbiBtYXRyaXguXHJcbiAgICAgKi9cclxuICAgIGdldFZpZXdQcm9qTWF0cml4KCkge1xyXG4gICAgICAgIGNvbnN0IHZpZXdQcm9qTWF0cml4ID0gdGhpcy5fdmlld1Byb2pNYXRyaXg7XHJcbiAgICAgICAgaWYgKHRoaXMuX2RpcnR5Qml0cyAmIDEgLyogVklFV19QUk9KX01BVFJJWCAqLykge1xyXG4gICAgICAgICAgICBtYXQ0LmNvcHkobWF0NC5JREVOVElUWSwgdmlld1Byb2pNYXRyaXgpO1xyXG4gICAgICAgICAgICBtYXQ0Lmxvb2tBdCh2aWV3UHJvak1hdHJpeCwgdGhpcy5fY29tcHV0ZUNlbnRlclRvQ2FtZXJhVmVjdG9yKCksIHZlYzMuT1JJR0lOLCB2ZWMzLnJvdGF0ZVoodmVjMy5QT1NJVElWRV9ZLCB0aGlzLl9hemltdXRoKSwgdmlld1Byb2pNYXRyaXgpO1xyXG4gICAgICAgICAgICBjb25zdCB7IGZvdiB9ID0gdGhpcy5vcHRpb25zO1xyXG4gICAgICAgICAgICBjb25zdCB0YW5GYWN0b3JzID0gTWF0aC50YW4odGhpcy5fdGlsdCkgKiBNYXRoLnRhbigwLjUgKiBmb3YpO1xyXG4gICAgICAgICAgICBtYXQ0LnBlcnNwZWN0aXZlKHZpZXdQcm9qTWF0cml4LCBmb3YsIHRoaXMuYXNwZWN0UmF0aW8sIE1hdGgubWluKHRoaXMuX2Rpc3RhbmNlVG9DZW50ZXIgKiAwLjAxLCB0aGlzLl9kaXN0YW5jZVRvQ2VudGVyIC8gKDEgKyB0YW5GYWN0b3JzKSksIHRoaXMuX2Rpc3RhbmNlVG9DZW50ZXIgLyAoMSAtIHRhbkZhY3RvcnMpLCB2aWV3UHJvak1hdHJpeCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2RpcnR5Qml0cyAmPSB+MSAvKiBWSUVXX1BST0pfTUFUUklYICovO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmlld1Byb2pNYXRyaXg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlY29tcHV0ZXMgKGlmIG5lZWRlZCkgYW5kIHJldHVybnMgcXVhZHJpbGF0ZXJhbCBjdXQgb24gdGhlIHdvcmxkIHBsYW5lXHJcbiAgICAgKiBieSBmcnVzdHVtIG9mIHRoZSBjYW1lcmEuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiBUaGUgcXVhZHJpbGF0ZXJhbCBlbmNsb3NpbmcgdmlzaWJsZSBwYXJ0IG9mIHRoZSB3b3JsZCBwbGFuZS5cclxuICAgICAqL1xyXG4gICAgZ2V0VmlzaWJsZVJlZ2lvbigpIHtcclxuICAgICAgICB0aGlzLl9jb21wdXRlVmlzaWJsZVF1YWRyaWxhdGVyYWwoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaWJsZVF1YWRyaWxhdGVyYWw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlY29tcHV0ZXMgKGlmIG5lZWRlZCkgYW5kIHJldHVybnMgYm91bmRpbmcgYm94IG9mIHRoZSB2aXNpYmxlIHJlZ2lvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIEJvdW5kaW5nIGJveCBvZiB0aGUgdmlzaWJsZSBxdWFkcmlsYXRlcmFsLlxyXG4gICAgICovXHJcbiAgICBnZXRWaXNpYmxlUmVnaW9uQkJveCgpIHtcclxuICAgICAgICB0aGlzLl9jb21wdXRlVmlzaWJsZVF1YWRyaWxhdGVyYWwoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaWJsZVF1YWRyaWxhdGVyYWxCQm94O1xyXG4gICAgfVxyXG4gICAgX2NvbnN0cmFpblRpbHQodGlsdCkge1xyXG4gICAgICAgIHJldHVybiBjbGFtcCh0aWx0LCAwLCBNQVhfVElMVCAqIHNtb290aFN0ZXAoTk9fVElMVF9NQVhfWk9PTSwgRlVMTF9USUxUX01JTl9aT09NLCB0aGlzLl96b29tKSk7XHJcbiAgICB9XHJcbiAgICBfc2V0RGlydHlCaXRzKGJpdHMpIHtcclxuICAgICAgICBpZiAoYml0cyBeIChiaXRzICYgdGhpcy5fZGlydHlCaXRzKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9kaXJ0eUJpdHMgfD0gYml0cztcclxuICAgICAgICAgICAgdGhpcy5vblVwZGF0ZS5maXJlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2NvbXB1dGVEaXN0YW5jZVRvQ2VudGVyKCkge1xyXG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlVG9DZW50ZXIgPVxyXG4gICAgICAgICAgICB0aGlzLnNjcmVlblNpemUuaGVpZ2h0ICogTWF0aC5wb3coMiwgLXRoaXMuX3pvb20pIC9cclxuICAgICAgICAgICAgICAgIChNYXRoLnRhbigwLjUgKiB0aGlzLm9wdGlvbnMuZm92KSAqIFpPT01fMF9XT1JMRF9DU1NfUElYRUxfU0laRSk7XHJcbiAgICB9XHJcbiAgICBfY29tcHV0ZUNlbnRlclRvQ2FtZXJhVmVjdG9yKGRzdCA9IHZlYzMuY3JlYXRlKDAsIDAsIDApKSB7XHJcbiAgICAgICAgdmVjMy5tdWxuKHZlYzMuUE9TSVRJVkVfWiwgdGhpcy5fZGlzdGFuY2VUb0NlbnRlciwgZHN0KTtcclxuICAgICAgICB2ZWMzLnJvdGF0ZVgoZHN0LCB0aGlzLl90aWx0LCBkc3QpO1xyXG4gICAgICAgIHZlYzMucm90YXRlWihkc3QsIHRoaXMuX2F6aW11dGgsIGRzdCk7XHJcbiAgICAgICAgcmV0dXJuIGRzdDtcclxuICAgIH1cclxuICAgIF9jb21wdXRlVmlzaWJsZVF1YWRyaWxhdGVyYWwoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2RpcnR5Qml0cyAmIDIgLyogVklTSUJMRV9RVUFEUklMQVRFUkFMICovKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZpc2libGVRdWFkcmlsYXRlcmFsID0gdGhpcy5fdmlzaWJsZVF1YWRyaWxhdGVyYWw7XHJcbiAgICAgICAgICAgIGNvbnN0IGhhbGZGb3ZUYW4gPSBNYXRoLnRhbigwLjUgKiB0aGlzLm9wdGlvbnMuZm92KTtcclxuICAgICAgICAgICAgY29uc3Qgb3JpZ2luID0gdGhpcy5fY29tcHV0ZUNlbnRlclRvQ2FtZXJhVmVjdG9yKCk7XHJcbiAgICAgICAgICAgIHZlYzIuYWRkKG9yaWdpbiwgdGhpcy5jZW50ZXIsIG9yaWdpbik7XHJcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlID0gdmVjMy5jcmVhdGUoaGFsZkZvdlRhbiAqIHRoaXMuYXNwZWN0UmF0aW8sIGhhbGZGb3ZUYW4sIDEpO1xyXG4gICAgICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSB2ZWMzLmNyZWF0ZSgwLCAwLCAwKTtcclxuICAgICAgICAgICAgY29uc3QgcmF5ID0geyBvcmlnaW4sIGRpcmVjdGlvbiB9O1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgdmVjMy5tdWx2KEZSVVNUVU1fRElSRUNUSU9OU1tpXSwgc2NhbGUsIGRpcmVjdGlvbik7XHJcbiAgICAgICAgICAgICAgICB2ZWMzLnJvdGF0ZVgoZGlyZWN0aW9uLCB0aGlzLl90aWx0LCBkaXJlY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgdmVjMy5yb3RhdGVaKGRpcmVjdGlvbiwgdGhpcy5fYXppbXV0aCwgZGlyZWN0aW9uKTtcclxuICAgICAgICAgICAgICAgIGlmICghdmVjMy5nZXRQbGFuZVJheUludGVyc2VjdGlvbih2ZWMzLlhZLCByYXksIHZpc2libGVRdWFkcmlsYXRlcmFsW2ldKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVmlzaWJsZSBxdWFkcmlsYXRlcmFsIGlzIHVuYm91bmRlZCwgZW5naW5lIGNhblxcJ3QgaGFuZGxlIHRoYXQgY2FzZSAoeWV0KScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZlYzIuY29tcHV0ZUJCb3hGb3JQb2ludHModmlzaWJsZVF1YWRyaWxhdGVyYWwsIHRoaXMuX3Zpc2libGVRdWFkcmlsYXRlcmFsQkJveCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2RpcnR5Qml0cyAmPSB+MiAvKiBWSVNJQkxFX1FVQURSSUxBVEVSQUwgKi87XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiBhIGNlbnRlciB2ZWN0b3Igb2YgYSBjYW1lcmEuIFRha2VzIGludG8gYWNjb3VudCB3cmFwcGluZ1xyXG4gKiBtb2RlcyBhbmQgdXBkYXRlcyBjYW1lcmEncyBkaXJ0eSBmbGFncy5cclxuICovXHJcbkNhbWVyYS5fQ2VudGVyID0gY2xhc3Mge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIG5ldyBjZW50ZXIgdmVjdG9yIGZvciBhIGNhbWVyYS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY2FtZXJhIFRoZSBjYW1lcmEuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGNhbWVyYSkge1xyXG4gICAgICAgIHRoaXMuX2NhbWVyYSA9IGNhbWVyYTtcclxuICAgICAgICB0aGlzLl94ID0gdGhpcy5feSA9IDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFZhbHVlcyBvZiBhYnNjaXNzYSBvZiB0aGUgY2VudGVyIHZlY3Rvci5cclxuICAgICAqL1xyXG4gICAgZ2V0IHgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3g7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFByb3Blcmx5IGNsYW1wcyBvciB3cmFwcyBuZXcgYWJzY2lzc2EgdmFsdWUgYW5kIHNldHMgaXQgdG8gdGhlIHZlY3Rvci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbmV3WCBUaGUgbmV3XHJcbiAgICAgKi9cclxuICAgIHNldCB4KG5ld1gpIHtcclxuICAgICAgICBjb25zdCBjYW1lcmEgPSB0aGlzLl9jYW1lcmE7XHJcbiAgICAgICAgbmV3WCA9IHJlc3RyaWN0Q29vcmRpbmF0ZShjYW1lcmEub3B0aW9ucy53cmFwTW9kZVgsIG5ld1gpO1xyXG4gICAgICAgIGlmICh0aGlzLl94ICE9PSBuZXdYKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3ggPSBuZXdYO1xyXG4gICAgICAgICAgICBjYW1lcmEuX3NldERpcnR5Qml0cygyIC8qIFZJU0lCTEVfUVVBRFJJTEFURVJBTCAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBWYWx1ZXMgb2Ygb3JkaW5hdGUgb2YgdGhlIGNlbnRlciB2ZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIGdldCB5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl95O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQcm9wZXJseSBjbGFtcHMgb3Igd3JhcHMgbmV3IG9yZGluYXRlIHZhbHVlIGFuZCBzZXRzIGl0IHRvIHRoZSB2ZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIHNldCB5KG5ld1kpIHtcclxuICAgICAgICBjb25zdCBjYW1lcmEgPSB0aGlzLl9jYW1lcmE7XHJcbiAgICAgICAgbmV3WSA9IHJlc3RyaWN0Q29vcmRpbmF0ZShjYW1lcmEub3B0aW9ucy53cmFwTW9kZVksIG5ld1kpO1xyXG4gICAgICAgIGlmICh0aGlzLl95ICE9PSBuZXdZKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3kgPSBuZXdZO1xyXG4gICAgICAgICAgICBjYW1lcmEuX3NldERpcnR5Qml0cygyIC8qIFZJU0lCTEVfUVVBRFJJTEFURVJBTCAqLyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5DYW1lcmEuX1NjcmVlblNpemUgPSBjbGFzcyB7XHJcbiAgICBjb25zdHJ1Y3RvcihjYW1lcmEpIHtcclxuICAgICAgICB0aGlzLl9jYW1lcmEgPSBjYW1lcmE7XHJcbiAgICAgICAgdGhpcy5fd2lkdGggPSB0aGlzLl9oZWlnaHQgPSAwO1xyXG4gICAgfVxyXG4gICAgZ2V0IHdpZHRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl93aWR0aDtcclxuICAgIH1cclxuICAgIHNldCB3aWR0aChuZXdXaWR0aCkge1xyXG4gICAgICAgIGlmICh0aGlzLl93aWR0aCAhPT0gbmV3V2lkdGgpIHtcclxuICAgICAgICAgICAgdGhpcy5fd2lkdGggPSBuZXdXaWR0aDtcclxuICAgICAgICAgICAgY29uc3QgY2FtZXJhID0gdGhpcy5fY2FtZXJhO1xyXG4gICAgICAgICAgICBjYW1lcmEuX3NldERpcnR5Qml0cygxIC8qIFZJRVdfUFJPSl9NQVRSSVggKi8gfCAyIC8qIFZJU0lCTEVfUVVBRFJJTEFURVJBTCAqLyk7XHJcbiAgICAgICAgICAgIGNhbWVyYS5fcGl4ZWxTaXplLnggPSAyLjAgLyB0aGlzLl93aWR0aDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgaGVpZ2h0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XHJcbiAgICB9XHJcbiAgICBzZXQgaGVpZ2h0KG5ld0hlaWdodCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9oZWlnaHQgIT09IG5ld0hlaWdodCkge1xyXG4gICAgICAgICAgICB0aGlzLl9oZWlnaHQgPSBuZXdIZWlnaHQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGNhbWVyYSA9IHRoaXMuX2NhbWVyYTtcclxuICAgICAgICAgICAgY2FtZXJhLl9jb21wdXRlRGlzdGFuY2VUb0NlbnRlcigpO1xyXG4gICAgICAgICAgICBjYW1lcmEuX3NldERpcnR5Qml0cygxIC8qIFZJRVdfUFJPSl9NQVRSSVggKi8gfCAyIC8qIFZJU0lCTEVfUVVBRFJJTEFURVJBTCAqLyk7XHJcbiAgICAgICAgICAgIGNhbWVyYS5fcGl4ZWxTaXplLnkgPSAyLjAgLyB0aGlzLl9oZWlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9jYW1lcmEudHNcbi8vIG1vZHVsZSBpZCA9IDYzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImNvbnN0IERFR19UT19SQUQgPSBNYXRoLlBJIC8gMTgwO1xyXG5leHBvcnQgZnVuY3Rpb24gZGVnMnJhZCh4KSB7XHJcbiAgICByZXR1cm4geCAqIERFR19UT19SQUQ7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIHJhZDJkZWcoeCkge1xyXG4gICAgcmV0dXJuIHggLyBERUdfVE9fUkFEO1xyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvcmFkX2RlZy50c1xuLy8gbW9kdWxlIGlkID0gNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIFJlc29sdmVzIG9wdGlvbnMuXHJcbiAqXHJcbiAqIEBwYXJhbSBkZWZhdWx0T3B0aW9ucyBPYmplY3Qgd2l0aCBkZWZhdWx0IHZhbHVlcy5cclxuICogQHBhcmFtIG9wdGlvbnMgT2JqZWN0IHdpdGggY3VzdG9tIHZhbHVlcyBmb3Igb3B0aW9ucy4gTGF0ZXIgb2JqZWN0cyBcIm92ZXJyaWRlXCJcclxuICogICAgICBmb3JtZXIgb25lcy5cclxuICogQHJldHVybnMgTmV3IG9iamVjdCBjb250YWluaW5nIHJlc29sdmVkIG9wdGlvbnMuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRGdWxsT3B0aW9ucyhkZWZhdWx0T3B0aW9ucywgLi4ub3B0aW9ucykge1xyXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCAuLi5vcHRpb25zKTtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL29wdGlvbnMudHNcbi8vIG1vZHVsZSBpZCA9IDY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAqIGFzIHZlY3RvcjMgZnJvbSAnLi92ZWN0b3IzJztcclxuY29uc3QgTUFUUklYX1NJWkUgPSA5O1xyXG4vKipcclxuICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIG5ldyAqKnVuaW5pdGlhbGl6ZWQqKiBtYXRyaXguXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKCkge1xyXG4gICAgcmV0dXJuIG5ldyBBcnJheShNQVRSSVhfU0laRSk7XHJcbn1cclxuLyoqXHJcbiAqIFplcm9lcyBhIG1hdHJpeC5cclxuICpcclxuICogQHBhcmFtIGRzdCBUaGUgbWF0cml4LlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB6ZXJvKGRzdCA9IGNyZWF0ZSgpKSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1BVFJJWF9TSVpFOyArK2kpIHtcclxuICAgICAgICBkc3RbaV0gPSAwO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogQ29waWVzIHRocmVlIHZlY3RvcnMgdG8gYSBtYXRyaXggYXMgcm93cy5cclxuICpcclxuICogQHBhcmFtIHIwIFRoZSBmaXJzdCByb3cuXHJcbiAqIEBwYXJhbSByMSBUaGUgc2Vjb25kIHJvdy5cclxuICogQHBhcmFtIHIyIFRoZSB0aGlyZCByb3cuXHJcbiAqIEBwYXJhbSBkc3QgVGhlIG1hdHJpeCB0aGUgcm93cyB3aWxsIGJlIHdyaXR0ZW4gdG8uXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGZyb21Sb3dzKHIwLCByMSwgcjIsIGRzdCA9IGNyZWF0ZSgpKSB7XHJcbiAgICBkc3RbMF0gPSByMC54O1xyXG4gICAgZHN0WzFdID0gcjEueDtcclxuICAgIGRzdFsyXSA9IHIyLng7XHJcbiAgICBkc3RbM10gPSByMC55O1xyXG4gICAgZHN0WzRdID0gcjEueTtcclxuICAgIGRzdFs1XSA9IHIyLnk7XHJcbiAgICBkc3RbNl0gPSByMC56O1xyXG4gICAgZHN0WzddID0gcjEuejtcclxuICAgIGRzdFs4XSA9IHIyLno7XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFycmF5IG9mIGNvbHVtbnMgb2YgYSBtYXRyaXguXHJcbiAqXHJcbiAqIEBwYXJhbSBtIFRoZSBtYXRyaXguXHJcbiAqIEBwYXJhbSBkc3QgVGhlIGFycmF5IGNvbHVtbnMgb2YgdGhlIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gdG8uXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbHVtbnMobSwgZHN0ID0gW1xyXG4gICAgdmVjdG9yMy5jcmVhdGUoMCwgMCwgMCksXHJcbiAgICB2ZWN0b3IzLmNyZWF0ZSgwLCAwLCAwKSxcclxuICAgIHZlY3RvcjMuY3JlYXRlKDAsIDAsIDApXHJcbl0pIHtcclxuICAgIGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IDM7ICsraSwgaiArPSAzKSB7XHJcbiAgICAgICAgZHN0W2ldLnggPSBtW2pdO1xyXG4gICAgICAgIGRzdFtpXS55ID0gbVtqICsgMV07XHJcbiAgICAgICAgZHN0W2ldLnogPSBtW2ogKyAyXTtcclxuICAgIH1cclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIENvcGllcyB0aHJlZSB2ZWN0b3JzIHRvIGEgbWF0cml4IGFzIGNvbHVtbnMuXHJcbiAqXHJcbiAqIEBwYXJhbSBjMCBUaGUgZmlyc3QgY29sdW1uLlxyXG4gKiBAcGFyYW0gYzEgVGhlIHNlY29uZCBjb2x1bW4uXHJcbiAqIEBwYXJhbSBjMiBUaGUgdGhpcmQgY29sdW1uLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSBtYXRyaXggdGhlIGNvbHVtbnMgd2lsbCBiZSB3cml0dGVuIHRvLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBmcm9tQ29sdW1ucyhjMCwgYzEsIGMyLCBkc3QgPSBjcmVhdGUoKSkge1xyXG4gICAgZHN0WzBdID0gYzAueDtcclxuICAgIGRzdFsxXSA9IGMwLnk7XHJcbiAgICBkc3RbMl0gPSBjMC56O1xyXG4gICAgZHN0WzNdID0gYzEueDtcclxuICAgIGRzdFs0XSA9IGMxLnk7XHJcbiAgICBkc3RbNV0gPSBjMS56O1xyXG4gICAgZHN0WzZdID0gYzIueDtcclxuICAgIGRzdFs3XSA9IGMyLnk7XHJcbiAgICBkc3RbOF0gPSBjMi56O1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogQ29tcHV0ZXMgZGV0ZXJtaW5hbnQgb2YgYSBtYXRyaXguXHJcbiAqXHJcbiAqIEBwYXJhbSBtIFRoZSBtYXRyaXguXHJcbiAqIEByZXR1cm5zIFRoZSBkZXRlcm1pbmFudC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBkZXRlcm1pbmFudChtKSB7XHJcbiAgICByZXR1cm4gbVswXSAqIChtWzRdICogbVs4XSAtIG1bN10gKiBtWzVdKSArXHJcbiAgICAgICAgbVszXSAqIChtWzFdICogbVs4XSAtIG1bN10gKiBtWzJdKSArXHJcbiAgICAgICAgbVs2XSAqIChtWzFdICogbVs1XSAtIG1bNF0gKiBtWzJdKTtcclxufVxyXG5jb25zdCBzdGF0aWNNYXRyaXhDb2x1bW5zID0gW1xyXG4gICAgLy8gTm90IHVzaW5nIHZlY3RvcjMuY3JlYXRlIGhlcmUgZHVlIHRvIGNpcmN1bGFyIGRlcGVuZGVuY3kuXHJcbiAgICB7IHg6IDAsIHk6IDAsIHo6IDAgfSxcclxuICAgIHsgeDogMCwgeTogMCwgejogMCB9LFxyXG4gICAgeyB4OiAwLCB5OiAwLCB6OiAwIH1cclxuXTtcclxuY29uc3Qgc3RhdGljTWF0cml4ID0gY3JlYXRlKCk7XHJcbi8qKlxyXG4gKiBTb2x2ZXMgYSBzeXN0ZW0gb2YgbGluZWFyIGVxdWF0aW9ucyByZXByZXNlbnRlZCB3aXRoIGEgbWF0cml4IGFuZCBhIHZlY3RvcixcclxuICogaS5lLjpcclxuICpcclxuICogYGBgXHJcbiAqIG0gKiAoeCwgeSAseileVCA9IHZcclxuICogYGBgXHJcbiAqXHJcbiAqIFVzZXMgQ3JhbWVyJ3MgcnVsZS5cclxuICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DcmFtZXInc19ydWxlXHJcbiAqXHJcbiAqIEBwYXJhbSBtIFRoZSBtYXRyaXggb2YgdGhlIHN5c3RlbS5cclxuICogQHBhcmFtIHYgVGhlIHZlY3RvciBvZiB0aGUgc3lzdGVtLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSB2ZWN0b3Igc29sdXRpb24gb2YgdGhlIHN5c3RlbSB3aWxsIGJlIHdyaXR0ZW4gdG8uXHJcbiAqIEByZXR1cm4gYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc29sdmUobSwgdiwgZHN0ID0gdmVjdG9yMy5jcmVhdGUoMCwgMCwgMCkpIHtcclxuICAgIGNvbnN0IHJldkRldCA9IDEgLyBkZXRlcm1pbmFudChtKTtcclxuICAgIGNvbnN0IFtjMCwgYzEsIGMyXSA9IGNvbHVtbnMobSwgc3RhdGljTWF0cml4Q29sdW1ucyk7XHJcbiAgICBkc3QueCA9IHJldkRldCAqIGRldGVybWluYW50KGZyb21Db2x1bW5zKHYsIGMxLCBjMiwgc3RhdGljTWF0cml4KSk7XHJcbiAgICBkc3QueSA9IHJldkRldCAqIGRldGVybWluYW50KGZyb21Db2x1bW5zKGMwLCB2LCBjMiwgc3RhdGljTWF0cml4KSk7XHJcbiAgICBkc3QueiA9IHJldkRldCAqIGRldGVybWluYW50KGZyb21Db2x1bW5zKGMwLCBjMSwgdiwgc3RhdGljTWF0cml4KSk7XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL21hdGgvbWF0cml4My50c1xuLy8gbW9kdWxlIGlkID0gNjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IFRpbGVCYXNlZEFkYXB0ZXIgZnJvbSAnLi4vdGlsZV9iYXNlZF9hZGFwdGVyL2FkYXB0ZXInO1xyXG5pbXBvcnQgSWNvbkJ1ZmZlcldyaXRlciBmcm9tICcuLi8uLi9wcmltaXRpdmUvaWNvbi9pY29uX2J1ZmZlcl93cml0ZXInO1xyXG5pbXBvcnQgTWVtb3J5U3ViQ2h1bmsgZnJvbSAnLi4vLi4vcmVuZGVyL21lbW9yeS9zdWJfY2h1bmsnO1xyXG5pbXBvcnQgSWRlbnRpZmllZEltYWdlQXRsYXNNYW5hZ2VyIGZyb20gJy4uLy4uL2JpbGxib2FyZC9pZGVudGlmaWVkX2ltYWdlX2F0bGFzX21hbmFnZXInO1xyXG5pbXBvcnQgRGZGb250IGZyb20gJy4uLy4uL2ZvbnQvZGZfZm9udCc7XHJcbmltcG9ydCB7IEFwaUltYWdlUHJvdmlkZXIgfSBmcm9tICcuL2FwaV9pbWFnZV9wcm92aWRlcic7XHJcbmltcG9ydCBNb2RlbEJ1ZmZlcldyaXRlciBmcm9tICcuLi8uLi9wcmltaXRpdmUvbW9kZWwvbW9kZWxfYnVmZmVyX3dyaXRlcic7XHJcbmltcG9ydCBUZXh0dXJlZFBvbHlsaW5lQnVmZmVyV3JpdGVyIGZyb20gJy4uLy4uL3ByaW1pdGl2ZS9wb2x5bGluZS90ZXh0dXJlZF9wb2x5bGluZV9idWZmZXJfd3JpdGVyJztcclxuaW1wb3J0IHsgSW1hZ2VNYW5hZ2VyIH0gZnJvbSAnLi4vLi4vYmlsbGJvYXJkL2ltYWdlX21hbmFnZXInO1xyXG5pbXBvcnQgVGV4dHVyZWRQb2x5Z29uQnVmZmVyUmV3cml0ZXIgZnJvbSAnLi4vLi4vcHJpbWl0aXZlL3BvbHlnb24vdGV4dHVyZWRfcG9seWdvbl9idWZmZXJfcmV3aXRlcic7XHJcbmltcG9ydCB7IFBPTFlHT05fQVRUUklCVVRFX01BUFBJTkcgfSBmcm9tICcuLi8uLi9wcmltaXRpdmUvcG9seWdvbi9wb2x5Z29uX2F0dHJpYnV0ZV9tYXBwaW5nJztcclxuaW1wb3J0IHsgVEVYVFVSRURfUE9MWUdPTl9BVFRSSUJVVEVfTUFQUElORyB9IGZyb20gJy4uLy4uL3ByaW1pdGl2ZS9wb2x5Z29uL3RleHR1cmVkX3BvbHlnb25fYXR0cmlidXRlX21hcHBpbmcnO1xyXG5pbXBvcnQgeyBCSUxMQk9BUkRfUkVDVEFOR0xFX0FUVFJJQlVURV9NQVBQSU5HIH0gZnJvbSAnLi4vLi4vcHJpbWl0aXZlL2JpbGxib2FyZF9yZWN0YW5nbGUvYXR0cmlidXRlX21hcHBpbmcnO1xyXG5pbXBvcnQgeyBQT0lOVF9MQUJFTF9BVFRSSUJVVEVfTUFQUElORyB9IGZyb20gJy4uLy4uL3ByaW1pdGl2ZS9sYWJlbC9wb2ludF9sYWJlbF9hdHRyaWJ1dGVfbWFwcGluZyc7XHJcbmltcG9ydCB7IENVUlZFRF9MQUJFTF9BVFRSSUJVVEVfTUFQUElORyB9IGZyb20gJy4uLy4uL3ByaW1pdGl2ZS9sYWJlbC9jdXJ2ZWRfbGFiZWxfYXR0cmlidXRlX21hcHBpbmcnO1xyXG5pbXBvcnQgeyBQT0xZTElORV9BVFRSSUJVVEVfTUFQUElORyB9IGZyb20gJy4uLy4uL3ByaW1pdGl2ZS9wb2x5bGluZS9wb2x5bGluZV9hdHRyaWJ1dGVfbWFwcGluZyc7XHJcbmltcG9ydCB7IFRpbGVQcm92aWRlcldvcmtlckNsaWVudCB9IGZyb20gJy4vd29ya2VyL3RpbGVfcHJvdmlkZXJfd29ya2VyX2NsaWVudCc7XHJcbmltcG9ydCB7IFRpbGVQcm92aWRlck1lc3NhZ2VUeXBlIH0gZnJvbSAnLi93b3JrZXIvdGlsZV9wcm92aWRlcl93b3JrZXJfbWVzc2FnZXMnO1xyXG5pbXBvcnQgeyBUUkFOU1BBUkVOVF9QT0xZR09OX0FUVFJJQlVURV9NQVBQSU5HIH0gZnJvbSAnLi4vLi4vcHJpbWl0aXZlL3BvbHlnb24vdHJhbnNwYXJlbnRfcG9seWdvbl9hdHRyaWJ1dGVfbWFwcGluZyc7XHJcbmltcG9ydCB7IGdldFRpbGVJZCB9IGZyb20gJy4uL3RpbGVfYmFzZWRfYWRhcHRlci90aWxlX2lkJztcclxuaW1wb3J0IElkbGVUYXNrUXVldWUgZnJvbSAnLi4vLi4vdXRpbC9pZGxlX3Rhc2tfcXVldWUnO1xyXG5pbXBvcnQgeyBjb3VudFRpbGVQYXJzZVRpbWUgfSBmcm9tICcuLi8uLi91dGlsL3N0YXQnO1xyXG5pbXBvcnQgeyB1bmlxdWVJZCB9IGZyb20gJy4uLy4uL3V0aWwvdW5pcXVlX2lkJztcclxuaW1wb3J0IFJlbmRlcmFibGVQb2x5Z29uIGZyb20gJy4uLy4uL3ByaW1pdGl2ZS9wb2x5Z29uL3JlbmRlcmFibGVfcG9seWdvbic7XHJcbmltcG9ydCBSZW5kZXJhYmxlVGV4dHVyZWRQb2x5Z29uIGZyb20gJy4uLy4uL3ByaW1pdGl2ZS9wb2x5Z29uL3JlbmRlcmFibGVfdGV4dHVyZWRfcG9seWdvbic7XHJcbmltcG9ydCBSZW5kZXJhYmxlUG9seWxpbmUgZnJvbSAnLi4vLi4vcHJpbWl0aXZlL3BvbHlsaW5lL3JlbmRlcmFibGVfcG9seWxpbmUnO1xyXG5pbXBvcnQgUmVuZGVyYWJsZVRleHR1cmVkUG9seWxpbmUgZnJvbSAnLi4vLi4vcHJpbWl0aXZlL3BvbHlsaW5lL3JlbmRlcmFibGVfdGV4dHVyZWRfcG9seWxpbmUnO1xyXG5pbXBvcnQgUmVuZGVyYWJsZU1vZGVsIGZyb20gJy4uLy4uL3ByaW1pdGl2ZS9tb2RlbC9yZW5kZXJhYmxlX21vZGVsJztcclxuaW1wb3J0IHsgUE9MWUdPTl9FWFRSQUNUT1IsIFRFWFRVUkVEX1BPTFlHT05fRVhUUkFDVE9SLCBQT0xZTElORV9FWFRSQUNUT1IsIFRFWFRVUkVEX1BPTFlMSU5FX0VYVFJBQ1RPUiwgUE9JTlRfRVhUUkFDVE9SLCBQT0lOVF9MQUJFTF9FWFRSQUNUT1IsIENVUlZFRF9MQUJFTF9FWFRSQUNUT1IsIE1PREVMX0VYVFJBQ1RPUiwgRVhURVJOQUxfTUVTSF9FWFRSQUNUT1IgfSBmcm9tICcuL3RpbGVfZGF0YSc7XHJcbmltcG9ydCBSZW5kZXJhYmxlUHJpbWl0aXZlTWFuYWdlciBmcm9tICcuL3ByaW1pdGl2ZV9tYW5hZ2VyL3JlbmRlcmFibGVfcHJpbWl0aXZlX21hbmFnZXInO1xyXG5pbXBvcnQgUHJpbWl0aXZlU2V0U3RvcmFnZSBmcm9tICcuLi8uLi9yZW5kZXIvcHJpbWl0aXZlcy9wcmltaXRpdmVfc2V0X3N0b3JhZ2UnO1xyXG5pbXBvcnQgUG9seWdvbk1hbmFnZXIgZnJvbSAnLi9wcmltaXRpdmVfbWFuYWdlci9wb2x5Z29uX21hbmFnZXInO1xyXG5pbXBvcnQgRGlzYXBwZWFyaW5nUHJpbWl0aXZlU2V0U3RvcmFnZSBmcm9tICcuLi8uLi9yZW5kZXIvcHJpbWl0aXZlcy9kaXNhcHBlYXJpbmdfcHJpbWl0aXZlX3NldF9zdG9yYWdlJztcclxuaW1wb3J0IERlbGF5ZWREaXNhcHBlYXJpbmdQcmltaXRpdmVTZXRTdG9yYWdlIGZyb20gJy4uLy4uL3JlbmRlci9wcmltaXRpdmVzL2RlbGF5ZWRfZGlzYXBwZWFyaW5nX3ByaW1pdGl2ZV9zZXRfc3RvcmFnZSc7XHJcbmltcG9ydCBab29tRmlsdGVyYWJsZVByaW1pdGl2ZU1hbmFnZXIgZnJvbSAnLi9wcmltaXRpdmVfbWFuYWdlci96b29tX2ZpbHRlcmFibGVfcHJpbWl0aXZlX21hbmFnZXInO1xyXG5pbXBvcnQgRXh0ZXJuYWxNZXNoUHJpbWl0aXZlTWFuYWdlciBmcm9tICcuL3ByaW1pdGl2ZV9tYW5hZ2VyL2V4dGVybmFsX21lc2hfbWFuYWdlcic7XHJcbmltcG9ydCBSZW5kZXJhYmxlQmlsbGJvYXJkUmVjdGFuZ2xlIGZyb20gJy4uLy4uL3ByaW1pdGl2ZS9iaWxsYm9hcmRfcmVjdGFuZ2xlL3JlbmRlcmFibGVfYmlsbGJvYXJkX3JlY3RhbmdsZSc7XHJcbmltcG9ydCB7IFpvb21SZXN0cmljdGVkTGFiZWwgfSBmcm9tICcuL3ByaW1pdGl2ZS96b29tX3Jlc3RyaWN0ZWRfbGFiZWwnO1xyXG5pbXBvcnQgeyBab29tUmVzdHJpY3RlZEljb24gfSBmcm9tICcuL3ByaW1pdGl2ZS96b29tX3Jlc3RyaWN0ZWRfaWNvbic7XHJcbmltcG9ydCBQcmlvcml0eVF1ZXVlIGZyb20gJy4uLy4uL3V0aWwvdGFza19xdWV1ZSc7XHJcbmNvbnN0IFdPUkxEX1NJWkUgPSAyLjA7XHJcbmNvbnN0IE5PUk1BTF9USUxFX1NJREVfU0laRV9QWCA9IDI1NjsgLy8gdGlsZXMgb2Ygbm9ybWFsIHNpemUgYXJlIG9wdGltaXplZCBmb3IgZGlzcGxheWluZyBpbiBhIDI1NngyNTYgY3NzIHB4IHNxdWFyZVxyXG5mdW5jdGlvbiBnZXRUaWxlU2lkZVNpemVQeCh0aWxlU2l6ZSkge1xyXG4gICAgc3dpdGNoICh0aWxlU2l6ZSkge1xyXG4gICAgICAgIGNhc2UgMSAvKiBYNCAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIE5PUk1BTF9USUxFX1NJREVfU0laRV9QWCAqIDI7XHJcbiAgICAgICAgY2FzZSAyIC8qIFgxNiAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIE5PUk1BTF9USUxFX1NJREVfU0laRV9QWCAqIDQ7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIE5PUk1BTF9USUxFX1NJREVfU0laRV9QWDtcclxuICAgIH1cclxufVxyXG5jb25zdCBNQVhfUEVSRl9MT0dfSVRFTVNfQ09VTlQgPSAxMDI0O1xyXG5jb25zdCBRVUVVRV9UQVNLX1BSSU9SSVRJRVMgPSB7XHJcbiAgICBmaXJzdFRpbGVQb3J0aW9uOiAyMCxcclxuICAgIHNlY29uZFRpbGVQb3J0aW9uOiAxMFxyXG59O1xyXG5jb25zdCBERUZBVUxUX0lETEVfVEFTS19QUklPUklUWSA9IDA7XHJcbi8vIFRoZSB2YWx1ZXMgYXJlIGNob3NlbiBlbXBpcmljYWxseTogaHR0cHM6Ly9zdC55YW5kZXgtdGVhbS5ydS9WRUNUT1ItMzAwIzViZTViNjM4NTIzMjExMDAxYjliZDk0MVxyXG5jb25zdCBNSU5aT09NX0RFTFRBUyA9IHtcclxuICAgIHBvaW50TGFiZWxzOiAxLFxyXG4gICAgY3VydmVkTGFiZWxzOiAxLFxyXG4gICAgaWNvbnM6IDAuNzVcclxufTtcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmVjdG9yQXBpQWRhcHRlciBleHRlbmRzIFRpbGVCYXNlZEFkYXB0ZXIge1xyXG4gICAgY29uc3RydWN0b3IoZW5naW5lLCBjYW1lcmEsIHRpbGVQcm92aWRlcldvcmtlclVybCwgbGF5ZXJOYW1lLCB7IGltYWdlVXJsVGVtcGxhdGUsIHRpbGVVcmxUZW1wbGF0ZSwgbWVzaFVybFRlbXBsYXRlLCBnbHlwaFJhbmdlVXJsVGVtcGxhdGUgfSwgdGlsZVNpemUgPSAwIC8qIFgxICovLCBwcmVsb2FkZWRUaWxlc0JlbHRTaXplID0gMCkge1xyXG4gICAgICAgIHN1cGVyKGVuZ2luZSwgY2FtZXJhLCB0aWxlU2l6ZSwgcHJlbG9hZGVkVGlsZXNCZWx0U2l6ZSwgbGF5ZXJOYW1lKTtcclxuICAgICAgICB0aGlzLl90aWxlU2lkZVNpemVQeCA9IGdldFRpbGVTaWRlU2l6ZVB4KHRpbGVTaXplKTtcclxuICAgICAgICB0aGlzLl9wZXJmTG9nSXRlbXMgPSBbXTtcclxuICAgICAgICB0aGlzLl9kZXN0cm95YWJsZXMgPSBbXTtcclxuICAgICAgICB0aGlzLl90aWxlUHJvdmlkZXIgPSBuZXcgVGlsZVByb3ZpZGVyV29ya2VyQ2xpZW50KHRpbGVQcm92aWRlcldvcmtlclVybCk7XHJcbiAgICAgICAgdGhpcy5fdGlsZVByb3ZpZGVyLnNlbmRNZXNzYWdlKHtcclxuICAgICAgICAgICAgdHlwZTogVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGUuSU5JVCxcclxuICAgICAgICAgICAgdGlsZVVybFRlbXBsYXRlLFxyXG4gICAgICAgICAgICBtZXNoVXJsVGVtcGxhdGUsXHJcbiAgICAgICAgICAgIGdseXBoUmFuZ2VVcmxUZW1wbGF0ZVxyXG4gICAgICAgIH0sIDEgLyogSU1NRURJQVRFICovKTtcclxuICAgICAgICB0aGlzLl9tZW1vcnlNYW5hZ2VyID0gZW5naW5lLm1lbW9yeU1hbmFnZXI7XHJcbiAgICAgICAgdGhpcy5fZ2x5cGhBdGxhcyA9IGVuZ2luZS5nbHlwaEF0bGFzO1xyXG4gICAgICAgIHRoaXMuX2ZvbnRSZWdpc3RyeSA9IGVuZ2luZS5mb250UmVnaXN0cnk7XHJcbiAgICAgICAgdGhpcy5faW1hZ2VNYW5hZ2VyTmVhcmVzdCA9IG5ldyBJbWFnZU1hbmFnZXIobmV3IElkZW50aWZpZWRJbWFnZUF0bGFzTWFuYWdlcihlbmdpbmUuY3JlYXRlSW1hZ2VBdGxhcyh7XHJcbiAgICAgICAgICAgIGZpbHRlcjogOTcyOCAvKiBORUFSRVNUICovLFxyXG4gICAgICAgICAgICBwcmVtdWx0aXBsaWVkQWxwaGE6IGZhbHNlXHJcbiAgICAgICAgfSkpLCBuZXcgQXBpSW1hZ2VQcm92aWRlcihpbWFnZVVybFRlbXBsYXRlKSk7XHJcbiAgICAgICAgdGhpcy5faW1hZ2VNYW5hZ2VyTGluZWFyID0gbmV3IEltYWdlTWFuYWdlcihuZXcgSWRlbnRpZmllZEltYWdlQXRsYXNNYW5hZ2VyKGVuZ2luZS5jcmVhdGVJbWFnZUF0bGFzKHtcclxuICAgICAgICAgICAgZmlsdGVyOiA5NzI5IC8qIExJTkVBUiAqLyxcclxuICAgICAgICAgICAgcHJlbXVsdGlwbGllZEFscGhhOiB0cnVlXHJcbiAgICAgICAgfSkpLCBuZXcgQXBpSW1hZ2VQcm92aWRlcihpbWFnZVVybFRlbXBsYXRlKSk7XHJcbiAgICAgICAgY29uc3QgZmFkZUVmZmVjdCA9IGVuZ2luZS52aXNpYmlsaXR5TWFuYWdlci5mYWRlRWZmZWN0RHVyYXRpb247XHJcbiAgICAgICAgY29uc3Qgb3BhcXVlUG9seWdvbnNQcm92aWRlciA9IHRoaXMub3BhcXVlUG9seWdvbnNQcm92aWRlciA9IG5ldyBQcmltaXRpdmVTZXRTdG9yYWdlKCk7XHJcbiAgICAgICAgY29uc3QgdHJhbnNwYXJlbnRQb2x5Z29uc1Byb3ZpZGVyID0gdGhpcy50cmFuc3BhcmVudFBvbHlnb25zUHJvdmlkZXIgPSBuZXcgUHJpbWl0aXZlU2V0U3RvcmFnZSgpO1xyXG4gICAgICAgIGNvbnN0IHRleHR1cmVkUG9seWdvbnNQcm92aWRlciA9IHRoaXMudGV4dHVyZWRQb2x5Z29uc1Byb3ZpZGVyID0gbmV3IFByaW1pdGl2ZVNldFN0b3JhZ2UoKTtcclxuICAgICAgICBjb25zdCBwb2x5bGluZXNQcm92aWRlciA9IHRoaXMucG9seWxpbmVzUHJvdmlkZXIgPSBuZXcgUHJpbWl0aXZlU2V0U3RvcmFnZSgpO1xyXG4gICAgICAgIGNvbnN0IHRleHR1cmVkUG9seWxpbmVzUHJvdmlkZXIgPSB0aGlzLnRleHR1cmVkUG9seWxpbmVzUHJvdmlkZXIgPSBuZXcgUHJpbWl0aXZlU2V0U3RvcmFnZSgpO1xyXG4gICAgICAgIGNvbnN0IGljb25zUHJvdmlkZXIgPSB0aGlzLmljb25zUHJvdmlkZXIgPSBuZXcgRGlzYXBwZWFyaW5nUHJpbWl0aXZlU2V0U3RvcmFnZSgpO1xyXG4gICAgICAgIGNvbnN0IHBvaW50TGFiZWxzUHJvdmlkZXIgPSB0aGlzLnBvaW50TGFiZWxzUHJvdmlkZXIgPSBuZXcgRGVsYXllZERpc2FwcGVhcmluZ1ByaW1pdGl2ZVNldFN0b3JhZ2UoZmFkZUVmZmVjdCk7XHJcbiAgICAgICAgY29uc3QgY3VydmVkTGFiZWxzUHJvdmlkZXIgPSB0aGlzLmN1cnZlZExhYmVsc1Byb3ZpZGVyID0gbmV3IERlbGF5ZWREaXNhcHBlYXJpbmdQcmltaXRpdmVTZXRTdG9yYWdlKGZhZGVFZmZlY3QpO1xyXG4gICAgICAgIGNvbnN0IG1vZGVsc1Byb3ZpZGVyID0gdGhpcy5tb2RlbHNQcm92aWRlciA9IG5ldyBQcmltaXRpdmVTZXRTdG9yYWdlKCk7XHJcbiAgICAgICAgdGhpcy5fZGVzdHJveWFibGVzLnB1c2gocG9pbnRMYWJlbHNQcm92aWRlciwgY3VydmVkTGFiZWxzUHJvdmlkZXIpO1xyXG4gICAgICAgIHRoaXMuX3RpbGVEYXRhTWFuYWdlcnMgPSBbXHJcbiAgICAgICAgICAgIG5ldyBUaWxlRGF0YU1hbmFnZXIobmV3IFBvbHlnb25NYW5hZ2VyKG9wYXF1ZVBvbHlnb25zUHJvdmlkZXIsIHRyYW5zcGFyZW50UG9seWdvbnNQcm92aWRlciksIFBPTFlHT05fRVhUUkFDVE9SKSxcclxuICAgICAgICAgICAgbmV3IFRpbGVEYXRhTWFuYWdlcihuZXcgUmVuZGVyYWJsZVByaW1pdGl2ZU1hbmFnZXIodGV4dHVyZWRQb2x5Z29uc1Byb3ZpZGVyKSwgVEVYVFVSRURfUE9MWUdPTl9FWFRSQUNUT1IpLFxyXG4gICAgICAgICAgICBuZXcgVGlsZURhdGFNYW5hZ2VyKG5ldyBSZW5kZXJhYmxlUHJpbWl0aXZlTWFuYWdlcihwb2x5bGluZXNQcm92aWRlciksIFBPTFlMSU5FX0VYVFJBQ1RPUiksXHJcbiAgICAgICAgICAgIG5ldyBUaWxlRGF0YU1hbmFnZXIobmV3IFJlbmRlcmFibGVQcmltaXRpdmVNYW5hZ2VyKHRleHR1cmVkUG9seWxpbmVzUHJvdmlkZXIpLCBURVhUVVJFRF9QT0xZTElORV9FWFRSQUNUT1IpLFxyXG4gICAgICAgICAgICBuZXcgVGlsZURhdGFNYW5hZ2VyKG5ldyBab29tRmlsdGVyYWJsZVByaW1pdGl2ZU1hbmFnZXIoaWNvbnNQcm92aWRlciwgY2FtZXJhKSwgUE9JTlRfRVhUUkFDVE9SKSxcclxuICAgICAgICAgICAgbmV3IFRpbGVEYXRhTWFuYWdlcihuZXcgWm9vbUZpbHRlcmFibGVQcmltaXRpdmVNYW5hZ2VyKHBvaW50TGFiZWxzUHJvdmlkZXIsIGNhbWVyYSksIFBPSU5UX0xBQkVMX0VYVFJBQ1RPUiksXHJcbiAgICAgICAgICAgIG5ldyBUaWxlRGF0YU1hbmFnZXIobmV3IFpvb21GaWx0ZXJhYmxlUHJpbWl0aXZlTWFuYWdlcihjdXJ2ZWRMYWJlbHNQcm92aWRlciwgY2FtZXJhKSwgQ1VSVkVEX0xBQkVMX0VYVFJBQ1RPUiksXHJcbiAgICAgICAgICAgIG5ldyBUaWxlRGF0YU1hbmFnZXIobmV3IFJlbmRlcmFibGVQcmltaXRpdmVNYW5hZ2VyKG1vZGVsc1Byb3ZpZGVyKSwgTU9ERUxfRVhUUkFDVE9SKSxcclxuICAgICAgICAgICAgbmV3IFRpbGVEYXRhTWFuYWdlcihuZXcgRXh0ZXJuYWxNZXNoUHJpbWl0aXZlTWFuYWdlcihtb2RlbHNQcm92aWRlciwgdGhpcy5fdGlsZVByb3ZpZGVyLCB0aGlzLmVuZ2luZS5tZW1vcnlNYW5hZ2VyKSwgRVhURVJOQUxfTUVTSF9FWFRSQUNUT1IpXHJcbiAgICAgICAgXTtcclxuICAgICAgICB0aGlzLl9yZXF1ZXN0ZWRUaWxlc1N0YXRlID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuX3Rhc2tRdWV1ZSA9IG5ldyBQcmlvcml0eVF1ZXVlKCk7XHJcbiAgICAgICAgdGhpcy5fbWlub3JUYXNrUXVldWUgPSBuZXcgSWRsZVRhc2tRdWV1ZSgpO1xyXG4gICAgICAgIHRoaXMuX3RpbGVQcm92aWRlci5vbihUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZS5USUxFX1JFU1BPTlNFLCAocmVzcG9uc2UpID0+IHRoaXMuX29uVGlsZVByb3ZpZGVyUmVzcG9uc2UocmVzcG9uc2UpKTtcclxuICAgICAgICB0aGlzLl90aWxlUHJvdmlkZXIub24oVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGUuVElMRV9FUlJPUiwgKHJlc3BvbnNlKSA9PiB0aGlzLl9vblRpbGVFcnJvcihyZXNwb25zZS50aWxlKSk7XHJcbiAgICAgICAgdGhpcy5fb25DYW1lcmFVcGRhdGUoKTtcclxuICAgIH1cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5fdGlsZVByb3ZpZGVyLmRlc3Ryb3koKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGRlc3Ryb3lhYmxlIG9mIHRoaXMuX2Rlc3Ryb3lhYmxlcykge1xyXG4gICAgICAgICAgICBkZXN0cm95YWJsZS5kZXN0cm95KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcclxuICAgIH1cclxuICAgIHNldFRpbGVVcmxUZW1wbGF0ZSh0aWxlVXJsVGVtcGxhdGUpIHtcclxuICAgICAgICB0aGlzLl90aWxlUHJvdmlkZXIuc2VuZE1lc3NhZ2Uoe1xyXG4gICAgICAgICAgICB0eXBlOiBUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZS5USUxFX1VSTF9VUERBVEUsXHJcbiAgICAgICAgICAgIHRpbGVVcmxUZW1wbGF0ZVxyXG4gICAgICAgIH0sIDEgLyogSU1NRURJQVRFICovKTtcclxuICAgICAgICB0aGlzLl9yZWZyZXNoQ3VycmVudFRpbGVzKCk7XHJcbiAgICB9XHJcbiAgICBfY3JlYXRlVGlsZVJlcXVlc3QodGlsZUl0ZW0sIHByaW9yaXR5KSB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0Wm9vbSA9IHRoaXMuX2dldFRhcmdldFpvb20oKTtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgdGlsZUl0ZW0sIHsgcHJpb3JpdHksIGlzVmlzaWJsZTogdGhpcy5faXNUaWxlVmlzaWJsZSh0aWxlSXRlbSksIHpvb21NaW46IHRhcmdldFpvb20sIHpvb21NYXg6IHRhcmdldFpvb20gfSk7XHJcbiAgICB9XHJcbiAgICBfcmVxdWVzdFRpbGVzKHJlcXVlc3RzKSB7XHJcbiAgICAgICAgY29uc3QgcmVxdWVzdElkID0gdW5pcXVlSWQoKTtcclxuICAgICAgICB0aGlzLl9vblRpbGVzUmVxdWVzdChyZXF1ZXN0cywgcmVxdWVzdElkKTtcclxuICAgICAgICBmb3IgKGNvbnN0IHJlcXVlc3Qgb2YgcmVxdWVzdHMpIHtcclxuICAgICAgICAgICAgY29uc3QgcmVxdWVzdGVkVGlsZURhdGEgPSB7XHJcbiAgICAgICAgICAgICAgICBpc0dlb21ldHJ5UmVhZHk6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgYXJlTGFiZWxzUmVhZHk6IGZhbHNlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RlZFRpbGVzU3RhdGUuc2V0KGdldFRpbGVJZChyZXF1ZXN0KSwgcmVxdWVzdGVkVGlsZURhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xyXG4gICAgICAgICAgICB0eXBlOiBUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZS5USUxFX1JFUVVFU1RfQkFUQ0gsXHJcbiAgICAgICAgICAgIHJlc3BvbnNlVHlwZTogVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGUuVElMRV9SRVNQT05TRSxcclxuICAgICAgICAgICAgZXJyb3JUeXBlOiBUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZS5USUxFX0VSUk9SLFxyXG4gICAgICAgICAgICByZXF1ZXN0SWQsXHJcbiAgICAgICAgICAgIHJlcXVlc3RzXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLl90aWxlUHJvdmlkZXIuc2VuZE1lc3NhZ2UocmVxdWVzdCwgMSAvKiBJTU1FRElBVEUgKi8pO1xyXG4gICAgfVxyXG4gICAgX2NhbmNlbFRpbGVSZXF1ZXN0cyhyZXF1ZXN0cykge1xyXG4gICAgICAgIGZvciAoY29uc3QgcmVxdWVzdCBvZiByZXF1ZXN0cykge1xyXG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0ZWRUaWxlc1N0YXRlLmRlbGV0ZShnZXRUaWxlSWQocmVxdWVzdC50aWxlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX29uQ2FuY2VsVGlsZVJlcXVlc3RzKHJlcXVlc3RzKTtcclxuICAgICAgICB0aGlzLl90aWxlUHJvdmlkZXIuc2VuZE1lc3NhZ2Uoe1xyXG4gICAgICAgICAgICB0eXBlOiBUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZS5USUxFX1JFUVVFU1RfQ0FOQ0VMX0JBVENILFxyXG4gICAgICAgICAgICByZXF1ZXN0c1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX29uVGlsZURhdGFVcGRhdGUoZGF0YVRvU2hvdywgZGF0YVRvSGlkZSkge1xyXG4gICAgICAgIGZvciAoY29uc3QgcHJpbWl0aXZlTWFuYWdlciBvZiB0aGlzLl90aWxlRGF0YU1hbmFnZXJzKSB7XHJcbiAgICAgICAgICAgIHByaW1pdGl2ZU1hbmFnZXIudXBkYXRlUHJpbWl0aXZlcyhkYXRhVG9TaG93LCBkYXRhVG9IaWRlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfb25UaWxlRGVzdHJveShfdGlsZUl0ZW0sIGRhdGEpIHtcclxuICAgICAgICAvLyByZWxlYXNlIHByaW1pdGl2ZXMgdGhhdCB3ZSd2ZSBjcmVhdGVkIGluIGFsbG9jYXRvcnNcclxuICAgICAgICBmb3IgKGNvbnN0IHBvcnRpb24gb2YgZGF0YSkge1xyXG4gICAgICAgICAgICAocG9ydGlvbi5wb2x5Z29ucyB8fCBbXSkuZm9yRWFjaChyZWxlYXNlUHJpbWl0aXZlKTtcclxuICAgICAgICAgICAgKHBvcnRpb24udGV4dHVyZWRQb2x5Z29ucyB8fCBbXSkuZm9yRWFjaChyZWxlYXNlUHJpbWl0aXZlKTtcclxuICAgICAgICAgICAgKHBvcnRpb24ucG9seWxpbmVzIHx8IFtdKS5mb3JFYWNoKHJlbGVhc2VQcmltaXRpdmUpO1xyXG4gICAgICAgICAgICAocG9ydGlvbi50ZXh0dXJlZFBvbHlsaW5lcyB8fCBbXSkuZm9yRWFjaChyZWxlYXNlUHJpbWl0aXZlKTtcclxuICAgICAgICAgICAgKHBvcnRpb24ucG9pbnRzIHx8IFtdKS5mb3JFYWNoKHJlbGVhc2VQcmltaXRpdmUpO1xyXG4gICAgICAgICAgICAocG9ydGlvbi5wb2ludExhYmVscyB8fCBbXSkuZm9yRWFjaChyZWxlYXNlUHJpbWl0aXZlKTtcclxuICAgICAgICAgICAgKHBvcnRpb24uY3VydmVkTGFiZWxzIHx8IFtdKS5mb3JFYWNoKHJlbGVhc2VQcmltaXRpdmUpO1xyXG4gICAgICAgICAgICAocG9ydGlvbi5tb2RlbHMgfHwgW10pLmZvckVhY2gocmVsZWFzZVByaW1pdGl2ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3NlbmRTdGF0aXN0aWNzQmVmb3JlRGVzdHJveSgpIHtcclxuICAgICAgICBzdXBlci5fc2VuZFN0YXRpc3RpY3NCZWZvcmVEZXN0cm95KCk7XHJcbiAgICAgICAgaWYgKHRoaXMuX3BlcmZMb2dJdGVtcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpdGVtcyA9IHRoaXMuX3BlcmZMb2dJdGVtcztcclxuICAgICAgICBpdGVtcy5zb3J0KChhLCBiKSA9PiBhLnBhcnNlVGltZSAtIGIucGFyc2VUaW1lKTtcclxuICAgICAgICBjb25zdCBtaW4gPSBpdGVtc1swXTtcclxuICAgICAgICBjb25zdCBtYXggPSBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXTtcclxuICAgICAgICBjb25zdCBtZWRpYW4gPSBpdGVtc1tNYXRoLmZsb29yKGl0ZW1zLmxlbmd0aCAvIDIpXTtcclxuICAgICAgICBjb3VudFRpbGVQYXJzZVRpbWUodGhpcy5fbGF5ZXJOYW1lLCBtaW4udGlsZSwgbWluLnBhcnNlVGltZSwgbWF4LnRpbGUsIG1heC5wYXJzZVRpbWUsIG1lZGlhbi50aWxlLCBtZWRpYW4ucGFyc2VUaW1lKTtcclxuICAgIH1cclxuICAgIF9vblRpbGVQcm92aWRlclJlc3BvbnNlKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgdGhpcy5fcHVzaFBlcmZMb2dJdGVtKHJlc3BvbnNlLnRpbGUsIHJlc3BvbnNlLnBhcnNlVGltZSk7XHJcbiAgICAgICAgY29uc3QgdGlsZSA9IHJlc3BvbnNlLnRpbGU7XHJcbiAgICAgICAgY29uc3QgdGFza1ByaW9yaXR5ID0gUVVFVUVfVEFTS19QUklPUklUSUVTLmZpcnN0VGlsZVBvcnRpb24gK1xyXG4gICAgICAgICAgICB0aGlzLl9nZXRUaWxlUHJpb3JpdHkodGlsZSwgdGhpcy5faXNUaWxlVmlzaWJsZSh0aWxlKSk7XHJcbiAgICAgICAgdGhpcy5fdGFza1F1ZXVlLmVucXVldWUoe1xyXG4gICAgICAgICAgICBwcmlvcml0eTogdGFza1ByaW9yaXR5LFxyXG4gICAgICAgICAgICBleGVjdXRlOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBhdGxhcyBtdXN0IGJlIHVwZGF0ZWQgbm90d2l0aHN0YW5kaW5nIHRoZSB0aWxlIGlzIGFjdGl2ZSBvciBub3RcclxuICAgICAgICAgICAgICAgIC8vIGFzIHRoZXNlIG5ldyBnbHlwaHMgd2lsbCBiZSB1c2VkIGluIG5leHQgdGlsZXNcclxuICAgICAgICAgICAgICAgIGNvbnN0IGF0bGFzID0gcmVzcG9uc2UuZ2x5cGhBdGxhc1RvVXBkYXRlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGF0bGFzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ2x5cGhBdGxhcy51cGRhdGVDb250ZW50KGF0bGFzLndpZHRoLCBhdGxhcy5oZWlnaHQsIGF0bGFzLmRhdGEsIG5ldyBNYXAoYXRsYXMuZ2x5cGhMb2NhdGlvbnMpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2lzdHJ5ID0gcmVzcG9uc2UuZm9udFJlZ2lzdHJ5VG9VcGRhdGU7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVnaXN0cnkpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGZvbnREYXRhIG9mIHJlZ2lzdHJ5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmb250O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fZm9udFJlZ2lzdHJ5LmNvbnRhaW5zKGZvbnREYXRhLmlkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udCA9IHRoaXMuX2ZvbnRSZWdpc3RyeS5nZXQoZm9udERhdGEuaWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udCA9IG5ldyBEZkZvbnQoZm9udERhdGEuaWQsIGZvbnREYXRhLnhoZWlnaHQsIGZvbnREYXRhLm1hcmdpbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9mb250UmVnaXN0cnkuYWRkKGZvbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbnQuYWRkQWxsR2x5cGhzKGZvbnREYXRhLmdseXBocyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdElkID0gcmVzcG9uc2UucmVxdWVzdElkO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pc1RpbGVTdGlsbEFjdGl2ZSh0aWxlLCByZXF1ZXN0SWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gSWYgdGlsZSBpcyBiZWluZyByZWZyZXNoZWQgZG9uJ3QgdmlzdWFsaXplIGFueSBwb3J0aW9ucyB1bnRpbCBhbGwgb2YgdGhlbSBhcmUgbG9hZGVkIHRvIGF2b2lkIGEgYmxpbmtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGlzUmVmcmVzaGluZyA9IHRoaXMuX2lzVGlsZVJlZnJlc2hpbmcodGlsZSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpY29uc1NwbGl0dGVkID0gc3BsaXRJbWFnZURlcGVuZGFudFByaW1pdGl2ZXMocmVzcG9uc2UucG9pbnRzLCB0aGlzLl9pbWFnZU1hbmFnZXJOZWFyZXN0LCAocG9pbnQpID0+IHBvaW50LnN0eWxlc1swXS5pbWFnZUlkKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRleHR1cmVkUG9seWxpbmVzU3BsaXR0ZWQgPSBzcGxpdEltYWdlRGVwZW5kYW50UHJpbWl0aXZlcyhyZXNwb25zZS50ZXh0dXJlZFBvbHlsaW5lcywgdGhpcy5faW1hZ2VNYW5hZ2VyTGluZWFyLCAocG9seWxpbmUpID0+IHBvbHlsaW5lLnN0eWxlc1swXS5pbmxpbmUucGF0dGVybi5pbWFnZUlkKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRleHR1cmVkUG9seWdvbnNJbWFnZXMgPSBnZXRJbWFnZXNJZkFsbEFsbG9jYXRlZChyZXNwb25zZS50ZXh0dXJlZFBvbHlnb25zLCB0aGlzLl9pbWFnZU1hbmFnZXJOZWFyZXN0LCAocG9seWdvbikgPT4gcG9seWdvbi5zdHlsZXNbMF0ucGF0dGVybi5pbWFnZUlkKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Rhc2tRdWV1ZS5lbnF1ZXVlKHtcclxuICAgICAgICAgICAgICAgICAgICBwcmlvcml0eTogUVVFVUVfVEFTS19QUklPUklUSUVTLnNlY29uZFRpbGVQb3J0aW9uICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ2V0VGlsZVByaW9yaXR5KHRpbGUsIHRoaXMuX2lzVGlsZVZpc2libGUodGlsZSkpLFxyXG4gICAgICAgICAgICAgICAgICAgIGV4ZWN1dGU6ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzVGlsZVN0aWxsQWN0aXZlKHRpbGUsIHJlc3BvbnNlLnJlcXVlc3RJZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3B1dFRpbGVEYXRhKHRpbGUsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29uczogdGhpcy5fYWxsb2NhdGVQb2x5Z29ucyhyZXNwb25zZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWxzOiB0aGlzLl9hbGxvY2F0ZU1lc2hlcyhyZXNwb25zZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZXJuYWxNZXNoZXM6IHJlc3BvbnNlLmV4dGVybmFsTWVzaGVzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlsaW5lczogdGhpcy5fYWxsb2NhdGVQb2x5bGluZXMocmVzcG9uc2UpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50TGFiZWxzOiB0aGlzLl9hbGxvY2F0ZVBvaW50TGFiZWxzKHJlc3BvbnNlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJ2ZWRMYWJlbHM6IHRoaXMuX2FsbG9jYXRlQ3VydmVkTGFiZWxzKHJlc3BvbnNlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHM6IHRoaXMuX2FsbG9jYXRlSWNvbnModGlsZSwgaWNvbnNTcGxpdHRlZC5wcmltaXRpdmVzV2l0aEFsbG9jYXRlZEltYWdlcywgaWNvbnNTcGxpdHRlZC5hbGxvY2F0ZWRJbWFnZXMpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmVkUG9seWxpbmVzOiB0aGlzLl9hbGxvY2F0ZVRleHR1cmVkUG9seWxpbmVzKHRpbGUsIHRleHR1cmVkUG9seWxpbmVzU3BsaXR0ZWQucHJpbWl0aXZlc1dpdGhBbGxvY2F0ZWRJbWFnZXMsIHRleHR1cmVkUG9seWxpbmVzU3BsaXR0ZWQuYWxsb2NhdGVkSW1hZ2VzKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlZFBvbHlnb25zOiAhdGV4dHVyZWRQb2x5Z29uc0ltYWdlcy5hbGxvY2F0ZWRJbWFnZXMgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXSA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FsbG9jYXRlVGV4dHVyZWRQb2x5Z29ucyh0aWxlLCByZXNwb25zZS50ZXh0dXJlZFBvbHlnb25zLCB0ZXh0dXJlZFBvbHlnb25zSW1hZ2VzLmFsbG9jYXRlZEltYWdlcywgcmVzcG9uc2UudGV4dHVyZWRQb2x5Z29uUGFnZXMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCByZXF1ZXN0SWQsICFpc1JlZnJlc2hpbmcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWNvbnNTcGxpdHRlZC5hbGxvY2F0ZWRJbWFnZXMuZm9yRWFjaChyZWxlYXNlUHJpbWl0aXZlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmVkUG9seWxpbmVzU3BsaXR0ZWQuYWxsb2NhdGVkSW1hZ2VzLmZvckVhY2gocmVsZWFzZVByaW1pdGl2ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGV4dHVyZWRQb2x5Z29uc0ltYWdlcy5hbGxvY2F0ZWRJbWFnZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlZFBvbHlnb25zSW1hZ2VzLmFsbG9jYXRlZEltYWdlcy5mb3JFYWNoKHJlbGVhc2VQcmltaXRpdmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdGVkVGlsZURhdGEgPSB0aGlzLl9yZXF1ZXN0ZWRUaWxlc1N0YXRlLmdldChnZXRUaWxlSWQodGlsZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcXVlc3RlZFRpbGVEYXRhICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiB0aGUgZGF0YSBpcyBzeW5jZWQgb24gdGhlc2UgdHdvIHByb3BlcnRpZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICBhbmQgdGhpcyBjb2RlIGRvZXNuJ3QgbWFrZSBtdWNoIHNlbnNlIGZvciBub3csXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgYnV0IGl0IGlzIGxlZnQgXCJhcyBpc1wiIHNpbmNlIGl0IGlzIG5vdCBjbGVhclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgIGhvdyBpdCB3aWxsIGJlIGNoYW5nZWQgaW4gbmVhcmVzdCBmdXR1cmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0ZWRUaWxlRGF0YS5pc0dlb21ldHJ5UmVhZHkgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RlZFRpbGVEYXRhLmFyZUxhYmVsc1JlYWR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vblRpbGVEYXRhUmVhZHkodGlsZSwgcmVzcG9uc2UudXJsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHV0RGF0YVByb21pc2VzID0gW107XHJcbiAgICAgICAgICAgICAgICBwdXREYXRhUHJvbWlzZXMucHVzaChpY29uc1NwbGl0dGVkLm1pc3NpbmdJbWFnZXMudGhlbigoaW1hZ2VzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25NaXNzaW5nSWNvbkltYWdlc1JlYWR5KHJlc3BvbnNlLCBpY29uc1NwbGl0dGVkLCBpbWFnZXMpO1xyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgcHV0RGF0YVByb21pc2VzLnB1c2godGV4dHVyZWRQb2x5bGluZXNTcGxpdHRlZC5taXNzaW5nSW1hZ2VzLnRoZW4oKGltYWdlcykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29uTWlzc2luZ1BvbHlsaW5lSW1hZ2VzUmVhZHkocmVzcG9uc2UsIHRleHR1cmVkUG9seWxpbmVzU3BsaXR0ZWQsIGltYWdlcyk7XHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGV4dHVyZWRQb2x5Z29uc0ltYWdlcy5taXNzaW5nSW1hZ2VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHV0RGF0YVByb21pc2VzLnB1c2godGV4dHVyZWRQb2x5Z29uc0ltYWdlcy5taXNzaW5nSW1hZ2VzLnRoZW4oKGltYWdlcykgPT4gdGhpcy5fb25NaXNzaW5nUG9seWdvbkltYWdlc1JlYWR5KHJlc3BvbnNlLCBpbWFnZXMpKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNSZWZyZXNoaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiBhbGwgdGhlIHBvcnRpb25zIGFyZSBsb2FkZWQsIHB1dCBlbXB0eSBkYXRhIHRvIHZpc3VhemxpemUgaXRcclxuICAgICAgICAgICAgICAgICAgICBQcm9taXNlLmFsbChwdXREYXRhUHJvbWlzZXMpLnRoZW4oKCkgPT4gdGhpcy5fcHV0VGlsZURhdGEodGlsZSwge30sIHJlcXVlc3RJZCwgdHJ1ZSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfb25NaXNzaW5nSWNvbkltYWdlc1JlYWR5KHJlc3BvbnNlLCBpY29uc1NwbGl0dGVkLCBpbWFnZXMpIHtcclxuICAgICAgICBjb25zdCB0aWxlID0gcmVzcG9uc2UudGlsZTtcclxuICAgICAgICB0aGlzLl9taW5vclRhc2tRdWV1ZS5lbnF1ZXVlKHtcclxuICAgICAgICAgICAgcHJpb3JpdHk6IERFRkFVTFRfSURMRV9UQVNLX1BSSU9SSVRZICtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2dldFRpbGVQcmlvcml0eSh0aWxlLCB0aGlzLl9pc1RpbGVWaXNpYmxlKHRpbGUpKSxcclxuICAgICAgICAgICAgZXhlY3V0ZTogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lzVGlsZVN0aWxsQWN0aXZlKHRpbGUsIHJlc3BvbnNlLnJlcXVlc3RJZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb2ludHMgPSB0aGlzLl9hbGxvY2F0ZUljb25zKHRpbGUsIGljb25zU3BsaXR0ZWQucHJpbWl0aXZlc1dpdGhNaXNzaW5nSW1hZ2VzLCBpbWFnZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3B1dFRpbGVEYXRhKHRpbGUsIHsgcG9pbnRzIH0sIHJlc3BvbnNlLnJlcXVlc3RJZCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaW1hZ2VzLmZvckVhY2gocmVsZWFzZVByaW1pdGl2ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIF9vbk1pc3NpbmdQb2x5bGluZUltYWdlc1JlYWR5KHJlc3BvbnNlLCB0ZXh0dXJlZFBvbHlsaW5lc1NwbGl0dGVkLCBpbWFnZXMpIHtcclxuICAgICAgICBjb25zdCB0aWxlID0gcmVzcG9uc2UudGlsZTtcclxuICAgICAgICB0aGlzLl9taW5vclRhc2tRdWV1ZS5lbnF1ZXVlKHtcclxuICAgICAgICAgICAgcHJpb3JpdHk6IERFRkFVTFRfSURMRV9UQVNLX1BSSU9SSVRZICsgdGhpcy5fZ2V0VGlsZVByaW9yaXR5KHRpbGUsIHRoaXMuX2lzVGlsZVZpc2libGUodGlsZSkpLFxyXG4gICAgICAgICAgICBleGVjdXRlOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNUaWxlU3RpbGxBY3RpdmUodGlsZSwgcmVzcG9uc2UucmVxdWVzdElkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHR1cmVkUG9seWxpbmVzID0gdGhpcy5fYWxsb2NhdGVUZXh0dXJlZFBvbHlsaW5lcyh0aWxlLCB0ZXh0dXJlZFBvbHlsaW5lc1NwbGl0dGVkLnByaW1pdGl2ZXNXaXRoTWlzc2luZ0ltYWdlcywgaW1hZ2VzKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wdXRUaWxlRGF0YSh0aWxlLCB7IHRleHR1cmVkUG9seWxpbmVzIH0sIHJlc3BvbnNlLnJlcXVlc3RJZCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaW1hZ2VzLmZvckVhY2gocmVsZWFzZVByaW1pdGl2ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIF9vbk1pc3NpbmdQb2x5Z29uSW1hZ2VzUmVhZHkocmVzcG9uc2UsIGltYWdlcykge1xyXG4gICAgICAgIGNvbnN0IHRpbGUgPSByZXNwb25zZS50aWxlO1xyXG4gICAgICAgIHRoaXMuX21pbm9yVGFza1F1ZXVlLmVucXVldWUoe1xyXG4gICAgICAgICAgICBwcmlvcml0eTogREVGQVVMVF9JRExFX1RBU0tfUFJJT1JJVFkgK1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZ2V0VGlsZVByaW9yaXR5KHRpbGUsIHRoaXMuX2lzVGlsZVZpc2libGUodGlsZSkpLFxyXG4gICAgICAgICAgICBleGVjdXRlOiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNUaWxlU3RpbGxBY3RpdmUodGlsZSwgcmVzcG9uc2UucmVxdWVzdElkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHR1cmVkUG9seWdvbnMgPSB0aGlzLl9hbGxvY2F0ZVRleHR1cmVkUG9seWdvbnModGlsZSwgcmVzcG9uc2UudGV4dHVyZWRQb2x5Z29ucywgaW1hZ2VzLCByZXNwb25zZS50ZXh0dXJlZFBvbHlnb25QYWdlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHV0VGlsZURhdGEodGlsZSwgeyB0ZXh0dXJlZFBvbHlnb25zIH0sIHJlc3BvbnNlLnJlcXVlc3RJZCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaW1hZ2VzLmZvckVhY2gocmVsZWFzZVByaW1pdGl2ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIF9vblRpbGVFcnJvcih0aWxlKSB7XHJcbiAgICAgICAgc3VwZXIuX29uVGlsZUVycm9yKHRpbGUpO1xyXG4gICAgICAgIHRoaXMuX3JlcXVlc3RlZFRpbGVzU3RhdGUuZGVsZXRlKGdldFRpbGVJZCh0aWxlKSk7XHJcbiAgICB9XHJcbiAgICBfaXNUaWxlVmlzaWJsZSh0aWxlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRUaWxlcy5oYXMoZ2V0VGlsZUlkKHRpbGUpKTtcclxuICAgIH1cclxuICAgIF9hbGxvY2F0ZVBvbHlnb25zKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgY29uc3QgcG9seWdvblByaW1pdGl2ZXMgPSBuZXcgQXJyYXkocmVzcG9uc2UucG9seWdvbnMubGVuZ3RoICsgcmVzcG9uc2UudHJhbnNwYXJlbnRQb2x5Z29ucy5sZW5ndGgpO1xyXG4gICAgICAgIGNvbnN0IG1lbW9yeUNodW5rcyA9IG5ldyBNZW1vcnlDaHVua3MocmVzcG9uc2UucG9seWdvblBhZ2VzLCB0aGlzLl9tZW1vcnlNYW5hZ2VyLCBQT0xZR09OX0FUVFJJQlVURV9NQVBQSU5HKTtcclxuICAgICAgICBjb25zdCB0cmFuc3BhcmVudFBvbHlnb25zTWVtb3J5Q2h1bmtzID0gbmV3IE1lbW9yeUNodW5rcyhyZXNwb25zZS50cmFuc3BhcmVudFBvbHlnb25QYWdlcywgdGhpcy5fbWVtb3J5TWFuYWdlciwgVFJBTlNQQVJFTlRfUE9MWUdPTl9BVFRSSUJVVEVfTUFQUElORyk7XHJcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3BvbnNlLnBvbHlnb25zLmxlbmd0aDsgaSsrLCBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgYnVmZmVyTG9jYXRpb24gfSA9IHJlc3BvbnNlLnBvbHlnb25zW2ldO1xyXG4gICAgICAgICAgICBwb2x5Z29uUHJpbWl0aXZlc1tpbmRleF0gPSBuZXcgUmVuZGVyYWJsZVBvbHlnb24obmV3IE1lbW9yeVN1YkNodW5rKG1lbW9yeUNodW5rc1tidWZmZXJMb2NhdGlvbi5idWZmZXJJbmRleF0sIGJ1ZmZlckxvY2F0aW9uKSwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzcG9uc2UudHJhbnNwYXJlbnRQb2x5Z29ucy5sZW5ndGg7IGkrKywgaW5kZXgrKykge1xyXG4gICAgICAgICAgICBjb25zdCB7IGJ1ZmZlckxvY2F0aW9uIH0gPSByZXNwb25zZS50cmFuc3BhcmVudFBvbHlnb25zW2ldO1xyXG4gICAgICAgICAgICBwb2x5Z29uUHJpbWl0aXZlc1tpbmRleF0gPSBuZXcgUmVuZGVyYWJsZVBvbHlnb24obmV3IE1lbW9yeVN1YkNodW5rKHRyYW5zcGFyZW50UG9seWdvbnNNZW1vcnlDaHVua3NbYnVmZmVyTG9jYXRpb24uYnVmZmVySW5kZXhdLCBidWZmZXJMb2NhdGlvbiksIGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbWVtb3J5Q2h1bmtzLmZvckVhY2goKGNodW5rKSA9PiBjaHVuay5yZWxlYXNlKCkpO1xyXG4gICAgICAgIHRyYW5zcGFyZW50UG9seWdvbnNNZW1vcnlDaHVua3MuZm9yRWFjaCgoY2h1bmspID0+IGNodW5rLnJlbGVhc2UoKSk7XHJcbiAgICAgICAgcmV0dXJuIHBvbHlnb25QcmltaXRpdmVzO1xyXG4gICAgfVxyXG4gICAgX2FsbG9jYXRlVGV4dHVyZWRQb2x5Z29ucyh0aWxlLCBwb2x5Z29uRGVzY3JpcHRpb25zLCBpbWFnZXMsIHRleHR1cmVkUG9seWdvblBhZ2VzKSB7XHJcbiAgICAgICAgY29uc3QgdGV4dHVyZWRQb2x5Z29uUmV3cml0ZXIgPSBuZXcgVGV4dHVyZWRQb2x5Z29uQnVmZmVyUmV3cml0ZXIodGV4dHVyZWRQb2x5Z29uUGFnZXMpO1xyXG4gICAgICAgIGNvbnN0IHdvcmxkVG9QeEZhY3RvciA9IFdPUkxEX1NJWkUgLyAodGhpcy5fdGlsZVNpZGVTaXplUHggKiBNYXRoLnBvdygyLCB0aWxlLnpvb20pKTtcclxuICAgICAgICBjb25zdCBsb2NhdGlvbnMgPSBwb2x5Z29uRGVzY3JpcHRpb25zLm1hcCgocGFyc2VkUG9seWdvbiwgaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgaW1hZ2UgPSBpbWFnZXNbaW5kZXhdO1xyXG4gICAgICAgICAgICBpZiAoaW1hZ2UpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFsbG9jYXRlZEltYWdlID0gaW1hZ2U7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXR0ZXJuID0gcGFyc2VkUG9seWdvbi5zdHlsZXNbMF0ucGF0dGVybjtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGltYWdlU2NhbGUgPSBwYXR0ZXJuLndpZHRoIC8gYWxsb2NhdGVkSW1hZ2UuZGVzY3JpcHRvci53aWR0aDtcclxuICAgICAgICAgICAgICAgIHRleHR1cmVkUG9seWdvblJld3JpdGVyLnJld3JpdGVVVihwYXJzZWRQb2x5Z29uLmJ1ZmZlckxvY2F0aW9uLCBhbGxvY2F0ZWRJbWFnZS5iYm94LCB3b3JsZFRvUHhGYWN0b3IgKiBpbWFnZVNjYWxlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZWRQb2x5Z29uLmJ1ZmZlckxvY2F0aW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBtZW1vcnlDaHVua3MgPSBuZXcgTWVtb3J5Q2h1bmtzKHRleHR1cmVkUG9seWdvblBhZ2VzLCB0aGlzLl9tZW1vcnlNYW5hZ2VyLCBURVhUVVJFRF9QT0xZR09OX0FUVFJJQlVURV9NQVBQSU5HKTtcclxuICAgICAgICBjb25zdCB0ZXh0dXJlZFBvbHlnb25QcmltaXRpdmVzID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NhdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgbG9jYXRpb24gPSBsb2NhdGlvbnNbaV07XHJcbiAgICAgICAgICAgIGNvbnN0IGltYWdlID0gaW1hZ2VzW2ldO1xyXG4gICAgICAgICAgICBpZiAobG9jYXRpb24gJiYgaW1hZ2UpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRleHR1cmVkUG9seWdvblByaW1pdGl2ZSA9IG5ldyBSZW5kZXJhYmxlVGV4dHVyZWRQb2x5Z29uKG5ldyBNZW1vcnlTdWJDaHVuayhtZW1vcnlDaHVua3NbbG9jYXRpb24uYnVmZmVySW5kZXhdLCBsb2NhdGlvbiksIGltYWdlKTtcclxuICAgICAgICAgICAgICAgIHRleHR1cmVkUG9seWdvblByaW1pdGl2ZXMucHVzaCh0ZXh0dXJlZFBvbHlnb25QcmltaXRpdmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1lbW9yeUNodW5rcy5mb3JFYWNoKChjaHVuaykgPT4gY2h1bmsucmVsZWFzZSgpKTtcclxuICAgICAgICByZXR1cm4gdGV4dHVyZWRQb2x5Z29uUHJpbWl0aXZlcztcclxuICAgIH1cclxuICAgIF9hbGxvY2F0ZU1lc2hlcyh0aWxlUmVzcG9uc2UpIHtcclxuICAgICAgICBjb25zdCBtZW1vcnlDaHVua3MgPSB0aWxlUmVzcG9uc2UubWVzaFBhZ2VzLm1hcCgocGFnZSkgPT4gdGhpcy5fbWVtb3J5TWFuYWdlci5hbGxvY2F0ZShwYWdlLnZlcnRleEJ1ZmZlciwgcGFnZS5pbmRleEJ1ZmZlciwgTW9kZWxCdWZmZXJXcml0ZXIuQVRUUklCVVRFX01BUFBJTkcpKTtcclxuICAgICAgICBjb25zdCBtZXNoUHJpbWl0aXZlcyA9IHRpbGVSZXNwb25zZS5tZXNoZXMubWFwKChtZXNoKSA9PiBuZXcgUmVuZGVyYWJsZU1vZGVsKG5ldyBNZW1vcnlTdWJDaHVuayhtZW1vcnlDaHVua3NbbWVzaC5idWZmZXJMb2NhdGlvbi5idWZmZXJJbmRleF0sIG1lc2guYnVmZmVyTG9jYXRpb24pKSk7XHJcbiAgICAgICAgbWVtb3J5Q2h1bmtzLmZvckVhY2goKGNodW5rKSA9PiBjaHVuay5yZWxlYXNlKCkpO1xyXG4gICAgICAgIHJldHVybiBtZXNoUHJpbWl0aXZlcztcclxuICAgIH1cclxuICAgIF9hbGxvY2F0ZVBvbHlsaW5lcyhyZXNwb25zZSkge1xyXG4gICAgICAgIGNvbnN0IHBvbHlsaW5lUHJpbWl0aXZlcyA9IG5ldyBBcnJheShyZXNwb25zZS5wb2x5bGluZXMubGVuZ3RoKTtcclxuICAgICAgICBjb25zdCBtZW1vcnlDaHVua3MgPSBuZXcgTWVtb3J5Q2h1bmtzKHJlc3BvbnNlLnBvbHlsaW5lUGFnZXMsIHRoaXMuX21lbW9yeU1hbmFnZXIsIFBPTFlMSU5FX0FUVFJJQlVURV9NQVBQSU5HKTtcclxuICAgICAgICBsZXQgaW5kZXggPSAwO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzcG9uc2UucG9seWxpbmVzLmxlbmd0aDsgaSsrLCBpbmRleCsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgYnVmZmVyTG9jYXRpb24gfSA9IHJlc3BvbnNlLnBvbHlsaW5lc1tpXTtcclxuICAgICAgICAgICAgcG9seWxpbmVQcmltaXRpdmVzW2luZGV4XSA9IG5ldyBSZW5kZXJhYmxlUG9seWxpbmUobmV3IE1lbW9yeVN1YkNodW5rKG1lbW9yeUNodW5rc1tidWZmZXJMb2NhdGlvbi5idWZmZXJJbmRleF0sIGJ1ZmZlckxvY2F0aW9uKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1lbW9yeUNodW5rcy5mb3JFYWNoKChjaHVuaykgPT4gY2h1bmsucmVsZWFzZSgpKTtcclxuICAgICAgICByZXR1cm4gcG9seWxpbmVQcmltaXRpdmVzO1xyXG4gICAgfVxyXG4gICAgX2FsbG9jYXRlVGV4dHVyZWRQb2x5bGluZXModGlsZSwgcGFyc2VkUG9seWxpbmVzLCBpbWFnZXMpIHtcclxuICAgICAgICBjb25zdCB0ZXh0dXJlZFBvbHlsaW5lV3JpdGVyID0gbmV3IFRleHR1cmVkUG9seWxpbmVCdWZmZXJXcml0ZXIoKTtcclxuICAgICAgICBjb25zdCB3b3JsZFRvUHhGYWN0b3IgPSBXT1JMRF9TSVpFIC8gKHRoaXMuX3RpbGVTaWRlU2l6ZVB4ICogTWF0aC5wb3coMiwgdGlsZS56b29tKSk7XHJcbiAgICAgICAgY29uc3QgbG9jYXRpb25zID0gcGFyc2VkUG9seWxpbmVzLm1hcCgocGFyc2VkUG9seWxpbmUsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGltYWdlID0gaW1hZ2VzW2luZGV4XTtcclxuICAgICAgICAgICAgaWYgKGltYWdlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdHlsZSA9IHBhcnNlZFBvbHlsaW5lLnN0eWxlc1swXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gKHN0eWxlLmlubGluZSB8fCBzdHlsZS5vdXRsaW5lKS5zdHJva2VXaWR0aDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGltYWdlTG9jYXRpb24gPSBpbWFnZS5iYm94O1xyXG4gICAgICAgICAgICAgICAgLy8gaW1hZ2Ugc2l6ZSBtYXkgbm90IG1hdGNoIHBvbHlsaW5lJ3Mgc3Ryb2tlV2lkdGgsIHNvIGl0IG11c3QgYmUgc2NhbGVkIGFjY29yZGluZ2x5IGluXHJcbiAgICAgICAgICAgICAgICAvLyBib3RoIGRpcmVjdGlvbnMsIHRoaXMgZmFjdG9yIGNhbiBiZSBwYXNzZWQgdG8gdGhlIHdyaXRlciBpbiB3b3JsZFRvUHhGYWN0b3IgdXBkYXRlZC5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHBpeGVsUmF0aW8gPSB3aWR0aCAvIChpbWFnZUxvY2F0aW9uLm1heFkgLSBpbWFnZUxvY2F0aW9uLm1pblkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRleHR1cmVkUG9seWxpbmVXcml0ZXIud3JpdGVUZXh0dXJlZFBvbHlsaW5lKHBhcnNlZFBvbHlsaW5lLCB3aWR0aCwgd29ybGRUb1B4RmFjdG9yICogcGl4ZWxSYXRpbywgaW1hZ2VMb2NhdGlvbiwgc3R5bGUuekluZGV4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgcGFnZXMgPSB0ZXh0dXJlZFBvbHlsaW5lV3JpdGVyLmdldEJ1ZmZlcnMoKTtcclxuICAgICAgICBjb25zdCBtZW1vcnlDaHVua3MgPSBuZXcgTWVtb3J5Q2h1bmtzKHBhZ2VzLCB0aGlzLl9tZW1vcnlNYW5hZ2VyLCBUZXh0dXJlZFBvbHlsaW5lQnVmZmVyV3JpdGVyLkFUVFJJQlVURV9NQVBQSU5HKTtcclxuICAgICAgICBjb25zdCB0ZXh0dXJlZFBvbHlsaW5lUHJpbWl0aXZlcyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jYXRpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0gbG9jYXRpb25zW2ldO1xyXG4gICAgICAgICAgICBjb25zdCBpbWFnZSA9IGltYWdlc1tpXTtcclxuICAgICAgICAgICAgaWYgKGxvY2F0aW9uICYmIGltYWdlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0dXJlZFBvbHlsaW5lUHJpbWl0aXZlID0gbmV3IFJlbmRlcmFibGVUZXh0dXJlZFBvbHlsaW5lKG5ldyBNZW1vcnlTdWJDaHVuayhtZW1vcnlDaHVua3NbbG9jYXRpb24uYnVmZmVySW5kZXhdLCBsb2NhdGlvbiksIGltYWdlKTtcclxuICAgICAgICAgICAgICAgIHRleHR1cmVkUG9seWxpbmVQcmltaXRpdmVzLnB1c2godGV4dHVyZWRQb2x5bGluZVByaW1pdGl2ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbWVtb3J5Q2h1bmtzLmZvckVhY2goKGNodW5rKSA9PiBjaHVuay5yZWxlYXNlKCkpO1xyXG4gICAgICAgIHJldHVybiB0ZXh0dXJlZFBvbHlsaW5lUHJpbWl0aXZlcztcclxuICAgIH1cclxuICAgIF9hbGxvY2F0ZVBvaW50TGFiZWxzKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgY29uc3QgbWVtb3J5Q2h1bmtzID0gbmV3IE1lbW9yeUNodW5rcyhyZXNwb25zZS5wb2ludExhYmVsUGFnZXMsIHRoaXMuX21lbW9yeU1hbmFnZXIsIFBPSU5UX0xBQkVMX0FUVFJJQlVURV9NQVBQSU5HKTtcclxuICAgICAgICBjb25zdCBiYWNrZ3JvdW5kTWVtb3J5Q2h1bmtzID0gbmV3IE1lbW9yeUNodW5rcyhyZXNwb25zZS5wb2ludExhYmVsQmFja2dyb3VuZFBhZ2VzLCB0aGlzLl9tZW1vcnlNYW5hZ2VyLCBCSUxMQk9BUkRfUkVDVEFOR0xFX0FUVFJJQlVURV9NQVBQSU5HKTtcclxuICAgICAgICBjb25zdCBwb2ludExhYmVscyA9IHJlc3BvbnNlLnBvaW50TGFiZWxzLm1hcCgoeyBidWZmZXJMb2NhdGlvbiwgYmFja2dyb3VuZEJ1ZmZlckxvY2F0aW9uIH0pID0+IHtcclxuICAgICAgICAgICAgY29uc3QgYmFja2dyb3VuZFByaW1pdGl2ZSA9IGJhY2tncm91bmRCdWZmZXJMb2NhdGlvbiA/XHJcbiAgICAgICAgICAgICAgICBuZXcgUmVuZGVyYWJsZUJpbGxib2FyZFJlY3RhbmdsZShuZXcgTWVtb3J5U3ViQ2h1bmsoYmFja2dyb3VuZE1lbW9yeUNodW5rc1tiYWNrZ3JvdW5kQnVmZmVyTG9jYXRpb24uYnVmZmVySW5kZXhdLCBiYWNrZ3JvdW5kQnVmZmVyTG9jYXRpb24pKSA6XHJcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsUHJpbWl0aXZlID0gbmV3IFpvb21SZXN0cmljdGVkTGFiZWwobmV3IE1lbW9yeVN1YkNodW5rKG1lbW9yeUNodW5rc1tidWZmZXJMb2NhdGlvbi5idWZmZXJJbmRleF0sIGJ1ZmZlckxvY2F0aW9uKSwgdGhpcy5fZ2x5cGhBdGxhcywgdGhpcy5fY29tcHV0ZU1pblpvb20ocmVzcG9uc2UudGlsZSwgTUlOWk9PTV9ERUxUQVMucG9pbnRMYWJlbHMpLCBiYWNrZ3JvdW5kUHJpbWl0aXZlKTtcclxuICAgICAgICAgICAgaWYgKGJhY2tncm91bmRQcmltaXRpdmUpIHtcclxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRQcmltaXRpdmUucmVsZWFzZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBsYWJlbFByaW1pdGl2ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBiYWNrZ3JvdW5kTWVtb3J5Q2h1bmtzLmZvckVhY2goKGNodW5rKSA9PiBjaHVuay5yZWxlYXNlKCkpO1xyXG4gICAgICAgIG1lbW9yeUNodW5rcy5mb3JFYWNoKChjaHVuaykgPT4gY2h1bmsucmVsZWFzZSgpKTtcclxuICAgICAgICByZXR1cm4gcG9pbnRMYWJlbHM7XHJcbiAgICB9XHJcbiAgICBfYWxsb2NhdGVDdXJ2ZWRMYWJlbHMocmVzcG9uc2UpIHtcclxuICAgICAgICBjb25zdCBtZW1vcnlDaHVua3MgPSBuZXcgTWVtb3J5Q2h1bmtzKHJlc3BvbnNlLmN1cnZlZExhYmVsUGFnZXMsIHRoaXMuX21lbW9yeU1hbmFnZXIsIENVUlZFRF9MQUJFTF9BVFRSSUJVVEVfTUFQUElORyk7XHJcbiAgICAgICAgY29uc3QgY3VydmVkTGFiZWxQcmltaXRpdmVzID0gcmVzcG9uc2UuY3VydmVkTGFiZWxzLm1hcCgoeyBidWZmZXJMb2NhdGlvbiB9KSA9PiBuZXcgWm9vbVJlc3RyaWN0ZWRMYWJlbChuZXcgTWVtb3J5U3ViQ2h1bmsobWVtb3J5Q2h1bmtzW2J1ZmZlckxvY2F0aW9uLmJ1ZmZlckluZGV4XSwgYnVmZmVyTG9jYXRpb24pLCB0aGlzLl9nbHlwaEF0bGFzLCB0aGlzLl9jb21wdXRlTWluWm9vbShyZXNwb25zZS50aWxlLCBNSU5aT09NX0RFTFRBUy5jdXJ2ZWRMYWJlbHMpKSk7XHJcbiAgICAgICAgbWVtb3J5Q2h1bmtzLmZvckVhY2goKGNodW5rKSA9PiBjaHVuay5yZWxlYXNlKCkpO1xyXG4gICAgICAgIHJldHVybiBjdXJ2ZWRMYWJlbFByaW1pdGl2ZXM7XHJcbiAgICB9XHJcbiAgICBfYWxsb2NhdGVJY29ucyh0aWxlLCBwYXJzZWRJY29ucywgaW1hZ2VzKSB7XHJcbiAgICAgICAgY29uc3QgaWNvbldyaXRlciA9IG5ldyBJY29uQnVmZmVyV3JpdGVyKCk7XHJcbiAgICAgICAgY29uc3QgbG9jYXRpb25zID0gcGFyc2VkSWNvbnMubWFwKChwYXJzZWRJY29uLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBpbWFnZSA9IGltYWdlc1tpbmRleF07XHJcbiAgICAgICAgICAgIGlmIChpbWFnZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3R5bGUgPSBwYXJzZWRJY29uLnN0eWxlc1swXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNpemUgPSBpbWFnZS5kZXNjcmlwdG9yO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGl4ZWxSYXRpbyA9IHN0eWxlLndpZHRoIC8gc2l6ZS53aWR0aDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpY29uV3JpdGVyLndyaXRlSWNvbihwYXJzZWRJY29uLCBpbWFnZS5iYm94LCBzaXplLCBzdHlsZS5vZmZzZXQsIHBpeGVsUmF0aW8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBwYWdlcyA9IGljb25Xcml0ZXIuZ2V0QnVmZmVycygpO1xyXG4gICAgICAgIGNvbnN0IG1lbW9yeUNodW5rcyA9IG5ldyBNZW1vcnlDaHVua3MocGFnZXMsIHRoaXMuX21lbW9yeU1hbmFnZXIsIEljb25CdWZmZXJXcml0ZXIuQVRUUklCVVRFX01BUFBJTkcpO1xyXG4gICAgICAgIGNvbnN0IGljb25QcmltaXRpdmVzID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NhdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgbG9jYXRpb24gPSBsb2NhdGlvbnNbaV07XHJcbiAgICAgICAgICAgIGNvbnN0IGltYWdlID0gaW1hZ2VzW2ldO1xyXG4gICAgICAgICAgICBpZiAobG9jYXRpb24gJiYgaW1hZ2UpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGljb25QcmltaXRpdmUgPSBuZXcgWm9vbVJlc3RyaWN0ZWRJY29uKG5ldyBNZW1vcnlTdWJDaHVuayhtZW1vcnlDaHVua3NbbG9jYXRpb24uYnVmZmVySW5kZXhdLCBsb2NhdGlvbiksIGltYWdlLCB0aGlzLl9jb21wdXRlTWluWm9vbSh0aWxlLCBNSU5aT09NX0RFTFRBUy5pY29ucykpO1xyXG4gICAgICAgICAgICAgICAgaWNvblByaW1pdGl2ZXMucHVzaChpY29uUHJpbWl0aXZlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBtZW1vcnlDaHVua3MuZm9yRWFjaCgoY2h1bmspID0+IGNodW5rLnJlbGVhc2UoKSk7XHJcbiAgICAgICAgcmV0dXJuIGljb25QcmltaXRpdmVzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlcyBhIG1pbmltdW0gem9vbSBhbiBvYmplY3Qgc2hvdWxkIGJlIHN0aWxsIGRpc3BsYXllZCBvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdGlsZSBUaWxlIHRoZSBvYmplY3QgYmVsb25ncyB0by5cclxuICAgICAqIEBwYXJhbSBkZWx0YSBUb2xlcmFuY2Ugb2YgdGhlIHZpc2liaWxpdHkgdG8gem9vbWluZyBvdXQsIGRlZmF1bHQgdmFsdWUgd2FzIGVtcGlyaWNhbGx5IGNob3Nlbi5cclxuICAgICAqIEByZXR1cm5zIE1pbmltdW0gem9vbSBmb3IgdGhlIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgX2NvbXB1dGVNaW5ab29tKHRpbGUsIGRlbHRhID0gMSkge1xyXG4gICAgICAgIHJldHVybiB0aWxlLnpvb20gLSB0aGlzLl96b29tU2hpZnQgLSB0aGlzLl90YXJnZXRab29tU2hpZnQgLSBkZWx0YTtcclxuICAgIH1cclxuICAgIF9wdXNoUGVyZkxvZ0l0ZW0odGlsZSwgcGFyc2VUaW1lKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3BlcmZMb2dJdGVtcy5sZW5ndGggPCBNQVhfUEVSRl9MT0dfSVRFTVNfQ09VTlQpIHtcclxuICAgICAgICAgICAgdGhpcy5fcGVyZkxvZ0l0ZW1zLnB1c2goeyB0aWxlLCBwYXJzZVRpbWUgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBIZWxwZXIgY2xhc3MgZm9yIGFsbG9jYXRpb24gb2YgYW4gYXJyYXkgb2YgbWVtb3J5IGNodW5rcy5cclxuICovXHJcbmNsYXNzIE1lbW9yeUNodW5rcyBleHRlbmRzIEFycmF5IHtcclxuICAgIGNvbnN0cnVjdG9yKHBhZ2VzLCBtZW1vcnlNYW5hZ2VyLCBhdHRyaWJNYXBwaW5nKSB7XHJcbiAgICAgICAgc3VwZXIocGFnZXMubGVuZ3RoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZ2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXNbaV0gPSBtZW1vcnlNYW5hZ2VyLmFsbG9jYXRlKHBhZ2VzW2ldLnZlcnRleEJ1ZmZlciwgcGFnZXNbaV0uaW5kZXhCdWZmZXIsIGF0dHJpYk1hcHBpbmcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogRGF0YSBtYW5hZ2VycyByZXNwb25zaWJsZSBmb3Igc3BlY2lmaWMgdHlwZSBvZiBwcmltaXRpdmVzLiBJdCBqdXN0IGV4dHJhY3RzIHRoZW0gZnJvbSBUaWxlRGF0YSBhbmRcclxuICogdXBkYXRlcyBhcHByb3ByaWF0ZSBwcmltaXRpdmUgcHJvdmlkZXIuXHJcbiAqL1xyXG5jbGFzcyBUaWxlRGF0YU1hbmFnZXIge1xyXG4gICAgY29uc3RydWN0b3IocHJpbWl0aXZlTWFuYWdlciwgcHJpbWl0dmVFeHRyYWN0b3IpIHtcclxuICAgICAgICB0aGlzLl9wcmltaXRpdmVNYW5hZ2VyID0gcHJpbWl0aXZlTWFuYWdlcjtcclxuICAgICAgICB0aGlzLl9wcmltaXRpdmVFeHRyYWN0b3IgPSBwcmltaXR2ZUV4dHJhY3RvcjtcclxuICAgIH1cclxuICAgIHVwZGF0ZVByaW1pdGl2ZXModG9TaG93LCB0b0hpZGUpIHtcclxuICAgICAgICB0aGlzLl9wcmltaXRpdmVNYW5hZ2VyLnVwZGF0ZVNjZW5lKHRoaXMuX3ByaW1pdGl2ZUV4dHJhY3Rvcih0b1Nob3cpLCB0aGlzLl9wcmltaXRpdmVFeHRyYWN0b3IodG9IaWRlKSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcmVsZWFzZVByaW1pdGl2ZShwcmltaXRpdmUpIHtcclxuICAgIGlmIChwcmltaXRpdmUpIHtcclxuICAgICAgICBwcmltaXRpdmUucmVsZWFzZSgpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUdXJucyByZWplY3Rpb24gb2Ygb3JpZ2luYWwgcHJvbWlzZSBpbnRvIG51bGwtdmFsdWUgcmVzb2x1dGlvbi4gTnVsbHMgb24gYXBwcm9wcmlhdGUgcGxhY2VzXHJcbiAqIGFyZSByZXF1aXJlZCBpbiBhbGxvY2F0aW9uIG9mIHRleHR1cmVkIHByaW1pdGl2ZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBudWxsaWZ5UmVqZWN0aW9uKHByb21pc2UpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gcHJvbWlzZS50aGVuKHJlc29sdmUsICgpID0+IHJlc29sdmUobnVsbCkpKTtcclxufVxyXG4vKipcclxuICogU3BsaXRzIHByaW1pdGl2ZXMgaW50byB0d28gbGlzdHM6IHRob3NlIHRoYXQgaGF2ZSByZXF1aXJlZCBpbWFnZXMgYWxsb2NhdGVkIGFuZCB0aG9zZSB3aGljaCBpbWFnZXMgYXJlIHRvIGJlXHJcbiAqIHJlcXVlc3RlZC4gUmVxdWlyZWQgaW1hZ2VzIHJldHVybmVkIGluIGNvcnJlc3BvbmluZyBhcnJheXMgKHJlcXVlc3RlZCBpbWFnZXMgYXMgcHJvbWlzZXMpLlxyXG4gKi9cclxuZnVuY3Rpb24gc3BsaXRJbWFnZURlcGVuZGFudFByaW1pdGl2ZXMocHJpbWl0aXZlcywgaW1hZ2VNYW5hZ2VyLCBpZE1hcHBlcikge1xyXG4gICAgY29uc3QgcHJpbWl0aXZlc1dpdGhBbGxvY2F0ZWRJbWFnZXMgPSBbXTtcclxuICAgIGNvbnN0IGFsbG9jYXRlZEltYWdlcyA9IFtdO1xyXG4gICAgY29uc3QgcHJpbWl0aXZlc1dpdGhNaXNzaW5nSW1hZ2VzID0gW107XHJcbiAgICBjb25zdCBtaXNzaW5nSW1hZ2VJZHMgPSBbXTtcclxuICAgIGZvciAoY29uc3QgcHJpbWl0aXZlIG9mIHByaW1pdGl2ZXMpIHtcclxuICAgICAgICBjb25zdCBpZCA9IGlkTWFwcGVyKHByaW1pdGl2ZSk7XHJcbiAgICAgICAgY29uc3QgYWxsb2NhdGVkSW1hZ2UgPSBpbWFnZU1hbmFnZXIuZ2V0SW1hZ2UoaWQpO1xyXG4gICAgICAgIGlmIChhbGxvY2F0ZWRJbWFnZSkge1xyXG4gICAgICAgICAgICBwcmltaXRpdmVzV2l0aEFsbG9jYXRlZEltYWdlcy5wdXNoKHByaW1pdGl2ZSk7XHJcbiAgICAgICAgICAgIGFsbG9jYXRlZEltYWdlcy5wdXNoKGFsbG9jYXRlZEltYWdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHByaW1pdGl2ZXNXaXRoTWlzc2luZ0ltYWdlcy5wdXNoKHByaW1pdGl2ZSk7XHJcbiAgICAgICAgICAgIG1pc3NpbmdJbWFnZUlkcy5wdXNoKG51bGxpZnlSZWplY3Rpb24oaW1hZ2VNYW5hZ2VyLnJlcXVlc3RJbWFnZShpZCkpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHByaW1pdGl2ZXNXaXRoQWxsb2NhdGVkSW1hZ2VzLFxyXG4gICAgICAgIGFsbG9jYXRlZEltYWdlcyxcclxuICAgICAgICBwcmltaXRpdmVzV2l0aE1pc3NpbmdJbWFnZXMsXHJcbiAgICAgICAgbWlzc2luZ0ltYWdlczogUHJvbWlzZS5hbGwobWlzc2luZ0ltYWdlSWRzKVxyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyBlaXRoZXIgYXJyYXkgb2YgYWxsb2NhdGVkIGltYWdlcyAoaWYgYWxsIHJlcXVpcmVkIGltYWdlcyBhcmUgb24gdGhlIHNwb3QpIG9yIHByb21pc2VzIGZvciB0aGVtIChpZiBhdCBsZWFzdFxyXG4gKiBvbmUgcmVxdWlyZWQgaW1hZ2UgaXMgbm90IHlldCBhbGxvY2F0ZWQpLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0SW1hZ2VzSWZBbGxBbGxvY2F0ZWQocHJpbWl0aXZlcywgaW1hZ2VNYW5hZ2VyLCBpZE1hcHBlcikge1xyXG4gICAgbGV0IGlzQW55TWlzc2luZyA9IGZhbHNlO1xyXG4gICAgY29uc3QgYWxsb2NhdGVkSW1hZ2VzID0gbmV3IEFycmF5KHByaW1pdGl2ZXMubGVuZ3RoKTtcclxuICAgIGNvbnN0IG1pc3NpbmdJbWFnZXMgPSBuZXcgQXJyYXkocHJpbWl0aXZlcy5sZW5ndGgpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmltaXRpdmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgcHJpbWl0aXZlID0gcHJpbWl0aXZlc1tpXTtcclxuICAgICAgICBjb25zdCBpZCA9IGlkTWFwcGVyKHByaW1pdGl2ZSk7XHJcbiAgICAgICAgY29uc3QgYWxsb2NhdGVkSW1hZ2UgPSBpbWFnZU1hbmFnZXIuZ2V0SW1hZ2UoaWQpO1xyXG4gICAgICAgIGlmIChhbGxvY2F0ZWRJbWFnZSkge1xyXG4gICAgICAgICAgICBhbGxvY2F0ZWRJbWFnZXNbaV0gPSBhbGxvY2F0ZWRJbWFnZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlzQW55TWlzc2luZyA9IHRydWU7XHJcbiAgICAgICAgICAgIG1pc3NpbmdJbWFnZXNbaV0gPSBudWxsaWZ5UmVqZWN0aW9uKGltYWdlTWFuYWdlci5yZXF1ZXN0SW1hZ2UoaWQpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoaXNBbnlNaXNzaW5nKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmltaXRpdmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChhbGxvY2F0ZWRJbWFnZXNbaV0pIHtcclxuICAgICAgICAgICAgICAgIG1pc3NpbmdJbWFnZXNbaV0gPSBQcm9taXNlLnJlc29sdmUoYWxsb2NhdGVkSW1hZ2VzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyBtaXNzaW5nSW1hZ2VzOiBQcm9taXNlLmFsbChtaXNzaW5nSW1hZ2VzKSB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHsgYWxsb2NhdGVkSW1hZ2VzIH07XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdmVjdG9yX2FwaS9hZGFwdGVyLnRzXG4vLyBtb2R1bGUgaWQgPSA2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgQWRhcHRlciBmcm9tICcuLi9hZGFwdGVyJztcclxuaW1wb3J0IFRpbGVDb29yZGluYXRlU3lzdGVtLCB7IGlzUGFyZW50IH0gZnJvbSAnLi91dGlsL3RpbGVfc3lzdGVtJztcclxuaW1wb3J0IHsgYWxsT2ZJdGVyYWJsZSwgb25lT2ZJdGVyYWJsZSB9IGZyb20gJy4uLy4uL3V0aWwvaXRlcmFibGUnO1xyXG5pbXBvcnQgeyBnZXRUaWxlSWQgfSBmcm9tICcuL3RpbGVfaWQnO1xyXG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICcuLi8uLi91dGlsL2V2ZW50X2VtaXR0ZXInO1xyXG5pbXBvcnQgKiBhcyB2ZWMyIGZyb20gJy4uLy4uL21hdGgvdmVjdG9yMic7XHJcbmltcG9ydCB7IE5PX0lEIH0gZnJvbSAnLi4vLi4vdXRpbC93b3JrZXInO1xyXG5pbXBvcnQgeyBjb21wdXRlVmlzaWJsZVRpbGVzIH0gZnJvbSAnLi91dGlsL3Zpc2libGVfdGlsZSc7XHJcbmltcG9ydCB7IGNhbGN1bGF0ZUJlbHRUaWxlcyB9IGZyb20gJy4vYmVsdF90aWxlcyc7XHJcbmltcG9ydCB7IGNvdW50VGlsZVByb2Nlc3NpbmdUaW1lIH0gZnJvbSAnLi4vLi4vdXRpbC9zdGF0JztcclxuY29uc3QgTk9fVElMRVNfVE9fSEFORExFID0gW107XHJcbmNvbnN0IE1BWF9QRVJGX0xPR19JVEVNU19DT1VOVCA9IDEwMjQ7XHJcbi8vIFRvIHNlbGVjdCB3aGljaCB0aWxlIHRvIGxvYWQgY2FtZXJhIHpvb20gaXMgcm91bmRlZCBzbyB0aGUgc2hpZnQgaXMgMC41LlxyXG5jb25zdCBUQVJHRVRfWk9PTV9TSElGVCA9IDAuMjU7XHJcbmNvbnN0IFZJU0lCTEVfVElMRV9QUklPUklUWSA9IDIwMDtcclxuZnVuY3Rpb24qIGZsYXR0ZW5WaXNpYmxlRGF0YVBvcnRpb25zKHRpbGVzKSB7XHJcbiAgICBmb3IgKGNvbnN0IHRpbGUgb2YgdGlsZXMpIHtcclxuICAgICAgICB5aWVsZCogdGlsZS5kYXRhLnZpc2libGU7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZ2V0Wm9vbVNoaWZ0KHRpbGVTaXplKSB7XHJcbiAgICBzd2l0Y2ggKHRpbGVTaXplKSB7XHJcbiAgICAgICAgY2FzZSAxIC8qIFg0ICovOlxyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgY2FzZSAyIC8qIFgxNiAqLzpcclxuICAgICAgICAgICAgcmV0dXJuIC0yO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBCYXNlIGNsYXNzIGZvciBhZGFwdGVycyB0aGF0IGdldCB0aGVpciBkYXRhIGluIHRpbGVzLiBDb250ZW50IG9mIHRpbGVzIHRoYXQgY29tZSBpbnRvIGZpZWxkIG9mIHZpZXcgc2hvdWxkXHJcbiAqIGJlIHJlcXVlc3RlZCwgYXMgd2VsbCBhcyBjb250ZW50IG9mIGludmlzaWJsZSB0aWxlcyBzaG91bGQgYmUgcmVtb3ZlZCwgYWxzbyB0aWxlcyBvbiBkaWZmZXJlbnQgem9vbSBsZXZlbHMgY2FuXHJcbiAqIG92ZXJsYXAgZWFjaCBvdGhlci4gTWFuYWdpbmcgb2YgYWxsIHRoZXNlIGNhc2VzIGFuZCBvdGhlciB0aWxlLXNwZWNpZmljIGxvZ2ljIGlzIHRoZSByZXNwb25zaWJpbGl0eSBvZiB0aGlzIGNsYXNzLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGlsZUJhc2VkQWRhcHRlciBleHRlbmRzIEFkYXB0ZXIge1xyXG4gICAgY29uc3RydWN0b3IoZW5naW5lLCBjYW1lcmEsIHRpbGVTaXplID0gMCAvKiBYMSAqLywgcHJlbG9hZGVkVGlsZXNCZWx0U2l6ZSA9IDAsIGxheWVyTmFtZSA9ICcnKSB7XHJcbiAgICAgICAgc3VwZXIoZW5naW5lLCBjYW1lcmEpO1xyXG4gICAgICAgIHRoaXMuX2xheWVyTmFtZSA9IGxheWVyTmFtZTtcclxuICAgICAgICB0aGlzLl96b29tU2hpZnQgPSBnZXRab29tU2hpZnQodGlsZVNpemUpO1xyXG4gICAgICAgIHRoaXMuX3RhcmdldFpvb21TaGlmdCA9IFRBUkdFVF9aT09NX1NISUZUO1xyXG4gICAgICAgIHRoaXMuX2VuZ2luZVJlbmRlckxpc3RlbmVyID0gKCkgPT4gdGhpcy5fb25FbmdpbmVSZW5kZXJFdmVudCgpO1xyXG4gICAgICAgIHRoaXMuZW5naW5lLnJlbmRlcmVyLm9uUmVuZGVyLmFkZExpc3RlbmVyKHRoaXMuX2VuZ2luZVJlbmRlckxpc3RlbmVyKTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50VGlsZXMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5fYWxsVGlsZXMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5fcmVhZHlGb3JSZW5kZXJUaWxlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMub25UaWxlUmVhZHkgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5vblRpbGVMb2FkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMuX3JlcXVlc3RlZFRpbGVzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuX3RpbGVzVG9SZWZyZXNoID0gbmV3IFNldCgpO1xyXG4gICAgICAgIHRoaXMuX2JlbHRTaXplID0gcHJlbG9hZGVkVGlsZXNCZWx0U2l6ZTtcclxuICAgICAgICAvLyBTb21ldGltZXMgdGhlIGFkYXB0ZXIgaXNuJ3QgZGVzdHJveWVkLCBqdXN0IHRoZSBwYWdlIGNsb3Nlcy4gTGlzdGVuXHJcbiAgICAgICAgLy8gZm9yIHRoYXQgYW5kIHNlbmQgbWVhc3VyZW1lbnRzIHRvIHRoZSBzdGF0ZmFjZS5cclxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgdGhpcy5fb25CZWZvcmVVbmxvYWRMaXN0ZW5lciA9IHRoaXMuX3NlbmRTdGF0aXN0aWNzQmVmb3JlRGVzdHJveS5iaW5kKHRoaXMpKTtcclxuICAgICAgICB0aGlzLl90aWxlTG9hZExvZ3MgPSBbXTtcclxuICAgIH1cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIHRoaXMuX29uQmVmb3JlVW5sb2FkTGlzdGVuZXIpO1xyXG4gICAgICAgIHRoaXMuX3NlbmRTdGF0aXN0aWNzQmVmb3JlRGVzdHJveSgpO1xyXG4gICAgICAgIHRoaXMuZW5naW5lLnJlbmRlcmVyLm9uUmVuZGVyLnJlbW92ZUxpc3RlbmVyKHRoaXMuX2VuZ2luZVJlbmRlckxpc3RlbmVyKTtcclxuICAgICAgICBzdXBlci5kZXN0cm95KCk7XHJcbiAgICB9XHJcbiAgICBnZXRWaXNpYmxlVGlsZXNOdW1iZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRUaWxlcy5zaXplO1xyXG4gICAgfVxyXG4gICAgZ2V0UGVuZGluZ1RpbGVzTnVtYmVyKCkge1xyXG4gICAgICAgIGxldCBwZW5kaW5nQ291bnRlciA9IDA7XHJcbiAgICAgICAgdGhpcy5fcmVxdWVzdGVkVGlsZXMuZm9yRWFjaCgocmVxdWVzdGVkVGlsZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fY3VycmVudFRpbGVzLmdldChnZXRUaWxlSWQocmVxdWVzdGVkVGlsZS50aWxlSXRlbSkpKSB7XHJcbiAgICAgICAgICAgICAgICBwZW5kaW5nQ291bnRlcisrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHBlbmRpbmdDb3VudGVyO1xyXG4gICAgfVxyXG4gICAgX2dldFRhcmdldFpvb20oKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IodGhpcy5jYW1lcmEuem9vbSArIHRoaXMuX3RhcmdldFpvb21TaGlmdCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB0aWxlSXRlbSBUaGUgdGlsZSB0byB3aGljaCB0aGUgZGF0YSBiZWxvbmdzLlxyXG4gICAgICogQHBhcmFtIGRhdGEgRGF0YSBwb3J0aW9uIHRvIGJlIHNob3duIGluIHRpbGUgb25jZSBpdCBpcyByZWFkeSB0byB2aXN1YWxpemUuXHJcbiAgICAgKiBAcGFyYW0gcmVxdWVzdElkIElEIG9mIHRoZSByZXF1ZXN0IGRhdGEgd2FzIHJlcXVlc3RlZCB3aXRoLiBCYXNlZCBvbiB0aGlzIHRoZSBkYXRhIGlzIGJlaW5nIGRpc3BsYXllZCwgc3RvcmVkIGZvclxyXG4gICAgICogZnV0dXJlIHVzZSBvciBkaXNjYXJkZWQuXHJcbiAgICAgKiBAcGFyYW0gdmlzdWFsaXplIElzIHRoaXMgZGF0YSBwb3J0aW9uIGVub3VnaCB0byByZW5kZXIgdGhpcyB0aWxlIGFuZCByZXBsYWNlIG92ZXJsYXBwZWQgb25lcyBpZiBhbnkuXHJcbiAgICAgKi9cclxuICAgIF9wdXRUaWxlRGF0YSh0aWxlSXRlbSwgZGF0YSwgcmVxdWVzdElkID0gTk9fSUQsIHZpc3VhbGl6ZSA9IHRydWUpIHtcclxuICAgICAgICBjb25zdCB0aWxlID0gdGhpcy5fYWxsVGlsZXMuZ2V0KGdldFRpbGVJZCh0aWxlSXRlbSkpO1xyXG4gICAgICAgIGlmICghdGlsZSkge1xyXG4gICAgICAgICAgICAvLyBEYXRhIHJlY2lldmVkIGxhdGUgYW5kIHByb2JhYmx5IHRoZSB0aWxlIGhhZCBiZWVuIGRlc3Ryb3llZC5cclxuICAgICAgICAgICAgLy8gRGVzdHJveSBkYXRhIHRvby5cclxuICAgICAgICAgICAgdGhpcy5fb25UaWxlRGVzdHJveSh0aWxlSXRlbSwgW2RhdGFdKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBOT19JRCBwYXNzZWQgaGVyZSBtZWFucyBjb25jcmV0ZSBhZGFwdGVyIGRvZXNuJ3QgY2FyZSB0byBsYWJlbCB0aWxlIGRhdGEgd2l0aCBhIHJlcXVlc3RJZCB3aGljaCBtb3N0IGxpa2VseVxyXG4gICAgICAgIC8vIG1lYW5zIGFkYXB0ZXIga2VlcHMgaXRzIGRhdGEgYXMgYSB3aG9sZSwgbm90IHNwbGl0dGluZyBpdCBpbnRvIHBvcnRpb25zIGFuZCwgdGhlcmVmb3JlLCBkb2Vzbid0IG5lZWQgaXRzIGRhdGFcclxuICAgICAgICAvLyB0byBiZSBtYWludGFpbmVkIHNlcGFyYXRlbHkgYXMgdmlzaWJsZS9hY3R1YWwuIEluIHRoaXMgY2FzZSB0aGUgZGF0YSBpcyBhbHdheXMgdHJlYXRlZCBsaWtlIGFuIGFjdHVhbCBkYXRhLlxyXG4gICAgICAgIGlmIChyZXF1ZXN0SWQgPT09IHRpbGUuZGF0YS52aXNpYmxlUmVxdWVzdElkICYmIHJlcXVlc3RJZCAhPT0gTk9fSUQpIHtcclxuICAgICAgICAgICAgdGlsZS5kYXRhLnZpc2libGUucHVzaChkYXRhKTtcclxuICAgICAgICAgICAgaWYgKHRpbGUuaXNWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgZGF0YSBpcyBjdXJyZW50bHkgZGlzcGxheWVkIHNvIHRoZSBuZXcgcG9ydGlvbiBpcyBhZGRlZCB0byB0aGUgc2NlbmUuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVUaWxlRGF0YVBvcnRpb25zKFtkYXRhXSwgW10pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHJlcXVlc3RJZCA9PT0gdGlsZS5kYXRhLmFjdHVhbFJlcXVlc3RJZCkge1xyXG4gICAgICAgICAgICAvLyBUaGUgZGF0YSBpcyBhY3R1YWwgYW5kIGVpdGhlciBpcyBqdXN0IGJlaW5nIHB1dCBpbnRvIHRoZSB0aWxlIG9yIHZpc3VhbGl6ZXMgYWxsIGBhY3R1YWxgIHRpbGUgZGF0YS5cclxuICAgICAgICAgICAgdGhpcy5fcHV0QWN0dWFsVGlsZURhdGEodGlsZSwgZGF0YSwgdmlzdWFsaXplKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFRoZSBkYXRhIGlzIG5laXRoZXIgdmlzaWJsZSBub3IgYWN0dWFsLiBEZXN0cm95IGRhdGEuXHJcbiAgICAgICAgICAgIHRoaXMuX29uVGlsZURlc3Ryb3kodGlsZUl0ZW0sIFtkYXRhXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX29uQ2FtZXJhVXBkYXRlKCkge1xyXG4gICAgICAgIGNvbnN0IGNhbWVyYSA9IHRoaXMuY2FtZXJhO1xyXG4gICAgICAgIGNvbnN0IHpvb20gPSB0aGlzLl9nZXRUYXJnZXRab29tKCk7XHJcbiAgICAgICAgY29uc3QgbmV3Q3VycmVudCA9IG5ldyBTZXQoY29tcHV0ZVZpc2libGVUaWxlcyhjYW1lcmEuZ2V0VmlzaWJsZVJlZ2lvbigpLCBjYW1lcmEuZ2V0VmlzaWJsZVJlZ2lvbkJCb3goKSwgY2FtZXJhLm9wdGlvbnMud3JhcE1vZGVYLCBjYW1lcmEub3B0aW9ucy53cmFwTW9kZVksIE1hdGgubWF4KDAsIHpvb20gKyB0aGlzLl96b29tU2hpZnQpKSk7XHJcbiAgICAgICAgLy8gdGhpcy5fY3VycmVudFRpbGVzIGNvbnRhaW5zIGN1cnJlbnRseSB2aXNpYmxlIHRpbGVzLCBuZXdDdXJyZW50IGNvbnRhaW5zIHNldCBvZiB0aWxlcyB2aXNpYmxlIGZyb20gdXBkYXRlZFxyXG4gICAgICAgIC8vIGNhbWVyYSBwb3NpdGlvbiwgY29tcGFyZSB0aGVzZSB0d28gc2V0cyBhbmQgY2FsbCB0aGlzLl9vblZpc2libGVUaWxlc0NoYW5nZWQoKSBpZiB0aGVyZSBpcyBhIGRpZmZlcmVuY2UuXHJcbiAgICAgICAgaWYgKG5ld0N1cnJlbnQuc2l6ZSAhPT0gdGhpcy5fY3VycmVudFRpbGVzLnNpemUgfHxcclxuICAgICAgICAgICAgb25lT2ZJdGVyYWJsZShuZXdDdXJyZW50LCAodGlsZSkgPT4gIXRoaXMuX2N1cnJlbnRUaWxlcy5oYXMoZ2V0VGlsZUlkKHRpbGUpKSkpIHtcclxuICAgICAgICAgICAgdGhpcy5fb25WaXNpYmxlVGlsZXNDaGFuZ2VkKG5ld0N1cnJlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB0aGlzIGNoZWNrcyBwcmV2ZW50cyBsZWFrcyBvZiB0aWxlcyB3aGVuIHF1aWNrIHpvb20taW4vem9vbS1vdXQgaGFwcGVuc1xyXG4gICAgICAgIGZvciAoY29uc3QgdGlsZSBvZiB0aGlzLl9jdXJyZW50VGlsZXMudmFsdWVzKCkpIHtcclxuICAgICAgICAgICAgaWYgKHRpbGUuaXNSZWFkeVRvVmlzdWFsaXplKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGVja1RpbGVSZXBsYWNlbWVudHModGlsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfb25UaWxlc1JlcXVlc3QocmVxdWVzdHMsIHJlcXVlc3RJZCA9IE5PX0lEKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCB0aWxlUmVxdWVzdCBvZiByZXF1ZXN0cykge1xyXG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ZWRUaWxlRGF0YSA9IHtcclxuICAgICAgICAgICAgICAgIGluZm86IHtcclxuICAgICAgICAgICAgICAgICAgICBwcmlvcml0eTogdGlsZVJlcXVlc3QucHJpb3JpdHlcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBsb2FkVGltZXN0YW1wczoge1xyXG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlZDogcGVyZm9ybWFuY2Uubm93KCksXHJcbiAgICAgICAgICAgICAgICAgICAgbG9hZGVkOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVkOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlYWR5OiAwXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgdGlsZUl0ZW06IHRpbGVSZXF1ZXN0XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnN0IHRpbGVJZCA9IGdldFRpbGVJZCh0aWxlUmVxdWVzdCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RlZFRpbGVzLnNldCh0aWxlSWQsIHJlcXVlc3RlZFRpbGVEYXRhKTtcclxuICAgICAgICAgICAgdGhpcy5fcmVhZHlUaWxlc0NoYW5nZSA9IHRydWU7XHJcbiAgICAgICAgICAgIGNvbnN0IHRpbGUgPSB0aGlzLl9hbGxUaWxlcy5nZXQodGlsZUlkKTtcclxuICAgICAgICAgICAgaWYgKHRpbGUpIHtcclxuICAgICAgICAgICAgICAgIHRpbGUuZGF0YS5hY3R1YWxSZXF1ZXN0SWQgPSByZXF1ZXN0SWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfb25DYW5jZWxUaWxlUmVxdWVzdHMocmVxdWVzdHMpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IHJlcXVlc3Qgb2YgcmVxdWVzdHMpIHtcclxuICAgICAgICAgICAgY29uc3QgdGlsZUlkID0gZ2V0VGlsZUlkKHJlcXVlc3QudGlsZSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9yZXF1ZXN0ZWRUaWxlcy5kZWxldGUodGlsZUlkKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhZHlUaWxlc0NoYW5nZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90aWxlc1RvUmVmcmVzaC5kZWxldGUodGlsZUlkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9vblRpbGVFcnJvcih0aWxlSXRlbSkge1xyXG4gICAgICAgIGNvbnN0IHRpbGVJZCA9IGdldFRpbGVJZCh0aWxlSXRlbSk7XHJcbiAgICAgICAgaWYgKHRoaXMuX3JlcXVlc3RlZFRpbGVzLmRlbGV0ZSh0aWxlSWQpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlYWR5VGlsZXNDaGFuZ2UgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLl90aWxlc1RvUmVmcmVzaC5kZWxldGUodGlsZUlkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHdoZXJlIHRoZSB3aG9sZSBtYWdpYyBoYXBwZW5zLCBpdCBtYW5hZ2VzIHJlcGxhY2VtZW50IG9mIGN1cnJlbnQgc2V0IG9mIHZpc2libGUvcHJlbG9hZGVkIHRpbGVzXHJcbiAgICAgKiB3aXRoIGEgbmV3IG9uZS5cclxuICAgICAqL1xyXG4gICAgX29uVmlzaWJsZVRpbGVzQ2hhbmdlZCh2aXNpYmxlVGlsZXMpIHtcclxuICAgICAgICB0aGlzLl9jdXJyZW50VGlsZXMuY2xlYXIoKTtcclxuICAgICAgICBjb25zdCB0aWxlc1RvUmVxdWVzdCA9IFtdO1xyXG4gICAgICAgIGZvciAoY29uc3QgdGlsZUl0ZW0gb2YgdmlzaWJsZVRpbGVzKSB7XHJcbiAgICAgICAgICAgIGxldCB0aWxlID0gdGhpcy5fYWxsVGlsZXMuZ2V0KGdldFRpbGVJZCh0aWxlSXRlbSkpO1xyXG4gICAgICAgICAgICBpZiAoIXRpbGUpIHtcclxuICAgICAgICAgICAgICAgIHRpbGUgPSBuZXcgVGlsZSh0aWxlSXRlbSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hbGxUaWxlcy5zZXQodGlsZS5pZCwgdGlsZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50VGlsZXMuc2V0KHRpbGUuaWQsIHRpbGUpO1xyXG4gICAgICAgICAgICAgICAgdGlsZXNUb1JlcXVlc3QucHVzaCh0aGlzLl9jcmVhdGVUaWxlUmVxdWVzdCh0aWxlSXRlbSwgdGhpcy5fZ2V0VGlsZVByaW9yaXR5KHRpbGUudGlsZUl0ZW0sIHRydWUpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50VGlsZXMuc2V0KHRpbGUuaWQsIHRpbGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aWxlc1RvUmVxdWVzdC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RUaWxlcyh0aWxlc1RvUmVxdWVzdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGJlbHRUaWxlcyA9IG5ldyBNYXAoKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGJlbHRUaWxlSXRlbSBvZiBjYWxjdWxhdGVCZWx0VGlsZXModmlzaWJsZVRpbGVzLCB0aGlzLl9iZWx0U2l6ZSwgdGhpcy5jYW1lcmEub3B0aW9ucy53cmFwTW9kZVggPT09IDIgLyogUkVQRUFUICovLCB0aGlzLmNhbWVyYS5vcHRpb25zLndyYXBNb2RlWSA9PT0gMiAvKiBSRVBFQVQgKi8pKSB7XHJcbiAgICAgICAgICAgIGJlbHRUaWxlcy5zZXQoZ2V0VGlsZUlkKGJlbHRUaWxlSXRlbSksIGJlbHRUaWxlSXRlbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGJlbHRUaWxlc1RvUmVxdWVzdCA9IFtdO1xyXG4gICAgICAgIGZvciAoY29uc3QgYmVsdFRpbGVJdGVtIG9mIGJlbHRUaWxlcy52YWx1ZXMoKSkge1xyXG4gICAgICAgICAgICBjb25zdCB0aWxlSWQgPSBnZXRUaWxlSWQoYmVsdFRpbGVJdGVtKTtcclxuICAgICAgICAgICAgbGV0IHRpbGUgPSB0aGlzLl9hbGxUaWxlcy5nZXQodGlsZUlkKTtcclxuICAgICAgICAgICAgaWYgKCF0aWxlKSB7XHJcbiAgICAgICAgICAgICAgICB0aWxlID0gbmV3IFRpbGUoYmVsdFRpbGVJdGVtKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FsbFRpbGVzLnNldCh0aWxlSWQsIHRpbGUpO1xyXG4gICAgICAgICAgICAgICAgYmVsdFRpbGVzVG9SZXF1ZXN0LnB1c2godGhpcy5fY3JlYXRlVGlsZVJlcXVlc3QoYmVsdFRpbGVJdGVtLCB0aGlzLl9nZXRUaWxlUHJpb3JpdHkoYmVsdFRpbGVJdGVtLCBmYWxzZSkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYmVsdFRpbGVzVG9SZXF1ZXN0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0VGlsZXMoYmVsdFRpbGVzVG9SZXF1ZXN0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYnJva2UgY3VycmVudCByZWxhdGlvbnNoaXBzIHRvIHNldCB0aGVtIHVwIGFnYWluIGJ1dCB3aXRoIG5ldyBzZXQgb2YgdmlzaWJsZSB0aWxlc1xyXG4gICAgICAgIGZvciAoY29uc3QgdGlsZSBvZiB0aGlzLl9hbGxUaWxlcy52YWx1ZXMoKSkge1xyXG4gICAgICAgICAgICB0aWxlLnRvQmVSZXBsYWNlZEJ5LmNsZWFyKCk7XHJcbiAgICAgICAgICAgIHRpbGUucmVwbGFjZW1lbnRGb3IuY2xlYXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVE9ETzogb3B0aW1pemUgdGhpcyBuXjIgcmVsYXRpb25zaGlwcyByZXNvbHZlclxyXG4gICAgICAgIGZvciAoY29uc3QgY3VycmVudFRpbGUgb2YgdGhpcy5fY3VycmVudFRpbGVzLnZhbHVlcygpKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgdGlsZSBvZiB0aGlzLl9hbGxUaWxlcy52YWx1ZXMoKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRpbGUuaXNSZWFkeVRvVmlzdWFsaXplICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKGlzUGFyZW50KHRpbGUudGlsZUl0ZW0sIGN1cnJlbnRUaWxlLnRpbGVJdGVtKSB8fCBpc1BhcmVudChjdXJyZW50VGlsZS50aWxlSXRlbSwgdGlsZS50aWxlSXRlbSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGlsZS50b0JlUmVwbGFjZWRCeS5hZGQoY3VycmVudFRpbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUaWxlLnJlcGxhY2VtZW50Rm9yLmFkZCh0aWxlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyByZW1vdmUgaW52aXNpYmxlXHJcbiAgICAgICAgY29uc3QgdGlsZXNUb0NhbmNlbCA9IFtdO1xyXG4gICAgICAgIGZvciAoY29uc3QgdGlsZSBvZiB0aGlzLl9hbGxUaWxlcy52YWx1ZXMoKSkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2N1cnJlbnRUaWxlcy5oYXModGlsZS5pZCkgJiYgdGlsZS50b0JlUmVwbGFjZWRCeS5zaXplID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGlsZS5pc1Zpc2libGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVUaWxlRGF0YShOT19USUxFU19UT19IQU5ETEUsIFt0aWxlXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWJlbHRUaWxlcy5nZXQodGlsZS5pZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZXN0cm95VGlsZSh0aWxlKTtcclxuICAgICAgICAgICAgICAgICAgICB0aWxlc1RvQ2FuY2VsLnB1c2godGlsZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRpbGVzVG9DYW5jZWwubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIC8vIGlzc3VlIGNhbmNlbGxhdGlvbiBhbHNvIGluIGNhc2UgdGhlcmUgYXJlIG5vbiBwcm9jZXNzZWQgZGF0YSBlbnF1ZXVlZCB0byB0cnkgdG8gc2F2ZSBzb21lIGVmZm9ydHNcclxuICAgICAgICAgICAgdGhpcy5fY2FuY2VsVGlsZVJlcXVlc3RzKHRpbGVzVG9DYW5jZWxhdGlvbnModGlsZXNUb0NhbmNlbCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9yZWZyZXNoQ3VycmVudFRpbGVzKCkge1xyXG4gICAgICAgIGNvbnN0IHRpbGVzVG9SZXF1ZXN0ID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCB0aWxlIG9mIHRoaXMuX2N1cnJlbnRUaWxlcy52YWx1ZXMoKSkge1xyXG4gICAgICAgICAgICBjb25zdCB0aWxlSXRlbSA9IHRpbGUudGlsZUl0ZW07XHJcbiAgICAgICAgICAgIGNvbnN0IHRpbGVSZXF1ZXN0ID0gdGhpcy5fY3JlYXRlVGlsZVJlcXVlc3QodGlsZUl0ZW0sIHRoaXMuX2dldFRpbGVQcmlvcml0eSh0aWxlLnRpbGVJdGVtLCB0cnVlKSk7XHJcbiAgICAgICAgICAgIHRpbGVzVG9SZXF1ZXN0LnB1c2godGlsZVJlcXVlc3QpO1xyXG4gICAgICAgICAgICB0aGlzLl90aWxlc1RvUmVmcmVzaC5hZGQoZ2V0VGlsZUlkKHRpbGUudGlsZUl0ZW0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fY2FuY2VsVGlsZVJlcXVlc3RzKHRpbGVzVG9DYW5jZWxhdGlvbnModGhpcy5fY3VycmVudFRpbGVzLnZhbHVlcygpKSk7XHJcbiAgICAgICAgdGhpcy5fcmVxdWVzdFRpbGVzKHRpbGVzVG9SZXF1ZXN0KTtcclxuICAgIH1cclxuICAgIF9vblRpbGVEYXRhUmVhZHkodGlsZUl0ZW0sIHVybCkge1xyXG4gICAgICAgIGNvbnN0IHRpbGVJZCA9IGdldFRpbGVJZCh0aWxlSXRlbSk7XHJcbiAgICAgICAgY29uc3QgdGlsZURhdGEgPSB0aGlzLl9yZXF1ZXN0ZWRUaWxlcy5nZXQodGlsZUlkKTtcclxuICAgICAgICB0aGlzLl9yZXF1ZXN0ZWRUaWxlcy5kZWxldGUodGlsZUlkKTtcclxuICAgICAgICB0aGlzLl90aWxlc1RvUmVmcmVzaC5kZWxldGUodGlsZUlkKTtcclxuICAgICAgICB0aWxlRGF0YS5pbmZvLnVybCA9IHVybDtcclxuICAgICAgICB0aWxlRGF0YS5sb2FkVGltZXN0YW1wcy5sb2FkZWQgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgICBpZiAodGhpcy5fdGlsZUxvYWRMb2dzLmxlbmd0aCA8IE1BWF9QRVJGX0xPR19JVEVNU19DT1VOVCkge1xyXG4gICAgICAgICAgICB0aGlzLl90aWxlTG9hZExvZ3MucHVzaCh7XHJcbiAgICAgICAgICAgICAgICB0aWxlSXRlbSxcclxuICAgICAgICAgICAgICAgIHByb2Nlc3NpbmdUaW1lOiB0aWxlRGF0YS5sb2FkVGltZXN0YW1wcy5sb2FkZWQgLSB0aWxlRGF0YS5sb2FkVGltZXN0YW1wcy5xdWV1ZWRcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3JlYWR5Rm9yUmVuZGVyVGlsZXMucHVzaCh0aWxlRGF0YSk7XHJcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRUaWxlcy5nZXQodGlsZUlkKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZWFkeVRpbGVzQ2hhbmdlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfaXNUaWxlU3RpbGxBY3RpdmUodGlsZUl0ZW0sIHJlcXVlc3RJZCA9IE5PX0lEKSB7XHJcbiAgICAgICAgY29uc3QgdGlsZSA9IHRoaXMuX2FsbFRpbGVzLmdldChnZXRUaWxlSWQodGlsZUl0ZW0pKTtcclxuICAgICAgICBpZiAoIXRpbGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpc1JlcXVlc3RBY3RpdmUgPSB0aWxlLmRhdGEuYWN0dWFsUmVxdWVzdElkID09PSByZXF1ZXN0SWQgfHwgdGlsZS5kYXRhLnZpc2libGVSZXF1ZXN0SWQgPT09IHJlcXVlc3RJZDtcclxuICAgICAgICByZXR1cm4gaXNSZXF1ZXN0QWN0aXZlO1xyXG4gICAgfVxyXG4gICAgX2lzVGlsZVJlZnJlc2hpbmcodGlsZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90aWxlc1RvUmVmcmVzaC5oYXMoZ2V0VGlsZUlkKHRpbGUpKTtcclxuICAgIH1cclxuICAgIF9nZXRUaWxlUHJpb3JpdHkodGlsZSwgaXNWaXNpYmxlKSB7XHJcbiAgICAgICAgY29uc3QgY2VudGVyID0gdGhpcy5fY3JlYXRlVGlsZUNvb3JkaW5hdGVTeXN0ZW0oKS50b1RpbGVDb29yZGluYXRlcyh0aGlzLmNhbWVyYS5jZW50ZXIpO1xyXG4gICAgICAgIGNvbnN0IHpvb21EaWZmID0gTWF0aC5jZWlsKHRoaXMuY2FtZXJhLnpvb20pIC0gdGlsZS56b29tO1xyXG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gdmVjMi5kaXN0YW5jZSh0aWxlLCB7XHJcbiAgICAgICAgICAgIHg6IE1hdGguZmxvb3IoY2VudGVyLnggLyBNYXRoLnBvdygyLCB6b29tRGlmZikpLFxyXG4gICAgICAgICAgICB5OiBNYXRoLmZsb29yKGNlbnRlci55IC8gTWF0aC5wb3coMiwgem9vbURpZmYpKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiAoaXNWaXNpYmxlID8gVklTSUJMRV9USUxFX1BSSU9SSVRZIDogMCkgKyAxIC8gKGRpc3RhbmNlICsgMSk7XHJcbiAgICB9XHJcbiAgICBfc2VuZFN0YXRpc3RpY3NCZWZvcmVEZXN0cm95KCkge1xyXG4gICAgICAgIGlmICh0aGlzLl90aWxlTG9hZExvZ3MubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYWNjdW11bGF0ZWRUaW1pbmdzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIGFjY3VtdWxhdGVkVGltaW5ncy5zZXQoJ2F2ZXJhZ2UnLCB7XHJcbiAgICAgICAgICAgIHN1bTogMCxcclxuICAgICAgICAgICAgbnVtYmVyOiAwXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fdGlsZUxvYWRMb2dzLmZvckVhY2goKGxvZ0l0ZW0pID0+IHtcclxuICAgICAgICAgICAgYWNjdW11bGF0ZWRUaW1pbmdzLmdldCgnYXZlcmFnZScpLnN1bSArPSBsb2dJdGVtLnByb2Nlc3NpbmdUaW1lO1xyXG4gICAgICAgICAgICBhY2N1bXVsYXRlZFRpbWluZ3MuZ2V0KCdhdmVyYWdlJykubnVtYmVyKys7XHJcbiAgICAgICAgICAgIGNvbnN0IHpvb20gPSBsb2dJdGVtLnRpbGVJdGVtLnpvb20udG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgaWYgKCFhY2N1bXVsYXRlZFRpbWluZ3MuaGFzKHpvb20pKSB7XHJcbiAgICAgICAgICAgICAgICBhY2N1bXVsYXRlZFRpbWluZ3Muc2V0KHpvb20sIHtcclxuICAgICAgICAgICAgICAgICAgICBzdW06IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyOiAwXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhY2N1bXVsYXRlZFRpbWluZ3MuZ2V0KHpvb20pLnN1bSArPSBsb2dJdGVtLnByb2Nlc3NpbmdUaW1lO1xyXG4gICAgICAgICAgICBhY2N1bXVsYXRlZFRpbWluZ3MuZ2V0KHpvb20pLm51bWJlcisrO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBhY2N1bXVsYXRlZFRpbWluZ3MpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xyXG4gICAgICAgICAgICAgICAgem9vbTogaXRlbVswXSxcclxuICAgICAgICAgICAgICAgIHRpbWU6IChpdGVtWzFdLnN1bSAvIGl0ZW1bMV0ubnVtYmVyKVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY291bnRUaWxlUHJvY2Vzc2luZ1RpbWUodGhpcy5fbGF5ZXJOYW1lLCByZXN1bHQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQdXRzIGFjdHVhbCBkYXRhIGludG8gdGhlIHRpbGUgYW5kIG9wdGlvbmFsbHkgdmlzdWFsaXplcyBpdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdGlsZSBUaWxlIHRvIHB1dCBkYXRhIGludG8uXHJcbiAgICAgKiBAcGFyYW0gZGF0YSBEYXRhIHRvIGJlIHN0b3JlZCBpbiB0aGUgdGlsZSB1bnRpbCB2aXN1YWxpemF0aW9uLlxyXG4gICAgICogQHBhcmFtIHZpc3VhbGl6ZSBJZiBgdHJ1ZWAgcmVwbGFjZXMgYHZpc2libGVgIHRpbGUgZGF0YSB3aXRoIGBhY3R1YWxgIHRpbGUgZGF0YSBhbmQgdXBkYXRlcyB0aGUgc2NlbmUuXHJcbiAgICAgKi9cclxuICAgIF9wdXRBY3R1YWxUaWxlRGF0YSh0aWxlLCBkYXRhLCB2aXN1YWxpemUpIHtcclxuICAgICAgICB0aWxlLmRhdGEuYWN0dWFsLnB1c2goZGF0YSk7XHJcbiAgICAgICAgaWYgKHZpc3VhbGl6ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl92aXN1YWxpemVUaWxlKHRpbGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVmlzdWFsaXplcyB0aWxlIGBhY3R1YWxgIGRhdGE6IHJlcGxhY2VzIHRpbGUgYHZpc2libGVgIGRhdGEgd2l0aCB0aWxlIGBhY3R1YWxgIGRhdGEsIGFkZHMgaXQgdG8gdGhlIHNjZW5lLFxyXG4gICAgICogcmVtb3ZlcyBvbGQgdmlzaWJsZSBkYXRhIGZyb20gdGhlIHNjZW5lIGFuZCBkZXN0cm95cyBpdCwgY2hlY2tzIHRpbGUgcmVwbGFjZW1lbnRzIGFuZCB1cGRhdGVzIGB2aXNpYmxlUmVxdWVzdElkYC5cclxuICAgICAqIEBwYXJhbSB0aWxlIFRpbGUgdG8gdmlzdWFsaXplLlxyXG4gICAgICovXHJcbiAgICBfdmlzdWFsaXplVGlsZSh0aWxlKSB7XHJcbiAgICAgICAgY29uc3QgdG9EZXN0cm95ID0gdGlsZS5kYXRhLnZpc2libGU7XHJcbiAgICAgICAgdGlsZS5kYXRhLnZpc2libGUgPSB0aWxlLmRhdGEuYWN0dWFsO1xyXG4gICAgICAgIHRpbGUuZGF0YS5hY3R1YWwgPSBbXTtcclxuICAgICAgICB0aWxlLmRhdGEudmlzaWJsZVJlcXVlc3RJZCA9IHRpbGUuZGF0YS5hY3R1YWxSZXF1ZXN0SWQ7XHJcbiAgICAgICAgaWYgKCF0aWxlLmlzUmVhZHlUb1Zpc3VhbGl6ZSkge1xyXG4gICAgICAgICAgICB0aWxlLmlzUmVhZHlUb1Zpc3VhbGl6ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrVGlsZVJlcGxhY2VtZW50cyh0aWxlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGlsZS5pc1Zpc2libGUpIHtcclxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlVGlsZURhdGFQb3J0aW9ucyh0aWxlLmRhdGEudmlzaWJsZSwgW10pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodG9EZXN0cm95Lmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlVGlsZURhdGFQb3J0aW9ucyhbXSwgdG9EZXN0cm95KTtcclxuICAgICAgICAgICAgdGhpcy5fb25UaWxlRGVzdHJveSh0aWxlLnRpbGVJdGVtLCB0b0Rlc3Ryb3kpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9jcmVhdGVUaWxlQ29vcmRpbmF0ZVN5c3RlbSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFRpbGVDb29yZGluYXRlU3lzdGVtKHRoaXMuY2FtZXJhLnpvb20pO1xyXG4gICAgfVxyXG4gICAgLy8gV2UgbmVlZCBkbyBkZXRlY3Qgd2hlbiB0aWxlIGlzIHJlbmRlcmVkIHRvIGNvbGxlY3QgcGVyZm9tYW5jZSBtZXRyaWNzLlxyXG4gICAgLy8gV2UgZXhwZWN0IHRoYXQgdGlsZSB3aWxsIGJlIHJlbmRlcmVkIHdpdGggZmlyc3QgcmVuZGVyIGV2ZW50IGFmdGVyXHJcbiAgICAvLyB0aWxlIGRhdGEgaXMgYWRkZWQgdG8gc2NlbmUuXHJcbiAgICBfb25FbmdpbmVSZW5kZXJFdmVudCgpIHtcclxuICAgICAgICBpZiAodGhpcy5fcmVhZHlGb3JSZW5kZXJUaWxlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVhZHlGb3JSZW5kZXJUaWxlcy5mb3JFYWNoKCh0aWxlRGF0YSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRUaWxlcy5oYXMoZ2V0VGlsZUlkKHRpbGVEYXRhLnRpbGVJdGVtKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aWxlRGF0YS5sb2FkVGltZXN0YW1wcy5yZW5kZXJlZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRpbGVEYXRhLmxvYWRUaW1lc3RhbXBzLnJlYWR5ID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vblRpbGVSZWFkeS5maXJlKHRpbGVEYXRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlYWR5Rm9yUmVuZGVyVGlsZXMubGVuZ3RoID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX3JlYWR5VGlsZXNDaGFuZ2UpIHtcclxuICAgICAgICAgICAgdGhpcy5vblRpbGVMb2FkQ2hhbmdlLmZpcmUoe1xyXG4gICAgICAgICAgICAgICAgdG90YWxUaWxlTnVtYmVyOiB0aGlzLmdldFZpc2libGVUaWxlc051bWJlcigpLFxyXG4gICAgICAgICAgICAgICAgcmVhZHlUaWxlTnVtYmVyOiB0aGlzLmdldFZpc2libGVUaWxlc051bWJlcigpIC0gdGhpcy5nZXRQZW5kaW5nVGlsZXNOdW1iZXIoKVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5fcmVhZHlUaWxlc0NoYW5nZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2hvd3MvaGlkZXMgdGlsZXMgaWYgdGhleSBhcmUgbm90IHNob3duL2hpZGRlbiB5ZXQuIEl0IG5vdGlmaWVzIHN1YmNsYXNzZXMgYnkgY2FsbGluZyBhcHByb3ByaWF0ZVxyXG4gICAgICogYWJzdHJhY3QgbWV0aG9kLiBFdmVuIHRob3VnaCB2aXNpYmxlL2ludmlzaWJsZSB0aWxlcyBhcmUgbm90IHN1cHBvc2VkIHRvIGJlIHNob3duL2hpZGRlbiBhZ2FpbixcclxuICAgICAqIHRoZXJlIGFyZSBjYXNlcyB3aGVyZSBpdCBzaW1wbGlmaWVzIHRpbGUgdmlzdWFsaXphdGlvbiBsb2dpYy5cclxuICAgICAqIEl0IGlzIGltcG9ydGFudCB0byBoYXZlIGV4YWN0bHkgXCJ1cGRhdGVcIiwgbm90IFwiYWRkXCIvXCJyZW1vdmVcIiBzZXBhcmF0ZWx5LCBhcyBzb21lIGJ1c2luZXNzIGxvZ2ljIG1heSByZWx5IG9uIGl0LFxyXG4gICAgICogZS5nLiBtb3JwaGluZyB2aXNpYmxlIGRhdGEgb3IgbWFuYWdpbmcgc2hhcmVkIHJlc291cmNlcy5cclxuICAgICAqL1xyXG4gICAgX3VwZGF0ZVRpbGVEYXRhKHRvU2hvdywgdG9SZW1vdmUpIHtcclxuICAgICAgICBjb25zdCBkYXRhVG9TaG93ID0gQXJyYXkuZnJvbShmbGF0dGVuVmlzaWJsZURhdGFQb3J0aW9ucyh0b1Nob3cpKTtcclxuICAgICAgICBjb25zdCBkYXRhVG9SZW1vdmUgPSBBcnJheS5mcm9tKGZsYXR0ZW5WaXNpYmxlRGF0YVBvcnRpb25zKHRvUmVtb3ZlKSk7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlVGlsZURhdGFQb3J0aW9ucyhkYXRhVG9TaG93LCBkYXRhVG9SZW1vdmUpO1xyXG4gICAgICAgIGZvciAoY29uc3QgdGlsZSBvZiB0b1Nob3cpIHtcclxuICAgICAgICAgICAgdGlsZS5pc1Zpc2libGUgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IHRpbGUgb2YgdG9SZW1vdmUpIHtcclxuICAgICAgICAgICAgdGlsZS5pc1Zpc2libGUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfdXBkYXRlVGlsZURhdGFQb3J0aW9ucyh0b1Nob3csIHRvUmVtb3ZlKSB7XHJcbiAgICAgICAgdGhpcy5fb25UaWxlRGF0YVVwZGF0ZSh0b1Nob3csIHRvUmVtb3ZlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyB0aWxlIGlmIGlzIG5vdCByZW1vdmVkIHdpdGggY2FsbGluZyBhbGwgYXBwcm9wcmlhdGUgY2FsbGJhY2tzIChhYnN0cmFjdCBtZXRob2RzKVxyXG4gICAgICogdG8gbm90aWZ5IGRlc2NlbmRhbnQgY2xhc3Nlcy4gRXZlbiB0aG91Z2ggcmVtb3ZlZCB0aWxlIGlzIG5vdCBzdXBwb3NlZCB0byBiZSByZW1vdmVkIGFnYWluLFxyXG4gICAgICogYWxsb3dpbmcgdGhpcyBtYWtlcyBtdWNoIHNpbXBsZXIgdGlsZSBtYW5hZ2VtZW50LCBlc3BlY2lhbGx5IGluIHRpbGUgcmVwbGFjZW1lbnRzIGxvZ2ljIHdoZXJlIG11bHRpcGxlXHJcbiAgICAgKiB0aWxlcyBjYW4gaGF2ZSBsaW5rcyB0byB0aGUgc2FtZSB0aWxlICh0aGF0IGlzIHRvIGJlIHJlbW92ZWQpLlxyXG4gICAgICovXHJcbiAgICBfZGVzdHJveVRpbGUodGlsZSkge1xyXG4gICAgICAgIGlmICghdGlsZS5pc1JlbW92ZWQpIHtcclxuICAgICAgICAgICAgdGlsZS5pc1JlbW92ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLl9hbGxUaWxlcy5kZWxldGUodGlsZS5pZCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRUaWxlcy5kZWxldGUodGlsZS5pZCk7XHJcbiAgICAgICAgICAgIHRoaXMuX29uVGlsZURlc3Ryb3kodGlsZS50aWxlSXRlbSwgWy4uLnRpbGUuZGF0YS5hY3R1YWwsIC4uLnRpbGUuZGF0YS52aXNpYmxlXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgdGlsZXMgdGhhdCBjb3VsZCBiZSByZXBsYWNlZCBieSB0aGlzIG9uZSwgc2hvdWxkIGJlIGNhbGxlZCB3aGVuIHRpbGUgYmVjb21lcyByZWFkeSB0byB2aXN1YWxpemUuXHJcbiAgICAgKiBBcyBvdmVybGFwcGluZyByZWxhdGlvbnNoaXBzIGNhbiBoYXBwZW4gaW4gYm90aCBkaXJlY3Rpb25zIChjaGlsZHJlbiBieSBwYXJlbnRzIC8gcGFyZW50IGJ5IGNoaWxkcmVuKSB0aGlzXHJcbiAgICAgKiBtZXRob2QgZ29lcyBvbmUgc3RlcCBkZWVwZXIsIGkuZS4gaXQgY2hlY2sgbm90IG9ubHkgdGlsZXMgdGhhdCBzaG91bGQgYmUgcmVwbGFjZWQgKHRvIHJlbW92ZSB0aGVtKSxcclxuICAgICAqIGJ1dCBhbHNvIGFsbCB0aWxlcyB0aGF0IGNvdmVyIHRoZSByZXBsYWNlZCBvbmVzICh0byBzaG93IHRoZW0pLlxyXG4gICAgICovXHJcbiAgICBfY2hlY2tUaWxlUmVwbGFjZW1lbnRzKHRpbGUpIHtcclxuICAgICAgICBjb25zdCB0b0Rlc3Ryb3kgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgY29uc3QgdG9TaG93ID0gbmV3IFNldCgpO1xyXG4gICAgICAgIGNvbnN0IHRvSGlkZSA9IG5ldyBTZXQoKTtcclxuICAgICAgICBmb3IgKGNvbnN0IHRpbGVUb1JlcGxhY2Ugb2YgdGlsZS5yZXBsYWNlbWVudEZvcikge1xyXG4gICAgICAgICAgICBpZiAoYWxsT2ZJdGVyYWJsZSh0aWxlVG9SZXBsYWNlLnRvQmVSZXBsYWNlZEJ5LCAodGlsZSkgPT4gdGlsZS5pc1JlYWR5VG9WaXN1YWxpemUpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGlsZVRvUmVwbGFjZS5pc1Zpc2libGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0b0hpZGUuYWRkKHRpbGVUb1JlcGxhY2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCF0aWxlVG9SZXBsYWNlLmlzUmVtb3ZlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvRGVzdHJveS5hZGQodGlsZVRvUmVwbGFjZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRpbGVUb1Nob3cgb2YgdGlsZVRvUmVwbGFjZS50b0JlUmVwbGFjZWRCeSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGlsZVRvU2hvdy5pc1Zpc2libGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9TaG93LmFkZCh0aWxlVG9TaG93KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRpbGUucmVwbGFjZW1lbnRGb3Iuc2l6ZSA9PT0gMCAmJiAhdGlsZS5pc1Zpc2libGUpIHtcclxuICAgICAgICAgICAgdG9TaG93LmFkZCh0aWxlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRvU2hvdy5zaXplID4gMCB8fCB0b0hpZGUuc2l6ZSA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlVGlsZURhdGEodG9TaG93LCB0b0hpZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IHRpbGVUb0Rlc3Ryb3kgb2YgdG9EZXN0cm95KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3lUaWxlKHRpbGVUb0Rlc3Ryb3kpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodG9EZXN0cm95LnNpemUgPiAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NhbmNlbFRpbGVSZXF1ZXN0cyh0aWxlc1RvQ2FuY2VsYXRpb25zKHRvRGVzdHJveSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGhpcyBjbGFzcyBpcyB0aGUgbWFpbiB1bml0IG9mIHRoZSB3aG9sZSBwcm9jZXNzIG9mIHRpbGUgbWFuYWdlbWVudC4gSXQgc3RvcmVzIHZpc3VhbGl6YWJsZSBkYXRhIGFuZCBsaW5rcyB0b1xyXG4gKiBkZXBlbmRhbnQgdGlsZXMgKGZvciBwYXJlbnQvY2hpbGQgb3ZlcmxhcHBpbmcgY2FzZXMpLlxyXG4gKi9cclxuY2xhc3MgVGlsZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0aWxlSXRlbSkge1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IHtcclxuICAgICAgICAgICAgYWN0dWFsOiBbXSxcclxuICAgICAgICAgICAgdmlzaWJsZTogW10sXHJcbiAgICAgICAgICAgIGFjdHVhbFJlcXVlc3RJZDogTk9fSUQsXHJcbiAgICAgICAgICAgIHZpc2libGVSZXF1ZXN0SWQ6IE5PX0lEXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnRpbGVJdGVtID0gdGlsZUl0ZW07XHJcbiAgICAgICAgdGhpcy5pZCA9IGAke3RpbGVJdGVtLnh9OiR7dGlsZUl0ZW0ueX06JHt0aWxlSXRlbS56b29tfWA7XHJcbiAgICAgICAgdGhpcy5pc1JlYWR5VG9WaXN1YWxpemUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmlzVmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaXNSZW1vdmVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy50b0JlUmVwbGFjZWRCeSA9IG5ldyBTZXQoKTtcclxuICAgICAgICB0aGlzLnJlcGxhY2VtZW50Rm9yID0gbmV3IFNldCgpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHRpbGVzVG9DYW5jZWxhdGlvbnModGlsZXMpIHtcclxuICAgIHJldHVybiBBcnJheS5mcm9tKHRpbGVzLCAodGlsZSkgPT4gKHtcclxuICAgICAgICB0aWxlOiB0aWxlLnRpbGVJdGVtLFxyXG4gICAgICAgIHJlcXVlc3RJZDogdGlsZS5kYXRhLmFjdHVhbFJlcXVlc3RJZFxyXG4gICAgfSkpO1xyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2FkYXB0ZXJzL3RpbGVfYmFzZWRfYWRhcHRlci9hZGFwdGVyLnRzXG4vLyBtb2R1bGUgaWQgPSA2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBkZWJvdW5jZSB9IGZyb20gJy4uL3V0aWwvZnVuY3Rpb24nO1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBZGFwdGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGVuZ2luZSwgY2FtZXJhLCBjYW1lcmFVcGRhdGVEZWxheSA9IDUpIHtcclxuICAgICAgICB0aGlzLmVuZ2luZSA9IGVuZ2luZTtcclxuICAgICAgICB0aGlzLmNhbWVyYSA9IGNhbWVyYTtcclxuICAgICAgICB0aGlzLl9jYW1lcmFVcGRhdGVMaXN0ZW5lciA9IGRlYm91bmNlKHRoaXMuX29uQ2FtZXJhVXBkYXRlLmJpbmQodGhpcyksIGNhbWVyYVVwZGF0ZURlbGF5KTtcclxuICAgICAgICBjYW1lcmEub25VcGRhdGUuYWRkTGlzdGVuZXIodGhpcy5fY2FtZXJhVXBkYXRlTGlzdGVuZXIpO1xyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLmNhbWVyYS5vblVwZGF0ZS5yZW1vdmVMaXN0ZW5lcih0aGlzLl9jYW1lcmFVcGRhdGVMaXN0ZW5lcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbWVyYSB1cGRhdGUgaGFuZGxlciwgYnkgZGVmYXVsdCBkbyBub3RoaW5nLlxyXG4gICAgICovXHJcbiAgICBfb25DYW1lcmFVcGRhdGUoKSB7IH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9hZGFwdGVycy9hZGFwdGVyLnRzXG4vLyBtb2R1bGUgaWQgPSA2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICogQ3JlYXRlcyBuZXcgZnVuY3Rpb24gd2hpY2ggZXhlY3V0aW9uIGlzIFwiZGVib3VuY2VkXCIuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCkge1xyXG4gICAgbGV0IHRpbWVvdXQgPSAwO1xyXG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XHJcbiAgICAgICAgY29uc3QgbGF0ZXIgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRpbWVvdXQgPSAwO1xyXG4gICAgICAgICAgICBmdW5jKC4uLmFyZ3MpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKHRpbWVvdXQpIHtcclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XHJcbiAgICB9O1xyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvZnVuY3Rpb24udHNcbi8vIG1vZHVsZSBpZCA9IDcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IGNsYW1wIH0gZnJvbSAnLi4vLi4vLi4vbWF0aC9zY2FsYXInO1xyXG4vKipcclxuICogQHJldHVybiBgdHJ1ZWAgaWYgdGhlIGZpcnN0IHBhcmFtIG92ZXJsYXBzIHRoZSBzZWNvbmQgaW4gdGlsZSBoaWVyYXJjaHkuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNQYXJlbnQocG90ZW50aWFsUGFyZW50LCBwb3NzaWJsZUNoaWxkKSB7XHJcbiAgICBjb25zdCB6b29tRGlmZiA9IHBvc3NpYmxlQ2hpbGQuem9vbSAtIHBvdGVudGlhbFBhcmVudC56b29tO1xyXG4gICAgcmV0dXJuIHpvb21EaWZmID4gMCAmJlxyXG4gICAgICAgIHBvc3NpYmxlQ2hpbGQueCA+PiB6b29tRGlmZiA9PT0gcG90ZW50aWFsUGFyZW50LnggJiZcclxuICAgICAgICBwb3NzaWJsZUNoaWxkLnkgPj4gem9vbURpZmYgPT09IHBvdGVudGlhbFBhcmVudC55O1xyXG59XHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRpbGVDb29yZGluYXRlU3lzdGVtIHtcclxuICAgIGNvbnN0cnVjdG9yKHpvb20pIHtcclxuICAgICAgICB0aGlzLl96b29tID0gTWF0aC5jZWlsKGNsYW1wKHpvb20sIDAsIDMxKSk7XHJcbiAgICAgICAgdGhpcy5fdGlsZVNpemUgPSAyIC8gKDEgPDwgdGhpcy5fem9vbSk7XHJcbiAgICB9XHJcbiAgICBnZXRab29tKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl96b29tO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIFRpbGUgc2lkZSBsZW5ndGggaW4gdW5pdHMgb2YgdGhlIHdvcmxkIGNvb3JkaW5hdGUgc3lzdGVtLlxyXG4gICAgICovXHJcbiAgICBnZXRUaWxlU2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdGlsZVNpemU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gVG9wIGxlZnQgY29ybmVyIGNvb3JkaW5hdGVzIG9mIHRoZSB0aWxlLlxyXG4gICAgICovXHJcbiAgICBnZXRUaWxlT2Zmc2V0KHRpbGUpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB4OiB0aGlzLmdldFRpbGVTaXplKCkgKiB0aWxlLnggLSAxLFxyXG4gICAgICAgICAgICB5OiAxIC0gdGhpcy5nZXRUaWxlU2l6ZSgpICogdGlsZS55XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHRvVGlsZUNvb3JkaW5hdGVzKHdvcmxkQ29vcmRpbmF0ZXMpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB4OiAod29ybGRDb29yZGluYXRlcy54ICsgMSkgLyB0aGlzLl90aWxlU2l6ZSxcclxuICAgICAgICAgICAgeTogKDEgLSB3b3JsZENvb3JkaW5hdGVzLnkpIC8gdGhpcy5fdGlsZVNpemVcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2FkYXB0ZXJzL3RpbGVfYmFzZWRfYWRhcHRlci91dGlsL3RpbGVfc3lzdGVtLnRzXG4vLyBtb2R1bGUgaWQgPSA3MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJjb25zdCBUSUxFXzBfMF8wID0geyB4OiAwLCB5OiAwLCB6b29tOiAwIH07XHJcbi8qKlxyXG4gKiBDb21wdXRlcyBzZXQgb2YgdGlsZXMgdmlzaWJsZSB0aHJvdWdoIGEgY2FtZXJhLiBUaWxlcyBpbiB0aGUgc2V0IGFyZSBndWFyYW50ZWVkXHJcbiAqIHRvIGJlIHVuaXF1ZS5cclxuICpcclxuICogRklYTUUoZG1pa2lzKSBUaGUgdW5pcXVlbmVzcyBndWFyYW50ZWUgaXMgYnJva2VuIGN1cnJlbnRseSwgYnV0IGNvZGUgdGhhdCB1c2VzXHJcbiAqICAgICAgdGhpcyBmdW5jdGlvbiBkb2Vzbid0IHN1ZmZlciBmcm9tIHRoYXQuXHJcbiAqXHJcbiAqIEBwYXJhbSBjYW1lcmEgVGhlIGNhbWVyYS5cclxuICogQHJldHVybnMgQW4gaXRlcmF0b3Igb3ZlciB2aXNpYmxlIHRpbGUgaXRlbXMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24qIGNvbXB1dGVWaXNpYmxlVGlsZXModmlzaWJsZVJlZ2lvbiwgdmlzaWJsZVJlZ2lvbkJCb3gsIHdyYXBNb2RlWCwgd3JhcE1vZGVZLCB6b29tKSB7XHJcbiAgICBpZiAoem9vbSA9PT0gMCkge1xyXG4gICAgICAgIC8vIFRoZSBvbmx5IHRpbGUgb24gem9vbSAwIGVuY29tcGFzc2VzIHRoZSB3aG9sZSB3b3JsZC4gVGh1cyB0aGVyZSdzXHJcbiAgICAgICAgLy8gbGl0dGxlIHRvIG5vIHBvaW50IGNvbXB1dGluZyB0aGF0IGNhbWVyYSBzZWVzIGl0OiB3ZSBjYW4gdGVsbCB0aGF0XHJcbiAgICAgICAgLy8gcmlnaHQgYXdheS5cclxuICAgICAgICB5aWVsZCBUSUxFXzBfMF8wO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IHRpbGVDb3VudCA9IDEgPDwgem9vbTtcclxuICAgIGNvbnN0IHRpbGVJZHhNYXNrID0gdGlsZUNvdW50IC0gMTtcclxuICAgIC8vIFRoZSBpZGVhIGJlaGluZCB0aGUgY29kZSBiZWxvdyBpcyBxdWl0ZSBzaW1wbGU6IGRldGVybWluZSBjb2x1bW5zIG9mIHRoZVxyXG4gICAgLy8gdGlsZSBncmlkIHRoYXQgYXJlIHZpc2libGUgdG8gdGhlIGNhbWVyYSwgdGhlbiBmb3IgZWFjaCBjb2x1bW4gZmluZFxyXG4gICAgLy8gcmFuZ2Ugb2Ygcm93IGluZGljZXMgdGhhdCBhcmUgdmlzaWJsZS5cclxuICAgIC8vIEhlcmUncyBob3cgd2UgYXBwcm9hY2ggY29tcHV0aW5nIHRpbGUgaW5kaWNlcyBmcm9tIHdvcmxkIGNvb3JkaW5hdGVzLlxyXG4gICAgLy8gRmlyc3QsIHdlIHRyYW5zZm9ybSB3b3JsZCBjb29yZGluYXRlcyBmcm9tIFstMSwgMV0gcmFuZ2UgdG8gWzAsIDJdLFxyXG4gICAgLy8gZGVhbGluZyB3aXRoIGluY29uc2lzdGVuY3kgd2l0aCBZIGF4aXMgZGlyZWN0aW9uIGluIHdvcmxkIGFuZCB0aWxlIGdyaWRcclxuICAgIC8vIGNvb3JkaW5hdGUgc3lzdGVtLiBMZXQncyBkZXNpZ25hdGUgc3VjaCBhIGNvb3JkaW5hdGUgYXMgQyAoZm9yIGVpdGhlciBYXHJcbiAgICAvLyBvciBZKS4gU2l6ZSBvZiBhIHRpbGUgaXMgMiAvIHRpbGVDb3VudC4gVGh1cyxcclxuICAgIC8vXHJcbiAgICAvLyAgICAgIHRpbGVJZHggPSBNYXRoLmZsb29yKEMgLyAoMiAvIHRpbGVDb3VudCkpXHJcbiAgICAvLyAgICAgICAgICAgICAgPSBNYXRoLmZsb29yKEMgKiB0aWxlQ291bnQgLyAyKVxyXG4gICAgLy9cclxuICAgIGNvbnN0IHsgbWluWCwgbWF4WCwgbWluWSwgbWF4WSB9ID0gdmlzaWJsZVJlZ2lvbkJCb3g7XHJcbiAgICBjb25zdCBtaW5UWCA9IE1hdGguZmxvb3IoKG1pblggKyAxKSAqIHRpbGVDb3VudCAvIDIpO1xyXG4gICAgY29uc3QgbWF4VFggPSBNYXRoLmZsb29yKChtYXhYICsgMSkgKiB0aWxlQ291bnQgLyAyKTtcclxuICAgIGNvbnN0IGNvbHVtbkNvdW50ID0gbWF4VFggLSBtaW5UWCArIDE7XHJcbiAgICAvLyBBcnJheXMgb2YgaW5kaWNlcyBvZiBib3R0b21tb3N0IGFuZCB0b3Btb3N0IHRpbGVzIGNvcnJlc3BvbmRpbmdseSBmb3JcclxuICAgIC8vIGVhY2ggY29sdW1uLlxyXG4gICAgLy8gRklYTUUoZG1pa2lzKSBJZiBudW1iZXIgb2YgY29sdW1ucyBpcyB0b28gbGFyZ2UsIHdlJ2xsIGNvbnN1bWUgYSBsb3Qgb2ZcclxuICAgIC8vICAgICAgbWVtb3J5IGhlcmUuIFRoZXJlJ3MgYSBtZXRob2QgdG8gZG8gd2l0aG91dCB0aGUgYXJyYXlzLCBidXQgaXQncyBhXHJcbiAgICAvLyAgICAgIGJpdCBtb3JlIGNvbXBsaWNhdGVkIHRvIGltcGxlbWVudC5cclxuICAgIGNvbnN0IG1pbllzID0gbmV3IEFycmF5KGNvbHVtbkNvdW50KTtcclxuICAgIGNvbnN0IG1heFlzID0gbmV3IEFycmF5KGNvbHVtbkNvdW50KTtcclxuICAgIC8vIENvbW1vbiBzZW5zZSBzdWdnZXN0cyB0aGF0IHRob3NlIGluZGljZXMgY2FuJ3QgYmUgZ3JlYXRlciAobGVzcykgdGhhbiB0aGVcclxuICAgIC8vIGluZGV4IG9mIGEgdGlsZSByb3cgaW50ZXJzZWN0ZWQgYnkgYSBsaW5lIHkgPSBtaW5ZICh5ID0gbWF4WSkuIE5vdGUgdGhhdFxyXG4gICAgLy8gbWF4WSBjb3JyZXNwb25kcyB0byBhIHRpbGUgcm93IHdpdGggbGVzc2VyIGluZGV4LCBub3Qgb3RoZXIgd2F5IGFyb3VuZC5cclxuICAgIG1pbllzLmZpbGwoTWF0aC5mbG9vcigoMSAtIG1pblkpICogdGlsZUNvdW50IC8gMikpO1xyXG4gICAgbWF4WXMuZmlsbChNYXRoLmZsb29yKCgxIC0gbWF4WSkgKiB0aWxlQ291bnQgLyAyKSk7XHJcbiAgICBjb25zdCB2aXNpYmxlUG9seWdvbkxlbmd0aCA9IHZpc2libGVSZWdpb24ubGVuZ3RoO1xyXG4gICAgbGV0IHByZXZYID0gdmlzaWJsZVJlZ2lvblt2aXNpYmxlUG9seWdvbkxlbmd0aCAtIDFdLnggKyAxO1xyXG4gICAgbGV0IHByZXZZID0gMSAtIHZpc2libGVSZWdpb25bdmlzaWJsZVBvbHlnb25MZW5ndGggLSAxXS55O1xyXG4gICAgbGV0IHByZXZUWCA9IE1hdGguZmxvb3IocHJldlggKiB0aWxlQ291bnQgLyAyKTtcclxuICAgIGxldCBwcmV2VFkgPSBNYXRoLmZsb29yKHByZXZZICogdGlsZUNvdW50IC8gMik7XHJcbiAgICAvLyBJdGVyYXRlIG92ZXIgZWRnZXMgb2YgdmlzaWJsZSBwb2x5Z29uIG9mIHRoZSBjYW1lcmEgdG8gY29tcHV0ZSBpbmRleCBvZlxyXG4gICAgLy8gdG9wbW9zdCBhbmQgYm90dG9tbW9zdCB0aWxlcyBmb3IgZWFjaCBjb2x1bW4uXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZpc2libGVQb2x5Z29uTGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBjb25zdCB4ID0gdmlzaWJsZVJlZ2lvbltpXS54ICsgMTtcclxuICAgICAgICBjb25zdCB5ID0gMSAtIHZpc2libGVSZWdpb25baV0ueTtcclxuICAgICAgICBjb25zdCB0eCA9IE1hdGguZmxvb3IoeCAqIHRpbGVDb3VudCAvIDIpO1xyXG4gICAgICAgIGNvbnN0IHR5ID0gTWF0aC5mbG9vcih5ICogdGlsZUNvdW50IC8gMik7XHJcbiAgICAgICAgLy8gRm9yIGVhY2ggZWRnZSB3ZSBjb21wdXRlIDQtY29ubmVjdGVkIGxpbmUgb2YgdGlsZXMgb24gdGhlIHRpbGUgZ3JpZC5cclxuICAgICAgICAvLyBMZW5ndGggb2YgYSA0LWNvbm5lY3RlZCBsaW5lIGFsd2F5cyBlcXVhbHMgTWFuaGF0dGFuIGRpc3RhbmNlIGJldHdlZW5cclxuICAgICAgICAvLyBpdHMgZW5kcy4gSG93ZXZlciwgdG8gYXZvaWQgdW5uZWNlc3NhcnkgY29tcHV0YXRpb24sIHdlIG9taXQgbGFzdCB0aWxlXHJcbiAgICAgICAgLy8gZm9yIGV2ZXJ5IGVkZ2UuIEJ1dCwgc2luY2UgdGhlIHBvbHlnb24gaXMgY2xvc2VkLCB3ZSdsbCBpdGVyYXRlIG92ZXJcclxuICAgICAgICAvLyBhbGwgdGlsZXMgaW50ZXJzZWN0ZWQgYnkgZWRnZXMgYW55d2F5LlxyXG4gICAgICAgIGNvbnN0IGwgPSBNYXRoLmFicyh0eCAtIHByZXZUWCkgKyBNYXRoLmFicyh0eSAtIHByZXZUWSk7XHJcbiAgICAgICAgY29uc3QgbHggPSB4IC0gcHJldlg7XHJcbiAgICAgICAgY29uc3QgbHkgPSB5IC0gcHJldlk7XHJcbiAgICAgICAgY29uc3QgZHR4ID0gbHggPiAwID8gMSA6IC0xO1xyXG4gICAgICAgIGNvbnN0IGR0eSA9IGx5ID4gMCA/IDEgOiAtMTtcclxuICAgICAgICBjb25zdCBhID0gMiAqIGR0eCAqIGx5O1xyXG4gICAgICAgIGNvbnN0IGIgPSAtMiAqIGR0eCAqIGx4O1xyXG4gICAgICAgIGNvbnN0IGMgPSBkdHggKiB0aWxlQ291bnQgKiAobHggKiBwcmV2WSAtIGx5ICogcHJldlgpICsgYSAqICh+ZHR4ID4+PiAzMSk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHR4ID0gcHJldlRYLCB0eSA9IHByZXZUWTsgaSA8IGw7ICsraSkge1xyXG4gICAgICAgICAgICBjb25zdCBpbnRlcmNlcHQgPSBhICogdHggKyBiICogdHkgKyBjO1xyXG4gICAgICAgICAgICAvLyBUaGUgbWF0aCBoZXJlIGlzIHNvbWV3aGF0IGN1bWJlcnNvbWUgdG8gYXZvaWQgZGl2aXNpb25zLCBidXQgdGhlXHJcbiAgICAgICAgICAgIC8vIGVzc2VuY2UgaXMgdGhhdCB3ZSB0cnkgdG8gY2hlY2sgdGhyb3VnaCB3aGljaCBzaWRlIHRoZSBlZGdlIG9mXHJcbiAgICAgICAgICAgIC8vIHZpc2libGUgcG9seWdvbiBleGl0cyB0aGUgdGlsZS4gRGVwZW5kaW5nIG9uIHRoYXQgd2UgXCJtb3ZlXCIgdG9cclxuICAgICAgICAgICAgLy8gbmV4dCB0aWxlIGluIGVpdGhlciB2ZXJ0aWNhbCBvciBob3Jpem9udGFsIGRpcmVjdGlvbi5cclxuICAgICAgICAgICAgaWYgKDAgPD0gaW50ZXJjZXB0ICYmIGludGVyY2VwdCA8PSAtYikge1xyXG4gICAgICAgICAgICAgICAgdHggKz0gZHR4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdHkgKz0gZHR5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHlJZHggPSB0eCAtIG1pblRYO1xyXG4gICAgICAgICAgICBpZiAobWF4WXNbeUlkeF0gPCB0eSkge1xyXG4gICAgICAgICAgICAgICAgbWF4WXNbeUlkeF0gPSB0eTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobWluWXNbeUlkeF0gPiB0eSkge1xyXG4gICAgICAgICAgICAgICAgbWluWXNbeUlkeF0gPSB0eTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBwcmV2WCA9IHg7XHJcbiAgICAgICAgcHJldlkgPSB5O1xyXG4gICAgICAgIHByZXZUWCA9IHR4O1xyXG4gICAgICAgIHByZXZUWSA9IHR5O1xyXG4gICAgfVxyXG4gICAgLy8gSWYgdGhlIHdvcmxkIGlzIHJlcGVhdGVkIGFsb25nIFggYXhpcywgd2UgbmVlZCB0byBcImZvbGRcIiB0aGUgYXJyYXkgb2YgY29sdW1ucyxcclxuICAgIC8vIGkuZS4gY29tcHV0ZSB1bmlvbiBvZiByb3cgaW50ZXJ2YWxzIGZvciBjb2x1bW5zIHRpbGVDb3VudCBpbmRpY2VzIGFwYXJ0LlxyXG4gICAgaWYgKHdyYXBNb2RlWCA9PT0gMiAvKiBSRVBFQVQgKi8gJiYgY29sdW1uQ291bnQgPiB0aWxlQ291bnQpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRpbGVDb3VudDsgKytpKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgdGlsZUNvdW50OyBqIDwgY29sdW1uQ291bnQ7IGogKz0gdGlsZUNvdW50KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobWF4WXNbaV0gPCBtYXhZc1tqXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1heFlzW2ldID0gbWF4WXNbal07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobWluWXNbaV0gPiBtaW5Zc1tqXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbllzW2ldID0gbWluWXNbal07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBJZiB0aGUgd29ybGQgaXMgcmVwZWF0ZWQgYWxvbmcgWSBheGlzLCB3ZSBuZWVkIHRvIHdyYXAgaW5kaWNlcyBpbiBtaW5Zc1xyXG4gICAgLy8gYW5kIG1heFlzIGFycmF5cyB0byBbMCwgdGlsZUNvdW50KSBpbnRlcnZhbC5cclxuICAgIGlmICh3cmFwTW9kZVkgPT09IDIgLyogUkVQRUFUICovKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2x1bW5Db3VudCAmJiBpIDwgdGlsZUNvdW50OyArK2kpIHtcclxuICAgICAgICAgICAgY29uc3QgZHkgPSBtYXhZc1tpXSAtIG1pbllzW2ldO1xyXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSdzIG1vcmUgdGhhbiB0aWxlQ291bnQgcm93cyBiZXR3ZWVuIG1heFkgYW5kIG1pblksIHRoZW4gdGhlXHJcbiAgICAgICAgICAgIC8vIHdvcmxkIGlzIGVuY29tcGFzc2VkIHNvbWV3aGVyZSB3aXRoaW4gdmlzaWJsZSByZWdpb24uXHJcbiAgICAgICAgICAgIGlmIChkeSA+IHRpbGVDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgbWluWXNbaV0gPSAwO1xyXG4gICAgICAgICAgICAgICAgbWF4WXNbaV0gPSB0aWxlSWR4TWFzaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1pblkgPSBtaW5Zc1tpXSAmPSB0aWxlSWR4TWFzaztcclxuICAgICAgICAgICAgICAgIG1heFlzW2ldID0gbWluWSArIGR5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2x1bW5Db3VudCAmJiBpIDwgdGlsZUNvdW50OyArK2kpIHtcclxuICAgICAgICAgICAgbWluWXNbaV0gPSBNYXRoLm1heChtaW5Zc1tpXSwgMCk7XHJcbiAgICAgICAgICAgIG1heFlzW2ldID0gTWF0aC5taW4obWF4WXNbaV0sIHRpbGVJZHhNYXNrKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAod3JhcE1vZGVYID09PSAyIC8qIFJFUEVBVCAqLykge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sdW1uQ291bnQgJiYgaSA8IHRpbGVDb3VudDsgKytpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHR4ID0gKGkgKyBtaW5UWCkgJiB0aWxlSWR4TWFzaztcclxuICAgICAgICAgICAgZm9yIChsZXQgdHkgPSBtaW5Zc1tpXTsgdHkgPD0gbWF4WXNbaV07ICsrdHkpIHtcclxuICAgICAgICAgICAgICAgIHlpZWxkIHtcclxuICAgICAgICAgICAgICAgICAgICB4OiB0eCxcclxuICAgICAgICAgICAgICAgICAgICB5OiB0eSAmIHRpbGVJZHhNYXNrLFxyXG4gICAgICAgICAgICAgICAgICAgIHpvb21cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBmb3IgKGxldCB0eCA9IE1hdGgubWF4KG1pblRYLCAwKSwgdHhFbmQgPSBNYXRoLm1pbihtYXhUWCwgdGlsZUlkeE1hc2spOyB0eCA8PSB0eEVuZDsgKyt0eCkge1xyXG4gICAgICAgICAgICBjb25zdCBpID0gdHggLSBtaW5UWDtcclxuICAgICAgICAgICAgZm9yIChsZXQgdHkgPSBtaW5Zc1tpXTsgdHkgPD0gbWF4WXNbaV07ICsrdHkpIHtcclxuICAgICAgICAgICAgICAgIHlpZWxkIHtcclxuICAgICAgICAgICAgICAgICAgICB4OiB0eCxcclxuICAgICAgICAgICAgICAgICAgICB5OiB0eSAmIHRpbGVJZHhNYXNrLFxyXG4gICAgICAgICAgICAgICAgICAgIHpvb21cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdGlsZV9iYXNlZF9hZGFwdGVyL3V0aWwvdmlzaWJsZV90aWxlLnRzXG4vLyBtb2R1bGUgaWQgPSA3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBnZXRUaWxlSWQsIGdldFRpbGVJZEJ5UmF3VmFsdWVzIH0gZnJvbSAnLi90aWxlX2lkJztcclxuaW1wb3J0ICogYXMgdmVjMiBmcm9tICcuLi8uLi9tYXRoL3ZlY3RvcjInO1xyXG5pbXBvcnQgeyBjeWNsZVJlc3RyaWN0IH0gZnJvbSAnLi4vLi4vbWF0aC9zY2FsYXInO1xyXG5jb25zdCBMRUZUX1NJREUgPSB7XHJcbiAgICBkaXJlY3Rpb246IHZlYzIuY3JlYXRlKDAsIC0xKSxcclxuICAgIG5vcm1hbDogdmVjMi5jcmVhdGUoLTEsIDApLFxyXG4gICAgZGlhZ29uYWw6IHZlYzIuY3JlYXRlKC0xLCAtMSksXHJcbiAgICBwcmV2U2lkZTogKCkgPT4gQk9UVE9NX1NJREUsXHJcbiAgICBuZXh0U2lkZTogKCkgPT4gVE9QX1NJREVcclxufTtcclxuY29uc3QgUklHSFRfU0lERSA9IHtcclxuICAgIGRpcmVjdGlvbjogdmVjMi5jcmVhdGUoMCwgKzEpLFxyXG4gICAgbm9ybWFsOiB2ZWMyLmNyZWF0ZSgrMSwgMCksXHJcbiAgICBkaWFnb25hbDogdmVjMi5jcmVhdGUoKzEsICsxKSxcclxuICAgIHByZXZTaWRlOiAoKSA9PiBUT1BfU0lERSxcclxuICAgIG5leHRTaWRlOiAoKSA9PiBCT1RUT01fU0lERVxyXG59O1xyXG5jb25zdCBUT1BfU0lERSA9IHtcclxuICAgIGRpcmVjdGlvbjogdmVjMi5jcmVhdGUoKzEsIDApLFxyXG4gICAgbm9ybWFsOiB2ZWMyLmNyZWF0ZSgwLCAtMSksXHJcbiAgICBkaWFnb25hbDogdmVjMi5jcmVhdGUoKzEsIC0xKSxcclxuICAgIHByZXZTaWRlOiAoKSA9PiBMRUZUX1NJREUsXHJcbiAgICBuZXh0U2lkZTogKCkgPT4gUklHSFRfU0lERVxyXG59O1xyXG5jb25zdCBCT1RUT01fU0lERSA9IHtcclxuICAgIGRpcmVjdGlvbjogdmVjMi5jcmVhdGUoLTEsIDApLFxyXG4gICAgbm9ybWFsOiB2ZWMyLmNyZWF0ZSgwLCArMSksXHJcbiAgICBkaWFnb25hbDogdmVjMi5jcmVhdGUoLTEsICsxKSxcclxuICAgIHByZXZTaWRlOiAoKSA9PiBSSUdIVF9TSURFLFxyXG4gICAgbmV4dFNpZGU6ICgpID0+IExFRlRfU0lERVxyXG59O1xyXG4vKipcclxuICogQWRkcyB0aWxlIHRvIGJlbHQgdGlsZXMgaWYgaXQgZG9lc24ndCBmYWxsIG91dCBvZiB0aGUgd29ybGQuIEN5Y2xpbmcgY29vcmRpbmF0ZXMgY2FuJ3QgZmFsbCBvdXQsXHJcbiAqIHRoZXkganVzdCBnb3QgYWRqdXN0ZWQgZGlyZWN0bHkgaW4gdGlsZSBpdGVtLlxyXG4gKi9cclxuZnVuY3Rpb24gYWRkVGlsZUlmQXBwcm9wcmlhdGUodGlsZSwgYmVsdFRpbGVzLCBtYXhDb29yZGluYXRlLCBpc1hDeWNsZWQsIGlzWUN5Y2xlZCkge1xyXG4gICAgdGlsZS54ID0gaXNYQ3ljbGVkID8gY3ljbGVSZXN0cmljdCh0aWxlLngsIDAsIG1heENvb3JkaW5hdGUpIDogdGlsZS54O1xyXG4gICAgdGlsZS55ID0gaXNZQ3ljbGVkID8gY3ljbGVSZXN0cmljdCh0aWxlLnksIDAsIG1heENvb3JkaW5hdGUpIDogdGlsZS55O1xyXG4gICAgaWYgKCgwIDw9IHRpbGUueCkgJiYgKHRpbGUueCA8IG1heENvb3JkaW5hdGUpICYmXHJcbiAgICAgICAgKDAgPD0gdGlsZS55KSAmJiAodGlsZS55IDwgbWF4Q29vcmRpbmF0ZSkpIHtcclxuICAgICAgICBiZWx0VGlsZXMuc2V0KGdldFRpbGVJZCh0aWxlKSwgdGlsZSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFRoZSBhbGdvcml0aG0gaXMgaW1wbGVtZW50ZWQgYXMgYSBzdGF0ZSBtYWNoaW5lLCB0aGlzIG1ldGhvZCBwcm9kdWNlcyBiZWx0IHRpbGVzIGFuZCBzZXRzIGFwcHJvcHJpYXRlIHN0YXRlLlxyXG4gKiBIb3cgdG8gY2hhbmdlIHRoaXMgc3RhdGUgKGRldGVybWluZSBjdXJyZW50IHRpbGUgYW5kIGl0cyBzaWRlKSBpcyBkZXNjcmliZWQgaW4gZm91ciBUaWxlU2lkZSBpbXBsZW1lbnRhdGlvbnM6XHJcbiAqIGxlZnQsIHJpZ2h0LCB0b3AgYW5kIGJvdHRvbS5cclxuICovXHJcbmZ1bmN0aW9uIG1vdmUodGlsZXMsIHN0YXRlLCBzaXplLCBtYXhDb29yZGluYXRlLCBpc1hDeWNsZWQsIGlzWUN5Y2xlZCkge1xyXG4gICAgLy8gYWRkIHRpbGVzIG91dHdhcmQgaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgbm9ybWFsXHJcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBzaXplOyBpKyspIHtcclxuICAgICAgICBhZGRUaWxlSWZBcHByb3ByaWF0ZSh7XHJcbiAgICAgICAgICAgIHg6IHN0YXRlLmN1cnJlbnRUaWxlLnggKyBpICogc3RhdGUuY3VycmVudFRpbGVTaWRlLm5vcm1hbC54LFxyXG4gICAgICAgICAgICB5OiBzdGF0ZS5jdXJyZW50VGlsZS55ICsgaSAqIHN0YXRlLmN1cnJlbnRUaWxlU2lkZS5ub3JtYWwueSxcclxuICAgICAgICAgICAgem9vbTogc3RhdGUuY3VycmVudFRpbGUuem9vbVxyXG4gICAgICAgIH0sIHN0YXRlLmJlbHRUaWxlcywgbWF4Q29vcmRpbmF0ZSwgaXNYQ3ljbGVkLCBpc1lDeWNsZWQpO1xyXG4gICAgfVxyXG4gICAgLy8gY2hlY2sgZGlhZ29uYWwgdGlsZVxyXG4gICAgY29uc3QgZGlhZ29uYWxOZWlnaGJvdXIgPSB0aWxlcy5nZXQoZ2V0VGlsZUlkQnlSYXdWYWx1ZXMoc3RhdGUuY3VycmVudFRpbGUueCArIHN0YXRlLmN1cnJlbnRUaWxlU2lkZS5kaWFnb25hbC54LCBzdGF0ZS5jdXJyZW50VGlsZS55ICsgc3RhdGUuY3VycmVudFRpbGVTaWRlLmRpYWdvbmFsLnksIHN0YXRlLmN1cnJlbnRUaWxlLnpvb20pKTtcclxuICAgIGlmIChkaWFnb25hbE5laWdoYm91cikge1xyXG4gICAgICAgIHN0YXRlLmN1cnJlbnRUaWxlID0gZGlhZ29uYWxOZWlnaGJvdXI7XHJcbiAgICAgICAgc3RhdGUuY3VycmVudFRpbGVTaWRlID0gc3RhdGUuY3VycmVudFRpbGVTaWRlLnByZXZTaWRlKCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgLy8gY2hlY2sgbmVpZ2hib3VyIGluIHRoZSBzYW1lIGRpcmVjdGlvblxyXG4gICAgY29uc3QgbmVpZ2hib3VyID0gdGlsZXMuZ2V0KGdldFRpbGVJZEJ5UmF3VmFsdWVzKHN0YXRlLmN1cnJlbnRUaWxlLnggKyBzdGF0ZS5jdXJyZW50VGlsZVNpZGUuZGlyZWN0aW9uLngsIHN0YXRlLmN1cnJlbnRUaWxlLnkgKyBzdGF0ZS5jdXJyZW50VGlsZVNpZGUuZGlyZWN0aW9uLnksIHN0YXRlLmN1cnJlbnRUaWxlLnpvb20pKTtcclxuICAgIGlmIChuZWlnaGJvdXIpIHtcclxuICAgICAgICBzdGF0ZS5jdXJyZW50VGlsZSA9IG5laWdoYm91cjtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAvLyBoYW5kbGUgY29ybmVyIHRpbGVzXHJcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBzaXplOyBpKyspIHtcclxuICAgICAgICBmb3IgKGxldCBqID0gMTsgaiA8PSBzaXplOyBqKyspIHtcclxuICAgICAgICAgICAgYWRkVGlsZUlmQXBwcm9wcmlhdGUoe1xyXG4gICAgICAgICAgICAgICAgeDogc3RhdGUuY3VycmVudFRpbGUueCArIGkgKiBzdGF0ZS5jdXJyZW50VGlsZVNpZGUuZGlhZ29uYWwueCxcclxuICAgICAgICAgICAgICAgIHk6IHN0YXRlLmN1cnJlbnRUaWxlLnkgKyBqICogc3RhdGUuY3VycmVudFRpbGVTaWRlLmRpYWdvbmFsLnksXHJcbiAgICAgICAgICAgICAgICB6b29tOiBzdGF0ZS5jdXJyZW50VGlsZS56b29tXHJcbiAgICAgICAgICAgIH0sIHN0YXRlLmJlbHRUaWxlcywgbWF4Q29vcmRpbmF0ZSwgaXNYQ3ljbGVkLCBpc1lDeWNsZWQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRlLmN1cnJlbnRUaWxlU2lkZSA9IHN0YXRlLmN1cnJlbnRUaWxlU2lkZS5uZXh0U2lkZSgpO1xyXG59XHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRpbGVzIHRoYXQgc3Vycm91bmQgcHJvdmlkZWQgcmVnaW9uIChzZXQgb2YgdGlsZXMpLCB0aGUgcmVnaW9uIG11c3QgYmUgb25lIG9yIG1vcmUgY29udmV4IHBvbHlnb25zXHJcbiAqIHdpdGggbm8gaG9sZXMsIG90aGVyd2lzZSBjb3JyZWN0bmVzcyBpcyBub3QgZ3VhcmFudGVlZC4gTXVsdGlwbGUgcG9seWdvbnMgY2FuIGhhcHBlbiB3aGVuIHRoZSBjYW1lcmEgbG9va3NcclxuICogYXQgdGhlIGVkZ2Ugb2YgdGhlIHdvcmxkIGNhcHR1cmluZyBjeWNsZWQgdGlsZXMgZnJvbSBkaWZmZXJlbnQgc2lkZXMuXHJcbiAqIFRoZSBsb2dpYyBvZiBpbmNsdWRpbmcgdGlsZXMgaW4gdGhlIFwiYmVsdFwiIGlzIGFzIGZvbGxvd3M6IHNob3J0ZXN0IGRpc3RhbmNlIGZyb20gXCJvdXRzaWRlXCIgdG8gYW55IHBvaW50XHJcbiAqIGluIHRoZSBvcmlnaW5hbCByZWdpb24gc2hvdWxkIGJlIG5vdCBsZXNzIHRoYW4gdGlsZVNpemUgKiBiZWx0U2l6ZS5cclxuICpcclxuICogQHBhcmFtIHRpbGVzIFNldCBvZiB0aWxlcyB0aGF0IGNvdmVyIGEgY29udmV4IHBvbHlnb24uXHJcbiAqIEBwYXJhbSBiZWx0U2l6ZSBcInRoaWNrbmVzc1wiIChpbiB0aWxlcykgb2YgdGhlIHN1cnJvdW5kaW5nIGFyZWEuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlQmVsdFRpbGVzKHRpbGVzLCBiZWx0U2l6ZSwgaXNYQ3ljbGVkLCBpc1lDeWNsZWQpIHtcclxuICAgIC8vIHRoZSBhbGdvcml0aG0gaW4gc2ltcGxlIHdvcmRzOlxyXG4gICAgLy8gICAxLiBmaW5kIGEgdGlsZSBvbiBhbiBlZGdlIG9mIHRoZSBwb2x5Z29uIChlLmcuIG9uZSBvZiB0aGUgbGVmdG1vc3Qgb25lcylcclxuICAgIC8vICAgMi4gZ28gYXJvdW5kIHRoZSBwb2x5Z29uIHRpbGUtYnktdGlsZSBhZGRpbmcgc3Vycm91bmRpbmcgdGlsZXMgb3V0d2FyZGx5XHJcbiAgICBjb25zdCBpbmRleGVkVGlsZXMgPSBuZXcgTWFwKCk7XHJcbiAgICBjb25zdCBiZWx0VGlsZXMgPSBuZXcgTWFwKCk7XHJcbiAgICAvLyBpbmRleCB0aWxlc1xyXG4gICAgZm9yIChjb25zdCB0aWxlSXRlbSBvZiB0aWxlcykge1xyXG4gICAgICAgIGluZGV4ZWRUaWxlcy5zZXQoZ2V0VGlsZUlkKHRpbGVJdGVtKSwgdGlsZUl0ZW0pO1xyXG4gICAgfVxyXG4gICAgLy8gdGlsZXMgYXJlIGdyb3VwZWQgaW50byBvbmUgb3IgbW9yZSBjb252ZXggcG9seWdvbnMsIHByb2Nlc3MgdGhlc2UgcG9seWdvbnMgb25lIGJ5IG9uZVxyXG4gICAgY29uc3QgdGlsZXNUb1Byb2Nlc3MgPSBuZXcgTWFwKGluZGV4ZWRUaWxlcyk7XHJcbiAgICB3aGlsZSAodGlsZXNUb1Byb2Nlc3Muc2l6ZSA+IDApIHtcclxuICAgICAgICBsZXQgbGVmdG1vc3RUaWxlID0geyB4OiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIHk6IDAsIHpvb206IDAgfTtcclxuICAgICAgICAvLyBmaW5kIHRoZSBsZWZ0bW9zdCB0aWxlIHRvIHN0YXJ0IHdhbGtpbmcgZnJvbVxyXG4gICAgICAgIGZvciAoY29uc3QgdGlsZUl0ZW0gb2YgdGlsZXNUb1Byb2Nlc3MudmFsdWVzKCkpIHtcclxuICAgICAgICAgICAgaWYgKHRpbGVJdGVtLnggPCBsZWZ0bW9zdFRpbGUueCkge1xyXG4gICAgICAgICAgICAgICAgbGVmdG1vc3RUaWxlID0gdGlsZUl0ZW07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gc2F2ZSBtaW4vbWF4IHkgdmFsdWUgcGVyIHggY29vcmRpbmF0ZSB0byBiZSBhYmxlXHJcbiAgICAgICAgLy8gdG8gbWFyayB0aGVzZSB0aWxlcyBhcyBwcm9jZXNzZWQgKHJlbW92ZSBmcm9tIHRpbGVzVG9Qcm9jZXNzKVxyXG4gICAgICAgIGNvbnN0IG1heFkgPSBbXTtcclxuICAgICAgICBjb25zdCBtaW5ZID0gW107XHJcbiAgICAgICAgY29uc3QgaW5pdFN0YXRlID0geyBjdXJyZW50VGlsZTogbGVmdG1vc3RUaWxlLCBjdXJyZW50VGlsZVNpZGU6IExFRlRfU0lERSwgYmVsdFRpbGVzIH07XHJcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBPYmplY3QuYXNzaWduKHt9LCBpbml0U3RhdGUpO1xyXG4gICAgICAgIGNvbnN0IG1heENvb3JkaW5hdGUgPSBNYXRoLnBvdygyLCBsZWZ0bW9zdFRpbGUuem9vbSk7XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAvLyBtb3ZlIGFyb3VuZCB3aGlsZSB3ZSBkb24ndCByZWFjaCB0aGUgaW5pdCBwb3NpdGlvblxyXG4gICAgICAgICAgICBtb3ZlKHRpbGVzVG9Qcm9jZXNzLCBzdGF0ZSwgYmVsdFNpemUsIG1heENvb3JkaW5hdGUsIGlzWEN5Y2xlZCwgaXNZQ3ljbGVkKTtcclxuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBzdGF0ZS5jdXJyZW50VGlsZS54IC0gaW5pdFN0YXRlLmN1cnJlbnRUaWxlLng7XHJcbiAgICAgICAgICAgIG1heFlbaW5kZXhdID0gbWF4WVtpbmRleF0gPT09IHVuZGVmaW5lZCA/IHN0YXRlLmN1cnJlbnRUaWxlLnkgOiBNYXRoLm1heChtYXhZW2luZGV4XSwgc3RhdGUuY3VycmVudFRpbGUueSk7XHJcbiAgICAgICAgICAgIG1pbllbaW5kZXhdID0gbWluWVtpbmRleF0gPT09IHVuZGVmaW5lZCA/IHN0YXRlLmN1cnJlbnRUaWxlLnkgOiBNYXRoLm1pbihtaW5ZW2luZGV4XSwgc3RhdGUuY3VycmVudFRpbGUueSk7XHJcbiAgICAgICAgfSB3aGlsZSAoc3RhdGUuY3VycmVudFRpbGUgIT09IGluaXRTdGF0ZS5jdXJyZW50VGlsZSB8fFxyXG4gICAgICAgICAgICBzdGF0ZS5jdXJyZW50VGlsZVNpZGUgIT09IGluaXRTdGF0ZS5jdXJyZW50VGlsZVNpZGUpO1xyXG4gICAgICAgIC8vIG1hcmsgdGlsZXMgZnJvbSBjdXJyZW50IHBvbHlnb24gYXMgcHJvY2Vzc2VkXHJcbiAgICAgICAgY29uc3Qgem9vbSA9IGxlZnRtb3N0VGlsZS56b29tO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4WS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCB4ID0gbGVmdG1vc3RUaWxlLnggKyBpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gbWluWVtpXTsgeSA8PSBtYXhZW2ldOyB5KyspIHtcclxuICAgICAgICAgICAgICAgIHRpbGVzVG9Qcm9jZXNzLmRlbGV0ZShnZXRUaWxlSWRCeVJhd1ZhbHVlcyh4LCB5LCB6b29tKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyByZW1vdmUgYmVsdCB0aWxlcyB0aGF0IG92ZXJsYXBzIHRvIGF2b2lkIGR1cGxpY2F0aW9uc1xyXG4gICAgZm9yIChjb25zdCB0aWxlSWQgb2YgYmVsdFRpbGVzLmtleXMoKSkge1xyXG4gICAgICAgIGlmIChpbmRleGVkVGlsZXMuaGFzKHRpbGVJZCkpIHtcclxuICAgICAgICAgICAgYmVsdFRpbGVzLmRlbGV0ZSh0aWxlSWQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBiZWx0VGlsZXMudmFsdWVzKCk7XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdGlsZV9iYXNlZF9hZGFwdGVyL2JlbHRfdGlsZXMudHNcbi8vIG1vZHVsZSBpZCA9IDczXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IEF0dHJpYnV0ZU1hcHBpbmcgfSBmcm9tICcuLi8uLi9yZW5kZXIvYXR0cmliX21hcHBpbmcnO1xyXG5pbXBvcnQgQnVmZmVyV3JpdGVyIGZyb20gJy4uLy4uL3V0aWwvYnVmZmVyX3dyaXRlcic7XHJcbi8qKlxyXG4gKiBXcml0ZXIgb2YgZ2VvbWV0cnkgZGF0YSBvZiBpY29ucy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEljb25CdWZmZXJXcml0ZXIgZXh0ZW5kcyBCdWZmZXJXcml0ZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoSWNvbkJ1ZmZlcldyaXRlci5BVFRSSUJVVEVfTUFQUElORy52ZXJ0ZXhCeXRlU2l6ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhbiBpY29uIHRvIGJ1ZmZlcnMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGljb24gSWNvbiB0byBiZSB3cml0dGVuIHRvIGJ1ZmZlci5cclxuICAgICAqIEBwYXJhbSBsb2NhdGlvbiBJbWFnZSBsb2NhdGlvbiBpbiBhdGxhcy5cclxuICAgICAqIEBwYXJhbSBzaXplIEltYWdlIHNpemUgaW4gYXRsYXMuXHJcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IE9mZnNldCBvZiBpbWFnZSBwb2ludHMgaW4gQ1NTIHBpeGVscy5cclxuICAgICAqIEBwYXJhbSBwaXhlbFJhdGlvIFJhdGlvIG9mIGltYWdlIHNpemUgaW4gQ1NTIHBpeGVscyB0byB0aGUgc2l6ZSBpbiBhdGxhcyBwaXhlbHMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgTG9jYXRpb24gb2YgdGhlIGljb24gZGF0YSBpbiBidWZmZXJzLlxyXG4gICAgICovXHJcbiAgICB3cml0ZUljb24oaWNvbiwgbG9jYXRpb24sIHNpemUsIG9mZnNldCwgcGl4ZWxSYXRpbykge1xyXG4gICAgICAgIGNvbnN0IHRvcCA9IG9mZnNldC55O1xyXG4gICAgICAgIGNvbnN0IGJvdHRvbSA9IG9mZnNldC55ICsgc2l6ZS5oZWlnaHQgKiBwaXhlbFJhdGlvO1xyXG4gICAgICAgIGNvbnN0IGxlZnQgPSBvZmZzZXQueDtcclxuICAgICAgICBjb25zdCByaWdodCA9IG9mZnNldC54ICsgc2l6ZS53aWR0aCAqIHBpeGVsUmF0aW87XHJcbiAgICAgICAgdGhpcy53cml0ZVZlcnRleChpY29uLnBvc2l0aW9uLCBsZWZ0LCBib3R0b20sIGxvY2F0aW9uLm1pblgsIGxvY2F0aW9uLm1pblkpO1xyXG4gICAgICAgIHRoaXMud3JpdGVWZXJ0ZXgoaWNvbi5wb3NpdGlvbiwgbGVmdCwgdG9wLCBsb2NhdGlvbi5taW5YLCBsb2NhdGlvbi5tYXhZKTtcclxuICAgICAgICB0aGlzLndyaXRlVmVydGV4KGljb24ucG9zaXRpb24sIHJpZ2h0LCBib3R0b20sIGxvY2F0aW9uLm1heFgsIGxvY2F0aW9uLm1pblkpO1xyXG4gICAgICAgIHRoaXMud3JpdGVWZXJ0ZXgoaWNvbi5wb3NpdGlvbiwgcmlnaHQsIHRvcCwgbG9jYXRpb24ubWF4WCwgbG9jYXRpb24ubWF4WSk7XHJcbiAgICAgICAgdGhpcy53cml0ZUluZGljZXNGb3JDb250aW51b3VzU3RyaXAoNCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kTWVzaCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYSB2ZXJ0ZXggdG8gdGhlIHZlcnRleCBidWZmZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBvc2l0aW9uIFBvc2l0aW9uIG9mIHRoZSB2ZXJ0ZXggaW4gZGlzcGxheSBjb29yZGluYXRlcy5cclxuICAgICAqIEBwYXJhbSB1diBVVnMgb2YgdGhlIHZlcnRleC5cclxuICAgICAqIEByZXR1cm4gSW5kZXggb2YgdGhlIHdyaXR0ZW4gdmVydGV4LlxyXG4gICAgICovXHJcbiAgICB3cml0ZVZlcnRleChwb3NpdGlvbiwgZGlzcGxhY2VtZW50WCwgZGlzcGxhY2VtZW50WSwgdXZYLCB1dlkpIHtcclxuICAgICAgICBjb25zdCB2ZXJ0ZXhJZHggPSB0aGlzLmdldEN1cnJlbnRWZXJ0ZXhJZHgoKTtcclxuICAgICAgICB0aGlzLl93cml0ZVdvcmxkQ29vcmRpbmF0ZShwb3NpdGlvbik7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVIYWxmV29yZHMoZGlzcGxhY2VtZW50WCwgZGlzcGxhY2VtZW50WSk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVIYWxmV29yZHModXZYLCB1dlkpO1xyXG4gICAgICAgIHJldHVybiB2ZXJ0ZXhJZHg7XHJcbiAgICB9XHJcbn1cclxuLyoqIERlc2NyaXB0aW9uIG9mIGhvdyBhIHdyaXRlciBzdG9yZXMgdmVydGV4IGRhdGEuICovXHJcbkljb25CdWZmZXJXcml0ZXIuQVRUUklCVVRFX01BUFBJTkcgPSBuZXcgQXR0cmlidXRlTWFwcGluZyhbXHJcbiAgICBbXHJcbiAgICAgICAgMCAvKiBQT1NJVElPTl9ISUdIICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMixcclxuICAgICAgICAgICAgdHlwZTogNTEyMyAvKiBVTlNJR05FRF9TSE9SVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgMSAvKiBQT1NJVElPTl9MT1cgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIzIC8qIFVOU0lHTkVEX1NIT1JUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICA2IC8qIERJU1BMQUNFTUVOVCAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDIsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjIgLyogU0hPUlQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICA0IC8qIFVWICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMixcclxuICAgICAgICAgICAgdHlwZTogNTEyMyAvKiBVTlNJR05FRF9TSE9SVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICBdXHJcbl0pO1xyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9wcmltaXRpdmUvaWNvbi9pY29uX2J1ZmZlcl93cml0ZXIudHNcbi8vIG1vZHVsZSBpZCA9IDc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBSZWZlcmVuY2VDb3VudGVkIGZyb20gJy4uL3V0aWwvcmVmX2NvdW50ZWQnO1xyXG4vKipcclxuICogUmVwcmVzZW50cyBhbiBhbGxvY2F0ZWQgaW1hZ2UuIEFsbG9jYXRlZCBpbWFnZSBpcyBhIHNoYXJlYWJsZSByZXNvdXJjZSB0aGF0IHNob3VsZCBiZSByZXNlYWxlZFxyXG4gKiB3aGVuIHRoZXJlIGFyZSBubyBjbGllbnRzIHVzZSBpdC4gQXMgaXQgaXMgbm90IHBvc3NpYmxlIHRvIHJlbHkgb24gdGhlIEdDLCBjbGllbnRzIHNob3VsZFxyXG4gKiBtYW51YWxseSByZXRhaW4gdGhlaXIgcmVxdWlyZWQgaW1hZ2VzIGFuZCByZWxlYXNlIHRoZW0gd2hlbiB0aGV5IGFyZSBub3QgcmVxdWlyZWQgYW55bW9yZS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBBbGxvY2F0ZWRJbWFnZSBleHRlbmRzIFJlZmVyZW5jZUNvdW50ZWQge1xyXG4gICAgY29uc3RydWN0b3IoZGVzY3JpcHRvciwgYmJveCwgYXRsYXNNYW5hZ2VyKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmRlc2NyaXB0b3IgPSBkZXNjcmlwdG9yO1xyXG4gICAgICAgIHRoaXMuYmJveCA9IGJib3g7XHJcbiAgICAgICAgdGhpcy5hdGxhc01hbmFnZXIgPSBhdGxhc01hbmFnZXI7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVJbWFnZShzb3VyY2VJbWFnZSwgbG9jYXRpb25SZWdpb24sIHNvdXJjZUltYWdlUmVnaW9uKSB7XHJcbiAgICAgICAgdGhpcy5hdGxhc01hbmFnZXIuYXRsYXMudXBkYXRlSW1hZ2UodGhpcy5iYm94LCBzb3VyY2VJbWFnZSwgbG9jYXRpb25SZWdpb24sIHNvdXJjZUltYWdlUmVnaW9uKTtcclxuICAgIH1cclxuICAgIF9kZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMuYXRsYXNNYW5hZ2VyLnJlbW92ZUltYWdlKHRoaXMuZGVzY3JpcHRvcik7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIE1hbmFnZXMgYWxsb2NhdGlvbiBvZiBpbWFnZXMgYnkgaWQuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJZGVudGlmaWVkSW1hZ2VBdGxhc01hbmFnZXIge1xyXG4gICAgY29uc3RydWN0b3IoaW1hZ2VBdGxhcykge1xyXG4gICAgICAgIHRoaXMuYXRsYXMgPSBpbWFnZUF0bGFzO1xyXG4gICAgICAgIHRoaXMuX2xvY2F0aW9ucyA9IG5ldyBNYXAoKTtcclxuICAgIH1cclxuICAgIGdldCBzaXplKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhdGlvbnMuc2l6ZTtcclxuICAgIH1cclxuICAgIGdldEltYWdlKGlkLCByZXRhaW4gPSBmYWxzZSkge1xyXG4gICAgICAgIGNvbnN0IGltYWdlTG9jYXRpb24gPSB0aGlzLl9sb2NhdGlvbnMuZ2V0KGlkKTtcclxuICAgICAgICBpZiAocmV0YWluICYmIGltYWdlTG9jYXRpb24pIHtcclxuICAgICAgICAgICAgaW1hZ2VMb2NhdGlvbi5yZXRhaW4oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGltYWdlTG9jYXRpb24gfHwgbnVsbDtcclxuICAgIH1cclxuICAgIGFsbG9jYXRlSW1hZ2UoZGVzY3JpcHRvciwgaW1hZ2UpIHtcclxuICAgICAgICBjb25zdCBsb2NhdGlvbiA9IHRoaXMuYXRsYXMuYWxsb2NhdGVJbWFnZShkZXNjcmlwdG9yLCBpbWFnZSk7XHJcbiAgICAgICAgaWYgKGxvY2F0aW9uKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGltYWdlID0gbmV3IEFsbG9jYXRlZEltYWdlKGRlc2NyaXB0b3IsIGxvY2F0aW9uLCB0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5fbG9jYXRpb25zLnNldChkZXNjcmlwdG9yLmlkLCBpbWFnZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBpbWFnZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICByZW1vdmVJbWFnZShpbWFnZSkge1xyXG4gICAgICAgIGNvbnN0IGxvY2F0aW9uID0gdGhpcy5fbG9jYXRpb25zLmdldChpbWFnZS5pZCk7XHJcbiAgICAgICAgaWYgKGxvY2F0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXRsYXMucmVtb3ZlSW1hZ2UobG9jYXRpb24uYmJveCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvY2F0aW9ucy5kZWxldGUoaW1hZ2UuaWQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnRhaW5zKGlkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2F0aW9ucy5oYXMoaWQpO1xyXG4gICAgfVxyXG4gICAgcmVzZXJ2ZUxvY2F0aW9uKGRlc2NyaXB0b3IpIHtcclxuICAgICAgICBjb25zdCBsb2NhdGlvbiA9IHRoaXMuYXRsYXMucmVzZXJ2ZUxvY2F0aW9uKGRlc2NyaXB0b3IpO1xyXG4gICAgICAgIGlmIChsb2NhdGlvbikge1xyXG4gICAgICAgICAgICBjb25zdCBpbWFnZSA9IG5ldyBBbGxvY2F0ZWRJbWFnZShkZXNjcmlwdG9yLCBsb2NhdGlvbiwgdGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvY2F0aW9ucy5zZXQoZGVzY3JpcHRvci5pZCwgaW1hZ2UpO1xyXG4gICAgICAgICAgICByZXR1cm4gaW1hZ2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2JpbGxib2FyZC9pZGVudGlmaWVkX2ltYWdlX2F0bGFzX21hbmFnZXIudHNcbi8vIG1vZHVsZSBpZCA9IDc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiBGb250IGlzIGp1c3QgYSBjb2xsZWN0aW9uIG9mIGdseXBoIGRlc2NyaXB0aW9ucy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZvbnQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gaWQgRm9udCBpZC5cclxuICAgICAqIEBwYXJhbSB4aGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIFwieFwiIGNoYXIgaW4gYWJzdHJhY3QgcG9pbnRzLCBpbiBmYWN0IGlzIHVzZWQgYSB0aGUgZm9udCBzaXplLlxyXG4gICAgICogQHBhcmFtIHVua25vd25HbHlwaEluc3RhbmNlIEFuIGluc3RhbmNlIG9mIGdseXBoIHRvIGJlIHNlcnZlZCBhcyBhIHN0dWIgd2hlbiBub25leGlzdGVudCBnbHlwaFxyXG4gICAgICogICAgIGlzIHJlcXVlc3RlZC4gUmVxdWVzdGluZyBub25leGlzdGVudCBnbHlwaHMgbm9ybWFsbHkgc2hvdWxkIG5vdCBoYXBwZW4uXHJcbiAgICAgKiAgICAgVGhlIHN0dWIganVzdCBhbGxvd3MgdG8gYXZvaWQgdGVkaW91cyBudWxsIGNoZWNrcyBpbiBmb250IGNsaWVudHMuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGlkLCB4aGVpZ2h0LCB1bmtub3duR2x5cGhJbnN0YW5jZSkge1xyXG4gICAgICAgIHRoaXMuaWQgPSBpZDtcclxuICAgICAgICB0aGlzLnhoZWlnaHQgPSB4aGVpZ2h0O1xyXG4gICAgICAgIHRoaXMuX3Vua25vd25HbHlwaEluc3RhbmNlID0gdW5rbm93bkdseXBoSW5zdGFuY2U7XHJcbiAgICAgICAgdGhpcy5fZ2x5cGhzID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIEdseXBoIHdpdGggc3BlY2lmaWVkIGlkIG9yIHVua25vd24gZ2x5cGggaW5zdGFuY2UuXHJcbiAgICAgKi9cclxuICAgIGdldEdseXBoKGdseXBoSWQpIHtcclxuICAgICAgICBjb25zdCBnbHlwaCA9IHRoaXMuX2dseXBocy5nZXQoZ2x5cGhJZCk7XHJcbiAgICAgICAgaWYgKGdseXBoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBnbHlwaDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignV293LXdvdy13b3csIHNvbWV0aGluZyB3ZW50IHdyb25nLCB5b3Ugc2hvdWxkIG5vdCByZXF1ZXN0IG5vbmV4aXN0ZW50IGdseXBocycpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdW5rbm93bkdseXBoSW5zdGFuY2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBBbGwgc3RvcmVkIGdseXBocy5cclxuICAgICAqL1xyXG4gICAgZ2V0QWxsR2x5cGhzKCkge1xyXG4gICAgICAgIHJldHVybiBbLi4udGhpcy5fZ2x5cGhzLnZhbHVlcygpXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBnbHlwaCBkZXNjcmlwdGlvbi5cclxuICAgICAqL1xyXG4gICAgYWRkR2x5cGgoZ2x5cGgpIHtcclxuICAgICAgICB0aGlzLl9nbHlwaHMuc2V0KGdseXBoLmlkLCBnbHlwaCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgZ2x5cGggZGVzY3JpcHRpb25zIGZyb20gdGhlIGl0ZXJhYmxlLlxyXG4gICAgICovXHJcbiAgICBhZGRBbGxHbHlwaHMoZ2x5cGhzKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBnbHlwaCBvZiBnbHlwaHMpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRHbHlwaChnbHlwaCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2ZvbnQvZm9udC50c1xuLy8gbW9kdWxlIGlkID0gNzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgSW1hZ2VQcm92aWRlciB9IGZyb20gJy4uLy4uL2JpbGxib2FyZC9pbWFnZV9wcm92aWRlcic7XHJcbmltcG9ydCBnZXREcHIgZnJvbSAnLi4vLi4vdXRpbC9oZCc7XHJcbmltcG9ydCB7IGdldEhvc3RBbGlhc0J5VWlkIH0gZnJvbSAnLi91dGlsL2hvc3RzJztcclxuLyoqXHJcbiAqIEltYWdlIHByb3ZpZGVyIHRoYXQgZ2V0cyBpbWFnZXMgZnJvbSBzcGVjaWZpYyBBUEkgZW50cnkgcG9pbnQuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQXBpSW1hZ2VQcm92aWRlciBleHRlbmRzIEltYWdlUHJvdmlkZXIge1xyXG4gICAgY29uc3RydWN0b3IoaW1hZ2VVcmxUZW1wbGF0ZSkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5faW1hZ2VVcmxUZW1wbGF0ZSA9IGltYWdlVXJsVGVtcGxhdGU7XHJcbiAgICB9XHJcbiAgICBnZXRJbWFnZVVybChpZCkge1xyXG4gICAgICAgIC8vIEFQSSBjYW4gcmV0dXJuIHNjYWxlZCBpbWFnZXMgdGhhdCBhbGxvd3MgdXMgdG8gcmVxdWVzdCBpbWFnZXMgYWNjb3JkaW5nXHJcbiAgICAgICAgLy8gdG8gdXNlcidzIERQSSBhbmQgcmVuZGVyIHRoZW0gcHJvcGVybHksIG5vbi1pbnRlZ2VyIG51bWJlcnMgYXJlIGFjY2VwdGVkLlxyXG4gICAgICAgIHJldHVybiB0aGlzLl9pbWFnZVVybFRlbXBsYXRlXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKCd7e2hvc3RBbGlhc319JywgZ2V0SG9zdEFsaWFzQnlVaWQoaWQpKVxyXG4gICAgICAgICAgICAucmVwbGFjZSgvXFx7XFx7aWRcXH1cXH0vZywgaWQpXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKCd7e3NjYWxlfX0nLCBnZXREcHIoKS50b1N0cmluZygpKTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9hZGFwdGVycy92ZWN0b3JfYXBpL2FwaV9pbWFnZV9wcm92aWRlci50c1xuLy8gbW9kdWxlIGlkID0gNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIEFic3RyYWN0IGltYWdlIGNvbnRlbnQgcHJvdmlkZXIsIGNvbmNyZXRlIGltcGxlbWVudGF0aW9ucyBzaG91bGQgc3BlY2lmeSB0aGUgZW50cnkgcG9pbnQgaW4gZ2V0SW1hZ2VVcmwoKS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBJbWFnZVByb3ZpZGVyIHtcclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBpbWFnZSBiaXRtYXAgdmlhIGFuIEhUTUxJbWFnZUVsZW1lbnQgYW5kIGEgY2FudmFzLlxyXG4gICAgICovXHJcbiAgICBnZXRJbWFnZShpZCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGltYWdlRWxlbWVudCA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICAgICAgICBpbWFnZUVsZW1lbnQuY3Jvc3NPcmlnaW4gPSAnYW5vbnltb3VzJztcclxuICAgICAgICAgICAgaW1hZ2VFbGVtZW50Lm9ubG9hZCA9ICgpID0+IHJlc29sdmUoaW1hZ2VFbGVtZW50KTtcclxuICAgICAgICAgICAgaW1hZ2VFbGVtZW50Lm9uZXJyb3IgPSByZWplY3Q7XHJcbiAgICAgICAgICAgIGltYWdlRWxlbWVudC5zcmMgPSB0aGlzLmdldEltYWdlVXJsKGlkKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9iaWxsYm9hcmQvaW1hZ2VfcHJvdmlkZXIudHNcbi8vIG1vZHVsZSBpZCA9IDc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImNvbnN0IEhPU1RfQUxJQVNFU19OID0gNDtcclxuZXhwb3J0IGZ1bmN0aW9uIGdldEhvc3RBbGlhc0J5VWlkKHVpZCkge1xyXG4gICAgbGV0IHN1bSA9IDA7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVpZC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHN1bSArPSB1aWQuY2hhckNvZGVBdChpKTtcclxuICAgIH1cclxuICAgIHJldHVybiAoc3VtICUgSE9TVF9BTElBU0VTX04gKyAxKS50b1N0cmluZygpO1xyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2FkYXB0ZXJzL3ZlY3Rvcl9hcGkvdXRpbC9ob3N0cy50c1xuLy8gbW9kdWxlIGlkID0gNzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgQXR0cmlidXRlTWFwcGluZyB9IGZyb20gJy4uLy4uL3JlbmRlci9hdHRyaWJfbWFwcGluZyc7XHJcbmltcG9ydCBCdWZmZXJXcml0ZXIgZnJvbSAnLi4vLi4vdXRpbC9idWZmZXJfd3JpdGVyJztcclxuaW1wb3J0IHdyaXRlVGV4dHVyZWRQb2x5bGluZUdlb21ldHJ5IGZyb20gJy4vdGV4dHVyZWRfcG9seWxpbmVfZ2VvbWV0cnknO1xyXG5pbXBvcnQgeyBpbnRUb1pJbmRleCB9IGZyb20gJy4uLy4uL3V0aWwvel9pbmRleCc7XHJcbi8qKlxyXG4gKiBXcml0ZXIgb2YgZ2VvbWV0cnkgZGF0YSBvZiBwb2x5bGluZSBodWxscy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRleHR1cmVkUG9seWxpbmVCdWZmZXJXcml0ZXIgZXh0ZW5kcyBCdWZmZXJXcml0ZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoVGV4dHVyZWRQb2x5bGluZUJ1ZmZlcldyaXRlci5BVFRSSUJVVEVfTUFQUElORy52ZXJ0ZXhCeXRlU2l6ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlcyBhIGh1bGwgZm9yIGEgcG9seWxpbmUgYW5kIHdyaXRlcyBpdCB0byB0aGUgd3JpdGVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwb2x5bGluZSBUaGUgcG9seWxpbmUgdG8gYmUgd3JpdHRlbi5cclxuICAgICAqIEBwYXJhbSB3aWR0aCBUaGlja25lc3Mgb2YgdGhlIHBvbHlsaW5lLlxyXG4gICAgICogQHBhcmFtIHdvcmxkVG9QeEZhY3RvciBSYXRpbyBvZiB3b3JsZCBjb29yZGluYXRlcyB0byBwaXhlbHMuXHJcbiAgICAgKiBAcGFyYW0gaW1hZ2VMb2NhdGlvbiBJbWFnZSBsb2NhdGlvbiBpbiBhdGxhcy5cclxuICAgICAqIEBwYXJhbSB6SW5kZXggWi1pbmRleCBvZiB0aGUgcG9seWxpbmUuXHJcbiAgICAgKi9cclxuICAgIHdyaXRlVGV4dHVyZWRQb2x5bGluZShwb2x5bGluZSwgd2lkdGgsIHdvcmxkVG9QeEZhY3RvciwgaW1hZ2VMb2NhdGlvbiwgekluZGV4KSB7XHJcbiAgICAgICAgd3JpdGVUZXh0dXJlZFBvbHlsaW5lR2VvbWV0cnkodGhpcywgcG9seWxpbmUudmVydGljZXMsIHdvcmxkVG9QeEZhY3RvciwgaW1hZ2VMb2NhdGlvbiwgd2lkdGgsIGludFRvWkluZGV4KHpJbmRleCArIDEpKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5lbmRNZXNoKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIHZlcnRleCB0byB0aGUgdmVydGV4IGJ1ZmZlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcG9zaXRpb24gUG9zaXRpb24gb2YgdGhlIHZlcnRleCBpbiB3b3JsZCBjb29yZGluYXRlcy5cclxuICAgICAqIEBwYXJhbSBkaXNwbGFjZW1lbnQgRGlzcGxhY2VtZW50IHZlY3RvciwgaW4gbW9zdCBjYXNlcyBtdXN0IGJlIG5vcm1hbGl6ZWQsIHRoZSB3aWR0aCBpcyBjb25zaWRlcmVkIGluIHNoYWRlcnMuXHJcbiAgICAgKiBAcGFyYW0gaGFsZldpZHRoIFRoaWNrbmVzcyBvZiB0aGUgcG9seWxpbmUuXHJcbiAgICAgKiBAcGFyYW0gcGF0dGVyV2lkdGggV2lkdGggb2YgdGhlIGltYWdlIHRoYXQgaXMgcmVwZWF0ZWQgYWxvbmcgdGhlIHBvbHlsaW5lLlxyXG4gICAgICogQHBhcmFtIHBhdHRlcm5IYWxmSGVpZ2h0IEltYWdlIGhhbGYgaGVpZ2h0IG11bHRpcGxpZWQgYnkgYHNpZ24ocylgLCB3aGVyZSBgc2AgaXMgYSBbLTE7IDFdIGRpc3RhbmNlIHRvIHRoZVxyXG4gICAgICogYW5hbHl0aWNhbCBwb2x5bGluZSBhbG9uZyBzZWdtZW50J3Mgbm9ybWFsLlxyXG4gICAgICogQHBhcmFtIGxlbmd0aCBMZW5ndGggb2YgdGhlIHBvbHlsaW5lIGZvciBjdXJyZW50IHZlcnRleCwgbmVlZGVkIHRvIGNvcnJlY3RseSBjYWxjdWxhdGUgaW1hZ2UgdXYgeCBjb29yZGluYXRlLlxyXG4gICAgICogQHBhcmFtIHV2IFVWIGNvb3JkaW5hdGVzIG9mIHRoZSBpbWFnZS5cclxuICAgICAqIEBwYXJhbSB6SW5kZXggWi1pbmRleCBvZiB0aGUgcG9seWxpbmUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiBJbmRleCBvZiB0aGUgd3JpdHRlbiB2ZXJ0ZXguXHJcbiAgICAgKi9cclxuICAgIHdyaXRlVmVydGV4KHBvc2l0aW9uLCBkaXNwbGFjZW1lbnQsIGhhbGZXaWR0aCwgcGF0dGVybldpZHRoLCBwYXR0ZXJuSGFsZkhlaWdodCwgbGVuZ3RoLCB1diwgekluZGV4KSB7XHJcbiAgICAgICAgY29uc3QgdmVydGV4SWR4ID0gdGhpcy5nZXRDdXJyZW50VmVydGV4SWR4KCk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVXb3JsZENvb3JkaW5hdGUocG9zaXRpb24pO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlRmxvYXQzMihkaXNwbGFjZW1lbnQueCk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVGbG9hdDMyKGRpc3BsYWNlbWVudC55KTtcclxuICAgICAgICB0aGlzLl93cml0ZUhhbGZXb3Jkcyh1di54LCB1di55KTtcclxuICAgICAgICB0aGlzLl93cml0ZUZsb2F0MzIoekluZGV4KTtcclxuICAgICAgICB0aGlzLl93cml0ZUZsb2F0MzIoaGFsZldpZHRoKTtcclxuICAgICAgICB0aGlzLl93cml0ZUhhbGZXb3JkcyhwYXR0ZXJuV2lkdGgsIGxlbmd0aCk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVGbG9hdDMyKHBhdHRlcm5IYWxmSGVpZ2h0KTtcclxuICAgICAgICByZXR1cm4gdmVydGV4SWR4O1xyXG4gICAgfVxyXG59XHJcbi8qKiBEZXNjcmlwdGlvbiBvZiBob3cgYSB3cml0ZXIgc3RvcmVzIHZlcnRleCBkYXRhLiAqL1xyXG5UZXh0dXJlZFBvbHlsaW5lQnVmZmVyV3JpdGVyLkFUVFJJQlVURV9NQVBQSU5HID0gbmV3IEF0dHJpYnV0ZU1hcHBpbmcoW1xyXG4gICAgW1xyXG4gICAgICAgIDAgLyogUE9TSVRJT05fSElHSCAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDIsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjMgLyogVU5TSUdORURfU0hPUlQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDEgLyogUE9TSVRJT05fTE9XICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMixcclxuICAgICAgICAgICAgdHlwZTogNTEyMyAvKiBVTlNJR05FRF9TSE9SVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgNiAvKiBESVNQTEFDRU1FTlQgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTI2IC8qIEZMT0FUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgNCAvKiBVViAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDIsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjMgLyogVU5TSUdORURfU0hPUlQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICA5IC8qIFBSSU9SSVRZICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMSxcclxuICAgICAgICAgICAgdHlwZTogNTEyNiAvKiBGTE9BVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDExIC8qIEFVWCAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDEsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjYgLyogRkxPQVQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICAxMiAvKiBBVVgxICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMixcclxuICAgICAgICAgICAgdHlwZTogNTEyMyAvKiBVTlNJR05FRF9TSE9SVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDEzIC8qIEFVWDIgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAxLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTI2IC8qIEZMT0FUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgIF1cclxuXSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3ByaW1pdGl2ZS9wb2x5bGluZS90ZXh0dXJlZF9wb2x5bGluZV9idWZmZXJfd3JpdGVyLnRzXG4vLyBtb2R1bGUgaWQgPSA4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgKiBhcyB2ZWMyIGZyb20gJy4uLy4uL21hdGgvdmVjdG9yMic7XHJcbi8qKlxyXG4gKiBXcml0ZXMgcG9seWxpbmUgaW1hZ2UgZ2VvbWV0cnkgKHNldCBvZiB0cmlhbmdsZXMgdGhhdCBkcmF3IHVwIGEgc29saWQgdGhpY2sgcG9seWxpbmUpIGludG8gYSBidWZmZXIgd3JpdGVyLlxyXG4gKlxyXG4gKiBAcGFyYW0gd3JpdGVyIE91dHB1dCBidWZmZXIgd3JpdGVyLlxyXG4gKiBAcGFyYW0gcG9seWxpbmUgUG9seWxpbmUgdG8gYmUgd3JpdHRlbi5cclxuICogQHBhcmFtIHdvcmxkVG9QeEZhY3RvciBSYXRpbyBvZiB3b3JsZCBjb29yZGluYXRlcyB0byBwaXhlbHMuXHJcbiAqIEBwYXJhbSBpbWFnZUxvY2F0aW9uIEltYWdlIGxvY2F0aW9uIGluIGF0bGFzLlxyXG4gKiBAcGFyYW0gd2lkdGggVGhpY2tuZXNzIG9mIHRoZSBwb2x5bGluZS5cclxuICogQHBhcmFtIHogWi1pbmRleCBvZiB0aGUgcG9seWxpbmUuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB3cml0ZVRleHR1cmVkUG9seWxpbmVHZW9tZXRyeSh3cml0ZXIsIHBvbHlsaW5lLCB3b3JsZFRvUHhGYWN0b3IsIGltYWdlTG9jYXRpb24sIHdpZHRoLCB6KSB7XHJcbiAgICBjb25zdCBoV2lkdGggPSB3aWR0aCAvIDI7XHJcbiAgICBjb25zdCBwYXR0ZXJuV2lkdGggPSBpbWFnZUxvY2F0aW9uLm1heFggLSBpbWFnZUxvY2F0aW9uLm1pblg7XHJcbiAgICBjb25zdCBwYXR0ZXJuSGFsZkhlaWdodCA9IChpbWFnZUxvY2F0aW9uLm1heFkgLSBpbWFnZUxvY2F0aW9uLm1pblkpIC8gMjtcclxuICAgIGNvbnN0IHNlZ21lbnQgPSB2ZWMyLmNyZWF0ZSgwLCAwKTtcclxuICAgIGNvbnN0IGRpciA9IHZlYzIuY3JlYXRlKDAsIDApO1xyXG4gICAgY29uc3QgcHJldkRpciA9IHZlYzIuY3JlYXRlKDAsIDApO1xyXG4gICAgY29uc3Qgbm9ybSA9IHZlYzIuY3JlYXRlKDAsIDApO1xyXG4gICAgY29uc3Qgbm9ybUludiA9IHZlYzIuY3JlYXRlKDAsIDApO1xyXG4gICAgY29uc3QgdXYgPSB2ZWMyLmNyZWF0ZShpbWFnZUxvY2F0aW9uLm1pblgsIDApO1xyXG4gICAgbGV0IHByZXZCb3R0b21SaWdodCA9IC0xO1xyXG4gICAgbGV0IHByZXZUb3BSaWdodCA9IC0xO1xyXG4gICAgbGV0IGxlbmd0aCA9IDA7XHJcbiAgICBsZXQgcHJldkxlbmd0aCA9IDA7XHJcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHBvbHlsaW5lLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmVjMi5zdWIocG9seWxpbmVbaV0sIHBvbHlsaW5lW2kgLSAxXSwgc2VnbWVudCk7XHJcbiAgICAgICAgdmVjMi5ub3JtYWxpemUoc2VnbWVudCwgZGlyKTtcclxuICAgICAgICB2ZWMyLnJvdGF0ZTkwKGRpciwgbm9ybSk7XHJcbiAgICAgICAgdmVjMi5tdWxuKG5vcm0sIC0xLCBub3JtSW52KTtcclxuICAgICAgICAvLyBzZWdtZW50IGlzIHdyaXR0ZW4gYXMgYSByZWN0YW5nbGUgKHR3byB0cmlhbmdsZXMpXHJcbiAgICAgICAgdXYueSA9IGltYWdlTG9jYXRpb24ubWluWTtcclxuICAgICAgICBjb25zdCB0b3BMZWZ0ID0gd3JpdGVyLndyaXRlVmVydGV4KHBvbHlsaW5lW2kgLSAxXSwgbm9ybSwgaFdpZHRoLCBwYXR0ZXJuV2lkdGgsIHBhdHRlcm5IYWxmSGVpZ2h0LCBsZW5ndGgsIHV2LCB6KTtcclxuICAgICAgICB1di55ID0gaW1hZ2VMb2NhdGlvbi5tYXhZO1xyXG4gICAgICAgIGNvbnN0IGJvdHRvbUxlZnQgPSB3cml0ZXIud3JpdGVWZXJ0ZXgocG9seWxpbmVbaSAtIDFdLCBub3JtSW52LCBoV2lkdGgsIHBhdHRlcm5XaWR0aCwgLXBhdHRlcm5IYWxmSGVpZ2h0LCBsZW5ndGgsIHV2LCB6KTtcclxuICAgICAgICAvLyB1cGRhdGUgbGVuZ3RoIG9mIHRoZSBwb2x5bGluZSBpbiBwaXhlbHNcclxuICAgICAgICBsZW5ndGggKz0gdmVjMi5sZW5ndGgoc2VnbWVudCkgLyB3b3JsZFRvUHhGYWN0b3I7XHJcbiAgICAgICAgdXYueSA9IGltYWdlTG9jYXRpb24ubWluWTtcclxuICAgICAgICBjb25zdCB0b3BSaWdodCA9IHdyaXRlci53cml0ZVZlcnRleChwb2x5bGluZVtpXSwgbm9ybSwgaFdpZHRoLCBwYXR0ZXJuV2lkdGgsIHBhdHRlcm5IYWxmSGVpZ2h0LCBsZW5ndGgsIHV2LCB6KTtcclxuICAgICAgICB1di55ID0gaW1hZ2VMb2NhdGlvbi5tYXhZO1xyXG4gICAgICAgIGNvbnN0IGJvdHRvbVJpZ2h0ID0gd3JpdGVyLndyaXRlVmVydGV4KHBvbHlsaW5lW2ldLCBub3JtSW52LCBoV2lkdGgsIHBhdHRlcm5XaWR0aCwgLXBhdHRlcm5IYWxmSGVpZ2h0LCBsZW5ndGgsIHV2LCB6KTtcclxuICAgICAgICAvLyB3cml0ZSBsaW5lIGpvaW4gdGhhdCBmaWxscyBhbiBlbXB0eSBzcGFjZSBvbiBjb3JuZXJzXHJcbiAgICAgICAgaWYgKDEgPCBpICYmIGkgPCBwb2x5bGluZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdXYueSA9IChpbWFnZUxvY2F0aW9uLm1heFkgKyBpbWFnZUxvY2F0aW9uLm1pblkpIC8gMjtcclxuICAgICAgICAgICAgY29uc3Qgam9pblBvaW50SW5kZXggPSB3cml0ZXIud3JpdGVWZXJ0ZXgocG9seWxpbmVbaSAtIDFdLCB2ZWMyLlpFUk8sIGhXaWR0aCwgcGF0dGVybldpZHRoLCAwLCBwcmV2TGVuZ3RoLCB1diwgeik7XHJcbiAgICAgICAgICAgIC8vIGZpbmQgb3V0IHdoZXJlIHRoZSBmcmFjdHVyZSBvZiBzZWdtZW50cyBpcyBsb2NhdGVkIHRvIGNyZWF0ZSBjb3JyZWN0IGpvaW4gd2l0aCBtaW5pbXVtIG92ZXJkcmF3XHJcbiAgICAgICAgICAgIGNvbnN0IHR1cm5MZWZ0ID0gdmVjMi5jcm9zc1oocHJldkRpciwgZGlyKSA+IDA7XHJcbiAgICAgICAgICAgIGlmICh0dXJuTGVmdCkge1xyXG4gICAgICAgICAgICAgICAgd3JpdGVyLndyaXRlSW5kaWNlcyhbXHJcbiAgICAgICAgICAgICAgICAgICAgam9pblBvaW50SW5kZXgsIGJvdHRvbUxlZnQsIHByZXZCb3R0b21SaWdodFxyXG4gICAgICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB3cml0ZXIud3JpdGVJbmRpY2VzKFtcclxuICAgICAgICAgICAgICAgICAgICBqb2luUG9pbnRJbmRleCwgcHJldlRvcFJpZ2h0LCB0b3BMZWZ0XHJcbiAgICAgICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB3cml0ZXIud3JpdGVJbmRpY2VzKFtcclxuICAgICAgICAgICAgdG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsXHJcbiAgICAgICAgICAgIHRvcFJpZ2h0LCBib3R0b21SaWdodCwgYm90dG9tTGVmdFxyXG4gICAgICAgIF0pO1xyXG4gICAgICAgIHZlYzIuY29weShkaXIsIHByZXZEaXIpO1xyXG4gICAgICAgIHByZXZCb3R0b21SaWdodCA9IGJvdHRvbVJpZ2h0O1xyXG4gICAgICAgIHByZXZUb3BSaWdodCA9IHRvcFJpZ2h0O1xyXG4gICAgICAgIHByZXZMZW5ndGggPSBsZW5ndGg7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL3BvbHlsaW5lL3RleHR1cmVkX3BvbHlsaW5lX2dlb21ldHJ5LnRzXG4vLyBtb2R1bGUgaWQgPSA4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICogTWFuYWdlcyBhbGxvY2F0aW9uIG9mIHJlcXVlc3RlZCBpbWFnZXMuIFRoZSBzYW1lIGltYWdlcyBjYW4gYmUgcmVxdWVzdGVkIG11bHRpcGxlIHRpbWVzIGZyb20gZGlmZmVyZW50IHBsYWNlcyxcclxuICogdGhpcyBjbGFzcyB0YWtlcyBvdmVyIGR1cGxpY2F0aW9uIG9mIEhUVFAgcmVxdWVzdHMvYXRsYXMgYWxsb2NhdGlvbnMgcHJvdmlkaW5nIHNpbXBsZSBhc3luYyBpbnRlcmZhY2UgZm9yXHJcbiAqIGdldHRpbmcgYWxsb2NhdGVkIGltYWdlcy5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBJbWFnZU1hbmFnZXIge1xyXG4gICAgY29uc3RydWN0b3IoYXRsYXMsIHByb3ZpZGVyKSB7XHJcbiAgICAgICAgdGhpcy5fYXRsYXMgPSBhdGxhcztcclxuICAgICAgICB0aGlzLl9wcm92aWRlciA9IHByb3ZpZGVyO1xyXG4gICAgICAgIHRoaXMuX3JlcXVlc3RzID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGltYWdlIGlmIGl0IGlzIGFscmVhZHkgYWxsb2NhdGVkLiBQYXkgYXR0ZW50aW9uIHRoYXQgcmVzdWx0ZWQgYWxsb2NhdGVkIGltYWdlIGlzIFwicmV0YWluZWRcIixcclxuICAgICAqIHNvIGl0IG11c3QgYmUgcmVsZWFzZWQgb25jZSBpdCBpcyBwYXNzZWQgdG8gYSByZXNwb25zaWJsZSBjbGllbnQuXHJcbiAgICAgKi9cclxuICAgIGdldEltYWdlKGlkKSB7XHJcbiAgICAgICAgY29uc3QgaW1hZ2UgPSB0aGlzLl9hdGxhcy5nZXRJbWFnZShpZCwgdHJ1ZSk7XHJcbiAgICAgICAgaWYgKGltYWdlKSB7XHJcbiAgICAgICAgICAgIGltYWdlLnJldGFpbigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaW1hZ2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlcXVlc3QgaW1hZ2UgZnJvbSBpbWFnZSBwcm92aWRlciwgaWYgaXQgaXMgYWxyZWFkeSBhbGxvY2F0ZWQgbm8gcmVxdWVzdCBpcyBtYWRlLCBidXQgaXQgaXMgcmV0dXJuZWRcclxuICAgICAqIHdyYXBwZWQgaW50byBhIHJlc29sdmVkIHByb21pc2UuIFBheSBhdHRlbnRpb24gdGhhdCByZXN1bHRlZCBhbGxvY2F0ZWQgaW1hZ2UgaXMgXCJyZXRhaW5lZFwiLCBzbyBpdCBtdXN0IGJlXHJcbiAgICAgKiByZWxlYXNlZCBvbmNlIGl0IGlzIHBhc3NlZCB0byBhIHJlc3BvbnNpYmxlIGNsaWVudC5cclxuICAgICAqL1xyXG4gICAgcmVxdWVzdEltYWdlKGlkKSB7XHJcbiAgICAgICAgY29uc3QgYWxsb2NhdGVkSW1hZ2UgPSB0aGlzLl9hdGxhcy5nZXRJbWFnZShpZCwgdHJ1ZSk7XHJcbiAgICAgICAgaWYgKGFsbG9jYXRlZEltYWdlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoYWxsb2NhdGVkSW1hZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuX3JlcXVlc3RzLmdldChpZCk7XHJcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0KSB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnRoZW4oKGFsbG9jYXRlZEltYWdlKSA9PiBhbGxvY2F0ZWRJbWFnZSAmJiBhbGxvY2F0ZWRJbWFnZS5yZXRhaW4oKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxdWVzdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLl9wcm92aWRlclxyXG4gICAgICAgICAgICAgICAgICAgIC5nZXRJbWFnZShpZClcclxuICAgICAgICAgICAgICAgICAgICAudGhlbigoaW1hZ2UpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXF1ZXN0cy5kZWxldGUoaWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gaW1hZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWxsb2NhdGVkSW1hZ2UgPSB0aGlzLl9hdGxhcy5hbGxvY2F0ZUltYWdlKHsgaWQsIHdpZHRoLCBoZWlnaHQgfSwgaW1hZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghYWxsb2NhdGVkSW1hZ2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZG5cXCcgYWxsb2NhdGVkIGltYWdlJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWxsb2NhdGVkSW1hZ2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RzLmRlbGV0ZShpZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSByZXF1ZXN0IGZhaWxlZCcpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXF1ZXN0cy5zZXQoaWQsIHJlcXVlc3QpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYmlsbGJvYXJkL2ltYWdlX21hbmFnZXIudHNcbi8vIG1vZHVsZSBpZCA9IDgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBCdWZmZXJSZXdyaXRlciBmcm9tICcuLi8uLi91dGlsL2J1ZmZlcl9yZXdyaXRlcic7XHJcbmltcG9ydCB7IFRFWFRVUkVEX1BPTFlHT05fQVRUUklCVVRFX01BUFBJTkcgfSBmcm9tICcuL3RleHR1cmVkX3BvbHlnb25fYXR0cmlidXRlX21hcHBpbmcnO1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXh0dXJlZFBvbHlnb25CdWZmZXJSZXdyaXRlciBleHRlbmRzIEJ1ZmZlclJld3JpdGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGJ1ZmZlcnMpIHtcclxuICAgICAgICBzdXBlcihURVhUVVJFRF9QT0xZR09OX0FUVFJJQlVURV9NQVBQSU5HLCBidWZmZXJzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGxvY2F0aW9uIExvY2F0aW9uIG9mIHRoZSBwb2x5Z29uIGluIG1lbW9yeS5cclxuICAgICAqIEBwYXJhbSBpbWFnZUxvY2F0aW9uIExvY2F0aW9uIG9mIHRoZSBwYXR0ZXJuIGluIGF0bGFzLlxyXG4gICAgICogQHBhcmFtIGltYWdlU2NhbGUgSG93IHdvcmxkIGNvb3JkaW5hdGVzIHJlbGF0ZSB0byB0aGUgaW1hZ2Ugc2l6ZS5cclxuICAgICAqL1xyXG4gICAgcmV3cml0ZVVWKGxvY2F0aW9uLCBpbWFnZUxvY2F0aW9uLCBpbWFnZVNjYWxlKSB7XHJcbiAgICAgICAgY29uc3QgdXZPZmZzZXQgPSB0aGlzLl9nZXRBdHRyaWJPZmZzZXQoNCAvKiBVViAqLyk7XHJcbiAgICAgICAgY29uc3Qgc2NhbGVPZmZzZXQgPSB0aGlzLl9nZXRBdHRyaWJPZmZzZXQoMTEgLyogQVVYICovKTtcclxuICAgICAgICB0aGlzLl9mb3JFYWNoVmVydGV4KGxvY2F0aW9uLCAod3JpdGVyKSA9PiB7XHJcbiAgICAgICAgICAgIHdyaXRlci53cml0ZUhhbGZXb3Jkcyh1dk9mZnNldCwgaW1hZ2VMb2NhdGlvbi5taW5YLCBpbWFnZUxvY2F0aW9uLm1pblkpO1xyXG4gICAgICAgICAgICB3cml0ZXIud3JpdGVIYWxmV29yZHModXZPZmZzZXQgKyAxLCBpbWFnZUxvY2F0aW9uLm1heFggLSBpbWFnZUxvY2F0aW9uLm1pblgsIGltYWdlTG9jYXRpb24ubWF4WSAtIGltYWdlTG9jYXRpb24ubWluWSk7XHJcbiAgICAgICAgICAgIHdyaXRlci53cml0ZUZsb2F0MzIoc2NhbGVPZmZzZXQsIGltYWdlU2NhbGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3ByaW1pdGl2ZS9wb2x5Z29uL3RleHR1cmVkX3BvbHlnb25fYnVmZmVyX3Jld2l0ZXIudHNcbi8vIG1vZHVsZSBpZCA9IDgzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IFdPUkRfQllURV9TSVpFIH0gZnJvbSAnLi9idWZmZXJfd3JpdGVyJztcclxuLyoqXHJcbiAqIENsYXNzIHRoYXQgaXMgZXhwb3NlZCBhcyBhbiBpbnRlcmZhY2UgZm9yIHdyaXRpbmcgdG8gYSBzcGVjaWZpYyB2ZXJ0ZXggYXR0cmlidXRlLlxyXG4gKi9cclxuY2xhc3MgVmVydGV4V3JpdGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHZlcnRleEJ1ZmZlcikge1xyXG4gICAgICAgIHRoaXMuX3ZlcnRleEJ1ZmZlciA9IG5ldyBVaW50MzJBcnJheSh2ZXJ0ZXhCdWZmZXIuYnVmZmVyLCAwLCB2ZXJ0ZXhCdWZmZXIubGVuZ3RoKTtcclxuICAgICAgICB0aGlzLl92ZXJ0ZXhCdWZmZXJGbG9hdDMyVmlldyA9IG5ldyBGbG9hdDMyQXJyYXkodmVydGV4QnVmZmVyLmJ1ZmZlciwgMCwgdmVydGV4QnVmZmVyLmxlbmd0aCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBmbG9hdCBhdHRyaWJ1dGUgaW50byBzcGVjaWZpYyBwb3NpdGlvbiBpbiBidWZmZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGF0dHJpYk9mZnNldCBPZmZzZXQgb2YgYW4gYXR0cmlidXRlIGluIHdvcmRzICg0IGJ5dGVzKSwgZ2V0IGl0IGZyb20gQnVmZmVyUmV3cml0ZXIjX2dldEF0dHJpYk9mZnNldCgpLlxyXG4gICAgICogQHBhcmFtIHZhbHVlIFZhbHVlIHRvIGJlIHdyaXR0ZW4uXHJcbiAgICAgKi9cclxuICAgIHdyaXRlRmxvYXQzMihhdHRyaWJPZmZzZXQsIHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fdmVydGV4QnVmZmVyRmxvYXQzMlZpZXdbdGhpcy52ZXJ0ZXhPZmZzZXQgKyBhdHRyaWJPZmZzZXRdID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIHdvcmQgYXR0cmlidXRlIGludG8gc3BlY2lmaWMgcG9zaXRpb24gaW4gYnVmZmVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhdHRyaWJPZmZzZXQgT2Zmc2V0IG9mIGFuIGF0dHJpYnV0ZSBpbiB3b3JkcyAoNCBieXRlcyksIGdldCBpdCBmcm9tIEJ1ZmZlclJld3JpdGVyI19nZXRBdHRyaWJPZmZzZXQoKS5cclxuICAgICAqIEBwYXJhbSB2YWx1ZSBWYWx1ZSB0byBiZSB3cml0dGVuLlxyXG4gICAgICovXHJcbiAgICB3cml0ZVdvcmQoYXR0cmliT2Zmc2V0LCB2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX3ZlcnRleEJ1ZmZlclt0aGlzLnZlcnRleE9mZnNldCArIGF0dHJpYk9mZnNldF0gPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIHR3byBoYWxmIHdvcmQgYXR0cmlidXRlIHZhbHVlcyBpbnRvIHNwZWNpZmljIHBvc2l0aW9uIGluIGJ1ZmZlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYXR0cmliT2Zmc2V0IE9mZnNldCBvZiBhbiBhdHRyaWJ1dGUgaW4gd29yZHMgKDQgYnl0ZXMpLCBnZXQgaXQgZnJvbSBCdWZmZXJSZXdyaXRlciNfZ2V0QXR0cmliT2Zmc2V0KCkuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgVmFsdWUgdG8gYmUgd3JpdHRlbi5cclxuICAgICAqL1xyXG4gICAgd3JpdGVIYWxmV29yZHMoYXR0cmliT2Zmc2V0LCB2MSwgdjIpIHtcclxuICAgICAgICB0aGlzLndyaXRlV29yZChhdHRyaWJPZmZzZXQsIHYyIDw8IDE2IHwgdjEgJiAweGZmZmYpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBQcm92aWRlcyBzb21lIHV0aWxzIGZvciByZXdyaXRpbmcgdmVydGV4IGF0dHJpYnV0ZSB2YWx1ZXMsIHNlZSBWZXJ0ZXhXcml0ZXIgYW5kIHRlc3RzIGZvciBzb21lIHRpcHMgb2YgaG93IHRvIGRvIGl0LlxyXG4gKiBUT0RPOiBjb25zaWRlciBzdXBwb3J0aW5nIG9mIHNlcGFyYXRlIGJ1ZmZlcnMgZm9yIGRpZmZlcmVudCBhdHRyaWJ1dGVzLCB0aGF0IHdpbGwgbWFrZSB0aGlzIGNsYXNzIGxlc3MgdXNlZnVsXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCdWZmZXJSZXdyaXRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihhdHRyaWJNYXBwaW5nLCBidWZmZXJzKSB7XHJcbiAgICAgICAgdGhpcy5fYXR0cmliTWFwcGluZyA9IGF0dHJpYk1hcHBpbmc7XHJcbiAgICAgICAgdGhpcy5fYnVmZmVycyA9IGJ1ZmZlcnM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdhbGtzIG92ZXIgYWxsIHZlcnRpY2VzIGV4cG9zaW5nIFZlcnRleFdyaXRlciBmb3IgZWFjaCBvbmUgYnkgY2FsbGluZyB0aGUgaGFuZGxlciBhcmd1bWVudC5cclxuICAgICAqL1xyXG4gICAgX2ZvckVhY2hWZXJ0ZXgobG9jYXRpb24sIGhhbmRsZXIpIHtcclxuICAgICAgICBjb25zdCB2ZXJ0ZXhXcml0ZXIgPSBuZXcgVmVydGV4V3JpdGVyKHRoaXMuX2J1ZmZlcnNbbG9jYXRpb24uYnVmZmVySW5kZXhdLnZlcnRleEJ1ZmZlcik7XHJcbiAgICAgICAgY29uc3QgdmVydGV4Qnl0ZVNpemUgPSB0aGlzLl9hdHRyaWJNYXBwaW5nLnZlcnRleEJ5dGVTaXplO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jYXRpb24udmVydGV4Qnl0ZUxlbmd0aDsgaSArPSB2ZXJ0ZXhCeXRlU2l6ZSkge1xyXG4gICAgICAgICAgICB2ZXJ0ZXhXcml0ZXIudmVydGV4T2Zmc2V0ID0gKGxvY2F0aW9uLnZlcnRleEJ5dGVPZmZzZXQgKyBpKSAvIFdPUkRfQllURV9TSVpFO1xyXG4gICAgICAgICAgICBoYW5kbGVyKHZlcnRleFdyaXRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBPZmZzZXQgaW4gd29yZHMgKDQgYnl0ZXMpIG9mIHNwZWNpZmljIGF0dHJpYnV0ZSBpbiBhIHZlcnRleCAoZm9ybWF0IGlzIGRlZmluZWQgYnkgQXR0cmlidXRlTWFwcGluZykuXHJcbiAgICAgKi9cclxuICAgIF9nZXRBdHRyaWJPZmZzZXQoYXR0cmliKSB7XHJcbiAgICAgICAgY29uc3QgYXR0cmliUG9pbnRlciA9IHRoaXMuX2F0dHJpYk1hcHBpbmcuZ2V0KGF0dHJpYik7XHJcbiAgICAgICAgcmV0dXJuIGF0dHJpYlBvaW50ZXIgPyBhdHRyaWJQb2ludGVyLm9mZnNldCAvIFdPUkRfQllURV9TSVpFIDogLTE7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9idWZmZXJfcmV3cml0ZXIudHNcbi8vIG1vZHVsZSBpZCA9IDg0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IEF0dHJpYnV0ZU1hcHBpbmcgfSBmcm9tICcuLi8uLi9yZW5kZXIvYXR0cmliX21hcHBpbmcnO1xyXG4vKiogRGVzY3JpcHRpb24gb2YgaG93IGEgd3JpdGVyIHN0b3JlcyB2ZXJ0ZXggZGF0YS4gKi9cclxuZXhwb3J0IGNvbnN0IEJJTExCT0FSRF9SRUNUQU5HTEVfQVRUUklCVVRFX01BUFBJTkcgPSBuZXcgQXR0cmlidXRlTWFwcGluZyhbXHJcbiAgICBbXHJcbiAgICAgICAgMiAvKiBJRCAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDQsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjEgLyogVU5TSUdORURfQllURSAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgMCAvKiBQT1NJVElPTl9ISUdIICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMixcclxuICAgICAgICAgICAgdHlwZTogNTEyMyAvKiBVTlNJR05FRF9TSE9SVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgMSAvKiBQT1NJVElPTl9MT1cgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIzIC8qIFVOU0lHTkVEX1NIT1JUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICA2IC8qIERJU1BMQUNFTUVOVCAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDIsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjYgLyogRkxPQVQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICA0IC8qIFVWICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMixcclxuICAgICAgICAgICAgdHlwZTogNTEyMiAvKiBTSE9SVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgNyAvKiBDT0xPUiAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDQsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjEgLyogVU5TSUdORURfQllURSAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgMTEgLyogQVVYICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMixcclxuICAgICAgICAgICAgdHlwZTogNTEyMyAvKiBVTlNJR05FRF9TSE9SVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF1cclxuXSk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3ByaW1pdGl2ZS9iaWxsYm9hcmRfcmVjdGFuZ2xlL2F0dHJpYnV0ZV9tYXBwaW5nLnRzXG4vLyBtb2R1bGUgaWQgPSA4NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBBdHRyaWJ1dGVNYXBwaW5nIH0gZnJvbSAnLi4vLi4vcmVuZGVyL2F0dHJpYl9tYXBwaW5nJztcclxuLyoqIERlc2NyaXB0aW9uIG9mIGhvdyBhIHdyaXRlciBzdG9yZXMgdmVydGV4IGRhdGEuICovXHJcbmV4cG9ydCBjb25zdCBQT0lOVF9MQUJFTF9BVFRSSUJVVEVfTUFQUElORyA9IG5ldyBBdHRyaWJ1dGVNYXBwaW5nKFtcclxuICAgIFtcclxuICAgICAgICAyIC8qIElEICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogNCxcclxuICAgICAgICAgICAgdHlwZTogNTEyMSAvKiBVTlNJR05FRF9CWVRFICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICAwIC8qIFBPU0lUSU9OX0hJR0ggKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIzIC8qIFVOU0lHTkVEX1NIT1JUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICAxIC8qIFBPU0lUSU9OX0xPVyAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDIsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjMgLyogVU5TSUdORURfU0hPUlQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDYgLyogRElTUExBQ0VNRU5UICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMixcclxuICAgICAgICAgICAgdHlwZTogNTEyNiAvKiBGTE9BVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDQgLyogVVYgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIzIC8qIFVOU0lHTkVEX1NIT1JUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgNyAvKiBDT0xPUiAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDQsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjEgLyogVU5TSUdORURfQllURSAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgOCAvKiBPVVRMSU5FX0NPTE9SICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogNCxcclxuICAgICAgICAgICAgdHlwZTogNTEyMSAvKiBVTlNJR05FRF9CWVRFICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICA5IC8qIFBSSU9SSVRZICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMSxcclxuICAgICAgICAgICAgdHlwZTogNTEyNiAvKiBGTE9BVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDExIC8qIEFVWCAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDEsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjYgLyogRkxPQVQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgXVxyXG5dKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL2xhYmVsL3BvaW50X2xhYmVsX2F0dHJpYnV0ZV9tYXBwaW5nLnRzXG4vLyBtb2R1bGUgaWQgPSA4NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBBdHRyaWJ1dGVNYXBwaW5nIH0gZnJvbSAnLi4vLi4vcmVuZGVyL2F0dHJpYl9tYXBwaW5nJztcclxuLyoqIERlc2NyaXB0aW9uIG9mIGhvdyBhIHdyaXRlciBzdG9yZXMgdmVydGV4IGRhdGEuICovXHJcbmV4cG9ydCBjb25zdCBDVVJWRURfTEFCRUxfQVRUUklCVVRFX01BUFBJTkcgPSBuZXcgQXR0cmlidXRlTWFwcGluZyhbXHJcbiAgICBbXHJcbiAgICAgICAgMiAvKiBJRCAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDQsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjEgLyogVU5TSUdORURfQllURSAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgMCAvKiBQT1NJVElPTl9ISUdIICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMixcclxuICAgICAgICAgICAgdHlwZTogNTEyMyAvKiBVTlNJR05FRF9TSE9SVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgMSAvKiBQT1NJVElPTl9MT1cgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIzIC8qIFVOU0lHTkVEX1NIT1JUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICA2IC8qIERJU1BMQUNFTUVOVCAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDMsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjYgLyogRkxPQVQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICA0IC8qIFVWICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMixcclxuICAgICAgICAgICAgdHlwZTogNTEyMyAvKiBVTlNJR05FRF9TSE9SVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDcgLyogQ09MT1IgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiA0LFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIxIC8qIFVOU0lHTkVEX0JZVEUgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDggLyogT1VUTElORV9DT0xPUiAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDQsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjEgLyogVU5TSUdORURfQllURSAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgOSAvKiBQUklPUklUWSAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDEsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjYgLyogRkxPQVQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICAxMiAvKiBBVVgxICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogNCxcclxuICAgICAgICAgICAgdHlwZTogNTEyMSAvKiBVTlNJR05FRF9CWVRFICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICAxMyAvKiBBVVgyICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogNCxcclxuICAgICAgICAgICAgdHlwZTogNTEyMyAvKiBVTlNJR05FRF9TSE9SVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgMTQgLyogQVVYMyAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDQsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjEgLyogVU5TSUdORURfQllURSAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgMTUgLyogQVVYNCAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDQsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjMgLyogVU5TSUdORURfU0hPUlQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDExIC8qIEFVWCAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDIsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjYgLyogRkxPQVQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgXVxyXG5dKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL2xhYmVsL2N1cnZlZF9sYWJlbF9hdHRyaWJ1dGVfbWFwcGluZy50c1xuLy8gbW9kdWxlIGlkID0gODdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgV2ViV29ya2VyQ2xpZW50IH0gZnJvbSAnLi4vLi4vLi4vdXRpbC93b3JrZXInO1xyXG5leHBvcnQgY2xhc3MgVGlsZVByb3ZpZGVyV29ya2VyQ2xpZW50IGV4dGVuZHMgV2ViV29ya2VyQ2xpZW50IHtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9hZGFwdGVycy92ZWN0b3JfYXBpL3dvcmtlci90aWxlX3Byb3ZpZGVyX3dvcmtlcl9jbGllbnQudHNcbi8vIG1vZHVsZSBpZCA9IDg4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiBFeHRyYWN0IEFycmF5QnVmZmVycyAodGhhdCBhcmUgdGFuc2ZlcmFibGUpIGZyb20gcGFnZXMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFRyYW5zZmVyYWJsZXMocGFnZXMsIG91dHB1dCkge1xyXG4gICAgZm9yIChjb25zdCBwYWdlIG9mIHBhZ2VzKSB7XHJcbiAgICAgICAgb3V0cHV0LnB1c2gocGFnZS52ZXJ0ZXhCdWZmZXIuYnVmZmVyLCBwYWdlLmluZGV4QnVmZmVyLmJ1ZmZlcik7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdmVjdG9yX2FwaS93b3JrZXIvcHJpbWl0aXZlX3Byb3ZpZGVyX3dvcmtlcl9tZXNzYWdlcy50c1xuLy8gbW9kdWxlIGlkID0gODlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgQXR0cmlidXRlTWFwcGluZyB9IGZyb20gJy4uLy4uL3JlbmRlci9hdHRyaWJfbWFwcGluZyc7XHJcbmltcG9ydCB7IFBPTFlHT05fQVRUUklCVVRFX01BUFBJTkcgfSBmcm9tICcuL3BvbHlnb25fYXR0cmlidXRlX21hcHBpbmcnO1xyXG4vKipcclxuICogRGVzY3JpcHRpb24gb2YgaG93IGF0dHJpYnV0ZXMgb2YgdmVydGljZXMgYXJlIHBhY2tlZCBpbnRvIGEgdmVydGV4IGJ1ZmZlci5cclxuICovXHJcbmV4cG9ydCBjb25zdCBUUkFOU1BBUkVOVF9QT0xZR09OX0FUVFJJQlVURV9NQVBQSU5HID0gbmV3IEF0dHJpYnV0ZU1hcHBpbmcoUE9MWUdPTl9BVFRSSUJVVEVfTUFQUElORyk7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3ByaW1pdGl2ZS9wb2x5Z29uL3RyYW5zcGFyZW50X3BvbHlnb25fYXR0cmlidXRlX21hcHBpbmcudHNcbi8vIG1vZHVsZSBpZCA9IDkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBQcmlvcml0eVF1ZXVlIGZyb20gJy4vcHJpb3JpdHlfcXVldWUnO1xyXG5jb25zdCBNQVhfREVRVUVVRV9USU1FT1VUID0gMTAwMDsgLy8gbXNcclxuLy8gVE9ETzogcmVtb3ZlIHRoaXMgc2hpbSB3aGVuIGFsbCBzdXBwb3J0ZWQgYnJvd3NlcnMgaW1wbGVtZW50IGl0XHJcbmNvbnN0IFNISU1NRURfUFJPQ0VTU0lOR19EVVJBVElPTl9NUyA9IDI1O1xyXG53aW5kb3cuY2FuY2VsSWRsZUNhbGxiYWNrID0gd2luZG93LmNhbmNlbElkbGVDYWxsYmFjayB8fCB3aW5kb3cuY2xlYXJUaW1lb3V0O1xyXG53aW5kb3cucmVxdWVzdElkbGVDYWxsYmFjayA9IHdpbmRvdy5yZXF1ZXN0SWRsZUNhbGxiYWNrIHx8IGZ1bmN0aW9uIChoYW5kbGVyKSB7XHJcbiAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgIHJldHVybiBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICBoYW5kbGVyKHtcclxuICAgICAgICAgICAgZGlkVGltZW91dDogZmFsc2UsXHJcbiAgICAgICAgICAgIHRpbWVSZW1haW5pbmc6ICgpID0+IE1hdGgubWF4KDAsIFNISU1NRURfUFJPQ0VTU0lOR19EVVJBVElPTl9NUyAtIChwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZSkpXHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufTtcclxuLyoqXHJcbiAqIEl0IGlzIGEgdGFzayBxdWV1ZS4gVGFza3MgYXJlIGRlcXVldWVkIGR1cmluZyBpZGxlIHBlcmlvZC5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElkbGVUYXNrUXVldWUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5fcXVldWUgPSBuZXcgUHJpb3JpdHlRdWV1ZSgpO1xyXG4gICAgICAgIHRoaXMuX2RlcXVldWVJZGxlSGFuZGxlID0gMDtcclxuICAgIH1cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgY2FuY2VsSWRsZUNhbGxiYWNrKHRoaXMuX2RlcXVldWVJZGxlSGFuZGxlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRW5xdWV1ZXMgYSB0YXNrIHRvIHRoZSBxdWV1ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdGFzayBUaGUgdGFzay5cclxuICAgICAqL1xyXG4gICAgZW5xdWV1ZSh0YXNrKSB7XHJcbiAgICAgICAgdGhpcy5fcXVldWUuZW5xdWV1ZSh0YXNrKTtcclxuICAgICAgICB0aGlzLl9ydW4oKTtcclxuICAgIH1cclxuICAgIF9kZXF1ZXVlKGRlYWRsaW5lKSB7XHJcbiAgICAgICAgY29uc3QgcXVldWUgPSB0aGlzLl9xdWV1ZTtcclxuICAgICAgICBpZiAocXVldWUuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRlYWRsaW5lLmRpZFRpbWVvdXQpIHtcclxuICAgICAgICAgICAgcXVldWUuZGVxdWV1ZSgpLmV4ZWN1dGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHdoaWxlIChkZWFkbGluZS50aW1lUmVtYWluaW5nKCkgJiYgIXF1ZXVlLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICAgICAgcXVldWUuZGVxdWV1ZSgpLmV4ZWN1dGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9kZXF1ZXVlSWRsZUhhbmRsZSA9IDA7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9xdWV1ZS5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgdGhpcy5fcnVuKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3J1bigpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2RlcXVldWVJZGxlSGFuZGxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RlcXVldWVJZGxlSGFuZGxlID0gcmVxdWVzdElkbGVDYWxsYmFjaygoZGVhZGxpbmUpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2RlcXVldWUoZGVhZGxpbmUpO1xyXG4gICAgICAgICAgICB9LCB7IHRpbWVvdXQ6IE1BWF9ERVFVRVVFX1RJTUVPVVQgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvaWRsZV90YXNrX3F1ZXVlLnRzXG4vLyBtb2R1bGUgaWQgPSA5MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBzd2FwIH0gZnJvbSAnLi9hcnJheSc7XHJcbmltcG9ydCB7IERFRkFVTFRfQ09NUEFSQVRPUiB9IGZyb20gJy4vY29tcGFyYXRvcic7XHJcbi8qKlxyXG4gKiBDb21wdXRlcyBpbmRleCBvZiB0aGUgcGFyZW50IG9mIGFuIGl0ZW0uXHJcbiAqXHJcbiAqIEBwYXJhbSBpZHggSW5kZXggb2YgdGhlIGl0ZW0uXHJcbiAqIEByZXR1cm5zIEluZGV4IG9mIHRoZSBwYXJlbnQuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRQYXJlbnRJZHgoaWR4KSB7XHJcbiAgICByZXR1cm4gKGlkeCArIDEgPj4gMSkgLSAxO1xyXG59XHJcbi8qKlxyXG4gKiBDb21wdXRlcyBpbmRleCBvZiB0aGUgbGVmdCBjaGlsZCBvZiBhbiBpdGVtLlxyXG4gKlxyXG4gKiBAcGFyYW0gaWR4IEluZGV4IG9mIHRoZSBpdGVtLlxyXG4gKiBAcmV0dXJucyBJbmRleCBvZiB0aGUgY2hpbGQuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRGaXJzdENoaWxkSWR4KGlkeCkge1xyXG4gICAgcmV0dXJuIChpZHggKyAxIDw8IDEpIC0gMTtcclxufVxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCaW5hcnlIZWFwIHtcclxuICAgIC8qKlxyXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBlbXB0eSBoZWFwLiBPcmRlciBvZiBpdGVtcyBpbiB0aGUgaGVhcCB3aWxsIGJlIGRlZmluZWRcclxuICAgICAqIGJ5IGEgZ2l2ZW4gY29tcGFyYXRvci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY29tcGFyYXRvciBUaGUgY29tcGFyYXRvci5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoY29tcGFyYXRvciA9IERFRkFVTFRfQ09NUEFSQVRPUikge1xyXG4gICAgICAgIC8vIFRPRE8oZG1pa2lzKSBJbnZlc3RpZ2F0ZSBwcmVhbGxvY2F0aW9uLlxyXG4gICAgICAgIHRoaXMuX2l0ZW1zID0gW107XHJcbiAgICAgICAgdGhpcy5fY29tcGFyYXRvciA9IGNvbXBhcmF0b3I7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEluc2VydHMgYW4gaXRlbSBpbnRvIHRoZSBoZWFwLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpdGVtIFRoZSBpdGVtIHRvIGJlIGluc2VydGVkLlxyXG4gICAgICovXHJcbiAgICBpbnNlcnQoaXRlbSkge1xyXG4gICAgICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5faXRlbXM7XHJcbiAgICAgICAgY29uc3QgY29tcGFyYXRvciA9IHRoaXMuX2NvbXBhcmF0b3I7XHJcbiAgICAgICAgLy8gSW5zZXJ0IHRoZSBuZXcgaXRlbSBhcyBib3R0b20gcmlnaHQtbW9zdCBjaGlsZCBvZiB0aGUgaGVhcC5cclxuICAgICAgICBsZXQgaWR4ID0gaXRlbXMucHVzaChpdGVtKSAtIDE7XHJcbiAgICAgICAgbGV0IHBhcmVudElkeCA9IGdldFBhcmVudElkeChpZHgpO1xyXG4gICAgICAgIC8vIFdhbGsgdGhlIGhlYXAgdXB3YXJkIGFuZCByZXN0b3JlIGhlYXAgcHJvcGVydHkgb24gdGhlIHdheS5cclxuICAgICAgICB3aGlsZSAocGFyZW50SWR4ID4gLTEgJiZcclxuICAgICAgICAgICAgY29tcGFyYXRvcihpdGVtc1tpZHhdLCBpdGVtc1twYXJlbnRJZHhdKSA+IDApIHtcclxuICAgICAgICAgICAgc3dhcChpdGVtcywgaWR4LCBwYXJlbnRJZHgpO1xyXG4gICAgICAgICAgICBpZHggPSBwYXJlbnRJZHg7XHJcbiAgICAgICAgICAgIHBhcmVudElkeCA9IGdldFBhcmVudElkeChpZHgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBcIm1heGltdW1cIiBpdGVtIGZyb20gdGhlIGhlYWQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVGhlIHJlbW92ZWQgaXRlbSBvciBgdW5kZWZpbmVkYCBpcyB0aGUgaGVhcCdzIGVtcHR5LlxyXG4gICAgICovXHJcbiAgICBwb3AoKSB7XHJcbiAgICAgICAgY29uc3QgaXRlbXMgPSB0aGlzLl9pdGVtcztcclxuICAgICAgICBpZiAoaXRlbXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG5ld1NpemUgPSBpdGVtcy5sZW5ndGggLSAxO1xyXG4gICAgICAgIC8vIFBsYWNlIG1heCBpdGVtIGF0IHRoZSBlbmQgb2YgdGhlIGl0ZW1zIGFycmF5LlxyXG4gICAgICAgIHN3YXAoaXRlbXMsIDAsIG5ld1NpemUpO1xyXG4gICAgICAgIC8vIFdhbGsgZG93bndhcmQgZnJvbSB0aGUgbmV3IHJvb3QgdG8gcmVzdG9yZSBoZWFwIHByb3BlcnR5LlxyXG4gICAgICAgIGxldCBpZHggPSAwO1xyXG4gICAgICAgIGxldCBjaGlsZElkeCA9IDE7XHJcbiAgICAgICAgY29uc3QgY29tcGFyYXRvciA9IHRoaXMuX2NvbXBhcmF0b3I7XHJcbiAgICAgICAgd2hpbGUgKGNoaWxkSWR4IDwgbmV3U2l6ZSkge1xyXG4gICAgICAgICAgICBpZiAoY2hpbGRJZHggKyAxIDwgbmV3U2l6ZSAmJlxyXG4gICAgICAgICAgICAgICAgY29tcGFyYXRvcihpdGVtc1tjaGlsZElkeF0sIGl0ZW1zW2NoaWxkSWR4ICsgMV0pIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgY2hpbGRJZHggKz0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY29tcGFyYXRvcihpdGVtc1tpZHhdLCBpdGVtc1tjaGlsZElkeF0pID4gMCkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3dhcChpdGVtcywgaWR4LCBjaGlsZElkeCk7XHJcbiAgICAgICAgICAgIGlkeCA9IGNoaWxkSWR4O1xyXG4gICAgICAgICAgICBjaGlsZElkeCA9IGdldEZpcnN0Q2hpbGRJZHgoY2hpbGRJZHgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSZW1vdmUgcHJldmlvdXNseSBwbGFjZWQgYXQgdGhlIGVuZCBwcmV2aW91cyBtYXggaXRlbS5cclxuICAgICAgICByZXR1cm4gaXRlbXMucG9wKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFwiTWF4aW11bVwiIGl0ZW0gaW4gdGhlIGhlYXAgb3IgYHVuZGVmaW5lZGAgaWYgdGhlIGhlYWQgaXMgZW1wdHkuXHJcbiAgICAgKi9cclxuICAgIHBlZWsoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1zWzBdO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBJdGVyYXRvciBvdmVyIGFsbCBpdGVtcyBpbiB0aGUgaGVhcC4gTm90ZSB0aGF0IG9yZGVyIG9mIGl0ZW1zXHJcbiAgICAgKiAgICAgIGlzIHVuZGVmaW5lZC5cclxuICAgICAqL1xyXG4gICAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xyXG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLl9pdGVtcykge1xyXG4gICAgICAgICAgICB5aWVsZCBpdGVtO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgTnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBoZWFwLlxyXG4gICAgICovXHJcbiAgICBnZXQgc2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faXRlbXMubGVuZ3RoO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvYmluYXJ5X2hlYXAudHNcbi8vIG1vZHVsZSBpZCA9IDkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBSZW5kZXJhYmxlUHJpbWl0aXZlIGZyb20gJy4uL3JlbmRlcmFibGVfcHJpbWl0aXZlJztcclxuLyoqXHJcbiAqIEFsbG9jYXRlZCBpbiBHUFUgbWVtb3J5IHBvbHlnb24uXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW5kZXJhYmxlUG9seWdvbiBleHRlbmRzIFJlbmRlcmFibGVQcmltaXRpdmUge1xyXG4gICAgY29uc3RydWN0b3IobWVtb3J5U3ViQ2h1bmssIGlzT3BhcXVlKSB7XHJcbiAgICAgICAgc3VwZXIobWVtb3J5U3ViQ2h1bmspO1xyXG4gICAgICAgIHRoaXMuaXNPcGFxdWUgPSBpc09wYXF1ZTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9wcmltaXRpdmUvcG9seWdvbi9yZW5kZXJhYmxlX3BvbHlnb24udHNcbi8vIG1vZHVsZSBpZCA9IDkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBSZW5kZXJhYmxlUHJpbWl0aXZlIGZyb20gJy4uL3JlbmRlcmFibGVfcHJpbWl0aXZlJztcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVuZGVyYWJsZVRleHR1cmVkUG9seWdvbiBleHRlbmRzIFJlbmRlcmFibGVQcmltaXRpdmUge1xyXG4gICAgY29uc3RydWN0b3IobWVtb3J5Q2h1bmssIGFsbG9jYXRlZEltYWdlKSB7XHJcbiAgICAgICAgc3VwZXIobWVtb3J5Q2h1bmspO1xyXG4gICAgICAgIHRoaXMuX2FsbG9jYXRlZEltYWdlID0gYWxsb2NhdGVkSW1hZ2U7XHJcbiAgICAgICAgdGhpcy5hdGxhcyA9IGFsbG9jYXRlZEltYWdlLmF0bGFzTWFuYWdlci5hdGxhcztcclxuICAgICAgICBhbGxvY2F0ZWRJbWFnZS5yZXRhaW4oKTtcclxuICAgIH1cclxuICAgIF9kZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMuX2FsbG9jYXRlZEltYWdlLnJlbGVhc2UoKTtcclxuICAgICAgICBzdXBlci5fZGVzdHJveSgpO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3ByaW1pdGl2ZS9wb2x5Z29uL3JlbmRlcmFibGVfdGV4dHVyZWRfcG9seWdvbi50c1xuLy8gbW9kdWxlIGlkID0gOTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IFJlbmRlcmFibGVQb2x5bGluZSBmcm9tICcuL3JlbmRlcmFibGVfcG9seWxpbmUnO1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW5kZXJhYmxlVGV4dHVyZWRQb2x5bGluZSBleHRlbmRzIFJlbmRlcmFibGVQb2x5bGluZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihtZW1vcnlDaHVuaywgYWxsb2NhdGVkSW1hZ2UpIHtcclxuICAgICAgICBzdXBlcihtZW1vcnlDaHVuayk7XHJcbiAgICAgICAgdGhpcy5fYWxsb2NhdGVkSW1hZ2UgPSBhbGxvY2F0ZWRJbWFnZTtcclxuICAgICAgICB0aGlzLmF0bGFzID0gYWxsb2NhdGVkSW1hZ2UuYXRsYXNNYW5hZ2VyLmF0bGFzO1xyXG4gICAgICAgIGFsbG9jYXRlZEltYWdlLnJldGFpbigpO1xyXG4gICAgfVxyXG4gICAgX2Rlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5fYWxsb2NhdGVkSW1hZ2UucmVsZWFzZSgpO1xyXG4gICAgICAgIHN1cGVyLl9kZXN0cm95KCk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL3BvbHlsaW5lL3JlbmRlcmFibGVfdGV4dHVyZWRfcG9seWxpbmUudHNcbi8vIG1vZHVsZSBpZCA9IDk1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydCBjb25zdCBQT0xZR09OX0VYVFJBQ1RPUiA9IChkYXRhKSA9PiBmbGF0KG1hcCgncG9seWdvbnMnLCBkYXRhKSk7XHJcbmV4cG9ydCBjb25zdCBURVhUVVJFRF9QT0xZR09OX0VYVFJBQ1RPUiA9IChkYXRhKSA9PiBmbGF0KG1hcCgndGV4dHVyZWRQb2x5Z29ucycsIGRhdGEpKTtcclxuZXhwb3J0IGNvbnN0IFBPTFlMSU5FX0VYVFJBQ1RPUiA9IChkYXRhKSA9PiBmbGF0KG1hcCgncG9seWxpbmVzJywgZGF0YSkpO1xyXG5leHBvcnQgY29uc3QgVEVYVFVSRURfUE9MWUxJTkVfRVhUUkFDVE9SID0gKGRhdGEpID0+IGZsYXQobWFwKCd0ZXh0dXJlZFBvbHlsaW5lcycsIGRhdGEpKTtcclxuZXhwb3J0IGNvbnN0IFBPSU5UX0VYVFJBQ1RPUiA9IChkYXRhKSA9PiBmbGF0KG1hcCgncG9pbnRzJywgZGF0YSkpO1xyXG5leHBvcnQgY29uc3QgUE9JTlRfTEFCRUxfRVhUUkFDVE9SID0gKGRhdGEpID0+IGZsYXQobWFwKCdwb2ludExhYmVscycsIGRhdGEpKTtcclxuZXhwb3J0IGNvbnN0IENVUlZFRF9MQUJFTF9FWFRSQUNUT1IgPSAoZGF0YSkgPT4gZmxhdChtYXAoJ2N1cnZlZExhYmVscycsIGRhdGEpKTtcclxuZXhwb3J0IGNvbnN0IE1PREVMX0VYVFJBQ1RPUiA9IChkYXRhKSA9PiBmbGF0KG1hcCgnbW9kZWxzJywgZGF0YSkpO1xyXG5leHBvcnQgY29uc3QgRVhURVJOQUxfTUVTSF9FWFRSQUNUT1IgPSAoZGF0YSkgPT4gZmxhdChtYXAoJ2V4dGVybmFsTWVzaGVzJywgZGF0YSkpO1xyXG4vKipcclxuICogTWFwcyBsaXN0IG9mIFRpbGVEYXRhJ3MgaW50byBsaXN0IG9mIHNwZWNpZmllZCBwcmltaXRpdmVzLlxyXG4gKi9cclxuZnVuY3Rpb24qIG1hcCh0eXBlLCBkYXRhKSB7XHJcbiAgICBmb3IgKGNvbnN0IHBvcnRpb24gb2YgZGF0YSkge1xyXG4gICAgICAgIHlpZWxkIHBvcnRpb25bdHlwZV07XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEZsYXR0ZW4gdHdvIGRpbWVuc2lvbmFsIGxpc3Qgb2YgcHJpbWl0aXZlcyBpbiBhIHNpbmdsZSBkaW1lbnNpb25hbCBvbmUuXHJcbiAqL1xyXG5mdW5jdGlvbiogZmxhdChwcmltaXRpdmVzKSB7XHJcbiAgICBmb3IgKGNvbnN0IHBvcnRpb24gb2YgcHJpbWl0aXZlcykge1xyXG4gICAgICAgIGlmIChwb3J0aW9uKSB7XHJcbiAgICAgICAgICAgIHlpZWxkKiBwb3J0aW9uO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9hZGFwdGVycy92ZWN0b3JfYXBpL3RpbGVfZGF0YS50c1xuLy8gbW9kdWxlIGlkID0gOTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IFJlbmRlcmFibGVQcmltaXRpdmVNYW5hZ2VyIGZyb20gJy4vcmVuZGVyYWJsZV9wcmltaXRpdmVfbWFuYWdlcic7XHJcbi8qKlxyXG4gKiBQb2x5Z29ucyBzaG91bGQgYmUgc2VwYXJhdGVkIGJ5IG9wYXF1ZW5lc3MgYW5kIHRoZXJlIGFyZSB0d28gZGlzdGluY3QgcHJpbWl0aXZlIHByb3ZpZGVyc1xyXG4gKiBmb3IgdGhlbTogb3BhcXVlIGFuZCB0YW5zcGFyZW50LiBUaGF0IGlzIHdoYXQgdGhpcyBtYW5hZ2VyIHRha2VzIGNhcmUgb2YuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb2x5Z29uTWFuYWdlciBleHRlbmRzIFJlbmRlcmFibGVQcmltaXRpdmVNYW5hZ2VyIHtcclxuICAgIGNvbnN0cnVjdG9yKG9wYXF1ZVBvbHlnb25TdG9yYWdlLCB0cmFuc3BhcmVudFBvbHlnb25TdG9yYWdlKSB7XHJcbiAgICAgICAgc3VwZXIob3BhcXVlUG9seWdvblN0b3JhZ2UpO1xyXG4gICAgICAgIHRoaXMuX29wYXF1ZVBvbHlnb25TdG9yYWdlID0gb3BhcXVlUG9seWdvblN0b3JhZ2U7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNwYXJlbnRQb2x5Z29uU3RvcmFnZSA9IHRyYW5zcGFyZW50UG9seWdvblN0b3JhZ2U7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVTY2VuZSh0b1Nob3csIHRvSGlkZSkge1xyXG4gICAgICAgIGZvciAoY29uc3QgcHJpbWl0aXZlIG9mIHRvU2hvdykge1xyXG4gICAgICAgICAgICBpZiAocHJpbWl0aXZlLmlzT3BhcXVlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9vcGFxdWVQb2x5Z29uU3RvcmFnZS5hZGQocHJpbWl0aXZlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zcGFyZW50UG9seWdvblN0b3JhZ2UuYWRkKHByaW1pdGl2ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChjb25zdCBwcmltaXRpdmUgb2YgdG9IaWRlKSB7XHJcbiAgICAgICAgICAgIGlmIChwcmltaXRpdmUuaXNPcGFxdWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX29wYXF1ZVBvbHlnb25TdG9yYWdlLmRlbGV0ZShwcmltaXRpdmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNwYXJlbnRQb2x5Z29uU3RvcmFnZS5kZWxldGUocHJpbWl0aXZlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9hZGFwdGVycy92ZWN0b3JfYXBpL3ByaW1pdGl2ZV9tYW5hZ2VyL3BvbHlnb25fbWFuYWdlci50c1xuLy8gbW9kdWxlIGlkID0gOTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgZmlsdGVySXRlcmFibGUgfSBmcm9tICcuLi8uLi91dGlsL2l0ZXJhYmxlJztcclxuaW1wb3J0IERpc2FwcGVhcmluZ1ByaW1pdGl2ZVNldFN0b3JhZ2UgZnJvbSAnLi9kaXNhcHBlYXJpbmdfcHJpbWl0aXZlX3NldF9zdG9yYWdlJztcclxuLyoqXHJcbiAqIFByaW1pdGl2ZSBzdG9yYWdlIHRoYXQgc3RvcmVzIHByaW1pdGl2ZSBpbiBhIHNldC4gSXQgYWN0cyBhcyBhIHByaW1pdGl2ZSBwcm92aWRlciBhcyB3ZWxsLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGVsYXllZERpc2FwcGVhcmluZ1ByaW1pdGl2ZVNldFN0b3JhZ2UgZXh0ZW5kcyBEaXNhcHBlYXJpbmdQcmltaXRpdmVTZXRTdG9yYWdlIHtcclxuICAgIGNvbnN0cnVjdG9yKGFwcGVhcmluZ0VmZmVjdER1cmF0aW9uKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl9hcHBlYXJpbmdFZmZlY3REdXJhdGlvbiA9IGFwcGVhcmluZ0VmZmVjdER1cmF0aW9uO1xyXG4gICAgICAgIHRoaXMuX3NjaGVkdWxlZFJlbW92ZXMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5fdGltZW91dElkcyA9IG5ldyBTZXQoKTtcclxuICAgIH1cclxuICAgIGdldCBwcmltaXRpdmVzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wcmltaXRpdmVTZXQ7XHJcbiAgICB9XHJcbiAgICBhZGQoLi4ucHJpbWl0aXZlcykge1xyXG4gICAgICAgIC8vIHByaW1pdGl2ZXMgdGhhdCBhcmUgc2NoZWR1bGVkIGZvciByZW1vdmluZyB3YXMgbm90IHJlbW92ZWQgXCJwaHlzaWNhbGx5XCIsIHRoYXQgaXMgd2h5XHJcbiAgICAgICAgLy8gdGhleSBzaG91bGQgYmUgZmlsdGVyZWQgb3V0IHRvIHByZXZlbnQgbXVsdGlwbGUgYWRkaW5nIG9mIHRoZSBzYW1lIHByaW1pdGl2ZSBpbiBwYXJlbnRcclxuICAgICAgICBjb25zdCBub3RTY2hlZHVsZWRGb3JSZW1vdmVQcmltaXRpdmVzID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBwcmltaXRpdmUgb2YgcHJpbWl0aXZlcykge1xyXG4gICAgICAgICAgICBjb25zdCBwcmltaXRpdmVzVG9EZWxldGUgPSB0aGlzLl9zY2hlZHVsZWRSZW1vdmVzLmdldChwcmltaXRpdmUpO1xyXG4gICAgICAgICAgICBpZiAocHJpbWl0aXZlc1RvRGVsZXRlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIHByaW1pdGl2ZSBpcyBzY2hlZHVsZWQgZm9yIHJlbW92aW5nIGl0IGlzIGRlbGV0ZWQgZnJvbSBpdHMgYmF0Y2gsXHJcbiAgICAgICAgICAgICAgICAvLyB0aHVzIGNhbmNlbGluZyB0aGUgcmVtb3ZpbmcgaW4gdGhlIGNhbGxiYWNrXHJcbiAgICAgICAgICAgICAgICBwcmltaXRpdmVzVG9EZWxldGUuZGVsZXRlKHByaW1pdGl2ZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zY2hlZHVsZWRSZW1vdmVzLmRlbGV0ZShwcmltaXRpdmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbm90U2NoZWR1bGVkRm9yUmVtb3ZlUHJpbWl0aXZlcy5wdXNoKHByaW1pdGl2ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgc3VwZXIuYWRkKC4uLm5vdFNjaGVkdWxlZEZvclJlbW92ZVByaW1pdGl2ZXMpO1xyXG4gICAgICAgIHRoaXMuc2hvdyguLi5ub3RTY2hlZHVsZWRGb3JSZW1vdmVQcmltaXRpdmVzKTtcclxuICAgIH1cclxuICAgIGRlbGV0ZSguLi5wcmltaXRpdmVzKSB7XHJcbiAgICAgICAgdGhpcy5oaWRlKC4uLnByaW1pdGl2ZXMpO1xyXG4gICAgICAgIC8vIHByaW1pdGl2ZXMgYXJlIGJhdGNoZWQgaW4gYSBzZXQgdG8gYmUgZGVsZXRlZCBpbiBvbmUgc2V0VGltZW91dCBjYWxsYmFjayBmb3IgcGVyZm9ybWFuY2UsXHJcbiAgICAgICAgLy8gZmlsdGVyIG91dCBwcmltaXRpdmVzIHdoaWNoIHJlbW92aW5nIHdhcyBhbHJlYWR5IHNjaGVkdWxlZFxyXG4gICAgICAgIGNvbnN0IHByaW1pdGl2ZXNUb0RlbGV0ZSA9IG5ldyBTZXQoZmlsdGVySXRlcmFibGUocHJpbWl0aXZlcywgKHByaW1pdGl2ZSkgPT4gIXRoaXMuX3NjaGVkdWxlZFJlbW92ZXMuaGFzKHByaW1pdGl2ZSkpKTtcclxuICAgICAgICBpZiAocHJpbWl0aXZlc1RvRGVsZXRlLnNpemUgPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gcHJpbWl0aXZlc1RvRGVsZXRlIGNvbnRhaW5zIHJlbGV2YW50IGZvciByZW1vdmluZyBwcmltaXRpdmVzLCBpdCBjYW4gYmUgdXBkYXRlZCBpbiB0aGUgYWRkKCkgbWV0aG9kXHJcbiAgICAgICAgICAgICAgICAvLyBpZiBhIHByaW1pdGl2ZSBpcyBhZGRlZCBiYWNrLCB0aHVzLCBpbiBmYWN0LCBjYW5jZWxpbmcgcmVtb3Zpbmcgb2YgdGhpcyBzcGVjaWZpYyBwcmltaXRpdmVcclxuICAgICAgICAgICAgICAgIHN1cGVyLmRlbGV0ZSguLi5wcmltaXRpdmVzVG9EZWxldGUpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwcmltaXRpdmUgb2YgcHJpbWl0aXZlc1RvRGVsZXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2NoZWR1bGVkUmVtb3Zlcy5kZWxldGUocHJpbWl0aXZlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX3RpbWVvdXRJZHMuZGVsZXRlKHRpbWVvdXRJZCk7XHJcbiAgICAgICAgICAgIH0sIHRoaXMuX2FwcGVhcmluZ0VmZmVjdER1cmF0aW9uKTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBwcmltaXRpdmUgb2YgcHJpbWl0aXZlc1RvRGVsZXRlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zY2hlZHVsZWRSZW1vdmVzLnNldChwcmltaXRpdmUsIHByaW1pdGl2ZXNUb0RlbGV0ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fdGltZW91dElkcy5hZGQodGltZW91dElkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIGZvciAoY29uc3QgdGltZW91dElkIG9mIHRoaXMuX3RpbWVvdXRJZHMpIHtcclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2lzQWxsb3dlZFRvU2hvd1ByaW1pdGl2ZShwcmltaXRpdmUpIHtcclxuICAgICAgICByZXR1cm4gc3VwZXIuX2lzQWxsb3dlZFRvU2hvd1ByaW1pdGl2ZShwcmltaXRpdmUpICYmICF0aGlzLl9zY2hlZHVsZWRSZW1vdmVzLmhhcyhwcmltaXRpdmUpO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL2RlbGF5ZWRfZGlzYXBwZWFyaW5nX3ByaW1pdGl2ZV9zZXRfc3RvcmFnZS50c1xuLy8gbW9kdWxlIGlkID0gOThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IFJlbmRlcmFibGVQcmltaXRpdmVNYW5hZ2VyIGZyb20gJy4vcmVuZGVyYWJsZV9wcmltaXRpdmVfbWFuYWdlcic7XHJcbmltcG9ydCB7IG1hcEl0ZXJhYmxlLCBmaWx0ZXJJdGVyYWJsZSB9IGZyb20gJy4uLy4uLy4uL3V0aWwvaXRlcmFibGUnO1xyXG4vKipcclxuICogSXQgaXMgcmVxdWlyZWQgdG8gaGlkZSBzb21lIHByaW1pdGl2ZXMgKHRoYXQgZG9uJ3Qgc2NhbGUgd2l0aCB6b29tLCBlLmcuIGxhYmVscyBvciBpY29ucykgYnkgXCJ0b28gaXJyZWxldmFudFwiIHpvb20sXHJcbiAqIHRvIHByZXZlbnQgbWVzcyBvZiBjb2xsYXBzZWQgb2JqZWN0cyBvbiB0aGUgc2NyZWVuLiBUaGlzIHByaW1pdGl2ZSBtYW5hZ2VyIGlzIGEgdGVtcG9yYXJ5IHNvbHV0aW9uLFxyXG4gKiBwcm9wZXIgaGFuZGxpbmcgb2Ygem9vbSBzbGljZXMgd2lsbCByZXBsYWNlIGl0LlxyXG4gKi9cclxuLy8gVE9ETzogdGhpcyBtYW5hZ2VyIGlzIGEgdG1wIHNvbHV0aW9uLCBjb3JyZWN0IGhhbmRsaW5nIG9mIHpvb20gc2xpY2VzIGlzIGdvaW5nIHRvIHJlcGxhY2UgaXRcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgWm9vbUZpbHRlcmFibGVQcmltaXRpdmVNYW5hZ2VyIGV4dGVuZHMgUmVuZGVyYWJsZVByaW1pdGl2ZU1hbmFnZXIge1xyXG4gICAgY29uc3RydWN0b3IocHJpbWl0aXZlc1N0b3JhZ2UsIGNhbWVyYSkge1xyXG4gICAgICAgIHN1cGVyKHByaW1pdGl2ZXNTdG9yYWdlKTtcclxuICAgICAgICB0aGlzLl9kaXNhcHBlYXJpbmdQcmltaXRpdmVzU3RvcmFnZSA9IHByaW1pdGl2ZXNTdG9yYWdlO1xyXG4gICAgICAgIHRoaXMuX2NhbWVyYSA9IGNhbWVyYTtcclxuICAgICAgICB0aGlzLl9wcmltaXRpdmVzID0gbmV3IFNldCgpO1xyXG4gICAgICAgIHRoaXMuX3ByZXZab29tID0gY2FtZXJhLnpvb207XHJcbiAgICAgICAgdGhpcy5fem9vbVVwZGF0ZUxpc3RlbmVyID0gdGhpcy5fb25ab29tVXBkYXRlZC5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX2NhbWVyYS5vblVwZGF0ZS5hZGRMaXN0ZW5lcih0aGlzLl96b29tVXBkYXRlTGlzdGVuZXIpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlU2NlbmUodG9TaG93LCB0b0hpZGUpIHtcclxuICAgICAgICAvLyBzYXZlIHByaW1pdGl2ZXMgdG8gZmlsdGVyIHRoZW0gbGF0ZXJcclxuICAgICAgICBzdXBlci51cGRhdGVTY2VuZShtYXBJdGVyYWJsZSh0b1Nob3csIChwcmltaXRpdmUpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fcHJpbWl0aXZlcy5hZGQocHJpbWl0aXZlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHByaW1pdGl2ZTtcclxuICAgICAgICB9KSwgbWFwSXRlcmFibGUodG9IaWRlLCAocHJpbWl0aXZlKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX3ByaW1pdGl2ZXMuZGVsZXRlKHByaW1pdGl2ZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBwcmltaXRpdmU7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBhZGRlZCBwcmltaXRpdmVzIHRoYXQgY291bGQgYmUgcmVtb3ZlZCBieSB6b29tIHJlc3RyaWN0aW9uc1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZVpvb21WaXNpYmlsaXR5KCk7XHJcbiAgICB9XHJcbiAgICBfb25ab29tVXBkYXRlZCgpIHtcclxuICAgICAgICBpZiAodGhpcy5fcHJldlpvb20gIT09IHRoaXMuX2NhbWVyYS56b29tKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVpvb21WaXNpYmlsaXR5KCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3ByZXZab29tID0gdGhpcy5fY2FtZXJhLnpvb207XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3VwZGF0ZVpvb21WaXNpYmlsaXR5KCkge1xyXG4gICAgICAgIGNvbnN0IHpvb20gPSB0aGlzLl9jYW1lcmEuem9vbTtcclxuICAgICAgICB0aGlzLl9kaXNhcHBlYXJpbmdQcmltaXRpdmVzU3RvcmFnZS5zaG93KC4uLmZpbHRlckl0ZXJhYmxlKHRoaXMuX3ByaW1pdGl2ZXMsICh7IG1pblpvb20gfSkgPT4gem9vbSA+PSBtaW5ab29tKSk7XHJcbiAgICAgICAgdGhpcy5fZGlzYXBwZWFyaW5nUHJpbWl0aXZlc1N0b3JhZ2UuaGlkZSguLi5maWx0ZXJJdGVyYWJsZSh0aGlzLl9wcmltaXRpdmVzLCAoeyBtaW5ab29tIH0pID0+IHpvb20gPCBtaW5ab29tKSk7XHJcbiAgICB9XHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMuX2NhbWVyYS5vblVwZGF0ZS5yZW1vdmVMaXN0ZW5lcih0aGlzLl96b29tVXBkYXRlTGlzdGVuZXIpO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2FkYXB0ZXJzL3ZlY3Rvcl9hcGkvcHJpbWl0aXZlX21hbmFnZXIvem9vbV9maWx0ZXJhYmxlX3ByaW1pdGl2ZV9tYW5hZ2VyLnRzXG4vLyBtb2R1bGUgaWQgPSA5OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZSB9IGZyb20gJy4uL3dvcmtlci90aWxlX3Byb3ZpZGVyX3dvcmtlcl9tZXNzYWdlcyc7XHJcbmltcG9ydCBNZW1vcnlTdWJDaHVuayBmcm9tICcuLi8uLi8uLi9yZW5kZXIvbWVtb3J5L3N1Yl9jaHVuayc7XHJcbmltcG9ydCBNb2RlbEJ1ZmZlcldyaXRlciBmcm9tICcuLi8uLi8uLi9wcmltaXRpdmUvbW9kZWwvbW9kZWxfYnVmZmVyX3dyaXRlcic7XHJcbmltcG9ydCBQcmltaXRpdmVNYW5hZ2VyIGZyb20gJy4vcHJpbWl0aXZlX21hbmFnZXInO1xyXG5pbXBvcnQgUmVuZGVyYWJsZU1vZGVsIGZyb20gJy4uLy4uLy4uL3ByaW1pdGl2ZS9tb2RlbC9yZW5kZXJhYmxlX21vZGVsJztcclxuaW1wb3J0IHsgTk9fSUQgfSBmcm9tICcuLi8uLi8uLi91dGlsL3dvcmtlcic7XHJcbi8qKlxyXG4gKiBFeHRlcm5hbCBtZXNoZXMgY29tZSBpbiBwb2x5Z29ucyAoa2luZCBvZiBidWlsZGluZyBvdXRsaW5lcykuIFRoaXMgbWFuYWdlciBjb250cm9scyBxdWVyaW5nIGV4dGVybmFsIG1lc2hlc1xyXG4gKiBhY2NvcmRpbmcgdG8gYWRkZWQgcG9seWdvbnMsIGFzIG1hbnkgb2YgdGhlbSBjYW4gc2hhcmUgdGhlIHNhbWUgbWVzaCAodXN1YWxseSBhY3Jvc3MgbXVsdGlwbGUgdGlsZXMpLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXh0ZXJuYWxNZXNoUHJpbWl0aXZlTWFuYWdlciBleHRlbmRzIFByaW1pdGl2ZU1hbmFnZXIge1xyXG4gICAgY29uc3RydWN0b3IocHJpbWl0aXZlc1N0b3JhZ2UsIGdlb21ldHJ5UHJvdmlkZXIsIG1lbW9yeU1hbmFnZXIpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX3ByaW1pdGl2ZXNTdG9yYWdlID0gcHJpbWl0aXZlc1N0b3JhZ2U7XHJcbiAgICAgICAgdGhpcy5fdGlsZVByb3ZpZGVyID0gZ2VvbWV0cnlQcm92aWRlcjtcclxuICAgICAgICB0aGlzLl9tZW1vcnlNYW5hZ2VyID0gbWVtb3J5TWFuYWdlcjtcclxuICAgICAgICB0aGlzLl9leHRlcm5hbE1lc2hlcyA9IG5ldyBNYXAoKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZVNjZW5lKHRvU2hvdywgdG9IaWRlKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBwcmltaXRpdmUgb2YgdG9TaG93KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FkZFByaW1pdGl2ZShwcmltaXRpdmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IHByaW1pdGl2ZSBvZiB0b0hpZGUpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlUHJpbWl0aXZlKHByaW1pdGl2ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2FkZFByaW1pdGl2ZShwcmltaXRpdmUpIHtcclxuICAgICAgICBjb25zdCBpZCA9IGdldEZ1bGxNZXNoSWQocHJpbWl0aXZlKTtcclxuICAgICAgICBsZXQgZXh0ZXJuYWwgPSB0aGlzLl9leHRlcm5hbE1lc2hlcy5nZXQoaWQpO1xyXG4gICAgICAgIGlmICghZXh0ZXJuYWwpIHtcclxuICAgICAgICAgICAgZXh0ZXJuYWwgPSB7XHJcbiAgICAgICAgICAgICAgICB2aXNpYmxlUG9seWdvbnM6IG5ldyBTZXQoKSxcclxuICAgICAgICAgICAgICAgIGlzVmlzaWJsZTogZmFsc2VcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy5fZXh0ZXJuYWxNZXNoZXMuc2V0KGlkLCBleHRlcm5hbCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3RpbGVQcm92aWRlci5yZXF1ZXN0KHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFRpbGVQcm92aWRlck1lc3NhZ2VUeXBlLk1FU0hfUkVRVUVTVCxcclxuICAgICAgICAgICAgICAgIHJlc3BvbnNlVHlwZTogVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGUuTUVTSF9SRVNQT05TRSxcclxuICAgICAgICAgICAgICAgIGVycm9yVHlwZTogVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGUuTUVTSF9FUlJPUixcclxuICAgICAgICAgICAgICAgIG1lc2g6IHByaW1pdGl2ZSxcclxuICAgICAgICAgICAgICAgIHJlcXVlc3RJZDogTk9fSURcclxuICAgICAgICAgICAgfSkudGhlbigocmVzcG9uc2UpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGV4dGVybmFsID0gdGhpcy5fZXh0ZXJuYWxNZXNoZXMuZ2V0KGlkKTtcclxuICAgICAgICAgICAgICAgIGlmIChleHRlcm5hbCAmJiAhZXh0ZXJuYWwuaXNWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9jYXRpb24gPSByZXNwb25zZS5sb2NhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVua3MgPSByZXNwb25zZS5wYWdlcy5tYXAoKHBhZ2UpID0+IHRoaXMuX21lbW9yeU1hbmFnZXIuYWxsb2NhdGUocGFnZS52ZXJ0ZXhCdWZmZXIsIHBhZ2UuaW5kZXhCdWZmZXIsIE1vZGVsQnVmZmVyV3JpdGVyLkFUVFJJQlVURV9NQVBQSU5HKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXh0ZXJuYWwubWVzaCA9IG5ldyBSZW5kZXJhYmxlTW9kZWwobmV3IE1lbW9yeVN1YkNodW5rKGNodW5rc1tsb2NhdGlvbi5idWZmZXJJbmRleF0sIGxvY2F0aW9uKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXh0ZXJuYWwuaXNWaXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcmltaXRpdmVzU3RvcmFnZS5hZGQoZXh0ZXJuYWwubWVzaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtzLmZvckVhY2goKGNodW5rKSA9PiBjaHVuay5yZWxlYXNlKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZXh0ZXJuYWwudmlzaWJsZVBvbHlnb25zLmFkZChwcmltaXRpdmUpO1xyXG4gICAgfVxyXG4gICAgX3JlbW92ZVByaW1pdGl2ZShwcmltaXRpdmUpIHtcclxuICAgICAgICBjb25zdCBpZCA9IGdldEZ1bGxNZXNoSWQocHJpbWl0aXZlKTtcclxuICAgICAgICBjb25zdCBleHRlcm5hbCA9IHRoaXMuX2V4dGVybmFsTWVzaGVzLmdldChpZCk7XHJcbiAgICAgICAgaWYgKGV4dGVybmFsKSB7XHJcbiAgICAgICAgICAgIGV4dGVybmFsLnZpc2libGVQb2x5Z29ucy5kZWxldGUocHJpbWl0aXZlKTtcclxuICAgICAgICAgICAgLy8gZGVzdHJveSBleHRlcm5hbCBtZXNoIGlmIHRoZXJlIGlzIG5vIHZpc2libGUgcG9seWdvbnMgcmVtYWluaW5nXHJcbiAgICAgICAgICAgIGlmIChleHRlcm5hbC52aXNpYmxlUG9seWdvbnMuc2l6ZSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZXh0ZXJuYWxNZXNoZXMuZGVsZXRlKGlkKTtcclxuICAgICAgICAgICAgICAgIGlmIChleHRlcm5hbC5tZXNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXh0ZXJuYWwubWVzaC5yZWxlYXNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJpbWl0aXZlc1N0b3JhZ2UuZGVsZXRlKGV4dGVybmFsLm1lc2gpO1xyXG4gICAgICAgICAgICAgICAgICAgIGV4dGVybmFsLmlzVmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgbm8gbWVzaCB5ZXQgcmV0dXJuZWQgY2FuY2VsIHJlcXVlc3RcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90aWxlUHJvdmlkZXIuc2VuZE1lc3NhZ2Uoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZS5NRVNIX1JFUVVFU1RfQ0FOQ0VMLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNoOiBwcmltaXRpdmVcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBnZXRGdWxsTWVzaElkKG1lc2gpIHtcclxuICAgIHJldHVybiBtZXNoLm9iamVjdElkICsgbWVzaC5tZXNoSWQ7XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdmVjdG9yX2FwaS9wcmltaXRpdmVfbWFuYWdlci9leHRlcm5hbF9tZXNoX21hbmFnZXIudHNcbi8vIG1vZHVsZSBpZCA9IDEwMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgUmVuZGVyYWJsZVByaW1pdGl2ZSBmcm9tICcuLi9yZW5kZXJhYmxlX3ByaW1pdGl2ZSc7XHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbmRlcmFibGVCaWxsYm9hcmRSZWN0YW5nbGUgZXh0ZW5kcyBSZW5kZXJhYmxlUHJpbWl0aXZlIHtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9wcmltaXRpdmUvYmlsbGJvYXJkX3JlY3RhbmdsZS9yZW5kZXJhYmxlX2JpbGxib2FyZF9yZWN0YW5nbGUudHNcbi8vIG1vZHVsZSBpZCA9IDEwMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgUmVuZGVyYWJsZUxhYmVsIGZyb20gJy4uLy4uLy4uL3ByaW1pdGl2ZS9sYWJlbC9yZW5kZXJhYmxlX2xhYmVsJztcclxuZXhwb3J0IGNsYXNzIFpvb21SZXN0cmljdGVkTGFiZWwgZXh0ZW5kcyBSZW5kZXJhYmxlTGFiZWwge1xyXG4gICAgY29uc3RydWN0b3IobWVtb3J5U3ViQ2h1bmssIGF0bGFzLCBtaW5ab29tLCBiYWNrZ3JvdW5kKSB7XHJcbiAgICAgICAgc3VwZXIobWVtb3J5U3ViQ2h1bmssIGF0bGFzLCBiYWNrZ3JvdW5kKTtcclxuICAgICAgICB0aGlzLm1pblpvb20gPSBtaW5ab29tO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2FkYXB0ZXJzL3ZlY3Rvcl9hcGkvcHJpbWl0aXZlL3pvb21fcmVzdHJpY3RlZF9sYWJlbC50c1xuLy8gbW9kdWxlIGlkID0gMTAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBSZW5kZXJhYmxlUHJpbWl0aXZlIGZyb20gJy4uL3JlbmRlcmFibGVfcHJpbWl0aXZlJztcclxuLyoqXHJcbiAqIEFsbG9jYXRlZCBpbiBHUFUgbWVtb3J5IGxhYmVsLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVuZGVyYWJsZUxhYmVsIGV4dGVuZHMgUmVuZGVyYWJsZVByaW1pdGl2ZSB7XHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgcmVuZGVyYWJsZSBsYWJlbC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbWVtb3J5U3ViQ2h1bmtcclxuICAgICAqIEBwYXJhbSBhdGxhc1xyXG4gICAgICogQHBhcmFtIGJhY2tncm91bmRcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IobWVtb3J5U3ViQ2h1bmssIGF0bGFzLCBiYWNrZ3JvdW5kKSB7XHJcbiAgICAgICAgc3VwZXIobWVtb3J5U3ViQ2h1bmspO1xyXG4gICAgICAgIHRoaXMuYXRsYXMgPSBhdGxhcztcclxuICAgICAgICB0aGlzLmJhY2tncm91bmQgPSBiYWNrZ3JvdW5kO1xyXG4gICAgICAgIGlmIChiYWNrZ3JvdW5kKSB7XHJcbiAgICAgICAgICAgIGJhY2tncm91bmQucmV0YWluKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2Rlc3Ryb3koKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuYmFja2dyb3VuZCkge1xyXG4gICAgICAgICAgICB0aGlzLmJhY2tncm91bmQucmVsZWFzZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdXBlci5fZGVzdHJveSgpO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3ByaW1pdGl2ZS9sYWJlbC9yZW5kZXJhYmxlX2xhYmVsLnRzXG4vLyBtb2R1bGUgaWQgPSAxMDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IFJlbmRlcmFibGVJY29uIGZyb20gJy4uLy4uLy4uL3ByaW1pdGl2ZS9pY29uL3JlbmRlcmFibGVfaWNvbic7XHJcbmV4cG9ydCBjbGFzcyBab29tUmVzdHJpY3RlZEljb24gZXh0ZW5kcyBSZW5kZXJhYmxlSWNvbiB7XHJcbiAgICBjb25zdHJ1Y3RvcihtZW1vcnlTdWJDaHVuaywgYWxsb2NhdGVkSW1hZ2UsIG1pblpvb20pIHtcclxuICAgICAgICBzdXBlcihtZW1vcnlTdWJDaHVuaywgYWxsb2NhdGVkSW1hZ2UpO1xyXG4gICAgICAgIHRoaXMubWluWm9vbSA9IG1pblpvb207XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdmVjdG9yX2FwaS9wcmltaXRpdmUvem9vbV9yZXN0cmljdGVkX2ljb24udHNcbi8vIG1vZHVsZSBpZCA9IDEwNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgUmVuZGVyYWJsZUltYWdlIGZyb20gJy4uL2ltYWdlL3JlbmRlcmFibGVfaW1hZ2UnO1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW5kZXJhYmxlSWNvbiBleHRlbmRzIFJlbmRlcmFibGVJbWFnZSB7XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL2ljb24vcmVuZGVyYWJsZV9pY29uLnRzXG4vLyBtb2R1bGUgaWQgPSAxMDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IFRleHR1cmVkUmVuZGVyYWJsZVByaW1pdGl2ZSBmcm9tICcuLi90ZXh0dXJlZF9yZW5kZXJhYmxlX3ByaW1pdGl2ZSc7XHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbmRlcmFibGVJbWFnZSBleHRlbmRzIFRleHR1cmVkUmVuZGVyYWJsZVByaW1pdGl2ZSB7XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL2ltYWdlL3JlbmRlcmFibGVfaW1hZ2UudHNcbi8vIG1vZHVsZSBpZCA9IDEwNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgUmVuZGVyYWJsZVByaW1pdGl2ZSBmcm9tICcuL3JlbmRlcmFibGVfcHJpbWl0aXZlJztcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGV4dHVyZWRSZW5kZXJhYmxlUHJpbWl0aXZlIGV4dGVuZHMgUmVuZGVyYWJsZVByaW1pdGl2ZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihtZW1vcnlDaHVuaywgYWxsb2NhdGVkSW1hZ2UpIHtcclxuICAgICAgICBzdXBlcihtZW1vcnlDaHVuayk7XHJcbiAgICAgICAgdGhpcy5fYWxsb2NhdGVkSW1hZ2UgPSBhbGxvY2F0ZWRJbWFnZTtcclxuICAgICAgICB0aGlzLmF0bGFzID0gYWxsb2NhdGVkSW1hZ2UuYXRsYXNNYW5hZ2VyLmF0bGFzO1xyXG4gICAgICAgIHRoaXMuX2FsbG9jYXRlZEltYWdlLnJldGFpbigpO1xyXG4gICAgfVxyXG4gICAgX2Rlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5fYWxsb2NhdGVkSW1hZ2UucmVsZWFzZSgpO1xyXG4gICAgICAgIHN1cGVyLl9kZXN0cm95KCk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL3RleHR1cmVkX3JlbmRlcmFibGVfcHJpbWl0aXZlLnRzXG4vLyBtb2R1bGUgaWQgPSAxMDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IFByaW9yaXR5UWV1ZXVlIGZyb20gJy4vcHJpb3JpdHlfcXVldWUnO1xyXG5pbXBvcnQgeyBWb2lkRXZlbnRFbWl0dGVyIH0gZnJvbSAnLi4vdXRpbC9ldmVudF9lbWl0dGVyJztcclxuY29uc3QgREVRVUVVRV9USU1FT1VUID0gMTsgLy8gbXNcclxuLyoqXHJcbiAqIFByaW9yaXRpemVkIHRhc2sgcXVldWUuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUYXNrUXVldWUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb25zdHJ1Y3RzIGFuIGVtcHR5IHRhc2sgcXVldWUuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuX3F1ZXVlID0gbmV3IFByaW9yaXR5UWV1ZXVlKCk7XHJcbiAgICAgICAgdGhpcy5fZnJvemVuID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fZGVxdWV1ZVRpbWVvdXRIYW5kbGUgPSAwO1xyXG4gICAgICAgIHRoaXMub25FbXB0eSA9IG5ldyBWb2lkRXZlbnRFbWl0dGVyKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERlc3Ryb3lzIHRoZSBxdWV1ZS4gQW55IHJlbWFpbmluZyB0YXNrcyB3b24ndCBiZSBleGVjdXRlZC5cclxuICAgICAqL1xyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fZGVxdWV1ZVRpbWVvdXRIYW5kbGUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFbnF1ZXVlcyBhIHRhc2sgdG8gdGhlIHF1ZXVlIGFuZCBzY2hlZHVsZXMgcHJvY2Vzc2luZyBvZiB0aGUgcXVldWUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRhc2sgVGhlIHRhc2suXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHRoYXQgd2lsbCBiZSBmdWxsZmlsbGVkIHdoZW4gdGhlIHRhc2sgc3VjY2Vzc2Z1bGx5XHJcbiAgICAgKiAgICAgIGZpbmlzaGVzIG9yIHJlamVjdGVkIGlmIHRoZXJlJ3MgYW4gZXJyb3IuXHJcbiAgICAgKi9cclxuICAgIGVucXVldWUodGFzaykge1xyXG4gICAgICAgIGlmICghdGhpcy5fZnJvemVuKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldERlcXVldWVUaW1lb3V0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX3F1ZXVlLmVucXVldWUoe1xyXG4gICAgICAgICAgICAgICAgZXhlY3V0ZSgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrLmV4ZWN1dGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgcHJpb3JpdHk6IHRhc2sucHJpb3JpdHlcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpc0VtcHR5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9xdWV1ZS5pc0VtcHR5KCk7XHJcbiAgICB9XHJcbiAgICBmcmVlemUoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2RlcXVldWVUaW1lb3V0SGFuZGxlKSB7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9kZXF1ZXVlVGltZW91dEhhbmRsZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2RlcXVldWVUaW1lb3V0SGFuZGxlID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZnJvemVuID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHVuZnJlZXplKCkge1xyXG4gICAgICAgIHRoaXMuX2Zyb3plbiA9IGZhbHNlO1xyXG4gICAgICAgIGlmICghdGhpcy5fcXVldWUuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldERlcXVldWVUaW1lb3V0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2RlcXVldWUoKSB7XHJcbiAgICAgICAgY29uc3QgdGFzayA9IHRoaXMuX3F1ZXVlLmRlcXVldWUoKTtcclxuICAgICAgICBpZiAodGFzaykge1xyXG4gICAgICAgICAgICB0YXNrLmV4ZWN1dGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX3F1ZXVlLmlzRW1wdHkoKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9kZXF1ZXVlVGltZW91dEhhbmRsZSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMub25FbXB0eS5maXJlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9kZXF1ZXVlVGltZW91dEhhbmRsZSA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5fZGVxdWV1ZSgpLCBERVFVRVVFX1RJTUVPVVQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9zZXREZXF1ZXVlVGltZW91dCgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2RlcXVldWVUaW1lb3V0SGFuZGxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RlcXVldWVUaW1lb3V0SGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLl9kZXF1ZXVlKCksIERFUVVFVUVfVElNRU9VVCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvdGFza19xdWV1ZS50c1xuLy8gbW9kdWxlIGlkID0gMTA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IERlbGVnYXRvckJhc2UgfSBmcm9tICcuLi8uLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9kZWxlZ2F0b3InO1xyXG5pbXBvcnQgKiBhcyB2ZWMyIGZyb20gJy4uLy4uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9tYXRoL3ZlY3RvcjInO1xyXG5leHBvcnQgY2xhc3MgTW91c2VEcmFnQ29udHJvbGxlciBleHRlbmRzIERlbGVnYXRvckJhc2Uge1xyXG4gICAgY29uc3RydWN0b3IodGFyZ2V0KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgdGhpcy5fcHJlc3NlZEJ1dHRvbiA9IC0xIC8qIE5PTkUgKi87XHJcbiAgICAgICAgdGhpcy5fcHJldk1vdXNlQ29vcmRzID0gdmVjMi5jcmVhdGUoMCwgMCk7XHJcbiAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMpO1xyXG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMpO1xyXG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHRoaXMpO1xyXG4gICAgfVxyXG4gICAgaGFuZGxlRXZlbnQoZSkge1xyXG4gICAgICAgIHN3aXRjaCAoZS50eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ2NsaWNrJzpcclxuICAgICAgICAgICAgY2FzZSAnY29udGV4dG1lbnUnOlxyXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ21vdXNlZG93bic6XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcHJlc3NlZEJ1dHRvbiA9PT0gLTEgLyogTk9ORSAqLykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ByZXNzZWRCdXR0b24gPSBlLmJ1dHRvbjtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcmV2TW91c2VDb29yZHMueCA9IGUuY2xpZW50WDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcmV2TW91c2VDb29yZHMueSA9IGUuY2xpZW50WTtcclxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ21vdXNlbW92ZSc6XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZGVsZWdhdGUgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IG1vdXNlQ29vcmRzID0gdmVjMi5jcmVhdGUoZS5jbGllbnRYLCBlLmNsaWVudFkpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGVsdGEgPSB2ZWMyLnN1Yihtb3VzZUNvb3JkcywgdGhpcy5fcHJldk1vdXNlQ29vcmRzKTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fcHJlc3NlZEJ1dHRvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMCAvKiBMRUZUICovOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWxlZ2F0ZS5vbkxlZnRCdXR0b25EcmFnKGRlbHRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxIC8qIE1JRERMRSAqLzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVsZWdhdGUub25NaWRkbGVCdXR0b25EcmFnKGRlbHRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyIC8qIFJJR0hUICovOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWxlZ2F0ZS5vblJpZ2h0QnV0dG9uRHJhZyhkZWx0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmVjMi5jb3B5KG1vdXNlQ29vcmRzLCB0aGlzLl9wcmV2TW91c2VDb29yZHMpO1xyXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ21vdXNldXAnOlxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3ByZXNzZWRCdXR0b24gPT09IGUuYnV0dG9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcmVzc2VkQnV0dG9uID0gLTEgLyogTk9ORSAqLztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5fdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgdGhpcyk7XHJcbiAgICAgICAgdGhpcy5fdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcyk7XHJcbiAgICAgICAgdGhpcy5fdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBjbGFzcyBTY3JvbGxab29tQ29udHJvbGxlciBleHRlbmRzIERlbGVnYXRvckJhc2Uge1xyXG4gICAgY29uc3RydWN0b3IodGFyZ2V0KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3doZWVsJywgdGhpcyk7XHJcbiAgICB9XHJcbiAgICBoYW5kbGVFdmVudChlKSB7XHJcbiAgICAgICAgY29uc3QgZGVsZWdhdGUgPSB0aGlzLl9kZWxlZ2F0ZTtcclxuICAgICAgICBpZiAoIWRlbGVnYXRlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGUuZGVsdGFZIDwgMCkge1xyXG4gICAgICAgICAgICBkZWxlZ2F0ZS5vblNjcm9sbEluKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkZWxlZ2F0ZS5vblNjcm9sbE91dCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICB9XHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMuX3RhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCd3aGVlbCcsIHRoaXMpO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IFpPT01fU1RFUCA9IDAuMTtcclxuY29uc3QgVElMVF9BWklNVVRIX0ZBQ1RPUiA9IE1hdGguUEkgLyAxMDI0O1xyXG5leHBvcnQgY2xhc3MgQ2FtZXJhTW91c2VDb250cm9sbGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGNhbnZhcywgY2FtZXJhKSB7XHJcbiAgICAgICAgdGhpcy5fY2FtZXJhID0gY2FtZXJhO1xyXG4gICAgICAgIHRoaXMuX2NhbnZhc1NpemUgPSB2ZWMyLmNyZWF0ZShjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuZHJhZ0ZhY3RvciA9IDE7XHJcbiAgICB9XHJcbiAgICBvbkxlZnRCdXR0b25EcmFnKGRlbHRhKSB7XHJcbiAgICAgICAgLy8gVGhhdCdzIG5vdCBleGFjdCwgYnV0IGdvb2QgZW5vdWdoIGZvciBub3cuXHJcbiAgICAgICAgdmVjMi5kaXZ2KGRlbHRhLCB0aGlzLl9jYW52YXNTaXplLCBkZWx0YSk7XHJcbiAgICAgICAgY29uc3QgY2FtZXJhID0gdGhpcy5fY2FtZXJhO1xyXG4gICAgICAgIHZlYzIubXVsbihkZWx0YSwgdGhpcy5kcmFnRmFjdG9yICogY2FtZXJhLnNjcmVlblNpemUuaGVpZ2h0ICogTWF0aC5wb3coMiwgLWNhbWVyYS56b29tKSAvXHJcbiAgICAgICAgICAgIChNYXRoLnRhbigwLjUgKiBjYW1lcmEub3B0aW9ucy5mb3YpICogNjQpLCBkZWx0YSk7XHJcbiAgICAgICAgY29uc3QgY2VudGVyID0gdGhpcy5fY2FtZXJhLmNlbnRlcjtcclxuICAgICAgICBjZW50ZXIueCAtPSBkZWx0YS54O1xyXG4gICAgICAgIGNlbnRlci55ICs9IGRlbHRhLnk7XHJcbiAgICAgICAgdGhpcy5fY2FtZXJhLnNldERpcnR5KCk7XHJcbiAgICB9XHJcbiAgICBvbk1pZGRsZUJ1dHRvbkRyYWcoKSB7IH1cclxuICAgIG9uUmlnaHRCdXR0b25EcmFnKGRlbHRhKSB7XHJcbiAgICAgICAgY29uc3QgY2FtZXJhID0gdGhpcy5fY2FtZXJhO1xyXG4gICAgICAgIGNhbWVyYS50aWx0ICs9IGRlbHRhLnkgKiBUSUxUX0FaSU1VVEhfRkFDVE9SO1xyXG4gICAgICAgIGNhbWVyYS5hemltdXRoICs9IGRlbHRhLnggKiBUSUxUX0FaSU1VVEhfRkFDVE9SO1xyXG4gICAgICAgIHRoaXMuX2NhbWVyYS5zZXREaXJ0eSgpO1xyXG4gICAgfVxyXG4gICAgb25TY3JvbGxJbigpIHtcclxuICAgICAgICB0aGlzLl9jYW1lcmEuem9vbSArPSBaT09NX1NURVA7XHJcbiAgICAgICAgdGhpcy5fY2FtZXJhLnNldERpcnR5KCk7XHJcbiAgICB9XHJcbiAgICBvblNjcm9sbE91dCgpIHtcclxuICAgICAgICB0aGlzLl9jYW1lcmEuem9vbSAtPSBaT09NX1NURVA7XHJcbiAgICAgICAgdGhpcy5fY2FtZXJhLnNldERpcnR5KCk7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgY2FtZXJhU3RhdGVFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2NhbWVyYV9zdGF0ZScpO1xyXG5jb25zdCBjYW1lcmFTdGF0ZVRleHQgPSBjYW1lcmFTdGF0ZUVsZW1lbnQgJiYgY2FtZXJhU3RhdGVFbGVtZW50LmZpcnN0Q2hpbGQ7XHJcbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJDYW1lcmFTdGF0ZShjYW1lcmEpIHtcclxuICAgIGNvbnN0IHsgY2VudGVyOiB7IHgsIHkgfSwgem9vbSwgdGlsdCwgYXppbXV0aCB9ID0gY2FtZXJhO1xyXG4gICAgY2FtZXJhU3RhdGVUZXh0LnJlcGxhY2VEYXRhKDAsIGNhbWVyYVN0YXRlVGV4dC5sZW5ndGgsIGBjZW50ZXI6ICgke3gudG9GaXhlZCg4KX0sJHt5LnRvRml4ZWQoOCl9KTsgem9vbTogJHt6b29tLnRvRml4ZWQoNCl9OyBgICtcclxuICAgICAgICBgdGlsdDogJHt0aWx0LnRvRml4ZWQoNCl9OyBhemltdXRoOiAke2F6aW11dGgudG9GaXhlZCg0KX1gKTtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3Rvb2xzL3N0YW5kL2NhbWVyYV9zdHVmZi50c1xuLy8gbW9kdWxlIGlkID0gMTA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBwb2ludExhYmVsVmVydGV4U2hhZGVyIGZyb20gJy4vc2hhZGVyL3BvaW50X2xhYmVsLnZlcnQnO1xyXG5pbXBvcnQgY29sb3JJZEZyYWdtZW50U2hhZGVyIGZyb20gJy4vc2hhZGVyL2NvbG9yX2lkLmZyYWcnO1xyXG5pbXBvcnQgQ29sbGlkaW5nTGFiZWxDb2xvcklkUmVuZGVyZXIgZnJvbSAnLi9jb2xvcl9pZF9sYWJlbF9yZW5kZXJlcic7XHJcbmltcG9ydCB7IFBST0dSQU1fT1BUSU9OUyB9IGZyb20gJy4uLy4uLy4uL3JlbmRlci9wcmltaXRpdmVzL2xhYmVsL3BvaW50X2xhYmVsX3JlbmRlcl91bml0JztcclxuLyoqXHJcbiAqIFBvaW50IGxhYmVscyByZW5kZXJlciBmb3IgY29sbGlzaW9uIHJlc29sdXRpb24uXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb2xvcklkUG9pbnRMYWJlbFJlbmRlcmVyIGV4dGVuZHMgQ29sbGlkaW5nTGFiZWxDb2xvcklkUmVuZGVyZXIge1xyXG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgY2FtZXJhLCBwcmltaXRpdmVQcm92aWRlcikge1xyXG4gICAgICAgIGNvbnN0IHByb2dyYW0gPSBjb250ZXh0LmNyZWF0ZVByb2dyYW0ocG9pbnRMYWJlbFZlcnRleFNoYWRlciwgY29sb3JJZEZyYWdtZW50U2hhZGVyLCBQUk9HUkFNX09QVElPTlMpO1xyXG4gICAgICAgIHN1cGVyKGNvbnRleHQsIHByb2dyYW0sIHByaW1pdGl2ZVByb3ZpZGVyLCBjYW1lcmEpO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3Zpc2liaWxpdHkvcHJpbWl0aXZlcy9sYWJlbC9jb2xvcl9pZF9wb2ludF9sYWJlbF9yZW5kZXJlci50c1xuLy8gbW9kdWxlIGlkID0gMTEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleElkO1xcblxcbi8vIHBvaW50IGluIHRoZSB3b3JsZCB0aGUgbGFiZWwgaXMgYW5jaG9yZWQgdG9cXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhQb3NIaWdoO1xcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleFBvc0xvdztcXG5cXG4vLyB2ZWN0b3Igb2YgY29uY3JldGUgZ2x5cGggcG9pbnQgZGlzcGxhY2VtZW50ICh0b3AtbGVmdCwgYm90dG9tLWxlZnQsIC4uLikgcmVsYXRpdmUgdG8gbGFiZWwncyBjZW50ZXIsIGluIHB4XFxuYXR0cmlidXRlIHZlYzIgdmVydGV4RGlzcGxhY2VtZW50O1xcblxcbi8vIGNvb3JkaW5hdGVzIG9mIHRoZSBnbHlwaCB2ZXJ0ZXggaW4gdGhlIGF0bGFzXFxuYXR0cmlidXRlIHZlYzIgdmVydGV4VVY7XFxuXFxuYXR0cmlidXRlIGZsb2F0IHZlcnRleFByaW9yaXR5O1xcblxcbnVuaWZvcm0gdmVjMiBsb29rQXRIaWdoO1xcbnVuaWZvcm0gdmVjMiBsb29rQXRMb3c7XFxudW5pZm9ybSBtYXQ0IHZpZXdQcm9qTWF0cml4O1xcbnVuaWZvcm0gdmVjMiBwaXhlbFNpemU7XFxudW5pZm9ybSBzYW1wbGVyMkQgdmlzaWJpbGl0eTtcXG51bmlmb3JtIHZlYzIgaWRIYWxmUHhTaXplO1xcbnVuaWZvcm0gdmVjMiBzaGlmdDtcXG51bmlmb3JtIGxvd3AgZmxvYXQgY3VycmVudFpvb207XFxuXFxudmFyeWluZyB2ZWMyIHV2O1xcbnZhcnlpbmcgbG93cCB2ZWM0IGNvbG9yO1xcbnZhcnlpbmcgbG93cCB2ZWM0IG91dGxpbmVDb2xvcjtcXG52YXJ5aW5nIG1lZGl1bXAgZmxvYXQgc2NhbGU7XFxuXFxuY29uc3QgdmVjNCBESVNDQVJEX1BPU0lUSU9OID0gdmVjNCgyLCAyLCAyLCAxKTtcXG5cXG5jb25zdCBmbG9hdCBZVl9IXzFfMCA9IDEuOTk5OTY5NDgyNDIxODc1O1xcbmNvbnN0IGZsb2F0IFlWX0xfMV8xID0gMC4wMDAwMzA1MTcxMTI0NjM3MTI2OTI7XFxuXFxuLyoqXFxuICogUHJvamVjdHMgc3BlY2lmaWMgcG9pbnQgbGFiZWwgdmVydGV4IG9udG8gdGhlIHNjcmVlbi5cXG4gKi9cXG52ZWM0IHByb2plY3RQb2ludExhYmVsVmVydGV4XzFfMihcXG4gICAgbWF0NCB2aWV3UHJvak1hdHJpeCxcXG4gICAgdmVjMiBsb29rQXRIaWdoLFxcbiAgICB2ZWMyIGxvb2tBdExvdyxcXG4gICAgdmVjMiBwb3NIaWdoLFxcbiAgICB2ZWMyIHBvc0xvdyxcXG4gICAgdmVjMiBkaXNwbGFjZW1lbnQsXFxuICAgIHZlYzIgcHhTaXplXFxuKSB7XFxuICAgIHZlYzQgcG9zaXRpb24gPSB2aWV3UHJvak1hdHJpeCAqIHZlYzQoXFxuICAgICAgICBZVl9IXzFfMCAqIChwb3NIaWdoIC0gbG9va0F0SGlnaCkgK1xcbiAgICAgICAgICAgIFlWX0xfMV8xICogKHBvc0xvdyAtIGxvb2tBdExvdyksXFxuICAgICAgICAwLFxcbiAgICAgICAgMVxcbiAgICApO1xcbiAgICBwb3NpdGlvbiA9IHZlYzQocG9zaXRpb24ueHkgLyBwb3NpdGlvbi53LCAwLjAsIDEuMCk7XFxuXFxuICAgIHJldHVybiBwb3NpdGlvbiArIHZlYzQoZGlzcGxhY2VtZW50ICogcHhTaXplLCAwLjAsIDAuMCk7XFxufVxcblxcblxcblxcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIHZlYzIgaWRUZXhDb29yZGluYXRlID0gdmVydGV4SWQueHkgKyBpZEhhbGZQeFNpemU7XFxuICAgIGZsb2F0IG92ZXJsYXBab29tID0gdGV4dHVyZTJEKHZpc2liaWxpdHksIGlkVGV4Q29vcmRpbmF0ZSkuYjtcXG4gICAgaWYgKGN1cnJlbnRab29tIDwgb3ZlcmxhcFpvb20pIHtcXG4gICAgICAgIGdsX1Bvc2l0aW9uID0gRElTQ0FSRF9QT1NJVElPTjtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdFBvaW50TGFiZWxWZXJ0ZXhfMV8yKFxcbiAgICAgICAgICAgIHZpZXdQcm9qTWF0cml4LFxcbiAgICAgICAgICAgIGxvb2tBdEhpZ2gsXFxuICAgICAgICAgICAgbG9va0F0TG93LFxcbiAgICAgICAgICAgIHZlcnRleFBvc0hpZ2gsXFxuICAgICAgICAgICAgdmVydGV4UG9zTG93LFxcbiAgICAgICAgICAgIHZlcnRleERpc3BsYWNlbWVudCxcXG4gICAgICAgICAgICBwaXhlbFNpemVcXG4gICAgICAgICk7XFxuICAgICAgICBnbF9Qb3NpdGlvbi54eSArPSBzaGlmdDtcXG4gICAgICAgIGdsX1Bvc2l0aW9uLnogPSB2ZXJ0ZXhQcmlvcml0eTtcXG4gICAgICAgIGNvbG9yID0gdmVjNCh2ZXJ0ZXhJZCwgMCwgMSk7XFxuICAgIH1cXG5cXG59XFxuXCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS92aXNpYmlsaXR5L3ByaW1pdGl2ZXMvbGFiZWwvc2hhZGVyL3BvaW50X2xhYmVsLnZlcnRcbi8vIG1vZHVsZSBpZCA9IDExMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgUmVuZGVyU3RhdGUgZnJvbSAnLi4vLi4vcmVuZGVyL3N0YXRlJztcclxuaW1wb3J0ICogYXMgdmVjMiBmcm9tICcuLi8uLi9tYXRoL3ZlY3RvcjInO1xyXG5pbXBvcnQgV29ybGRQcmltaXRpdmVSZW5kZXJVbml0IGZyb20gJy4uLy4uL3JlbmRlci9wcmltaXRpdmVzL3dvcmxkX3ByaW1pdGl2ZV9yZW5kZXJfdW5pdCc7XHJcbmV4cG9ydCBjbGFzcyBDb2xsaWRpbmdQcmltaXRpdmVDb2xvcklkUmVuZGVyZXIgZXh0ZW5kcyBXb3JsZFByaW1pdGl2ZVJlbmRlclVuaXQge1xyXG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgcHJvZ3JhbSwgcHJpbWl0aXZlUHJvdmlkZXIpIHtcclxuICAgICAgICBzdXBlcihjb250ZXh0LCBuZXcgUmVuZGVyU3RhdGUoKSwgcHJvZ3JhbSwgcHJpbWl0aXZlUHJvdmlkZXIpO1xyXG4gICAgICAgIHRoaXMuX2lkSGFsZlB4U2l6ZVVuaWZvcm0gPSB2ZWMyLmNyZWF0ZSgwLCAwKTtcclxuICAgIH1cclxuICAgIF9nZXRQcmltaXRpdmVzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnByaW1pdGl2ZVByb3ZpZGVyLnZpc2libGVQcmltaXRpdmVzO1xyXG4gICAgfVxyXG4gICAgX3ByZXBhcmVQcm9ncmFtKHByb2dyYW0sIHZpZXdQcm9qTWF0cml4LCBjYW1lcmFQb3NpdGlvbnMsIHN0YXRlLCBzdGFiaWxpdHlTaGlmdCwgdmlzaWJpbGl0eSwgY3VycmVudFpvb20pIHtcclxuICAgICAgICBzdXBlci5fcHJlcGFyZVByb2dyYW0ocHJvZ3JhbSwgdmlld1Byb2pNYXRyaXgsIGNhbWVyYVBvc2l0aW9ucywgc3RhdGUsIHN0YWJpbGl0eVNoaWZ0LCB2aXNpYmlsaXR5LCBjdXJyZW50Wm9vbSk7XHJcbiAgICAgICAgdGhpcy5faWRIYWxmUHhTaXplVW5pZm9ybS54ID0gMC41IC8gdmlzaWJpbGl0eS5nZXRXaWR0aCgpO1xyXG4gICAgICAgIHRoaXMuX2lkSGFsZlB4U2l6ZVVuaWZvcm0ueSA9IDAuNSAvIHZpc2liaWxpdHkuZ2V0SGVpZ2h0KCk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kVGV4dHVyZVVuaXQoMCk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kVGV4dHVyZSh2aXNpYmlsaXR5KTtcclxuICAgICAgICBwcm9ncmFtLnNldEludFNjYWxhclVuaWZvcm0oJ3Zpc2liaWxpdHknLCAwKTtcclxuICAgICAgICBwcm9ncmFtLnNldFZlY3RvcjJVbmlmb3JtKCdpZEhhbGZQeFNpemUnLCB0aGlzLl9pZEhhbGZQeFNpemVVbmlmb3JtKTtcclxuICAgICAgICBwcm9ncmFtLnNldFZlY3RvcjJVbmlmb3JtKCdzaGlmdCcsIHN0YWJpbGl0eVNoaWZ0KTtcclxuICAgICAgICBwcm9ncmFtLnNldFNjYWxhclVuaWZvcm0oJ2N1cnJlbnRab29tJywgY3VycmVudFpvb20pO1xyXG4gICAgfVxyXG4gICAgX3ByZXBhcmVSZW5kZXJUYXJnZXQodGFyZ2V0LCBfdmlld1Byb2pNYXRyaXgsIF9jYW1lcmFQb3NpdGlvbnMsIHN0YXRlLCBfc3RhYmlsaXR5U2hpZnQsIF92aXNpYmlsaXR5LCBfY3VycmVudFpvb20pIHtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRSZW5kZXJTdGF0ZShzdGF0ZSk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kUmVuZGVyVGFyZ2V0KHRhcmdldCk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdmlzaWJpbGl0eS9wcmltaXRpdmVzL2NvbGxpZGluZ19wcmltaXRpdmVfY29sb3JfaWRfcmVuZGVyZXIudHNcbi8vIG1vZHVsZSBpZCA9IDExMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICogQXBwZW5kcyBwb3J0aW9uIG9mIG1lbW9yeSB0byBiYXRjaCBpZiB0aGV5IGFyZSBhZGphY2VudC5cclxuICpcclxuICogQHJldHVybnMgYHRydWVgIGlmIGJvdGggcGFyYW1zIGFyZSBhZGphY2VudCBhbmQgdGhlIGJhdGNoIHdhcyBzdWNjZXNzZnVsbHkgdXBkYXRlZCwgYGZhbHNlYCBvdGhlcndpc2UuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kVG9CYXRjaChtZW1vcnlMb2NhdGlvbiwgYmF0Y2gpIHtcclxuICAgIGlmIChiYXRjaC52ZXJ0ZXhCeXRlT2Zmc2V0ICsgYmF0Y2gudmVydGV4Qnl0ZUxlbmd0aCA9PT0gbWVtb3J5TG9jYXRpb24udmVydGV4Qnl0ZU9mZnNldCAmJlxyXG4gICAgICAgIGJhdGNoLmluZGV4Qnl0ZU9mZnNldCArIGJhdGNoLmluZGV4Qnl0ZUxlbmd0aCA9PT0gbWVtb3J5TG9jYXRpb24uaW5kZXhCeXRlT2Zmc2V0KSB7XHJcbiAgICAgICAgYmF0Y2gudmVydGV4Qnl0ZUxlbmd0aCArPSBtZW1vcnlMb2NhdGlvbi52ZXJ0ZXhCeXRlTGVuZ3RoO1xyXG4gICAgICAgIGJhdGNoLmluZGV4Qnl0ZUxlbmd0aCArPSBtZW1vcnlMb2NhdGlvbi5pbmRleEJ5dGVMZW5ndGg7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuLyoqXHJcbiAqIENvbWJpbmVzIG9iamVjdHMgYWxsb2NhdGVkIGluIG1lbW9yeSBpbnRvIGJhdGNoZXMuIE5vIHNvcnRpbmcgaXMgZG9uZSBpbiB0aGlzIG1ldGhvZCwgdGhlIG9iamVjdHMgYXJlIHN1cHBvc2VkXHJcbiAqIHRvIGJlIHNvcnRlZCBieSBpbmRleC92ZXJ0ZXggb2Zmc2V0cyB0byBtYWtlIGJhdGNoaW5nIGVmZmVjdGl2ZS4gVGhlIGJhdGNoIGlzIGNyZWF0ZWQgYnkgZmFjdG9yeSBzaW5jZSBpdCBjYW5cclxuICogY29udGFpbnMgcHJvYmxlbSBzcGVjaWZpYyBpbmZvcm1hdGlvbi5cclxuICpcclxuICogQHBhcmFtIG9iamVjdHMgTGlzdCBvZiBhbGxvY2F0ZWQgb2JqZWN0cy5cclxuICogQHBhcmFtIGdldE1lbW9yeUxvY2F0aW9uIFJldHVybnMgbWVtb3J5IGxvY2F0aW9uIG9mIHNwZWNpZmljIG9iamVjdC5cclxuICogQHBhcmFtIGNyZWF0ZUJhdGNoIEluaXRpYXRlcyBiYXRjaCBieSB0aGUgZmlyc3Qgb2JqZWN0LlxyXG4gKiBAcGFyYW0gY2FuQmF0Y2ggQ2hlY2tzIGlmIHR3byBvYmplY3RzIGNhbiBiZSBhbGxvY2F0ZWQuXHJcbiAqIEByZXR1cm5zIEl0ZXJhYmxlIGxpc3Qgb2YgYmF0Y2hlcy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiogYmF0Y2hBbGxvY2F0ZWRPYmplY3RzKG9iamVjdHMsIGdldE1lbW9yeUxvY2F0aW9uLCBjcmVhdGVCYXRjaCwgY2FuQmF0Y2ggPSAoKSA9PiB0cnVlKSB7XHJcbiAgICBjb25zdCBpdGVyYXRvciA9IG9iamVjdHNbU3ltYm9sLml0ZXJhdG9yXSgpO1xyXG4gICAgbGV0IHByaW1pdGl2ZSA9IGl0ZXJhdG9yLm5leHQoKS52YWx1ZTtcclxuICAgIGlmICghcHJpbWl0aXZlKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgbGV0IHByZXYgPSBwcmltaXRpdmU7XHJcbiAgICBsZXQgYmF0Y2ggPSBjcmVhdGVCYXRjaChwcmV2KTtcclxuICAgIHByaW1pdGl2ZSA9IGl0ZXJhdG9yLm5leHQoKS52YWx1ZTtcclxuICAgIHdoaWxlIChwcmltaXRpdmUpIHtcclxuICAgICAgICBjb25zdCBwcmltaXRpdmVNZW1vcnlMb2NhdGlvbiA9IGdldE1lbW9yeUxvY2F0aW9uKHByaW1pdGl2ZSk7XHJcbiAgICAgICAgaWYgKCFjYW5CYXRjaChwcmV2LCBwcmltaXRpdmUsIGJhdGNoKSB8fCAhYXBwZW5kVG9CYXRjaChwcmltaXRpdmVNZW1vcnlMb2NhdGlvbiwgYmF0Y2gpKSB7XHJcbiAgICAgICAgICAgIHlpZWxkIGJhdGNoO1xyXG4gICAgICAgICAgICBiYXRjaCA9IGNyZWF0ZUJhdGNoKHByaW1pdGl2ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByZXYgPSBwcmltaXRpdmU7XHJcbiAgICAgICAgcHJpbWl0aXZlID0gaXRlcmF0b3IubmV4dCgpLnZhbHVlO1xyXG4gICAgfVxyXG4gICAgeWllbGQgYmF0Y2g7XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL21lbW9yeS9yZWxhdGl2ZV9sb2NhdGlvbi50c1xuLy8gbW9kdWxlIGlkID0gMTEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleElkO1xcblxcbi8vIHBvaW50IGluIHRoZSB3b3JsZCB0aGUgbGFiZWwgaXMgYW5jaG9yZWQgdG9cXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhQb3NIaWdoO1xcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleFBvc0xvdztcXG5cXG4vLyB2ZWN0b3Igb2YgY29uY3JldGUgZ2x5cGggcG9pbnQgZGlzcGxhY2VtZW50ICh0b3AtbGVmdCwgYm90dG9tLWxlZnQsIC4uLikgcmVsYXRpdmUgdG8gbGFiZWwncyBjZW50ZXIsIGluIHB4XFxuYXR0cmlidXRlIHZlYzIgdmVydGV4RGlzcGxhY2VtZW50O1xcblxcbi8vIGNvb3JkaW5hdGVzIG9mIHRoZSBnbHlwaCB2ZXJ0ZXggaW4gdGhlIGF0bGFzXFxuYXR0cmlidXRlIHZlYzIgdmVydGV4VVY7XFxuXFxuYXR0cmlidXRlIGZsb2F0IHZlcnRleFByaW9yaXR5O1xcblxcbmF0dHJpYnV0ZSBsb3dwIHZlYzQgdmVydGV4Q29sb3I7XFxuYXR0cmlidXRlIGxvd3AgdmVjNCB2ZXJ0ZXhPdXRsaW5lQ29sb3I7XFxuYXR0cmlidXRlIGZsb2F0IHZlcnRleFNjYWxlO1xcblxcbnVuaWZvcm0gdmVjMiBsb29rQXRIaWdoO1xcbnVuaWZvcm0gdmVjMiBsb29rQXRMb3c7XFxudW5pZm9ybSBtYXQ0IHZpZXdQcm9qTWF0cml4O1xcbnVuaWZvcm0gdmVjMiBwaXhlbFNpemU7XFxudW5pZm9ybSBzYW1wbGVyMkQgdmlzaWJpbGl0eTtcXG51bmlmb3JtIHZlYzIgaWRIYWxmUHhTaXplO1xcbnVuaWZvcm0gdmVjMiBzaGlmdDtcXG51bmlmb3JtIGxvd3AgZmxvYXQgY3VycmVudFpvb207XFxuXFxudmFyeWluZyB2ZWMyIHV2O1xcbnZhcnlpbmcgbG93cCB2ZWM0IGNvbG9yO1xcbnZhcnlpbmcgbG93cCB2ZWM0IG91dGxpbmVDb2xvcjtcXG52YXJ5aW5nIG1lZGl1bXAgZmxvYXQgc2NhbGU7XFxuXFxuY29uc3QgdmVjNCBESVNDQVJEX1BPU0lUSU9OID0gdmVjNCgyLCAyLCAyLCAxKTtcXG5cXG5jb25zdCBmbG9hdCBZVl9IXzFfMCA9IDEuOTk5OTY5NDgyNDIxODc1O1xcbmNvbnN0IGZsb2F0IFlWX0xfMV8xID0gMC4wMDAwMzA1MTcxMTI0NjM3MTI2OTI7XFxuXFxuLyoqXFxuICogUHJvamVjdHMgc3BlY2lmaWMgcG9pbnQgbGFiZWwgdmVydGV4IG9udG8gdGhlIHNjcmVlbi5cXG4gKi9cXG52ZWM0IHByb2plY3RQb2ludExhYmVsVmVydGV4XzFfMihcXG4gICAgbWF0NCB2aWV3UHJvak1hdHJpeCxcXG4gICAgdmVjMiBsb29rQXRIaWdoLFxcbiAgICB2ZWMyIGxvb2tBdExvdyxcXG4gICAgdmVjMiBwb3NIaWdoLFxcbiAgICB2ZWMyIHBvc0xvdyxcXG4gICAgdmVjMiBkaXNwbGFjZW1lbnQsXFxuICAgIHZlYzIgcHhTaXplXFxuKSB7XFxuICAgIHZlYzQgcG9zaXRpb24gPSB2aWV3UHJvak1hdHJpeCAqIHZlYzQoXFxuICAgICAgICBZVl9IXzFfMCAqIChwb3NIaWdoIC0gbG9va0F0SGlnaCkgK1xcbiAgICAgICAgICAgIFlWX0xfMV8xICogKHBvc0xvdyAtIGxvb2tBdExvdyksXFxuICAgICAgICAwLFxcbiAgICAgICAgMVxcbiAgICApO1xcbiAgICBwb3NpdGlvbiA9IHZlYzQocG9zaXRpb24ueHkgLyBwb3NpdGlvbi53LCAwLjAsIDEuMCk7XFxuXFxuICAgIHJldHVybiBwb3NpdGlvbiArIHZlYzQoZGlzcGxhY2VtZW50ICogcHhTaXplLCAwLjAsIDAuMCk7XFxufVxcblxcblxcblxcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIGZsb2F0IHZpc2liaWxpdHlBbHBoYSA9IHRleHR1cmUyRCh2aXNpYmlsaXR5LCB2ZXJ0ZXhJZC54eSArIGlkSGFsZlB4U2l6ZSkuYTtcXG4gICAgaWYgKHZpc2liaWxpdHlBbHBoYSAhPSAwLjApIHtcXG4gICAgICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdFBvaW50TGFiZWxWZXJ0ZXhfMV8yKFxcbiAgICAgICAgICAgIHZpZXdQcm9qTWF0cml4LFxcbiAgICAgICAgICAgIGxvb2tBdEhpZ2gsXFxuICAgICAgICAgICAgbG9va0F0TG93LFxcbiAgICAgICAgICAgIHZlcnRleFBvc0hpZ2gsXFxuICAgICAgICAgICAgdmVydGV4UG9zTG93LFxcbiAgICAgICAgICAgIHZlcnRleERpc3BsYWNlbWVudCxcXG4gICAgICAgICAgICBwaXhlbFNpemVcXG4gICAgICAgICk7XFxuXFxuICAgICAgICB1diA9IHZlcnRleFVWO1xcbiAgICAgICAgY29sb3IgPSB2ZXJ0ZXhDb2xvcjtcXG4gICAgICAgIG91dGxpbmVDb2xvciA9IHZlcnRleE91dGxpbmVDb2xvcjtcXG4gICAgICAgIHNjYWxlID0gdmVydGV4U2NhbGU7XFxuXFxuICAgICAgICBjb2xvci5hICo9IHZpc2liaWxpdHlBbHBoYTtcXG4gICAgICAgIG91dGxpbmVDb2xvci5hICo9IHZpc2liaWxpdHlBbHBoYTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIGdsX1Bvc2l0aW9uID0gRElTQ0FSRF9QT1NJVElPTjtcXG4gICAgfVxcbn1cXG5cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL2xhYmVsL3NoYWRlci9wb2ludF9sYWJlbC52ZXJ0XG4vLyBtb2R1bGUgaWQgPSAxMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHJlY3RhbmdsZVZlcnRleFNoYWRlciBmcm9tICcuL3NoYWRlci9iaWxsYm9hcmRfcmVjdGFuZ2xlLnZlcnQnO1xyXG5pbXBvcnQgcmVjdGFuZ2xlRnJhZ21lbnRTaGFkZXIgZnJvbSAnLi9zaGFkZXIvYmlsbGJvYXJkX3JlY3RhbmdsZS5mcmFnJztcclxuaW1wb3J0ICogYXMgdmVjMiBmcm9tICcuLi8uLi8uLi9tYXRoL3ZlY3RvcjInO1xyXG5pbXBvcnQgV29ybGRQcmltaXRpdmVSZW5kZXJVbml0IGZyb20gJy4uL3dvcmxkX3ByaW1pdGl2ZV9yZW5kZXJfdW5pdCc7XHJcbmltcG9ydCBSZW5kZXJTdGF0ZSBmcm9tICcuLi8uLi8uLi9yZW5kZXIvc3RhdGUnO1xyXG5pbXBvcnQgeyBCTEVORF9PVkVSX1JFTkRFUl9TVEFURSB9IGZyb20gJy4uLy4uLy4uL3JlbmRlci9zdGF0ZSc7XHJcbmNvbnN0IFJFTkRFUl9TVEFURSA9IG5ldyBSZW5kZXJTdGF0ZShCTEVORF9PVkVSX1JFTkRFUl9TVEFURSk7XHJcbi8qKlxyXG4gKiBSZW5kZXJlciBvZiBiaWxsYm9hcmQgcmVjdGFuZ2xlcy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJpbGxib2FyZFJlY3RhbmdsZVJlbmRlclVuaXQgZXh0ZW5kcyBXb3JsZFByaW1pdGl2ZVJlbmRlclVuaXQge1xyXG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgY2FtZXJhLCB2aXNpYmlsaXR5UHJvdmlkZXIsIHByaW1pdGl2ZVByb3ZpZGVyKSB7XHJcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IGNvbnRleHQuY3JlYXRlUHJvZ3JhbShyZWN0YW5nbGVWZXJ0ZXhTaGFkZXIsIHJlY3RhbmdsZUZyYWdtZW50U2hhZGVyLCB7XHJcbiAgICAgICAgICAgIGF0dHJpYk1hcDoge1xyXG4gICAgICAgICAgICAgICAgdmVydGV4SWQ6IDIgLyogSUQgKi8sXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhQb3NIaWdoOiAwIC8qIFBPU0lUSU9OX0hJR0ggKi8sXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhQb3NMb3c6IDEgLyogUE9TSVRJT05fTE9XICovLFxyXG4gICAgICAgICAgICAgICAgdmVydGV4RGlzcGxhY2VtZW50OiA2IC8qIERJU1BMQUNFTUVOVCAqLyxcclxuICAgICAgICAgICAgICAgIHZlcnRleFVWOiA0IC8qIFVWICovLFxyXG4gICAgICAgICAgICAgICAgdmVydGV4Q29sb3I6IDcgLyogQ09MT1IgKi8sXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhCb3JkZXJSYWRpaTogMTEgLyogQVVYICovXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBzdXBlcihjb250ZXh0LCBSRU5ERVJfU1RBVEUsIHByb2dyYW0sIHByaW1pdGl2ZVByb3ZpZGVyKTtcclxuICAgICAgICB0aGlzLl92aXNpYmlsaXR5UHJvdmlkZXIgPSB2aXNpYmlsaXR5UHJvdmlkZXI7XHJcbiAgICAgICAgdGhpcy5fY2FtZXJhID0gY2FtZXJhO1xyXG4gICAgICAgIHRoaXMuX3Zpc2liaWxpdHlTaXplVW5pZm9ybSA9IHZlYzIuY3JlYXRlKDAsIDApO1xyXG4gICAgICAgIGNvbnRleHQuYmluZFByb2dyYW0ocHJvZ3JhbSk7XHJcbiAgICAgICAgcHJvZ3JhbS5zZXRJbnRTY2FsYXJVbmlmb3JtKCd2aXNpYmlsaXR5JywgMCk7XHJcbiAgICB9XHJcbiAgICBfcHJlcGFyZVByb2dyYW0ocHJvZ3JhbSwgdmlld1Byb2pNYXRyaXgsIGNhbWVyYVBvc2l0aW9ucykge1xyXG4gICAgICAgIHN1cGVyLl9wcmVwYXJlUHJvZ3JhbShwcm9ncmFtLCB2aWV3UHJvak1hdHJpeCwgY2FtZXJhUG9zaXRpb25zKTtcclxuICAgICAgICBjb25zdCB2aXNpYmlsaXR5ID0gdGhpcy5fdmlzaWJpbGl0eVByb3ZpZGVyKCk7XHJcbiAgICAgICAgdGhpcy5fdmlzaWJpbGl0eVNpemVVbmlmb3JtLnggPSB2aXNpYmlsaXR5LmdldFdpZHRoKCk7XHJcbiAgICAgICAgdGhpcy5fdmlzaWJpbGl0eVNpemVVbmlmb3JtLnkgPSB2aXNpYmlsaXR5LmdldEhlaWdodCgpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFRleHR1cmVVbml0KDApO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFRleHR1cmUodmlzaWJpbGl0eSk7XHJcbiAgICAgICAgcHJvZ3JhbS5zZXRWZWN0b3IyVW5pZm9ybSgndmlzaWJpbGl0eVNpemUnLCB0aGlzLl92aXNpYmlsaXR5U2l6ZVVuaWZvcm0pO1xyXG4gICAgICAgIHByb2dyYW0uc2V0VmVjdG9yMlVuaWZvcm0oJ3BpeGVsU2l6ZScsIHRoaXMuX2NhbWVyYS5waXhlbFNpemUpO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL2JpbGxib2FyZF9yZWN0YW5nbGUvYmlsbGJvYXJkX3JlY3RhbmdsZV9yZW5kZXJfdW5pdC50c1xuLy8gbW9kdWxlIGlkID0gMTE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleElkO1xcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleFBvc0hpZ2g7XFxuYXR0cmlidXRlIHZlYzIgdmVydGV4UG9zTG93O1xcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleERpc3BsYWNlbWVudDtcXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhVVjtcXG5hdHRyaWJ1dGUgdmVjNCB2ZXJ0ZXhDb2xvcjtcXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhCb3JkZXJSYWRpaTtcXG5cXG51bmlmb3JtIHZlYzIgbG9va0F0SGlnaDtcXG51bmlmb3JtIHZlYzIgbG9va0F0TG93O1xcbnVuaWZvcm0gbWF0NCB2aWV3UHJvak1hdHJpeDtcXG51bmlmb3JtIHZlYzIgcGl4ZWxTaXplO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHZpc2liaWxpdHk7XFxudW5pZm9ybSB2ZWMyIHZpc2liaWxpdHlTaXplO1xcblxcbnZhcnlpbmcgdmVjMiB1djtcXG52YXJ5aW5nIHZlYzQgY29sb3I7XFxudmFyeWluZyB2ZWMyIGJvcmRlclJhZGlpO1xcblxcbmNvbnN0IHZlYzQgRElTQ0FSRF9QT1NJVElPTiA9IHZlYzQoMiwgMiwgMiwgMSk7XFxuY29uc3QgZmxvYXQgWVZfSCA9IDEuOTk5OTY5NDgyNDIxODc1O1xcbmNvbnN0IGZsb2F0IFlWX0wgPSAwLjAwMDAzMDUxNzExMjQ2MzcxMjY5MjtcXG52ZWMyIFZJU0lCSUxJVFlfSEFMRl9QWCA9IDAuNSAvIHZpc2liaWxpdHlTaXplO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIGZsb2F0IHZpc2liaWxpdHlBbHBoYSA9IHRleHR1cmUyRCh2aXNpYmlsaXR5LCB2ZXJ0ZXhJZC54eSArIFZJU0lCSUxJVFlfSEFMRl9QWCkuYTtcXG4gICAgaWYgKHZpc2liaWxpdHlBbHBoYSA9PSAwLjApIHtcXG4gICAgICAgIGdsX1Bvc2l0aW9uID0gRElTQ0FSRF9QT1NJVElPTjtcXG4gICAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICB2ZWM0IHBvc2l0aW9uID0gdmlld1Byb2pNYXRyaXggKiB2ZWM0KFxcbiAgICAgICAgWVZfSCAqICh2ZXJ0ZXhQb3NIaWdoIC0gbG9va0F0SGlnaCkgK1xcbiAgICAgICAgICAgIFlWX0wgKiAodmVydGV4UG9zTG93IC0gbG9va0F0TG93KSxcXG4gICAgICAgIDAsXFxuICAgICAgICAxXFxuICAgICk7XFxuICAgIHBvc2l0aW9uLnh5eiAvPSBwb3NpdGlvbi53O1xcbiAgICBwb3NpdGlvbi53ID0gMS4wO1xcblxcbiAgICBnbF9Qb3NpdGlvbiA9IHBvc2l0aW9uICsgdmVjNCh2ZXJ0ZXhEaXNwbGFjZW1lbnQgKiBwaXhlbFNpemUsIDAuMCwgMC4wKTtcXG5cXG4gICAgdXYgPSB2ZXJ0ZXhVVjtcXG4gICAgY29sb3IgPSB2ZXJ0ZXhDb2xvcjtcXG4gICAgY29sb3IuYSAqPSB2aXNpYmlsaXR5QWxwaGE7XFxuICAgIGJvcmRlclJhZGlpID0gdmVydGV4Qm9yZGVyUmFkaWk7XFxufVxcblwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvYmlsbGJvYXJkX3JlY3RhbmdsZS9zaGFkZXIvYmlsbGJvYXJkX3JlY3RhbmdsZS52ZXJ0XG4vLyBtb2R1bGUgaWQgPSAxMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcIiN2ZXJzaW9uIDEwMFxcblxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxudmFyeWluZyB2ZWMyIHV2O1xcbnZhcnlpbmcgdmVjNCBjb2xvcjtcXG52YXJ5aW5nIHZlYzIgYm9yZGVyUmFkaWk7XFxuXFxuZmxvYXQgcm91bmRlZFJlY3RhbmdsZShjb25zdCBpbiB2ZWMyIHV2LCBjb25zdCBpbiB2ZWMyIHJhZGlpKSB7XFxuICAgIHZlYzIgYWJzVXYgPSBhYnModXYpO1xcbiAgICB2ZWMyIHEgPSBhYnNVdiArIHJhZGlpIC0gMS4wO1xcbiAgICByZXR1cm4gbWluKHEueCwgcS55KSA+IDAuMCA/IGxlbmd0aChxIC8gcmFkaWkpIDogbWF4KGFic1V2LngsIGFic1V2LnkpO1xcbn1cXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgICBnbF9GcmFnQ29sb3IgPSBzdGVwKHJvdW5kZWRSZWN0YW5nbGUodXYsIGJvcmRlclJhZGlpKSwgMS4wKSAqIGNvbG9yO1xcbn1cXG5cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL2JpbGxib2FyZF9yZWN0YW5nbGUvc2hhZGVyL2JpbGxib2FyZF9yZWN0YW5nbGUuZnJhZ1xuLy8gbW9kdWxlIGlkID0gMTE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBjdXJ2ZWRMYWJlbFZlcnRleFNoYWRlciBmcm9tICcuL3NoYWRlci9jdXJ2ZWRfbGFiZWwudmVydCc7XHJcbmltcG9ydCBjb2xvcklkRnJhZ21lbnRTaGFkZXIgZnJvbSAnLi9zaGFkZXIvY29sb3JfaWQuZnJhZyc7XHJcbmltcG9ydCB7IFBST0dSQU1fT1BUSU9OUyB9IGZyb20gJy4uLy4uLy4uL3JlbmRlci9wcmltaXRpdmVzL2xhYmVsL2N1cnZlZF9sYWJlbF9yZW5kZXJfdW5pdCc7XHJcbmltcG9ydCBDb2xsaWRpbmdMYWJlbENvbG9ySWRSZW5kZXJlciBmcm9tICcuL2NvbG9yX2lkX2xhYmVsX3JlbmRlcmVyJztcclxuLyoqXHJcbiAqIEN1cnZlZCBsYWJlbHMgcmVuZGVyZXIgZm9yIGNvbGxpc2lvbiByZXNvbHV0aW9uLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29sb3JJZEN1cnZlZExhYmVsUmVuZGVyZXIgZXh0ZW5kcyBDb2xsaWRpbmdMYWJlbENvbG9ySWRSZW5kZXJlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBjYW1lcmEsIHByaW1pdGl2ZVByb3ZpZGVyKSB7XHJcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IGNvbnRleHQuY3JlYXRlUHJvZ3JhbShjdXJ2ZWRMYWJlbFZlcnRleFNoYWRlciwgY29sb3JJZEZyYWdtZW50U2hhZGVyLCBQUk9HUkFNX09QVElPTlMpO1xyXG4gICAgICAgIHN1cGVyKGNvbnRleHQsIHByb2dyYW0sIHByaW1pdGl2ZVByb3ZpZGVyLCBjYW1lcmEpO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3Zpc2liaWxpdHkvcHJpbWl0aXZlcy9sYWJlbC9jb2xvcl9pZF9jdXJ2ZWRfbGFiZWxfcmVuZGVyZXIudHNcbi8vIG1vZHVsZSBpZCA9IDExOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwiI3ZlcnNpb24gMTAwXFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhJZDtcXG5cXG4vLyBwb2ludCBpbiB0aGUgd29ybGQgdGhlIGxhYmVsIGlzIGFuY2hvcmVkIHRvXFxuYXR0cmlidXRlIHZlYzIgdmVydGV4UG9zSGlnaDtcXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhQb3NMb3c7XFxuXFxuLy8gdmVjdG9yIG9mIGNvbmNyZXRlIGdseXBoIHBvaW50IGRpc3BsYWNlbWVudCAodG9wLWxlZnQsIGJvdHRvbS1sZWZ0LCAuLi4pIHJlbGF0aXZlIHRvIGdseXBoJ3MgY2VudGVyICh0d28gdmFsdWVzKSxcXG4vLyBhbmQgZGlzdGFuY2Ugb2YgdGhlIGdseXBoIGNlbnRlciB0byBsYWJlbCdzIGNlbnRlciAodGhpcmQgdmFsdWUpLCBpbiBweFxcbmF0dHJpYnV0ZSB2ZWMzIHZlcnRleERpc3BsYWNlbWVudHM7XFxuXFxuLy8gY29vcmRpbmF0ZXMgb2YgdGhlIGdseXBoIHZlcnRleCBpbiB0aGUgYXRsYXNcXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhVVjtcXG5cXG5hdHRyaWJ1dGUgZmxvYXQgdmVydGV4UHJpb3JpdHk7XFxuXFxuYXR0cmlidXRlIGxvd3AgdmVjNCB2ZXJ0ZXhDb2xvcjtcXG5hdHRyaWJ1dGUgbG93cCB2ZWM0IHZlcnRleE91dGxpbmVDb2xvcjtcXG5hdHRyaWJ1dGUgdmVjMiBwb2x5bGluZUxlbmd0aF92ZXJ0ZXhTY2FsZTtcXG5cXG4vLyBkZWx0YXMgcmVsYXRpdmUgdG8gdGhlIHdvcmxkIHBvaW50IGVuY29kZWQgaW4gdmVydGV4UG9zSGlnaC92ZXJ0ZXhQb3NMb3cgZW5jb2RlZCB2aWEgbGVuZ3RocyBhbmQgYW5kIGFuZ2xlcyBvZlxcbi8vIGNvcnJlc3BvbmRpbmcgdmVjdG9yc1xcbmF0dHJpYnV0ZSB2ZWM0IGxlZnRQb2x5bGluZVJhdGlvcztcXG5hdHRyaWJ1dGUgdmVjNCBsZWZ0UG9seWxpbmVBbmdsZXM7XFxuYXR0cmlidXRlIHZlYzQgcmlnaHRQb2x5bGluZVJhdGlvcztcXG5hdHRyaWJ1dGUgdmVjNCByaWdodFBvbHlsaW5lQW5nbGVzO1xcblxcbnVuaWZvcm0gdmVjMiBsb29rQXRIaWdoO1xcbnVuaWZvcm0gdmVjMiBsb29rQXRMb3c7XFxudW5pZm9ybSBtYXQ0IHZpZXdQcm9qTWF0cml4O1xcbnVuaWZvcm0gdmVjMiBwaXhlbFNpemU7XFxudW5pZm9ybSBzYW1wbGVyMkQgdmlzaWJpbGl0eTtcXG51bmlmb3JtIHZlYzIgaWRIYWxmUHhTaXplO1xcbnVuaWZvcm0gdmVjMiBzaGlmdDtcXG51bmlmb3JtIGxvd3AgZmxvYXQgY3VycmVudFpvb207XFxuXFxudmFyeWluZyB2ZWMyIHV2O1xcbnZhcnlpbmcgbG93cCB2ZWM0IGNvbG9yO1xcbnZhcnlpbmcgbG93cCB2ZWM0IG91dGxpbmVDb2xvcjtcXG52YXJ5aW5nIGZsb2F0IHNjYWxlO1xcblxcbmNvbnN0IHZlYzQgRElTQ0FSRF9QT1NJVElPTiA9IHZlYzQoMiwgMiwgMiwgMSk7XFxuXFxuY29uc3QgZmxvYXQgWVZfSF8xXzAgPSAxLjk5OTk2OTQ4MjQyMTg3NTtcXG5jb25zdCBmbG9hdCBZVl9MXzFfMSA9IDAuMDAwMDMwNTE3MTEyNDYzNzEyNjkyO1xcblxcbmNvbnN0IGZsb2F0IFBJXzFfMiA9IDMuMTQxNTkyNzQxMDEyNTczMjtcXG5cXG5jb25zdCBpbnQgTUFYX1BPTFlMSU5FX1BPSU5UU18xXzMgPSA0O1xcbmNvbnN0IGZsb2F0IElORklOSVRZXzFfNCA9IDEwMDAwMDAuMDsgLy8gbGFyZ2UgZW5vdWdoIGZvciBhIHNlZ21lbnQgbGVuZ3RoIHRvIGNvbnNpZGVyIGl0IGluZmluaXR5XFxuXFxuLyoqXFxuICogUmV0dXJucyB3b3JsZCBjb29yZGluYXRlIChwbHVzIGRlbHRhKSBwcm9qZWN0ZWQgb24gc2NyZWVuLCBpbiBwaXhlbHMuXFxuICovXFxudmVjMiBwcm9qZWN0XzFfNShcXG4gICAgbWF0NCB2aWV3UHJvak1hdHJpeCxcXG4gICAgdmVjMiBsb29rQXRIaWdoLFxcbiAgICB2ZWMyIGxvb2tBdExvdyxcXG4gICAgdmVjMiBwaXhlbFNpemUsXFxuICAgIHZlYzIgcG9pbnRIaWdoLFxcbiAgICB2ZWMyIHBvaW50TG93LFxcbiAgICB2ZWMyIGRlbHRhXFxuKSB7XFxuICAgIHZlYzQgcG9zaXRpb24gPSB2aWV3UHJvak1hdHJpeCAqIHZlYzQoXFxuICAgICAgICAgICAgWVZfSF8xXzAgKiAocG9pbnRIaWdoIC0gbG9va0F0SGlnaCkgKyBZVl9MXzFfMSAqIChwb2ludExvdyAtIGxvb2tBdExvdykgKyBkZWx0YSxcXG4gICAgICAgICAgICAwLFxcbiAgICAgICAgICAgIDFcXG4gICAgICAgICk7XFxuICAgIHZlYzIgcHJvamVjdGVkID0gcG9zaXRpb24ueHkgLyBwb3NpdGlvbi53O1xcbiAgICByZXR1cm4gcHJvamVjdGVkIC8gcGl4ZWxTaXplO1xcbn1cXG5cXG4vKipcXG4gKiBFYWNoIHBvaW50IG9mIHRoZSBwb2x5bGluZSBpcyBlbmNvZGVkIGFzIGEgdmVjdG9yIGZyb20gdGhlIHBvbHlsaW5lIGNlbnRlciBieSBpdHMgbm9ybWFsaXplZCBhbmdsZSBhbmQgdGhlIHJhdGlvIG9mXFxuICogaXRzIGxlbmd0aCB0byB0aGUgcG9seWxpbmUncyBsZW5ndGguXFxuICovXFxudmVjMiBkZWNvZGVQb2x5bGluZURlbHRhc18xXzYoZmxvYXQgcmF0aW8sIGZsb2F0IGFuZ2xlLCBmbG9hdCBwb2x5bGluZUxlbmd0aCkge1xcbiAgICAvLyBkZW5vcm1hbGl6ZSBhbmdsZSBiYWNrIHRvIHJhZGlhbnNcXG4gICAgZmxvYXQgYSA9IGFuZ2xlICogMi4wICogUElfMV8yIC0gUElfMV8yO1xcbiAgICAvLyBsZW5ndGggb2YgYSB2ZWN0b3JcXG4gICAgZmxvYXQgbGVuID0gcmF0aW8gKiBwb2x5bGluZUxlbmd0aDtcXG4gICAgLy8gcmVzdG9yZWQgcG9pbnQncyAoeCwgeSkgY29vcmRpbmF0ZXNcXG4gICAgcmV0dXJuIHZlYzIoY29zKGEpLCBzaW4oYSkpICogbGVuO1xcbn1cXG5cXG4vKipcXG4gKiBQcm9qZWN0cyBzcGVjaWZpYyBjdXJ2ZWQgbGFiZWwgdmVydGV4IG9udG8gdGhlIHNjcmVlbi4gVGhlIGxhYmVsIGlzIGxheW91dGVkIGJ5IGNlbnRlcmluZyBwb2x5bGluZSBpblxcbiAqIHRoZSB2ZXJ0ZXhQb3NIaWdoL3ZlcnRleFBvc0xvdyBhbmQgb3RoZXIgcG9pbnRzIGFyZSB1c2VkIHRvIGd1aWRlIGNvbmNyZXRlIGdyeXBoIHZlcnRleC5cXG4gKiBOdW1iZXIgb2YgcG9seWxpbmUgcG9pbnRzIGlzIGhhcmRjb2RlZCB0byBwYXNzIHRoZW0gaW4gYXR0cmlidXRlcy5cXG4gKi9cXG52ZWM0IHByb2plY3RDdXJ2ZWRMYWJlbFZlcnRleF8xXzcoXFxuICAgIG1hdDQgdmlld1Byb2pNYXRyaXgsXFxuICAgIHZlYzIgbG9va0F0SGlnaCxcXG4gICAgdmVjMiBsb29rQXRMb3csXFxuICAgIHZlYzIgcHhTaXplLFxcbiAgICB2ZWMyIHBvc0hpZ2gsXFxuICAgIHZlYzIgcG9zTG93LFxcbiAgICB2ZWMyIGRpc3BsYWNlbWVudCxcXG4gICAgZmxvYXQgbGluZURpc3BsYWNlbWVudCxcXG4gICAgZmxvYXQgcG9seWxpbmVMZW5ndGgsXFxuICAgIHZlYzQgbGVmdFBvbHlsaW5lUmF0aW9zLFxcbiAgICB2ZWM0IGxlZnRQb2x5bGluZUFuZ2xlcyxcXG4gICAgdmVjNCByaWdodFBvbHlsaW5lUmF0aW9zLFxcbiAgICB2ZWM0IHJpZ2h0UG9seWxpbmVBbmdsZXNcXG4pIHtcXG4gICAgdmVjMiBwb2x5bGluZURlbHRhc1tNQVhfUE9MWUxJTkVfUE9JTlRTXzFfM107XFxuICAgIHZlYzIgcG9zaXRpb24gPSBwcm9qZWN0XzFfNSh2aWV3UHJvak1hdHJpeCwgbG9va0F0SGlnaCwgbG9va0F0TG93LCBweFNpemUsIHBvc0hpZ2gsIHBvc0xvdywgdmVjMigwLCAwKSk7XFxuICAgIGZsb2F0IHJlbWFpbmluZ0xlbmd0aCA9IGFicyhsaW5lRGlzcGxhY2VtZW50KTtcXG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCBNQVhfUE9MWUxJTkVfUE9JTlRTXzFfMzsgaSsrKSB7XFxuICAgICAgICB2ZWMyIHByb2plY3RlZFBvaW50O1xcblxcbiAgICAgICAgLy8gZmlndXJlIG91dCB0aGUgZGlyZWN0aW9uIChsZWZ0L3JpZ2h0KSBhdCB0aGUgZmlyc3Qgc3RlcFxcbiAgICAgICAgaWYgKGkgPT0gMCkge1xcbiAgICAgICAgICAgIHByb2plY3RlZFBvaW50ID0gcHJvamVjdF8xXzUoXFxuICAgICAgICAgICAgICAgIHZpZXdQcm9qTWF0cml4LFxcbiAgICAgICAgICAgICAgICBsb29rQXRIaWdoLFxcbiAgICAgICAgICAgICAgICBsb29rQXRMb3csXFxuICAgICAgICAgICAgICAgIHB4U2l6ZSxcXG4gICAgICAgICAgICAgICAgcG9zSGlnaCxcXG4gICAgICAgICAgICAgICAgcG9zTG93LFxcbiAgICAgICAgICAgICAgICBkZWNvZGVQb2x5bGluZURlbHRhc18xXzYocmlnaHRQb2x5bGluZVJhdGlvc1swXSwgcmlnaHRQb2x5bGluZUFuZ2xlc1swXSwgcG9seWxpbmVMZW5ndGgpXFxuICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICBib29sIGlzUmlnaHRQYXJ0ID0gbGluZURpc3BsYWNlbWVudCA+IDAuMDtcXG4gICAgICAgICAgICBib29sIGlzSW52ZXJ0ZWQgPSBwcm9qZWN0ZWRQb2ludC54IDwgcG9zaXRpb24ueDtcXG5cXG4gICAgICAgICAgICAvLyB0aGUgbWFwIGNvdWxkIGJlIHJvdGF0ZWQgYW5kIGN1cnZlZCBsYWJlbCBzaG91bGQgY2hhbmdlIGl0cyBkaXJlY3Rpb24gaWYgdGhleSBnb3QgdXBzaWRlIGRvd25cXG4gICAgICAgICAgICAvLyB1c2luZyBjZW50ZXIgc2VnbWVudCB0byBpZGVudGlmeSB0aGlzIGNhc2UgaXMgYW4gYXBwcm94aW1hdGlvbiAoaWRlYWxseSB3ZSBzaG91bGQgY2hlY2sgYWxsIHNlZ21lbnRzKVxcbiAgICAgICAgICAgIGlmIChpc1JpZ2h0UGFydCBeXiBpc0ludmVydGVkKSB7XFxuICAgICAgICAgICAgICAgIHBvbHlsaW5lRGVsdGFzWzBdID0gZGVjb2RlUG9seWxpbmVEZWx0YXNfMV82KHJpZ2h0UG9seWxpbmVSYXRpb3NbMF0sIHJpZ2h0UG9seWxpbmVBbmdsZXNbMF0sIHBvbHlsaW5lTGVuZ3RoKTtcXG4gICAgICAgICAgICAgICAgcG9seWxpbmVEZWx0YXNbMV0gPSBkZWNvZGVQb2x5bGluZURlbHRhc18xXzYocmlnaHRQb2x5bGluZVJhdGlvc1sxXSwgcmlnaHRQb2x5bGluZUFuZ2xlc1sxXSwgcG9seWxpbmVMZW5ndGgpO1xcbiAgICAgICAgICAgICAgICBwb2x5bGluZURlbHRhc1syXSA9IGRlY29kZVBvbHlsaW5lRGVsdGFzXzFfNihyaWdodFBvbHlsaW5lUmF0aW9zWzJdLCByaWdodFBvbHlsaW5lQW5nbGVzWzJdLCBwb2x5bGluZUxlbmd0aCk7XFxuICAgICAgICAgICAgICAgIHBvbHlsaW5lRGVsdGFzWzNdID0gZGVjb2RlUG9seWxpbmVEZWx0YXNfMV82KHJpZ2h0UG9seWxpbmVSYXRpb3NbM10sIHJpZ2h0UG9seWxpbmVBbmdsZXNbM10sIHBvbHlsaW5lTGVuZ3RoKTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBwb2x5bGluZURlbHRhc1swXSA9IGRlY29kZVBvbHlsaW5lRGVsdGFzXzFfNihsZWZ0UG9seWxpbmVSYXRpb3NbMF0sIGxlZnRQb2x5bGluZUFuZ2xlc1swXSwgcG9seWxpbmVMZW5ndGgpO1xcbiAgICAgICAgICAgICAgICBwb2x5bGluZURlbHRhc1sxXSA9IGRlY29kZVBvbHlsaW5lRGVsdGFzXzFfNihsZWZ0UG9seWxpbmVSYXRpb3NbMV0sIGxlZnRQb2x5bGluZUFuZ2xlc1sxXSwgcG9seWxpbmVMZW5ndGgpO1xcbiAgICAgICAgICAgICAgICBwb2x5bGluZURlbHRhc1syXSA9IGRlY29kZVBvbHlsaW5lRGVsdGFzXzFfNihsZWZ0UG9seWxpbmVSYXRpb3NbMl0sIGxlZnRQb2x5bGluZUFuZ2xlc1syXSwgcG9seWxpbmVMZW5ndGgpO1xcbiAgICAgICAgICAgICAgICBwb2x5bGluZURlbHRhc1szXSA9IGRlY29kZVBvbHlsaW5lRGVsdGFzXzFfNihsZWZ0UG9seWxpbmVSYXRpb3NbM10sIGxlZnRQb2x5bGluZUFuZ2xlc1szXSwgcG9seWxpbmVMZW5ndGgpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAvLyB0aGUgZmlyc3QgcmlnaHQgcG9pbnQgb2YgdGhlIHNlZ21lbnQgYWxyZWFkeSBjYWxjdWxhdGVkLFxcbiAgICAgICAgICAgIC8vIHJlY2FsY3VsYXRlIHRoZSBwb2ludCBpZiB0aGlzIHBhcnQgb2YgdGhlIGxhYmVsIGdvZXMgb3RoZXIgZGlyZWN0aW9uXFxuICAgICAgICAgICAgaWYgKCEoaXNSaWdodFBhcnQgJiYgIWlzSW52ZXJ0ZWQpICYmICEoIWlzUmlnaHRQYXJ0ICYmIGlzSW52ZXJ0ZWQpKSB7XFxuICAgICAgICAgICAgICAgIHByb2plY3RlZFBvaW50ID0gcHJvamVjdF8xXzUodmlld1Byb2pNYXRyaXgsIGxvb2tBdEhpZ2gsIGxvb2tBdExvdywgcHhTaXplLCBwb3NIaWdoLCBwb3NMb3csIHBvbHlsaW5lRGVsdGFzW2ldKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHByb2plY3RlZFBvaW50ID0gcHJvamVjdF8xXzUodmlld1Byb2pNYXRyaXgsIGxvb2tBdEhpZ2gsIGxvb2tBdExvdywgcHhTaXplLCBwb3NIaWdoLCBwb3NMb3csIHBvbHlsaW5lRGVsdGFzW2ldKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZlYzIgc2VnbWVudCA9IHByb2plY3RlZFBvaW50IC0gcG9zaXRpb247XFxuICAgICAgICBib29sIGlzTGFzdCA9IGkgPT0gKE1BWF9QT0xZTElORV9QT0lOVFNfMV8zIC0gMSk7XFxuICAgICAgICBmbG9hdCBzZWdtZW50TGVuZ3RoID0gKGlzTGFzdCB8fCAocG9seWxpbmVEZWx0YXNbaSArIDFdID09IHZlYzIoMCwgMCkpKSA/IElORklOSVRZXzFfNCA6IGxlbmd0aChzZWdtZW50KTtcXG5cXG4gICAgICAgIGlmIChzZWdtZW50TGVuZ3RoID4gcmVtYWluaW5nTGVuZ3RoKSB7XFxuICAgICAgICAgICAgZmxvYXQgc2lnbkZhY3RvciA9IGxpbmVEaXNwbGFjZW1lbnQgPiAwLjAgPyAxLjAgOiAtMS4wO1xcbiAgICAgICAgICAgIHZlYzIgZGlyZWN0aW9uID0gbm9ybWFsaXplKHNlZ21lbnQpO1xcbiAgICAgICAgICAgIHZlYzIgbm9ybWFsID0gdmVjMigtZGlyZWN0aW9uLnksIGRpcmVjdGlvbi54KTtcXG5cXG4gICAgICAgICAgICBwb3NpdGlvbiArPSBkaXJlY3Rpb24gKiByZW1haW5pbmdMZW5ndGg7XFxuICAgICAgICAgICAgcG9zaXRpb24gKz0gc2lnbkZhY3RvciAqIGRpcmVjdGlvbiAqIGRpc3BsYWNlbWVudC54O1xcbiAgICAgICAgICAgIHBvc2l0aW9uICs9IHNpZ25GYWN0b3IgKiBub3JtYWwgKiBkaXNwbGFjZW1lbnQueTtcXG5cXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgcmVtYWluaW5nTGVuZ3RoIC09IHNlZ21lbnRMZW5ndGg7XFxuICAgICAgICAgICAgcG9zaXRpb24gKz0gc2VnbWVudDtcXG4gICAgICAgIH1cXG4gICAgfVxcblxcbiAgICByZXR1cm4gdmVjNChwb3NpdGlvbiAqIHB4U2l6ZSwgMC4wLCAxLjApO1xcbn1cXG5cXG5cXG5cXG5cXG5cXG4vKipcXG4gKiBDdXJ2ZWQgbGFiZWxzIGFyZSBsYXlvdXRlZCBoZXJlOiB0aGUgbGFiZWwgaXMgY2VudGVyZWQgaW4gdGhlIHZlcnRleFBvc0hpZ2gvdmVydGV4UG9zTG93IGFuZCBwb2x5bGluZSBwb2ludHNcXG4gKiBhcmUgdXNlZCB0byBndWlkZSBjb25jcmV0ZSBncnlwaCB2ZXJ0ZXguIE51bWJlciBvZiBwb2x5bGluZSBwb2ludHMgaXMgaGFyZGNvZGVkIHRvIHBhc3MgdGhlbSBpbiBhdHRyaWJ1dGVzLlxcbiAqL1xcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIHZlYzIgaWRUZXhDb29yZGluYXRlID0gdmVydGV4SWQueHkgKyBpZEhhbGZQeFNpemU7XFxuICAgIGZsb2F0IG92ZXJsYXBab29tID0gdGV4dHVyZTJEKHZpc2liaWxpdHksIGlkVGV4Q29vcmRpbmF0ZSkuYjtcXG5cXG4gICAgaWYgKGN1cnJlbnRab29tIDwgb3ZlcmxhcFpvb20pIHtcXG4gICAgICAgIGdsX1Bvc2l0aW9uID0gRElTQ0FSRF9QT1NJVElPTjtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIHZlYzIgdmVydGV4RGlzcGxhY2VtZW50ID0gdmVydGV4RGlzcGxhY2VtZW50cy54eTtcXG4gICAgICAgIGZsb2F0IHZlcnRleExpbmVEaXNwbGFjZW1lbnQgPSB2ZXJ0ZXhEaXNwbGFjZW1lbnRzLno7XFxuICAgICAgICBmbG9hdCBwb2x5bGluZUxlbmd0aCA9IHBvbHlsaW5lTGVuZ3RoX3ZlcnRleFNjYWxlWzBdO1xcbiAgICAgICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0Q3VydmVkTGFiZWxWZXJ0ZXhfMV83KFxcbiAgICAgICAgICAgIHZpZXdQcm9qTWF0cml4LFxcbiAgICAgICAgICAgIGxvb2tBdEhpZ2gsXFxuICAgICAgICAgICAgbG9va0F0TG93LFxcbiAgICAgICAgICAgIHBpeGVsU2l6ZSxcXG4gICAgICAgICAgICB2ZXJ0ZXhQb3NIaWdoLFxcbiAgICAgICAgICAgIHZlcnRleFBvc0xvdyxcXG4gICAgICAgICAgICB2ZXJ0ZXhEaXNwbGFjZW1lbnQsXFxuICAgICAgICAgICAgdmVydGV4TGluZURpc3BsYWNlbWVudCxcXG4gICAgICAgICAgICBwb2x5bGluZUxlbmd0aCxcXG4gICAgICAgICAgICBsZWZ0UG9seWxpbmVSYXRpb3MsXFxuICAgICAgICAgICAgbGVmdFBvbHlsaW5lQW5nbGVzLFxcbiAgICAgICAgICAgIHJpZ2h0UG9seWxpbmVSYXRpb3MsXFxuICAgICAgICAgICAgcmlnaHRQb2x5bGluZUFuZ2xlc1xcbiAgICAgICAgKTtcXG5cXG4gICAgICAgIGdsX1Bvc2l0aW9uLnh5ICs9IHNoaWZ0O1xcbiAgICAgICAgZ2xfUG9zaXRpb24ueiA9IHZlcnRleFByaW9yaXR5O1xcblxcbiAgICAgICAgY29sb3IgPSB2ZWM0KHZlcnRleElkLCAwLCAxKTtcXG4gICAgfVxcbn1cXG5cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3Zpc2liaWxpdHkvcHJpbWl0aXZlcy9sYWJlbC9zaGFkZXIvY3VydmVkX2xhYmVsLnZlcnRcbi8vIG1vZHVsZSBpZCA9IDExOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwiI3ZlcnNpb24gMTAwXFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhJZDtcXG5cXG4vLyBwb2ludCBpbiB0aGUgd29ybGQgdGhlIGxhYmVsIGlzIGFuY2hvcmVkIHRvXFxuYXR0cmlidXRlIHZlYzIgdmVydGV4UG9zSGlnaDtcXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhQb3NMb3c7XFxuXFxuLy8gdmVjdG9yIG9mIGNvbmNyZXRlIGdseXBoIHBvaW50IGRpc3BsYWNlbWVudCAodG9wLWxlZnQsIGJvdHRvbS1sZWZ0LCAuLi4pIHJlbGF0aXZlIHRvIGdseXBoJ3MgY2VudGVyICh0d28gdmFsdWVzKSxcXG4vLyBhbmQgZGlzdGFuY2Ugb2YgdGhlIGdseXBoIGNlbnRlciB0byBsYWJlbCdzIGNlbnRlciAodGhpcmQgdmFsdWUpLCBpbiBweFxcbmF0dHJpYnV0ZSB2ZWMzIHZlcnRleERpc3BsYWNlbWVudHM7XFxuXFxuLy8gY29vcmRpbmF0ZXMgb2YgdGhlIGdseXBoIHZlcnRleCBpbiB0aGUgYXRsYXNcXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhVVjtcXG5cXG5hdHRyaWJ1dGUgZmxvYXQgdmVydGV4UHJpb3JpdHk7XFxuXFxuYXR0cmlidXRlIGxvd3AgdmVjNCB2ZXJ0ZXhDb2xvcjtcXG5hdHRyaWJ1dGUgbG93cCB2ZWM0IHZlcnRleE91dGxpbmVDb2xvcjtcXG5hdHRyaWJ1dGUgdmVjMiBwb2x5bGluZUxlbmd0aF92ZXJ0ZXhTY2FsZTtcXG5cXG4vLyBkZWx0YXMgcmVsYXRpdmUgdG8gdGhlIHdvcmxkIHBvaW50IGVuY29kZWQgaW4gdmVydGV4UG9zSGlnaC92ZXJ0ZXhQb3NMb3cgZW5jb2RlZCB2aWEgbGVuZ3RocyBhbmQgYW5kIGFuZ2xlcyBvZlxcbi8vIGNvcnJlc3BvbmRpbmcgdmVjdG9yc1xcbmF0dHJpYnV0ZSB2ZWM0IGxlZnRQb2x5bGluZVJhdGlvcztcXG5hdHRyaWJ1dGUgdmVjNCBsZWZ0UG9seWxpbmVBbmdsZXM7XFxuYXR0cmlidXRlIHZlYzQgcmlnaHRQb2x5bGluZVJhdGlvcztcXG5hdHRyaWJ1dGUgdmVjNCByaWdodFBvbHlsaW5lQW5nbGVzO1xcblxcbnVuaWZvcm0gdmVjMiBsb29rQXRIaWdoO1xcbnVuaWZvcm0gdmVjMiBsb29rQXRMb3c7XFxudW5pZm9ybSBtYXQ0IHZpZXdQcm9qTWF0cml4O1xcbnVuaWZvcm0gdmVjMiBwaXhlbFNpemU7XFxudW5pZm9ybSBzYW1wbGVyMkQgdmlzaWJpbGl0eTtcXG51bmlmb3JtIHZlYzIgaWRIYWxmUHhTaXplO1xcbnVuaWZvcm0gdmVjMiBzaGlmdDtcXG51bmlmb3JtIGxvd3AgZmxvYXQgY3VycmVudFpvb207XFxuXFxudmFyeWluZyB2ZWMyIHV2O1xcbnZhcnlpbmcgbG93cCB2ZWM0IGNvbG9yO1xcbnZhcnlpbmcgbG93cCB2ZWM0IG91dGxpbmVDb2xvcjtcXG52YXJ5aW5nIGZsb2F0IHNjYWxlO1xcblxcbmNvbnN0IHZlYzQgRElTQ0FSRF9QT1NJVElPTiA9IHZlYzQoMiwgMiwgMiwgMSk7XFxuXFxuY29uc3QgZmxvYXQgWVZfSF8xXzAgPSAxLjk5OTk2OTQ4MjQyMTg3NTtcXG5jb25zdCBmbG9hdCBZVl9MXzFfMSA9IDAuMDAwMDMwNTE3MTEyNDYzNzEyNjkyO1xcblxcbmNvbnN0IGZsb2F0IFBJXzFfMiA9IDMuMTQxNTkyNzQxMDEyNTczMjtcXG5cXG5jb25zdCBpbnQgTUFYX1BPTFlMSU5FX1BPSU5UU18xXzMgPSA0O1xcbmNvbnN0IGZsb2F0IElORklOSVRZXzFfNCA9IDEwMDAwMDAuMDsgLy8gbGFyZ2UgZW5vdWdoIGZvciBhIHNlZ21lbnQgbGVuZ3RoIHRvIGNvbnNpZGVyIGl0IGluZmluaXR5XFxuXFxuLyoqXFxuICogUmV0dXJucyB3b3JsZCBjb29yZGluYXRlIChwbHVzIGRlbHRhKSBwcm9qZWN0ZWQgb24gc2NyZWVuLCBpbiBwaXhlbHMuXFxuICovXFxudmVjMiBwcm9qZWN0XzFfNShcXG4gICAgbWF0NCB2aWV3UHJvak1hdHJpeCxcXG4gICAgdmVjMiBsb29rQXRIaWdoLFxcbiAgICB2ZWMyIGxvb2tBdExvdyxcXG4gICAgdmVjMiBwaXhlbFNpemUsXFxuICAgIHZlYzIgcG9pbnRIaWdoLFxcbiAgICB2ZWMyIHBvaW50TG93LFxcbiAgICB2ZWMyIGRlbHRhXFxuKSB7XFxuICAgIHZlYzQgcG9zaXRpb24gPSB2aWV3UHJvak1hdHJpeCAqIHZlYzQoXFxuICAgICAgICAgICAgWVZfSF8xXzAgKiAocG9pbnRIaWdoIC0gbG9va0F0SGlnaCkgKyBZVl9MXzFfMSAqIChwb2ludExvdyAtIGxvb2tBdExvdykgKyBkZWx0YSxcXG4gICAgICAgICAgICAwLFxcbiAgICAgICAgICAgIDFcXG4gICAgICAgICk7XFxuICAgIHZlYzIgcHJvamVjdGVkID0gcG9zaXRpb24ueHkgLyBwb3NpdGlvbi53O1xcbiAgICByZXR1cm4gcHJvamVjdGVkIC8gcGl4ZWxTaXplO1xcbn1cXG5cXG4vKipcXG4gKiBFYWNoIHBvaW50IG9mIHRoZSBwb2x5bGluZSBpcyBlbmNvZGVkIGFzIGEgdmVjdG9yIGZyb20gdGhlIHBvbHlsaW5lIGNlbnRlciBieSBpdHMgbm9ybWFsaXplZCBhbmdsZSBhbmQgdGhlIHJhdGlvIG9mXFxuICogaXRzIGxlbmd0aCB0byB0aGUgcG9seWxpbmUncyBsZW5ndGguXFxuICovXFxudmVjMiBkZWNvZGVQb2x5bGluZURlbHRhc18xXzYoZmxvYXQgcmF0aW8sIGZsb2F0IGFuZ2xlLCBmbG9hdCBwb2x5bGluZUxlbmd0aCkge1xcbiAgICAvLyBkZW5vcm1hbGl6ZSBhbmdsZSBiYWNrIHRvIHJhZGlhbnNcXG4gICAgZmxvYXQgYSA9IGFuZ2xlICogMi4wICogUElfMV8yIC0gUElfMV8yO1xcbiAgICAvLyBsZW5ndGggb2YgYSB2ZWN0b3JcXG4gICAgZmxvYXQgbGVuID0gcmF0aW8gKiBwb2x5bGluZUxlbmd0aDtcXG4gICAgLy8gcmVzdG9yZWQgcG9pbnQncyAoeCwgeSkgY29vcmRpbmF0ZXNcXG4gICAgcmV0dXJuIHZlYzIoY29zKGEpLCBzaW4oYSkpICogbGVuO1xcbn1cXG5cXG4vKipcXG4gKiBQcm9qZWN0cyBzcGVjaWZpYyBjdXJ2ZWQgbGFiZWwgdmVydGV4IG9udG8gdGhlIHNjcmVlbi4gVGhlIGxhYmVsIGlzIGxheW91dGVkIGJ5IGNlbnRlcmluZyBwb2x5bGluZSBpblxcbiAqIHRoZSB2ZXJ0ZXhQb3NIaWdoL3ZlcnRleFBvc0xvdyBhbmQgb3RoZXIgcG9pbnRzIGFyZSB1c2VkIHRvIGd1aWRlIGNvbmNyZXRlIGdyeXBoIHZlcnRleC5cXG4gKiBOdW1iZXIgb2YgcG9seWxpbmUgcG9pbnRzIGlzIGhhcmRjb2RlZCB0byBwYXNzIHRoZW0gaW4gYXR0cmlidXRlcy5cXG4gKi9cXG52ZWM0IHByb2plY3RDdXJ2ZWRMYWJlbFZlcnRleF8xXzcoXFxuICAgIG1hdDQgdmlld1Byb2pNYXRyaXgsXFxuICAgIHZlYzIgbG9va0F0SGlnaCxcXG4gICAgdmVjMiBsb29rQXRMb3csXFxuICAgIHZlYzIgcHhTaXplLFxcbiAgICB2ZWMyIHBvc0hpZ2gsXFxuICAgIHZlYzIgcG9zTG93LFxcbiAgICB2ZWMyIGRpc3BsYWNlbWVudCxcXG4gICAgZmxvYXQgbGluZURpc3BsYWNlbWVudCxcXG4gICAgZmxvYXQgcG9seWxpbmVMZW5ndGgsXFxuICAgIHZlYzQgbGVmdFBvbHlsaW5lUmF0aW9zLFxcbiAgICB2ZWM0IGxlZnRQb2x5bGluZUFuZ2xlcyxcXG4gICAgdmVjNCByaWdodFBvbHlsaW5lUmF0aW9zLFxcbiAgICB2ZWM0IHJpZ2h0UG9seWxpbmVBbmdsZXNcXG4pIHtcXG4gICAgdmVjMiBwb2x5bGluZURlbHRhc1tNQVhfUE9MWUxJTkVfUE9JTlRTXzFfM107XFxuICAgIHZlYzIgcG9zaXRpb24gPSBwcm9qZWN0XzFfNSh2aWV3UHJvak1hdHJpeCwgbG9va0F0SGlnaCwgbG9va0F0TG93LCBweFNpemUsIHBvc0hpZ2gsIHBvc0xvdywgdmVjMigwLCAwKSk7XFxuICAgIGZsb2F0IHJlbWFpbmluZ0xlbmd0aCA9IGFicyhsaW5lRGlzcGxhY2VtZW50KTtcXG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCBNQVhfUE9MWUxJTkVfUE9JTlRTXzFfMzsgaSsrKSB7XFxuICAgICAgICB2ZWMyIHByb2plY3RlZFBvaW50O1xcblxcbiAgICAgICAgLy8gZmlndXJlIG91dCB0aGUgZGlyZWN0aW9uIChsZWZ0L3JpZ2h0KSBhdCB0aGUgZmlyc3Qgc3RlcFxcbiAgICAgICAgaWYgKGkgPT0gMCkge1xcbiAgICAgICAgICAgIHByb2plY3RlZFBvaW50ID0gcHJvamVjdF8xXzUoXFxuICAgICAgICAgICAgICAgIHZpZXdQcm9qTWF0cml4LFxcbiAgICAgICAgICAgICAgICBsb29rQXRIaWdoLFxcbiAgICAgICAgICAgICAgICBsb29rQXRMb3csXFxuICAgICAgICAgICAgICAgIHB4U2l6ZSxcXG4gICAgICAgICAgICAgICAgcG9zSGlnaCxcXG4gICAgICAgICAgICAgICAgcG9zTG93LFxcbiAgICAgICAgICAgICAgICBkZWNvZGVQb2x5bGluZURlbHRhc18xXzYocmlnaHRQb2x5bGluZVJhdGlvc1swXSwgcmlnaHRQb2x5bGluZUFuZ2xlc1swXSwgcG9seWxpbmVMZW5ndGgpXFxuICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICBib29sIGlzUmlnaHRQYXJ0ID0gbGluZURpc3BsYWNlbWVudCA+IDAuMDtcXG4gICAgICAgICAgICBib29sIGlzSW52ZXJ0ZWQgPSBwcm9qZWN0ZWRQb2ludC54IDwgcG9zaXRpb24ueDtcXG5cXG4gICAgICAgICAgICAvLyB0aGUgbWFwIGNvdWxkIGJlIHJvdGF0ZWQgYW5kIGN1cnZlZCBsYWJlbCBzaG91bGQgY2hhbmdlIGl0cyBkaXJlY3Rpb24gaWYgdGhleSBnb3QgdXBzaWRlIGRvd25cXG4gICAgICAgICAgICAvLyB1c2luZyBjZW50ZXIgc2VnbWVudCB0byBpZGVudGlmeSB0aGlzIGNhc2UgaXMgYW4gYXBwcm94aW1hdGlvbiAoaWRlYWxseSB3ZSBzaG91bGQgY2hlY2sgYWxsIHNlZ21lbnRzKVxcbiAgICAgICAgICAgIGlmIChpc1JpZ2h0UGFydCBeXiBpc0ludmVydGVkKSB7XFxuICAgICAgICAgICAgICAgIHBvbHlsaW5lRGVsdGFzWzBdID0gZGVjb2RlUG9seWxpbmVEZWx0YXNfMV82KHJpZ2h0UG9seWxpbmVSYXRpb3NbMF0sIHJpZ2h0UG9seWxpbmVBbmdsZXNbMF0sIHBvbHlsaW5lTGVuZ3RoKTtcXG4gICAgICAgICAgICAgICAgcG9seWxpbmVEZWx0YXNbMV0gPSBkZWNvZGVQb2x5bGluZURlbHRhc18xXzYocmlnaHRQb2x5bGluZVJhdGlvc1sxXSwgcmlnaHRQb2x5bGluZUFuZ2xlc1sxXSwgcG9seWxpbmVMZW5ndGgpO1xcbiAgICAgICAgICAgICAgICBwb2x5bGluZURlbHRhc1syXSA9IGRlY29kZVBvbHlsaW5lRGVsdGFzXzFfNihyaWdodFBvbHlsaW5lUmF0aW9zWzJdLCByaWdodFBvbHlsaW5lQW5nbGVzWzJdLCBwb2x5bGluZUxlbmd0aCk7XFxuICAgICAgICAgICAgICAgIHBvbHlsaW5lRGVsdGFzWzNdID0gZGVjb2RlUG9seWxpbmVEZWx0YXNfMV82KHJpZ2h0UG9seWxpbmVSYXRpb3NbM10sIHJpZ2h0UG9seWxpbmVBbmdsZXNbM10sIHBvbHlsaW5lTGVuZ3RoKTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBwb2x5bGluZURlbHRhc1swXSA9IGRlY29kZVBvbHlsaW5lRGVsdGFzXzFfNihsZWZ0UG9seWxpbmVSYXRpb3NbMF0sIGxlZnRQb2x5bGluZUFuZ2xlc1swXSwgcG9seWxpbmVMZW5ndGgpO1xcbiAgICAgICAgICAgICAgICBwb2x5bGluZURlbHRhc1sxXSA9IGRlY29kZVBvbHlsaW5lRGVsdGFzXzFfNihsZWZ0UG9seWxpbmVSYXRpb3NbMV0sIGxlZnRQb2x5bGluZUFuZ2xlc1sxXSwgcG9seWxpbmVMZW5ndGgpO1xcbiAgICAgICAgICAgICAgICBwb2x5bGluZURlbHRhc1syXSA9IGRlY29kZVBvbHlsaW5lRGVsdGFzXzFfNihsZWZ0UG9seWxpbmVSYXRpb3NbMl0sIGxlZnRQb2x5bGluZUFuZ2xlc1syXSwgcG9seWxpbmVMZW5ndGgpO1xcbiAgICAgICAgICAgICAgICBwb2x5bGluZURlbHRhc1szXSA9IGRlY29kZVBvbHlsaW5lRGVsdGFzXzFfNihsZWZ0UG9seWxpbmVSYXRpb3NbM10sIGxlZnRQb2x5bGluZUFuZ2xlc1szXSwgcG9seWxpbmVMZW5ndGgpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAvLyB0aGUgZmlyc3QgcmlnaHQgcG9pbnQgb2YgdGhlIHNlZ21lbnQgYWxyZWFkeSBjYWxjdWxhdGVkLFxcbiAgICAgICAgICAgIC8vIHJlY2FsY3VsYXRlIHRoZSBwb2ludCBpZiB0aGlzIHBhcnQgb2YgdGhlIGxhYmVsIGdvZXMgb3RoZXIgZGlyZWN0aW9uXFxuICAgICAgICAgICAgaWYgKCEoaXNSaWdodFBhcnQgJiYgIWlzSW52ZXJ0ZWQpICYmICEoIWlzUmlnaHRQYXJ0ICYmIGlzSW52ZXJ0ZWQpKSB7XFxuICAgICAgICAgICAgICAgIHByb2plY3RlZFBvaW50ID0gcHJvamVjdF8xXzUodmlld1Byb2pNYXRyaXgsIGxvb2tBdEhpZ2gsIGxvb2tBdExvdywgcHhTaXplLCBwb3NIaWdoLCBwb3NMb3csIHBvbHlsaW5lRGVsdGFzW2ldKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHByb2plY3RlZFBvaW50ID0gcHJvamVjdF8xXzUodmlld1Byb2pNYXRyaXgsIGxvb2tBdEhpZ2gsIGxvb2tBdExvdywgcHhTaXplLCBwb3NIaWdoLCBwb3NMb3csIHBvbHlsaW5lRGVsdGFzW2ldKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZlYzIgc2VnbWVudCA9IHByb2plY3RlZFBvaW50IC0gcG9zaXRpb247XFxuICAgICAgICBib29sIGlzTGFzdCA9IGkgPT0gKE1BWF9QT0xZTElORV9QT0lOVFNfMV8zIC0gMSk7XFxuICAgICAgICBmbG9hdCBzZWdtZW50TGVuZ3RoID0gKGlzTGFzdCB8fCAocG9seWxpbmVEZWx0YXNbaSArIDFdID09IHZlYzIoMCwgMCkpKSA/IElORklOSVRZXzFfNCA6IGxlbmd0aChzZWdtZW50KTtcXG5cXG4gICAgICAgIGlmIChzZWdtZW50TGVuZ3RoID4gcmVtYWluaW5nTGVuZ3RoKSB7XFxuICAgICAgICAgICAgZmxvYXQgc2lnbkZhY3RvciA9IGxpbmVEaXNwbGFjZW1lbnQgPiAwLjAgPyAxLjAgOiAtMS4wO1xcbiAgICAgICAgICAgIHZlYzIgZGlyZWN0aW9uID0gbm9ybWFsaXplKHNlZ21lbnQpO1xcbiAgICAgICAgICAgIHZlYzIgbm9ybWFsID0gdmVjMigtZGlyZWN0aW9uLnksIGRpcmVjdGlvbi54KTtcXG5cXG4gICAgICAgICAgICBwb3NpdGlvbiArPSBkaXJlY3Rpb24gKiByZW1haW5pbmdMZW5ndGg7XFxuICAgICAgICAgICAgcG9zaXRpb24gKz0gc2lnbkZhY3RvciAqIGRpcmVjdGlvbiAqIGRpc3BsYWNlbWVudC54O1xcbiAgICAgICAgICAgIHBvc2l0aW9uICs9IHNpZ25GYWN0b3IgKiBub3JtYWwgKiBkaXNwbGFjZW1lbnQueTtcXG5cXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgcmVtYWluaW5nTGVuZ3RoIC09IHNlZ21lbnRMZW5ndGg7XFxuICAgICAgICAgICAgcG9zaXRpb24gKz0gc2VnbWVudDtcXG4gICAgICAgIH1cXG4gICAgfVxcblxcbiAgICByZXR1cm4gdmVjNChwb3NpdGlvbiAqIHB4U2l6ZSwgMC4wLCAxLjApO1xcbn1cXG5cXG5cXG5cXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgICBmbG9hdCB2aXNpYmlsaXR5QWxwaGEgPSB0ZXh0dXJlMkQodmlzaWJpbGl0eSwgdmVydGV4SWQueHkgKyBpZEhhbGZQeFNpemUpLmE7XFxuICAgIGlmICh2aXNpYmlsaXR5QWxwaGEgIT0gMC4wKSB7XFxuICAgICAgICB2ZWMyIHZlcnRleERpc3BsYWNlbWVudCA9IHZlcnRleERpc3BsYWNlbWVudHMueHk7XFxuICAgICAgICBmbG9hdCB2ZXJ0ZXhMaW5lRGlzcGxhY2VtZW50ID0gdmVydGV4RGlzcGxhY2VtZW50cy56O1xcbiAgICAgICAgZmxvYXQgcG9seWxpbmVMZW5ndGggPSBwb2x5bGluZUxlbmd0aF92ZXJ0ZXhTY2FsZVswXTtcXG4gICAgICAgIGZsb2F0IHZlcnRleFNjYWxlID0gcG9seWxpbmVMZW5ndGhfdmVydGV4U2NhbGVbMV07XFxuICAgICAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3RDdXJ2ZWRMYWJlbFZlcnRleF8xXzcoXFxuICAgICAgICAgICAgdmlld1Byb2pNYXRyaXgsXFxuICAgICAgICAgICAgbG9va0F0SGlnaCxcXG4gICAgICAgICAgICBsb29rQXRMb3csXFxuICAgICAgICAgICAgcGl4ZWxTaXplLFxcbiAgICAgICAgICAgIHZlcnRleFBvc0hpZ2gsXFxuICAgICAgICAgICAgdmVydGV4UG9zTG93LFxcbiAgICAgICAgICAgIHZlcnRleERpc3BsYWNlbWVudCxcXG4gICAgICAgICAgICB2ZXJ0ZXhMaW5lRGlzcGxhY2VtZW50LFxcbiAgICAgICAgICAgIHBvbHlsaW5lTGVuZ3RoLFxcbiAgICAgICAgICAgIGxlZnRQb2x5bGluZVJhdGlvcyxcXG4gICAgICAgICAgICBsZWZ0UG9seWxpbmVBbmdsZXMsXFxuICAgICAgICAgICAgcmlnaHRQb2x5bGluZVJhdGlvcyxcXG4gICAgICAgICAgICByaWdodFBvbHlsaW5lQW5nbGVzXFxuICAgICAgICApO1xcblxcbiAgICAgICAgdXYgPSB2ZXJ0ZXhVVjtcXG4gICAgICAgIGNvbG9yID0gdmVydGV4Q29sb3I7XFxuICAgICAgICBvdXRsaW5lQ29sb3IgPSB2ZXJ0ZXhPdXRsaW5lQ29sb3I7XFxuICAgICAgICBzY2FsZSA9IHZlcnRleFNjYWxlO1xcblxcbiAgICAgICAgY29sb3IuYSAqPSB2aXNpYmlsaXR5QWxwaGE7XFxuICAgICAgICBvdXRsaW5lQ29sb3IuYSAqPSB2aXNpYmlsaXR5QWxwaGE7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICBnbF9Qb3NpdGlvbiA9IERJU0NBUkRfUE9TSVRJT047XFxuICAgIH1cXG59XFxuXCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9sYWJlbC9zaGFkZXIvY3VydmVkX2xhYmVsLnZlcnRcbi8vIG1vZHVsZSBpZCA9IDEyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgaWNvblZlcnRleFNoYWRlciBmcm9tICcuL3NoYWRlci9pY29uLnZlcnQnO1xyXG5pbXBvcnQgaWNvbkZyYWdtZW50U2hhZGVyIGZyb20gJy4vc2hhZGVyL2ljb24uZnJhZyc7XHJcbmltcG9ydCBJbWFnZVJlbmRlclVuaXQgZnJvbSAnLi4vaW1hZ2UvaW1hZ2VfcmVuZGVyX3VuaXQnO1xyXG4vKipcclxuICogUmVuZGVyZXIgb2YgaWNvbiBwcmltaXRpdmVzLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSWNvblJlbmRlclVuaXQgZXh0ZW5kcyBJbWFnZVJlbmRlclVuaXQge1xyXG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgY2FtZXJhLCBwcmltaXRpdmVQcm92aWRlcikge1xyXG4gICAgICAgIGNvbnN0IHByb2dyYW0gPSBjb250ZXh0LmNyZWF0ZVByb2dyYW0oaWNvblZlcnRleFNoYWRlciwgaWNvbkZyYWdtZW50U2hhZGVyLCB7XHJcbiAgICAgICAgICAgIGF0dHJpYk1hcDoge1xyXG4gICAgICAgICAgICAgICAgdmVydGV4UG9zSGlnaDogMCAvKiBQT1NJVElPTl9ISUdIICovLFxyXG4gICAgICAgICAgICAgICAgdmVydGV4UG9zTG93OiAxIC8qIFBPU0lUSU9OX0xPVyAqLyxcclxuICAgICAgICAgICAgICAgIHZlcnRleERpc3BsYWNlbWVudDogNiAvKiBESVNQTEFDRU1FTlQgKi8sXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhVVjogNCAvKiBVViAqL1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc3VwZXIoY29udGV4dCwgcHJpbWl0aXZlUHJvdmlkZXIsIHByb2dyYW0pO1xyXG4gICAgICAgIHRoaXMuX2NhbWVyYSA9IGNhbWVyYTtcclxuICAgIH1cclxuICAgIF9wcmVwYXJlUHJvZ3JhbShwcm9ncmFtLCB2aWV3UHJvak1hdHJpeCwgY2FtZXJhUG9zaXRpb25zKSB7XHJcbiAgICAgICAgc3VwZXIuX3ByZXBhcmVQcm9ncmFtKHByb2dyYW0sIHZpZXdQcm9qTWF0cml4LCBjYW1lcmFQb3NpdGlvbnMpO1xyXG4gICAgICAgIHByb2dyYW0uc2V0VmVjdG9yMlVuaWZvcm0oJ3BpeGVsU2l6ZScsIHRoaXMuX2NhbWVyYS5waXhlbFNpemUpO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL2ljb24vaWNvbl9yZW5kZXJfdW5pdC50c1xuLy8gbW9kdWxlIGlkID0gMTIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleFBvc0hpZ2g7XFxuYXR0cmlidXRlIHZlYzIgdmVydGV4UG9zTG93O1xcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleERpc3BsYWNlbWVudDtcXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhVVjtcXG5cXG51bmlmb3JtIHZlYzIgbG9va0F0SGlnaDtcXG51bmlmb3JtIHZlYzIgbG9va0F0TG93O1xcbnVuaWZvcm0gbWF0NCB2aWV3UHJvak1hdHJpeDtcXG51bmlmb3JtIHZlYzIgcGl4ZWxTaXplO1xcblxcbnZhcnlpbmcgdmVjMiB1djtcXG5cXG5jb25zdCBmbG9hdCBZVl9IID0gMS45OTk5Njk0ODI0MjE4NzU7XFxuY29uc3QgZmxvYXQgWVZfTCA9IDAuMDAwMDMwNTE3MTEyNDYzNzEyNjkyO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgdmVjNCBwb3NpdGlvbiA9IHZpZXdQcm9qTWF0cml4ICogdmVjNChcXG4gICAgICAgIFlWX0ggKiAodmVydGV4UG9zSGlnaCAtIGxvb2tBdEhpZ2gpICtcXG4gICAgICAgICAgICBZVl9MICogKHZlcnRleFBvc0xvdyAtIGxvb2tBdExvdyksXFxuICAgICAgICAwLFxcbiAgICAgICAgMVxcbiAgICApO1xcbiAgICBwb3NpdGlvbiA9IHZlYzQocG9zaXRpb24ueHkgLyBwb3NpdGlvbi53LCAwLjAsIDEuMCk7XFxuXFxuICAgIGdsX1Bvc2l0aW9uID0gcG9zaXRpb24gKyB2ZWM0KHZlcnRleERpc3BsYWNlbWVudCAqIHBpeGVsU2l6ZSwgMC4wLCAwLjApO1xcblxcbiAgICB1diA9IHZlcnRleFVWO1xcbn1cXG5cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL2ljb24vc2hhZGVyL2ljb24udmVydFxuLy8gbW9kdWxlIGlkID0gMTIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbnVuaWZvcm0gc2FtcGxlcjJEIGF0bGFzO1xcbnVuaWZvcm0gdmVjMiBhdGxhc1NpemU7XFxuXFxudmFyeWluZyB2ZWMyIHV2O1xcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKGF0bGFzLCB1diAvIGF0bGFzU2l6ZSk7XFxufVxcblwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvaWNvbi9zaGFkZXIvaWNvbi5mcmFnXG4vLyBtb2R1bGUgaWQgPSAxMjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IGltYWdlVmVydGV4U2hhZGVyIGZyb20gJy4vc2hhZGVyL2ltYWdlLnZlcnQnO1xyXG5pbXBvcnQgaW1hZ2VGcmFnbWVudFNoYWRlciBmcm9tICcuL3NoYWRlci9pbWFnZS5mcmFnJztcclxuaW1wb3J0ICogYXMgdmVjMiBmcm9tICcuLi8uLi8uLi9tYXRoL3ZlY3RvcjInO1xyXG5pbXBvcnQgV29ybGRQcmltaXRpdmVSZW5kZXJVbml0IGZyb20gJy4uL3dvcmxkX3ByaW1pdGl2ZV9yZW5kZXJfdW5pdCc7XHJcbmltcG9ydCBSZW5kZXJTdGF0ZSBmcm9tICcuLi8uLi8uLi9yZW5kZXIvc3RhdGUnO1xyXG5pbXBvcnQgeyBCTEVORF9PVkVSX1JFTkRFUl9TVEFURSB9IGZyb20gJy4uLy4uLy4uL3JlbmRlci9zdGF0ZSc7XHJcbmNvbnN0IFJFTkRFUl9TVEFURSA9IG5ldyBSZW5kZXJTdGF0ZShCTEVORF9PVkVSX1JFTkRFUl9TVEFURSk7XHJcbmZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRQcm9ncmFtKGNvbnRleHQpIHtcclxuICAgIHJldHVybiBjb250ZXh0LmNyZWF0ZVByb2dyYW0oaW1hZ2VWZXJ0ZXhTaGFkZXIsIGltYWdlRnJhZ21lbnRTaGFkZXIsIHtcclxuICAgICAgICBhdHRyaWJNYXA6IHtcclxuICAgICAgICAgICAgdmVydGV4UG9zSGlnaDogMCAvKiBQT1NJVElPTl9ISUdIICovLFxyXG4gICAgICAgICAgICB2ZXJ0ZXhQb3NMb3c6IDEgLyogUE9TSVRJT05fTE9XICovLFxyXG4gICAgICAgICAgICB2ZXJ0ZXhVVjogNCAvKiBVViAqL1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBSZW5kZXJlciBvZiBpbWFnZSBwcmltaXRpdmVzLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW1hZ2VSZW5kZXJVbml0IGV4dGVuZHMgV29ybGRQcmltaXRpdmVSZW5kZXJVbml0IHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIHByaW1pdGl2ZVByb3ZpZGVyLCBwcm9ncmFtID0gY3JlYXRlRGVmYXVsdFByb2dyYW0oY29udGV4dCkpIHtcclxuICAgICAgICBzdXBlcihjb250ZXh0LCBSRU5ERVJfU1RBVEUsIHByb2dyYW0sIHByaW1pdGl2ZVByb3ZpZGVyKTtcclxuICAgICAgICB0aGlzLl9hdGxhc1NpemVVbmlmb3JtID0gdmVjMi5jcmVhdGUoMCwgMCk7XHJcbiAgICAgICAgY29udGV4dC5iaW5kUHJvZ3JhbShwcm9ncmFtKTtcclxuICAgICAgICBwcm9ncmFtLnNldEludFNjYWxhclVuaWZvcm0oJ2F0bGFzJywgMCk7XHJcbiAgICB9XHJcbiAgICBfcmVuZGVyQmF0Y2gobWVtb3J5QmF0Y2gpIHtcclxuICAgICAgICBjb25zdCBhdGxhcyA9IG1lbW9yeUJhdGNoLmZpcnN0UHJpbWl0aXZlLmF0bGFzO1xyXG4gICAgICAgIHRoaXMuX2F0bGFzU2l6ZVVuaWZvcm0ueCA9IGF0bGFzLndpZHRoO1xyXG4gICAgICAgIHRoaXMuX2F0bGFzU2l6ZVVuaWZvcm0ueSA9IGF0bGFzLmhlaWdodDtcclxuICAgICAgICBpZiAoYXRsYXMuaXNEaXJ0eSkge1xyXG4gICAgICAgICAgICBhdGxhcy5zeW5jVGV4dHVyZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9wcm9ncmFtLnNldFZlY3RvcjJVbmlmb3JtKCdhdGxhc1NpemUnLCB0aGlzLl9hdGxhc1NpemVVbmlmb3JtKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRUZXh0dXJlVW5pdCgwKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRUZXh0dXJlKGF0bGFzLnRleHR1cmUpO1xyXG4gICAgICAgIHN1cGVyLl9yZW5kZXJCYXRjaChtZW1vcnlCYXRjaCk7XHJcbiAgICB9XHJcbiAgICBfY2FuQmF0Y2hBZGphY2VudFByaW1pdGl2ZXMoYSwgYikge1xyXG4gICAgICAgIHJldHVybiBzdXBlci5fY2FuQmF0Y2hBZGphY2VudFByaW1pdGl2ZXMoYSwgYikgJiYgKGEuYXRsYXMgPT09IGIuYXRsYXMpO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL2ltYWdlL2ltYWdlX3JlbmRlcl91bml0LnRzXG4vLyBtb2R1bGUgaWQgPSAxMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcIiN2ZXJzaW9uIDEwMFxcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxuYXR0cmlidXRlIHZlYzIgdmVydGV4UG9zSGlnaDtcXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhQb3NMb3c7XFxuYXR0cmlidXRlIHZlYzIgdmVydGV4VVY7XFxuXFxudW5pZm9ybSB2ZWMyIGxvb2tBdEhpZ2g7XFxudW5pZm9ybSB2ZWMyIGxvb2tBdExvdztcXG51bmlmb3JtIG1hdDQgdmlld1Byb2pNYXRyaXg7XFxuXFxudmFyeWluZyB2ZWMyIHV2O1xcblxcbmNvbnN0IGZsb2F0IFlWX0ggPSAxLjk5OTk2OTQ4MjQyMTg3NTtcXG5jb25zdCBmbG9hdCBZVl9MID0gMC4wMDAwMzA1MTcxMTI0NjM3MTI2OTI7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICB2ZWM0IHBvc2l0aW9uID0gdmlld1Byb2pNYXRyaXggKiB2ZWM0KFxcbiAgICAgICAgWVZfSCAqICh2ZXJ0ZXhQb3NIaWdoIC0gbG9va0F0SGlnaCkgK1xcbiAgICAgICAgICAgIFlWX0wgKiAodmVydGV4UG9zTG93IC0gbG9va0F0TG93KSxcXG4gICAgICAgIDAsXFxuICAgICAgICAxXFxuICAgICk7XFxuXFxuICAgIGdsX1Bvc2l0aW9uID0gcG9zaXRpb247XFxuXFxuICAgIHV2ID0gdmVydGV4VVY7XFxufVxcblwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvaW1hZ2Uvc2hhZGVyL2ltYWdlLnZlcnRcbi8vIG1vZHVsZSBpZCA9IDEyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwiI3ZlcnNpb24gMTAwXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCBhdGxhcztcXG51bmlmb3JtIHZlYzIgYXRsYXNTaXplO1xcblxcbnZhcnlpbmcgdmVjMiB1djtcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRChhdGxhcywgdXYgLyBhdGxhc1NpemUpO1xcblxcbiAgICBpZiAoZ2xfRnJhZ0NvbG9yLmEgPT0gMC4wKSB7XFxuICAgICAgICBkaXNjYXJkO1xcbiAgICB9XFxufVxcblwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvaW1hZ2Uvc2hhZGVyL2ltYWdlLmZyYWdcbi8vIG1vZHVsZSBpZCA9IDEyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgbW9kZWxWZXJ0ZXhTaGFkZXIgZnJvbSAnLi9zaGFkZXIvbW9kZWwudmVydCc7XHJcbmltcG9ydCBtb2RlbEZyYWdtZW50U2hhZGVyIGZyb20gJy4vc2hhZGVyL21vZGVsLmZyYWcnO1xyXG5pbXBvcnQgeyBjcmVhdGVFeHRlbnQyIH0gZnJvbSAnLi4vLi4vLi4vbWF0aC92ZWN0b3IyJztcclxuaW1wb3J0IE92ZXJsYXlSZW5kZXJlciBmcm9tICcuLi9vdmVybGF5L292ZXJsYXlfcmVuZGVyZXInO1xyXG5pbXBvcnQgUmVuZGVyU3RhdGUgZnJvbSAnLi4vLi4vLi4vcmVuZGVyL3N0YXRlJztcclxuaW1wb3J0IFdvcmxkUHJpbWl0aXZlUmVuZGVyVW5pdCBmcm9tICcuLi93b3JsZF9wcmltaXRpdmVfcmVuZGVyX3VuaXQnO1xyXG5jb25zdCBSRU5ERVJfU1RBVEUgPSBuZXcgUmVuZGVyU3RhdGUoe1xyXG4gICAgZGVwdGhUZXN0OiB0cnVlXHJcbn0pO1xyXG4vKipcclxuICogUmVuZGVyZXIgb2YgbW9kZWxzLiBJdCByZW5kZXJzIG1vZGVscyBpbnRvIGEgdGV4dHVyZSB3aXRoIGRlcHRoIHRlc3QgYW5kIHRoZW4gdGhpcyB0ZXh0dXJlIGludG8gdGhlIHJlbmRlciB0YXJnZXQuXHJcbiAqIEl0IGFsbG93cyB0byBzaG93IG9ubHkgdGhlIHRvcCBmYWNldHMgb2Ygc2VtaS10cmFuc3BhcmVudCBvYmplY3RzIHdpdGhvdXQgZXhwb3NpbmcgdGhlaXIgaW5uZXIgc3RydWN0dXJlLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW9kZWxSZW5kZXJVbml0IGV4dGVuZHMgV29ybGRQcmltaXRpdmVSZW5kZXJVbml0IHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIHByaW1pdGl2ZVByb3ZpZGVyKSB7XHJcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IGNvbnRleHQuY3JlYXRlUHJvZ3JhbShtb2RlbFZlcnRleFNoYWRlciwgbW9kZWxGcmFnbWVudFNoYWRlciwge1xyXG4gICAgICAgICAgICBhdHRyaWJNYXA6IHtcclxuICAgICAgICAgICAgICAgIHZlcnRleFBvc0hpZ2g6IDAgLyogUE9TSVRJT05fSElHSCAqLyxcclxuICAgICAgICAgICAgICAgIHZlcnRleFBvc0xvdzogMSAvKiBQT1NJVElPTl9MT1cgKi8sXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhIZWlnaHQ6IDMgLyogSEVJR0hUICovLFxyXG4gICAgICAgICAgICAgICAgdmVydGV4Q29sb3I6IDcgLyogQ09MT1IgKi9cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHN1cGVyKGNvbnRleHQsIFJFTkRFUl9TVEFURSwgcHJvZ3JhbSwgcHJpbWl0aXZlUHJvdmlkZXIpO1xyXG4gICAgICAgIHRoaXMuX291dHB1dFNpemUgPSBjcmVhdGVFeHRlbnQyKC0xLCAtMSk7XHJcbiAgICAgICAgdGhpcy5fb3ZlcmxheVJlbmRlcmVyID0gbmV3IE92ZXJsYXlSZW5kZXJlcihjb250ZXh0KTtcclxuICAgIH1cclxuICAgIHJlbmRlcih0YXJnZXQsIHZpZXdQcm9qTWF0cml4LCBjYW1lcmFQb3NpdGlvbnMpIHtcclxuICAgICAgICB0aGlzLl9zeW5jT3V0cHV0QnVmZmVyKHRhcmdldCk7XHJcbiAgICAgICAgc3VwZXIucmVuZGVyKHRoaXMuX291dHB1dEJ1ZmZlciwgdmlld1Byb2pNYXRyaXgsIGNhbWVyYVBvc2l0aW9ucyk7XHJcbiAgICAgICAgLy8gZG8gbm90IHJ1biB1bm5lY2Vzc2FyeSBjb3B5aW5nIGlmIHRoaXMuX291dHB1dEJ1ZmZlciB3YXMgbm90IHVwZGF0ZWQgKG5vIG1vZGVscyBpbiBzY2VuZT8pXHJcbiAgICAgICAgaWYgKCF0aGlzLl9vdXRwdXRCdWZmZXIuaXNDbGVhcikge1xyXG4gICAgICAgICAgICAvLyBjb3B5IGludG8gdGhlIGZpbmFsIHRhcmdldFxyXG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5UmVuZGVyZXIucmVuZGVyKHRhcmdldCwgdGhpcy5fb3V0cHV0VGV4dHVyZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLl9vdmVybGF5UmVuZGVyZXIuZGVzdHJveSgpO1xyXG4gICAgICAgIGlmICh0aGlzLl9vdXRwdXRUZXh0dXJlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX291dHB1dFRleHR1cmUuZGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fb3V0cHV0RGVwdGhCdWZmZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5fb3V0cHV0RGVwdGhCdWZmZXIuZGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fb3V0cHV0QnVmZmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX291dHB1dEJ1ZmZlci5kZXN0cm95KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcclxuICAgIH1cclxuICAgIF9zeW5jT3V0cHV0QnVmZmVyKHRhcmdldCkge1xyXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgaW50ZXJtZWRpYXRlIHRleHR1cmUgZml0cyB0aGUgb3V0cHV0IHRhcmdldFxyXG4gICAgICAgIGlmICh0aGlzLl9vdXRwdXRTaXplLndpZHRoICE9PSB0YXJnZXQuZ2V0V2lkdGgoKSB8fFxyXG4gICAgICAgICAgICB0aGlzLl9vdXRwdXRTaXplLmhlaWdodCAhPT0gdGFyZ2V0LmdldEhlaWdodCgpKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9vdXRwdXRUZXh0dXJlIHx8IHRoaXMuX291dHB1dERlcHRoQnVmZmVyIHx8IHRoaXMuX291dHB1dEJ1ZmZlcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fb3V0cHV0VGV4dHVyZS5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9vdXRwdXREZXB0aEJ1ZmZlci5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9vdXRwdXRCdWZmZXIuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX291dHB1dFNpemUgPSB7IHdpZHRoOiB0YXJnZXQuZ2V0V2lkdGgoKSwgaGVpZ2h0OiB0YXJnZXQuZ2V0SGVpZ2h0KCkgfTtcclxuICAgICAgICAgICAgdGhpcy5fb3V0cHV0VGV4dHVyZSA9IHRoaXMuX2NvbnRleHQuY3JlYXRlRW1wdHkyRFRleHR1cmUodGhpcy5fb3V0cHV0U2l6ZS53aWR0aCwgdGhpcy5fb3V0cHV0U2l6ZS5oZWlnaHQsIDY0MDggLyogUkdCQSAqLywgNTEyMSAvKiBVTlNJR05FRF9CWVRFICovKTtcclxuICAgICAgICAgICAgdGhpcy5fb3V0cHV0RGVwdGhCdWZmZXIgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZVJlbmRlcmJ1ZmZlcih0aGlzLl9vdXRwdXRTaXplLndpZHRoLCB0aGlzLl9vdXRwdXRTaXplLmhlaWdodCwgMzQwNDEgLyogREVQVEhfU1RFTkNJTCAqLyk7XHJcbiAgICAgICAgICAgIHRoaXMuX291dHB1dEJ1ZmZlciA9IHRoaXMuX2NvbnRleHQuY3JlYXRlRnJhbWVidWZmZXIoe1xyXG4gICAgICAgICAgICAgICAgY29sb3I6IHRoaXMuX291dHB1dFRleHR1cmUsXHJcbiAgICAgICAgICAgICAgICBkZXB0aFN0ZW5jaWw6IHRoaXMuX291dHB1dERlcHRoQnVmZmVyXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT3ZlcnJpZGRlbiBfYmluZFJlbmRlclRhcmdldCgpIHRvIGJpbmQgaW50ZXJtZWRpYXRlIHJlbmRlciB0YXJnZXQgdG8gcmVuZGVyIG1vZGVscyBpbnRvIGFuZFxyXG4gICAgICogbGF0ZXIgcHV0IGl0cyBjb250ZW50IGludG8gdGhlIGZpbmFsIHRhcmdldC5cclxuICAgICAqL1xyXG4gICAgX3ByZXBhcmVSZW5kZXJUYXJnZXQodGFyZ2V0LCB2aWV3UHJvak1hdHJpeCwgY2FtZXJhUG9zaXRpb25zKSB7XHJcbiAgICAgICAgc3VwZXIuX3ByZXBhcmVSZW5kZXJUYXJnZXQodGFyZ2V0LCB2aWV3UHJvak1hdHJpeCwgY2FtZXJhUG9zaXRpb25zKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmNsZWFyQ3VycmVudFRhcmdldCgxNjM4NCAvKiBDT0xPUl9CVUZGRVJfQklUICovIHwgMjU2IC8qIERFUFRIX0JVRkZFUl9CSVQgKi8pO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL21vZGVsL21vZGVsX3JlbmRlcl91bml0LnRzXG4vLyBtb2R1bGUgaWQgPSAxMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcIiN2ZXJzaW9uIDEwMFxcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxuYXR0cmlidXRlIHZlYzMgdmVydGV4UG9zSGlnaDtcXG5hdHRyaWJ1dGUgdmVjMyB2ZXJ0ZXhQb3NMb3c7XFxuYXR0cmlidXRlIGZsb2F0IHZlcnRleEhlaWdodDtcXG5hdHRyaWJ1dGUgdmVjNCB2ZXJ0ZXhDb2xvcjtcXG5cXG51bmlmb3JtIHZlYzIgbG9va0F0SGlnaDtcXG51bmlmb3JtIHZlYzIgbG9va0F0TG93O1xcbnVuaWZvcm0gbWF0NCB2aWV3UHJvak1hdHJpeDtcXG5cXG52YXJ5aW5nIHZlYzQgZ2xvYmFsUG9zO1xcbnZhcnlpbmcgdmVjNCBkaWZmdXNlQ29sb3I7XFxuXFxuY29uc3QgZmxvYXQgWVZfSCA9IDEuOTk5OTY5NDgyNDIxODc1O1xcbmNvbnN0IGZsb2F0IFlWX0wgPSAwLjAwMDAzMDUxNzExMjQ2MzcxMjY5MjtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgICBnbG9iYWxQb3MgPSB2ZWM0KFxcbiAgICAgICAgWVZfSCAqICh2ZXJ0ZXhQb3NIaWdoLnh5IC0gbG9va0F0SGlnaCkgKyBZVl9MICogKHZlcnRleFBvc0xvdy54eSAtIGxvb2tBdExvdyksXFxuICAgICAgICB2ZXJ0ZXhIZWlnaHQsXFxuICAgICAgICAxXFxuICAgICk7XFxuXFxuICAgIGdsX1Bvc2l0aW9uID0gdmlld1Byb2pNYXRyaXggKiBnbG9iYWxQb3M7XFxuICAgIGRpZmZ1c2VDb2xvciA9IHZlcnRleENvbG9yO1xcbn1cXG5cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL21vZGVsL3NoYWRlci9tb2RlbC52ZXJ0XG4vLyBtb2R1bGUgaWQgPSAxMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcIiN2ZXJzaW9uIDEwMFxcblxcbiNleHRlbnNpb24gR0xfT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzIDogcmVxdWlyZVxcblxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxudmFyeWluZyB2ZWM0IGRpZmZ1c2VDb2xvcjtcXG52YXJ5aW5nIHZlYzQgZ2xvYmFsUG9zO1xcblxcbmNvbnN0IHZlYzMgTElHSFRfRElSRUNUSU9OID0gbm9ybWFsaXplKHZlYzMoMC41LCAwLjUsIDEuMCkpO1xcbmNvbnN0IGZsb2F0IExJR0hUX0lOVEVOU0lUWSA9IDAuMztcXG5jb25zdCBmbG9hdCBBTUJJRU5UX0xJR0hUX0lOVEVOU0lUWSA9IDEuMCAtIExJR0hUX0lOVEVOU0lUWTtcXG5jb25zdCBmbG9hdCBIT1JJWk9OVEFMX1BMQU5FX0RJRkZVU0VfSU5URU5TSVRZID1cXG4gICAgQU1CSUVOVF9MSUdIVF9JTlRFTlNJVFkgKyAwLjUgKiBMSUdIVF9JTlRFTlNJVFkgKiAoTElHSFRfRElSRUNUSU9OLnogKyAxLjApO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIHZlYzMgcG9zID0gZ2xvYmFsUG9zLnh5ejtcXG5cXG4gICAgdmVjMyBkeHBvcyA9IG5vcm1hbGl6ZShkRmR4KHBvcykpO1xcbiAgICB2ZWMzIGR5cG9zID0gbm9ybWFsaXplKGRGZHkocG9zKSk7XFxuICAgIHZlYzMgbm9ybWFsID0gbm9ybWFsaXplKGNyb3NzKGR4cG9zLCBkeXBvcykpO1xcblxcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KFxcbiAgICAgICAgZGlmZnVzZUNvbG9yLnJnYiAqIChBTUJJRU5UX0xJR0hUX0lOVEVOU0lUWSArIDAuNSAqIExJR0hUX0lOVEVOU0lUWSAqIChkb3Qobm9ybWFsLCBMSUdIVF9ESVJFQ1RJT04pICsgMS4wKSkgL1xcbiAgICAgICAgICAgIEhPUklaT05UQUxfUExBTkVfRElGRlVTRV9JTlRFTlNJVFksXFxuICAgICAgICBkaWZmdXNlQ29sb3IuYVxcbiAgICApO1xcbn1cXG5cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL21vZGVsL3NoYWRlci9tb2RlbC5mcmFnXG4vLyBtb2R1bGUgaWQgPSAxMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IG92ZXJsYXlWZXJ0ZXhTaGFkZXIgZnJvbSAnLi9zaGFkZXIvb3ZlcmxheS52ZXJ0JztcclxuaW1wb3J0IG92ZXJsYXlGcmFnbWVudFNoYWRlciBmcm9tICcuL3NoYWRlci9vdmVybGF5LmZyYWcnO1xyXG5pbXBvcnQgeyBHbFJlbmRlcmVyIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyL2dsX3JlbmRlcmVyJztcclxuaW1wb3J0IFJlbmRlclN0YXRlIGZyb20gJy4uLy4uLy4uL3JlbmRlci9zdGF0ZSc7XHJcbmltcG9ydCB7IEJMRU5EX09WRVJfUkVOREVSX1NUQVRFIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyL3N0YXRlJztcclxuY29uc3QgUkVOREVSX1NUQVRFID0gbmV3IFJlbmRlclN0YXRlKEJMRU5EX09WRVJfUkVOREVSX1NUQVRFKTtcclxuLyoqXHJcbiAqIFJlbmRlcnMgYSB0ZXh0dXJlIGludG8gYSByZW5kZXIgdGFyZ2V0IHdpdGggT1ZFUiBjb21wb3NpdGluZy4gVGhlIHRleHR1cmUgd2lsbCBjb21wbGV0ZWx5IG92ZXJsYXkgdGhlIHRhcmdldCwgaS5lLlxyXG4gKiBpdCBpcyBzdHJldGNoZWQvc2hyaW5rZWQgdG8gZml0IHRoZSB0YXJnZXQgd2lkdGgvaGVpZ2h0LCBzbyBpZGVhbGx5IHRoZXkgc2hvdWxkIGhhdmUgdGhlIHNhbWUgZGltZW5zaW9ucy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE92ZXJsYXlSZW5kZXJlciBleHRlbmRzIEdsUmVuZGVyZXIge1xyXG4gICAgY29uc3RydWN0b3IoY29udGV4dCkge1xyXG4gICAgICAgIGNvbnN0IHByb2dyYW0gPSBjb250ZXh0LmNyZWF0ZVByb2dyYW0ob3ZlcmxheVZlcnRleFNoYWRlciwgb3ZlcmxheUZyYWdtZW50U2hhZGVyLCB7XHJcbiAgICAgICAgICAgIGF0dHJpYk1hcDoge1xyXG4gICAgICAgICAgICAgICAgdmVydGV4UG9zaXRpb246IDAgLyogUE9TSVRJT04gKi8sXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhVVjogNCAvKiBVViAqL1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc3VwZXIoY29udGV4dCwgUkVOREVSX1NUQVRFLCBwcm9ncmFtKTtcclxuICAgIH1cclxuICAgIF9yZW5kZXIodGV4dHVyZSkge1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFRleHR1cmVVbml0KDApO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFRleHR1cmUodGV4dHVyZSk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kUXVhZFZhbygpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuZHJhd1F1YWQoKTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9vdmVybGF5L292ZXJsYXlfcmVuZGVyZXIudHNcbi8vIG1vZHVsZSBpZCA9IDEzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwiI3ZlcnNpb24gMTAwXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhQb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhVVjtcXG5cXG52YXJ5aW5nIHZlYzIgdXY7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICBnbF9Qb3NpdGlvbiA9IHZlYzQodmVydGV4UG9zaXRpb24sIDAsIDEpO1xcbiAgICB1diA9IHZlcnRleFVWO1xcbn1cXG5cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL292ZXJsYXkvc2hhZGVyL292ZXJsYXkudmVydFxuLy8gbW9kdWxlIGlkID0gMTMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHRleHR1cmU7XFxuXFxudmFyeWluZyB2ZWMyIHV2O1xcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHRleHR1cmUsIHV2KTtcXG59XFxuXCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvcHJpbWl0aXZlcy9vdmVybGF5L3NoYWRlci9vdmVybGF5LmZyYWdcbi8vIG1vZHVsZSBpZCA9IDEzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgdGV4dHVyZWRQb2x5bGluZVZlcnRleFNoYWRlciBmcm9tICcuL3NoYWRlci90ZXh0dXJlZF9wb2x5bGluZS52ZXJ0JztcclxuaW1wb3J0IHRleHR1cmVkUG9seWxpbmVGcmFnbWVudFNoYWRlciBmcm9tICcuL3NoYWRlci90ZXh0dXJlZF9wb2x5bGluZS5mcmFnJztcclxuaW1wb3J0ICogYXMgdmVjMiBmcm9tICcuLi8uLi8uLi9tYXRoL3ZlY3RvcjInO1xyXG5pbXBvcnQgUmVuZGVyU3RhdGUsIHsgQkxFTkRfT1ZFUl9QUkVNVUxUSVBMSUVEX0FMUEhBX1JFTkRFUl9TVEFURSB9IGZyb20gJy4uLy4uLy4uL3JlbmRlci9zdGF0ZSc7XHJcbmltcG9ydCBCYXNlUG9seWxpbmVSZW5kZXJVbml0IGZyb20gJy4vYmFzZV9wb2x5bGluZV9yZW5kZXJfdW5pdCc7XHJcbmNvbnN0IEZJTFRFUl9SQURJVVMgPSAxLjAgLyBkZXZpY2VQaXhlbFJhdGlvO1xyXG5jb25zdCBSRU5ERVJfU1RBVEUgPSBuZXcgUmVuZGVyU3RhdGUoQkxFTkRfT1ZFUl9QUkVNVUxUSVBMSUVEX0FMUEhBX1JFTkRFUl9TVEFURSwge1xyXG4gICAgZGVwdGhUZXN0OiB0cnVlLFxyXG4gICAgZGVwdGhNYXNrOiBmYWxzZSxcclxuICAgIGRlcHRoRnVuYzogNTE4IC8qIEdSRUFURVJfT1JfRVFVQUwgKi9cclxufSk7XHJcbi8qKlxyXG4gKiBSZW5kZXJlciBvZiBwb2x5bGluZSBwcmltaXRpdmVzLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGV4dHVyZWRQb2x5bGluZVJlbmRlclVuaXQgZXh0ZW5kcyBCYXNlUG9seWxpbmVSZW5kZXJVbml0IHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIGNhbWVyYSwgcHJpbWl0aXZlUHJvdmlkZXIpIHtcclxuICAgICAgICBjb25zdCBwcm9ncmFtID0gY29udGV4dC5jcmVhdGVQcm9ncmFtKHRleHR1cmVkUG9seWxpbmVWZXJ0ZXhTaGFkZXIsIHRleHR1cmVkUG9seWxpbmVGcmFnbWVudFNoYWRlciwge1xyXG4gICAgICAgICAgICBkZWZpbmVzOiB7XHJcbiAgICAgICAgICAgICAgICBGSUxURVJfUkFESVVTOiBgZmxvYXQoJHtGSUxURVJfUkFESVVTfSlgXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGF0dHJpYk1hcDoge1xyXG4gICAgICAgICAgICAgICAgdmVydGV4UG9zSGlnaDogMCAvKiBQT1NJVElPTl9ISUdIICovLFxyXG4gICAgICAgICAgICAgICAgdmVydGV4UG9zTG93OiAxIC8qIFBPU0lUSU9OX0xPVyAqLyxcclxuICAgICAgICAgICAgICAgIHZlcnRleERpc3BsYWNlbWVudDogNiAvKiBESVNQTEFDRU1FTlQgKi8sXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhVVjogNCAvKiBVViAqLyxcclxuICAgICAgICAgICAgICAgIHZlcnRleFpJbmRleDogOSAvKiBQUklPUklUWSAqLyxcclxuICAgICAgICAgICAgICAgIHZlcnRleEhhbGZXaWR0aDogMTEgLyogQVVYICovLFxyXG4gICAgICAgICAgICAgICAgdmVydGV4UGF0dGVybjogMTIgLyogQVVYMSAqLyxcclxuICAgICAgICAgICAgICAgIHZlcnRleFBhdHRlcm5IYWxmSGVpZ2h0OiAxMyAvKiBBVVgyICovXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBzdXBlcihjb250ZXh0LCBSRU5ERVJfU1RBVEUsIHByb2dyYW0sIHByaW1pdGl2ZVByb3ZpZGVyLCBjYW1lcmEpO1xyXG4gICAgICAgIHRoaXMuX2F0bGFzU2l6ZVVuaWZvcm0gPSB2ZWMyLmNyZWF0ZSgwLCAwKTtcclxuICAgICAgICBjb250ZXh0LmJpbmRQcm9ncmFtKHByb2dyYW0pO1xyXG4gICAgICAgIHByb2dyYW0uc2V0SW50U2NhbGFyVW5pZm9ybSgnYXRsYXMnLCAwKTtcclxuICAgIH1cclxuICAgIF9yZW5kZXJCYXRjaChtZW1vcnlCYXRjaCkge1xyXG4gICAgICAgIGNvbnN0IGF0bGFzID0gbWVtb3J5QmF0Y2guZmlyc3RQcmltaXRpdmUuYXRsYXM7XHJcbiAgICAgICAgdGhpcy5fYXRsYXNTaXplVW5pZm9ybS54ID0gYXRsYXMud2lkdGg7XHJcbiAgICAgICAgdGhpcy5fYXRsYXNTaXplVW5pZm9ybS55ID0gYXRsYXMuaGVpZ2h0O1xyXG4gICAgICAgIGlmIChhdGxhcy5pc0RpcnR5KSB7XHJcbiAgICAgICAgICAgIGF0bGFzLnN5bmNUZXh0dXJlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3Byb2dyYW0uc2V0VmVjdG9yMlVuaWZvcm0oJ2F0bGFzU2l6ZScsIHRoaXMuX2F0bGFzU2l6ZVVuaWZvcm0pO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFRleHR1cmVVbml0KDApO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFRleHR1cmUoYXRsYXMudGV4dHVyZSk7XHJcbiAgICAgICAgc3VwZXIuX3JlbmRlckJhdGNoKG1lbW9yeUJhdGNoKTtcclxuICAgIH1cclxuICAgIF9jYW5CYXRjaEFkamFjZW50UHJpbWl0aXZlcyhhLCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIHN1cGVyLl9jYW5CYXRjaEFkamFjZW50UHJpbWl0aXZlcyhhLCBiKSAmJiAoYS5hdGxhcyA9PT0gYi5hdGxhcyk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvcG9seWxpbmUvdGV4dHVyZWRfcG9seWxpbmVfcmVuZGVyX3VuaXQudHNcbi8vIG1vZHVsZSBpZCA9IDEzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwiI3ZlcnNpb24gMTAwXFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG4jaWZuZGVmIEZJTFRFUl9SQURJVVNcXG4jICAgZXJyb3IgRklMVEVSX1JBRElVUyBtdXN0IGJlIHNldFxcbiNlbmRpZlxcblxcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleFBvc0hpZ2g7XFxuYXR0cmlidXRlIHZlYzIgdmVydGV4UG9zTG93O1xcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleERpc3BsYWNlbWVudDtcXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhVVjtcXG5hdHRyaWJ1dGUgZmxvYXQgdmVydGV4SGFsZldpZHRoO1xcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleFBhdHRlcm47XFxuYXR0cmlidXRlIGZsb2F0IHZlcnRleFBhdHRlcm5IYWxmSGVpZ2h0O1xcbmF0dHJpYnV0ZSBmbG9hdCB2ZXJ0ZXhaSW5kZXg7XFxuXFxudW5pZm9ybSB2ZWMyIGxvb2tBdEhpZ2g7XFxudW5pZm9ybSB2ZWMyIGxvb2tBdExvdztcXG51bmlmb3JtIG1hdDQgdmlld1Byb2pNYXRyaXg7XFxudW5pZm9ybSBmbG9hdCB3b3JsZFRvUHhGYWN0b3I7XFxuXFxudmFyeWluZyB2ZWMyIHV2O1xcbnZhcnlpbmcgZmxvYXQgcztcXG52YXJ5aW5nIGZsb2F0IHBhdHRlcm5MZW5ndGg7XFxudmFyeWluZyBmbG9hdCBsZW47XFxudmFyeWluZyBmbG9hdCBoYWxmV2lkdGg7XFxudmFyeWluZyBmbG9hdCBleHRIYWxmV2lkdGg7XFxudmFyeWluZyBmbG9hdCBwYXR0ZXJuSGFsZkhlaWdodDtcXG5cXG5jb25zdCBmbG9hdCBZVl9IID0gMS45OTk5Njk0ODI0MjE4NzU7XFxuY29uc3QgZmxvYXQgWVZfTCA9IDAuMDAwMDMwNTE3MTEyNDYzNzEyNjkyO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIGhhbGZXaWR0aCA9IHZlcnRleEhhbGZXaWR0aDtcXG4gICAgZXh0SGFsZldpZHRoID0gaGFsZldpZHRoICsgRklMVEVSX1JBRElVUztcXG5cXG4gICAgdmVjNCBwb3NpdGlvbiA9IHZpZXdQcm9qTWF0cml4ICogdmVjNChcXG4gICAgICAgIFlWX0ggKiAodmVydGV4UG9zSGlnaCAtIGxvb2tBdEhpZ2gpICtcXG4gICAgICAgICAgICBZVl9MICogKHZlcnRleFBvc0xvdyAtIGxvb2tBdExvdykgK1xcbiAgICAgICAgICAgICAgICB3b3JsZFRvUHhGYWN0b3IgKiBleHRIYWxmV2lkdGggKiB2ZXJ0ZXhEaXNwbGFjZW1lbnQsXFxuICAgICAgICAwLFxcbiAgICAgICAgMVxcbiAgICApO1xcblxcbiAgICBwb3NpdGlvbi54eSAvPSBwb3NpdGlvbi53O1xcbiAgICBwb3NpdGlvbi56ID0gdmVydGV4WkluZGV4O1xcbiAgICBwb3NpdGlvbi53ID0gMS4wO1xcblxcbiAgICBnbF9Qb3NpdGlvbiA9IHBvc2l0aW9uO1xcblxcbiAgICBwYXR0ZXJuTGVuZ3RoID0gdmVydGV4UGF0dGVyblswXTtcXG4gICAgbGVuID0gdmVydGV4UGF0dGVyblsxXTtcXG4gICAgLy8gRGlzdGFuY2UgdG8gdGhlIGFuYWx5dGljYWwgbGluZSBhbG9uZyBzZWdtZW50J3Mgbm9ybWFsXFxuICAgIHMgPSBzaWduKHZlcnRleFBhdHRlcm5IYWxmSGVpZ2h0KSAqIGV4dEhhbGZXaWR0aDtcXG4gICAgLy8gVGhlIHdob2xlIHRleHR1cmUgaXMgYmVpbmcgc2FtcGxlZCB0byB0aGUgb3JpZ2luYWwgZ2VvbWV0cnkuIEZvciBwaXhlbHMgaW4gdGhlIGV4dGVuZGVkIHBvbHlsaW5lIHBhcnQgdGhlIHRvcG1vc3RcXG4gICAgLy8gKGJvdHRvbW1vc3QpIHRleGVscyBhcmUgdGFrZW4uIFRvIG1ha2UgdGhpcyBoYXBwZW4gdGhlIFVWIHRleHR1cmUgY29vcmRpbmF0ZXMgYXJlIGV4dGVuZGVkIGluIHByb3BvcnRpb24gdG8gdGhlXFxuICAgIC8vIHBvbHlsaW5lIHdpZHRoIGV4dGVuc2lvbi5cXG4gICAgcGF0dGVybkhhbGZIZWlnaHQgPSBhYnModmVydGV4UGF0dGVybkhhbGZIZWlnaHQpO1xcbiAgICB1diA9IHZlYzIodmVydGV4VVYueCwgdmVydGV4VVYueSAtIHZlcnRleFBhdHRlcm5IYWxmSGVpZ2h0ICogRklMVEVSX1JBRElVUyAvIGhhbGZXaWR0aCk7XFxufVxcblwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvcG9seWxpbmUvc2hhZGVyL3RleHR1cmVkX3BvbHlsaW5lLnZlcnRcbi8vIG1vZHVsZSBpZCA9IDEzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwiI3ZlcnNpb24gMTAwXFxuXFxuI2lmbmRlZiBGSUxURVJfUkFESVVTXFxuIyAgIGVycm9yIEZJTFRFUl9SQURJVVMgbXVzdCBiZSBzZXRcXG4jZW5kaWZcXG5cXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbnVuaWZvcm0gc2FtcGxlcjJEIGF0bGFzO1xcbnVuaWZvcm0gdmVjMiBhdGxhc1NpemU7XFxuXFxudmFyeWluZyB2ZWMyIHV2O1xcbnZhcnlpbmcgZmxvYXQgcztcXG52YXJ5aW5nIGZsb2F0IHBhdHRlcm5MZW5ndGg7XFxudmFyeWluZyBmbG9hdCBsZW47XFxudmFyeWluZyBmbG9hdCBoYWxmV2lkdGg7XFxudmFyeWluZyBmbG9hdCBleHRIYWxmV2lkdGg7XFxudmFyeWluZyBmbG9hdCBwYXR0ZXJuSGFsZkhlaWdodDtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgICBsb3dwIGZsb2F0IGFscGhhID0gc21vb3Roc3RlcCgwLjAsIEZJTFRFUl9SQURJVVMgKyBtaW4oRklMVEVSX1JBRElVUywgZXh0SGFsZldpZHRoKSwgZXh0SGFsZldpZHRoIC0gYWJzKHMpKTtcXG5cXG4gICAgLy8gQ2xhbXAgdGV4dHVyZSBVIGNvb3JkaW5hdGUgYnkgMC41cHggZnJvbSBib3RoIHNpZGVzIHRvIGF2b2lkIGJsZWVkaW5nLlxcbiAgICB2ZWMyIHV2QWRqdXN0ZWQgPSB2ZWMyKHV2LnggKyBjbGFtcChtb2QobGVuLCBwYXR0ZXJuTGVuZ3RoKSwgMC41LCBwYXR0ZXJuTGVuZ3RoIC0gMC41KSwgdXYueSk7XFxuICAgIC8vIFVWIHRleHR1cmUgY29vcmRpbmF0ZXMgaGF2ZSBiZWVuIGV4dGVuZGVkIGluIHByb3BvcnRpb24gdG8gdGhlIHBvbHlsaW5lIHdpZHRoIGV4dGVuc2lvbi5cXG4gICAgLy8gQ2xhbXAgdGV4dHVyZSBWIGNvb3JkaW5hdGUgdG8gdGhlIG9yaWdpbmFsIGdlb21ldHJ5IG1pbnVzIDAuNXB4IHRvIGF2b2lkIGJsZWVkaW5nLlxcbiAgICBmbG9hdCBwYXR0ZXJuVG9HZW9tZXRyeUZhY3RvciA9IGhhbGZXaWR0aCAvIHBhdHRlcm5IYWxmSGVpZ2h0O1xcbiAgICBmbG9hdCBjbGFtcFRvID0gaGFsZldpZHRoIC0gMC41ICogcGF0dGVyblRvR2VvbWV0cnlGYWN0b3I7XFxuICAgIGlmIChzdGVwKGNsYW1wVG8sIGFicyhzKSkgPT0gMS4pIHtcXG4gICAgICAgIGZsb2F0IGRlbHRhID0gcyAtIGNsYW1wKHMsIC1jbGFtcFRvLCBjbGFtcFRvKTtcXG4gICAgICAgIHV2QWRqdXN0ZWQueSArPSBkZWx0YSAvIHBhdHRlcm5Ub0dlb21ldHJ5RmFjdG9yO1xcbiAgICB9XFxuXFxuICAgIGxvd3AgdmVjNCBjb2xvciA9IHRleHR1cmUyRChhdGxhcywgdXZBZGp1c3RlZCAvIGF0bGFzU2l6ZSk7XFxuICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yICogYWxwaGE7XFxufVxcblwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvcG9seWxpbmUvc2hhZGVyL3RleHR1cmVkX3BvbHlsaW5lLmZyYWdcbi8vIG1vZHVsZSBpZCA9IDEzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBNQVhfSEFMRl9XSURUSCwgTUFYX0ZJTExfR0FQIH0gZnJvbSAnLi4vLi4vLi4vcHJpbWl0aXZlL3BvbHlsaW5lL3BvbHlsaW5lX2J1ZmZlcl93cml0ZXInO1xyXG5pbXBvcnQgcG9seWxpbmVWZXJ0ZXhTaGFkZXIgZnJvbSAnLi9zaGFkZXIvcG9seWxpbmUudmVydCc7XHJcbmltcG9ydCBwb2x5bGluZUZyYWdtZW50U2hhZGVyIGZyb20gJy4vc2hhZGVyL3BvbHlsaW5lLmZyYWcnO1xyXG5pbXBvcnQgQmFzZVBvbHlsaW5lUmVuZGVyVW5pdCBmcm9tICcuL2Jhc2VfcG9seWxpbmVfcmVuZGVyX3VuaXQnO1xyXG5pbXBvcnQgUmVuZGVyU3RhdGUgZnJvbSAnLi4vLi4vLi4vcmVuZGVyL3N0YXRlJztcclxuLy8gVmFsdWVzIHdhcyBjaG9zZW4gYnkgdGVhbSBjb25zZW5zdXMgaW4gVkVDVE9SLTE5N1xyXG5jb25zdCBGSUxURVJfUkFESVVTID0gMS4wIC8gZGV2aWNlUGl4ZWxSYXRpbzsgLy8gcHhcclxuZXhwb3J0IGNvbnN0IERFRkFVTFRfUkVOREVSX1NUQVRFX1BBUkFNUyA9IHtcclxuICAgIGJsZW5kOiB0cnVlLFxyXG4gICAgYmxlbmRGdW5jU3JjUmdiOiAxIC8qIE9ORSAqLyxcclxuICAgIGJsZW5kRnVuY0RzdFJnYjogNzcxIC8qIE9ORV9NSU5VU19TUkNfQUxQSEEgKi8sXHJcbiAgICBibGVuZEZ1bmNTcmNBbHBoYTogMSAvKiBPTkUgKi8sXHJcbiAgICBibGVuZEZ1bmNEc3RBbHBoYTogNzcxIC8qIE9ORV9NSU5VU19TUkNfQUxQSEEgKi9cclxufTtcclxuLyoqXHJcbiAqIFJlbmRlcmVyIG9mIHBvbHlsaW5lIHByaW1pdGl2ZXMuIEl0cyBkZWZhdWx0IHJlbmRlciBzdGF0ZSBpcyBhaW1lZCB0byByZW5kZXIgb3BhcXVlIHBvbHlsaW5lcy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvbHlsaW5lUmVuZGVyVW5pdCBleHRlbmRzIEJhc2VQb2x5bGluZVJlbmRlclVuaXQge1xyXG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgY2FtZXJhLCBwcmltaXRpdmVQcm92aWRlciwgcmVuZGVyU3RhdGUgPSBuZXcgUmVuZGVyU3RhdGUoREVGQVVMVF9SRU5ERVJfU1RBVEVfUEFSQU1TKSkge1xyXG4gICAgICAgIGNvbnN0IHByb2dyYW0gPSBjb250ZXh0LmNyZWF0ZVByb2dyYW0ocG9seWxpbmVWZXJ0ZXhTaGFkZXIsIHBvbHlsaW5lRnJhZ21lbnRTaGFkZXIsIHtcclxuICAgICAgICAgICAgZGVmaW5lczoge1xyXG4gICAgICAgICAgICAgICAgRklMVEVSX1JBRElVUzogYGZsb2F0KCR7RklMVEVSX1JBRElVU30pYCxcclxuICAgICAgICAgICAgICAgIE1BWF9IQUxGX1dJRFRIOiBgZmxvYXQoJHtNQVhfSEFMRl9XSURUSH0pYCxcclxuICAgICAgICAgICAgICAgIE1BWF9GSUxMX0dBUDogYGZsb2F0KCR7TUFYX0ZJTExfR0FQfSlgXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGF0dHJpYk1hcDoge1xyXG4gICAgICAgICAgICAgICAgdmVydGV4UG9zOiAwIC8qIFBPU0lUSU9OICovLFxyXG4gICAgICAgICAgICAgICAgdmVydGV4Tm9ybWFsUGFja2VkOiA1IC8qIE5PUk1BTCAqLyxcclxuICAgICAgICAgICAgICAgIHZlcnRleFV2UGFja2VkOiA0IC8qIFVWICovLFxyXG4gICAgICAgICAgICAgICAgdmVydGV4V2lkdGhGaWxsR2FwOiAxMSAvKiBBVVggKi8sXHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhDb2xvcjogNyAvKiBDT0xPUiAqLyxcclxuICAgICAgICAgICAgICAgIHZlcnRleE1pdGVyOiAxMiAvKiBBVVgxICovLFxyXG4gICAgICAgICAgICAgICAgdmVydGV4VkxpbWl0OiAxMyAvKiBBVVgyICovLFxyXG4gICAgICAgICAgICAgICAgdmVydGV4TGVuZ3RoOiAxNCAvKiBBVVgzICovXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBzdXBlcihjb250ZXh0LCByZW5kZXJTdGF0ZSwgcHJvZ3JhbSwgcHJpbWl0aXZlUHJvdmlkZXIsIGNhbWVyYSk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvcG9seWxpbmUvcG9seWxpbmVfcmVuZGVyX3VuaXQudHNcbi8vIG1vZHVsZSBpZCA9IDEzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgKiBhcyB2ZWMyIGZyb20gJy4uLy4uL21hdGgvdmVjdG9yMic7XHJcbmltcG9ydCB7IGVuY29kZVJnYmE4IH0gZnJvbSAnLi4vLi4vdXRpbC9jb2xvcic7XHJcbmltcG9ydCBCdWZmZXJXcml0ZXIgZnJvbSAnLi4vLi4vdXRpbC9idWZmZXJfd3JpdGVyJztcclxuaW1wb3J0IHsgUE9MWUxJTkVfQVRUUklCVVRFX01BUFBJTkcgfSBmcm9tICcuL3BvbHlsaW5lX2F0dHJpYnV0ZV9tYXBwaW5nJztcclxuaW1wb3J0IHsgZmxvYXRUb1VpbnQ4LCBmbG9hdFRvVWludDE2IH0gZnJvbSAnLi4vLi4vdXRpbC9ncHV0eXBlcyc7XHJcbmltcG9ydCB7IGludFRvWkluZGV4IH0gZnJvbSAnLi4vLi4vdXRpbC96X2luZGV4JztcclxuaW1wb3J0IHsgY2xhbXAgfSBmcm9tICcuLi8uLi9tYXRoL3NjYWxhcic7XHJcbi8qKlxyXG4gKiBDb21wdXRlcyBtaXRlciBvZiBhIGpvaW4gYmV0d2VlbiB0d28gc2VnbWVudHMuXHJcbiAqXHJcbiAqIEBwYXJhbSBuMSBOb3JtYWwgdmVjdG9yIG9mIHRoZSBmaXJzdCBzZWdtZW50LlxyXG4gKiBAcGFyYW0gbjIgTm9ybWFsIHZlY3RvciBvZiB0aGUgc2Vjb25kIHNlZ21lbnQuXHJcbiAqIEByZXR1cm5zIE1pdGVyIHZhbHVlLCBpLmUuIGJ5IGhvdyBtYXRjaCBkaXNwbGFjZW1lbnQgaXMgbG9uZ2VyIHRoYW4gYSBub3JtYWxcclxuICogICAgICBvbmUuXHJcbiAqL1xyXG5mdW5jdGlvbiBjb21wdXRlTWl0ZXIobjEsIG4yKSB7XHJcbiAgICByZXR1cm4gTWF0aC5zcXJ0KDIgLyAoMSArIHZlYzIuZG90KG4xLCBuMikpKTtcclxufVxyXG5jb25zdCBTRUdNRU5UX1ZFUlRFWF9DT1VOVCA9IDQ7XHJcbmNvbnN0IFNRVUFSRV9DQVBfVkVSVEVYX0NPVU5UID0gNTtcclxuY29uc3QgUk9VTkRfQ0FQX1ZFUlRFWF9DT1VOVCA9IDQ7XHJcbmNvbnN0IEZMT0FUX01BWCA9IDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzg7XHJcbmNvbnN0IE1JVEVSX0xJTUlUID0gNDtcclxuY29uc3QgVVZfUE9TX09ORV9QQUNLRUQgPSAyNTU7IC8vIHBhY2tlZCAxXHJcbmNvbnN0IFVWX05FR19PTkVfUEFDS0VEID0gMTsgLy8gcGFja2VkIC0xXHJcbmNvbnN0IFVWX1pFUk9fUEFDS0VEID0gMTI4O1xyXG4vKipcclxuICogUGFja3MgYSBjb21wb25lbnQgb2YgdXYgaW50byBhIHVuc2lnbmVkIDgtYml0IHZhbHVlLiBBZnRlciBwYWNraW5nIC0xIHdpbGxcclxuICogYmVjb21lIDEgYW5kIDEgd2lsbCBiZWNvbWUgMjU1LiBUaGF0J3MgbmVlZCB0byBlbXVsYXRlIHplcm8tcHJlc2VydmluZ1xyXG4gKiBub3JtYWxpemF0aW9uICh3ZSBjYW4ndCByZWx5IG9uIFdlYkdMIHRvIGRvIGl0IGZvciB1cyA6KCkuXHJcbiAqXHJcbiAqIEBwYXJhbSBjIFRoZSBjb21wb25lbnQuXHJcbiAqIEByZXR1cm5zIFBhY2tlZCBjb21wb25lbnQuXHJcbiAqL1xyXG5mdW5jdGlvbiBwYWNrVXZDb21wb25lbnQoYykge1xyXG4gICAgLy8gV2UgZG9uJ3QgdHJ1bmNhdGUgaGVyZSBiZWNhdXNlIGJ1ZmZlciB3cml0ZXIgd2lsbCBkbyB0aGF0IGZvciB1cy5cclxuICAgIHJldHVybiAxMjggKyAoMTI3ICogYyk7XHJcbn1cclxuLyoqXHJcbiAqIEhhbGYgd2lkdGggb2YgdGhlIHBvbHlsaW5lIGlzIHN0b3JlZCBpbiBhIG5vcm1hbGl6ZWQgYXR0cmlidXRlLiBUaGlzIGNvbnN0YW50XHJcbiAqIGRlZmluZXMgaGFsZiB3aWR0aCB2YWx1ZSBvZiAxIGNvcnJlc3BvbmRzIHRvLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IE1BWF9IQUxGX1dJRFRIID0gMjU1IC8gNDsgLy8gcHhcclxuLyoqXHJcbiAqIFNhbWUgYXMgZm9yIHBvbHlsaW5lIGhhbGYgd2lkdGgsIGJ1dCBmb3IgZGFzaCBwYXR0ZXJuIGRlZmluaXRpb24uXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgTUFYX0ZJTExfR0FQID0gMjU1OyAvLyBweFxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb2x5bGluZUJ1ZmZlcldyaXRlciBleHRlbmRzIEJ1ZmZlcldyaXRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcihQT0xZTElORV9BVFRSSUJVVEVfTUFQUElORy52ZXJ0ZXhCeXRlU2l6ZSk7XHJcbiAgICAgICAgdGhpcy5fZGlzcGxhY2VtZW50ID0gdmVjMi5jcmVhdGUoMCwgMCk7XHJcbiAgICAgICAgdGhpcy5fcHJldkRpc3BsYWNlbWVudCA9IHZlYzIuY3JlYXRlKDAsIDApO1xyXG4gICAgICAgIHRoaXMuX2luaXRQb2x5bGluZVN0YXRlKFt2ZWMyLlpFUk8sIHZlYzIuWkVST10sIDAsIDAsIDAsIDAsIDAgLyogTUlURVIgKi8sIDApO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZXMgYSBtZXNoIGZvciBhIHBvbHlsaW5lIHdpdGggYSBnaXZlbiBzdHlsZSwgYmFraW5nIGFsbCBuZWNlc3NhcnlcclxuICAgICAqIHBhcmFtZXRlcnMgaW50byBhdHRyaWJ1dGVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwb2x5bGluZSBUaGUgcG9seWxpbmUuXHJcbiAgICAgKiBAcGFyYW0gc3R5bGUgVGhlIHBvbHlsaW5lIHN0eWxlLlxyXG4gICAgICogQHJldHVybnMgTG9jYXRpb24gb2YgdGhlIHdyaXR0ZW4gbWVzaCBpbiB0aGUgbWFuYWdlZCBidWZmZXJzLlxyXG4gICAgICovXHJcbiAgICB3cml0ZVBvbHlsaW5lKHBvbHlsaW5lLCBzdHlsZSwgekluZGV4KSB7XHJcbiAgICAgICAgY29uc3QgeyB2ZXJ0aWNlcyB9ID0gcG9seWxpbmU7XHJcbiAgICAgICAgY29uc3QgbGFzdElkeCA9IHZlcnRpY2VzLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgaWYgKGxhc3RJZHggPCAxKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT25lIHZlcnRleCBpbiBub3QgYSBwb2x5bGluZS4gSXRcXCdzIG5vdCBldmVuIGEgbGluZS4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5faW5pdFBvbHlsaW5lU3RhdGUodmVydGljZXMsIGVuY29kZVJnYmE4KHN0eWxlLnN0cm9rZUNvbG9yKSwgc3R5bGUuc3Ryb2tlV2lkdGgsIHN0eWxlLmRhc2ggPyBzdHlsZS5kYXNoLmZpbGwgOiAwLCBzdHlsZS5kYXNoID8gc3R5bGUuZGFzaC5nYXAgOiAwLCBzdHlsZS5qb2luLCBpbnRUb1pJbmRleCh6SW5kZXgpKTtcclxuICAgICAgICB0aGlzLl93cml0ZUNhcChzdHlsZS5zdGFydENhcCwgdmVydGljZXNbMF0sIDEpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGFzdElkeDsgKytpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3dyaXRlU2VnbWVudCh2ZXJ0aWNlc1tpIC0gMV0sIHZlcnRpY2VzW2ldLCB2ZXJ0aWNlc1tpICsgMV0pO1xyXG4gICAgICAgICAgICB0aGlzLl93cml0ZUpvaW4odmVydGljZXNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl93cml0ZUxhc3RTZWdtZW50KHZlcnRpY2VzW2xhc3RJZHggLSAxXSwgdmVydGljZXNbbGFzdElkeF0pO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlQ2FwKHN0eWxlLmVuZENhcCwgdmVydGljZXNbbGFzdElkeF0sIDEpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVuZE1lc2goKTtcclxuICAgIH1cclxuICAgIF9pbml0UG9seWxpbmVTdGF0ZSh2ZXJ0aWNlcywgY29sb3JSZ2JhOCwgd2lkdGgsIGZpbGwsIGdhcCwgam9pbiwgekluZGV4KSB7XHJcbiAgICAgICAgdGhpcy5fYmFzZUluZGV4ID0gdGhpcy5fcG9seWxpbmVMZW5ndGggPSB0aGlzLl9sYXN0RGlyZWN0aW9uID0gMDtcclxuICAgICAgICB0aGlzLl9sYXN0U2lnbmVkTWl0ZXIgPSAxO1xyXG4gICAgICAgIGNvbnN0IGRpc3BsYWNlbWVudCA9IHZlYzIuc3ViKHZlcnRpY2VzWzFdLCB2ZXJ0aWNlc1swXSwgdGhpcy5fZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB0aGlzLl9zZWdtZW50TGVuZ3RoID0gdmVjMi5sZW5ndGgoZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB2ZWMyLmRpdm4oZGlzcGxhY2VtZW50LCB0aGlzLl9zZWdtZW50TGVuZ3RoLCBkaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHZlYzIucm90YXRlOTAoZGlzcGxhY2VtZW50LCBkaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHRoaXMuX2NvbG9yUmdiYTggPSBjb2xvclJnYmE4O1xyXG4gICAgICAgIHRoaXMuX2hhbGZXaWR0aEZpbGxHYXBQYWNrZWQgPVxyXG4gICAgICAgICAgICBmbG9hdFRvVWludDgoY2xhbXAoMC41ICogd2lkdGgsIDAsIE1BWF9IQUxGX1dJRFRIKSAvIE1BWF9IQUxGX1dJRFRIKSB8XHJcbiAgICAgICAgICAgICAgICBmbG9hdFRvVWludDgoY2xhbXAoZmlsbCwgMCwgTUFYX0ZJTExfR0FQKSAvIE1BWF9GSUxMX0dBUCkgPDwgOCB8XHJcbiAgICAgICAgICAgICAgICBmbG9hdFRvVWludDgoY2xhbXAoZ2FwLCAwLCBNQVhfRklMTF9HQVApIC8gTUFYX0ZJTExfR0FQKSA8PCAxNjtcclxuICAgICAgICB0aGlzLl9qb2luID0gam9pbjtcclxuICAgICAgICB0aGlzLl96SW5kZXggPSB6SW5kZXg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIHNpbmdsZSB2ZXJ0ZXggaW50byBtYW5hZ2VkIHZlcnRleCBidWZmZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBvc2l0aW9uIFZlcnRleCB3b3JsZCBwb3NpdGlvbi5cclxuICAgICAqIEBwYXJhbSBub3JtYWwgTm9ybWFsIG9mIHNlZ21lbnQgdGhlIHZlcnRleCBiZWxvbmdzIHRvLlxyXG4gICAgICogQHBhcmFtIHUgTm9ybWFsaXplZCBkaXN0YW5jZSB0byB0aGUgcG9seWxpbmUgYWxvbmcgdGhlIG5vcm1hbC5cclxuICAgICAqIEBwYXJhbSB2IE5vcm1hbGl6ZWQgZGlzdGFuY2UgdG8gdGhlIHBvbHlsaW5lIGFsb25nIHRoZSB0YW5nZW50LlxyXG4gICAgICogQHBhcmFtIHBvbHlsaW5lTGVuZ3RoIERpc3RhbmNlIHRvIHRoZSBmaXJzdCB2ZXJ0ZXggYWxvbmcgdGhlIHBvbHlsaW5lLlxyXG4gICAgICogQHBhcmFtIG1pdGVyIEpvaW4gbWl0ZXIuXHJcbiAgICAgKiBAcGFyYW0gbGVuZ3RoQ29ycmVjdGlvbkxpbWl0IExpbWl0IG9uIHRoZSB2ZXJ0ZXggZGlzcGxhY2VtZW50IGFsb25nIHRoZVxyXG4gICAgICogICAgICBwb2x5bGluZS5cclxuICAgICAqL1xyXG4gICAgX3dyaXRlVmVydGV4KHBvc2l0aW9uLCBub3JtYWwsIHVQYWNrZWQsIHZQYWNrZWQsIHBvbHlsaW5lTGVuZ3RoLCBtaXRlciwgbGVuZ3RoQ29ycmVjdGlvbkxpbWl0KSB7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVXb3JsZENvb3JkaW5hdGUocG9zaXRpb24pO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlSGFsZldvcmRzKGZsb2F0VG9VaW50MTYoMC41ICogKG5vcm1hbC54ICogTWF0aC5TUVJUMV8yICsgMSkpLCBmbG9hdFRvVWludDE2KDAuNSAqIChub3JtYWwueSAqIE1hdGguU1FSVDFfMiArIDEpKSk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVIYWxmV29yZHModVBhY2tlZCwgdlBhY2tlZCk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVXb3JkKHRoaXMuX2hhbGZXaWR0aEZpbGxHYXBQYWNrZWQpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlRmxvYXQzMihtaXRlcik7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVGbG9hdDMyKGxlbmd0aENvcnJlY3Rpb25MaW1pdCk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVGbG9hdDMyKHBvbHlsaW5lTGVuZ3RoKTtcclxuICAgICAgICB0aGlzLl93cml0ZVdvcmQodGhpcy5fY29sb3JSZ2JhOCk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVGbG9hdDMyKHRoaXMuX3pJbmRleCk7XHJcbiAgICB9XHJcbiAgICBfd3JpdGVDYXAoY2FwLCBlbmRWZXJ0ZXgsIGRpc3BsYWNlbWVudFNpZ24pIHtcclxuICAgICAgICBzd2l0Y2ggKGNhcCkge1xyXG4gICAgICAgICAgICBjYXNlIDEgLyogUk9VTkQgKi86XHJcbiAgICAgICAgICAgICAgICB0aGlzLl93cml0ZVJvdW5kQ2FwKGVuZFZlcnRleCwgZGlzcGxhY2VtZW50U2lnbik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAyIC8qIFNRVUFSRSAqLzpcclxuICAgICAgICAgICAgICAgIHRoaXMuX3dyaXRlU3F1YXJlQ2FwKGVuZFZlcnRleCwgZGlzcGxhY2VtZW50U2lnbik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfd3JpdGVSb3VuZENhcChlbmRWZXJ0ZXgsIGRpc3BsYWNlbWVudFNpZ24pIHtcclxuICAgICAgICBjb25zdCBkaXNwbGFjZW1lbnQgPSB2ZWMyLmNyZWF0ZSgwLCAwKTtcclxuICAgICAgICBjb25zdCBwb2x5bGluZUxlbmd0aCA9IHRoaXMuX3BvbHlsaW5lTGVuZ3RoO1xyXG4gICAgICAgIHZlYzIubXVsbih0aGlzLl9kaXNwbGFjZW1lbnQsIC1kaXNwbGFjZW1lbnRTaWduLCBkaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlVmVydGV4KGVuZFZlcnRleCwgZGlzcGxhY2VtZW50LCBVVl9ORUdfT05FX1BBQ0tFRCwgVVZfWkVST19QQUNLRUQsIHBvbHlsaW5lTGVuZ3RoLCAxLCBGTE9BVF9NQVgpO1xyXG4gICAgICAgIHZlYzIucm90YXRlOTAodGhpcy5fZGlzcGxhY2VtZW50LCBkaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHZlYzIuc3ViKGRpc3BsYWNlbWVudCwgdGhpcy5fZGlzcGxhY2VtZW50LCBkaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHZlYzIubXVsbihkaXNwbGFjZW1lbnQsIGRpc3BsYWNlbWVudFNpZ24sIGRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVWZXJ0ZXgoZW5kVmVydGV4LCBkaXNwbGFjZW1lbnQsIFVWX05FR19PTkVfUEFDS0VELCBVVl9QT1NfT05FX1BBQ0tFRCwgcG9seWxpbmVMZW5ndGgsIDEsIEZMT0FUX01BWCk7XHJcbiAgICAgICAgdmVjMi5tdWxuKHRoaXMuX2Rpc3BsYWNlbWVudCwgZGlzcGxhY2VtZW50U2lnbiwgZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB0aGlzLl93cml0ZVZlcnRleChlbmRWZXJ0ZXgsIGRpc3BsYWNlbWVudCwgVVZfUE9TX09ORV9QQUNLRUQsIFVWX1pFUk9fUEFDS0VELCBwb2x5bGluZUxlbmd0aCwgMSwgRkxPQVRfTUFYKTtcclxuICAgICAgICB2ZWMyLnJvdGF0ZTkwKHRoaXMuX2Rpc3BsYWNlbWVudCwgZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB2ZWMyLmFkZChkaXNwbGFjZW1lbnQsIHRoaXMuX2Rpc3BsYWNlbWVudCwgZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB2ZWMyLm11bG4oZGlzcGxhY2VtZW50LCBkaXNwbGFjZW1lbnRTaWduLCBkaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlVmVydGV4KGVuZFZlcnRleCwgZGlzcGxhY2VtZW50LCBVVl9QT1NfT05FX1BBQ0tFRCwgVVZfUE9TX09ORV9QQUNLRUQsIHBvbHlsaW5lTGVuZ3RoLCAxLCBGTE9BVF9NQVgpO1xyXG4gICAgICAgIHRoaXMud3JpdGVJbmRpY2VzRm9yQ29udGludW91c1N0cmlwKFJPVU5EX0NBUF9WRVJURVhfQ09VTlQsIHRoaXMuX2Jhc2VJbmRleCk7XHJcbiAgICAgICAgdGhpcy5fYmFzZUluZGV4ICs9IFJPVU5EX0NBUF9WRVJURVhfQ09VTlQ7XHJcbiAgICB9XHJcbiAgICBfd3JpdGVTcXVhcmVDYXAoZW5kVmVydGV4LCBkaXNwbGFjZW1lbnRTaWduKSB7XHJcbiAgICAgICAgY29uc3QgZGlzcGxhY2VtZW50ID0gdmVjMi5jcmVhdGUoMCwgMCk7XHJcbiAgICAgICAgY29uc3QgcG9seWxpbmVMZW5ndGggPSB0aGlzLl9wb2x5bGluZUxlbmd0aDtcclxuICAgICAgICB0aGlzLl93cml0ZVZlcnRleChlbmRWZXJ0ZXgsIHZlYzIuWkVSTywgVVZfWkVST19QQUNLRUQsIFVWX1pFUk9fUEFDS0VELCBwb2x5bGluZUxlbmd0aCwgMSwgMCk7XHJcbiAgICAgICAgdmVjMi5tdWxuKHRoaXMuX2Rpc3BsYWNlbWVudCwgLWRpc3BsYWNlbWVudFNpZ24sIGRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVWZXJ0ZXgoZW5kVmVydGV4LCBkaXNwbGFjZW1lbnQsIFVWX1BPU19PTkVfUEFDS0VELCBVVl9aRVJPX1BBQ0tFRCwgcG9seWxpbmVMZW5ndGgsIDEsIEZMT0FUX01BWCk7XHJcbiAgICAgICAgdmVjMi5yb3RhdGU5MCh0aGlzLl9kaXNwbGFjZW1lbnQsIGRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdmVjMi5zdWIoZGlzcGxhY2VtZW50LCB0aGlzLl9kaXNwbGFjZW1lbnQsIGRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdmVjMi5tdWxuKGRpc3BsYWNlbWVudCwgZGlzcGxhY2VtZW50U2lnbiwgZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB0aGlzLl93cml0ZVZlcnRleChlbmRWZXJ0ZXgsIGRpc3BsYWNlbWVudCwgVVZfUE9TX09ORV9QQUNLRUQsIFVWX1pFUk9fUEFDS0VELCBwb2x5bGluZUxlbmd0aCwgMSwgRkxPQVRfTUFYKTtcclxuICAgICAgICB2ZWMyLnJvdGF0ZTkwKHRoaXMuX2Rpc3BsYWNlbWVudCwgZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB2ZWMyLnN1YihkaXNwbGFjZW1lbnQsIHRoaXMuX2Rpc3BsYWNlbWVudCwgZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB2ZWMyLm11bG4oZGlzcGxhY2VtZW50LCBkaXNwbGFjZW1lbnRTaWduLCBkaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlVmVydGV4KGVuZFZlcnRleCwgZGlzcGxhY2VtZW50LCBVVl9QT1NfT05FX1BBQ0tFRCwgVVZfWkVST19QQUNLRUQsIHBvbHlsaW5lTGVuZ3RoLCAxLCBGTE9BVF9NQVgpO1xyXG4gICAgICAgIHZlYzIubXVsbih0aGlzLl9kaXNwbGFjZW1lbnQsIGRpc3BsYWNlbWVudFNpZ24sIGRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVWZXJ0ZXgoZW5kVmVydGV4LCB0aGlzLl9kaXNwbGFjZW1lbnQsIFVWX1BPU19PTkVfUEFDS0VELCBVVl9aRVJPX1BBQ0tFRCwgcG9seWxpbmVMZW5ndGgsIDEsIEZMT0FUX01BWCk7XHJcbiAgICAgICAgdGhpcy53cml0ZUluZGljZXNGb3JDb250aW51b3VzRmFuKFNRVUFSRV9DQVBfVkVSVEVYX0NPVU5ULCB0aGlzLl9iYXNlSW5kZXgpO1xyXG4gICAgICAgIHRoaXMuX2Jhc2VJbmRleCArPSBTUVVBUkVfQ0FQX1ZFUlRFWF9DT1VOVDtcclxuICAgIH1cclxuICAgIF93cml0ZVNlZ21lbnQoc3RhcnQsIGVuZCwgbmV4dEVuZCkge1xyXG4gICAgICAgIGNvbnN0IGRpc3BsYWNlbWVudCA9IHRoaXMuX2Rpc3BsYWNlbWVudDtcclxuICAgICAgICBjb25zdCBwb2x5bGluZUxlbmd0aCA9IHRoaXMuX3BvbHlsaW5lTGVuZ3RoO1xyXG4gICAgICAgIGNvbnN0IG5leHRTZWdtZW50TGVuZ3RoID0gdmVjMi5kaXN0YW5jZShuZXh0RW5kLCBlbmQpO1xyXG4gICAgICAgIGNvbnN0IG5leHRTZWdtZW50Tm9ybWFsID0gdmVjMi5zdWIobmV4dEVuZCwgZW5kKTtcclxuICAgICAgICB2ZWMyLmRpdm4obmV4dFNlZ21lbnROb3JtYWwsIG5leHRTZWdtZW50TGVuZ3RoLCBuZXh0U2VnbWVudE5vcm1hbCk7XHJcbiAgICAgICAgdmVjMi5yb3RhdGU5MChuZXh0U2VnbWVudE5vcm1hbCwgbmV4dFNlZ21lbnROb3JtYWwpO1xyXG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbjEgPSB0aGlzLl9sYXN0RGlyZWN0aW9uO1xyXG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbjIgPSBNYXRoLnNpZ24odmVjMi5jcm9zc1ooZGlzcGxhY2VtZW50LCBuZXh0U2VnbWVudE5vcm1hbCkpO1xyXG4gICAgICAgIGNvbnN0IG1pdGVyMSA9IHRoaXMuX2xhc3RTaWduZWRNaXRlcjtcclxuICAgICAgICBjb25zdCBtaXRlcjIgPSBjb21wdXRlTWl0ZXIoZGlzcGxhY2VtZW50LCBuZXh0U2VnbWVudE5vcm1hbCk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVWZXJ0ZXgoc3RhcnQsIGRpc3BsYWNlbWVudCwgVVZfUE9TX09ORV9QQUNLRUQsIFVWX1pFUk9fUEFDS0VELCBwb2x5bGluZUxlbmd0aCwgZGlyZWN0aW9uMSA9PT0gLTEgJiYgKHRoaXMuX2pvaW4gIT09IDAgLyogTUlURVIgKi8gfHwgTWF0aC5hYnMobWl0ZXIxKSA+IE1JVEVSX0xJTUlUKSA/XHJcbiAgICAgICAgICAgIDEgOlxyXG4gICAgICAgICAgICBtaXRlcjEsIGRpcmVjdGlvbjEgPT09IC0xID8gLUZMT0FUX01BWCA6IDAuNSAqIHRoaXMuX3NlZ21lbnRMZW5ndGgpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlVmVydGV4KGVuZCwgZGlzcGxhY2VtZW50LCBVVl9QT1NfT05FX1BBQ0tFRCwgVVZfWkVST19QQUNLRUQsIHBvbHlsaW5lTGVuZ3RoICsgdGhpcy5fc2VnbWVudExlbmd0aCwgZGlyZWN0aW9uMiA9PT0gLTEgJiYgKHRoaXMuX2pvaW4gIT09IDAgLyogTUlURVIgKi8gfHwgbWl0ZXIyID4gTUlURVJfTElNSVQpID9cclxuICAgICAgICAgICAgMSA6XHJcbiAgICAgICAgICAgIGRpcmVjdGlvbjIgKiBtaXRlcjIsIGRpcmVjdGlvbjIgPT09IC0xID8gRkxPQVRfTUFYIDogLTAuNSAqIHRoaXMuX3NlZ21lbnRMZW5ndGgpO1xyXG4gICAgICAgIHZlYzIuaW52ZXJ0KGRpc3BsYWNlbWVudCwgZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB0aGlzLl93cml0ZVZlcnRleChzdGFydCwgZGlzcGxhY2VtZW50LCBVVl9ORUdfT05FX1BBQ0tFRCwgVVZfWkVST19QQUNLRUQsIHBvbHlsaW5lTGVuZ3RoLCBkaXJlY3Rpb24xID09PSAxICYmICh0aGlzLl9qb2luICE9PSAwIC8qIE1JVEVSICovIHx8IE1hdGguYWJzKG1pdGVyMSkgPiBNSVRFUl9MSU1JVCkgP1xyXG4gICAgICAgICAgICAxIDpcclxuICAgICAgICAgICAgbWl0ZXIxLCBkaXJlY3Rpb24xID09PSAxID8gLUZMT0FUX01BWCA6IDAuNSAqIHRoaXMuX3NlZ21lbnRMZW5ndGgpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlVmVydGV4KGVuZCwgZGlzcGxhY2VtZW50LCBVVl9ORUdfT05FX1BBQ0tFRCwgVVZfWkVST19QQUNLRUQsIHBvbHlsaW5lTGVuZ3RoICsgdGhpcy5fc2VnbWVudExlbmd0aCwgZGlyZWN0aW9uMiA9PT0gMSAmJiAodGhpcy5fam9pbiAhPT0gMCAvKiBNSVRFUiAqLyB8fCBtaXRlcjIgPiBNSVRFUl9MSU1JVCkgP1xyXG4gICAgICAgICAgICAxIDpcclxuICAgICAgICAgICAgZGlyZWN0aW9uMiAqIG1pdGVyMiwgZGlyZWN0aW9uMiA9PT0gMSA/IEZMT0FUX01BWCA6IC0wLjUgKiB0aGlzLl9zZWdtZW50TGVuZ3RoKTtcclxuICAgICAgICB0aGlzLndyaXRlSW5kaWNlc0ZvckNvbnRpbnVvdXNTdHJpcChTRUdNRU5UX1ZFUlRFWF9DT1VOVCwgdGhpcy5fYmFzZUluZGV4KTtcclxuICAgICAgICB0aGlzLl9iYXNlSW5kZXggKz0gU0VHTUVOVF9WRVJURVhfQ09VTlQ7XHJcbiAgICAgICAgdGhpcy5fbGFzdFNpZ25lZE1pdGVyID0gLWRpcmVjdGlvbjIgKiBtaXRlcjI7XHJcbiAgICAgICAgdGhpcy5fbGFzdERpcmVjdGlvbiA9IGRpcmVjdGlvbjI7XHJcbiAgICAgICAgdmVjMi5jb3B5KGRpc3BsYWNlbWVudCwgdGhpcy5fcHJldkRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdmVjMi5jb3B5KG5leHRTZWdtZW50Tm9ybWFsLCBkaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHRoaXMuX3BvbHlsaW5lTGVuZ3RoICs9IHRoaXMuX3NlZ21lbnRMZW5ndGg7XHJcbiAgICAgICAgdGhpcy5fc2VnbWVudExlbmd0aCA9IG5leHRTZWdtZW50TGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgX3dyaXRlSm9pbihqb2luVmVydGV4KSB7XHJcbiAgICAgICAgc3dpdGNoICh0aGlzLl9qb2luKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMiAvKiBCRVZFTCAqLzpcclxuICAgICAgICAgICAgICAgIHRoaXMuX3dyaXRlQmV2ZWxKb2luKGpvaW5WZXJ0ZXgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMSAvKiBST1VORCAqLzpcclxuICAgICAgICAgICAgICAgIHRoaXMuX3dyaXRlUm91bmRKb2luKGpvaW5WZXJ0ZXgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMCAvKiBNSVRFUiAqLzpcclxuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyh0aGlzLl9sYXN0U2lnbmVkTWl0ZXIpID4gTUlURVJfTElNSVQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl93cml0ZUJldmVsSm9pbihqb2luVmVydGV4KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF93cml0ZUJldmVsSm9pbihqb2luVmVydGV4KSB7XHJcbiAgICAgICAgY29uc3QgbGFzdERpcmVjdGlvbiA9IHRoaXMuX2xhc3REaXJlY3Rpb247XHJcbiAgICAgICAgY29uc3QgZGlzcGxhY2VtZW50ID0gdmVjMi5pbnZlcnQodGhpcy5fZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB2ZWMyLmFkZChkaXNwbGFjZW1lbnQsIHRoaXMuX3ByZXZEaXNwbGFjZW1lbnQsIGRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdmVjMi5tdWxuKGRpc3BsYWNlbWVudCwgMC41ICogbGFzdERpcmVjdGlvbiwgZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB0aGlzLl93cml0ZVZlcnRleChqb2luVmVydGV4LCBkaXNwbGFjZW1lbnQsIGxhc3REaXJlY3Rpb24gPT09IC0xIC8qIExFRlQgKi8gP1xyXG4gICAgICAgICAgICBVVl9QT1NfT05FX1BBQ0tFRCA6XHJcbiAgICAgICAgICAgIFVWX05FR19PTkVfUEFDS0VELCBVVl9aRVJPX1BBQ0tFRCwgdGhpcy5fcG9seWxpbmVMZW5ndGgsIDEsIDEpO1xyXG4gICAgICAgIGNvbnN0IGJhc2VJbmRleCA9IHRoaXMuX2Jhc2VJbmRleDtcclxuICAgICAgICB0aGlzLndyaXRlSW5kaWNlcyhbXHJcbiAgICAgICAgICAgIGJhc2VJbmRleCAtIDEsXHJcbiAgICAgICAgICAgIGJhc2VJbmRleCAtIDMsXHJcbiAgICAgICAgICAgIGJhc2VJbmRleCxcclxuICAgICAgICAgICAgYmFzZUluZGV4LFxyXG4gICAgICAgICAgICBsYXN0RGlyZWN0aW9uID09PSAtMSAvKiBMRUZUICovID8gYmFzZUluZGV4ICsgMSA6IGJhc2VJbmRleCArIDMsXHJcbiAgICAgICAgICAgIGxhc3REaXJlY3Rpb24gPT09IC0xIC8qIExFRlQgKi8gPyBiYXNlSW5kZXggKyAzIDogYmFzZUluZGV4ICsgMVxyXG4gICAgICAgIF0pO1xyXG4gICAgICAgIHRoaXMuX2Jhc2VJbmRleCArPSAxO1xyXG4gICAgfVxyXG4gICAgX3dyaXRlUm91bmRKb2luKGpvaW5WZXJ0ZXgpIHtcclxuICAgICAgICBjb25zdCBwb2x5bGluZUxlbmd0aCA9IHRoaXMuX3BvbHlsaW5lTGVuZ3RoO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlVmVydGV4KGpvaW5WZXJ0ZXgsIHZlYzIuWkVSTywgVVZfWkVST19QQUNLRUQsIFVWX1pFUk9fUEFDS0VELCBwb2x5bGluZUxlbmd0aCwgMCwgMCk7XHJcbiAgICAgICAgY29uc3QgbGFzdERpcmVjdGlvbiA9IHRoaXMuX2xhc3REaXJlY3Rpb247XHJcbiAgICAgICAgY29uc3QgbWlkZGxlRGlzcGxhY2VtZW50ID0gdmVjMi5pbnZlcnQodGhpcy5fcHJldkRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdmVjMi5hZGQodGhpcy5fZGlzcGxhY2VtZW50LCBtaWRkbGVEaXNwbGFjZW1lbnQsIG1pZGRsZURpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdmVjMi5ub3JtYWxpemUobWlkZGxlRGlzcGxhY2VtZW50LCBtaWRkbGVEaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIGNvbnN0IGRpc3BsYWNlbWVudCA9IHZlYzIuaW52ZXJ0KHRoaXMuX3ByZXZEaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIGNvbnN0IG1pdGVyMSA9IGNvbXB1dGVNaXRlcihtaWRkbGVEaXNwbGFjZW1lbnQsIGRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdmVjMi5hZGQoZGlzcGxhY2VtZW50LCBtaWRkbGVEaXNwbGFjZW1lbnQsIGRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdmVjMi5ub3JtYWxpemUoZGlzcGxhY2VtZW50LCBkaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHZlYzIubXVsbihkaXNwbGFjZW1lbnQsIC1sYXN0RGlyZWN0aW9uICogbWl0ZXIxLCBkaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlVmVydGV4KGpvaW5WZXJ0ZXgsIGRpc3BsYWNlbWVudCwgbGFzdERpcmVjdGlvbiA9PT0gLTEgLyogTEVGVCAqLyA/XHJcbiAgICAgICAgICAgIFVWX1BPU19PTkVfUEFDS0VEIDpcclxuICAgICAgICAgICAgVVZfTkVHX09ORV9QQUNLRUQsIHBhY2tVdkNvbXBvbmVudChNYXRoLnNxcnQobWl0ZXIxICogbWl0ZXIxIC0gMSkpLCBwb2x5bGluZUxlbmd0aCwgMSwgRkxPQVRfTUFYKTtcclxuICAgICAgICB2ZWMyLm11bG4obWlkZGxlRGlzcGxhY2VtZW50LCAtbGFzdERpcmVjdGlvbiwgZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB0aGlzLl93cml0ZVZlcnRleChqb2luVmVydGV4LCBkaXNwbGFjZW1lbnQsIGxhc3REaXJlY3Rpb24gPT09IC0xIC8qIExFRlQgKi8gP1xyXG4gICAgICAgICAgICBVVl9QT1NfT05FX1BBQ0tFRCA6XHJcbiAgICAgICAgICAgIFVWX05FR19PTkVfUEFDS0VELCBVVl9aRVJPX1BBQ0tFRCwgcG9seWxpbmVMZW5ndGgsIDEsIEZMT0FUX01BWCk7XHJcbiAgICAgICAgY29uc3QgbWl0ZXIyID0gY29tcHV0ZU1pdGVyKG1pZGRsZURpc3BsYWNlbWVudCwgdGhpcy5fZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB2ZWMyLmFkZCh0aGlzLl9kaXNwbGFjZW1lbnQsIG1pZGRsZURpc3BsYWNlbWVudCwgZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB2ZWMyLm5vcm1hbGl6ZShkaXNwbGFjZW1lbnQsIGRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdmVjMi5tdWxuKGRpc3BsYWNlbWVudCwgLWxhc3REaXJlY3Rpb24gKiBtaXRlcjIsIGRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVWZXJ0ZXgoam9pblZlcnRleCwgZGlzcGxhY2VtZW50LCBsYXN0RGlyZWN0aW9uID09PSAtMSAvKiBMRUZUICovID9cclxuICAgICAgICAgICAgVVZfUE9TX09ORV9QQUNLRUQgOlxyXG4gICAgICAgICAgICBVVl9ORUdfT05FX1BBQ0tFRCwgcGFja1V2Q29tcG9uZW50KE1hdGguc3FydChtaXRlcjIgKiBtaXRlcjIgLSAxKSksIHBvbHlsaW5lTGVuZ3RoLCAxLCBGTE9BVF9NQVgpO1xyXG4gICAgICAgIGNvbnN0IGJhc2VJbmRleCA9IHRoaXMuX2Jhc2VJbmRleDtcclxuICAgICAgICB0aGlzLndyaXRlSW5kaWNlcyhbXHJcbiAgICAgICAgICAgIGJhc2VJbmRleCAtIDMsXHJcbiAgICAgICAgICAgIGJhc2VJbmRleCAtIDEsXHJcbiAgICAgICAgICAgIGJhc2VJbmRleCxcclxuICAgICAgICAgICAgYmFzZUluZGV4LFxyXG4gICAgICAgICAgICBsYXN0RGlyZWN0aW9uID09PSAtMSAvKiBMRUZUICovID8gYmFzZUluZGV4IC0gMyA6IGJhc2VJbmRleCAtIDEsXHJcbiAgICAgICAgICAgIGJhc2VJbmRleCArIDEsXHJcbiAgICAgICAgICAgIGJhc2VJbmRleCxcclxuICAgICAgICAgICAgYmFzZUluZGV4ICsgMSxcclxuICAgICAgICAgICAgYmFzZUluZGV4ICsgMixcclxuICAgICAgICAgICAgYmFzZUluZGV4LFxyXG4gICAgICAgICAgICBiYXNlSW5kZXggKyAyLFxyXG4gICAgICAgICAgICBiYXNlSW5kZXggKyAzLFxyXG4gICAgICAgICAgICBiYXNlSW5kZXgsXHJcbiAgICAgICAgICAgIGJhc2VJbmRleCArIDMsXHJcbiAgICAgICAgICAgIGxhc3REaXJlY3Rpb24gPT09IC0xIC8qIExFRlQgKi8gPyBiYXNlSW5kZXggKyA0IDogYmFzZUluZGV4ICsgNixcclxuICAgICAgICAgICAgYmFzZUluZGV4LFxyXG4gICAgICAgICAgICBiYXNlSW5kZXggKyA0LFxyXG4gICAgICAgICAgICBiYXNlSW5kZXggKyA2XHJcbiAgICAgICAgXSk7XHJcbiAgICAgICAgdGhpcy5fYmFzZUluZGV4ICs9IDQ7XHJcbiAgICB9XHJcbiAgICBfd3JpdGVMYXN0U2VnbWVudChzdGFydCwgZW5kKSB7XHJcbiAgICAgICAgY29uc3QgZGlzcGxhY2VtZW50ID0gdGhpcy5fZGlzcGxhY2VtZW50O1xyXG4gICAgICAgIGNvbnN0IGxhc3REaXJlY3Rpb24gPSB0aGlzLl9sYXN0RGlyZWN0aW9uO1xyXG4gICAgICAgIGNvbnN0IHBvbHlsaW5lTGVuZ3RoID0gdGhpcy5fcG9seWxpbmVMZW5ndGg7XHJcbiAgICAgICAgY29uc3QgbWl0ZXIgPSB0aGlzLl9sYXN0U2lnbmVkTWl0ZXI7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVWZXJ0ZXgoc3RhcnQsIGRpc3BsYWNlbWVudCwgVVZfUE9TX09ORV9QQUNLRUQsIFVWX1pFUk9fUEFDS0VELCBwb2x5bGluZUxlbmd0aCwgbGFzdERpcmVjdGlvbiA9PT0gLTEgLyogTEVGVCAqLyAmJiAodGhpcy5fam9pbiAhPT0gMCAvKiBNSVRFUiAqLyB8fCBNYXRoLmFicyhtaXRlcikgPiBNSVRFUl9MSU1JVCkgP1xyXG4gICAgICAgICAgICAxIDpcclxuICAgICAgICAgICAgbWl0ZXIsIGxhc3REaXJlY3Rpb24gPT09IC0xIC8qIExFRlQgKi8gPyAtRkxPQVRfTUFYIDogdGhpcy5fc2VnbWVudExlbmd0aCk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVWZXJ0ZXgoZW5kLCBkaXNwbGFjZW1lbnQsIFVWX1BPU19PTkVfUEFDS0VELCBVVl9aRVJPX1BBQ0tFRCwgcG9seWxpbmVMZW5ndGggKyB0aGlzLl9zZWdtZW50TGVuZ3RoLCAxLCBGTE9BVF9NQVgpO1xyXG4gICAgICAgIHZlYzIuaW52ZXJ0KGRpc3BsYWNlbWVudCwgZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB0aGlzLl93cml0ZVZlcnRleChzdGFydCwgZGlzcGxhY2VtZW50LCBVVl9ORUdfT05FX1BBQ0tFRCwgVVZfWkVST19QQUNLRUQsIHBvbHlsaW5lTGVuZ3RoLCBsYXN0RGlyZWN0aW9uID09PSAxIC8qIFJJR0hUICovICYmICh0aGlzLl9qb2luICE9PSAwIC8qIE1JVEVSICovIHx8IE1hdGguYWJzKG1pdGVyKSA+IE1JVEVSX0xJTUlUKSA/XHJcbiAgICAgICAgICAgIDEgOlxyXG4gICAgICAgICAgICBtaXRlciwgbGFzdERpcmVjdGlvbiA9PT0gMSAvKiBSSUdIVCAqLyA/IC1GTE9BVF9NQVggOiB0aGlzLl9zZWdtZW50TGVuZ3RoKTtcclxuICAgICAgICB0aGlzLl93cml0ZVZlcnRleChlbmQsIGRpc3BsYWNlbWVudCwgVVZfTkVHX09ORV9QQUNLRUQsIFVWX1pFUk9fUEFDS0VELCBwb2x5bGluZUxlbmd0aCArIHRoaXMuX3NlZ21lbnRMZW5ndGgsIDEsIEZMT0FUX01BWCk7XHJcbiAgICAgICAgdGhpcy53cml0ZUluZGljZXNGb3JDb250aW51b3VzU3RyaXAoU0VHTUVOVF9WRVJURVhfQ09VTlQsIHRoaXMuX2Jhc2VJbmRleCk7XHJcbiAgICAgICAgdGhpcy5fYmFzZUluZGV4ICs9IFNFR01FTlRfVkVSVEVYX0NPVU5UO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3ByaW1pdGl2ZS9wb2x5bGluZS9wb2x5bGluZV9idWZmZXJfd3JpdGVyLnRzXG4vLyBtb2R1bGUgaWQgPSAxMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcIiN2ZXJzaW9uIDEwMFxcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxuI2lmbmRlZiBGSUxURVJfUkFESVVTXFxuIyAgIGVycm9yIEZJTFRFUl9SQURJVVMgbXVzdCBiZSBzZXRcXG4jZW5kaWZcXG5cXG4jaWZuZGVmIE1BWF9IQUxGX1dJRFRIXFxuIyAgIGVycm9yIE1BWF9IQUxGX1dJRFRIIG11c3QgYmUgc2V0XFxuI2VuZGlmXFxuXFxuI2lmbmRlZiBNQVhfRklMTF9HQVBcXG4jICAgZXJyb3IgTUFYX0ZJTExfR0FQIG11c3QgYmUgc2V0XFxuI2VuZGlmXFxuXFxuYXR0cmlidXRlIHZlYzQgdmVydGV4UG9zO1xcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleE5vcm1hbFBhY2tlZDtcXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhVdlBhY2tlZDtcXG5hdHRyaWJ1dGUgdmVjMyB2ZXJ0ZXhXaWR0aEZpbGxHYXA7XFxuYXR0cmlidXRlIHZlYzQgdmVydGV4Q29sb3I7XFxuYXR0cmlidXRlIGZsb2F0IHZlcnRleE1pdGVyO1xcbmF0dHJpYnV0ZSBmbG9hdCB2ZXJ0ZXhWTGltaXQ7XFxuYXR0cmlidXRlIGZsb2F0IHZlcnRleExlbmd0aDtcXG5cXG51bmlmb3JtIHZlYzIgbG9va0F0SGlnaDtcXG51bmlmb3JtIHZlYzIgbG9va0F0TG93O1xcbnVuaWZvcm0gbWF0NCB2aWV3UHJvak1hdHJpeDtcXG51bmlmb3JtIGZsb2F0IHdvcmxkVG9QeEZhY3RvcjtcXG5cXG52YXJ5aW5nIHZlYzIgdXY7XFxudmFyeWluZyBmbG9hdCBsZW47XFxudmFyeWluZyBmbG9hdCBoYWxmV2lkdGg7XFxudmFyeWluZyB2ZWMzIGRhc2g7XFxudmFyeWluZyB2ZWM0IGNvbG9yO1xcblxcbmNvbnN0IGZsb2F0IFlWX0ggPSAxLjk5OTk2OTQ4MjQyMTg3NTtcXG5jb25zdCBmbG9hdCBZVl9MID0gMC4wMDAwMzA1MTcxMTI0NjM3MTI2OTI7XFxuY29uc3QgdmVjNCBZVl9ISExMID0gdmVjNChZVl9ILCBZVl9ILCBZVl9MLCBZVl9MKTtcXG5cXG5jb25zdCBmbG9hdCBTUVJUMiA9IDEuNDE0MjEzNTM4MTY5ODYwODtcXG5cXG52ZWMyIHVucGFja1V2KGNvbnN0IGluIHZlYzIgdXYpIHtcXG4gICAgcmV0dXJuICh1diAtIDEyOC4pIC8gMTI3LjtcXG59XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gICAgdmVjMiBub3JtYWwgPSAoMi4wICogdmVydGV4Tm9ybWFsUGFja2VkIC0gMS4wKSAqIFNRUlQyO1xcblxcbiAgICBoYWxmV2lkdGggPSBmbG9hdChNQVhfSEFMRl9XSURUSCkgKiB2ZXJ0ZXhXaWR0aEZpbGxHYXAueDtcXG4gICAgaGFsZldpZHRoICs9IEZJTFRFUl9SQURJVVM7XFxuXFxuICAgIGZsb2F0IHRhbmdlbnRMZW5ndGggPSBtaW4oXFxuICAgICAgICBzcXJ0KHZlcnRleE1pdGVyICogdmVydGV4TWl0ZXIgLSAxLikgKiBoYWxmV2lkdGggKiB3b3JsZFRvUHhGYWN0b3IsXFxuICAgICAgICBhYnModmVydGV4VkxpbWl0KVxcbiAgICApO1xcblxcbiAgICB2ZWM0IGxvb2tBdCA9IHZlYzQobG9va0F0SGlnaCwgbG9va0F0TG93KTtcXG4gICAgdmVjNCByZWxhdGl2ZVRvRXllUG9zaXRpb24gPSBZVl9ISExMICogKHZlcnRleFBvcyAtIGxvb2tBdCk7XFxuXFxuICAgIGdsX1Bvc2l0aW9uID0gdmlld1Byb2pNYXRyaXggKiB2ZWM0KFxcbiAgICAgICAgcmVsYXRpdmVUb0V5ZVBvc2l0aW9uLnh5ICsgcmVsYXRpdmVUb0V5ZVBvc2l0aW9uLnp3ICtcXG4gICAgICAgICAgICAgICAgd29ybGRUb1B4RmFjdG9yICogaGFsZldpZHRoICogbm9ybWFsIC1cXG4gICAgICAgICAgICAgICAgICAgIHNpZ24odmVydGV4TWl0ZXIpICogdGFuZ2VudExlbmd0aCAqIHZlYzIobm9ybWFsLnksIC1ub3JtYWwueCksXFxuICAgICAgICAwLFxcbiAgICAgICAgMVxcbiAgICApO1xcblxcbiAgICB1diA9IHVucGFja1V2KHZlcnRleFV2UGFja2VkKSAqIGhhbGZXaWR0aDtcXG4gICAgbGVuID0gKHZlcnRleExlbmd0aCArIHNpZ24odmVydGV4VkxpbWl0KSAqIHRhbmdlbnRMZW5ndGgpIC8gd29ybGRUb1B4RmFjdG9yO1xcblxcbiAgICBkYXNoLnh5ID0gdmVjMihNQVhfRklMTF9HQVApICogdmVydGV4V2lkdGhGaWxsR2FwLnl6O1xcbiAgICBkYXNoLnogPSBkYXNoLnggKyBkYXNoLnk7XFxuXFxuICAgIGNvbG9yID0gdmVydGV4Q29sb3I7XFxuICAgIGNvbG9yLnJnYiAqPSBjb2xvci5hO1xcbn1cXG5cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL3BvbHlsaW5lL3NoYWRlci9wb2x5bGluZS52ZXJ0XG4vLyBtb2R1bGUgaWQgPSAxMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcIiN2ZXJzaW9uIDEwMFxcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxuI2lmbmRlZiBGSUxURVJfUkFESVVTXFxuIyAgIGVycm9yIEZJTFRFUl9SQURJVVMgbXVzdCBiZSBzZXRcXG4jZW5kaWZcXG5cXG52YXJ5aW5nIGhpZ2hwIHZlYzIgdXY7XFxudmFyeWluZyBoaWdocCBmbG9hdCBsZW47XFxudmFyeWluZyBoaWdocCBmbG9hdCBoYWxmV2lkdGg7XFxudmFyeWluZyBsb3dwIHZlYzMgZGFzaDtcXG52YXJ5aW5nIGxvd3AgdmVjNCBjb2xvcjtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgICBsb3dwIGZsb2F0IGFscGhhID1cXG4gICAgICAgIHNtb290aHN0ZXAoMC4wLCBGSUxURVJfUkFESVVTICsgbWluKEZJTFRFUl9SQURJVVMsIGhhbGZXaWR0aCksIGhhbGZXaWR0aCAtIGxlbmd0aCh1dikpO1xcblxcbiAgICBpZiAoZGFzaC56ID4gMC4wKSB7XFxuICAgICAgICBsb3dwIHZlYzMgaGFsZkRhc2ggPSBkYXNoICogMC41O1xcbiAgICAgICAgbG93cCBmbG9hdCBkYXNoUGhhc2UgPSBtb2QobGVuICsgaGFsZkRhc2gueSwgZGFzaC56KTtcXG4gICAgICAgIGxvd3AgZmxvYXQgciA9IG1pbihGSUxURVJfUkFESVVTLCBoYWxmRGFzaC55KTtcXG5cXG4gICAgICAgIGFscGhhICo9IHNtb290aHN0ZXAoLXIsIHIsIGhhbGZEYXNoLnggLSBhYnMoZGFzaFBoYXNlIC0gaGFsZkRhc2gueikpO1xcbiAgICB9XFxuXFxuICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yICogYWxwaGE7XFxufVxcblwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvcG9seWxpbmUvc2hhZGVyL3BvbHlsaW5lLmZyYWdcbi8vIG1vZHVsZSBpZCA9IDEzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgdGV4dHVyZWRQb2x5Z29uVmVydGV4U2hhZGVyIGZyb20gJy4vc2hhZGVyL3RleHR1cmVkX3BvbHlnb24udmVydCc7XHJcbmltcG9ydCB0ZXh0dXJlZFBvbHlnb25GcmFnbWVudFNoYWRlciBmcm9tICcuL3NoYWRlci90ZXh0dXJlZF9wb2x5Z29uLmZyYWcnO1xyXG5pbXBvcnQgKiBhcyB2ZWMyIGZyb20gJy4uLy4uLy4uL21hdGgvdmVjdG9yMic7XHJcbmltcG9ydCBSZW5kZXJTdGF0ZSBmcm9tICcuLi8uLi8uLi9yZW5kZXIvc3RhdGUnO1xyXG5pbXBvcnQgeyBCTEVORF9PVkVSX1JFTkRFUl9TVEFURSB9IGZyb20gJy4uLy4uLy4uL3JlbmRlci9zdGF0ZSc7XHJcbmltcG9ydCBXb3JsZFByaW1pdGl2ZVJlbmRlclVuaXQgZnJvbSAnLi4vd29ybGRfcHJpbWl0aXZlX3JlbmRlcl91bml0JztcclxuY29uc3QgUkVOREVSX1NUQVRFID0gbmV3IFJlbmRlclN0YXRlKEJMRU5EX09WRVJfUkVOREVSX1NUQVRFLCB7XHJcbiAgICBkZXB0aFRlc3Q6IHRydWUsXHJcbiAgICBkZXB0aE1hc2s6IGZhbHNlLFxyXG4gICAgZGVwdGhGdW5jOiA1MTggLyogR1JFQVRFUl9PUl9FUVVBTCAqL1xyXG59KTtcclxuLyoqXHJcbiAqIFJlbmRlcmVyIG9mIHBvbHlsaW5lIHByaW1pdGl2ZXMuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXh0dXJlZFBvbHlnb25SZW5kZXJVbml0IGV4dGVuZHMgV29ybGRQcmltaXRpdmVSZW5kZXJVbml0IHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIHByaW1pdGl2ZVByb3ZpZGVyKSB7XHJcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IGNvbnRleHQuY3JlYXRlUHJvZ3JhbSh0ZXh0dXJlZFBvbHlnb25WZXJ0ZXhTaGFkZXIsIHRleHR1cmVkUG9seWdvbkZyYWdtZW50U2hhZGVyLCB7XHJcbiAgICAgICAgICAgIGF0dHJpYk1hcDoge1xyXG4gICAgICAgICAgICAgICAgdmVydGV4UG9zSGlnaDogMCAvKiBQT1NJVElPTl9ISUdIICovLFxyXG4gICAgICAgICAgICAgICAgdmVydGV4UG9zTG93OiAxIC8qIFBPU0lUSU9OX0xPVyAqLyxcclxuICAgICAgICAgICAgICAgIHZlcnRleFVWOiA0IC8qIFVWICovLFxyXG4gICAgICAgICAgICAgICAgdmVydGV4SW1hZ2VTY2FsZTogMTEgLyogQVVYICovLFxyXG4gICAgICAgICAgICAgICAgdmVydGV4WkluZGV4OiAxMCAvKiBaX0lOREVYICovXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBzdXBlcihjb250ZXh0LCBSRU5ERVJfU1RBVEUsIHByb2dyYW0sIHByaW1pdGl2ZVByb3ZpZGVyKTtcclxuICAgICAgICB0aGlzLl9hdGxhc1NpemVVbmlmb3JtID0gdmVjMi5jcmVhdGUoMCwgMCk7XHJcbiAgICAgICAgY29udGV4dC5iaW5kUHJvZ3JhbShwcm9ncmFtKTtcclxuICAgICAgICBwcm9ncmFtLnNldEludFNjYWxhclVuaWZvcm0oJ2F0bGFzJywgMCk7XHJcbiAgICB9XHJcbiAgICBfcmVuZGVyQmF0Y2gobWVtb3J5QmF0Y2gpIHtcclxuICAgICAgICBjb25zdCBhdGxhcyA9IG1lbW9yeUJhdGNoLmZpcnN0UHJpbWl0aXZlLmF0bGFzO1xyXG4gICAgICAgIHRoaXMuX2F0bGFzU2l6ZVVuaWZvcm0ueCA9IGF0bGFzLndpZHRoO1xyXG4gICAgICAgIHRoaXMuX2F0bGFzU2l6ZVVuaWZvcm0ueSA9IGF0bGFzLmhlaWdodDtcclxuICAgICAgICBpZiAoYXRsYXMuaXNEaXJ0eSkge1xyXG4gICAgICAgICAgICBhdGxhcy5zeW5jVGV4dHVyZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9wcm9ncmFtLnNldFZlY3RvcjJVbmlmb3JtKCdhdGxhc1NpemUnLCB0aGlzLl9hdGxhc1NpemVVbmlmb3JtKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRUZXh0dXJlVW5pdCgwKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRUZXh0dXJlKGF0bGFzLnRleHR1cmUpO1xyXG4gICAgICAgIHN1cGVyLl9yZW5kZXJCYXRjaChtZW1vcnlCYXRjaCk7XHJcbiAgICB9XHJcbiAgICBfY2FuQmF0Y2hBZGphY2VudFByaW1pdGl2ZXMoYSwgYikge1xyXG4gICAgICAgIHJldHVybiBzdXBlci5fY2FuQmF0Y2hBZGphY2VudFByaW1pdGl2ZXMoYSwgYikgJiYgKGEuYXRsYXMgPT09IGIuYXRsYXMpO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL3BvbHlnb24vdGV4dHVyZWRfcG9seWdvbl9yZW5kZXJfdW5pdC50c1xuLy8gbW9kdWxlIGlkID0gMTQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleFBvc0hpZ2g7XFxuYXR0cmlidXRlIHZlYzIgdmVydGV4UG9zTG93O1xcbmF0dHJpYnV0ZSB2ZWM0IHZlcnRleFVWO1xcbmF0dHJpYnV0ZSBmbG9hdCB2ZXJ0ZXhJbWFnZVNjYWxlO1xcbmF0dHJpYnV0ZSBmbG9hdCB2ZXJ0ZXhaSW5kZXg7XFxuXFxudW5pZm9ybSB2ZWMyIGxvb2tBdEhpZ2g7XFxudW5pZm9ybSB2ZWMyIGxvb2tBdExvdztcXG51bmlmb3JtIG1hdDQgdmlld1Byb2pNYXRyaXg7XFxuXFxudmFyeWluZyB2ZWMyIHV2UG9zaXRpb247XFxudmFyeWluZyB2ZWMyIHRleHR1cmVTaXplO1xcbnZhcnlpbmcgdmVjMiB1dkRpc3BsYWNlbWVudDtcXG5cXG5jb25zdCBmbG9hdCBZVl9IID0gMS45OTk5Njk0ODI0MjE4NzU7XFxuY29uc3QgZmxvYXQgWVZfTCA9IDAuMDAwMDMwNTE3MTEyNDYzNzEyNjkyO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIHV2UG9zaXRpb24gPSB2ZXJ0ZXhVVi54eTtcXG4gICAgdGV4dHVyZVNpemUgPSB2ZXJ0ZXhVVi56dztcXG5cXG4gICAgLy8gVGhlIHNhbWUgcGF0dGVybiBpbWFnZSBzaG91bGQgbWF0Y2ggYWNyb3NzIG11bHRpcGxlICh1c3VhbGx5IGFkamFjZW50KSBwb2x5Z29ucyBhbmQgaXQgc2hvdWxkIGhhdmVcXG4gICAgLy8gc3RhYmxlIHBvc2l0aW9uIHJlYWx0aXZlIHRvIHRoZSBwb2x5Z29uLiBBbHNvIHBhdHRlcm4gaXMgcmVwZWF0ZWQgYXQgYm90aCBkaXJlY3Rpb25zLlxcbiAgICAvLyBUbyBtZWV0IHRoZXNlIHJlcXVpcmVtZW50cyB0aGUgd29ybGQgaXMgY292ZXJlZCAodmlydHVhbGx5KSBieSBhIHRleHR1cmUgb2YgYXBwcm9wcmlhdGUgc2l6ZSAocmVwZWF0ZWQgaW1hZ2UpXFxuICAgIC8vIGFuZCB2ZXJ0ZXggY29vcmRpbmF0ZXMgYXJlIG1hcHBlZCB0byB0aGVzZSB0ZXh0dXJlIGNvb3JkaW5hdGVzICh1dkRpc3BsYWNlbWVudCkuXFxuICAgIC8vIEJ1dCBkdWUgdG8gbGltaXRlZCBwcmVjaXNpb24gd2UndmUgZ290IHRvIHdvcmsgd2l0aCBcXFwibmFycm93XFxcIiBmbG9hdHMgKGFzIGl0IGlzIGRvbmUgaW4gd29ybGQgcG9zaXRpb24gY2FsY3VsYXRpb24pOlxcbiAgICAvLyAgIDEuIGNhbGN1bGF0ZSBob3cgYmlnIHRleHR1cmUgcGF0dGVybiBpbiB3b3JsZCBjb29yZGluYXRlcyAoc2NhbGVkVGV4dHVyZVNpemUpXFxuICAgIC8vICAgMi4gZmluZCB0aGUgY2xvc2VzdCB0byBleWUgY29vcmRpbmF0ZXMgdGV4dHVyZSBiYXNlIHBvaW50ICh0aGUgYm90dG9tIGxlZnQgcG9pbnQgb2YgdGhlIHBhdHRlcm4pXFxuICAgIC8vICAgMy4gdXNlIHZlcnRleCBwb3NpdGlvbiBhbmQgdGV4dHVyZUJhc2VQb2ludCB2ZWN0b3JzIHRvIGZpbmQgY29vcmRpbmF0ZXMgaW4gdmlydHVhbCB0ZXh0dXJlXFxuICAgIC8vICAgNC4gZmluZCB1diBjb29yZGluYXRlcyBpbiByZWFsIHRleHR1cmUgdXNpbmcgbW9kIG9wZXJhdGlvblxcbiAgICAvL1xcbiAgICAvLyBCb3RoIHRleHR1cmVCYXNlUG9pbnQgYW5kIHBvc2l0aW9uIGFyZSByZWxhdGl2ZWxseSBzbWFsbCB2ZWN0b3JzIHNvIHRoYXQgcHJlY2lzaW9uIHJlcXVpcmVtZW50cyBhcmUgbWV0LFxcbiAgICAvLyBhbmQgY29ycmVjdCBpbnRlcnBvbGF0aW9uIG9mIHJlcGVhdGVkIGltYWdlIGlzIHBvc3NpYmxlIGJ5IHVzaW5nIHNpbmdsZSBiYXNlIHBvaW50IGluIGFsbCB2ZXJ0aWNlcy5cXG5cXG4gICAgdmVjMiBzY2FsZWRUZXh0dXJlU2l6ZSA9IHRleHR1cmVTaXplICogdmVydGV4SW1hZ2VTY2FsZTsgLy8gdGV4dHVyZSBzaXplIGluIHdvcmxkIGNvb3JkaW5hdGVzXFxuICAgIHZlYzIgdGV4dHVyZUJhc2VQb2ludCA9IG1vZChZVl9IICogbG9va0F0SGlnaCwgc2NhbGVkVGV4dHVyZVNpemUpICsgbW9kKFlWX0wgKiBsb29rQXRMb3csIHNjYWxlZFRleHR1cmVTaXplKTtcXG4gICAgdmVjMiBwb3NpdGlvbiA9IFlWX0ggKiAodmVydGV4UG9zSGlnaCAtIGxvb2tBdEhpZ2gpICsgWVZfTCAqICh2ZXJ0ZXhQb3NMb3cgLSBsb29rQXRMb3cpO1xcblxcbiAgICBnbF9Qb3NpdGlvbiA9IHZpZXdQcm9qTWF0cml4ICogdmVjNChwb3NpdGlvbiwgMCwgMSk7XFxuICAgIGdsX1Bvc2l0aW9uLnh5IC89IGdsX1Bvc2l0aW9uLnc7XFxuICAgIGdsX1Bvc2l0aW9uLnogPSB2ZXJ0ZXhaSW5kZXg7XFxuICAgIGdsX1Bvc2l0aW9uLncgPSAxLjA7XFxuXFxuICAgIC8vIGNvbnZlcnQgd29ybGQgY29vcmRpbmF0ZXMgYmFjayB0byB0ZXR1cmUgcGl4ZWxzXFxuICAgIHV2RGlzcGxhY2VtZW50ID0gKHBvc2l0aW9uICsgdGV4dHVyZUJhc2VQb2ludCkgLyB2ZXJ0ZXhJbWFnZVNjYWxlO1xcbn1cXG5cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL3BvbHlnb24vc2hhZGVyL3RleHR1cmVkX3BvbHlnb24udmVydFxuLy8gbW9kdWxlIGlkID0gMTQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG5cXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbnVuaWZvcm0gc2FtcGxlcjJEIGF0bGFzO1xcbnVuaWZvcm0gdmVjMiBhdGxhc1NpemU7XFxuXFxudmFyeWluZyB2ZWMyIHV2UG9zaXRpb247XFxudmFyeWluZyB2ZWMyIHRleHR1cmVTaXplO1xcbnZhcnlpbmcgdmVjMiB1dkRpc3BsYWNlbWVudDtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgICB2ZWMyIHV2QWRqdXN0ZWQgPSB2ZWMyKFxcbiAgICAgICAgdXZQb3NpdGlvbi54ICsgbW9kKHV2RGlzcGxhY2VtZW50LngsIHRleHR1cmVTaXplLngpLFxcbiAgICAgICAgdXZQb3NpdGlvbi55ICsgbW9kKHV2RGlzcGxhY2VtZW50LnksIHRleHR1cmVTaXplLnkpXFxuICAgICk7XFxuXFxuICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRChhdGxhcywgdXZBZGp1c3RlZCAvIGF0bGFzU2l6ZSk7XFxufVxcblwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL3ByaW1pdGl2ZXMvcG9seWdvbi9zaGFkZXIvdGV4dHVyZWRfcG9seWdvbi5mcmFnXG4vLyBtb2R1bGUgaWQgPSAxNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IFBvbHlnb25SZW5kZXJlclVuaXQgZnJvbSAnLi9wb2x5Z29uX3JlbmRlcl91bml0JztcclxuaW1wb3J0IFJlbmRlclN0YXRlIGZyb20gJy4uLy4uLy4uL3JlbmRlci9zdGF0ZSc7XHJcbmltcG9ydCB7IERFRkFVTFRfUkVOREVSX1NUQVRFX1BBUkFNUyB9IGZyb20gJy4vcG9seWdvbl9yZW5kZXJfdW5pdCc7XHJcbmltcG9ydCB7IEJMRU5EX09WRVJfUkVOREVSX1NUQVRFIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyL3N0YXRlJztcclxuLyoqXHJcbiAqIFJlbmRlcmVyIG9mIHRyYW5zcGFyZW50IHBvbHlnb24gcHJpbWl0aXZlcy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRyYW5zcGFyZW50UG9seWdvblJlbmRlclVuaXQgZXh0ZW5kcyBQb2x5Z29uUmVuZGVyZXJVbml0IHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIHByaW1pdGl2ZVByb3ZpZGVyKSB7XHJcbiAgICAgICAgc3VwZXIoY29udGV4dCwgcHJpbWl0aXZlUHJvdmlkZXIsIG5ldyBSZW5kZXJTdGF0ZShERUZBVUxUX1JFTkRFUl9TVEFURV9QQVJBTVMsIHsgZGVwdGhNYXNrOiBmYWxzZSB9LCBCTEVORF9PVkVSX1JFTkRFUl9TVEFURSkpO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL3BvbHlnb24vdHJhbnNwYXJlbnRfcG9seWdvbl9yZW5kZXJfdW5pdC50c1xuLy8gbW9kdWxlIGlkID0gMTQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleFBvc0hpZ2g7XFxuYXR0cmlidXRlIHZlYzIgdmVydGV4UG9zTG93O1xcbmF0dHJpYnV0ZSB2ZWM0IHZlcnRleENvbG9yO1xcbmF0dHJpYnV0ZSBmbG9hdCB2ZXJ0ZXhaSW5kZXg7XFxuXFxudW5pZm9ybSB2ZWMyIGxvb2tBdEhpZ2g7XFxudW5pZm9ybSB2ZWMyIGxvb2tBdExvdztcXG51bmlmb3JtIG1hdDQgdmlld1Byb2pNYXRyaXg7XFxuXFxudmFyeWluZyB2ZWM0IGNvbG9yO1xcblxcbmNvbnN0IGZsb2F0IFlWX0ggPSAxLjk5OTk2OTQ4MjQyMTg3NTtcXG5jb25zdCBmbG9hdCBZVl9MID0gMC4wMDAwMzA1MTcxMTI0NjM3MTI2OTI7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gICAgdmVjNCBwb3NpdGlvbiA9IHZpZXdQcm9qTWF0cml4ICogdmVjNChcXG4gICAgICAgIFlWX0ggKiAodmVydGV4UG9zSGlnaCAtIGxvb2tBdEhpZ2gpICtcXG4gICAgICAgICAgICBZVl9MICogKHZlcnRleFBvc0xvdyAtIGxvb2tBdExvdyksXFxuICAgICAgICAwLFxcbiAgICAgICAgMVxcbiAgICApO1xcblxcbiAgICBwb3NpdGlvbi54eSAvPSBwb3NpdGlvbi53O1xcbiAgICBwb3NpdGlvbi56ID0gdmVydGV4WkluZGV4O1xcbiAgICBwb3NpdGlvbi53ID0gMS4wO1xcblxcbiAgICBnbF9Qb3NpdGlvbiA9IHBvc2l0aW9uO1xcblxcbiAgICBjb2xvciA9IHZlcnRleENvbG9yO1xcbn1cXG5cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL3BvbHlnb24vc2hhZGVyL3BvbHlnb24udmVydFxuLy8gbW9kdWxlIGlkID0gMTQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbnZhcnlpbmcgbG93cCB2ZWM0IGNvbG9yO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbn1cXG5cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9wcmltaXRpdmVzL3BvbHlnb24vc2hhZGVyL3BvbHlnb24uZnJhZ1xuLy8gbW9kdWxlIGlkID0gMTQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBFbmdpbmUgZnJvbSAnLi9lbmdpbmUnO1xyXG5pbXBvcnQgRnhhYVJlbmRlclVuaXQgZnJvbSAnLi9yZW5kZXIvZnhhYV9yZW5kZXJfdW5pdCc7XHJcbmltcG9ydCBCYWNrZ3JvdW5kUmVuZGVyVW5pdCBmcm9tICcuL3JlbmRlci9iYWNrZ3JvdW5kX3JlbmRlcl91bml0JztcclxuaW1wb3J0IExheWVyUmVuZGVyVW5pdCBmcm9tICcuL3JlbmRlci9sYXllcl9yZW5kZXJfdW5pdCc7XHJcbi8qKlxyXG4gKiBHcm91bmQgbGF5ZXIgd2l0aCBiYWNrZ3JvdW5kIHRoYXQgZ29lcyByaWdodCBhZnRlciBzdWIgcmVuZGVyIHVuaXRzLiBJdCBhbGxvd3MgdG8gYWRkIG90aGVyIExheWVyUmVuZGVyVW5pdHMgYWJvdmVcclxuICogZ3JvdW5kTGF5ZXIgd2l0aG91dCB3b3JyeWluZyB0aGF0IHRoZXkgZGVzdHJveSBkZXB0aCBpbmZvcm1hdGlvbiBjb2xsZWN0ZWQgb24gZ3JvdW5kIGFuZCBicm9rZSBiYWNrZ3JvdW5kICh0aGF0IGhhc1xyXG4gKiBhIHBlcmZvcm1hbmNlIG9wdGltaXNhdGlvbjogaXQgdXNlcyBkZXB0aCBpbmZvcm1hdGlvbiBmcm9tIHRoZSBsYXllcnMgYmVsb3cgdG8gcHJldmVudCBleHRlbnNpdmUgcGl4ZWwgb3ZlcndyaXRpbmcpLlxyXG4gKi9cclxuY2xhc3MgQmFja2dyb3VuZGVkR3JvdW5kTGF5ZXIgZXh0ZW5kcyBMYXllclJlbmRlclVuaXQge1xyXG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgZGVwdGhDbGVhclN0cmF0ZWd5ID0gMCAvKiBOT19DTEVBUiAqLykge1xyXG4gICAgICAgIHN1cGVyKGNvbnRleHQsIGRlcHRoQ2xlYXJTdHJhdGVneSk7XHJcbiAgICAgICAgdGhpcy5fYmFja2dyb3VuZCA9IG5ldyBCYWNrZ3JvdW5kUmVuZGVyVW5pdChjb250ZXh0KTtcclxuICAgIH1cclxuICAgIHJlbmRlcih0YXJnZXQsIC4uLmFyZ3MpIHtcclxuICAgICAgICBzdXBlci5yZW5kZXIodGFyZ2V0LCAuLi5hcmdzKTtcclxuICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kLnJlbmRlcih0YXJnZXQpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hcEVuZ2luZSBleHRlbmRzIEVuZ2luZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBjYW1lcmEsIHJlbmRlckxvb3ApIHtcclxuICAgICAgICBzdXBlcihjb250ZXh0LCBjYW1lcmEsIHJlbmRlckxvb3ApO1xyXG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lhYmxlcyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IGFudGlhbGlhc2luZ0xheWVyID0gbmV3IEZ4YWFSZW5kZXJVbml0KGNvbnRleHQsIHRoaXMucmVuZGVyTG9vcCk7XHJcbiAgICAgICAgdGhpcy5iYWNrZ291bmRMYXllciA9IG5ldyBMYXllclJlbmRlclVuaXQoY29udGV4dCk7XHJcbiAgICAgICAgdGhpcy5ncm91bmRMYXllciA9IG5ldyBCYWNrZ3JvdW5kZWRHcm91bmRMYXllcihjb250ZXh0KTtcclxuICAgICAgICB0aGlzLmJ1aWxkaW5nc0xheWVyID0gbmV3IExheWVyUmVuZGVyVW5pdChjb250ZXh0KTtcclxuICAgICAgICB0aGlzLmljb25zTGF5ZXIgPSBuZXcgTGF5ZXJSZW5kZXJVbml0KGNvbnRleHQpO1xyXG4gICAgICAgIHRoaXMubGFiZWxzTGF5ZXIgPSBuZXcgTGF5ZXJSZW5kZXJVbml0KGNvbnRleHQpO1xyXG4gICAgICAgIGFudGlhbGlhc2luZ0xheWVyLmFkZFJlbmRlclVuaXQodGhpcy5idWlsZGluZ3NMYXllcik7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRSZW5kZXJVbml0KHRoaXMuYmFja2dvdW5kTGF5ZXIpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIuYWRkUmVuZGVyVW5pdCh0aGlzLmdyb3VuZExheWVyKTtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZFJlbmRlclVuaXQoYW50aWFsaWFzaW5nTGF5ZXIpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIuYWRkUmVuZGVyVW5pdCh0aGlzLmljb25zTGF5ZXIpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIuYWRkUmVuZGVyVW5pdCh0aGlzLmxhYmVsc0xheWVyKTtcclxuICAgICAgICB0aGlzLl9kZXN0cm95YWJsZXMucHVzaChhbnRpYWxpYXNpbmdMYXllcik7XHJcbiAgICAgICAgLy8gZm9yY2UgaW5pdGlhbCByZW5kZXJpbmcgKG5vIGRhdGEgeWV0LCBqdXN0IGJhY2tncm91bmQpIGFzIHRoZSBjYW52YXMgKGJsYWNrKSBjYW4gYWxyZWFkeSBiZSB2aXNpYmxlIHRvIHVzZXJzLFxyXG4gICAgICAgIC8vIHJlbmRlcmVyIGlzIGNhbGxlZCBkaXJlY3RseSAod2l0aG91dCBzY2hlZHVsaW5nIHZpYSByZW5kZXIgbG9vcCkgYXMgaXQgaXMgcHJldHR5IG11Y2ggc2FmZSB0byBhc3N1bWVcclxuICAgICAgICAvLyB0aGF0IG5vIHJlbmRlcmluZyBpcyBzY2hlZHVsZWQgZm9yIHRoaXMgZnJhbWUsIGFuZCBkZWZlcnJlZCB1cGRhdGUgY2FuIHBvdGVudGlhbGx5IGNhdXNlIGEgc2luZ2xlIGZyYW1lIGJsaW5rXHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5fcmVuZGVyVGFyZ2V0KTtcclxuICAgIH1cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgLy8gZGVzdHJveSBpbiByZXZlcnNlIG9yZGVyIHRvIHByZXZlbnQgcG90ZW50aWFsIGlzc3VlcyBpZiBkZXN0cm95YWJsZXMgb3duIGVhY2ggb3RoZXJcclxuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5fZGVzdHJveWFibGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3lhYmxlc1tpXS5kZXN0cm95KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9tYXBfZW5naW5lLnRzXG4vLyBtb2R1bGUgaWQgPSAxNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgVm9pZEV2ZW50RW1pdHRlciB9IGZyb20gJy4vdXRpbC9ldmVudF9lbWl0dGVyJztcclxuaW1wb3J0IFJlbmRlcmFibGVEZkdseXBoQXRsYXMgZnJvbSAnLi9yZW5kZXIvZm9udC9yZW5kZXJhYmxlX2RmX2dseXBoX2F0bGFzJztcclxuaW1wb3J0IERmRm9udFJlZ2lzdHJ5IGZyb20gJy4vZm9udC9kZl9mb250X3JlZ2lzdHJ5JztcclxuaW1wb3J0IFJlbmRlcmFibGVJbWFnZUF0bGFzIGZyb20gJy4vcmVuZGVyL2JpbGxib2FyZC9yZW5kZXJhYmxlX2ltYWdlX2F0bGFzJztcclxuaW1wb3J0IFZpc2liaWxpdHlNYW5hZ2VyIGZyb20gJy4vdmlzaWJpbGl0eS92aXNpYmlsaXR5X21hbmFnZXInO1xyXG5pbXBvcnQgeyBtZWRpYW5GaWx0ZXIgfSBmcm9tICcuL3V0aWwvbWVkaWFuX2ZpbHRlcic7XHJcbmltcG9ydCB7IGNvdW50RnBzIH0gZnJvbSAnLi91dGlsL3N0YXQnO1xyXG5pbXBvcnQgTWFpblJlbmRlclVuaXQgZnJvbSAnLi9yZW5kZXIvbWFpbl9yZW5kZXJfdW5pdCc7XHJcbmltcG9ydCBNZW1vcnlNYW5hZ2VyIGZyb20gJy4vcmVuZGVyL21lbW9yeS9tYW5hZ2VyJztcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRW5naW5lIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIGNhbWVyYSwgcmVuZGVyTG9vcCkge1xyXG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XHJcbiAgICAgICAgdGhpcy5fY2FtZXJhID0gY2FtZXJhO1xyXG4gICAgICAgIHRoaXMuX3JlbmRlclRhcmdldCA9IGNvbnRleHQuZ2V0RGVmYXVsdFJlbmRlclRhcmdldCgpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgTWFpblJlbmRlclVuaXQoY29udGV4dCwgY2FtZXJhKTtcclxuICAgICAgICB0aGlzLnJlbmRlckxvb3AgPSByZW5kZXJMb29wO1xyXG4gICAgICAgIHRoaXMubWVtb3J5TWFuYWdlciA9IG5ldyBNZW1vcnlNYW5hZ2VyKGNvbnRleHQpO1xyXG4gICAgICAgIHRoaXMuX2F0bGFzZXMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgdGhpcy52aXNpYmlsaXR5TWFuYWdlciA9IG5ldyBWaXNpYmlsaXR5TWFuYWdlcihjb250ZXh0LCBjYW1lcmEsIHJlbmRlckxvb3AsIHRoaXMuX3JlbmRlclRhcmdldC5nZXRXaWR0aCgpLCB0aGlzLl9yZW5kZXJUYXJnZXQuZ2V0SGVpZ2h0KCkpO1xyXG4gICAgICAgIHRoaXMudmlzYmlsaXR5VGV4dHVyZVByb3ZpZGVyID0gKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnZpc2liaWxpdHlNYW5hZ2VyLnVwZGF0ZVZpc2liaWxpdHlJZk5lZWRlZCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aXNpYmlsaXR5TWFuYWdlci52aXNpYmlsaXR5VGV4dHVyZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuX2ZyYW1lVGltaW5nc0xpc3RlbmVyID0gdGhpcy5fb25GcmFtZVRpbWVzRnVsbC5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHJlbmRlckxvb3Aub25GcmFtZVRpbWVzRnVsbC5hZGRMaXN0ZW5lcih0aGlzLl9mcmFtZVRpbWluZ3NMaXN0ZW5lcik7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyTGlzdGVuZXIgPSB0aGlzLl9vblJlbmRlci5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHJlbmRlckxvb3Aub25SZW5kZXIuYWRkTGlzdGVuZXIodGhpcy5fcmVuZGVyTGlzdGVuZXIpO1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZUxpc3RlbmVyID0gKCkgPT4gdGhpcy5yZW5kZXJMb29wLnVwZGF0ZSgpO1xyXG4gICAgICAgIHRoaXMuZ2x5cGhBdGxhcyA9IG5ldyBSZW5kZXJhYmxlRGZHbHlwaEF0bGFzKGNvbnRleHQpO1xyXG4gICAgICAgIHRoaXMuZm9udFJlZ2lzdHJ5ID0gbmV3IERmRm9udFJlZ2lzdHJ5KCk7XHJcbiAgICAgICAgdGhpcy5vbkludGVybmFsRXJyb3IgPSBuZXcgVm9pZEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMuX2NhbWVyYS5vblVwZGF0ZS5hZGRMaXN0ZW5lcih0aGlzLl91cGRhdGVMaXN0ZW5lcik7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5vblVwZGF0ZS5hZGRMaXN0ZW5lcih0aGlzLl91cGRhdGVMaXN0ZW5lcik7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dExvc3RMaXN0ZW5lciA9ICgpID0+IHRoaXMub25JbnRlcm5hbEVycm9yLmZpcmUoKTtcclxuICAgICAgICB0aGlzLmNvbnRleHQub25Mb3NzLmFkZExpc3RlbmVyKHRoaXMuX2NvbnRleHRMb3N0TGlzdGVuZXIpO1xyXG4gICAgfVxyXG4gICAgc2V0UmVuZGVyVGFyZ2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3JlbmRlclRhcmdldC5nZXRXaWR0aCgpICE9PSB3aWR0aCB8fFxyXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJUYXJnZXQuZ2V0SGVpZ2h0KCkgIT09IGhlaWdodCkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJUYXJnZXQuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICAgICAgdGhpcy52aXNpYmlsaXR5TWFuYWdlci5zZXRUYXJnZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNyZWF0ZUltYWdlQXRsYXMocGFyYW1zKSB7XHJcbiAgICAgICAgY29uc3QgYXRsYXMgPSBuZXcgUmVuZGVyYWJsZUltYWdlQXRsYXModGhpcy5jb250ZXh0LCBwYXJhbXMpO1xyXG4gICAgICAgIGF0bGFzLm9uQ29udGVudFVwZGF0ZS5hZGRMaXN0ZW5lcih0aGlzLl91cGRhdGVMaXN0ZW5lcik7XHJcbiAgICAgICAgdGhpcy5fYXRsYXNlcy5hZGQoYXRsYXMpO1xyXG4gICAgICAgIHJldHVybiBhdGxhcztcclxuICAgIH1cclxuICAgIHJlbW92ZUltYWdlQXRsYXMoYXRsYXMpIHtcclxuICAgICAgICBhdGxhcy5kZXN0cm95KCk7XHJcbiAgICAgICAgYXRsYXMub25Db250ZW50VXBkYXRlLnJlbW92ZUxpc3RlbmVyKHRoaXMuX3VwZGF0ZUxpc3RlbmVyKTtcclxuICAgICAgICB0aGlzLl9hdGxhc2VzLmRlbGV0ZShhdGxhcyk7XHJcbiAgICB9XHJcbiAgICBnZXRDYW1lcmEoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbWVyYTtcclxuICAgIH1cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5fY2FtZXJhLm9uVXBkYXRlLnJlbW92ZUxpc3RlbmVyKHRoaXMuX3VwZGF0ZUxpc3RlbmVyKTtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyLm9uVXBkYXRlLnJlbW92ZUxpc3RlbmVyKHRoaXMuX3VwZGF0ZUxpc3RlbmVyKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGF0bGFzIG9mIHRoaXMuX2F0bGFzZXMpIHtcclxuICAgICAgICAgICAgYXRsYXMub25Db250ZW50VXBkYXRlLnJlbW92ZUxpc3RlbmVyKHRoaXMuX3VwZGF0ZUxpc3RlbmVyKTtcclxuICAgICAgICAgICAgYXRsYXMuZGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmdseXBoQXRsYXMuZGVzdHJveSgpO1xyXG4gICAgICAgIHRoaXMuY29udGV4dC5vbkxvc3MucmVtb3ZlTGlzdGVuZXIodGhpcy5fY29udGV4dExvc3RMaXN0ZW5lcik7XHJcbiAgICB9XHJcbiAgICBfb25SZW5kZXIoKSB7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5fcmVuZGVyVGFyZ2V0KTtcclxuICAgIH1cclxuICAgIF9vbkZyYW1lVGltZXNGdWxsKHRpbWVzKSB7XHJcbiAgICAgICAgY291bnRGcHMoMWUzICogdGltZXMubGVuZ3RoIC8gbWVkaWFuRmlsdGVyKHRpbWVzKS5yZWR1Y2UoKHN1bSwgdGltZSkgPT4gc3VtICsgdGltZSkpO1xyXG4gICAgICAgIC8vIEZvciBub3cgd2UgYWNxdWlyZSBmcmFtZSB0aW1pbmcgYW5kIGxvZyB0aGVtIG9ubHkgb25jZSBhIHNlc3Npb24uXHJcbiAgICAgICAgdGhpcy5yZW5kZXJMb29wLm9uRnJhbWVUaW1lc0Z1bGwucmVtb3ZlTGlzdGVuZXIodGhpcy5fZnJhbWVUaW1pbmdzTGlzdGVuZXIpO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2VuZ2luZS50c1xuLy8gbW9kdWxlIGlkID0gMTQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBEZkdseXBoQXRsYXMgZnJvbSAnLi4vLi4vZm9udC9kZl9nbHlwaF9hdGxhcyc7XHJcbi8qKlxyXG4gKiBBdGxhcyB0aGF0IG1hbmFnZXMgYWxsb2NhdGlvbiBpbiBHTCB0ZXh0dXJlLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVuZGVyYWJsZURmR2x5cGhBdGxhcyBleHRlbmRzIERmR2x5cGhBdGxhcyB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XHJcbiAgICAgICAgc3VwZXIoMCwgMCwgbmV3IFVpbnQ4QXJyYXkoMCksIG5ldyBNYXAoKSk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XHJcbiAgICAgICAgdGhpcy50ZXh0dXJlID0gdGhpcy5fY3JlYXRlVGV4dHVyZSgwLCAwKTtcclxuICAgIH1cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy50ZXh0dXJlLmRlc3Ryb3koKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgd2hvbGUgY29udGVudCBvZiB0aGUgZ2x5cGggYml0bWFwIGF0bGFzLCB0ZXh0dXJlIGFsc28gZ2V0IHVwZGF0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHdpZHRoIG5ldyBiaXRtYXAgd2lkdGhcclxuICAgICAqIEBwYXJhbSBoZWlnaHQgbmV3IGJpdG1hcCBoZWlnaHRcclxuICAgICAqIEBwYXJhbSBkYXRhLCBsZW5ndGggc2hvdWxkIGJlIHN0cmljdGx5IGVxdWFsIHRvIHdpZHRoICogaGVpZ2h0XHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZUNvbnRlbnQod2lkdGgsIGhlaWdodCwgZGF0YSwgZ2x5cGhMb2NhdGlvbnMpIHtcclxuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgICAgICB0aGlzLl9nbHlwaExvY2F0aW9ucyA9IGdseXBoTG9jYXRpb25zO1xyXG4gICAgICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLnRleHR1cmU7XHJcbiAgICAgICAgaWYgKCF0ZXh0dXJlIHx8IHRleHR1cmUuZ2V0V2lkdGgoKSAhPT0gd2lkdGggfHwgdGV4dHVyZS5nZXRIZWlnaHQoKSAhPT0gaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRleHR1cmUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudGV4dHVyZS5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy50ZXh0dXJlID0gdGhpcy5fY3JlYXRlVGV4dHVyZSh3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5zZXRUZXh0dXJlRGF0YSh0aGlzLnRleHR1cmUsIGRhdGEpO1xyXG4gICAgfVxyXG4gICAgX2NyZWF0ZVRleHR1cmUod2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0LmNyZWF0ZUVtcHR5MkRUZXh0dXJlKHdpZHRoLCBoZWlnaHQsIDY0MDYgLyogQUxQSEEgKi8sIDUxMjEgLyogVU5TSUdORURfQllURSAqLywge1xyXG4gICAgICAgICAgICB3cmFwUzogMzMwNzEgLyogQ0xBTVBfVE9fRURHRSAqLyxcclxuICAgICAgICAgICAgd3JhcFQ6IDMzMDcxIC8qIENMQU1QX1RPX0VER0UgKi8sXHJcbiAgICAgICAgICAgIG1hZ25pZmljYXRpb25GaWx0ZXI6IDk3MjkgLyogTElORUFSICovLFxyXG4gICAgICAgICAgICBtaW5pZmljYXRpb25GaWx0ZXI6IDk3MjkgLyogTElORUFSICovLFxyXG4gICAgICAgICAgICBwcmVtdWx0aXBsaWVkQWxwaGE6IGZhbHNlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL2ZvbnQvcmVuZGVyYWJsZV9kZl9nbHlwaF9hdGxhcy50c1xuLy8gbW9kdWxlIGlkID0gMTQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImNvbnN0IFVOS05PV05fR0xZUEhfTE9DQVRJT04gPSB7XHJcbiAgICBtaW5YOiAwLFxyXG4gICAgbWF4WDogMCxcclxuICAgIG1pblk6IDAsXHJcbiAgICBtYXhZOiAwXHJcbn07XHJcbi8qKlxyXG4gKiBBYnN0cmFjdCBnbHlwaCBhdGxhcyBpbnRlcmZhY2UuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZkdseXBoQXRsYXMge1xyXG4gICAgY29uc3RydWN0b3Iod2lkdGgsIGhlaWdodCwgZGF0YSwgZ2x5cGhMb2NhdGlvbnMpIHtcclxuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgICAgICB0aGlzLl9nbHlwaExvY2F0aW9ucyA9IGdseXBoTG9jYXRpb25zO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIEdseXBoIGxvY2F0aW9uIG9yIGZha2UgbG9jYXRpb24gcG9pbnRpbmcgdG8gdGhlIG9yaWdpbiAoMCwgMCkuXHJcbiAgICAgKi9cclxuICAgIGdldEdseXBoTG9jYXRpb24oZm9udElkLCBnbHlwaElkKSB7XHJcbiAgICAgICAgY29uc3QgZ2x5cGhMb2NhdGlvbiA9IHRoaXMuX2dseXBoTG9jYXRpb25zLmdldChmb250SWQgKyBnbHlwaElkKTtcclxuICAgICAgICBpZiAoZ2x5cGhMb2NhdGlvbikge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2x5cGhMb2NhdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignV293LXdvdy13b3csIHNvbWV0aGluZyB3ZW50IHdyb25nLCB5b3Ugc2hvdWxkIG5vdCByZXF1ZXN0IG5vbmV4aXN0ZW50IGdseXBoIGxvY2F0aW9ucycpO1xyXG4gICAgICAgICAgICByZXR1cm4gVU5LTk9XTl9HTFlQSF9MT0NBVElPTjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gQWxsIGdseXBoIGxvY2F0aW9ucyBhcyBbZ2x5cGggaWQsIGdseXBoIGxvY2F0aW9uXSBhcnJheS4gR2x5cGggaWQgaXMgZm9udCBpZCBjb25jYXRlbmF0ZWQgd2l0aCBnbHlwaCBpZC5cclxuICAgICAqL1xyXG4gICAgZ2V0QWxsR2x5cGhMb2NhdGlvbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIFsuLi50aGlzLl9nbHlwaExvY2F0aW9ucy5lbnRyaWVzKCldO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2ZvbnQvZGZfZ2x5cGhfYXRsYXMudHNcbi8vIG1vZHVsZSBpZCA9IDE0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgRm9udFJlZ2lzdHJ5IGZyb20gJy4vZm9udF9yZWdpc3RyeSc7XHJcbmltcG9ydCBEZkZvbnQgZnJvbSAnLi9kZl9mb250JztcclxuLyoqXHJcbiAqIFJlZ2lzdHJ5IHRoYXQgc3RvcmVzIGRpc3RhbmNlIGZpZWxkIGZvbnRzLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGZGb250UmVnaXN0cnkgZXh0ZW5kcyBGb250UmVnaXN0cnkge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIobmV3IERmRm9udCgnVU5LTk9XTl9ERl9GT05UJywgMTQsIDApKTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9mb250L2RmX2ZvbnRfcmVnaXN0cnkudHNcbi8vIG1vZHVsZSBpZCA9IDE1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICogQSBjZW50cmFsIHN0b3JhZ2Ugb2YgYWxsIGF2YWlsYWJsZSBmb250cy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZvbnRSZWdpc3RyeSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB1bmtub3duRm9udEluc3RhbmNlIEFuIGluc3RhbmNlIG9mIHNwZWNpZmljIGZvbnQgdHlwZSB0byBiZSBzZXJ2ZWQgYXMgYSBzdHViIHdoZW4gbm9uZXhpc3RlbnQgZm9udFxyXG4gICAgICogICAgIGlzIHJlcXVlc3RlZC4gUmVxdWVzdGluZyBub25leGlzdGVudCBmb250cyBub3JtYWxseSBzaG91bGQgbm90IGhhcHBlbi5cclxuICAgICAqICAgICBUaGUgc3R1YiBqdXN0IGFsbG93cyB0byBhdm9pZCB0ZWRpb3VzIG51bGwgY2hlY2tzIGluIHJlZ2lzdHJ5IGNsaWVudHMuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHVua25vd25Gb250SW5zdGFuY2UpIHtcclxuICAgICAgICB0aGlzLl9mb250cyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLl91bmtub3duRm9udEluc3RhbmNlID0gdW5rbm93bkZvbnRJbnN0YW5jZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiBJZiBhIGZvbnQgd2l0aCBzcGVjaWZpZWQgaWQgaXMgaW4gdGhlIHJlZ2lzdHJ5LlxyXG4gICAgICovXHJcbiAgICBjb250YWlucyhmb250SWQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZm9udHMuaGFzKGZvbnRJZCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gRm9udCB3aXRoIHNwZWNpZmllZCBpZCBvciB1bmtub3duIGZvbnQgaW5zdGFuY2UgaWYgaXQgaXMgbm90IGZvdW5kLlxyXG4gICAgICovXHJcbiAgICBnZXQoZm9udElkKSB7XHJcbiAgICAgICAgY29uc3QgZm9udCA9IHRoaXMuX2ZvbnRzLmdldChmb250SWQpO1xyXG4gICAgICAgIGlmIChmb250KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmb250O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdXb3ctd293LXdvdywgc29tZXRoaW5nIHdlbnQgd3JvbmcsIHlvdSBzaG91bGQgbm90IHJlcXVlc3Qgbm9uZXhpc3RlbnQgZm9udHMnKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Vua25vd25Gb250SW5zdGFuY2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIEFsbCBzdG9yZWQgZm9udHMuXHJcbiAgICAgKi9cclxuICAgIGdldEFsbCgpIHtcclxuICAgICAgICByZXR1cm4gWy4uLnRoaXMuX2ZvbnRzLnZhbHVlcygpXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBuZXcgZm9yIHRvIHRoZSByZWdpc3RyeS5cclxuICAgICAqL1xyXG4gICAgYWRkKGZvbnQpIHtcclxuICAgICAgICB0aGlzLl9mb250cy5zZXQoZm9udC5pZCwgZm9udCk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvZm9udC9mb250X3JlZ2lzdHJ5LnRzXG4vLyBtb2R1bGUgaWQgPSAxNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IEltYWdlQXRsYXMgZnJvbSAnLi4vLi4vYmlsbGJvYXJkL2ltYWdlX2F0bGFzJztcclxuLyoqXHJcbiAqIEF0bGFzIHRoYXQgbWFuYWdlcyBhbGxvY2F0aW9uIGluIEdMIHRleHR1cmUuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW5kZXJhYmxlSW1hZ2VBdGxhcyBleHRlbmRzIEltYWdlQXRsYXMge1xyXG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgcGFyYW1zKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICBjb25zdCB7IGZpbHRlciwgcHJlbXVsdGlwbGllZEFscGhhIH0gPSBwYXJhbXM7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XHJcbiAgICAgICAgdGhpcy5fZmlsdGVyID0gZmlsdGVyO1xyXG4gICAgICAgIHRoaXMuX3ByZW11bHRpcGxpZWRBbHBoYSA9IHByZW11bHRpcGxpZWRBbHBoYTtcclxuICAgICAgICB0aGlzLnRleHR1cmUgPSB0aGlzLl9jcmVhdGVUZXh0dXJlKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCBmaWx0ZXIsIHByZW11bHRpcGxpZWRBbHBoYSk7XHJcbiAgICAgICAgdGhpcy5pc0RpcnR5ID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgR0wgdGV4dHVyZSB3aXRoIGNoYW5nZWQgZGF0YS4gU2hvdWxkIGJlIGNhbGxlZCBhZnRlciBlYWNoIGltYWdlIGFkZGVkIHRvIHRha2UgZWZmZWN0IGluIHNoYWRlcnMuXHJcbiAgICAgKi9cclxuICAgIHN5bmNUZXh0dXJlKCkge1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuc2V0VGV4dHVyZURhdGFGcm9tRG9tRWxlbWVudCh0aGlzLnRleHR1cmUsIHRoaXMuY2FudmFzKTtcclxuICAgICAgICB0aGlzLmlzRGlydHkgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIHVwZGF0ZUltYWdlKGxvY2F0aW9uLCBzb3VyY2VJbWFnZSwgbG9jYXRpb25SZWdpb24sIHNvdXJjZUltYWdlUmVnaW9uKSB7XHJcbiAgICAgICAgc3VwZXIudXBkYXRlSW1hZ2UobG9jYXRpb24sIHNvdXJjZUltYWdlLCBsb2NhdGlvblJlZ2lvbiwgc291cmNlSW1hZ2VSZWdpb24pO1xyXG4gICAgICAgIHRoaXMuaXNEaXJ0eSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMudGV4dHVyZS5kZXN0cm95KCk7XHJcbiAgICB9XHJcbiAgICBfZXhwYW5kKG5ld1dpZHRoLCBuZXdIZWlnaHQpIHtcclxuICAgICAgICBzdXBlci5fZXhwYW5kKG5ld1dpZHRoLCBuZXdIZWlnaHQpO1xyXG4gICAgICAgIHRoaXMudGV4dHVyZS5kZXN0cm95KCk7XHJcbiAgICAgICAgdGhpcy50ZXh0dXJlID0gdGhpcy5fY3JlYXRlVGV4dHVyZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcy5fZmlsdGVyLCB0aGlzLl9wcmVtdWx0aXBsaWVkQWxwaGEpO1xyXG4gICAgICAgIHRoaXMuaXNEaXJ0eSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBfY3JlYXRlVGV4dHVyZSh3aWR0aCwgaGVpZ2h0LCBmaWx0ZXIsIHByZW11bHRpcGxpZWRBbHBoYSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0LmNyZWF0ZUVtcHR5MkRUZXh0dXJlKHdpZHRoLCBoZWlnaHQsIDY0MDggLyogUkdCQSAqLywgNTEyMSAvKiBVTlNJR05FRF9CWVRFICovLCB7XHJcbiAgICAgICAgICAgIG1pbmlmaWNhdGlvbkZpbHRlcjogZmlsdGVyLFxyXG4gICAgICAgICAgICBtYWduaWZpY2F0aW9uRmlsdGVyOiBmaWx0ZXIsXHJcbiAgICAgICAgICAgIHdyYXBTOiAzMzA3MSAvKiBDTEFNUF9UT19FREdFICovLFxyXG4gICAgICAgICAgICB3cmFwVDogMzMwNzEgLyogQ0xBTVBfVE9fRURHRSAqLyxcclxuICAgICAgICAgICAgcHJlbXVsdGlwbGllZEFscGhhXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL2JpbGxib2FyZC9yZW5kZXJhYmxlX2ltYWdlX2F0bGFzLnRzXG4vLyBtb2R1bGUgaWQgPSAxNTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgY3JlYXRlQkJveDIgfSBmcm9tICcuLi9tYXRoL3ZlY3RvcjInO1xyXG5pbXBvcnQgeyBTaGVsZkFsbG9jYXRvcjJEIH0gZnJvbSAnLi4vdXRpbC9hbGxvY2F0b3JfMmQnO1xyXG5pbXBvcnQgeyBWb2lkRXZlbnRFbWl0dGVyIH0gZnJvbSAnLi4vdXRpbC9ldmVudF9lbWl0dGVyJztcclxuY29uc3QgSU5JVF9BVExBU19XSURUSCA9IDI1NjtcclxuY29uc3QgSU5JVF9BVExBU19IRUlHSFQgPSAyNTY7XHJcbmNvbnN0IE1BWF9BVExBU19XSURUSCA9IDIwNDg7XHJcbmNvbnN0IE1BWF9BVExBU19IRUlHSFQgPSAyMDQ4O1xyXG5jb25zdCBFWFBBTkRfRkFDVE9SID0gMjtcclxuLyoqXHJcbiAqIE1hbmFnZXMgYWxsb2NhdGlvbiBvZiBpbWFnZXMuIEl0IHJlc2l6ZXMgaXRzZWxmICh1cCB0byBhIGZpeGVkIGxpbWl0KSB3aGVuIHRoZXJlIGlzIG5vIHJlZ2lvblxyXG4gKiBvZiBlbm91Z2ggc2l6ZSBmb3IgdGhlIG5leHQgaW1hZ2UuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbWFnZUF0bGFzIHtcclxuICAgIGNvbnN0cnVjdG9yKGluaXRBdGxhc1dpZHRoID0gSU5JVF9BVExBU19XSURUSCwgaW5pdEF0bGFzSGVpZ2h0ID0gSU5JVF9BVExBU19IRUlHSFQpIHtcclxuICAgICAgICB0aGlzLm9uQ29udGVudFVwZGF0ZSA9IG5ldyBWb2lkRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IGluaXRBdGxhc1dpZHRoO1xyXG4gICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IGluaXRBdGxhc0hlaWdodDtcclxuICAgICAgICB0aGlzLl9jYW52YXNDb250ZXh0ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgICAgICB0aGlzLl9hbGxvY2F0b3IgPSBuZXcgU2hlbGZBbGxvY2F0b3IyRCh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcbiAgICB9XHJcbiAgICBnZXQgd2lkdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzLndpZHRoO1xyXG4gICAgfVxyXG4gICAgZ2V0IGhlaWdodCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jYW52YXMuaGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBbGxvY2F0ZXMgaW1hZ2UgYml0bWFwLlxyXG4gICAgICovXHJcbiAgICBhbGxvY2F0ZUltYWdlKGRlc2NyaXB0b3IsIGltYWdlKSB7XHJcbiAgICAgICAgY29uc3QgbG9jYXRpb24gPSB0aGlzLl9hbGxvY2F0ZShkZXNjcmlwdG9yKTtcclxuICAgICAgICBpZiAobG9jYXRpb24pIHtcclxuICAgICAgICAgICAgY29uc3QgcmVnaW9uID0gY3JlYXRlQkJveDIoMCwgZGVzY3JpcHRvci53aWR0aCwgMCwgZGVzY3JpcHRvci5oZWlnaHQpO1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUltYWdlKGxvY2F0aW9uLCBpbWFnZSwgcmVnaW9uLCByZWdpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbG9jYXRpb247XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlc2VydmVzIHNwYWNlIG9mIGFwcHJvcHJpYXRlIHNpemUgdGhhdCBjYW4gYmUgdXBkYXRlZCBsYXRlciB3aXRoIHVwZGF0ZUltYWdlKCkgbWV0aG9kLlxyXG4gICAgICovXHJcbiAgICByZXNlcnZlTG9jYXRpb24oZGVzY3JpcHRvcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hbGxvY2F0ZShkZXNjcmlwdG9yKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyBpbWFnZSBjb250ZW50IGluIGFwcHJvcHJpYXRlIGxvY2F0aW9uLiBBc3N1bWVzIHRoYXQgdGhlcmUgaXMgcmVhbGx5IHN1Y2ggbG9jYXRpb24gcmVzZXJ2ZWQsXHJcbiAgICAgKiBubyBjaGVjayBmb3IgdGhpcyBpcyBkb25lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsb2NhdGlvbiBMb2NhdGlvbiBpbiBhdGxhcyBvZiB0aGUgaW1hZ2UuXHJcbiAgICAgKiBAcGFyYW0gc291cmNlSW1hZ2UgSW1hZ2UgdG8gdXBkYXRlIGF0bGFzIGZyb20uXHJcbiAgICAgKiBAcGFyYW0gbG9jYXRpb25SZWdpb24gUmVnaW9uIChiYm94IHdpdGggY29vcmRpbmF0ZXMgcmVsYXRpdmUgdG8gdGhlIGxvY2F0aW9uJ3MgYmJveCkgb2YgdGhlIGxvY2F0aW9uIHRvIHVwZGF0ZS5cclxuICAgICAqIEBwYXJhbSBzb3VyY2VJbWFnZVJlZ2lvbiBSZWdpb24gb2YgdGhlIGltYWdlIChCQm94MiBpbiBpbWFnZSdzIGNvb3JkaW5hdGUgc3BhY2UpIHRvIGJlIGNvcGllZCBpbnRvIGF0bGFzLlxyXG4gICAgICovXHJcbiAgICB1cGRhdGVJbWFnZShsb2NhdGlvbiwgc291cmNlSW1hZ2UsIGxvY2F0aW9uUmVnaW9uID0gY3JlYXRlQkJveDIoMCwgbG9jYXRpb24ubWF4WCAtIGxvY2F0aW9uLm1pblgsIDAsIGxvY2F0aW9uLm1heFkgLSBsb2NhdGlvbi5taW5ZKSwgc291cmNlSW1hZ2VSZWdpb24gPSBjcmVhdGVCQm94MigwLCBzb3VyY2VJbWFnZS53aWR0aCwgMCwgc291cmNlSW1hZ2UuaGVpZ2h0KSkge1xyXG4gICAgICAgIGNvbnN0IHNyY1ggPSBzb3VyY2VJbWFnZVJlZ2lvbi5taW5YO1xyXG4gICAgICAgIGNvbnN0IHNyY1kgPSBzb3VyY2VJbWFnZVJlZ2lvbi5taW5ZO1xyXG4gICAgICAgIGNvbnN0IHNyY1cgPSBzb3VyY2VJbWFnZVJlZ2lvbi5tYXhYIC0gc291cmNlSW1hZ2VSZWdpb24ubWluWDtcclxuICAgICAgICBjb25zdCBzcmNIID0gc291cmNlSW1hZ2VSZWdpb24ubWF4WSAtIHNvdXJjZUltYWdlUmVnaW9uLm1pblk7XHJcbiAgICAgICAgY29uc3QgZHN0WCA9IGxvY2F0aW9uLm1pblggKyBsb2NhdGlvblJlZ2lvbi5taW5YO1xyXG4gICAgICAgIGNvbnN0IGRzdFkgPSBsb2NhdGlvbi5taW5ZICsgbG9jYXRpb25SZWdpb24ubWluWTtcclxuICAgICAgICBjb25zdCBkc3RXID0gbG9jYXRpb25SZWdpb24ubWF4WCAtIGxvY2F0aW9uUmVnaW9uLm1pblg7XHJcbiAgICAgICAgY29uc3QgZHN0SCA9IGxvY2F0aW9uUmVnaW9uLm1heFkgLSBsb2NhdGlvblJlZ2lvbi5taW5ZO1xyXG4gICAgICAgIHRoaXMuX2NhbnZhc0NvbnRleHQuY2xlYXJSZWN0KGRzdFgsIGRzdFksIGRzdFcsIGRzdEgpO1xyXG4gICAgICAgIHRoaXMuX2NhbnZhc0NvbnRleHQuZHJhd0ltYWdlKHNvdXJjZUltYWdlLCBzcmNYLCBzcmNZLCBzcmNXLCBzcmNILCBkc3RYLCBkc3RZLCBkc3RXLCBkc3RIKTtcclxuICAgICAgICB0aGlzLm9uQ29udGVudFVwZGF0ZS5maXJlKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERlYWxsb2NhdGVzIGltYWdlIGZyb20gdGhlIGF0bGFzLlxyXG4gICAgICovXHJcbiAgICByZW1vdmVJbWFnZShpbWFnZSkge1xyXG4gICAgICAgIHRoaXMuX2FsbG9jYXRvci5kZWFsbG9jYXRlKGltYWdlKTtcclxuICAgIH1cclxuICAgIF9hbGxvY2F0ZShkZXNjcmlwdG9yKSB7XHJcbiAgICAgICAgbGV0IGxvY2F0aW9uID0gdGhpcy5fYWxsb2NhdG9yLmFsbG9jYXRlKGRlc2NyaXB0b3IpO1xyXG4gICAgICAgIC8vIGluY3JlbWVudGFsIGV4cGFuZCBjYW4gYmUgaW5lZmZpY2llbnQgaWYgdHdvIG9yIG1vcmUgaXRlcmF0aW9ucyBhcmUgbmVlZGVkIHRvIGFsbG9jYXRlIGFuIGltYWdlLFxyXG4gICAgICAgIC8vIGJ1dCBpdCBpcyBleHBlY3RlZCB0byBiZSBhIHJhcmUgKGlmIGFueSkgY2FzZSwgcmV3b3JrIGlmIGl0IHR1cm5zIG91dCB0byBiZSB3cm9uZ1xyXG4gICAgICAgIHdoaWxlICghbG9jYXRpb24pIHtcclxuICAgICAgICAgICAgY29uc3QgZXhwYW5kZWRXaWR0aCA9IHRoaXMud2lkdGggKiBFWFBBTkRfRkFDVE9SO1xyXG4gICAgICAgICAgICBjb25zdCBleHBhbmRlZEhlaWdodCA9IHRoaXMuaGVpZ2h0ICogRVhQQU5EX0ZBQ1RPUjtcclxuICAgICAgICAgICAgaWYgKGV4cGFuZGVkV2lkdGggPD0gTUFYX0FUTEFTX1dJRFRIICYmIGV4cGFuZGVkSGVpZ2h0IDw9IE1BWF9BVExBU19IRUlHSFQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2V4cGFuZChleHBhbmRlZFdpZHRoLCBleHBhbmRlZEhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICBsb2NhdGlvbiA9IHRoaXMuX2FsbG9jYXRvci5hbGxvY2F0ZShkZXNjcmlwdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBsb2NhdGlvbjtcclxuICAgIH1cclxuICAgIF9leHBhbmQobmV3V2lkdGgsIG5ld0hlaWdodCkge1xyXG4gICAgICAgIHRoaXMuX2FsbG9jYXRvci5yZXNpemUobmV3V2lkdGgsIG5ld0hlaWdodCk7XHJcbiAgICAgICAgLy8gc2V0dGluZyBuZXcgd2lkdGgvaGVpZ2h0IHRvIGNhbnZhcyB3aWxsIGNsZWFyIGl0LFxyXG4gICAgICAgIC8vIHNvIGN1cnJlbnQgZGF0YSBpcyBzYXZlZCB0byBiZSByZXN0b3JlZCBpbW1lZGlhdGVseSBhZnRlciByZXNpemluZ1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9jYW52YXNDb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5jYW52YXMud2lkdGggPSBuZXdXaWR0aDtcclxuICAgICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSBuZXdIZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5fY2FudmFzQ29udGV4dC5wdXRJbWFnZURhdGEoZGF0YSwgMCwgMCk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYmlsbGJvYXJkL2ltYWdlX2F0bGFzLnRzXG4vLyBtb2R1bGUgaWQgPSAxNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgQXJlbmFBbGxvY2F0b3IsIEZyZWVMaXN0QWxsb2NhdG9yIH0gZnJvbSAnLi9hbGxvY2F0b3InO1xyXG4vKipcclxuICogQSByZWN0YW5ndWxhciByZWdpb24gd2l0aCBmaXhlZCBoZWlnaHQuIFV0aWxpdHkgY2xhc3MgZm9yIHNoZWxmIGFsbG9jYXRpb24gZGVmaW5lZCBiZWxvdy5cclxuICovXHJcbmNsYXNzIFNoZWxmIHtcclxuICAgIGNvbnN0cnVjdG9yKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5fYWxsb2NhdG9yID0gbmV3IEZyZWVMaXN0QWxsb2NhdG9yKHRoaXMud2lkdGgpO1xyXG4gICAgfVxyXG4gICAgYWxsb2NhdGUod2lkdGgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWxsb2NhdG9yLmFsbG9jYXRlKHdpZHRoKTtcclxuICAgIH1cclxuICAgIGRlYWxsb2NhdGUob2Zmc2V0KSB7XHJcbiAgICAgICAgdGhpcy5fYWxsb2NhdG9yLmRlYWxsb2NhdGUob2Zmc2V0KTtcclxuICAgIH1cclxuICAgIGlzQWxsb2NhdGVkKG9mZnNldCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hbGxvY2F0b3IuaXNBbGxvY2F0ZWQob2Zmc2V0KTtcclxuICAgIH1cclxuICAgIGNhbkFsbG9jYXRlKHdpZHRoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FsbG9jYXRvci5tYXhBbGxvY2FibGVTaXplID49IHdpZHRoO1xyXG4gICAgfVxyXG4gICAgcmVzaXplKHdpZHRoKSB7XHJcbiAgICAgICAgdGhpcy5fYWxsb2NhdG9yLmV4dGVuZCh3aWR0aCk7XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBbGxvY2F0ZXMgcmVjdGFuZ2xlcyBpbiBcInNoZWx2ZXNcIiAoaGVpZ2h0IGZpeGVkIHJlZ2lvbnMpLiBUaGV5IGFyZSBjcmVhdGVkIG9mIG5lY2Vzc2l0eSB3aGVuIHRoZSBuZXh0IG9iamVjdCBkb2VzbnRcclxuICogZml0IGFueSBleGlzdGluZyBzaGVsZi4gVG8gb3B0aW1pemUgc3BhY2UgdXNhZ2UgaXQgdHJpZXMgdG8gZmluZCB0aGUgYmVzdCBzaGVsZiBmb3IgYWxsb2NhdGlvbiAobWluIGhlaWdodCBkaWZmKS5cclxuICogQSBzaGVsZiB3aGVuIGFsbG9jYXRlZCBpcyBuZXZlciBkZWFsbG9jYXRlZCBiYWNrIGFuZCBleGlzdHMgZHVyaW5nIGFsbCB0aGUgYWxsb2NhdG9yIGxpZmV0aW1lLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFNoZWxmQWxsb2NhdG9yMkQge1xyXG4gICAgY29uc3RydWN0b3Iod2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICB0aGlzLl9zaGVsdmVzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuX3NoZWxmQWxsb2NhdG9yID0gbmV3IEFyZW5hQWxsb2NhdG9yKGhlaWdodCk7IC8vIG5vIHNoZWxmIGRlYWxsb2NhdGlvbiwgdGhhdCBpcyB3aHkgQXJlbmFBbGxvY2F0b3IgaXMgZmluZVxyXG4gICAgfVxyXG4gICAgYWxsb2NhdGUob2JqZWN0KSB7XHJcbiAgICAgICAgbGV0IGJlc3RTaGVsZjtcclxuICAgICAgICBsZXQgYmVzdFNoZWxmT2Zmc2V0ID0gLTE7XHJcbiAgICAgICAgbGV0IGJlc3RTaGVsZlJhdGlvID0gLTE7XHJcbiAgICAgICAgZm9yIChjb25zdCBbb2Zmc2V0LCBzaGVsZl0gb2YgdGhpcy5fc2hlbHZlcy5lbnRyaWVzKCkpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2hlbGZSYXRpbyA9IG9iamVjdC5oZWlnaHQgLyBzaGVsZi5oZWlnaHQ7XHJcbiAgICAgICAgICAgIGlmIChzaGVsZlJhdGlvID09PSAxICYmIHNoZWxmLmNhbkFsbG9jYXRlKG9iamVjdC53aWR0aCkpIHtcclxuICAgICAgICAgICAgICAgIGJlc3RTaGVsZiA9IHNoZWxmO1xyXG4gICAgICAgICAgICAgICAgYmVzdFNoZWxmT2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc2hlbGZSYXRpbyA8IDEgJiYgc2hlbGZSYXRpbyA+IGJlc3RTaGVsZlJhdGlvICYmIHNoZWxmLmNhbkFsbG9jYXRlKG9iamVjdC53aWR0aCkpIHtcclxuICAgICAgICAgICAgICAgIGJlc3RTaGVsZiA9IHNoZWxmO1xyXG4gICAgICAgICAgICAgICAgYmVzdFNoZWxmT2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgYmVzdFNoZWxmUmF0aW8gPSBzaGVsZlJhdGlvO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghYmVzdFNoZWxmICYmIHRoaXMuX3NoZWxmQWxsb2NhdG9yLm1heEFsbG9jYWJsZVNpemUgPj0gb2JqZWN0LmhlaWdodCAmJiB0aGlzLndpZHRoID49IG9iamVjdC53aWR0aCkge1xyXG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLl9zaGVsZkFsbG9jYXRvci5hbGxvY2F0ZShvYmplY3QuaGVpZ2h0KTtcclxuICAgICAgICAgICAgYmVzdFNoZWxmID0gbmV3IFNoZWxmKHRoaXMud2lkdGgsIG9iamVjdC5oZWlnaHQpO1xyXG4gICAgICAgICAgICBiZXN0U2hlbGZPZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgIHRoaXMuX3NoZWx2ZXMuc2V0KG9mZnNldCwgYmVzdFNoZWxmKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGJlc3RTaGVsZikge1xyXG4gICAgICAgICAgICBjb25zdCBsZWZ0ID0gYmVzdFNoZWxmLmFsbG9jYXRlKG9iamVjdC53aWR0aCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRvcCA9IGJlc3RTaGVsZk9mZnNldDtcclxuICAgICAgICAgICAgY29uc3QgbG9jYXRpb24gPSB7XHJcbiAgICAgICAgICAgICAgICBtaW5YOiBsZWZ0LFxyXG4gICAgICAgICAgICAgICAgbWF4WDogbGVmdCArIG9iamVjdC53aWR0aCxcclxuICAgICAgICAgICAgICAgIG1pblk6IHRvcCxcclxuICAgICAgICAgICAgICAgIG1heFk6IHRvcCArIG9iamVjdC5oZWlnaHRcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIGxvY2F0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZGVhbGxvY2F0ZShvYmplY3RMb2NhdGlvbikge1xyXG4gICAgICAgIGNvbnN0IHNoZWxmID0gdGhpcy5fc2hlbHZlcy5nZXQob2JqZWN0TG9jYXRpb24ubWluWSk7XHJcbiAgICAgICAgaWYgKHNoZWxmKSB7XHJcbiAgICAgICAgICAgIHNoZWxmLmRlYWxsb2NhdGUob2JqZWN0TG9jYXRpb24ubWluWCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaXNBbGxvY2F0ZWQob2JqZWN0TG9jYXRpb24pIHtcclxuICAgICAgICBjb25zdCBzaGVsZiA9IHRoaXMuX3NoZWx2ZXMuZ2V0KG9iamVjdExvY2F0aW9uLm1pblkpO1xyXG4gICAgICAgIHJldHVybiAhIXNoZWxmICYmIHNoZWxmLmlzQWxsb2NhdGVkKG9iamVjdExvY2F0aW9uLm1pblgpO1xyXG4gICAgfVxyXG4gICAgcmVzaXplKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICB0aGlzLl9zaGVsZkFsbG9jYXRvci5leHRlbmQoaGVpZ2h0KTtcclxuICAgICAgICBmb3IgKGNvbnN0IHNoZWxmIG9mIHRoaXMuX3NoZWx2ZXMudmFsdWVzKCkpIHtcclxuICAgICAgICAgICAgc2hlbGYucmVzaXplKHdpZHRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvYWxsb2NhdG9yXzJkLnRzXG4vLyBtb2R1bGUgaWQgPSAxNTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXHJcbiAqIFNpbXBsZSBpbXBsZW1lbnRhdGlvbiBvZiBCaW5hcnkgU2VhcmNoIFRyZWUuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQmluYXJ5U2VhcmNoVHJlZSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBjb21wYXJhdG9yIFRvIHNwZWNpZnkgdGhlIG9yZGVyIG9mIGl0ZW1zLCB0aGF0IGNhbiBiZSBhbnkgY29tcGxleCBvYmplY3RzLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihjb21wYXJhdG9yKSB7XHJcbiAgICAgICAgdGhpcy5fY29tcGFyYXRvciA9IGNvbXBhcmF0b3I7XHJcbiAgICAgICAgdGhpcy5fc2l6ZSA9IDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFRoZSByb290IGVsZW1lbnQgb3IgYHVuZGVmaW5lZGAgaWYgdGhlIHRyZWUgaXMgZW1wdHkuXHJcbiAgICAgKi9cclxuICAgIGdldCByb290KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9yb290O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSB0cmVlLlxyXG4gICAgICovXHJcbiAgICBnZXQgc2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVGhlIHNtYWxsZXN0IGVsZW1lbnQgaW4gdGhlIHRyZWUgb3IgYHVuZGVmaW5lZGAgdGhlIHRoZSB0cmVlIGlzIGVtcHR5LlxyXG4gICAgICovXHJcbiAgICBnZXQgbWluKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9yb290KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9taW4odGhpcy5fcm9vdCkudmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFRoZSBiaWdnZXN0IGVsZW1lbnQgaW4gdGhlIHRyZWUgb3IgYHVuZGVmaW5lZGAgdGhlIHRoZSB0cmVlIGlzIGVtcHR5LlxyXG4gICAgICovXHJcbiAgICBnZXQgbWF4KCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9yb290KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tYXgodGhpcy5fcm9vdCkudmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBpbnNlcnQoaXRlbSkge1xyXG4gICAgICAgIHRoaXMuX3NpemUrKztcclxuICAgICAgICBpZiAoIXRoaXMuX3Jvb3QpIHtcclxuICAgICAgICAgICAgdGhpcy5fcm9vdCA9IHsgdmFsdWU6IGl0ZW0gfTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBub2RlID0gdGhpcy5fcm9vdDtcclxuICAgICAgICB3aGlsZSAobm9kZSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fY29tcGFyYXRvcihpdGVtLCBub2RlLnZhbHVlKSA8IDApIHtcclxuICAgICAgICAgICAgICAgIGlmICghbm9kZS5sZWZ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUubGVmdCA9IHsgcGFyZW50OiBub2RlLCB2YWx1ZTogaXRlbSB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICghbm9kZS5yaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLnJpZ2h0ID0geyBwYXJlbnQ6IG5vZGUsIHZhbHVlOiBpdGVtIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpbXBvc3NpYmxlIHRvIGdldCB0aGVyZSwgdGhyb3dpbmcgaXMgdG8gbWFrZSBUUyBhbmFsaXphdG9yIGhhcHB5XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XHJcbiAgICB9XHJcbiAgICByZW1vdmUobm9kZSkge1xyXG4gICAgICAgIHRoaXMuX3NpemUtLTtcclxuICAgICAgICBpZiAobm9kZS5sZWZ0ICYmIG5vZGUucmlnaHQpIHtcclxuICAgICAgICAgICAgY29uc3Qgc3VjY2Vzc29yID0gdGhpcy5fbWluKG5vZGUucmlnaHQpO1xyXG4gICAgICAgICAgICB0aGlzLl9yZXBsYWNlU3VidHJlZShub2RlLCBzdWNjZXNzb3IpO1xyXG4gICAgICAgICAgICAvLyB1cGRhdGUgbGlua3MgdG8gY2hpbGRyZW4gb2YgdGhlIHJlbW92ZWQgbm9kZVxyXG4gICAgICAgICAgICBpZiAobm9kZS5sZWZ0KSB7XHJcbiAgICAgICAgICAgICAgICBzdWNjZXNzb3IubGVmdCA9IG5vZGUubGVmdDtcclxuICAgICAgICAgICAgICAgIG5vZGUubGVmdC5wYXJlbnQgPSBzdWNjZXNzb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG5vZGUucmlnaHQpIHtcclxuICAgICAgICAgICAgICAgIHN1Y2Nlc3Nvci5yaWdodCA9IG5vZGUucmlnaHQ7XHJcbiAgICAgICAgICAgICAgICBub2RlLnJpZ2h0LnBhcmVudCA9IHN1Y2Nlc3NvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChub2RlLmxlZnQpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVwbGFjZVN1YnRyZWUobm9kZSwgbm9kZS5sZWZ0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobm9kZS5yaWdodCkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZXBsYWNlU3VidHJlZShub2RlLCBub2RlLnJpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlcGxhY2VTdWJ0cmVlKG5vZGUsIHVuZGVmaW5lZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJdGVyYXRlcyBlbGVtZW50cyBpbiBhc2NlbmRpbmcgb3JkZXIuXHJcbiAgICAgKi9cclxuICAgICp2YWx1ZXMobm9kZSkge1xyXG4gICAgICAgIGlmIChub2RlKSB7XHJcbiAgICAgICAgICAgIHlpZWxkKiB0aGlzLnZhbHVlcyhub2RlLmxlZnQpO1xyXG4gICAgICAgICAgICB5aWVsZCBub2RlLnZhbHVlO1xyXG4gICAgICAgICAgICB5aWVsZCogdGhpcy52YWx1ZXMobm9kZS5yaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJdGVyYXRlcyBlbGVtZW50cyBpbiBhc2NlbmRpbmcgb3JkZXIuXHJcbiAgICAgKi9cclxuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlcyh0aGlzLl9yb290KTtcclxuICAgIH1cclxuICAgIF9taW4oZnJvbSkge1xyXG4gICAgICAgIGxldCBub2RlID0gZnJvbTtcclxuICAgICAgICB3aGlsZSAobm9kZS5sZWZ0KSB7XHJcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgfVxyXG4gICAgX21heChmcm9tKSB7XHJcbiAgICAgICAgbGV0IG5vZGUgPSBmcm9tO1xyXG4gICAgICAgIHdoaWxlIChub2RlLnJpZ2h0KSB7XHJcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVvcmdhbml6ZXMgdGhlIHRyZWUgc3RydWN0dXJlIHNvIHRoYXQgdGhlIHJlcGxhY2VtZW50IG5vZGUgdGFrZXMgcmVwbGFjZWFibGUncyBwb3NpdGlvbiwgdGhlIGxhdHRlciBpcyByZW1vdmVkLlxyXG4gICAgICovXHJcbiAgICBfcmVwbGFjZVN1YnRyZWUocmVwbGFjZWFibGUsIHJlcGxhY2VtZW50KSB7XHJcbiAgICAgICAgaWYgKHJlcGxhY2VhYmxlLnBhcmVudCkge1xyXG4gICAgICAgICAgICBpZiAocmVwbGFjZWFibGUucGFyZW50LmxlZnQgPT09IHJlcGxhY2VhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICByZXBsYWNlYWJsZS5wYXJlbnQubGVmdCA9IHJlcGxhY2VtZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHJlcGxhY2VhYmxlLnBhcmVudC5yaWdodCA9PT0gcmVwbGFjZWFibGUpIHtcclxuICAgICAgICAgICAgICAgIHJlcGxhY2VhYmxlLnBhcmVudC5yaWdodCA9IHJlcGxhY2VtZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9yb290ID0gcmVwbGFjZW1lbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZXBsYWNlbWVudCkge1xyXG4gICAgICAgICAgICAvLyByZW1vdmUgcmVwbGFjZW1lbnQgZnJvbSBpdHMgY3VycmVudCBsb2NhdGlvblxyXG4gICAgICAgICAgICBpZiAocmVwbGFjZW1lbnQucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVwbGFjZW1lbnQucGFyZW50LmxlZnQgPT09IHJlcGxhY2VtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQucGFyZW50LmxlZnQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXBsYWNlbWVudC5wYXJlbnQucmlnaHQgPT09IHJlcGxhY2VtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQucGFyZW50LnJpZ2h0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlcGxhY2VtZW50LnBhcmVudCA9IHJlcGxhY2VhYmxlLnBhcmVudDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9iaW5hcnlfdHJlZS50c1xuLy8gbW9kdWxlIGlkID0gMTU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxyXG4gKiBTZXQgd2l0aCBwcmVkaWN0YWJsZSBpdGVyYXRpb24gb3JkZXIuIFN0b3JlcyBpdGVtcyBhcyBhIHR3byB3YXkgbGlua2VkIGxpc3QgdGh1cyBhbGxvd2luZyB0byBpbnNlcnQgaXRlbXMgaW4gYmV0d2Vlbi5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpbmtlZFNldCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLl9ub2RlcyA9IG5ldyBNYXAoKTtcclxuICAgIH1cclxuICAgIGdldCBiZWdpbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYmVnaW4gJiYgdGhpcy5fYmVnaW4udmFsdWU7XHJcbiAgICB9XHJcbiAgICBnZXQgZW5kKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9lbmQgJiYgdGhpcy5fZW5kLnZhbHVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnNlcnRzIGEgbmV3IGl0ZW0gYXQgdGhlIGVuZCBvZiB0aGUgc2V0LlxyXG4gICAgICovXHJcbiAgICBpbnNlcnQoaXRlbSkge1xyXG4gICAgICAgIGlmICghdGhpcy5fbm9kZXMuaGFzKGl0ZW0pKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB7IHZhbHVlOiBpdGVtIH07XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9lbmQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5zZXJ0QWZ0ZXIodGhpcy5fZW5kLnZhbHVlLCBpdGVtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2JlZ2luID0gdGhpcy5fZW5kID0gbm9kZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX25vZGVzLnNldChpdGVtLCBub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSW5zZXJ0cyBhIG5ldyBpdGVtIGJlZm9yZSB0aGUgc3BlY2lmaWVkIG9uZS4gSWYgdGhlIGJlZm9yZSBpdGVtIGlzIG5vdCBpbiB0aGUgc2V0IG9yXHJcbiAgICAgKiB0aGUgaXRlbSBpcyBhbHJlYWR5IGluc2VydGVkIG5vdGhpbmcgaGFwcGVucy5cclxuICAgICAqL1xyXG4gICAgaW5zZXJ0QmVmb3JlKGJlZm9yZSwgaXRlbSkge1xyXG4gICAgICAgIGNvbnN0IGJlZm9yZU5vZGUgPSB0aGlzLl9ub2Rlcy5nZXQoYmVmb3JlKTtcclxuICAgICAgICBpZiAoYmVmb3JlTm9kZSAmJiAhdGhpcy5fbm9kZXMuaGFzKGl0ZW0pKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB7IHZhbHVlOiBpdGVtIH07XHJcbiAgICAgICAgICAgIGlmIChiZWZvcmVOb2RlLnByZXYpIHtcclxuICAgICAgICAgICAgICAgIGJlZm9yZU5vZGUucHJldi5uZXh0ID0gbm9kZTtcclxuICAgICAgICAgICAgICAgIG5vZGUucHJldiA9IGJlZm9yZU5vZGUucHJldjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBub2RlLm5leHQgPSBiZWZvcmVOb2RlO1xyXG4gICAgICAgICAgICBiZWZvcmVOb2RlLnByZXYgPSBub2RlO1xyXG4gICAgICAgICAgICB0aGlzLl9ub2Rlcy5zZXQoaXRlbSwgbm9kZSk7XHJcbiAgICAgICAgICAgIGlmIChiZWZvcmVOb2RlID09PSB0aGlzLl9iZWdpbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYmVnaW4gPSBub2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnNlcnRzIGEgbmV3IGl0ZW0gYWZ0ZXIgdGhlIHNwZWNpZmllZCBvbmUuIElmIHRoZSBhZnRlciBpdGVtIGlzIG5vdCBpbiB0aGUgc2V0IG9yXHJcbiAgICAgKiB0aGUgaXRlbSBpcyBhbHJlYWR5IGluc2VydGVkIG5vdGhpbmcgaGFwcGVucy5cclxuICAgICAqL1xyXG4gICAgaW5zZXJ0QWZ0ZXIoYWZ0ZXIsIGl0ZW0pIHtcclxuICAgICAgICBjb25zdCBhZnRlck5vZGUgPSB0aGlzLl9ub2Rlcy5nZXQoYWZ0ZXIpO1xyXG4gICAgICAgIGlmIChhZnRlck5vZGUgJiYgIXRoaXMuX25vZGVzLmhhcyhpdGVtKSkge1xyXG4gICAgICAgICAgICBjb25zdCBub2RlID0geyB2YWx1ZTogaXRlbSB9O1xyXG4gICAgICAgICAgICBpZiAoYWZ0ZXJOb2RlLm5leHQpIHtcclxuICAgICAgICAgICAgICAgIGFmdGVyTm9kZS5uZXh0LnByZXYgPSBub2RlO1xyXG4gICAgICAgICAgICAgICAgbm9kZS5uZXh0ID0gYWZ0ZXJOb2RlLm5leHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbm9kZS5wcmV2ID0gYWZ0ZXJOb2RlO1xyXG4gICAgICAgICAgICBhZnRlck5vZGUubmV4dCA9IG5vZGU7XHJcbiAgICAgICAgICAgIHRoaXMuX25vZGVzLnNldChpdGVtLCBub2RlKTtcclxuICAgICAgICAgICAgaWYgKGFmdGVyTm9kZSA9PT0gdGhpcy5fZW5kKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lbmQgPSBub2RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGl0ZW0gZnJvbSB0aGUgc2V0LlxyXG4gICAgICovXHJcbiAgICByZW1vdmUoaXRlbSkge1xyXG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLl9ub2Rlcy5nZXQoaXRlbSk7XHJcbiAgICAgICAgaWYgKG5vZGUpIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUgPT09IHRoaXMuX2JlZ2luKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9iZWdpbiA9IG5vZGUubmV4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobm9kZSA9PT0gdGhpcy5fZW5kKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lbmQgPSBub2RlLnByZXY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG5vZGUubmV4dCkge1xyXG4gICAgICAgICAgICAgICAgbm9kZS5uZXh0LnByZXYgPSBub2RlLnByZXY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG5vZGUucHJldikge1xyXG4gICAgICAgICAgICAgICAgbm9kZS5wcmV2Lm5leHQgPSBub2RlLm5leHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fbm9kZXMuZGVsZXRlKGl0ZW0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgYHVuZGVmaW5lZGAgaWYgdGhlIGl0ZW0gaXMgbm90IGluIHRoZSBzZXQgb3IgaXQgaXMgdGhlIGZpcnN0IGVsZW1lbnRzLlxyXG4gICAgICovXHJcbiAgICBnZXRQcmV2KGl0ZW0pIHtcclxuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5fbm9kZXMuZ2V0KGl0ZW0pO1xyXG4gICAgICAgIGlmIChub2RlICYmIG5vZGUucHJldikge1xyXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5wcmV2LnZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBgdW5kZWZpbmVkYCBpZiB0aGUgaXRlbSBpcyBub3QgaW4gdGhlIHNldCBvciBpdCBpcyB0aGUgbGFzdCBlbGVtZW50cy5cclxuICAgICAqL1xyXG4gICAgZ2V0TmV4dChpdGVtKSB7XHJcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuX25vZGVzLmdldChpdGVtKTtcclxuICAgICAgICBpZiAobm9kZSAmJiBub2RlLm5leHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5vZGUubmV4dC52YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSXRlcmF0ZXMgb3ZlciB0aGUgc2V0IGZyb20gdGhlIGZpc3QgZWxlbWVudCB0byB0aGUgbGFzdCAoaW4gdGhlIG9yZGVyIG9mIGluc2VydGlvblxyXG4gICAgICogaWYgdGhlIGluc2VydCBtZXRob2Qgd2FzIHVzZWQgb25seSkuXHJcbiAgICAgKi9cclxuICAgICp2YWx1ZXMoKSB7XHJcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLl9iZWdpbjtcclxuICAgICAgICB3aGlsZSAobm9kZSkge1xyXG4gICAgICAgICAgICB5aWVsZCBub2RlLnZhbHVlO1xyXG4gICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSXRlcmF0ZXMgb3ZlciB0aGUgc2V0IGZyb20gdGhlIGZpc3QgZWxlbWVudCB0byB0aGUgbGFzdCAoaW4gdGhlIG9yZGVyIG9mIGluc2VydGlvblxyXG4gICAgICogaWYgdGhlIGluc2VydCBtZXRob2Qgd2FzIHVzZWQgb25seSkuXHJcbiAgICAgKi9cclxuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlcygpO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvbGlua2VkX3NldC50c1xuLy8gbW9kdWxlIGlkID0gMTU2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBSZW5kZXJTdGF0ZSBmcm9tICcuLi9yZW5kZXIvc3RhdGUnO1xyXG5pbXBvcnQgKiBhcyBjb2xvciBmcm9tICcuLi91dGlsL2NvbG9yJztcclxuaW1wb3J0ICogYXMgdmVjMiBmcm9tICcuLi9tYXRoL3ZlY3RvcjInO1xyXG5pbXBvcnQgKiBhcyB2ZWMzIGZyb20gJy4uL21hdGgvdmVjdG9yMyc7XHJcbmltcG9ydCAqIGFzIG1hdDQgZnJvbSAnLi4vbWF0aC9tYXRyaXg0JztcclxuaW1wb3J0IEdyaWRTYW1wbGVyQnVmZmVyV3JpdGVyLCB7IEFUVFJJQlVURV9NQVBQSU5HIGFzIEdSSURfU0FNUExFUl9BVFRSSUJVVEVTIH0gZnJvbSAnLi9ncmlkX3NhbXBsZXJfYnVmZmVyX3dyaXRlcic7XHJcbmltcG9ydCB7IFZvaWRFdmVudEVtaXR0ZXIgfSBmcm9tICcuLi91dGlsL2V2ZW50X2VtaXR0ZXInO1xyXG5pbXBvcnQgR3JpZFJlbmRlcmVyIGZyb20gJy4vZ3JpZF9yZW5kZXJlcic7XHJcbmltcG9ydCBSZXNldFJlbW92ZWRQcmltaXRpdmVzIGZyb20gJy4vdmlzaWJpbGl0eV9yZXNvbHV0aW9uX3N0ZXBzL3Jlc2V0X3JlbW92ZWRfcHJpbWl0aXZlcyc7XHJcbmltcG9ydCBGYWRlb3V0QWxsIGZyb20gJy4vdmlzaWJpbGl0eV9yZXNvbHV0aW9uX3N0ZXBzL2ZhZGVvdXRfYWxsJztcclxuaW1wb3J0IEZhZGVpblZpc2libGUgZnJvbSAnLi92aXNpYmlsaXR5X3Jlc29sdXRpb25fc3RlcHMvZmFkZWluX3Zpc2libGUnO1xyXG5pbXBvcnQgRmFkZW91dE92ZXJsYXBwZWQgZnJvbSAnLi92aXNpYmlsaXR5X3Jlc29sdXRpb25fc3RlcHMvZmFkZW91dF9vdmVybGFwcGVkJztcclxuaW1wb3J0IHsgY2FsY3VsYXRlQ2FtZXJhUG9zaXRpb25zIH0gZnJvbSAnLi4vcmVuZGVyL3V0aWwvY2FtZXJhX3Bvc2l0aW9uJztcclxuaW1wb3J0IGdldERwciBmcm9tICcuLi91dGlsL2hkJztcclxuY29uc3QgRkFESU5HX1NUT1BQRUQgPSAtMTtcclxuY29uc3QgREVGQVVMVF9GQURFX0VGRkVDVF9EVVJBVElPTiA9IDE1MDtcclxuY29uc3QgSURfQ09NUE9ORU5UX1NJWkUgPSAyNTY7XHJcbmNvbnN0IFZJU0lCSUxJVFlfSU5JVF9TVEFURSA9IG5ldyBSZW5kZXJTdGF0ZSh7XHJcbiAgICBjbGVhckNvbG9yOiBjb2xvci5jcmVhdGUoMCwgMCwgMCwgMCksXHJcbiAgICBkaXRoZXI6IGZhbHNlXHJcbn0pO1xyXG5jb25zdCBFTVBUWV9HUklEX0NFTEwgPSBjb2xvci5jcmVhdGUoMCwgMCwgMCwgMSk7XHJcbmNvbnN0IERJUkVDVF9QUklPUklUWV9HUklEX1NUQVRFID0gbmV3IFJlbmRlclN0YXRlKHtcclxuICAgIGNsZWFyQ29sb3I6IEVNUFRZX0dSSURfQ0VMTCxcclxuICAgIGRlcHRoVGVzdDogdHJ1ZSxcclxuICAgIGNsZWFyRGVwdGg6IDAsXHJcbiAgICAvLyBwcmltaXRpdmVzIHdpdGggZXF1YWwgcHJpb3JpdHkgYXJlIHJlc29sdmVkIGFzIGZvbGxvd2luZzogbGF0ZXIgb25lcyBvdmVybGFwIHByZXZpb3VzXHJcbiAgICBkZXB0aEZ1bmM6IDUxOCAvKiBHUkVBVEVSX09SX0VRVUFMICovLFxyXG4gICAgZGl0aGVyOiBmYWxzZVxyXG59KTtcclxuY29uc3QgUkVWRVJTRV9QUklPUklUWV9HUklEX1NUQVRFID0gbmV3IFJlbmRlclN0YXRlKHtcclxuICAgIGNsZWFyQ29sb3I6IEVNUFRZX0dSSURfQ0VMTCxcclxuICAgIGRlcHRoVGVzdDogdHJ1ZSxcclxuICAgIGNsZWFyRGVwdGg6IDEsXHJcbiAgICBkZXB0aEZ1bmM6IDUxMyAvKiBMRVNTICovLFxyXG4gICAgZGl0aGVyOiBmYWxzZVxyXG59KTtcclxuLy8gc2l6ZSBvZiBtaW5pbWFsIHJlY29nbml6YWJsZSBzcXVhcmUgc2lkZSBpbiBjc3MgcGl4ZWxzLlxyXG5jb25zdCBHUklEX1BSRUNJU0lPTl9QWCA9IDY7XHJcbi8qKlxyXG4gKiBBcGFydCBmcm9tIGJlaW5nIHJlbW92ZWQgZnJvbSBzY2VuZSB0aGVyZSBhcmUgb3RoZXIgcmVhc29ucyBmb3IgcHJpbWl0aXZlcyB0byBiZSBpbnZpc2libGU6IGUuZy4gdGhleSBhcmVcclxuICogb3ZlcmxhcHBlZCBieSBwcmltaXRpdmVzIHdpdGggaGlnaGVyIHByaW9yaXR5LiBUaGlzIHN0YXRlIGlzIGhpZ2hseSBkeW5hbWljLCBwcmltaXRpdmVzIG1heSBiZSBvZiBkaWZmZXJlbnQgdHlwZXMsXHJcbiAqIGZyb20gZGlmZmVyZW50IHNvdXJjZXMgYW5kIHRoZXkgY2FuIGhhdmUgcXVpdGUgbm9uLXRyaXZpYWwgc2hhcGVzLiBTbyB0aGVyZSBzaG91bGQgYmUgYSBzaW5nbGUgcG9pbnQgb2YgY29sbGlzaW9uXHJcbiAqIHJlc29sdXRpb24gZm9yIGFsbCBwcmltaXRpdmVzIGluIHNjZW5lLCB0aGF0IGlzIHdoYXQgdmlzaWJpbGl0eSBtYW5hZ2VyIGlzLlxyXG4gKlxyXG4gKiBWaXNpYmlsaXR5IG9mIHByaW1pdGl2ZXMgaXMgY2FsY3VsYXRlZCBldmVyeSBmcmFtZS4gVG8gc3VwcG9ydCBmYWRlLWluL291dCBhbmltYXRpb24gdmlzaWJpbGl0eSB2YWx1ZSBpcyBhIGZhY3RvclxyXG4gKiB0aGUgYWxwaGEgY2hhbm5lbCBvZiBhIGZpbmFsbHkgcmVuZGVyZWQgcHJpbWl0aXZlIGlzIHRvIGJlIG11bHRpcGxpZWQgYnkgKHZhbHVlIGZyb20gMC4wIHRvIDEuMCkuIEZvciBpbnN0YW5jZSxcclxuICogaWYgYW4gb2JqZWN0IGlzIGp1c3QgYXBwZWFyZWQgb24gdGhlIHNjZW5lLCB0aGlzIGZhY3RvciB3aWxsIGJlIGNoYW5nZWQgZnJvbSAwLjAgdG8gMS4wIGluIGZhZGVFZmZlY3REdXJhdGlvbk1zIG1zLlxyXG4gKiBUaGVyZSBhcmUgNCBzdGVwcyB0aGUgd2hvbGUgcHJvY2VzcyBjYW4gYmUgcm91Z2hseSBzdW1tYXJpemVkIGludG86XHJcbiAqICAxLiBhY3R1YWxpemF0aW9uIC0gcmVzZXQgdmFsdWVzIGZvciByZW1vdmVkIGZyb20gc2NlbmUgcHJpbWl0aXZlc1xyXG4gKiAgMi4gZmFkZS1vdXQgYWxsIC0gZXZlbiB0aG91Z2ggYWxsIHByaW1pdGl2ZXMgYXJlIGZhZGVkIG91dCBhdCB0aGlzIHN0ZXAsIHRoaXMgc3RlcCBpcyBpbnRlbmRlZCBmb3IgaW52aXNpYmxlXHJcbiAqICAgICBwcmltaXRpdmVzIHRvIGFuaW1hdGUgdGhlbSBkaXNhcHBlYXJpbmcuXHJcbiAqICAzLiBmYWRlLWluIHZpc2libGUgLSBjaGVjayB3aGljaCBwcmltaXRpdmUgYXJlIHZpc2libGUgYW5kIGluY3JlYXNlIGl0cyBhbHBoYSB2aXNpYmlsaXR5IHZhbHVlLlxyXG4gKiAgNC4gZmFkZS1vdXQgb3ZlcmxhcHBlZCAtIGZpbmQgb3ZlcmxhcHMgYnkgY29tcGFyaW5nIGNvcnJlc3BvbmRpbmcgcGl4ZWxzIG9mIHRoZSBzY2VuZSByZW5kZXJlZCBpbiBkaXJlY3QgYW5kXHJcbiAqICAgICByZXZlcnNlIHByaW9yaXR5IG9yZGVycy5cclxuICpcclxuICogIER1ZSB0byB0aGUgZmFjdCB0aGF0IHdlIHVzZSBncmlkIHdpdGggZmluaXRlIHByZWNpc2lvbiB0aGVyZSBhcmUgc29tZSBjYXNlcyB3aGVyZSB0aGlzIGFwcHJvYWNoIHByb2R1Y2VzXHJcbiAqICB1bnBsZWFzYW50IGFydGlmYWN0cyAoYmxpbmtpbmcpLiBUbyBjb3BlIHdpdGggaXQgc3RhYmlsaXR5IHNoaWZ0IGFuZCBzdG9yaW5nIHpvb20gb2YgdGhlIGZpcnN0IG92ZXJsYXAgYXJlXHJcbiAqICBpbnRyb2R1Y2VkLCBidXQgaXQgd29ya3Mgd2VsbCBmb3Igbm9uLXRpbHRlZCBtYXAgb25seS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZpc2liaWxpdHlNYW5hZ2VyIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIGNhbWVyYSwgcmVuZGVyTG9vcCwgdGFyZ2V0V2lkdGgsIHRhcmdldEhlaWdodCwgZmFkZUVmZmVjdER1cmF0aW9uID0gREVGQVVMVF9GQURFX0VGRkVDVF9EVVJBVElPTikge1xyXG4gICAgICAgIHRoaXMub25SZXJlbmRlclJlcXVpcmVkID0gbmV3IFZvaWRFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB0aGlzLmZhZGVFZmZlY3REdXJhdGlvbiA9IGZhZGVFZmZlY3REdXJhdGlvbjtcclxuICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcclxuICAgICAgICB0aGlzLl9jYW1lcmEgPSBjYW1lcmE7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyTG9vcCA9IHJlbmRlckxvb3A7XHJcbiAgICAgICAgdGhpcy5fbGFzdFJlbmRlclRpbWVJbkxvb3AgPSBGQURJTkdfU1RPUFBFRDtcclxuICAgICAgICB0aGlzLl9wcmV2VGFyZ2V0U2l6ZSA9IHsgd2lkdGg6IDAsIGhlaWdodDogMCB9O1xyXG4gICAgICAgIHRoaXMuX3NjZW5lVXBkYXRlTGlzdGVuZXIgPSB0aGlzLl9vblNjZW5lVXBkYXRlLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5fY2FtZXJhLm9uVXBkYXRlLmFkZExpc3RlbmVyKHRoaXMuX3NjZW5lVXBkYXRlTGlzdGVuZXIpO1xyXG4gICAgICAgIHRoaXMuX2JlZm9yZVJlbmRlckxpc3RlbmVyID0gdGhpcy5fb25CZWZvcmVSZW5kZXIuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLl9yZW5kZXJMb29wLm9uQmVmb3JlUmVuZGVyLmFkZExpc3RlbmVyKHRoaXMuX2JlZm9yZVJlbmRlckxpc3RlbmVyKTtcclxuICAgICAgICB0aGlzLl9kaXJlY3RQcmlvcml0eUdyaWRSZW5kZXJlciA9IG5ldyBHcmlkUmVuZGVyZXIoY29udGV4dCwgRElSRUNUX1BSSU9SSVRZX0dSSURfU1RBVEUpO1xyXG4gICAgICAgIHRoaXMuX3JldmVyc2VQcmlvcml0eUdyaWRSZW5kZXJlciA9IG5ldyBHcmlkUmVuZGVyZXIoY29udGV4dCwgUkVWRVJTRV9QUklPUklUWV9HUklEX1NUQVRFKTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50VmlzaWJpbGl0eVRleHR1cmUgPSBjb250ZXh0LmNyZWF0ZUVtcHR5MkRUZXh0dXJlKElEX0NPTVBPTkVOVF9TSVpFLCBJRF9DT01QT05FTlRfU0laRSwgNjQwOCAvKiBSR0JBICovLCA1MTIxIC8qIFVOU0lHTkVEX0JZVEUgKi8pO1xyXG4gICAgICAgIHRoaXMuX3ByZXZWaXNpYmlsaXR5VGV4dHVyZSA9IGNvbnRleHQuY3JlYXRlRW1wdHkyRFRleHR1cmUoSURfQ09NUE9ORU5UX1NJWkUsIElEX0NPTVBPTkVOVF9TSVpFLCA2NDA4IC8qIFJHQkEgKi8sIDUxMjEgLyogVU5TSUdORURfQllURSAqLyk7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudFZpc2liaWxpdHlCdWZmZXIgPSBjb250ZXh0LmNyZWF0ZUZyYW1lYnVmZmVyKHsgY29sb3I6IHRoaXMuX2N1cnJlbnRWaXNpYmlsaXR5VGV4dHVyZSB9KTtcclxuICAgICAgICB0aGlzLl9wcmV2VmlzaWJpbGl0eUJ1ZmZlciA9IGNvbnRleHQuY3JlYXRlRnJhbWVidWZmZXIoeyBjb2xvcjogdGhpcy5fcHJldlZpc2liaWxpdHlUZXh0dXJlIH0pO1xyXG4gICAgICAgIHRoaXMuX3N0YWJpbGl0eVNoaWZ0ID0gdmVjMy5jcmVhdGUoMCwgMCwgMCk7XHJcbiAgICAgICAgdGhpcy5fZ3JpZEhhbGZQeFNpemVVbmlmb3JtID0gdmVjMi5jcmVhdGUoMCwgMCk7XHJcbiAgICAgICAgdGhpcy5faWRIYWxmUHhTaXplVW5pZm9ybSA9IHZlYzIuY3JlYXRlKDAuNSAvIElEX0NPTVBPTkVOVF9TSVpFLCAwLjUgLyBJRF9DT01QT05FTlRfU0laRSk7XHJcbiAgICAgICAgdGhpcy5fc3RlcDFSZXNldFJlbW92ZWQgPSBuZXcgUmVzZXRSZW1vdmVkUHJpbWl0aXZlcygpO1xyXG4gICAgICAgIHRoaXMuX3N0ZXAyRmFkZW91dEFsbCA9IG5ldyBGYWRlb3V0QWxsKGNvbnRleHQpO1xyXG4gICAgICAgIHRoaXMuX3N0ZXAzRmFkZWluVmlzaWJsZSA9IG5ldyBGYWRlaW5WaXNpYmxlKGNvbnRleHQpO1xyXG4gICAgICAgIHRoaXMuX3N0ZXA0RmFkZW91dE92ZXJsYXBwZWQgPSBuZXcgRmFkZW91dE92ZXJsYXBwZWQoY29udGV4dCk7XHJcbiAgICAgICAgdGhpcy5fY2xlYXJWaXNpYmlsaXR5KHRoaXMuX2N1cnJlbnRWaXNpYmlsaXR5QnVmZmVyKTtcclxuICAgICAgICB0aGlzLl9wcmltaXRpdmVQcm92aWRlcnMgPSBbXTtcclxuICAgICAgICB0aGlzLl9jb2xvcklkUmVuZGVyZXJzID0gW107XHJcbiAgICAgICAgdGhpcy5fcmVzZXRSZW1vdmVkUmVuZGVyZXJzID0gW107XHJcbiAgICAgICAgdGhpcy5zZXRUYXJnZXRTaXplKHRhcmdldFdpZHRoLCB0YXJnZXRIZWlnaHQpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHZpc2liaWxpdHlUZXh0dXJlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50VmlzaWJpbGl0eVRleHR1cmU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRvIHByb3ZpZGUgcHJvcGVyIHByZWNpc2lvbiBpbiBjb2xsaXNpb24gcmVzb2x1dGlvbiBzaW1wbGlmaWVkIGdyaWQgc2l6ZSBkZXBlbmRzIG9uIHRoZSByZW5kZXIgdGFyZ2V0LFxyXG4gICAgICogdGhhdCBjYW4gYmUgY2hhbmdlZCBhdCBydW4gdGltZSAoZS5nLiB0aGUgdXNlciByZXNpemVzIGJyb3dzZXIgd2luZG93KS4gQSBsb3Qgb2YgYXNzb2NpYXRlZCBHTCByZXNvdXJjZXMgaXMgYmVcclxuICAgICAqIHVwZGF0ZWQgaW4gdGhhdCBjYXNlLlxyXG4gICAgICovXHJcbiAgICBzZXRUYXJnZXRTaXplKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICBjb25zdCBncmlkUHJlY2lzaW9uVGFyZ2V0UHggPSBHUklEX1BSRUNJU0lPTl9QWCAqIGdldERwcigpO1xyXG4gICAgICAgIGNvbnN0IGdyaWRXaWR0aCA9IE1hdGguY2VpbCh3aWR0aCAvIGdyaWRQcmVjaXNpb25UYXJnZXRQeCk7XHJcbiAgICAgICAgY29uc3QgZ3JpZEhlaWdodCA9IE1hdGguY2VpbChoZWlnaHQgLyBncmlkUHJlY2lzaW9uVGFyZ2V0UHgpO1xyXG4gICAgICAgIHRoaXMuX2RpcmVjdFByaW9yaXR5R3JpZFJlbmRlcmVyLnNldFJlc29sdXRpb24oZ3JpZFdpZHRoLCBncmlkSGVpZ2h0KTtcclxuICAgICAgICB0aGlzLl9yZXZlcnNlUHJpb3JpdHlHcmlkUmVuZGVyZXIuc2V0UmVzb2x1dGlvbihncmlkV2lkdGgsIGdyaWRIZWlnaHQpO1xyXG4gICAgICAgIGlmICh0aGlzLl9ncmlkU2FtcGxlclZlcnRleEJ1ZmZlcikge1xyXG4gICAgICAgICAgICB0aGlzLl9kZXN0cm95R3JpZFJlc291cmNlcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBvdmVybGFwU2FtcGxlckJ1ZmZlcldyaXRlciA9IG5ldyBHcmlkU2FtcGxlckJ1ZmZlcldyaXRlcihncmlkV2lkdGgsIGdyaWRIZWlnaHQpO1xyXG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLl9jb250ZXh0O1xyXG4gICAgICAgIHRoaXMuX2dyaWRTYW1wbGVyVmVydGV4QnVmZmVyID0gY29udGV4dC5jcmVhdGVWZXJ0ZXhCdWZmZXIob3ZlcmxhcFNhbXBsZXJCdWZmZXJXcml0ZXIuZGF0YS5ieXRlTGVuZ3RoKTtcclxuICAgICAgICB0aGlzLl9ncmlkU2FtcGxlclZhbyA9IGNvbnRleHQuY3JlYXRlVmFvKEdSSURfU0FNUExFUl9BVFRSSUJVVEVTLCB0aGlzLl9ncmlkU2FtcGxlclZlcnRleEJ1ZmZlciwgbnVsbCk7XHJcbiAgICAgICAgdGhpcy5fbnVtYmVyT2ZHcmlkU2FtcGxlcnMgPSBvdmVybGFwU2FtcGxlckJ1ZmZlcldyaXRlci5udW1iZXJPZlNhbXBsZXJzO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQudXBsb2FkRGF0YVRvQnVmZmVyKHRoaXMuX2dyaWRTYW1wbGVyVmVydGV4QnVmZmVyLCBvdmVybGFwU2FtcGxlckJ1ZmZlcldyaXRlci5kYXRhKTtcclxuICAgICAgICB0aGlzLl9wcmV2VGFyZ2V0U2l6ZS53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMuX3ByZXZUYXJnZXRTaXplLmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICB0aGlzLl9ncmlkSGFsZlB4U2l6ZVVuaWZvcm0ueCA9IDAuNSAvIGdyaWRXaWR0aDtcclxuICAgICAgICB0aGlzLl9ncmlkSGFsZlB4U2l6ZVVuaWZvcm0ueSA9IDAuNSAvIGdyaWRIZWlnaHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlY2FsY3VsYXRlcyB2aXNpYmlsaXR5IG9mIGFsbCBjb2xsaWRpbmcgcHJpbWl0aXZlcyBpbiBzY2VuZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgdGhlIHNjZW5lIGlzIHRvIGJlIHJlbmRlcmVkIGludG8uXHJcbiAgICAgKiBAcGFyYW0gdW5pZm9ybXMgU2V0IG9mIHByZWNhbGN1bGF0ZWQgdW5pZm9ybXMgZ2xvYmFsIGZvciBjdXJyZW50IGZyYW1lLlxyXG4gICAgICogQHJldHVybnMgVXBkYXRlZCB0ZXh0dXJlIHdpdGggdmlzaWJpbGl0eSB2YWx1ZXMgZm9yIGFsbCBwcmltaXRpdmVzLlxyXG4gICAgICovXHJcbiAgICB1cGRhdGVWaXNpYmlsaXR5SWZOZWVkZWQoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9pc0RpcnR5KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5faXNEaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIC8vIFJhc3Rlcml6YXRpb24gbWF5IGJlIG5vdCBzdGFibGUgaW4gdGhlIHNlbnNlIG9mIHRoZSBzaGFwZSBvZiBwaXhlbHMgb2NjdXBpZWQgYnkgcGFydGljdWxhciBvYmplY3Qgd2hlbiB0aGlzXHJcbiAgICAgICAgLy8gb2JqZWN0IGdldHMgc2hpZnRlZCAoZS5nLiB0aGUgdXNlciBkcmFncyB0aGUgY2VudGVyIG9mIHRoZSBtYXApIGFuZCBzaW5jZSBjb2xsaXNpb25zIGFyZSBkZXRlY3RlZCBieVxyXG4gICAgICAgIC8vIG92ZXJsYXBwZWQgcGl4ZWxzIHRoaXMgZmFjdCBjYW4gbGVhZCB0byBibGlua2luZyAoZm91bmQgb3ZlcmxhcHBpbmcgaW4gb25lIGZyYW1lL25vdCBmb3VuZCBpbiB0aGUgbmV4dC9ldGMpLlxyXG4gICAgICAgIC8vIEZvciB0aG9zZSBvYmplY3RzIChhbmQgdGhlaXIgcG9zaXRpb25zKSB0aGF0IGFyZSBub3QgZGlzdG9ydGVkIGJ5IHBlcnNwZWN0aXZlIGl0IGNhbiBiZSBmaXhlZCBieVxyXG4gICAgICAgIC8vIGludHJvZHVjaW5nIGEgc2hpZnQgdGhhdCB0YWtlcyBpbnRvIGFjY291bnQgdGhlIGFtb3VudCBvZiBkcmFnIGFuZCBmb3JjZXMgdmVydGljZXMgdG8gYmUgZGlzcGxhY2VkIGluIHRoZVxyXG4gICAgICAgIC8vIHNhbWUgcG9zaXRpb24gaW4gZ3JpZCdzIGNlbGwuXHJcbiAgICAgICAgY29uc3Qgc2hpZnQgPSB0aGlzLl9zdGFiaWxpdHlTaGlmdDtcclxuICAgICAgICB2ZWMyLmNvcHkodGhpcy5fY2FtZXJhLmNlbnRlciwgc2hpZnQpO1xyXG4gICAgICAgIHNoaWZ0LnogPSAwO1xyXG4gICAgICAgIG1hdDQuYXBwbHkodGhpcy5fY2FtZXJhLmdldFZpZXdQcm9qTWF0cml4KCksIHNoaWZ0LCBzaGlmdCk7XHJcbiAgICAgICAgLy8gTkRDICgtMSA6IDEpIGFyZSAyIHRpbWVzIGxhcmdlciB0aGFuIHRleHR1cmUgY29vcmRpbmF0ZXMgKDAgOiAxKVxyXG4gICAgICAgIHNoaWZ0LnggJT0gNCAqIHRoaXMuX2dyaWRIYWxmUHhTaXplVW5pZm9ybS54O1xyXG4gICAgICAgIHNoaWZ0LnkgJT0gNCAqIHRoaXMuX2dyaWRIYWxmUHhTaXplVW5pZm9ybS55O1xyXG4gICAgICAgIGNvbnN0IHByZXZUZXh0dXJlID0gdGhpcy5fcHJldlZpc2liaWxpdHlUZXh0dXJlO1xyXG4gICAgICAgIGNvbnN0IHByZXZGcmFtZWJ1ZmZlciA9IHRoaXMuX3ByZXZWaXNpYmlsaXR5QnVmZmVyO1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRUZXh0dXJlID0gdGhpcy5fY3VycmVudFZpc2liaWxpdHlUZXh0dXJlO1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRGcmFtZWJ1ZmZlciA9IHRoaXMuX2N1cnJlbnRWaXNpYmlsaXR5QnVmZmVyO1xyXG4gICAgICAgIHRoaXMuX2NsZWFyVmlzaWJpbGl0eShwcmV2RnJhbWVidWZmZXIpO1xyXG4gICAgICAgIC8vIG9uIHRoaXMgc3RlcFxyXG4gICAgICAgIHRoaXMuX3N0ZXAxUmVzZXRSZW1vdmVkLnJlbmRlcihwcmV2RnJhbWVidWZmZXIsIHRoaXMuX3Jlc2V0UmVtb3ZlZFJlbmRlcmVycywgY3VycmVudFRleHR1cmUsIHRoaXMuX2lkSGFsZlB4U2l6ZVVuaWZvcm0pO1xyXG4gICAgICAgIC8vIHBhc3Mgem9vbSBhcyBhIHZhbHVlIGJldHdlZW4gMC4wIGFuZCAxLjAsIGFzIGFic29sdXRlIHZhbHVlIGlzIG5vdCBpbXBvcnRhbnRcclxuICAgICAgICBjb25zdCB6b29tID0gdGhpcy5fY2FtZXJhLnpvb20gLyB0aGlzLl9jYW1lcmEub3B0aW9ucy5tYXhab29tO1xyXG4gICAgICAgIGNvbnN0IHZpZXdQcm9qTWF0cml4ID0gdGhpcy5fY2FtZXJhLmdldFZpZXdQcm9qTWF0cml4KCk7XHJcbiAgICAgICAgY29uc3QgY2FtZXJhUG9zaXRpb25zID0gY2FsY3VsYXRlQ2FtZXJhUG9zaXRpb25zKHRoaXMuX2NhbWVyYSk7XHJcbiAgICAgICAgY29uc3QgZGlyZWN0UHJpb3JpdHlHcmlkID0gdGhpcy5fZGlyZWN0UHJpb3JpdHlHcmlkUmVuZGVyZXIudXBkYXRlR3JpZCh2aWV3UHJvak1hdHJpeCwgY2FtZXJhUG9zaXRpb25zLCB0aGlzLl9jb2xvcklkUmVuZGVyZXJzLCBzaGlmdCwgcHJldlRleHR1cmUsIHpvb20pO1xyXG4gICAgICAgIGNvbnN0IHJldmVyc2VQcmlvcml0eUdyaWQgPSB0aGlzLl9yZXZlcnNlUHJpb3JpdHlHcmlkUmVuZGVyZXIudXBkYXRlR3JpZCh2aWV3UHJvak1hdHJpeCwgY2FtZXJhUG9zaXRpb25zLCB0aGlzLl9jb2xvcklkUmVuZGVyZXJzLCBzaGlmdCwgcHJldlRleHR1cmUsIHpvb20pO1xyXG4gICAgICAgIGNvbnN0IG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgICAgIGNvbnN0IGxhc3RSZW5kZXJpbmcgPSB0aGlzLl9sYXN0UmVuZGVyVGltZUluTG9vcDtcclxuICAgICAgICBjb25zdCBpc0FuaW1hdGlvbkZpbmlzaGVkID0gKG5vdyAtIHRoaXMuX2xhc3RTY2VuZVVwZGF0ZVRpbWUpID4gdGhpcy5mYWRlRWZmZWN0RHVyYXRpb247XHJcbiAgICAgICAgY29uc3Qgd2FzQW5pbWF0aW9uQWN0aXZlID0gbGFzdFJlbmRlcmluZyAhPT0gRkFESU5HX1NUT1BQRUQ7XHJcbiAgICAgICAgY29uc3QgZmFkZUVmZmVjdCA9IGlzQW5pbWF0aW9uRmluaXNoZWQgP1xyXG4gICAgICAgICAgICAxLjAgOiB3YXNBbmltYXRpb25BY3RpdmUgPyAobm93IC0gbGFzdFJlbmRlcmluZykgLyB0aGlzLmZhZGVFZmZlY3REdXJhdGlvbiA6IDA7XHJcbiAgICAgICAgY29uc3QgaWRIYWxmUHggPSB0aGlzLl9pZEhhbGZQeFNpemVVbmlmb3JtO1xyXG4gICAgICAgIGNvbnN0IHNhbXBsZXJWYW8gPSB0aGlzLl9ncmlkU2FtcGxlclZhbztcclxuICAgICAgICBjb25zdCBudW1iZXJPZlNhbXBsZXJzID0gdGhpcy5fbnVtYmVyT2ZHcmlkU2FtcGxlcnM7XHJcbiAgICAgICAgdGhpcy5fY2xlYXJWaXNpYmlsaXR5KGN1cnJlbnRGcmFtZWJ1ZmZlcik7XHJcbiAgICAgICAgdGhpcy5fc3RlcDJGYWRlb3V0QWxsLnJlbmRlcihjdXJyZW50RnJhbWVidWZmZXIsIHByZXZUZXh0dXJlLCBmYWRlRWZmZWN0KTtcclxuICAgICAgICB0aGlzLl9zdGVwM0ZhZGVpblZpc2libGUucmVuZGVyKGN1cnJlbnRGcmFtZWJ1ZmZlciwgc2FtcGxlclZhbywgbnVtYmVyT2ZTYW1wbGVycywgZGlyZWN0UHJpb3JpdHlHcmlkLCBwcmV2VGV4dHVyZSwgaWRIYWxmUHgsIGZhZGVFZmZlY3QpO1xyXG4gICAgICAgIHRoaXMuX3N0ZXA0RmFkZW91dE92ZXJsYXBwZWQucmVuZGVyKGN1cnJlbnRGcmFtZWJ1ZmZlciwgc2FtcGxlclZhbywgbnVtYmVyT2ZTYW1wbGVycywgZGlyZWN0UHJpb3JpdHlHcmlkLCByZXZlcnNlUHJpb3JpdHlHcmlkLCBwcmV2VGV4dHVyZSwgaWRIYWxmUHgsIGZhZGVFZmZlY3QsIHpvb20pO1xyXG4gICAgICAgIC8vIGNoZWNrIGlmIHdlIG5lZWQgb25lIG1vcmUgcmVuZGVyaW5nIHRvIGZpbmlzaCBhbmltYXRpb25cclxuICAgICAgICBpZiAoaXNBbmltYXRpb25GaW5pc2hlZCkge1xyXG4gICAgICAgICAgICAvLyBubyBtb3JlIHJlbmRlcmluZ3MgbmVlZGVkIGZvciBmYWRlIGVmZmVjdCwgaXRzIHRpbWVzdGFtcCBpcyBtYXJrZWQgd2l0aCBzcGVjaWFsIHZhbHVlXHJcbiAgICAgICAgICAgIC8vIHRvIHRha2UgaXQgaW50byBhY2NvdW50IGR1cmluZyBuZXh0IGZhZGUgZWZmZWN0IGFtb3VudCBjYWxjdWxhdGlvblxyXG4gICAgICAgICAgICB0aGlzLl9sYXN0UmVuZGVyVGltZUluTG9vcCA9IEZBRElOR19TVE9QUEVEO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyTG9vcC51cGRhdGUoKTtcclxuICAgICAgICAgICAgdGhpcy5fbGFzdFJlbmRlclRpbWVJbkxvb3AgPSBub3c7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVnaXN0ZXJDb2xsaWRpbmdQcmltaXRpdmVzKHByaW1pdGl2ZVByb3ZpZGVyLCBjb2xvcklkUmVuZGVyZXIsIHJlc2V0UmVtb3ZlUmVuZGVyZXIpIHtcclxuICAgICAgICB0aGlzLl9wcmltaXRpdmVQcm92aWRlcnMucHVzaChwcmltaXRpdmVQcm92aWRlcik7XHJcbiAgICAgICAgdGhpcy5fY29sb3JJZFJlbmRlcmVycy5wdXNoKGNvbG9ySWRSZW5kZXJlcik7XHJcbiAgICAgICAgdGhpcy5fcmVzZXRSZW1vdmVkUmVuZGVyZXJzLnB1c2gocmVzZXRSZW1vdmVSZW5kZXJlcik7XHJcbiAgICAgICAgcHJpbWl0aXZlUHJvdmlkZXIub25VcGRhdGUuYWRkTGlzdGVuZXIodGhpcy5fc2NlbmVVcGRhdGVMaXN0ZW5lcik7XHJcbiAgICB9XHJcbiAgICBkZXJlZ2lzdGVyQ29sbGlkaW5nUHJpbWl0aXZlcyhwcmltaXRpdmVQcm92aWRlciwgY29sb3JJZFJlbmRlcmVyLCByZXNldFJlbW92ZVJlbmRlcmVyKSB7XHJcbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5fcHJpbWl0aXZlUHJvdmlkZXJzLmluZGV4T2YocHJpbWl0aXZlUHJvdmlkZXIpO1xyXG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3ByaW1pdGl2ZVByb3ZpZGVycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbmRleCA9IHRoaXMuX2NvbG9ySWRSZW5kZXJlcnMuaW5kZXhPZihjb2xvcklkUmVuZGVyZXIpO1xyXG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbG9ySWRSZW5kZXJlcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaW5kZXggPSB0aGlzLl9yZXNldFJlbW92ZWRSZW5kZXJlcnMuaW5kZXhPZihyZXNldFJlbW92ZVJlbmRlcmVyKTtcclxuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZXNldFJlbW92ZWRSZW5kZXJlcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHJpbWl0aXZlUHJvdmlkZXIub25VcGRhdGUucmVtb3ZlTGlzdGVuZXIodGhpcy5fc2NlbmVVcGRhdGVMaXN0ZW5lcik7XHJcbiAgICB9XHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lHcmlkUmVzb3VyY2VzKCk7XHJcbiAgICAgICAgdGhpcy5fZGlyZWN0UHJpb3JpdHlHcmlkUmVuZGVyZXIuZGVzdHJveSgpO1xyXG4gICAgICAgIHRoaXMuX3JldmVyc2VQcmlvcml0eUdyaWRSZW5kZXJlci5kZXN0cm95KCk7XHJcbiAgICAgICAgdGhpcy5fY2FtZXJhLm9uVXBkYXRlLnJlbW92ZUxpc3RlbmVyKHRoaXMuX3NjZW5lVXBkYXRlTGlzdGVuZXIpO1xyXG4gICAgICAgIGZvciAoY29uc3QgcHJpbWl0aXZlUHJvdmlkZXIgb2YgdGhpcy5fcHJpbWl0aXZlUHJvdmlkZXJzKSB7XHJcbiAgICAgICAgICAgIHByaW1pdGl2ZVByb3ZpZGVyLm9uVXBkYXRlLnJlbW92ZUxpc3RlbmVyKHRoaXMuX3NjZW5lVXBkYXRlTGlzdGVuZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9vblNjZW5lVXBkYXRlKCkge1xyXG4gICAgICAgIHRoaXMuX2xhc3RTY2VuZVVwZGF0ZVRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgICB0aGlzLl9yZW5kZXJMb29wLnVwZGF0ZSgpO1xyXG4gICAgfVxyXG4gICAgX29uQmVmb3JlUmVuZGVyKCkge1xyXG4gICAgICAgIHRoaXMuX2lzRGlydHkgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldHMgdmlzaWJpbGl0eSB0ZXh0dXJlIHRvIGl0cyBpbml0aWFsIHN0YXRlLlxyXG4gICAgICovXHJcbiAgICBfY2xlYXJWaXNpYmlsaXR5KHRhcmdldCkge1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFJlbmRlclN0YXRlKFZJU0lCSUxJVFlfSU5JVF9TVEFURSk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kUmVuZGVyVGFyZ2V0KHRhcmdldCk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5jbGVhckN1cnJlbnRUYXJnZXQoMTYzODQgLyogQ09MT1JfQlVGRkVSX0JJVCAqLyk7XHJcbiAgICB9XHJcbiAgICBfZGVzdHJveUdyaWRSZXNvdXJjZXMoKSB7XHJcbiAgICAgICAgdGhpcy5fZ3JpZFNhbXBsZXJWZXJ0ZXhCdWZmZXIuZGVzdHJveSgpO1xyXG4gICAgICAgIHRoaXMuX2dyaWRTYW1wbGVyVmFvLmRlc3Ryb3koKTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS92aXNpYmlsaXR5L3Zpc2liaWxpdHlfbWFuYWdlci50c1xuLy8gbW9kdWxlIGlkID0gMTU3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IEF0dHJpYnV0ZU1hcHBpbmcgfSBmcm9tICcuLi9yZW5kZXIvYXR0cmliX21hcHBpbmcnO1xyXG5pbXBvcnQgQnVmZmVyV3JpdGVyIGZyb20gJy4uL3V0aWwvYnVmZmVyX3dyaXRlcic7XHJcbmltcG9ydCB7IGZsb2F0VG9VaW50MTYgfSBmcm9tICcuLi91dGlsL2dwdXR5cGVzJztcclxuZXhwb3J0IGNvbnN0IEFUVFJJQlVURV9NQVBQSU5HID0gbmV3IEF0dHJpYnV0ZU1hcHBpbmcoW1xyXG4gICAgW1xyXG4gICAgICAgIDAgLyogUE9TSVRJT04gKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIzIC8qIFVOU0lHTkVEX1NIT1JUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXVxyXG5dKTtcclxuLyoqXHJcbiAqIFdyaXRlcyBzYW1wbGVyIHBvc2l0aW9ucyBpbnRvIHZlcnRleCBidWZmZXIgYXMgYSByZWd1bGFyIGdyaWQgd2l0aCB0aGUgc3RlcCBlcXVhbCB0byB0aGUgc2l6ZSBvZiBhIGdyaWQgY2VsbC5cclxuICogVGhlIG51bWJlciBvZiB2ZXJ0aWNlcyAoc2FtcGxlcnMpIGlzIGVxdWFsIHRvIFwid2lkdGggeCBoZWlnaHRcIi5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdyaWRTYW1wbGVyQnVmZmVyV3JpdGVyIGV4dGVuZHMgQnVmZmVyV3JpdGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICBjb25zdCBudW1iZXJPZlNhbXBsZXJzID0gd2lkdGggKiBoZWlnaHQ7XHJcbiAgICAgICAgc3VwZXIoQVRUUklCVVRFX01BUFBJTkcudmVydGV4Qnl0ZVNpemUsIG51bWJlck9mU2FtcGxlcnMsIHVuZGVmaW5lZCwgMCk7XHJcbiAgICAgICAgY29uc3QgY29sU3RlcCA9IGZsb2F0VG9VaW50MTYoMS4wIC8gd2lkdGgpO1xyXG4gICAgICAgIGNvbnN0IHJvd1N0ZXAgPSBmbG9hdFRvVWludDE2KDEuMCAvIGhlaWdodCk7XHJcbiAgICAgICAgY29uc3QgY29sSGFsZlN0ZXAgPSBjb2xTdGVwIC8gMjtcclxuICAgICAgICBjb25zdCByb3dIYWxmU3RlcCA9IHJvd1N0ZXAgLyAyO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBjb2wgPSBjb2xIYWxmU3RlcDsgaSA8IHdpZHRoOyBpKyssIGNvbCArPSBjb2xTdGVwKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwLCByb3cgPSByb3dIYWxmU3RlcDsgaiA8IGhlaWdodDsgaisrLCByb3cgKz0gcm93U3RlcCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fd3JpdGVIYWxmV29yZHMoY29sLCByb3cpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZGF0YSA9IHRoaXMuZ2V0QnVmZmVycygpWzBdLnZlcnRleEJ1ZmZlcjtcclxuICAgICAgICB0aGlzLm51bWJlck9mU2FtcGxlcnMgPSBudW1iZXJPZlNhbXBsZXJzO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3Zpc2liaWxpdHkvZ3JpZF9zYW1wbGVyX2J1ZmZlcl93cml0ZXIudHNcbi8vIG1vZHVsZSBpZCA9IDE1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBHbFJlbmRlcmVyIH0gZnJvbSAnLi4vcmVuZGVyL2dsX3JlbmRlcmVyJztcclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR3JpZFJlbmRlcmVyIGV4dGVuZHMgR2xSZW5kZXJlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCByZW5kZXJTdGF0ZSkge1xyXG4gICAgICAgIHN1cGVyKGNvbnRleHQsIHJlbmRlclN0YXRlKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZUdyaWQoLi4uYXJncykge1xyXG4gICAgICAgIHRoaXMucmVuZGVyKHRoaXMuX3RhcmdldCwgLi4uYXJncyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHR1cmU7XHJcbiAgICB9XHJcbiAgICBfcmVuZGVyKHZpZXdQcm9qTWF0cml4LCBjYW1lcmFQb3NpdGlvbnMsIHJlbmRlcmVycywgc3RhYmlsaXR5U2hpZnQsIHByZXZWaXNpYmlsaXR5LCBjdXJyZW50Wm9vbSkge1xyXG4gICAgICAgIGZvciAoY29uc3QgcmVuZGVyZXIgb2YgcmVuZGVyZXJzKSB7XHJcbiAgICAgICAgICAgIHJlbmRlcmVyLnJlbmRlcih0aGlzLl90YXJnZXQsIHZpZXdQcm9qTWF0cml4LCBjYW1lcmFQb3NpdGlvbnMsIHRoaXMuX3JlbmRlclN0YXRlLCBzdGFiaWxpdHlTaGlmdCwgcHJldlZpc2liaWxpdHksIGN1cnJlbnRab29tKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgcmVzb2x1dGlvbiBvZiB0aGUgZ3JpZC5cclxuICAgICAqL1xyXG4gICAgc2V0UmVzb2x1dGlvbih3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgdGhpcy5fZGVzdHJveVJlc291cmNlcygpO1xyXG4gICAgICAgIHRoaXMuX2RlcHRoQnVmZmVyID0gdGhpcy5fY29udGV4dC5jcmVhdGVSZW5kZXJidWZmZXIod2lkdGgsIGhlaWdodCwgMzQwNDEgLyogREVQVEhfU1RFTkNJTCAqLyk7XHJcbiAgICAgICAgdGhpcy5fdGV4dHVyZSA9IHRoaXMuX2NvbnRleHQuY3JlYXRlRW1wdHkyRFRleHR1cmUod2lkdGgsIGhlaWdodCwgNjQwOCAvKiBSR0JBICovLCA1MTIxIC8qIFVOU0lHTkVEX0JZVEUgKi8pO1xyXG4gICAgICAgIHRoaXMuX3RhcmdldCA9IHRoaXMuX2NvbnRleHQuY3JlYXRlRnJhbWVidWZmZXIoeyBjb2xvcjogdGhpcy5fdGV4dHVyZSwgZGVwdGhTdGVuY2lsOiB0aGlzLl9kZXB0aEJ1ZmZlciB9KTtcclxuICAgIH1cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5fZGVzdHJveVJlc291cmNlcygpO1xyXG4gICAgfVxyXG4gICAgX3ByZXBhcmVSZW5kZXJUYXJnZXQodGFyZ2V0LCAuLi5hcmdzKSB7XHJcbiAgICAgICAgc3VwZXIuX3ByZXBhcmVSZW5kZXJUYXJnZXQodGFyZ2V0LCAuLi5hcmdzKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmNsZWFyQ3VycmVudFRhcmdldCgxNjM4NCAvKiBDT0xPUl9CVUZGRVJfQklUICovIHwgMjU2IC8qIERFUFRIX0JVRkZFUl9CSVQgKi8pO1xyXG4gICAgfVxyXG4gICAgX2Rlc3Ryb3lSZXNvdXJjZXMoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3RhcmdldCkge1xyXG4gICAgICAgICAgICB0aGlzLl90YXJnZXQuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB0aGlzLl90ZXh0dXJlLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgdGhpcy5fZGVwdGhCdWZmZXIuZGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS92aXNpYmlsaXR5L2dyaWRfcmVuZGVyZXIudHNcbi8vIG1vZHVsZSBpZCA9IDE1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcclxuICogT25lIG9mIHRoZSBzdGVwcyBvZiBwcmltaXRpdmVzIHZpc2liaWxpdHkgcmVzb2x1dGlvbiBwcm9jZXNzLiBCYXNpY2FsbHkgaXQgZG9lcyBub3RoaW5nLCBqdXN0IGNhbGwgYXBwcm9wcmlhdGVcclxuICogbWV0aG9kcyBvZiBDb2xsaWRpbmdQcmltaXRpdmVSZW5kZXJlcidzLCBidXQgaXQgZXhwZWN0cyB0aGF0IHRoZXNlIHJlbmRlcmVycyB3aWxsIGNvcHkgdmlzaWJpbGl0eSB2YWx1ZSBvZiBhY3R1YWxcclxuICogcHJpbWl0aXZlcyBvbmx5LCB0aHVzIHJlbW92ZWQgcHJpbWl0aXZlJ3MgdmFsdWVzIHdpbGwgYmUgcmVzZXQgKG92ZXJsYXAgem9vbSBjbGVhcmVkIGFuZCBhbGwgdGhhdCkuIEl0IGlzIGltcG9ydGFudFxyXG4gKiBmb3IgcmV1c2luZyB0aGVzZSBpZHMgZm9yIGZ1dHVyZSBwcmltaXRpdmVzLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVzZXRSZW1vdmVkUHJpbWl0aXZlcyB7XHJcbiAgICByZW5kZXIodGFyZ2V0LCByZW5kZXJlcnMsIHByZXZWaXNpYmlsaXR5LCBpZEhhbGZQeFNpemVVbmlmb3JtKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCByZW5kZXJlciBvZiByZW5kZXJlcnMpIHtcclxuICAgICAgICAgICAgcmVuZGVyZXIucmVuZGVyKHRhcmdldCwgcHJldlZpc2liaWxpdHksIGlkSGFsZlB4U2l6ZVVuaWZvcm0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS92aXNpYmlsaXR5L3Zpc2liaWxpdHlfcmVzb2x1dGlvbl9zdGVwcy9yZXNldF9yZW1vdmVkX3ByaW1pdGl2ZXMudHNcbi8vIG1vZHVsZSBpZCA9IDE2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgZmFkZW91dEFsbFZlcnRleFNoYWRlciBmcm9tICcuL3NoYWRlcnMvZmFkZW91dF9hbGwudmVydCc7XHJcbmltcG9ydCBmYWRlb3V0QWxsRnJhZ21lbnRTaGFkZXIgZnJvbSAnLi9zaGFkZXJzL2ZhZGVvdXRfYWxsLmZyYWcnO1xyXG5pbXBvcnQgeyBHbFJlbmRlcmVyIH0gZnJvbSAnLi4vLi4vcmVuZGVyL2dsX3JlbmRlcmVyJztcclxuaW1wb3J0IFJlbmRlclN0YXRlIGZyb20gJy4uLy4uL3JlbmRlci9zdGF0ZSc7XHJcbmltcG9ydCBJZFNhbXBsZXJCdWZmZXJXcml0ZXIsIHsgQVRUUklCVVRFX01BUFBJTkcgfSBmcm9tICcuLi9pZF9zYW1wbGVyX2J1ZmZlcl93cml0ZXInO1xyXG5jb25zdCBTVEFURSA9IG5ldyBSZW5kZXJTdGF0ZSh7XHJcbiAgICBkaXRoZXI6IGZhbHNlXHJcbn0pO1xyXG4vKipcclxuICogT25lIG9mIHRoZSBzdGVwcyBvZiBwcmltaXRpdmVzIHZpc2liaWxpdHkgcmVzb2x1dGlvbiBwcm9jZXNzLiBJdCBzYW1wbGVzIGFsbCB2aXNpYmlsaXR5IHZhbHVlcyBhbmQgc3VidHJhY3RcclxuICogZGVsdGEgKGZhZGVvdXRBbW91bnQpIGZyb20gdGhlbSwgdGhlc2UgbmV3IHZhbHVlcyBhcmUgc3RvcmVkIGludG8gY3VycmVudCB2aXNpYmlsaXR5IHRleHR1cmUuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGYWRlb3V0QWxsIGV4dGVuZHMgR2xSZW5kZXJlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XHJcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IGNvbnRleHQuY3JlYXRlUHJvZ3JhbShmYWRlb3V0QWxsVmVydGV4U2hhZGVyLCBmYWRlb3V0QWxsRnJhZ21lbnRTaGFkZXIsIHtcclxuICAgICAgICAgICAgYXR0cmliTWFwOiB7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogMCAvKiBQT1NJVElPTiAqL1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc3VwZXIoY29udGV4dCwgU1RBVEUsIHByb2dyYW0pO1xyXG4gICAgICAgIGNvbnN0IGlkU2FtcGxlckJ1ZmZlcldyaXRlciA9IG5ldyBJZFNhbXBsZXJCdWZmZXJXcml0ZXIoKTtcclxuICAgICAgICB0aGlzLl9pZFNhbXBsZXJWZXJ0ZXhCdWZmZXIgPSB0aGlzLl9jb250ZXh0LmNyZWF0ZVZlcnRleEJ1ZmZlcihpZFNhbXBsZXJCdWZmZXJXcml0ZXIudmVydGV4RGF0YS5ieXRlTGVuZ3RoKTtcclxuICAgICAgICB0aGlzLl9pZFNhbXBsZXJJbmRleEJ1ZmZlciA9IHRoaXMuX2NvbnRleHQuY3JlYXRlSW5kZXhCdWZmZXIoaWRTYW1wbGVyQnVmZmVyV3JpdGVyLmluZGV4RGF0YS5ieXRlTGVuZ3RoKTtcclxuICAgICAgICB0aGlzLl9pZFNhbXBsZXJWYW8gPSB0aGlzLl9jb250ZXh0LmNyZWF0ZVZhbyhBVFRSSUJVVEVfTUFQUElORywgdGhpcy5faWRTYW1wbGVyVmVydGV4QnVmZmVyLCB0aGlzLl9pZFNhbXBsZXJJbmRleEJ1ZmZlcik7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC51cGxvYWREYXRhVG9CdWZmZXIodGhpcy5faWRTYW1wbGVyVmVydGV4QnVmZmVyLCBpZFNhbXBsZXJCdWZmZXJXcml0ZXIudmVydGV4RGF0YSk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC51cGxvYWREYXRhVG9CdWZmZXIodGhpcy5faWRTYW1wbGVySW5kZXhCdWZmZXIsIGlkU2FtcGxlckJ1ZmZlcldyaXRlci5pbmRleERhdGEpO1xyXG4gICAgICAgIGNvbnRleHQuYmluZFByb2dyYW0ocHJvZ3JhbSk7XHJcbiAgICAgICAgcHJvZ3JhbS5zZXRJbnRTY2FsYXJVbmlmb3JtKCdwcmV2VmlzaWJpbGl0eScsIDApO1xyXG4gICAgfVxyXG4gICAgX3ByZXBhcmVQcm9ncmFtKHByb2dyYW0sIHByZXZWaXNpYmlsaXR5LCBmYWRlb3V0QW1vdW50KSB7XHJcbiAgICAgICAgc3VwZXIuX3ByZXBhcmVQcm9ncmFtKHByb2dyYW0sIHByZXZWaXNpYmlsaXR5LCBmYWRlb3V0QW1vdW50KTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRUZXh0dXJlVW5pdCgwKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRUZXh0dXJlKHByZXZWaXNpYmlsaXR5KTtcclxuICAgICAgICBwcm9ncmFtLnNldFNjYWxhclVuaWZvcm0oJ2ZhZGVvdXRBbW91bnQnLCBmYWRlb3V0QW1vdW50KTtcclxuICAgIH1cclxuICAgIF9yZW5kZXIoKSB7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kVmFvKHRoaXMuX2lkU2FtcGxlclZhbyk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5kcmF3SW5kZXhlZE1lc2goMCwgNiwgNCAvKiBUUklBTkdMRVMgKi8pO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3Zpc2liaWxpdHkvdmlzaWJpbGl0eV9yZXNvbHV0aW9uX3N0ZXBzL2ZhZGVvdXRfYWxsLnRzXG4vLyBtb2R1bGUgaWQgPSAxNjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcIiN2ZXJzaW9uIDEwMFxcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxuYXR0cmlidXRlIHZlYzQgcG9zaXRpb247XFxuXFxudmFyeWluZyB2ZWMyIGlkVGV4Q29vcmRpbmF0ZXM7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICBnbF9Qb3NpdGlvbiA9IHZlYzQocG9zaXRpb24ueHksIDAsIDEpO1xcbiAgICBpZFRleENvb3JkaW5hdGVzID0gcG9zaXRpb24uenc7XFxufVxcblwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdmlzaWJpbGl0eS92aXNpYmlsaXR5X3Jlc29sdXRpb25fc3RlcHMvc2hhZGVycy9mYWRlb3V0X2FsbC52ZXJ0XG4vLyBtb2R1bGUgaWQgPSAxNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcIiN2ZXJzaW9uIDEwMFxcblxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgcHJldlZpc2liaWxpdHk7XFxudW5pZm9ybSBmbG9hdCBmYWRlb3V0QW1vdW50O1xcblxcbnZhcnlpbmcgdmVjMiBpZFRleENvb3JkaW5hdGVzO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgdmVjNCB2aXNpYmlsaXR5VmFsdWUgPSB0ZXh0dXJlMkQocHJldlZpc2liaWxpdHksIGlkVGV4Q29vcmRpbmF0ZXMpO1xcbiAgICB2aXNpYmlsaXR5VmFsdWUuYSA9IGNsYW1wKHZpc2liaWxpdHlWYWx1ZS5hIC0gZmFkZW91dEFtb3VudCwgMC4wLCAxLjApO1xcblxcbiAgICBnbF9GcmFnQ29sb3IgPSB2aXNpYmlsaXR5VmFsdWU7XFxufVxcblwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdmlzaWJpbGl0eS92aXNpYmlsaXR5X3Jlc29sdXRpb25fc3RlcHMvc2hhZGVycy9mYWRlb3V0X2FsbC5mcmFnXG4vLyBtb2R1bGUgaWQgPSAxNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgQXR0cmlidXRlTWFwcGluZyB9IGZyb20gJy4uL3JlbmRlci9hdHRyaWJfbWFwcGluZyc7XHJcbmltcG9ydCBCdWZmZXJXcml0ZXIgZnJvbSAnLi4vdXRpbC9idWZmZXJfd3JpdGVyJztcclxuZXhwb3J0IGNvbnN0IEFUVFJJQlVURV9NQVBQSU5HID0gbmV3IEF0dHJpYnV0ZU1hcHBpbmcoW1xyXG4gICAgW1xyXG4gICAgICAgIDAgLyogUE9TSVRJT04gKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiA0LFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIwIC8qIEJZVEUgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgXVxyXG5dKTtcclxuLyoqXHJcbiAqIFdyaXRlIHZlcnRpY2VzIG9mIHR3byB0cmlhbmdsZXMgdGhhdCBmdWxseSBjb3ZlciB2aXNpYmlsaXR5IHRleHR1cmUsIGl0cyB2YWx1ZXMgY2FuIGJlIHNhbXBsZWQgaW4gZnJhZ21lbnQgc2hhZGVycy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElkU2FtcGxlckJ1ZmZlcldyaXRlciBleHRlbmRzIEJ1ZmZlcldyaXRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcihBVFRSSUJVVEVfTUFQUElORy52ZXJ0ZXhCeXRlU2l6ZSwgNCwgNCwgNik7XHJcbiAgICAgICAgLy8gd2luZG93IHgsIHdpbmRvdyB5LCB0ZXh0dXJlIHgsIHRleHR1cmUgeVxyXG4gICAgICAgIHRoaXMuX3dyaXRlQnl0ZXMoLTEsIC0xLCAwLCAwKTtcclxuICAgICAgICB0aGlzLl93cml0ZUJ5dGVzKC0xLCAxLCAwLCAxKTtcclxuICAgICAgICB0aGlzLl93cml0ZUJ5dGVzKDEsIDEsIDEsIDEpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlQnl0ZXMoMSwgLTEsIDEsIDApO1xyXG4gICAgICAgIHRoaXMud3JpdGVJbmRpY2VzRm9yRmFuKFswLCAxLCAyLCAzXSk7XHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhEYXRhID0gdGhpcy5nZXRCdWZmZXJzKClbMF0udmVydGV4QnVmZmVyO1xyXG4gICAgICAgIHRoaXMuaW5kZXhEYXRhID0gdGhpcy5nZXRCdWZmZXJzKClbMF0uaW5kZXhCdWZmZXI7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdmlzaWJpbGl0eS9pZF9zYW1wbGVyX2J1ZmZlcl93cml0ZXIudHNcbi8vIG1vZHVsZSBpZCA9IDE2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBHbFJlbmRlcmVyIH0gZnJvbSAnLi4vLi4vcmVuZGVyL2dsX3JlbmRlcmVyJztcclxuaW1wb3J0IGZhZGVpblZpc2libGVWZXJ0ZXhTaGFkZXIgZnJvbSAnLi9zaGFkZXJzL2ZhZGVpbl92aXNpYmxlLnZlcnQnO1xyXG5pbXBvcnQgZmFkZWluVmlzaWJsZUZyYWdtZW50U2hhZGVyIGZyb20gJy4vc2hhZGVycy9mYWRlaW5fdmlzaWJsZS5mcmFnJztcclxuaW1wb3J0IFJlbmRlclN0YXRlIGZyb20gJy4uLy4uL3JlbmRlci9zdGF0ZSc7XHJcbmNvbnN0IFNUQVRFID0gbmV3IFJlbmRlclN0YXRlKHtcclxuICAgIGRpdGhlcjogZmFsc2VcclxufSk7XHJcbi8qKlxyXG4gKiBPbmUgb2YgdGhlIHN0ZXBzIG9mIHByaW1pdGl2ZXMgdmlzaWJpbGl0eSByZXNvbHV0aW9uIHByb2Nlc3MuIEl0IHNhbXBsZXMgYWxsIHBpeGVscyBvZiB0aGUgc2NlbmUgKHJlbmRlcmVkIGluIGRpcmVjdFxyXG4gKiBwcmlvcml0eSBvcmRlciBpbnRvIHNpbXBsaWZpZWQgZ3JpZCkgYW5kIGFkZHMgZGVsdGEgKGZhZGVpbkFtb3VudCkgdG8gYWxwaGEgdmlzaWJpbGl0eSBvZiBwcmltaXRpdmUgd2l0aFxyXG4gKiBpZCBpbiB0aGlzIHBpeGVsLiBUaG9zZSBwcmltaXRpdmVzIGFyZSBjb25zaWRlcmVkIHZpc2libGUuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGYWRlaW5WaXNpYmxlIGV4dGVuZHMgR2xSZW5kZXJlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XHJcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IGNvbnRleHQuY3JlYXRlUHJvZ3JhbShmYWRlaW5WaXNpYmxlVmVydGV4U2hhZGVyLCBmYWRlaW5WaXNpYmxlRnJhZ21lbnRTaGFkZXIsIHtcclxuICAgICAgICAgICAgYXR0cmliTWFwOiB7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogMCAvKiBQT1NJVElPTiAqL1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc3VwZXIoY29udGV4dCwgU1RBVEUsIHByb2dyYW0pO1xyXG4gICAgICAgIGNvbnRleHQuYmluZFByb2dyYW0ocHJvZ3JhbSk7XHJcbiAgICAgICAgcHJvZ3JhbS5zZXRJbnRTY2FsYXJVbmlmb3JtKCdkaXJlY3RQcmlvcml0eUdyaWQnLCAwKTtcclxuICAgICAgICBwcm9ncmFtLnNldEludFNjYWxhclVuaWZvcm0oJ3ByZXZWaXNpYmlsaXR5JywgMSk7XHJcbiAgICB9XHJcbiAgICBfcHJlcGFyZVByb2dyYW0ocHJvZ3JhbSwgZGF0YSwgc2FtcGxlcnMsIGRpcmVjdFByaW9yaXR5R3JpZCwgcHJldlZpc2liaWxpdHksIGlkSGFsZlB4U2l6ZSwgZmFkZWluQW1vdW50KSB7XHJcbiAgICAgICAgc3VwZXIuX3ByZXBhcmVQcm9ncmFtKHByb2dyYW0sIGRhdGEsIHNhbXBsZXJzLCBkaXJlY3RQcmlvcml0eUdyaWQsIHByZXZWaXNpYmlsaXR5LCBpZEhhbGZQeFNpemUsIGZhZGVpbkFtb3VudCk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kVGV4dHVyZVVuaXQoMCk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kVGV4dHVyZShkaXJlY3RQcmlvcml0eUdyaWQpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFRleHR1cmVVbml0KDEpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFRleHR1cmUocHJldlZpc2liaWxpdHkpO1xyXG4gICAgICAgIHByb2dyYW0uc2V0VmVjdG9yMlVuaWZvcm0oJ2lkSGFsZlB4U2l6ZScsIGlkSGFsZlB4U2l6ZSk7XHJcbiAgICAgICAgcHJvZ3JhbS5zZXRTY2FsYXJVbmlmb3JtKCdmYWRlaW5BbW91bnQnLCBmYWRlaW5BbW91bnQpO1xyXG4gICAgfVxyXG4gICAgX3JlbmRlcihkYXRhLCBudW1iZXJPZlNhbXBsZXJzKSB7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kVmFvKGRhdGEpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuZHJhd01lc2goMCwgbnVtYmVyT2ZTYW1wbGVycywgMCAvKiBQT0lOVFMgKi8pO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3Zpc2liaWxpdHkvdmlzaWJpbGl0eV9yZXNvbHV0aW9uX3N0ZXBzL2ZhZGVpbl92aXNpYmxlLnRzXG4vLyBtb2R1bGUgaWQgPSAxNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcIiN2ZXJzaW9uIDEwMFxcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxuYXR0cmlidXRlIHZlYzIgcG9zaXRpb247XFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgZGlyZWN0UHJpb3JpdHlHcmlkO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHByZXZWaXNpYmlsaXR5O1xcbnVuaWZvcm0gdmVjMiBpZEhhbGZQeFNpemU7XFxudW5pZm9ybSBmbG9hdCBmYWRlaW5BbW91bnQ7XFxuXFxudmFyeWluZyBsb3dwIHZlYzQgdmlzaWJpbGl0eVZhbHVlO1xcblxcbmNvbnN0IHZlYzIgTk9fSUQgPSB2ZWMyKDAsIDApO1xcbmNvbnN0IHZlYzQgRElTQ0FSRF9QT1NJVElPTiA9IHZlYzQoMiwgMiwgMiwgMSk7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICB2ZWMyIHByaW1pdGl2ZUlkID0gdGV4dHVyZTJEKGRpcmVjdFByaW9yaXR5R3JpZCwgcG9zaXRpb24pLnJnO1xcblxcbiAgICBpZiAocHJpbWl0aXZlSWQgIT0gTk9fSUQpIHtcXG4gICAgICAgIHZlYzIgaWRUZXhDb29yZGluYXRlcyA9IHByaW1pdGl2ZUlkICsgaWRIYWxmUHhTaXplO1xcbiAgICAgICAgdmVjNCBpZFdpbmRvd0Nvb3JkaW5hdGVzID0gdmVjNChpZFRleENvb3JkaW5hdGVzICogMi4wIC0gMS4wLCAwLCAxKTtcXG4gICAgICAgIGdsX1Bvc2l0aW9uID0gaWRXaW5kb3dDb29yZGluYXRlcztcXG4gICAgICAgIGdsX1BvaW50U2l6ZSA9IDEuMDtcXG5cXG4gICAgICAgIHZpc2liaWxpdHlWYWx1ZSA9IHRleHR1cmUyRChwcmV2VmlzaWJpbGl0eSwgaWRUZXhDb29yZGluYXRlcyk7XFxuICAgICAgICB2aXNpYmlsaXR5VmFsdWUuYSA9IGNsYW1wKHZpc2liaWxpdHlWYWx1ZS5hICsgZmFkZWluQW1vdW50LCAwLjAsIDEuMCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICBnbF9Qb3NpdGlvbiA9IERJU0NBUkRfUE9TSVRJT047XFxuICAgIH1cXG59XFxuXCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS92aXNpYmlsaXR5L3Zpc2liaWxpdHlfcmVzb2x1dGlvbl9zdGVwcy9zaGFkZXJzL2ZhZGVpbl92aXNpYmxlLnZlcnRcbi8vIG1vZHVsZSBpZCA9IDE2NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwiI3ZlcnNpb24gMTAwXFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG52YXJ5aW5nIGxvd3AgdmVjNCB2aXNpYmlsaXR5VmFsdWU7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgICBnbF9GcmFnQ29sb3IgPSB2aXNpYmlsaXR5VmFsdWU7XFxufVxcblwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdmlzaWJpbGl0eS92aXNpYmlsaXR5X3Jlc29sdXRpb25fc3RlcHMvc2hhZGVycy9mYWRlaW5fdmlzaWJsZS5mcmFnXG4vLyBtb2R1bGUgaWQgPSAxNjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgR2xSZW5kZXJlciB9IGZyb20gJy4uLy4uL3JlbmRlci9nbF9yZW5kZXJlcic7XHJcbmltcG9ydCBmYWRlb3V0T3ZlcmxhcHBlZFZlcnRleFNoYWRlciBmcm9tICcuL3NoYWRlcnMvZmFkZW91dF9vdmVybGFwcGVkLnZlcnQnO1xyXG5pbXBvcnQgZmFkZW91dE92ZXJsYXBwZWRGcmFnbWVudFNoYWRlciBmcm9tICcuL3NoYWRlcnMvZmFkZW91dF9vdmVybGFwcGVkLmZyYWcnO1xyXG5pbXBvcnQgUmVuZGVyU3RhdGUgZnJvbSAnLi4vLi4vcmVuZGVyL3N0YXRlJztcclxuY29uc3QgU1RBVEUgPSBuZXcgUmVuZGVyU3RhdGUoeyBkaXRoZXI6IGZhbHNlIH0pO1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGYWRlb3V0T3ZlcmxhcHBlZCBleHRlbmRzIEdsUmVuZGVyZXIge1xyXG4gICAgY29uc3RydWN0b3IoY29udGV4dCkge1xyXG4gICAgICAgIGNvbnN0IHByb2dyYW0gPSBjb250ZXh0LmNyZWF0ZVByb2dyYW0oZmFkZW91dE92ZXJsYXBwZWRWZXJ0ZXhTaGFkZXIsIGZhZGVvdXRPdmVybGFwcGVkRnJhZ21lbnRTaGFkZXIsIHtcclxuICAgICAgICAgICAgYXR0cmliTWFwOiB7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogMCAvKiBQT1NJVElPTiAqL1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc3VwZXIoY29udGV4dCwgU1RBVEUsIHByb2dyYW0pO1xyXG4gICAgICAgIGNvbnRleHQuYmluZFByb2dyYW0ocHJvZ3JhbSk7XHJcbiAgICAgICAgcHJvZ3JhbS5zZXRJbnRTY2FsYXJVbmlmb3JtKCdkaXJlY3RQcmlvcml0eUdyaWQnLCAwKTtcclxuICAgICAgICBwcm9ncmFtLnNldEludFNjYWxhclVuaWZvcm0oJ3JldmVyc2VQcmlvcml0eUdyaWQnLCAxKTtcclxuICAgICAgICBwcm9ncmFtLnNldEludFNjYWxhclVuaWZvcm0oJ3ByZXZWaXNpYmlsaXR5JywgMik7XHJcbiAgICB9XHJcbiAgICBfcHJlcGFyZVByb2dyYW0ocHJvZ3JhbSwgZGF0YSwgc2FtcGxlcnMsIGRpcmVjdFByaW9yaXR5LCByZXZlcnNlUHJpb3JpdHksIHByZXZWaXNpYmlsaXR5LCBpZEhhbGZQeFNpemUsIGZhZGVvdXRBbW91bnQsIGN1cnJlbnRab29tKSB7XHJcbiAgICAgICAgc3VwZXIuX3ByZXBhcmVQcm9ncmFtKHByb2dyYW0sIGRhdGEsIHNhbXBsZXJzLCBkaXJlY3RQcmlvcml0eSwgcmV2ZXJzZVByaW9yaXR5LCBwcmV2VmlzaWJpbGl0eSwgaWRIYWxmUHhTaXplLCBmYWRlb3V0QW1vdW50LCBjdXJyZW50Wm9vbSk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kVGV4dHVyZVVuaXQoMCk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kVGV4dHVyZShkaXJlY3RQcmlvcml0eSk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kVGV4dHVyZVVuaXQoMSk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kVGV4dHVyZShyZXZlcnNlUHJpb3JpdHkpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFRleHR1cmVVbml0KDIpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFRleHR1cmUocHJldlZpc2liaWxpdHkpO1xyXG4gICAgICAgIHByb2dyYW0uc2V0VmVjdG9yMlVuaWZvcm0oJ2lkSGFsZlB4U2l6ZScsIGlkSGFsZlB4U2l6ZSk7XHJcbiAgICAgICAgcHJvZ3JhbS5zZXRTY2FsYXJVbmlmb3JtKCdmYWRlb3V0QW1vdW50JywgZmFkZW91dEFtb3VudCk7XHJcbiAgICAgICAgcHJvZ3JhbS5zZXRTY2FsYXJVbmlmb3JtKCdjdXJyZW50Wm9vbScsIGN1cnJlbnRab29tKTtcclxuICAgIH1cclxuICAgIF9yZW5kZXIoZGF0YSwgbnVtYmVyT2ZTYW1wbGVycykge1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFZhbyhkYXRhKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmRyYXdNZXNoKDAsIG51bWJlck9mU2FtcGxlcnMsIDAgLyogUE9JTlRTICovKTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS92aXNpYmlsaXR5L3Zpc2liaWxpdHlfcmVzb2x1dGlvbl9zdGVwcy9mYWRlb3V0X292ZXJsYXBwZWQudHNcbi8vIG1vZHVsZSBpZCA9IDE2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwiI3ZlcnNpb24gMTAwXFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG5hdHRyaWJ1dGUgdmVjMiBwb3NpdGlvbjtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCBkaXJlY3RQcmlvcml0eUdyaWQ7XFxudW5pZm9ybSBzYW1wbGVyMkQgcmV2ZXJzZVByaW9yaXR5R3JpZDtcXG51bmlmb3JtIHNhbXBsZXIyRCBwcmV2VmlzaWJpbGl0eTtcXG51bmlmb3JtIHZlYzIgaWRIYWxmUHhTaXplO1xcbnVuaWZvcm0gZmxvYXQgZmFkZW91dEFtb3VudDtcXG51bmlmb3JtIGZsb2F0IGN1cnJlbnRab29tO1xcblxcbnZhcnlpbmcgdmVjNCB2aXNpYmlsaXR5VmFsdWU7XFxuXFxuY29uc3QgdmVjMiBOT19JRCA9IHZlYzIoMCwgMCk7XFxuY29uc3QgdmVjNCBESVNDQVJEX1BPU0lUSU9OID0gdmVjNCgyLCAyLCAyLCAxKTtcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIHZlYzIgcHJpbWl0aXZlSWRSZXZlcnNlUHJpb3JpdHkgPSB0ZXh0dXJlMkQocmV2ZXJzZVByaW9yaXR5R3JpZCwgcG9zaXRpb24pLnJnO1xcblxcbiAgICBpZiAoXFxuICAgICAgICBwcmltaXRpdmVJZFJldmVyc2VQcmlvcml0eSAhPSBOT19JRCAmJlxcbiAgICAgICAgcHJpbWl0aXZlSWRSZXZlcnNlUHJpb3JpdHkgIT0gdGV4dHVyZTJEKGRpcmVjdFByaW9yaXR5R3JpZCwgcG9zaXRpb24pLnJnXFxuICAgICkge1xcbiAgICAgICAgdmVjMiBpZFRleENvb3JkaW5hdGVzID0gcHJpbWl0aXZlSWRSZXZlcnNlUHJpb3JpdHkgKyBpZEhhbGZQeFNpemU7XFxuICAgICAgICB2ZWM0IGlkV2luZG93Q29vcmRpbmF0ZXMgPSB2ZWM0KGlkVGV4Q29vcmRpbmF0ZXMgKiAyLjAgLSAxLjAsIDAsIDEpO1xcblxcbiAgICAgICAgZ2xfUG9zaXRpb24gPSBpZFdpbmRvd0Nvb3JkaW5hdGVzO1xcbiAgICAgICAgZ2xfUG9pbnRTaXplID0gMS4wO1xcblxcbiAgICAgICAgdmlzaWJpbGl0eVZhbHVlID0gdGV4dHVyZTJEKHByZXZWaXNpYmlsaXR5LCBpZFRleENvb3JkaW5hdGVzKTtcXG4gICAgICAgIHZpc2liaWxpdHlWYWx1ZS5iID0gY3VycmVudFpvb207XFxuICAgICAgICB2aXNpYmlsaXR5VmFsdWUuYSA9IGNsYW1wKHZpc2liaWxpdHlWYWx1ZS5hIC0gZmFkZW91dEFtb3VudCwgMC4wLCAxLjApO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgZ2xfUG9zaXRpb24gPSBESVNDQVJEX1BPU0lUSU9OO1xcbiAgICB9XFxufVxcblwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdmlzaWJpbGl0eS92aXNpYmlsaXR5X3Jlc29sdXRpb25fc3RlcHMvc2hhZGVycy9mYWRlb3V0X292ZXJsYXBwZWQudmVydFxuLy8gbW9kdWxlIGlkID0gMTY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbnZhcnlpbmcgbG93cCB2ZWM0IHZpc2liaWxpdHlWYWx1ZTtcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIGdsX0ZyYWdDb2xvciA9IHZpc2liaWxpdHlWYWx1ZTtcXG59XFxuXCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS92aXNpYmlsaXR5L3Zpc2liaWxpdHlfcmVzb2x1dGlvbl9zdGVwcy9zaGFkZXJzL2ZhZGVvdXRfb3ZlcmxhcHBlZC5mcmFnXG4vLyBtb2R1bGUgaWQgPSAxNzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICogYXMgdmVjMiBmcm9tICcuLi9tYXRoL3ZlY3RvcjInO1xyXG5pbXBvcnQgeyBjb21wdXRlQkJveEZvclBvaW50cyB9IGZyb20gJy4uL21hdGgvdmVjdG9yMic7XHJcbi8qKlxyXG4gKiBDb250YWluZXIgb2YgaW5kZXhlZCBtaW4vbWF4IHZhbHVlcyB3aXRoIGEgc2luZ2xlIHVwZGF0ZSBtZXRob2QuXHJcbiAqL1xyXG5jbGFzcyBFeHRyZW11bVN0b3JhZ2Uge1xyXG4gICAgY29uc3RydWN0b3IobGVuZ3RoKSB7XHJcbiAgICAgICAgdGhpcy5fbWlucyA9IG5ldyBBcnJheShsZW5ndGgpO1xyXG4gICAgICAgIHRoaXMuX21heHMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcclxuICAgICAgICB0aGlzLl9taW5zLmZpbGwoTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcclxuICAgICAgICB0aGlzLl9tYXhzLmZpbGwoTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZVZhbHVlKGluZGV4LCB2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX21pbnNbaW5kZXhdID0gTWF0aC5taW4odGhpcy5fbWluc1tpbmRleF0sIHZhbHVlKTtcclxuICAgICAgICB0aGlzLl9tYXhzW2luZGV4XSA9IE1hdGgubWF4KHRoaXMuX21heHNbaW5kZXhdLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICAqdmFsdWVzKCkge1xyXG4gICAgICAgIGNvbnN0IGl0ZW0gPSB7IG1pbjogMCwgbWF4OiAwLCBpbmRleDogLTEgfTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX21pbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaXRlbS5taW4gPSB0aGlzLl9taW5zW2ldO1xyXG4gICAgICAgICAgICBpdGVtLm1heCA9IHRoaXMuX21heHNbaV07XHJcbiAgICAgICAgICAgIGl0ZW0uaW5kZXggPSBpO1xyXG4gICAgICAgICAgICB5aWVsZCBpdGVtO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogU3F1YXJlcyB0aGF0IGFyZSBvbnkgdG91Y2hlZCBieSBhIGxpbmUgKHdpdGggbm8gc2lnbmlmaWNhbnQgY3Jvc3NpbmcgYW4gZWRnZSkgc2hvdWxkIG5vdCBiZSBjb25zaWRlcmVkIFwiY292ZXJlZFwiLlxyXG4gKiBJdCBoYXBwZW5zIHdoZW4gYSBwb2ludCBtYXRjaGVzIHRoZSBtYXggY29vcmRpbmF0ZSAoaW50ZWdlcikgYW5kIHRoaXMgY2FzZSBpcyBoYW5kbGVkIGhlcmUuXHJcbiAqL1xyXG5mdW5jdGlvbiBmbG9vclRvQ2VsbENvb3JkaW5hdGUodmFsdWUsIG1heFZhbHVlKSB7XHJcbiAgICByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkgJiYgbWF4VmFsdWUgPT09IHZhbHVlID8gdmFsdWUgLSAxIDogTWF0aC5mbG9vcih2YWx1ZSk7XHJcbn1cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgc3F1YXJlcyBjb3ZlcmVkIChhdCBsZWFzdCBwYXJ0aWFsbHkpIGJ5IGEgY29udmV4IHBvbHlnb24uXHJcbiAqXHJcbiAqIEBwYXJhbSBwb2ludHMgQ29udmV4IHBvbHlnb24gcG9pbnQgY29vcmRpbmF0ZXMgKG9uIHRoZSBncmlkKS5cclxuICogQHJldHVybnMgTGlzdCBvZiB1bml0IHNxdWFyZSBjb29yZGluYXRlcy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlU3F1YXJlc0NvdmVyZWRCeUNvbnZleFBvbHlnb24ocG9pbnRzKSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgIGNvbnN0IGJib3ggPSBjb21wdXRlQkJveEZvclBvaW50cyhwb2ludHMpO1xyXG4gICAgY29uc3QgbWluWCA9IE1hdGguZmxvb3IoYmJveC5taW5YKTtcclxuICAgIGNvbnN0IHhMZW5ndGggPSBNYXRoLmNlaWwoYmJveC5tYXhYKSAtIG1pblg7XHJcbiAgICBjb25zdCBleHRyZW11bXMgPSBuZXcgRXh0cmVtdW1TdG9yYWdlKHhMZW5ndGgpO1xyXG4gICAgZm9yIChsZXQgaSA9IHBvaW50cy5sZW5ndGggLSAxLCBqID0gMDsgaiA8IHBvaW50cy5sZW5ndGg7IGkgPSBqKyspIHtcclxuICAgICAgICBsZXQgcDEgPSBwb2ludHNbaV07XHJcbiAgICAgICAgbGV0IHAyID0gcG9pbnRzW2pdO1xyXG4gICAgICAgIC8vIGdvIGZyb20gbGVmdCB0byByaWdodCBhbHdheXMgdG8gbm90IGhhbmRsZSB0aGUgb3Bwb3NpdGUgY2FzZVxyXG4gICAgICAgIGlmIChwMS54ID4gcDIueCkge1xyXG4gICAgICAgICAgICBjb25zdCB0bXAgPSBwMTtcclxuICAgICAgICAgICAgcDEgPSBwMjtcclxuICAgICAgICAgICAgcDIgPSB0bXA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBmcm9tL3RvIGludGVydmFsIHNvIHRoYXQgb25seSBcImludGVybmFsXCIgaW50ZWdlciB4LWVzIGFyZSBjYXB0dXJlZFxyXG4gICAgICAgIGNvbnN0IGZyb21YID0gTWF0aC5mbG9vcihwMS54ICsgMSk7XHJcbiAgICAgICAgY29uc3QgdG9YID0gTWF0aC5jZWlsKHAyLnggLSAxKTtcclxuICAgICAgICBjb25zdCBzbG9wZSA9IChwMS55IC0gcDIueSkgLyAocDEueCAtIHAyLngpO1xyXG4gICAgICAgIC8vIGhhbmRsZSB0ZXJtaW5hbCBwb2ludHMgc2VwYXJhdGVseSBmcm9tIHRoZSBcImludGVybmFsXCIgb25lc1xyXG4gICAgICAgIGV4dHJlbXVtcy51cGRhdGVWYWx1ZShmbG9vclRvQ2VsbENvb3JkaW5hdGUocDEueCwgYmJveC5tYXhYKSAtIG1pblgsIGZsb29yVG9DZWxsQ29vcmRpbmF0ZShwMS55LCBiYm94Lm1heFkpKTtcclxuICAgICAgICBleHRyZW11bXMudXBkYXRlVmFsdWUoZmxvb3JUb0NlbGxDb29yZGluYXRlKHAyLngsIGJib3gubWF4WCkgLSBtaW5YLCBmbG9vclRvQ2VsbENvb3JkaW5hdGUocDIueSwgYmJveC5tYXhZKSk7XHJcbiAgICAgICAgZm9yIChsZXQgeCA9IGZyb21YOyB4IDw9IHRvWDsgeCsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHlJbnRlcmNlcHQgPSAoaXNGaW5pdGUoc2xvcGUpID8gc2xvcGUgKiAoeCAtIHAxLngpIDogMCkgKyBwMS55O1xyXG4gICAgICAgICAgICBjb25zdCBuZXh0WCA9IHggLSBtaW5YO1xyXG4gICAgICAgICAgICBjb25zdCBwcmV2WCA9IG5leHRYIC0gMTtcclxuICAgICAgICAgICAgY29uc3QgeSA9IE1hdGguZmxvb3IoeUludGVyY2VwdCk7XHJcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHdlIGhpdCBleGFjdGx5IHRoZSBpbnRlcnNlY3Rpb24gb2YgdHdvIGludGVnZXIgY29vcmRpbmF0ZXNcclxuICAgICAgICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIoeUludGVyY2VwdCkpIHtcclxuICAgICAgICAgICAgICAgIGlmICh5SW50ZXJjZXB0ID09PSBiYm94Lm1heFkpIHtcclxuICAgICAgICAgICAgICAgICAgICBleHRyZW11bXMudXBkYXRlVmFsdWUocHJldlgsIHkgLSAxKTtcclxuICAgICAgICAgICAgICAgICAgICBleHRyZW11bXMudXBkYXRlVmFsdWUobmV4dFgsIHkgLSAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNsb3BlID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHR3byBkaWFnb25hbCBzcXVhcmVzIGludGVyc2VjdGVkIGJ5IGEgbGluZSB3aXRoIHBvc2l0aXZlIHNsb3BlXHJcbiAgICAgICAgICAgICAgICAgICAgZXh0cmVtdW1zLnVwZGF0ZVZhbHVlKHByZXZYLCB5IC0gMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXh0cmVtdW1zLnVwZGF0ZVZhbHVlKG5leHRYLCB5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNsb3BlIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHR3byBkaWFnb25hbCBzcXVhcmVzIGludGVyc2VjdGVkIGJ5IGEgbGluZSB3aXRoIG5lZ2F0aXZlIHNsb3BlXHJcbiAgICAgICAgICAgICAgICAgICAgZXh0cmVtdW1zLnVwZGF0ZVZhbHVlKHByZXZYLCB5KTtcclxuICAgICAgICAgICAgICAgICAgICBleHRyZW11bXMudXBkYXRlVmFsdWUobmV4dFgsIHkgLSAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGV4dHJlbXVtcy51cGRhdGVWYWx1ZShwcmV2WCwgeSk7XHJcbiAgICAgICAgICAgICAgICBleHRyZW11bXMudXBkYXRlVmFsdWUobmV4dFgsIHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZm9yIChjb25zdCB7IG1pbiwgbWF4LCBpbmRleCB9IG9mIGV4dHJlbXVtcy52YWx1ZXMoKSkge1xyXG4gICAgICAgIGNvbnN0IHggPSBtaW5YICsgaW5kZXg7XHJcbiAgICAgICAgZm9yIChsZXQgeSA9IG1pbjsgeSA8PSBtYXg7IHkrKykge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaCh2ZWMyLmNyZWF0ZSh4LCB5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL2NhcnRlc2lhbl9ncmlkLnRzXG4vLyBtb2R1bGUgaWQgPSAxNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgY29weSB9IGZyb20gJy4vYXJyYXknO1xyXG5pbXBvcnQgeyBOVU1FUklDQUxfQ09NUEFSQVRPUiB9IGZyb20gJy4vY29tcGFyYXRvcic7XHJcbi8qKlxyXG4gKiBGaWx0ZXJzIGFuIGFycmF5IG9mIHZhbHVlcyB3aXRoIG1lZGlhbiBmaWx0ZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB2YWx1ZXMgVmFsdWVzIHRvIGJlIGZpbHRlcmVkLlxyXG4gKiBAcGFyYW0gd2luZG93UmFkaXVzIEhvdyBtYW55IHZhbHVlcyBhcm91bmQgYSBzYW1wbGUgZ2V0IGludG8gZmlsdGVyIHdpbmRvdy5cclxuICogQHJldHVybnMgQXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG1lZGlhbkZpbHRlcih2YWx1ZXMsIHdpbmRvd1JhZGl1cyA9IDMpIHtcclxuICAgIGNvbnN0IHdpbmRvdyA9IG5ldyBBcnJheSgyICogd2luZG93UmFkaXVzICsgMSk7XHJcbiAgICB3aW5kb3cuZmlsbCh2YWx1ZXNbMF0pO1xyXG4gICAgY29uc3QgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aDtcclxuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheShsZW5ndGgpO1xyXG4gICAgY29uc3QgZmlyc3QgPSB2YWx1ZXNbMF07XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdpbmRvd1JhZGl1czsgKytpKSB7XHJcbiAgICAgICAgd2luZG93LmZpbGwoZmlyc3QsIDAsIHdpbmRvd1JhZGl1cyAtIGkgKyAxKTtcclxuICAgICAgICBjb3B5KHZhbHVlcywgd2luZG93LCAwLCBpICsgd2luZG93UmFkaXVzICsgMSwgd2luZG93UmFkaXVzIC0gaSArIDEpO1xyXG4gICAgICAgIHdpbmRvdy5zb3J0KE5VTUVSSUNBTF9DT01QQVJBVE9SKTtcclxuICAgICAgICByZXN1bHRbaV0gPSB3aW5kb3dbd2luZG93UmFkaXVzXTtcclxuICAgIH1cclxuICAgIGZvciAobGV0IGkgPSB3aW5kb3dSYWRpdXM7IGkgPCBsZW5ndGggLSB3aW5kb3dSYWRpdXM7ICsraSkge1xyXG4gICAgICAgIGNvcHkodmFsdWVzLCB3aW5kb3csIGkgLSB3aW5kb3dSYWRpdXMsIGkgKyB3aW5kb3dSYWRpdXMgKyAxKTtcclxuICAgICAgICB3aW5kb3cuc29ydChOVU1FUklDQUxfQ09NUEFSQVRPUik7XHJcbiAgICAgICAgcmVzdWx0W2ldID0gd2luZG93W3dpbmRvd1JhZGl1c107XHJcbiAgICB9XHJcbiAgICBjb25zdCBsYXN0ID0gdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXTtcclxuICAgIGZvciAobGV0IGkgPSBsZW5ndGggLSB3aW5kb3dSYWRpdXM7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgICAgIGNvcHkodmFsdWVzLCB3aW5kb3csIGkgLSB3aW5kb3dSYWRpdXMsIGxlbmd0aCk7XHJcbiAgICAgICAgd2luZG93LmZpbGwobGFzdCwgdmFsdWVzLmxlbmd0aCAtIGkgKyB3aW5kb3dSYWRpdXMpO1xyXG4gICAgICAgIHdpbmRvdy5zb3J0KE5VTUVSSUNBTF9DT01QQVJBVE9SKTtcclxuICAgICAgICByZXN1bHRbaV0gPSB3aW5kb3dbd2luZG93UmFkaXVzXTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9tZWRpYW5fZmlsdGVyLnRzXG4vLyBtb2R1bGUgaWQgPSAxNzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IExpc3RSZW5kZXJVbml0IGZyb20gJy4vbGlzdF9yZW5kZXJfdW5pdCc7XHJcbmltcG9ydCB7IFZvaWRFdmVudEVtaXR0ZXIgfSBmcm9tICcuLi91dGlsL2V2ZW50X2VtaXR0ZXInO1xyXG5pbXBvcnQgUmVuZGVyU3RhdGUgZnJvbSAnLi9zdGF0ZSc7XHJcbmltcG9ydCB7IGNhbGN1bGF0ZUNhbWVyYVBvc2l0aW9ucyB9IGZyb20gJy4vdXRpbC9jYW1lcmFfcG9zaXRpb24nO1xyXG5jb25zdCBGSU5BTF9SRU5ERVJfU1RBVEUgPSBuZXcgUmVuZGVyU3RhdGUoe1xyXG4gICAgY2xlYXJEZXB0aDogMCxcclxuICAgIGRlcHRoVGVzdDogdHJ1ZSxcclxuICAgIGRlcHRoRnVuYzogNTE4IC8qIEdSRUFURVJfT1JfRVFVQUwgKi9cclxufSk7XHJcbi8qKlxyXG4gKiBSb290IHNjZW5lIHJlbmRlcmVyLiBJdCBnZW5lcmF0ZXMgZmluYWwgY2FudmFzIGltYWdlIGNvbXBvc2luZyBpdCBmcm9tIGluZGVwZW5kZW50IGxheWVycyAoTGF5ZXJSZW5kZXJVbml0KS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1haW5SZW5kZXJVbml0IGV4dGVuZHMgTGlzdFJlbmRlclVuaXQge1xyXG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgY2FtZXJhKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcclxuICAgICAgICB0aGlzLl9jYW1lcmEgPSBjYW1lcmE7XHJcbiAgICAgICAgdGhpcy5vblJlbmRlciA9IG5ldyBWb2lkRXZlbnRFbWl0dGVyKCk7XHJcbiAgICB9XHJcbiAgICByZW5kZXIodGFyZ2V0KSB7XHJcbiAgICAgICAgY29uc3Qgdmlld1Byb2pNYXRpeCA9IHRoaXMuX2NhbWVyYS5nZXRWaWV3UHJvak1hdHJpeCgpO1xyXG4gICAgICAgIGNvbnN0IGNhbWVyYVBvc2l0aW9ucyA9IGNhbGN1bGF0ZUNhbWVyYVBvc2l0aW9ucyh0aGlzLl9jYW1lcmEpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFJlbmRlclRhcmdldCh0YXJnZXQpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFJlbmRlclN0YXRlKEZJTkFMX1JFTkRFUl9TVEFURSk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5jbGVhckN1cnJlbnRUYXJnZXQoMTc2NjQgLyogQUxMICovKTtcclxuICAgICAgICBmb3IgKGNvbnN0IHJlbmRlcmVyIG9mIHRoaXMuX3N1YlJlbmRlclVuaXRzKSB7XHJcbiAgICAgICAgICAgIHJlbmRlcmVyLnJlbmRlcih0YXJnZXQsIHZpZXdQcm9qTWF0aXgsIGNhbWVyYVBvc2l0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMub25SZW5kZXIuZmlyZSgpO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9tYWluX3JlbmRlcl91bml0LnRzXG4vLyBtb2R1bGUgaWQgPSAxNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IE1lbW9yeVBhZ2UgZnJvbSAnLi9wYWdlJztcclxuaW1wb3J0IHsgY291bnRWZXJ0aWNlcyB9IGZyb20gJy4vY291bnRfdmVydGljZXMnO1xyXG5pbXBvcnQgeyBBcmVuYUFsbG9jYXRvciB9IGZyb20gJy4uLy4uL3V0aWwvYWxsb2NhdG9yJztcclxuY29uc3QgTUFYX1ZFUlRFWF9DT1VOVCA9IDB4MTAwMDA7XHJcbi8vIEZJWE1FKGRtaWtpcykgTGV0J3MgdXNlIG92ZXJzaXplZCBpbmRleCBidWZmZXIgdGlsIHdlIHNvcnQgb3V0IGluZGljZXMgYWxsb2NhdGlvblxyXG4vLyBib3RoIGluIHdyaXRlcnMgYW5kIHRoZSBtYW5hZ2VyLlxyXG5jb25zdCBQQUdFX0lOREVYX0JVRkZFUl9CWVRFX1NJWkUgPSAweDEwMDAwMDtcclxuLyoqXHJcbiAqIE1lbW9yeSBwYWdlIHdpdGggdGhlIGZvbGxvd2luZyBwZWN1bGlhcml0eTogb25jZSBhbGxvY2F0aW9uIGlzIGZhaWxlZCBpdCBnZXRzIGNsb3NlZCBmb3IgYW55IHN1YnNlcXVlbnRcclxuICogYWxsb2NhdGlvbnMuIEl0IGFsbG93IHRvIGtlZXAgcmVsYXRlZCBwcmltaXRpdmVzIGNsb3NlciBpbiBtZW1vcnkuXHJcbiAqL1xyXG5jbGFzcyBTaW5nbGVQYXNzTWVtb3J5UGFnZSBleHRlbmRzIE1lbW9yeVBhZ2Uge1xyXG4gICAgY29uc3RydWN0b3IodmVydGV4QnVmZmVyLCBpbmRleEJ1ZmZlciwgdmFvLCBpbmRleFR5cGUpIHtcclxuICAgICAgICBzdXBlcih2ZXJ0ZXhCdWZmZXIsIGluZGV4QnVmZmVyLCB2YW8sIGluZGV4VHlwZSwgbmV3IEFyZW5hQWxsb2NhdG9yKHZlcnRleEJ1ZmZlci5nZXRTaXplKCkpLCBuZXcgQXJlbmFBbGxvY2F0b3IoaW5kZXhCdWZmZXIuZ2V0U2l6ZSgpKSk7XHJcbiAgICAgICAgdGhpcy5fZmFpbGVkQWxsb2NhdGlvbiA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgYWxsb2NhdGUodmVydGV4Qnl0ZUxlbmd0aCwgaW5kZXhCeXRlTGVuZ3RoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2ZhaWxlZEFsbG9jYXRpb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNodW5rID0gc3VwZXIuYWxsb2NhdGUodmVydGV4Qnl0ZUxlbmd0aCwgaW5kZXhCeXRlTGVuZ3RoKTtcclxuICAgICAgICB0aGlzLl9mYWlsZWRBbGxvY2F0aW9uID0gKGNodW5rID09PSBudWxsKTtcclxuICAgICAgICByZXR1cm4gY2h1bms7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIE1hbmFnZXIgdGhhdCBjb250cm9scyBHTCBtZW1vcnkgYWxsb2NhdGlvbnMgYW5kIHBhZ2luYXRpb24uW11cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1lbW9yeU1hbmFnZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IG1lbW9yeSBtYW5hZ2VyIHRoYXQgd2lsbCBhbGxvY2F0ZSBtZW1vcnkgaW4gYSBnaXZlbiBjb250ZXh0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBjb250ZXh0LlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XHJcbiAgICAgICAgdGhpcy5fcGFnZXMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5fZW1wdHlQYWdlc0NsZWFyVGltZW91dCA9IDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFsbG9jYXRlcyBtZW1vcnkgZm9yIGEgZ2l2ZW4gZGF0YSBpbiB0aGUgbWFuYWdlciBhbmQgdXBsb2FkcyBnaXZlbiBkYXRhLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB2ZXJ0ZXhEYXRhIEJ1ZmZlciB3aXRoIHZlcnRpY2VzIHRoYXQgbmVlZHMgdG8gYmUgYWxsb2NhdGVkLlxyXG4gICAgICogQHBhcmFtIGluZGV4RGF0YSBCdWZmZXIgd2l0aCBpbmRpY2VzIHRoYXQgbmVlZHMgdG8gYmUgYWxsb2NhdGVkLlxyXG4gICAgICogQHBhcmFtIGF0dHJpYnV0ZU1hcHBpbmcgTWFwcGluZyBvZiB2ZXJ0ZXggYXR0cmlidXRlcy5cclxuICAgICAqIEByZXR1cm5zIERlc2NyaXB0b3Igb2YgdGhlIGFsbG9jYXRlZCBtZW1vcnkgcmVnaW9uLlxyXG4gICAgICovXHJcbiAgICBhbGxvY2F0ZSh2ZXJ0ZXhEYXRhLCBpbmRleERhdGEsIGF0dHJpYnV0ZU1hcHBpbmcpIHtcclxuICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5fY29udGV4dDtcclxuICAgICAgICBsZXQgcGFnZVNldCA9IHRoaXMuX3BhZ2VzLmdldChhdHRyaWJ1dGVNYXBwaW5nKTtcclxuICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIHBhZ2VzIGZvciB0aGUgZ2l2ZW4gYXR0cmlidXRlIG1hcHBpbmcsIGNyZWF0ZSBhIG5ldyBzZXQuXHJcbiAgICAgICAgaWYgKCFwYWdlU2V0KSB7XHJcbiAgICAgICAgICAgIHBhZ2VTZXQgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3BhZ2VzLnNldChhdHRyaWJ1dGVNYXBwaW5nLCBwYWdlU2V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVHJ5IHRvIGFsbG9jYXRlIGRhdGEgaW4gdGhlIGV4aXN0aW5nIHBhZ2VzLlxyXG4gICAgICAgIGZvciAoY29uc3QgcGFnZSBvZiBwYWdlU2V0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1lbW9yeUNodW5rID0gcGFnZS5hbGxvY2F0ZSh2ZXJ0ZXhEYXRhLmJ5dGVMZW5ndGgsIGluZGV4RGF0YS5ieXRlTGVuZ3RoKTtcclxuICAgICAgICAgICAgaWYgKG1lbW9yeUNodW5rKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTdWNjZXNzISBOb3cgd2UganVzdCB1cGxvYWQgdGhlIGRhdGEuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVQYWdlKHBhZ2UsIG1lbW9yeUNodW5rLCB2ZXJ0ZXhEYXRhLCBpbmRleERhdGEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lbW9yeUNodW5rO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFdlJ3ZlIGZhaWxlZCB0byBhbGxvY2F0ZSB0aGUgZGF0YSBpbiBhbnkgb2YgZXhpc3RpbmcgcGFnZXMuIE5vIHdvcnJpZXNcclxuICAgICAgICAvLyB0aG91Z2gsIHdlIGp1c3QgY3JlYXRlIGEgbmV3IG9uZTopXHJcbiAgICAgICAgY29uc3QgdmVydGV4QnVmZmVyID0gY29udGV4dC5jcmVhdGVWZXJ0ZXhCdWZmZXIoXHJcbiAgICAgICAgLy8gc29tZSBidWZmZXIgd3JpdGVycyBkb24ndCB1c2UgaW5kaWNlcyBhbmQgTUFYX1ZFUlRFWF9DT1VOVCByZXN0cmljdGlvbiBpcyBub3QgYXBwbGllZCBpbiBzdWNoIGNhc2VzXHJcbiAgICAgICAgTWF0aC5tYXgoTUFYX1ZFUlRFWF9DT1VOVCAqIGF0dHJpYnV0ZU1hcHBpbmcudmVydGV4Qnl0ZVNpemUsIHZlcnRleERhdGEuYnl0ZUxlbmd0aCkpO1xyXG4gICAgICAgIGNvbnN0IGluZGV4QnVmZmVyID0gY29udGV4dC5jcmVhdGVJbmRleEJ1ZmZlcihQQUdFX0lOREVYX0JVRkZFUl9CWVRFX1NJWkUpO1xyXG4gICAgICAgIGNvbnN0IHZhbyA9IGNvbnRleHQuY3JlYXRlVmFvKGF0dHJpYnV0ZU1hcHBpbmcsIHZlcnRleEJ1ZmZlciwgaW5kZXhCdWZmZXIpO1xyXG4gICAgICAgIGNvbnN0IHBhZ2UgPSBuZXcgU2luZ2xlUGFzc01lbW9yeVBhZ2UodmVydGV4QnVmZmVyLCBpbmRleEJ1ZmZlciwgdmFvLCA1MTIzIC8qIFVOU0lHTkVEX1NIT1JUICovKTtcclxuICAgICAgICBwYWdlLnNldERlbGVnYXRlKHRoaXMpO1xyXG4gICAgICAgIHBhZ2VTZXQuYWRkKHBhZ2UpO1xyXG4gICAgICAgIC8vIEhlcmUgd2UgYXNzdW1lIHdlIGFsd2F5cyBjYW4gYWxsb2NhdGUgZGF0YSBpbiBhbiBlbXB0eSBwYWdlLlxyXG4gICAgICAgIGNvbnN0IG1lbW9yeUNodW5rID0gcGFnZS5hbGxvY2F0ZSh2ZXJ0ZXhEYXRhLmJ5dGVMZW5ndGgsIGluZGV4RGF0YS5ieXRlTGVuZ3RoKTtcclxuICAgICAgICB0aGlzLl91cGRhdGVQYWdlKHBhZ2UsIG1lbW9yeUNodW5rLCB2ZXJ0ZXhEYXRhLCBpbmRleERhdGEpO1xyXG4gICAgICAgIHJldHVybiBtZW1vcnlDaHVuaztcclxuICAgIH1cclxuICAgIG9uUGFnZUVtcHR5KCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fZW1wdHlQYWdlc0NsZWFyVGltZW91dCkge1xyXG4gICAgICAgICAgICB0aGlzLl9lbXB0eVBhZ2VzQ2xlYXJUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jbGVhckVtcHR5UGFnZXMoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2VtcHR5UGFnZXNDbGVhclRpbWVvdXQgPSAwO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERlc3Ryb3lzIHRoZSBtYW5hZ2VyIGFuZCBhbGwgaXRzIG1lbW9yeSBwYWdlcy4gQWxsIG1lbW9yeSBjaHVua3MgdGhhdCB3ZXJlXHJcbiAgICAgKiBhbGxvY2F0ZWQgaW4gdGhlIG1hbmFnZXIgYmVjb21lIGludmFsaWQuXHJcbiAgICAgKi9cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2VtcHR5UGFnZXNDbGVhclRpbWVvdXQpIHtcclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2VtcHR5UGFnZXNDbGVhclRpbWVvdXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IFssIHBhZ2VTZXRdIG9mIHRoaXMuX3BhZ2VzKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGFnZSBvZiBwYWdlU2V0KSB7XHJcbiAgICAgICAgICAgICAgICBwYWdlLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF91cGRhdGVQYWdlKHBhZ2UsIG1lbW9yeUNodW5rLCB2ZXJ0ZXhEYXRhLCBpbmRleERhdGEpIHtcclxuICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5fY29udGV4dDtcclxuICAgICAgICAvLyBMZXQncyBlbnN1cmUgdGhhdCB3ZSB3b24ndCBicmVhayBhbnkgYm91bmQgVkFPcy5cclxuICAgICAgICBjb250ZXh0LmJpbmRWYW8obnVsbCk7XHJcbiAgICAgICAgY29udGV4dC51cGxvYWREYXRhVG9CdWZmZXIocGFnZS52ZXJ0ZXhCdWZmZXIsIHZlcnRleERhdGEsIG1lbW9yeUNodW5rLnZlcnRleEJ5dGVPZmZzZXQpO1xyXG4gICAgICAgIC8vIFNoaWZ0IGluZGljZXMuXHJcbiAgICAgICAgY29uc3QgYmFzZUluZGV4ID0gY291bnRWZXJ0aWNlcyhtZW1vcnlDaHVuay52ZXJ0ZXhCeXRlT2Zmc2V0LCBwYWdlLnZhby5hdHRyaWJ1dGVNYXBwaW5nKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGV4RGF0YS5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBpbmRleERhdGFbaV0gKz0gYmFzZUluZGV4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb250ZXh0LnVwbG9hZERhdGFUb0J1ZmZlcihwYWdlLmluZGV4QnVmZmVyLCBpbmRleERhdGEsIG1lbW9yeUNodW5rLmluZGV4Qnl0ZU9mZnNldCk7XHJcbiAgICB9XHJcbiAgICBfY2xlYXJFbXB0eVBhZ2VzKCkge1xyXG4gICAgICAgIGZvciAoY29uc3QgcGFnZVNldCBvZiB0aGlzLl9wYWdlcy52YWx1ZXMoKSkge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBhZ2Ugb2YgcGFnZVNldCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhZ2UuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFnZVNldC5kZWxldGUocGFnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFnZS5zZXREZWxlZ2F0ZShudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICBwYWdlLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvbWVtb3J5L21hbmFnZXIudHNcbi8vIG1vZHVsZSBpZCA9IDE3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgQ2h1bmsgZnJvbSAnLi9jaHVuayc7XHJcbmltcG9ydCB7IERlbGVnYXRvckJhc2UgfSBmcm9tICcuLi8uLi91dGlsL2RlbGVnYXRvcic7XHJcbi8qKlxyXG4gKiBBIFwicGFnZVwiIG9mIEdQVSBtZW1vcnkuIENvbXByaXNlcyB2ZXJ0ZXggYW5kIGluZGV4IGJ1ZmZlcnMgb2YgYSBmaXhlZCBzaXplLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWVtb3J5UGFnZSBleHRlbmRzIERlbGVnYXRvckJhc2Uge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHBhZ2UgdG8gbWFuYWdlIGdpdmVuIHZlcnRleCBhbmQgaW5kZXggYnVmZmVycy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmVydGV4QnVmZmVyIFRoZSB2ZXJ0ZXggYnVmZmVyIHRoZSBwYWdlIHdpbGwgbWFuYWdlLlxyXG4gICAgICogQHBhcmFtIGluZGV4QnVmZmVyIFRoZSBpbmRleCBidWZmZXIgdGhlIHBhZ2Ugd2lsbCBtYW5hZ2VyLlxyXG4gICAgICogQHBhcmFtIHZhbyBUaGUgVkFPIG9mIHRoZSBwYWdlLlxyXG4gICAgICogQHBhcmFtIGluZGV4VHlwZSBUeXBlIG9mIGVsZW1lbnRzIG9mIGluZGV4QnVmZmVyLlxyXG4gICAgICogQHBhcmFtIHZlcnRleEFsbG9jYXRvciBBbGxvY2F0b3Igb2YgdmVydGV4IGRhdGEsIGxvZ2ljIG9mIGFsbG9jYXRpb24gZGlyZWN0bHkgaW1wYWN0cyB0aGUgbGlmZWN5Y2xlIG9mIHRoZSBwYWdlLlxyXG4gICAgICogQHBhcmFtIGluZGV4QWxsb2NhdG9yIEFsbG9jYXRvciBvZiBpbmRleCBkYXRhLCBsb2dpYyBvZiBhbGxvY2F0aW9uIGRpcmVjdGx5IGltcGFjdHMgdGhlIGxpZmVjeWNsZSBvZiB0aGUgcGFnZS5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IodmVydGV4QnVmZmVyLCBpbmRleEJ1ZmZlciwgdmFvLCBpbmRleFR5cGUsIHZlcnRleEFsbG9jYXRvciwgaW5kZXhBbGxvY2F0b3IpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMudmVydGV4QnVmZmVyID0gdmVydGV4QnVmZmVyO1xyXG4gICAgICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBpbmRleEJ1ZmZlcjtcclxuICAgICAgICB0aGlzLnZhbyA9IHZhbztcclxuICAgICAgICB0aGlzLmluZGV4VHlwZSA9IGluZGV4VHlwZTtcclxuICAgICAgICB0aGlzLl92ZXJ0ZXhBbGxvY2F0b3IgPSB2ZXJ0ZXhBbGxvY2F0b3I7XHJcbiAgICAgICAgdGhpcy5faW5kZXhBbGxvY2F0b3IgPSBpbmRleEFsbG9jYXRvcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWxsb2NhdGVzIGFuZCB3cml0ZXMgdmVydGV4IGFuZCBpbmRleCBkYXRhIHRvIHRoZSBwYWdlLiBPZmZzZXRzIGluZGljZXNcclxuICAgICAqIGluIGFuIGluZGV4IGFycmF5IHRvIGFwcHJvcHJpYXRlbHkgdGFrZSBpbnRvIGFjY291bnQgb2Zmc2V0IG9mIHRoZSB2ZXJ0ZXhcclxuICAgICAqIGRhdGEuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZlcnRleEJ5dGVMZW5ndGggcmVxdWlyZWQgbnVtYmVyIG9mIGJ5dGVzIGluIHZlcnRleCBidWZmZXJcclxuICAgICAqIEBwYXJhbSBpbmRleEJ5dGVMZW5ndGggcmVxdWlyZWQgbnVtYmVyIG9mIGJ5dGVzIGluIGluZGV4IGJ1ZmZlclxyXG4gICAgICogQHJldHVybnMgbWVtb3J5IGNodW5rIGFsbG9jYXRlZCBvciBgbnVsbGAgaWYgYWxsb2NhdGlvbidzIGZhaWxlZFxyXG4gICAgICovXHJcbiAgICBhbGxvY2F0ZSh2ZXJ0ZXhCeXRlTGVuZ3RoLCBpbmRleEJ5dGVMZW5ndGgpIHtcclxuICAgICAgICBpZiAodGhpcy5fdmVydGV4QWxsb2NhdG9yLm1heEFsbG9jYWJsZVNpemUgPj0gdmVydGV4Qnl0ZUxlbmd0aCAmJlxyXG4gICAgICAgICAgICB0aGlzLl9pbmRleEFsbG9jYXRvci5tYXhBbGxvY2FibGVTaXplID49IGluZGV4Qnl0ZUxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENodW5rKHRoaXMsIHtcclxuICAgICAgICAgICAgICAgIHZlcnRleEJ5dGVPZmZzZXQ6IHRoaXMuX3ZlcnRleEFsbG9jYXRvci5hbGxvY2F0ZSh2ZXJ0ZXhCeXRlTGVuZ3RoKSxcclxuICAgICAgICAgICAgICAgIHZlcnRleEJ5dGVMZW5ndGg6IHZlcnRleEJ5dGVMZW5ndGgsXHJcbiAgICAgICAgICAgICAgICBpbmRleEJ5dGVPZmZzZXQ6IHRoaXMuX2luZGV4QWxsb2NhdG9yLmFsbG9jYXRlKGluZGV4Qnl0ZUxlbmd0aCksXHJcbiAgICAgICAgICAgICAgICBpbmRleEJ5dGVMZW5ndGg6IGluZGV4Qnl0ZUxlbmd0aFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRnJlZXMgYSBwcmV2aW91c2x5IGFsbG9jYXRlZCBtZW1vcnkgY2h1bmsuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byBiZSBmcmVlZC5cclxuICAgICAqL1xyXG4gICAgZnJlZShjaHVuaykge1xyXG4gICAgICAgIHRoaXMuX3ZlcnRleEFsbG9jYXRvci5kZWFsbG9jYXRlKGNodW5rLnZlcnRleEJ5dGVPZmZzZXQpO1xyXG4gICAgICAgIHRoaXMuX2luZGV4QWxsb2NhdG9yLmRlYWxsb2NhdGUoY2h1bmsuaW5kZXhCeXRlT2Zmc2V0KTtcclxuICAgICAgICBpZiAodGhpcy5pc0VtcHR5KCkgJiYgdGhpcy5fZGVsZWdhdGUpIHtcclxuICAgICAgICAgICAgdGhpcy5fZGVsZWdhdGUub25QYWdlRW1wdHkodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgcGFnZSBkb2VzIG5vdCBjb250YWluIGFueSBwcmV2aW91c2x5IGFsbG9jYXRlZCBkYXRhXHJcbiAgICAgKiBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXHJcbiAgICAgKi9cclxuICAgIGlzRW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZlcnRleEFsbG9jYXRvci5pc0VtcHR5ICYmIHRoaXMuX2luZGV4QWxsb2NhdG9yLmlzRW1wdHk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERlc3Ryb3lzIHRoZSBwYWdlIGFuZCBhbGwgaXRzIHJlc291cmNlcy5cclxuICAgICAqL1xyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLnZlcnRleEJ1ZmZlci5kZXN0cm95KCk7XHJcbiAgICAgICAgdGhpcy5pbmRleEJ1ZmZlci5kZXN0cm95KCk7XHJcbiAgICAgICAgdGhpcy52YW8uZGVzdHJveSgpO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9tZW1vcnkvcGFnZS50c1xuLy8gbW9kdWxlIGlkID0gMTc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBSZWZDb3VudGVkIGZyb20gJy4uLy4uL3V0aWwvcmVmX2NvdW50ZWQnO1xyXG4vKiogSGFuZGxlciB0byBhIGFsbG9jYXRlZCBtZW1vcnkgY2h1bmsuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1lbW9yeUNodW5rIGV4dGVuZHMgUmVmQ291bnRlZCB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgaGFuZGxlciB0byBhIG1lbW9yeSBjaHVuayB3aXRoIGdpdmVuIG9mZnNldHMgYWxsb2NhdGVkIGluXHJcbiAgICAgKiBhIGdpdmVuIG1lbW9yeSBwYWdlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwYWdlIFRoZSBwYWdlIHRoZSBjaHVuayB3YXMgYWxsb2NhdGVkIGluLlxyXG4gICAgICogQHBhcmFtIHZlcnRleE9mZnNldCBUaGUgb2Zmc2V0IG9mIGNodW5rJ3MgdmVydGV4IGRhdGEuXHJcbiAgICAgKiBAcGFyYW0gaW5kZXhPZmZzZXQgVGhlIG9mZnNldCBvZiBjaHVuaydzIGluZGV4IGRhdGEuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHBhZ2UsIGxvY2F0aW9uKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnBhZ2UgPSBwYWdlO1xyXG4gICAgICAgIHRoaXMuX2xvY2F0aW9uID0gbG9jYXRpb247XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgb2Zmc2V0IG9mIHZlcnRleCBkYXRhIG9mIHRoZSBjaHVuayBpbiBieXRlcy5cclxuICAgICAqL1xyXG4gICAgZ2V0IHZlcnRleEJ5dGVPZmZzZXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2F0aW9uLnZlcnRleEJ5dGVPZmZzZXQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgb2Zmc2V0IG9mIGluZGV4IGRhdGEgb2YgdGhlIGNodW5rIGluIGJ5dGVzLlxyXG4gICAgICovXHJcbiAgICBnZXQgaW5kZXhCeXRlT2Zmc2V0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhdGlvbi5pbmRleEJ5dGVPZmZzZXQ7XHJcbiAgICB9XHJcbiAgICBfZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLnBhZ2UuZnJlZSh0aGlzKTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvbWVtb3J5L2NodW5rLnRzXG4vLyBtb2R1bGUgaWQgPSAxNzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICogYXMgdmVjdG9yMiBmcm9tICcuLi9tYXRoL3ZlY3RvcjInO1xyXG5pbXBvcnQgUmVuZGVyU3RhdGUgZnJvbSAnLi9zdGF0ZSc7XHJcbmltcG9ydCBmeGFhRnJhZ21lbnRTaGFkZXIgZnJvbSAnLi9zaGFkZXJzL2Z4YWEuZnJhZyc7XHJcbmltcG9ydCBmeGFhVmVydGV4U2hhZGVyIGZyb20gJy4vc2hhZGVycy9xdWFkLnZlcnQnO1xyXG5pbXBvcnQgZ2V0RHByIGZyb20gJy4uL3V0aWwvaGQnO1xyXG5pbXBvcnQgeyBHbFJlbmRlcmVyIH0gZnJvbSAnLi9nbF9yZW5kZXJlcic7XHJcbmltcG9ydCBMaXN0UmVuZGVyVW5pdCBmcm9tICcuL2xpc3RfcmVuZGVyX3VuaXQnO1xyXG5pbXBvcnQgeyBCTEVORF9PVkVSX1JFTkRFUl9TVEFURSB9IGZyb20gJy4vc3RhdGUnO1xyXG5jb25zdCBTVEFURSA9IG5ldyBSZW5kZXJTdGF0ZShCTEVORF9PVkVSX1JFTkRFUl9TVEFURSk7XHJcbi8qKlxyXG4gKiBSZW5kZXJlciBvZiBGWEFBIHBvc3Rwcm9jZXNzaW5nIHBhc3MuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGeGFhUmVuZGVyVW5pdCBleHRlbmRzIEdsUmVuZGVyZXIge1xyXG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgcmVuZGVyTG9vcCkge1xyXG4gICAgICAgIHN1cGVyKGNvbnRleHQsIFNUQVRFLCBjb250ZXh0LmNyZWF0ZVByb2dyYW0oZnhhYVZlcnRleFNoYWRlciwgZnhhYUZyYWdtZW50U2hhZGVyLCB7XHJcbiAgICAgICAgICAgIGF0dHJpYk1hcDoge1xyXG4gICAgICAgICAgICAgICAgdmVydGV4UG9zaXRpb246IDAgLyogUE9TSVRJT04gKi9cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pKTtcclxuICAgICAgICB0aGlzLl9yZW5kZXJlcnMgPSBuZXcgTGlzdFJlbmRlclVuaXQoKTtcclxuICAgICAgICB0aGlzLl9yZW5kZXJMb29wID0gcmVuZGVyTG9vcDtcclxuICAgICAgICB0aGlzLm9uVXBkYXRlID0gdGhpcy5fcmVuZGVyZXJzLm9uVXBkYXRlO1xyXG4gICAgICAgIHRoaXMuX3BpeGVsU2l6ZSA9IHZlY3RvcjIuY3JlYXRlKDAsIDApO1xyXG4gICAgfVxyXG4gICAgYWRkUmVuZGVyVW5pdCh1bml0KSB7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyZXJzLmFkZFJlbmRlclVuaXQodW5pdCk7XHJcbiAgICB9XHJcbiAgICByZW1vdmVSZW5kZXJVbml0KHVuaXQpIHtcclxuICAgICAgICB0aGlzLl9yZW5kZXJlcnMucmVtb3ZlUmVuZGVyVW5pdCh1bml0KTtcclxuICAgIH1cclxuICAgIHJlbmRlcih0YXJnZXQsIC4uLmFyZ3MpIHtcclxuICAgICAgICAvLyBza2lwIGFudGlhbGlhc2luZyBpZiB0aGVzZSBpcyBhY3Rpb24gaW4gdGhlIHNjZW5lXHJcbiAgICAgICAgaWYgKHRoaXMuX3JlbmRlckxvb3AuaXNBY3RpdmUpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXJzLnJlbmRlcih0YXJnZXQsIC4uLmFyZ3MpO1xyXG4gICAgICAgICAgICAvLyBzY2hlZHVsZSBhdCBsZWFzdCBvbmUgbW9yZSByZW5kZXJpbmcgdG8gbm90IGxlYXZlIHN0YXRpYyAoc3RvcHBlZCkgc2NlbmUgaW4gbm9uLWFudGlhbGlhc2VkIHN0YXRlXHJcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlckxvb3AudXBkYXRlKCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLl9pbnRlcm1lZGlhdGVSZW5kZXJlQnVmZmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2luaXRJbnRlcm1lZGlhdGVSZW5kZXJUYXJnZXRzKHRhcmdldC5nZXRXaWR0aCgpLCB0YXJnZXQuZ2V0SGVpZ2h0KCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLl9pbnRlcm1lZGlhdGVSZW5kZXJlQnVmZmVyLmdldFdpZHRoKCkgIT09IHRhcmdldC5nZXRXaWR0aCgpIHx8XHJcbiAgICAgICAgICAgIHRoaXMuX2ludGVybWVkaWF0ZVJlbmRlcmVCdWZmZXIuZ2V0SGVpZ2h0KCkgIT09IHRhcmdldC5nZXRIZWlnaHQoKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9kZXN0cm95SW50ZXJuYWxSZW5kZXJUYXJnZXRzKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2luaXRJbnRlcm1lZGlhdGVSZW5kZXJUYXJnZXRzKHRhcmdldC5nZXRXaWR0aCgpLCB0YXJnZXQuZ2V0SGVpZ2h0KCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRSZW5kZXJUYXJnZXQodGhpcy5faW50ZXJtZWRpYXRlUmVuZGVyZUJ1ZmZlcik7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5jbGVhckN1cnJlbnRUYXJnZXQoMTc2NjQgLyogQUxMICovKTtcclxuICAgICAgICB0aGlzLl9yZW5kZXJlcnMucmVuZGVyKHRoaXMuX2ludGVybWVkaWF0ZVJlbmRlcmVCdWZmZXIsIC4uLmFyZ3MpO1xyXG4gICAgICAgIC8vIGRvIG5vdCBydW4gYW50aWFsaWFzaW5nIG9uIGVtcHR5IHRoaXMuX2ludGVybWVkaWF0ZVJlbmRlcmVCdWZmZXJcclxuICAgICAgICBpZiAoIXRoaXMuX2ludGVybWVkaWF0ZVJlbmRlcmVCdWZmZXIuaXNDbGVhcikge1xyXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVGcmFtZVVuaWZvcm1TdGF0ZSh0YXJnZXQpO1xyXG4gICAgICAgICAgICBzdXBlci5yZW5kZXIodGFyZ2V0LCAuLi5hcmdzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9pbnRlcm1lZGlhdGVSZW5kZXJlQnVmZmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3lJbnRlcm5hbFJlbmRlclRhcmdldHMoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfcmVuZGVyKCkge1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFF1YWRWYW8oKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmRyYXdRdWFkKCk7XHJcbiAgICB9XHJcbiAgICBfcHJlcGFyZVByb2dyYW0ocHJvZ3JhbSwgLi4uYXJncykge1xyXG4gICAgICAgIHN1cGVyLl9wcmVwYXJlUHJvZ3JhbShwcm9ncmFtLCAuLi5hcmdzKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRUZXh0dXJlVW5pdCgwKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRUZXh0dXJlKHRoaXMuX2ludGVybWVkaWF0ZUNvbG9yQnVmZmVyKTtcclxuICAgICAgICBwcm9ncmFtLnNldEludFNjYWxhclVuaWZvcm0oJ3RleHR1cmUnLCAwKTtcclxuICAgICAgICBwcm9ncmFtLnNldFZlY3RvcjJVbmlmb3JtKCdwaXhlbFNpemUnLCB0aGlzLl9waXhlbFNpemUpO1xyXG4gICAgICAgIHByb2dyYW0uc2V0U2NhbGFyVW5pZm9ybSgnZHByJywgZ2V0RHByKCkpO1xyXG4gICAgfVxyXG4gICAgX3VwZGF0ZUZyYW1lVW5pZm9ybVN0YXRlKHRhcmdldCkge1xyXG4gICAgICAgIHRoaXMuX3BpeGVsU2l6ZS54ID0gMSAvIHRhcmdldC5nZXRXaWR0aCgpO1xyXG4gICAgICAgIHRoaXMuX3BpeGVsU2l6ZS55ID0gMSAvIHRhcmdldC5nZXRIZWlnaHQoKTtcclxuICAgIH1cclxuICAgIF9pbml0SW50ZXJtZWRpYXRlUmVuZGVyVGFyZ2V0cyh3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuX2NvbnRleHQ7XHJcbiAgICAgICAgY29uc3QgaW50ZXJtZWRpYXRlQ29sb3JCdWZmZXIgPSB0aGlzLl9pbnRlcm1lZGlhdGVDb2xvckJ1ZmZlciA9XHJcbiAgICAgICAgICAgIGNvbnRleHQuY3JlYXRlRW1wdHkyRFRleHR1cmUod2lkdGgsIGhlaWdodCwgNjQwOCAvKiBSR0JBICovLCA1MTIxIC8qIFVOU0lHTkVEX0JZVEUgKi8pO1xyXG4gICAgICAgIGNvbnN0IGludGVybWVkaWF0ZURlcHRoU3RlbmNpbEJ1ZmZlciA9IHRoaXMuX2ludGVybWVkaWF0ZURlcHRoU3RlbmNpbEJ1ZmZlciA9XHJcbiAgICAgICAgICAgIGNvbnRleHQuY3JlYXRlUmVuZGVyYnVmZmVyKHdpZHRoLCBoZWlnaHQsIDM0MDQxIC8qIERFUFRIX1NURU5DSUwgKi8pO1xyXG4gICAgICAgIHRoaXMuX2ludGVybWVkaWF0ZVJlbmRlcmVCdWZmZXIgPSBjb250ZXh0LmNyZWF0ZUZyYW1lYnVmZmVyKHtcclxuICAgICAgICAgICAgY29sb3I6IGludGVybWVkaWF0ZUNvbG9yQnVmZmVyLFxyXG4gICAgICAgICAgICBkZXB0aFN0ZW5jaWw6IGludGVybWVkaWF0ZURlcHRoU3RlbmNpbEJ1ZmZlclxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX2Rlc3Ryb3lJbnRlcm5hbFJlbmRlclRhcmdldHMoKSB7XHJcbiAgICAgICAgdGhpcy5faW50ZXJtZWRpYXRlUmVuZGVyZUJ1ZmZlci5kZXN0cm95KCk7XHJcbiAgICAgICAgdGhpcy5faW50ZXJtZWRpYXRlQ29sb3JCdWZmZXIuZGVzdHJveSgpO1xyXG4gICAgICAgIHRoaXMuX2ludGVybWVkaWF0ZURlcHRoU3RlbmNpbEJ1ZmZlci5kZXN0cm95KCk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL2Z4YWFfcmVuZGVyX3VuaXQudHNcbi8vIG1vZHVsZSBpZCA9IDE3N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwiI3ZlcnNpb24gMTAwXFxuXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG51bmlmb3JtIHZlYzIgcGl4ZWxTaXplO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHRleHR1cmU7XFxudW5pZm9ybSBmbG9hdCBkcHI7XFxuXFxuY29uc3QgZmxvYXQgRlhBQV9RVUFMSVRZX1NVQlBJWCA9IDAuNzU7XFxuY29uc3QgZmxvYXQgRlhBQV9RVUFMSVRZX0VER0VfVEhSRVNIT0xEID0gMC4wNjM7XFxuY29uc3QgZmxvYXQgRlhBQV9RVUFMSVRZX0VER0VfVEhSRVNIT0xEX01JTiA9IDAuMDYyNTtcXG5jb25zdCBmbG9hdCBFUFNJTE9OID0gMC4wMDAxO1xcblxcbmZsb2F0IGx1bWEodmVjNCByZ2JhKSB7XFxuICAgIHJldHVybiBkb3QocmdiYS54eXosIHZlYzMoMC4yOTksIDAuNTg3LCAwLjExNCkpO1xcbn1cXG5cXG52ZWM0IGZ4YWEoXFxuICAgIHZlYzIgcG9zLFxcbiAgICBzYW1wbGVyMkQgdGV4LFxcbiAgICB2ZWMyIGZ4YWFRdWFsaXR5UmNwRnJhbWUsXFxuICAgIC8vIFRoaXMgdXNlZCB0byBiZSB0aGUgRlhBQV9RVUFMSVRZX1NVQlBJWCBkZWZpbmUuXFxuICAgIC8vIENob29zZSB0aGUgYW1vdW50IG9mIHN1Yi1waXhlbCBhbGlhc2luZyByZW1vdmFsLlxcbiAgICAvLyBUaGlzIGNhbiBlZmZlY3Qgc2hhcnBuZXNzLlxcbiAgICAvLyAgIDEuMDAgLSB1cHBlciBsaW1pdCAoc29mdGVyKVxcbiAgICAvLyAgIDAuNzUgLSBkZWZhdWx0IGFtb3VudCBvZiBmaWx0ZXJpbmdcXG4gICAgLy8gICAwLjUwIC0gbG93ZXIgbGltaXQgKHNoYXJwZXIsIGxlc3Mgc3ViLXBpeGVsIGFsaWFzaW5nIHJlbW92YWwpXFxuICAgIC8vICAgMC4yNSAtIGFsbW9zdCBvZmZcXG4gICAgLy8gICAwLjAwIC0gY29tcGxldGVseSBvZmZcXG4gICAgZmxvYXQgZnhhYVF1YWxpdHlTdWJwaXgsXFxuICAgIC8vIFRoaXMgdXNlZCB0byBiZSB0aGUgRlhBQV9RVUFMSVRZX0VER0VfVEhSRVNIT0xEIGRlZmluZS5cXG4gICAgLy8gVGhlIG1pbmltdW0gYW1vdW50IG9mIGxvY2FsIGNvbnRyYXN0IHJlcXVpcmVkIHRvIGFwcGx5IGFsZ29yaXRobS5cXG4gICAgLy8gICAwLjMzMyAtIHRvbyBsaXR0bGUgKGZhc3RlcilcXG4gICAgLy8gICAwLjI1MCAtIGxvdyBxdWFsaXR5XFxuICAgIC8vICAgMC4xNjYgLSBkZWZhdWx0XFxuICAgIC8vICAgMC4xMjUgLSBoaWdoIHF1YWxpdHlcXG4gICAgLy8gICAwLjA2MyAtIG92ZXJraWxsIChzbG93ZXIpXFxuICAgIGZsb2F0IGZ4YWFRdWFsaXR5RWRnZVRocmVzaG9sZCxcXG4gICAgLy8gVGhpcyB1c2VkIHRvIGJlIHRoZSBGWEFBX1FVQUxJVFlfRURHRV9USFJFU0hPTERfTUlOIGRlZmluZS5cXG4gICAgLy8gVHJpbXMgdGhlIGFsZ29yaXRobSBmcm9tIHByb2Nlc3NpbmcgZGFya3MuXFxuICAgIC8vICAgMC4wODMzIC0gdXBwZXIgbGltaXQgKGRlZmF1bHQsIHRoZSBzdGFydCBvZiB2aXNpYmxlIHVuZmlsdGVyZWQgZWRnZXMpXFxuICAgIC8vICAgMC4wNjI1IC0gaGlnaCBxdWFsaXR5IChmYXN0ZXIpXFxuICAgIC8vICAgMC4wMzEyIC0gdmlzaWJsZSBsaW1pdCAoc2xvd2VyKVxcbiAgICBmbG9hdCBmeGFhUXVhbGl0eUVkZ2VUaHJlc2hvbGRNaW5cXG4pIHtcXG4gICAgdmVjMiBwb3NNO1xcbiAgICBwb3NNLnggPSBwb3MueDtcXG4gICAgcG9zTS55ID0gcG9zLnk7XFxuICAgIHZlYzQgcmdieU0gPSB0ZXh0dXJlMkQodGV4LCBwb3NNKTtcXG4gICAgZmxvYXQgbHVtYU0gPSBsdW1hKHJnYnlNKTtcXG5cXG4gICAgZmxvYXQgbHVtYVMgPSBsdW1hKHRleHR1cmUyRCh0ZXgsIHBvc00gKyB2ZWMyKCAwLCAxKSAqIGZ4YWFRdWFsaXR5UmNwRnJhbWUueHkpKTtcXG4gICAgZmxvYXQgbHVtYUUgPSBsdW1hKHRleHR1cmUyRCh0ZXgsIHBvc00gKyB2ZWMyKCAxLCAwKSAqIGZ4YWFRdWFsaXR5UmNwRnJhbWUueHkpKTtcXG4gICAgZmxvYXQgbHVtYU4gPSBsdW1hKHRleHR1cmUyRCh0ZXgsIHBvc00gKyB2ZWMyKCAwLC0xKSAqIGZ4YWFRdWFsaXR5UmNwRnJhbWUueHkpKTtcXG4gICAgZmxvYXQgbHVtYVcgPSBsdW1hKHRleHR1cmUyRCh0ZXgsIHBvc00gKyB2ZWMyKC0xLCAwKSAqIGZ4YWFRdWFsaXR5UmNwRnJhbWUueHkpKTtcXG5cXG4gICAgZmxvYXQgbWF4U00gPSBtYXgobHVtYVMsIGx1bWFNKTtcXG4gICAgZmxvYXQgbWluU00gPSBtaW4obHVtYVMsIGx1bWFNKTtcXG4gICAgZmxvYXQgbWF4RVNNID0gbWF4KGx1bWFFLCBtYXhTTSk7XFxuICAgIGZsb2F0IG1pbkVTTSA9IG1pbihsdW1hRSwgbWluU00pO1xcbiAgICBmbG9hdCBtYXhXTiA9IG1heChsdW1hTiwgbHVtYVcpO1xcbiAgICBmbG9hdCBtaW5XTiA9IG1pbihsdW1hTiwgbHVtYVcpO1xcbiAgICBmbG9hdCByYW5nZU1heCA9IG1heChtYXhXTiwgbWF4RVNNKTtcXG4gICAgZmxvYXQgcmFuZ2VNaW4gPSBtaW4obWluV04sIG1pbkVTTSk7XFxuICAgIGZsb2F0IHJhbmdlTWF4U2NhbGVkID0gcmFuZ2VNYXggKiBmeGFhUXVhbGl0eUVkZ2VUaHJlc2hvbGQ7XFxuICAgIGZsb2F0IHJhbmdlID0gcmFuZ2VNYXggLSByYW5nZU1pbjtcXG4gICAgZmxvYXQgcmFuZ2VNYXhDbGFtcGVkID0gbWF4KGZ4YWFRdWFsaXR5RWRnZVRocmVzaG9sZE1pbiwgcmFuZ2VNYXhTY2FsZWQpO1xcbiAgICBib29sIGVhcmx5RXhpdCA9IHJhbmdlIDwgcmFuZ2VNYXhDbGFtcGVkO1xcblxcbiAgICBpZiAoZWFybHlFeGl0KVxcbiAgICAgICAgcmV0dXJuIHJnYnlNO1xcblxcbiAgICBmbG9hdCBsdW1hTlcgPSBsdW1hKHRleHR1cmUyRCh0ZXgsIHBvc00gKyB2ZWMyKC0xLC0xKSAqIGZ4YWFRdWFsaXR5UmNwRnJhbWUueHkpKTtcXG4gICAgZmxvYXQgbHVtYVNFID0gbHVtYSh0ZXh0dXJlMkQodGV4LCBwb3NNICsgdmVjMiggMSwgMSkgKiBmeGFhUXVhbGl0eVJjcEZyYW1lLnh5KSk7XFxuICAgIGZsb2F0IGx1bWFORSA9IGx1bWEodGV4dHVyZTJEKHRleCwgcG9zTSArIHZlYzIoIDEsLTEpICogZnhhYVF1YWxpdHlSY3BGcmFtZS54eSkpO1xcbiAgICBmbG9hdCBsdW1hU1cgPSBsdW1hKHRleHR1cmUyRCh0ZXgsIHBvc00gKyB2ZWMyKC0xLCAxKSAqIGZ4YWFRdWFsaXR5UmNwRnJhbWUueHkpKTtcXG5cXG4gICAgZmxvYXQgbHVtYU5TID0gbHVtYU4gKyBsdW1hUztcXG4gICAgZmxvYXQgbHVtYVdFID0gbHVtYVcgKyBsdW1hRTtcXG4gICAgZmxvYXQgc3VicGl4UmNwUmFuZ2UgPSAxLjAvcmFuZ2U7XFxuICAgIGZsb2F0IHN1YnBpeE5TV0UgPSBsdW1hTlMgKyBsdW1hV0U7XFxuICAgIGZsb2F0IGVkZ2VIb3J6MSA9ICgtMi4wICogbHVtYU0pICsgbHVtYU5TO1xcbiAgICBmbG9hdCBlZGdlVmVydDEgPSAoLTIuMCAqIGx1bWFNKSArIGx1bWFXRTtcXG5cXG4gICAgZmxvYXQgbHVtYU5FU0UgPSBsdW1hTkUgKyBsdW1hU0U7XFxuICAgIGZsb2F0IGx1bWFOV05FID0gbHVtYU5XICsgbHVtYU5FO1xcbiAgICBmbG9hdCBlZGdlSG9yejIgPSAoLTIuMCAqIGx1bWFFKSArIGx1bWFORVNFO1xcbiAgICBmbG9hdCBlZGdlVmVydDIgPSAoLTIuMCAqIGx1bWFOKSArIGx1bWFOV05FO1xcblxcbiAgICBmbG9hdCBsdW1hTldTVyA9IGx1bWFOVyArIGx1bWFTVztcXG4gICAgZmxvYXQgbHVtYVNXU0UgPSBsdW1hU1cgKyBsdW1hU0U7XFxuICAgIGZsb2F0IGVkZ2VIb3J6NCA9IChhYnMoZWRnZUhvcnoxKSAqIDIuMCkgKyBhYnMoZWRnZUhvcnoyKTtcXG4gICAgZmxvYXQgZWRnZVZlcnQ0ID0gKGFicyhlZGdlVmVydDEpICogMi4wKSArIGFicyhlZGdlVmVydDIpO1xcbiAgICBmbG9hdCBlZGdlSG9yejMgPSAoLTIuMCAqIGx1bWFXKSArIGx1bWFOV1NXO1xcbiAgICBmbG9hdCBlZGdlVmVydDMgPSAoLTIuMCAqIGx1bWFTKSArIGx1bWFTV1NFO1xcbiAgICBmbG9hdCBlZGdlSG9yeiA9IGFicyhlZGdlSG9yejMpICsgZWRnZUhvcno0O1xcbiAgICBmbG9hdCBlZGdlVmVydCA9IGFicyhlZGdlVmVydDMpICsgZWRnZVZlcnQ0O1xcblxcbiAgICBmbG9hdCBzdWJwaXhOV1NXTkVTRSA9IGx1bWFOV1NXICsgbHVtYU5FU0U7XFxuICAgIGZsb2F0IGxlbmd0aFNpZ24gPSBmeGFhUXVhbGl0eVJjcEZyYW1lLng7XFxuICAgIGJvb2wgaG9yelNwYW4gPSBlZGdlSG9yeiA+PSBlZGdlVmVydDtcXG4gICAgZmxvYXQgc3VicGl4QSA9IHN1YnBpeE5TV0UgKiAyLjAgKyBzdWJwaXhOV1NXTkVTRTtcXG5cXG4gICAgaWYgKGhvcnpTcGFuKSB7XFxuICAgICAgICBsZW5ndGhTaWduID0gZnhhYVF1YWxpdHlSY3BGcmFtZS55O1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgbHVtYU4gPSBsdW1hVztcXG4gICAgICAgIGx1bWFTID0gbHVtYUU7XFxuICAgIH1cXG4gICAgZmxvYXQgc3VicGl4QiA9IChzdWJwaXhBICogKDEuMC8xMi4wKSkgLSBsdW1hTTtcXG5cXG4gICAgZmxvYXQgZ3JhZGllbnROID0gbHVtYU4gLSBsdW1hTTtcXG4gICAgZmxvYXQgZ3JhZGllbnRTID0gbHVtYVMgLSBsdW1hTTtcXG4gICAgZmxvYXQgbHVtYU5OID0gbHVtYU4gKyBsdW1hTTtcXG4gICAgZmxvYXQgbHVtYVNTID0gbHVtYVMgKyBsdW1hTTtcXG4gICAgYm9vbCBwYWlyTiA9IGFicyhncmFkaWVudE4pID49IGFicyhncmFkaWVudFMpO1xcbiAgICBmbG9hdCBncmFkaWVudCA9IG1heChhYnMoZ3JhZGllbnROKSwgYWJzKGdyYWRpZW50UykpO1xcbiAgICBpZiAocGFpck4pIHtcXG4gICAgICAgIGxlbmd0aFNpZ24gPSAtbGVuZ3RoU2lnbjtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIGx1bWFOTiA9IGx1bWFTUztcXG4gICAgfVxcbiAgICBmbG9hdCBzdWJwaXhDID0gY2xhbXAoYWJzKHN1YnBpeEIpICogc3VicGl4UmNwUmFuZ2UsIDAuMCwgMS4wKTtcXG5cXG4gICAgdmVjMiBwb3NCID0gcG9zTTtcXG4gICAgdmVjMiBvZmZOUDtcXG5cXG4gICAgdmVjMiBvZmZITTtcXG4gICAgaWYgKGhvcnpTcGFuKSB7XFxuICAgICAgICBvZmZOUCA9IHZlYzIoZnhhYVF1YWxpdHlSY3BGcmFtZS54LCAwLjApO1xcbiAgICAgICAgb2ZmSE0gPSB2ZWMyKDAuMCwgbGVuZ3RoU2lnbik7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICBvZmZOUCA9IHZlYzIoMC4wLCBmeGFhUXVhbGl0eVJjcEZyYW1lLnkpO1xcbiAgICAgICAgb2ZmSE0gPSB2ZWMyKGxlbmd0aFNpZ24sIDAuMCk7XFxuICAgIH1cXG5cXG4gICAgdmVjMiBwb3NOID0gcG9zQiAtIG9mZk5QICogMi47XFxuICAgIHZlYzIgcG9zUCA9IHBvc0IgKyBvZmZOUCAqIDIuO1xcblxcbiAgICBmbG9hdCBzdWJwaXhEID0gKCgtMi4wKSpzdWJwaXhDKSArIDMuMDtcXG4gICAgZmxvYXQgbHVtYUVuZE4gPSBsdW1hKFxcbiAgICAgICAgbWl4KFxcbiAgICAgICAgICAgIHRleHR1cmUyRCh0ZXgsIHBvc04pLFxcbiAgICAgICAgICAgIHRleHR1cmUyRCh0ZXgsIHBvc04gKyBvZmZITSksXFxuICAgICAgICAgICAgMC41XFxuICAgICAgICApXFxuICAgICk7XFxuICAgIGZsb2F0IHN1YnBpeEUgPSBzdWJwaXhDICogc3VicGl4QztcXG4gICAgZmxvYXQgbHVtYUVuZFAgPSBsdW1hKFxcbiAgICAgICAgbWl4KFxcbiAgICAgICAgICAgIHRleHR1cmUyRCh0ZXgsIHBvc1ApLFxcbiAgICAgICAgICAgIHRleHR1cmUyRCh0ZXgsIHBvc1AgKyBvZmZITSksXFxuICAgICAgICAgICAgMC41XFxuICAgICAgICApXFxuICAgICk7XFxuXFxuICAgIGZsb2F0IGdyYWRpZW50U2NhbGVkID0gZ3JhZGllbnQgKiAwLjI1O1xcbiAgICBmbG9hdCBsdW1hTU0gPSBsdW1hTSAtIGx1bWFOTiAqIDAuNTtcXG4gICAgZmxvYXQgc3VicGl4RiA9IHN1YnBpeEQgKiBzdWJwaXhFO1xcbiAgICBib29sIGx1bWFNTFRaZXJvID0gbHVtYU1NIDwgMC4wO1xcblxcbiAgICBsdW1hRW5kTiAtPSBsdW1hTk4gKiAwLjU7XFxuICAgIGx1bWFFbmRQIC09IGx1bWFOTiAqIDAuNTtcXG4gICAgYm9vbCBkb25lTiA9IGFicyhsdW1hRW5kTikgPj0gZ3JhZGllbnRTY2FsZWQ7XFxuICAgIGJvb2wgZG9uZVAgPSBhYnMobHVtYUVuZFApID49IGdyYWRpZW50U2NhbGVkO1xcbiAgICBpZiAoIWRvbmVOKSB7XFxuICAgICAgICBwb3NOIC09IG9mZk5QICogMy4wO1xcbiAgICB9XFxuICAgIGJvb2wgZG9uZU5QID0gKCFkb25lTikgfHwgKCFkb25lUCk7XFxuICAgIGlmICghZG9uZVApIHtcXG4gICAgICAgIHBvc1AgKz0gb2ZmTlAgKiAzLjA7XFxuICAgIH1cXG5cXG4gICAgaWYgKGRvbmVOUCkge1xcbiAgICAgICAgaWYgKCFkb25lTikge1xcbiAgICAgICAgICAgIGx1bWFFbmROID0gbHVtYShcXG4gICAgICAgICAgICAgICAgbWl4KFxcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZTJEKHRleCwgcG9zTiksXFxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlMkQodGV4LCBwb3NOICsgb2ZmSE0pLFxcbiAgICAgICAgICAgICAgICAgICAgMC41XFxuICAgICAgICAgICAgICAgIClcXG4gICAgICAgICAgICApO1xcbiAgICAgICAgICAgIGx1bWFFbmROID0gbHVtYUVuZE4gLSBsdW1hTk4gKiAwLjU7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoIWRvbmVQKSB7XFxuICAgICAgICAgICAgbHVtYUVuZFAgPSBsdW1hKFxcbiAgICAgICAgICAgICAgICBtaXgoXFxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlMkQodGV4LCBwb3NQLnh5KSxcXG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmUyRCh0ZXgsIHBvc1AueHkgKyBvZmZITSksXFxuICAgICAgICAgICAgICAgICAgICAwLjVcXG4gICAgICAgICAgICAgICAgKVxcbiAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgbHVtYUVuZFAgPSBsdW1hRW5kUCAtIGx1bWFOTiAqIDAuNTtcXG4gICAgICAgIH1cXG4gICAgICAgIGRvbmVOID0gYWJzKGx1bWFFbmROKSA+PSBncmFkaWVudFNjYWxlZDtcXG4gICAgICAgIGRvbmVQID0gYWJzKGx1bWFFbmRQKSA+PSBncmFkaWVudFNjYWxlZDtcXG4gICAgICAgIGlmICghZG9uZU4pIHtcXG4gICAgICAgICAgICBwb3NOIC09IG9mZk5QICogMTIuMDtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICghZG9uZVApIHtcXG4gICAgICAgICAgICBwb3NQICs9IG9mZk5QICogMTIuMDtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICBmbG9hdCBkc3ROID0gcG9zTS54IC0gcG9zTi54O1xcbiAgICBmbG9hdCBkc3RQID0gcG9zUC54IC0gcG9zTS54O1xcbiAgICBpZiAoIWhvcnpTcGFuKSB7XFxuICAgICAgICBkc3ROID0gcG9zTS55IC0gcG9zTi55O1xcbiAgICAgICAgZHN0UCA9IHBvc1AueSAtIHBvc00ueTtcXG4gICAgfVxcbiAgICBib29sIGdvb2RTcGFuTiA9IChsdW1hRW5kTiA8IDAuMCkgIT0gbHVtYU1MVFplcm87XFxuICAgIGZsb2F0IHNwYW5MZW5ndGggPSAoZHN0UCArIGRzdE4pO1xcbiAgICBib29sIGdvb2RTcGFuUCA9IChsdW1hRW5kUCA8IDAuMCkgIT0gbHVtYU1MVFplcm87XFxuICAgIGZsb2F0IHNwYW5MZW5ndGhSY3AgPSAxLjAvc3Bhbkxlbmd0aDtcXG4gICAgYm9vbCBkaXJlY3Rpb25OID0gZHN0TiA8IGRzdFA7XFxuICAgIGZsb2F0IGRzdCA9IG1pbihkc3ROLCBkc3RQKTtcXG4gICAgYm9vbCBnb29kU3BhbiA9IGRpcmVjdGlvbk4gPyBnb29kU3Bhbk4gOiBnb29kU3BhblA7XFxuICAgIGZsb2F0IHN1YnBpeEcgPSBzdWJwaXhGICogc3VicGl4RjtcXG4gICAgZmxvYXQgcGl4ZWxPZmZzZXQgPSAoZHN0ICogKC1zcGFuTGVuZ3RoUmNwKSkgKyAwLjU7XFxuICAgIGZsb2F0IHN1YnBpeEggPSBzdWJwaXhHICogZnhhYVF1YWxpdHlTdWJwaXg7XFxuICAgIGZsb2F0IHBpeGVsT2Zmc2V0R29vZCA9IGdvb2RTcGFuID8gcGl4ZWxPZmZzZXQgOiAwLjA7XFxuICAgIGZsb2F0IHBpeGVsT2Zmc2V0U3VicGl4ID0gbWF4KHBpeGVsT2Zmc2V0R29vZCwgc3VicGl4SCk7XFxuICAgIHZlYzQgY29sb3I7XFxuICAgIGZsb2F0IGZhY3RvciA9IHBpeGVsT2Zmc2V0U3VicGl4O1xcbiAgICBpZiAoaG9yelNwYW4pIHtcXG4gICAgICAgIGNvbG9yID0gbWl4KFxcbiAgICAgICAgICAgIHRleHR1cmUyRCh0ZXgsIHBvc00pLFxcbiAgICAgICAgICAgIHRleHR1cmUyRCh0ZXgsIHBvc00gKyB2ZWMyKDAuMCwgbGVuZ3RoU2lnbikpLFxcbiAgICAgICAgICAgIGZhY3RvclxcbiAgICAgICAgKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIGNvbG9yID0gbWl4KFxcbiAgICAgICAgICAgIHRleHR1cmUyRCh0ZXgsIHBvc00pLFxcbiAgICAgICAgICAgIHRleHR1cmUyRCh0ZXgsIHBvc00gKyB2ZWMyKGxlbmd0aFNpZ24sIDAuMCkpLFxcbiAgICAgICAgICAgIGZhY3RvclxcbiAgICAgICAgKTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gY29sb3I7XFxufVxcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgdmVjMiBwb3MgPSBnbF9GcmFnQ29vcmQueHkgKiBwaXhlbFNpemU7XFxuICAgIHZlYzQgY29sb3IgPSBmeGFhKFxcbiAgICAgICAgcG9zLFxcbiAgICAgICAgdGV4dHVyZSxcXG4gICAgICAgIHBpeGVsU2l6ZSxcXG4gICAgICAgIEZYQUFfUVVBTElUWV9TVUJQSVgsXFxuICAgICAgICBGWEFBX1FVQUxJVFlfRURHRV9USFJFU0hPTEQsXFxuICAgICAgICBGWEFBX1FVQUxJVFlfRURHRV9USFJFU0hPTERfTUlOXFxuICAgICk7XFxuXFxuICAgIC8vIElmIGNvbG9yLmEgaXMgbGVzcyB0aGFuIG9uZSwgdGhlbiB0aGUgY29sb3IgaGFzIGJlZW4gYmxlbmRlZCB3aXRoIGEgYmxhY2sgYmFja2dyb3VuZCBiZWZvcmUuXFxuICAgIC8vIEFuIG9yaWdpbmFsIGNvbG9yIG9mIHRyYW5zcGFyZW50IG9iamVjdHMgaXMgdmVjNChjb2xvci54eXogLyBjb2xvci5hLCBjb2xvci5hKS5cXG4gICAgLy8gV2UgaGF2ZSB0byBibGVuZCBhbiBvcmlnaW5hbCBjb2xvciB3aXRoIGJhY2tncm91bmQgcGF0dGVybi5cXG4gICAgLy8gY29sb3IuYSBjYW4gYmUgdG9vIGNsb3NlIHRvIHplcm8uIENoZWNrIGl0LlxcbiAgICBpZiAoY29sb3IuYSA+IEVQU0lMT04pIHtcXG4gICAgICAgIGNvbG9yLnh5eiAvPSBjb2xvci5hO1xcbiAgICB9XFxuICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbn1cXG5cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9zaGFkZXJzL2Z4YWEuZnJhZ1xuLy8gbW9kdWxlIGlkID0gMTc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IEdsUmVuZGVyZXIgfSBmcm9tICcuL2dsX3JlbmRlcmVyJztcclxuaW1wb3J0IFJlbmRlclN0YXRlIGZyb20gJy4vc3RhdGUnO1xyXG5pbXBvcnQgeyBWb2lkRXZlbnRFbWl0dGVyIH0gZnJvbSAnLi8uLi91dGlsL2V2ZW50X2VtaXR0ZXInO1xyXG5pbXBvcnQgcXVhZFZlcnRleFNoYWRlciBmcm9tICcuL3NoYWRlcnMvcXVhZC52ZXJ0JztcclxuaW1wb3J0IGJhY2tncm91bmRGcmFnbWVudFNoYWRlciBmcm9tICcuL3NoYWRlcnMvYmFja2dyb3VuZC5mcmFnJztcclxuaW1wb3J0IGdldERwciBmcm9tICcuLi91dGlsL2hkJztcclxuY29uc3QgU1RBVEUgPSBuZXcgUmVuZGVyU3RhdGUoe1xyXG4gICAgZGVwdGhUZXN0OiB0cnVlLFxyXG4gICAgZGVwdGhGdW5jOiA1MTggLyogR1JFQVRFUl9PUl9FUVVBTCAqL1xyXG59KTtcclxuLyoqXHJcbiAqIEZpbGxzIG1hcCdzIGNhbnZhcyB3aXRoIGJhY2tncm91bmQgcGF0dGVybiBvbiByZWdpb25zIHRoYXQgaGF2ZSBubyBkYXRhIHlldC5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhY2tncm91bmRSZW5kZXJVbml0IGV4dGVuZHMgR2xSZW5kZXJlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XHJcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IGNvbnRleHQuY3JlYXRlUHJvZ3JhbShxdWFkVmVydGV4U2hhZGVyLCBiYWNrZ3JvdW5kRnJhZ21lbnRTaGFkZXIsIHtcclxuICAgICAgICAgICAgYXR0cmliTWFwOiB7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhQb3NpdGlvbjogMCAvKiBQT1NJVElPTiAqLyxcclxuICAgICAgICAgICAgICAgIHZlcnRleFV2OiA0IC8qIFVWICovXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBzdXBlcihjb250ZXh0LCBTVEFURSwgcHJvZ3JhbSk7XHJcbiAgICAgICAgY29udGV4dC5iaW5kUHJvZ3JhbShwcm9ncmFtKTtcclxuICAgICAgICBwcm9ncmFtLnNldFNjYWxhclVuaWZvcm0oJ3pJbmRleCcsIC0xKTtcclxuICAgICAgICB0aGlzLm9uVXBkYXRlID0gbmV3IFZvaWRFdmVudEVtaXR0ZXIoKTtcclxuICAgIH1cclxuICAgIF9yZW5kZXIoKSB7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kUXVhZFZhbygpO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHQuZHJhd1F1YWQoKTtcclxuICAgIH1cclxuICAgIF9wcmVwYXJlUHJvZ3JhbShwcm9ncmFtKSB7XHJcbiAgICAgICAgc3VwZXIuX3ByZXBhcmVQcm9ncmFtKHByb2dyYW0pO1xyXG4gICAgICAgIHByb2dyYW0uc2V0U2NhbGFyVW5pZm9ybSgnZHByJywgZ2V0RHByKCkpO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9iYWNrZ3JvdW5kX3JlbmRlcl91bml0LnRzXG4vLyBtb2R1bGUgaWQgPSAxNzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcIiN2ZXJzaW9uIDEwMFxcbiNkZWZpbmUgR0xTTElGWSAxXFxuXFxudm9pZCBtYWluKCkge1xcbiAgICAvLyBCYWNrZ3JvdW5kIGNvbG9yIHNob3VsZCBtYXRjaCBtYWluIG1hcCBsYXllciBjb2xvci5cXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjk4LCAwLjk3LCAwLjk0LCAxKTtcXG59XFxuXCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvc2hhZGVycy9iYWNrZ3JvdW5kLmZyYWdcbi8vIG1vZHVsZSBpZCA9IDE4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgTGlzdFJlbmRlclVuaXQgZnJvbSAnLi9saXN0X3JlbmRlcl91bml0JztcclxuaW1wb3J0IFJlbmRlclN0YXRlIGZyb20gJy4vc3RhdGUnO1xyXG5jb25zdCBERVBUSF9DTEVBUl9TVEFURSA9IG5ldyBSZW5kZXJTdGF0ZSh7XHJcbiAgICBkZXB0aFRlc3Q6IHRydWUsXHJcbiAgICBjbGVhckRlcHRoOiAwXHJcbn0pO1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMYXllclJlbmRlclVuaXQgZXh0ZW5kcyBMaXN0UmVuZGVyVW5pdCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBkZXB0aENsZWFyU3RyYXRlZ3kgPSAwIC8qIE5PX0NMRUFSICovKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl9kZXB0aENsZWFyU3RyYXRlZ3kgPSBkZXB0aENsZWFyU3RyYXRlZ3k7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XHJcbiAgICB9XHJcbiAgICByZW5kZXIodGFyZ2V0LCAuLi5hcmdzKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2RlcHRoQ2xlYXJTdHJhdGVneSA9PT0gMSAvKiBCRUZPUkVfUkVOREVSICovKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuYmluZFJlbmRlclN0YXRlKERFUFRIX0NMRUFSX1NUQVRFKTtcclxuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kUmVuZGVyVGFyZ2V0KHRhcmdldCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuY2xlYXJDdXJyZW50VGFyZ2V0KDI1NiAvKiBERVBUSF9CVUZGRVJfQklUICovKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3VwZXIucmVuZGVyKHRhcmdldCwgLi4uYXJncyk7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcmVuZGVyL2xheWVyX3JlbmRlcl91bml0LnRzXG4vLyBtb2R1bGUgaWQgPSAxODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IFJlbmRlclN0YXRlIGZyb20gJy4uLy4uL3JlbmRlci9zdGF0ZSc7XHJcbmltcG9ydCB7IGNvdW50SW5kaWNlcyB9IGZyb20gJy4uLy4uL3JlbmRlci9tZW1vcnkvY291bnRfdmVydGljZXMnO1xyXG5pbXBvcnQgcmVzZXRSZW1vdmVkVmVydGV4U2hhZGVyIGZyb20gJy4vc2hhZGVycy9yZXNldF9yZW1vdmVkLnZlcnQnO1xyXG5pbXBvcnQgcmVzZXRSZW1vdmVkRnJhZ21lbnRTaGFkZXIgZnJvbSAnLi9zaGFkZXJzL3Jlc2V0X3JlbW92ZWQuZnJhZyc7XHJcbmltcG9ydCB7IEdsUmVuZGVyZXIgfSBmcm9tICcuLi8uLi9yZW5kZXIvZ2xfcmVuZGVyZXInO1xyXG5pbXBvcnQgeyBiYXRjaFByaW1pdGl2ZXMgfSBmcm9tICcuLi8uLi9yZW5kZXIvcHJpbWl0aXZlcy9wcmltaXRpdmVfYmF0Y2gnO1xyXG5leHBvcnQgY2xhc3MgQ29sbGlkaW5nUHJpbWl0aXZlc1Jlc2V0UmVtb3ZlZFJlbmRlcmVyIGV4dGVuZHMgR2xSZW5kZXJlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBwcmltaXRpdmVQcm92aWRlcikge1xyXG4gICAgICAgIGNvbnN0IHByb2dyYW0gPSBjb250ZXh0LmNyZWF0ZVByb2dyYW0ocmVzZXRSZW1vdmVkVmVydGV4U2hhZGVyLCByZXNldFJlbW92ZWRGcmFnbWVudFNoYWRlciwge1xyXG4gICAgICAgICAgICBhdHRyaWJNYXA6IHtcclxuICAgICAgICAgICAgICAgIHZlcnRleFBvc0hpZ2g6IDAgLyogUE9TSVRJT05fSElHSCAqLyxcclxuICAgICAgICAgICAgICAgIHZlcnRleElkOiAyIC8qIElEICovXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBzdXBlcihjb250ZXh0LCBuZXcgUmVuZGVyU3RhdGUoKSwgcHJvZ3JhbSk7XHJcbiAgICAgICAgdGhpcy5fcHJpbWl0aXZlUHJvdmlkZXIgPSBwcmltaXRpdmVQcm92aWRlcjtcclxuICAgICAgICBjb250ZXh0LmJpbmRQcm9ncmFtKHByb2dyYW0pO1xyXG4gICAgICAgIHByb2dyYW0uc2V0SW50U2NhbGFyVW5pZm9ybSgncHJldlZpc2liaWxpdHknLCAwKTtcclxuICAgIH1cclxuICAgIF9yZW5kZXIoKSB7XHJcbiAgICAgICAgY29uc3QgcHJpbWl0aXZlcyA9IHRoaXMuX3ByaW1pdGl2ZVByb3ZpZGVyLnByaW1pdGl2ZXM7XHJcbiAgICAgICAgZm9yIChjb25zdCBtZW1vcnlCYXRjaCBvZiBiYXRjaFByaW1pdGl2ZXMocHJpbWl0aXZlcykpIHtcclxuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5iaW5kVmFvKG1lbW9yeUJhdGNoLnBhZ2UudmFvKTtcclxuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5kcmF3SW5kZXhlZE1lc2gobWVtb3J5QmF0Y2guaW5kZXhCeXRlT2Zmc2V0LCBjb3VudEluZGljZXMobWVtb3J5QmF0Y2guaW5kZXhCeXRlTGVuZ3RoLCBtZW1vcnlCYXRjaC5wYWdlLmluZGV4VHlwZSksIDAgLyogUE9JTlRTICovKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfcHJlcGFyZVByb2dyYW0ocHJvZ3JhbSwgcHJldlZpc2liaWxpdHksIGlkSGFsZlB4U2l6ZSkge1xyXG4gICAgICAgIHN1cGVyLl9wcmVwYXJlUHJvZ3JhbShwcm9ncmFtLCBwcmV2VmlzaWJpbGl0eSwgaWRIYWxmUHhTaXplKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRUZXh0dXJlVW5pdCgwKTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0LmJpbmRUZXh0dXJlKHByZXZWaXNpYmlsaXR5KTtcclxuICAgICAgICBwcm9ncmFtLnNldFZlY3RvcjJVbmlmb3JtKCdpZEhhbGZQeFNpemUnLCBpZEhhbGZQeFNpemUpO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3Zpc2liaWxpdHkvcHJpbWl0aXZlcy9jb2xsaWRpbmdfcHJpbWl0aXZlX3Jlc2V0X3JlbW92ZWRfcmVuZGVyZXIudHNcbi8vIG1vZHVsZSBpZCA9IDE4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IFwiI3ZlcnNpb24gMTAwXFxuI2RlZmluZSBHTFNMSUZZIDFcXG5cXG5hdHRyaWJ1dGUgdmVjMiB2ZXJ0ZXhQb3NIaWdoO1xcbmF0dHJpYnV0ZSB2ZWMyIHZlcnRleElkO1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHByZXZWaXNpYmlsaXR5O1xcbnVuaWZvcm0gdmVjMiBpZEhhbGZQeFNpemU7XFxuXFxudmFyeWluZyBsb3dwIHZlYzQgdmlzaWJpbGl0eVZhbHVlO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gICAgdmVjMiBpZFRleENvb3JkaW5hdGVzID0gdmVydGV4SWQgKyBpZEhhbGZQeFNpemU7XFxuICAgIHZlYzQgaWRXaW5kb3dDb29yZGluYXRlcyA9IHZlYzQoaWRUZXhDb29yZGluYXRlcyAqIDIuMCAtIDEuMCwgMCwgMSk7XFxuICAgIGdsX1Bvc2l0aW9uID0gaWRXaW5kb3dDb29yZGluYXRlcztcXG4gICAgZ2xfUG9pbnRTaXplID0gMS4wICsgdmVydGV4UG9zSGlnaC54ICogMC4wO1xcblxcbiAgICB2aXNpYmlsaXR5VmFsdWUgPSB0ZXh0dXJlMkQocHJldlZpc2liaWxpdHksIGlkVGV4Q29vcmRpbmF0ZXMpO1xcbn1cXG5cIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3Zpc2liaWxpdHkvcHJpbWl0aXZlcy9zaGFkZXJzL3Jlc2V0X3JlbW92ZWQudmVydFxuLy8gbW9kdWxlIGlkID0gMTgzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gXCIjdmVyc2lvbiAxMDBcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcbnZhcnlpbmcgbG93cCB2ZWM0IHZpc2liaWxpdHlWYWx1ZTtcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIGdsX0ZyYWdDb2xvciA9IHZpc2liaWxpdHlWYWx1ZTtcXG59XFxuXCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS92aXNpYmlsaXR5L3ByaW1pdGl2ZXMvc2hhZGVycy9yZXNldF9yZW1vdmVkLmZyYWdcbi8vIG1vZHVsZSBpZCA9IDE4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBFdmVudEVtaXR0ZXIsIFZvaWRFdmVudEVtaXR0ZXIgfSBmcm9tICcuL3V0aWwvZXZlbnRfZW1pdHRlcic7XHJcbmNvbnN0IE1BWF9GUkFNRV9USU1FX0NPVU5UID0gMTAwO1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZW5kZXJMb29wIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgbmV3IHJlbmRlciBsb29wLCBidXQgZG9lc24ndCBzY2hlZHVsZSBhbnkgYW5pbWF0aW9uIGZyYW1lcy5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5vbkZyYW1lVGltZXNGdWxsID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMub25CZWZvcmVSZW5kZXIgPSBuZXcgVm9pZEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMub25SZW5kZXIgPSBuZXcgVm9pZEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMuX2lzUnVubmluZyA9IHRoaXMuX3VwZGF0ZUlzUmVxdWVzdGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fbGFzdEZyYW1lVGltZSA9IDA7XHJcbiAgICAgICAgdGhpcy5fZnJhbWVUaW1lcyA9IG5ldyBBcnJheShNQVhfRlJBTUVfVElNRV9DT1VOVCk7XHJcbiAgICAgICAgdGhpcy5fZnJhbWVUaW1lcy5maWxsKDApO1xyXG4gICAgICAgIHRoaXMuX25leHRGcmFtZVRpbWVJZHggPSAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBsb29wIGlzIHJ1bm5pbmcgYSBjaGFpbiBvZiBjb25zZWN1dGl2ZSBhbmltYXRpb25cclxuICAgICAqICAgICAgZnJhbWVzIG9yIG5vdC5cclxuICAgICAqL1xyXG4gICAgZ2V0IGlzQWN0aXZlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pc1J1bm5pbmc7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN0YXJ0cyBhIGNoYWluIG9mIGNvbnNlY3V0aXZlIGFuaW1hdGlvbiBmcmFtZXMuXHJcbiAgICAgKi9cclxuICAgIHN0YXJ0KCkge1xyXG4gICAgICAgIHRoaXMuX2lzUnVubmluZyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fcmVxdWVzdEZyYW1lKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN0b3BzIHByZXZpb3VzbHkgc3RhcnRlZCBjaGFpbiBvZiBjb25zZWN1dGl2ZSBhbmltYXRpb24gZnJhbWVzLiBJZiBhblxyXG4gICAgICogdXBkYXRlIHdhcyByZXF1ZXN0ZWQgYmVmb3JlIHN0b3BwaW5nLCBvbmUgbW9yZSBhbmltYXRpb24gZnJhbWUgd2lsbCBiZVxyXG4gICAgICogZmlyZWQuXHJcbiAgICAgKi9cclxuICAgIHN0b3AoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2lzUnVubmluZykge1xyXG4gICAgICAgICAgICB0aGlzLl9pc1J1bm5pbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl91cGRhdGVJc1JlcXVlc3RlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FuY2VsRnJhbWUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2NoZWR1bGVzIGEgc2luZ2xlXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZSgpIHtcclxuICAgICAgICB0aGlzLl91cGRhdGVJc1JlcXVlc3RlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fcmVxdWVzdEZyYW1lKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN0b3BzIGFsbCB0aGUgcmVuZGVyaW5nIGFjdGl2aXRpZXMuXHJcbiAgICAgKi9cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5fY2FuY2VsRnJhbWUoKTtcclxuICAgIH1cclxuICAgIF9yZW5kZXJGcmFtZSh0aW1lKSB7XHJcbiAgICAgICAgdGhpcy5fcmFmSWQgPSAwO1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZUlzUmVxdWVzdGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5vbkJlZm9yZVJlbmRlci5maXJlKCk7XHJcbiAgICAgICAgdGhpcy5vblJlbmRlci5maXJlKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuX2xhc3RGcmFtZVRpbWUgPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5leHRGcmFtZVRpbWVJZHggPSB0aGlzLl9uZXh0RnJhbWVUaW1lSWR4O1xyXG4gICAgICAgICAgICB0aGlzLl9mcmFtZVRpbWVzW25leHRGcmFtZVRpbWVJZHhdID0gdGltZSAtIHRoaXMuX2xhc3RGcmFtZVRpbWU7XHJcbiAgICAgICAgICAgIHRoaXMuX25leHRGcmFtZVRpbWVJZHggPSAobmV4dEZyYW1lVGltZUlkeCArIDEpICUgTUFYX0ZSQU1FX1RJTUVfQ09VTlQ7XHJcbiAgICAgICAgICAgIC8vIE5leHQgdGltZSBpbmRleCBiZWluZyAwIG1lYW5zIHRoYXQgdGhlIGFycmF5IGlzIGZ1bGwgYW5kIGl0J3NcclxuICAgICAgICAgICAgLy8gdGltZSB0byBub3RpZnkgbGlzdGVuZXJzIGFib3V0IHRoYXQgYmVmb3JlIHdlIHN0YXJ0IHRvIHJld3JpdGVcclxuICAgICAgICAgICAgLy8gdmFsdWVzLlxyXG4gICAgICAgICAgICBpZiAodGhpcy5fbmV4dEZyYW1lVGltZUlkeCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbkZyYW1lVGltZXNGdWxsLmZpcmUodGhpcy5fZnJhbWVUaW1lcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX2lzUnVubmluZykge1xyXG4gICAgICAgICAgICB0aGlzLl9sYXN0RnJhbWVUaW1lID0gdGltZTtcclxuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdEZyYW1lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBJZiB3ZSBkb24ndCBzY2hlZHVsZSBuZXh0IGZyYW1lIGltbWVkaWF0ZWx5IHRoZXJlJ3Mgbm8gd2F5IHRvXHJcbiAgICAgICAgICAgIC8vIHRlbGwgdGhhdCBpdCB3aWxsIGJlIGNvbnNlY3V0aXZlIHRvIHRoZSBjdXJyZW50IG9uZS4gSGVuY2UgdGhlcmUnc1xyXG4gICAgICAgICAgICAvLyBubyBwb2ludCBpbiByZWNvcmRpbmcgYSB0aW1lIGRlbHRhIGluIGl0LlxyXG4gICAgICAgICAgICB0aGlzLl9sYXN0RnJhbWVUaW1lID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfcmVxdWVzdEZyYW1lKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fcmFmSWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmFmSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCh0aW1lKSA9PiB0aGlzLl9yZW5kZXJGcmFtZSh0aW1lKSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9jYW5jZWxGcmFtZSgpIHtcclxuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLl9yYWZJZCk7XHJcbiAgICAgICAgdGhpcy5fcmFmSWQgPSAwO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlcl9sb29wLnRzXG4vLyBtb2R1bGUgaWQgPSAxODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==
;console.warn(`Hash: aac753a8755363264870
Version: webpack 3.8.1
Time: 131ms
      Asset     Size  Chunks         Chunk Names
index.ts.js  1.45 MB       0  [big]  index
  [10] ./src/vector_render_engine/util/hd.ts 343 bytes {0}
  [22] ./src/vector_render_engine/render/primitives/polygon/polygon_render_unit.ts 1.01 kB {0}
  [45] ./src/vector_render_engine/render/primitives/label/point_label_render_unit.ts 2.16 kB {0}
  [48] ./src/vector_render_engine/render/primitives/label/curved_label_render_unit.ts 1.25 kB {0}
  [53] ./tools/stand/index.ts 7.34 kB {0}
  [54] ./src/vector_render_engine/render/context.ts 32.6 kB {0}
  [63] ./src/vector_render_engine/camera.ts 11.6 kB {0}
  [67] ./src/vector_render_engine/adapters/vector_api/adapter.ts 33.1 kB {0} [1 error]
 [133] ./src/vector_render_engine/render/primitives/polyline/textured_polyline_render_unit.ts 2.29 kB {0}
 [136] ./src/vector_render_engine/render/primitives/polyline/polyline_render_unit.ts 1.82 kB {0}
 [140] ./src/vector_render_engine/render/primitives/polygon/textured_polygon_render_unit.ts 1.97 kB {0}
 [143] ./src/vector_render_engine/render/primitives/polygon/transparent_polygon_render_unit.ts 577 bytes {0}
 [146] ./src/vector_render_engine/map_engine.ts 2.6 kB {0}
 [182] ./src/vector_render_engine/visibility/primitives/colliding_primitive_reset_removed_renderer.ts 1.66 kB {0}
 [185] ./src/vector_render_engine/render_loop.ts 3.06 kB {0}
    + 171 hidden modules

ERROR in ./src/vector_render_engine/adapters/vector_api/adapter.ts
[90m[tsl] [39m[1m[31mERROR[39m[22m[1m[31m in [39m[22m[1m[36mC:\Users\allergic\workspace\jsapi-v3\src\vector_render_engine\adapters\vector_api\adapter.ts(272,13)[39m[22m
[1m[31m      TS2322: Type '{ priority: number; isVisible: boolean; zoomMin: number; zoomMax: number; zoom: number; x: number; y: number; }' is not assignable to type 'VMapTileRequest'.[39m[22m
[1m[31m  Object literal may only specify known properties, and 'isVisible' does not exist in type 'VMapTileRequest'.[39m[22m`);