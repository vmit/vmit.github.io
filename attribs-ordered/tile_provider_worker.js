/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_worker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _tile_provider_worker_messages__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4);
/* harmony import */ var _font_df_font_registry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6);
/* harmony import */ var _font_df_glyph_atlas_allocator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(10);
/* harmony import */ var _util_http__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(12);
/* harmony import */ var _glyph_delivery_manager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(13);
/* harmony import */ var _tile_based_adapter_tile_id__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(37);
/* harmony import */ var _util_color__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(38);
/* harmony import */ var _parser_extract_points__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(39);
/* harmony import */ var _proto_aliases__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(14);
/* harmony import */ var _parser_extract_polylines__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(46);
/* harmony import */ var _primitive_polygon_polygon_buffer_writer__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(48);
/* harmony import */ var _primitive_polygon_textured_polygon_buffer_writer__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(60);
/* harmony import */ var _primitive_polyline_polyline_buffer_writer__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(62);
/* harmony import */ var _parser_extract_polygons__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(64);
/* harmony import */ var _util_extruded_polygon_buffer_writer__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(65);
/* harmony import */ var _math_vector2__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(43);
/* harmony import */ var _parser_extract_curved_labels__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(67);
/* harmony import */ var _parser_extract_point_labels__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(69);
/* harmony import */ var _primitive_label_layout_point_label__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(70);
/* harmony import */ var _primitive_billboard_rectangle_buffer_writer__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(71);
/* harmony import */ var _primitive_label_point_label_buffer_writer__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(73);
/* harmony import */ var _primitive_label_curved_label_buffer_writer__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(75);
/* harmony import */ var _util_iterable__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(57);
/* harmony import */ var _util_label__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(79);
/* harmony import */ var _util_trimesh_polygon_buffer_writer__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(80);
/* harmony import */ var _render_memory_relative_location__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(89);
/* harmony import */ var _util_task_queue__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(90);
/* harmony import */ var _util_array__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(51);
/* harmony import */ var _id_manager__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(78);
/* harmony import */ var _util_hosts__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(36);
































const BACKGROUND_RADIUS_PX = 2;
function filterOutUnstyledPrimitives(primitive) {
    return primitive.styles.length > 0;
}
function batchPrimitiveDescriptions(primitives) {
    return Object(_util_iterable__WEBPACK_IMPORTED_MODULE_23__["mapIterable"])(Object(_render_memory_relative_location__WEBPACK_IMPORTED_MODULE_26__["batchAllocatedObjects"])(primitives, (primitive) => primitive.bufferLocation, (primitive) => (Object.assign({}, primitive.bufferLocation)), (a, b) => (a.bufferLocation.bufferIndex === b.bufferLocation.bufferIndex)), (bufferLocation) => ({ bufferLocation, styles: [] }));
}
/**
 * Batch labels along with their backgrounds. I.e. a label batch must contain batched background locations of those
 * labels in the batch to support LabelPrimitiveDescription interface.
 */
function* batchLabels(labels) {
    const getLocation = (primitive) => primitive.bufferLocation;
    const createBatch = (primitive) => {
        return Object.assign({}, primitive.bufferLocation, { backgroundBatch: primitive.backgroundBufferLocation ? Object.assign({}, primitive.backgroundBufferLocation) : undefined });
    };
    const canBatch = (a, b, batch) => {
        const areLabelsInSameBuffer = a.bufferLocation.bufferIndex === b.bufferLocation.bufferIndex;
        if (b.backgroundBufferLocation) {
            // there could be no backgroundBatch if previous labels had no backgrounds,
            // so background batching starts with the fist label that contains one
            if (!batch.backgroundBatch) {
                batch.backgroundBatch = Object.assign({}, b.backgroundBufferLocation);
            }
            // label batching breaks if backgrounds can't be batched
            if (b.backgroundBufferLocation.bufferIndex !== batch.backgroundBatch.bufferIndex ||
                !areLabelsInSameBuffer ||
                !Object(_render_memory_relative_location__WEBPACK_IMPORTED_MODULE_26__["appendToBatch"])(b.backgroundBufferLocation, batch.backgroundBatch)) {
                return false;
            }
        }
        return areLabelsInSameBuffer;
    };
    for (const batch of Object(_render_memory_relative_location__WEBPACK_IMPORTED_MODULE_26__["batchAllocatedObjects"])(labels, getLocation, createBatch, canBatch)) {
        const backgroundBufferLocation = batch.backgroundBatch;
        delete batch.backgroundBatch; // this property is not required in main thread, save some serialization efforts
        yield {
            backgroundBufferLocation,
            bufferLocation: batch,
            styles: []
        };
    }
}
function getObjectRequestId(objectId, requestId) {
    return [objectId, requestId].join('-');
}
const EMPTY_LABELS_RESPONSE = {
    type: _tile_provider_worker_messages__WEBPACK_IMPORTED_MODULE_1__["TileProviderMessageType"].LABELS_RESPONSE,
    tile: { x: 0, y: 0, zoom: 0 },
    pointLabelPages: [],
    pointLabelBackgroundPages: [],
    curvedLabelPages: [],
    pointLabels: [],
    curvedLabels: []
};
// Tile parsing priority is always non-negative, so to make sure they're processed
// before anything else, other priorities are less than 0.
const MESH_PARSE_PRIORITY = -2;
class TileProviderWorker extends _util_worker__WEBPACK_IMPORTED_MODULE_0__["WebWorkerImplementation"] {
    constructor(addressee) {
        super(addressee);
        this._taskQueue = new _util_task_queue__WEBPACK_IMPORTED_MODULE_27__["default"]();
        this._minorTaskQueue = new _util_task_queue__WEBPACK_IMPORTED_MODULE_27__["default"]();
        this._tileUrlTemplate = '';
        this._fontRegistry = new _font_df_font_registry__WEBPACK_IMPORTED_MODULE_2__["default"]();
        this._atlas = new _font_df_glyph_atlas_allocator__WEBPACK_IMPORTED_MODULE_3__["default"](2048, 2048);
        this._glyphsDeliveryManager = new _glyph_delivery_manager__WEBPACK_IMPORTED_MODULE_5__["ApiGlyphsDeliveryManager"](this._fontRegistry, this._atlas);
        this._tileRequests = new Map();
        this._meshRequests = new Map();
        this._taskQueue.onEmpty.addListener(() => {
            if (Object(_util_iterable__WEBPACK_IMPORTED_MODULE_23__["allOfIterable"])(this._tileRequests.values(), ({ tile }) => !tile.isVisible)) {
                this._minorTaskQueue.unfreeze();
            }
        });
        this.on(_tile_provider_worker_messages__WEBPACK_IMPORTED_MODULE_1__["TileProviderMessageType"].INIT, this._onInit.bind(this));
        this.on(_tile_provider_worker_messages__WEBPACK_IMPORTED_MODULE_1__["TileProviderMessageType"].TILE_URL_UPDATE, this._onTileUrlUpdate.bind(this));
        this.on(_tile_provider_worker_messages__WEBPACK_IMPORTED_MODULE_1__["TileProviderMessageType"].TILE_REQUEST_BATCH, this._onTileRequestBatch.bind(this));
        this.on(_tile_provider_worker_messages__WEBPACK_IMPORTED_MODULE_1__["TileProviderMessageType"].TILE_REQUEST_CANCEL_BATCH, this._onTileRequestCancelBatch.bind(this));
        this.on(_tile_provider_worker_messages__WEBPACK_IMPORTED_MODULE_1__["TileProviderMessageType"].MESH_REQUEST, this._onMeshRequest.bind(this));
        this.on(_tile_provider_worker_messages__WEBPACK_IMPORTED_MODULE_1__["TileProviderMessageType"].MESH_REQUEST_CANCEL, this._onMeshRequestCancel.bind(this));
        this.setTransferableExtractor(_tile_provider_worker_messages__WEBPACK_IMPORTED_MODULE_1__["TileProviderMessageType"].TILE_RESPONSE, _tile_provider_worker_messages__WEBPACK_IMPORTED_MODULE_1__["tileTransferableExtractor"]);
        this.setTransferableExtractor(_tile_provider_worker_messages__WEBPACK_IMPORTED_MODULE_1__["TileProviderMessageType"].GEOMETRY_RESPONSE, _tile_provider_worker_messages__WEBPACK_IMPORTED_MODULE_1__["geometryTransferableExtractor"]);
        this.setTransferableExtractor(_tile_provider_worker_messages__WEBPACK_IMPORTED_MODULE_1__["TileProviderMessageType"].MESH_RESPONSE, _tile_provider_worker_messages__WEBPACK_IMPORTED_MODULE_1__["meshTransferableExtractor"]);
        this.setTransferableExtractor(_tile_provider_worker_messages__WEBPACK_IMPORTED_MODULE_1__["TileProviderMessageType"].LABELS_RESPONSE, _tile_provider_worker_messages__WEBPACK_IMPORTED_MODULE_1__["labelTransferableExtractor"]);
    }
    _onInit(message) {
        this._tileUrlTemplate = message.tileUrlTemplate;
        this._meshUrlTemplate = message.meshUrlTemplate;
        this._glyphsDeliveryManager.glyphRangeUrlTemplate = message.glyphRangeUrlTemplate;
    }
    _onTileUrlUpdate(message) {
        this._tileUrlTemplate = message.tileUrlTemplate;
    }
    _onTileRequestBatch(request) {
        // Request higher priority tiles first
        request.requests.sort((a, b) => b.priority - a.priority);
        for (const tile of request.requests) {
            const tileUrl = this._tileUrlTemplate
                .replace('{{hostAlias}}', Object(_util_hosts__WEBPACK_IMPORTED_MODULE_30__["getHostAliasByUid"])(Object(_tile_based_adapter_tile_id__WEBPACK_IMPORTED_MODULE_6__["getTileId"])(tile)))
                .replace('{{x}}', tile.x.toString())
                .replace('{{y}}', tile.y.toString())
                .replace('{{z}}', tile.zoom.toString())
                .replace('{{zmin}}', tile.zoomMin.toString())
                .replace('{{zmax}}', tile.zoomMax.toString());
            if (!tileUrl) {
                return;
            }
            const tileId = Object(_tile_based_adapter_tile_id__WEBPACK_IMPORTED_MODULE_6__["getTileId"])(tile);
            const tileRequest = new _util_http__WEBPACK_IMPORTED_MODULE_4__["BinaryHttpRequest"](tileUrl);
            const requestId = request.requestId;
            const tileRequestId = getObjectRequestId(tileId, requestId);
            tileRequest.send().then((buffer) => {
                const taskQueue = tile.isVisible ? this._taskQueue : this._minorTaskQueue;
                return taskQueue.enqueue({
                    execute: () => {
                        // check if tile was not canceled before processing
                        if (this._tileRequests.has(tileRequestId)) {
                            const decodedTile = _proto_aliases__WEBPACK_IMPORTED_MODULE_9__["Tile"].decode(new Uint8Array(buffer));
                            const extractLabelsPromise = this._extractLabels(tile, decodedTile);
                            const geometryResponse = this._computeGeometryResponse(tile, decodedTile);
                            extractLabelsPromise.then((labelsResponse) => {
                                this.sendMessage(Object.assign({}, (labelsResponse || EMPTY_LABELS_RESPONSE), geometryResponse, { type: _tile_provider_worker_messages__WEBPACK_IMPORTED_MODULE_1__["TileProviderMessageType"].TILE_RESPONSE, tile, url: tileUrl, requestId: request.requestId, parseTime: geometryResponse.parseTime +
                                        (labelsResponse ? labelsResponse.parseTime : 0) }));
                            });
                            this._tileRequests.delete(tileRequestId);
                        }
                    },
                    priority: tile.priority
                });
            }, (error) => {
                console.error(`Failed to load and parse tile (${tile.x},${tile.y},${tile.zoom}): ${error}`);
                this.sendMessage({
                    type: _tile_provider_worker_messages__WEBPACK_IMPORTED_MODULE_1__["TileProviderMessageType"].TILE_ERROR,
                    tile,
                    requestId: request.requestId
                });
                this._tileRequests.delete(tileRequestId);
            });
            this._tileRequests.set(tileRequestId, {
                request: tileRequest,
                tile
            });
            if (tile.isVisible) {
                this._minorTaskQueue.freeze();
            }
        }
    }
    _onTileRequestCancelBatch(message) {
        for (const request of message.requests) {
            const id = Object(_tile_based_adapter_tile_id__WEBPACK_IMPORTED_MODULE_6__["getTileId"])(request.tile);
            const tileRequestId = getObjectRequestId(id, request.requestId);
            const tileRequest = this._tileRequests.get(tileRequestId);
            if (tileRequest) {
                tileRequest.request.cancel();
                this._tileRequests.delete(tileRequestId);
            }
        }
    }
    _onMeshRequest(request) {
        if (!this._meshUrlTemplate) {
            return;
        }
        const mesh = request.mesh;
        const meshRequestId = mesh.objectId;
        const meshRequest = new _util_http__WEBPACK_IMPORTED_MODULE_4__["BinaryHttpRequest"](this._meshUrlTemplate
            .replace('{{hostAlias}}', Object(_util_hosts__WEBPACK_IMPORTED_MODULE_30__["getHostAliasByUid"])(mesh.meshId))
            .replace(/\{\{id\}\}/g, mesh.meshId));
        this._meshRequests.set(meshRequestId, meshRequest);
        meshRequest.send().then((buffer) => {
            return this._minorTaskQueue.enqueue({
                execute: () => {
                    // check if mesh was not canceled before processing
                    if (this._meshRequests.has(meshRequestId)) {
                        const writer = new _util_trimesh_polygon_buffer_writer__WEBPACK_IMPORTED_MODULE_25__["TrimeshPolygonBufferWriter"]();
                        const mesh = request.mesh;
                        const location = writer.writeModel(buffer, mesh, mesh.color);
                        this.respond(request, {
                            type: _tile_provider_worker_messages__WEBPACK_IMPORTED_MODULE_1__["TileProviderMessageType"].MESH_RESPONSE,
                            pages: writer.getBuffers(),
                            requestId: request.requestId,
                            location
                        });
                        this._meshRequests.delete(meshRequestId);
                    }
                },
                priority: MESH_PARSE_PRIORITY
            });
        }).catch((error) => {
            console.error(`Failed to load and parse mesh: ${error}`);
            this.respond(request, {
                type: _tile_provider_worker_messages__WEBPACK_IMPORTED_MODULE_1__["TileProviderMessageType"].MESH_ERROR,
                requestId: request.requestId
            });
            this._meshRequests.delete(meshRequestId);
        });
    }
    _onMeshRequestCancel(request) {
        const mesh = request.mesh;
        const meshRequestId = mesh.objectId;
        const meshRequest = this._meshRequests.get(meshRequestId);
        if (meshRequest) {
            meshRequest.cancel();
            this._meshRequests.delete(meshRequestId);
        }
    }
    _computeGeometryResponse(tile, decodedTile) {
        const startTime = performance.now();
        const minZoom = tile.zoom;
        const maxZoom = tile.zoom;
        // Parse polygons from the tile.
        const polygons = [];
        const transparentPolygons = [];
        const texturedPolygons = [];
        const meshes = [];
        const externalMeshes = [];
        const polygonWriter = new _primitive_polygon_polygon_buffer_writer__WEBPACK_IMPORTED_MODULE_11__["default"]();
        const transparentPolygonWriter = new _primitive_polygon_polygon_buffer_writer__WEBPACK_IMPORTED_MODULE_11__["default"]();
        const texturedPolygonWriter = new _primitive_polygon_textured_polygon_buffer_writer__WEBPACK_IMPORTED_MODULE_12__["default"]();
        const extrudedPolygonWriter = new _util_extruded_polygon_buffer_writer__WEBPACK_IMPORTED_MODULE_15__["ExtrudedPolygonBufferWriter"]();
        const extractedPolygons = Object(_util_iterable__WEBPACK_IMPORTED_MODULE_23__["filterIterable"])(Object(_parser_extract_polygons__WEBPACK_IMPORTED_MODULE_14__["default"])(tile, decodedTile, minZoom, maxZoom), filterOutUnstyledPrimitives);
        for (const polygon of extractedPolygons) {
            if (polygon.height === 0) {
                const style = polygon.styles[0];
                if (style.pattern) {
                    texturedPolygons.push({
                        bufferLocation: texturedPolygonWriter.writePolygon(polygon, _math_vector2__WEBPACK_IMPORTED_MODULE_16__["EMPTY"], style.zIndex),
                        styles: polygon.styles
                    });
                }
                else if (_util_color__WEBPACK_IMPORTED_MODULE_7__["isOpaque"](style.color)) {
                    polygons.push({
                        bufferLocation: polygonWriter.writePolygon(polygon, style.zIndex, style.color),
                        styles: polygon.styles
                    });
                }
                else {
                    transparentPolygons.push({
                        bufferLocation: transparentPolygonWriter.writePolygon(polygon, style.zIndex, style.color),
                        styles: polygon.styles
                    });
                }
            }
            else if (polygon.externalMesh) {
                externalMeshes.push(polygon.externalMesh);
            }
            else {
                const style = polygon.styles[0];
                meshes.push({
                    bufferLocation: extrudedPolygonWriter.writePolygon(polygon, polygon.height, style.color),
                    styles: polygon.styles
                });
            }
        }
        // Parse polylines from the tile.
        const polylineWriter = new _primitive_polyline_polyline_buffer_writer__WEBPACK_IMPORTED_MODULE_13__["default"]();
        const polylines = [];
        const texturedPolylines = [];
        const extractedPolylines = Object(_util_iterable__WEBPACK_IMPORTED_MODULE_23__["reduceIterable"])(Object(_util_iterable__WEBPACK_IMPORTED_MODULE_23__["filterIterable"])(Object(_parser_extract_polylines__WEBPACK_IMPORTED_MODULE_10__["default"])(tile, decodedTile, minZoom, maxZoom), filterOutUnstyledPrimitives), (extractedPolylines, polyline) => {
            const style = polyline.styles[0];
            if (style.inline) {
                extractedPolylines.push({
                    polyline,
                    style: style.inline,
                    zIndex: style.zIndex + 0.01
                });
            }
            if (style.outline) {
                extractedPolylines.push({
                    polyline,
                    style: style.outline,
                    zIndex: style.zIndex
                });
            }
            return extractedPolylines;
        }, []);
        // We need to sort polylines stably to preserve drawing order of ones
        // with equal z indices.
        Object(_util_array__WEBPACK_IMPORTED_MODULE_28__["mergeSort"])(extractedPolylines, (p1, p2) => p1.zIndex - p2.zIndex);
        for (const { polyline, style, zIndex } of extractedPolylines) {
            if (style.pattern) {
                texturedPolylines.push(polyline);
            }
            else {
                polylines.push({
                    bufferLocation: polylineWriter.writePolyline(polyline, style, zIndex),
                    styles: polyline.styles
                });
            }
        }
        // Parse points from the tile.
        const points = [
            ...Object(_util_iterable__WEBPACK_IMPORTED_MODULE_23__["filterIterable"])(Object(_parser_extract_points__WEBPACK_IMPORTED_MODULE_8__["default"])(tile, decodedTile, minZoom, maxZoom), filterOutUnstyledPrimitives)
        ];
        return {
            type: _tile_provider_worker_messages__WEBPACK_IMPORTED_MODULE_1__["TileProviderMessageType"].GEOMETRY_RESPONSE,
            tile,
            polygonPages: polygonWriter.getBuffers(),
            polygons: [...batchPrimitiveDescriptions(polygons)],
            transparentPolygonPages: transparentPolygonWriter.getBuffers(),
            transparentPolygons: [...batchPrimitiveDescriptions(transparentPolygons)],
            texturedPolygons,
            texturedPolygonPages: texturedPolygonWriter.getBuffers(),
            meshPages: extrudedPolygonWriter.getBuffers(),
            meshes: [...batchPrimitiveDescriptions(meshes)],
            externalMeshes,
            polylinePages: polylineWriter.getBuffers(),
            polylines: [...batchPrimitiveDescriptions(polylines)],
            texturedPolylines,
            points,
            parseTime: performance.now() - startTime
        };
    }
    _extractLabels(tile, decodedTile) {
        const minZoom = tile.zoom;
        const maxZoom = tile.zoom;
        return Promise.all([
            this._prepareLabels(Object(_util_iterable__WEBPACK_IMPORTED_MODULE_23__["filterIterable"])(Object(_parser_extract_point_labels__WEBPACK_IMPORTED_MODULE_18__["default"])(tile, decodedTile, minZoom, maxZoom), filterOutUnstyledPrimitives)),
            this._prepareLabels(Object(_util_iterable__WEBPACK_IMPORTED_MODULE_23__["filterIterable"])(Object(_parser_extract_curved_labels__WEBPACK_IMPORTED_MODULE_17__["default"])(tile, decodedTile, minZoom, maxZoom), filterOutUnstyledPrimitives))
        ]).then(([pointLabels, curvedLabels]) => this._computeLabelsResponse(tile, pointLabels, curvedLabels), (error) => console.log('TODO: respond with error', error));
    }
    _prepareLabels(labels) {
        return Promise.all(Object(_util_iterable__WEBPACK_IMPORTED_MODULE_23__["mapIterable"])(labels, (label) => {
            // make sure all the glyphs are on hand before forming label GPU data
            return this._fetchAllGlyphs(label.texts, label.styles).then(() => (label));
        }));
    }
    /**
     * Fetches all the required by texts glyphs as a single Promise.
     */
    _fetchAllGlyphs(texts, styles) {
        const requests = [];
        for (const text of texts) {
            const glyphs = text.textLines.reduce((glyphs, textLine) => {
                glyphs.push(...textLine.glyphIds);
                return glyphs;
            }, []);
            for (const zoomStyle of styles) {
                for (const textStyle of zoomStyle.styles) {
                    requests.push(this._glyphsDeliveryManager.fetchGlyphs(textStyle.fontId, glyphs));
                }
            }
        }
        return Promise.all(requests);
    }
    _computeLabelsResponse(tile, parsedPointLabels = [], parsedCurvedLabels = []) {
        const startTime = performance.now();
        const pointLabelWriter = new _primitive_label_point_label_buffer_writer__WEBPACK_IMPORTED_MODULE_21__["default"]();
        const pointLabelBackgroundWriter = new _primitive_billboard_rectangle_buffer_writer__WEBPACK_IMPORTED_MODULE_20__["default"]();
        const pointLabels = Array.from(parsedPointLabels, (label) => {
            const style = label.styles[0];
            const layout = Object(_primitive_label_layout_point_label__WEBPACK_IMPORTED_MODULE_19__["default"])(label, style, this._fontRegistry);
            const id = Object(_id_manager__WEBPACK_IMPORTED_MODULE_29__["getId"])();
            let backgroundBufferLocation;
            if (style.background) {
                const bbox = Object(_util_label__WEBPACK_IMPORTED_MODULE_24__["calculatePointLabelBBox"])(layout, style.background.verticalPadding, style.background.horizontalPadding);
                backgroundBufferLocation = pointLabelBackgroundWriter.writeRectangle(id, {
                    position: label.anchorPoint
                }, {
                    width: bbox.maxX - bbox.minX,
                    height: bbox.maxY - bbox.minY,
                    offset: _math_vector2__WEBPACK_IMPORTED_MODULE_16__["create"]((bbox.maxX + bbox.minX) / 2, (bbox.maxY + bbox.minY) / 2),
                    borderRadius: BACKGROUND_RADIUS_PX,
                    color: style.background.color
                });
            }
            return {
                backgroundBufferLocation: backgroundBufferLocation,
                bufferLocation: pointLabelWriter.writePointLabel(id, label, style, layout, this._atlas),
                styles: label.styles
            };
        });
        const curvedLabelWriter = new _primitive_label_curved_label_buffer_writer__WEBPACK_IMPORTED_MODULE_22__["default"]();
        const curvedLabels = Array.from(parsedCurvedLabels, (label) => ({
            bufferLocation: curvedLabelWriter.writeLabel(label, label.styles[0], this._fontRegistry, this._atlas),
            styles: label.styles
        }));
        const isAtlasDirty = this._atlas.isDirty;
        this._atlas.isDirty = false;
        return {
            type: _tile_provider_worker_messages__WEBPACK_IMPORTED_MODULE_1__["TileProviderMessageType"].LABELS_RESPONSE,
            tile,
            pointLabelPages: pointLabelWriter.getBuffers(),
            pointLabelBackgroundPages: pointLabelBackgroundWriter.getBuffers(),
            curvedLabelPages: curvedLabelWriter.getBuffers(),
            pointLabels: [...batchLabels(pointLabels)],
            curvedLabels: [...batchPrimitiveDescriptions(curvedLabels)],
            fontRegistryToUpdate: isAtlasDirty ? this._fontRegistry.getAll().map((font) => {
                return {
                    id: font.id,
                    xheight: font.xheight,
                    margin: font.margin,
                    glyphs: font.getAllGlyphs()
                };
            }) : undefined,
            glyphAtlasToUpdate: isAtlasDirty ? {
                width: this._atlas.width,
                height: this._atlas.height,
                glyphLocations: this._atlas.getAllGlyphLocations(),
                data: this._atlas.data
            } : undefined,
            parseTime: performance.now() - startTime
        };
    }
}
new TileProviderWorker(self)
    .run();


/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NO_ID", function() { return NO_ID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "messageIs", function() { return messageIs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebWorkerCommunicator", function() { return WebWorkerCommunicator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebWorkerClient", function() { return WebWorkerClient; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebWorkerImplementation", function() { return WebWorkerImplementation; });
/* harmony import */ var _event_emitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _unique_id__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/**
 * Base interface for webworker messages, both incoming and outgoing ones.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Transferable
 */


const MESSAGE_BATCH_MAX_SIZE = 50;
const FLUSH_TIMEOUT = 50;
// each subsequent message debounces postMessage call, that can lead to infinite delay, this const limits it
const MAX_FLUSH_TIMEOUT = 250;
const NO_ID = -1;
/**
 * Checks message type with type guarding. It gives a little bit more elegant alternative
 * to tagged type unions providing the same type safety.
 *
 * @param message to be checked
 * @param type the value of the "type" property
 * @return {boolean}
 */
function messageIs(message, type) {
    return message.type === type;
}
/**
 * Base class for both sides of a webworker: its implementation (separate js that is run in a worker thread) and
 * a controller for the main thread. They have similar mechanism of sending/receiving messages that is implement here.
 */
class WebWorkerCommunicator {
    constructor(addressee) {
        this._addressee = addressee;
        this._events = new _event_emitter__WEBPACK_IMPORTED_MODULE_0__["EventEmitter"]();
        this._listeners = new Map();
        this._transferableExtractors = new Map();
        this._messages = [];
        this._transferables = [];
        this._timeoutHandle = 0;
        this._flushMessagesBinded = this._flushMessages.bind(this);
    }
    setTransferableExtractor(type, extractor) {
        this._transferableExtractors.set(type, extractor);
    }
    /**
     * Send a message to the opposite side of the web worker communication channel.
     * Messages are batched by delaying postMessage call to group messages that come during this delay and minimize
     * the number of interprocess communications that badly affect performance.
     *
     * @param message Message to be sent.
     * @param urgency IMMEDIATE forces message to be sent immediately (synchronous call) with no batching delay,
     *                DEFAULT debounces sending for another FLUSH_TIMEOUT.
     */
    sendMessage(message, urgency = 0 /* DEFAULT */) {
        const transferableExtractor = this._transferableExtractors.get(message.type);
        const transferables = transferableExtractor ? transferableExtractor(message) : undefined;
        const isFirstMessageInBatch = (this._messages.length === 0);
        if (isFirstMessageInBatch) {
            this._firstMessageTime = performance.now();
        }
        // Send messages asynchronously packing them into one message.
        // We don't want to abuse the web worker communication channel and
        // send messages asynchronously in short period of time or many messages synchronously.
        this._messages.push(message);
        if (transferables) {
            this._transferables = this._transferables.concat(transferables);
        }
        clearTimeout(this._timeoutHandle);
        if (this._messages.length > MESSAGE_BATCH_MAX_SIZE ||
            urgency === 1 /* IMMEDIATE */ ||
            (!isFirstMessageInBatch && (performance.now() - this._firstMessageTime) > MAX_FLUSH_TIMEOUT)) {
            this._flushMessages();
        }
        else {
            this._timeoutHandle = setTimeout(this._flushMessagesBinded, FLUSH_TIMEOUT);
        }
    }
    /**
     * Sends request message to/from worker as promise, the other side can respond and the promise is resolved.
     * Request/response is synchronized by the requestId field.
     */
    request(request, urgency) {
        return new Promise((resolve, reject) => {
            if (request.requestId === NO_ID) {
                request.requestId = Object(_unique_id__WEBPACK_IMPORTED_MODULE_1__["uniqueId"])();
            }
            const listener = (message) => {
                if (messageIs(message, request.responseType) &&
                    message.requestId === request.requestId) {
                    resolve(message);
                    this._events.removeListener(listener);
                }
                if (messageIs(message, request.errorType) &&
                    message.requestId === request.requestId) {
                    reject();
                    this.off(listener);
                }
            };
            this._events.addListener(listener);
            this.sendMessage(request, urgency);
        });
    }
    /**
     * Responds to provided request.
     */
    respond(request, response, urgency) {
        response.requestId = request.requestId;
        this.sendMessage(response, urgency);
    }
    /**
     * Sets a listener to specific type of incoming messages.
     */
    on(type, listener) {
        const typeSafeListener = (message) => {
            if (messageIs(message, type)) {
                listener(message);
            }
        };
        this._listeners.set(listener, typeSafeListener);
        this._events.addListener(typeSafeListener);
    }
    /**
     * Removes incoming messages listener.
     */
    off(listener) {
        const typeSafeListener = this._listeners.get(listener);
        if (typeSafeListener) {
            this._events.removeListener(typeSafeListener);
        }
    }
    /**
     * Starts listening for incoming messages.
     */
    listen() {
        this._addressee.onmessage = ({ data: messages }) => {
            for (const message of messages) {
                this.onMessage(message);
            }
        };
    }
    /**
     * Handler of incoming messages.
     */
    onMessage(message) {
        this._events.fire(message);
    }
    _flushMessages() {
        this._addressee.postMessage(this._messages, this._transferables);
        this._messages.length = 0;
        this._transferables.length = 0;
    }
}
/**
 * Base class for a webworker controller for the main thread code.
 * It also wraps creation of a native Worker.
 */
class WebWorkerClient extends WebWorkerCommunicator {
    /**
     * @param url URL of webworker's deployed js file
     */
    constructor(url) {
        const worker = new Worker(url);
        super(worker);
        this._worker = worker;
        this.listen();
    }
    destroy() {
        this._worker.terminate();
    }
}
/**
 * Base class for a webworker thread implementation. Concrete class should be the entry point for a webworker js build:
 *     new ConcreteWebWorkerImplementation(<DedicatedWorkerGlobalScope>self).run();
 */
class WebWorkerImplementation extends WebWorkerCommunicator {
    run() {
        this.listen();
    }
}


/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EventEmitter", function() { return EventEmitter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VoidEventEmitter", function() { return VoidEventEmitter; });
/**
 * Simple pub/sub implementation. The emitter is supposed to emit only one type of event,
 * if someone has to emit events of different types, multiple emitters should be created.
 */
class EventEmitter {
    constructor() {
        this._listeners = new Set();
    }
    /**
     * Adds listener.
     */
    addListener(listener) {
        this._listeners.add(listener);
    }
    /**
     * Removes listener.
     */
    removeListener(listener) {
        this._listeners.delete(listener);
    }
    /**
     * Calls all the added listeners, the order (e.g. of adding) is not guaranteed.
     */
    fire(data) {
        this._listeners.forEach((listener) => {
            listener(data);
        });
    }
}
/**
 * Event emitter with no payload emitted.
 */
class VoidEventEmitter extends EventEmitter {
    fire() {
        super.fire(undefined);
    }
}


/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "uniqueId", function() { return uniqueId; });
let id = 1;
/**
 * Generates unique id
*/
function uniqueId() {
    return id++;
}


/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TileProviderMessageType", function() { return TileProviderMessageType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "geometryTransferableExtractor", function() { return geometryTransferableExtractor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "meshTransferableExtractor", function() { return meshTransferableExtractor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "labelTransferableExtractor", function() { return labelTransferableExtractor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tileTransferableExtractor", function() { return tileTransferableExtractor; });
/* harmony import */ var _primitive_provider_worker_messages__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);

var TileProviderMessageType;
(function (TileProviderMessageType) {
    TileProviderMessageType[TileProviderMessageType["INIT"] = 0] = "INIT";
    TileProviderMessageType[TileProviderMessageType["TILE_URL_UPDATE"] = 1] = "TILE_URL_UPDATE";
    TileProviderMessageType[TileProviderMessageType["TILE_REQUEST_BATCH"] = 2] = "TILE_REQUEST_BATCH";
    TileProviderMessageType[TileProviderMessageType["TILE_REQUEST_CANCEL_BATCH"] = 3] = "TILE_REQUEST_CANCEL_BATCH";
    TileProviderMessageType[TileProviderMessageType["TILE_RESPONSE"] = 4] = "TILE_RESPONSE";
    TileProviderMessageType[TileProviderMessageType["TILE_ERROR"] = 5] = "TILE_ERROR";
    TileProviderMessageType[TileProviderMessageType["GEOMETRY_RESPONSE"] = 6] = "GEOMETRY_RESPONSE";
    TileProviderMessageType[TileProviderMessageType["LABELS_RESPONSE"] = 7] = "LABELS_RESPONSE";
    TileProviderMessageType[TileProviderMessageType["MESH_REQUEST"] = 8] = "MESH_REQUEST";
    TileProviderMessageType[TileProviderMessageType["MESH_REQUEST_CANCEL"] = 9] = "MESH_REQUEST_CANCEL";
    TileProviderMessageType[TileProviderMessageType["MESH_RESPONSE"] = 10] = "MESH_RESPONSE";
    TileProviderMessageType[TileProviderMessageType["MESH_ERROR"] = 11] = "MESH_ERROR";
})(TileProviderMessageType || (TileProviderMessageType = {}));
const geometryTransferableExtractor = function (message, transferables = []) {
    Object(_primitive_provider_worker_messages__WEBPACK_IMPORTED_MODULE_0__["extractTransferables"])(message.polygonPages, transferables);
    Object(_primitive_provider_worker_messages__WEBPACK_IMPORTED_MODULE_0__["extractTransferables"])(message.transparentPolygonPages, transferables);
    Object(_primitive_provider_worker_messages__WEBPACK_IMPORTED_MODULE_0__["extractTransferables"])(message.texturedPolygonPages, transferables);
    Object(_primitive_provider_worker_messages__WEBPACK_IMPORTED_MODULE_0__["extractTransferables"])(message.meshPages, transferables);
    Object(_primitive_provider_worker_messages__WEBPACK_IMPORTED_MODULE_0__["extractTransferables"])(message.polylinePages, transferables);
    return transferables;
};
const meshTransferableExtractor = function (message) {
    const transferables = [];
    Object(_primitive_provider_worker_messages__WEBPACK_IMPORTED_MODULE_0__["extractTransferables"])(message.pages, transferables);
    return transferables;
};
const labelTransferableExtractor = function (message, transferables = []) {
    Object(_primitive_provider_worker_messages__WEBPACK_IMPORTED_MODULE_0__["extractTransferables"])(message.pointLabelPages, transferables);
    Object(_primitive_provider_worker_messages__WEBPACK_IMPORTED_MODULE_0__["extractTransferables"])(message.pointLabelBackgroundPages, transferables);
    Object(_primitive_provider_worker_messages__WEBPACK_IMPORTED_MODULE_0__["extractTransferables"])(message.curvedLabelPages, transferables);
    return transferables;
};
const tileTransferableExtractor = function (message) {
    const transferables = [];
    geometryTransferableExtractor(message, transferables);
    labelTransferableExtractor(message, transferables);
    return transferables;
};


/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractTransferables", function() { return extractTransferables; });
/**
 * Extract ArrayBuffers (that are tansferable) from pages.
 */
function extractTransferables(pages, output) {
    for (const page of pages) {
        output.push(page.vertexBuffer.buffer, page.indexBuffer.buffer);
    }
}


/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DfFontRegistry; });
/* harmony import */ var _font_registry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7);
/* harmony import */ var _df_font__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);


/**
 * Registry that stores distance field fonts.
 */
class DfFontRegistry extends _font_registry__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super(new _df_font__WEBPACK_IMPORTED_MODULE_1__["default"]('UNKNOWN_DF_FONT', 14, 0));
    }
}


/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return FontRegistry; });
/**
 * A central storage of all available fonts.
 */
class FontRegistry {
    /**
     * @param unknownFontInstance An instance of specific font type to be served as a stub when nonexistent font
     *     is requested. Requesting nonexistent fonts normally should not happen.
     *     The stub just allows to avoid tedious null checks in registry clients.
     */
    constructor(unknownFontInstance) {
        this._fonts = new Map();
        this._unknownFontInstance = unknownFontInstance;
    }
    /**
     * @return If a font with specified id is in the registry.
     */
    contains(fontId) {
        return this._fonts.has(fontId);
    }
    /**
     * @return Font with specified id or unknown font instance if it is not found.
     */
    get(fontId) {
        const font = this._fonts.get(fontId);
        if (font) {
            return font;
        }
        else {
            console.warn('Wow-wow-wow, something went wrong, you should not request nonexistent fonts');
            return this._unknownFontInstance;
        }
    }
    /**
     * @return All stored fonts.
     */
    getAll() {
        return [...this._fonts.values()];
    }
    /**
     * Adds new for to the registry.
     */
    add(font) {
        this._fonts.set(font.id, font);
    }
}


/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DfFont; });
/* harmony import */ var _font__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9);

const UNKNOWN_GLYPH = {
    id: -1,
    width: 0,
    height: 0,
    bearingX: 0,
    bearingY: 0,
    advance: 18
};
/**
 * Font whose glyphs are specified in distance field bitmaps. It's "margin" metric specifies glyph bitmap inner padding,
 * that is required to fit a "blurred" glyph image. This margin should be considered during layouting to draw glyphs of
 * proper sizes.
 */
class DfFont extends _font__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(id, xheight, margin) {
        super(id, xheight, UNKNOWN_GLYPH);
        this.margin = margin;
    }
}


/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Font; });
/**
 * Font is just a collection of glyph descriptions.
 */
class Font {
    /**
     * @param id Font id.
     * @param xheight The height of the "x" char in abstract points, in fact is used a the font size.
     * @param unknownGlyphInstance An instance of glyph to be served as a stub when nonexistent glyph
     *     is requested. Requesting nonexistent glyphs normally should not happen.
     *     The stub just allows to avoid tedious null checks in font clients.
     */
    constructor(id, xheight, unknownGlyphInstance) {
        this.id = id;
        this.xheight = xheight;
        this._unknownGlyphInstance = unknownGlyphInstance;
        this._glyphs = new Map();
    }
    /**
     * @return Glyph with specified id or unknown glyph instance.
     */
    getGlyph(glyphId) {
        const glyph = this._glyphs.get(glyphId);
        if (glyph) {
            return glyph;
        }
        else {
            console.warn('Wow-wow-wow, something went wrong, you should not request nonexistent glyphs');
            return this._unknownGlyphInstance;
        }
    }
    /**
     * @returns All stored glyphs.
     */
    getAllGlyphs() {
        return [...this._glyphs.values()];
    }
    /**
     * Adds glyph description.
     */
    addGlyph(glyph) {
        this._glyphs.set(glyph.id, glyph);
    }
    /**
     * Adds glyph descriptions from the iterable.
     */
    addAllGlyphs(glyphs) {
        for (const glyph of glyphs) {
            this.addGlyph(glyph);
        }
    }
}


/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DfGlyphAtlasAllocator; });
/* harmony import */ var _df_glyph_atlas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(11);

/**
 * Glyph bitmap atlas. It manages allocation os separate glyph bitmaps in one big texture.
 */
class DfGlyphAtlasAllocator extends _df_glyph_atlas__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(width, height) {
        super(width, height, new Uint8Array(width * height), new Map());
        this.isDirty = false;
        this._currentLinePositionX = 0;
        this._currentLinePositionY = 0;
        this._currentLineHeight = 0;
    }
    /**
     * Allocates distance field glyph in atlas with specified padding.
     */
    allocateGlyph(fontId, glyph, padding) {
        const width = glyph.width + padding * 2;
        const height = glyph.height + padding * 2;
        const maxCurrentLineWidth = this.width - this._currentLinePositionX;
        const maxCurrentLineHeight = this.height - this._currentLinePositionY;
        if (width <= maxCurrentLineWidth &&
            height <= maxCurrentLineHeight) {
            const location = {
                minX: this._currentLinePositionX,
                maxX: this._currentLinePositionX + width,
                minY: this._currentLinePositionY,
                maxY: this._currentLinePositionY + height
            };
            this._currentLinePositionX += width;
            this._currentLineHeight = Math.max(this._currentLineHeight, height);
            this._putGlyphBitmap(fontId, glyph, location);
            return location;
        }
        else {
            const maxNextLineHeight = this.height - (this._currentLinePositionY + this._currentLineHeight);
            if (width <= this.width &&
                height <= maxNextLineHeight) {
                this._currentLinePositionX = width;
                this._currentLinePositionY += this._currentLineHeight;
                this._currentLineHeight = height;
                const location = {
                    minY: this._currentLinePositionY,
                    maxY: this._currentLinePositionY + height,
                    minX: 0,
                    maxX: width
                };
                this._putGlyphBitmap(fontId, glyph, location);
                return location;
            }
            else {
                throw new Error('no room available');
            }
        }
    }
    /**
     * Puts glyph's bitmap in specified position.
     */
    _putGlyphBitmap(fontId, glyph, location) {
        for (let atlasY = location.minY, glyphY = 0; atlasY < location.maxY; atlasY++, glyphY++) {
            const atlasRowOffset = atlasY * this.width;
            const glyphRowOffset = glyphY * (location.maxX - location.minX);
            for (let atlasX = location.minX, glyphX = 0; atlasX < location.maxX; atlasX++, glyphX++) {
                this.data[atlasRowOffset + atlasX] = glyph.bitmap[glyphRowOffset + glyphX];
            }
        }
        this._glyphLocations.set(fontId + glyph.id, location);
        this.isDirty = true;
    }
}


/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DfGlyphAtlas; });
const UNKNOWN_GLYPH_LOCATION = {
    minX: 0,
    maxX: 0,
    minY: 0,
    maxY: 0
};
/**
 * Abstract glyph atlas interface.
 */
class DfGlyphAtlas {
    constructor(width, height, data, glyphLocations) {
        this.width = width;
        this.height = height;
        this.data = data;
        this._glyphLocations = glyphLocations;
    }
    /**
     * @return Glyph location or fake location pointing to the origin (0, 0).
     */
    getGlyphLocation(fontId, glyphId) {
        const glyphLocation = this._glyphLocations.get(fontId + glyphId);
        if (glyphLocation) {
            return glyphLocation;
        }
        else {
            console.warn('Wow-wow-wow, something went wrong, you should not request nonexistent glyph locations');
            return UNKNOWN_GLYPH_LOCATION;
        }
    }
    /**
     * @return All glyph locations as [glyph id, glyph location] array. Glyph id is font id concatenated with glyph id.
     */
    getAllGlyphLocations() {
        return [...this._glyphLocations.entries()];
    }
}


/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BinaryHttpRequest", function() { return BinaryHttpRequest; });
/**
 * Base class for HTTP request wrappers. Its main function is to simplify API for HTTP via reasonable abstraction.
 */
class HttpRequest {
    constructor(url, responseType, method = 'GET') {
        this._url = url;
        this._method = method;
        this._xhr = new XMLHttpRequest();
        this._xhr.responseType = responseType;
    }
    get isCanceled() {
        return this._xhr.readyState === XMLHttpRequest.DONE && this._xhr.status === 0;
    }
    /**
     * Initiates all the networking activities. Must be called only once.
     */
    send() {
        const xhr = this._xhr;
        if (xhr.readyState !== XMLHttpRequest.UNSENT) {
            return Promise.reject(new Error('already sent'));
        }
        return new Promise((resolve, reject) => {
            xhr.open(this._method, this._url);
            xhr.onload = () => {
                if (this.isCanceled) {
                    return;
                }
                if (200 <= xhr.status && xhr.status < 300) {
                    resolve(this._prepareResponse(xhr.response));
                }
                else {
                    reject(new Error(`Failed request: ${xhr.status} ${xhr.statusText}, ${this._url}`));
                }
            };
            this._xhr.onerror = () => {
                reject(new Error(`Failed request: ${this._url}`));
            };
            this._xhr.send();
        });
    }
    /**
     * Cancels active request if possible, at least promise callback of the send() methods will not be invoked.
     */
    cancel() {
        if (this._xhr.readyState !== XMLHttpRequest.UNSENT &&
            !this.isCanceled) {
            this._xhr.abort();
        }
    }
}
/**
 * HTTP request that gets its response as an ArrayBuffer.
 */
class BinaryHttpRequest extends HttpRequest {
    constructor(url, method = 'GET') {
        super(url, 'arraybuffer', method);
    }
    _prepareResponse(response) {
        if (!(response instanceof ArrayBuffer)) {
            return new ArrayBuffer(0);
        }
        return response;
    }
}


/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ApiGlyphsDeliveryManager", function() { return ApiGlyphsDeliveryManager; });
/* harmony import */ var _proto_aliases__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(14);
/* harmony import */ var _font_df_font__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);
/* harmony import */ var _font_df_glyph_delivery_manager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(35);
/* harmony import */ var _util_hosts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(36);




/**
 * Provides glyphs from the API.
 */
class ApiGlyphsDeliveryManager extends _font_df_glyph_delivery_manager__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor(fontRegistry, atlas) {
        super(fontRegistry, atlas);
        this.glyphRangeUrlTemplate = '';
    }
    _getGlyphRange(fontId, startGlyphId, endGlyphId) {
        const url = this._getGlyphRangeUrl(fontId, startGlyphId, endGlyphId);
        if (!url) {
            return Promise.resolve([]);
        }
        return fetch(url)
            .then((r) => r.arrayBuffer())
            .then((buffer) => {
            const response = _proto_aliases__WEBPACK_IMPORTED_MODULE_0__["GlyphList"].decode(new Uint8Array(buffer));
            if (this._fontRegistry.contains(fontId)) {
                const font = this._fontRegistry.get(fontId);
                font.xheight = response.font.xheight;
                font.margin = response.font.margin;
            }
            else {
                this._fontRegistry.add(new _font_df_font__WEBPACK_IMPORTED_MODULE_1__["default"](fontId, response.font.xheight, response.font.margin));
            }
            return response.glyphs;
        });
    }
    _getGlyphRangeUrl(fontId, startGlyphId, endGlyphId) {
        return this.glyphRangeUrlTemplate
            .replace('{{hostAlias}}', Object(_util_hosts__WEBPACK_IMPORTED_MODULE_3__["getHostAliasByUid"])(fontId))
            .replace('{{fontId}}', fontId)
            .replace('{{range}}', `${startGlyphId},${endGlyphId}`);
    }
}


/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Presentation", function() { return Presentation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Tile", function() { return Tile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GlyphList", function() { return GlyphList; });
/* harmony import */ var _proto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15);
/* harmony import */ var _proto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_proto__WEBPACK_IMPORTED_MODULE_0__);

// The sole purpose of this module is to provide shorthands to messages used in
// the codebase without polluting the rest of it.
//
// NB: `import` keyword here bears a meaning that's somewhat different from the
// ES modules one. It's here to create an alias to a symbol. It's necessary
// because those symbols are simultaneously types, classes and namespaces (thus,
// using `const` and `type` doesn't cut it).
//
// See https://www.typescriptlang.org/docs/handbook/namespaces.html#aliases.
var Presentation = _proto__WEBPACK_IMPORTED_MODULE_0__["yandex"].maps.proto.vectordata2.presentation.Presentation;
var Tile = _proto__WEBPACK_IMPORTED_MODULE_0__["yandex"].maps.proto.vectordata2.tile.Tile;
var GlyphList = _proto__WEBPACK_IMPORTED_MODULE_0__["yandex"].maps.proto.vectordata2.glyphs.GlyphList;


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/


var $protobuf = __webpack_require__(16);

// Common aliases
var $Reader = $protobuf.Reader, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.yandex = (function() {

    /**
     * Namespace yandex.
     * @exports yandex
     * @namespace
     */
    var yandex = {};

    yandex.maps = (function() {

        /**
         * Namespace maps.
         * @memberof yandex
         * @namespace
         */
        var maps = {};

        maps.proto = (function() {

            /**
             * Namespace proto.
             * @memberof yandex.maps
             * @namespace
             */
            var proto = {};

            proto.vectordata2 = (function() {

                /**
                 * Namespace vectordata2.
                 * @memberof yandex.maps.proto
                 * @namespace
                 */
                var vectordata2 = {};

                vectordata2.tile = (function() {

                    /**
                     * Namespace tile.
                     * @memberof yandex.maps.proto.vectordata2
                     * @namespace
                     */
                    var tile = {};

                    tile.Tile = (function() {

                        /**
                         * Properties of a Tile.
                         * @memberof yandex.maps.proto.vectordata2.tile
                         * @interface ITile
                         * @property {Array.<yandex.maps.proto.vectordata2.presentation.Presentation>|null} [presentation] Tile presentation
                         * @property {yandex.maps.proto.vectordata2.tile.Tile.PointObjects|null} [points] Tile points
                         * @property {yandex.maps.proto.vectordata2.tile.Tile.PolylineObjects|null} [polylines] Tile polylines
                         * @property {yandex.maps.proto.vectordata2.tile.Tile.PolygonObjects|null} [polygons] Tile polygons
                         * @property {yandex.maps.proto.vectordata2.tile.Tile.StraightLabels|null} [pointLabels] Tile pointLabels
                         * @property {yandex.maps.proto.vectordata2.tile.Tile.CurvedLabels|null} [polylineLabels] Tile polylineLabels
                         * @property {Array.<yandex.maps.proto.vectordata2.tile.Tile.Layer>|null} [layers] Tile layers
                         * @property {Array.<string>|null} [indoorPlanId] Tile indoorPlanId
                         */

                        /**
                         * Constructs a new Tile.
                         * @memberof yandex.maps.proto.vectordata2.tile
                         * @classdesc Represents a Tile.
                         * @implements ITile
                         * @constructor
                         * @param {yandex.maps.proto.vectordata2.tile.ITile=} [properties] Properties to set
                         */
                        function Tile(properties) {
                            this.presentation = [];
                            this.layers = [];
                            this.indoorPlanId = [];
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Tile presentation.
                         * @member {Array.<yandex.maps.proto.vectordata2.presentation.Presentation>} presentation
                         * @memberof yandex.maps.proto.vectordata2.tile.Tile
                         * @instance
                         */
                        Tile.prototype.presentation = $util.emptyArray;

                        /**
                         * Tile points.
                         * @member {yandex.maps.proto.vectordata2.tile.Tile.PointObjects|null|undefined} points
                         * @memberof yandex.maps.proto.vectordata2.tile.Tile
                         * @instance
                         */
                        Tile.prototype.points = null;

                        /**
                         * Tile polylines.
                         * @member {yandex.maps.proto.vectordata2.tile.Tile.PolylineObjects|null|undefined} polylines
                         * @memberof yandex.maps.proto.vectordata2.tile.Tile
                         * @instance
                         */
                        Tile.prototype.polylines = null;

                        /**
                         * Tile polygons.
                         * @member {yandex.maps.proto.vectordata2.tile.Tile.PolygonObjects|null|undefined} polygons
                         * @memberof yandex.maps.proto.vectordata2.tile.Tile
                         * @instance
                         */
                        Tile.prototype.polygons = null;

                        /**
                         * Tile pointLabels.
                         * @member {yandex.maps.proto.vectordata2.tile.Tile.StraightLabels|null|undefined} pointLabels
                         * @memberof yandex.maps.proto.vectordata2.tile.Tile
                         * @instance
                         */
                        Tile.prototype.pointLabels = null;

                        /**
                         * Tile polylineLabels.
                         * @member {yandex.maps.proto.vectordata2.tile.Tile.CurvedLabels|null|undefined} polylineLabels
                         * @memberof yandex.maps.proto.vectordata2.tile.Tile
                         * @instance
                         */
                        Tile.prototype.polylineLabels = null;

                        /**
                         * Tile layers.
                         * @member {Array.<yandex.maps.proto.vectordata2.tile.Tile.Layer>} layers
                         * @memberof yandex.maps.proto.vectordata2.tile.Tile
                         * @instance
                         */
                        Tile.prototype.layers = $util.emptyArray;

                        /**
                         * Tile indoorPlanId.
                         * @member {Array.<string>} indoorPlanId
                         * @memberof yandex.maps.proto.vectordata2.tile.Tile
                         * @instance
                         */
                        Tile.prototype.indoorPlanId = $util.emptyArray;

                        /**
                         * Decodes a Tile message from the specified reader or buffer.
                         * @function decode
                         * @memberof yandex.maps.proto.vectordata2.tile.Tile
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {yandex.maps.proto.vectordata2.tile.Tile} Tile
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Tile.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.yandex.maps.proto.vectordata2.tile.Tile();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    if (!(message.presentation && message.presentation.length))
                                        message.presentation = [];
                                    message.presentation.push($root.yandex.maps.proto.vectordata2.presentation.Presentation.decode(reader, reader.uint32()));
                                    break;
                                case 2:
                                    message.points = $root.yandex.maps.proto.vectordata2.tile.Tile.PointObjects.decode(reader, reader.uint32());
                                    break;
                                case 3:
                                    message.polylines = $root.yandex.maps.proto.vectordata2.tile.Tile.PolylineObjects.decode(reader, reader.uint32());
                                    break;
                                case 4:
                                    message.polygons = $root.yandex.maps.proto.vectordata2.tile.Tile.PolygonObjects.decode(reader, reader.uint32());
                                    break;
                                case 5:
                                    message.pointLabels = $root.yandex.maps.proto.vectordata2.tile.Tile.StraightLabels.decode(reader, reader.uint32());
                                    break;
                                case 6:
                                    message.polylineLabels = $root.yandex.maps.proto.vectordata2.tile.Tile.CurvedLabels.decode(reader, reader.uint32());
                                    break;
                                case 8:
                                    if (!(message.layers && message.layers.length))
                                        message.layers = [];
                                    message.layers.push($root.yandex.maps.proto.vectordata2.tile.Tile.Layer.decode(reader, reader.uint32()));
                                    break;
                                case 9:
                                    if (!(message.indoorPlanId && message.indoorPlanId.length))
                                        message.indoorPlanId = [];
                                    message.indoorPlanId.push(reader.string());
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        Tile.PointObjects = (function() {

                            /**
                             * Properties of a PointObjects.
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile
                             * @interface IPointObjects
                             * @property {Array.<number>|null} [coordsx] PointObjects coordsx
                             * @property {Array.<number>|null} [coordsy] PointObjects coordsy
                             * @property {Array.<number>|null} [classId] PointObjects classId
                             * @property {Array.<number>|null} [zOrder] PointObjects zOrder
                             */

                            /**
                             * Constructs a new PointObjects.
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile
                             * @classdesc Represents a PointObjects.
                             * @implements IPointObjects
                             * @constructor
                             * @param {yandex.maps.proto.vectordata2.tile.Tile.IPointObjects=} [properties] Properties to set
                             */
                            function PointObjects(properties) {
                                this.coordsx = [];
                                this.coordsy = [];
                                this.classId = [];
                                this.zOrder = [];
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * PointObjects coordsx.
                             * @member {Array.<number>} coordsx
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile.PointObjects
                             * @instance
                             */
                            PointObjects.prototype.coordsx = $util.emptyArray;

                            /**
                             * PointObjects coordsy.
                             * @member {Array.<number>} coordsy
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile.PointObjects
                             * @instance
                             */
                            PointObjects.prototype.coordsy = $util.emptyArray;

                            /**
                             * PointObjects classId.
                             * @member {Array.<number>} classId
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile.PointObjects
                             * @instance
                             */
                            PointObjects.prototype.classId = $util.emptyArray;

                            /**
                             * PointObjects zOrder.
                             * @member {Array.<number>} zOrder
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile.PointObjects
                             * @instance
                             */
                            PointObjects.prototype.zOrder = $util.emptyArray;

                            /**
                             * Decodes a PointObjects message from the specified reader or buffer.
                             * @function decode
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile.PointObjects
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {yandex.maps.proto.vectordata2.tile.Tile.PointObjects} PointObjects
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            PointObjects.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.yandex.maps.proto.vectordata2.tile.Tile.PointObjects();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        if (!(message.coordsx && message.coordsx.length))
                                            message.coordsx = [];
                                        if ((tag & 7) === 2) {
                                            var end2 = reader.uint32() + reader.pos;
                                            while (reader.pos < end2)
                                                message.coordsx.push(reader.sint32());
                                        } else
                                            message.coordsx.push(reader.sint32());
                                        break;
                                    case 2:
                                        if (!(message.coordsy && message.coordsy.length))
                                            message.coordsy = [];
                                        if ((tag & 7) === 2) {
                                            var end2 = reader.uint32() + reader.pos;
                                            while (reader.pos < end2)
                                                message.coordsy.push(reader.sint32());
                                        } else
                                            message.coordsy.push(reader.sint32());
                                        break;
                                    case 3:
                                        if (!(message.classId && message.classId.length))
                                            message.classId = [];
                                        if ((tag & 7) === 2) {
                                            var end2 = reader.uint32() + reader.pos;
                                            while (reader.pos < end2)
                                                message.classId.push(reader.uint32());
                                        } else
                                            message.classId.push(reader.uint32());
                                        break;
                                    case 4:
                                        if (!(message.zOrder && message.zOrder.length))
                                            message.zOrder = [];
                                        if ((tag & 7) === 2) {
                                            var end2 = reader.uint32() + reader.pos;
                                            while (reader.pos < end2)
                                                message.zOrder.push(reader.sint32());
                                        } else
                                            message.zOrder.push(reader.sint32());
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            return PointObjects;
                        })();

                        Tile.PolylineObjects = (function() {

                            /**
                             * Properties of a PolylineObjects.
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile
                             * @interface IPolylineObjects
                             * @property {Array.<number>|null} [coordsx] PolylineObjects coordsx
                             * @property {Array.<number>|null} [coordsy] PolylineObjects coordsy
                             * @property {Array.<number>|null} [lineSize] PolylineObjects lineSize
                             * @property {Array.<number|Long>|null} [distance] PolylineObjects distance
                             * @property {Array.<number>|null} [classId] PolylineObjects classId
                             * @property {Array.<number>|null} [pointVisibility] PolylineObjects pointVisibility
                             * @property {Array.<number>|null} [zOrderBegin] PolylineObjects zOrderBegin
                             * @property {Array.<number>|null} [zOrderEnd] PolylineObjects zOrderEnd
                             */

                            /**
                             * Constructs a new PolylineObjects.
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile
                             * @classdesc Represents a PolylineObjects.
                             * @implements IPolylineObjects
                             * @constructor
                             * @param {yandex.maps.proto.vectordata2.tile.Tile.IPolylineObjects=} [properties] Properties to set
                             */
                            function PolylineObjects(properties) {
                                this.coordsx = [];
                                this.coordsy = [];
                                this.lineSize = [];
                                this.distance = [];
                                this.classId = [];
                                this.pointVisibility = [];
                                this.zOrderBegin = [];
                                this.zOrderEnd = [];
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * PolylineObjects coordsx.
                             * @member {Array.<number>} coordsx
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile.PolylineObjects
                             * @instance
                             */
                            PolylineObjects.prototype.coordsx = $util.emptyArray;

                            /**
                             * PolylineObjects coordsy.
                             * @member {Array.<number>} coordsy
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile.PolylineObjects
                             * @instance
                             */
                            PolylineObjects.prototype.coordsy = $util.emptyArray;

                            /**
                             * PolylineObjects lineSize.
                             * @member {Array.<number>} lineSize
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile.PolylineObjects
                             * @instance
                             */
                            PolylineObjects.prototype.lineSize = $util.emptyArray;

                            /**
                             * PolylineObjects distance.
                             * @member {Array.<number|Long>} distance
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile.PolylineObjects
                             * @instance
                             */
                            PolylineObjects.prototype.distance = $util.emptyArray;

                            /**
                             * PolylineObjects classId.
                             * @member {Array.<number>} classId
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile.PolylineObjects
                             * @instance
                             */
                            PolylineObjects.prototype.classId = $util.emptyArray;

                            /**
                             * PolylineObjects pointVisibility.
                             * @member {Array.<number>} pointVisibility
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile.PolylineObjects
                             * @instance
                             */
                            PolylineObjects.prototype.pointVisibility = $util.emptyArray;

                            /**
                             * PolylineObjects zOrderBegin.
                             * @member {Array.<number>} zOrderBegin
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile.PolylineObjects
                             * @instance
                             */
                            PolylineObjects.prototype.zOrderBegin = $util.emptyArray;

                            /**
                             * PolylineObjects zOrderEnd.
                             * @member {Array.<number>} zOrderEnd
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile.PolylineObjects
                             * @instance
                             */
                            PolylineObjects.prototype.zOrderEnd = $util.emptyArray;

                            /**
                             * Decodes a PolylineObjects message from the specified reader or buffer.
                             * @function decode
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile.PolylineObjects
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {yandex.maps.proto.vectordata2.tile.Tile.PolylineObjects} PolylineObjects
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            PolylineObjects.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.yandex.maps.proto.vectordata2.tile.Tile.PolylineObjects();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        if (!(message.coordsx && message.coordsx.length))
                                            message.coordsx = [];
                                        if ((tag & 7) === 2) {
                                            var end2 = reader.uint32() + reader.pos;
                                            while (reader.pos < end2)
                                                message.coordsx.push(reader.sint32());
                                        } else
                                            message.coordsx.push(reader.sint32());
                                        break;
                                    case 2:
                                        if (!(message.coordsy && message.coordsy.length))
                                            message.coordsy = [];
                                        if ((tag & 7) === 2) {
                                            var end2 = reader.uint32() + reader.pos;
                                            while (reader.pos < end2)
                                                message.coordsy.push(reader.sint32());
                                        } else
                                            message.coordsy.push(reader.sint32());
                                        break;
                                    case 3:
                                        if (!(message.lineSize && message.lineSize.length))
                                            message.lineSize = [];
                                        if ((tag & 7) === 2) {
                                            var end2 = reader.uint32() + reader.pos;
                                            while (reader.pos < end2)
                                                message.lineSize.push(reader.uint32());
                                        } else
                                            message.lineSize.push(reader.uint32());
                                        break;
                                    case 4:
                                        if (!(message.distance && message.distance.length))
                                            message.distance = [];
                                        if ((tag & 7) === 2) {
                                            var end2 = reader.uint32() + reader.pos;
                                            while (reader.pos < end2)
                                                message.distance.push(reader.uint64());
                                        } else
                                            message.distance.push(reader.uint64());
                                        break;
                                    case 5:
                                        if (!(message.classId && message.classId.length))
                                            message.classId = [];
                                        if ((tag & 7) === 2) {
                                            var end2 = reader.uint32() + reader.pos;
                                            while (reader.pos < end2)
                                                message.classId.push(reader.uint32());
                                        } else
                                            message.classId.push(reader.uint32());
                                        break;
                                    case 6:
                                        if (!(message.pointVisibility && message.pointVisibility.length))
                                            message.pointVisibility = [];
                                        if ((tag & 7) === 2) {
                                            var end2 = reader.uint32() + reader.pos;
                                            while (reader.pos < end2)
                                                message.pointVisibility.push(reader.uint32());
                                        } else
                                            message.pointVisibility.push(reader.uint32());
                                        break;
                                    case 7:
                                        if (!(message.zOrderBegin && message.zOrderBegin.length))
                                            message.zOrderBegin = [];
                                        if ((tag & 7) === 2) {
                                            var end2 = reader.uint32() + reader.pos;
                                            while (reader.pos < end2)
                                                message.zOrderBegin.push(reader.sint32());
                                        } else
                                            message.zOrderBegin.push(reader.sint32());
                                        break;
                                    case 8:
                                        if (!(message.zOrderEnd && message.zOrderEnd.length))
                                            message.zOrderEnd = [];
                                        if ((tag & 7) === 2) {
                                            var end2 = reader.uint32() + reader.pos;
                                            while (reader.pos < end2)
                                                message.zOrderEnd.push(reader.sint32());
                                        } else
                                            message.zOrderEnd.push(reader.sint32());
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            return PolylineObjects;
                        })();

                        Tile.PolygonObjects = (function() {

                            /**
                             * Properties of a PolygonObjects.
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile
                             * @interface IPolygonObjects
                             * @property {Array.<number>|null} [coordsx] PolygonObjects coordsx
                             * @property {Array.<number>|null} [coordsy] PolygonObjects coordsy
                             * @property {Array.<number>|null} [classId] PolygonObjects classId
                             * @property {Array.<number>|null} [ringCount] PolygonObjects ringCount
                             * @property {Array.<number>|null} [ringSize] PolygonObjects ringSize
                             * @property {Array.<number>|null} [contourIndex] PolygonObjects contourIndex
                             * @property {Array.<number>|null} [contourCount] PolygonObjects contourCount
                             * @property {Array.<number>|null} [pointVisibility] PolygonObjects pointVisibility
                             * @property {Array.<number>|null} [height] PolygonObjects height
                             * @property {Array.<number>|null} [zOrder] PolygonObjects zOrder
                             * @property {Array.<yandex.maps.proto.vectordata2.tile.Tile.PolygonObjects.Mesh>|null} [mesh] PolygonObjects mesh
                             */

                            /**
                             * Constructs a new PolygonObjects.
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile
                             * @classdesc Represents a PolygonObjects.
                             * @implements IPolygonObjects
                             * @constructor
                             * @param {yandex.maps.proto.vectordata2.tile.Tile.IPolygonObjects=} [properties] Properties to set
                             */
                            function PolygonObjects(properties) {
                                this.coordsx = [];
                                this.coordsy = [];
                                this.classId = [];
                                this.ringCount = [];
                                this.ringSize = [];
                                this.contourIndex = [];
                                this.contourCount = [];
                                this.pointVisibility = [];
                                this.height = [];
                                this.zOrder = [];
                                this.mesh = [];
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * PolygonObjects coordsx.
                             * @member {Array.<number>} coordsx
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile.PolygonObjects
                             * @instance
                             */
                            PolygonObjects.prototype.coordsx = $util.emptyArray;

                            /**
                             * PolygonObjects coordsy.
                             * @member {Array.<number>} coordsy
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile.PolygonObjects
                             * @instance
                             */
                            PolygonObjects.prototype.coordsy = $util.emptyArray;

                            /**
                             * PolygonObjects classId.
                             * @member {Array.<number>} classId
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile.PolygonObjects
                             * @instance
                             */
                            PolygonObjects.prototype.classId = $util.emptyArray;

                            /**
                             * PolygonObjects ringCount.
                             * @member {Array.<number>} ringCount
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile.PolygonObjects
                             * @instance
                             */
                            PolygonObjects.prototype.ringCount = $util.emptyArray;

                            /**
                             * PolygonObjects ringSize.
                             * @member {Array.<number>} ringSize
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile.PolygonObjects
                             * @instance
                             */
                            PolygonObjects.prototype.ringSize = $util.emptyArray;

                            /**
                             * PolygonObjects contourIndex.
                             * @member {Array.<number>} contourIndex
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile.PolygonObjects
                             * @instance
                             */
                            PolygonObjects.prototype.contourIndex = $util.emptyArray;

                            /**
                             * PolygonObjects contourCount.
                             * @member {Array.<number>} contourCount
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile.PolygonObjects
                             * @instance
                             */
                            PolygonObjects.prototype.contourCount = $util.emptyArray;

                            /**
                             * PolygonObjects pointVisibility.
                             * @member {Array.<number>} pointVisibility
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile.PolygonObjects
                             * @instance
                             */
                            PolygonObjects.prototype.pointVisibility = $util.emptyArray;

                            /**
                             * PolygonObjects height.
                             * @member {Array.<number>} height
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile.PolygonObjects
                             * @instance
                             */
                            PolygonObjects.prototype.height = $util.emptyArray;

                            /**
                             * PolygonObjects zOrder.
                             * @member {Array.<number>} zOrder
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile.PolygonObjects
                             * @instance
                             */
                            PolygonObjects.prototype.zOrder = $util.emptyArray;

                            /**
                             * PolygonObjects mesh.
                             * @member {Array.<yandex.maps.proto.vectordata2.tile.Tile.PolygonObjects.Mesh>} mesh
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile.PolygonObjects
                             * @instance
                             */
                            PolygonObjects.prototype.mesh = $util.emptyArray;

                            /**
                             * Decodes a PolygonObjects message from the specified reader or buffer.
                             * @function decode
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile.PolygonObjects
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {yandex.maps.proto.vectordata2.tile.Tile.PolygonObjects} PolygonObjects
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            PolygonObjects.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.yandex.maps.proto.vectordata2.tile.Tile.PolygonObjects();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        if (!(message.coordsx && message.coordsx.length))
                                            message.coordsx = [];
                                        if ((tag & 7) === 2) {
                                            var end2 = reader.uint32() + reader.pos;
                                            while (reader.pos < end2)
                                                message.coordsx.push(reader.sint32());
                                        } else
                                            message.coordsx.push(reader.sint32());
                                        break;
                                    case 2:
                                        if (!(message.coordsy && message.coordsy.length))
                                            message.coordsy = [];
                                        if ((tag & 7) === 2) {
                                            var end2 = reader.uint32() + reader.pos;
                                            while (reader.pos < end2)
                                                message.coordsy.push(reader.sint32());
                                        } else
                                            message.coordsy.push(reader.sint32());
                                        break;
                                    case 3:
                                        if (!(message.classId && message.classId.length))
                                            message.classId = [];
                                        if ((tag & 7) === 2) {
                                            var end2 = reader.uint32() + reader.pos;
                                            while (reader.pos < end2)
                                                message.classId.push(reader.uint32());
                                        } else
                                            message.classId.push(reader.uint32());
                                        break;
                                    case 4:
                                        if (!(message.ringCount && message.ringCount.length))
                                            message.ringCount = [];
                                        if ((tag & 7) === 2) {
                                            var end2 = reader.uint32() + reader.pos;
                                            while (reader.pos < end2)
                                                message.ringCount.push(reader.uint32());
                                        } else
                                            message.ringCount.push(reader.uint32());
                                        break;
                                    case 5:
                                        if (!(message.ringSize && message.ringSize.length))
                                            message.ringSize = [];
                                        if ((tag & 7) === 2) {
                                            var end2 = reader.uint32() + reader.pos;
                                            while (reader.pos < end2)
                                                message.ringSize.push(reader.uint32());
                                        } else
                                            message.ringSize.push(reader.uint32());
                                        break;
                                    case 6:
                                        if (!(message.contourIndex && message.contourIndex.length))
                                            message.contourIndex = [];
                                        if ((tag & 7) === 2) {
                                            var end2 = reader.uint32() + reader.pos;
                                            while (reader.pos < end2)
                                                message.contourIndex.push(reader.sint32());
                                        } else
                                            message.contourIndex.push(reader.sint32());
                                        break;
                                    case 7:
                                        if (!(message.contourCount && message.contourCount.length))
                                            message.contourCount = [];
                                        if ((tag & 7) === 2) {
                                            var end2 = reader.uint32() + reader.pos;
                                            while (reader.pos < end2)
                                                message.contourCount.push(reader.sint32());
                                        } else
                                            message.contourCount.push(reader.sint32());
                                        break;
                                    case 8:
                                        if (!(message.pointVisibility && message.pointVisibility.length))
                                            message.pointVisibility = [];
                                        if ((tag & 7) === 2) {
                                            var end2 = reader.uint32() + reader.pos;
                                            while (reader.pos < end2)
                                                message.pointVisibility.push(reader.uint32());
                                        } else
                                            message.pointVisibility.push(reader.uint32());
                                        break;
                                    case 9:
                                        if (!(message.height && message.height.length))
                                            message.height = [];
                                        if ((tag & 7) === 2) {
                                            var end2 = reader.uint32() + reader.pos;
                                            while (reader.pos < end2)
                                                message.height.push(reader.sint32());
                                        } else
                                            message.height.push(reader.sint32());
                                        break;
                                    case 10:
                                        if (!(message.zOrder && message.zOrder.length))
                                            message.zOrder = [];
                                        if ((tag & 7) === 2) {
                                            var end2 = reader.uint32() + reader.pos;
                                            while (reader.pos < end2)
                                                message.zOrder.push(reader.sint32());
                                        } else
                                            message.zOrder.push(reader.sint32());
                                        break;
                                    case 11:
                                        if (!(message.mesh && message.mesh.length))
                                            message.mesh = [];
                                        message.mesh.push($root.yandex.maps.proto.vectordata2.tile.Tile.PolygonObjects.Mesh.decode(reader, reader.uint32()));
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            PolygonObjects.BBox = (function() {

                                /**
                                 * Properties of a BBox.
                                 * @memberof yandex.maps.proto.vectordata2.tile.Tile.PolygonObjects
                                 * @interface IBBox
                                 * @property {number|null} [minX] BBox minX
                                 * @property {number|null} [minY] BBox minY
                                 * @property {number|null} [maxX] BBox maxX
                                 * @property {number|null} [maxY] BBox maxY
                                 */

                                /**
                                 * Constructs a new BBox.
                                 * @memberof yandex.maps.proto.vectordata2.tile.Tile.PolygonObjects
                                 * @classdesc Represents a BBox.
                                 * @implements IBBox
                                 * @constructor
                                 * @param {yandex.maps.proto.vectordata2.tile.Tile.PolygonObjects.IBBox=} [properties] Properties to set
                                 */
                                function BBox(properties) {
                                    if (properties)
                                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                            if (properties[keys[i]] != null)
                                                this[keys[i]] = properties[keys[i]];
                                }

                                /**
                                 * BBox minX.
                                 * @member {number} minX
                                 * @memberof yandex.maps.proto.vectordata2.tile.Tile.PolygonObjects.BBox
                                 * @instance
                                 */
                                BBox.prototype.minX = 0;

                                /**
                                 * BBox minY.
                                 * @member {number} minY
                                 * @memberof yandex.maps.proto.vectordata2.tile.Tile.PolygonObjects.BBox
                                 * @instance
                                 */
                                BBox.prototype.minY = 0;

                                /**
                                 * BBox maxX.
                                 * @member {number} maxX
                                 * @memberof yandex.maps.proto.vectordata2.tile.Tile.PolygonObjects.BBox
                                 * @instance
                                 */
                                BBox.prototype.maxX = 0;

                                /**
                                 * BBox maxY.
                                 * @member {number} maxY
                                 * @memberof yandex.maps.proto.vectordata2.tile.Tile.PolygonObjects.BBox
                                 * @instance
                                 */
                                BBox.prototype.maxY = 0;

                                /**
                                 * Decodes a BBox message from the specified reader or buffer.
                                 * @function decode
                                 * @memberof yandex.maps.proto.vectordata2.tile.Tile.PolygonObjects.BBox
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @param {number} [length] Message length if known beforehand
                                 * @returns {yandex.maps.proto.vectordata2.tile.Tile.PolygonObjects.BBox} BBox
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                BBox.decode = function decode(reader, length) {
                                    if (!(reader instanceof $Reader))
                                        reader = $Reader.create(reader);
                                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.yandex.maps.proto.vectordata2.tile.Tile.PolygonObjects.BBox();
                                    while (reader.pos < end) {
                                        var tag = reader.uint32();
                                        switch (tag >>> 3) {
                                        case 1:
                                            message.minX = reader.sint32();
                                            break;
                                        case 2:
                                            message.minY = reader.sint32();
                                            break;
                                        case 3:
                                            message.maxX = reader.sint32();
                                            break;
                                        case 4:
                                            message.maxY = reader.sint32();
                                            break;
                                        default:
                                            reader.skipType(tag & 7);
                                            break;
                                        }
                                    }
                                    return message;
                                };

                                return BBox;
                            })();

                            PolygonObjects.Mesh = (function() {

                                /**
                                 * Properties of a Mesh.
                                 * @memberof yandex.maps.proto.vectordata2.tile.Tile.PolygonObjects
                                 * @interface IMesh
                                 * @property {number|null} [polygonId] Mesh polygonId
                                 * @property {string|null} [meshId] Mesh meshId
                                 * @property {yandex.maps.proto.vectordata2.tile.Tile.PolygonObjects.BBox|null} [bbox] Mesh bbox
                                 * @property {string|null} [objectId] Mesh objectId
                                 */

                                /**
                                 * Constructs a new Mesh.
                                 * @memberof yandex.maps.proto.vectordata2.tile.Tile.PolygonObjects
                                 * @classdesc Represents a Mesh.
                                 * @implements IMesh
                                 * @constructor
                                 * @param {yandex.maps.proto.vectordata2.tile.Tile.PolygonObjects.IMesh=} [properties] Properties to set
                                 */
                                function Mesh(properties) {
                                    if (properties)
                                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                            if (properties[keys[i]] != null)
                                                this[keys[i]] = properties[keys[i]];
                                }

                                /**
                                 * Mesh polygonId.
                                 * @member {number} polygonId
                                 * @memberof yandex.maps.proto.vectordata2.tile.Tile.PolygonObjects.Mesh
                                 * @instance
                                 */
                                Mesh.prototype.polygonId = 0;

                                /**
                                 * Mesh meshId.
                                 * @member {string} meshId
                                 * @memberof yandex.maps.proto.vectordata2.tile.Tile.PolygonObjects.Mesh
                                 * @instance
                                 */
                                Mesh.prototype.meshId = "";

                                /**
                                 * Mesh bbox.
                                 * @member {yandex.maps.proto.vectordata2.tile.Tile.PolygonObjects.BBox|null|undefined} bbox
                                 * @memberof yandex.maps.proto.vectordata2.tile.Tile.PolygonObjects.Mesh
                                 * @instance
                                 */
                                Mesh.prototype.bbox = null;

                                /**
                                 * Mesh objectId.
                                 * @member {string} objectId
                                 * @memberof yandex.maps.proto.vectordata2.tile.Tile.PolygonObjects.Mesh
                                 * @instance
                                 */
                                Mesh.prototype.objectId = "";

                                /**
                                 * Decodes a Mesh message from the specified reader or buffer.
                                 * @function decode
                                 * @memberof yandex.maps.proto.vectordata2.tile.Tile.PolygonObjects.Mesh
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @param {number} [length] Message length if known beforehand
                                 * @returns {yandex.maps.proto.vectordata2.tile.Tile.PolygonObjects.Mesh} Mesh
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                Mesh.decode = function decode(reader, length) {
                                    if (!(reader instanceof $Reader))
                                        reader = $Reader.create(reader);
                                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.yandex.maps.proto.vectordata2.tile.Tile.PolygonObjects.Mesh();
                                    while (reader.pos < end) {
                                        var tag = reader.uint32();
                                        switch (tag >>> 3) {
                                        case 1:
                                            message.polygonId = reader.uint32();
                                            break;
                                        case 2:
                                            message.meshId = reader.string();
                                            break;
                                        case 3:
                                            message.bbox = $root.yandex.maps.proto.vectordata2.tile.Tile.PolygonObjects.BBox.decode(reader, reader.uint32());
                                            break;
                                        case 4:
                                            message.objectId = reader.string();
                                            break;
                                        default:
                                            reader.skipType(tag & 7);
                                            break;
                                        }
                                    }
                                    return message;
                                };

                                return Mesh;
                            })();

                            return PolygonObjects;
                        })();

                        Tile.ShapedString = (function() {

                            /**
                             * Properties of a ShapedString.
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile
                             * @interface IShapedString
                             * @property {Array.<number>|null} [glyphs] ShapedString glyphs
                             */

                            /**
                             * Constructs a new ShapedString.
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile
                             * @classdesc Represents a ShapedString.
                             * @implements IShapedString
                             * @constructor
                             * @param {yandex.maps.proto.vectordata2.tile.Tile.IShapedString=} [properties] Properties to set
                             */
                            function ShapedString(properties) {
                                this.glyphs = [];
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * ShapedString glyphs.
                             * @member {Array.<number>} glyphs
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile.ShapedString
                             * @instance
                             */
                            ShapedString.prototype.glyphs = $util.emptyArray;

                            /**
                             * Decodes a ShapedString message from the specified reader or buffer.
                             * @function decode
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile.ShapedString
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {yandex.maps.proto.vectordata2.tile.Tile.ShapedString} ShapedString
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            ShapedString.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.yandex.maps.proto.vectordata2.tile.Tile.ShapedString();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        if (!(message.glyphs && message.glyphs.length))
                                            message.glyphs = [];
                                        if ((tag & 7) === 2) {
                                            var end2 = reader.uint32() + reader.pos;
                                            while (reader.pos < end2)
                                                message.glyphs.push(reader.uint32());
                                        } else
                                            message.glyphs.push(reader.uint32());
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            return ShapedString;
                        })();

                        Tile.ShapedText = (function() {

                            /**
                             * Properties of a ShapedText.
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile
                             * @interface IShapedText
                             * @property {Array.<yandex.maps.proto.vectordata2.tile.Tile.ShapedString>|null} [strings] ShapedText strings
                             */

                            /**
                             * Constructs a new ShapedText.
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile
                             * @classdesc Represents a ShapedText.
                             * @implements IShapedText
                             * @constructor
                             * @param {yandex.maps.proto.vectordata2.tile.Tile.IShapedText=} [properties] Properties to set
                             */
                            function ShapedText(properties) {
                                this.strings = [];
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * ShapedText strings.
                             * @member {Array.<yandex.maps.proto.vectordata2.tile.Tile.ShapedString>} strings
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile.ShapedText
                             * @instance
                             */
                            ShapedText.prototype.strings = $util.emptyArray;

                            /**
                             * Decodes a ShapedText message from the specified reader or buffer.
                             * @function decode
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile.ShapedText
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {yandex.maps.proto.vectordata2.tile.Tile.ShapedText} ShapedText
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            ShapedText.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.yandex.maps.proto.vectordata2.tile.Tile.ShapedText();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        if (!(message.strings && message.strings.length))
                                            message.strings = [];
                                        message.strings.push($root.yandex.maps.proto.vectordata2.tile.Tile.ShapedString.decode(reader, reader.uint32()));
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            return ShapedText;
                        })();

                        Tile.StraightLabels = (function() {

                            /**
                             * Properties of a StraightLabels.
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile
                             * @interface IStraightLabels
                             * @property {Array.<number>|null} [classId] StraightLabels classId
                             * @property {Array.<number>|null} [centerX] StraightLabels centerX
                             * @property {Array.<number>|null} [centerY] StraightLabels centerY
                             * @property {Array.<number>|null} [offsetX] StraightLabels offsetX
                             * @property {Array.<number>|null} [offsetY] StraightLabels offsetY
                             * @property {Array.<yandex.maps.proto.vectordata2.tile.Tile.ShapedText>|null} [text] StraightLabels text
                             * @property {Array.<yandex.maps.proto.vectordata2.tile.Tile.ShapedText>|null} [textAlt] StraightLabels textAlt
                             * @property {Array.<number>|null} [priority] StraightLabels priority
                             * @property {Array.<yandex.maps.proto.vectordata2.tile.Tile.StraightLabels.AlignType>|null} [align] StraightLabels align
                             */

                            /**
                             * Constructs a new StraightLabels.
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile
                             * @classdesc Represents a StraightLabels.
                             * @implements IStraightLabels
                             * @constructor
                             * @param {yandex.maps.proto.vectordata2.tile.Tile.IStraightLabels=} [properties] Properties to set
                             */
                            function StraightLabels(properties) {
                                this.classId = [];
                                this.centerX = [];
                                this.centerY = [];
                                this.offsetX = [];
                                this.offsetY = [];
                                this.text = [];
                                this.textAlt = [];
                                this.priority = [];
                                this.align = [];
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * StraightLabels classId.
                             * @member {Array.<number>} classId
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile.StraightLabels
                             * @instance
                             */
                            StraightLabels.prototype.classId = $util.emptyArray;

                            /**
                             * StraightLabels centerX.
                             * @member {Array.<number>} centerX
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile.StraightLabels
                             * @instance
                             */
                            StraightLabels.prototype.centerX = $util.emptyArray;

                            /**
                             * StraightLabels centerY.
                             * @member {Array.<number>} centerY
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile.StraightLabels
                             * @instance
                             */
                            StraightLabels.prototype.centerY = $util.emptyArray;

                            /**
                             * StraightLabels offsetX.
                             * @member {Array.<number>} offsetX
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile.StraightLabels
                             * @instance
                             */
                            StraightLabels.prototype.offsetX = $util.emptyArray;

                            /**
                             * StraightLabels offsetY.
                             * @member {Array.<number>} offsetY
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile.StraightLabels
                             * @instance
                             */
                            StraightLabels.prototype.offsetY = $util.emptyArray;

                            /**
                             * StraightLabels text.
                             * @member {Array.<yandex.maps.proto.vectordata2.tile.Tile.ShapedText>} text
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile.StraightLabels
                             * @instance
                             */
                            StraightLabels.prototype.text = $util.emptyArray;

                            /**
                             * StraightLabels textAlt.
                             * @member {Array.<yandex.maps.proto.vectordata2.tile.Tile.ShapedText>} textAlt
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile.StraightLabels
                             * @instance
                             */
                            StraightLabels.prototype.textAlt = $util.emptyArray;

                            /**
                             * StraightLabels priority.
                             * @member {Array.<number>} priority
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile.StraightLabels
                             * @instance
                             */
                            StraightLabels.prototype.priority = $util.emptyArray;

                            /**
                             * StraightLabels align.
                             * @member {Array.<yandex.maps.proto.vectordata2.tile.Tile.StraightLabels.AlignType>} align
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile.StraightLabels
                             * @instance
                             */
                            StraightLabels.prototype.align = $util.emptyArray;

                            /**
                             * Decodes a StraightLabels message from the specified reader or buffer.
                             * @function decode
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile.StraightLabels
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {yandex.maps.proto.vectordata2.tile.Tile.StraightLabels} StraightLabels
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            StraightLabels.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.yandex.maps.proto.vectordata2.tile.Tile.StraightLabels();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        if (!(message.classId && message.classId.length))
                                            message.classId = [];
                                        if ((tag & 7) === 2) {
                                            var end2 = reader.uint32() + reader.pos;
                                            while (reader.pos < end2)
                                                message.classId.push(reader.uint32());
                                        } else
                                            message.classId.push(reader.uint32());
                                        break;
                                    case 2:
                                        if (!(message.centerX && message.centerX.length))
                                            message.centerX = [];
                                        if ((tag & 7) === 2) {
                                            var end2 = reader.uint32() + reader.pos;
                                            while (reader.pos < end2)
                                                message.centerX.push(reader.sint32());
                                        } else
                                            message.centerX.push(reader.sint32());
                                        break;
                                    case 3:
                                        if (!(message.centerY && message.centerY.length))
                                            message.centerY = [];
                                        if ((tag & 7) === 2) {
                                            var end2 = reader.uint32() + reader.pos;
                                            while (reader.pos < end2)
                                                message.centerY.push(reader.sint32());
                                        } else
                                            message.centerY.push(reader.sint32());
                                        break;
                                    case 4:
                                        if (!(message.offsetX && message.offsetX.length))
                                            message.offsetX = [];
                                        if ((tag & 7) === 2) {
                                            var end2 = reader.uint32() + reader.pos;
                                            while (reader.pos < end2)
                                                message.offsetX.push(reader.sint32());
                                        } else
                                            message.offsetX.push(reader.sint32());
                                        break;
                                    case 5:
                                        if (!(message.offsetY && message.offsetY.length))
                                            message.offsetY = [];
                                        if ((tag & 7) === 2) {
                                            var end2 = reader.uint32() + reader.pos;
                                            while (reader.pos < end2)
                                                message.offsetY.push(reader.sint32());
                                        } else
                                            message.offsetY.push(reader.sint32());
                                        break;
                                    case 6:
                                        if (!(message.text && message.text.length))
                                            message.text = [];
                                        message.text.push($root.yandex.maps.proto.vectordata2.tile.Tile.ShapedText.decode(reader, reader.uint32()));
                                        break;
                                    case 7:
                                        if (!(message.textAlt && message.textAlt.length))
                                            message.textAlt = [];
                                        message.textAlt.push($root.yandex.maps.proto.vectordata2.tile.Tile.ShapedText.decode(reader, reader.uint32()));
                                        break;
                                    case 8:
                                        if (!(message.priority && message.priority.length))
                                            message.priority = [];
                                        if ((tag & 7) === 2) {
                                            var end2 = reader.uint32() + reader.pos;
                                            while (reader.pos < end2)
                                                message.priority.push(reader.sint32());
                                        } else
                                            message.priority.push(reader.sint32());
                                        break;
                                    case 9:
                                        if (!(message.align && message.align.length))
                                            message.align = [];
                                        if ((tag & 7) === 2) {
                                            var end2 = reader.uint32() + reader.pos;
                                            while (reader.pos < end2)
                                                message.align.push(reader.int32());
                                        } else
                                            message.align.push(reader.int32());
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            /**
                             * AlignType enum.
                             * @name yandex.maps.proto.vectordata2.tile.Tile.StraightLabels.AlignType
                             * @enum {string}
                             * @property {number} Left=0 Left value
                             * @property {number} Center=1 Center value
                             * @property {number} Right=2 Right value
                             */
                            StraightLabels.AlignType = (function() {
                                var valuesById = {}, values = Object.create(valuesById);
                                values[valuesById[0] = "Left"] = 0;
                                values[valuesById[1] = "Center"] = 1;
                                values[valuesById[2] = "Right"] = 2;
                                return values;
                            })();

                            return StraightLabels;
                        })();

                        Tile.CurvedLabels = (function() {

                            /**
                             * Properties of a CurvedLabels.
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile
                             * @interface ICurvedLabels
                             * @property {Array.<number>|null} [classId] CurvedLabels classId
                             * @property {Array.<yandex.maps.proto.vectordata2.tile.Tile.ShapedString>|null} [text] CurvedLabels text
                             * @property {Array.<yandex.maps.proto.vectordata2.tile.Tile.ShapedString>|null} [textAlt] CurvedLabels textAlt
                             * @property {Array.<number>|null} [priority] CurvedLabels priority
                             * @property {Array.<number>|null} [verticesCount] CurvedLabels verticesCount
                             * @property {Array.<number>|null} [vertexX] CurvedLabels vertexX
                             * @property {Array.<number>|null} [vertexY] CurvedLabels vertexY
                             */

                            /**
                             * Constructs a new CurvedLabels.
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile
                             * @classdesc Represents a CurvedLabels.
                             * @implements ICurvedLabels
                             * @constructor
                             * @param {yandex.maps.proto.vectordata2.tile.Tile.ICurvedLabels=} [properties] Properties to set
                             */
                            function CurvedLabels(properties) {
                                this.classId = [];
                                this.text = [];
                                this.textAlt = [];
                                this.priority = [];
                                this.verticesCount = [];
                                this.vertexX = [];
                                this.vertexY = [];
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * CurvedLabels classId.
                             * @member {Array.<number>} classId
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile.CurvedLabels
                             * @instance
                             */
                            CurvedLabels.prototype.classId = $util.emptyArray;

                            /**
                             * CurvedLabels text.
                             * @member {Array.<yandex.maps.proto.vectordata2.tile.Tile.ShapedString>} text
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile.CurvedLabels
                             * @instance
                             */
                            CurvedLabels.prototype.text = $util.emptyArray;

                            /**
                             * CurvedLabels textAlt.
                             * @member {Array.<yandex.maps.proto.vectordata2.tile.Tile.ShapedString>} textAlt
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile.CurvedLabels
                             * @instance
                             */
                            CurvedLabels.prototype.textAlt = $util.emptyArray;

                            /**
                             * CurvedLabels priority.
                             * @member {Array.<number>} priority
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile.CurvedLabels
                             * @instance
                             */
                            CurvedLabels.prototype.priority = $util.emptyArray;

                            /**
                             * CurvedLabels verticesCount.
                             * @member {Array.<number>} verticesCount
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile.CurvedLabels
                             * @instance
                             */
                            CurvedLabels.prototype.verticesCount = $util.emptyArray;

                            /**
                             * CurvedLabels vertexX.
                             * @member {Array.<number>} vertexX
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile.CurvedLabels
                             * @instance
                             */
                            CurvedLabels.prototype.vertexX = $util.emptyArray;

                            /**
                             * CurvedLabels vertexY.
                             * @member {Array.<number>} vertexY
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile.CurvedLabels
                             * @instance
                             */
                            CurvedLabels.prototype.vertexY = $util.emptyArray;

                            /**
                             * Decodes a CurvedLabels message from the specified reader or buffer.
                             * @function decode
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile.CurvedLabels
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {yandex.maps.proto.vectordata2.tile.Tile.CurvedLabels} CurvedLabels
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            CurvedLabels.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.yandex.maps.proto.vectordata2.tile.Tile.CurvedLabels();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        if (!(message.classId && message.classId.length))
                                            message.classId = [];
                                        if ((tag & 7) === 2) {
                                            var end2 = reader.uint32() + reader.pos;
                                            while (reader.pos < end2)
                                                message.classId.push(reader.uint32());
                                        } else
                                            message.classId.push(reader.uint32());
                                        break;
                                    case 2:
                                        if (!(message.text && message.text.length))
                                            message.text = [];
                                        message.text.push($root.yandex.maps.proto.vectordata2.tile.Tile.ShapedString.decode(reader, reader.uint32()));
                                        break;
                                    case 3:
                                        if (!(message.textAlt && message.textAlt.length))
                                            message.textAlt = [];
                                        message.textAlt.push($root.yandex.maps.proto.vectordata2.tile.Tile.ShapedString.decode(reader, reader.uint32()));
                                        break;
                                    case 4:
                                        if (!(message.priority && message.priority.length))
                                            message.priority = [];
                                        if ((tag & 7) === 2) {
                                            var end2 = reader.uint32() + reader.pos;
                                            while (reader.pos < end2)
                                                message.priority.push(reader.sint32());
                                        } else
                                            message.priority.push(reader.sint32());
                                        break;
                                    case 5:
                                        if (!(message.verticesCount && message.verticesCount.length))
                                            message.verticesCount = [];
                                        if ((tag & 7) === 2) {
                                            var end2 = reader.uint32() + reader.pos;
                                            while (reader.pos < end2)
                                                message.verticesCount.push(reader.uint32());
                                        } else
                                            message.verticesCount.push(reader.uint32());
                                        break;
                                    case 6:
                                        if (!(message.vertexX && message.vertexX.length))
                                            message.vertexX = [];
                                        if ((tag & 7) === 2) {
                                            var end2 = reader.uint32() + reader.pos;
                                            while (reader.pos < end2)
                                                message.vertexX.push(reader.sint32());
                                        } else
                                            message.vertexX.push(reader.sint32());
                                        break;
                                    case 7:
                                        if (!(message.vertexY && message.vertexY.length))
                                            message.vertexY = [];
                                        if ((tag & 7) === 2) {
                                            var end2 = reader.uint32() + reader.pos;
                                            while (reader.pos < end2)
                                                message.vertexY.push(reader.sint32());
                                        } else
                                            message.vertexY.push(reader.sint32());
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            return CurvedLabels;
                        })();

                        Tile.Layer = (function() {

                            /**
                             * Properties of a Layer.
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile
                             * @interface ILayer
                             * @property {string|null} [name] Layer name
                             * @property {Array.<string>|null} [ids] Layer ids
                             * @property {Array.<number>|null} [objectIndices] Layer objectIndices
                             * @property {Array.<string>|null} [keys] Layer keys
                             * @property {Array.<string>|null} [values] Layer values
                             */

                            /**
                             * Constructs a new Layer.
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile
                             * @classdesc Represents a Layer.
                             * @implements ILayer
                             * @constructor
                             * @param {yandex.maps.proto.vectordata2.tile.Tile.ILayer=} [properties] Properties to set
                             */
                            function Layer(properties) {
                                this.ids = [];
                                this.objectIndices = [];
                                this.keys = [];
                                this.values = [];
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * Layer name.
                             * @member {string} name
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile.Layer
                             * @instance
                             */
                            Layer.prototype.name = "";

                            /**
                             * Layer ids.
                             * @member {Array.<string>} ids
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile.Layer
                             * @instance
                             */
                            Layer.prototype.ids = $util.emptyArray;

                            /**
                             * Layer objectIndices.
                             * @member {Array.<number>} objectIndices
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile.Layer
                             * @instance
                             */
                            Layer.prototype.objectIndices = $util.emptyArray;

                            /**
                             * Layer keys.
                             * @member {Array.<string>} keys
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile.Layer
                             * @instance
                             */
                            Layer.prototype.keys = $util.emptyArray;

                            /**
                             * Layer values.
                             * @member {Array.<string>} values
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile.Layer
                             * @instance
                             */
                            Layer.prototype.values = $util.emptyArray;

                            /**
                             * Decodes a Layer message from the specified reader or buffer.
                             * @function decode
                             * @memberof yandex.maps.proto.vectordata2.tile.Tile.Layer
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {yandex.maps.proto.vectordata2.tile.Tile.Layer} Layer
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Layer.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.yandex.maps.proto.vectordata2.tile.Tile.Layer();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.name = reader.string();
                                        break;
                                    case 2:
                                        if (!(message.ids && message.ids.length))
                                            message.ids = [];
                                        message.ids.push(reader.string());
                                        break;
                                    case 3:
                                        if (!(message.objectIndices && message.objectIndices.length))
                                            message.objectIndices = [];
                                        if ((tag & 7) === 2) {
                                            var end2 = reader.uint32() + reader.pos;
                                            while (reader.pos < end2)
                                                message.objectIndices.push(reader.uint32());
                                        } else
                                            message.objectIndices.push(reader.uint32());
                                        break;
                                    case 4:
                                        if (!(message.keys && message.keys.length))
                                            message.keys = [];
                                        message.keys.push(reader.string());
                                        break;
                                    case 5:
                                        if (!(message.values && message.values.length))
                                            message.values = [];
                                        message.values.push(reader.string());
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            return Layer;
                        })();

                        return Tile;
                    })();

                    return tile;
                })();

                vectordata2.presentation = (function() {

                    /**
                     * Namespace presentation.
                     * @memberof yandex.maps.proto.vectordata2
                     * @namespace
                     */
                    var presentation = {};

                    presentation.Presentation = (function() {

                        /**
                         * Properties of a Presentation.
                         * @memberof yandex.maps.proto.vectordata2.presentation
                         * @interface IPresentation
                         * @property {Array.<yandex.maps.proto.vectordata2.presentation.Presentation.Class>|null} [classes] Presentation classes
                         * @property {string|null} [name] Presentation name
                         * @property {yandex.maps.proto.vectordata2.presentation.Presentation.Parameters|null} [params] Presentation params
                         */

                        /**
                         * Constructs a new Presentation.
                         * @memberof yandex.maps.proto.vectordata2.presentation
                         * @classdesc Represents a Presentation.
                         * @implements IPresentation
                         * @constructor
                         * @param {yandex.maps.proto.vectordata2.presentation.IPresentation=} [properties] Properties to set
                         */
                        function Presentation(properties) {
                            this.classes = [];
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Presentation classes.
                         * @member {Array.<yandex.maps.proto.vectordata2.presentation.Presentation.Class>} classes
                         * @memberof yandex.maps.proto.vectordata2.presentation.Presentation
                         * @instance
                         */
                        Presentation.prototype.classes = $util.emptyArray;

                        /**
                         * Presentation name.
                         * @member {string} name
                         * @memberof yandex.maps.proto.vectordata2.presentation.Presentation
                         * @instance
                         */
                        Presentation.prototype.name = "";

                        /**
                         * Presentation params.
                         * @member {yandex.maps.proto.vectordata2.presentation.Presentation.Parameters|null|undefined} params
                         * @memberof yandex.maps.proto.vectordata2.presentation.Presentation
                         * @instance
                         */
                        Presentation.prototype.params = null;

                        /**
                         * Decodes a Presentation message from the specified reader or buffer.
                         * @function decode
                         * @memberof yandex.maps.proto.vectordata2.presentation.Presentation
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {yandex.maps.proto.vectordata2.presentation.Presentation} Presentation
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Presentation.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.yandex.maps.proto.vectordata2.presentation.Presentation();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    if (!(message.classes && message.classes.length))
                                        message.classes = [];
                                    message.classes.push($root.yandex.maps.proto.vectordata2.presentation.Presentation.Class.decode(reader, reader.uint32()));
                                    break;
                                case 2:
                                    message.name = reader.string();
                                    break;
                                case 3:
                                    message.params = $root.yandex.maps.proto.vectordata2.presentation.Presentation.Parameters.decode(reader, reader.uint32());
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };

                        Presentation.Class = (function() {

                            /**
                             * Properties of a Class.
                             * @memberof yandex.maps.proto.vectordata2.presentation.Presentation
                             * @interface IClass
                             * @property {number|null} [id] Class id
                             * @property {string|null} [name] Class name
                             * @property {Array.<yandex.maps.proto.vectordata2.presentation.Presentation.Class.ZoomSlice>|null} [slices] Class slices
                             */

                            /**
                             * Constructs a new Class.
                             * @memberof yandex.maps.proto.vectordata2.presentation.Presentation
                             * @classdesc Represents a Class.
                             * @implements IClass
                             * @constructor
                             * @param {yandex.maps.proto.vectordata2.presentation.Presentation.IClass=} [properties] Properties to set
                             */
                            function Class(properties) {
                                this.slices = [];
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * Class id.
                             * @member {number} id
                             * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class
                             * @instance
                             */
                            Class.prototype.id = 0;

                            /**
                             * Class name.
                             * @member {string} name
                             * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class
                             * @instance
                             */
                            Class.prototype.name = "";

                            /**
                             * Class slices.
                             * @member {Array.<yandex.maps.proto.vectordata2.presentation.Presentation.Class.ZoomSlice>} slices
                             * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class
                             * @instance
                             */
                            Class.prototype.slices = $util.emptyArray;

                            /**
                             * Decodes a Class message from the specified reader or buffer.
                             * @function decode
                             * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {yandex.maps.proto.vectordata2.presentation.Presentation.Class} Class
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Class.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.yandex.maps.proto.vectordata2.presentation.Presentation.Class();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.id = reader.uint32();
                                        break;
                                    case 2:
                                        message.name = reader.string();
                                        break;
                                    case 3:
                                        if (!(message.slices && message.slices.length))
                                            message.slices = [];
                                        message.slices.push($root.yandex.maps.proto.vectordata2.presentation.Presentation.Class.ZoomSlice.decode(reader, reader.uint32()));
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            Class.ZoomRange = (function() {

                                /**
                                 * Properties of a ZoomRange.
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class
                                 * @interface IZoomRange
                                 * @property {number|null} [min] ZoomRange min
                                 * @property {number|null} [max] ZoomRange max
                                 */

                                /**
                                 * Constructs a new ZoomRange.
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class
                                 * @classdesc Represents a ZoomRange.
                                 * @implements IZoomRange
                                 * @constructor
                                 * @param {yandex.maps.proto.vectordata2.presentation.Presentation.Class.IZoomRange=} [properties] Properties to set
                                 */
                                function ZoomRange(properties) {
                                    if (properties)
                                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                            if (properties[keys[i]] != null)
                                                this[keys[i]] = properties[keys[i]];
                                }

                                /**
                                 * ZoomRange min.
                                 * @member {number} min
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.ZoomRange
                                 * @instance
                                 */
                                ZoomRange.prototype.min = 0;

                                /**
                                 * ZoomRange max.
                                 * @member {number} max
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.ZoomRange
                                 * @instance
                                 */
                                ZoomRange.prototype.max = 0;

                                /**
                                 * Decodes a ZoomRange message from the specified reader or buffer.
                                 * @function decode
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.ZoomRange
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @param {number} [length] Message length if known beforehand
                                 * @returns {yandex.maps.proto.vectordata2.presentation.Presentation.Class.ZoomRange} ZoomRange
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                ZoomRange.decode = function decode(reader, length) {
                                    if (!(reader instanceof $Reader))
                                        reader = $Reader.create(reader);
                                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.yandex.maps.proto.vectordata2.presentation.Presentation.Class.ZoomRange();
                                    while (reader.pos < end) {
                                        var tag = reader.uint32();
                                        switch (tag >>> 3) {
                                        case 1:
                                            message.min = reader.sint32();
                                            break;
                                        case 2:
                                            message.max = reader.sint32();
                                            break;
                                        default:
                                            reader.skipType(tag & 7);
                                            break;
                                        }
                                    }
                                    return message;
                                };

                                return ZoomRange;
                            })();

                            Class.Image = (function() {

                                /**
                                 * Properties of an Image.
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class
                                 * @interface IImage
                                 * @property {string|null} [id] Image id
                                 * @property {number|null} [width] Image width
                                 */

                                /**
                                 * Constructs a new Image.
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class
                                 * @classdesc Represents an Image.
                                 * @implements IImage
                                 * @constructor
                                 * @param {yandex.maps.proto.vectordata2.presentation.Presentation.Class.IImage=} [properties] Properties to set
                                 */
                                function Image(properties) {
                                    if (properties)
                                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                            if (properties[keys[i]] != null)
                                                this[keys[i]] = properties[keys[i]];
                                }

                                /**
                                 * Image id.
                                 * @member {string} id
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.Image
                                 * @instance
                                 */
                                Image.prototype.id = "";

                                /**
                                 * Image width.
                                 * @member {number} width
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.Image
                                 * @instance
                                 */
                                Image.prototype.width = 0;

                                /**
                                 * Decodes an Image message from the specified reader or buffer.
                                 * @function decode
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.Image
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @param {number} [length] Message length if known beforehand
                                 * @returns {yandex.maps.proto.vectordata2.presentation.Presentation.Class.Image} Image
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                Image.decode = function decode(reader, length) {
                                    if (!(reader instanceof $Reader))
                                        reader = $Reader.create(reader);
                                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.yandex.maps.proto.vectordata2.presentation.Presentation.Class.Image();
                                    while (reader.pos < end) {
                                        var tag = reader.uint32();
                                        switch (tag >>> 3) {
                                        case 1:
                                            message.id = reader.string();
                                            break;
                                        case 2:
                                            message.width = reader.float();
                                            break;
                                        default:
                                            reader.skipType(tag & 7);
                                            break;
                                        }
                                    }
                                    return message;
                                };

                                return Image;
                            })();

                            Class.PointStyle = (function() {

                                /**
                                 * Properties of a PointStyle.
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class
                                 * @interface IPointStyle
                                 * @property {yandex.maps.proto.vectordata2.presentation.Presentation.Class.Image|null} [icon] PointStyle icon
                                 * @property {number|null} [anchorX] PointStyle anchorX
                                 * @property {number|null} [anchorY] PointStyle anchorY
                                 * @property {yandex.maps.proto.vectordata2.presentation.Presentation.Class.Image|null} [selectedIcon] PointStyle selectedIcon
                                 * @property {number|null} [selectedAnchorX] PointStyle selectedAnchorX
                                 * @property {number|null} [selectedAnchorY] PointStyle selectedAnchorY
                                 */

                                /**
                                 * Constructs a new PointStyle.
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class
                                 * @classdesc Represents a PointStyle.
                                 * @implements IPointStyle
                                 * @constructor
                                 * @param {yandex.maps.proto.vectordata2.presentation.Presentation.Class.IPointStyle=} [properties] Properties to set
                                 */
                                function PointStyle(properties) {
                                    if (properties)
                                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                            if (properties[keys[i]] != null)
                                                this[keys[i]] = properties[keys[i]];
                                }

                                /**
                                 * PointStyle icon.
                                 * @member {yandex.maps.proto.vectordata2.presentation.Presentation.Class.Image|null|undefined} icon
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.PointStyle
                                 * @instance
                                 */
                                PointStyle.prototype.icon = null;

                                /**
                                 * PointStyle anchorX.
                                 * @member {number} anchorX
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.PointStyle
                                 * @instance
                                 */
                                PointStyle.prototype.anchorX = 0;

                                /**
                                 * PointStyle anchorY.
                                 * @member {number} anchorY
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.PointStyle
                                 * @instance
                                 */
                                PointStyle.prototype.anchorY = 0;

                                /**
                                 * PointStyle selectedIcon.
                                 * @member {yandex.maps.proto.vectordata2.presentation.Presentation.Class.Image|null|undefined} selectedIcon
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.PointStyle
                                 * @instance
                                 */
                                PointStyle.prototype.selectedIcon = null;

                                /**
                                 * PointStyle selectedAnchorX.
                                 * @member {number} selectedAnchorX
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.PointStyle
                                 * @instance
                                 */
                                PointStyle.prototype.selectedAnchorX = 0;

                                /**
                                 * PointStyle selectedAnchorY.
                                 * @member {number} selectedAnchorY
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.PointStyle
                                 * @instance
                                 */
                                PointStyle.prototype.selectedAnchorY = 0;

                                /**
                                 * Decodes a PointStyle message from the specified reader or buffer.
                                 * @function decode
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.PointStyle
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @param {number} [length] Message length if known beforehand
                                 * @returns {yandex.maps.proto.vectordata2.presentation.Presentation.Class.PointStyle} PointStyle
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                PointStyle.decode = function decode(reader, length) {
                                    if (!(reader instanceof $Reader))
                                        reader = $Reader.create(reader);
                                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.yandex.maps.proto.vectordata2.presentation.Presentation.Class.PointStyle();
                                    while (reader.pos < end) {
                                        var tag = reader.uint32();
                                        switch (tag >>> 3) {
                                        case 1:
                                            message.icon = $root.yandex.maps.proto.vectordata2.presentation.Presentation.Class.Image.decode(reader, reader.uint32());
                                            break;
                                        case 2:
                                            message.anchorX = reader.float();
                                            break;
                                        case 3:
                                            message.anchorY = reader.float();
                                            break;
                                        case 4:
                                            message.selectedIcon = $root.yandex.maps.proto.vectordata2.presentation.Presentation.Class.Image.decode(reader, reader.uint32());
                                            break;
                                        case 5:
                                            message.selectedAnchorX = reader.float();
                                            break;
                                        case 6:
                                            message.selectedAnchorY = reader.float();
                                            break;
                                        default:
                                            reader.skipType(tag & 7);
                                            break;
                                        }
                                    }
                                    return message;
                                };

                                return PointStyle;
                            })();

                            Class.DashItem = (function() {

                                /**
                                 * Properties of a DashItem.
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class
                                 * @interface IDashItem
                                 * @property {number|null} [fill] DashItem fill
                                 * @property {number|null} [gap] DashItem gap
                                 */

                                /**
                                 * Constructs a new DashItem.
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class
                                 * @classdesc Represents a DashItem.
                                 * @implements IDashItem
                                 * @constructor
                                 * @param {yandex.maps.proto.vectordata2.presentation.Presentation.Class.IDashItem=} [properties] Properties to set
                                 */
                                function DashItem(properties) {
                                    if (properties)
                                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                            if (properties[keys[i]] != null)
                                                this[keys[i]] = properties[keys[i]];
                                }

                                /**
                                 * DashItem fill.
                                 * @member {number} fill
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.DashItem
                                 * @instance
                                 */
                                DashItem.prototype.fill = 0;

                                /**
                                 * DashItem gap.
                                 * @member {number} gap
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.DashItem
                                 * @instance
                                 */
                                DashItem.prototype.gap = 0;

                                /**
                                 * Decodes a DashItem message from the specified reader or buffer.
                                 * @function decode
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.DashItem
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @param {number} [length] Message length if known beforehand
                                 * @returns {yandex.maps.proto.vectordata2.presentation.Presentation.Class.DashItem} DashItem
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                DashItem.decode = function decode(reader, length) {
                                    if (!(reader instanceof $Reader))
                                        reader = $Reader.create(reader);
                                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.yandex.maps.proto.vectordata2.presentation.Presentation.Class.DashItem();
                                    while (reader.pos < end) {
                                        var tag = reader.uint32();
                                        switch (tag >>> 3) {
                                        case 1:
                                            message.fill = reader.float();
                                            break;
                                        case 2:
                                            message.gap = reader.float();
                                            break;
                                        default:
                                            reader.skipType(tag & 7);
                                            break;
                                        }
                                    }
                                    return message;
                                };

                                return DashItem;
                            })();

                            Class.DashStyle = (function() {

                                /**
                                 * Properties of a DashStyle.
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class
                                 * @interface IDashStyle
                                 * @property {Array.<yandex.maps.proto.vectordata2.presentation.Presentation.Class.DashItem>|null} [dashes] DashStyle dashes
                                 */

                                /**
                                 * Constructs a new DashStyle.
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class
                                 * @classdesc Represents a DashStyle.
                                 * @implements IDashStyle
                                 * @constructor
                                 * @param {yandex.maps.proto.vectordata2.presentation.Presentation.Class.IDashStyle=} [properties] Properties to set
                                 */
                                function DashStyle(properties) {
                                    this.dashes = [];
                                    if (properties)
                                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                            if (properties[keys[i]] != null)
                                                this[keys[i]] = properties[keys[i]];
                                }

                                /**
                                 * DashStyle dashes.
                                 * @member {Array.<yandex.maps.proto.vectordata2.presentation.Presentation.Class.DashItem>} dashes
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.DashStyle
                                 * @instance
                                 */
                                DashStyle.prototype.dashes = $util.emptyArray;

                                /**
                                 * Decodes a DashStyle message from the specified reader or buffer.
                                 * @function decode
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.DashStyle
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @param {number} [length] Message length if known beforehand
                                 * @returns {yandex.maps.proto.vectordata2.presentation.Presentation.Class.DashStyle} DashStyle
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                DashStyle.decode = function decode(reader, length) {
                                    if (!(reader instanceof $Reader))
                                        reader = $Reader.create(reader);
                                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.yandex.maps.proto.vectordata2.presentation.Presentation.Class.DashStyle();
                                    while (reader.pos < end) {
                                        var tag = reader.uint32();
                                        switch (tag >>> 3) {
                                        case 1:
                                            if (!(message.dashes && message.dashes.length))
                                                message.dashes = [];
                                            message.dashes.push($root.yandex.maps.proto.vectordata2.presentation.Presentation.Class.DashItem.decode(reader, reader.uint32()));
                                            break;
                                        default:
                                            reader.skipType(tag & 7);
                                            break;
                                        }
                                    }
                                    return message;
                                };

                                return DashStyle;
                            })();

                            Class.LineStyle = (function() {

                                /**
                                 * Properties of a LineStyle.
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class
                                 * @interface ILineStyle
                                 * @property {number|null} [color] LineStyle color
                                 * @property {number|null} [width] LineStyle width
                                 * @property {yandex.maps.proto.vectordata2.presentation.Presentation.Class.LineStyle.CapStyle|null} [caps] LineStyle caps
                                 * @property {yandex.maps.proto.vectordata2.presentation.Presentation.Class.LineStyle.JoinStyle|null} [joins] LineStyle joins
                                 * @property {yandex.maps.proto.vectordata2.presentation.Presentation.Class.DashStyle|null} [dash] LineStyle dash
                                 * @property {yandex.maps.proto.vectordata2.presentation.Presentation.Class.Image|null} [pattern] LineStyle pattern
                                 */

                                /**
                                 * Constructs a new LineStyle.
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class
                                 * @classdesc Represents a LineStyle.
                                 * @implements ILineStyle
                                 * @constructor
                                 * @param {yandex.maps.proto.vectordata2.presentation.Presentation.Class.ILineStyle=} [properties] Properties to set
                                 */
                                function LineStyle(properties) {
                                    if (properties)
                                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                            if (properties[keys[i]] != null)
                                                this[keys[i]] = properties[keys[i]];
                                }

                                /**
                                 * LineStyle color.
                                 * @member {number} color
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.LineStyle
                                 * @instance
                                 */
                                LineStyle.prototype.color = 0;

                                /**
                                 * LineStyle width.
                                 * @member {number} width
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.LineStyle
                                 * @instance
                                 */
                                LineStyle.prototype.width = 0;

                                /**
                                 * LineStyle caps.
                                 * @member {yandex.maps.proto.vectordata2.presentation.Presentation.Class.LineStyle.CapStyle} caps
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.LineStyle
                                 * @instance
                                 */
                                LineStyle.prototype.caps = 0;

                                /**
                                 * LineStyle joins.
                                 * @member {yandex.maps.proto.vectordata2.presentation.Presentation.Class.LineStyle.JoinStyle} joins
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.LineStyle
                                 * @instance
                                 */
                                LineStyle.prototype.joins = 0;

                                /**
                                 * LineStyle dash.
                                 * @member {yandex.maps.proto.vectordata2.presentation.Presentation.Class.DashStyle|null|undefined} dash
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.LineStyle
                                 * @instance
                                 */
                                LineStyle.prototype.dash = null;

                                /**
                                 * LineStyle pattern.
                                 * @member {yandex.maps.proto.vectordata2.presentation.Presentation.Class.Image|null|undefined} pattern
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.LineStyle
                                 * @instance
                                 */
                                LineStyle.prototype.pattern = null;

                                /**
                                 * Decodes a LineStyle message from the specified reader or buffer.
                                 * @function decode
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.LineStyle
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @param {number} [length] Message length if known beforehand
                                 * @returns {yandex.maps.proto.vectordata2.presentation.Presentation.Class.LineStyle} LineStyle
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                LineStyle.decode = function decode(reader, length) {
                                    if (!(reader instanceof $Reader))
                                        reader = $Reader.create(reader);
                                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.yandex.maps.proto.vectordata2.presentation.Presentation.Class.LineStyle();
                                    while (reader.pos < end) {
                                        var tag = reader.uint32();
                                        switch (tag >>> 3) {
                                        case 1:
                                            message.color = reader.fixed32();
                                            break;
                                        case 2:
                                            message.width = reader.float();
                                            break;
                                        case 3:
                                            message.caps = reader.int32();
                                            break;
                                        case 4:
                                            message.joins = reader.int32();
                                            break;
                                        case 5:
                                            message.dash = $root.yandex.maps.proto.vectordata2.presentation.Presentation.Class.DashStyle.decode(reader, reader.uint32());
                                            break;
                                        case 6:
                                            message.pattern = $root.yandex.maps.proto.vectordata2.presentation.Presentation.Class.Image.decode(reader, reader.uint32());
                                            break;
                                        default:
                                            reader.skipType(tag & 7);
                                            break;
                                        }
                                    }
                                    return message;
                                };

                                /**
                                 * CapStyle enum.
                                 * @name yandex.maps.proto.vectordata2.presentation.Presentation.Class.LineStyle.CapStyle
                                 * @enum {string}
                                 * @property {number} CapRound=0 CapRound value
                                 * @property {number} CapBevel=1 CapBevel value
                                 * @property {number} CapSquare=2 CapSquare value
                                 */
                                LineStyle.CapStyle = (function() {
                                    var valuesById = {}, values = Object.create(valuesById);
                                    values[valuesById[0] = "CapRound"] = 0;
                                    values[valuesById[1] = "CapBevel"] = 1;
                                    values[valuesById[2] = "CapSquare"] = 2;
                                    return values;
                                })();

                                /**
                                 * JoinStyle enum.
                                 * @name yandex.maps.proto.vectordata2.presentation.Presentation.Class.LineStyle.JoinStyle
                                 * @enum {string}
                                 * @property {number} JoinMiter=0 JoinMiter value
                                 * @property {number} JoinRound=1 JoinRound value
                                 * @property {number} JoinBevel=2 JoinBevel value
                                 */
                                LineStyle.JoinStyle = (function() {
                                    var valuesById = {}, values = Object.create(valuesById);
                                    values[valuesById[0] = "JoinMiter"] = 0;
                                    values[valuesById[1] = "JoinRound"] = 1;
                                    values[valuesById[2] = "JoinBevel"] = 2;
                                    return values;
                                })();

                                return LineStyle;
                            })();

                            Class.PolylineStyle = (function() {

                                /**
                                 * Properties of a PolylineStyle.
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class
                                 * @interface IPolylineStyle
                                 * @property {yandex.maps.proto.vectordata2.presentation.Presentation.Class.LineStyle|null} [line] PolylineStyle line
                                 * @property {yandex.maps.proto.vectordata2.presentation.Presentation.Class.LineStyle|null} [outline] PolylineStyle outline
                                 */

                                /**
                                 * Constructs a new PolylineStyle.
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class
                                 * @classdesc Represents a PolylineStyle.
                                 * @implements IPolylineStyle
                                 * @constructor
                                 * @param {yandex.maps.proto.vectordata2.presentation.Presentation.Class.IPolylineStyle=} [properties] Properties to set
                                 */
                                function PolylineStyle(properties) {
                                    if (properties)
                                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                            if (properties[keys[i]] != null)
                                                this[keys[i]] = properties[keys[i]];
                                }

                                /**
                                 * PolylineStyle line.
                                 * @member {yandex.maps.proto.vectordata2.presentation.Presentation.Class.LineStyle|null|undefined} line
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.PolylineStyle
                                 * @instance
                                 */
                                PolylineStyle.prototype.line = null;

                                /**
                                 * PolylineStyle outline.
                                 * @member {yandex.maps.proto.vectordata2.presentation.Presentation.Class.LineStyle|null|undefined} outline
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.PolylineStyle
                                 * @instance
                                 */
                                PolylineStyle.prototype.outline = null;

                                /**
                                 * Decodes a PolylineStyle message from the specified reader or buffer.
                                 * @function decode
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.PolylineStyle
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @param {number} [length] Message length if known beforehand
                                 * @returns {yandex.maps.proto.vectordata2.presentation.Presentation.Class.PolylineStyle} PolylineStyle
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                PolylineStyle.decode = function decode(reader, length) {
                                    if (!(reader instanceof $Reader))
                                        reader = $Reader.create(reader);
                                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.yandex.maps.proto.vectordata2.presentation.Presentation.Class.PolylineStyle();
                                    while (reader.pos < end) {
                                        var tag = reader.uint32();
                                        switch (tag >>> 3) {
                                        case 1:
                                            message.line = $root.yandex.maps.proto.vectordata2.presentation.Presentation.Class.LineStyle.decode(reader, reader.uint32());
                                            break;
                                        case 2:
                                            message.outline = $root.yandex.maps.proto.vectordata2.presentation.Presentation.Class.LineStyle.decode(reader, reader.uint32());
                                            break;
                                        default:
                                            reader.skipType(tag & 7);
                                            break;
                                        }
                                    }
                                    return message;
                                };

                                return PolylineStyle;
                            })();

                            Class.PolygonStyle = (function() {

                                /**
                                 * Properties of a PolygonStyle.
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class
                                 * @interface IPolygonStyle
                                 * @property {yandex.maps.proto.vectordata2.presentation.Presentation.Class.Image|null} [pattern] PolygonStyle pattern
                                 * @property {number|null} [color] PolygonStyle color
                                 * @property {yandex.maps.proto.vectordata2.presentation.Presentation.Class.PolygonStyle.Extrusion|null} [extrusion] PolygonStyle extrusion
                                 * @property {yandex.maps.proto.vectordata2.presentation.Presentation.Class.LineStyle|null} [contour] PolygonStyle contour
                                 */

                                /**
                                 * Constructs a new PolygonStyle.
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class
                                 * @classdesc Represents a PolygonStyle.
                                 * @implements IPolygonStyle
                                 * @constructor
                                 * @param {yandex.maps.proto.vectordata2.presentation.Presentation.Class.IPolygonStyle=} [properties] Properties to set
                                 */
                                function PolygonStyle(properties) {
                                    if (properties)
                                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                            if (properties[keys[i]] != null)
                                                this[keys[i]] = properties[keys[i]];
                                }

                                /**
                                 * PolygonStyle pattern.
                                 * @member {yandex.maps.proto.vectordata2.presentation.Presentation.Class.Image|null|undefined} pattern
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.PolygonStyle
                                 * @instance
                                 */
                                PolygonStyle.prototype.pattern = null;

                                /**
                                 * PolygonStyle color.
                                 * @member {number} color
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.PolygonStyle
                                 * @instance
                                 */
                                PolygonStyle.prototype.color = 0;

                                /**
                                 * PolygonStyle extrusion.
                                 * @member {yandex.maps.proto.vectordata2.presentation.Presentation.Class.PolygonStyle.Extrusion|null|undefined} extrusion
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.PolygonStyle
                                 * @instance
                                 */
                                PolygonStyle.prototype.extrusion = null;

                                /**
                                 * PolygonStyle contour.
                                 * @member {yandex.maps.proto.vectordata2.presentation.Presentation.Class.LineStyle|null|undefined} contour
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.PolygonStyle
                                 * @instance
                                 */
                                PolygonStyle.prototype.contour = null;

                                /**
                                 * Decodes a PolygonStyle message from the specified reader or buffer.
                                 * @function decode
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.PolygonStyle
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @param {number} [length] Message length if known beforehand
                                 * @returns {yandex.maps.proto.vectordata2.presentation.Presentation.Class.PolygonStyle} PolygonStyle
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                PolygonStyle.decode = function decode(reader, length) {
                                    if (!(reader instanceof $Reader))
                                        reader = $Reader.create(reader);
                                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.yandex.maps.proto.vectordata2.presentation.Presentation.Class.PolygonStyle();
                                    while (reader.pos < end) {
                                        var tag = reader.uint32();
                                        switch (tag >>> 3) {
                                        case 1:
                                            message.pattern = $root.yandex.maps.proto.vectordata2.presentation.Presentation.Class.Image.decode(reader, reader.uint32());
                                            break;
                                        case 2:
                                            message.color = reader.fixed32();
                                            break;
                                        case 3:
                                            message.extrusion = $root.yandex.maps.proto.vectordata2.presentation.Presentation.Class.PolygonStyle.Extrusion.decode(reader, reader.uint32());
                                            break;
                                        case 4:
                                            message.contour = $root.yandex.maps.proto.vectordata2.presentation.Presentation.Class.LineStyle.decode(reader, reader.uint32());
                                            break;
                                        default:
                                            reader.skipType(tag & 7);
                                            break;
                                        }
                                    }
                                    return message;
                                };

                                PolygonStyle.Extrusion = (function() {

                                    /**
                                     * Properties of an Extrusion.
                                     * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.PolygonStyle
                                     * @interface IExtrusion
                                     * @property {boolean|null} [enabled] Extrusion enabled
                                     * @property {number|null} [height] Extrusion height
                                     */

                                    /**
                                     * Constructs a new Extrusion.
                                     * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.PolygonStyle
                                     * @classdesc Represents an Extrusion.
                                     * @implements IExtrusion
                                     * @constructor
                                     * @param {yandex.maps.proto.vectordata2.presentation.Presentation.Class.PolygonStyle.IExtrusion=} [properties] Properties to set
                                     */
                                    function Extrusion(properties) {
                                        if (properties)
                                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                                if (properties[keys[i]] != null)
                                                    this[keys[i]] = properties[keys[i]];
                                    }

                                    /**
                                     * Extrusion enabled.
                                     * @member {boolean} enabled
                                     * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.PolygonStyle.Extrusion
                                     * @instance
                                     */
                                    Extrusion.prototype.enabled = false;

                                    /**
                                     * Extrusion height.
                                     * @member {number} height
                                     * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.PolygonStyle.Extrusion
                                     * @instance
                                     */
                                    Extrusion.prototype.height = 0;

                                    /**
                                     * Decodes an Extrusion message from the specified reader or buffer.
                                     * @function decode
                                     * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.PolygonStyle.Extrusion
                                     * @static
                                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                     * @param {number} [length] Message length if known beforehand
                                     * @returns {yandex.maps.proto.vectordata2.presentation.Presentation.Class.PolygonStyle.Extrusion} Extrusion
                                     * @throws {Error} If the payload is not a reader or valid buffer
                                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                     */
                                    Extrusion.decode = function decode(reader, length) {
                                        if (!(reader instanceof $Reader))
                                            reader = $Reader.create(reader);
                                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.yandex.maps.proto.vectordata2.presentation.Presentation.Class.PolygonStyle.Extrusion();
                                        while (reader.pos < end) {
                                            var tag = reader.uint32();
                                            switch (tag >>> 3) {
                                            case 1:
                                                message.enabled = reader.bool();
                                                break;
                                            case 3:
                                                message.height = reader.float();
                                                break;
                                            default:
                                                reader.skipType(tag & 7);
                                                break;
                                            }
                                        }
                                        return message;
                                    };

                                    return Extrusion;
                                })();

                                return PolygonStyle;
                            })();

                            Class.TextStyle = (function() {

                                /**
                                 * Properties of a TextStyle.
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class
                                 * @interface ITextStyle
                                 * @property {number|null} [color] TextStyle color
                                 * @property {string|null} [fontId] TextStyle fontId
                                 * @property {number|null} [fontSize] TextStyle fontSize
                                 * @property {number|null} [outlineColor] TextStyle outlineColor
                                 */

                                /**
                                 * Constructs a new TextStyle.
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class
                                 * @classdesc Represents a TextStyle.
                                 * @implements ITextStyle
                                 * @constructor
                                 * @param {yandex.maps.proto.vectordata2.presentation.Presentation.Class.ITextStyle=} [properties] Properties to set
                                 */
                                function TextStyle(properties) {
                                    if (properties)
                                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                            if (properties[keys[i]] != null)
                                                this[keys[i]] = properties[keys[i]];
                                }

                                /**
                                 * TextStyle color.
                                 * @member {number} color
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.TextStyle
                                 * @instance
                                 */
                                TextStyle.prototype.color = 0;

                                /**
                                 * TextStyle fontId.
                                 * @member {string} fontId
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.TextStyle
                                 * @instance
                                 */
                                TextStyle.prototype.fontId = "";

                                /**
                                 * TextStyle fontSize.
                                 * @member {number} fontSize
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.TextStyle
                                 * @instance
                                 */
                                TextStyle.prototype.fontSize = 0;

                                /**
                                 * TextStyle outlineColor.
                                 * @member {number} outlineColor
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.TextStyle
                                 * @instance
                                 */
                                TextStyle.prototype.outlineColor = 0;

                                /**
                                 * Decodes a TextStyle message from the specified reader or buffer.
                                 * @function decode
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.TextStyle
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @param {number} [length] Message length if known beforehand
                                 * @returns {yandex.maps.proto.vectordata2.presentation.Presentation.Class.TextStyle} TextStyle
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                TextStyle.decode = function decode(reader, length) {
                                    if (!(reader instanceof $Reader))
                                        reader = $Reader.create(reader);
                                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.yandex.maps.proto.vectordata2.presentation.Presentation.Class.TextStyle();
                                    while (reader.pos < end) {
                                        var tag = reader.uint32();
                                        switch (tag >>> 3) {
                                        case 1:
                                            message.color = reader.fixed32();
                                            break;
                                        case 2:
                                            message.fontId = reader.string();
                                            break;
                                        case 3:
                                            message.fontSize = reader.float();
                                            break;
                                        case 4:
                                            message.outlineColor = reader.fixed32();
                                            break;
                                        default:
                                            reader.skipType(tag & 7);
                                            break;
                                        }
                                    }
                                    return message;
                                };

                                return TextStyle;
                            })();

                            Class.LabelStyle = (function() {

                                /**
                                 * Properties of a LabelStyle.
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class
                                 * @interface ILabelStyle
                                 * @property {yandex.maps.proto.vectordata2.presentation.Presentation.Class.TextStyle|null} [text] LabelStyle text
                                 * @property {yandex.maps.proto.vectordata2.presentation.Presentation.Class.TextStyle|null} [textAlt] LabelStyle textAlt
                                 * @property {number|null} [hdistance] LabelStyle hdistance
                                 * @property {number|null} [vdistance] LabelStyle vdistance
                                 * @property {yandex.maps.proto.vectordata2.presentation.Presentation.Class.LabelBackgroundStyle|null} [background] LabelStyle background
                                 */

                                /**
                                 * Constructs a new LabelStyle.
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class
                                 * @classdesc Represents a LabelStyle.
                                 * @implements ILabelStyle
                                 * @constructor
                                 * @param {yandex.maps.proto.vectordata2.presentation.Presentation.Class.ILabelStyle=} [properties] Properties to set
                                 */
                                function LabelStyle(properties) {
                                    if (properties)
                                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                            if (properties[keys[i]] != null)
                                                this[keys[i]] = properties[keys[i]];
                                }

                                /**
                                 * LabelStyle text.
                                 * @member {yandex.maps.proto.vectordata2.presentation.Presentation.Class.TextStyle|null|undefined} text
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.LabelStyle
                                 * @instance
                                 */
                                LabelStyle.prototype.text = null;

                                /**
                                 * LabelStyle textAlt.
                                 * @member {yandex.maps.proto.vectordata2.presentation.Presentation.Class.TextStyle|null|undefined} textAlt
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.LabelStyle
                                 * @instance
                                 */
                                LabelStyle.prototype.textAlt = null;

                                /**
                                 * LabelStyle hdistance.
                                 * @member {number} hdistance
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.LabelStyle
                                 * @instance
                                 */
                                LabelStyle.prototype.hdistance = 0;

                                /**
                                 * LabelStyle vdistance.
                                 * @member {number} vdistance
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.LabelStyle
                                 * @instance
                                 */
                                LabelStyle.prototype.vdistance = 0;

                                /**
                                 * LabelStyle background.
                                 * @member {yandex.maps.proto.vectordata2.presentation.Presentation.Class.LabelBackgroundStyle|null|undefined} background
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.LabelStyle
                                 * @instance
                                 */
                                LabelStyle.prototype.background = null;

                                /**
                                 * Decodes a LabelStyle message from the specified reader or buffer.
                                 * @function decode
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.LabelStyle
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @param {number} [length] Message length if known beforehand
                                 * @returns {yandex.maps.proto.vectordata2.presentation.Presentation.Class.LabelStyle} LabelStyle
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                LabelStyle.decode = function decode(reader, length) {
                                    if (!(reader instanceof $Reader))
                                        reader = $Reader.create(reader);
                                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.yandex.maps.proto.vectordata2.presentation.Presentation.Class.LabelStyle();
                                    while (reader.pos < end) {
                                        var tag = reader.uint32();
                                        switch (tag >>> 3) {
                                        case 1:
                                            message.text = $root.yandex.maps.proto.vectordata2.presentation.Presentation.Class.TextStyle.decode(reader, reader.uint32());
                                            break;
                                        case 2:
                                            message.textAlt = $root.yandex.maps.proto.vectordata2.presentation.Presentation.Class.TextStyle.decode(reader, reader.uint32());
                                            break;
                                        case 3:
                                            message.hdistance = reader.float();
                                            break;
                                        case 4:
                                            message.vdistance = reader.float();
                                            break;
                                        case 5:
                                            message.background = $root.yandex.maps.proto.vectordata2.presentation.Presentation.Class.LabelBackgroundStyle.decode(reader, reader.uint32());
                                            break;
                                        default:
                                            reader.skipType(tag & 7);
                                            break;
                                        }
                                    }
                                    return message;
                                };

                                return LabelStyle;
                            })();

                            Class.LabelBackgroundStyle = (function() {

                                /**
                                 * Properties of a LabelBackgroundStyle.
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class
                                 * @interface ILabelBackgroundStyle
                                 * @property {number|null} [hPadding] LabelBackgroundStyle hPadding
                                 * @property {number|null} [vPadding] LabelBackgroundStyle vPadding
                                 * @property {number|null} [color] LabelBackgroundStyle color
                                 * @property {yandex.maps.proto.vectordata2.presentation.Presentation.Class.LineStyle|null} [outline] LabelBackgroundStyle outline
                                 */

                                /**
                                 * Constructs a new LabelBackgroundStyle.
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class
                                 * @classdesc Represents a LabelBackgroundStyle.
                                 * @implements ILabelBackgroundStyle
                                 * @constructor
                                 * @param {yandex.maps.proto.vectordata2.presentation.Presentation.Class.ILabelBackgroundStyle=} [properties] Properties to set
                                 */
                                function LabelBackgroundStyle(properties) {
                                    if (properties)
                                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                            if (properties[keys[i]] != null)
                                                this[keys[i]] = properties[keys[i]];
                                }

                                /**
                                 * LabelBackgroundStyle hPadding.
                                 * @member {number} hPadding
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.LabelBackgroundStyle
                                 * @instance
                                 */
                                LabelBackgroundStyle.prototype.hPadding = 0;

                                /**
                                 * LabelBackgroundStyle vPadding.
                                 * @member {number} vPadding
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.LabelBackgroundStyle
                                 * @instance
                                 */
                                LabelBackgroundStyle.prototype.vPadding = 0;

                                /**
                                 * LabelBackgroundStyle color.
                                 * @member {number} color
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.LabelBackgroundStyle
                                 * @instance
                                 */
                                LabelBackgroundStyle.prototype.color = 0;

                                /**
                                 * LabelBackgroundStyle outline.
                                 * @member {yandex.maps.proto.vectordata2.presentation.Presentation.Class.LineStyle|null|undefined} outline
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.LabelBackgroundStyle
                                 * @instance
                                 */
                                LabelBackgroundStyle.prototype.outline = null;

                                /**
                                 * Decodes a LabelBackgroundStyle message from the specified reader or buffer.
                                 * @function decode
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.LabelBackgroundStyle
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @param {number} [length] Message length if known beforehand
                                 * @returns {yandex.maps.proto.vectordata2.presentation.Presentation.Class.LabelBackgroundStyle} LabelBackgroundStyle
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                LabelBackgroundStyle.decode = function decode(reader, length) {
                                    if (!(reader instanceof $Reader))
                                        reader = $Reader.create(reader);
                                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.yandex.maps.proto.vectordata2.presentation.Presentation.Class.LabelBackgroundStyle();
                                    while (reader.pos < end) {
                                        var tag = reader.uint32();
                                        switch (tag >>> 3) {
                                        case 1:
                                            message.hPadding = reader.float();
                                            break;
                                        case 2:
                                            message.vPadding = reader.float();
                                            break;
                                        case 3:
                                            message.color = reader.fixed32();
                                            break;
                                        case 4:
                                            message.outline = $root.yandex.maps.proto.vectordata2.presentation.Presentation.Class.LineStyle.decode(reader, reader.uint32());
                                            break;
                                        default:
                                            reader.skipType(tag & 7);
                                            break;
                                        }
                                    }
                                    return message;
                                };

                                return LabelBackgroundStyle;
                            })();

                            Class.ZoomSlice = (function() {

                                /**
                                 * Properties of a ZoomSlice.
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class
                                 * @interface IZoomSlice
                                 * @property {number|null} [zIndex] ZoomSlice zIndex
                                 * @property {yandex.maps.proto.vectordata2.presentation.Presentation.Class.ZoomRange|null} [visibility] ZoomSlice visibility
                                 * @property {yandex.maps.proto.vectordata2.presentation.Presentation.Class.PolylineStyle|null} [line] ZoomSlice line
                                 * @property {yandex.maps.proto.vectordata2.presentation.Presentation.Class.PolygonStyle|null} [poly] ZoomSlice poly
                                 * @property {yandex.maps.proto.vectordata2.presentation.Presentation.Class.PointStyle|null} [point] ZoomSlice point
                                 * @property {yandex.maps.proto.vectordata2.presentation.Presentation.Class.LabelStyle|null} [label] ZoomSlice label
                                 */

                                /**
                                 * Constructs a new ZoomSlice.
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class
                                 * @classdesc Represents a ZoomSlice.
                                 * @implements IZoomSlice
                                 * @constructor
                                 * @param {yandex.maps.proto.vectordata2.presentation.Presentation.Class.IZoomSlice=} [properties] Properties to set
                                 */
                                function ZoomSlice(properties) {
                                    if (properties)
                                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                            if (properties[keys[i]] != null)
                                                this[keys[i]] = properties[keys[i]];
                                }

                                /**
                                 * ZoomSlice zIndex.
                                 * @member {number} zIndex
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.ZoomSlice
                                 * @instance
                                 */
                                ZoomSlice.prototype.zIndex = 0;

                                /**
                                 * ZoomSlice visibility.
                                 * @member {yandex.maps.proto.vectordata2.presentation.Presentation.Class.ZoomRange|null|undefined} visibility
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.ZoomSlice
                                 * @instance
                                 */
                                ZoomSlice.prototype.visibility = null;

                                /**
                                 * ZoomSlice line.
                                 * @member {yandex.maps.proto.vectordata2.presentation.Presentation.Class.PolylineStyle|null|undefined} line
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.ZoomSlice
                                 * @instance
                                 */
                                ZoomSlice.prototype.line = null;

                                /**
                                 * ZoomSlice poly.
                                 * @member {yandex.maps.proto.vectordata2.presentation.Presentation.Class.PolygonStyle|null|undefined} poly
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.ZoomSlice
                                 * @instance
                                 */
                                ZoomSlice.prototype.poly = null;

                                /**
                                 * ZoomSlice point.
                                 * @member {yandex.maps.proto.vectordata2.presentation.Presentation.Class.PointStyle|null|undefined} point
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.ZoomSlice
                                 * @instance
                                 */
                                ZoomSlice.prototype.point = null;

                                /**
                                 * ZoomSlice label.
                                 * @member {yandex.maps.proto.vectordata2.presentation.Presentation.Class.LabelStyle|null|undefined} label
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.ZoomSlice
                                 * @instance
                                 */
                                ZoomSlice.prototype.label = null;

                                /**
                                 * Decodes a ZoomSlice message from the specified reader or buffer.
                                 * @function decode
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Class.ZoomSlice
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @param {number} [length] Message length if known beforehand
                                 * @returns {yandex.maps.proto.vectordata2.presentation.Presentation.Class.ZoomSlice} ZoomSlice
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                ZoomSlice.decode = function decode(reader, length) {
                                    if (!(reader instanceof $Reader))
                                        reader = $Reader.create(reader);
                                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.yandex.maps.proto.vectordata2.presentation.Presentation.Class.ZoomSlice();
                                    while (reader.pos < end) {
                                        var tag = reader.uint32();
                                        switch (tag >>> 3) {
                                        case 1:
                                            message.zIndex = reader.sint32();
                                            break;
                                        case 2:
                                            message.visibility = $root.yandex.maps.proto.vectordata2.presentation.Presentation.Class.ZoomRange.decode(reader, reader.uint32());
                                            break;
                                        case 3:
                                            message.line = $root.yandex.maps.proto.vectordata2.presentation.Presentation.Class.PolylineStyle.decode(reader, reader.uint32());
                                            break;
                                        case 4:
                                            message.poly = $root.yandex.maps.proto.vectordata2.presentation.Presentation.Class.PolygonStyle.decode(reader, reader.uint32());
                                            break;
                                        case 5:
                                            message.point = $root.yandex.maps.proto.vectordata2.presentation.Presentation.Class.PointStyle.decode(reader, reader.uint32());
                                            break;
                                        case 6:
                                            message.label = $root.yandex.maps.proto.vectordata2.presentation.Presentation.Class.LabelStyle.decode(reader, reader.uint32());
                                            break;
                                        default:
                                            reader.skipType(tag & 7);
                                            break;
                                        }
                                    }
                                    return message;
                                };

                                return ZoomSlice;
                            })();

                            return Class;
                        })();

                        Presentation.Parameters = (function() {

                            /**
                             * Properties of a Parameters.
                             * @memberof yandex.maps.proto.vectordata2.presentation.Presentation
                             * @interface IParameters
                             * @property {yandex.maps.proto.vectordata2.presentation.Presentation.Parameters.Extrusion|null} [extrusion] Parameters extrusion
                             */

                            /**
                             * Constructs a new Parameters.
                             * @memberof yandex.maps.proto.vectordata2.presentation.Presentation
                             * @classdesc Represents a Parameters.
                             * @implements IParameters
                             * @constructor
                             * @param {yandex.maps.proto.vectordata2.presentation.Presentation.IParameters=} [properties] Properties to set
                             */
                            function Parameters(properties) {
                                if (properties)
                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * Parameters extrusion.
                             * @member {yandex.maps.proto.vectordata2.presentation.Presentation.Parameters.Extrusion|null|undefined} extrusion
                             * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Parameters
                             * @instance
                             */
                            Parameters.prototype.extrusion = null;

                            /**
                             * Decodes a Parameters message from the specified reader or buffer.
                             * @function decode
                             * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Parameters
                             * @static
                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                             * @param {number} [length] Message length if known beforehand
                             * @returns {yandex.maps.proto.vectordata2.presentation.Presentation.Parameters} Parameters
                             * @throws {Error} If the payload is not a reader or valid buffer
                             * @throws {$protobuf.util.ProtocolError} If required fields are missing
                             */
                            Parameters.decode = function decode(reader, length) {
                                if (!(reader instanceof $Reader))
                                    reader = $Reader.create(reader);
                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.yandex.maps.proto.vectordata2.presentation.Presentation.Parameters();
                                while (reader.pos < end) {
                                    var tag = reader.uint32();
                                    switch (tag >>> 3) {
                                    case 1:
                                        message.extrusion = $root.yandex.maps.proto.vectordata2.presentation.Presentation.Parameters.Extrusion.decode(reader, reader.uint32());
                                        break;
                                    default:
                                        reader.skipType(tag & 7);
                                        break;
                                    }
                                }
                                return message;
                            };

                            Parameters.Extrusion = (function() {

                                /**
                                 * Properties of an Extrusion.
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Parameters
                                 * @interface IExtrusion
                                 * @property {number|null} [adjustMeshHeightK] Extrusion adjustMeshHeightK
                                 * @property {number|null} [adjustMeshHeightPow] Extrusion adjustMeshHeightPow
                                 * @property {number|null} [adjustBoxHeightK] Extrusion adjustBoxHeightK
                                 * @property {number|null} [adjustBoxHeightPow] Extrusion adjustBoxHeightPow
                                 */

                                /**
                                 * Constructs a new Extrusion.
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Parameters
                                 * @classdesc Represents an Extrusion.
                                 * @implements IExtrusion
                                 * @constructor
                                 * @param {yandex.maps.proto.vectordata2.presentation.Presentation.Parameters.IExtrusion=} [properties] Properties to set
                                 */
                                function Extrusion(properties) {
                                    if (properties)
                                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                            if (properties[keys[i]] != null)
                                                this[keys[i]] = properties[keys[i]];
                                }

                                /**
                                 * Extrusion adjustMeshHeightK.
                                 * @member {number} adjustMeshHeightK
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Parameters.Extrusion
                                 * @instance
                                 */
                                Extrusion.prototype.adjustMeshHeightK = 0;

                                /**
                                 * Extrusion adjustMeshHeightPow.
                                 * @member {number} adjustMeshHeightPow
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Parameters.Extrusion
                                 * @instance
                                 */
                                Extrusion.prototype.adjustMeshHeightPow = 0;

                                /**
                                 * Extrusion adjustBoxHeightK.
                                 * @member {number} adjustBoxHeightK
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Parameters.Extrusion
                                 * @instance
                                 */
                                Extrusion.prototype.adjustBoxHeightK = 0;

                                /**
                                 * Extrusion adjustBoxHeightPow.
                                 * @member {number} adjustBoxHeightPow
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Parameters.Extrusion
                                 * @instance
                                 */
                                Extrusion.prototype.adjustBoxHeightPow = 0;

                                /**
                                 * Decodes an Extrusion message from the specified reader or buffer.
                                 * @function decode
                                 * @memberof yandex.maps.proto.vectordata2.presentation.Presentation.Parameters.Extrusion
                                 * @static
                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                                 * @param {number} [length] Message length if known beforehand
                                 * @returns {yandex.maps.proto.vectordata2.presentation.Presentation.Parameters.Extrusion} Extrusion
                                 * @throws {Error} If the payload is not a reader or valid buffer
                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                                 */
                                Extrusion.decode = function decode(reader, length) {
                                    if (!(reader instanceof $Reader))
                                        reader = $Reader.create(reader);
                                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.yandex.maps.proto.vectordata2.presentation.Presentation.Parameters.Extrusion();
                                    while (reader.pos < end) {
                                        var tag = reader.uint32();
                                        switch (tag >>> 3) {
                                        case 1:
                                            message.adjustMeshHeightK = reader.float();
                                            break;
                                        case 2:
                                            message.adjustMeshHeightPow = reader.float();
                                            break;
                                        case 3:
                                            message.adjustBoxHeightK = reader.float();
                                            break;
                                        case 4:
                                            message.adjustBoxHeightPow = reader.float();
                                            break;
                                        default:
                                            reader.skipType(tag & 7);
                                            break;
                                        }
                                    }
                                    return message;
                                };

                                return Extrusion;
                            })();

                            return Parameters;
                        })();

                        return Presentation;
                    })();

                    return presentation;
                })();

                vectordata2.glyphs = (function() {

                    /**
                     * Namespace glyphs.
                     * @memberof yandex.maps.proto.vectordata2
                     * @namespace
                     */
                    var glyphs = {};

                    glyphs.Glyph = (function() {

                        /**
                         * Properties of a Glyph.
                         * @memberof yandex.maps.proto.vectordata2.glyphs
                         * @interface IGlyph
                         * @property {number} id Glyph id
                         * @property {Uint8Array} bitmap Glyph bitmap
                         * @property {number} width Glyph width
                         * @property {number} height Glyph height
                         * @property {number} bearingX Glyph bearingX
                         * @property {number} bearingY Glyph bearingY
                         * @property {number} advance Glyph advance
                         */

                        /**
                         * Constructs a new Glyph.
                         * @memberof yandex.maps.proto.vectordata2.glyphs
                         * @classdesc Represents a Glyph.
                         * @implements IGlyph
                         * @constructor
                         * @param {yandex.maps.proto.vectordata2.glyphs.IGlyph=} [properties] Properties to set
                         */
                        function Glyph(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Glyph id.
                         * @member {number} id
                         * @memberof yandex.maps.proto.vectordata2.glyphs.Glyph
                         * @instance
                         */
                        Glyph.prototype.id = 0;

                        /**
                         * Glyph bitmap.
                         * @member {Uint8Array} bitmap
                         * @memberof yandex.maps.proto.vectordata2.glyphs.Glyph
                         * @instance
                         */
                        Glyph.prototype.bitmap = $util.newBuffer([]);

                        /**
                         * Glyph width.
                         * @member {number} width
                         * @memberof yandex.maps.proto.vectordata2.glyphs.Glyph
                         * @instance
                         */
                        Glyph.prototype.width = 0;

                        /**
                         * Glyph height.
                         * @member {number} height
                         * @memberof yandex.maps.proto.vectordata2.glyphs.Glyph
                         * @instance
                         */
                        Glyph.prototype.height = 0;

                        /**
                         * Glyph bearingX.
                         * @member {number} bearingX
                         * @memberof yandex.maps.proto.vectordata2.glyphs.Glyph
                         * @instance
                         */
                        Glyph.prototype.bearingX = 0;

                        /**
                         * Glyph bearingY.
                         * @member {number} bearingY
                         * @memberof yandex.maps.proto.vectordata2.glyphs.Glyph
                         * @instance
                         */
                        Glyph.prototype.bearingY = 0;

                        /**
                         * Glyph advance.
                         * @member {number} advance
                         * @memberof yandex.maps.proto.vectordata2.glyphs.Glyph
                         * @instance
                         */
                        Glyph.prototype.advance = 0;

                        /**
                         * Decodes a Glyph message from the specified reader or buffer.
                         * @function decode
                         * @memberof yandex.maps.proto.vectordata2.glyphs.Glyph
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {yandex.maps.proto.vectordata2.glyphs.Glyph} Glyph
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        Glyph.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.yandex.maps.proto.vectordata2.glyphs.Glyph();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.id = reader.uint32();
                                    break;
                                case 2:
                                    message.bitmap = reader.bytes();
                                    break;
                                case 3:
                                    message.width = reader.uint32();
                                    break;
                                case 4:
                                    message.height = reader.uint32();
                                    break;
                                case 5:
                                    message.bearingX = reader.sint32();
                                    break;
                                case 6:
                                    message.bearingY = reader.sint32();
                                    break;
                                case 7:
                                    message.advance = reader.uint32();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            if (!message.hasOwnProperty("id"))
                                throw $util.ProtocolError("missing required 'id'", { instance: message });
                            if (!message.hasOwnProperty("bitmap"))
                                throw $util.ProtocolError("missing required 'bitmap'", { instance: message });
                            if (!message.hasOwnProperty("width"))
                                throw $util.ProtocolError("missing required 'width'", { instance: message });
                            if (!message.hasOwnProperty("height"))
                                throw $util.ProtocolError("missing required 'height'", { instance: message });
                            if (!message.hasOwnProperty("bearingX"))
                                throw $util.ProtocolError("missing required 'bearingX'", { instance: message });
                            if (!message.hasOwnProperty("bearingY"))
                                throw $util.ProtocolError("missing required 'bearingY'", { instance: message });
                            if (!message.hasOwnProperty("advance"))
                                throw $util.ProtocolError("missing required 'advance'", { instance: message });
                            return message;
                        };

                        return Glyph;
                    })();

                    glyphs.FontDescription = (function() {

                        /**
                         * Properties of a FontDescription.
                         * @memberof yandex.maps.proto.vectordata2.glyphs
                         * @interface IFontDescription
                         * @property {string} fontId FontDescription fontId
                         * @property {number} xheight FontDescription xheight
                         * @property {number} margin FontDescription margin
                         */

                        /**
                         * Constructs a new FontDescription.
                         * @memberof yandex.maps.proto.vectordata2.glyphs
                         * @classdesc Represents a FontDescription.
                         * @implements IFontDescription
                         * @constructor
                         * @param {yandex.maps.proto.vectordata2.glyphs.IFontDescription=} [properties] Properties to set
                         */
                        function FontDescription(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * FontDescription fontId.
                         * @member {string} fontId
                         * @memberof yandex.maps.proto.vectordata2.glyphs.FontDescription
                         * @instance
                         */
                        FontDescription.prototype.fontId = "";

                        /**
                         * FontDescription xheight.
                         * @member {number} xheight
                         * @memberof yandex.maps.proto.vectordata2.glyphs.FontDescription
                         * @instance
                         */
                        FontDescription.prototype.xheight = 0;

                        /**
                         * FontDescription margin.
                         * @member {number} margin
                         * @memberof yandex.maps.proto.vectordata2.glyphs.FontDescription
                         * @instance
                         */
                        FontDescription.prototype.margin = 3;

                        /**
                         * Decodes a FontDescription message from the specified reader or buffer.
                         * @function decode
                         * @memberof yandex.maps.proto.vectordata2.glyphs.FontDescription
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {yandex.maps.proto.vectordata2.glyphs.FontDescription} FontDescription
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        FontDescription.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.yandex.maps.proto.vectordata2.glyphs.FontDescription();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.fontId = reader.string();
                                    break;
                                case 2:
                                    message.xheight = reader.uint32();
                                    break;
                                case 3:
                                    message.margin = reader.sint32();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            if (!message.hasOwnProperty("fontId"))
                                throw $util.ProtocolError("missing required 'fontId'", { instance: message });
                            if (!message.hasOwnProperty("xheight"))
                                throw $util.ProtocolError("missing required 'xheight'", { instance: message });
                            if (!message.hasOwnProperty("margin"))
                                throw $util.ProtocolError("missing required 'margin'", { instance: message });
                            return message;
                        };

                        return FontDescription;
                    })();

                    glyphs.GlyphList = (function() {

                        /**
                         * Properties of a GlyphList.
                         * @memberof yandex.maps.proto.vectordata2.glyphs
                         * @interface IGlyphList
                         * @property {yandex.maps.proto.vectordata2.glyphs.FontDescription} font GlyphList font
                         * @property {Array.<yandex.maps.proto.vectordata2.glyphs.Glyph>|null} [glyphs] GlyphList glyphs
                         */

                        /**
                         * Constructs a new GlyphList.
                         * @memberof yandex.maps.proto.vectordata2.glyphs
                         * @classdesc Represents a GlyphList.
                         * @implements IGlyphList
                         * @constructor
                         * @param {yandex.maps.proto.vectordata2.glyphs.IGlyphList=} [properties] Properties to set
                         */
                        function GlyphList(properties) {
                            this.glyphs = [];
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * GlyphList font.
                         * @member {yandex.maps.proto.vectordata2.glyphs.FontDescription} font
                         * @memberof yandex.maps.proto.vectordata2.glyphs.GlyphList
                         * @instance
                         */
                        GlyphList.prototype.font = null;

                        /**
                         * GlyphList glyphs.
                         * @member {Array.<yandex.maps.proto.vectordata2.glyphs.Glyph>} glyphs
                         * @memberof yandex.maps.proto.vectordata2.glyphs.GlyphList
                         * @instance
                         */
                        GlyphList.prototype.glyphs = $util.emptyArray;

                        /**
                         * Decodes a GlyphList message from the specified reader or buffer.
                         * @function decode
                         * @memberof yandex.maps.proto.vectordata2.glyphs.GlyphList
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {yandex.maps.proto.vectordata2.glyphs.GlyphList} GlyphList
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        GlyphList.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.yandex.maps.proto.vectordata2.glyphs.GlyphList();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.font = $root.yandex.maps.proto.vectordata2.glyphs.FontDescription.decode(reader, reader.uint32());
                                    break;
                                case 2:
                                    if (!(message.glyphs && message.glyphs.length))
                                        message.glyphs = [];
                                    message.glyphs.push($root.yandex.maps.proto.vectordata2.glyphs.Glyph.decode(reader, reader.uint32()));
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            if (!message.hasOwnProperty("font"))
                                throw $util.ProtocolError("missing required 'font'", { instance: message });
                            return message;
                        };

                        return GlyphList;
                    })();

                    return glyphs;
                })();

                return vectordata2;
            })();

            return proto;
        })();

        return maps;
    })();

    return yandex;
})();

module.exports = $root;


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// minimal library entry point.


module.exports = __webpack_require__(17);


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var protobuf = exports;

/**
 * Build type, one of `"full"`, `"light"` or `"minimal"`.
 * @name build
 * @type {string}
 * @const
 */
protobuf.build = "minimal";

// Serialization
protobuf.Writer       = __webpack_require__(18);
protobuf.BufferWriter = __webpack_require__(29);
protobuf.Reader       = __webpack_require__(30);
protobuf.BufferReader = __webpack_require__(31);

// Utility
protobuf.util         = __webpack_require__(19);
protobuf.rpc          = __webpack_require__(32);
protobuf.roots        = __webpack_require__(34);
protobuf.configure    = configure;

/* istanbul ignore next */
/**
 * Reconfigures the library according to the environment.
 * @returns {undefined}
 */
function configure() {
    protobuf.Reader._configure(protobuf.BufferReader);
    protobuf.util._configure();
}

// Set up buffer utility according to the environment
protobuf.Writer._configure(protobuf.BufferWriter);
configure();


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Writer;

var util      = __webpack_require__(19);

var BufferWriter; // cyclic

var LongBits  = util.LongBits,
    base64    = util.base64,
    utf8      = util.utf8;

/**
 * Constructs a new writer operation instance.
 * @classdesc Scheduled writer operation.
 * @constructor
 * @param {function(*, Uint8Array, number)} fn Function to call
 * @param {number} len Value byte length
 * @param {*} val Value to write
 * @ignore
 */
function Op(fn, len, val) {

    /**
     * Function to call.
     * @type {function(Uint8Array, number, *)}
     */
    this.fn = fn;

    /**
     * Value byte length.
     * @type {number}
     */
    this.len = len;

    /**
     * Next operation.
     * @type {Writer.Op|undefined}
     */
    this.next = undefined;

    /**
     * Value to write.
     * @type {*}
     */
    this.val = val; // type varies
}

/* istanbul ignore next */
function noop() {} // eslint-disable-line no-empty-function

/**
 * Constructs a new writer state instance.
 * @classdesc Copied writer state.
 * @memberof Writer
 * @constructor
 * @param {Writer} writer Writer to copy state from
 * @ignore
 */
function State(writer) {

    /**
     * Current head.
     * @type {Writer.Op}
     */
    this.head = writer.head;

    /**
     * Current tail.
     * @type {Writer.Op}
     */
    this.tail = writer.tail;

    /**
     * Current buffer length.
     * @type {number}
     */
    this.len = writer.len;

    /**
     * Next state.
     * @type {State|null}
     */
    this.next = writer.states;
}

/**
 * Constructs a new writer instance.
 * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 */
function Writer() {

    /**
     * Current length.
     * @type {number}
     */
    this.len = 0;

    /**
     * Operations head.
     * @type {Object}
     */
    this.head = new Op(noop, 0, 0);

    /**
     * Operations tail
     * @type {Object}
     */
    this.tail = this.head;

    /**
     * Linked forked states.
     * @type {Object|null}
     */
    this.states = null;

    // When a value is written, the writer calculates its byte length and puts it into a linked
    // list of operations to perform when finish() is called. This both allows us to allocate
    // buffers of the exact required size and reduces the amount of work we have to do compared
    // to first calculating over objects and then encoding over objects. In our case, the encoding
    // part is just a linked list walk calling operations with already prepared values.
}

/**
 * Creates a new writer.
 * @function
 * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
 */
Writer.create = util.Buffer
    ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
            return new BufferWriter();
        })();
    }
    /* istanbul ignore next */
    : function create_array() {
        return new Writer();
    };

/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */
Writer.alloc = function alloc(size) {
    return new util.Array(size);
};

// Use Uint8Array buffer pool in the browser, just like node does with buffers
/* istanbul ignore else */
if (util.Array !== Array)
    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);

/**
 * Pushes a new operation to the queue.
 * @param {function(Uint8Array, number, *)} fn Function to call
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @returns {Writer} `this`
 * @private
 */
Writer.prototype._push = function push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
};

function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
}

function writeVarint32(val, buf, pos) {
    while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
    }
    buf[pos] = val;
}

/**
 * Constructs a new varint writer operation instance.
 * @classdesc Scheduled varint writer operation.
 * @extends Op
 * @constructor
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @ignore
 */
function VarintOp(len, val) {
    this.len = len;
    this.next = undefined;
    this.val = val;
}

VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;

/**
 * Writes an unsigned 32 bit value as a varint.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.uint32 = function write_uint32(value) {
    // here, the call to this.push has been inlined and a varint specific Op subclass is used.
    // uint32 is by far the most frequently used operation and benefits significantly from this.
    this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0)
                < 128       ? 1
        : value < 16384     ? 2
        : value < 2097152   ? 3
        : value < 268435456 ? 4
        :                     5,
    value)).len;
    return this;
};

/**
 * Writes a signed 32 bit value as a varint.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.int32 = function write_int32(value) {
    return value < 0
        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
        : this.uint32(value);
};

/**
 * Writes a 32 bit value as a varint, zig-zag encoded.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sint32 = function write_sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
};

function writeVarint64(val, buf, pos) {
    while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
    }
    while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
}

/**
 * Writes an unsigned 64 bit value as a varint.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.uint64 = function write_uint64(value) {
    var bits = LongBits.from(value);
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a signed 64 bit value as a varint.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.int64 = Writer.prototype.uint64;

/**
 * Writes a signed 64 bit value as a varint, zig-zag encoded.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sint64 = function write_sint64(value) {
    var bits = LongBits.from(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a boolish value as a varint.
 * @param {boolean} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.bool = function write_bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
};

function writeFixed32(val, buf, pos) {
    buf[pos    ] =  val         & 255;
    buf[pos + 1] =  val >>> 8   & 255;
    buf[pos + 2] =  val >>> 16  & 255;
    buf[pos + 3] =  val >>> 24;
}

/**
 * Writes an unsigned 32 bit value as fixed 32 bits.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.fixed32 = function write_fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
};

/**
 * Writes a signed 32 bit value as fixed 32 bits.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sfixed32 = Writer.prototype.fixed32;

/**
 * Writes an unsigned 64 bit value as fixed 64 bits.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.fixed64 = function write_fixed64(value) {
    var bits = LongBits.from(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
};

/**
 * Writes a signed 64 bit value as fixed 64 bits.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sfixed64 = Writer.prototype.fixed64;

/**
 * Writes a float (32 bit).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.float = function write_float(value) {
    return this._push(util.float.writeFloatLE, 4, value);
};

/**
 * Writes a double (64 bit float).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.double = function write_double(value) {
    return this._push(util.float.writeDoubleLE, 8, value);
};

var writeBytes = util.Array.prototype.set
    ? function writeBytes_set(val, buf, pos) {
        buf.set(val, pos); // also works for plain array values
    }
    /* istanbul ignore next */
    : function writeBytes_for(val, buf, pos) {
        for (var i = 0; i < val.length; ++i)
            buf[pos + i] = val[i];
    };

/**
 * Writes a sequence of bytes.
 * @param {Uint8Array|string} value Buffer or base64 encoded string to write
 * @returns {Writer} `this`
 */
Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len)
        return this._push(writeByte, 1, 0);
    if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
};

/**
 * Writes a string.
 * @param {string} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.string = function write_string(value) {
    var len = utf8.length(value);
    return len
        ? this.uint32(len)._push(utf8.write, len, value)
        : this._push(writeByte, 1, 0);
};

/**
 * Forks this writer's state by pushing it to a stack.
 * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
 * @returns {Writer} `this`
 */
Writer.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
};

/**
 * Resets this instance to the last state.
 * @returns {Writer} `this`
 */
Writer.prototype.reset = function reset() {
    if (this.states) {
        this.head   = this.states.head;
        this.tail   = this.states.tail;
        this.len    = this.states.len;
        this.states = this.states.next;
    } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len  = 0;
    }
    return this;
};

/**
 * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
 * @returns {Writer} `this`
 */
Writer.prototype.ldelim = function ldelim() {
    var head = this.head,
        tail = this.tail,
        len  = this.len;
    this.reset().uint32(len);
    if (len) {
        this.tail.next = head.next; // skip noop
        this.tail = tail;
        this.len += len;
    }
    return this;
};

/**
 * Finishes the write operation.
 * @returns {Uint8Array} Finished buffer
 */
Writer.prototype.finish = function finish() {
    var head = this.head.next, // skip noop
        buf  = this.constructor.alloc(this.len),
        pos  = 0;
    while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
    }
    // this.head = this.tail = null;
    return buf;
};

Writer._configure = function(BufferWriter_) {
    BufferWriter = BufferWriter_;
};


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
var util = exports;

// used to return a Promise where callback is omitted
util.asPromise = __webpack_require__(21);

// converts to / from base64 encoded strings
util.base64 = __webpack_require__(22);

// base class of rpc.Service
util.EventEmitter = __webpack_require__(23);

// float handling accross browsers
util.float = __webpack_require__(24);

// requires modules optionally and hides the call from bundlers
util.inquire = __webpack_require__(25);

// converts to / from utf8 encoded strings
util.utf8 = __webpack_require__(26);

// provides a node-like buffer pool in the browser
util.pool = __webpack_require__(27);

// utility to work with the low and high bits of a 64 bit value
util.LongBits = __webpack_require__(28);

// global object reference
util.global = typeof window !== "undefined" && window
           || typeof global !== "undefined" && global
           || typeof self   !== "undefined" && self
           || this; // eslint-disable-line no-invalid-this

/**
 * An immuable empty array.
 * @memberof util
 * @type {Array.<*>}
 * @const
 */
util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes

/**
 * An immutable empty object.
 * @type {Object}
 * @const
 */
util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes

/**
 * Whether running within node or not.
 * @memberof util
 * @type {boolean}
 * @const
 */
util.isNode = Boolean(util.global.process && util.global.process.versions && util.global.process.versions.node);

/**
 * Tests if the specified value is an integer.
 * @function
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is an integer
 */
util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
};

/**
 * Tests if the specified value is a string.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a string
 */
util.isString = function isString(value) {
    return typeof value === "string" || value instanceof String;
};

/**
 * Tests if the specified value is a non-null object.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a non-null object
 */
util.isObject = function isObject(value) {
    return value && typeof value === "object";
};

/**
 * Checks if a property on a message is considered to be present.
 * This is an alias of {@link util.isSet}.
 * @function
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isset =

/**
 * Checks if a property on a message is considered to be present.
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isSet = function isSet(obj, prop) {
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
};

/**
 * Any compatible Buffer instance.
 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
 * @interface Buffer
 * @extends Uint8Array
 */

/**
 * Node's Buffer class if available.
 * @type {Constructor<Buffer>}
 */
util.Buffer = (function() {
    try {
        var Buffer = util.inquire("buffer").Buffer;
        // refuse to use non-node buffers if not explicitly assigned (perf reasons):
        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
    } catch (e) {
        /* istanbul ignore next */
        return null;
    }
})();

// Internal alias of or polyfull for Buffer.from.
util._Buffer_from = null;

// Internal alias of or polyfill for Buffer.allocUnsafe.
util._Buffer_allocUnsafe = null;

/**
 * Creates a new buffer of whatever type supported by the environment.
 * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
 * @returns {Uint8Array|Buffer} Buffer
 */
util.newBuffer = function newBuffer(sizeOrArray) {
    /* istanbul ignore next */
    return typeof sizeOrArray === "number"
        ? util.Buffer
            ? util._Buffer_allocUnsafe(sizeOrArray)
            : new util.Array(sizeOrArray)
        : util.Buffer
            ? util._Buffer_from(sizeOrArray)
            : typeof Uint8Array === "undefined"
                ? sizeOrArray
                : new Uint8Array(sizeOrArray);
};

/**
 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
 * @type {Constructor<Uint8Array>}
 */
util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */ : Array;

/**
 * Any compatible Long instance.
 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
 * @interface Long
 * @property {number} low Low bits
 * @property {number} high High bits
 * @property {boolean} unsigned Whether unsigned or not
 */

/**
 * Long.js's Long class if available.
 * @type {Constructor<Long>}
 */
util.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long
         || /* istanbul ignore next */ util.global.Long
         || util.inquire("long");

/**
 * Regular expression used to verify 2 bit (`bool`) map keys.
 * @type {RegExp}
 * @const
 */
util.key2Re = /^true|false|0|1$/;

/**
 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;

/**
 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;

/**
 * Converts a number or long to an 8 characters long hash string.
 * @param {Long|number} value Value to convert
 * @returns {string} Hash
 */
util.longToHash = function longToHash(value) {
    return value
        ? util.LongBits.from(value).toHash()
        : util.LongBits.zeroHash;
};

/**
 * Converts an 8 characters long hash string to a long or number.
 * @param {string} hash Hash
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long|number} Original value
 */
util.longFromHash = function longFromHash(hash, unsigned) {
    var bits = util.LongBits.fromHash(hash);
    if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
};

/**
 * Merges the properties of the source object into the destination object.
 * @memberof util
 * @param {Object.<string,*>} dst Destination object
 * @param {Object.<string,*>} src Source object
 * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
 * @returns {Object.<string,*>} Destination object
 */
function merge(dst, src, ifNotSet) { // used by converters
    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === undefined || !ifNotSet)
            dst[keys[i]] = src[keys[i]];
    return dst;
}

util.merge = merge;

/**
 * Converts the first character of a string to lower case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.lcFirst = function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
};

/**
 * Creates a custom error constructor.
 * @memberof util
 * @param {string} name Error name
 * @returns {Constructor<Error>} Custom error constructor
 */
function newError(name) {

    function CustomError(message, properties) {

        if (!(this instanceof CustomError))
            return new CustomError(message, properties);

        // Error.call(this, message);
        // ^ just returns a new error instance because the ctor can be called as a function

        Object.defineProperty(this, "message", { get: function() { return message; } });

        /* istanbul ignore next */
        if (Error.captureStackTrace) // node
            Error.captureStackTrace(this, CustomError);
        else
            Object.defineProperty(this, "stack", { value: (new Error()).stack || "" });

        if (properties)
            merge(this, properties);
    }

    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;

    Object.defineProperty(CustomError.prototype, "name", { get: function() { return name; } });

    CustomError.prototype.toString = function toString() {
        return this.name + ": " + this.message;
    };

    return CustomError;
}

util.newError = newError;

/**
 * Constructs a new protocol error.
 * @classdesc Error subclass indicating a protocol specifc error.
 * @memberof util
 * @extends Error
 * @template T extends Message<T>
 * @constructor
 * @param {string} message Error message
 * @param {Object.<string,*>} [properties] Additional properties
 * @example
 * try {
 *     MyMessage.decode(someBuffer); // throws if required fields are missing
 * } catch (e) {
 *     if (e instanceof ProtocolError && e.instance)
 *         console.log("decoded so far: " + JSON.stringify(e.instance));
 * }
 */
util.ProtocolError = newError("ProtocolError");

/**
 * So far decoded message instance.
 * @name util.ProtocolError#instance
 * @type {Message<T>}
 */

/**
 * A OneOf getter as returned by {@link util.oneOfGetter}.
 * @typedef OneOfGetter
 * @type {function}
 * @returns {string|undefined} Set field name, if any
 */

/**
 * Builds a getter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfGetter} Unbound getter
 */
util.oneOfGetter = function getOneOf(fieldNames) {
    var fieldMap = {};
    for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;

    /**
     * @returns {string|undefined} Set field name, if any
     * @this Object
     * @ignore
     */
    return function() { // eslint-disable-line consistent-return
        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)
            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)
                return keys[i];
    };
};

/**
 * A OneOf setter as returned by {@link util.oneOfSetter}.
 * @typedef OneOfSetter
 * @type {function}
 * @param {string|undefined} value Field name
 * @returns {undefined}
 */

/**
 * Builds a setter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfSetter} Unbound setter
 */
util.oneOfSetter = function setOneOf(fieldNames) {

    /**
     * @param {string} name Field name
     * @returns {undefined}
     * @this Object
     * @ignore
     */
    return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
            if (fieldNames[i] !== name)
                delete this[fieldNames[i]];
    };
};

/**
 * Default conversion options used for {@link Message#toJSON} implementations.
 *
 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
 *
 * - Longs become strings
 * - Enums become string keys
 * - Bytes become base64 encoded strings
 * - (Sub-)Messages become plain objects
 * - Maps become plain objects with all string keys
 * - Repeated fields become arrays
 * - NaN and Infinity for float and double fields become strings
 *
 * @type {IConversionOptions}
 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
 */
util.toJSONOptions = {
    longs: String,
    enums: String,
    bytes: String,
    json: true
};

// Sets up buffer utility according to the environment (called in index-minimal)
util._configure = function() {
    var Buffer = util.Buffer;
    /* istanbul ignore if */
    if (!Buffer) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
    }
    // because node 4.x buffers are incompatible & immutable
    // see: https://github.com/dcodeIO/protobuf.js/pull/665
    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||
        /* istanbul ignore next */
        function Buffer_from(value, encoding) {
            return new Buffer(value, encoding);
        };
    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||
        /* istanbul ignore next */
        function Buffer_allocUnsafe(size) {
            return new Buffer(size);
        };
};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(20)))

/***/ }),
/* 20 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = asPromise;

/**
 * Callback as used by {@link util.asPromise}.
 * @typedef asPromiseCallback
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {...*} params Additional arguments
 * @returns {undefined}
 */

/**
 * Returns a promise from a node-style callback function.
 * @memberof util
 * @param {asPromiseCallback} fn Function to call
 * @param {*} ctx Function context
 * @param {...*} params Function arguments
 * @returns {Promise<*>} Promisified function
 */
function asPromise(fn, ctx/*, varargs */) {
    var params  = new Array(arguments.length - 1),
        offset  = 0,
        index   = 2,
        pending = true;
    while (index < arguments.length)
        params[offset++] = arguments[index++];
    return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err/*, varargs */) {
            if (pending) {
                pending = false;
                if (err)
                    reject(err);
                else {
                    var params = new Array(arguments.length - 1),
                        offset = 0;
                    while (offset < params.length)
                        params[offset++] = arguments[offset];
                    resolve.apply(null, params);
                }
            }
        };
        try {
            fn.apply(ctx || null, params);
        } catch (err) {
            if (pending) {
                pending = false;
                reject(err);
            }
        }
    });
}


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A minimal base64 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var base64 = exports;

/**
 * Calculates the byte length of a base64 encoded string.
 * @param {string} string Base64 encoded string
 * @returns {number} Byte length
 */
base64.length = function length(string) {
    var p = string.length;
    if (!p)
        return 0;
    var n = 0;
    while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
    return Math.ceil(string.length * 3) / 4 - n;
};

// Base64 encoding table
var b64 = new Array(64);

// Base64 decoding table
var s64 = new Array(123);

// 65..90, 97..122, 48..57, 43, 47
for (var i = 0; i < 64;)
    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;

/**
 * Encodes a buffer to a base64 encoded string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} Base64 encoded string
 */
base64.encode = function encode(buffer, start, end) {
    var parts = null,
        chunk = [];
    var i = 0, // output index
        j = 0, // goto index
        t;     // temporary
    while (start < end) {
        var b = buffer[start++];
        switch (j) {
            case 0:
                chunk[i++] = b64[b >> 2];
                t = (b & 3) << 4;
                j = 1;
                break;
            case 1:
                chunk[i++] = b64[t | b >> 4];
                t = (b & 15) << 2;
                j = 2;
                break;
            case 2:
                chunk[i++] = b64[t | b >> 6];
                chunk[i++] = b64[b & 63];
                j = 0;
                break;
        }
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (j) {
        chunk[i++] = b64[t];
        chunk[i++] = 61;
        if (j === 1)
            chunk[i++] = 61;
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

var invalidEncoding = "invalid encoding";

/**
 * Decodes a base64 encoded string to a buffer.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Number of bytes written
 * @throws {Error} If encoding is invalid
 */
base64.decode = function decode(string, buffer, offset) {
    var start = offset;
    var j = 0, // goto index
        t;     // temporary
    for (var i = 0; i < string.length;) {
        var c = string.charCodeAt(i++);
        if (c === 61 && j > 1)
            break;
        if ((c = s64[c]) === undefined)
            throw Error(invalidEncoding);
        switch (j) {
            case 0:
                t = c;
                j = 1;
                break;
            case 1:
                buffer[offset++] = t << 2 | (c & 48) >> 4;
                t = c;
                j = 2;
                break;
            case 2:
                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
                t = c;
                j = 3;
                break;
            case 3:
                buffer[offset++] = (t & 3) << 6 | c;
                j = 0;
                break;
        }
    }
    if (j === 1)
        throw Error(invalidEncoding);
    return offset - start;
};

/**
 * Tests if the specified string appears to be base64 encoded.
 * @param {string} string String to test
 * @returns {boolean} `true` if probably base64 encoded, otherwise false
 */
base64.test = function test(string) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
};


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = EventEmitter;

/**
 * Constructs a new event emitter instance.
 * @classdesc A minimal event emitter.
 * @memberof util
 * @constructor
 */
function EventEmitter() {

    /**
     * Registered listeners.
     * @type {Object.<string,*>}
     * @private
     */
    this._listeners = {};
}

/**
 * Registers an event listener.
 * @param {string} evt Event name
 * @param {function} fn Listener
 * @param {*} [ctx] Listener context
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.on = function on(evt, fn, ctx) {
    (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn  : fn,
        ctx : ctx || this
    });
    return this;
};

/**
 * Removes an event listener or any matching listeners if arguments are omitted.
 * @param {string} [evt] Event name. Removes all listeners if omitted.
 * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.off = function off(evt, fn) {
    if (evt === undefined)
        this._listeners = {};
    else {
        if (fn === undefined)
            this._listeners[evt] = [];
        else {
            var listeners = this._listeners[evt];
            for (var i = 0; i < listeners.length;)
                if (listeners[i].fn === fn)
                    listeners.splice(i, 1);
                else
                    ++i;
        }
    }
    return this;
};

/**
 * Emits an event by calling its listeners with the specified arguments.
 * @param {string} evt Event name
 * @param {...*} args Arguments
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.emit = function emit(evt) {
    var listeners = this._listeners[evt];
    if (listeners) {
        var args = [],
            i = 1;
        for (; i < arguments.length;)
            args.push(arguments[i++]);
        for (i = 0; i < listeners.length;)
            listeners[i].fn.apply(listeners[i++].ctx, args);
    }
    return this;
};


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = factory(factory);

/**
 * Reads / writes floats / doubles from / to buffers.
 * @name util.float
 * @namespace
 */

/**
 * Writes a 32 bit float to a buffer using little endian byte order.
 * @name util.float.writeFloatLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 32 bit float to a buffer using big endian byte order.
 * @name util.float.writeFloatBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 32 bit float from a buffer using little endian byte order.
 * @name util.float.readFloatLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 32 bit float from a buffer using big endian byte order.
 * @name util.float.readFloatBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Writes a 64 bit double to a buffer using little endian byte order.
 * @name util.float.writeDoubleLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 64 bit double to a buffer using big endian byte order.
 * @name util.float.writeDoubleBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 64 bit double from a buffer using little endian byte order.
 * @name util.float.readDoubleLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 64 bit double from a buffer using big endian byte order.
 * @name util.float.readDoubleBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

// Factory function for the purpose of node-based testing in modified global environments
function factory(exports) {

    // float: typed array
    if (typeof Float32Array !== "undefined") (function() {

        var f32 = new Float32Array([ -0 ]),
            f8b = new Uint8Array(f32.buffer),
            le  = f8b[3] === 128;

        function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
        }

        function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        /* istanbul ignore next */
        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

        function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
        }

        function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos    ];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
        }

        /* istanbul ignore next */
        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        /* istanbul ignore next */
        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;

    // float: ieee754
    })(); else (function() {

        function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0)
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);
            else if (isNaN(val))
                writeUint(2143289344, buf, pos);
            else if (val > 3.4028234663852886e+38) // +-Infinity
                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 1.1754943508222875e-38) // denormal
                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);
            else {
                var exponent = Math.floor(Math.log(val) / Math.LN2),
                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
        }

        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

        function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos),
                sign = (uint >> 31) * 2 + 1,
                exponent = uint >>> 23 & 255,
                mantissa = uint & 8388607;
            return exponent === 255
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 1.401298464324817e-45 * mantissa
                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }

        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);

    })();

    // double: typed array
    if (typeof Float64Array !== "undefined") (function() {

        var f64 = new Float64Array([-0]),
            f8b = new Uint8Array(f64.buffer),
            le  = f8b[7] === 128;

        function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
        }

        function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        /* istanbul ignore next */
        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;

        function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
        }

        function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos    ];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
        }

        /* istanbul ignore next */
        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        /* istanbul ignore next */
        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;

    // double: ieee754
    })(); else (function() {

        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0) {
                writeUint(0, buf, pos + off0);
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);
            } else if (isNaN(val)) {
                writeUint(0, buf, pos + off0);
                writeUint(2146959360, buf, pos + off1);
            } else if (val > 1.7976931348623157e+308) { // +-Infinity
                writeUint(0, buf, pos + off0);
                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
                var mantissa;
                if (val < 2.2250738585072014e-308) { // denormal
                    mantissa = val / 5e-324;
                    writeUint(mantissa >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
                } else {
                    var exponent = Math.floor(Math.log(val) / Math.LN2);
                    if (exponent === 1024)
                        exponent = 1023;
                    mantissa = val * Math.pow(2, -exponent);
                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
                }
            }
        }

        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);

        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0),
                hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1,
                exponent = hi >>> 20 & 2047,
                mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 5e-324 * mantissa
                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }

        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);

    })();

    return exports;
}

// uint helpers

function writeUintLE(val, buf, pos) {
    buf[pos    ] =  val        & 255;
    buf[pos + 1] =  val >>> 8  & 255;
    buf[pos + 2] =  val >>> 16 & 255;
    buf[pos + 3] =  val >>> 24;
}

function writeUintBE(val, buf, pos) {
    buf[pos    ] =  val >>> 24;
    buf[pos + 1] =  val >>> 16 & 255;
    buf[pos + 2] =  val >>> 8  & 255;
    buf[pos + 3] =  val        & 255;
}

function readUintLE(buf, pos) {
    return (buf[pos    ]
          | buf[pos + 1] << 8
          | buf[pos + 2] << 16
          | buf[pos + 3] << 24) >>> 0;
}

function readUintBE(buf, pos) {
    return (buf[pos    ] << 24
          | buf[pos + 1] << 16
          | buf[pos + 2] << 8
          | buf[pos + 3]) >>> 0;
}


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = inquire;

/**
 * Requires a module only if available.
 * @memberof util
 * @param {string} moduleName Module to require
 * @returns {?Object} Required module if available and not empty, otherwise `null`
 */
function inquire(moduleName) {
    try {
        var mod = eval("quire".replace(/^/,"re"))(moduleName); // eslint-disable-line no-eval
        if (mod && (mod.length || Object.keys(mod).length))
            return mod;
    } catch (e) {} // eslint-disable-line no-empty
    return null;
}


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A minimal UTF8 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var utf8 = exports;

/**
 * Calculates the UTF8 byte length of a string.
 * @param {string} string String
 * @returns {number} Byte length
 */
utf8.length = function utf8_length(string) {
    var len = 0,
        c = 0;
    for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
            len += 1;
        else if (c < 2048)
            len += 2;
        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
            ++i;
            len += 4;
        } else
            len += 3;
    }
    return len;
};

/**
 * Reads UTF8 bytes as a string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} String read
 */
utf8.read = function utf8_read(buffer, start, end) {
    var len = end - start;
    if (len < 1)
        return "";
    var parts = null,
        chunk = [],
        i = 0, // char offset
        t;     // temporary
    while (start < end) {
        t = buffer[start++];
        if (t < 128)
            chunk[i++] = t;
        else if (t > 191 && t < 224)
            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
            chunk[i++] = 0xD800 + (t >> 10);
            chunk[i++] = 0xDC00 + (t & 1023);
        } else
            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

/**
 * Writes a string as UTF8 bytes.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Bytes written
 */
utf8.write = function utf8_write(string, buffer, offset) {
    var start = offset,
        c1, // character 1
        c2; // character 2
    for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
            buffer[offset++] = c1;
        } else if (c1 < 2048) {
            buffer[offset++] = c1 >> 6       | 192;
            buffer[offset++] = c1       & 63 | 128;
        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
            ++i;
            buffer[offset++] = c1 >> 18      | 240;
            buffer[offset++] = c1 >> 12 & 63 | 128;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        } else {
            buffer[offset++] = c1 >> 12      | 224;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        }
    }
    return offset - start;
};


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = pool;

/**
 * An allocator as used by {@link util.pool}.
 * @typedef PoolAllocator
 * @type {function}
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */

/**
 * A slicer as used by {@link util.pool}.
 * @typedef PoolSlicer
 * @type {function}
 * @param {number} start Start offset
 * @param {number} end End offset
 * @returns {Uint8Array} Buffer slice
 * @this {Uint8Array}
 */

/**
 * A general purpose buffer pool.
 * @memberof util
 * @function
 * @param {PoolAllocator} alloc Allocator
 * @param {PoolSlicer} slice Slicer
 * @param {number} [size=8192] Slab size
 * @returns {PoolAllocator} Pooled allocator
 */
function pool(alloc, slice, size) {
    var SIZE   = size || 8192;
    var MAX    = SIZE >>> 1;
    var slab   = null;
    var offset = SIZE;
    return function pool_alloc(size) {
        if (size < 1 || size > MAX)
            return alloc(size);
        if (offset + size > SIZE) {
            slab = alloc(SIZE);
            offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size);
        if (offset & 7) // align to 32 bit
            offset = (offset | 7) + 1;
        return buf;
    };
}


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = LongBits;

var util = __webpack_require__(19);

/**
 * Constructs new long bits.
 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
 * @memberof util
 * @constructor
 * @param {number} lo Low 32 bits, unsigned
 * @param {number} hi High 32 bits, unsigned
 */
function LongBits(lo, hi) {

    // note that the casts below are theoretically unnecessary as of today, but older statically
    // generated converter code might still call the ctor with signed 32bits. kept for compat.

    /**
     * Low bits.
     * @type {number}
     */
    this.lo = lo >>> 0;

    /**
     * High bits.
     * @type {number}
     */
    this.hi = hi >>> 0;
}

/**
 * Zero bits.
 * @memberof util.LongBits
 * @type {util.LongBits}
 */
var zero = LongBits.zero = new LongBits(0, 0);

zero.toNumber = function() { return 0; };
zero.zzEncode = zero.zzDecode = function() { return this; };
zero.length = function() { return 1; };

/**
 * Zero hash.
 * @memberof util.LongBits
 * @type {string}
 */
var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";

/**
 * Constructs new long bits from the specified number.
 * @param {number} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.fromNumber = function fromNumber(value) {
    if (value === 0)
        return zero;
    var sign = value < 0;
    if (sign)
        value = -value;
    var lo = value >>> 0,
        hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
            lo = 0;
            if (++hi > 4294967295)
                hi = 0;
        }
    }
    return new LongBits(lo, hi);
};

/**
 * Constructs new long bits from a number, long or string.
 * @param {Long|number|string} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.from = function from(value) {
    if (typeof value === "number")
        return LongBits.fromNumber(value);
    if (util.isString(value)) {
        /* istanbul ignore else */
        if (util.Long)
            value = util.Long.fromString(value);
        else
            return LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
};

/**
 * Converts this long bits to a possibly unsafe JavaScript number.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {number} Possibly unsafe number
 */
LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0,
            hi = ~this.hi     >>> 0;
        if (!lo)
            hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
};

/**
 * Converts this long bits to a long.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long} Long
 */
LongBits.prototype.toLong = function toLong(unsigned) {
    return util.Long
        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
        /* istanbul ignore next */
        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
};

var charCodeAt = String.prototype.charCodeAt;

/**
 * Constructs new long bits from the specified 8 characters long hash.
 * @param {string} hash Hash
 * @returns {util.LongBits} Bits
 */
LongBits.fromHash = function fromHash(hash) {
    if (hash === zeroHash)
        return zero;
    return new LongBits(
        ( charCodeAt.call(hash, 0)
        | charCodeAt.call(hash, 1) << 8
        | charCodeAt.call(hash, 2) << 16
        | charCodeAt.call(hash, 3) << 24) >>> 0
    ,
        ( charCodeAt.call(hash, 4)
        | charCodeAt.call(hash, 5) << 8
        | charCodeAt.call(hash, 6) << 16
        | charCodeAt.call(hash, 7) << 24) >>> 0
    );
};

/**
 * Converts this long bits to a 8 characters long hash.
 * @returns {string} Hash
 */
LongBits.prototype.toHash = function toHash() {
    return String.fromCharCode(
        this.lo        & 255,
        this.lo >>> 8  & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24      ,
        this.hi        & 255,
        this.hi >>> 8  & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
    );
};

/**
 * Zig-zag encodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzEncode = function zzEncode() {
    var mask =   this.hi >> 31;
    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;
    return this;
};

/**
 * Zig-zag decodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;
    return this;
};

/**
 * Calculates the length of this longbits when encoded as a varint.
 * @returns {number} Length
 */
LongBits.prototype.length = function length() {
    var part0 =  this.lo,
        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
        part2 =  this.hi >>> 24;
    return part2 === 0
         ? part1 === 0
           ? part0 < 16384
             ? part0 < 128 ? 1 : 2
             : part0 < 2097152 ? 3 : 4
           : part1 < 16384
             ? part1 < 128 ? 5 : 6
             : part1 < 2097152 ? 7 : 8
         : part2 < 128 ? 9 : 10;
};


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = BufferWriter;

// extends Writer
var Writer = __webpack_require__(18);
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;

var util = __webpack_require__(19);

var Buffer = util.Buffer;

/**
 * Constructs a new buffer writer instance.
 * @classdesc Wire format writer using node buffers.
 * @extends Writer
 * @constructor
 */
function BufferWriter() {
    Writer.call(this);
}

/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Buffer} Buffer
 */
BufferWriter.alloc = function alloc_buffer(size) {
    return (BufferWriter.alloc = util._Buffer_allocUnsafe)(size);
};

var writeBytesBuffer = Buffer && Buffer.prototype instanceof Uint8Array && Buffer.prototype.set.name === "set"
    ? function writeBytesBuffer_set(val, buf, pos) {
        buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
                           // also works for plain array values
    }
    /* istanbul ignore next */
    : function writeBytesBuffer_copy(val, buf, pos) {
        if (val.copy) // Buffer values
            val.copy(buf, pos, 0, val.length);
        else for (var i = 0; i < val.length;) // plain array values
            buf[pos++] = val[i++];
    };

/**
 * @override
 */
BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
    if (util.isString(value))
        value = util._Buffer_from(value, "base64");
    var len = value.length >>> 0;
    this.uint32(len);
    if (len)
        this._push(writeBytesBuffer, len, value);
    return this;
};

function writeStringBuffer(val, buf, pos) {
    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)
        util.utf8.write(val, buf, pos);
    else
        buf.utf8Write(val, pos);
}

/**
 * @override
 */
BufferWriter.prototype.string = function write_string_buffer(value) {
    var len = Buffer.byteLength(value);
    this.uint32(len);
    if (len)
        this._push(writeStringBuffer, len, value);
    return this;
};


/**
 * Finishes the write operation.
 * @name BufferWriter#finish
 * @function
 * @returns {Buffer} Finished buffer
 */


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Reader;

var util      = __webpack_require__(19);

var BufferReader; // cyclic

var LongBits  = util.LongBits,
    utf8      = util.utf8;

/* istanbul ignore next */
function indexOutOfRange(reader, writeLength) {
    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
}

/**
 * Constructs a new reader instance using the specified buffer.
 * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 * @param {Uint8Array} buffer Buffer to read from
 */
function Reader(buffer) {

    /**
     * Read buffer.
     * @type {Uint8Array}
     */
    this.buf = buffer;

    /**
     * Read buffer position.
     * @type {number}
     */
    this.pos = 0;

    /**
     * Read buffer length.
     * @type {number}
     */
    this.len = buffer.length;
}

var create_array = typeof Uint8Array !== "undefined"
    ? function create_typed_array(buffer) {
        if (buffer instanceof Uint8Array || Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    }
    /* istanbul ignore next */
    : function create_array(buffer) {
        if (Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    };

/**
 * Creates a new reader using the specified buffer.
 * @function
 * @param {Uint8Array|Buffer} buffer Buffer to read from
 * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
 * @throws {Error} If `buffer` is not a valid buffer
 */
Reader.create = util.Buffer
    ? function create_buffer_setup(buffer) {
        return (Reader.create = function create_buffer(buffer) {
            return util.Buffer.isBuffer(buffer)
                ? new BufferReader(buffer)
                /* istanbul ignore next */
                : create_array(buffer);
        })(buffer);
    }
    /* istanbul ignore next */
    : create_array;

Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;

/**
 * Reads a varint as an unsigned 32 bit value.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.uint32 = (function read_uint32_setup() {
    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
    return function read_uint32() {
        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;

        /* istanbul ignore if */
        if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
        }
        return value;
    };
})();

/**
 * Reads a varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
};

/**
 * Reads a zig-zag encoded varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.sint32 = function read_sint32() {
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
};

/* eslint-disable no-invalid-this */

function readLongVarint() {
    // tends to deopt with local vars for octet etc.
    var bits = new LongBits(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) { // fast route (lo)
        for (; i < 4; ++i) {
            // 1st..4th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 5th
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;
        if (this.buf[this.pos++] < 128)
            return bits;
        i = 0;
    } else {
        for (; i < 3; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 1st..3th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 4th
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
    }
    if (this.len - this.pos > 4) { // fast route (hi)
        for (; i < 5; ++i) {
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    } else {
        for (; i < 5; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    }
    /* istanbul ignore next */
    throw Error("invalid varint encoding");
}

/* eslint-enable no-invalid-this */

/**
 * Reads a varint as a signed 64 bit value.
 * @name Reader#int64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as an unsigned 64 bit value.
 * @name Reader#uint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a zig-zag encoded varint as a signed 64 bit value.
 * @name Reader#sint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as a boolean.
 * @returns {boolean} Value read
 */
Reader.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
};

function readFixed32_end(buf, end) { // note that this uses `end`, not `pos`
    return (buf[end - 4]
          | buf[end - 3] << 8
          | buf[end - 2] << 16
          | buf[end - 1] << 24) >>> 0;
}

/**
 * Reads fixed 32 bits as an unsigned 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.fixed32 = function read_fixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4);
};

/**
 * Reads fixed 32 bits as a signed 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.sfixed32 = function read_sfixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4) | 0;
};

/* eslint-disable no-invalid-this */

function readFixed64(/* this: Reader */) {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);

    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}

/* eslint-enable no-invalid-this */

/**
 * Reads fixed 64 bits.
 * @name Reader#fixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads zig-zag encoded fixed 64 bits.
 * @name Reader#sfixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a float (32 bit) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.float = function read_float() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
};

/**
 * Reads a double (64 bit float) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.double = function read_double() {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @returns {Uint8Array} Value read
 */
Reader.prototype.bytes = function read_bytes() {
    var length = this.uint32(),
        start  = this.pos,
        end    = this.pos + length;

    /* istanbul ignore if */
    if (end > this.len)
        throw indexOutOfRange(this, length);

    this.pos += length;
    if (Array.isArray(this.buf)) // plain array
        return this.buf.slice(start, end);
    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1
        ? new this.buf.constructor(0)
        : this._slice.call(this.buf, start, end);
};

/**
 * Reads a string preceeded by its byte length as a varint.
 * @returns {string} Value read
 */
Reader.prototype.string = function read_string() {
    var bytes = this.bytes();
    return utf8.read(bytes, 0, bytes.length);
};

/**
 * Skips the specified number of bytes if specified, otherwise skips a varint.
 * @param {number} [length] Length if known, otherwise a varint is assumed
 * @returns {Reader} `this`
 */
Reader.prototype.skip = function skip(length) {
    if (typeof length === "number") {
        /* istanbul ignore if */
        if (this.pos + length > this.len)
            throw indexOutOfRange(this, length);
        this.pos += length;
    } else {
        do {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
    }
    return this;
};

/**
 * Skips the next element of the specified wire type.
 * @param {number} wireType Wire type received
 * @returns {Reader} `this`
 */
Reader.prototype.skipType = function(wireType) {
    switch (wireType) {
        case 0:
            this.skip();
            break;
        case 1:
            this.skip(8);
            break;
        case 2:
            this.skip(this.uint32());
            break;
        case 3:
            while ((wireType = this.uint32() & 7) !== 4) {
                this.skipType(wireType);
            }
            break;
        case 5:
            this.skip(4);
            break;

        /* istanbul ignore next */
        default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
};

Reader._configure = function(BufferReader_) {
    BufferReader = BufferReader_;

    var fn = util.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
    util.merge(Reader.prototype, {

        int64: function read_int64() {
            return readLongVarint.call(this)[fn](false);
        },

        uint64: function read_uint64() {
            return readLongVarint.call(this)[fn](true);
        },

        sint64: function read_sint64() {
            return readLongVarint.call(this).zzDecode()[fn](false);
        },

        fixed64: function read_fixed64() {
            return readFixed64.call(this)[fn](true);
        },

        sfixed64: function read_sfixed64() {
            return readFixed64.call(this)[fn](false);
        }

    });
};


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = BufferReader;

// extends Reader
var Reader = __webpack_require__(30);
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;

var util = __webpack_require__(19);

/**
 * Constructs a new buffer reader instance.
 * @classdesc Wire format reader using node buffers.
 * @extends Reader
 * @constructor
 * @param {Buffer} buffer Buffer to read from
 */
function BufferReader(buffer) {
    Reader.call(this, buffer);

    /**
     * Read buffer.
     * @name BufferReader#buf
     * @type {Buffer}
     */
}

/* istanbul ignore else */
if (util.Buffer)
    BufferReader.prototype._slice = util.Buffer.prototype.slice;

/**
 * @override
 */
BufferReader.prototype.string = function read_string_buffer() {
    var len = this.uint32(); // modifies pos
    return this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len));
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @name BufferReader#bytes
 * @function
 * @returns {Buffer} Value read
 */


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Streaming RPC helpers.
 * @namespace
 */
var rpc = exports;

/**
 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
 * @typedef RPCImpl
 * @type {function}
 * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
 * @param {Uint8Array} requestData Request data
 * @param {RPCImplCallback} callback Callback function
 * @returns {undefined}
 * @example
 * function rpcImpl(method, requestData, callback) {
 *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
 *         throw Error("no such method");
 *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
 *         callback(err, responseData);
 *     });
 * }
 */

/**
 * Node-style callback as used by {@link RPCImpl}.
 * @typedef RPCImplCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
 * @returns {undefined}
 */

rpc.Service = __webpack_require__(33);


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Service;

var util = __webpack_require__(19);

// Extends EventEmitter
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;

/**
 * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
 *
 * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
 * @typedef rpc.ServiceMethodCallback
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {TRes} [response] Response message
 * @returns {undefined}
 */

/**
 * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
 * @typedef rpc.ServiceMethod
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
 * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
 */

/**
 * Constructs a new RPC service instance.
 * @classdesc An RPC service as returned by {@link Service#create}.
 * @exports rpc.Service
 * @extends util.EventEmitter
 * @constructor
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 */
function Service(rpcImpl, requestDelimited, responseDelimited) {

    if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");

    util.EventEmitter.call(this);

    /**
     * RPC implementation. Becomes `null` once the service is ended.
     * @type {RPCImpl|null}
     */
    this.rpcImpl = rpcImpl;

    /**
     * Whether requests are length-delimited.
     * @type {boolean}
     */
    this.requestDelimited = Boolean(requestDelimited);

    /**
     * Whether responses are length-delimited.
     * @type {boolean}
     */
    this.responseDelimited = Boolean(responseDelimited);
}

/**
 * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
 * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
 * @param {Constructor<TReq>} requestCtor Request constructor
 * @param {Constructor<TRes>} responseCtor Response constructor
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
 * @returns {undefined}
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 */
Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {

    if (!request)
        throw TypeError("request must be specified");

    var self = this;
    if (!callback)
        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

    if (!self.rpcImpl) {
        setTimeout(function() { callback(Error("already ended")); }, 0);
        return undefined;
    }

    try {
        return self.rpcImpl(
            method,
            requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
            function rpcCallback(err, response) {

                if (err) {
                    self.emit("error", err, method);
                    return callback(err);
                }

                if (response === null) {
                    self.end(/* endedByRPC */ true);
                    return undefined;
                }

                if (!(response instanceof responseCtor)) {
                    try {
                        response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
                    } catch (err) {
                        self.emit("error", err, method);
                        return callback(err);
                    }
                }

                self.emit("data", response, method);
                return callback(null, response);
            }
        );
    } catch (err) {
        self.emit("error", err, method);
        setTimeout(function() { callback(err); }, 0);
        return undefined;
    }
};

/**
 * Ends this service and emits the `end` event.
 * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
 * @returns {rpc.Service} `this`
 */
Service.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
        if (!endedByRPC) // signal end to rpcImpl
            this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
    }
    return this;
};


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = {};

/**
 * Named roots.
 * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
 * Can also be used manually to make roots available accross modules.
 * @name roots
 * @type {Object.<string,Root>}
 * @example
 * // pbjs -r myroot -o compiled.js ...
 *
 * // in another module:
 * require("./compiled.js");
 *
 * // in any subsequent module:
 * var root = protobuf.roots["myroot"];
 */


/***/ }),
/* 35 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DfGlyphDeliveryManager; });
/**
 * This class is responsible for enriching font and the atlas by new glyphs. The glyph source is abstracted and
 * should be specified in concrete descendants by implementing _getGlyphRange(), more likely it will be an http call.
 */
class DfGlyphDeliveryManager {
    constructor(fontRegistry, atlas) {
        this._fontRegistry = fontRegistry;
        this._atlas = atlas;
        this._rangeRequests = new Map();
    }
    /**
     * Requests glyphs via provider and stores them. Glyphs are requested by ranges, that is kind of an optimisation,
     * as it is more likely that subsequent glyph requests will be in those ranges too.
     */
    fetchGlyphs(fontId, glyphIds) {
        const requests = new Set();
        for (const glyphId of glyphIds) {
            // to save HTTP requests glyphs are requested by ranges, but this optimisation doesn't work well for asian
            // writings, where glyphs are highly scattered (such ranges contains not so many really used glyphs).
            // 10000 threshold is just a magic number that "works" (there is no reliable method to choose the strategy)
            // TODO: checkout https://st.yandex-team.ru/MAPSRENDER-2127 resolution and update this hack accordingly
            const rangeLength = glyphId > 10000 ? 1 : 256;
            const range = glyphId - glyphId % rangeLength;
            const fullRangeName = fontId + range;
            let request = this._rangeRequests.get(fullRangeName);
            if (!request) {
                request = this._getGlyphRange(fontId, range, range + rangeLength - 1);
                request.then(this._onNewRange.bind(this, fontId));
                this._rangeRequests.set(fullRangeName, request);
            }
            requests.add(request);
        }
        return Promise.all(requests);
    }
    /**
     * Handles incoming glyph range response. It adds new glyphs to font and atlas.
     */
    _onNewRange(fontId, glyphs) {
        for (const glyph of glyphs) {
            const font = this._fontRegistry.get(fontId);
            font.addGlyph(glyph);
            this._atlas.allocateGlyph(fontId, glyph, font.margin);
        }
    }
}


/***/ }),
/* 36 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getHostAliasByUid", function() { return getHostAliasByUid; });
const HOST_ALIASES_N = 4;
function getHostAliasByUid(uid) {
    let sum = 0;
    for (let i = 0; i < uid.length; i++) {
        sum += uid.charCodeAt(i);
    }
    return (sum % HOST_ALIASES_N + 1).toString();
}


/***/ }),
/* 37 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTileIdByRawValues", function() { return getTileIdByRawValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTileId", function() { return getTileId; });
function getTileIdByRawValues(x, y, zoom) {
    return `${x}:${y}:${zoom}`;
}
function getTileId(tile) {
    return getTileIdByRawValues(tile.x, tile.y, tile.zoom);
}


/***/ }),
/* 38 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OPAQUE_BLACK", function() { return OPAQUE_BLACK; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TRANSPARENT_BLACK", function() { return TRANSPARENT_BLACK; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "areEqual", function() { return areEqual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodeAbgr8", function() { return decodeAbgr8; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encodeRgba8", function() { return encodeRgba8; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isOpaque", function() { return isOpaque; });
const OPAQUE_BLACK = create(0, 0, 0, 1);
const TRANSPARENT_BLACK = create(0, 0, 0, 0);
/**
 * @param r Red component as a normalized value [0..1]
 * @param g Green component as a normalized value [0..1]
 * @param b Blue component as a normalized value [0..1]
 * @param a Alpha component as a normalized value [0..1]
 *
 * @returns A color with given values assigned to components.
 */
function create(r, g, b, a = 1) {
    return { r, g, b, a };
}
/**
 * Copies a color to another one.
 *
 * @param src The source color.
 * @param dst The color the source color will be copied to.
 * @returns `dst`.
 */
function copy(src, dst = create(0, 0, 0, 0)) {
    dst.r = src.r;
    dst.g = src.g;
    dst.b = src.b;
    dst.a = src.a;
    return dst;
}
function areEqual(c1, c2) {
    return c1.r === c2.r && c1.g === c2.g && c1.b === c2.b && c1.a === c2.a;
}
/**
 * Decodes a color represented as four 8-bit channels encoded into a 32-bit
 * number in ABGR order (from MSB to LSB).
 *
 * @param color Color encoded into unsigned 32-bit integer.
 * @returns Decoded color.
 */
function decodeAbgr8(color) {
    return {
        r: (color >>> 24) / 0xff,
        g: (color >>> 16 & 0xff) / 0xff,
        b: (color >>> 8 & 0xff) / 0xff,
        a: (color & 0xff) / 0xff
    };
}
/**
 * Encodes a color components into four 8 bit numbers packed into 32-bit one.
 *
 * @param c The color to be encoded.
 * @returns The color as 32-bit integer.
 */
function encodeRgba8(c) {
    return (c.r * 0xff |
        (c.g * 0xff << 8) |
        (c.b * 0xff << 16) |
        (c.a * 0xff << 24));
}
/**
 * Checks if a color is completely opaque.
 *
 * @param color The color to be checked.
 * @returns `true` if the color is opaque and `false` otherwise.
 */
function isOpaque(color) {
    return color.a === 1;
}


/***/ }),
/* 39 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return extractPoints; });
/* harmony import */ var _tile_world_coordinates_converter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _math_vector2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(43);
/* harmony import */ var _extract_styles__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(45);



/**
 * Utility method for getting point specific style details from a zoom slice.
 * To be used as a zoom slice style converter for style extractor.
 */
function convertZoomSliceToStyle(slice, styleBase) {
    const style = slice.point;
    return style && style.icon ? Object.assign({}, styleBase, { imageId: style.icon.id, 
        // Offsets are specified in the coordinate system with top-to-bottom Y axe, so `1 - style.anchorY` instead
        // of `style.anchorY` is used.
        offset: _math_vector2__WEBPACK_IMPORTED_MODULE_1__["create"](-style.anchorX * style.icon.width, (style.anchorY - 1) * style.icon.width), width: style.icon.width }) :
        undefined;
}
/**
 * Utility method for getting points from API tile response.
 */
function* extractPoints(tile, decodedApiTile, tileMinZoom, tileMaxZoom) {
    const points = decodedApiTile.points;
    if (points) {
        const converter = new _tile_world_coordinates_converter__WEBPACK_IMPORTED_MODULE_0__["default"](tile);
        for (let i = 0; i < points.classId.length; i++) {
            yield {
                position: converter.toWorldCoordinates(points.coordsx[i], points.coordsy[i]),
                styles: [
                    ...Object(_extract_styles__WEBPACK_IMPORTED_MODULE_2__["default"])(decodedApiTile.presentation, points.classId[i], convertZoomSliceToStyle, tileMinZoom, tileMaxZoom)
                ]
            };
        }
    }
}


/***/ }),
/* 40 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isTileEdgeCoordinates", function() { return isTileEdgeCoordinates; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TileWorldCoordinatesConverter; });
/* harmony import */ var _tile_based_adapter_util_tile_system__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(41);
/* harmony import */ var _math_vector2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(43);
/* harmony import */ var _math_scalar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(42);



// Tiles from API coordinates are defined in [-0x4000; 0x3FFF] range. See tile.proto for details.
const TILE_MIN_COORDINATE = -0x4000;
const TILE_MAX_COORDINATE = 0x3FFF;
/**
 * Check if point with specified coordinates lays on an edge of a tile.
 */
function isTileEdgeCoordinates(tileXCoordinate, tileYCoordinate) {
    return (tileXCoordinate === TILE_MIN_COORDINATE ||
        tileXCoordinate === TILE_MAX_COORDINATE ||
        tileYCoordinate === TILE_MIN_COORDINATE ||
        tileYCoordinate === TILE_MAX_COORDINATE);
}
/**
 * Coordinates converter, from tile units (taking into account tile position) to world units.
 */
class TileWorldCoordinatesConverter {
    constructor(tile) {
        const worldTileSystem = new _tile_based_adapter_util_tile_system__WEBPACK_IMPORTED_MODULE_0__["default"](tile.zoom);
        const tileOffset = worldTileSystem.getTileOffset(tile);
        const tileSize = worldTileSystem.getTileSize();
        const tileCenterOffset = tileSize / 2;
        this._tileCenter = _math_vector2__WEBPACK_IMPORTED_MODULE_1__["create"](tileOffset.x + tileCenterOffset, tileOffset.y - tileCenterOffset);
        this._tileWorldRatio = tileSize / (TILE_MAX_COORDINATE - TILE_MIN_COORDINATE);
    }
    /**
     * @return World's x coordinate that corresponds to the tile's one.
     */
    toWorldXCoordinate(tileXCoordinate) {
        return Object(_math_scalar__WEBPACK_IMPORTED_MODULE_2__["clamp"])(this._tileCenter.x + tileXCoordinate * this._tileWorldRatio, -1, 1);
    }
    /**
     * @return World's y coordinate that corresponds to the tile's one.
     */
    toWorldYCoordinate(tileYCoordinate) {
        return Object(_math_scalar__WEBPACK_IMPORTED_MODULE_2__["clamp"])(this._tileCenter.y - tileYCoordinate * this._tileWorldRatio, -1, 1);
    }
    /**
     * @return World's z coordinate that corresponds to the tile's one.
     */
    toWorldZCoordinate(tileZCoordinate) {
        return tileZCoordinate * this._tileWorldRatio;
    }
    /**
     * @return World's coordinates that corresponds to the tile's ones.
     */
    toWorldCoordinates(tileXCoordinate, tileYCoordinate) {
        return _math_vector2__WEBPACK_IMPORTED_MODULE_1__["create"](this.toWorldXCoordinate(tileXCoordinate), this.toWorldYCoordinate(tileYCoordinate));
    }
}


/***/ }),
/* 41 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isParent", function() { return isParent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TileCoordinateSystem; });
/* harmony import */ var _math_scalar__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(42);

/**
 * @return `true` if the first param overlaps the second in tile hierarchy.
 */
function isParent(potentialParent, possibleChild) {
    const zoomDiff = possibleChild.zoom - potentialParent.zoom;
    return zoomDiff > 0 &&
        possibleChild.x >> zoomDiff === potentialParent.x &&
        possibleChild.y >> zoomDiff === potentialParent.y;
}
class TileCoordinateSystem {
    constructor(zoom) {
        this._zoom = Math.ceil(Object(_math_scalar__WEBPACK_IMPORTED_MODULE_0__["clamp"])(zoom, 0, 31));
        this._tileSize = 2 / (1 << this._zoom);
    }
    getZoom() {
        return this._zoom;
    }
    /**
     * @return Tile side length in units of the world coordinate system.
     */
    getTileSize() {
        return this._tileSize;
    }
    /**
     * @return Top left corner coordinates of the tile.
     */
    getTileOffset(tile) {
        return {
            x: this.getTileSize() * tile.x - 1,
            y: 1 - this.getTileSize() * tile.y
        };
    }
    toTileCoordinates(worldCoordinates) {
        return {
            x: (worldCoordinates.x + 1) / this._tileSize,
            y: (1 - worldCoordinates.y) / this._tileSize
        };
    }
}


/***/ }),
/* 42 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clamp", function() { return clamp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cycleRestrict", function() { return cycleRestrict; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mix", function() { return mix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "smoothStep", function() { return smoothStep; });
/**
 * Clamps a value to a given range.
 *
 * @param x The value.
 * @param min Start of the range.
 * @param max End of the range.
 * @returns Clamped value.
 */
function clamp(x, min, max) {
    return min < x ? x < max ? x : max : min;
}
/**
 * Restricts a value to a given cycled range, i.e. ends of the range are
 * equivalent. E.g. like angles can be restricted to any range of size `2 * PI`.
 *
 * @param x The value.
 * @param min Start of the range.
 * @param max End of the range.
 * @returns Restricted value.
 */
function cycleRestrict(x, min, max) {
    const d = max - min;
    const s = (x - min) / (max - min);
    return min + d * (s - Math.floor(s));
}
/**
 * Linear interpolation.
 *
 * @param min Value that correspond to 0% progress.
 * @param max Value that correspond to 100% progress.
 * @param progress In 0..1.0 range that maps to 0..100% progress. It is allowed to pass a value
 *      outside of this range, that means progress greater then 100% or negative progress.
 */
function mix(min, max, progress) {
    return (1 - progress) * min + progress * max;
}
/**
 * A step function with a smooth transition between given edges. Completely
 * analogous to `smoothstep` in GLSL (GLSL ES 1.0 8.3).
 *
 * @param edge1 The smaller edge.
 * @param edge2
 * @param x `0` if `x < edge1`, `1` if `x > edge2` and an interpolated value for
 *      `edge1 < x < edge2`.
 */
function smoothStep(edge1, edge2, x) {
    const factor = clamp((x - edge1) / (edge2 - edge1), 0, 1);
    return factor * factor * (3 - 2 * factor);
}


/***/ }),
/* 43 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZERO", function() { return ZERO; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ORIGIN", function() { return ORIGIN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "POSITIVE_X", function() { return POSITIVE_X; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NEGATIVE_X", function() { return NEGATIVE_X; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "POSITIVE_Y", function() { return POSITIVE_Y; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NEGATIVE_Y", function() { return NEGATIVE_Y; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "areEqual", function() { return areEqual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "areCollinear", function() { return areCollinear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "areFuzzyEqual", function() { return areFuzzyEqual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mulv", function() { return mulv; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "muln", function() { return muln; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divv", function() { return divv; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divn", function() { return divn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mod", function() { return mod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mix", function() { return mix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate45", function() { return rotate45; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate90", function() { return rotate90; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateNeg90", function() { return rotateNeg90; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "convert", function() { return convert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "crossZ", function() { return crossZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EMPTY", function() { return EMPTY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UNIT_BBOX", function() { return UNIT_BBOX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createBBox2", function() { return createBBox2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyBBox2", function() { return copyBBox2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bboxesOverlap", function() { return bboxesOverlap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pointIsInBBox", function() { return pointIsInBBox; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "computeBBoxForPoints", function() { return computeBBoxForPoints; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "X_AXIS", function() { return X_AXIS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Y_AXIS", function() { return Y_AXIS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLineFromPoints", function() { return getLineFromPoints; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSignedDistanceToLine", function() { return getSignedDistanceToLine; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createExtent2", function() { return createExtent2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyExtent2", function() { return copyExtent2; });
/* harmony import */ var _util_fuzzy_equal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(44);

/**
 * Creates a new vector and initializes it with given components.
 *
 * @param x X component of the vector.
 * @param y Y component of the vector.
 * @returns The vector.
 */
function create(x, y) {
    return { x, y };
}
const ZERO = create(0, 0);
const ORIGIN = ZERO;
const POSITIVE_X = create(1, 0);
const NEGATIVE_X = create(-1, 0);
const POSITIVE_Y = create(0, 1);
const NEGATIVE_Y = create(0, -1);
/**
 * Copies a vector to another one.
 *
 * @param src The source vector.
 * @param dst The vector the source vector will be copied to.
 * @returns `dst`.
 */
function copy(src, dst = create(0, 0)) {
    dst.x = src.x;
    dst.y = src.y;
    return dst;
}
/**
 * Checks if two vectors are strictly equal component-wise.
 *
 * @param v1 The first vector.
 * @param v2 The second vector.
 * @returns `true` if the vectors are equal and `false` otherwise.
 */
function areEqual(v1, v2) {
    return v1.x === v2.x && v1.y === v2.y;
}
/**
 * Checks if two vectors are collinear.
 *
 * @param v1 The first vector.
 * @param v2 The second vector.
 * @returns `true` if the vectors are collinear and `false` otherwise.
 */
function areCollinear(v1, v2) {
    return v1.x / v2.x === v1.y / v2.y;
}
/**
 * Checks if corresponding components of two vectors are all within given
 * tolerance from each other.
 *
 * @param v1 The first vector.
 * @param v2 The second vector.
 * @param tolerance The tolerance.
 * @returns `true` if the vectors are "fuzzy" equal and `false` otherwise.
 */
function areFuzzyEqual(v1, v2, tolerance = _util_fuzzy_equal__WEBPACK_IMPORTED_MODULE_0__["DEFAULT_TOLERANCE"]) {
    return (Object(_util_fuzzy_equal__WEBPACK_IMPORTED_MODULE_0__["default"])(v1.x, v2.x, tolerance) &&
        Object(_util_fuzzy_equal__WEBPACK_IMPORTED_MODULE_0__["default"])(v1.y, v2.y, tolerance));
}
/**
 * Adds two vector and stores the result into a third one, i.e. `dst = a + b`.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function add(a, b, dst = create(0, 0)) {
    dst.x = a.x + b.x;
    dst.y = a.y + b.y;
    return dst;
}
/**
 * Subtracts a vector from another one and stores the result to a third one, i.e.
 * `dst = a - b`.
 *
 * @param a The minuend vector.
 * @param b The subtrahend vector.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function sub(a, b, dst = create(0, 0)) {
    dst.x = a.x - b.x;
    dst.y = a.y - b.y;
    return dst;
}
/**
 * Multiplies two vectors component-wise and stores the result into a third one.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function mulv(a, b, dst = create(0, 0)) {
    dst.x = a.x * b.x;
    dst.y = a.y * b.y;
    return dst;
}
/**
 * Multiplies a vector by a scalar and stores the result into a third vector.
 *
 * @param a The vector.
 * @param n The scalar.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function muln(a, n, dst = create(0, 0)) {
    dst.x = a.x * n;
    dst.y = a.y * n;
    return dst;
}
/**
 * Divides a vector by another one component wise and stores the result into a
 * third one.
 *
 * @param a The dividend vector.
 * @param b The divisor vector.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function divv(a, b, dst = create(0, 0)) {
    dst.x = a.x / b.x;
    dst.y = a.y / b.y;
    return dst;
}
/**
 * Divides a vector by a scalar and stores the result into a third vector.
 *
 * @param a The dividend vector.
 * @param n The scalar.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function divn(a, n, dst = create(0, 0)) {
    dst.x = a.x / n;
    dst.y = a.y / n;
    return dst;
}
/**
 * Calculates the reminder after division of a's components by n and stores the result into a third vector.
 *
 * @param a The dividend vector.
 * @param n The scalar.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function mod(a, n, dst = create(0, 0)) {
    dst.x = a.x % n;
    dst.y = a.y % n;
    return dst;
}
/**
 * Linearly interpolates between two vectors, i.e. computes
 * `(1 - factor) * a + factor * b`, and writes the result into a third vector.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @param factor The interpolation factor.
 * @param dst The vector the result will be written to.
 * @returns `dst`.
 */
function mix(a, b, factor, dst = create(0, 0)) {
    dst.x = (1 - factor) * a.x + factor * b.x;
    dst.y = (1 - factor) * a.y + factor * b.y;
    return dst;
}
/**
 * Rotates a vector by a given angle and stores the result into a second vector.
 * Positive direction is from +X to +Y.
 *
 * @param v The vector to rotate.
 * @param angle The angle of rotation.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function rotate(v, angle, dst = create(0, 0)) {
    const x = v.x;
    const y = v.y;
    const angleCos = Math.cos(angle);
    const angleSin = Math.sin(angle);
    dst.x = angleCos * x - angleSin * y;
    dst.y = angleSin * x + angleCos * y;
    return dst;
}
/**
 * Rotates a vector by 45 degrees and stores the result into a second vector.
 * Analogous to `rotate(v, Math.PI / 4, dst)`, but faster.
 *
 * @param v The vector to rotate.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function rotate45(v, dst = create(0, 0)) {
    const y = v.y;
    const s = Math.SQRT1_2;
    dst.y = s * v.x + s * v.y;
    dst.x = s * v.x - s * y;
    return dst;
}
/**
 * Rotates a vector by 90 degrees and stores the result into a second vector.
 * Analogous to `rotate(v, Math.PI / 2, dst)`, but faster.
 *
 * @param v The vector to rotate.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function rotate90(v, dst = create(0, 0)) {
    const y = v.y;
    dst.y = v.x;
    dst.x = -y;
    return dst;
}
/**
 * Rotates a vector by -90 degrees and stores the result into a second vector.
 * Analogous to `rotate(v, -Math.PI / 2, dst)`, but faster.
 *
 * @param v The vector to rotate.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function rotateNeg90(v, dst = create(0, 0)) {
    const y = v.y;
    dst.y = -v.x;
    dst.x = y;
    return dst;
}
/**
 * Inverts signs of components of a vector and stores the result into a second
 * vector. Analogous to `rotate(v, Math.PI, dst)` (or `rotate(v, -Math.PI, dst)`,
 * which is the same), but faster.
 *
 * @param v The vector to invert.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function invert(v, dst = create(0, 0)) {
    dst.x = -v.x;
    dst.y = -v.y;
    return dst;
}
/**
 * Computes length of a vector.
 *
 * @param v The vector.
 * @returns The length.
 */
function length(v) {
    return Math.hypot(v.x, v.y);
}
/**
 * Computes distance between ends of two vectors.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @returns The distance, i.e. `length(sub(a, b))`.
 */
function distance(a, b) {
    return Math.hypot(a.x - b.x, a.y - b.y);
}
/**
 * Divides a vector by its length (thus making it a unit vector) and stores the
 * result to another one.
 *
 * @param v The vector to be normalized.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function normalize(v, dst = create(0, 0)) {
    return divn(v, length(v), dst);
}
/**
 * Converts each component of vector.
 *
 * @param v The vector to be converted.
 * @param converter The component converter.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function convert(v, converter, dst = create(0, 0)) {
    dst.x = converter(v.x);
    dst.y = converter(v.y);
    return dst;
}
/**
 * Computes dot product of two vectors.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @returns The dot product.
 */
function dot(a, b) {
    return a.x * b.x + a.y * b.y;
}
/**
 * Computes Z-component of a cross product of two vectors.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @returns Z-component of the cross product.
 */
function crossZ(a, b) {
    return a.x * b.y - a.y * b.x;
}
const EMPTY = {
    minX: 0,
    maxX: 0,
    minY: 0,
    maxY: 0
};
const UNIT_BBOX = {
    minX: -1,
    maxX: 1,
    minY: -1,
    maxY: 1
};
/**
 * Creates a new bbox and initializes it with given components.
 *
 * @param minX Left border of the bbox.
 * @param maxX Right border of the bbox.
 * @param minY Lower border of the bbox.
 * @param maxY Upper border of the bbox.
 * @returns The bbox.
 */
function createBBox2(minX, maxX, minY, maxY) {
    return { minX, maxX, minY, maxY };
}
/**
 * Copies a bbox to another one.
 *
 * @param src The source bbox.
 * @param dst The bbox the source bbox will be copied to.
 * @returns `dst`.
 */
function copyBBox2(src, dst = createBBox2(0, 0, 0, 0)) {
    dst.minX = src.minX;
    dst.maxX = src.maxX;
    dst.minY = src.minY;
    dst.maxY = src.maxY;
    return dst;
}
/**
 * Checks if two bounding boxes overlap.
 *
 * @param bbox1 A bounding box.
 * @param bbox2 Another bounding box.
 * @returns `true` if given bounding boxes do overlap and `false` otherwise.
 */
function bboxesOverlap(bbox1, bbox2) {
    let leftBBox;
    let rightBBox;
    if (bbox1.minX < bbox2.minX) {
        leftBBox = bbox1;
        rightBBox = bbox2;
    }
    else {
        leftBBox = bbox2;
        rightBBox = bbox1;
    }
    let topBBox;
    let bottomBBox;
    if (bbox1.maxY > bbox2.maxY) {
        topBBox = bbox1;
        bottomBBox = bbox2;
    }
    else {
        topBBox = bbox2;
        bottomBBox = bbox1;
    }
    return rightBBox.minX < leftBBox.maxX && bottomBBox.maxY > topBBox.minY;
}
/**
 * Checks if a 2D point lies inside a bounding box or on its border.
 *
 * @param point The point.
 * @param bbox The bounding box.
 * @returns `true` if the point is inside of the box and `false` otherwise.
 */
function pointIsInBBox(point, bbox) {
    return bbox.minX <= point.x && point.x <= bbox.maxX &&
        bbox.minY <= point.y && point.y <= bbox.maxY;
}
/**
 * Computes bounding box of an array of points and stores it to a given object.
 *
 * @param points The array of points.
 * @param dst The bbox the result will be written to. Left unmodified if the array
 *      of points is empty.
 * @returns `dst`.
 */
function computeBBoxForPoints(points, dst = { minX: 0, maxX: 0, minY: 0, maxY: 0 }) {
    if (points.length === 0) {
        return dst;
    }
    dst.minX = dst.maxX = points[0].x;
    dst.minY = dst.maxY = points[0].y;
    for (let i = 1; i < points.length; ++i) {
        const { x, y } = points[i];
        if (x < dst.minX) {
            dst.minX = x;
        }
        if (x > dst.maxX) {
            dst.maxX = x;
        }
        if (y < dst.minY) {
            dst.minY = y;
        }
        if (y > dst.maxY) {
            dst.maxY = y;
        }
    }
    return dst;
}
const X_AXIS = {
    origin: ORIGIN,
    tangent: POSITIVE_X
};
const Y_AXIS = {
    origin: ORIGIN,
    tangent: POSITIVE_Y
};
function getLineFromPoints(p1, p2, dst = {
    origin: create(0, 0),
    tangent: create(0, 0)
}) {
    copy(p1, dst.origin);
    sub(p2, p1, dst.tangent);
    return dst;
}
/**
 * Computes signed distance from a point to a line.
 *
 * @param p The point.
 * @param l1 Start point of the line.
 * @param l2 End point of the line.
 * @returns Distance from the point to the line. It'll be greater than 0 if the
 *      point lies to the left of the line and less than 0 otherwise.
 */
function getSignedDistanceToLine(p, l) {
    const tangent = l.tangent;
    return dot(sub(p, l.origin), create(-tangent.y, tangent.x)) / length(tangent);
}
/**
 * Creates a new extent and initializes it with given components.
 *
 * @param width Width of the extent.
 * @param Height Height of the extent.
 * @returns The extent.
 */
function createExtent2(width, height) {
    return { width, height };
}
/**
 * Copies an extent to another one.
 *
 * @param src The source bbox.
 * @param dst The extent the source extent will be copied to.
 * @returns `dst`.
 */
function copyExtent2(src, dst = createExtent2(0, 0)) {
    dst.width = src.width;
    dst.height = src.height;
    return dst;
}


/***/ }),
/* 44 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_TOLERANCE", function() { return DEFAULT_TOLERANCE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return areFuzzyEqual; });
const DEFAULT_TOLERANCE = 1e-6;
/**
 * Checks if two floating point number are within a tolerance from each other.
 *
 * @param a The first number.
 * @param b The second number.
 * @param tolerance The tolerance.
 * @returns `true` if the number are within the tolerance and `false` otherwise.
 */
function areFuzzyEqual(a, b, tolerance = DEFAULT_TOLERANCE) {
    const d = a - b;
    return -tolerance < d && d < tolerance;
}


/***/ }),
/* 45 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return extractStyles; });
/**
 * One object is used as a buffer to pass common properties to style extractors,
 * to prevent creation of many temporary objects.
 */
const styleBase = {
    minZoom: 0,
    maxZoom: 0,
    zIndex: 0
};
/**
 * Utility method for parsing styles from decoded API tile response. It handles some common logic regarding
 * zoom slices and delegates fetching style details to a StyleHandler.
 * Tile min/max zoom params are used to set proper styles to be used in over/under zooming, still adhering
 * the API convention where missing zoom range slice means object invisibility.
 */
function* extractStyles(presentations, classId, toStyle, tileMinZoom, tileMaxZoom, presentationName = 'map') {
    const presentation = presentations.find((presentation) => presentation.name === presentationName) ||
        presentations[0];
    const styleClass = presentation.classes[classId];
    if (styleClass) {
        for (const slice of styleClass.slices) {
            if (slice.visibility) {
                styleBase.minZoom = slice.visibility.min === tileMinZoom ? -Infinity : slice.visibility.min;
                styleBase.maxZoom = slice.visibility.max === tileMaxZoom ? +Infinity : slice.visibility.max;
                styleBase.zIndex = slice.zIndex;
                const style = toStyle(slice, styleBase);
                if (style) {
                    yield style;
                }
            }
        }
    }
}


/***/ }),
/* 46 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return extractPolylines; });
/* harmony import */ var _proto_aliases__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(14);
/* harmony import */ var _math_vector2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(43);
/* harmony import */ var _tile_world_coordinates_converter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(40);
/* harmony import */ var _extract_styles__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(45);
/* harmony import */ var _util_color__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(38);
/* harmony import */ var _util_polyline__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(47);







const JOINS = {
    [_proto_aliases__WEBPACK_IMPORTED_MODULE_0__["Presentation"].Class.LineStyle.JoinStyle.JoinMiter]: 0 /* MITER */,
    [_proto_aliases__WEBPACK_IMPORTED_MODULE_0__["Presentation"].Class.LineStyle.JoinStyle.JoinRound]: 1 /* ROUND */,
    [_proto_aliases__WEBPACK_IMPORTED_MODULE_0__["Presentation"].Class.LineStyle.JoinStyle.JoinBevel]: 2 /* BEVEL */
};
const CAPS = {
    [_proto_aliases__WEBPACK_IMPORTED_MODULE_0__["Presentation"].Class.LineStyle.CapStyle.CapBevel]: 0 /* BUTT */,
    [_proto_aliases__WEBPACK_IMPORTED_MODULE_0__["Presentation"].Class.LineStyle.CapStyle.CapSquare]: 2 /* SQUARE */,
    [_proto_aliases__WEBPACK_IMPORTED_MODULE_0__["Presentation"].Class.LineStyle.CapStyle.CapRound]: 1 /* ROUND */
};
function extractPolylineStyle(zoomSlice, styleBase) {
    const inlineStyle = (zoomSlice.line && zoomSlice.line.line) || (zoomSlice.poly && zoomSlice.poly.contour);
    const outlineStyle = zoomSlice.line && zoomSlice.line.outline;
    return inlineStyle || outlineStyle ? Object.assign({}, styleBase, { inline: inlineStyle ? {
            strokeColor: inlineStyle.pattern ? _util_color__WEBPACK_IMPORTED_MODULE_4__["TRANSPARENT_BLACK"] : Object(_util_color__WEBPACK_IMPORTED_MODULE_4__["decodeAbgr8"])(inlineStyle.color),
            strokeWidth: inlineStyle.width,
            join: JOINS[inlineStyle.joins],
            startCap: CAPS[inlineStyle.caps],
            endCap: CAPS[inlineStyle.caps],
            dash: inlineStyle.dash ? {
                fill: inlineStyle.dash.dashes[0].fill,
                gap: inlineStyle.dash.dashes[0].gap
            } : undefined,
            pattern: inlineStyle.pattern ? {
                imageId: inlineStyle.pattern.id,
                width: inlineStyle.pattern.width,
                height: inlineStyle.width
            } : undefined
        } : undefined, outline: outlineStyle ? {
            strokeColor: outlineStyle.pattern ? _util_color__WEBPACK_IMPORTED_MODULE_4__["TRANSPARENT_BLACK"] : Object(_util_color__WEBPACK_IMPORTED_MODULE_4__["decodeAbgr8"])(outlineStyle.color),
            strokeWidth: outlineStyle.width,
            join: JOINS[outlineStyle.joins],
            startCap: CAPS[outlineStyle.caps],
            endCap: CAPS[outlineStyle.caps],
            dash: outlineStyle.dash ? {
                fill: outlineStyle.dash.dashes[0].fill,
                gap: outlineStyle.dash.dashes[0].gap
            } : undefined
        } : undefined }) : undefined;
}
function* extractPolylines(tile, decodedApiTile, tileMinZoom, tileMaxZoom) {
    const polylines = decodedApiTile.polylines;
    if (!polylines) {
        return;
    }
    const preparePolyline = (vertices, classId, zOrder, forcedStartCap, forcedEndCap) => {
        const styles = [...Object(_extract_styles__WEBPACK_IMPORTED_MODULE_3__["default"])(decodedApiTile.presentation, classId, extractPolylineStyle, tileMinZoom, tileMaxZoom)];
        for (const style of styles) {
            style.zIndex += zOrder;
            if (forcedStartCap !== undefined) {
                if (style.inline) {
                    style.inline.startCap = forcedStartCap;
                }
                if (style.outline) {
                    style.outline.startCap = forcedStartCap;
                }
            }
            if (forcedEndCap !== undefined && style.inline) {
                if (style.inline) {
                    style.inline.endCap = forcedEndCap;
                }
                if (style.outline) {
                    style.outline.endCap = forcedEndCap;
                }
            }
        }
        return { vertices, styles };
    };
    const converter = new _tile_world_coordinates_converter__WEBPACK_IMPORTED_MODULE_2__["default"](tile);
    for (let lineIdx = 0, vertexIdx = 0; lineIdx < polylines.lineSize.length; ++lineIdx) {
        const zOrderBegin = polylines.zOrderBegin[lineIdx] | 0;
        const zOrderEnd = polylines.zOrderEnd[lineIdx] | 0;
        const size = polylines.lineSize[lineIdx];
        const vertices = new Array(size);
        let forcedStartCap;
        let forcedEndCap;
        let x = 0;
        let y = 0;
        for (let i = 0; i < size; ++i, ++vertexIdx) {
            x += polylines.coordsx[vertexIdx];
            y += polylines.coordsy[vertexIdx];
            // polylines between tiles that are actually one line on the map overlaps themself at the edge,
            // to handle this case their caps are forcible removed, it is kind of hack and generally it is incorrect,
            // but works well enough for the data being come from API.
            if (i === 0 && Object(_tile_world_coordinates_converter__WEBPACK_IMPORTED_MODULE_2__["isTileEdgeCoordinates"])(x, y)) {
                forcedStartCap = 0 /* BUTT */;
            }
            if (i === size - 1 && Object(_tile_world_coordinates_converter__WEBPACK_IMPORTED_MODULE_2__["isTileEdgeCoordinates"])(x, y)) {
                forcedEndCap = 0 /* BUTT */;
            }
            vertices[i] = _math_vector2__WEBPACK_IMPORTED_MODULE_1__["create"](converter.toWorldXCoordinate(x), converter.toWorldYCoordinate(y));
        }
        if (zOrderBegin !== zOrderEnd) {
            const verticesSplit = Object(_util_polyline__WEBPACK_IMPORTED_MODULE_5__["splitPolyline"])(vertices);
            yield preparePolyline(verticesSplit[0], polylines.classId[lineIdx], zOrderBegin, forcedStartCap, forcedEndCap);
            yield preparePolyline(verticesSplit[1], polylines.classId[lineIdx], zOrderEnd, forcedStartCap, forcedEndCap);
        }
        else {
            yield preparePolyline(vertices, polylines.classId[lineIdx], zOrderBegin, forcedStartCap, forcedEndCap);
        }
    }
}


/***/ }),
/* 47 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "splitPolyline", function() { return splitPolyline; });
/* harmony import */ var _math_vector2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(43);
/* harmony import */ var _fuzzy_equal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(44);



/**
 * Spilts a polyline in two parts: two polylines covering the input polyline with a coincident spilt point.
 *
 * @param polyline Polyline to be separated.
 * @param proportion Length of the first part as percentage (0..1) of the length of the polyline.
 * @returns Two polylines.
 */
function splitPolyline(polyline, proportion = 0.5) {
    const subLengths = new Array(polyline.length);
    subLengths[0] = 0;
    for (let i = 1; i < polyline.length; ++i) {
        subLengths[i] = subLengths[i - 1] + _math_vector2__WEBPACK_IMPORTED_MODULE_0__["distance"](polyline[i - 1], polyline[i]);
    }
    const splitLength = proportion * subLengths[polyline.length - 1];
    const splitIndex = subLengths.findIndex((length) => length >= splitLength) || 1; // "|| 1" to handle 0-length case
    const splitPoint = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["mix"](polyline[splitIndex - 1], polyline[splitIndex], 
    // "|| 1" to handle 0-length case
    (splitLength - subLengths[splitIndex - 1]) / ((subLengths[splitIndex] - subLengths[splitIndex - 1]) || 1));
    const leftPartLength = splitIndex + 1;
    const leftPart = new Array(leftPartLength);
    for (let i = 0; i < splitIndex; ++i) {
        leftPart[i] = polyline[i];
    }
    leftPart[splitIndex] = splitPoint;
    const isSplitExistingPoint = Object(_math_vector2__WEBPACK_IMPORTED_MODULE_0__["areFuzzyEqual"])(polyline[splitIndex], splitPoint, splitLength * _fuzzy_equal__WEBPACK_IMPORTED_MODULE_1__["DEFAULT_TOLERANCE"]);
    const rightPartLength = polyline.length - splitIndex;
    const rightPart = new Array(rightPartLength + (isSplitExistingPoint ? 0 : 1));
    let rightPartIndex = 0;
    // don't include splitPoint if splitting has happened at a polyline's point
    if (!isSplitExistingPoint) {
        rightPart[rightPartIndex++] = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["copy"](splitPoint);
    }
    for (let i = 0; i < rightPartLength; i++) {
        rightPart[rightPartIndex++] = polyline[splitIndex + i];
    }
    return [leftPart, rightPart];
}


/***/ }),
/* 48 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PolygonBufferWriter; });
/* harmony import */ var _util_buffer_writer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(49);
/* harmony import */ var _util_triangulate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(53);
/* harmony import */ var _polygon_attribute_mapping__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55);
/* harmony import */ var _util_color__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(38);
/* harmony import */ var _util_z_index__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(59);





/**
 * Writer of geometry data of labels.
 */
class PolygonBufferWriter extends _util_buffer_writer__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super(_polygon_attribute_mapping__WEBPACK_IMPORTED_MODULE_2__["POLYGON_ATTRIBUTE_MAPPING"].vertexByteSize);
    }
    writePolygon(polygon, zIndex, color) {
        const zIndexInt24 = Object(_util_z_index__WEBPACK_IMPORTED_MODULE_4__["intToZIndex"])(zIndex);
        const colorRgba8 = Object(_util_color__WEBPACK_IMPORTED_MODULE_3__["encodeRgba8"])(color);
        for (const ring of polygon.vertexRings) {
            for (const vertex of ring) {
                this._writeWorldCoordinate(vertex);
                this._writeWord(colorRgba8);
                this._writeFloat32(zIndexInt24);
            }
        }
        this.writeIndices(Object(_util_triangulate__WEBPACK_IMPORTED_MODULE_1__["default"])(polygon.vertexRings));
        return this.endMesh();
    }
}


/***/ }),
/* 49 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WORD_BYTE_SIZE", function() { return WORD_BYTE_SIZE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BufferWriter; });
/* harmony import */ var _gputypes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(50);
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(51);


const WORD_BYTE_SIZE = 4;
/**
 * Generates triangles of a fan of a given length as if it is continuous and
 * starts with 0.
 *
 * @param count Number of vertices in the fan.
 * @returns Iterator over indices of triangles.
 */
function* generateFan(count) {
    for (let i = 2; i < count; ++i) {
        yield 0;
        yield i - 1;
        yield i;
    }
}
/**
 * Generates triangles of a strip of a given length as if it is continuous and
 * starts with 0.
 *
 * @param count Number of vertices in the fan.
 * @returns Iterator over indices of triangles.
 */
function* generateStrip(count) {
    yield 0;
    yield 1;
    yield 2;
    let offset0 = 1;
    let offset1 = 2;
    for (let i = 3; i < count; ++i) {
        yield i - offset0;
        yield i - offset1;
        yield i;
        const tmp = offset0;
        offset0 = offset1;
        offset1 = tmp;
    }
}
/**
 * Vertex buffer helper class, that supports sequential writing interface and takes over some single-buffer operations.
 * It is an integral part of the buffer writer class and its main purpose is to make the writer's code easier.
 */
class VertexBuffer {
    /**
     * @param byteSize Initial size of the buffer in bytes. As it gets filled by words
     *      the size must be a multiply of 4.
     */
    constructor(byteSize) {
        this._nextWordOffset = 0;
        this._initBuffers(byteSize);
    }
    /**
     * @returns true if there is no free space remaining in buffer.
     */
    get isFull() {
        return this._nextWordOffset >= this._uint32View.length;
    }
    /**
     * @returns The number of words (4 bytes values) already written.
     */
    get occupiedSize() {
        return this._nextWordOffset;
    }
    /**
     * @return Max number of bytes this buffer is able to store. It can be increased by the extend() method.
     */
    get byteSize() {
        return this._uint32View.byteLength;
    }
    /**
     * Extends buffer to the new size. The new size must be not less than current one and it must be a multiply of 4.
     */
    extend(newByteSize) {
        // TODO assert newByteLength is larger than current _arrayBuffer and its is a multiply of the word size.
        const oldUint32View = this._uint32View;
        this._initBuffers(newByteSize);
        this._uint32View.set(oldUint32View);
    }
    /**
     * Appends value as a uint32 number.
     */
    pushUint32(value) {
        this._uint32View[this._nextWordOffset++] = value;
    }
    /**
     * Appends value as a float32 number.
     */
    pushFloat32(value) {
        this._float32View[this._nextWordOffset++] = value;
    }
    /**
     * @returns uint8 view of this buffer. The size of the view matches the amount of written data.
     */
    asUint32Array() {
        return this._uint32View.subarray(0, this.occupiedSize);
    }
    _initBuffers(byteLength) {
        const arrayBuffer = new ArrayBuffer(byteLength);
        this._uint32View = new Uint32Array(arrayBuffer);
        this._float32View = new Float32Array(arrayBuffer);
    }
    /**
     * Moves "tail" data (from the offset specified to the end of the buffer) of one buffer to another. The cursors of
     * buffers will be appropriately updated to reflect data changes.
     */
    static transferDataTail(src, dst, srcWordOffset, dstOffset = 0) {
        const tailLength = src.occupiedSize - srcWordOffset;
        const srcTail = src._uint32View.subarray(srcWordOffset, src.occupiedSize);
        dst._uint32View.set(srcTail, dstOffset);
        dst._nextWordOffset = tailLength;
        src._nextWordOffset = srcWordOffset;
    }
}
/**
 * Index buffer helper class, that supports sequential writing interface and takes over some single-buffer operations.
 * It is an integral part of the buffer writer class and its main purpose is to make the writer's code easier.
 */
class IndexBuffer {
    /**
     * @param size Initial size of the buffer.
     */
    constructor(size) {
        this._nextIndexOffset = 0;
        this._uint16View = new Uint16Array(size);
    }
    /**
     * @returns The number of indices already written.
     */
    get occupiedSize() {
        return this._nextIndexOffset;
    }
    /**
     * @return Max number of indices this buffer is able to store. It can be increased by the extend() method.
     */
    get size() {
        return this._uint16View.length;
    }
    /**
     * Extends buffer to the new size.
     */
    extend(newSize) {
        // TODO assert newByteLength is larger than current _arrayBuffer
        const oldUint16View = this._uint16View;
        this._uint16View = new Uint16Array(newSize);
        this._uint16View.set(oldUint16View);
    }
    /**
     * Appends index to the end of the buffer.
     */
    push(index) {
        this._uint16View[this._nextIndexOffset++] = index;
    }
    /**
     * @returns uint16 view of this buffer. The size of the view matches the amount of written data.
     */
    asUint16Array() {
        return new Uint16Array(this._uint16View.buffer, 0, this.occupiedSize);
    }
    /**
     * Moves "tail" data (from the offset specified to the end of the buffer) of one buffer to another. The offsets of
     * buffers will be appropriately updated to reflect data changes.
     * baseIndex will be deducted from all moved indices.
     */
    static transferDataTail(src, dst, baseIndex, srcOffset, dstOffset = 0) {
        for (let i = srcOffset, j = dstOffset; i < src.occupiedSize; i++, j++) {
            dst._uint16View[j] = src._uint16View[i] - baseIndex;
        }
        dst._nextIndexOffset = src.occupiedSize - srcOffset;
        src._nextIndexOffset = srcOffset;
    }
}
/**
 * Base buffer writer implementation. Can write unsigned short indices and
 * provides facilities for child classes to handle writing vertex data. Defines
 * a concept of current mesh. Basically, it mean that all vertices and indices
 * written to a writer between two `endMesh` calls (or construction of the writer
 * and an `endMesh` call) must be considered belonging to one atomic piece of
 * geometry and should not be spitted between separate buffers.
 */
class BufferWriter {
    /**
     * Creates a new writer and allocates initial amount of memory to store data.
     * Also implicitly "start" a mesh.
     *
     * @param vertexByteSize
     * @param initVertexBufferSize Init size (in vertices) of growing vertex buffers.
     * @param maxVertexBufferSize Max size (in vertices) of vertex buffers.
     * @param initIndexBufferUint16Size Init size (in uint16 number) of growing index buffers.
     */
    constructor(vertexByteSize, initVertexBufferSize = 0x400, maxVertexBufferSize = 0x10000, initIndexBufferUint16Size = 0xc00) {
        this._vertexByteSize = vertexByteSize;
        this._initVertexBufferByteSize = vertexByteSize * initVertexBufferSize;
        this._maxVertexBufferByteSize = vertexByteSize * maxVertexBufferSize;
        this._initIndexBufferUint16Size = initIndexBufferUint16Size;
        this._vertexBuffer = new VertexBuffer(this._initVertexBufferByteSize);
        this._vertexBuffers = [this._vertexBuffer];
        this._indexBuffer = new IndexBuffer(this._initIndexBufferUint16Size);
        this._indexBuffers = [this._indexBuffer];
        this._currentMeshVertexOffset = 0;
        this._currentMeshIndexOffset = 0;
        this._currentMeshBaseIndex = 0;
    }
    /**
     * Writes a bunch of indices to the underlying storage as unsigned short
     * numbers. If current storage doesn't have enough space to accommodate
     * given indices, the writer will automatically resize it. The writer
     * automatically adds base index to the supplied values, so from a user
     * point of view first vertex of a mesh has index 0 and there's no need
     * to take into account it's offset while generating mesh's topology.
     *
     * @param indices Array of indices to write.
     */
    writeIndices(indices) {
        this._ensureEnoughIndexBufferSpace(indices.length);
        const buffer = this._indexBuffer;
        const baseIndex = this._currentMeshBaseIndex;
        for (let i = 0; i < indices.length; ++i) {
            buffer.push(baseIndex + indices[i]);
        }
    }
    /**
     * Generates triangle indices from an array of indices of a triangle strip
     * (as in GL) and writes generated triplets to the managed index buffer.
     * @see OpenGL ES 2.0 Spec, 2.6.1
     *
     * @param indices Indices of the strip.
     */
    writeIndicesForStrip(indices) {
        this._ensureEnoughIndexBufferSpace(3 * (indices.length - 2));
        const buffer = this._indexBuffer;
        const baseIndex = this._currentMeshBaseIndex;
        for (const i of generateStrip(indices.length)) {
            buffer.push(baseIndex + indices[i]);
        }
    }
    /**
     * Generates triangle indices from a continuous triangle strip of a given
     * length and writes generated triplets to managed index buffer.
     * @see OpenGL ES 2.0 Spec, 2.6.1
     *
     * @param indexCount
     * @param baseIndexInMesh
     */
    writeIndicesForContinuousStrip(indexCount, baseIndexInMesh = 0) {
        this._ensureEnoughIndexBufferSpace(3 * (indexCount - 2));
        const buffer = this._indexBuffer;
        const baseIndex = this._currentMeshBaseIndex + baseIndexInMesh;
        for (const i of generateStrip(indexCount)) {
            buffer.push(baseIndex + i);
        }
    }
    /**
     * Generates triangle indices from an array of indices of a triangle fan (as
     * in GL) and writes generated triplets to the managed index buffer.
     * @see OpenGL ES 2.0 Spec, 2.6.1
     *
     * @param indices Indices of the strip.
     */
    writeIndicesForFan(indices) {
        this._ensureEnoughIndexBufferSpace(3 * (indices.length - 2));
        const buffer = this._indexBuffer;
        const baseIndex = this._currentMeshBaseIndex;
        for (const i of generateFan(indices.length)) {
            buffer.push(baseIndex + indices[i]);
        }
    }
    /**
     * Generates triangle indices from a continuous triangle fan of a given length
     * and writes generated triplets to managed index buffer.
     * @see OpenGL ES 2.0 Spec, 2.6.1
     *
     * @param indexCount
     * @param baseIndexInMesh
     */
    writeIndicesForContinuousFan(indexCount, baseIndexInMesh = 0) {
        this._ensureEnoughIndexBufferSpace(3 * (indexCount - 2));
        const buffer = this._indexBuffer;
        const baseIndex = baseIndexInMesh + this._currentMeshBaseIndex;
        for (const i of generateFan(indexCount)) {
            buffer.push(baseIndex + i);
        }
    }
    /**
     * Ends current mesh and implicitly starts a new one.
     *
     * @returns Internal index of vertex and index buffers the mesh was written
     *      to and its memory location in them.
     */
    endMesh() {
        const currentMeshVertexOffset = this._currentMeshVertexOffset;
        const vertexOccupiedSize = this._vertexBuffer.occupiedSize;
        this._currentMeshVertexOffset = vertexOccupiedSize;
        this._currentMeshBaseIndex = (vertexOccupiedSize << 2) / this._vertexByteSize;
        const currentMeshIndexOffset = this._currentMeshIndexOffset;
        const indexOccupiedSize = this._indexBuffer.occupiedSize;
        this._currentMeshIndexOffset = indexOccupiedSize;
        return {
            vertexByteOffset: currentMeshVertexOffset << 2,
            vertexByteLength: vertexOccupiedSize - currentMeshVertexOffset << 2,
            indexByteOffset: currentMeshIndexOffset << 1,
            indexByteLength: indexOccupiedSize - currentMeshIndexOffset << 1,
            // We can't return actual buffer reference since it can change if
            // the buffer gets reallocated.
            bufferIndex: this._vertexBuffers.length - 1
        };
    }
    /**
     * Returns an array of currently owned buffer data. This call's better
     * made when you're done with the writer since if the writer decides to
     * resize any of the buffers some of the references in the returned array
     * may become outdated.
     */
    getBuffers() {
        return Object(_array__WEBPACK_IMPORTED_MODULE_1__["zip"])(this._vertexBuffers, this._indexBuffers, (vertexBuffer, indexBuffer) => ({
            vertexBuffer: vertexBuffer.asUint32Array(),
            indexBuffer: indexBuffer.asUint16Array()
        }));
    }
    /**
     * Returns an offset in the current vertex buffer to the location where next
     * piece of data will be written.
     */
    getCurrentVertexBufferByteOffset() {
        return this._vertexBuffer.occupiedSize << 2;
    }
    /**
     * Returns index of currently written vertex structure in the current vertex
     * buffer.
     */
    getCurrentVertexIdx() {
        return ((this._vertexBuffer.occupiedSize << 2) / this._vertexByteSize | 0) - this._currentMeshBaseIndex;
    }
    /**
     * Writes a floating point value to the current vertex buffer and advances
     * the offset by 4 bytes.
     *
     * @param value The value to be written.
     */
    _writeFloat32(value) {
        this._ensureEnoughVertexBufferSpace();
        this._vertexBuffer.pushFloat32(value);
    }
    /**
     * Writes an unsigned integer value to the current vertex buffer and advances
     * the offset by 4 bytes.
     *
     * @param value The value to be written.
     */
    _writeWord(value) {
        this._ensureEnoughVertexBufferSpace();
        this._vertexBuffer.pushUint32(value);
    }
    /**
     * Writes an unsigned short value to the current vertex buffer and advances
     * the offset by 2 bytes. Passed values will be truncated to 16 bits.
     *
     * @param value The value to be written.
     */
    _writeHalfWords(v1, v2) {
        this._writeWord(v2 << 16 | v1 & 0xffff);
    }
    /**
     * Writes an unsigned byte value to the current vertex buffer and advances
     * the offset by 1 byte. Passed values will be truncated to 8 bits.
     *
     * @param value The value to be written.
     */
    _writeBytes(v1, v2, v3, v4) {
        this._writeWord(v4 << 24 |
            (v3 & 0xff) << 16 |
            (v2 & 0xff) << 8 |
            v1 & 0xff);
    }
    /**
     * Encodes a world coordinate vector as a pair of 32-bit integers (splitting
     * them in turn into to 16-bit ones).
     *
     * @param c The world coordinate.
     */
    _writeWorldCoordinate(c) {
        // To avoid using GPU singed integer conversions we shift and scale world
        // coordinates so they're in [0, 1] range (instead of [-1, 1]) and then
        // encoded as unsigned 32 bit integers split into to 16 bit ones.
        const xUint32 = Object(_gputypes__WEBPACK_IMPORTED_MODULE_0__["floatToUint32"])(0.5 * (c.x + 1));
        const yUint32 = Object(_gputypes__WEBPACK_IMPORTED_MODULE_0__["floatToUint32"])(0.5 * (c.y + 1));
        this._writeHalfWords(xUint32 >>> 16, yUint32 >>> 16);
        this._writeHalfWords(xUint32, yUint32);
    }
    /**
     * Computes new bigger size of a vertex buffer based on its current size. By
     * default just double the current size.
     *
     * @param currentByteSize Current size of the index buffer in bytes.
     * @returns The new size.
     */
    _getNextVertexBufferByteSize(currentByteSize) {
        return currentByteSize << 1;
    }
    /**
     * Computes new bigger size of an index buffer based on its current size. By
     * default just double the current size.
     *
     * @param currentUint16Size Current size of the index buffer in shorts.
     * @returns The new size.
     */
    _getNextIndexBufferUint16Size(currentUint16Size) {
        return currentUint16Size << 1;
    }
    /**
     * Ensures that the managed vertex buffer has enough space to fit in a chunk
     * of data of a given size. Either does nothing, resizes the current vertex
     * buffer or creates entirely new pair of vertex and index buffers.
     *
     * @param valueSize Byte size of the data that needs to be accommodated by
     *      the vertex buffer.
     */
    _ensureEnoughVertexBufferSpace() {
        const vertexBuffer = this._vertexBuffer;
        if (!vertexBuffer.isFull) {
            // We have enough space, so nothing to be done.
            return;
        }
        if (vertexBuffer.byteSize < this._maxVertexBufferByteSize) {
            // If we can just resize the current vertex buffer, do that.
            this._vertexBuffer.extend(this._getNextVertexBufferByteSize(vertexBuffer.byteSize));
            return;
        }
        // If there's no enough space in the current vertex buffer and it's
        // already of maximum size, allocate new vertex and index buffers and
        // copy data of the current mesh to them from the current buffers.
        // Then make those buffer the current ones.
        const currentMeshVertexOffset = this._currentMeshVertexOffset;
        const currentMeshVertexByteSize = (vertexBuffer.occupiedSize - currentMeshVertexOffset) * 4;
        const maxVertexBufferByteSize = this._maxVertexBufferByteSize;
        if (currentMeshVertexByteSize === maxVertexBufferByteSize) {
            throw new Error('Mesh is too big to fit in.');
        }
        let newVertexBufferByteSize = this._initVertexBufferByteSize;
        // Initial vertex buffer size may be too small to accommodate the current
        // mesh, so we find next bigger size that is sufficient.
        while (newVertexBufferByteSize <= currentMeshVertexByteSize) {
            newVertexBufferByteSize = this._getNextVertexBufferByteSize(newVertexBufferByteSize);
        }
        const newVertexBuffer = new VertexBuffer(newVertexBufferByteSize);
        VertexBuffer.transferDataTail(vertexBuffer, newVertexBuffer, currentMeshVertexOffset);
        this._vertexBuffer = newVertexBuffer;
        this._vertexBuffers.push(newVertexBuffer);
        this._currentMeshVertexOffset = 0;
        const indexBuffer = this._indexBuffer;
        const currentMeshIndexOffset = this._currentMeshIndexOffset;
        const currentMeshIndexSize = indexBuffer.occupiedSize - currentMeshIndexOffset;
        let newIndexBufferSize = this._initIndexBufferUint16Size;
        // Initial index buffer size may be too small to accommodate the current
        // mesh, so we find next bigger size that is sufficient.
        while (newIndexBufferSize <= currentMeshIndexSize) {
            newIndexBufferSize = this._getNextIndexBufferUint16Size(newIndexBufferSize);
        }
        const newIndexBuffer = new IndexBuffer(newIndexBufferSize);
        // Since the current mesh's copied to the beginning of the new vertex
        // buffer, it's base index now is 0. If the mesh has any written indices,
        // they're already offset by the old base index.
        IndexBuffer.transferDataTail(indexBuffer, newIndexBuffer, this._currentMeshBaseIndex, currentMeshIndexOffset);
        this._currentMeshBaseIndex = 0;
        this._currentMeshIndexOffset = 0;
        this._indexBuffer = newIndexBuffer;
        this._indexBuffers.push(newIndexBuffer);
    }
    /**
     * Ensures that the managed index buffer has enough space to fit in a given
     * number of indices. Either does nothing or resizes the current index
     * buffer.
     *
     * @param indexCount Number of indices client wants to write to the managed
     *      index buffer.
     */
    _ensureEnoughIndexBufferSpace(indexCount) {
        const buffer = this._indexBuffer;
        const requiredSize = buffer.occupiedSize + indexCount;
        if (requiredSize <= buffer.size) {
            // We have enough space so nothing to be done.
            return;
        }
        let newBufferSize = buffer.size;
        // Let's compute new larger size of the index buffer until we can
        // accommodate incoming data.
        while (requiredSize > newBufferSize) {
            newBufferSize = this._getNextIndexBufferUint16Size(newBufferSize);
        }
        this._indexBuffer.extend(newBufferSize);
    }
}


/***/ }),
/* 50 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floatToUint8", function() { return floatToUint8; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floatToUint16", function() { return floatToUint16; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floatToInt16", function() { return floatToInt16; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floatToUint32", function() { return floatToUint32; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floatToInt32", function() { return floatToInt32; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "int32ToFloat", function() { return int32ToFloat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "uint32ToFloat", function() { return uint32ToFloat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "int16ToFloat", function() { return int16ToFloat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "uint16ToFloat", function() { return uint16ToFloat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "uint8ToFloat", function() { return uint8ToFloat; });
const UINT8_MAX = 0xff;
const UINT16_MAX = 0xffff;
const UINT32_MAX = 0xffffffff;
function floatToUint8(x) {
    return UINT8_MAX * x | 0;
}
function floatToUint16(x) {
    return x * UINT16_MAX | 0;
}
function floatToInt16(x) {
    return (x * UINT16_MAX - 1) / 2 | 0;
}
function floatToUint32(x) {
    return x * UINT32_MAX | 0;
}
function floatToInt32(x) {
    return (x * UINT32_MAX - 1) / 2 | 0;
}
function int32ToFloat(x) {
    return (2 * x + 1) / UINT32_MAX;
}
function uint32ToFloat(x) {
    return x / UINT32_MAX;
}
function int16ToFloat(x) {
    return (2 * x + 1) / UINT16_MAX;
}
function uint16ToFloat(x) {
    return x / UINT16_MAX;
}
function uint8ToFloat(x) {
    return x / UINT8_MAX;
}


/***/ }),
/* 51 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "swap", function() { return swap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reverse", function() { return reverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shuffle", function() { return shuffle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zip", function() { return zip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compare", function() { return compare; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "insertionSort", function() { return insertionSort; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mergeSort", function() { return mergeSort; });
/* harmony import */ var _comparator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);

/**
 * Swaps two values in an array.
 *
 * @param array The array.
 * @param i Index of a value to be swapped.
 * @param j Index of a value to be swapped.
 */
function swap(array, i, j) {
    const t = array[i];
    array[i] = array[j];
    array[j] = t;
}
/**
 * Reverses order of elements in a range in an array.
 *
 * @param array The array.
 * @param start The start of the range.
 * @param end The end of the range.
 */
function reverse(array, start = 0, end = array.length) {
    for (let i = start, j = end - 1; i < j; ++i, --j) {
        swap(array, i, j);
    }
}
/**
 * Rotates a range of elements in an array by given amount.
 *
 * @param array The array.
 * @param amount The amount.
 * @param start The start of the range.
 * @param end The end of the range.
 */
function rotate(array, amount = 1, start = 0, end = array.length) {
    reverse(array, start, end);
    reverse(array, start, start + amount);
    reverse(array, start + amount, end);
}
/**
 * Copies a range of elements from a source array to a range in a destination
 * array.
 *
 * @param src The source array.
 * @param dst The destination array.
 * @param srcStart The start of the source range.
 * @param srcStart The start of the source range.
 * @param dstStart The start of the destination range.
 */
function copy(src, dst, srcStart = 0, srcEnd = src.length, dstStart = 0) {
    for (let i = srcStart, j = dstStart; i < srcEnd; ++i, ++j) {
        dst[j] = src[i];
    }
}
/**
 * Shuffles randomly a range of elements in an array.
 *
 * @param array The array.
 * @param start The start of the range.
 * @param end The end of the range.
 */
function shuffle(array, start = 0, end = array.length) {
    for (let i = start, j = i + 1; i < end; ++i, ++j) {
        swap(array, i, j + (Math.random() * (end - j) | 0));
    }
}
function zip(ts, us, zipper = (t, u) => [t, u]) {
    const l = Math.min(ts.length, us.length);
    const vs = new Array(l);
    for (let i = 0; i < l; ++i) {
        vs[i] = zipper(ts[i], us[i]);
    }
    return vs;
}
/**
 * Compares two arrays lexicographically. The order is specified be the comparator parameter.
 *
 * @param comparator Elements comparator with standard signature.
 * @param a The first array to compare.
 * @param b The second array to compare.
 * @returns 0 if all elements and lengths are equal,
 *      negative number if the first element is less then the second (lexicographically),
 *      positive number if the first element is greater then the second,
 *      if all the elements are equal the lengths are being compared.
 */
function compare(comparator, a, b) {
    const length = Math.min(a.length, b.length);
    for (let i = 0; i < length; i++) {
        const result = comparator(a[i], b[i]);
        if (result) {
            return result;
        }
    }
    return a.length - b.length;
}
/**
 * Sorts a range of elements of an array in place with insertion sort.
 *
 * @param array The array to be sorted.
 * @param comparator Comparator for array elements.
 * @param start Index of the first element in the range to be sorted.
 * @param end Index of an element behind the last element in the range to be
 *      sorted.
 */
function insertionSort(array, comparator = _comparator__WEBPACK_IMPORTED_MODULE_0__["DEFAULT_COMPARATOR"], start = 0, end = array.length) {
    for (let i = start; i < end; ++i) {
        for (let j = i; j > start && comparator(array[j - 1], array[j]) > 0; --j) {
            swap(array, j - 1, j);
        }
    }
}
const BLOCK_SIZE = 32;
/**
 * Merges two sorted ranges of an array. Stores the result into another one.
 *
 * @param src The array with the ranges to be merged.
 * @param dst The array the resulting range will be stored to.
 * @param comparator The comparator for array elements.
 * @param start Start of the first range to be merged.
 * @param middle End of the first and simultaneously start of the second range
 *      to be merged.
 * @param end End of the second range to be merged.
 * @param dstOffset Offset of merged range in the result array.
 */
function merge(src, dst, comparator, start, middle, end, dstOffset) {
    let i = dstOffset;
    let j = start;
    let k = middle;
    while (j < middle && k < end) {
        dst[i++] = comparator(src[j], src[k]) > 0 ? src[k++] : src[j++];
    }
    copy(src, dst, j, middle, i);
    copy(src, dst, k, end, i);
}
/**
 * Sorts a range of elements of an array with merge sort.
 *
 * @param array  The array to be sorted.
 * @param comparator Comparator for array elements.
 * @param end Index of an element behind the last element in the range to be
 *      sorted.
 */
function mergeSort(array, comparator = _comparator__WEBPACK_IMPORTED_MODULE_0__["DEFAULT_COMPARATOR"], start = 0, end = array.length) {
    // First and foremost: if the range is smaller than the block size, just
    // perform insertion sort on it.
    if (end - start <= BLOCK_SIZE) {
        insertionSort(array, comparator, start, end);
        return;
    }
    // First we split the given range into subranges of size BLOCK_SIZE and
    // sort every range with insertion sort.
    {
        let s = start;
        let e = s + BLOCK_SIZE;
        while (e < end) {
            insertionSort(array, comparator, s, e);
            s = e;
            e += BLOCK_SIZE;
        }
        insertionSort(array, comparator, s, end);
    }
    // TODO(dmikis): Implement in-place merge. It seems there're reasonably
    //      complex solutions out there.
    const auxArray = new Array(end - start);
    // Then we merge blocks pairs, increase block size by 2 and repeat.
    for (let blockSize = BLOCK_SIZE; blockSize < end - start; blockSize += blockSize) {
        // TODO(dmikis): Before aforementioned todo maybe implement array
        // pingponging to cut down amount of full copies.
        copy(array, auxArray, start, end);
        let i = start;
        let s = 0;
        let m = blockSize;
        let e = m + blockSize;
        while (e < end - start) {
            merge(auxArray, array, comparator, s, m, e, i);
            s = e;
            m = s + blockSize;
            e = m + blockSize;
            i += 2 * blockSize;
        }
        merge(auxArray, array, comparator, s, Math.min(m, end - start), end - start, i);
    }
}


/***/ }),
/* 52 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_COMPARATOR", function() { return DEFAULT_COMPARATOR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NUMERICAL_COMPARATOR", function() { return NUMERICAL_COMPARATOR; });
function DEFAULT_COMPARATOR(a, b) {
    if (a > b) {
        return 1;
    }
    if (a < b) {
        return -1;
    }
    return 0;
}
function NUMERICAL_COMPARATOR(a, b) {
    return a - b;
}


/***/ }),
/* 53 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return triangulate; });
/* harmony import */ var earcut__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(54);
/* harmony import */ var earcut__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(earcut__WEBPACK_IMPORTED_MODULE_0__);

/**
 * Triangulates complex 2D polygons with holes.
 *
 * @param polygon Polygon with holes encoded as a set of rings, with the first ring representing
 *      the outer contour and others - the holes.
 * @returns Triangle indices that correspond to vertices of all the rings as if they
 *      were flattened into a single array.
 */
function triangulate(polygon) {
    const earcutVertices = [];
    const earcutHoles = [];
    let ringCoordsOffset = 0;
    for (const ring of polygon) {
        // skip the first ring that is not a hole
        if (ringCoordsOffset !== 0) {
            earcutHoles.push(ringCoordsOffset);
        }
        for (const vertex of ring) {
            earcutVertices.push(vertex.x, vertex.y);
            ringCoordsOffset++;
        }
    }
    return earcut__WEBPACK_IMPORTED_MODULE_0___default()(earcutVertices, earcutHoles);
}


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = earcut;
module.exports.default = earcut;

function earcut(data, holeIndices, dim) {

    dim = dim || 2;

    var hasHoles = holeIndices && holeIndices.length,
        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
        outerNode = linkedList(data, 0, outerLen, dim, true),
        triangles = [];

    if (!outerNode) return triangles;

    var minX, minY, maxX, maxY, x, y, invSize;

    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];

        for (var i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        }

        // minX, minY and invSize are later used to transform coords into integers for z-order calculation
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 1 / invSize : 0;
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);

    return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var i, last;

    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
    } else {
        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
    }

    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }

    return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;

    var p = start,
        again;
    do {
        again = false;

        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) break;
            again = true;

        } else {
            p = p.next;
        }
    } while (again || p !== end);

    return end;
}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;

    // interlink polygon nodes in z-order
    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);

    var stop = ear,
        prev, next;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;

        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);

            removeNode(ear);

            // skipping the next vertice leads to less sliver triangles
            ear = next.next;
            stop = next.next;

            continue;
        }

        ear = next;

        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

            // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = cureLocalIntersections(ear, triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }

            break;
        }
    }
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear
    var p = ear.next.next;

    while (p !== ear.prev) {
        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }

    return true;
}

function isEarHashed(ear, minX, minY, invSize) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // triangle bbox; min & max are calculated like this for speed
    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);

    // z-order range for the current triangle bbox;
    var minZ = zOrder(minTX, minTY, minX, minY, invSize),
        maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);

    var p = ear.prevZ,
        n = ear.nextZ;

    // look for points inside the triangle in both directions
    while (p && p.z >= minZ && n && n.z <= maxZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;

        if (n !== ear.prev && n !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
            area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    // look for remaining points in decreasing z-order
    while (p && p.z >= minZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }

    // look for remaining points in increasing z-order
    while (n && n.z <= maxZ) {
        if (n !== ear.prev && n !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
            area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    return true;
}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev,
            b = p.next.next;

        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

            triangles.push(a.i / dim);
            triangles.push(p.i / dim);
            triangles.push(b.i / dim);

            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);

            p = start = b;
        }
        p = p.next;
    } while (p !== start);

    return p;
}

// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);

                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);

                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, invSize);
                earcutLinked(c, triangles, dim, minX, minY, invSize);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [],
        i, len, start, end, list;

    for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }

    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        eliminateHole(queue[i], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
    }

    return outerNode;
}

function compareX(a, b) {
    return a.x - b.x;
}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    outerNode = findHoleBridge(hole, outerNode);
    if (outerNode) {
        var b = splitPolygon(outerNode, hole);
        filterPoints(b, b.next);
    }
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode,
        hx = hole.x,
        hy = hole.y,
        qx = -Infinity,
        m;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                if (x === hx) {
                    if (hy === p.y) return p;
                    if (hy === p.next.y) return p.next;
                }
                m = p.x < p.next.x ? p : p.next;
            }
        }
        p = p.next;
    } while (p !== outerNode);

    if (!m) return null;

    if (hx === qx) return m.prev; // hole touches outer segment; pick lower endpoint

    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var stop = m,
        mx = m.x,
        my = m.y,
        tanMin = Infinity,
        tan;

    p = m.next;

    while (p !== stop) {
        if (hx >= p.x && p.x >= mx && hx !== p.x &&
                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

            if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) {
                m = p;
                tanMin = tan;
            }
        }

        p = p.next;
    }

    return m;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
    var p = start;
    do {
        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    } while (p !== start);

    p.prevZ.nextZ = null;
    p.prevZ = null;

    sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize,
        inSize = 1;

    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }
            qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) tail.nextZ = e;
                else list = e;

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;
        inSize *= 2;

    } while (numMerges > 1);

    return list;
}

// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = 32767 * (x - minX) * invSize;
    y = 32767 * (y - minY) * invSize;

    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start,
        leftmost = start;
    do {
        if (p.x < leftmost.x) leftmost = p;
        p = p.next;
    } while (p !== start);

    return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
           (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
           (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) &&
           locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
}

// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    if ((equals(p1, q1) && equals(p2, q2)) ||
        (equals(p1, q2) && equals(p2, q1))) return true;
    return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 &&
           area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects(p, p.next, a, b)) return true;
        p = p.next;
    } while (p !== a);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ?
        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a,
        inside = false,
        px = (a.x + b.x) / 2,
        py = (a.y + b.y) / 2;
    do {
        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
            inside = !inside;
        p = p.next;
    } while (p !== a);

    return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y),
        b2 = new Node(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);

    if (!last) {
        p.prev = p;
        p.next = p;

    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}

function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;

    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
    // vertice index in coordinates array
    this.i = i;

    // vertex coordinates
    this.x = x;
    this.y = y;

    // previous and next vertice nodes in a polygon ring
    this.prev = null;
    this.next = null;

    // z-order curve value
    this.z = null;

    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;

    // indicates whether this is a steiner point
    this.steiner = false;
}

// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
earcut.deviation = function (data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) {
        for (var i = 0, len = holeIndices.length; i < len; i++) {
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
    }

    var trianglesArea = 0;
    for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
    }

    return polygonArea === 0 && trianglesArea === 0 ? 0 :
        Math.abs((trianglesArea - polygonArea) / polygonArea);
};

function signedArea(data, start, end, dim) {
    var sum = 0;
    for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}

// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
earcut.flatten = function (data) {
    var dim = data[0][0].length,
        result = {vertices: [], holes: [], dimensions: dim},
        holeIndex = 0;

    for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
        }
    }
    return result;
};


/***/ }),
/* 55 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "POLYGON_ATTRIBUTE_MAPPING", function() { return POLYGON_ATTRIBUTE_MAPPING; });
/* harmony import */ var _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(56);

/**
 * Description of how attributes of vertices are packed into a vertex buffer.
 */
const POLYGON_ATTRIBUTE_MAPPING = new _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__["AttributeMapping"]([
    [
        0 /* POSITION_HIGH */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        1 /* POSITION_LOW */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        7 /* COLOR */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        10 /* Z_INDEX */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ]
]);


/***/ }),
/* 56 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AttributeMapping", function() { return AttributeMapping; });
/* harmony import */ var _util_iterable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(57);
/* harmony import */ var _util_pow_of_2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(58);


/**
 * Gives size of a GL type.
 *
 * @param type The type.
 * @returns Size of the type in bytes.
 */
function getTypeSize(type) {
    switch (type) {
        case 5120 /* BYTE */:
        case 5121 /* UNSIGNED_BYTE */:
            return 1;
        case 5122 /* SHORT */:
        case 5123 /* UNSIGNED_SHORT */:
            return 2;
        case 5124 /* INT */:
        case 5125 /* UNSIGNED_INT */:
        case 5126 /* FLOAT */:
            return 4;
    }
}
/**
 * Description of how particular attributes of a vertex are packed into a vertex
 * buffer.
 */
class AttributeMapping extends Map {
    /**
     * Creates a new attribute mapping with a set of attributes of given types and
     * sizes. Automatically computes offsets of the attributes.
     *
     * @param mapping The mapping from attribute IDs to types and sizes.
     * @param alignment Desired alignment of attributes in the vertex data
     *      structure. Must be a power of 2.
     */
    constructor(mapping, alignment = 4 /* ALIGN_4_BYTES */) {
        let offset = 0;
        super(Object(_util_iterable__WEBPACK_IMPORTED_MODULE_0__["mapIterable"])(mapping, ([idx, { type, size, normalized }]) => {
            const pointer = [
                idx,
                {
                    type,
                    size,
                    normalized,
                    offset
                }
            ];
            const attributeSize = size * getTypeSize(type);
            const newOffset = Object(_util_pow_of_2__WEBPACK_IMPORTED_MODULE_1__["align"])(offset + attributeSize, -alignment);
            // TODO(dmikis) Check this in debug mode.
            // if (newOffset - offset > attributeSize) {
            //    console.warn(`${newOffset - offset} byte padding's inserted`);
            // }
            offset = newOffset;
            return pointer;
        }));
        this.vertexByteSize = offset;
    }
}


/***/ }),
/* 57 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findInIterable", function() { return findInIterable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mapIterable", function() { return mapIterable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "filterIterable", function() { return filterIterable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reduceIterable", function() { return reduceIterable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "oneOfIterable", function() { return oneOfIterable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "allOfIterable", function() { return allOfIterable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rangeIterable", function() { return rangeIterable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zipIterables", function() { return zipIterables; });
/**
 * Searches for the first collection item satisfying a predicate.
 *
 * @param collection The collection.
 * @param predicate The predicate.
 * @returns The first item satisfying the predicate or `undefined` if none found.
 */
function findInIterable(collection, predicate) {
    for (const item of collection) {
        if (predicate(item)) {
            return item;
        }
    }
    return;
}
/**
 * Transforms a collection to another one.
 *
 * @param collection The source collection.
 * @param mapper A function producing items for destination collection.
 * @returns Collection of produced items.
 */
function* mapIterable(collection, mapper) {
    for (const item of collection) {
        yield mapper(item);
    }
}
/**
 * Chooses items of a collection satisfying a predicate.
 *
 * @param collection The collection.
 * @param predicate The predicate.
 * @returns Collection of chosen items.
 */
function* filterIterable(collection, predicate) {
    for (const item of collection) {
        if (predicate(item)) {
            yield item;
        }
    }
}
/**
 * Traverses a collection from left to right recomputing an accumulator on every
 * iteration.
 *
 * @param collection The collection.
 * @param reducer The function used to compute next value of the accumulator.
 * @param initial
 * @returns Value of the accumulator.
 */
function reduceIterable(collection, reducer, initial) {
    let result = initial;
    for (const item of collection) {
        result = reducer(result, item);
    }
    return result;
}
/**
 * Checks if there's at least one item in a collection satisfying a predicate.
 *
 * @param collection The collection.
 * @param predicate The predicate.
 * @returns `true` if for at least one item in the collection the predicate returns
 *      `true` and `false` otherwise.
 */
function oneOfIterable(collection, predicate) {
    for (const item of collection) {
        if (predicate(item)) {
            return true;
        }
    }
    return false;
}
/**
 * Checks if all items of a collection satisfy a predicate.
 *
 * @param collection The collection.
 * @param predicate The predicate.
 * @returns `false` if for at least one item in the collection the predicate returns
 *      `false` and `true` otherwise.
 */
function allOfIterable(collection, predicate) {
    for (const item of collection) {
        if (!predicate(item)) {
            return false;
        }
    }
    return true;
}
/**
 * Creates an iterator for [startIndex, startIndex+length) range.
 */
function* rangeIterable(length, startIndex = 0) {
    const endIndex = startIndex + length;
    for (let i = startIndex; i < endIndex; i++) {
        yield i;
    }
}
function* zipIterables(ts, us, zipper = (t, u) => [t, u]) {
    const tIterator = ts[Symbol.iterator]();
    const uIterator = us[Symbol.iterator]();
    for (let t = tIterator.next(), u = uIterator.next(); !(t.done || u.done); t = tIterator.next(), u = uIterator.next()) {
        yield zipper(t.value, u.value);
    }
}


/***/ }),
/* 58 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isPowOf2", function() { return isPowOf2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "align", function() { return align; });
/**
 * Checks if a number is a power of 2.
 *
 * @param x The number to check.
 * @returns `true` if the number is an integer power of 2 and `false` otherwise.
 */
function isPowOf2(x) {
    return x > 0 && !(x & (x - 1));
}
/**
 * Aligns an offset by an alignment given by a mask.
 *
 * @param offset The offset.
 * @param alignmentMask The alignment mask  a bit field that has `log2(alignment)`
 *      of least significant bits unset and other set, e.g. if `alignment` is 4
 *      then the `alignmentMask` will be `0xffffffc`
 * @returns Aligned offset.
 */
function align(offset, alignmentMask) {
    return (offset - 1 & alignmentMask) - alignmentMask;
}


/***/ }),
/* 59 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "intToZIndex", function() { return intToZIndex; });
const MIN_ZINDEX = -1 + Math.pow(2, 1 - 24); // epsilon is added (for normalized 24-bit value) to free up reserved value
function intToZIndex(x) {
    return Math.max(MIN_ZINDEX, x / 0x7fffff);
}


/***/ }),
/* 60 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TexturedPolygonBufferWriter; });
/* harmony import */ var _util_buffer_writer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(49);
/* harmony import */ var _util_triangulate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(53);
/* harmony import */ var _textured_polygon_attribute_mapping__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(61);
/* harmony import */ var _util_z_index__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(59);




/**
 * Writer of geometry data of polygon images.
 */
class TexturedPolygonBufferWriter extends _util_buffer_writer__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super(_textured_polygon_attribute_mapping__WEBPACK_IMPORTED_MODULE_2__["TEXTURED_POLYGON_ATTRIBUTE_MAPPING"].vertexByteSize);
    }
    writePolygon(polygon, imageLocation, zIndex) {
        for (const ring of polygon.vertexRings) {
            for (const vertex of ring) {
                this._writeVertex(vertex, imageLocation, 0, Object(_util_z_index__WEBPACK_IMPORTED_MODULE_3__["intToZIndex"])(zIndex));
            }
        }
        this.writeIndices(Object(_util_triangulate__WEBPACK_IMPORTED_MODULE_1__["default"])(polygon.vertexRings));
        return this.endMesh();
    }
    /**
     * @param position World coordinates of the vertex.
     * @param imageLocation Location of the pateern in atlas.
     * @param imageScale How world coordinates relate to the image size.
     * @param zIndex Vertex z-coordinate.
     */
    _writeVertex(position, imageLocation, imageScale, zIndex) {
        this._writeWorldCoordinate(position);
        this._writeHalfWords(imageLocation.minX, imageLocation.minY);
        this._writeHalfWords(imageLocation.maxX - imageLocation.minX, imageLocation.maxY - imageLocation.minY);
        this._writeFloat32(imageScale);
        this._writeFloat32(zIndex);
    }
}


/***/ }),
/* 61 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEXTURED_POLYGON_ATTRIBUTE_MAPPING", function() { return TEXTURED_POLYGON_ATTRIBUTE_MAPPING; });
/* harmony import */ var _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(56);

/**
 * Description of how attributes of vertices are packed into a vertex buffer.
 */
const TEXTURED_POLYGON_ATTRIBUTE_MAPPING = new _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__["AttributeMapping"]([
    [
        0 /* POSITION_HIGH */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        1 /* POSITION_LOW */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        4 /* UV */,
        {
            size: 4,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: false
        }
    ],
    [
        11 /* AUX */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        10 /* Z_INDEX */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ]
]);


/***/ }),
/* 62 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAX_HALF_WIDTH", function() { return MAX_HALF_WIDTH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAX_FILL_GAP", function() { return MAX_FILL_GAP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PolylineBufferWriter; });
/* harmony import */ var _math_vector2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(43);
/* harmony import */ var _util_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(38);
/* harmony import */ var _util_buffer_writer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(49);
/* harmony import */ var _polyline_attribute_mapping__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(63);
/* harmony import */ var _util_gputypes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(50);
/* harmony import */ var _util_z_index__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(59);
/* harmony import */ var _math_scalar__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(42);







/**
 * Computes miter of a join between two segments.
 *
 * @param n1 Normal vector of the first segment.
 * @param n2 Normal vector of the second segment.
 * @returns Miter value, i.e. by how match displacement is longer than a normal
 *      one.
 */
function computeMiter(n1, n2) {
    return Math.sqrt(2 / (1 + _math_vector2__WEBPACK_IMPORTED_MODULE_0__["dot"](n1, n2)));
}
const SEGMENT_VERTEX_COUNT = 4;
const SQUARE_CAP_VERTEX_COUNT = 5;
const ROUND_CAP_VERTEX_COUNT = 4;
const FLOAT_MAX = 3.4028234663852886e+38;
const MITER_LIMIT = 4;
const UV_POS_ONE_PACKED = 255; // packed 1
const UV_NEG_ONE_PACKED = 1; // packed -1
const UV_ZERO_PACKED = 128;
/**
 * Packs a component of uv into a unsigned 8-bit value. After packing -1 will
 * become 1 and 1 will become 255. That's need to emulate zero-preserving
 * normalization (we can't rely on WebGL to do it for us :().
 *
 * @param c The component.
 * @returns Packed component.
 */
function packUvComponent(c) {
    // We don't truncate here because buffer writer will do that for us.
    return 128 + (127 * c);
}
/**
 * Half width of the polyline is stored in a normalized attribute. This constant
 * defines half width value of 1 corresponds to.
 */
const MAX_HALF_WIDTH = 255 / 4; // px
/**
 * Same as for polyline half width, but for dash pattern definition.
 */
const MAX_FILL_GAP = 255; // px
class PolylineBufferWriter extends _util_buffer_writer__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor() {
        super(_polyline_attribute_mapping__WEBPACK_IMPORTED_MODULE_3__["POLYLINE_ATTRIBUTE_MAPPING"].vertexByteSize);
        this._displacement = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["create"](0, 0);
        this._prevDisplacement = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["create"](0, 0);
        this._initPolylineState([_math_vector2__WEBPACK_IMPORTED_MODULE_0__["ZERO"], _math_vector2__WEBPACK_IMPORTED_MODULE_0__["ZERO"]], 0, 0, 0, 0, 0 /* MITER */, 0);
    }
    /**
     * Generates a mesh for a polyline with a given style, baking all necessary
     * parameters into attributes.
     *
     * @param polyline The polyline.
     * @param style The polyline style.
     * @returns Location of the written mesh in the managed buffers.
     */
    writePolyline(polyline, style, zIndex) {
        const { vertices } = polyline;
        const lastIdx = vertices.length - 1;
        if (lastIdx < 1) {
            throw new Error('One vertex in not a polyline. It\'s not even a line.');
        }
        this._initPolylineState(vertices, Object(_util_color__WEBPACK_IMPORTED_MODULE_1__["encodeRgba8"])(style.strokeColor), style.strokeWidth, style.dash ? style.dash.fill : 0, style.dash ? style.dash.gap : 0, style.join, Object(_util_z_index__WEBPACK_IMPORTED_MODULE_5__["intToZIndex"])(zIndex));
        this._writeCap(style.startCap, vertices[0], 1);
        for (let i = 1; i < lastIdx; ++i) {
            this._writeSegment(vertices[i - 1], vertices[i], vertices[i + 1]);
            this._writeJoin(vertices[i]);
        }
        this._writeLastSegment(vertices[lastIdx - 1], vertices[lastIdx]);
        this._writeCap(style.endCap, vertices[lastIdx], 1);
        return this.endMesh();
    }
    _initPolylineState(vertices, colorRgba8, width, fill, gap, join, zIndex) {
        this._baseIndex = this._polylineLength = this._lastDirection = 0;
        this._lastSignedMiter = 1;
        const displacement = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["sub"](vertices[1], vertices[0], this._displacement);
        this._segmentLength = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["length"](displacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["divn"](displacement, this._segmentLength, displacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["rotate90"](displacement, displacement);
        this._colorRgba8 = colorRgba8;
        this._halfWidthFillGapPacked =
            Object(_util_gputypes__WEBPACK_IMPORTED_MODULE_4__["floatToUint8"])(Object(_math_scalar__WEBPACK_IMPORTED_MODULE_6__["clamp"])(0.5 * width, 0, MAX_HALF_WIDTH) / MAX_HALF_WIDTH) |
                Object(_util_gputypes__WEBPACK_IMPORTED_MODULE_4__["floatToUint8"])(Object(_math_scalar__WEBPACK_IMPORTED_MODULE_6__["clamp"])(fill, 0, MAX_FILL_GAP) / MAX_FILL_GAP) << 8 |
                Object(_util_gputypes__WEBPACK_IMPORTED_MODULE_4__["floatToUint8"])(Object(_math_scalar__WEBPACK_IMPORTED_MODULE_6__["clamp"])(gap, 0, MAX_FILL_GAP) / MAX_FILL_GAP) << 16;
        this._join = join;
        this._zIndex = zIndex;
    }
    /**
     * Writes a single vertex into managed vertex buffer.
     *
     * @param position Vertex world position.
     * @param normal Normal of segment the vertex belongs to.
     * @param u Normalized distance to the polyline along the normal.
     * @param v Normalized distance to the polyline along the tangent.
     * @param polylineLength Distance to the first vertex along the polyline.
     * @param miter Join miter.
     * @param lengthCorrectionLimit Limit on the vertex displacement along the
     *      polyline.
     */
    _writeVertex(position, normal, uPacked, vPacked, polylineLength, miter, lengthCorrectionLimit) {
        this._writeWorldCoordinate(position);
        this._writeHalfWords(Object(_util_gputypes__WEBPACK_IMPORTED_MODULE_4__["floatToUint16"])(0.5 * (normal.x * Math.SQRT1_2 + 1)), Object(_util_gputypes__WEBPACK_IMPORTED_MODULE_4__["floatToUint16"])(0.5 * (normal.y * Math.SQRT1_2 + 1)));
        this._writeHalfWords(uPacked, vPacked);
        this._writeWord(this._halfWidthFillGapPacked);
        this._writeFloat32(miter);
        this._writeFloat32(lengthCorrectionLimit);
        this._writeFloat32(polylineLength);
        this._writeWord(this._colorRgba8);
        this._writeFloat32(this._zIndex);
    }
    _writeCap(cap, endVertex, displacementSign) {
        switch (cap) {
            case 1 /* ROUND */:
                this._writeRoundCap(endVertex, displacementSign);
                break;
            case 2 /* SQUARE */:
                this._writeSquareCap(endVertex, displacementSign);
                break;
        }
    }
    _writeRoundCap(endVertex, displacementSign) {
        const displacement = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["create"](0, 0);
        const polylineLength = this._polylineLength;
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["muln"](this._displacement, -displacementSign, displacement);
        this._writeVertex(endVertex, displacement, UV_NEG_ONE_PACKED, UV_ZERO_PACKED, polylineLength, 1, FLOAT_MAX);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["rotate90"](this._displacement, displacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["sub"](displacement, this._displacement, displacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["muln"](displacement, displacementSign, displacement);
        this._writeVertex(endVertex, displacement, UV_NEG_ONE_PACKED, UV_POS_ONE_PACKED, polylineLength, 1, FLOAT_MAX);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["muln"](this._displacement, displacementSign, displacement);
        this._writeVertex(endVertex, displacement, UV_POS_ONE_PACKED, UV_ZERO_PACKED, polylineLength, 1, FLOAT_MAX);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["rotate90"](this._displacement, displacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["add"](displacement, this._displacement, displacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["muln"](displacement, displacementSign, displacement);
        this._writeVertex(endVertex, displacement, UV_POS_ONE_PACKED, UV_POS_ONE_PACKED, polylineLength, 1, FLOAT_MAX);
        this.writeIndicesForContinuousStrip(ROUND_CAP_VERTEX_COUNT, this._baseIndex);
        this._baseIndex += ROUND_CAP_VERTEX_COUNT;
    }
    _writeSquareCap(endVertex, displacementSign) {
        const displacement = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["create"](0, 0);
        const polylineLength = this._polylineLength;
        this._writeVertex(endVertex, _math_vector2__WEBPACK_IMPORTED_MODULE_0__["ZERO"], UV_ZERO_PACKED, UV_ZERO_PACKED, polylineLength, 1, 0);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["muln"](this._displacement, -displacementSign, displacement);
        this._writeVertex(endVertex, displacement, UV_POS_ONE_PACKED, UV_ZERO_PACKED, polylineLength, 1, FLOAT_MAX);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["rotate90"](this._displacement, displacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["sub"](displacement, this._displacement, displacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["muln"](displacement, displacementSign, displacement);
        this._writeVertex(endVertex, displacement, UV_POS_ONE_PACKED, UV_ZERO_PACKED, polylineLength, 1, FLOAT_MAX);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["rotate90"](this._displacement, displacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["sub"](displacement, this._displacement, displacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["muln"](displacement, displacementSign, displacement);
        this._writeVertex(endVertex, displacement, UV_POS_ONE_PACKED, UV_ZERO_PACKED, polylineLength, 1, FLOAT_MAX);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["muln"](this._displacement, displacementSign, displacement);
        this._writeVertex(endVertex, this._displacement, UV_POS_ONE_PACKED, UV_ZERO_PACKED, polylineLength, 1, FLOAT_MAX);
        this.writeIndicesForContinuousFan(SQUARE_CAP_VERTEX_COUNT, this._baseIndex);
        this._baseIndex += SQUARE_CAP_VERTEX_COUNT;
    }
    _writeSegment(start, end, nextEnd) {
        const displacement = this._displacement;
        const polylineLength = this._polylineLength;
        const nextSegmentLength = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["distance"](nextEnd, end);
        const nextSegmentNormal = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["sub"](nextEnd, end);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["divn"](nextSegmentNormal, nextSegmentLength, nextSegmentNormal);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["rotate90"](nextSegmentNormal, nextSegmentNormal);
        const direction1 = this._lastDirection;
        const direction2 = Math.sign(_math_vector2__WEBPACK_IMPORTED_MODULE_0__["crossZ"](displacement, nextSegmentNormal));
        const miter1 = this._lastSignedMiter;
        const miter2 = computeMiter(displacement, nextSegmentNormal);
        this._writeVertex(start, displacement, UV_POS_ONE_PACKED, UV_ZERO_PACKED, polylineLength, direction1 === -1 && (this._join !== 0 /* MITER */ || Math.abs(miter1) > MITER_LIMIT) ?
            1 :
            miter1, direction1 === -1 ? -FLOAT_MAX : 0.5 * this._segmentLength);
        this._writeVertex(end, displacement, UV_POS_ONE_PACKED, UV_ZERO_PACKED, polylineLength + this._segmentLength, direction2 === -1 && (this._join !== 0 /* MITER */ || miter2 > MITER_LIMIT) ?
            1 :
            direction2 * miter2, direction2 === -1 ? FLOAT_MAX : -0.5 * this._segmentLength);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["invert"](displacement, displacement);
        this._writeVertex(start, displacement, UV_NEG_ONE_PACKED, UV_ZERO_PACKED, polylineLength, direction1 === 1 && (this._join !== 0 /* MITER */ || Math.abs(miter1) > MITER_LIMIT) ?
            1 :
            miter1, direction1 === 1 ? -FLOAT_MAX : 0.5 * this._segmentLength);
        this._writeVertex(end, displacement, UV_NEG_ONE_PACKED, UV_ZERO_PACKED, polylineLength + this._segmentLength, direction2 === 1 && (this._join !== 0 /* MITER */ || miter2 > MITER_LIMIT) ?
            1 :
            direction2 * miter2, direction2 === 1 ? FLOAT_MAX : -0.5 * this._segmentLength);
        this.writeIndicesForContinuousStrip(SEGMENT_VERTEX_COUNT, this._baseIndex);
        this._baseIndex += SEGMENT_VERTEX_COUNT;
        this._lastSignedMiter = -direction2 * miter2;
        this._lastDirection = direction2;
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["copy"](displacement, this._prevDisplacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["copy"](nextSegmentNormal, displacement);
        this._polylineLength += this._segmentLength;
        this._segmentLength = nextSegmentLength;
    }
    _writeJoin(joinVertex) {
        switch (this._join) {
            case 2 /* BEVEL */:
                this._writeBevelJoin(joinVertex);
                break;
            case 1 /* ROUND */:
                this._writeRoundJoin(joinVertex);
                break;
            case 0 /* MITER */:
                if (Math.abs(this._lastSignedMiter) > MITER_LIMIT) {
                    this._writeBevelJoin(joinVertex);
                }
                break;
        }
    }
    _writeBevelJoin(joinVertex) {
        const lastDirection = this._lastDirection;
        const displacement = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["invert"](this._displacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["add"](displacement, this._prevDisplacement, displacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["muln"](displacement, 0.5 * lastDirection, displacement);
        this._writeVertex(joinVertex, displacement, lastDirection === -1 /* LEFT */ ?
            UV_POS_ONE_PACKED :
            UV_NEG_ONE_PACKED, UV_ZERO_PACKED, this._polylineLength, 1, 1);
        const baseIndex = this._baseIndex;
        this.writeIndices([
            baseIndex - 1,
            baseIndex - 3,
            baseIndex,
            baseIndex,
            lastDirection === -1 /* LEFT */ ? baseIndex + 1 : baseIndex + 3,
            lastDirection === -1 /* LEFT */ ? baseIndex + 3 : baseIndex + 1
        ]);
        this._baseIndex += 1;
    }
    _writeRoundJoin(joinVertex) {
        const polylineLength = this._polylineLength;
        this._writeVertex(joinVertex, _math_vector2__WEBPACK_IMPORTED_MODULE_0__["ZERO"], UV_ZERO_PACKED, UV_ZERO_PACKED, polylineLength, 0, 0);
        const lastDirection = this._lastDirection;
        const middleDisplacement = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["invert"](this._prevDisplacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["add"](this._displacement, middleDisplacement, middleDisplacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["normalize"](middleDisplacement, middleDisplacement);
        const displacement = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["invert"](this._prevDisplacement);
        const miter1 = computeMiter(middleDisplacement, displacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["add"](displacement, middleDisplacement, displacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["normalize"](displacement, displacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["muln"](displacement, -lastDirection * miter1, displacement);
        this._writeVertex(joinVertex, displacement, lastDirection === -1 /* LEFT */ ?
            UV_POS_ONE_PACKED :
            UV_NEG_ONE_PACKED, packUvComponent(Math.sqrt(miter1 * miter1 - 1)), polylineLength, 1, FLOAT_MAX);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["muln"](middleDisplacement, -lastDirection, displacement);
        this._writeVertex(joinVertex, displacement, lastDirection === -1 /* LEFT */ ?
            UV_POS_ONE_PACKED :
            UV_NEG_ONE_PACKED, UV_ZERO_PACKED, polylineLength, 1, FLOAT_MAX);
        const miter2 = computeMiter(middleDisplacement, this._displacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["add"](this._displacement, middleDisplacement, displacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["normalize"](displacement, displacement);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["muln"](displacement, -lastDirection * miter2, displacement);
        this._writeVertex(joinVertex, displacement, lastDirection === -1 /* LEFT */ ?
            UV_POS_ONE_PACKED :
            UV_NEG_ONE_PACKED, packUvComponent(Math.sqrt(miter2 * miter2 - 1)), polylineLength, 1, FLOAT_MAX);
        const baseIndex = this._baseIndex;
        this.writeIndices([
            baseIndex - 3,
            baseIndex - 1,
            baseIndex,
            baseIndex,
            lastDirection === -1 /* LEFT */ ? baseIndex - 3 : baseIndex - 1,
            baseIndex + 1,
            baseIndex,
            baseIndex + 1,
            baseIndex + 2,
            baseIndex,
            baseIndex + 2,
            baseIndex + 3,
            baseIndex,
            baseIndex + 3,
            lastDirection === -1 /* LEFT */ ? baseIndex + 4 : baseIndex + 6,
            baseIndex,
            baseIndex + 4,
            baseIndex + 6
        ]);
        this._baseIndex += 4;
    }
    _writeLastSegment(start, end) {
        const displacement = this._displacement;
        const lastDirection = this._lastDirection;
        const polylineLength = this._polylineLength;
        const miter = this._lastSignedMiter;
        this._writeVertex(start, displacement, UV_POS_ONE_PACKED, UV_ZERO_PACKED, polylineLength, lastDirection === -1 /* LEFT */ && (this._join !== 0 /* MITER */ || Math.abs(miter) > MITER_LIMIT) ?
            1 :
            miter, lastDirection === -1 /* LEFT */ ? -FLOAT_MAX : this._segmentLength);
        this._writeVertex(end, displacement, UV_POS_ONE_PACKED, UV_ZERO_PACKED, polylineLength + this._segmentLength, 1, FLOAT_MAX);
        _math_vector2__WEBPACK_IMPORTED_MODULE_0__["invert"](displacement, displacement);
        this._writeVertex(start, displacement, UV_NEG_ONE_PACKED, UV_ZERO_PACKED, polylineLength, lastDirection === 1 /* RIGHT */ && (this._join !== 0 /* MITER */ || Math.abs(miter) > MITER_LIMIT) ?
            1 :
            miter, lastDirection === 1 /* RIGHT */ ? -FLOAT_MAX : this._segmentLength);
        this._writeVertex(end, displacement, UV_NEG_ONE_PACKED, UV_ZERO_PACKED, polylineLength + this._segmentLength, 1, FLOAT_MAX);
        this.writeIndicesForContinuousStrip(SEGMENT_VERTEX_COUNT, this._baseIndex);
        this._baseIndex += SEGMENT_VERTEX_COUNT;
    }
}


/***/ }),
/* 63 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "POLYLINE_ATTRIBUTE_MAPPING", function() { return POLYLINE_ATTRIBUTE_MAPPING; });
/* harmony import */ var _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(56);

/**
 * Description of how attributes of vertices are packed into a vertex buffer.
 */
const POLYLINE_ATTRIBUTE_MAPPING = new _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__["AttributeMapping"]([
    /** Vertex world position. */
    [
        0 /* POSITION */,
        {
            size: 4,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    /** Normal to polyline segment the vertex belong to. */
    [
        5 /* NORMAL */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    /**
     * "UV" vertex that used to compute stroke and dashes. It's components:
     *
     *   - distance to the analytical polyline along segment's normal;
     *   - distance to the analytical polyline along segment.
     */
    [
        4 /* UV */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: false
        }
    ],
    /**
     * Vector with polyline's half width and dash style. It's components:
     *
     *   - half width;
     *   - length of a dash;
     *   - distance between dashes.
     */
    [
        11 /* AUX */,
        {
            size: 3,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    /**
     * Miter (i.e. how much displacement of the vertex is longer then the
     * normal).
     */
    [
        12 /* AUX1 */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    /**
     * Limit on displacement tangent component.Applied to avoid geometry
     * glitches in over-degenerative cases.
     */
    [
        13 /* AUX2 */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    /**
     * Distance to the first vertex along the polyline.
     */
    [
        14 /* AUX3 */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    /** Polyline's color. */
    [
        7 /* COLOR */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    /** Polyline's Z index. */
    [
        10 /* Z_INDEX */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ]
]);


/***/ }),
/* 64 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return extractPolygons; });
/* harmony import */ var _tile_world_coordinates_converter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _util_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(38);
/* harmony import */ var _extract_styles__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(45);
/* harmony import */ var _util_iterable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(57);




/**
 * Utility method for getting polygon ring vertices from API tile response.
 */
function* extractVertices(polygons, coordsOffset, ringSize, converter) {
    // coordinates are stored in deltas relatively to the first values in ring
    // so we need to accumulate x and y to determine subsequent coordinates
    let x = 0;
    let y = 0;
    for (let j = 0; j < ringSize; j++) {
        x += polygons.coordsx[coordsOffset];
        y += polygons.coordsy[coordsOffset];
        yield converter.toWorldCoordinates(x, y);
        coordsOffset++;
    }
}
/**
 * Utility method for getting polygon rings from API tile response.
 */
function* extractRings(polygons, coordsOffset, ringSizeOffset, ringSizeLength, converter) {
    for (let i = 0; i < ringSizeLength; i++) {
        const ringSize = polygons.ringSize[ringSizeOffset + i];
        yield extractVertices(polygons, coordsOffset, ringSize, converter);
        coordsOffset += ringSize;
    }
}
function convertMeshDescription(height, converter, styles, mesh) {
    if (mesh && mesh.bbox) {
        return {
            objectId: mesh.objectId,
            meshId: mesh.meshId,
            bbox: {
                minX: converter.toWorldXCoordinate(mesh.bbox.minX),
                maxX: converter.toWorldXCoordinate(mesh.bbox.maxX),
                minY: converter.toWorldYCoordinate(mesh.bbox.maxY),
                maxY: converter.toWorldYCoordinate(mesh.bbox.minY),
                minZ: height,
                maxZ: 0
            },
            color: styles[0].color
        };
    }
    else {
        return undefined;
    }
}
/**
 * Utility method for getting polygon specific style details from a zoom slice.
 * To be used as a zoom slice style converter for style extractor.
 */
function convertZoomSliceToStyle(slice, styleBase) {
    if (slice.poly) {
        const extruded = !!slice.poly.extrusion && slice.poly.extrusion.enabled;
        return Object.assign({}, styleBase, { color: Object(_util_color__WEBPACK_IMPORTED_MODULE_1__["decodeAbgr8"])(slice.poly.color), pattern: slice.poly.pattern ? {
                imageId: slice.poly.pattern.id,
                width: slice.poly.pattern.width
            } : undefined, extruded, height: extruded ? slice.poly.extrusion.height : 0 });
    }
    return undefined;
}
/**
 * Utility method for getting point labels from API tile response.
 */
function* extractPolygons(tile, decodedApiTile, tileMinZoom, tileMaxZoom) {
    const polygons = decodedApiTile.polygons;
    if (polygons) {
        const converter = new _tile_world_coordinates_converter__WEBPACK_IMPORTED_MODULE_0__["default"](tile);
        let ringCountOffset = 0;
        let ringSizeOffset = 0;
        let coordsOffset = 0;
        const meshes = polygons.mesh.reduce((meshes, mesh) => (meshes.set(mesh.polygonId, mesh), meshes), new Map());
        while (ringCountOffset < polygons.ringCount.length) {
            const polygonRingSizeLength = polygons.ringCount[ringCountOffset];
            const polygonRingSizeOffset = ringSizeOffset;
            const polygonCoordsOffset = coordsOffset;
            const classId = polygons.classId[ringCountOffset];
            const styles = [
                ...Object(_extract_styles__WEBPACK_IMPORTED_MODULE_2__["default"])(decodedApiTile.presentation, classId, convertZoomSliceToStyle, tileMinZoom, tileMaxZoom)
            ];
            const isExtruded = styles[0] && styles[0].extruded;
            const height = isExtruded ?
                converter.toWorldZCoordinate(polygons.height[ringCountOffset] || styles[0].height || 0) :
                0;
            const externalMesh = isExtruded ?
                convertMeshDescription(height, converter, styles, meshes.get(ringCountOffset)) :
                undefined;
            let coordsLength = 0;
            for (let i = 0; i < polygonRingSizeLength; i++) {
                coordsLength += polygons.ringSize[ringSizeOffset + i];
            }
            yield {
                vertexRings: [...Object(_util_iterable__WEBPACK_IMPORTED_MODULE_3__["mapIterable"])(extractRings(polygons, polygonCoordsOffset, polygonRingSizeOffset, polygonRingSizeLength, converter), (ringIterable) => [...ringIterable])],
                height,
                externalMesh,
                styles
            };
            ringSizeOffset += polygonRingSizeLength;
            coordsOffset += coordsLength;
            ringCountOffset++;
        }
    }
}


/***/ }),
/* 65 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ExtrudedPolygonBufferWriter", function() { return ExtrudedPolygonBufferWriter; });
/* harmony import */ var _util_triangulate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(53);
/* harmony import */ var _primitive_model_model_buffer_writer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(66);
/* harmony import */ var _util_color__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(38);



/**
 * Buffer writer that writes extruded polygons as 3D meshes.
 * It just moves a polygon up to the height and adds the "walls" around.
 */
class ExtrudedPolygonBufferWriter extends _primitive_model_model_buffer_writer__WEBPACK_IMPORTED_MODULE_1__["default"] {
    /**
     * Writes a polygon as a prism with specified height and with only one upper base.
     *
     * @param polygon The form of the prism's base.
     * @param height The height of the prism, world z-coordinate.
     * @returns The location of the mesh in a buffer.
     */
    writePolygon(polygon, height, color) {
        const encodedColor = Object(_util_color__WEBPACK_IMPORTED_MODULE_2__["encodeRgba8"])(color);
        const vertices = polygon.vertexRings.reduce((vertices, ring) => (vertices.push(...ring), vertices), []);
        for (const vertex of vertices) {
            this._writeVertex(Object.assign({}, vertex, { z: height }), encodedColor);
        }
        for (const vertex of vertices) {
            this._writeVertex(Object.assign({}, vertex, { z: 0 }), encodedColor);
        }
        this.writeIndices(Object(_util_triangulate__WEBPACK_IMPORTED_MODULE_0__["default"])(polygon.vertexRings));
        this._buildWall(polygon.vertexRings, vertices.length);
        return this.endMesh();
    }
    _buildWall(vertexRings, verticesCount) {
        let offset = 0;
        for (const ring of vertexRings) {
            for (let i = 0; i < ring.length; i++) {
                const from = offset + i;
                const to = offset + (i + 1) % ring.length;
                this.writeIndices([
                    from + verticesCount,
                    to,
                    from,
                    from + verticesCount,
                    to + verticesCount,
                    to
                ]);
            }
            offset += ring.length;
        }
    }
}


/***/ }),
/* 66 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ModelBufferWriter; });
/* harmony import */ var _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(56);
/* harmony import */ var _util_buffer_writer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49);


/**
 * Base class for 3D models buffer writers. It is not supposed to write indices, instead it writes vertices (possibly
 * duplicated) in order that correspond to triangular facets of the mesh.
 */
class ModelBufferWriter extends _util_buffer_writer__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor() {
        super(ModelBufferWriter.ATTRIBUTE_MAPPING.vertexByteSize);
    }
    /**
     * Writes a vertex to the vertex buffer.
     */
    _writeVertex(v, colorRgba8) {
        const vertexIdx = this.getCurrentVertexIdx();
        this._writeWorldCoordinate(v);
        this._writeFloat32(v.z);
        this._writeWord(colorRgba8);
        return vertexIdx;
    }
}
/**
 * Description of how attributes of vertices are packed into a vertex buffer.
 */
ModelBufferWriter.ATTRIBUTE_MAPPING = new _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__["AttributeMapping"]([
    [
        0 /* POSITION_HIGH */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        1 /* POSITION_LOW */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        3 /* HEIGHT */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        7 /* COLOR */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ]
]);


/***/ }),
/* 67 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return extractCurvedLabels; });
/* harmony import */ var _tile_world_coordinates_converter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var _extract_styles__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(45);
/* harmony import */ var _extract_labels__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(68);



/**
 * Utility method for getting label polyline from API tile response.
 *
 * @param curvedLabels API tile response.
 * @param polylineOffset Offset of polyline in vertex arrays.
 * @param polylineLength Number of points in polyline.
 * @param converter Vertex coordinates are stored in tile coordinates, output should be converted.
 */
function* extractPolyline(curvedLabels, polylineOffset, polylineLength, converter) {
    // the first vertex is in absolute tile coordinates,
    // others - in deltas that should be added to the previous (accumulated) value
    let x = 0;
    let y = 0;
    for (let i = 0; i < polylineLength; i++) {
        yield converter.toWorldCoordinates(x += curvedLabels.vertexX[polylineOffset + i], y += curvedLabels.vertexY[polylineOffset + i]);
    }
}
/**
 * Utility method for getting texts (text and altText) from API tile response. These texts are both optional and
 * returned iterable may contains from 0 to 2 texts.
 *
 * @param curvedLabels API tile response.
 * @param index Label position in curvedLabels's text/textAlt arrays.
 */
function* extractTexts(curvedLabels, index) {
    if (curvedLabels.text[index]) {
        yield {
            textLines: [{ glyphIds: curvedLabels.text[index].glyphs }]
        };
    }
    if (curvedLabels.textAlt[index] && curvedLabels.textAlt[index].glyphs.length > 0) {
        yield {
            textLines: [{ glyphIds: curvedLabels.textAlt[index].glyphs }]
        };
    }
}
/**
 * Overridden style converter, takes care of vertical distance extraction.
 */
function convertZoomSliceToCurvedLabelStyle(slice, styleBase) {
    const style = Object(_extract_labels__WEBPACK_IMPORTED_MODULE_2__["convertZoomSliceToLabelStyle"])(slice, styleBase);
    if (style && slice.label && slice.label.hdistance) {
        style.distance = slice.label.hdistance;
    }
    return style;
}
/**
 * Utility method for getting curved labels from API tile response.
 */
function* extractCurvedLabels(tile, decodedApiTile, tileMinZoom, tileMaxZoom) {
    const labels = decodedApiTile.polylineLabels;
    if (labels) {
        const converter = new _tile_world_coordinates_converter__WEBPACK_IMPORTED_MODULE_0__["default"](tile);
        let offset = 0;
        for (let i = 0; i < labels.text.length; i++) {
            const classId = labels.classId[i];
            const vertexCount = labels.verticesCount[i];
            yield {
                polyline: [...extractPolyline(labels, offset, vertexCount, converter)],
                priority: labels.priority[i],
                texts: [...extractTexts(labels, i)],
                styles: [
                    ...Object(_extract_styles__WEBPACK_IMPORTED_MODULE_1__["default"])(decodedApiTile.presentation, classId, convertZoomSliceToCurvedLabelStyle, tileMinZoom, tileMaxZoom)
                ]
            };
            offset += vertexCount;
        }
    }
}


/***/ }),
/* 68 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "convertZoomSliceToLabelStyle", function() { return convertZoomSliceToLabelStyle; });
/* harmony import */ var _util_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);

function convertTextStyle(style) {
    return {
        color: Object(_util_color__WEBPACK_IMPORTED_MODULE_0__["decodeAbgr8"])(style.color),
        outlineColor: Object(_util_color__WEBPACK_IMPORTED_MODULE_0__["decodeAbgr8"])(style.outlineColor),
        fontId: style.fontId,
        fontSize: style.fontSize
    };
}
/**
 * Utility method for getting point label specific style details from a zoom slice.
 * To be used as a zoom slice style converter for style extractor.
 */
function convertZoomSliceToLabelStyle(slice, styleBase) {
    const styles = [];
    if (slice.label) {
        if (slice.label.text) {
            styles.push(convertTextStyle(slice.label.text));
        }
        if (slice.label.textAlt) {
            styles.push(convertTextStyle(slice.label.textAlt));
        }
        return Object.assign({}, styleBase, { distance: 0, styles: styles, align: 1 /* CENTER */, background: slice.label.background ?
                {
                    color: Object(_util_color__WEBPACK_IMPORTED_MODULE_0__["decodeAbgr8"])(slice.label.background.color),
                    verticalPadding: slice.label.background.vPadding,
                    horizontalPadding: slice.label.background.hPadding
                } :
                undefined });
    }
    return undefined;
}


/***/ }),
/* 69 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return extractPointLabel; });
/* harmony import */ var _proto_aliases__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(14);
/* harmony import */ var _tile_world_coordinates_converter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(40);
/* harmony import */ var _math_vector2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(43);
/* harmony import */ var _extract_styles__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(45);
/* harmony import */ var _extract_labels__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(68);





const ALIGNMENT = {
    [_proto_aliases__WEBPACK_IMPORTED_MODULE_0__["Tile"].StraightLabels.AlignType.Left]: 0 /* LEFT */,
    [_proto_aliases__WEBPACK_IMPORTED_MODULE_0__["Tile"].StraightLabels.AlignType.Right]: 2 /* RIGHT */,
    [_proto_aliases__WEBPACK_IMPORTED_MODULE_0__["Tile"].StraightLabels.AlignType.Center]: 1 /* CENTER */
};
/**
 * Utility method for getting texts (text and altText) from API tile response. These texts are both optional and
 * returned iterable may contains from 0 to 2 texts.
 *
 * @param pointLabels API tile response.
 * @param index Label position in pointLabel's text/textAlt arrays.
 */
function* extractTexts(pointLabels, index) {
    if (pointLabels.text[index]) {
        yield {
            textLines: pointLabels.text[index].strings.map((str) => ({ glyphIds: str.glyphs }))
        };
    }
    if (pointLabels.textAlt[index] && pointLabels.textAlt[index].strings.length > 0) {
        yield {
            textLines: pointLabels.textAlt[index].strings.map((str) => ({ glyphIds: str.glyphs }))
        };
    }
}
/**
 * Overridden style converter, takes care of vertical distance extraction.
 */
function convertZoomSliceToStraightLabelStyle(slice, styleBase) {
    const style = Object(_extract_labels__WEBPACK_IMPORTED_MODULE_4__["convertZoomSliceToLabelStyle"])(slice, styleBase);
    if (style && slice.label) {
        style.distance = slice.label.vdistance;
    }
    return style;
}
/**
 * Utility method for getting point labels from API tile response.
 */
function* extractPointLabel(tile, decodedApiTile, tileMinZoom, tileMaxZoom) {
    const pointLabels = decodedApiTile.pointLabels;
    if (pointLabels) {
        const converter = new _tile_world_coordinates_converter__WEBPACK_IMPORTED_MODULE_1__["default"](tile);
        for (let i = 0; i < pointLabels.text.length; i++) {
            const classId = pointLabels.classId[i];
            const styles = [...Object(_extract_styles__WEBPACK_IMPORTED_MODULE_3__["default"])(decodedApiTile.presentation, classId, convertZoomSliceToStraightLabelStyle, tileMinZoom, tileMaxZoom)];
            for (const style of styles) {
                style.align = ALIGNMENT[pointLabels.align[i]];
            }
            yield {
                anchorPoint: converter.toWorldCoordinates(pointLabels.centerX[i], pointLabels.centerY[i]),
                offset: _math_vector2__WEBPACK_IMPORTED_MODULE_2__["create"](pointLabels.offsetX[i], pointLabels.offsetY[i]),
                priority: pointLabels.priority[i],
                texts: [...extractTexts(pointLabels, i)],
                styles: styles
            };
        }
    }
}


/***/ }),
/* 70 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return layoutPointLabel; });
/* harmony import */ var _math_vector2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(43);

/**
 * @returns Full width of all line glyphs using glyph's advance metric (it doesn't take into account the font size).
 */
function calculateLineWidth(font, line) {
    return line.glyphIds.reduce((width, glyphId) => {
        return width + font.getGlyph(glyphId).advance;
    }, 0);
}
/**
 * @returns Real max height of the line looking through all the glyphs and their bearingY and height metrics.
 */
function calculateLineHeight(font, line) {
    let maxHeightAboveBaseline = 0;
    let maxHeightBelowBaseline = 0;
    for (const glyphId of line.glyphIds) {
        const glyph = font.getGlyph(glyphId);
        maxHeightAboveBaseline = Math.max(maxHeightAboveBaseline, glyph.bearingY);
        maxHeightBelowBaseline = Math.max(maxHeightBelowBaseline, glyph.height - glyph.bearingY);
    }
    return maxHeightAboveBaseline + maxHeightBelowBaseline;
}
/**
 * Layout one straight line in absolute (to the whole label) coordinates using the origin point as an offset vector.
 */
function* layoutLine(textLine, xOrigin, yOrigin, font, scale) {
    const glyphIds = textLine.glyphIds;
    const length = glyphIds.length;
    for (let i = 0; i < length; i++) {
        const glyph = font.getGlyph(glyphIds[i]);
        const left = xOrigin + (glyph.bearingX - font.margin) * scale;
        const right = xOrigin + (glyph.bearingX + glyph.width + font.margin) * scale;
        const top = yOrigin + (glyph.bearingY + font.margin) * scale;
        const bottom = yOrigin + (glyph.bearingY - glyph.height - font.margin) * scale;
        const topLeft = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["create"](left, top);
        const topRight = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["create"](right, top);
        const bottomRight = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["create"](right, bottom);
        const bottomLeft = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["create"](left, bottom);
        yield {
            fontId: font.id,
            glyphId: glyph.id,
            scale,
            topLeft,
            topRight,
            bottomRight,
            bottomLeft
        };
        xOrigin += glyph.advance * scale;
    }
}
/**
 * How bigger the line height to the font size.
 */
const LINE_HEIGHT_FACTOR = 1.5;
/**
 * Additional space between the lines.
 */
const FONT_LEADING = 3;
/**
 * Creates layout of glyphs in abstract points, that are roughly correspond to CSS pixels and should be rendered
 * accordingly. Text's textLines all start from new lines, a text is just a set of lines with common styles.
 * The origin (0, 0) depending on the alignment is located at:
 *  * the first line's baseline leftmost point for LEFT
 *  * the first line's baseline center point for CENTER
 *  * the first line's baseline rightmost point for RIGHT
 */
function layoutPointLabel(label, labelStyle, fontRegistry) {
    const layout = [];
    const textLineDetails = label.texts.map((text, i) => {
        const textStyle = labelStyle.styles[i];
        const font = fontRegistry.get(textStyle.fontId);
        const scale = textStyle.fontSize / font.xheight;
        const height = textStyle.fontSize * LINE_HEIGHT_FACTOR;
        return text.textLines.map((line) => {
            const width = calculateLineWidth(font, line) * scale;
            const maxHeight = calculateLineHeight(font, line) * scale;
            return { line, font, scale, width, height, maxHeight };
        });
    });
    const bboxSize = textLineDetails.reduce((bboxSize, lineSizes) => {
        return lineSizes.reduce((bboxSize, lineSize) => {
            bboxSize.width = Math.max(bboxSize.width, lineSize.width);
            bboxSize.height += lineSize.maxHeight;
            return bboxSize;
        }, bboxSize);
    }, {
        width: 0,
        height: labelStyle.distance * (textLineDetails.length - 1)
    });
    const xOrigin = label.offset.x - bboxSize.width / 2;
    let yOrigin = label.offset.y + bboxSize.height / 2;
    let isFirstTextLine = true;
    for (const textLines of textLineDetails) {
        const textLayout = [];
        for (const line of textLines) {
            const lineYOrigin = (yOrigin -= line.height + (isFirstTextLine ? 0 : FONT_LEADING));
            const lineXOrigin = xOrigin + ((labelStyle.align === 0 /* LEFT */) ? 0 :
                (labelStyle.align === 1 /* CENTER */) ? (bboxSize.width - line.width) / 2 :
                    (labelStyle.align === 2 /* RIGHT */) ? (bboxSize.width - line.width) : 0);
            isFirstTextLine = false;
            for (const glyphLayout of layoutLine(line.line, lineXOrigin, lineYOrigin, line.font, line.scale)) {
                textLayout.push(glyphLayout);
            }
        }
        yOrigin -= labelStyle.distance;
        layout.push(textLayout);
    }
    return layout;
}


/***/ }),
/* 71 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BillboardRectangleBufferWriter; });
/* harmony import */ var _util_buffer_writer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(49);
/* harmony import */ var _math_vector2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(43);
/* harmony import */ var _util_color__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(38);
/* harmony import */ var _attribute_mapping__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(72);
/* harmony import */ var _util_gputypes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(50);





const BOTTOM_LEFT_UV_INT16 = _math_vector2__WEBPACK_IMPORTED_MODULE_1__["create"](-0x8000, -0x8000);
const TOP_LEFT_UV_INT16 = _math_vector2__WEBPACK_IMPORTED_MODULE_1__["create"](-0x8000, 0x7fff);
const BOTTOM_RIGHT_UV_INT16 = _math_vector2__WEBPACK_IMPORTED_MODULE_1__["create"](0x7fff, -0x8000);
const TOP_RIGHT_UV_INT16 = _math_vector2__WEBPACK_IMPORTED_MODULE_1__["create"](0x7fff, 0x7fff);
/**
 * Writer of geometry data of rectangles.
 */
class BillboardRectangleBufferWriter extends _util_buffer_writer__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super(_attribute_mapping__WEBPACK_IMPORTED_MODULE_3__["BILLBOARD_RECTANGLE_ATTRIBUTE_MAPPING"].vertexByteSize);
    }
    /**
     * Writes a rectangle to buffers.
     *
     * @returns Location of the image data in buffers.
     */
    writeRectangle(id, rectangle, style) {
        const idHigh = id >> 8;
        const idLow = id & 0xff;
        const { borderRadius, offset, width, height } = style;
        const halfWidth = width / 2;
        const halfHeight = height / 2;
        const colorRgba8 = Object(_util_color__WEBPACK_IMPORTED_MODULE_2__["encodeRgba8"])(style.color);
        const borderRadiusX = borderRadius / halfWidth;
        const borderRadiusY = borderRadius / halfHeight;
        this._writeVertex(idHigh, idLow, rectangle.position, -halfWidth, -halfHeight, offset, BOTTOM_LEFT_UV_INT16, colorRgba8, borderRadiusX, borderRadiusY);
        this._writeVertex(idHigh, idLow, rectangle.position, -halfWidth, halfHeight, offset, TOP_LEFT_UV_INT16, colorRgba8, borderRadiusX, borderRadiusY);
        this._writeVertex(idHigh, idLow, rectangle.position, halfWidth, -halfHeight, offset, BOTTOM_RIGHT_UV_INT16, colorRgba8, borderRadiusX, borderRadiusY);
        this._writeVertex(idHigh, idLow, rectangle.position, halfWidth, halfHeight, offset, TOP_RIGHT_UV_INT16, colorRgba8, borderRadiusX, borderRadiusY);
        this.writeIndicesForContinuousStrip(4);
        return this.endMesh();
    }
    /**
     * Writes a vertex to the vertex buffer.
     *
     * @param idHigh Most significant 8 bits of rectangle id.
     * @param idLow Least significant 8 bits of rectangle id.
     * @param position World coordinate of rectangle.
     * @param displacementX X coordinate displacement in pixels of concrete vertex.
     * @param displacementY Y coordinate displacement in pixels of concrete vertex.
     * @param offset Additional displacement for all vertices specified in style.
     * @param uv UV coordinated of the vertex of the rectangle.
     * @param color Background color encoded into RGBA8
     * @param borderRadiusX Radius of corner rounding along X axis (i.e., horizontal
     *      axis of rounding ellipse).
     * @param borderRadiusY Radius of corner rounding along Y axis (i.e., vertical
     *      axis of rounding ellipse).
     * @returns Index of the written vertex.
     */
    _writeVertex(idHigh, idLow, position, displacementX, displacementY, offset, uv, colorRgba8, borderRadiusX, borderRadiusY) {
        const vertexIdx = this.getCurrentVertexIdx();
        this._writeBytes(idHigh, idLow, 0, 0);
        this._writeWorldCoordinate(position);
        this._writeFloat32(displacementX + offset.x);
        this._writeFloat32(displacementY + offset.y);
        this._writeHalfWords(uv.x, uv.y);
        this._writeWord(colorRgba8);
        this._writeHalfWords(Object(_util_gputypes__WEBPACK_IMPORTED_MODULE_4__["floatToUint16"])(borderRadiusX), Object(_util_gputypes__WEBPACK_IMPORTED_MODULE_4__["floatToUint16"])(borderRadiusY));
        return vertexIdx;
    }
}


/***/ }),
/* 72 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BILLBOARD_RECTANGLE_ATTRIBUTE_MAPPING", function() { return BILLBOARD_RECTANGLE_ATTRIBUTE_MAPPING; });
/* harmony import */ var _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(56);

/** Description of how a writer stores vertex data. */
const BILLBOARD_RECTANGLE_ATTRIBUTE_MAPPING = new _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__["AttributeMapping"]([
    [
        2 /* ID */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        0 /* POSITION_HIGH */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        1 /* POSITION_LOW */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        6 /* DISPLACEMENT */,
        {
            size: 2,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        4 /* UV */,
        {
            size: 2,
            type: 5122 /* SHORT */,
            normalized: true
        }
    ],
    [
        7 /* COLOR */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        11 /* AUX */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ]
]);


/***/ }),
/* 73 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PointLabelBufferWriter; });
/* harmony import */ var _util_buffer_writer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(49);
/* harmony import */ var _util_iterable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(57);
/* harmony import */ var _util_color__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(38);
/* harmony import */ var _util_z_index__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(59);
/* harmony import */ var _point_label_attribute_mapping__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(74);





/**
 * Writer of geometry data of point labels.
 */
class PointLabelBufferWriter extends _util_buffer_writer__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super(_point_label_attribute_mapping__WEBPACK_IMPORTED_MODULE_4__["POINT_LABEL_ATTRIBUTE_MAPPING"].vertexByteSize);
    }
    /**
     * Writes point label to buffers.
     *
     * @param id Label id.
     * @param label Label to be written to buffers.
     * @param style Style of the label, that directly affects written data.
     * @param fontRegistry Registry of all system fonts, it should contain fonts used in this label styles.
     * @param glyphAtlas Atlas of all system glyphs, it should contain glyphs used in this label.
     *
     * @returns Location of the data in buffers.
     */
    writePointLabel(id, label, style, layout, glyphAtlas) {
        const idHigh = id >> 8;
        const idLow = id & 0xff;
        const position = label.anchorPoint;
        const priority = Object(_util_z_index__WEBPACK_IMPORTED_MODULE_3__["intToZIndex"])(label.priority);
        for (const [textLayout, textStyle] of Object(_util_iterable__WEBPACK_IMPORTED_MODULE_1__["zipIterables"])(layout, style.styles)) {
            const textColorRgba8 = Object(_util_color__WEBPACK_IMPORTED_MODULE_2__["encodeRgba8"])(textStyle.color);
            const outlineColorRgba8 = Object(_util_color__WEBPACK_IMPORTED_MODULE_2__["encodeRgba8"])(textStyle.outlineColor);
            for (const glyph of textLayout) {
                const allocatedGlyph = glyphAtlas.getGlyphLocation(glyph.fontId, glyph.glyphId);
                const v1 = this._writeVertex(idHigh, idLow, position, glyph.topLeft, {
                    x: allocatedGlyph.minX,
                    y: allocatedGlyph.minY
                }, textColorRgba8, outlineColorRgba8, priority, glyph.scale);
                const v2 = this._writeVertex(idHigh, idLow, position, glyph.topRight, {
                    x: allocatedGlyph.maxX,
                    y: allocatedGlyph.minY
                }, textColorRgba8, outlineColorRgba8, priority, glyph.scale);
                const v3 = this._writeVertex(idHigh, idLow, position, glyph.bottomRight, {
                    x: allocatedGlyph.maxX,
                    y: allocatedGlyph.maxY
                }, textColorRgba8, outlineColorRgba8, priority, glyph.scale);
                const v4 = this._writeVertex(idHigh, idLow, position, glyph.bottomLeft, {
                    x: allocatedGlyph.minX,
                    y: allocatedGlyph.maxY
                }, textColorRgba8, outlineColorRgba8, priority, glyph.scale);
                this.writeIndices([v1, v2, v3, v1, v3, v4]);
            }
        }
        return this.endMesh();
    }
    /**
     * Writes a vertex to the vertex buffer. See attribute descriptions in the ATTRIBUTE_MAPPING property.
     */
    _writeVertex(idHigh, idLow, position, displacement, uv, colorRgba8, outlineColorRgba8, priority, scale) {
        const vertexIdx = this.getCurrentVertexIdx();
        this._writeBytes(idHigh, idLow, 0, 0);
        this._writeWorldCoordinate(position);
        this._writeFloat32(displacement.x);
        this._writeFloat32(displacement.y);
        this._writeHalfWords(uv.x, uv.y);
        this._writeWord(colorRgba8);
        this._writeWord(outlineColorRgba8);
        this._writeFloat32(priority);
        this._writeFloat32(scale);
        return vertexIdx;
    }
}


/***/ }),
/* 74 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "POINT_LABEL_ATTRIBUTE_MAPPING", function() { return POINT_LABEL_ATTRIBUTE_MAPPING; });
/* harmony import */ var _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(56);

/** Description of how a writer stores vertex data. */
const POINT_LABEL_ATTRIBUTE_MAPPING = new _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__["AttributeMapping"]([
    [
        2 /* ID */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        0 /* POSITION_HIGH */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        1 /* POSITION_LOW */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        6 /* DISPLACEMENT */,
        {
            size: 2,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        4 /* UV */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: false
        }
    ],
    [
        7 /* COLOR */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        8 /* OUTLINE_COLOR */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        9 /* PRIORITY */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        11 /* AUX */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ]
]);


/***/ }),
/* 75 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CurvedLabelBufferWriter; });
/* harmony import */ var _math_vector2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(43);
/* harmony import */ var _util_buffer_writer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49);
/* harmony import */ var _util_gputypes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(50);
/* harmony import */ var _util_z_index__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(59);
/* harmony import */ var _util_iterable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(57);
/* harmony import */ var _util_color__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(38);
/* harmony import */ var _layout_curved_label__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(76);
/* harmony import */ var _util_polyline__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(47);
/* harmony import */ var _curved_label_attribute_mapping__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(77);
/* harmony import */ var _id_manager__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(78);










const POLYLINE_SIDE_LENGTH = 4;
/**
 * Writer of geometry data of curved labels.
 */
class CurvedLabelBufferWriter extends _util_buffer_writer__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor() {
        super(_curved_label_attribute_mapping__WEBPACK_IMPORTED_MODULE_8__["CURVED_LABEL_ATTRIBUTE_MAPPING"].vertexByteSize);
    }
    /**
     * Writes curved label to buffers.
     *
     * @param label Label to be written to buffers.
     * @param style Style of the label, that directly affects written data.
     * @param fontRegistry Registry of all system fonts, it should contain fonts used in this label styles.
     * @param glyphAtlas Atlas of all system glyphs, it should contain glyphs used in this label.
     *
     * @returns Location of the data in buffers.
     */
    writeLabel(label, style, fontRegistry, glyphAtlas) {
        const id = Object(_id_manager__WEBPACK_IMPORTED_MODULE_9__["getId"])();
        const idHigh = id >> 8;
        const idLow = id & 0xff;
        const textLayouts = Object(_layout_curved_label__WEBPACK_IMPORTED_MODULE_6__["default"])(label, style, fontRegistry);
        const priority = Object(_util_z_index__WEBPACK_IMPORTED_MODULE_3__["intToZIndex"])(label.priority);
        // To make layouting on GPU possible guiding polyline should be splitted on left/right parts,
        // mid point of the polyline is used to anchor the label. This information is not changed at runtime and
        // simplifies calculations in shaders.
        const polyline = Object(_util_polyline__WEBPACK_IMPORTED_MODULE_7__["splitPolyline"])(label.polyline);
        const midPoint = polyline[1][0];
        polyline[0].reverse(); // left part must be reversed to write both parts alike
        for (const polylinePart of polyline) {
            for (let i = 1; i < polylinePart.length; i++) {
                // write polyline vertex as delta to the mid point to get reasonable precision from float
                _math_vector2__WEBPACK_IMPORTED_MODULE_0__["sub"](polylinePart[i], midPoint, polylinePart[i]);
            }
        }
        for (const [textLayout, textStyle] of Object(_util_iterable__WEBPACK_IMPORTED_MODULE_4__["zipIterables"])(textLayouts, style.styles)) {
            const textColorRgba8 = Object(_util_color__WEBPACK_IMPORTED_MODULE_5__["encodeRgba8"])(textStyle.color);
            const outlineColorRgba8 = Object(_util_color__WEBPACK_IMPORTED_MODULE_5__["encodeRgba8"])(textStyle.outlineColor);
            for (const glyph of textLayout) {
                const allocatedGlyph = glyphAtlas.getGlyphLocation(glyph.fontId, glyph.glyphId);
                const v1 = this._writeVertex(idHigh, idLow, midPoint, glyph.topLeft, {
                    x: allocatedGlyph.minX,
                    y: allocatedGlyph.minY
                }, textColorRgba8, outlineColorRgba8, priority, glyph.lineDisplacement, polyline, glyph.scale);
                const v2 = this._writeVertex(idHigh, idLow, midPoint, glyph.topRight, {
                    x: allocatedGlyph.maxX,
                    y: allocatedGlyph.minY
                }, textColorRgba8, outlineColorRgba8, priority, glyph.lineDisplacement, polyline, glyph.scale);
                const v3 = this._writeVertex(idHigh, idLow, midPoint, glyph.bottomRight, {
                    x: allocatedGlyph.maxX,
                    y: allocatedGlyph.maxY
                }, textColorRgba8, outlineColorRgba8, priority, glyph.lineDisplacement, polyline, glyph.scale);
                const v4 = this._writeVertex(idHigh, idLow, midPoint, glyph.bottomLeft, {
                    x: allocatedGlyph.minX,
                    y: allocatedGlyph.maxY
                }, textColorRgba8, outlineColorRgba8, priority, glyph.lineDisplacement, polyline, glyph.scale);
                this.writeIndices([v1, v2, v3, v1, v3, v4]);
            }
        }
        return this.endMesh();
    }
    /**
     * Writes a vertex to the vertex buffer. See attribute descriptions in the ATTRIBUTE_MAPPING property.
     */
    _writeVertex(idHigh, idLow, position, displacement, uv, colorRgba8, outlineColorRgba8, priority, lineDisplacement, polyline, scale) {
        const vertexIdx = this.getCurrentVertexIdx();
        this._writeBytes(idHigh, idLow, 0, 0);
        this._writeWorldCoordinate(position);
        this._writeFloat32(displacement.x);
        this._writeFloat32(displacement.y);
        this._writeFloat32(lineDisplacement);
        this._writeHalfWords(uv.x, uv.y);
        this._writeWord(colorRgba8);
        this._writeWord(outlineColorRgba8);
        this._writeFloat32(priority);
        const polylineLength = this._computePolylineLength(polyline);
        for (const polylinePart of polyline) {
            this._writePolylinePart(polylinePart, polylineLength);
        }
        this._writeFloat32(polylineLength);
        this._writeFloat32(scale);
        return vertexIdx;
    }
    /**
     * Writes polyline's left or right part to buffers. Polyline part consists of segments (two consecutive points in
     * the polylinePart array).
     *
     * @param polylinePart Polyline part to be written.
     * @param polylineLength Total length of the polyline.
     */
    _writePolylinePart(polylinePart, polylineLength) {
        const points = [];
        for (let i = 1; i <= POLYLINE_SIDE_LENGTH; i++) {
            points.push(this._encodePoint(polylinePart[i], polylineLength));
        }
        // Ratios and angles of the points are encoded in different sizes so each point of the polyline is stored in two
        // attribute's corresponding components.
        for (let i = 0; i < POLYLINE_SIDE_LENGTH; i += 4) {
            this._writeBytes(Object(_util_gputypes__WEBPACK_IMPORTED_MODULE_2__["floatToUint8"])(points[i].ratio), Object(_util_gputypes__WEBPACK_IMPORTED_MODULE_2__["floatToUint8"])(points[i + 1].ratio), Object(_util_gputypes__WEBPACK_IMPORTED_MODULE_2__["floatToUint8"])(points[i + 2].ratio), Object(_util_gputypes__WEBPACK_IMPORTED_MODULE_2__["floatToUint8"])(points[i + 3].ratio));
        }
        for (let i = 0; i < POLYLINE_SIDE_LENGTH; i += 2) {
            this._writeHalfWords(Object(_util_gputypes__WEBPACK_IMPORTED_MODULE_2__["floatToUint16"])(points[i].angle), Object(_util_gputypes__WEBPACK_IMPORTED_MODULE_2__["floatToUint16"])(points[i + 1].angle));
        }
    }
    /**
     * Encodes a point of the polyline's segment as a vector (from the polyline center) by its normalized angle and the
     * ratio of its length to the polyline's length.
     *
     * @param point Point to be encoded.
     * @param polylineLength Total length of the polyline.
     */
    _encodePoint(point = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["create"](0, 0), polylineLength) {
        const ratio = _math_vector2__WEBPACK_IMPORTED_MODULE_0__["length"](point) / polylineLength;
        const angle = (Math.atan2(point.y, point.x) + Math.PI) / (2 * Math.PI);
        return { ratio, angle };
    }
    /**
     * Computes the total length of the polyine. Polyline will be limited by `POLYLINE_SIDE_LENGTH` segments on each
     * side.
     *
     * @param polyline
     */
    _computePolylineLength(polyline) {
        let polylineLength = 0;
        for (const polylinePart of polyline) {
            for (let i = 1; i <= POLYLINE_SIDE_LENGTH; i++) {
                if (polylinePart[i]) {
                    polylineLength += _math_vector2__WEBPACK_IMPORTED_MODULE_0__["length"](polylinePart[i]);
                }
            }
        }
        return polylineLength;
    }
}


/***/ }),
/* 76 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return layoutCurvedLabel; });
/* harmony import */ var _util_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(51);

/**
 * Label layouting is done partially on CPU and partially on GPU. This helper method is responsible for the CPU part,
 * it calculates glyph's corner positions on a straight line, that will lay on a curved  polyline later in GPU.
 * All the metrics are given in pixels.
 *
 * @returns Position of each glyph for each text separately.
 */
function layoutCurvedLabel(label, labelStyle, fontRegistry) {
    const layout = [];
    let lineDisplacement = 0;
    for (const [text, style] of Object(_util_array__WEBPACK_IMPORTED_MODULE_0__["zip"])(label.texts, labelStyle.styles)) {
        const textLayout = [];
        const font = fontRegistry.get(style.fontId);
        const scale = style.fontSize / font.xheight;
        const baselineOffset = style.fontSize / 2;
        for (const line of text.textLines) {
            for (const glyphId of line.glyphIds) {
                const glyph = font.getGlyph(glyphId);
                const top = (glyph.bearingY + font.margin) * scale;
                const bottom = (glyph.bearingY - glyph.height - font.margin) * scale;
                const left = (glyph.bearingX - font.margin) * scale;
                const right = (glyph.bearingX + glyph.width + font.margin) * scale;
                const widthHalf = (right - left) / 2;
                const leftShifted = left - widthHalf;
                const rightShifted = right - widthHalf;
                const topShifted = top - baselineOffset;
                const bottomShifted = bottom - baselineOffset;
                textLayout.push({
                    fontId: font.id,
                    glyphId: glyphId,
                    scale,
                    topLeft: { x: leftShifted, y: topShifted },
                    topRight: { x: rightShifted, y: topShifted },
                    bottomRight: { x: rightShifted, y: bottomShifted },
                    bottomLeft: { x: leftShifted, y: bottomShifted },
                    lineDisplacement: lineDisplacement + widthHalf
                });
                lineDisplacement += glyph.advance * scale;
            }
        }
        lineDisplacement += labelStyle.distance;
        layout.push(textLayout);
    }
    // remove trailing style distance (added at the end of each text above), as it must be in between texts only
    lineDisplacement -= labelStyle.distance;
    const lineDisplacementHalf = lineDisplacement / 2;
    for (const textLayout of layout) {
        for (const glyphLayout of textLayout) {
            glyphLayout.lineDisplacement -= lineDisplacementHalf;
        }
    }
    return layout;
}


/***/ }),
/* 77 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CURVED_LABEL_ATTRIBUTE_MAPPING", function() { return CURVED_LABEL_ATTRIBUTE_MAPPING; });
/* harmony import */ var _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(56);

/** Description of how a writer stores vertex data. */
const CURVED_LABEL_ATTRIBUTE_MAPPING = new _render_attrib_mapping__WEBPACK_IMPORTED_MODULE_0__["AttributeMapping"]([
    [
        2 /* ID */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        0 /* POSITION_HIGH */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        1 /* POSITION_LOW */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        6 /* DISPLACEMENT */,
        {
            size: 3,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        4 /* UV */,
        {
            size: 2,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: false
        }
    ],
    [
        7 /* COLOR */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        8 /* OUTLINE_COLOR */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        9 /* PRIORITY */,
        {
            size: 1,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ],
    [
        12 /* AUX1 */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        13 /* AUX2 */,
        {
            size: 4,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        14 /* AUX3 */,
        {
            size: 4,
            type: 5121 /* UNSIGNED_BYTE */,
            normalized: true
        }
    ],
    [
        15 /* AUX4 */,
        {
            size: 4,
            type: 5123 /* UNSIGNED_SHORT */,
            normalized: true
        }
    ],
    [
        11 /* AUX */,
        {
            size: 2,
            type: 5126 /* FLOAT */,
            normalized: false
        }
    ]
]);


/***/ }),
/* 78 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getId", function() { return getId; });
// this value is mostly dictated by technical details of how visibility resolution is implemented: it uses
// a 256x256 texture and max number of distinct values that can be stored there is 256*256.
// Of course, we can compress it and use one pixel, say, for two/four ids, or use multiple textures, but it
// naturally complicates the solution, while ~65k ids is seen as "more than enough" (taking into account that
// ids are reused).
const MAX_ID = 0xffff;
let id = 0;
/**
 * Manages assignments of ids for primitives that must be distinguished in global space (e.g. for collision resolution).
 * Note that this class is not "thread safe", to use it in different memory spaces something like "id regions"
 * (similar to ip address assignment problem) is to be implemented.
 *
 *  @returns Pseudo unique id number from [0x0:0xffff] range, it increments previously returned id and starts from 0
 *     when the prev one is the max available, that gives acceptable degree of uniqueness for colliding primitives.
 */
function getId() {
    return id = ++id % MAX_ID;
}


/***/ }),
/* 79 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "calculatePointLabelBBox", function() { return calculatePointLabelBBox; });
/**
 * Calculates bbox of a layouted label, it just find the left/right/top/bottom-most points and adds paddings.
 */
function calculatePointLabelBBox(layout, verticalPadding, horizontalPadding) {
    const bbox = {
        minX: Number.MAX_VALUE,
        maxX: -Number.MAX_VALUE,
        minY: Number.MAX_VALUE,
        maxY: -Number.MAX_VALUE
    };
    for (const textLayout of layout) {
        for (const glyphLayout of textLayout) {
            bbox.minX = Math.min(bbox.minX, glyphLayout.topLeft.x);
            bbox.maxX = Math.max(bbox.maxX, glyphLayout.topRight.x);
            bbox.minY = Math.min(bbox.minY, glyphLayout.bottomLeft.y);
            bbox.maxY = Math.max(bbox.maxY, glyphLayout.topLeft.y);
        }
    }
    bbox.minX -= horizontalPadding;
    bbox.maxX += horizontalPadding;
    bbox.minY -= verticalPadding;
    bbox.maxY += verticalPadding;
    return bbox;
}


/***/ }),
/* 80 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TrimeshPolygonBufferWriter", function() { return TrimeshPolygonBufferWriter; });
/* harmony import */ var _trimesh_parse_trimesh__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(81);
/* harmony import */ var _math_scalar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(42);
/* harmony import */ var _primitive_model_model_buffer_writer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(66);
/* harmony import */ var _util_color__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(38);




/**
 * Buffer writer that writes trimesh object into common mesh buffers.
 */
class TrimeshPolygonBufferWriter extends _primitive_model_model_buffer_writer__WEBPACK_IMPORTED_MODULE_2__["default"] {
    /**
     * Writes a mesh from raw trimesh file data. Uses parseTrimesh() utility function
     * to get vertices and write them in correct order.
     *
     * @param data Raw (unzipped) trimesh file data.
     * @param mesh Description of the mesh in the world space.
     * @returns The location of the mesh in a buffer.
     */
    writeModel(data, mesh, color) {
        this._currentMesh = mesh;
        this._currentColor = Object(_util_color__WEBPACK_IMPORTED_MODULE_3__["encodeRgba8"])(color);
        let prevManifoldLocation;
        for (const manifoldLocation of Object(_trimesh_parse_trimesh__WEBPACK_IMPORTED_MODULE_0__["parseTrimesh"])(data, this)) {
            if (prevManifoldLocation) {
                // manifolds are written consequently, it allows to "accumulate" vertices and return
                // the location of the first one and the sum of the lengths
                if (prevManifoldLocation.bufferIndex === manifoldLocation.bufferIndex) {
                    prevManifoldLocation.vertexByteLength += manifoldLocation.vertexByteLength;
                    prevManifoldLocation.indexByteLength += manifoldLocation.indexByteLength;
                }
                else {
                    // return the first portion, very large (~65k vertices) object will be truncated
                    // TODO: consider support of such objects
                    break;
                }
            }
            else {
                prevManifoldLocation = manifoldLocation;
            }
        }
        return prevManifoldLocation;
    }
    /**
     * Stores converted to world space vertices to refer them later in indices writing.
     */
    writeVertex(vertex) {
        const mesh = this._currentMesh;
        if (mesh) {
            const bbox = mesh.bbox;
            vertex.x = _math_scalar__WEBPACK_IMPORTED_MODULE_1__["mix"](bbox.minX, bbox.maxX, vertex.x);
            vertex.y = _math_scalar__WEBPACK_IMPORTED_MODULE_1__["mix"](bbox.minY, bbox.maxY, vertex.y);
            vertex.z = _math_scalar__WEBPACK_IMPORTED_MODULE_1__["mix"](bbox.maxZ, bbox.minZ, vertex.z);
            return this._writeVertex(vertex, this._currentColor);
        }
        else {
            return -1;
        }
    }
    /**
     * Finishes current manifold and returns its location in a buffer.
     */
    flush() {
        return this.endMesh();
    }
}


/***/ }),
/* 81 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseTrimesh", function() { return parseTrimesh; });
/* harmony import */ var _file_reader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(82);
/* harmony import */ var _parse_manifold__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(86);
/* harmony import */ var _vertex_decoder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(88);



/**
 * Streaming parser of a trimesh file. It writes the model into an abstract output buffer, that have to manage
 * vertices storing. The model can be quite big, that is why it is flushed out by portions (manifolds) that could
 * be placed into separate buffers.
 * The format overview and motivation see here: https://wiki.yandex-team.ru/maps/dev/core/renderer/vec3d/.
 */
function* parseTrimesh(data, output) {
    const reader = new _file_reader__WEBPACK_IMPORTED_MODULE_0__["default"](data);
    const decoder = new _vertex_decoder__WEBPACK_IMPORTED_MODULE_2__["default"](reader.header.precision);
    while (reader.hasCommands()) {
        yield Object(_parse_manifold__WEBPACK_IMPORTED_MODULE_1__["parseManifold"])(reader, decoder, output);
    }
}


/***/ }),
/* 82 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return FileReader; });
/* harmony import */ var _math_vector3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(83);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(85);


const VALENCE_BIAS = {
    [0 /* ADD */]: 3,
    [1 /* HOLE */]: 3,
    [2 /* SPLIT */]: 1,
    [3 /* MERGE */]: 1
};
const HEADER_BYTE_SIZE = 13;
/**
 * Parses raw trimesh file data. See the format described here:
 * https://wiki.yandex-team.ru/maps/dev/core/renderer/vec3d/#strukturafajjla.
 */
class FileReader {
    constructor(data) {
        this._view = new DataView(data);
        this.header = {
            signature: this._view.getUint32(0, true),
            nCmdAdd: this._view.getUint32(4, true),
            nCmdEtc: this._view.getUint16(8, true),
            nAux: this._view.getUint16(10, true),
            precision: this._view.getUint8(12)
        };
        this._auxOffset = HEADER_BYTE_SIZE;
        this._cmdOffset = this._auxOffset + this.header.nAux * 2;
        this._diffOffset = this._cmdOffset + this.header.nCmdAdd + this.header.nCmdEtc;
        this._cmdEnd = this._diffOffset;
    }
    /**
     * @returns The next command and increases the command cursor.
     */
    readCommand(dst = { type: 0 /* ADD */, valence: 0, shift: 0 }) {
        const commandPacked = this._view.getUint8(this._cmdOffset++);
        const type = commandPacked & 0b11;
        let valence = commandPacked >> 2;
        valence = valence !== 0 ? valence - 1 : this._readAux() + 62;
        valence += VALENCE_BIAS[type];
        const shift = type === 2 /* SPLIT */ || type === 3 /* MERGE */ ? this._readAux() : 0;
        dst.type = type;
        dst.valence = valence;
        dst.shift = shift;
        return dst;
    }
    /**
     * @returns The next diff and increases the diff cursor.
     */
    readDiff(dst = _math_vector3__WEBPACK_IMPORTED_MODULE_0__["create"](0, 0, 0)) {
        dst.x = this._readDiff(this._diffOffset + this.header.nCmdAdd * 3, this._diffOffset + this.header.nCmdAdd * 0);
        dst.y = this._readDiff(this._diffOffset + this.header.nCmdAdd * 4, this._diffOffset + this.header.nCmdAdd * 1);
        dst.z = this._readDiff(this._diffOffset + this.header.nCmdAdd * 5, this._diffOffset + this.header.nCmdAdd * 2);
        this._diffOffset++;
        return dst;
    }
    /**
     * @returns Is there command unread.
     */
    hasCommands() {
        return this._cmdOffset < this._cmdEnd;
    }
    _readAux() {
        const low = this._view.getUint8(this._auxOffset);
        const high = this._view.getUint8(this._auxOffset + this.header.nAux);
        const aux = (high << 8) | low;
        this._auxOffset++;
        return aux;
    }
    _readDiff(highPartIndex, lowPartIndex) {
        return Object(_utils__WEBPACK_IMPORTED_MODULE_1__["zigZagUnpack"])(this._view.getUint8(highPartIndex) << 8 |
            this._view.getUint8(lowPartIndex));
    }
}


/***/ }),
/* 83 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ORIGIN", function() { return ORIGIN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "POSITIVE_X", function() { return POSITIVE_X; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NEGATIVE_X", function() { return NEGATIVE_X; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "POSITIVE_Y", function() { return POSITIVE_Y; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NEGATIVE_Y", function() { return NEGATIVE_Y; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "POSITIVE_Z", function() { return POSITIVE_Z; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NEGATIVE_Z", function() { return NEGATIVE_Z; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "areEqual", function() { return areEqual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "areFuzzyEqual", function() { return areFuzzyEqual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "areCollinear", function() { return areCollinear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mulv", function() { return mulv; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "muln", function() { return muln; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divv", function() { return divv; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divn", function() { return divn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cross", function() { return cross; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateX", function() { return rotateX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateY", function() { return rotateY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateZ", function() { return rotateZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "X_AXIS", function() { return X_AXIS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Y_AXIS", function() { return Y_AXIS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Z_AXIS", function() { return Z_AXIS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "XY", function() { return XY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "YZ", function() { return YZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZX", function() { return ZX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPlaneLineIntersection", function() { return getPlaneLineIntersection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPlaneRayIntersection", function() { return getPlaneRayIntersection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPlanePlaneIntersection", function() { return getPlanePlaneIntersection; });
/* harmony import */ var _matrix3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(84);
/* harmony import */ var _util_fuzzy_equal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(44);


/**
 * Creates a new vector and initializes it with given components.
 *
 * @param x X component of the vector.
 * @param y Y component of the vector.
 * @param z Z component of the vector.
 * @returns The vector.
 */
function create(x, y, z) {
    return { x, y, z };
}
const ORIGIN = create(0, 0, 0);
const POSITIVE_X = create(1, 0, 0);
const NEGATIVE_X = create(-1, 0, 0);
const POSITIVE_Y = create(0, 1, 0);
const NEGATIVE_Y = create(0, -1, 0);
const POSITIVE_Z = create(0, 0, 1);
const NEGATIVE_Z = create(0, 0, -1);
/**
 * Copies a vector to another one.
 *
 * @param src The source vector.
 * @param dst The vector the source vector will be copied to.
 * @returns `dst`.
 */
function copy(src, dst = create(0, 0, 0)) {
    dst.x = src.x;
    dst.y = src.y;
    dst.z = src.z;
    return dst;
}
/**
 * Checks if two vectors are strictly equal component-wise.
 *
 * @param v1 The first vector.
 * @param v2 The second vector.
 * @returns `true` if the vectors are equal and `false` otherwise.
 */
function areEqual(v1, v2) {
    return v1.x === v2.x && v1.y === v2.y && v1.z === v2.z;
}
/**
 * Checks if corresponding components of two vectors are all within given
 * tolerance from each other.
 *
 * @param v1 The first vector.
 * @param v2 The second vector.
 * @param tolerance The tolerance.
 * @returns `true` if the vectors are "fuzzy" equal and `false` otherwise.
 */
function areFuzzyEqual(v1, v2, tolerance = _util_fuzzy_equal__WEBPACK_IMPORTED_MODULE_1__["DEFAULT_TOLERANCE"]) {
    return (Object(_util_fuzzy_equal__WEBPACK_IMPORTED_MODULE_1__["default"])(v1.x, v2.x, tolerance) &&
        Object(_util_fuzzy_equal__WEBPACK_IMPORTED_MODULE_1__["default"])(v1.y, v2.y, tolerance) &&
        Object(_util_fuzzy_equal__WEBPACK_IMPORTED_MODULE_1__["default"])(v1.z, v2.z, tolerance));
}
/**
 * Checks if two vectors are collinear.
 *
 * @param v1 The first vector.
 * @param v2 The second vector.
 * @returns `true` if the vectors are collinear and `false` otherwise.
 */
function areCollinear(v1, v2) {
    const lambdaX = v1.x / v2.x;
    const lambdaY = v1.y / v2.y;
    const lambdaZ = v1.z / v2.z;
    return lambdaX === lambdaY && lambdaY === lambdaZ;
}
/**
 * Adds two vector and stores the result into a third one, i.e. `dst = a + b`.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function add(a, b, dst = create(0, 0, 0)) {
    dst.x = a.x + b.x;
    dst.y = a.y + b.y;
    dst.z = a.z + b.z;
    return dst;
}
/**
 * Subtracts a vector from another one and stores the result to a third one, i.e.
 * `dst = a - b`.
 *
 * @param a The minuend vector.
 * @param b The subtrahend vector.
 * @param dst The vector the result will be stored to.
 */
function sub(a, b, dst = create(0, 0, 0)) {
    dst.x = a.x - b.x;
    dst.y = a.y - b.y;
    dst.z = a.z - b.z;
    return dst;
}
/**
 * Multiplies two vectors component-wise and stores the result into a third one.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function mulv(a, b, dst = create(0, 0, 0)) {
    dst.x = a.x * b.x;
    dst.y = a.y * b.y;
    dst.z = a.z * b.z;
    return dst;
}
/**
 * Multiplies a vector by a scalar and stores the result into a third vector.
 *
 * @param a The vector.
 * @param n The scalar.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function muln(a, n, dst = create(0, 0, 0)) {
    dst.x = a.x * n;
    dst.y = a.y * n;
    dst.z = a.z * n;
    return dst;
}
/**
 * Divides a vector by another one component wise and stores the result into a
 * third one.
 *
 * @param a The dividend vector.
 * @param b The divisor vector.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function divv(a, b, dst = create(0, 0, 0)) {
    dst.x = a.x / b.x;
    dst.y = a.y / b.y;
    dst.z = a.z / b.z;
    return dst;
}
/**
 * Divides a vector by a scalar and stores the result into a third vector.
 *
 * @param a The dividend vector.
 * @param n The scalar.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function divn(a, n, dst = create(0, 0, 0)) {
    dst.x = a.x / n;
    dst.y = a.y / n;
    dst.z = a.z / n;
    return dst;
}
/**
 * Computes length of a vector.
 *
 * @param v The vector.
 * @returns The length.
 */
function length(v) {
    return Math.hypot(v.x, v.y, v.z);
}
/**
 * Computes distance between ends of two vectors.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @returns The distance, i.e. `length(sub(a, b))`.
 */
function distance(a, b) {
    return Math.hypot(a.x - b.x, a.y - b.y, a.z - b.z);
}
/**
 * Divides a vector by its length (thus making it a unit vector) and stores the
 * result to another one.
 *
 * @param v The vector to be normalized.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function normalize(v, dst = create(0, 0, 0)) {
    return divn(v, length(v), dst);
}
/**
 * Computes dot product of two vectors.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @returns The dot product.
 */
function dot(a, b) {
    return a.x * b.x + a.y * b.y + a.z * b.z;
}
/**
 * Computes cross product of two vectors and stores it to a third one.
 *
 * @param a The first vector.
 * @param b The second vector.
 * @param dst The vector the result will be stored to.
 * @returns `dst`.
 */
function cross(a, b, dst = create(0, 0, 0)) {
    // Write components to a separate variables so we don't produce incorrect
    // results in cases when a == dst or b == dst.
    const x = a.y * b.z - a.z * b.y;
    const y = a.z * b.x - a.x * b.z;
    const z = a.x * b.y - a.y * b.x;
    dst.x = x;
    dst.y = y;
    dst.z = z;
    return dst;
}
/**
 * Rotates vector about the X axis.
 *
 * @param v The vector to be rotated.
 * @param angle The angle of rotation (in radians), positive values rotates from +Y to +Z
 * @param dst The vector the result will be stored to.
 */
function rotateX(v, angle, dst = create(0, 0, 0)) {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    const y = v.y;
    dst.x = v.x;
    dst.y = y * cos - v.z * sin;
    dst.z = y * sin + v.z * cos;
    return dst;
}
/**
 * Rotates vector about the Y axis.
 *
 * @param v The vector to be rotated.
 * @param angle The angle of rotation (in radians), positive values rotates from +X to +Z
 * @param dst The vector the result will be stored to.
 */
function rotateY(v, angle, dst = create(0, 0, 0)) {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    // handle the case when source and destination are the same object: related components can break each other
    v = (v === dst) ? copy(v) : v;
    dst.x = v.x * cos + v.z * sin;
    dst.y = v.y;
    dst.z = -v.x * sin + v.z * cos;
    return dst;
}
/**
 * Rotates vector about the Z axis.
 *
 * @param v The vector to be rotated.
 * @param angle The angle of rotation (in radians), positive values rotates from +X to +Y
 * @param dst The vector the result will be stored to.
 */
function rotateZ(v, angle, dst = create(0, 0, 0)) {
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    // handle the case when source and destination are the same object: related components can break each other
    v = (v === dst) ? copy(v) : v;
    dst.x = v.x * cos - v.y * sin;
    dst.y = v.x * sin + v.y * cos;
    dst.z = v.z;
    return dst;
}
const X_AXIS = {
    origin: ORIGIN,
    tangent: POSITIVE_X
};
const Y_AXIS = {
    origin: ORIGIN,
    tangent: POSITIVE_Y
};
const Z_AXIS = {
    origin: ORIGIN,
    tangent: POSITIVE_Z
};
const XY = {
    normal: POSITIVE_Z,
    distance: 0
};
const YZ = {
    normal: POSITIVE_X,
    distance: 0
};
const ZX = {
    normal: POSITIVE_Y,
    distance: 0
};
/**
 * Computes intersection of a plane and a line.
 *
 * @param p The plane.
 * @param l The line.
 * @returns The point or `null` if the line is parallel to the plane.
 */
function getPlaneLineIntersection(p, l) {
    const dotLP = dot(l.tangent, p.normal);
    // If plane normal and line tangent vector are perpendicular intersection is
    // either an empty set or the line itself.
    if (dotLP === 0) {
        return null;
    }
    const intersection = copy(l.tangent);
    muln(intersection, (p.distance - dot(p.normal, l.origin)) / dotLP, intersection);
    add(intersection, l.origin, intersection);
    return intersection;
}
/**
 * Computes an intersection of a plane and a ray and stores it into a given
 * vector.
 *
 * @param plane The plane.
 * @param ray The ray.
 * @param dst The vector the intersection point will be stored to. If there's no
 *      intersection, this vector will be left unmodified.
 * @returns The `dst` or `null` if the ray doesn't have a common point with the
 *      plane.
 */
function getPlaneRayIntersection(plane, ray, dst = create(0, 0, 0)) {
    const dotRP = dot(ray.direction, plane.normal);
    if (dotRP === 0) {
        // The plane normal and the ray direction vector are perpendicular, so
        // intersection is either an empty set or the ray itself.
        return null;
    }
    const lambda = (plane.distance - dot(plane.normal, ray.origin)) / dotRP;
    if (lambda < 0) {
        // The intersection point is on a line that contains the ray, but not on
        // the ray itself.
        return null;
    }
    copy(ray.direction, dst);
    muln(dst, lambda, dst);
    add(dst, ray.origin, dst);
    return dst;
}
/**
 * Computes intersection of two planes.
 *
 * @param p1 The first plane.
 * @param p2 The second plane.
 * @returns The line or `null` if the planes are parallel to each other.
 */
function getPlanePlaneIntersection(p1, p2) {
    const n1 = p1.normal;
    const n2 = p2.normal;
    if (areCollinear(n1, n2)) {
        return null;
    }
    const tangent = cross(n1, n2);
    normalize(tangent);
    return {
        tangent,
        origin: _matrix3__WEBPACK_IMPORTED_MODULE_0__["solve"](_matrix3__WEBPACK_IMPORTED_MODULE_0__["fromRows"](n1, n2, tangent), create(p1.distance, p2.distance, 0))
    };
}


/***/ }),
/* 84 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zero", function() { return zero; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRows", function() { return fromRows; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "columns", function() { return columns; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromColumns", function() { return fromColumns; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "determinant", function() { return determinant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "solve", function() { return solve; });
/* harmony import */ var _vector3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(83);

const MATRIX_SIZE = 9;
/**
 * Creates and returns a new **uninitialized** matrix.
 */
function create() {
    return new Array(MATRIX_SIZE);
}
/**
 * Zeroes a matrix.
 *
 * @param dst The matrix.
 * @returns `dst`.
 */
function zero(dst = create()) {
    for (let i = 0; i < MATRIX_SIZE; ++i) {
        dst[i] = 0;
    }
    return dst;
}
/**
 * Copies three vectors to a matrix as rows.
 *
 * @param r0 The first row.
 * @param r1 The second row.
 * @param r2 The third row.
 * @param dst The matrix the rows will be written to.
 * @returns `dst`.
 */
function fromRows(r0, r1, r2, dst = create()) {
    dst[0] = r0.x;
    dst[1] = r1.x;
    dst[2] = r2.x;
    dst[3] = r0.y;
    dst[4] = r1.y;
    dst[5] = r2.y;
    dst[6] = r0.z;
    dst[7] = r1.z;
    dst[8] = r2.z;
    return dst;
}
/**
 * Returns array of columns of a matrix.
 *
 * @param m The matrix.
 * @param dst The array columns of the matrix will be written to.
 * @returns `dst`.
 */
function columns(m, dst = [
    _vector3__WEBPACK_IMPORTED_MODULE_0__["create"](0, 0, 0),
    _vector3__WEBPACK_IMPORTED_MODULE_0__["create"](0, 0, 0),
    _vector3__WEBPACK_IMPORTED_MODULE_0__["create"](0, 0, 0)
]) {
    for (let i = 0, j = 0; i < 3; ++i, j += 3) {
        dst[i].x = m[j];
        dst[i].y = m[j + 1];
        dst[i].z = m[j + 2];
    }
    return dst;
}
/**
 * Copies three vectors to a matrix as columns.
 *
 * @param c0 The first column.
 * @param c1 The second column.
 * @param c2 The third column.
 * @param dst The matrix the columns will be written to.
 * @returns `dst`.
 */
function fromColumns(c0, c1, c2, dst = create()) {
    dst[0] = c0.x;
    dst[1] = c0.y;
    dst[2] = c0.z;
    dst[3] = c1.x;
    dst[4] = c1.y;
    dst[5] = c1.z;
    dst[6] = c2.x;
    dst[7] = c2.y;
    dst[8] = c2.z;
    return dst;
}
/**
 * Computes determinant of a matrix.
 *
 * @param m The matrix.
 * @returns The determinant.
 */
function determinant(m) {
    return m[0] * (m[4] * m[8] - m[7] * m[5]) +
        m[3] * (m[1] * m[8] - m[7] * m[2]) +
        m[6] * (m[1] * m[5] - m[4] * m[2]);
}
const staticMatrixColumns = [
    // Not using vector3.create here due to circular dependency.
    { x: 0, y: 0, z: 0 },
    { x: 0, y: 0, z: 0 },
    { x: 0, y: 0, z: 0 }
];
const staticMatrix = create();
/**
 * Solves a system of linear equations represented with a matrix and a vector,
 * i.e.:
 *
 * ```
 * m * (x, y ,z)^T = v
 * ```
 *
 * Uses Cramer's rule.
 * @see https://en.wikipedia.org/wiki/Cramer's_rule
 *
 * @param m The matrix of the system.
 * @param v The vector of the system.
 * @param dst The vector solution of the system will be written to.
 * @return `dst`.
 */
function solve(m, v, dst = _vector3__WEBPACK_IMPORTED_MODULE_0__["create"](0, 0, 0)) {
    const revDet = 1 / determinant(m);
    const [c0, c1, c2] = columns(m, staticMatrixColumns);
    dst.x = revDet * determinant(fromColumns(v, c1, c2, staticMatrix));
    dst.y = revDet * determinant(fromColumns(c0, v, c2, staticMatrix));
    dst.z = revDet * determinant(fromColumns(c0, c1, v, staticMatrix));
    return dst;
}


/***/ }),
/* 85 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cyclicNextIndex", function() { return cyclicNextIndex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cyclicPrevIndex", function() { return cyclicPrevIndex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cyclicNext", function() { return cyclicNext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cyclicPrev", function() { return cyclicPrev; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zigZagUnpack", function() { return zigZagUnpack; });
/**
 * @returns The next index of specified array or "0" if the index points to te last element.
 */
function cyclicNextIndex(list, index) {
    return (index + 1) % list.length;
}
/**
 * @returns The prev index of specified array or "list.length-1" if the index points to te first element.
 */
function cyclicPrevIndex(list, index) {
    return (index || list.length) - 1;
}
/**
 * @returns The next to specified by index element or the first element if the index points to te last.
 */
function cyclicNext(list, index) {
    return list[cyclicNextIndex(list, index)];
}
/**
 * @returns The prev to specified by index element or the last element if the index points to te first.
 */
function cyclicPrev(list, index) {
    return list[cyclicPrevIndex(list, index)];
}
/**
 * The same idea as described here https://en.wikipedia.org/wiki/Variable-length_quantity#Zigzag_encoding/.
 *
 * @returns Decoded number.
 */
function zigZagUnpack(v) {
    return (v >> 1) ^ (-(v & 1));
}


/***/ }),
/* 86 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseManifold", function() { return parseManifold; });
/* harmony import */ var _math_vector3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(83);
/* harmony import */ var _util_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(51);
/* harmony import */ var _node__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(87);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(85);




const tmpDiff = _math_vector3__WEBPACK_IMPORTED_MODULE_0__["create"](0, 0, 0);
const tmpVertex = _math_vector3__WEBPACK_IMPORTED_MODULE_0__["create"](0, 0, 0);
const tmpCommand = { type: 0 /* ADD */, valence: 0, shift: 0 };
/**
 * Writes vertices of three node into the output buffer if the is no a hole node between them.
 */
function writeTriangle(node1, node2, node3, output) {
    if (!_node__WEBPACK_IMPORTED_MODULE_2__["HoleNode"].isHoleNode(node1) &&
        !_node__WEBPACK_IMPORTED_MODULE_2__["HoleNode"].isHoleNode(node2) &&
        !_node__WEBPACK_IMPORTED_MODULE_2__["HoleNode"].isHoleNode(node3)) {
        output.writeIndices([node1.index, node2.index, node3.index]);
    }
}
/**
 * Each manifold restoring starts with a triangle. This function read the first three vertices, forms a triangle
 * of them and return this initialized node ring to be processed further.
 */
function getInitTriangle(reader, decoder, output) {
    const vertex = _math_vector3__WEBPACK_IMPORTED_MODULE_0__["create"](0, 0, 0);
    const ring = new Array(3);
    for (let i = 0; i < 3; i++) {
        const command = reader.readCommand();
        if (command.type === 1 /* HOLE */) {
            ring[i] = new _node__WEBPACK_IMPORTED_MODULE_2__["HoleNode"](command.valence);
        }
        else if (command.type === 0 /* ADD */) {
            reader.readDiff(tmpDiff);
            _math_vector3__WEBPACK_IMPORTED_MODULE_0__["add"](vertex, tmpDiff, vertex);
            ring[i] = new _node__WEBPACK_IMPORTED_MODULE_2__["default"](command.valence, _math_vector3__WEBPACK_IMPORTED_MODULE_0__["copy"](vertex), output.writeVertex(decoder.decode(vertex)));
        }
    }
    for (let i = 0; i < ring.length; i++) {
        ring[i].setNeighbors(Object(_utils__WEBPACK_IMPORTED_MODULE_3__["cyclicNext"])(ring, i), Object(_utils__WEBPACK_IMPORTED_MODULE_3__["cyclicPrev"])(ring, i));
    }
    writeTriangle(ring[0], ring[1], ring[2], output);
    return ring;
}
const spanComparator = (a, b) => a - b;
/**
 * Removes finished (with all edges processed) nodes from the active ring before processing the next command.
 */
function prepareActiveRing(ring, output) {
    const spans = new Array(ring.length);
    for (let i = 0, unprocessedNodes = ring.length; unprocessedNodes > 0;) {
        spans[i] = ring[i].calculateSpan(Object(_utils__WEBPACK_IMPORTED_MODULE_3__["cyclicPrev"])(ring, i), Object(_utils__WEBPACK_IMPORTED_MODULE_3__["cyclicNext"])(ring, i));
        if (spans[i] > 1) {
            i = Object(_utils__WEBPACK_IMPORTED_MODULE_3__["cyclicNextIndex"])(ring, i);
            unprocessedNodes--;
        }
        else if (spans[i] === 1) {
            const node1 = ring[i];
            const node2 = Object(_utils__WEBPACK_IMPORTED_MODULE_3__["cyclicPrev"])(ring, i);
            const node3 = Object(_utils__WEBPACK_IMPORTED_MODULE_3__["cyclicNext"])(ring, i);
            node3.setAfter(node1, node2);
            node2.setBefore(node1, node3);
            writeTriangle(node1, node2, node3, output);
            for (let j = i; j < spans.length - 1; j++) {
                spans[j] = spans[j + 1];
            }
            ring.splice(i, 1);
            i = Object(_utils__WEBPACK_IMPORTED_MODULE_3__["cyclicPrevIndex"])(ring, i);
            unprocessedNodes++;
        }
        else {
            _util_array__WEBPACK_IMPORTED_MODULE_1__["rotate"](ring, ring.length - Object(_utils__WEBPACK_IMPORTED_MODULE_3__["cyclicNextIndex"])(ring, i));
            ring.splice(ring.length - 2, 2);
            i = 0;
            unprocessedNodes = ring.length;
        }
        if (ring.length < 3) {
            return;
        }
    }
    let minIndex = 0;
    let min = [spans[minIndex], spans[Object(_utils__WEBPACK_IMPORTED_MODULE_3__["cyclicPrevIndex"])(ring, minIndex)], spans[Object(_utils__WEBPACK_IMPORTED_MODULE_3__["cyclicNextIndex"])(ring, minIndex)]];
    for (let i = 1; i < ring.length; i++) {
        const triangleSpans = [spans[i], spans[Object(_utils__WEBPACK_IMPORTED_MODULE_3__["cyclicPrevIndex"])(ring, i)], spans[Object(_utils__WEBPACK_IMPORTED_MODULE_3__["cyclicNextIndex"])(ring, i)]];
        if (_util_array__WEBPACK_IMPORTED_MODULE_1__["compare"](spanComparator, triangleSpans, min) < 0) {
            min = triangleSpans;
            minIndex = i;
        }
    }
    _util_array__WEBPACK_IMPORTED_MODULE_1__["rotate"](ring, ring.length - minIndex);
}
/**
 * Writes triangle that arises from the next node using the two ends of the active ring.
 */
function closeTriangle(output, front, back, add, dist, base) {
    add.setNeighbors(front, back, dist, base);
    front.setAfter(back, add);
    back.setBefore(front, add);
    writeTriangle(add, front, back, output);
}
/**
 * Process the next command.
 */
function processCommand(cmd, queue, reader, decoder, output) {
    const active = queue[0];
    const front = active[0];
    const back = active[active.length - 1];
    switch (cmd.type) {
        case 0 /* ADD */: {
            const m = front.getPrevNeighbor(back);
            let base;
            if (_node__WEBPACK_IMPORTED_MODULE_2__["HoleNode"].isHoleNode(front) || _node__WEBPACK_IMPORTED_MODULE_2__["HoleNode"].isHoleNode(back) || _node__WEBPACK_IMPORTED_MODULE_2__["HoleNode"].isHoleNode(m)) {
                base = _node__WEBPACK_IMPORTED_MODULE_2__["HoleNode"].isHoleNode(front) ? back.vertex : front.vertex;
            }
            else {
                // diff is a diff to predicted position:
                // https://wiki.yandex-team.ru/maps/dev/core/renderer/vec3d/#geometrijaupakovkakoordinatvershin
                _math_vector3__WEBPACK_IMPORTED_MODULE_0__["add"](back.vertex, front.vertex, tmpVertex);
                _math_vector3__WEBPACK_IMPORTED_MODULE_0__["sub"](tmpVertex, m.vertex, tmpVertex);
                decoder.clamp(tmpVertex, tmpVertex);
                base = tmpVertex;
            }
            reader.readDiff(tmpDiff);
            _math_vector3__WEBPACK_IMPORTED_MODULE_0__["add"](base, tmpDiff, tmpVertex);
            const vertex = _math_vector3__WEBPACK_IMPORTED_MODULE_0__["copy"](tmpVertex);
            const vertexDecoded = decoder.decode(vertex);
            const node = new _node__WEBPACK_IMPORTED_MODULE_2__["default"](cmd.valence, vertex, output.writeVertex(vertexDecoded));
            closeTriangle(output, front, back, node, 0);
            active.push(node);
            break;
        }
        case 1 /* HOLE */: {
            const node = new _node__WEBPACK_IMPORTED_MODULE_2__["HoleNode"](cmd.valence);
            closeTriangle(output, front, back, node, 0);
            active.push(node);
            break;
        }
        case 2 /* SPLIT */: {
            const add = cmd.shift;
            closeTriangle(output, front, back, active[add], cmd.valence, active[add - 1]);
            queue.push(active.slice(0, add + 1));
            active.splice(0, add);
            break;
        }
        case 3 /* MERGE */: {
            let other = 1;
            for (; other !== queue.length && queue[other].length <= cmd.shift; other++) {
                cmd.shift -= queue[other].length;
            }
            _util_array__WEBPACK_IMPORTED_MODULE_1__["rotate"](queue[other], queue[other].length - cmd.shift);
            const add = queue[other][0];
            closeTriangle(output, front, back, add, cmd.valence, queue[other][queue[other].length - 1]);
            queue[other].push(queue[other][0]);
            active.splice(0, 0, ...queue[other]);
            queue.splice(other, 1);
            break;
        }
    }
}
/**
 * Read a portion of the model (manifold) from the file and writes vertices/triangles into the output.
 */
function parseManifold(reader, decoder, output) {
    const ring = getInitTriangle(reader, decoder, output);
    const queue = [ring];
    while (queue.length !== 0) {
        // active ring is the first element int the queue
        prepareActiveRing(queue[0], output);
        while (queue[0].length > 2) {
            processCommand(reader.readCommand(tmpCommand), queue, reader, decoder, output);
            prepareActiveRing(queue[0], output);
        }
        queue.shift();
    }
    return output.flush();
}


/***/ }),
/* 87 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Node; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HoleNode", function() { return HoleNode; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(85);
/* harmony import */ var _math_vector3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(83);


/**
 * A node of the model mesh. Basically it is a vertex, but also contains some intermediate data to
 * restore the mesh during parsing.
 */
class Node {
    /**
     * @param valence Number adjacent vertices.
     * @param vertex Coordinates of the node.
     * @param index Position of the vertex in a storage (like GL buffer or an intermediate array buffer).
     */
    constructor(valence, vertex, index) {
        this.vertex = vertex;
        this.index = index;
        this._neighbours = new Array(valence).fill(undefined);
    }
    /**
     * @returns Distance between two neighbors in the node's neighbors list.
     */
    calculateSpan(a, b) {
        const aIndex = this._neighbours.indexOf(a);
        const bIndex = this._neighbours.indexOf(b);
        return (this._neighbours.length + (bIndex - aIndex)) % this._neighbours.length;
    }
    /**
     * Sets two neighbors that forms a triangle with the current one.
     */
    setNeighbors(a, b, span = 0, prev) {
        let index = (this._neighbours.indexOf(prev) + span) % this._neighbours.length;
        this._neighbours[index] = a;
        index = Object(_utils__WEBPACK_IMPORTED_MODULE_0__["cyclicNextIndex"])(this._neighbours, index);
        this._neighbours[index] = b;
    }
    /**
     * Sets a neighbor before the specified one.
     */
    setBefore(next, val) {
        const index = this._neighbours.indexOf(next);
        this._neighbours[Object(_utils__WEBPACK_IMPORTED_MODULE_0__["cyclicPrevIndex"])(this._neighbours, index)] = val;
    }
    /**
     * Sets a neighbor next to the specified one.
     */
    setAfter(prev, val) {
        const index = this._neighbours.indexOf(prev);
        this._neighbours[Object(_utils__WEBPACK_IMPORTED_MODULE_0__["cyclicNextIndex"])(this._neighbours, index)] = val;
    }
    /**
     * @returns Neighbor previous to the specified one.
     */
    getPrevNeighbor(val) {
        const index = this._neighbours.indexOf(val);
        return Object(_utils__WEBPACK_IMPORTED_MODULE_0__["cyclicPrev"])(this._neighbours, index);
    }
    /**
     * @returns Neighbor next to the specified one.
     */
    getNextNeighbor(val) {
        const index = this._neighbours.indexOf(val);
        return Object(_utils__WEBPACK_IMPORTED_MODULE_0__["cyclicNext"])(this._neighbours, index);
    }
}
const STUB_HOLE_NODE_VERTEX = _math_vector3__WEBPACK_IMPORTED_MODULE_1__["create"](-1, -1, -1);
const STUB_HOLE_NODE_INDEX = -1;
/**
 * A special type of nodes that do not represent a real vertex (and is not supposed to be written into a buffer),
 * but required to support the mesh structure.
 */
class HoleNode extends Node {
    constructor(valence) {
        super(valence, STUB_HOLE_NODE_VERTEX, STUB_HOLE_NODE_INDEX);
    }
    static isHoleNode(node) {
        return node instanceof HoleNode;
    }
}


/***/ }),
/* 88 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return VertexDecoder; });
/* harmony import */ var _math_vector3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(83);
/* harmony import */ var _math_scalar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(42);
/* harmony import */ var _util_gputypes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(50);



/**
 * Vertex components are encoded in two bytes with specified precision to facilitate better compression.
 * This decoder translate those values into floats.
 */
class VertexDecoder {
    constructor(precision) {
        this._precisionXY = precision & 0xF;
        this._precisionZ = precision >> 4;
        this._shiftXY = 16 - this._precisionXY;
        this._shiftZ = 16 - this._precisionZ;
        this._maxXY = (1 << this._precisionXY) - 1;
        this._maxZ = (1 << this._precisionZ) - 1;
    }
    /**
     * @returns Vector with components clamped to their max values.
     */
    clamp(vertex, dst = _math_vector3__WEBPACK_IMPORTED_MODULE_0__["create"](0, 0, 0)) {
        dst.x = Object(_math_scalar__WEBPACK_IMPORTED_MODULE_1__["clamp"])(vertex.x, 0, this._maxXY);
        dst.y = Object(_math_scalar__WEBPACK_IMPORTED_MODULE_1__["clamp"])(vertex.y, 0, this._maxXY);
        dst.z = Object(_math_scalar__WEBPACK_IMPORTED_MODULE_1__["clamp"])(vertex.z, 0, this._maxZ);
        return dst;
    }
    /**
     * @param vertex Encoded vertex.
     * @param dst The output vector.
     * @returns Decoded vertex (components are adjusted by the precision and converted into floats)
     */
    decode(vertex, dst = _math_vector3__WEBPACK_IMPORTED_MODULE_0__["create"](0, 0, 0)) {
        dst.x = VertexDecoder._decode(vertex.x, this._precisionXY, this._shiftXY);
        dst.y = VertexDecoder._decode(vertex.y, this._precisionXY, this._shiftXY);
        dst.z = VertexDecoder._decode(vertex.z, this._precisionZ, this._shiftZ);
        return dst;
    }
    static _decode(value, precision, shift) {
        value = value << shift;
        value |= value >> precision;
        value = Object(_util_gputypes__WEBPACK_IMPORTED_MODULE_2__["uint16ToFloat"])(value);
        return value;
    }
}


/***/ }),
/* 89 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "appendToBatch", function() { return appendToBatch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "batchAllocatedObjects", function() { return batchAllocatedObjects; });
/**
 * Appends portion of memory to batch if they are adjacent.
 *
 * @returns `true` if both params are adjacent and the batch was successfully updated, `false` otherwise.
 */
function appendToBatch(memoryLocation, batch) {
    if (batch.vertexByteOffset + batch.vertexByteLength === memoryLocation.vertexByteOffset &&
        batch.indexByteOffset + batch.indexByteLength === memoryLocation.indexByteOffset) {
        batch.vertexByteLength += memoryLocation.vertexByteLength;
        batch.indexByteLength += memoryLocation.indexByteLength;
        return true;
    }
    return false;
}
/**
 * Combines objects allocated in memory into batches. No sorting is done in this method, the objects are supposed
 * to be sorted by index/vertex offsets to make batching effective. The batch is created by factory since it can
 * contains problem specific information.
 *
 * @param objects List of allocated objects.
 * @param getMemoryLocation Returns memory location of specific object.
 * @param createBatch Initiates batch by the first object.
 * @param canBatch Checks if two objects can be allocated.
 * @returns Iterable list of batches.
 */
function* batchAllocatedObjects(objects, getMemoryLocation, createBatch, canBatch = () => true) {
    const iterator = objects[Symbol.iterator]();
    let primitive = iterator.next().value;
    if (!primitive) {
        return;
    }
    let prev = primitive;
    let batch = createBatch(prev);
    primitive = iterator.next().value;
    while (primitive) {
        const primitiveMemoryLocation = getMemoryLocation(primitive);
        if (!canBatch(prev, primitive, batch) || !appendToBatch(primitiveMemoryLocation, batch)) {
            yield batch;
            batch = createBatch(primitive);
        }
        prev = primitive;
        primitive = iterator.next().value;
    }
    yield batch;
}


/***/ }),
/* 90 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TaskQueue; });
/* harmony import */ var _priority_queue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(91);
/* harmony import */ var _util_event_emitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);


const DEQUEUE_TIMEOUT = 1; // ms
/**
 * Prioritized task queue.
 */
class TaskQueue {
    /**
     * Constructs an empty task queue.
     */
    constructor() {
        this._queue = new _priority_queue__WEBPACK_IMPORTED_MODULE_0__["default"]();
        this._frozen = false;
        this._dequeueTimeoutHandle = 0;
        this.onEmpty = new _util_event_emitter__WEBPACK_IMPORTED_MODULE_1__["VoidEventEmitter"]();
    }
    /**
     * Destroys the queue. Any remaining tasks won't be executed.
     */
    destroy() {
        clearTimeout(this._dequeueTimeoutHandle);
    }
    /**
     * Enqueues a task to the queue and schedules processing of the queue.
     *
     * @param task The task.
     * @returns Promise that will be fullfilled when the task successfully
     *      finishes or rejected if there's an error.
     */
    enqueue(task) {
        if (!this._frozen) {
            this._setDequeueTimeout();
        }
        return new Promise((resolve, reject) => {
            this._queue.enqueue({
                execute() {
                    try {
                        task.execute();
                        resolve();
                    }
                    catch (error) {
                        reject(error);
                    }
                },
                priority: task.priority
            });
        });
    }
    isEmpty() {
        return this._queue.isEmpty();
    }
    freeze() {
        if (this._dequeueTimeoutHandle) {
            clearTimeout(this._dequeueTimeoutHandle);
            this._dequeueTimeoutHandle = 0;
        }
        this._frozen = true;
    }
    unfreeze() {
        this._frozen = false;
        if (!this._queue.isEmpty()) {
            this._setDequeueTimeout();
        }
    }
    _dequeue() {
        const task = this._queue.dequeue();
        if (task) {
            task.execute();
        }
        if (this._queue.isEmpty()) {
            this._dequeueTimeoutHandle = 0;
            this.onEmpty.fire();
        }
        else {
            this._dequeueTimeoutHandle = setTimeout(() => this._dequeue(), DEQUEUE_TIMEOUT);
        }
    }
    _setDequeueTimeout() {
        if (!this._dequeueTimeoutHandle) {
            this._dequeueTimeoutHandle = setTimeout(() => this._dequeue(), DEQUEUE_TIMEOUT);
        }
    }
}


/***/ }),
/* 91 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PriorityQueue; });
/* harmony import */ var _binary_heap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(92);

function itemComparator(a, b) {
    return a.priority - b.priority;
}
/**
 * Priority queue based on a heap.
 */
class PriorityQueue {
    /**
     * Constructs new empty priority queue.
     */
    constructor() {
        this._heap = new _binary_heap__WEBPACK_IMPORTED_MODULE_0__["default"](itemComparator);
    }
    /**
     * Adds an item into the queue.
     *
     * @param item The item.
     */
    enqueue(item) {
        this._heap.insert(item);
    }
    /**
     * Removes next item from the queue.
     *
     * @returns The next item or `undefined` if the queue's empty.
     */
    dequeue() {
        return this._heap.pop();
    }
    /**
     * Checks if the queue has no items in it.
     *
     * @returns `true` if there're no items it the queue and `false` otherwise.
     */
    isEmpty() {
        return this._heap.size === 0;
    }
}


/***/ }),
/* 92 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BinaryHeap; });
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(51);
/* harmony import */ var _comparator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52);


/**
 * Computes index of the parent of an item.
 *
 * @param idx Index of the item.
 * @returns Index of the parent.
 */
function getParentIdx(idx) {
    return (idx + 1 >> 1) - 1;
}
/**
 * Computes index of the left child of an item.
 *
 * @param idx Index of the item.
 * @returns Index of the child.
 */
function getFirstChildIdx(idx) {
    return (idx + 1 << 1) - 1;
}
class BinaryHeap {
    /**
     * Constructs a new empty heap. Order of items in the heap will be defined
     * by a given comparator.
     *
     * @param comparator The comparator.
     */
    constructor(comparator = _comparator__WEBPACK_IMPORTED_MODULE_1__["DEFAULT_COMPARATOR"]) {
        // TODO(dmikis) Investigate preallocation.
        this._items = [];
        this._comparator = comparator;
    }
    /**
     * Inserts an item into the heap.
     *
     * @param item The item to be inserted.
     */
    insert(item) {
        const items = this._items;
        const comparator = this._comparator;
        // Insert the new item as bottom right-most child of the heap.
        let idx = items.push(item) - 1;
        let parentIdx = getParentIdx(idx);
        // Walk the heap upward and restore heap property on the way.
        while (parentIdx > -1 &&
            comparator(items[idx], items[parentIdx]) > 0) {
            Object(_array__WEBPACK_IMPORTED_MODULE_0__["swap"])(items, idx, parentIdx);
            idx = parentIdx;
            parentIdx = getParentIdx(idx);
        }
    }
    /**
     * Removes "maximum" item from the head.
     *
     * @returns The removed item or `undefined` is the heap's empty.
     */
    pop() {
        const items = this._items;
        if (items.length === 0) {
            return undefined;
        }
        const newSize = items.length - 1;
        // Place max item at the end of the items array.
        Object(_array__WEBPACK_IMPORTED_MODULE_0__["swap"])(items, 0, newSize);
        // Walk downward from the new root to restore heap property.
        let idx = 0;
        let childIdx = 1;
        const comparator = this._comparator;
        while (childIdx < newSize) {
            if (childIdx + 1 < newSize &&
                comparator(items[childIdx], items[childIdx + 1]) < 0) {
                childIdx += 1;
            }
            if (comparator(items[idx], items[childIdx]) > 0) {
                break;
            }
            Object(_array__WEBPACK_IMPORTED_MODULE_0__["swap"])(items, idx, childIdx);
            idx = childIdx;
            childIdx = getFirstChildIdx(childIdx);
        }
        // Remove previously placed at the end previous max item.
        return items.pop();
    }
    /**
     * @returns "Maximum" item in the heap or `undefined` if the head is empty.
     */
    peek() {
        return this._items[0];
    }
    /**
     * @returns Iterator over all items in the heap. Note that order of items
     *      is undefined.
     */
    *[Symbol.iterator]() {
        for (const item of this._items) {
            yield item;
        }
    }
    /**
     * @returns Number of items in the heap.
     */
    get size() {
        return this._items.length;
    }
}


/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2FkYXB0ZXJzL3ZlY3Rvcl9hcGkvd29ya2VyL3RpbGVfcHJvdmlkZXJfd29ya2VyLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL3dvcmtlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9ldmVudF9lbWl0dGVyLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL3VuaXF1ZV9pZC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdmVjdG9yX2FwaS93b3JrZXIvdGlsZV9wcm92aWRlcl93b3JrZXJfbWVzc2FnZXMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2FkYXB0ZXJzL3ZlY3Rvcl9hcGkvd29ya2VyL3ByaW1pdGl2ZV9wcm92aWRlcl93b3JrZXJfbWVzc2FnZXMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2ZvbnQvZGZfZm9udF9yZWdpc3RyeS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvZm9udC9mb250X3JlZ2lzdHJ5LnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9mb250L2RmX2ZvbnQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2ZvbnQvZm9udC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvZm9udC9kZl9nbHlwaF9hdGxhc19hbGxvY2F0b3IudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2ZvbnQvZGZfZ2x5cGhfYXRsYXMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvaHR0cC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdmVjdG9yX2FwaS93b3JrZXIvZ2x5cGhfZGVsaXZlcnlfbWFuYWdlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdmVjdG9yX2FwaS93b3JrZXIvcHJvdG9fYWxpYXNlcy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdmVjdG9yX2FwaS93b3JrZXIvcHJvdG8uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvbWluaW1hbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvaW5kZXgtbWluaW1hbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvd3JpdGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy91dGlsL21pbmltYWwuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb3RvYnVmanMvYXNwcm9taXNlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9iYXNlNjQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL2V2ZW50ZW1pdHRlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb3RvYnVmanMvZmxvYXQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL2lucXVpcmUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL3V0ZjgvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL3Bvb2wvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3V0aWwvbG9uZ2JpdHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3dyaXRlcl9idWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JlYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcmVhZGVyX2J1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcnBjLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9ycGMvc2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcm9vdHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2ZvbnQvZGZfZ2x5cGhfZGVsaXZlcnlfbWFuYWdlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdmVjdG9yX2FwaS91dGlsL2hvc3RzLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9hZGFwdGVycy90aWxlX2Jhc2VkX2FkYXB0ZXIvdGlsZV9pZC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9jb2xvci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdmVjdG9yX2FwaS93b3JrZXIvcGFyc2VyL2V4dHJhY3RfcG9pbnRzLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9hZGFwdGVycy92ZWN0b3JfYXBpL3dvcmtlci9wYXJzZXIvdGlsZV93b3JsZF9jb29yZGluYXRlc19jb252ZXJ0ZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2FkYXB0ZXJzL3RpbGVfYmFzZWRfYWRhcHRlci91dGlsL3RpbGVfc3lzdGVtLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9tYXRoL3NjYWxhci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvbWF0aC92ZWN0b3IyLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL2Z1enp5X2VxdWFsLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9hZGFwdGVycy92ZWN0b3JfYXBpL3dvcmtlci9wYXJzZXIvZXh0cmFjdF9zdHlsZXMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2FkYXB0ZXJzL3ZlY3Rvcl9hcGkvd29ya2VyL3BhcnNlci9leHRyYWN0X3BvbHlsaW5lcy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9wb2x5bGluZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL3BvbHlnb24vcG9seWdvbl9idWZmZXJfd3JpdGVyLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL2J1ZmZlcl93cml0ZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvZ3B1dHlwZXMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvYXJyYXkudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvY29tcGFyYXRvci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC90cmlhbmd1bGF0ZS50cyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWFyY3V0L3NyYy9lYXJjdXQuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3ByaW1pdGl2ZS9wb2x5Z29uL3BvbHlnb25fYXR0cmlidXRlX21hcHBpbmcudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3JlbmRlci9hdHRyaWJfbWFwcGluZy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9pdGVyYWJsZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC9wb3dfb2ZfMi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvdXRpbC96X2luZGV4LnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9wcmltaXRpdmUvcG9seWdvbi90ZXh0dXJlZF9wb2x5Z29uX2J1ZmZlcl93cml0ZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3ByaW1pdGl2ZS9wb2x5Z29uL3RleHR1cmVkX3BvbHlnb25fYXR0cmlidXRlX21hcHBpbmcudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3ByaW1pdGl2ZS9wb2x5bGluZS9wb2x5bGluZV9idWZmZXJfd3JpdGVyLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9wcmltaXRpdmUvcG9seWxpbmUvcG9seWxpbmVfYXR0cmlidXRlX21hcHBpbmcudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2FkYXB0ZXJzL3ZlY3Rvcl9hcGkvd29ya2VyL3BhcnNlci9leHRyYWN0X3BvbHlnb25zLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9hZGFwdGVycy92ZWN0b3JfYXBpL3V0aWwvZXh0cnVkZWRfcG9seWdvbl9idWZmZXJfd3JpdGVyLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9wcmltaXRpdmUvbW9kZWwvbW9kZWxfYnVmZmVyX3dyaXRlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdmVjdG9yX2FwaS93b3JrZXIvcGFyc2VyL2V4dHJhY3RfY3VydmVkX2xhYmVscy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdmVjdG9yX2FwaS93b3JrZXIvcGFyc2VyL2V4dHJhY3RfbGFiZWxzLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9hZGFwdGVycy92ZWN0b3JfYXBpL3dvcmtlci9wYXJzZXIvZXh0cmFjdF9wb2ludF9sYWJlbHMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3ByaW1pdGl2ZS9sYWJlbC9sYXlvdXRfcG9pbnRfbGFiZWwudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3ByaW1pdGl2ZS9iaWxsYm9hcmRfcmVjdGFuZ2xlL2J1ZmZlcl93cml0ZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3ByaW1pdGl2ZS9iaWxsYm9hcmRfcmVjdGFuZ2xlL2F0dHJpYnV0ZV9tYXBwaW5nLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9wcmltaXRpdmUvbGFiZWwvcG9pbnRfbGFiZWxfYnVmZmVyX3dyaXRlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvcHJpbWl0aXZlL2xhYmVsL3BvaW50X2xhYmVsX2F0dHJpYnV0ZV9tYXBwaW5nLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9wcmltaXRpdmUvbGFiZWwvY3VydmVkX2xhYmVsX2J1ZmZlcl93cml0ZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3ByaW1pdGl2ZS9sYWJlbC9sYXlvdXRfY3VydmVkX2xhYmVsLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9wcmltaXRpdmUvbGFiZWwvY3VydmVkX2xhYmVsX2F0dHJpYnV0ZV9tYXBwaW5nLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9pZF9tYW5hZ2VyLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9hZGFwdGVycy92ZWN0b3JfYXBpL3V0aWwvbGFiZWwudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2FkYXB0ZXJzL3ZlY3Rvcl9hcGkvdXRpbC90cmltZXNoX3BvbHlnb25fYnVmZmVyX3dyaXRlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdmVjdG9yX2FwaS91dGlsL3RyaW1lc2gvcGFyc2VfdHJpbWVzaC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdmVjdG9yX2FwaS91dGlsL3RyaW1lc2gvZmlsZV9yZWFkZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL21hdGgvdmVjdG9yMy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvbWF0aC9tYXRyaXgzLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9hZGFwdGVycy92ZWN0b3JfYXBpL3V0aWwvdHJpbWVzaC91dGlscy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdmVjdG9yX3JlbmRlcl9lbmdpbmUvYWRhcHRlcnMvdmVjdG9yX2FwaS91dGlsL3RyaW1lc2gvcGFyc2VfbWFuaWZvbGQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2FkYXB0ZXJzL3ZlY3Rvcl9hcGkvdXRpbC90cmltZXNoL25vZGUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL2FkYXB0ZXJzL3ZlY3Rvcl9hcGkvdXRpbC90cmltZXNoL3ZlcnRleF9kZWNvZGVyLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS9yZW5kZXIvbWVtb3J5L3JlbGF0aXZlX2xvY2F0aW9uLnRzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3JfcmVuZGVyX2VuZ2luZS91dGlsL3Rhc2tfcXVldWUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvcHJpb3JpdHlfcXVldWUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZlY3Rvcl9yZW5kZXJfZW5naW5lL3V0aWwvYmluYXJ5X2hlYXAudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0RBQTBDLGdDQUFnQztBQUMxRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdFQUF3RCxrQkFBa0I7QUFDMUU7QUFDQSx5REFBaUQsY0FBYztBQUMvRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQXlDLGlDQUFpQztBQUMxRSx3SEFBZ0gsbUJBQW1CLEVBQUU7QUFDckk7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7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QUE7QUFBQTtBQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDZSxvQ0FBb0MsdURBQVk7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx3QkFBd0I7QUFDNUU7QUFDQTtBQUNBLHdEQUF3RCx3QkFBd0I7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDcEVBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDbkNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxXQUFXLEdBQUcsZUFBZSxJQUFJLFVBQVU7QUFDbkc7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFVBQVU7QUFDOUQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q3RCLFdBQVcsT0FBTztBQUNsQixhQUFhLE9BQU87QUFDcEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUssSUFBSTs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUssSUFBSTs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYSwwQ0FBMEM7QUFDdkQ7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLG9EQUFvRDtBQUNw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Q3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtB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Q0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNoREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQTZFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZO0FBQ1o7QUFDTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sMkNBQTJDLG1FQUFpQjtBQUNuRSxZQUFZLGlFQUFtQjtBQUMvQixRQUFRLGlFQUFtQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sNkNBQTZDLHFDQUFxQztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QyxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QixpRUFBVztBQUN2QywyQkFBMkIsK0RBQVc7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUVBQVc7QUFDckM7QUFDQTtBQUNBOzs7Ozs7OztBQ3pCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQTJDO0FBQ2I7QUFDdkI7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFdBQVc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFdBQVc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxzQkFBc0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9CQUFvQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtEQUFHO0FBQ2xCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLCtEQUFhO0FBQ3JDLHdCQUF3QiwrREFBYTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7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O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUEsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaURBQWlELFNBQVM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ3JEQTtBQUFBO0FBQUE7QUFBK0Q7QUFDL0Q7QUFDTywyQ0FBMkMsdUVBQWdCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMzR0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTs7Ozs7Ozs7QUNqQkE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUN2QkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQXVEO0FBQ1I7QUFDOEI7QUFDM0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ08seUNBQXlDLDRFQUFpQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwrREFBVztBQUN4QztBQUNBLHVDQUF1QywyRUFBWTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdEQUFVO0FBQ2pDLHVCQUF1QixnREFBVTtBQUNqQyx1QkFBdUIsZ0RBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDOURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBdUM7QUFDVTtBQUNKO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsdUJBQXVCLG9EQUFVO0FBQ2pDLHdCQUF3Qix1REFBYTtBQUNyQztBQUNBLGNBQWMscUVBQWE7QUFDM0I7QUFDQTs7Ozs7Ozs7QUNmQTtBQUFBO0FBQUE7QUFBQTtBQUFvRDtBQUNiO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMENBQTBDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0RBQWM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMkRBQVk7QUFDM0I7QUFDQTtBQUNBOzs7Ozs7OztBQ3RFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQXFDO0FBQ3dDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVk7QUFDWjtBQUNPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDJDQUEyQyxtRUFBaUI7QUFDbkUsWUFBWSxpRUFBbUI7QUFDL0IsUUFBUSxpRUFBbUI7QUFDM0IsUUFBUSxpRUFBbUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDdENBO0FBQUE7QUFBQTtBQUFBO0FBQStCO0FBQ21CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDhEQUFrQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1EQUFJO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxtREFBSTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbURBQUk7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoidGlsZV9wcm92aWRlcl93b3JrZXIudHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMCk7XG4iLCJpbXBvcnQgeyBXZWJXb3JrZXJJbXBsZW1lbnRhdGlvbiB9IGZyb20gJy4uLy4uLy4uL3V0aWwvd29ya2VyJztcclxuaW1wb3J0IHsgVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGUsIGdlb21ldHJ5VHJhbnNmZXJhYmxlRXh0cmFjdG9yLCBtZXNoVHJhbnNmZXJhYmxlRXh0cmFjdG9yLCBsYWJlbFRyYW5zZmVyYWJsZUV4dHJhY3RvciwgdGlsZVRyYW5zZmVyYWJsZUV4dHJhY3RvciB9IGZyb20gJy4vdGlsZV9wcm92aWRlcl93b3JrZXJfbWVzc2FnZXMnO1xyXG5pbXBvcnQgRGZGb250UmVnaXN0cnkgZnJvbSAnLi4vLi4vLi4vZm9udC9kZl9mb250X3JlZ2lzdHJ5JztcclxuaW1wb3J0IERmR2x5cGhBdGxhc0FsbG9jYXRvciBmcm9tICcuLi8uLi8uLi9mb250L2RmX2dseXBoX2F0bGFzX2FsbG9jYXRvcic7XHJcbmltcG9ydCB7IEJpbmFyeUh0dHBSZXF1ZXN0IH0gZnJvbSAnLi4vLi4vLi4vdXRpbC9odHRwJztcclxuaW1wb3J0IHsgQXBpR2x5cGhzRGVsaXZlcnlNYW5hZ2VyIH0gZnJvbSAnLi9nbHlwaF9kZWxpdmVyeV9tYW5hZ2VyJztcclxuaW1wb3J0IHsgZ2V0VGlsZUlkIH0gZnJvbSAnLi4vLi4vdGlsZV9iYXNlZF9hZGFwdGVyL3RpbGVfaWQnO1xyXG5pbXBvcnQgKiBhcyBjb2xvciBmcm9tICcuLi8uLi8uLi91dGlsL2NvbG9yJztcclxuaW1wb3J0IGV4dHJhY3RQb2ludHMgZnJvbSAnLi9wYXJzZXIvZXh0cmFjdF9wb2ludHMnO1xyXG5pbXBvcnQgeyBUaWxlIH0gZnJvbSAnLi9wcm90b19hbGlhc2VzJztcclxuaW1wb3J0IGV4dHJhY3RQb2x5bGluZXMgZnJvbSAnLi9wYXJzZXIvZXh0cmFjdF9wb2x5bGluZXMnO1xyXG5pbXBvcnQgUG9seWdvbkJ1ZmZlcldyaXRlciBmcm9tICcuLi8uLi8uLi9wcmltaXRpdmUvcG9seWdvbi9wb2x5Z29uX2J1ZmZlcl93cml0ZXInO1xyXG5pbXBvcnQgVGV4dHVyZWRQb2x5Z29uQnVmZmVyV3JpdGVyIGZyb20gJy4uLy4uLy4uL3ByaW1pdGl2ZS9wb2x5Z29uL3RleHR1cmVkX3BvbHlnb25fYnVmZmVyX3dyaXRlcic7XHJcbmltcG9ydCBQb2x5bGluZUJ1ZmZlcldyaXRlciBmcm9tICcuLi8uLi8uLi9wcmltaXRpdmUvcG9seWxpbmUvcG9seWxpbmVfYnVmZmVyX3dyaXRlcic7XHJcbmltcG9ydCBleHRyYWN0UG9seWdvbnMgZnJvbSAnLi9wYXJzZXIvZXh0cmFjdF9wb2x5Z29ucyc7XHJcbmltcG9ydCB7IEV4dHJ1ZGVkUG9seWdvbkJ1ZmZlcldyaXRlciB9IGZyb20gJy4uL3V0aWwvZXh0cnVkZWRfcG9seWdvbl9idWZmZXJfd3JpdGVyJztcclxuaW1wb3J0IHsgRU1QVFkgfSBmcm9tICcuLi8uLi8uLi9tYXRoL3ZlY3RvcjInO1xyXG5pbXBvcnQgZXh0cmFjdEN1cnZlZExhYmVscyBmcm9tICcuL3BhcnNlci9leHRyYWN0X2N1cnZlZF9sYWJlbHMnO1xyXG5pbXBvcnQgZXh0cmFjdFBvaW50TGFiZWxzIGZyb20gJy4vcGFyc2VyL2V4dHJhY3RfcG9pbnRfbGFiZWxzJztcclxuaW1wb3J0IGxheW91dFBvaW50TGFiZWwgZnJvbSAnLi4vLi4vLi4vcHJpbWl0aXZlL2xhYmVsL2xheW91dF9wb2ludF9sYWJlbCc7XHJcbmltcG9ydCBSZWN0YW5nbGVCdWZmZXJXcml0ZXIgZnJvbSAnLi4vLi4vLi4vcHJpbWl0aXZlL2JpbGxib2FyZF9yZWN0YW5nbGUvYnVmZmVyX3dyaXRlcic7XHJcbmltcG9ydCAqIGFzIHZlYzIgZnJvbSAnLi4vLi4vLi4vbWF0aC92ZWN0b3IyJztcclxuaW1wb3J0IFBvaW50TGFiZWxCdWZmZXJXcml0ZXIgZnJvbSAnLi4vLi4vLi4vcHJpbWl0aXZlL2xhYmVsL3BvaW50X2xhYmVsX2J1ZmZlcl93cml0ZXInO1xyXG5pbXBvcnQgQ3VydmVkTGFiZWxCdWZmZXJXcml0ZXIgZnJvbSAnLi4vLi4vLi4vcHJpbWl0aXZlL2xhYmVsL2N1cnZlZF9sYWJlbF9idWZmZXJfd3JpdGVyJztcclxuaW1wb3J0IHsgYWxsT2ZJdGVyYWJsZSwgZmlsdGVySXRlcmFibGUsIG1hcEl0ZXJhYmxlLCByZWR1Y2VJdGVyYWJsZSB9IGZyb20gJy4uLy4uLy4uL3V0aWwvaXRlcmFibGUnO1xyXG5pbXBvcnQgeyBjYWxjdWxhdGVQb2ludExhYmVsQkJveCB9IGZyb20gJy4uL3V0aWwvbGFiZWwnO1xyXG5pbXBvcnQgeyBUcmltZXNoUG9seWdvbkJ1ZmZlcldyaXRlciB9IGZyb20gJy4uL3V0aWwvdHJpbWVzaF9wb2x5Z29uX2J1ZmZlcl93cml0ZXInO1xyXG5pbXBvcnQgeyBhcHBlbmRUb0JhdGNoLCBiYXRjaEFsbG9jYXRlZE9iamVjdHMgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXIvbWVtb3J5L3JlbGF0aXZlX2xvY2F0aW9uJztcclxuaW1wb3J0IFRhc2tRdWV1ZSBmcm9tICcuLi8uLi8uLi91dGlsL3Rhc2tfcXVldWUnO1xyXG5pbXBvcnQgeyBtZXJnZVNvcnQgfSBmcm9tICcuLi8uLi8uLi91dGlsL2FycmF5JztcclxuaW1wb3J0IHsgZ2V0SWQgfSBmcm9tICcuLi8uLi8uLi9pZF9tYW5hZ2VyJztcclxuaW1wb3J0IHsgZ2V0SG9zdEFsaWFzQnlVaWQgfSBmcm9tICcuLi91dGlsL2hvc3RzJztcclxuY29uc3QgQkFDS0dST1VORF9SQURJVVNfUFggPSAyO1xyXG5mdW5jdGlvbiBmaWx0ZXJPdXRVbnN0eWxlZFByaW1pdGl2ZXMocHJpbWl0aXZlKSB7XHJcbiAgICByZXR1cm4gcHJpbWl0aXZlLnN0eWxlcy5sZW5ndGggPiAwO1xyXG59XHJcbmZ1bmN0aW9uIGJhdGNoUHJpbWl0aXZlRGVzY3JpcHRpb25zKHByaW1pdGl2ZXMpIHtcclxuICAgIHJldHVybiBtYXBJdGVyYWJsZShiYXRjaEFsbG9jYXRlZE9iamVjdHMocHJpbWl0aXZlcywgKHByaW1pdGl2ZSkgPT4gcHJpbWl0aXZlLmJ1ZmZlckxvY2F0aW9uLCAocHJpbWl0aXZlKSA9PiAoT2JqZWN0LmFzc2lnbih7fSwgcHJpbWl0aXZlLmJ1ZmZlckxvY2F0aW9uKSksIChhLCBiKSA9PiAoYS5idWZmZXJMb2NhdGlvbi5idWZmZXJJbmRleCA9PT0gYi5idWZmZXJMb2NhdGlvbi5idWZmZXJJbmRleCkpLCAoYnVmZmVyTG9jYXRpb24pID0+ICh7IGJ1ZmZlckxvY2F0aW9uLCBzdHlsZXM6IFtdIH0pKTtcclxufVxyXG4vKipcclxuICogQmF0Y2ggbGFiZWxzIGFsb25nIHdpdGggdGhlaXIgYmFja2dyb3VuZHMuIEkuZS4gYSBsYWJlbCBiYXRjaCBtdXN0IGNvbnRhaW4gYmF0Y2hlZCBiYWNrZ3JvdW5kIGxvY2F0aW9ucyBvZiB0aG9zZVxyXG4gKiBsYWJlbHMgaW4gdGhlIGJhdGNoIHRvIHN1cHBvcnQgTGFiZWxQcmltaXRpdmVEZXNjcmlwdGlvbiBpbnRlcmZhY2UuXHJcbiAqL1xyXG5mdW5jdGlvbiogYmF0Y2hMYWJlbHMobGFiZWxzKSB7XHJcbiAgICBjb25zdCBnZXRMb2NhdGlvbiA9IChwcmltaXRpdmUpID0+IHByaW1pdGl2ZS5idWZmZXJMb2NhdGlvbjtcclxuICAgIGNvbnN0IGNyZWF0ZUJhdGNoID0gKHByaW1pdGl2ZSkgPT4ge1xyXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBwcmltaXRpdmUuYnVmZmVyTG9jYXRpb24sIHsgYmFja2dyb3VuZEJhdGNoOiBwcmltaXRpdmUuYmFja2dyb3VuZEJ1ZmZlckxvY2F0aW9uID8gT2JqZWN0LmFzc2lnbih7fSwgcHJpbWl0aXZlLmJhY2tncm91bmRCdWZmZXJMb2NhdGlvbikgOiB1bmRlZmluZWQgfSk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgY2FuQmF0Y2ggPSAoYSwgYiwgYmF0Y2gpID0+IHtcclxuICAgICAgICBjb25zdCBhcmVMYWJlbHNJblNhbWVCdWZmZXIgPSBhLmJ1ZmZlckxvY2F0aW9uLmJ1ZmZlckluZGV4ID09PSBiLmJ1ZmZlckxvY2F0aW9uLmJ1ZmZlckluZGV4O1xyXG4gICAgICAgIGlmIChiLmJhY2tncm91bmRCdWZmZXJMb2NhdGlvbikge1xyXG4gICAgICAgICAgICAvLyB0aGVyZSBjb3VsZCBiZSBubyBiYWNrZ3JvdW5kQmF0Y2ggaWYgcHJldmlvdXMgbGFiZWxzIGhhZCBubyBiYWNrZ3JvdW5kcyxcclxuICAgICAgICAgICAgLy8gc28gYmFja2dyb3VuZCBiYXRjaGluZyBzdGFydHMgd2l0aCB0aGUgZmlzdCBsYWJlbCB0aGF0IGNvbnRhaW5zIG9uZVxyXG4gICAgICAgICAgICBpZiAoIWJhdGNoLmJhY2tncm91bmRCYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgYmF0Y2guYmFja2dyb3VuZEJhdGNoID0gT2JqZWN0LmFzc2lnbih7fSwgYi5iYWNrZ3JvdW5kQnVmZmVyTG9jYXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGxhYmVsIGJhdGNoaW5nIGJyZWFrcyBpZiBiYWNrZ3JvdW5kcyBjYW4ndCBiZSBiYXRjaGVkXHJcbiAgICAgICAgICAgIGlmIChiLmJhY2tncm91bmRCdWZmZXJMb2NhdGlvbi5idWZmZXJJbmRleCAhPT0gYmF0Y2guYmFja2dyb3VuZEJhdGNoLmJ1ZmZlckluZGV4IHx8XHJcbiAgICAgICAgICAgICAgICAhYXJlTGFiZWxzSW5TYW1lQnVmZmVyIHx8XHJcbiAgICAgICAgICAgICAgICAhYXBwZW5kVG9CYXRjaChiLmJhY2tncm91bmRCdWZmZXJMb2NhdGlvbiwgYmF0Y2guYmFja2dyb3VuZEJhdGNoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcmVMYWJlbHNJblNhbWVCdWZmZXI7XHJcbiAgICB9O1xyXG4gICAgZm9yIChjb25zdCBiYXRjaCBvZiBiYXRjaEFsbG9jYXRlZE9iamVjdHMobGFiZWxzLCBnZXRMb2NhdGlvbiwgY3JlYXRlQmF0Y2gsIGNhbkJhdGNoKSkge1xyXG4gICAgICAgIGNvbnN0IGJhY2tncm91bmRCdWZmZXJMb2NhdGlvbiA9IGJhdGNoLmJhY2tncm91bmRCYXRjaDtcclxuICAgICAgICBkZWxldGUgYmF0Y2guYmFja2dyb3VuZEJhdGNoOyAvLyB0aGlzIHByb3BlcnR5IGlzIG5vdCByZXF1aXJlZCBpbiBtYWluIHRocmVhZCwgc2F2ZSBzb21lIHNlcmlhbGl6YXRpb24gZWZmb3J0c1xyXG4gICAgICAgIHlpZWxkIHtcclxuICAgICAgICAgICAgYmFja2dyb3VuZEJ1ZmZlckxvY2F0aW9uLFxyXG4gICAgICAgICAgICBidWZmZXJMb2NhdGlvbjogYmF0Y2gsXHJcbiAgICAgICAgICAgIHN0eWxlczogW11cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldE9iamVjdFJlcXVlc3RJZChvYmplY3RJZCwgcmVxdWVzdElkKSB7XHJcbiAgICByZXR1cm4gW29iamVjdElkLCByZXF1ZXN0SWRdLmpvaW4oJy0nKTtcclxufVxyXG5jb25zdCBFTVBUWV9MQUJFTFNfUkVTUE9OU0UgPSB7XHJcbiAgICB0eXBlOiBUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZS5MQUJFTFNfUkVTUE9OU0UsXHJcbiAgICB0aWxlOiB7IHg6IDAsIHk6IDAsIHpvb206IDAgfSxcclxuICAgIHBvaW50TGFiZWxQYWdlczogW10sXHJcbiAgICBwb2ludExhYmVsQmFja2dyb3VuZFBhZ2VzOiBbXSxcclxuICAgIGN1cnZlZExhYmVsUGFnZXM6IFtdLFxyXG4gICAgcG9pbnRMYWJlbHM6IFtdLFxyXG4gICAgY3VydmVkTGFiZWxzOiBbXVxyXG59O1xyXG4vLyBUaWxlIHBhcnNpbmcgcHJpb3JpdHkgaXMgYWx3YXlzIG5vbi1uZWdhdGl2ZSwgc28gdG8gbWFrZSBzdXJlIHRoZXkncmUgcHJvY2Vzc2VkXHJcbi8vIGJlZm9yZSBhbnl0aGluZyBlbHNlLCBvdGhlciBwcmlvcml0aWVzIGFyZSBsZXNzIHRoYW4gMC5cclxuY29uc3QgTUVTSF9QQVJTRV9QUklPUklUWSA9IC0yO1xyXG5jbGFzcyBUaWxlUHJvdmlkZXJXb3JrZXIgZXh0ZW5kcyBXZWJXb3JrZXJJbXBsZW1lbnRhdGlvbiB7XHJcbiAgICBjb25zdHJ1Y3RvcihhZGRyZXNzZWUpIHtcclxuICAgICAgICBzdXBlcihhZGRyZXNzZWUpO1xyXG4gICAgICAgIHRoaXMuX3Rhc2tRdWV1ZSA9IG5ldyBUYXNrUXVldWUoKTtcclxuICAgICAgICB0aGlzLl9taW5vclRhc2tRdWV1ZSA9IG5ldyBUYXNrUXVldWUoKTtcclxuICAgICAgICB0aGlzLl90aWxlVXJsVGVtcGxhdGUgPSAnJztcclxuICAgICAgICB0aGlzLl9mb250UmVnaXN0cnkgPSBuZXcgRGZGb250UmVnaXN0cnkoKTtcclxuICAgICAgICB0aGlzLl9hdGxhcyA9IG5ldyBEZkdseXBoQXRsYXNBbGxvY2F0b3IoMjA0OCwgMjA0OCk7XHJcbiAgICAgICAgdGhpcy5fZ2x5cGhzRGVsaXZlcnlNYW5hZ2VyID0gbmV3IEFwaUdseXBoc0RlbGl2ZXJ5TWFuYWdlcih0aGlzLl9mb250UmVnaXN0cnksIHRoaXMuX2F0bGFzKTtcclxuICAgICAgICB0aGlzLl90aWxlUmVxdWVzdHMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5fbWVzaFJlcXVlc3RzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuX3Rhc2tRdWV1ZS5vbkVtcHR5LmFkZExpc3RlbmVyKCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKGFsbE9mSXRlcmFibGUodGhpcy5fdGlsZVJlcXVlc3RzLnZhbHVlcygpLCAoeyB0aWxlIH0pID0+ICF0aWxlLmlzVmlzaWJsZSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21pbm9yVGFza1F1ZXVlLnVuZnJlZXplKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLm9uKFRpbGVQcm92aWRlck1lc3NhZ2VUeXBlLklOSVQsIHRoaXMuX29uSW5pdC5iaW5kKHRoaXMpKTtcclxuICAgICAgICB0aGlzLm9uKFRpbGVQcm92aWRlck1lc3NhZ2VUeXBlLlRJTEVfVVJMX1VQREFURSwgdGhpcy5fb25UaWxlVXJsVXBkYXRlLmJpbmQodGhpcykpO1xyXG4gICAgICAgIHRoaXMub24oVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGUuVElMRV9SRVFVRVNUX0JBVENILCB0aGlzLl9vblRpbGVSZXF1ZXN0QmF0Y2guYmluZCh0aGlzKSk7XHJcbiAgICAgICAgdGhpcy5vbihUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZS5USUxFX1JFUVVFU1RfQ0FOQ0VMX0JBVENILCB0aGlzLl9vblRpbGVSZXF1ZXN0Q2FuY2VsQmF0Y2guYmluZCh0aGlzKSk7XHJcbiAgICAgICAgdGhpcy5vbihUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZS5NRVNIX1JFUVVFU1QsIHRoaXMuX29uTWVzaFJlcXVlc3QuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgdGhpcy5vbihUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZS5NRVNIX1JFUVVFU1RfQ0FOQ0VMLCB0aGlzLl9vbk1lc2hSZXF1ZXN0Q2FuY2VsLmJpbmQodGhpcykpO1xyXG4gICAgICAgIHRoaXMuc2V0VHJhbnNmZXJhYmxlRXh0cmFjdG9yKFRpbGVQcm92aWRlck1lc3NhZ2VUeXBlLlRJTEVfUkVTUE9OU0UsIHRpbGVUcmFuc2ZlcmFibGVFeHRyYWN0b3IpO1xyXG4gICAgICAgIHRoaXMuc2V0VHJhbnNmZXJhYmxlRXh0cmFjdG9yKFRpbGVQcm92aWRlck1lc3NhZ2VUeXBlLkdFT01FVFJZX1JFU1BPTlNFLCBnZW9tZXRyeVRyYW5zZmVyYWJsZUV4dHJhY3Rvcik7XHJcbiAgICAgICAgdGhpcy5zZXRUcmFuc2ZlcmFibGVFeHRyYWN0b3IoVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGUuTUVTSF9SRVNQT05TRSwgbWVzaFRyYW5zZmVyYWJsZUV4dHJhY3Rvcik7XHJcbiAgICAgICAgdGhpcy5zZXRUcmFuc2ZlcmFibGVFeHRyYWN0b3IoVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGUuTEFCRUxTX1JFU1BPTlNFLCBsYWJlbFRyYW5zZmVyYWJsZUV4dHJhY3Rvcik7XHJcbiAgICB9XHJcbiAgICBfb25Jbml0KG1lc3NhZ2UpIHtcclxuICAgICAgICB0aGlzLl90aWxlVXJsVGVtcGxhdGUgPSBtZXNzYWdlLnRpbGVVcmxUZW1wbGF0ZTtcclxuICAgICAgICB0aGlzLl9tZXNoVXJsVGVtcGxhdGUgPSBtZXNzYWdlLm1lc2hVcmxUZW1wbGF0ZTtcclxuICAgICAgICB0aGlzLl9nbHlwaHNEZWxpdmVyeU1hbmFnZXIuZ2x5cGhSYW5nZVVybFRlbXBsYXRlID0gbWVzc2FnZS5nbHlwaFJhbmdlVXJsVGVtcGxhdGU7XHJcbiAgICB9XHJcbiAgICBfb25UaWxlVXJsVXBkYXRlKG1lc3NhZ2UpIHtcclxuICAgICAgICB0aGlzLl90aWxlVXJsVGVtcGxhdGUgPSBtZXNzYWdlLnRpbGVVcmxUZW1wbGF0ZTtcclxuICAgIH1cclxuICAgIF9vblRpbGVSZXF1ZXN0QmF0Y2gocmVxdWVzdCkge1xyXG4gICAgICAgIC8vIFJlcXVlc3QgaGlnaGVyIHByaW9yaXR5IHRpbGVzIGZpcnN0XHJcbiAgICAgICAgcmVxdWVzdC5yZXF1ZXN0cy5zb3J0KChhLCBiKSA9PiBiLnByaW9yaXR5IC0gYS5wcmlvcml0eSk7XHJcbiAgICAgICAgZm9yIChjb25zdCB0aWxlIG9mIHJlcXVlc3QucmVxdWVzdHMpIHtcclxuICAgICAgICAgICAgY29uc3QgdGlsZVVybCA9IHRoaXMuX3RpbGVVcmxUZW1wbGF0ZVxyXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoJ3t7aG9zdEFsaWFzfX0nLCBnZXRIb3N0QWxpYXNCeVVpZChnZXRUaWxlSWQodGlsZSkpKVxyXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoJ3t7eH19JywgdGlsZS54LnRvU3RyaW5nKCkpXHJcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgne3t5fX0nLCB0aWxlLnkudG9TdHJpbmcoKSlcclxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKCd7e3p9fScsIHRpbGUuem9vbS50b1N0cmluZygpKVxyXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoJ3t7em1pbn19JywgdGlsZS56b29tTWluLnRvU3RyaW5nKCkpXHJcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgne3t6bWF4fX0nLCB0aWxlLnpvb21NYXgudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgIGlmICghdGlsZVVybCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHRpbGVJZCA9IGdldFRpbGVJZCh0aWxlKTtcclxuICAgICAgICAgICAgY29uc3QgdGlsZVJlcXVlc3QgPSBuZXcgQmluYXJ5SHR0cFJlcXVlc3QodGlsZVVybCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RJZCA9IHJlcXVlc3QucmVxdWVzdElkO1xyXG4gICAgICAgICAgICBjb25zdCB0aWxlUmVxdWVzdElkID0gZ2V0T2JqZWN0UmVxdWVzdElkKHRpbGVJZCwgcmVxdWVzdElkKTtcclxuICAgICAgICAgICAgdGlsZVJlcXVlc3Quc2VuZCgpLnRoZW4oKGJ1ZmZlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGFza1F1ZXVlID0gdGlsZS5pc1Zpc2libGUgPyB0aGlzLl90YXNrUXVldWUgOiB0aGlzLl9taW5vclRhc2tRdWV1ZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0YXNrUXVldWUuZW5xdWV1ZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZTogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiB0aWxlIHdhcyBub3QgY2FuY2VsZWQgYmVmb3JlIHByb2Nlc3NpbmdcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3RpbGVSZXF1ZXN0cy5oYXModGlsZVJlcXVlc3RJZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlY29kZWRUaWxlID0gVGlsZS5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleHRyYWN0TGFiZWxzUHJvbWlzZSA9IHRoaXMuX2V4dHJhY3RMYWJlbHModGlsZSwgZGVjb2RlZFRpbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2VvbWV0cnlSZXNwb25zZSA9IHRoaXMuX2NvbXB1dGVHZW9tZXRyeVJlc3BvbnNlKHRpbGUsIGRlY29kZWRUaWxlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhY3RMYWJlbHNQcm9taXNlLnRoZW4oKGxhYmVsc1Jlc3BvbnNlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW5kTWVzc2FnZShPYmplY3QuYXNzaWduKHt9LCAobGFiZWxzUmVzcG9uc2UgfHwgRU1QVFlfTEFCRUxTX1JFU1BPTlNFKSwgZ2VvbWV0cnlSZXNwb25zZSwgeyB0eXBlOiBUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZS5USUxFX1JFU1BPTlNFLCB0aWxlLCB1cmw6IHRpbGVVcmwsIHJlcXVlc3RJZDogcmVxdWVzdC5yZXF1ZXN0SWQsIHBhcnNlVGltZTogZ2VvbWV0cnlSZXNwb25zZS5wYXJzZVRpbWUgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxhYmVsc1Jlc3BvbnNlID8gbGFiZWxzUmVzcG9uc2UucGFyc2VUaW1lIDogMCkgfSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90aWxlUmVxdWVzdHMuZGVsZXRlKHRpbGVSZXF1ZXN0SWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBwcmlvcml0eTogdGlsZS5wcmlvcml0eVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0sIChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIGxvYWQgYW5kIHBhcnNlIHRpbGUgKCR7dGlsZS54fSwke3RpbGUueX0sJHt0aWxlLnpvb219KTogJHtlcnJvcn1gKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VuZE1lc3NhZ2Uoe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFRpbGVQcm92aWRlck1lc3NhZ2VUeXBlLlRJTEVfRVJST1IsXHJcbiAgICAgICAgICAgICAgICAgICAgdGlsZSxcclxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SWQ6IHJlcXVlc3QucmVxdWVzdElkXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RpbGVSZXF1ZXN0cy5kZWxldGUodGlsZVJlcXVlc3RJZCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLl90aWxlUmVxdWVzdHMuc2V0KHRpbGVSZXF1ZXN0SWQsIHtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHRpbGVSZXF1ZXN0LFxyXG4gICAgICAgICAgICAgICAgdGlsZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKHRpbGUuaXNWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9taW5vclRhc2tRdWV1ZS5mcmVlemUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9vblRpbGVSZXF1ZXN0Q2FuY2VsQmF0Y2gobWVzc2FnZSkge1xyXG4gICAgICAgIGZvciAoY29uc3QgcmVxdWVzdCBvZiBtZXNzYWdlLnJlcXVlc3RzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlkID0gZ2V0VGlsZUlkKHJlcXVlc3QudGlsZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRpbGVSZXF1ZXN0SWQgPSBnZXRPYmplY3RSZXF1ZXN0SWQoaWQsIHJlcXVlc3QucmVxdWVzdElkKTtcclxuICAgICAgICAgICAgY29uc3QgdGlsZVJlcXVlc3QgPSB0aGlzLl90aWxlUmVxdWVzdHMuZ2V0KHRpbGVSZXF1ZXN0SWQpO1xyXG4gICAgICAgICAgICBpZiAodGlsZVJlcXVlc3QpIHtcclxuICAgICAgICAgICAgICAgIHRpbGVSZXF1ZXN0LnJlcXVlc3QuY2FuY2VsKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90aWxlUmVxdWVzdHMuZGVsZXRlKHRpbGVSZXF1ZXN0SWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX29uTWVzaFJlcXVlc3QocmVxdWVzdCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fbWVzaFVybFRlbXBsYXRlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbWVzaCA9IHJlcXVlc3QubWVzaDtcclxuICAgICAgICBjb25zdCBtZXNoUmVxdWVzdElkID0gbWVzaC5vYmplY3RJZDtcclxuICAgICAgICBjb25zdCBtZXNoUmVxdWVzdCA9IG5ldyBCaW5hcnlIdHRwUmVxdWVzdCh0aGlzLl9tZXNoVXJsVGVtcGxhdGVcclxuICAgICAgICAgICAgLnJlcGxhY2UoJ3t7aG9zdEFsaWFzfX0nLCBnZXRIb3N0QWxpYXNCeVVpZChtZXNoLm1lc2hJZCkpXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHtcXHtpZFxcfVxcfS9nLCBtZXNoLm1lc2hJZCkpO1xyXG4gICAgICAgIHRoaXMuX21lc2hSZXF1ZXN0cy5zZXQobWVzaFJlcXVlc3RJZCwgbWVzaFJlcXVlc3QpO1xyXG4gICAgICAgIG1lc2hSZXF1ZXN0LnNlbmQoKS50aGVuKChidWZmZXIpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21pbm9yVGFza1F1ZXVlLmVucXVldWUoe1xyXG4gICAgICAgICAgICAgICAgZXhlY3V0ZTogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIG1lc2ggd2FzIG5vdCBjYW5jZWxlZCBiZWZvcmUgcHJvY2Vzc2luZ1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tZXNoUmVxdWVzdHMuaGFzKG1lc2hSZXF1ZXN0SWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdyaXRlciA9IG5ldyBUcmltZXNoUG9seWdvbkJ1ZmZlcldyaXRlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNoID0gcmVxdWVzdC5tZXNoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2NhdGlvbiA9IHdyaXRlci53cml0ZU1vZGVsKGJ1ZmZlciwgbWVzaCwgbWVzaC5jb2xvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzcG9uZChyZXF1ZXN0LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZS5NRVNIX1JFU1BPTlNFLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZXM6IHdyaXRlci5nZXRCdWZmZXJzKCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SWQ6IHJlcXVlc3QucmVxdWVzdElkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21lc2hSZXF1ZXN0cy5kZWxldGUobWVzaFJlcXVlc3RJZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHByaW9yaXR5OiBNRVNIX1BBUlNFX1BSSU9SSVRZXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pLmNhdGNoKChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gbG9hZCBhbmQgcGFyc2UgbWVzaDogJHtlcnJvcn1gKTtcclxuICAgICAgICAgICAgdGhpcy5yZXNwb25kKHJlcXVlc3QsIHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IFRpbGVQcm92aWRlck1lc3NhZ2VUeXBlLk1FU0hfRVJST1IsXHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0SWQ6IHJlcXVlc3QucmVxdWVzdElkXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLl9tZXNoUmVxdWVzdHMuZGVsZXRlKG1lc2hSZXF1ZXN0SWQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX29uTWVzaFJlcXVlc3RDYW5jZWwocmVxdWVzdCkge1xyXG4gICAgICAgIGNvbnN0IG1lc2ggPSByZXF1ZXN0Lm1lc2g7XHJcbiAgICAgICAgY29uc3QgbWVzaFJlcXVlc3RJZCA9IG1lc2gub2JqZWN0SWQ7XHJcbiAgICAgICAgY29uc3QgbWVzaFJlcXVlc3QgPSB0aGlzLl9tZXNoUmVxdWVzdHMuZ2V0KG1lc2hSZXF1ZXN0SWQpO1xyXG4gICAgICAgIGlmIChtZXNoUmVxdWVzdCkge1xyXG4gICAgICAgICAgICBtZXNoUmVxdWVzdC5jYW5jZWwoKTtcclxuICAgICAgICAgICAgdGhpcy5fbWVzaFJlcXVlc3RzLmRlbGV0ZShtZXNoUmVxdWVzdElkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfY29tcHV0ZUdlb21ldHJ5UmVzcG9uc2UodGlsZSwgZGVjb2RlZFRpbGUpIHtcclxuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgICBjb25zdCBtaW5ab29tID0gdGlsZS56b29tO1xyXG4gICAgICAgIGNvbnN0IG1heFpvb20gPSB0aWxlLnpvb207XHJcbiAgICAgICAgLy8gUGFyc2UgcG9seWdvbnMgZnJvbSB0aGUgdGlsZS5cclxuICAgICAgICBjb25zdCBwb2x5Z29ucyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IHRyYW5zcGFyZW50UG9seWdvbnMgPSBbXTtcclxuICAgICAgICBjb25zdCB0ZXh0dXJlZFBvbHlnb25zID0gW107XHJcbiAgICAgICAgY29uc3QgbWVzaGVzID0gW107XHJcbiAgICAgICAgY29uc3QgZXh0ZXJuYWxNZXNoZXMgPSBbXTtcclxuICAgICAgICBjb25zdCBwb2x5Z29uV3JpdGVyID0gbmV3IFBvbHlnb25CdWZmZXJXcml0ZXIoKTtcclxuICAgICAgICBjb25zdCB0cmFuc3BhcmVudFBvbHlnb25Xcml0ZXIgPSBuZXcgUG9seWdvbkJ1ZmZlcldyaXRlcigpO1xyXG4gICAgICAgIGNvbnN0IHRleHR1cmVkUG9seWdvbldyaXRlciA9IG5ldyBUZXh0dXJlZFBvbHlnb25CdWZmZXJXcml0ZXIoKTtcclxuICAgICAgICBjb25zdCBleHRydWRlZFBvbHlnb25Xcml0ZXIgPSBuZXcgRXh0cnVkZWRQb2x5Z29uQnVmZmVyV3JpdGVyKCk7XHJcbiAgICAgICAgY29uc3QgZXh0cmFjdGVkUG9seWdvbnMgPSBmaWx0ZXJJdGVyYWJsZShleHRyYWN0UG9seWdvbnModGlsZSwgZGVjb2RlZFRpbGUsIG1pblpvb20sIG1heFpvb20pLCBmaWx0ZXJPdXRVbnN0eWxlZFByaW1pdGl2ZXMpO1xyXG4gICAgICAgIGZvciAoY29uc3QgcG9seWdvbiBvZiBleHRyYWN0ZWRQb2x5Z29ucykge1xyXG4gICAgICAgICAgICBpZiAocG9seWdvbi5oZWlnaHQgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0eWxlID0gcG9seWdvbi5zdHlsZXNbMF07XHJcbiAgICAgICAgICAgICAgICBpZiAoc3R5bGUucGF0dGVybikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmVkUG9seWdvbnMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlckxvY2F0aW9uOiB0ZXh0dXJlZFBvbHlnb25Xcml0ZXIud3JpdGVQb2x5Z29uKHBvbHlnb24sIEVNUFRZLCBzdHlsZS56SW5kZXgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXM6IHBvbHlnb24uc3R5bGVzXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjb2xvci5pc09wYXF1ZShzdHlsZS5jb2xvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb2x5Z29ucy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyTG9jYXRpb246IHBvbHlnb25Xcml0ZXIud3JpdGVQb2x5Z29uKHBvbHlnb24sIHN0eWxlLnpJbmRleCwgc3R5bGUuY29sb3IpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXM6IHBvbHlnb24uc3R5bGVzXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmFuc3BhcmVudFBvbHlnb25zLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJMb2NhdGlvbjogdHJhbnNwYXJlbnRQb2x5Z29uV3JpdGVyLndyaXRlUG9seWdvbihwb2x5Z29uLCBzdHlsZS56SW5kZXgsIHN0eWxlLmNvbG9yKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzOiBwb2x5Z29uLnN0eWxlc1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHBvbHlnb24uZXh0ZXJuYWxNZXNoKSB7XHJcbiAgICAgICAgICAgICAgICBleHRlcm5hbE1lc2hlcy5wdXNoKHBvbHlnb24uZXh0ZXJuYWxNZXNoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0eWxlID0gcG9seWdvbi5zdHlsZXNbMF07XHJcbiAgICAgICAgICAgICAgICBtZXNoZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyTG9jYXRpb246IGV4dHJ1ZGVkUG9seWdvbldyaXRlci53cml0ZVBvbHlnb24ocG9seWdvbiwgcG9seWdvbi5oZWlnaHQsIHN0eWxlLmNvbG9yKSxcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZXM6IHBvbHlnb24uc3R5bGVzXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBQYXJzZSBwb2x5bGluZXMgZnJvbSB0aGUgdGlsZS5cclxuICAgICAgICBjb25zdCBwb2x5bGluZVdyaXRlciA9IG5ldyBQb2x5bGluZUJ1ZmZlcldyaXRlcigpO1xyXG4gICAgICAgIGNvbnN0IHBvbHlsaW5lcyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IHRleHR1cmVkUG9seWxpbmVzID0gW107XHJcbiAgICAgICAgY29uc3QgZXh0cmFjdGVkUG9seWxpbmVzID0gcmVkdWNlSXRlcmFibGUoZmlsdGVySXRlcmFibGUoZXh0cmFjdFBvbHlsaW5lcyh0aWxlLCBkZWNvZGVkVGlsZSwgbWluWm9vbSwgbWF4Wm9vbSksIGZpbHRlck91dFVuc3R5bGVkUHJpbWl0aXZlcyksIChleHRyYWN0ZWRQb2x5bGluZXMsIHBvbHlsaW5lKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0eWxlID0gcG9seWxpbmUuc3R5bGVzWzBdO1xyXG4gICAgICAgICAgICBpZiAoc3R5bGUuaW5saW5lKSB7XHJcbiAgICAgICAgICAgICAgICBleHRyYWN0ZWRQb2x5bGluZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9seWxpbmUsXHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHN0eWxlLmlubGluZSxcclxuICAgICAgICAgICAgICAgICAgICB6SW5kZXg6IHN0eWxlLnpJbmRleCArIDAuMDFcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzdHlsZS5vdXRsaW5lKSB7XHJcbiAgICAgICAgICAgICAgICBleHRyYWN0ZWRQb2x5bGluZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9seWxpbmUsXHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHN0eWxlLm91dGxpbmUsXHJcbiAgICAgICAgICAgICAgICAgICAgekluZGV4OiBzdHlsZS56SW5kZXhcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBleHRyYWN0ZWRQb2x5bGluZXM7XHJcbiAgICAgICAgfSwgW10pO1xyXG4gICAgICAgIC8vIFdlIG5lZWQgdG8gc29ydCBwb2x5bGluZXMgc3RhYmx5IHRvIHByZXNlcnZlIGRyYXdpbmcgb3JkZXIgb2Ygb25lc1xyXG4gICAgICAgIC8vIHdpdGggZXF1YWwgeiBpbmRpY2VzLlxyXG4gICAgICAgIG1lcmdlU29ydChleHRyYWN0ZWRQb2x5bGluZXMsIChwMSwgcDIpID0+IHAxLnpJbmRleCAtIHAyLnpJbmRleCk7XHJcbiAgICAgICAgZm9yIChjb25zdCB7IHBvbHlsaW5lLCBzdHlsZSwgekluZGV4IH0gb2YgZXh0cmFjdGVkUG9seWxpbmVzKSB7XHJcbiAgICAgICAgICAgIGlmIChzdHlsZS5wYXR0ZXJuKSB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0dXJlZFBvbHlsaW5lcy5wdXNoKHBvbHlsaW5lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHBvbHlsaW5lcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBidWZmZXJMb2NhdGlvbjogcG9seWxpbmVXcml0ZXIud3JpdGVQb2x5bGluZShwb2x5bGluZSwgc3R5bGUsIHpJbmRleCksXHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzOiBwb2x5bGluZS5zdHlsZXNcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFBhcnNlIHBvaW50cyBmcm9tIHRoZSB0aWxlLlxyXG4gICAgICAgIGNvbnN0IHBvaW50cyA9IFtcclxuICAgICAgICAgICAgLi4uZmlsdGVySXRlcmFibGUoZXh0cmFjdFBvaW50cyh0aWxlLCBkZWNvZGVkVGlsZSwgbWluWm9vbSwgbWF4Wm9vbSksIGZpbHRlck91dFVuc3R5bGVkUHJpbWl0aXZlcylcclxuICAgICAgICBdO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFRpbGVQcm92aWRlck1lc3NhZ2VUeXBlLkdFT01FVFJZX1JFU1BPTlNFLFxyXG4gICAgICAgICAgICB0aWxlLFxyXG4gICAgICAgICAgICBwb2x5Z29uUGFnZXM6IHBvbHlnb25Xcml0ZXIuZ2V0QnVmZmVycygpLFxyXG4gICAgICAgICAgICBwb2x5Z29uczogWy4uLmJhdGNoUHJpbWl0aXZlRGVzY3JpcHRpb25zKHBvbHlnb25zKV0sXHJcbiAgICAgICAgICAgIHRyYW5zcGFyZW50UG9seWdvblBhZ2VzOiB0cmFuc3BhcmVudFBvbHlnb25Xcml0ZXIuZ2V0QnVmZmVycygpLFxyXG4gICAgICAgICAgICB0cmFuc3BhcmVudFBvbHlnb25zOiBbLi4uYmF0Y2hQcmltaXRpdmVEZXNjcmlwdGlvbnModHJhbnNwYXJlbnRQb2x5Z29ucyldLFxyXG4gICAgICAgICAgICB0ZXh0dXJlZFBvbHlnb25zLFxyXG4gICAgICAgICAgICB0ZXh0dXJlZFBvbHlnb25QYWdlczogdGV4dHVyZWRQb2x5Z29uV3JpdGVyLmdldEJ1ZmZlcnMoKSxcclxuICAgICAgICAgICAgbWVzaFBhZ2VzOiBleHRydWRlZFBvbHlnb25Xcml0ZXIuZ2V0QnVmZmVycygpLFxyXG4gICAgICAgICAgICBtZXNoZXM6IFsuLi5iYXRjaFByaW1pdGl2ZURlc2NyaXB0aW9ucyhtZXNoZXMpXSxcclxuICAgICAgICAgICAgZXh0ZXJuYWxNZXNoZXMsXHJcbiAgICAgICAgICAgIHBvbHlsaW5lUGFnZXM6IHBvbHlsaW5lV3JpdGVyLmdldEJ1ZmZlcnMoKSxcclxuICAgICAgICAgICAgcG9seWxpbmVzOiBbLi4uYmF0Y2hQcmltaXRpdmVEZXNjcmlwdGlvbnMocG9seWxpbmVzKV0sXHJcbiAgICAgICAgICAgIHRleHR1cmVkUG9seWxpbmVzLFxyXG4gICAgICAgICAgICBwb2ludHMsXHJcbiAgICAgICAgICAgIHBhcnNlVGltZTogcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydFRpbWVcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgX2V4dHJhY3RMYWJlbHModGlsZSwgZGVjb2RlZFRpbGUpIHtcclxuICAgICAgICBjb25zdCBtaW5ab29tID0gdGlsZS56b29tO1xyXG4gICAgICAgIGNvbnN0IG1heFpvb20gPSB0aWxlLnpvb207XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcclxuICAgICAgICAgICAgdGhpcy5fcHJlcGFyZUxhYmVscyhmaWx0ZXJJdGVyYWJsZShleHRyYWN0UG9pbnRMYWJlbHModGlsZSwgZGVjb2RlZFRpbGUsIG1pblpvb20sIG1heFpvb20pLCBmaWx0ZXJPdXRVbnN0eWxlZFByaW1pdGl2ZXMpKSxcclxuICAgICAgICAgICAgdGhpcy5fcHJlcGFyZUxhYmVscyhmaWx0ZXJJdGVyYWJsZShleHRyYWN0Q3VydmVkTGFiZWxzKHRpbGUsIGRlY29kZWRUaWxlLCBtaW5ab29tLCBtYXhab29tKSwgZmlsdGVyT3V0VW5zdHlsZWRQcmltaXRpdmVzKSlcclxuICAgICAgICBdKS50aGVuKChbcG9pbnRMYWJlbHMsIGN1cnZlZExhYmVsc10pID0+IHRoaXMuX2NvbXB1dGVMYWJlbHNSZXNwb25zZSh0aWxlLCBwb2ludExhYmVscywgY3VydmVkTGFiZWxzKSwgKGVycm9yKSA9PiBjb25zb2xlLmxvZygnVE9ETzogcmVzcG9uZCB3aXRoIGVycm9yJywgZXJyb3IpKTtcclxuICAgIH1cclxuICAgIF9wcmVwYXJlTGFiZWxzKGxhYmVscykge1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChtYXBJdGVyYWJsZShsYWJlbHMsIChsYWJlbCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgYWxsIHRoZSBnbHlwaHMgYXJlIG9uIGhhbmQgYmVmb3JlIGZvcm1pbmcgbGFiZWwgR1BVIGRhdGFcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZldGNoQWxsR2x5cGhzKGxhYmVsLnRleHRzLCBsYWJlbC5zdHlsZXMpLnRoZW4oKCkgPT4gKGxhYmVsKSk7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGZXRjaGVzIGFsbCB0aGUgcmVxdWlyZWQgYnkgdGV4dHMgZ2x5cGhzIGFzIGEgc2luZ2xlIFByb21pc2UuXHJcbiAgICAgKi9cclxuICAgIF9mZXRjaEFsbEdseXBocyh0ZXh0cywgc3R5bGVzKSB7XHJcbiAgICAgICAgY29uc3QgcmVxdWVzdHMgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IHRleHQgb2YgdGV4dHMpIHtcclxuICAgICAgICAgICAgY29uc3QgZ2x5cGhzID0gdGV4dC50ZXh0TGluZXMucmVkdWNlKChnbHlwaHMsIHRleHRMaW5lKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBnbHlwaHMucHVzaCguLi50ZXh0TGluZS5nbHlwaElkcyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2x5cGhzO1xyXG4gICAgICAgICAgICB9LCBbXSk7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qgem9vbVN0eWxlIG9mIHN0eWxlcykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB0ZXh0U3R5bGUgb2Ygem9vbVN0eWxlLnN0eWxlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RzLnB1c2godGhpcy5fZ2x5cGhzRGVsaXZlcnlNYW5hZ2VyLmZldGNoR2x5cGhzKHRleHRTdHlsZS5mb250SWQsIGdseXBocykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChyZXF1ZXN0cyk7XHJcbiAgICB9XHJcbiAgICBfY29tcHV0ZUxhYmVsc1Jlc3BvbnNlKHRpbGUsIHBhcnNlZFBvaW50TGFiZWxzID0gW10sIHBhcnNlZEN1cnZlZExhYmVscyA9IFtdKSB7XHJcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAgICAgY29uc3QgcG9pbnRMYWJlbFdyaXRlciA9IG5ldyBQb2ludExhYmVsQnVmZmVyV3JpdGVyKCk7XHJcbiAgICAgICAgY29uc3QgcG9pbnRMYWJlbEJhY2tncm91bmRXcml0ZXIgPSBuZXcgUmVjdGFuZ2xlQnVmZmVyV3JpdGVyKCk7XHJcbiAgICAgICAgY29uc3QgcG9pbnRMYWJlbHMgPSBBcnJheS5mcm9tKHBhcnNlZFBvaW50TGFiZWxzLCAobGFiZWwpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgc3R5bGUgPSBsYWJlbC5zdHlsZXNbMF07XHJcbiAgICAgICAgICAgIGNvbnN0IGxheW91dCA9IGxheW91dFBvaW50TGFiZWwobGFiZWwsIHN0eWxlLCB0aGlzLl9mb250UmVnaXN0cnkpO1xyXG4gICAgICAgICAgICBjb25zdCBpZCA9IGdldElkKCk7XHJcbiAgICAgICAgICAgIGxldCBiYWNrZ3JvdW5kQnVmZmVyTG9jYXRpb247XHJcbiAgICAgICAgICAgIGlmIChzdHlsZS5iYWNrZ3JvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBiYm94ID0gY2FsY3VsYXRlUG9pbnRMYWJlbEJCb3gobGF5b3V0LCBzdHlsZS5iYWNrZ3JvdW5kLnZlcnRpY2FsUGFkZGluZywgc3R5bGUuYmFja2dyb3VuZC5ob3Jpem9udGFsUGFkZGluZyk7XHJcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQnVmZmVyTG9jYXRpb24gPSBwb2ludExhYmVsQmFja2dyb3VuZFdyaXRlci53cml0ZVJlY3RhbmdsZShpZCwge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBsYWJlbC5hbmNob3JQb2ludFxyXG4gICAgICAgICAgICAgICAgfSwge1xyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBiYm94Lm1heFggLSBiYm94Lm1pblgsXHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBiYm94Lm1heFkgLSBiYm94Lm1pblksXHJcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB2ZWMyLmNyZWF0ZSgoYmJveC5tYXhYICsgYmJveC5taW5YKSAvIDIsIChiYm94Lm1heFkgKyBiYm94Lm1pblkpIC8gMiksXHJcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiBCQUNLR1JPVU5EX1JBRElVU19QWCxcclxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogc3R5bGUuYmFja2dyb3VuZC5jb2xvclxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRCdWZmZXJMb2NhdGlvbjogYmFja2dyb3VuZEJ1ZmZlckxvY2F0aW9uLFxyXG4gICAgICAgICAgICAgICAgYnVmZmVyTG9jYXRpb246IHBvaW50TGFiZWxXcml0ZXIud3JpdGVQb2ludExhYmVsKGlkLCBsYWJlbCwgc3R5bGUsIGxheW91dCwgdGhpcy5fYXRsYXMpLFxyXG4gICAgICAgICAgICAgICAgc3R5bGVzOiBsYWJlbC5zdHlsZXNcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBjdXJ2ZWRMYWJlbFdyaXRlciA9IG5ldyBDdXJ2ZWRMYWJlbEJ1ZmZlcldyaXRlcigpO1xyXG4gICAgICAgIGNvbnN0IGN1cnZlZExhYmVscyA9IEFycmF5LmZyb20ocGFyc2VkQ3VydmVkTGFiZWxzLCAobGFiZWwpID0+ICh7XHJcbiAgICAgICAgICAgIGJ1ZmZlckxvY2F0aW9uOiBjdXJ2ZWRMYWJlbFdyaXRlci53cml0ZUxhYmVsKGxhYmVsLCBsYWJlbC5zdHlsZXNbMF0sIHRoaXMuX2ZvbnRSZWdpc3RyeSwgdGhpcy5fYXRsYXMpLFxyXG4gICAgICAgICAgICBzdHlsZXM6IGxhYmVsLnN0eWxlc1xyXG4gICAgICAgIH0pKTtcclxuICAgICAgICBjb25zdCBpc0F0bGFzRGlydHkgPSB0aGlzLl9hdGxhcy5pc0RpcnR5O1xyXG4gICAgICAgIHRoaXMuX2F0bGFzLmlzRGlydHkgPSBmYWxzZTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiBUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZS5MQUJFTFNfUkVTUE9OU0UsXHJcbiAgICAgICAgICAgIHRpbGUsXHJcbiAgICAgICAgICAgIHBvaW50TGFiZWxQYWdlczogcG9pbnRMYWJlbFdyaXRlci5nZXRCdWZmZXJzKCksXHJcbiAgICAgICAgICAgIHBvaW50TGFiZWxCYWNrZ3JvdW5kUGFnZXM6IHBvaW50TGFiZWxCYWNrZ3JvdW5kV3JpdGVyLmdldEJ1ZmZlcnMoKSxcclxuICAgICAgICAgICAgY3VydmVkTGFiZWxQYWdlczogY3VydmVkTGFiZWxXcml0ZXIuZ2V0QnVmZmVycygpLFxyXG4gICAgICAgICAgICBwb2ludExhYmVsczogWy4uLmJhdGNoTGFiZWxzKHBvaW50TGFiZWxzKV0sXHJcbiAgICAgICAgICAgIGN1cnZlZExhYmVsczogWy4uLmJhdGNoUHJpbWl0aXZlRGVzY3JpcHRpb25zKGN1cnZlZExhYmVscyldLFxyXG4gICAgICAgICAgICBmb250UmVnaXN0cnlUb1VwZGF0ZTogaXNBdGxhc0RpcnR5ID8gdGhpcy5fZm9udFJlZ2lzdHJ5LmdldEFsbCgpLm1hcCgoZm9udCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICBpZDogZm9udC5pZCxcclxuICAgICAgICAgICAgICAgICAgICB4aGVpZ2h0OiBmb250LnhoZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiBmb250Lm1hcmdpbixcclxuICAgICAgICAgICAgICAgICAgICBnbHlwaHM6IGZvbnQuZ2V0QWxsR2x5cGhzKClcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0pIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICBnbHlwaEF0bGFzVG9VcGRhdGU6IGlzQXRsYXNEaXJ0eSA/IHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLl9hdGxhcy53aWR0aCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5fYXRsYXMuaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgZ2x5cGhMb2NhdGlvbnM6IHRoaXMuX2F0bGFzLmdldEFsbEdseXBoTG9jYXRpb25zKCksXHJcbiAgICAgICAgICAgICAgICBkYXRhOiB0aGlzLl9hdGxhcy5kYXRhXHJcbiAgICAgICAgICAgIH0gOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIHBhcnNlVGltZTogcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydFRpbWVcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbm5ldyBUaWxlUHJvdmlkZXJXb3JrZXIoc2VsZilcclxuICAgIC5ydW4oKTtcclxuIiwiLyoqXHJcbiAqIEJhc2UgaW50ZXJmYWNlIGZvciB3ZWJ3b3JrZXIgbWVzc2FnZXMsIGJvdGggaW5jb21pbmcgYW5kIG91dGdvaW5nIG9uZXMuXHJcbiAqXHJcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1RyYW5zZmVyYWJsZVxyXG4gKi9cclxuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnLi9ldmVudF9lbWl0dGVyJztcclxuaW1wb3J0IHsgdW5pcXVlSWQgfSBmcm9tICcuL3VuaXF1ZV9pZCc7XHJcbmNvbnN0IE1FU1NBR0VfQkFUQ0hfTUFYX1NJWkUgPSA1MDtcclxuY29uc3QgRkxVU0hfVElNRU9VVCA9IDUwO1xyXG4vLyBlYWNoIHN1YnNlcXVlbnQgbWVzc2FnZSBkZWJvdW5jZXMgcG9zdE1lc3NhZ2UgY2FsbCwgdGhhdCBjYW4gbGVhZCB0byBpbmZpbml0ZSBkZWxheSwgdGhpcyBjb25zdCBsaW1pdHMgaXRcclxuY29uc3QgTUFYX0ZMVVNIX1RJTUVPVVQgPSAyNTA7XHJcbmV4cG9ydCBjb25zdCBOT19JRCA9IC0xO1xyXG4vKipcclxuICogQ2hlY2tzIG1lc3NhZ2UgdHlwZSB3aXRoIHR5cGUgZ3VhcmRpbmcuIEl0IGdpdmVzIGEgbGl0dGxlIGJpdCBtb3JlIGVsZWdhbnQgYWx0ZXJuYXRpdmVcclxuICogdG8gdGFnZ2VkIHR5cGUgdW5pb25zIHByb3ZpZGluZyB0aGUgc2FtZSB0eXBlIHNhZmV0eS5cclxuICpcclxuICogQHBhcmFtIG1lc3NhZ2UgdG8gYmUgY2hlY2tlZFxyXG4gKiBAcGFyYW0gdHlwZSB0aGUgdmFsdWUgb2YgdGhlIFwidHlwZVwiIHByb3BlcnR5XHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbWVzc2FnZUlzKG1lc3NhZ2UsIHR5cGUpIHtcclxuICAgIHJldHVybiBtZXNzYWdlLnR5cGUgPT09IHR5cGU7XHJcbn1cclxuLyoqXHJcbiAqIEJhc2UgY2xhc3MgZm9yIGJvdGggc2lkZXMgb2YgYSB3ZWJ3b3JrZXI6IGl0cyBpbXBsZW1lbnRhdGlvbiAoc2VwYXJhdGUganMgdGhhdCBpcyBydW4gaW4gYSB3b3JrZXIgdGhyZWFkKSBhbmRcclxuICogYSBjb250cm9sbGVyIGZvciB0aGUgbWFpbiB0aHJlYWQuIFRoZXkgaGF2ZSBzaW1pbGFyIG1lY2hhbmlzbSBvZiBzZW5kaW5nL3JlY2VpdmluZyBtZXNzYWdlcyB0aGF0IGlzIGltcGxlbWVudCBoZXJlLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFdlYldvcmtlckNvbW11bmljYXRvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihhZGRyZXNzZWUpIHtcclxuICAgICAgICB0aGlzLl9hZGRyZXNzZWUgPSBhZGRyZXNzZWU7XHJcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLl90cmFuc2ZlcmFibGVFeHRyYWN0b3JzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuX21lc3NhZ2VzID0gW107XHJcbiAgICAgICAgdGhpcy5fdHJhbnNmZXJhYmxlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3RpbWVvdXRIYW5kbGUgPSAwO1xyXG4gICAgICAgIHRoaXMuX2ZsdXNoTWVzc2FnZXNCaW5kZWQgPSB0aGlzLl9mbHVzaE1lc3NhZ2VzLmJpbmQodGhpcyk7XHJcbiAgICB9XHJcbiAgICBzZXRUcmFuc2ZlcmFibGVFeHRyYWN0b3IodHlwZSwgZXh0cmFjdG9yKSB7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNmZXJhYmxlRXh0cmFjdG9ycy5zZXQodHlwZSwgZXh0cmFjdG9yKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2VuZCBhIG1lc3NhZ2UgdG8gdGhlIG9wcG9zaXRlIHNpZGUgb2YgdGhlIHdlYiB3b3JrZXIgY29tbXVuaWNhdGlvbiBjaGFubmVsLlxyXG4gICAgICogTWVzc2FnZXMgYXJlIGJhdGNoZWQgYnkgZGVsYXlpbmcgcG9zdE1lc3NhZ2UgY2FsbCB0byBncm91cCBtZXNzYWdlcyB0aGF0IGNvbWUgZHVyaW5nIHRoaXMgZGVsYXkgYW5kIG1pbmltaXplXHJcbiAgICAgKiB0aGUgbnVtYmVyIG9mIGludGVycHJvY2VzcyBjb21tdW5pY2F0aW9ucyB0aGF0IGJhZGx5IGFmZmVjdCBwZXJmb3JtYW5jZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSBNZXNzYWdlIHRvIGJlIHNlbnQuXHJcbiAgICAgKiBAcGFyYW0gdXJnZW5jeSBJTU1FRElBVEUgZm9yY2VzIG1lc3NhZ2UgdG8gYmUgc2VudCBpbW1lZGlhdGVseSAoc3luY2hyb25vdXMgY2FsbCkgd2l0aCBubyBiYXRjaGluZyBkZWxheSxcclxuICAgICAqICAgICAgICAgICAgICAgIERFRkFVTFQgZGVib3VuY2VzIHNlbmRpbmcgZm9yIGFub3RoZXIgRkxVU0hfVElNRU9VVC5cclxuICAgICAqL1xyXG4gICAgc2VuZE1lc3NhZ2UobWVzc2FnZSwgdXJnZW5jeSA9IDAgLyogREVGQVVMVCAqLykge1xyXG4gICAgICAgIGNvbnN0IHRyYW5zZmVyYWJsZUV4dHJhY3RvciA9IHRoaXMuX3RyYW5zZmVyYWJsZUV4dHJhY3RvcnMuZ2V0KG1lc3NhZ2UudHlwZSk7XHJcbiAgICAgICAgY29uc3QgdHJhbnNmZXJhYmxlcyA9IHRyYW5zZmVyYWJsZUV4dHJhY3RvciA/IHRyYW5zZmVyYWJsZUV4dHJhY3RvcihtZXNzYWdlKSA6IHVuZGVmaW5lZDtcclxuICAgICAgICBjb25zdCBpc0ZpcnN0TWVzc2FnZUluQmF0Y2ggPSAodGhpcy5fbWVzc2FnZXMubGVuZ3RoID09PSAwKTtcclxuICAgICAgICBpZiAoaXNGaXJzdE1lc3NhZ2VJbkJhdGNoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZpcnN0TWVzc2FnZVRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU2VuZCBtZXNzYWdlcyBhc3luY2hyb25vdXNseSBwYWNraW5nIHRoZW0gaW50byBvbmUgbWVzc2FnZS5cclxuICAgICAgICAvLyBXZSBkb24ndCB3YW50IHRvIGFidXNlIHRoZSB3ZWIgd29ya2VyIGNvbW11bmljYXRpb24gY2hhbm5lbCBhbmRcclxuICAgICAgICAvLyBzZW5kIG1lc3NhZ2VzIGFzeW5jaHJvbm91c2x5IGluIHNob3J0IHBlcmlvZCBvZiB0aW1lIG9yIG1hbnkgbWVzc2FnZXMgc3luY2hyb25vdXNseS5cclxuICAgICAgICB0aGlzLl9tZXNzYWdlcy5wdXNoKG1lc3NhZ2UpO1xyXG4gICAgICAgIGlmICh0cmFuc2ZlcmFibGVzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zZmVyYWJsZXMgPSB0aGlzLl90cmFuc2ZlcmFibGVzLmNvbmNhdCh0cmFuc2ZlcmFibGVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXRIYW5kbGUpO1xyXG4gICAgICAgIGlmICh0aGlzLl9tZXNzYWdlcy5sZW5ndGggPiBNRVNTQUdFX0JBVENIX01BWF9TSVpFIHx8XHJcbiAgICAgICAgICAgIHVyZ2VuY3kgPT09IDEgLyogSU1NRURJQVRFICovIHx8XHJcbiAgICAgICAgICAgICghaXNGaXJzdE1lc3NhZ2VJbkJhdGNoICYmIChwZXJmb3JtYW5jZS5ub3coKSAtIHRoaXMuX2ZpcnN0TWVzc2FnZVRpbWUpID4gTUFYX0ZMVVNIX1RJTUVPVVQpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZsdXNoTWVzc2FnZXMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RpbWVvdXRIYW5kbGUgPSBzZXRUaW1lb3V0KHRoaXMuX2ZsdXNoTWVzc2FnZXNCaW5kZWQsIEZMVVNIX1RJTUVPVVQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2VuZHMgcmVxdWVzdCBtZXNzYWdlIHRvL2Zyb20gd29ya2VyIGFzIHByb21pc2UsIHRoZSBvdGhlciBzaWRlIGNhbiByZXNwb25kIGFuZCB0aGUgcHJvbWlzZSBpcyByZXNvbHZlZC5cclxuICAgICAqIFJlcXVlc3QvcmVzcG9uc2UgaXMgc3luY2hyb25pemVkIGJ5IHRoZSByZXF1ZXN0SWQgZmllbGQuXHJcbiAgICAgKi9cclxuICAgIHJlcXVlc3QocmVxdWVzdCwgdXJnZW5jeSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0LnJlcXVlc3RJZCA9PT0gTk9fSUQpIHtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3QucmVxdWVzdElkID0gdW5pcXVlSWQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBsaXN0ZW5lciA9IChtZXNzYWdlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZUlzKG1lc3NhZ2UsIHJlcXVlc3QucmVzcG9uc2VUeXBlKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucmVxdWVzdElkID09PSByZXF1ZXN0LnJlcXVlc3RJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUobWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKGxpc3RlbmVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlSXMobWVzc2FnZSwgcmVxdWVzdC5lcnJvclR5cGUpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yZXF1ZXN0SWQgPT09IHJlcXVlc3QucmVxdWVzdElkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vZmYobGlzdGVuZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMuYWRkTGlzdGVuZXIobGlzdGVuZXIpO1xyXG4gICAgICAgICAgICB0aGlzLnNlbmRNZXNzYWdlKHJlcXVlc3QsIHVyZ2VuY3kpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNwb25kcyB0byBwcm92aWRlZCByZXF1ZXN0LlxyXG4gICAgICovXHJcbiAgICByZXNwb25kKHJlcXVlc3QsIHJlc3BvbnNlLCB1cmdlbmN5KSB7XHJcbiAgICAgICAgcmVzcG9uc2UucmVxdWVzdElkID0gcmVxdWVzdC5yZXF1ZXN0SWQ7XHJcbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZShyZXNwb25zZSwgdXJnZW5jeSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgYSBsaXN0ZW5lciB0byBzcGVjaWZpYyB0eXBlIG9mIGluY29taW5nIG1lc3NhZ2VzLlxyXG4gICAgICovXHJcbiAgICBvbih0eXBlLCBsaXN0ZW5lcikge1xyXG4gICAgICAgIGNvbnN0IHR5cGVTYWZlTGlzdGVuZXIgPSAobWVzc2FnZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAobWVzc2FnZUlzKG1lc3NhZ2UsIHR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcihtZXNzYWdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzLnNldChsaXN0ZW5lciwgdHlwZVNhZmVMaXN0ZW5lcik7XHJcbiAgICAgICAgdGhpcy5fZXZlbnRzLmFkZExpc3RlbmVyKHR5cGVTYWZlTGlzdGVuZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGluY29taW5nIG1lc3NhZ2VzIGxpc3RlbmVyLlxyXG4gICAgICovXHJcbiAgICBvZmYobGlzdGVuZXIpIHtcclxuICAgICAgICBjb25zdCB0eXBlU2FmZUxpc3RlbmVyID0gdGhpcy5fbGlzdGVuZXJzLmdldChsaXN0ZW5lcik7XHJcbiAgICAgICAgaWYgKHR5cGVTYWZlTGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKHR5cGVTYWZlTGlzdGVuZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3RhcnRzIGxpc3RlbmluZyBmb3IgaW5jb21pbmcgbWVzc2FnZXMuXHJcbiAgICAgKi9cclxuICAgIGxpc3RlbigpIHtcclxuICAgICAgICB0aGlzLl9hZGRyZXNzZWUub25tZXNzYWdlID0gKHsgZGF0YTogbWVzc2FnZXMgfSkgPT4ge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgbWVzc2FnZXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub25NZXNzYWdlKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlciBvZiBpbmNvbWluZyBtZXNzYWdlcy5cclxuICAgICAqL1xyXG4gICAgb25NZXNzYWdlKG1lc3NhZ2UpIHtcclxuICAgICAgICB0aGlzLl9ldmVudHMuZmlyZShtZXNzYWdlKTtcclxuICAgIH1cclxuICAgIF9mbHVzaE1lc3NhZ2VzKCkge1xyXG4gICAgICAgIHRoaXMuX2FkZHJlc3NlZS5wb3N0TWVzc2FnZSh0aGlzLl9tZXNzYWdlcywgdGhpcy5fdHJhbnNmZXJhYmxlcyk7XHJcbiAgICAgICAgdGhpcy5fbWVzc2FnZXMubGVuZ3RoID0gMDtcclxuICAgICAgICB0aGlzLl90cmFuc2ZlcmFibGVzLmxlbmd0aCA9IDA7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEJhc2UgY2xhc3MgZm9yIGEgd2Vid29ya2VyIGNvbnRyb2xsZXIgZm9yIHRoZSBtYWluIHRocmVhZCBjb2RlLlxyXG4gKiBJdCBhbHNvIHdyYXBzIGNyZWF0aW9uIG9mIGEgbmF0aXZlIFdvcmtlci5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBXZWJXb3JrZXJDbGllbnQgZXh0ZW5kcyBXZWJXb3JrZXJDb21tdW5pY2F0b3Ige1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gdXJsIFVSTCBvZiB3ZWJ3b3JrZXIncyBkZXBsb3llZCBqcyBmaWxlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHVybCkge1xyXG4gICAgICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIodXJsKTtcclxuICAgICAgICBzdXBlcih3b3JrZXIpO1xyXG4gICAgICAgIHRoaXMuX3dvcmtlciA9IHdvcmtlcjtcclxuICAgICAgICB0aGlzLmxpc3RlbigpO1xyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLl93b3JrZXIudGVybWluYXRlKCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEJhc2UgY2xhc3MgZm9yIGEgd2Vid29ya2VyIHRocmVhZCBpbXBsZW1lbnRhdGlvbi4gQ29uY3JldGUgY2xhc3Mgc2hvdWxkIGJlIHRoZSBlbnRyeSBwb2ludCBmb3IgYSB3ZWJ3b3JrZXIganMgYnVpbGQ6XHJcbiAqICAgICBuZXcgQ29uY3JldGVXZWJXb3JrZXJJbXBsZW1lbnRhdGlvbig8RGVkaWNhdGVkV29ya2VyR2xvYmFsU2NvcGU+c2VsZikucnVuKCk7XHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgV2ViV29ya2VySW1wbGVtZW50YXRpb24gZXh0ZW5kcyBXZWJXb3JrZXJDb21tdW5pY2F0b3Ige1xyXG4gICAgcnVuKCkge1xyXG4gICAgICAgIHRoaXMubGlzdGVuKCk7XHJcbiAgICB9XHJcbn1cclxuIiwiLyoqXHJcbiAqIFNpbXBsZSBwdWIvc3ViIGltcGxlbWVudGF0aW9uLiBUaGUgZW1pdHRlciBpcyBzdXBwb3NlZCB0byBlbWl0IG9ubHkgb25lIHR5cGUgb2YgZXZlbnQsXHJcbiAqIGlmIHNvbWVvbmUgaGFzIHRvIGVtaXQgZXZlbnRzIG9mIGRpZmZlcmVudCB0eXBlcywgbXVsdGlwbGUgZW1pdHRlcnMgc2hvdWxkIGJlIGNyZWF0ZWQuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgRXZlbnRFbWl0dGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IG5ldyBTZXQoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBsaXN0ZW5lci5cclxuICAgICAqL1xyXG4gICAgYWRkTGlzdGVuZXIobGlzdGVuZXIpIHtcclxuICAgICAgICB0aGlzLl9saXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBsaXN0ZW5lci5cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlTGlzdGVuZXIobGlzdGVuZXIpIHtcclxuICAgICAgICB0aGlzLl9saXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbHMgYWxsIHRoZSBhZGRlZCBsaXN0ZW5lcnMsIHRoZSBvcmRlciAoZS5nLiBvZiBhZGRpbmcpIGlzIG5vdCBndWFyYW50ZWVkLlxyXG4gICAgICovXHJcbiAgICBmaXJlKGRhdGEpIHtcclxuICAgICAgICB0aGlzLl9saXN0ZW5lcnMuZm9yRWFjaCgobGlzdGVuZXIpID0+IHtcclxuICAgICAgICAgICAgbGlzdGVuZXIoZGF0YSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEV2ZW50IGVtaXR0ZXIgd2l0aCBubyBwYXlsb2FkIGVtaXR0ZWQuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgVm9pZEV2ZW50RW1pdHRlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XHJcbiAgICBmaXJlKCkge1xyXG4gICAgICAgIHN1cGVyLmZpcmUodW5kZWZpbmVkKTtcclxuICAgIH1cclxufVxyXG4iLCJsZXQgaWQgPSAxO1xyXG4vKipcclxuICogR2VuZXJhdGVzIHVuaXF1ZSBpZFxyXG4qL1xyXG5leHBvcnQgZnVuY3Rpb24gdW5pcXVlSWQoKSB7XHJcbiAgICByZXR1cm4gaWQrKztcclxufVxyXG4iLCJpbXBvcnQgeyBleHRyYWN0VHJhbnNmZXJhYmxlcyB9IGZyb20gJy4vcHJpbWl0aXZlX3Byb3ZpZGVyX3dvcmtlcl9tZXNzYWdlcyc7XHJcbmV4cG9ydCB2YXIgVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGU7XHJcbihmdW5jdGlvbiAoVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGUpIHtcclxuICAgIFRpbGVQcm92aWRlck1lc3NhZ2VUeXBlW1RpbGVQcm92aWRlck1lc3NhZ2VUeXBlW1wiSU5JVFwiXSA9IDBdID0gXCJJTklUXCI7XHJcbiAgICBUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZVtUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZVtcIlRJTEVfVVJMX1VQREFURVwiXSA9IDFdID0gXCJUSUxFX1VSTF9VUERBVEVcIjtcclxuICAgIFRpbGVQcm92aWRlck1lc3NhZ2VUeXBlW1RpbGVQcm92aWRlck1lc3NhZ2VUeXBlW1wiVElMRV9SRVFVRVNUX0JBVENIXCJdID0gMl0gPSBcIlRJTEVfUkVRVUVTVF9CQVRDSFwiO1xyXG4gICAgVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGVbVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGVbXCJUSUxFX1JFUVVFU1RfQ0FOQ0VMX0JBVENIXCJdID0gM10gPSBcIlRJTEVfUkVRVUVTVF9DQU5DRUxfQkFUQ0hcIjtcclxuICAgIFRpbGVQcm92aWRlck1lc3NhZ2VUeXBlW1RpbGVQcm92aWRlck1lc3NhZ2VUeXBlW1wiVElMRV9SRVNQT05TRVwiXSA9IDRdID0gXCJUSUxFX1JFU1BPTlNFXCI7XHJcbiAgICBUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZVtUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZVtcIlRJTEVfRVJST1JcIl0gPSA1XSA9IFwiVElMRV9FUlJPUlwiO1xyXG4gICAgVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGVbVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGVbXCJHRU9NRVRSWV9SRVNQT05TRVwiXSA9IDZdID0gXCJHRU9NRVRSWV9SRVNQT05TRVwiO1xyXG4gICAgVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGVbVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGVbXCJMQUJFTFNfUkVTUE9OU0VcIl0gPSA3XSA9IFwiTEFCRUxTX1JFU1BPTlNFXCI7XHJcbiAgICBUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZVtUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZVtcIk1FU0hfUkVRVUVTVFwiXSA9IDhdID0gXCJNRVNIX1JFUVVFU1RcIjtcclxuICAgIFRpbGVQcm92aWRlck1lc3NhZ2VUeXBlW1RpbGVQcm92aWRlck1lc3NhZ2VUeXBlW1wiTUVTSF9SRVFVRVNUX0NBTkNFTFwiXSA9IDldID0gXCJNRVNIX1JFUVVFU1RfQ0FOQ0VMXCI7XHJcbiAgICBUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZVtUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZVtcIk1FU0hfUkVTUE9OU0VcIl0gPSAxMF0gPSBcIk1FU0hfUkVTUE9OU0VcIjtcclxuICAgIFRpbGVQcm92aWRlck1lc3NhZ2VUeXBlW1RpbGVQcm92aWRlck1lc3NhZ2VUeXBlW1wiTUVTSF9FUlJPUlwiXSA9IDExXSA9IFwiTUVTSF9FUlJPUlwiO1xyXG59KShUaWxlUHJvdmlkZXJNZXNzYWdlVHlwZSB8fCAoVGlsZVByb3ZpZGVyTWVzc2FnZVR5cGUgPSB7fSkpO1xyXG5leHBvcnQgY29uc3QgZ2VvbWV0cnlUcmFuc2ZlcmFibGVFeHRyYWN0b3IgPSBmdW5jdGlvbiAobWVzc2FnZSwgdHJhbnNmZXJhYmxlcyA9IFtdKSB7XHJcbiAgICBleHRyYWN0VHJhbnNmZXJhYmxlcyhtZXNzYWdlLnBvbHlnb25QYWdlcywgdHJhbnNmZXJhYmxlcyk7XHJcbiAgICBleHRyYWN0VHJhbnNmZXJhYmxlcyhtZXNzYWdlLnRyYW5zcGFyZW50UG9seWdvblBhZ2VzLCB0cmFuc2ZlcmFibGVzKTtcclxuICAgIGV4dHJhY3RUcmFuc2ZlcmFibGVzKG1lc3NhZ2UudGV4dHVyZWRQb2x5Z29uUGFnZXMsIHRyYW5zZmVyYWJsZXMpO1xyXG4gICAgZXh0cmFjdFRyYW5zZmVyYWJsZXMobWVzc2FnZS5tZXNoUGFnZXMsIHRyYW5zZmVyYWJsZXMpO1xyXG4gICAgZXh0cmFjdFRyYW5zZmVyYWJsZXMobWVzc2FnZS5wb2x5bGluZVBhZ2VzLCB0cmFuc2ZlcmFibGVzKTtcclxuICAgIHJldHVybiB0cmFuc2ZlcmFibGVzO1xyXG59O1xyXG5leHBvcnQgY29uc3QgbWVzaFRyYW5zZmVyYWJsZUV4dHJhY3RvciA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XHJcbiAgICBjb25zdCB0cmFuc2ZlcmFibGVzID0gW107XHJcbiAgICBleHRyYWN0VHJhbnNmZXJhYmxlcyhtZXNzYWdlLnBhZ2VzLCB0cmFuc2ZlcmFibGVzKTtcclxuICAgIHJldHVybiB0cmFuc2ZlcmFibGVzO1xyXG59O1xyXG5leHBvcnQgY29uc3QgbGFiZWxUcmFuc2ZlcmFibGVFeHRyYWN0b3IgPSBmdW5jdGlvbiAobWVzc2FnZSwgdHJhbnNmZXJhYmxlcyA9IFtdKSB7XHJcbiAgICBleHRyYWN0VHJhbnNmZXJhYmxlcyhtZXNzYWdlLnBvaW50TGFiZWxQYWdlcywgdHJhbnNmZXJhYmxlcyk7XHJcbiAgICBleHRyYWN0VHJhbnNmZXJhYmxlcyhtZXNzYWdlLnBvaW50TGFiZWxCYWNrZ3JvdW5kUGFnZXMsIHRyYW5zZmVyYWJsZXMpO1xyXG4gICAgZXh0cmFjdFRyYW5zZmVyYWJsZXMobWVzc2FnZS5jdXJ2ZWRMYWJlbFBhZ2VzLCB0cmFuc2ZlcmFibGVzKTtcclxuICAgIHJldHVybiB0cmFuc2ZlcmFibGVzO1xyXG59O1xyXG5leHBvcnQgY29uc3QgdGlsZVRyYW5zZmVyYWJsZUV4dHJhY3RvciA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XHJcbiAgICBjb25zdCB0cmFuc2ZlcmFibGVzID0gW107XHJcbiAgICBnZW9tZXRyeVRyYW5zZmVyYWJsZUV4dHJhY3RvcihtZXNzYWdlLCB0cmFuc2ZlcmFibGVzKTtcclxuICAgIGxhYmVsVHJhbnNmZXJhYmxlRXh0cmFjdG9yKG1lc3NhZ2UsIHRyYW5zZmVyYWJsZXMpO1xyXG4gICAgcmV0dXJuIHRyYW5zZmVyYWJsZXM7XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBFeHRyYWN0IEFycmF5QnVmZmVycyAodGhhdCBhcmUgdGFuc2ZlcmFibGUpIGZyb20gcGFnZXMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdFRyYW5zZmVyYWJsZXMocGFnZXMsIG91dHB1dCkge1xyXG4gICAgZm9yIChjb25zdCBwYWdlIG9mIHBhZ2VzKSB7XHJcbiAgICAgICAgb3V0cHV0LnB1c2gocGFnZS52ZXJ0ZXhCdWZmZXIuYnVmZmVyLCBwYWdlLmluZGV4QnVmZmVyLmJ1ZmZlcik7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IEZvbnRSZWdpc3RyeSBmcm9tICcuL2ZvbnRfcmVnaXN0cnknO1xyXG5pbXBvcnQgRGZGb250IGZyb20gJy4vZGZfZm9udCc7XHJcbi8qKlxyXG4gKiBSZWdpc3RyeSB0aGF0IHN0b3JlcyBkaXN0YW5jZSBmaWVsZCBmb250cy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERmRm9udFJlZ2lzdHJ5IGV4dGVuZHMgRm9udFJlZ2lzdHJ5IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKG5ldyBEZkZvbnQoJ1VOS05PV05fREZfRk9OVCcsIDE0LCAwKSk7XHJcbiAgICB9XHJcbn1cclxuIiwiLyoqXHJcbiAqIEEgY2VudHJhbCBzdG9yYWdlIG9mIGFsbCBhdmFpbGFibGUgZm9udHMuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGb250UmVnaXN0cnkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gdW5rbm93bkZvbnRJbnN0YW5jZSBBbiBpbnN0YW5jZSBvZiBzcGVjaWZpYyBmb250IHR5cGUgdG8gYmUgc2VydmVkIGFzIGEgc3R1YiB3aGVuIG5vbmV4aXN0ZW50IGZvbnRcclxuICAgICAqICAgICBpcyByZXF1ZXN0ZWQuIFJlcXVlc3Rpbmcgbm9uZXhpc3RlbnQgZm9udHMgbm9ybWFsbHkgc2hvdWxkIG5vdCBoYXBwZW4uXHJcbiAgICAgKiAgICAgVGhlIHN0dWIganVzdCBhbGxvd3MgdG8gYXZvaWQgdGVkaW91cyBudWxsIGNoZWNrcyBpbiByZWdpc3RyeSBjbGllbnRzLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcih1bmtub3duRm9udEluc3RhbmNlKSB7XHJcbiAgICAgICAgdGhpcy5fZm9udHMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5fdW5rbm93bkZvbnRJbnN0YW5jZSA9IHVua25vd25Gb250SW5zdGFuY2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gSWYgYSBmb250IHdpdGggc3BlY2lmaWVkIGlkIGlzIGluIHRoZSByZWdpc3RyeS5cclxuICAgICAqL1xyXG4gICAgY29udGFpbnMoZm9udElkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvbnRzLmhhcyhmb250SWQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIEZvbnQgd2l0aCBzcGVjaWZpZWQgaWQgb3IgdW5rbm93biBmb250IGluc3RhbmNlIGlmIGl0IGlzIG5vdCBmb3VuZC5cclxuICAgICAqL1xyXG4gICAgZ2V0KGZvbnRJZCkge1xyXG4gICAgICAgIGNvbnN0IGZvbnQgPSB0aGlzLl9mb250cy5nZXQoZm9udElkKTtcclxuICAgICAgICBpZiAoZm9udCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZm9udDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignV293LXdvdy13b3csIHNvbWV0aGluZyB3ZW50IHdyb25nLCB5b3Ugc2hvdWxkIG5vdCByZXF1ZXN0IG5vbmV4aXN0ZW50IGZvbnRzJyk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl91bmtub3duRm9udEluc3RhbmNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiBBbGwgc3RvcmVkIGZvbnRzLlxyXG4gICAgICovXHJcbiAgICBnZXRBbGwoKSB7XHJcbiAgICAgICAgcmV0dXJuIFsuLi50aGlzLl9mb250cy52YWx1ZXMoKV07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgbmV3IGZvciB0byB0aGUgcmVnaXN0cnkuXHJcbiAgICAgKi9cclxuICAgIGFkZChmb250KSB7XHJcbiAgICAgICAgdGhpcy5fZm9udHMuc2V0KGZvbnQuaWQsIGZvbnQpO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCBGb250IGZyb20gJy4vZm9udCc7XHJcbmNvbnN0IFVOS05PV05fR0xZUEggPSB7XHJcbiAgICBpZDogLTEsXHJcbiAgICB3aWR0aDogMCxcclxuICAgIGhlaWdodDogMCxcclxuICAgIGJlYXJpbmdYOiAwLFxyXG4gICAgYmVhcmluZ1k6IDAsXHJcbiAgICBhZHZhbmNlOiAxOFxyXG59O1xyXG4vKipcclxuICogRm9udCB3aG9zZSBnbHlwaHMgYXJlIHNwZWNpZmllZCBpbiBkaXN0YW5jZSBmaWVsZCBiaXRtYXBzLiBJdCdzIFwibWFyZ2luXCIgbWV0cmljIHNwZWNpZmllcyBnbHlwaCBiaXRtYXAgaW5uZXIgcGFkZGluZyxcclxuICogdGhhdCBpcyByZXF1aXJlZCB0byBmaXQgYSBcImJsdXJyZWRcIiBnbHlwaCBpbWFnZS4gVGhpcyBtYXJnaW4gc2hvdWxkIGJlIGNvbnNpZGVyZWQgZHVyaW5nIGxheW91dGluZyB0byBkcmF3IGdseXBocyBvZlxyXG4gKiBwcm9wZXIgc2l6ZXMuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZkZvbnQgZXh0ZW5kcyBGb250IHtcclxuICAgIGNvbnN0cnVjdG9yKGlkLCB4aGVpZ2h0LCBtYXJnaW4pIHtcclxuICAgICAgICBzdXBlcihpZCwgeGhlaWdodCwgVU5LTk9XTl9HTFlQSCk7XHJcbiAgICAgICAgdGhpcy5tYXJnaW4gPSBtYXJnaW47XHJcbiAgICB9XHJcbn1cclxuIiwiLyoqXHJcbiAqIEZvbnQgaXMganVzdCBhIGNvbGxlY3Rpb24gb2YgZ2x5cGggZGVzY3JpcHRpb25zLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRm9udCB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBpZCBGb250IGlkLlxyXG4gICAgICogQHBhcmFtIHhoZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgXCJ4XCIgY2hhciBpbiBhYnN0cmFjdCBwb2ludHMsIGluIGZhY3QgaXMgdXNlZCBhIHRoZSBmb250IHNpemUuXHJcbiAgICAgKiBAcGFyYW0gdW5rbm93bkdseXBoSW5zdGFuY2UgQW4gaW5zdGFuY2Ugb2YgZ2x5cGggdG8gYmUgc2VydmVkIGFzIGEgc3R1YiB3aGVuIG5vbmV4aXN0ZW50IGdseXBoXHJcbiAgICAgKiAgICAgaXMgcmVxdWVzdGVkLiBSZXF1ZXN0aW5nIG5vbmV4aXN0ZW50IGdseXBocyBub3JtYWxseSBzaG91bGQgbm90IGhhcHBlbi5cclxuICAgICAqICAgICBUaGUgc3R1YiBqdXN0IGFsbG93cyB0byBhdm9pZCB0ZWRpb3VzIG51bGwgY2hlY2tzIGluIGZvbnQgY2xpZW50cy5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoaWQsIHhoZWlnaHQsIHVua25vd25HbHlwaEluc3RhbmNlKSB7XHJcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG4gICAgICAgIHRoaXMueGhlaWdodCA9IHhoZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5fdW5rbm93bkdseXBoSW5zdGFuY2UgPSB1bmtub3duR2x5cGhJbnN0YW5jZTtcclxuICAgICAgICB0aGlzLl9nbHlwaHMgPSBuZXcgTWFwKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gR2x5cGggd2l0aCBzcGVjaWZpZWQgaWQgb3IgdW5rbm93biBnbHlwaCBpbnN0YW5jZS5cclxuICAgICAqL1xyXG4gICAgZ2V0R2x5cGgoZ2x5cGhJZCkge1xyXG4gICAgICAgIGNvbnN0IGdseXBoID0gdGhpcy5fZ2x5cGhzLmdldChnbHlwaElkKTtcclxuICAgICAgICBpZiAoZ2x5cGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdseXBoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdXb3ctd293LXdvdywgc29tZXRoaW5nIHdlbnQgd3JvbmcsIHlvdSBzaG91bGQgbm90IHJlcXVlc3Qgbm9uZXhpc3RlbnQgZ2x5cGhzJyk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl91bmtub3duR2x5cGhJbnN0YW5jZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIEFsbCBzdG9yZWQgZ2x5cGhzLlxyXG4gICAgICovXHJcbiAgICBnZXRBbGxHbHlwaHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIFsuLi50aGlzLl9nbHlwaHMudmFsdWVzKCldO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGdseXBoIGRlc2NyaXB0aW9uLlxyXG4gICAgICovXHJcbiAgICBhZGRHbHlwaChnbHlwaCkge1xyXG4gICAgICAgIHRoaXMuX2dseXBocy5zZXQoZ2x5cGguaWQsIGdseXBoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBnbHlwaCBkZXNjcmlwdGlvbnMgZnJvbSB0aGUgaXRlcmFibGUuXHJcbiAgICAgKi9cclxuICAgIGFkZEFsbEdseXBocyhnbHlwaHMpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGdseXBoIG9mIGdseXBocykge1xyXG4gICAgICAgICAgICB0aGlzLmFkZEdseXBoKGdseXBoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IERmR2x5cGhBdGxhcyBmcm9tICcuL2RmX2dseXBoX2F0bGFzJztcclxuLyoqXHJcbiAqIEdseXBoIGJpdG1hcCBhdGxhcy4gSXQgbWFuYWdlcyBhbGxvY2F0aW9uIG9zIHNlcGFyYXRlIGdseXBoIGJpdG1hcHMgaW4gb25lIGJpZyB0ZXh0dXJlLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGZHbHlwaEF0bGFzQWxsb2NhdG9yIGV4dGVuZHMgRGZHbHlwaEF0bGFzIHtcclxuICAgIGNvbnN0cnVjdG9yKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICBzdXBlcih3aWR0aCwgaGVpZ2h0LCBuZXcgVWludDhBcnJheSh3aWR0aCAqIGhlaWdodCksIG5ldyBNYXAoKSk7XHJcbiAgICAgICAgdGhpcy5pc0RpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudExpbmVQb3NpdGlvblggPSAwO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRMaW5lUG9zaXRpb25ZID0gMDtcclxuICAgICAgICB0aGlzLl9jdXJyZW50TGluZUhlaWdodCA9IDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFsbG9jYXRlcyBkaXN0YW5jZSBmaWVsZCBnbHlwaCBpbiBhdGxhcyB3aXRoIHNwZWNpZmllZCBwYWRkaW5nLlxyXG4gICAgICovXHJcbiAgICBhbGxvY2F0ZUdseXBoKGZvbnRJZCwgZ2x5cGgsIHBhZGRpbmcpIHtcclxuICAgICAgICBjb25zdCB3aWR0aCA9IGdseXBoLndpZHRoICsgcGFkZGluZyAqIDI7XHJcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gZ2x5cGguaGVpZ2h0ICsgcGFkZGluZyAqIDI7XHJcbiAgICAgICAgY29uc3QgbWF4Q3VycmVudExpbmVXaWR0aCA9IHRoaXMud2lkdGggLSB0aGlzLl9jdXJyZW50TGluZVBvc2l0aW9uWDtcclxuICAgICAgICBjb25zdCBtYXhDdXJyZW50TGluZUhlaWdodCA9IHRoaXMuaGVpZ2h0IC0gdGhpcy5fY3VycmVudExpbmVQb3NpdGlvblk7XHJcbiAgICAgICAgaWYgKHdpZHRoIDw9IG1heEN1cnJlbnRMaW5lV2lkdGggJiZcclxuICAgICAgICAgICAgaGVpZ2h0IDw9IG1heEN1cnJlbnRMaW5lSGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0ge1xyXG4gICAgICAgICAgICAgICAgbWluWDogdGhpcy5fY3VycmVudExpbmVQb3NpdGlvblgsXHJcbiAgICAgICAgICAgICAgICBtYXhYOiB0aGlzLl9jdXJyZW50TGluZVBvc2l0aW9uWCArIHdpZHRoLFxyXG4gICAgICAgICAgICAgICAgbWluWTogdGhpcy5fY3VycmVudExpbmVQb3NpdGlvblksXHJcbiAgICAgICAgICAgICAgICBtYXhZOiB0aGlzLl9jdXJyZW50TGluZVBvc2l0aW9uWSArIGhlaWdodFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50TGluZVBvc2l0aW9uWCArPSB3aWR0aDtcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudExpbmVIZWlnaHQgPSBNYXRoLm1heCh0aGlzLl9jdXJyZW50TGluZUhlaWdodCwgaGVpZ2h0KTtcclxuICAgICAgICAgICAgdGhpcy5fcHV0R2x5cGhCaXRtYXAoZm9udElkLCBnbHlwaCwgbG9jYXRpb24pO1xyXG4gICAgICAgICAgICByZXR1cm4gbG9jYXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBtYXhOZXh0TGluZUhlaWdodCA9IHRoaXMuaGVpZ2h0IC0gKHRoaXMuX2N1cnJlbnRMaW5lUG9zaXRpb25ZICsgdGhpcy5fY3VycmVudExpbmVIZWlnaHQpO1xyXG4gICAgICAgICAgICBpZiAod2lkdGggPD0gdGhpcy53aWR0aCAmJlxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0IDw9IG1heE5leHRMaW5lSGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50TGluZVBvc2l0aW9uWCA9IHdpZHRoO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudExpbmVQb3NpdGlvblkgKz0gdGhpcy5fY3VycmVudExpbmVIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50TGluZUhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIG1pblk6IHRoaXMuX2N1cnJlbnRMaW5lUG9zaXRpb25ZLFxyXG4gICAgICAgICAgICAgICAgICAgIG1heFk6IHRoaXMuX2N1cnJlbnRMaW5lUG9zaXRpb25ZICsgaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgIG1pblg6IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgbWF4WDogd2lkdGhcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wdXRHbHlwaEJpdG1hcChmb250SWQsIGdseXBoLCBsb2NhdGlvbik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYXRpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIHJvb20gYXZhaWxhYmxlJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFB1dHMgZ2x5cGgncyBiaXRtYXAgaW4gc3BlY2lmaWVkIHBvc2l0aW9uLlxyXG4gICAgICovXHJcbiAgICBfcHV0R2x5cGhCaXRtYXAoZm9udElkLCBnbHlwaCwgbG9jYXRpb24pIHtcclxuICAgICAgICBmb3IgKGxldCBhdGxhc1kgPSBsb2NhdGlvbi5taW5ZLCBnbHlwaFkgPSAwOyBhdGxhc1kgPCBsb2NhdGlvbi5tYXhZOyBhdGxhc1krKywgZ2x5cGhZKyspIHtcclxuICAgICAgICAgICAgY29uc3QgYXRsYXNSb3dPZmZzZXQgPSBhdGxhc1kgKiB0aGlzLndpZHRoO1xyXG4gICAgICAgICAgICBjb25zdCBnbHlwaFJvd09mZnNldCA9IGdseXBoWSAqIChsb2NhdGlvbi5tYXhYIC0gbG9jYXRpb24ubWluWCk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGF0bGFzWCA9IGxvY2F0aW9uLm1pblgsIGdseXBoWCA9IDA7IGF0bGFzWCA8IGxvY2F0aW9uLm1heFg7IGF0bGFzWCsrLCBnbHlwaFgrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhW2F0bGFzUm93T2Zmc2V0ICsgYXRsYXNYXSA9IGdseXBoLmJpdG1hcFtnbHlwaFJvd09mZnNldCArIGdseXBoWF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZ2x5cGhMb2NhdGlvbnMuc2V0KGZvbnRJZCArIGdseXBoLmlkLCBsb2NhdGlvbik7XHJcbiAgICAgICAgdGhpcy5pc0RpcnR5ID0gdHJ1ZTtcclxuICAgIH1cclxufVxyXG4iLCJjb25zdCBVTktOT1dOX0dMWVBIX0xPQ0FUSU9OID0ge1xyXG4gICAgbWluWDogMCxcclxuICAgIG1heFg6IDAsXHJcbiAgICBtaW5ZOiAwLFxyXG4gICAgbWF4WTogMFxyXG59O1xyXG4vKipcclxuICogQWJzdHJhY3QgZ2x5cGggYXRsYXMgaW50ZXJmYWNlLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGZHbHlwaEF0bGFzIHtcclxuICAgIGNvbnN0cnVjdG9yKHdpZHRoLCBoZWlnaHQsIGRhdGEsIGdseXBoTG9jYXRpb25zKSB7XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgdGhpcy5fZ2x5cGhMb2NhdGlvbnMgPSBnbHlwaExvY2F0aW9ucztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiBHbHlwaCBsb2NhdGlvbiBvciBmYWtlIGxvY2F0aW9uIHBvaW50aW5nIHRvIHRoZSBvcmlnaW4gKDAsIDApLlxyXG4gICAgICovXHJcbiAgICBnZXRHbHlwaExvY2F0aW9uKGZvbnRJZCwgZ2x5cGhJZCkge1xyXG4gICAgICAgIGNvbnN0IGdseXBoTG9jYXRpb24gPSB0aGlzLl9nbHlwaExvY2F0aW9ucy5nZXQoZm9udElkICsgZ2x5cGhJZCk7XHJcbiAgICAgICAgaWYgKGdseXBoTG9jYXRpb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdseXBoTG9jYXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1dvdy13b3ctd293LCBzb21ldGhpbmcgd2VudCB3cm9uZywgeW91IHNob3VsZCBub3QgcmVxdWVzdCBub25leGlzdGVudCBnbHlwaCBsb2NhdGlvbnMnKTtcclxuICAgICAgICAgICAgcmV0dXJuIFVOS05PV05fR0xZUEhfTE9DQVRJT047XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIEFsbCBnbHlwaCBsb2NhdGlvbnMgYXMgW2dseXBoIGlkLCBnbHlwaCBsb2NhdGlvbl0gYXJyYXkuIEdseXBoIGlkIGlzIGZvbnQgaWQgY29uY2F0ZW5hdGVkIHdpdGggZ2x5cGggaWQuXHJcbiAgICAgKi9cclxuICAgIGdldEFsbEdseXBoTG9jYXRpb25zKCkge1xyXG4gICAgICAgIHJldHVybiBbLi4udGhpcy5fZ2x5cGhMb2NhdGlvbnMuZW50cmllcygpXTtcclxuICAgIH1cclxufVxyXG4iLCIvKipcclxuICogQmFzZSBjbGFzcyBmb3IgSFRUUCByZXF1ZXN0IHdyYXBwZXJzLiBJdHMgbWFpbiBmdW5jdGlvbiBpcyB0byBzaW1wbGlmeSBBUEkgZm9yIEhUVFAgdmlhIHJlYXNvbmFibGUgYWJzdHJhY3Rpb24uXHJcbiAqL1xyXG5jbGFzcyBIdHRwUmVxdWVzdCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih1cmwsIHJlc3BvbnNlVHlwZSwgbWV0aG9kID0gJ0dFVCcpIHtcclxuICAgICAgICB0aGlzLl91cmwgPSB1cmw7XHJcbiAgICAgICAgdGhpcy5fbWV0aG9kID0gbWV0aG9kO1xyXG4gICAgICAgIHRoaXMuX3hociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgICAgIHRoaXMuX3hoci5yZXNwb25zZVR5cGUgPSByZXNwb25zZVR5cGU7XHJcbiAgICB9XHJcbiAgICBnZXQgaXNDYW5jZWxlZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5feGhyLnJlYWR5U3RhdGUgPT09IFhNTEh0dHBSZXF1ZXN0LkRPTkUgJiYgdGhpcy5feGhyLnN0YXR1cyA9PT0gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhdGVzIGFsbCB0aGUgbmV0d29ya2luZyBhY3Rpdml0aWVzLiBNdXN0IGJlIGNhbGxlZCBvbmx5IG9uY2UuXHJcbiAgICAgKi9cclxuICAgIHNlbmQoKSB7XHJcbiAgICAgICAgY29uc3QgeGhyID0gdGhpcy5feGhyO1xyXG4gICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSAhPT0gWE1MSHR0cFJlcXVlc3QuVU5TRU5UKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ2FscmVhZHkgc2VudCcpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgeGhyLm9wZW4odGhpcy5fbWV0aG9kLCB0aGlzLl91cmwpO1xyXG4gICAgICAgICAgICB4aHIub25sb2FkID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNDYW5jZWxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICgyMDAgPD0geGhyLnN0YXR1cyAmJiB4aHIuc3RhdHVzIDwgMzAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLl9wcmVwYXJlUmVzcG9uc2UoeGhyLnJlc3BvbnNlKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBGYWlsZWQgcmVxdWVzdDogJHt4aHIuc3RhdHVzfSAke3hoci5zdGF0dXNUZXh0fSwgJHt0aGlzLl91cmx9YCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLl94aHIub25lcnJvciA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYEZhaWxlZCByZXF1ZXN0OiAke3RoaXMuX3VybH1gKSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuX3hoci5zZW5kKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbmNlbHMgYWN0aXZlIHJlcXVlc3QgaWYgcG9zc2libGUsIGF0IGxlYXN0IHByb21pc2UgY2FsbGJhY2sgb2YgdGhlIHNlbmQoKSBtZXRob2RzIHdpbGwgbm90IGJlIGludm9rZWQuXHJcbiAgICAgKi9cclxuICAgIGNhbmNlbCgpIHtcclxuICAgICAgICBpZiAodGhpcy5feGhyLnJlYWR5U3RhdGUgIT09IFhNTEh0dHBSZXF1ZXN0LlVOU0VOVCAmJlxyXG4gICAgICAgICAgICAhdGhpcy5pc0NhbmNlbGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3hoci5hYm9ydCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogSFRUUCByZXF1ZXN0IHRoYXQgZ2V0cyBpdHMgcmVzcG9uc2UgYXMgYW4gQXJyYXlCdWZmZXIuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQmluYXJ5SHR0cFJlcXVlc3QgZXh0ZW5kcyBIdHRwUmVxdWVzdCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih1cmwsIG1ldGhvZCA9ICdHRVQnKSB7XHJcbiAgICAgICAgc3VwZXIodXJsLCAnYXJyYXlidWZmZXInLCBtZXRob2QpO1xyXG4gICAgfVxyXG4gICAgX3ByZXBhcmVSZXNwb25zZShyZXNwb25zZSkge1xyXG4gICAgICAgIGlmICghKHJlc3BvbnNlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXlCdWZmZXIoMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXNwb25zZTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBHbHlwaExpc3QgfSBmcm9tICcuL3Byb3RvX2FsaWFzZXMnO1xyXG5pbXBvcnQgRGZGb250IGZyb20gJy4uLy4uLy4uL2ZvbnQvZGZfZm9udCc7XHJcbmltcG9ydCBEZkdseXBoRGVsaXZlcnlNYW5hZ2VyIGZyb20gJy4uLy4uLy4uL2ZvbnQvZGZfZ2x5cGhfZGVsaXZlcnlfbWFuYWdlcic7XHJcbmltcG9ydCB7IGdldEhvc3RBbGlhc0J5VWlkIH0gZnJvbSAnLi4vdXRpbC9ob3N0cyc7XHJcbi8qKlxyXG4gKiBQcm92aWRlcyBnbHlwaHMgZnJvbSB0aGUgQVBJLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEFwaUdseXBoc0RlbGl2ZXJ5TWFuYWdlciBleHRlbmRzIERmR2x5cGhEZWxpdmVyeU1hbmFnZXIge1xyXG4gICAgY29uc3RydWN0b3IoZm9udFJlZ2lzdHJ5LCBhdGxhcykge1xyXG4gICAgICAgIHN1cGVyKGZvbnRSZWdpc3RyeSwgYXRsYXMpO1xyXG4gICAgICAgIHRoaXMuZ2x5cGhSYW5nZVVybFRlbXBsYXRlID0gJyc7XHJcbiAgICB9XHJcbiAgICBfZ2V0R2x5cGhSYW5nZShmb250SWQsIHN0YXJ0R2x5cGhJZCwgZW5kR2x5cGhJZCkge1xyXG4gICAgICAgIGNvbnN0IHVybCA9IHRoaXMuX2dldEdseXBoUmFuZ2VVcmwoZm9udElkLCBzdGFydEdseXBoSWQsIGVuZEdseXBoSWQpO1xyXG4gICAgICAgIGlmICghdXJsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoW10pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmV0Y2godXJsKVxyXG4gICAgICAgICAgICAudGhlbigocikgPT4gci5hcnJheUJ1ZmZlcigpKVxyXG4gICAgICAgICAgICAudGhlbigoYnVmZmVyKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gR2x5cGhMaXN0LmRlY29kZShuZXcgVWludDhBcnJheShidWZmZXIpKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2ZvbnRSZWdpc3RyeS5jb250YWlucyhmb250SWQpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmb250ID0gdGhpcy5fZm9udFJlZ2lzdHJ5LmdldChmb250SWQpO1xyXG4gICAgICAgICAgICAgICAgZm9udC54aGVpZ2h0ID0gcmVzcG9uc2UuZm9udC54aGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgZm9udC5tYXJnaW4gPSByZXNwb25zZS5mb250Lm1hcmdpbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ZvbnRSZWdpc3RyeS5hZGQobmV3IERmRm9udChmb250SWQsIHJlc3BvbnNlLmZvbnQueGhlaWdodCwgcmVzcG9uc2UuZm9udC5tYXJnaW4pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuZ2x5cGhzO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX2dldEdseXBoUmFuZ2VVcmwoZm9udElkLCBzdGFydEdseXBoSWQsIGVuZEdseXBoSWQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nbHlwaFJhbmdlVXJsVGVtcGxhdGVcclxuICAgICAgICAgICAgLnJlcGxhY2UoJ3t7aG9zdEFsaWFzfX0nLCBnZXRIb3N0QWxpYXNCeVVpZChmb250SWQpKVxyXG4gICAgICAgICAgICAucmVwbGFjZSgne3tmb250SWR9fScsIGZvbnRJZClcclxuICAgICAgICAgICAgLnJlcGxhY2UoJ3t7cmFuZ2V9fScsIGAke3N0YXJ0R2x5cGhJZH0sJHtlbmRHbHlwaElkfWApO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IHlhbmRleCB9IGZyb20gJy4vcHJvdG8nO1xyXG4vLyBUaGUgc29sZSBwdXJwb3NlIG9mIHRoaXMgbW9kdWxlIGlzIHRvIHByb3ZpZGUgc2hvcnRoYW5kcyB0byBtZXNzYWdlcyB1c2VkIGluXHJcbi8vIHRoZSBjb2RlYmFzZSB3aXRob3V0IHBvbGx1dGluZyB0aGUgcmVzdCBvZiBpdC5cclxuLy9cclxuLy8gTkI6IGBpbXBvcnRgIGtleXdvcmQgaGVyZSBiZWFycyBhIG1lYW5pbmcgdGhhdCdzIHNvbWV3aGF0IGRpZmZlcmVudCBmcm9tIHRoZVxyXG4vLyBFUyBtb2R1bGVzIG9uZS4gSXQncyBoZXJlIHRvIGNyZWF0ZSBhbiBhbGlhcyB0byBhIHN5bWJvbC4gSXQncyBuZWNlc3NhcnlcclxuLy8gYmVjYXVzZSB0aG9zZSBzeW1ib2xzIGFyZSBzaW11bHRhbmVvdXNseSB0eXBlcywgY2xhc3NlcyBhbmQgbmFtZXNwYWNlcyAodGh1cyxcclxuLy8gdXNpbmcgYGNvbnN0YCBhbmQgYHR5cGVgIGRvZXNuJ3QgY3V0IGl0KS5cclxuLy9cclxuLy8gU2VlIGh0dHBzOi8vd3d3LnR5cGVzY3JpcHRsYW5nLm9yZy9kb2NzL2hhbmRib29rL25hbWVzcGFjZXMuaHRtbCNhbGlhc2VzLlxyXG5leHBvcnQgdmFyIFByZXNlbnRhdGlvbiA9IHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb247XHJcbmV4cG9ydCB2YXIgVGlsZSA9IHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZTtcclxuZXhwb3J0IHZhciBHbHlwaExpc3QgPSB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5nbHlwaHMuR2x5cGhMaXN0O1xyXG4iLCIvKmVzbGludC1kaXNhYmxlIGJsb2NrLXNjb3BlZC12YXIsIGlkLWxlbmd0aCwgbm8tY29udHJvbC1yZWdleCwgbm8tbWFnaWMtbnVtYmVycywgbm8tcHJvdG90eXBlLWJ1aWx0aW5zLCBuby1yZWRlY2xhcmUsIG5vLXNoYWRvdywgbm8tdmFyLCBzb3J0LXZhcnMqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciAkcHJvdG9idWYgPSByZXF1aXJlKFwicHJvdG9idWZqcy9taW5pbWFsXCIpO1xuXG4vLyBDb21tb24gYWxpYXNlc1xudmFyICRSZWFkZXIgPSAkcHJvdG9idWYuUmVhZGVyLCAkdXRpbCA9ICRwcm90b2J1Zi51dGlsO1xuXG4vLyBFeHBvcnRlZCByb290IG5hbWVzcGFjZVxudmFyICRyb290ID0gJHByb3RvYnVmLnJvb3RzW1wiZGVmYXVsdFwiXSB8fCAoJHByb3RvYnVmLnJvb3RzW1wiZGVmYXVsdFwiXSA9IHt9KTtcblxuJHJvb3QueWFuZGV4ID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgLyoqXG4gICAgICogTmFtZXNwYWNlIHlhbmRleC5cbiAgICAgKiBAZXhwb3J0cyB5YW5kZXhcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICovXG4gICAgdmFyIHlhbmRleCA9IHt9O1xuXG4gICAgeWFuZGV4Lm1hcHMgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5hbWVzcGFjZSBtYXBzLlxuICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4XG4gICAgICAgICAqIEBuYW1lc3BhY2VcbiAgICAgICAgICovXG4gICAgICAgIHZhciBtYXBzID0ge307XG5cbiAgICAgICAgbWFwcy5wcm90byA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBOYW1lc3BhY2UgcHJvdG8uXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHNcbiAgICAgICAgICAgICAqIEBuYW1lc3BhY2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIHByb3RvID0ge307XG5cbiAgICAgICAgICAgIHByb3RvLnZlY3RvcmRhdGEyID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogTmFtZXNwYWNlIHZlY3RvcmRhdGEyLlxuICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90b1xuICAgICAgICAgICAgICAgICAqIEBuYW1lc3BhY2VcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB2YXIgdmVjdG9yZGF0YTIgPSB7fTtcblxuICAgICAgICAgICAgICAgIHZlY3RvcmRhdGEyLnRpbGUgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIE5hbWVzcGFjZSB0aWxlLlxuICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTJcbiAgICAgICAgICAgICAgICAgICAgICogQG5hbWVzcGFjZVxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpbGUgPSB7fTtcblxuICAgICAgICAgICAgICAgICAgICB0aWxlLlRpbGUgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogUHJvcGVydGllcyBvZiBhIFRpbGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICogQGludGVyZmFjZSBJVGlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48eWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbj58bnVsbH0gW3ByZXNlbnRhdGlvbl0gVGlsZSBwcmVzZW50YXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7eWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlLlBvaW50T2JqZWN0c3xudWxsfSBbcG9pbnRzXSBUaWxlIHBvaW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHt5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi50aWxlLlRpbGUuUG9seWxpbmVPYmplY3RzfG51bGx9IFtwb2x5bGluZXNdIFRpbGUgcG9seWxpbmVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge3lhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZS5Qb2x5Z29uT2JqZWN0c3xudWxsfSBbcG9seWdvbnNdIFRpbGUgcG9seWdvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7eWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlLlN0cmFpZ2h0TGFiZWxzfG51bGx9IFtwb2ludExhYmVsc10gVGlsZSBwb2ludExhYmVsc1xuICAgICAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHt5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi50aWxlLlRpbGUuQ3VydmVkTGFiZWxzfG51bGx9IFtwb2x5bGluZUxhYmVsc10gVGlsZSBwb2x5bGluZUxhYmVsc1xuICAgICAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48eWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlLkxheWVyPnxudWxsfSBbbGF5ZXJzXSBUaWxlIGxheWVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48c3RyaW5nPnxudWxsfSBbaW5kb29yUGxhbklkXSBUaWxlIGluZG9vclBsYW5JZFxuICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBUaWxlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIFRpbGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW1wbGVtZW50cyBJVGlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3lhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuSVRpbGU9fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gVGlsZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmVzZW50YXRpb24gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxheWVycyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kb29yUGxhbklkID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBUaWxlIHByZXNlbnRhdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXIge0FycmF5Ljx5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uPn0gcHJlc2VudGF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgVGlsZS5wcm90b3R5cGUucHJlc2VudGF0aW9uID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBUaWxlIHBvaW50cy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXIge3lhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZS5Qb2ludE9iamVjdHN8bnVsbHx1bmRlZmluZWR9IHBvaW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIFRpbGUucHJvdG90eXBlLnBvaW50cyA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogVGlsZSBwb2x5bGluZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHt5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi50aWxlLlRpbGUuUG9seWxpbmVPYmplY3RzfG51bGx8dW5kZWZpbmVkfSBwb2x5bGluZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi50aWxlLlRpbGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICBUaWxlLnByb3RvdHlwZS5wb2x5bGluZXMgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIFRpbGUgcG9seWdvbnMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHt5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi50aWxlLlRpbGUuUG9seWdvbk9iamVjdHN8bnVsbHx1bmRlZmluZWR9IHBvbHlnb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgVGlsZS5wcm90b3R5cGUucG9seWdvbnMgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIFRpbGUgcG9pbnRMYWJlbHMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHt5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi50aWxlLlRpbGUuU3RyYWlnaHRMYWJlbHN8bnVsbHx1bmRlZmluZWR9IHBvaW50TGFiZWxzXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgVGlsZS5wcm90b3R5cGUucG9pbnRMYWJlbHMgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIFRpbGUgcG9seWxpbmVMYWJlbHMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHt5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi50aWxlLlRpbGUuQ3VydmVkTGFiZWxzfG51bGx8dW5kZWZpbmVkfSBwb2x5bGluZUxhYmVsc1xuICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIFRpbGUucHJvdG90eXBlLnBvbHlsaW5lTGFiZWxzID0gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBUaWxlIGxheWVycy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXIge0FycmF5Ljx5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi50aWxlLlRpbGUuTGF5ZXI+fSBsYXllcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi50aWxlLlRpbGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICBUaWxlLnByb3RvdHlwZS5sYXllcnMgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIFRpbGUgaW5kb29yUGxhbklkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPHN0cmluZz59IGluZG9vclBsYW5JZFxuICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIFRpbGUucHJvdG90eXBlLmluZG9vclBsYW5JZCA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogRGVjb2RlcyBhIFRpbGUgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi50aWxlLlRpbGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHt5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi50aWxlLlRpbGV9IFRpbGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgVGlsZS5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC55YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi50aWxlLlRpbGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLnByZXNlbnRhdGlvbiAmJiBtZXNzYWdlLnByZXNlbnRhdGlvbi5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucHJlc2VudGF0aW9uID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnByZXNlbnRhdGlvbi5wdXNoKCRyb290LnlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wb2ludHMgPSAkcm9vdC55YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi50aWxlLlRpbGUuUG9pbnRPYmplY3RzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wb2x5bGluZXMgPSAkcm9vdC55YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi50aWxlLlRpbGUuUG9seWxpbmVPYmplY3RzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wb2x5Z29ucyA9ICRyb290LnlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZS5Qb2x5Z29uT2JqZWN0cy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucG9pbnRMYWJlbHMgPSAkcm9vdC55YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi50aWxlLlRpbGUuU3RyYWlnaHRMYWJlbHMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBvbHlsaW5lTGFiZWxzID0gJHJvb3QueWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlLkN1cnZlZExhYmVscy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UubGF5ZXJzICYmIG1lc3NhZ2UubGF5ZXJzLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5sYXllcnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubGF5ZXJzLnB1c2goJHJvb3QueWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlLkxheWVyLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UuaW5kb29yUGxhbklkICYmIG1lc3NhZ2UuaW5kb29yUGxhbklkLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pbmRvb3JQbGFuSWQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaW5kb29yUGxhbklkLnB1c2gocmVhZGVyLnN0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBUaWxlLlBvaW50T2JqZWN0cyA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFByb3BlcnRpZXMgb2YgYSBQb2ludE9iamVjdHMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbnRlcmZhY2UgSVBvaW50T2JqZWN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG51bWJlcj58bnVsbH0gW2Nvb3Jkc3hdIFBvaW50T2JqZWN0cyBjb29yZHN4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48bnVtYmVyPnxudWxsfSBbY29vcmRzeV0gUG9pbnRPYmplY3RzIGNvb3Jkc3lcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5LjxudW1iZXI+fG51bGx9IFtjbGFzc0lkXSBQb2ludE9iamVjdHMgY2xhc3NJZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG51bWJlcj58bnVsbH0gW3pPcmRlcl0gUG9pbnRPYmplY3RzIHpPcmRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBQb2ludE9iamVjdHMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIFBvaW50T2JqZWN0cy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW1wbGVtZW50cyBJUG9pbnRPYmplY3RzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHt5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi50aWxlLlRpbGUuSVBvaW50T2JqZWN0cz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFBvaW50T2JqZWN0cyhwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29vcmRzeCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvb3Jkc3kgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGFzc0lkID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuek9yZGVyID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogUG9pbnRPYmplY3RzIGNvb3Jkc3guXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPG51bWJlcj59IGNvb3Jkc3hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlLlBvaW50T2JqZWN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvaW50T2JqZWN0cy5wcm90b3R5cGUuY29vcmRzeCA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBQb2ludE9iamVjdHMgY29vcmRzeS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48bnVtYmVyPn0gY29vcmRzeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi50aWxlLlRpbGUuUG9pbnRPYmplY3RzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUG9pbnRPYmplY3RzLnByb3RvdHlwZS5jb29yZHN5ID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFBvaW50T2JqZWN0cyBjbGFzc0lkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXIge0FycmF5LjxudW1iZXI+fSBjbGFzc0lkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZS5Qb2ludE9iamVjdHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQb2ludE9iamVjdHMucHJvdG90eXBlLmNsYXNzSWQgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogUG9pbnRPYmplY3RzIHpPcmRlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48bnVtYmVyPn0gek9yZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZS5Qb2ludE9iamVjdHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQb2ludE9iamVjdHMucHJvdG90eXBlLnpPcmRlciA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEZWNvZGVzIGEgUG9pbnRPYmplY3RzIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi50aWxlLlRpbGUuUG9pbnRPYmplY3RzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHJldHVybnMge3lhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZS5Qb2ludE9iamVjdHN9IFBvaW50T2JqZWN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUG9pbnRPYmplY3RzLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290LnlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZS5Qb2ludE9iamVjdHMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UuY29vcmRzeCAmJiBtZXNzYWdlLmNvb3Jkc3gubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jb29yZHN4ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh0YWcgJiA3KSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kMiA9IHJlYWRlci51aW50MzIoKSArIHJlYWRlci5wb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY29vcmRzeC5wdXNoKHJlYWRlci5zaW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY29vcmRzeC5wdXNoKHJlYWRlci5zaW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5jb29yZHN5ICYmIG1lc3NhZ2UuY29vcmRzeS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNvb3Jkc3kgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHRhZyAmIDcpID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmQyID0gcmVhZGVyLnVpbnQzMigpICsgcmVhZGVyLnBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jb29yZHN5LnB1c2gocmVhZGVyLnNpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jb29yZHN5LnB1c2gocmVhZGVyLnNpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLmNsYXNzSWQgJiYgbWVzc2FnZS5jbGFzc0lkLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY2xhc3NJZCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodGFnICYgNykgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZDIgPSByZWFkZXIudWludDMyKCkgKyByZWFkZXIucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZDIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNsYXNzSWQucHVzaChyZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNsYXNzSWQucHVzaChyZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2Uuek9yZGVyICYmIG1lc3NhZ2Uuek9yZGVyLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuek9yZGVyID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh0YWcgJiA3KSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kMiA9IHJlYWRlci51aW50MzIoKSArIHJlYWRlci5wb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuek9yZGVyLnB1c2gocmVhZGVyLnNpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS56T3JkZXIucHVzaChyZWFkZXIuc2ludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQb2ludE9iamVjdHM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBUaWxlLlBvbHlsaW5lT2JqZWN0cyA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFByb3BlcnRpZXMgb2YgYSBQb2x5bGluZU9iamVjdHMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbnRlcmZhY2UgSVBvbHlsaW5lT2JqZWN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG51bWJlcj58bnVsbH0gW2Nvb3Jkc3hdIFBvbHlsaW5lT2JqZWN0cyBjb29yZHN4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48bnVtYmVyPnxudWxsfSBbY29vcmRzeV0gUG9seWxpbmVPYmplY3RzIGNvb3Jkc3lcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5LjxudW1iZXI+fG51bGx9IFtsaW5lU2l6ZV0gUG9seWxpbmVPYmplY3RzIGxpbmVTaXplXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48bnVtYmVyfExvbmc+fG51bGx9IFtkaXN0YW5jZV0gUG9seWxpbmVPYmplY3RzIGRpc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48bnVtYmVyPnxudWxsfSBbY2xhc3NJZF0gUG9seWxpbmVPYmplY3RzIGNsYXNzSWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5LjxudW1iZXI+fG51bGx9IFtwb2ludFZpc2liaWxpdHldIFBvbHlsaW5lT2JqZWN0cyBwb2ludFZpc2liaWxpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5LjxudW1iZXI+fG51bGx9IFt6T3JkZXJCZWdpbl0gUG9seWxpbmVPYmplY3RzIHpPcmRlckJlZ2luXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48bnVtYmVyPnxudWxsfSBbek9yZGVyRW5kXSBQb2x5bGluZU9iamVjdHMgek9yZGVyRW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFBvbHlsaW5lT2JqZWN0cy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgUG9seWxpbmVPYmplY3RzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbXBsZW1lbnRzIElQb2x5bGluZU9iamVjdHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3lhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZS5JUG9seWxpbmVPYmplY3RzPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gUG9seWxpbmVPYmplY3RzKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb29yZHN4ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29vcmRzeSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmVTaXplID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzdGFuY2UgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGFzc0lkID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9pbnRWaXNpYmlsaXR5ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuek9yZGVyQmVnaW4gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy56T3JkZXJFbmQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBQb2x5bGluZU9iamVjdHMgY29vcmRzeC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48bnVtYmVyPn0gY29vcmRzeFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi50aWxlLlRpbGUuUG9seWxpbmVPYmplY3RzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUG9seWxpbmVPYmplY3RzLnByb3RvdHlwZS5jb29yZHN4ID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFBvbHlsaW5lT2JqZWN0cyBjb29yZHN5LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXIge0FycmF5LjxudW1iZXI+fSBjb29yZHN5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZS5Qb2x5bGluZU9iamVjdHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQb2x5bGluZU9iamVjdHMucHJvdG90eXBlLmNvb3Jkc3kgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogUG9seWxpbmVPYmplY3RzIGxpbmVTaXplLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXIge0FycmF5LjxudW1iZXI+fSBsaW5lU2l6ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi50aWxlLlRpbGUuUG9seWxpbmVPYmplY3RzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUG9seWxpbmVPYmplY3RzLnByb3RvdHlwZS5saW5lU2l6ZSA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBQb2x5bGluZU9iamVjdHMgZGlzdGFuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPG51bWJlcnxMb25nPn0gZGlzdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlLlBvbHlsaW5lT2JqZWN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvbHlsaW5lT2JqZWN0cy5wcm90b3R5cGUuZGlzdGFuY2UgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogUG9seWxpbmVPYmplY3RzIGNsYXNzSWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPG51bWJlcj59IGNsYXNzSWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlLlBvbHlsaW5lT2JqZWN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvbHlsaW5lT2JqZWN0cy5wcm90b3R5cGUuY2xhc3NJZCA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBQb2x5bGluZU9iamVjdHMgcG9pbnRWaXNpYmlsaXR5LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXIge0FycmF5LjxudW1iZXI+fSBwb2ludFZpc2liaWxpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlLlBvbHlsaW5lT2JqZWN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvbHlsaW5lT2JqZWN0cy5wcm90b3R5cGUucG9pbnRWaXNpYmlsaXR5ID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFBvbHlsaW5lT2JqZWN0cyB6T3JkZXJCZWdpbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48bnVtYmVyPn0gek9yZGVyQmVnaW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlLlBvbHlsaW5lT2JqZWN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvbHlsaW5lT2JqZWN0cy5wcm90b3R5cGUuek9yZGVyQmVnaW4gPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogUG9seWxpbmVPYmplY3RzIHpPcmRlckVuZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48bnVtYmVyPn0gek9yZGVyRW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZS5Qb2x5bGluZU9iamVjdHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQb2x5bGluZU9iamVjdHMucHJvdG90eXBlLnpPcmRlckVuZCA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEZWNvZGVzIGEgUG9seWxpbmVPYmplY3RzIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi50aWxlLlRpbGUuUG9seWxpbmVPYmplY3RzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHJldHVybnMge3lhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZS5Qb2x5bGluZU9iamVjdHN9IFBvbHlsaW5lT2JqZWN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUG9seWxpbmVPYmplY3RzLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290LnlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZS5Qb2x5bGluZU9iamVjdHMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UuY29vcmRzeCAmJiBtZXNzYWdlLmNvb3Jkc3gubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jb29yZHN4ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh0YWcgJiA3KSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kMiA9IHJlYWRlci51aW50MzIoKSArIHJlYWRlci5wb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY29vcmRzeC5wdXNoKHJlYWRlci5zaW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY29vcmRzeC5wdXNoKHJlYWRlci5zaW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5jb29yZHN5ICYmIG1lc3NhZ2UuY29vcmRzeS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNvb3Jkc3kgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHRhZyAmIDcpID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmQyID0gcmVhZGVyLnVpbnQzMigpICsgcmVhZGVyLnBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jb29yZHN5LnB1c2gocmVhZGVyLnNpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jb29yZHN5LnB1c2gocmVhZGVyLnNpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLmxpbmVTaXplICYmIG1lc3NhZ2UubGluZVNpemUubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5saW5lU2l6ZSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodGFnICYgNykgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZDIgPSByZWFkZXIudWludDMyKCkgKyByZWFkZXIucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZDIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmxpbmVTaXplLnB1c2gocmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5saW5lU2l6ZS5wdXNoKHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5kaXN0YW5jZSAmJiBtZXNzYWdlLmRpc3RhbmNlLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGlzdGFuY2UgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHRhZyAmIDcpID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmQyID0gcmVhZGVyLnVpbnQzMigpICsgcmVhZGVyLnBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kaXN0YW5jZS5wdXNoKHJlYWRlci51aW50NjQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGlzdGFuY2UucHVzaChyZWFkZXIudWludDY0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UuY2xhc3NJZCAmJiBtZXNzYWdlLmNsYXNzSWQubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jbGFzc0lkID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh0YWcgJiA3KSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kMiA9IHJlYWRlci51aW50MzIoKSArIHJlYWRlci5wb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY2xhc3NJZC5wdXNoKHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY2xhc3NJZC5wdXNoKHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5wb2ludFZpc2liaWxpdHkgJiYgbWVzc2FnZS5wb2ludFZpc2liaWxpdHkubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wb2ludFZpc2liaWxpdHkgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHRhZyAmIDcpID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmQyID0gcmVhZGVyLnVpbnQzMigpICsgcmVhZGVyLnBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wb2ludFZpc2liaWxpdHkucHVzaChyZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBvaW50VmlzaWJpbGl0eS5wdXNoKHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS56T3JkZXJCZWdpbiAmJiBtZXNzYWdlLnpPcmRlckJlZ2luLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuek9yZGVyQmVnaW4gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHRhZyAmIDcpID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmQyID0gcmVhZGVyLnVpbnQzMigpICsgcmVhZGVyLnBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS56T3JkZXJCZWdpbi5wdXNoKHJlYWRlci5zaW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuek9yZGVyQmVnaW4ucHVzaChyZWFkZXIuc2ludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2Uuek9yZGVyRW5kICYmIG1lc3NhZ2Uuek9yZGVyRW5kLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuek9yZGVyRW5kID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh0YWcgJiA3KSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kMiA9IHJlYWRlci51aW50MzIoKSArIHJlYWRlci5wb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuek9yZGVyRW5kLnB1c2gocmVhZGVyLnNpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS56T3JkZXJFbmQucHVzaChyZWFkZXIuc2ludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQb2x5bGluZU9iamVjdHM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBUaWxlLlBvbHlnb25PYmplY3RzID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogUHJvcGVydGllcyBvZiBhIFBvbHlnb25PYmplY3RzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi50aWxlLlRpbGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW50ZXJmYWNlIElQb2x5Z29uT2JqZWN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG51bWJlcj58bnVsbH0gW2Nvb3Jkc3hdIFBvbHlnb25PYmplY3RzIGNvb3Jkc3hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5LjxudW1iZXI+fG51bGx9IFtjb29yZHN5XSBQb2x5Z29uT2JqZWN0cyBjb29yZHN5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48bnVtYmVyPnxudWxsfSBbY2xhc3NJZF0gUG9seWdvbk9iamVjdHMgY2xhc3NJZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG51bWJlcj58bnVsbH0gW3JpbmdDb3VudF0gUG9seWdvbk9iamVjdHMgcmluZ0NvdW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48bnVtYmVyPnxudWxsfSBbcmluZ1NpemVdIFBvbHlnb25PYmplY3RzIHJpbmdTaXplXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48bnVtYmVyPnxudWxsfSBbY29udG91ckluZGV4XSBQb2x5Z29uT2JqZWN0cyBjb250b3VySW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5LjxudW1iZXI+fG51bGx9IFtjb250b3VyQ291bnRdIFBvbHlnb25PYmplY3RzIGNvbnRvdXJDb3VudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG51bWJlcj58bnVsbH0gW3BvaW50VmlzaWJpbGl0eV0gUG9seWdvbk9iamVjdHMgcG9pbnRWaXNpYmlsaXR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48bnVtYmVyPnxudWxsfSBbaGVpZ2h0XSBQb2x5Z29uT2JqZWN0cyBoZWlnaHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5LjxudW1iZXI+fG51bGx9IFt6T3JkZXJdIFBvbHlnb25PYmplY3RzIHpPcmRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZS5Qb2x5Z29uT2JqZWN0cy5NZXNoPnxudWxsfSBbbWVzaF0gUG9seWdvbk9iamVjdHMgbWVzaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBQb2x5Z29uT2JqZWN0cy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgUG9seWdvbk9iamVjdHMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGltcGxlbWVudHMgSVBvbHlnb25PYmplY3RzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHt5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi50aWxlLlRpbGUuSVBvbHlnb25PYmplY3RzPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gUG9seWdvbk9iamVjdHMocHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvb3Jkc3ggPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb29yZHN5ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xhc3NJZCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJpbmdDb3VudCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJpbmdTaXplID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udG91ckluZGV4ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29udG91ckNvdW50ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9pbnRWaXNpYmlsaXR5ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuek9yZGVyID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWVzaCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFBvbHlnb25PYmplY3RzIGNvb3Jkc3guXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPG51bWJlcj59IGNvb3Jkc3hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlLlBvbHlnb25PYmplY3RzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUG9seWdvbk9iamVjdHMucHJvdG90eXBlLmNvb3Jkc3ggPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogUG9seWdvbk9iamVjdHMgY29vcmRzeS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48bnVtYmVyPn0gY29vcmRzeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi50aWxlLlRpbGUuUG9seWdvbk9iamVjdHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQb2x5Z29uT2JqZWN0cy5wcm90b3R5cGUuY29vcmRzeSA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBQb2x5Z29uT2JqZWN0cyBjbGFzc0lkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXIge0FycmF5LjxudW1iZXI+fSBjbGFzc0lkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZS5Qb2x5Z29uT2JqZWN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvbHlnb25PYmplY3RzLnByb3RvdHlwZS5jbGFzc0lkID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFBvbHlnb25PYmplY3RzIHJpbmdDb3VudC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48bnVtYmVyPn0gcmluZ0NvdW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZS5Qb2x5Z29uT2JqZWN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvbHlnb25PYmplY3RzLnByb3RvdHlwZS5yaW5nQ291bnQgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogUG9seWdvbk9iamVjdHMgcmluZ1NpemUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPG51bWJlcj59IHJpbmdTaXplXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZS5Qb2x5Z29uT2JqZWN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvbHlnb25PYmplY3RzLnByb3RvdHlwZS5yaW5nU2l6ZSA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBQb2x5Z29uT2JqZWN0cyBjb250b3VySW5kZXguXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPG51bWJlcj59IGNvbnRvdXJJbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi50aWxlLlRpbGUuUG9seWdvbk9iamVjdHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQb2x5Z29uT2JqZWN0cy5wcm90b3R5cGUuY29udG91ckluZGV4ID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFBvbHlnb25PYmplY3RzIGNvbnRvdXJDb3VudC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48bnVtYmVyPn0gY29udG91ckNvdW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZS5Qb2x5Z29uT2JqZWN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvbHlnb25PYmplY3RzLnByb3RvdHlwZS5jb250b3VyQ291bnQgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogUG9seWdvbk9iamVjdHMgcG9pbnRWaXNpYmlsaXR5LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXIge0FycmF5LjxudW1iZXI+fSBwb2ludFZpc2liaWxpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlLlBvbHlnb25PYmplY3RzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUG9seWdvbk9iamVjdHMucHJvdG90eXBlLnBvaW50VmlzaWJpbGl0eSA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBQb2x5Z29uT2JqZWN0cyBoZWlnaHQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPG51bWJlcj59IGhlaWdodFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi50aWxlLlRpbGUuUG9seWdvbk9iamVjdHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQb2x5Z29uT2JqZWN0cy5wcm90b3R5cGUuaGVpZ2h0ID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFBvbHlnb25PYmplY3RzIHpPcmRlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48bnVtYmVyPn0gek9yZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZS5Qb2x5Z29uT2JqZWN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvbHlnb25PYmplY3RzLnByb3RvdHlwZS56T3JkZXIgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogUG9seWdvbk9iamVjdHMgbWVzaC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48eWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlLlBvbHlnb25PYmplY3RzLk1lc2g+fSBtZXNoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZS5Qb2x5Z29uT2JqZWN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvbHlnb25PYmplY3RzLnByb3RvdHlwZS5tZXNoID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERlY29kZXMgYSBQb2x5Z29uT2JqZWN0cyBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlLlBvbHlnb25PYmplY3RzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHJldHVybnMge3lhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZS5Qb2x5Z29uT2JqZWN0c30gUG9seWdvbk9iamVjdHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvbHlnb25PYmplY3RzLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290LnlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZS5Qb2x5Z29uT2JqZWN0cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5jb29yZHN4ICYmIG1lc3NhZ2UuY29vcmRzeC5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNvb3Jkc3ggPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHRhZyAmIDcpID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmQyID0gcmVhZGVyLnVpbnQzMigpICsgcmVhZGVyLnBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jb29yZHN4LnB1c2gocmVhZGVyLnNpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jb29yZHN4LnB1c2gocmVhZGVyLnNpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLmNvb3Jkc3kgJiYgbWVzc2FnZS5jb29yZHN5Lmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY29vcmRzeSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodGFnICYgNykgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZDIgPSByZWFkZXIudWludDMyKCkgKyByZWFkZXIucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZDIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNvb3Jkc3kucHVzaChyZWFkZXIuc2ludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNvb3Jkc3kucHVzaChyZWFkZXIuc2ludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UuY2xhc3NJZCAmJiBtZXNzYWdlLmNsYXNzSWQubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jbGFzc0lkID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh0YWcgJiA3KSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kMiA9IHJlYWRlci51aW50MzIoKSArIHJlYWRlci5wb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY2xhc3NJZC5wdXNoKHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY2xhc3NJZC5wdXNoKHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5yaW5nQ291bnQgJiYgbWVzc2FnZS5yaW5nQ291bnQubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yaW5nQ291bnQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHRhZyAmIDcpID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmQyID0gcmVhZGVyLnVpbnQzMigpICsgcmVhZGVyLnBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yaW5nQ291bnQucHVzaChyZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnJpbmdDb3VudC5wdXNoKHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5yaW5nU2l6ZSAmJiBtZXNzYWdlLnJpbmdTaXplLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucmluZ1NpemUgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHRhZyAmIDcpID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmQyID0gcmVhZGVyLnVpbnQzMigpICsgcmVhZGVyLnBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5yaW5nU2l6ZS5wdXNoKHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucmluZ1NpemUucHVzaChyZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UuY29udG91ckluZGV4ICYmIG1lc3NhZ2UuY29udG91ckluZGV4Lmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY29udG91ckluZGV4ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh0YWcgJiA3KSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kMiA9IHJlYWRlci51aW50MzIoKSArIHJlYWRlci5wb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY29udG91ckluZGV4LnB1c2gocmVhZGVyLnNpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jb250b3VySW5kZXgucHVzaChyZWFkZXIuc2ludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UuY29udG91ckNvdW50ICYmIG1lc3NhZ2UuY29udG91ckNvdW50Lmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY29udG91ckNvdW50ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh0YWcgJiA3KSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kMiA9IHJlYWRlci51aW50MzIoKSArIHJlYWRlci5wb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY29udG91ckNvdW50LnB1c2gocmVhZGVyLnNpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jb250b3VyQ291bnQucHVzaChyZWFkZXIuc2ludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UucG9pbnRWaXNpYmlsaXR5ICYmIG1lc3NhZ2UucG9pbnRWaXNpYmlsaXR5Lmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucG9pbnRWaXNpYmlsaXR5ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh0YWcgJiA3KSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kMiA9IHJlYWRlci51aW50MzIoKSArIHJlYWRlci5wb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucG9pbnRWaXNpYmlsaXR5LnB1c2gocmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wb2ludFZpc2liaWxpdHkucHVzaChyZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UuaGVpZ2h0ICYmIG1lc3NhZ2UuaGVpZ2h0Lmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaGVpZ2h0ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh0YWcgJiA3KSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kMiA9IHJlYWRlci51aW50MzIoKSArIHJlYWRlci5wb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaGVpZ2h0LnB1c2gocmVhZGVyLnNpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5oZWlnaHQucHVzaChyZWFkZXIuc2ludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLnpPcmRlciAmJiBtZXNzYWdlLnpPcmRlci5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnpPcmRlciA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodGFnICYgNykgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZDIgPSByZWFkZXIudWludDMyKCkgKyByZWFkZXIucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZDIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnpPcmRlci5wdXNoKHJlYWRlci5zaW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuek9yZGVyLnB1c2gocmVhZGVyLnNpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5tZXNoICYmIG1lc3NhZ2UubWVzaC5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm1lc2ggPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm1lc2gucHVzaCgkcm9vdC55YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi50aWxlLlRpbGUuUG9seWdvbk9iamVjdHMuTWVzaC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQb2x5Z29uT2JqZWN0cy5CQm94ID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgQkJveC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZS5Qb2x5Z29uT2JqZWN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW50ZXJmYWNlIElCQm94XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfG51bGx9IFttaW5YXSBCQm94IG1pblhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8bnVsbH0gW21pblldIEJCb3ggbWluWVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcnxudWxsfSBbbWF4WF0gQkJveCBtYXhYXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfG51bGx9IFttYXhZXSBCQm94IG1heFlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgQkJveC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZS5Qb2x5Z29uT2JqZWN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBCQm94LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW1wbGVtZW50cyBJQkJveFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHt5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi50aWxlLlRpbGUuUG9seWdvbk9iamVjdHMuSUJCb3g9fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEJCb3gocHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBCQm94IG1pblguXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXIge251bWJlcn0gbWluWFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlLlBvbHlnb25PYmplY3RzLkJCb3hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBCQm94LnByb3RvdHlwZS5taW5YID0gMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQkJveCBtaW5ZLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IG1pbllcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZS5Qb2x5Z29uT2JqZWN0cy5CQm94XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQkJveC5wcm90b3R5cGUubWluWSA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEJCb3ggbWF4WC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfSBtYXhYXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi50aWxlLlRpbGUuUG9seWdvbk9iamVjdHMuQkJveFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEJCb3gucHJvdG90eXBlLm1heFggPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBCQm94IG1heFkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXIge251bWJlcn0gbWF4WVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlLlBvbHlnb25PYmplY3RzLkJCb3hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBCQm94LnByb3RvdHlwZS5tYXhZID0gMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRGVjb2RlcyBhIEJCb3ggbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlLlBvbHlnb25PYmplY3RzLkJCb3hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHJldHVybnMge3lhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZS5Qb2x5Z29uT2JqZWN0cy5CQm94fSBCQm94XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQkJveC5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC55YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi50aWxlLlRpbGUuUG9seWdvbk9iamVjdHMuQkJveCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm1pblggPSByZWFkZXIuc2ludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5taW5ZID0gcmVhZGVyLnNpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubWF4WCA9IHJlYWRlci5zaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm1heFkgPSByZWFkZXIuc2ludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJCb3g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvbHlnb25PYmplY3RzLk1lc2ggPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFByb3BlcnRpZXMgb2YgYSBNZXNoLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlLlBvbHlnb25PYmplY3RzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbnRlcmZhY2UgSU1lc2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8bnVsbH0gW3BvbHlnb25JZF0gTWVzaCBwb2x5Z29uSWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW21lc2hJZF0gTWVzaCBtZXNoSWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHt5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi50aWxlLlRpbGUuUG9seWdvbk9iamVjdHMuQkJveHxudWxsfSBbYmJveF0gTWVzaCBiYm94XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtvYmplY3RJZF0gTWVzaCBvYmplY3RJZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBNZXNoLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlLlBvbHlnb25PYmplY3RzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIE1lc2guXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbXBsZW1lbnRzIElNZXNoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3lhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZS5Qb2x5Z29uT2JqZWN0cy5JTWVzaD19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gTWVzaChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIE1lc2ggcG9seWdvbklkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IHBvbHlnb25JZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlLlBvbHlnb25PYmplY3RzLk1lc2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNZXNoLnByb3RvdHlwZS5wb2x5Z29uSWQgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBNZXNoIG1lc2hJZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSBtZXNoSWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZS5Qb2x5Z29uT2JqZWN0cy5NZXNoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWVzaC5wcm90b3R5cGUubWVzaElkID0gXCJcIjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogTWVzaCBiYm94LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHt5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi50aWxlLlRpbGUuUG9seWdvbk9iamVjdHMuQkJveHxudWxsfHVuZGVmaW5lZH0gYmJveFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlLlBvbHlnb25PYmplY3RzLk1lc2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNZXNoLnByb3RvdHlwZS5iYm94ID0gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogTWVzaCBvYmplY3RJZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSBvYmplY3RJZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlLlBvbHlnb25PYmplY3RzLk1lc2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNZXNoLnByb3RvdHlwZS5vYmplY3RJZCA9IFwiXCI7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERlY29kZXMgYSBNZXNoIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZS5Qb2x5Z29uT2JqZWN0cy5NZXNoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHt5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi50aWxlLlRpbGUuUG9seWdvbk9iamVjdHMuTWVzaH0gTWVzaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1lc2guZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QueWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlLlBvbHlnb25PYmplY3RzLk1lc2goKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wb2x5Z29uSWQgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5tZXNoSWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5iYm94ID0gJHJvb3QueWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlLlBvbHlnb25PYmplY3RzLkJCb3guZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm9iamVjdElkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNZXNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUG9seWdvbk9iamVjdHM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBUaWxlLlNoYXBlZFN0cmluZyA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFByb3BlcnRpZXMgb2YgYSBTaGFwZWRTdHJpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbnRlcmZhY2UgSVNoYXBlZFN0cmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG51bWJlcj58bnVsbH0gW2dseXBoc10gU2hhcGVkU3RyaW5nIGdseXBoc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBTaGFwZWRTdHJpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIFNoYXBlZFN0cmluZy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW1wbGVtZW50cyBJU2hhcGVkU3RyaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHt5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi50aWxlLlRpbGUuSVNoYXBlZFN0cmluZz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFNoYXBlZFN0cmluZyhwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2x5cGhzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogU2hhcGVkU3RyaW5nIGdseXBocy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48bnVtYmVyPn0gZ2x5cGhzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZS5TaGFwZWRTdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTaGFwZWRTdHJpbmcucHJvdG90eXBlLmdseXBocyA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEZWNvZGVzIGEgU2hhcGVkU3RyaW5nIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi50aWxlLlRpbGUuU2hhcGVkU3RyaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHJldHVybnMge3lhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZS5TaGFwZWRTdHJpbmd9IFNoYXBlZFN0cmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU2hhcGVkU3RyaW5nLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290LnlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZS5TaGFwZWRTdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UuZ2x5cGhzICYmIG1lc3NhZ2UuZ2x5cGhzLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZ2x5cGhzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh0YWcgJiA3KSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kMiA9IHJlYWRlci51aW50MzIoKSArIHJlYWRlci5wb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZ2x5cGhzLnB1c2gocmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5nbHlwaHMucHVzaChyZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBTaGFwZWRTdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBUaWxlLlNoYXBlZFRleHQgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgU2hhcGVkVGV4dC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGludGVyZmFjZSBJU2hhcGVkVGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZS5TaGFwZWRTdHJpbmc+fG51bGx9IFtzdHJpbmdzXSBTaGFwZWRUZXh0IHN0cmluZ3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgU2hhcGVkVGV4dC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgU2hhcGVkVGV4dC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW1wbGVtZW50cyBJU2hhcGVkVGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7eWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlLklTaGFwZWRUZXh0PX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gU2hhcGVkVGV4dChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RyaW5ncyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFNoYXBlZFRleHQgc3RyaW5ncy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48eWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlLlNoYXBlZFN0cmluZz59IHN0cmluZ3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlLlNoYXBlZFRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTaGFwZWRUZXh0LnByb3RvdHlwZS5zdHJpbmdzID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERlY29kZXMgYSBTaGFwZWRUZXh0IG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi50aWxlLlRpbGUuU2hhcGVkVGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHt5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi50aWxlLlRpbGUuU2hhcGVkVGV4dH0gU2hhcGVkVGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU2hhcGVkVGV4dC5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC55YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi50aWxlLlRpbGUuU2hhcGVkVGV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5zdHJpbmdzICYmIG1lc3NhZ2Uuc3RyaW5ncy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnN0cmluZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnN0cmluZ3MucHVzaCgkcm9vdC55YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi50aWxlLlRpbGUuU2hhcGVkU3RyaW5nLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBTaGFwZWRUZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgVGlsZS5TdHJhaWdodExhYmVscyA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFByb3BlcnRpZXMgb2YgYSBTdHJhaWdodExhYmVscy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGludGVyZmFjZSBJU3RyYWlnaHRMYWJlbHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5LjxudW1iZXI+fG51bGx9IFtjbGFzc0lkXSBTdHJhaWdodExhYmVscyBjbGFzc0lkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48bnVtYmVyPnxudWxsfSBbY2VudGVyWF0gU3RyYWlnaHRMYWJlbHMgY2VudGVyWFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG51bWJlcj58bnVsbH0gW2NlbnRlclldIFN0cmFpZ2h0TGFiZWxzIGNlbnRlcllcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5LjxudW1iZXI+fG51bGx9IFtvZmZzZXRYXSBTdHJhaWdodExhYmVscyBvZmZzZXRYXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48bnVtYmVyPnxudWxsfSBbb2Zmc2V0WV0gU3RyYWlnaHRMYWJlbHMgb2Zmc2V0WVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZS5TaGFwZWRUZXh0PnxudWxsfSBbdGV4dF0gU3RyYWlnaHRMYWJlbHMgdGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZS5TaGFwZWRUZXh0PnxudWxsfSBbdGV4dEFsdF0gU3RyYWlnaHRMYWJlbHMgdGV4dEFsdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG51bWJlcj58bnVsbH0gW3ByaW9yaXR5XSBTdHJhaWdodExhYmVscyBwcmlvcml0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZS5TdHJhaWdodExhYmVscy5BbGlnblR5cGU+fG51bGx9IFthbGlnbl0gU3RyYWlnaHRMYWJlbHMgYWxpZ25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgU3RyYWlnaHRMYWJlbHMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIFN0cmFpZ2h0TGFiZWxzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbXBsZW1lbnRzIElTdHJhaWdodExhYmVsc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7eWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlLklTdHJhaWdodExhYmVscz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFN0cmFpZ2h0TGFiZWxzKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGFzc0lkID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2VudGVyWCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNlbnRlclkgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRYID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0WSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0QWx0ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJpb3JpdHkgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hbGlnbiA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFN0cmFpZ2h0TGFiZWxzIGNsYXNzSWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPG51bWJlcj59IGNsYXNzSWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlLlN0cmFpZ2h0TGFiZWxzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU3RyYWlnaHRMYWJlbHMucHJvdG90eXBlLmNsYXNzSWQgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogU3RyYWlnaHRMYWJlbHMgY2VudGVyWC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48bnVtYmVyPn0gY2VudGVyWFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi50aWxlLlRpbGUuU3RyYWlnaHRMYWJlbHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTdHJhaWdodExhYmVscy5wcm90b3R5cGUuY2VudGVyWCA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBTdHJhaWdodExhYmVscyBjZW50ZXJZLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXIge0FycmF5LjxudW1iZXI+fSBjZW50ZXJZXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZS5TdHJhaWdodExhYmVsc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFN0cmFpZ2h0TGFiZWxzLnByb3RvdHlwZS5jZW50ZXJZID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFN0cmFpZ2h0TGFiZWxzIG9mZnNldFguXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPG51bWJlcj59IG9mZnNldFhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlLlN0cmFpZ2h0TGFiZWxzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU3RyYWlnaHRMYWJlbHMucHJvdG90eXBlLm9mZnNldFggPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogU3RyYWlnaHRMYWJlbHMgb2Zmc2V0WS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48bnVtYmVyPn0gb2Zmc2V0WVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi50aWxlLlRpbGUuU3RyYWlnaHRMYWJlbHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTdHJhaWdodExhYmVscy5wcm90b3R5cGUub2Zmc2V0WSA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBTdHJhaWdodExhYmVscyB0ZXh0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXIge0FycmF5Ljx5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi50aWxlLlRpbGUuU2hhcGVkVGV4dD59IHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlLlN0cmFpZ2h0TGFiZWxzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU3RyYWlnaHRMYWJlbHMucHJvdG90eXBlLnRleHQgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogU3RyYWlnaHRMYWJlbHMgdGV4dEFsdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48eWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlLlNoYXBlZFRleHQ+fSB0ZXh0QWx0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZS5TdHJhaWdodExhYmVsc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFN0cmFpZ2h0TGFiZWxzLnByb3RvdHlwZS50ZXh0QWx0ID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFN0cmFpZ2h0TGFiZWxzIHByaW9yaXR5LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXIge0FycmF5LjxudW1iZXI+fSBwcmlvcml0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi50aWxlLlRpbGUuU3RyYWlnaHRMYWJlbHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTdHJhaWdodExhYmVscy5wcm90b3R5cGUucHJpb3JpdHkgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogU3RyYWlnaHRMYWJlbHMgYWxpZ24uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZS5TdHJhaWdodExhYmVscy5BbGlnblR5cGU+fSBhbGlnblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi50aWxlLlRpbGUuU3RyYWlnaHRMYWJlbHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTdHJhaWdodExhYmVscy5wcm90b3R5cGUuYWxpZ24gPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRGVjb2RlcyBhIFN0cmFpZ2h0TGFiZWxzIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi50aWxlLlRpbGUuU3RyYWlnaHRMYWJlbHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7eWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlLlN0cmFpZ2h0TGFiZWxzfSBTdHJhaWdodExhYmVsc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU3RyYWlnaHRMYWJlbHMuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QueWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlLlN0cmFpZ2h0TGFiZWxzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLmNsYXNzSWQgJiYgbWVzc2FnZS5jbGFzc0lkLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY2xhc3NJZCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodGFnICYgNykgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZDIgPSByZWFkZXIudWludDMyKCkgKyByZWFkZXIucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZDIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNsYXNzSWQucHVzaChyZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNsYXNzSWQucHVzaChyZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UuY2VudGVyWCAmJiBtZXNzYWdlLmNlbnRlclgubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jZW50ZXJYID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh0YWcgJiA3KSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kMiA9IHJlYWRlci51aW50MzIoKSArIHJlYWRlci5wb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY2VudGVyWC5wdXNoKHJlYWRlci5zaW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY2VudGVyWC5wdXNoKHJlYWRlci5zaW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5jZW50ZXJZICYmIG1lc3NhZ2UuY2VudGVyWS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNlbnRlclkgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHRhZyAmIDcpID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmQyID0gcmVhZGVyLnVpbnQzMigpICsgcmVhZGVyLnBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jZW50ZXJZLnB1c2gocmVhZGVyLnNpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jZW50ZXJZLnB1c2gocmVhZGVyLnNpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLm9mZnNldFggJiYgbWVzc2FnZS5vZmZzZXRYLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uub2Zmc2V0WCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodGFnICYgNykgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZDIgPSByZWFkZXIudWludDMyKCkgKyByZWFkZXIucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZDIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm9mZnNldFgucHVzaChyZWFkZXIuc2ludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm9mZnNldFgucHVzaChyZWFkZXIuc2ludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2Uub2Zmc2V0WSAmJiBtZXNzYWdlLm9mZnNldFkubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5vZmZzZXRZID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh0YWcgJiA3KSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kMiA9IHJlYWRlci51aW50MzIoKSArIHJlYWRlci5wb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uub2Zmc2V0WS5wdXNoKHJlYWRlci5zaW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uub2Zmc2V0WS5wdXNoKHJlYWRlci5zaW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS50ZXh0ICYmIG1lc3NhZ2UudGV4dC5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRleHQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRleHQucHVzaCgkcm9vdC55YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi50aWxlLlRpbGUuU2hhcGVkVGV4dC5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLnRleHRBbHQgJiYgbWVzc2FnZS50ZXh0QWx0Lmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudGV4dEFsdCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudGV4dEFsdC5wdXNoKCRyb290LnlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZS5TaGFwZWRUZXh0LmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UucHJpb3JpdHkgJiYgbWVzc2FnZS5wcmlvcml0eS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnByaW9yaXR5ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh0YWcgJiA3KSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kMiA9IHJlYWRlci51aW50MzIoKSArIHJlYWRlci5wb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucHJpb3JpdHkucHVzaChyZWFkZXIuc2ludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnByaW9yaXR5LnB1c2gocmVhZGVyLnNpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLmFsaWduICYmIG1lc3NhZ2UuYWxpZ24ubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hbGlnbiA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodGFnICYgNykgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZDIgPSByZWFkZXIudWludDMyKCkgKyByZWFkZXIucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZDIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmFsaWduLnB1c2gocmVhZGVyLmludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmFsaWduLnB1c2gocmVhZGVyLmludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEFsaWduVHlwZSBlbnVtLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBuYW1lIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZS5TdHJhaWdodExhYmVscy5BbGlnblR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZW51bSB7c3RyaW5nfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBMZWZ0PTAgTGVmdCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBDZW50ZXI9MSBDZW50ZXIgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gUmlnaHQ9MiBSaWdodCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFN0cmFpZ2h0TGFiZWxzLkFsaWduVHlwZSA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlc0J5SWQgPSB7fSwgdmFsdWVzID0gT2JqZWN0LmNyZWF0ZSh2YWx1ZXNCeUlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMF0gPSBcIkxlZnRcIl0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFsxXSA9IFwiQ2VudGVyXCJdID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMl0gPSBcIlJpZ2h0XCJdID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN0cmFpZ2h0TGFiZWxzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgVGlsZS5DdXJ2ZWRMYWJlbHMgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgQ3VydmVkTGFiZWxzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi50aWxlLlRpbGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW50ZXJmYWNlIElDdXJ2ZWRMYWJlbHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5LjxudW1iZXI+fG51bGx9IFtjbGFzc0lkXSBDdXJ2ZWRMYWJlbHMgY2xhc3NJZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZS5TaGFwZWRTdHJpbmc+fG51bGx9IFt0ZXh0XSBDdXJ2ZWRMYWJlbHMgdGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZS5TaGFwZWRTdHJpbmc+fG51bGx9IFt0ZXh0QWx0XSBDdXJ2ZWRMYWJlbHMgdGV4dEFsdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG51bWJlcj58bnVsbH0gW3ByaW9yaXR5XSBDdXJ2ZWRMYWJlbHMgcHJpb3JpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5LjxudW1iZXI+fG51bGx9IFt2ZXJ0aWNlc0NvdW50XSBDdXJ2ZWRMYWJlbHMgdmVydGljZXNDb3VudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPG51bWJlcj58bnVsbH0gW3ZlcnRleFhdIEN1cnZlZExhYmVscyB2ZXJ0ZXhYXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48bnVtYmVyPnxudWxsfSBbdmVydGV4WV0gQ3VydmVkTGFiZWxzIHZlcnRleFlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgQ3VydmVkTGFiZWxzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi50aWxlLlRpbGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBDdXJ2ZWRMYWJlbHMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGltcGxlbWVudHMgSUN1cnZlZExhYmVsc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7eWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlLklDdXJ2ZWRMYWJlbHM9fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBDdXJ2ZWRMYWJlbHMocHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsYXNzSWQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGV4dEFsdCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByaW9yaXR5ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmVydGljZXNDb3VudCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZlcnRleFggPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52ZXJ0ZXhZID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQ3VydmVkTGFiZWxzIGNsYXNzSWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPG51bWJlcj59IGNsYXNzSWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlLkN1cnZlZExhYmVsc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEN1cnZlZExhYmVscy5wcm90b3R5cGUuY2xhc3NJZCA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBDdXJ2ZWRMYWJlbHMgdGV4dC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48eWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlLlNoYXBlZFN0cmluZz59IHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlLkN1cnZlZExhYmVsc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEN1cnZlZExhYmVscy5wcm90b3R5cGUudGV4dCA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBDdXJ2ZWRMYWJlbHMgdGV4dEFsdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48eWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlLlNoYXBlZFN0cmluZz59IHRleHRBbHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlLkN1cnZlZExhYmVsc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEN1cnZlZExhYmVscy5wcm90b3R5cGUudGV4dEFsdCA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBDdXJ2ZWRMYWJlbHMgcHJpb3JpdHkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPG51bWJlcj59IHByaW9yaXR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZS5DdXJ2ZWRMYWJlbHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDdXJ2ZWRMYWJlbHMucHJvdG90eXBlLnByaW9yaXR5ID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEN1cnZlZExhYmVscyB2ZXJ0aWNlc0NvdW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXIge0FycmF5LjxudW1iZXI+fSB2ZXJ0aWNlc0NvdW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZS5DdXJ2ZWRMYWJlbHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDdXJ2ZWRMYWJlbHMucHJvdG90eXBlLnZlcnRpY2VzQ291bnQgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQ3VydmVkTGFiZWxzIHZlcnRleFguXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPG51bWJlcj59IHZlcnRleFhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlLkN1cnZlZExhYmVsc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEN1cnZlZExhYmVscy5wcm90b3R5cGUudmVydGV4WCA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBDdXJ2ZWRMYWJlbHMgdmVydGV4WS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48bnVtYmVyPn0gdmVydGV4WVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi50aWxlLlRpbGUuQ3VydmVkTGFiZWxzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ3VydmVkTGFiZWxzLnByb3RvdHlwZS52ZXJ0ZXhZID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERlY29kZXMgYSBDdXJ2ZWRMYWJlbHMgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZS5DdXJ2ZWRMYWJlbHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7eWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlLkN1cnZlZExhYmVsc30gQ3VydmVkTGFiZWxzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDdXJ2ZWRMYWJlbHMuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QueWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlLkN1cnZlZExhYmVscygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5jbGFzc0lkICYmIG1lc3NhZ2UuY2xhc3NJZC5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNsYXNzSWQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHRhZyAmIDcpID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmQyID0gcmVhZGVyLnVpbnQzMigpICsgcmVhZGVyLnBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jbGFzc0lkLnB1c2gocmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jbGFzc0lkLnB1c2gocmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLnRleHQgJiYgbWVzc2FnZS50ZXh0Lmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudGV4dCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudGV4dC5wdXNoKCRyb290LnlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZS5TaGFwZWRTdHJpbmcuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS50ZXh0QWx0ICYmIG1lc3NhZ2UudGV4dEFsdC5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRleHRBbHQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRleHRBbHQucHVzaCgkcm9vdC55YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi50aWxlLlRpbGUuU2hhcGVkU3RyaW5nLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UucHJpb3JpdHkgJiYgbWVzc2FnZS5wcmlvcml0eS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnByaW9yaXR5ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh0YWcgJiA3KSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kMiA9IHJlYWRlci51aW50MzIoKSArIHJlYWRlci5wb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucHJpb3JpdHkucHVzaChyZWFkZXIuc2ludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnByaW9yaXR5LnB1c2gocmVhZGVyLnNpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLnZlcnRpY2VzQ291bnQgJiYgbWVzc2FnZS52ZXJ0aWNlc0NvdW50Lmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmVydGljZXNDb3VudCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodGFnICYgNykgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZDIgPSByZWFkZXIudWludDMyKCkgKyByZWFkZXIucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZDIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnZlcnRpY2VzQ291bnQucHVzaChyZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnZlcnRpY2VzQ291bnQucHVzaChyZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UudmVydGV4WCAmJiBtZXNzYWdlLnZlcnRleFgubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52ZXJ0ZXhYID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh0YWcgJiA3KSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kMiA9IHJlYWRlci51aW50MzIoKSArIHJlYWRlci5wb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmVydGV4WC5wdXNoKHJlYWRlci5zaW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmVydGV4WC5wdXNoKHJlYWRlci5zaW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS52ZXJ0ZXhZICYmIG1lc3NhZ2UudmVydGV4WS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnZlcnRleFkgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHRhZyAmIDcpID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmQyID0gcmVhZGVyLnVpbnQzMigpICsgcmVhZGVyLnBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52ZXJ0ZXhZLnB1c2gocmVhZGVyLnNpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52ZXJ0ZXhZLnB1c2gocmVhZGVyLnNpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQ3VydmVkTGFiZWxzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgVGlsZS5MYXllciA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFByb3BlcnRpZXMgb2YgYSBMYXllci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGludGVyZmFjZSBJTGF5ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbbmFtZV0gTGF5ZXIgbmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPHN0cmluZz58bnVsbH0gW2lkc10gTGF5ZXIgaWRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48bnVtYmVyPnxudWxsfSBbb2JqZWN0SW5kaWNlc10gTGF5ZXIgb2JqZWN0SW5kaWNlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPHN0cmluZz58bnVsbH0gW2tleXNdIExheWVyIGtleXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5LjxzdHJpbmc+fG51bGx9IFt2YWx1ZXNdIExheWVyIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBMYXllci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgTGF5ZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGltcGxlbWVudHMgSUxheWVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHt5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi50aWxlLlRpbGUuSUxheWVyPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gTGF5ZXIocHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlkcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9iamVjdEluZGljZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5rZXlzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWVzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogTGF5ZXIgbmFtZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IG5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlLkxheWVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTGF5ZXIucHJvdG90eXBlLm5hbWUgPSBcIlwiO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogTGF5ZXIgaWRzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXIge0FycmF5LjxzdHJpbmc+fSBpZHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlLkxheWVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTGF5ZXIucHJvdG90eXBlLmlkcyA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBMYXllciBvYmplY3RJbmRpY2VzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXIge0FycmF5LjxudW1iZXI+fSBvYmplY3RJbmRpY2VzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZS5MYXllclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIExheWVyLnByb3RvdHlwZS5vYmplY3RJbmRpY2VzID0gJHV0aWwuZW1wdHlBcnJheTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIExheWVyIGtleXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlciB7QXJyYXkuPHN0cmluZz59IGtleXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlLkxheWVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTGF5ZXIucHJvdG90eXBlLmtleXMgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogTGF5ZXIgdmFsdWVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXIge0FycmF5LjxzdHJpbmc+fSB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIudGlsZS5UaWxlLkxheWVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTGF5ZXIucHJvdG90eXBlLnZhbHVlcyA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEZWNvZGVzIGEgTGF5ZXIgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnRpbGUuVGlsZS5MYXllclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHt5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi50aWxlLlRpbGUuTGF5ZXJ9IExheWVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBMYXllci5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC55YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi50aWxlLlRpbGUuTGF5ZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubmFtZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLmlkcyAmJiBtZXNzYWdlLmlkcy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmlkcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaWRzLnB1c2gocmVhZGVyLnN0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLm9iamVjdEluZGljZXMgJiYgbWVzc2FnZS5vYmplY3RJbmRpY2VzLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uub2JqZWN0SW5kaWNlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodGFnICYgNykgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZDIgPSByZWFkZXIudWludDMyKCkgKyByZWFkZXIucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZDIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm9iamVjdEluZGljZXMucHVzaChyZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm9iamVjdEluZGljZXMucHVzaChyZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2Uua2V5cyAmJiBtZXNzYWdlLmtleXMubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5rZXlzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5rZXlzLnB1c2gocmVhZGVyLnN0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLnZhbHVlcyAmJiBtZXNzYWdlLnZhbHVlcy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudmFsdWVzLnB1c2gocmVhZGVyLnN0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTGF5ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gVGlsZTtcbiAgICAgICAgICAgICAgICAgICAgfSkoKTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGlsZTtcbiAgICAgICAgICAgICAgICB9KSgpO1xuXG4gICAgICAgICAgICAgICAgdmVjdG9yZGF0YTIucHJlc2VudGF0aW9uID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBOYW1lc3BhY2UgcHJlc2VudGF0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTJcbiAgICAgICAgICAgICAgICAgICAgICogQG5hbWVzcGFjZVxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZXNlbnRhdGlvbiA9IHt9O1xuXG4gICAgICAgICAgICAgICAgICAgIHByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24gPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogUHJvcGVydGllcyBvZiBhIFByZXNlbnRhdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbnRlcmZhY2UgSVByZXNlbnRhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48eWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcz58bnVsbH0gW2NsYXNzZXNdIFByZXNlbnRhdGlvbiBjbGFzc2VzXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbbmFtZV0gUHJlc2VudGF0aW9uIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7eWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5QYXJhbWV0ZXJzfG51bGx9IFtwYXJhbXNdIFByZXNlbnRhdGlvbiBwYXJhbXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgUHJlc2VudGF0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgUHJlc2VudGF0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICogQGltcGxlbWVudHMgSVByZXNlbnRhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3lhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5JUHJlc2VudGF0aW9uPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFByZXNlbnRhdGlvbihwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGFzc2VzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBQcmVzZW50YXRpb24gY2xhc3Nlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXIge0FycmF5Ljx5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzPn0gY2xhc3Nlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICBQcmVzZW50YXRpb24ucHJvdG90eXBlLmNsYXNzZXMgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIFByZXNlbnRhdGlvbiBuYW1lLlxuICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSBuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIFByZXNlbnRhdGlvbi5wcm90b3R5cGUubmFtZSA9IFwiXCI7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogUHJlc2VudGF0aW9uIHBhcmFtcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXIge3lhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uUGFyYW1ldGVyc3xudWxsfHVuZGVmaW5lZH0gcGFyYW1zXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIFByZXNlbnRhdGlvbi5wcm90b3R5cGUucGFyYW1zID0gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBEZWNvZGVzIGEgUHJlc2VudGF0aW9uIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICogQHJldHVybnMge3lhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb259IFByZXNlbnRhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICBQcmVzZW50YXRpb24uZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QueWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UuY2xhc3NlcyAmJiBtZXNzYWdlLmNsYXNzZXMubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNsYXNzZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY2xhc3Nlcy5wdXNoKCRyb290LnlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3MuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5uYW1lID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucGFyYW1zID0gJHJvb3QueWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5QYXJhbWV0ZXJzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgUHJlc2VudGF0aW9uLkNsYXNzID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogUHJvcGVydGllcyBvZiBhIENsYXNzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGludGVyZmFjZSBJQ2xhc3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcnxudWxsfSBbaWRdIENsYXNzIGlkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW25hbWVdIENsYXNzIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5Ljx5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzLlpvb21TbGljZT58bnVsbH0gW3NsaWNlc10gQ2xhc3Mgc2xpY2VzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IENsYXNzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgQ2xhc3MuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGltcGxlbWVudHMgSUNsYXNzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHt5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLklDbGFzcz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIENsYXNzKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zbGljZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBDbGFzcyBpZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGlkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDbGFzcy5wcm90b3R5cGUuaWQgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQ2xhc3MgbmFtZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IG5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIENsYXNzLnByb3RvdHlwZS5uYW1lID0gXCJcIjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIENsYXNzIHNsaWNlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48eWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5ab29tU2xpY2U+fSBzbGljZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIENsYXNzLnByb3RvdHlwZS5zbGljZXMgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRGVjb2RlcyBhIENsYXNzIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHJldHVybnMge3lhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3N9IENsYXNzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDbGFzcy5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC55YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmlkID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubmFtZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtZXNzYWdlLnNsaWNlcyAmJiBtZXNzYWdlLnNsaWNlcy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNsaWNlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2xpY2VzLnB1c2goJHJvb3QueWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5ab29tU2xpY2UuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2xhc3MuWm9vbVJhbmdlID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgWm9vbVJhbmdlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW50ZXJmYWNlIElab29tUmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8bnVsbH0gW21pbl0gWm9vbVJhbmdlIG1pblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcnxudWxsfSBbbWF4XSBab29tUmFuZ2UgbWF4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFpvb21SYW5nZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgWm9vbVJhbmdlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW1wbGVtZW50cyBJWm9vbVJhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3lhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3MuSVpvb21SYW5nZT19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gWm9vbVJhbmdlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogWm9vbVJhbmdlIG1pbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfSBtaW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3MuWm9vbVJhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWm9vbVJhbmdlLnByb3RvdHlwZS5taW4gPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBab29tUmFuZ2UgbWF4LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IG1heFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5ab29tUmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBab29tUmFuZ2UucHJvdG90eXBlLm1heCA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERlY29kZXMgYSBab29tUmFuZ2UgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5ab29tUmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHJldHVybnMge3lhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3MuWm9vbVJhbmdlfSBab29tUmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBab29tUmFuZ2UuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QueWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5ab29tUmFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5taW4gPSByZWFkZXIuc2ludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5tYXggPSByZWFkZXIuc2ludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFpvb21SYW5nZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2xhc3MuSW1hZ2UgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFByb3BlcnRpZXMgb2YgYW4gSW1hZ2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbnRlcmZhY2UgSUltYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtpZF0gSW1hZ2UgaWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8bnVsbH0gW3dpZHRoXSBJbWFnZSB3aWR0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBJbWFnZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGFuIEltYWdlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW1wbGVtZW50cyBJSW1hZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7eWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5JSW1hZ2U9fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEltYWdlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogSW1hZ2UgaWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXIge3N0cmluZ30gaWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3MuSW1hZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbWFnZS5wcm90b3R5cGUuaWQgPSBcIlwiO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBJbWFnZSB3aWR0aC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfSB3aWR0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5JbWFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEltYWdlLnByb3RvdHlwZS53aWR0aCA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERlY29kZXMgYW4gSW1hZ2UgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5JbWFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7eWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5JbWFnZX0gSW1hZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbWFnZS5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC55YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzLkltYWdlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaWQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS53aWR0aCA9IHJlYWRlci5mbG9hdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBJbWFnZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2xhc3MuUG9pbnRTdHlsZSA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogUHJvcGVydGllcyBvZiBhIFBvaW50U3R5bGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbnRlcmZhY2UgSVBvaW50U3R5bGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHt5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzLkltYWdlfG51bGx9IFtpY29uXSBQb2ludFN0eWxlIGljb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8bnVsbH0gW2FuY2hvclhdIFBvaW50U3R5bGUgYW5jaG9yWFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcnxudWxsfSBbYW5jaG9yWV0gUG9pbnRTdHlsZSBhbmNob3JZXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7eWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5JbWFnZXxudWxsfSBbc2VsZWN0ZWRJY29uXSBQb2ludFN0eWxlIHNlbGVjdGVkSWNvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcnxudWxsfSBbc2VsZWN0ZWRBbmNob3JYXSBQb2ludFN0eWxlIHNlbGVjdGVkQW5jaG9yWFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcnxudWxsfSBbc2VsZWN0ZWRBbmNob3JZXSBQb2ludFN0eWxlIHNlbGVjdGVkQW5jaG9yWVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBQb2ludFN0eWxlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBQb2ludFN0eWxlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW1wbGVtZW50cyBJUG9pbnRTdHlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHt5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzLklQb2ludFN0eWxlPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBQb2ludFN0eWxlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogUG9pbnRTdHlsZSBpY29uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHt5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzLkltYWdlfG51bGx8dW5kZWZpbmVkfSBpY29uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzLlBvaW50U3R5bGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQb2ludFN0eWxlLnByb3RvdHlwZS5pY29uID0gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogUG9pbnRTdHlsZSBhbmNob3JYLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGFuY2hvclhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3MuUG9pbnRTdHlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvaW50U3R5bGUucHJvdG90eXBlLmFuY2hvclggPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBQb2ludFN0eWxlIGFuY2hvclkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXIge251bWJlcn0gYW5jaG9yWVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5Qb2ludFN0eWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUG9pbnRTdHlsZS5wcm90b3R5cGUuYW5jaG9yWSA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFBvaW50U3R5bGUgc2VsZWN0ZWRJY29uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHt5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzLkltYWdlfG51bGx8dW5kZWZpbmVkfSBzZWxlY3RlZEljb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3MuUG9pbnRTdHlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvaW50U3R5bGUucHJvdG90eXBlLnNlbGVjdGVkSWNvbiA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFBvaW50U3R5bGUgc2VsZWN0ZWRBbmNob3JYLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IHNlbGVjdGVkQW5jaG9yWFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5Qb2ludFN0eWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUG9pbnRTdHlsZS5wcm90b3R5cGUuc2VsZWN0ZWRBbmNob3JYID0gMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogUG9pbnRTdHlsZSBzZWxlY3RlZEFuY2hvclkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXIge251bWJlcn0gc2VsZWN0ZWRBbmNob3JZXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzLlBvaW50U3R5bGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQb2ludFN0eWxlLnByb3RvdHlwZS5zZWxlY3RlZEFuY2hvclkgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEZWNvZGVzIGEgUG9pbnRTdHlsZSBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzLlBvaW50U3R5bGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHJldHVybnMge3lhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3MuUG9pbnRTdHlsZX0gUG9pbnRTdHlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvaW50U3R5bGUuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QueWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5Qb2ludFN0eWxlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaWNvbiA9ICRyb290LnlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3MuSW1hZ2UuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmFuY2hvclggPSByZWFkZXIuZmxvYXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmFuY2hvclkgPSByZWFkZXIuZmxvYXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNlbGVjdGVkSWNvbiA9ICRyb290LnlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3MuSW1hZ2UuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnNlbGVjdGVkQW5jaG9yWCA9IHJlYWRlci5mbG9hdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uuc2VsZWN0ZWRBbmNob3JZID0gcmVhZGVyLmZsb2F0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBvaW50U3R5bGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIENsYXNzLkRhc2hJdGVtID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgRGFzaEl0ZW0uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbnRlcmZhY2UgSURhc2hJdGVtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfG51bGx9IFtmaWxsXSBEYXNoSXRlbSBmaWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfG51bGx9IFtnYXBdIERhc2hJdGVtIGdhcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBEYXNoSXRlbS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgRGFzaEl0ZW0uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbXBsZW1lbnRzIElEYXNoSXRlbVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHt5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzLklEYXNoSXRlbT19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gRGFzaEl0ZW0ocHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEYXNoSXRlbSBmaWxsLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGZpbGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3MuRGFzaEl0ZW1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEYXNoSXRlbS5wcm90b3R5cGUuZmlsbCA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERhc2hJdGVtIGdhcC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfSBnYXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3MuRGFzaEl0ZW1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEYXNoSXRlbS5wcm90b3R5cGUuZ2FwID0gMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRGVjb2RlcyBhIERhc2hJdGVtIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3MuRGFzaEl0ZW1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHJldHVybnMge3lhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3MuRGFzaEl0ZW19IERhc2hJdGVtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGFzaEl0ZW0uZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QueWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5EYXNoSXRlbSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmZpbGwgPSByZWFkZXIuZmxvYXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmdhcCA9IHJlYWRlci5mbG9hdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBEYXNoSXRlbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2xhc3MuRGFzaFN0eWxlID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgRGFzaFN0eWxlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW50ZXJmYWNlIElEYXNoU3R5bGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtBcnJheS48eWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5EYXNoSXRlbT58bnVsbH0gW2Rhc2hlc10gRGFzaFN0eWxlIGRhc2hlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBEYXNoU3R5bGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIERhc2hTdHlsZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGltcGxlbWVudHMgSURhc2hTdHlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHt5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzLklEYXNoU3R5bGU9fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIERhc2hTdHlsZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRhc2hlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEYXNoU3R5bGUgZGFzaGVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHtBcnJheS48eWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5EYXNoSXRlbT59IGRhc2hlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5EYXNoU3R5bGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEYXNoU3R5bGUucHJvdG90eXBlLmRhc2hlcyA9ICR1dGlsLmVtcHR5QXJyYXk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERlY29kZXMgYSBEYXNoU3R5bGUgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5EYXNoU3R5bGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHJldHVybnMge3lhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3MuRGFzaFN0eWxlfSBEYXNoU3R5bGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEYXNoU3R5bGUuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QueWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5EYXNoU3R5bGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWVzc2FnZS5kYXNoZXMgJiYgbWVzc2FnZS5kYXNoZXMubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGFzaGVzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZGFzaGVzLnB1c2goJHJvb3QueWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5EYXNoSXRlbS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGFzaFN0eWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDbGFzcy5MaW5lU3R5bGUgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFByb3BlcnRpZXMgb2YgYSBMaW5lU3R5bGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbnRlcmZhY2UgSUxpbmVTdHlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcnxudWxsfSBbY29sb3JdIExpbmVTdHlsZSBjb2xvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcnxudWxsfSBbd2lkdGhdIExpbmVTdHlsZSB3aWR0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge3lhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3MuTGluZVN0eWxlLkNhcFN0eWxlfG51bGx9IFtjYXBzXSBMaW5lU3R5bGUgY2Fwc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge3lhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3MuTGluZVN0eWxlLkpvaW5TdHlsZXxudWxsfSBbam9pbnNdIExpbmVTdHlsZSBqb2luc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge3lhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3MuRGFzaFN0eWxlfG51bGx9IFtkYXNoXSBMaW5lU3R5bGUgZGFzaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge3lhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3MuSW1hZ2V8bnVsbH0gW3BhdHRlcm5dIExpbmVTdHlsZSBwYXR0ZXJuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IExpbmVTdHlsZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgTGluZVN0eWxlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW1wbGVtZW50cyBJTGluZVN0eWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3lhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3MuSUxpbmVTdHlsZT19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gTGluZVN0eWxlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogTGluZVN0eWxlIGNvbG9yLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGNvbG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzLkxpbmVTdHlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIExpbmVTdHlsZS5wcm90b3R5cGUuY29sb3IgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBMaW5lU3R5bGUgd2lkdGguXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXIge251bWJlcn0gd2lkdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3MuTGluZVN0eWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTGluZVN0eWxlLnByb3RvdHlwZS53aWR0aCA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIExpbmVTdHlsZSBjYXBzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHt5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzLkxpbmVTdHlsZS5DYXBTdHlsZX0gY2Fwc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5MaW5lU3R5bGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBMaW5lU3R5bGUucHJvdG90eXBlLmNhcHMgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBMaW5lU3R5bGUgam9pbnMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXIge3lhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3MuTGluZVN0eWxlLkpvaW5TdHlsZX0gam9pbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3MuTGluZVN0eWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTGluZVN0eWxlLnByb3RvdHlwZS5qb2lucyA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIExpbmVTdHlsZSBkYXNoLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHt5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzLkRhc2hTdHlsZXxudWxsfHVuZGVmaW5lZH0gZGFzaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5MaW5lU3R5bGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBMaW5lU3R5bGUucHJvdG90eXBlLmRhc2ggPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBMaW5lU3R5bGUgcGF0dGVybi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlciB7eWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5JbWFnZXxudWxsfHVuZGVmaW5lZH0gcGF0dGVyblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5MaW5lU3R5bGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBMaW5lU3R5bGUucHJvdG90eXBlLnBhdHRlcm4gPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBEZWNvZGVzIGEgTGluZVN0eWxlIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3MuTGluZVN0eWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHt5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzLkxpbmVTdHlsZX0gTGluZVN0eWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTGluZVN0eWxlLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290LnlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3MuTGluZVN0eWxlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuY29sb3IgPSByZWFkZXIuZml4ZWQzMigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uud2lkdGggPSByZWFkZXIuZmxvYXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNhcHMgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmpvaW5zID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5kYXNoID0gJHJvb3QueWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5EYXNoU3R5bGUuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBhdHRlcm4gPSAkcm9vdC55YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzLkltYWdlLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIENhcFN0eWxlIGVudW0uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBuYW1lIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3MuTGluZVN0eWxlLkNhcFN0eWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBlbnVtIHtzdHJpbmd9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBDYXBSb3VuZD0wIENhcFJvdW5kIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBDYXBCZXZlbD0xIENhcEJldmVsIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBDYXBTcXVhcmU9MiBDYXBTcXVhcmUgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIExpbmVTdHlsZS5DYXBTdHlsZSA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZXNCeUlkID0ge30sIHZhbHVlcyA9IE9iamVjdC5jcmVhdGUodmFsdWVzQnlJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFswXSA9IFwiQ2FwUm91bmRcIl0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMV0gPSBcIkNhcEJldmVsXCJdID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzJdID0gXCJDYXBTcXVhcmVcIl0gPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogSm9pblN0eWxlIGVudW0uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBuYW1lIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3MuTGluZVN0eWxlLkpvaW5TdHlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZW51bSB7c3RyaW5nfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gSm9pbk1pdGVyPTAgSm9pbk1pdGVyIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBKb2luUm91bmQ9MSBKb2luUm91bmQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IEpvaW5CZXZlbD0yIEpvaW5CZXZlbCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTGluZVN0eWxlLkpvaW5TdHlsZSA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZXNCeUlkID0ge30sIHZhbHVlcyA9IE9iamVjdC5jcmVhdGUodmFsdWVzQnlJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXNbdmFsdWVzQnlJZFswXSA9IFwiSm9pbk1pdGVyXCJdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlc1t2YWx1ZXNCeUlkWzFdID0gXCJKb2luUm91bmRcIl0gPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzW3ZhbHVlc0J5SWRbMl0gPSBcIkpvaW5CZXZlbFwiXSA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBMaW5lU3R5bGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIENsYXNzLlBvbHlsaW5lU3R5bGUgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFByb3BlcnRpZXMgb2YgYSBQb2x5bGluZVN0eWxlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW50ZXJmYWNlIElQb2x5bGluZVN0eWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7eWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5MaW5lU3R5bGV8bnVsbH0gW2xpbmVdIFBvbHlsaW5lU3R5bGUgbGluZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge3lhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3MuTGluZVN0eWxlfG51bGx9IFtvdXRsaW5lXSBQb2x5bGluZVN0eWxlIG91dGxpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgUG9seWxpbmVTdHlsZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgUG9seWxpbmVTdHlsZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGltcGxlbWVudHMgSVBvbHlsaW5lU3R5bGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7eWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5JUG9seWxpbmVTdHlsZT19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gUG9seWxpbmVTdHlsZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFBvbHlsaW5lU3R5bGUgbGluZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlciB7eWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5MaW5lU3R5bGV8bnVsbHx1bmRlZmluZWR9IGxpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3MuUG9seWxpbmVTdHlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvbHlsaW5lU3R5bGUucHJvdG90eXBlLmxpbmUgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBQb2x5bGluZVN0eWxlIG91dGxpbmUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXIge3lhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3MuTGluZVN0eWxlfG51bGx8dW5kZWZpbmVkfSBvdXRsaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzLlBvbHlsaW5lU3R5bGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQb2x5bGluZVN0eWxlLnByb3RvdHlwZS5vdXRsaW5lID0gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRGVjb2RlcyBhIFBvbHlsaW5lU3R5bGUgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5Qb2x5bGluZVN0eWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHt5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzLlBvbHlsaW5lU3R5bGV9IFBvbHlsaW5lU3R5bGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQb2x5bGluZVN0eWxlLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290LnlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3MuUG9seWxpbmVTdHlsZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmxpbmUgPSAkcm9vdC55YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzLkxpbmVTdHlsZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2Uub3V0bGluZSA9ICRyb290LnlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3MuTGluZVN0eWxlLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBvbHlsaW5lU3R5bGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIENsYXNzLlBvbHlnb25TdHlsZSA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogUHJvcGVydGllcyBvZiBhIFBvbHlnb25TdHlsZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGludGVyZmFjZSBJUG9seWdvblN0eWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7eWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5JbWFnZXxudWxsfSBbcGF0dGVybl0gUG9seWdvblN0eWxlIHBhdHRlcm5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8bnVsbH0gW2NvbG9yXSBQb2x5Z29uU3R5bGUgY29sb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHt5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzLlBvbHlnb25TdHlsZS5FeHRydXNpb258bnVsbH0gW2V4dHJ1c2lvbl0gUG9seWdvblN0eWxlIGV4dHJ1c2lvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge3lhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3MuTGluZVN0eWxlfG51bGx9IFtjb250b3VyXSBQb2x5Z29uU3R5bGUgY29udG91clxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBQb2x5Z29uU3R5bGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIFBvbHlnb25TdHlsZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGltcGxlbWVudHMgSVBvbHlnb25TdHlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHt5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzLklQb2x5Z29uU3R5bGU9fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFBvbHlnb25TdHlsZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFBvbHlnb25TdHlsZSBwYXR0ZXJuLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHt5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzLkltYWdlfG51bGx8dW5kZWZpbmVkfSBwYXR0ZXJuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzLlBvbHlnb25TdHlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvbHlnb25TdHlsZS5wcm90b3R5cGUucGF0dGVybiA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFBvbHlnb25TdHlsZSBjb2xvci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfSBjb2xvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5Qb2x5Z29uU3R5bGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQb2x5Z29uU3R5bGUucHJvdG90eXBlLmNvbG9yID0gMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogUG9seWdvblN0eWxlIGV4dHJ1c2lvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlciB7eWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5Qb2x5Z29uU3R5bGUuRXh0cnVzaW9ufG51bGx8dW5kZWZpbmVkfSBleHRydXNpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3MuUG9seWdvblN0eWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUG9seWdvblN0eWxlLnByb3RvdHlwZS5leHRydXNpb24gPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBQb2x5Z29uU3R5bGUgY29udG91ci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlciB7eWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5MaW5lU3R5bGV8bnVsbHx1bmRlZmluZWR9IGNvbnRvdXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3MuUG9seWdvblN0eWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUG9seWdvblN0eWxlLnByb3RvdHlwZS5jb250b3VyID0gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRGVjb2RlcyBhIFBvbHlnb25TdHlsZSBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzLlBvbHlnb25TdHlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7eWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5Qb2x5Z29uU3R5bGV9IFBvbHlnb25TdHlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvbHlnb25TdHlsZS5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC55YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzLlBvbHlnb25TdHlsZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnBhdHRlcm4gPSAkcm9vdC55YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzLkltYWdlLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jb2xvciA9IHJlYWRlci5maXhlZDMyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5leHRydXNpb24gPSAkcm9vdC55YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzLlBvbHlnb25TdHlsZS5FeHRydXNpb24uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNvbnRvdXIgPSAkcm9vdC55YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzLkxpbmVTdHlsZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBvbHlnb25TdHlsZS5FeHRydXNpb24gPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogUHJvcGVydGllcyBvZiBhbiBFeHRydXNpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5Qb2x5Z29uU3R5bGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbnRlcmZhY2UgSUV4dHJ1c2lvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtib29sZWFufG51bGx9IFtlbmFibGVkXSBFeHRydXNpb24gZW5hYmxlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8bnVsbH0gW2hlaWdodF0gRXh0cnVzaW9uIGhlaWdodFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBFeHRydXNpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5Qb2x5Z29uU3R5bGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhbiBFeHRydXNpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW1wbGVtZW50cyBJRXh0cnVzaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7eWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5Qb2x5Z29uU3R5bGUuSUV4dHJ1c2lvbj19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBFeHRydXNpb24ocHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRXh0cnVzaW9uIGVuYWJsZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufSBlbmFibGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5Qb2x5Z29uU3R5bGUuRXh0cnVzaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRXh0cnVzaW9uLnByb3RvdHlwZS5lbmFibGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRXh0cnVzaW9uIGhlaWdodC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXIge251bWJlcn0gaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5Qb2x5Z29uU3R5bGUuRXh0cnVzaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRXh0cnVzaW9uLnByb3RvdHlwZS5oZWlnaHQgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERlY29kZXMgYW4gRXh0cnVzaW9uIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5Qb2x5Z29uU3R5bGUuRXh0cnVzaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7eWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5Qb2x5Z29uU3R5bGUuRXh0cnVzaW9ufSBFeHRydXNpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRXh0cnVzaW9uLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290LnlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3MuUG9seWdvblN0eWxlLkV4dHJ1c2lvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZW5hYmxlZCA9IHJlYWRlci5ib29sKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5oZWlnaHQgPSByZWFkZXIuZmxvYXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRXh0cnVzaW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQb2x5Z29uU3R5bGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIENsYXNzLlRleHRTdHlsZSA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogUHJvcGVydGllcyBvZiBhIFRleHRTdHlsZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGludGVyZmFjZSBJVGV4dFN0eWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfG51bGx9IFtjb2xvcl0gVGV4dFN0eWxlIGNvbG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtmb250SWRdIFRleHRTdHlsZSBmb250SWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8bnVsbH0gW2ZvbnRTaXplXSBUZXh0U3R5bGUgZm9udFNpemVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8bnVsbH0gW291dGxpbmVDb2xvcl0gVGV4dFN0eWxlIG91dGxpbmVDb2xvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBUZXh0U3R5bGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIFRleHRTdHlsZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGltcGxlbWVudHMgSVRleHRTdHlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHt5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzLklUZXh0U3R5bGU9fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFRleHRTdHlsZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFRleHRTdHlsZSBjb2xvci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfSBjb2xvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5UZXh0U3R5bGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUZXh0U3R5bGUucHJvdG90eXBlLmNvbG9yID0gMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogVGV4dFN0eWxlIGZvbnRJZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSBmb250SWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3MuVGV4dFN0eWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGV4dFN0eWxlLnByb3RvdHlwZS5mb250SWQgPSBcIlwiO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBUZXh0U3R5bGUgZm9udFNpemUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXIge251bWJlcn0gZm9udFNpemVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3MuVGV4dFN0eWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGV4dFN0eWxlLnByb3RvdHlwZS5mb250U2l6ZSA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFRleHRTdHlsZSBvdXRsaW5lQ29sb3IuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXIge251bWJlcn0gb3V0bGluZUNvbG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzLlRleHRTdHlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRleHRTdHlsZS5wcm90b3R5cGUub3V0bGluZUNvbG9yID0gMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRGVjb2RlcyBhIFRleHRTdHlsZSBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzLlRleHRTdHlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7eWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5UZXh0U3R5bGV9IFRleHRTdHlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRleHRTdHlsZS5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC55YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzLlRleHRTdHlsZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNvbG9yID0gcmVhZGVyLmZpeGVkMzIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmZvbnRJZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmZvbnRTaXplID0gcmVhZGVyLmZsb2F0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5vdXRsaW5lQ29sb3IgPSByZWFkZXIuZml4ZWQzMigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBUZXh0U3R5bGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIENsYXNzLkxhYmVsU3R5bGUgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFByb3BlcnRpZXMgb2YgYSBMYWJlbFN0eWxlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW50ZXJmYWNlIElMYWJlbFN0eWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7eWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5UZXh0U3R5bGV8bnVsbH0gW3RleHRdIExhYmVsU3R5bGUgdGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge3lhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3MuVGV4dFN0eWxlfG51bGx9IFt0ZXh0QWx0XSBMYWJlbFN0eWxlIHRleHRBbHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8bnVsbH0gW2hkaXN0YW5jZV0gTGFiZWxTdHlsZSBoZGlzdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8bnVsbH0gW3ZkaXN0YW5jZV0gTGFiZWxTdHlsZSB2ZGlzdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHt5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzLkxhYmVsQmFja2dyb3VuZFN0eWxlfG51bGx9IFtiYWNrZ3JvdW5kXSBMYWJlbFN0eWxlIGJhY2tncm91bmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgTGFiZWxTdHlsZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgTGFiZWxTdHlsZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGltcGxlbWVudHMgSUxhYmVsU3R5bGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7eWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5JTGFiZWxTdHlsZT19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gTGFiZWxTdHlsZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIExhYmVsU3R5bGUgdGV4dC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlciB7eWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5UZXh0U3R5bGV8bnVsbHx1bmRlZmluZWR9IHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3MuTGFiZWxTdHlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIExhYmVsU3R5bGUucHJvdG90eXBlLnRleHQgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBMYWJlbFN0eWxlIHRleHRBbHQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXIge3lhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3MuVGV4dFN0eWxlfG51bGx8dW5kZWZpbmVkfSB0ZXh0QWx0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzLkxhYmVsU3R5bGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBMYWJlbFN0eWxlLnByb3RvdHlwZS50ZXh0QWx0ID0gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogTGFiZWxTdHlsZSBoZGlzdGFuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXIge251bWJlcn0gaGRpc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzLkxhYmVsU3R5bGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBMYWJlbFN0eWxlLnByb3RvdHlwZS5oZGlzdGFuY2UgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBMYWJlbFN0eWxlIHZkaXN0YW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfSB2ZGlzdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3MuTGFiZWxTdHlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIExhYmVsU3R5bGUucHJvdG90eXBlLnZkaXN0YW5jZSA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIExhYmVsU3R5bGUgYmFja2dyb3VuZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlciB7eWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5MYWJlbEJhY2tncm91bmRTdHlsZXxudWxsfHVuZGVmaW5lZH0gYmFja2dyb3VuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5MYWJlbFN0eWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTGFiZWxTdHlsZS5wcm90b3R5cGUuYmFja2dyb3VuZCA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERlY29kZXMgYSBMYWJlbFN0eWxlIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3MuTGFiZWxTdHlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7eWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5MYWJlbFN0eWxlfSBMYWJlbFN0eWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTGFiZWxTdHlsZS5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC55YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzLkxhYmVsU3R5bGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50ZXh0ID0gJHJvb3QueWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5UZXh0U3R5bGUuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRleHRBbHQgPSAkcm9vdC55YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzLlRleHRTdHlsZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaGRpc3RhbmNlID0gcmVhZGVyLmZsb2F0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS52ZGlzdGFuY2UgPSByZWFkZXIuZmxvYXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmJhY2tncm91bmQgPSAkcm9vdC55YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzLkxhYmVsQmFja2dyb3VuZFN0eWxlLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIExhYmVsU3R5bGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIENsYXNzLkxhYmVsQmFja2dyb3VuZFN0eWxlID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgTGFiZWxCYWNrZ3JvdW5kU3R5bGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbnRlcmZhY2UgSUxhYmVsQmFja2dyb3VuZFN0eWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfG51bGx9IFtoUGFkZGluZ10gTGFiZWxCYWNrZ3JvdW5kU3R5bGUgaFBhZGRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8bnVsbH0gW3ZQYWRkaW5nXSBMYWJlbEJhY2tncm91bmRTdHlsZSB2UGFkZGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcnxudWxsfSBbY29sb3JdIExhYmVsQmFja2dyb3VuZFN0eWxlIGNvbG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7eWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5MaW5lU3R5bGV8bnVsbH0gW291dGxpbmVdIExhYmVsQmFja2dyb3VuZFN0eWxlIG91dGxpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgTGFiZWxCYWNrZ3JvdW5kU3R5bGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIExhYmVsQmFja2dyb3VuZFN0eWxlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW1wbGVtZW50cyBJTGFiZWxCYWNrZ3JvdW5kU3R5bGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7eWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5JTGFiZWxCYWNrZ3JvdW5kU3R5bGU9fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIExhYmVsQmFja2dyb3VuZFN0eWxlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogTGFiZWxCYWNrZ3JvdW5kU3R5bGUgaFBhZGRpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXIge251bWJlcn0gaFBhZGRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3MuTGFiZWxCYWNrZ3JvdW5kU3R5bGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBMYWJlbEJhY2tncm91bmRTdHlsZS5wcm90b3R5cGUuaFBhZGRpbmcgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBMYWJlbEJhY2tncm91bmRTdHlsZSB2UGFkZGluZy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfSB2UGFkZGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5MYWJlbEJhY2tncm91bmRTdHlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIExhYmVsQmFja2dyb3VuZFN0eWxlLnByb3RvdHlwZS52UGFkZGluZyA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIExhYmVsQmFja2dyb3VuZFN0eWxlIGNvbG9yLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGNvbG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzLkxhYmVsQmFja2dyb3VuZFN0eWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTGFiZWxCYWNrZ3JvdW5kU3R5bGUucHJvdG90eXBlLmNvbG9yID0gMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogTGFiZWxCYWNrZ3JvdW5kU3R5bGUgb3V0bGluZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlciB7eWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5MaW5lU3R5bGV8bnVsbHx1bmRlZmluZWR9IG91dGxpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3MuTGFiZWxCYWNrZ3JvdW5kU3R5bGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBMYWJlbEJhY2tncm91bmRTdHlsZS5wcm90b3R5cGUub3V0bGluZSA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERlY29kZXMgYSBMYWJlbEJhY2tncm91bmRTdHlsZSBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzLkxhYmVsQmFja2dyb3VuZFN0eWxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHt5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzLkxhYmVsQmFja2dyb3VuZFN0eWxlfSBMYWJlbEJhY2tncm91bmRTdHlsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIExhYmVsQmFja2dyb3VuZFN0eWxlLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290LnlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3MuTGFiZWxCYWNrZ3JvdW5kU3R5bGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5oUGFkZGluZyA9IHJlYWRlci5mbG9hdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudlBhZGRpbmcgPSByZWFkZXIuZmxvYXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmNvbG9yID0gcmVhZGVyLmZpeGVkMzIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm91dGxpbmUgPSAkcm9vdC55YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzLkxpbmVTdHlsZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBMYWJlbEJhY2tncm91bmRTdHlsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2xhc3MuWm9vbVNsaWNlID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgWm9vbVNsaWNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW50ZXJmYWNlIElab29tU2xpY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8bnVsbH0gW3pJbmRleF0gWm9vbVNsaWNlIHpJbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge3lhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3MuWm9vbVJhbmdlfG51bGx9IFt2aXNpYmlsaXR5XSBab29tU2xpY2UgdmlzaWJpbGl0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge3lhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3MuUG9seWxpbmVTdHlsZXxudWxsfSBbbGluZV0gWm9vbVNsaWNlIGxpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHt5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzLlBvbHlnb25TdHlsZXxudWxsfSBbcG9seV0gWm9vbVNsaWNlIHBvbHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHt5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzLlBvaW50U3R5bGV8bnVsbH0gW3BvaW50XSBab29tU2xpY2UgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHt5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzLkxhYmVsU3R5bGV8bnVsbH0gW2xhYmVsXSBab29tU2xpY2UgbGFiZWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgWm9vbVNsaWNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBab29tU2xpY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbXBsZW1lbnRzIElab29tU2xpY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7eWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5JWm9vbVNsaWNlPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBab29tU2xpY2UocHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBab29tU2xpY2UgekluZGV4LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IHpJbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5ab29tU2xpY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBab29tU2xpY2UucHJvdG90eXBlLnpJbmRleCA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFpvb21TbGljZSB2aXNpYmlsaXR5LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHt5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzLlpvb21SYW5nZXxudWxsfHVuZGVmaW5lZH0gdmlzaWJpbGl0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5ab29tU2xpY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBab29tU2xpY2UucHJvdG90eXBlLnZpc2liaWxpdHkgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBab29tU2xpY2UgbGluZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlciB7eWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5Qb2x5bGluZVN0eWxlfG51bGx8dW5kZWZpbmVkfSBsaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzLlpvb21TbGljZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFpvb21TbGljZS5wcm90b3R5cGUubGluZSA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFpvb21TbGljZSBwb2x5LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHt5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzLlBvbHlnb25TdHlsZXxudWxsfHVuZGVmaW5lZH0gcG9seVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5ab29tU2xpY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBab29tU2xpY2UucHJvdG90eXBlLnBvbHkgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBab29tU2xpY2UgcG9pbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXIge3lhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3MuUG9pbnRTdHlsZXxudWxsfHVuZGVmaW5lZH0gcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3MuWm9vbVNsaWNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWm9vbVNsaWNlLnByb3RvdHlwZS5wb2ludCA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFpvb21TbGljZSBsYWJlbC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlciB7eWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5MYWJlbFN0eWxlfG51bGx8dW5kZWZpbmVkfSBsYWJlbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5ab29tU2xpY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBab29tU2xpY2UucHJvdG90eXBlLmxhYmVsID0gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRGVjb2RlcyBhIFpvb21TbGljZSBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzLlpvb21TbGljZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7eWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5DbGFzcy5ab29tU2xpY2V9IFpvb21TbGljZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFpvb21TbGljZS5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC55YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzLlpvb21TbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnpJbmRleCA9IHJlYWRlci5zaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnZpc2liaWxpdHkgPSAkcm9vdC55YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzLlpvb21SYW5nZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubGluZSA9ICRyb290LnlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3MuUG9seWxpbmVTdHlsZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UucG9seSA9ICRyb290LnlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3MuUG9seWdvblN0eWxlLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5wb2ludCA9ICRyb290LnlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uQ2xhc3MuUG9pbnRTdHlsZS5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UubGFiZWwgPSAkcm9vdC55YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLkNsYXNzLkxhYmVsU3R5bGUuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWm9vbVNsaWNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQ2xhc3M7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBQcmVzZW50YXRpb24uUGFyYW1ldGVycyA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFByb3BlcnRpZXMgb2YgYSBQYXJhbWV0ZXJzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGludGVyZmFjZSBJUGFyYW1ldGVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7eWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5QYXJhbWV0ZXJzLkV4dHJ1c2lvbnxudWxsfSBbZXh0cnVzaW9uXSBQYXJhbWV0ZXJzIGV4dHJ1c2lvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBQYXJhbWV0ZXJzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgUGFyYW1ldGVycy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW1wbGVtZW50cyBJUGFyYW1ldGVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7eWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5JUGFyYW1ldGVycz19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIFBhcmFtZXRlcnMocHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFBhcmFtZXRlcnMgZXh0cnVzaW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXIge3lhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uUGFyYW1ldGVycy5FeHRydXNpb258bnVsbHx1bmRlZmluZWR9IGV4dHJ1c2lvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLlBhcmFtZXRlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQYXJhbWV0ZXJzLnByb3RvdHlwZS5leHRydXNpb24gPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRGVjb2RlcyBhIFBhcmFtZXRlcnMgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uUGFyYW1ldGVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHt5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLlBhcmFtZXRlcnN9IFBhcmFtZXRlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBhcmFtZXRlcnMuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QueWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIucHJlc2VudGF0aW9uLlByZXNlbnRhdGlvbi5QYXJhbWV0ZXJzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmV4dHJ1c2lvbiA9ICRyb290LnlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uUGFyYW1ldGVycy5FeHRydXNpb24uZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQYXJhbWV0ZXJzLkV4dHJ1c2lvbiA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogUHJvcGVydGllcyBvZiBhbiBFeHRydXNpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLlBhcmFtZXRlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGludGVyZmFjZSBJRXh0cnVzaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfG51bGx9IFthZGp1c3RNZXNoSGVpZ2h0S10gRXh0cnVzaW9uIGFkanVzdE1lc2hIZWlnaHRLXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfG51bGx9IFthZGp1c3RNZXNoSGVpZ2h0UG93XSBFeHRydXNpb24gYWRqdXN0TWVzaEhlaWdodFBvd1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcnxudWxsfSBbYWRqdXN0Qm94SGVpZ2h0S10gRXh0cnVzaW9uIGFkanVzdEJveEhlaWdodEtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8bnVsbH0gW2FkanVzdEJveEhlaWdodFBvd10gRXh0cnVzaW9uIGFkanVzdEJveEhlaWdodFBvd1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBFeHRydXNpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLlBhcmFtZXRlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGFuIEV4dHJ1c2lvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGltcGxlbWVudHMgSUV4dHJ1c2lvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHt5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLlBhcmFtZXRlcnMuSUV4dHJ1c2lvbj19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gRXh0cnVzaW9uKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRXh0cnVzaW9uIGFkanVzdE1lc2hIZWlnaHRLLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGFkanVzdE1lc2hIZWlnaHRLXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLlBhcmFtZXRlcnMuRXh0cnVzaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRXh0cnVzaW9uLnByb3RvdHlwZS5hZGp1c3RNZXNoSGVpZ2h0SyA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEV4dHJ1c2lvbiBhZGp1c3RNZXNoSGVpZ2h0UG93LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGFkanVzdE1lc2hIZWlnaHRQb3dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uUGFyYW1ldGVycy5FeHRydXNpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFeHRydXNpb24ucHJvdG90eXBlLmFkanVzdE1lc2hIZWlnaHRQb3cgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBFeHRydXNpb24gYWRqdXN0Qm94SGVpZ2h0Sy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfSBhZGp1c3RCb3hIZWlnaHRLXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLlBhcmFtZXRlcnMuRXh0cnVzaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRXh0cnVzaW9uLnByb3RvdHlwZS5hZGp1c3RCb3hIZWlnaHRLID0gMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogRXh0cnVzaW9uIGFkanVzdEJveEhlaWdodFBvdy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfSBhZGp1c3RCb3hIZWlnaHRQb3dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uUGFyYW1ldGVycy5FeHRydXNpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFeHRydXNpb24ucHJvdG90eXBlLmFkanVzdEJveEhlaWdodFBvdyA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERlY29kZXMgYW4gRXh0cnVzaW9uIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uUGFyYW1ldGVycy5FeHRydXNpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQHJldHVybnMge3lhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLnByZXNlbnRhdGlvbi5QcmVzZW50YXRpb24uUGFyYW1ldGVycy5FeHRydXNpb259IEV4dHJ1c2lvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEV4dHJ1c2lvbi5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC55YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5wcmVzZW50YXRpb24uUHJlc2VudGF0aW9uLlBhcmFtZXRlcnMuRXh0cnVzaW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYWRqdXN0TWVzaEhlaWdodEsgPSByZWFkZXIuZmxvYXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmFkanVzdE1lc2hIZWlnaHRQb3cgPSByZWFkZXIuZmxvYXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmFkanVzdEJveEhlaWdodEsgPSByZWFkZXIuZmxvYXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmFkanVzdEJveEhlaWdodFBvdyA9IHJlYWRlci5mbG9hdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBFeHRydXNpb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQYXJhbWV0ZXJzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByZXNlbnRhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgfSkoKTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJlc2VudGF0aW9uO1xuICAgICAgICAgICAgICAgIH0pKCk7XG5cbiAgICAgICAgICAgICAgICB2ZWN0b3JkYXRhMi5nbHlwaHMgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIE5hbWVzcGFjZSBnbHlwaHMuXG4gICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMlxuICAgICAgICAgICAgICAgICAgICAgKiBAbmFtZXNwYWNlXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ2x5cGhzID0ge307XG5cbiAgICAgICAgICAgICAgICAgICAgZ2x5cGhzLkdseXBoID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIFByb3BlcnRpZXMgb2YgYSBHbHlwaC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5nbHlwaHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbnRlcmZhY2UgSUdseXBoXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gaWQgR2x5cGggaWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7VWludDhBcnJheX0gYml0bWFwIEdseXBoIGJpdG1hcFxuICAgICAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHdpZHRoIEdseXBoIHdpZHRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gaGVpZ2h0IEdseXBoIGhlaWdodFxuICAgICAgICAgICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGJlYXJpbmdYIEdseXBoIGJlYXJpbmdYXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYmVhcmluZ1kgR2x5cGggYmVhcmluZ1lcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBhZHZhbmNlIEdseXBoIGFkdmFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgR2x5cGguXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIuZ2x5cGhzXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBHbHlwaC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbXBsZW1lbnRzIElHbHlwaFxuICAgICAgICAgICAgICAgICAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3lhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLmdseXBocy5JR2x5cGg9fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gR2x5cGgocHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogR2x5cGggaWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGlkXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIuZ2x5cGhzLkdseXBoXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgR2x5cGgucHJvdG90eXBlLmlkID0gMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBHbHlwaCBiaXRtYXAuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHtVaW50OEFycmF5fSBiaXRtYXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5nbHlwaHMuR2x5cGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICBHbHlwaC5wcm90b3R5cGUuYml0bWFwID0gJHV0aWwubmV3QnVmZmVyKFtdKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBHbHlwaCB3aWR0aC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXIge251bWJlcn0gd2lkdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5nbHlwaHMuR2x5cGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICBHbHlwaC5wcm90b3R5cGUud2lkdGggPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEdseXBoIGhlaWdodC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXIge251bWJlcn0gaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIuZ2x5cGhzLkdseXBoXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgR2x5cGgucHJvdG90eXBlLmhlaWdodCA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogR2x5cGggYmVhcmluZ1guXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGJlYXJpbmdYXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIuZ2x5cGhzLkdseXBoXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgR2x5cGgucHJvdG90eXBlLmJlYXJpbmdYID0gMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBHbHlwaCBiZWFyaW5nWS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXIge251bWJlcn0gYmVhcmluZ1lcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5nbHlwaHMuR2x5cGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICBHbHlwaC5wcm90b3R5cGUuYmVhcmluZ1kgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEdseXBoIGFkdmFuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGFkdmFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5nbHlwaHMuR2x5cGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICBHbHlwaC5wcm90b3R5cGUuYWR2YW5jZSA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogRGVjb2RlcyBhIEdseXBoIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIuZ2x5cGhzLkdseXBoXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7eWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIuZ2x5cGhzLkdseXBofSBHbHlwaFxuICAgICAgICAgICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICBHbHlwaC5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC55YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5nbHlwaHMuR2x5cGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmlkID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYml0bWFwID0gcmVhZGVyLmJ5dGVzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS53aWR0aCA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmhlaWdodCA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLmJlYXJpbmdYID0gcmVhZGVyLnNpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuYmVhcmluZ1kgPSByZWFkZXIuc2ludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5hZHZhbmNlID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJpZFwiKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgJHV0aWwuUHJvdG9jb2xFcnJvcihcIm1pc3NpbmcgcmVxdWlyZWQgJ2lkJ1wiLCB7IGluc3RhbmNlOiBtZXNzYWdlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImJpdG1hcFwiKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgJHV0aWwuUHJvdG9jb2xFcnJvcihcIm1pc3NpbmcgcmVxdWlyZWQgJ2JpdG1hcCdcIiwgeyBpbnN0YW5jZTogbWVzc2FnZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ3aWR0aFwiKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgJHV0aWwuUHJvdG9jb2xFcnJvcihcIm1pc3NpbmcgcmVxdWlyZWQgJ3dpZHRoJ1wiLCB7IGluc3RhbmNlOiBtZXNzYWdlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImhlaWdodFwiKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgJHV0aWwuUHJvdG9jb2xFcnJvcihcIm1pc3NpbmcgcmVxdWlyZWQgJ2hlaWdodCdcIiwgeyBpbnN0YW5jZTogbWVzc2FnZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJiZWFyaW5nWFwiKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgJHV0aWwuUHJvdG9jb2xFcnJvcihcIm1pc3NpbmcgcmVxdWlyZWQgJ2JlYXJpbmdYJ1wiLCB7IGluc3RhbmNlOiBtZXNzYWdlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImJlYXJpbmdZXCIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAkdXRpbC5Qcm90b2NvbEVycm9yKFwibWlzc2luZyByZXF1aXJlZCAnYmVhcmluZ1knXCIsIHsgaW5zdGFuY2U6IG1lc3NhZ2UgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtZXNzYWdlLmhhc093blByb3BlcnR5KFwiYWR2YW5jZVwiKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgJHV0aWwuUHJvdG9jb2xFcnJvcihcIm1pc3NpbmcgcmVxdWlyZWQgJ2FkdmFuY2UnXCIsIHsgaW5zdGFuY2U6IG1lc3NhZ2UgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gR2x5cGg7XG4gICAgICAgICAgICAgICAgICAgIH0pKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgZ2x5cGhzLkZvbnREZXNjcmlwdGlvbiA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgRm9udERlc2NyaXB0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLmdseXBoc1xuICAgICAgICAgICAgICAgICAgICAgICAgICogQGludGVyZmFjZSBJRm9udERlc2NyaXB0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gZm9udElkIEZvbnREZXNjcmlwdGlvbiBmb250SWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4aGVpZ2h0IEZvbnREZXNjcmlwdGlvbiB4aGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbWFyZ2luIEZvbnREZXNjcmlwdGlvbiBtYXJnaW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgRm9udERlc2NyaXB0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLmdseXBoc1xuICAgICAgICAgICAgICAgICAgICAgICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgRm9udERlc2NyaXB0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICogQGltcGxlbWVudHMgSUZvbnREZXNjcmlwdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3lhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLmdseXBocy5JRm9udERlc2NyaXB0aW9uPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIEZvbnREZXNjcmlwdGlvbihwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBGb250RGVzY3JpcHRpb24gZm9udElkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSBmb250SWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5nbHlwaHMuRm9udERlc2NyaXB0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgRm9udERlc2NyaXB0aW9uLnByb3RvdHlwZS5mb250SWQgPSBcIlwiO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEZvbnREZXNjcmlwdGlvbiB4aGVpZ2h0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfSB4aGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIuZ2x5cGhzLkZvbnREZXNjcmlwdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIEZvbnREZXNjcmlwdGlvbi5wcm90b3R5cGUueGhlaWdodCA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogRm9udERlc2NyaXB0aW9uIG1hcmdpbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXIge251bWJlcn0gbWFyZ2luXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIuZ2x5cGhzLkZvbnREZXNjcmlwdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIEZvbnREZXNjcmlwdGlvbi5wcm90b3R5cGUubWFyZ2luID0gMztcblxuICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBEZWNvZGVzIGEgRm9udERlc2NyaXB0aW9uIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIuZ2x5cGhzLkZvbnREZXNjcmlwdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICogQHJldHVybnMge3lhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLmdseXBocy5Gb250RGVzY3JpcHRpb259IEZvbnREZXNjcmlwdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICBGb250RGVzY3JpcHRpb24uZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QueWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIuZ2x5cGhzLkZvbnREZXNjcmlwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZm9udElkID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UueGhlaWdodCA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLm1hcmdpbiA9IHJlYWRlci5zaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtZXNzYWdlLmhhc093blByb3BlcnR5KFwiZm9udElkXCIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAkdXRpbC5Qcm90b2NvbEVycm9yKFwibWlzc2luZyByZXF1aXJlZCAnZm9udElkJ1wiLCB7IGluc3RhbmNlOiBtZXNzYWdlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInhoZWlnaHRcIikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93ICR1dGlsLlByb3RvY29sRXJyb3IoXCJtaXNzaW5nIHJlcXVpcmVkICd4aGVpZ2h0J1wiLCB7IGluc3RhbmNlOiBtZXNzYWdlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIm1hcmdpblwiKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgJHV0aWwuUHJvdG9jb2xFcnJvcihcIm1pc3NpbmcgcmVxdWlyZWQgJ21hcmdpbidcIiwgeyBpbnN0YW5jZTogbWVzc2FnZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBGb250RGVzY3JpcHRpb247XG4gICAgICAgICAgICAgICAgICAgIH0pKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgZ2x5cGhzLkdseXBoTGlzdCA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgR2x5cGhMaXN0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICogQG1lbWJlcm9mIHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLmdseXBoc1xuICAgICAgICAgICAgICAgICAgICAgICAgICogQGludGVyZmFjZSBJR2x5cGhMaXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge3lhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLmdseXBocy5Gb250RGVzY3JpcHRpb259IGZvbnQgR2x5cGhMaXN0IGZvbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPHlhbmRleC5tYXBzLnByb3RvLnZlY3RvcmRhdGEyLmdseXBocy5HbHlwaD58bnVsbH0gW2dseXBoc10gR2x5cGhMaXN0IGdseXBoc1xuICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBHbHlwaExpc3QuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIuZ2x5cGhzXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBHbHlwaExpc3QuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW1wbGVtZW50cyBJR2x5cGhMaXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7eWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIuZ2x5cGhzLklHbHlwaExpc3Q9fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gR2x5cGhMaXN0KHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdseXBocyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogR2x5cGhMaXN0IGZvbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHt5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5nbHlwaHMuRm9udERlc2NyaXB0aW9ufSBmb250XG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAbWVtYmVyb2YgeWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIuZ2x5cGhzLkdseXBoTGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIEdseXBoTGlzdC5wcm90b3R5cGUuZm9udCA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogR2x5cGhMaXN0IGdseXBocy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXIge0FycmF5Ljx5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5nbHlwaHMuR2x5cGg+fSBnbHlwaHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5nbHlwaHMuR2x5cGhMaXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgR2x5cGhMaXN0LnByb3RvdHlwZS5nbHlwaHMgPSAkdXRpbC5lbXB0eUFycmF5O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIERlY29kZXMgYSBHbHlwaExpc3QgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtZW1iZXJvZiB5YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5nbHlwaHMuR2x5cGhMaXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7eWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIuZ2x5cGhzLkdseXBoTGlzdH0gR2x5cGhMaXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgICAgICAgICAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIEdseXBoTGlzdC5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC55YW5kZXgubWFwcy5wcm90by52ZWN0b3JkYXRhMi5nbHlwaHMuR2x5cGhMaXN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5mb250ID0gJHJvb3QueWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIuZ2x5cGhzLkZvbnREZXNjcmlwdGlvbi5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1lc3NhZ2UuZ2x5cGhzICYmIG1lc3NhZ2UuZ2x5cGhzLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5nbHlwaHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuZ2x5cGhzLnB1c2goJHJvb3QueWFuZGV4Lm1hcHMucHJvdG8udmVjdG9yZGF0YTIuZ2x5cGhzLkdseXBoLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJmb250XCIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAkdXRpbC5Qcm90b2NvbEVycm9yKFwibWlzc2luZyByZXF1aXJlZCAnZm9udCdcIiwgeyBpbnN0YW5jZTogbWVzc2FnZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBHbHlwaExpc3Q7XG4gICAgICAgICAgICAgICAgICAgIH0pKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdseXBocztcbiAgICAgICAgICAgICAgICB9KSgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZlY3RvcmRhdGEyO1xuICAgICAgICAgICAgfSkoKTtcblxuICAgICAgICAgICAgcmV0dXJuIHByb3RvO1xuICAgICAgICB9KSgpO1xuXG4gICAgICAgIHJldHVybiBtYXBzO1xuICAgIH0pKCk7XG5cbiAgICByZXR1cm4geWFuZGV4O1xufSkoKTtcblxubW9kdWxlLmV4cG9ydHMgPSAkcm9vdDtcbiIsIi8vIG1pbmltYWwgbGlicmFyeSBlbnRyeSBwb2ludC5cclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3NyYy9pbmRleC1taW5pbWFsXCIpO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIHByb3RvYnVmID0gZXhwb3J0cztcclxuXHJcbi8qKlxyXG4gKiBCdWlsZCB0eXBlLCBvbmUgb2YgYFwiZnVsbFwiYCwgYFwibGlnaHRcImAgb3IgYFwibWluaW1hbFwiYC5cclxuICogQG5hbWUgYnVpbGRcclxuICogQHR5cGUge3N0cmluZ31cclxuICogQGNvbnN0XHJcbiAqL1xyXG5wcm90b2J1Zi5idWlsZCA9IFwibWluaW1hbFwiO1xyXG5cclxuLy8gU2VyaWFsaXphdGlvblxyXG5wcm90b2J1Zi5Xcml0ZXIgICAgICAgPSByZXF1aXJlKFwiLi93cml0ZXJcIik7XHJcbnByb3RvYnVmLkJ1ZmZlcldyaXRlciA9IHJlcXVpcmUoXCIuL3dyaXRlcl9idWZmZXJcIik7XHJcbnByb3RvYnVmLlJlYWRlciAgICAgICA9IHJlcXVpcmUoXCIuL3JlYWRlclwiKTtcclxucHJvdG9idWYuQnVmZmVyUmVhZGVyID0gcmVxdWlyZShcIi4vcmVhZGVyX2J1ZmZlclwiKTtcclxuXHJcbi8vIFV0aWxpdHlcclxucHJvdG9idWYudXRpbCAgICAgICAgID0gcmVxdWlyZShcIi4vdXRpbC9taW5pbWFsXCIpO1xyXG5wcm90b2J1Zi5ycGMgICAgICAgICAgPSByZXF1aXJlKFwiLi9ycGNcIik7XHJcbnByb3RvYnVmLnJvb3RzICAgICAgICA9IHJlcXVpcmUoXCIuL3Jvb3RzXCIpO1xyXG5wcm90b2J1Zi5jb25maWd1cmUgICAgPSBjb25maWd1cmU7XHJcblxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4vKipcclxuICogUmVjb25maWd1cmVzIHRoZSBsaWJyYXJ5IGFjY29yZGluZyB0byB0aGUgZW52aXJvbm1lbnQuXHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqL1xyXG5mdW5jdGlvbiBjb25maWd1cmUoKSB7XHJcbiAgICBwcm90b2J1Zi5SZWFkZXIuX2NvbmZpZ3VyZShwcm90b2J1Zi5CdWZmZXJSZWFkZXIpO1xyXG4gICAgcHJvdG9idWYudXRpbC5fY29uZmlndXJlKCk7XHJcbn1cclxuXHJcbi8vIFNldCB1cCBidWZmZXIgdXRpbGl0eSBhY2NvcmRpbmcgdG8gdGhlIGVudmlyb25tZW50XHJcbnByb3RvYnVmLldyaXRlci5fY29uZmlndXJlKHByb3RvYnVmLkJ1ZmZlcldyaXRlcik7XHJcbmNvbmZpZ3VyZSgpO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSBXcml0ZXI7XHJcblxyXG52YXIgdXRpbCAgICAgID0gcmVxdWlyZShcIi4vdXRpbC9taW5pbWFsXCIpO1xyXG5cclxudmFyIEJ1ZmZlcldyaXRlcjsgLy8gY3ljbGljXHJcblxyXG52YXIgTG9uZ0JpdHMgID0gdXRpbC5Mb25nQml0cyxcclxuICAgIGJhc2U2NCAgICA9IHV0aWwuYmFzZTY0LFxyXG4gICAgdXRmOCAgICAgID0gdXRpbC51dGY4O1xyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdHMgYSBuZXcgd3JpdGVyIG9wZXJhdGlvbiBpbnN0YW5jZS5cclxuICogQGNsYXNzZGVzYyBTY2hlZHVsZWQgd3JpdGVyIG9wZXJhdGlvbi5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgVWludDhBcnJheSwgbnVtYmVyKX0gZm4gRnVuY3Rpb24gdG8gY2FsbFxyXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuIFZhbHVlIGJ5dGUgbGVuZ3RoXHJcbiAqIEBwYXJhbSB7Kn0gdmFsIFZhbHVlIHRvIHdyaXRlXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmZ1bmN0aW9uIE9wKGZuLCBsZW4sIHZhbCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRnVuY3Rpb24gdG8gY2FsbC5cclxuICAgICAqIEB0eXBlIHtmdW5jdGlvbihVaW50OEFycmF5LCBudW1iZXIsICopfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmZuID0gZm47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBWYWx1ZSBieXRlIGxlbmd0aC5cclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubGVuID0gbGVuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTmV4dCBvcGVyYXRpb24uXHJcbiAgICAgKiBAdHlwZSB7V3JpdGVyLk9wfHVuZGVmaW5lZH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5uZXh0ID0gdW5kZWZpbmVkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVmFsdWUgdG8gd3JpdGUuXHJcbiAgICAgKiBAdHlwZSB7Kn1cclxuICAgICAqL1xyXG4gICAgdGhpcy52YWwgPSB2YWw7IC8vIHR5cGUgdmFyaWVzXHJcbn1cclxuXHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbmZ1bmN0aW9uIG5vb3AoKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVtcHR5LWZ1bmN0aW9uXHJcblxyXG4vKipcclxuICogQ29uc3RydWN0cyBhIG5ldyB3cml0ZXIgc3RhdGUgaW5zdGFuY2UuXHJcbiAqIEBjbGFzc2Rlc2MgQ29waWVkIHdyaXRlciBzdGF0ZS5cclxuICogQG1lbWJlcm9mIFdyaXRlclxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtXcml0ZXJ9IHdyaXRlciBXcml0ZXIgdG8gY29weSBzdGF0ZSBmcm9tXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmZ1bmN0aW9uIFN0YXRlKHdyaXRlcikge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3VycmVudCBoZWFkLlxyXG4gICAgICogQHR5cGUge1dyaXRlci5PcH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5oZWFkID0gd3JpdGVyLmhlYWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDdXJyZW50IHRhaWwuXHJcbiAgICAgKiBAdHlwZSB7V3JpdGVyLk9wfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnRhaWwgPSB3cml0ZXIudGFpbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEN1cnJlbnQgYnVmZmVyIGxlbmd0aC5cclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubGVuID0gd3JpdGVyLmxlbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE5leHQgc3RhdGUuXHJcbiAgICAgKiBAdHlwZSB7U3RhdGV8bnVsbH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5uZXh0ID0gd3JpdGVyLnN0YXRlcztcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdHMgYSBuZXcgd3JpdGVyIGluc3RhbmNlLlxyXG4gKiBAY2xhc3NkZXNjIFdpcmUgZm9ybWF0IHdyaXRlciB1c2luZyBgVWludDhBcnJheWAgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgYEFycmF5YC5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBXcml0ZXIoKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDdXJyZW50IGxlbmd0aC5cclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubGVuID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE9wZXJhdGlvbnMgaGVhZC5cclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuaGVhZCA9IG5ldyBPcChub29wLCAwLCAwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE9wZXJhdGlvbnMgdGFpbFxyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqL1xyXG4gICAgdGhpcy50YWlsID0gdGhpcy5oZWFkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTGlua2VkIGZvcmtlZCBzdGF0ZXMuXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fG51bGx9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuc3RhdGVzID0gbnVsbDtcclxuXHJcbiAgICAvLyBXaGVuIGEgdmFsdWUgaXMgd3JpdHRlbiwgdGhlIHdyaXRlciBjYWxjdWxhdGVzIGl0cyBieXRlIGxlbmd0aCBhbmQgcHV0cyBpdCBpbnRvIGEgbGlua2VkXHJcbiAgICAvLyBsaXN0IG9mIG9wZXJhdGlvbnMgdG8gcGVyZm9ybSB3aGVuIGZpbmlzaCgpIGlzIGNhbGxlZC4gVGhpcyBib3RoIGFsbG93cyB1cyB0byBhbGxvY2F0ZVxyXG4gICAgLy8gYnVmZmVycyBvZiB0aGUgZXhhY3QgcmVxdWlyZWQgc2l6ZSBhbmQgcmVkdWNlcyB0aGUgYW1vdW50IG9mIHdvcmsgd2UgaGF2ZSB0byBkbyBjb21wYXJlZFxyXG4gICAgLy8gdG8gZmlyc3QgY2FsY3VsYXRpbmcgb3ZlciBvYmplY3RzIGFuZCB0aGVuIGVuY29kaW5nIG92ZXIgb2JqZWN0cy4gSW4gb3VyIGNhc2UsIHRoZSBlbmNvZGluZ1xyXG4gICAgLy8gcGFydCBpcyBqdXN0IGEgbGlua2VkIGxpc3Qgd2FsayBjYWxsaW5nIG9wZXJhdGlvbnMgd2l0aCBhbHJlYWR5IHByZXBhcmVkIHZhbHVlcy5cclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgd3JpdGVyLlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHJldHVybnMge0J1ZmZlcldyaXRlcnxXcml0ZXJ9IEEge0BsaW5rIEJ1ZmZlcldyaXRlcn0gd2hlbiBCdWZmZXJzIGFyZSBzdXBwb3J0ZWQsIG90aGVyd2lzZSBhIHtAbGluayBXcml0ZXJ9XHJcbiAqL1xyXG5Xcml0ZXIuY3JlYXRlID0gdXRpbC5CdWZmZXJcclxuICAgID8gZnVuY3Rpb24gY3JlYXRlX2J1ZmZlcl9zZXR1cCgpIHtcclxuICAgICAgICByZXR1cm4gKFdyaXRlci5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGVfYnVmZmVyKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcldyaXRlcigpO1xyXG4gICAgICAgIH0pKCk7XHJcbiAgICB9XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgOiBmdW5jdGlvbiBjcmVhdGVfYXJyYXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBXcml0ZXIoKTtcclxuICAgIH07XHJcblxyXG4vKipcclxuICogQWxsb2NhdGVzIGEgYnVmZmVyIG9mIHRoZSBzcGVjaWZpZWQgc2l6ZS5cclxuICogQHBhcmFtIHtudW1iZXJ9IHNpemUgQnVmZmVyIHNpemVcclxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IEJ1ZmZlclxyXG4gKi9cclxuV3JpdGVyLmFsbG9jID0gZnVuY3Rpb24gYWxsb2Moc2l6ZSkge1xyXG4gICAgcmV0dXJuIG5ldyB1dGlsLkFycmF5KHNpemUpO1xyXG59O1xyXG5cclxuLy8gVXNlIFVpbnQ4QXJyYXkgYnVmZmVyIHBvb2wgaW4gdGhlIGJyb3dzZXIsIGp1c3QgbGlrZSBub2RlIGRvZXMgd2l0aCBidWZmZXJzXHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXHJcbmlmICh1dGlsLkFycmF5ICE9PSBBcnJheSlcclxuICAgIFdyaXRlci5hbGxvYyA9IHV0aWwucG9vbChXcml0ZXIuYWxsb2MsIHV0aWwuQXJyYXkucHJvdG90eXBlLnN1YmFycmF5KTtcclxuXHJcbi8qKlxyXG4gKiBQdXNoZXMgYSBuZXcgb3BlcmF0aW9uIHRvIHRoZSBxdWV1ZS5cclxuICogQHBhcmFtIHtmdW5jdGlvbihVaW50OEFycmF5LCBudW1iZXIsICopfSBmbiBGdW5jdGlvbiB0byBjYWxsXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW4gVmFsdWUgYnl0ZSBsZW5ndGhcclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcclxuICogQHByaXZhdGVcclxuICovXHJcbldyaXRlci5wcm90b3R5cGUuX3B1c2ggPSBmdW5jdGlvbiBwdXNoKGZuLCBsZW4sIHZhbCkge1xyXG4gICAgdGhpcy50YWlsID0gdGhpcy50YWlsLm5leHQgPSBuZXcgT3AoZm4sIGxlbiwgdmFsKTtcclxuICAgIHRoaXMubGVuICs9IGxlbjtcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gd3JpdGVCeXRlKHZhbCwgYnVmLCBwb3MpIHtcclxuICAgIGJ1Zltwb3NdID0gdmFsICYgMjU1O1xyXG59XHJcblxyXG5mdW5jdGlvbiB3cml0ZVZhcmludDMyKHZhbCwgYnVmLCBwb3MpIHtcclxuICAgIHdoaWxlICh2YWwgPiAxMjcpIHtcclxuICAgICAgICBidWZbcG9zKytdID0gdmFsICYgMTI3IHwgMTI4O1xyXG4gICAgICAgIHZhbCA+Pj49IDc7XHJcbiAgICB9XHJcbiAgICBidWZbcG9zXSA9IHZhbDtcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdHMgYSBuZXcgdmFyaW50IHdyaXRlciBvcGVyYXRpb24gaW5zdGFuY2UuXHJcbiAqIEBjbGFzc2Rlc2MgU2NoZWR1bGVkIHZhcmludCB3cml0ZXIgb3BlcmF0aW9uLlxyXG4gKiBAZXh0ZW5kcyBPcFxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtudW1iZXJ9IGxlbiBWYWx1ZSBieXRlIGxlbmd0aFxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIFZhbHVlIHRvIHdyaXRlXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmZ1bmN0aW9uIFZhcmludE9wKGxlbiwgdmFsKSB7XHJcbiAgICB0aGlzLmxlbiA9IGxlbjtcclxuICAgIHRoaXMubmV4dCA9IHVuZGVmaW5lZDtcclxuICAgIHRoaXMudmFsID0gdmFsO1xyXG59XHJcblxyXG5WYXJpbnRPcC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE9wLnByb3RvdHlwZSk7XHJcblZhcmludE9wLnByb3RvdHlwZS5mbiA9IHdyaXRlVmFyaW50MzI7XHJcblxyXG4vKipcclxuICogV3JpdGVzIGFuIHVuc2lnbmVkIDMyIGJpdCB2YWx1ZSBhcyBhIHZhcmludC5cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxyXG4gKi9cclxuV3JpdGVyLnByb3RvdHlwZS51aW50MzIgPSBmdW5jdGlvbiB3cml0ZV91aW50MzIodmFsdWUpIHtcclxuICAgIC8vIGhlcmUsIHRoZSBjYWxsIHRvIHRoaXMucHVzaCBoYXMgYmVlbiBpbmxpbmVkIGFuZCBhIHZhcmludCBzcGVjaWZpYyBPcCBzdWJjbGFzcyBpcyB1c2VkLlxyXG4gICAgLy8gdWludDMyIGlzIGJ5IGZhciB0aGUgbW9zdCBmcmVxdWVudGx5IHVzZWQgb3BlcmF0aW9uIGFuZCBiZW5lZml0cyBzaWduaWZpY2FudGx5IGZyb20gdGhpcy5cclxuICAgIHRoaXMubGVuICs9ICh0aGlzLnRhaWwgPSB0aGlzLnRhaWwubmV4dCA9IG5ldyBWYXJpbnRPcChcclxuICAgICAgICAodmFsdWUgPSB2YWx1ZSA+Pj4gMClcclxuICAgICAgICAgICAgICAgIDwgMTI4ICAgICAgID8gMVxyXG4gICAgICAgIDogdmFsdWUgPCAxNjM4NCAgICAgPyAyXHJcbiAgICAgICAgOiB2YWx1ZSA8IDIwOTcxNTIgICA/IDNcclxuICAgICAgICA6IHZhbHVlIDwgMjY4NDM1NDU2ID8gNFxyXG4gICAgICAgIDogICAgICAgICAgICAgICAgICAgICA1LFxyXG4gICAgdmFsdWUpKS5sZW47XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYSBzaWduZWQgMzIgYml0IHZhbHVlIGFzIGEgdmFyaW50LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxyXG4gKi9cclxuV3JpdGVyLnByb3RvdHlwZS5pbnQzMiA9IGZ1bmN0aW9uIHdyaXRlX2ludDMyKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdmFsdWUgPCAwXHJcbiAgICAgICAgPyB0aGlzLl9wdXNoKHdyaXRlVmFyaW50NjQsIDEwLCBMb25nQml0cy5mcm9tTnVtYmVyKHZhbHVlKSkgLy8gMTAgYnl0ZXMgcGVyIHNwZWNcclxuICAgICAgICA6IHRoaXMudWludDMyKHZhbHVlKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYSAzMiBiaXQgdmFsdWUgYXMgYSB2YXJpbnQsIHppZy16YWcgZW5jb2RlZC5cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxyXG4gKi9cclxuV3JpdGVyLnByb3RvdHlwZS5zaW50MzIgPSBmdW5jdGlvbiB3cml0ZV9zaW50MzIodmFsdWUpIHtcclxuICAgIHJldHVybiB0aGlzLnVpbnQzMigodmFsdWUgPDwgMSBeIHZhbHVlID4+IDMxKSA+Pj4gMCk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiB3cml0ZVZhcmludDY0KHZhbCwgYnVmLCBwb3MpIHtcclxuICAgIHdoaWxlICh2YWwuaGkpIHtcclxuICAgICAgICBidWZbcG9zKytdID0gdmFsLmxvICYgMTI3IHwgMTI4O1xyXG4gICAgICAgIHZhbC5sbyA9ICh2YWwubG8gPj4+IDcgfCB2YWwuaGkgPDwgMjUpID4+PiAwO1xyXG4gICAgICAgIHZhbC5oaSA+Pj49IDc7XHJcbiAgICB9XHJcbiAgICB3aGlsZSAodmFsLmxvID4gMTI3KSB7XHJcbiAgICAgICAgYnVmW3BvcysrXSA9IHZhbC5sbyAmIDEyNyB8IDEyODtcclxuICAgICAgICB2YWwubG8gPSB2YWwubG8gPj4+IDc7XHJcbiAgICB9XHJcbiAgICBidWZbcG9zKytdID0gdmFsLmxvO1xyXG59XHJcblxyXG4vKipcclxuICogV3JpdGVzIGFuIHVuc2lnbmVkIDY0IGJpdCB2YWx1ZSBhcyBhIHZhcmludC5cclxuICogQHBhcmFtIHtMb25nfG51bWJlcnxzdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxyXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGB2YWx1ZWAgaXMgYSBzdHJpbmcgYW5kIG5vIGxvbmcgbGlicmFyeSBpcyBwcmVzZW50LlxyXG4gKi9cclxuV3JpdGVyLnByb3RvdHlwZS51aW50NjQgPSBmdW5jdGlvbiB3cml0ZV91aW50NjQodmFsdWUpIHtcclxuICAgIHZhciBiaXRzID0gTG9uZ0JpdHMuZnJvbSh2YWx1ZSk7XHJcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZVZhcmludDY0LCBiaXRzLmxlbmd0aCgpLCBiaXRzKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYSBzaWduZWQgNjQgYml0IHZhbHVlIGFzIGEgdmFyaW50LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtMb25nfG51bWJlcnxzdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxyXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGB2YWx1ZWAgaXMgYSBzdHJpbmcgYW5kIG5vIGxvbmcgbGlicmFyeSBpcyBwcmVzZW50LlxyXG4gKi9cclxuV3JpdGVyLnByb3RvdHlwZS5pbnQ2NCA9IFdyaXRlci5wcm90b3R5cGUudWludDY0O1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhIHNpZ25lZCA2NCBiaXQgdmFsdWUgYXMgYSB2YXJpbnQsIHppZy16YWcgZW5jb2RlZC5cclxuICogQHBhcmFtIHtMb25nfG51bWJlcnxzdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxyXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGB2YWx1ZWAgaXMgYSBzdHJpbmcgYW5kIG5vIGxvbmcgbGlicmFyeSBpcyBwcmVzZW50LlxyXG4gKi9cclxuV3JpdGVyLnByb3RvdHlwZS5zaW50NjQgPSBmdW5jdGlvbiB3cml0ZV9zaW50NjQodmFsdWUpIHtcclxuICAgIHZhciBiaXRzID0gTG9uZ0JpdHMuZnJvbSh2YWx1ZSkuenpFbmNvZGUoKTtcclxuICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlVmFyaW50NjQsIGJpdHMubGVuZ3RoKCksIGJpdHMpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhIGJvb2xpc2ggdmFsdWUgYXMgYSB2YXJpbnQuXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXHJcbiAqL1xyXG5Xcml0ZXIucHJvdG90eXBlLmJvb2wgPSBmdW5jdGlvbiB3cml0ZV9ib29sKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZUJ5dGUsIDEsIHZhbHVlID8gMSA6IDApO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gd3JpdGVGaXhlZDMyKHZhbCwgYnVmLCBwb3MpIHtcclxuICAgIGJ1Zltwb3MgICAgXSA9ICB2YWwgICAgICAgICAmIDI1NTtcclxuICAgIGJ1Zltwb3MgKyAxXSA9ICB2YWwgPj4+IDggICAmIDI1NTtcclxuICAgIGJ1Zltwb3MgKyAyXSA9ICB2YWwgPj4+IDE2ICAmIDI1NTtcclxuICAgIGJ1Zltwb3MgKyAzXSA9ICB2YWwgPj4+IDI0O1xyXG59XHJcblxyXG4vKipcclxuICogV3JpdGVzIGFuIHVuc2lnbmVkIDMyIGJpdCB2YWx1ZSBhcyBmaXhlZCAzMiBiaXRzLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXHJcbiAqL1xyXG5Xcml0ZXIucHJvdG90eXBlLmZpeGVkMzIgPSBmdW5jdGlvbiB3cml0ZV9maXhlZDMyKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZUZpeGVkMzIsIDQsIHZhbHVlID4+PiAwKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYSBzaWduZWQgMzIgYml0IHZhbHVlIGFzIGZpeGVkIDMyIGJpdHMuXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXHJcbiAqL1xyXG5Xcml0ZXIucHJvdG90eXBlLnNmaXhlZDMyID0gV3JpdGVyLnByb3RvdHlwZS5maXhlZDMyO1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhbiB1bnNpZ25lZCA2NCBiaXQgdmFsdWUgYXMgZml4ZWQgNjQgYml0cy5cclxuICogQHBhcmFtIHtMb25nfG51bWJlcnxzdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxyXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGB2YWx1ZWAgaXMgYSBzdHJpbmcgYW5kIG5vIGxvbmcgbGlicmFyeSBpcyBwcmVzZW50LlxyXG4gKi9cclxuV3JpdGVyLnByb3RvdHlwZS5maXhlZDY0ID0gZnVuY3Rpb24gd3JpdGVfZml4ZWQ2NCh2YWx1ZSkge1xyXG4gICAgdmFyIGJpdHMgPSBMb25nQml0cy5mcm9tKHZhbHVlKTtcclxuICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlRml4ZWQzMiwgNCwgYml0cy5sbykuX3B1c2god3JpdGVGaXhlZDMyLCA0LCBiaXRzLmhpKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYSBzaWduZWQgNjQgYml0IHZhbHVlIGFzIGZpeGVkIDY0IGJpdHMuXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcclxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXHJcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYHZhbHVlYCBpcyBhIHN0cmluZyBhbmQgbm8gbG9uZyBsaWJyYXJ5IGlzIHByZXNlbnQuXHJcbiAqL1xyXG5Xcml0ZXIucHJvdG90eXBlLnNmaXhlZDY0ID0gV3JpdGVyLnByb3RvdHlwZS5maXhlZDY0O1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhIGZsb2F0ICgzMiBiaXQpLlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxyXG4gKi9cclxuV3JpdGVyLnByb3RvdHlwZS5mbG9hdCA9IGZ1bmN0aW9uIHdyaXRlX2Zsb2F0KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh1dGlsLmZsb2F0LndyaXRlRmxvYXRMRSwgNCwgdmFsdWUpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhIGRvdWJsZSAoNjQgYml0IGZsb2F0KS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcclxuICovXHJcbldyaXRlci5wcm90b3R5cGUuZG91YmxlID0gZnVuY3Rpb24gd3JpdGVfZG91YmxlKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh1dGlsLmZsb2F0LndyaXRlRG91YmxlTEUsIDgsIHZhbHVlKTtcclxufTtcclxuXHJcbnZhciB3cml0ZUJ5dGVzID0gdXRpbC5BcnJheS5wcm90b3R5cGUuc2V0XHJcbiAgICA/IGZ1bmN0aW9uIHdyaXRlQnl0ZXNfc2V0KHZhbCwgYnVmLCBwb3MpIHtcclxuICAgICAgICBidWYuc2V0KHZhbCwgcG9zKTsgLy8gYWxzbyB3b3JrcyBmb3IgcGxhaW4gYXJyYXkgdmFsdWVzXHJcbiAgICB9XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgOiBmdW5jdGlvbiB3cml0ZUJ5dGVzX2Zvcih2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyArK2kpXHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyBpXSA9IHZhbFtpXTtcclxuICAgIH07XHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgc2VxdWVuY2Ugb2YgYnl0ZXMuXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheXxzdHJpbmd9IHZhbHVlIEJ1ZmZlciBvciBiYXNlNjQgZW5jb2RlZCBzdHJpbmcgdG8gd3JpdGVcclxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXHJcbiAqL1xyXG5Xcml0ZXIucHJvdG90eXBlLmJ5dGVzID0gZnVuY3Rpb24gd3JpdGVfYnl0ZXModmFsdWUpIHtcclxuICAgIHZhciBsZW4gPSB2YWx1ZS5sZW5ndGggPj4+IDA7XHJcbiAgICBpZiAoIWxlbilcclxuICAgICAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZUJ5dGUsIDEsIDApO1xyXG4gICAgaWYgKHV0aWwuaXNTdHJpbmcodmFsdWUpKSB7XHJcbiAgICAgICAgdmFyIGJ1ZiA9IFdyaXRlci5hbGxvYyhsZW4gPSBiYXNlNjQubGVuZ3RoKHZhbHVlKSk7XHJcbiAgICAgICAgYmFzZTY0LmRlY29kZSh2YWx1ZSwgYnVmLCAwKTtcclxuICAgICAgICB2YWx1ZSA9IGJ1ZjtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLnVpbnQzMihsZW4pLl9wdXNoKHdyaXRlQnl0ZXMsIGxlbiwgdmFsdWUpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhIHN0cmluZy5cclxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXHJcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxyXG4gKi9cclxuV3JpdGVyLnByb3RvdHlwZS5zdHJpbmcgPSBmdW5jdGlvbiB3cml0ZV9zdHJpbmcodmFsdWUpIHtcclxuICAgIHZhciBsZW4gPSB1dGY4Lmxlbmd0aCh2YWx1ZSk7XHJcbiAgICByZXR1cm4gbGVuXHJcbiAgICAgICAgPyB0aGlzLnVpbnQzMihsZW4pLl9wdXNoKHV0Zjgud3JpdGUsIGxlbiwgdmFsdWUpXHJcbiAgICAgICAgOiB0aGlzLl9wdXNoKHdyaXRlQnl0ZSwgMSwgMCk7XHJcbn07XHJcblxyXG4vKipcclxuICogRm9ya3MgdGhpcyB3cml0ZXIncyBzdGF0ZSBieSBwdXNoaW5nIGl0IHRvIGEgc3RhY2suXHJcbiAqIENhbGxpbmcge0BsaW5rIFdyaXRlciNyZXNldHxyZXNldH0gb3Ige0BsaW5rIFdyaXRlciNsZGVsaW18bGRlbGltfSByZXNldHMgdGhlIHdyaXRlciB0byB0aGUgcHJldmlvdXMgc3RhdGUuXHJcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxyXG4gKi9cclxuV3JpdGVyLnByb3RvdHlwZS5mb3JrID0gZnVuY3Rpb24gZm9yaygpIHtcclxuICAgIHRoaXMuc3RhdGVzID0gbmV3IFN0YXRlKHRoaXMpO1xyXG4gICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbmV3IE9wKG5vb3AsIDAsIDApO1xyXG4gICAgdGhpcy5sZW4gPSAwO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVzZXRzIHRoaXMgaW5zdGFuY2UgdG8gdGhlIGxhc3Qgc3RhdGUuXHJcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxyXG4gKi9cclxuV3JpdGVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xyXG4gICAgaWYgKHRoaXMuc3RhdGVzKSB7XHJcbiAgICAgICAgdGhpcy5oZWFkICAgPSB0aGlzLnN0YXRlcy5oZWFkO1xyXG4gICAgICAgIHRoaXMudGFpbCAgID0gdGhpcy5zdGF0ZXMudGFpbDtcclxuICAgICAgICB0aGlzLmxlbiAgICA9IHRoaXMuc3RhdGVzLmxlbjtcclxuICAgICAgICB0aGlzLnN0YXRlcyA9IHRoaXMuc3RhdGVzLm5leHQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG5ldyBPcChub29wLCAwLCAwKTtcclxuICAgICAgICB0aGlzLmxlbiAgPSAwO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVzZXRzIHRvIHRoZSBsYXN0IHN0YXRlIGFuZCBhcHBlbmRzIHRoZSBmb3JrIHN0YXRlJ3MgY3VycmVudCB3cml0ZSBsZW5ndGggYXMgYSB2YXJpbnQgZm9sbG93ZWQgYnkgaXRzIG9wZXJhdGlvbnMuXHJcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxyXG4gKi9cclxuV3JpdGVyLnByb3RvdHlwZS5sZGVsaW0gPSBmdW5jdGlvbiBsZGVsaW0oKSB7XHJcbiAgICB2YXIgaGVhZCA9IHRoaXMuaGVhZCxcclxuICAgICAgICB0YWlsID0gdGhpcy50YWlsLFxyXG4gICAgICAgIGxlbiAgPSB0aGlzLmxlbjtcclxuICAgIHRoaXMucmVzZXQoKS51aW50MzIobGVuKTtcclxuICAgIGlmIChsZW4pIHtcclxuICAgICAgICB0aGlzLnRhaWwubmV4dCA9IGhlYWQubmV4dDsgLy8gc2tpcCBub29wXHJcbiAgICAgICAgdGhpcy50YWlsID0gdGFpbDtcclxuICAgICAgICB0aGlzLmxlbiArPSBsZW47XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBGaW5pc2hlcyB0aGUgd3JpdGUgb3BlcmF0aW9uLlxyXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX0gRmluaXNoZWQgYnVmZmVyXHJcbiAqL1xyXG5Xcml0ZXIucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uIGZpbmlzaCgpIHtcclxuICAgIHZhciBoZWFkID0gdGhpcy5oZWFkLm5leHQsIC8vIHNraXAgbm9vcFxyXG4gICAgICAgIGJ1ZiAgPSB0aGlzLmNvbnN0cnVjdG9yLmFsbG9jKHRoaXMubGVuKSxcclxuICAgICAgICBwb3MgID0gMDtcclxuICAgIHdoaWxlIChoZWFkKSB7XHJcbiAgICAgICAgaGVhZC5mbihoZWFkLnZhbCwgYnVmLCBwb3MpO1xyXG4gICAgICAgIHBvcyArPSBoZWFkLmxlbjtcclxuICAgICAgICBoZWFkID0gaGVhZC5uZXh0O1xyXG4gICAgfVxyXG4gICAgLy8gdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcclxuICAgIHJldHVybiBidWY7XHJcbn07XHJcblxyXG5Xcml0ZXIuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uKEJ1ZmZlcldyaXRlcl8pIHtcclxuICAgIEJ1ZmZlcldyaXRlciA9IEJ1ZmZlcldyaXRlcl87XHJcbn07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgdXRpbCA9IGV4cG9ydHM7XHJcblxyXG4vLyB1c2VkIHRvIHJldHVybiBhIFByb21pc2Ugd2hlcmUgY2FsbGJhY2sgaXMgb21pdHRlZFxyXG51dGlsLmFzUHJvbWlzZSA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9hc3Byb21pc2VcIik7XHJcblxyXG4vLyBjb252ZXJ0cyB0byAvIGZyb20gYmFzZTY0IGVuY29kZWQgc3RyaW5nc1xyXG51dGlsLmJhc2U2NCA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9iYXNlNjRcIik7XHJcblxyXG4vLyBiYXNlIGNsYXNzIG9mIHJwYy5TZXJ2aWNlXHJcbnV0aWwuRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL2V2ZW50ZW1pdHRlclwiKTtcclxuXHJcbi8vIGZsb2F0IGhhbmRsaW5nIGFjY3Jvc3MgYnJvd3NlcnNcclxudXRpbC5mbG9hdCA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9mbG9hdFwiKTtcclxuXHJcbi8vIHJlcXVpcmVzIG1vZHVsZXMgb3B0aW9uYWxseSBhbmQgaGlkZXMgdGhlIGNhbGwgZnJvbSBidW5kbGVyc1xyXG51dGlsLmlucXVpcmUgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvaW5xdWlyZVwiKTtcclxuXHJcbi8vIGNvbnZlcnRzIHRvIC8gZnJvbSB1dGY4IGVuY29kZWQgc3RyaW5nc1xyXG51dGlsLnV0ZjggPSByZXF1aXJlKFwiQHByb3RvYnVmanMvdXRmOFwiKTtcclxuXHJcbi8vIHByb3ZpZGVzIGEgbm9kZS1saWtlIGJ1ZmZlciBwb29sIGluIHRoZSBicm93c2VyXHJcbnV0aWwucG9vbCA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9wb29sXCIpO1xyXG5cclxuLy8gdXRpbGl0eSB0byB3b3JrIHdpdGggdGhlIGxvdyBhbmQgaGlnaCBiaXRzIG9mIGEgNjQgYml0IHZhbHVlXHJcbnV0aWwuTG9uZ0JpdHMgPSByZXF1aXJlKFwiLi9sb25nYml0c1wiKTtcclxuXHJcbi8vIGdsb2JhbCBvYmplY3QgcmVmZXJlbmNlXHJcbnV0aWwuZ2xvYmFsID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3dcclxuICAgICAgICAgICB8fCB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbFxyXG4gICAgICAgICAgIHx8IHR5cGVvZiBzZWxmICAgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZlxyXG4gICAgICAgICAgIHx8IHRoaXM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8taW52YWxpZC10aGlzXHJcblxyXG4vKipcclxuICogQW4gaW1tdWFibGUgZW1wdHkgYXJyYXkuXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEB0eXBlIHtBcnJheS48Kj59XHJcbiAqIEBjb25zdFxyXG4gKi9cclxudXRpbC5lbXB0eUFycmF5ID0gT2JqZWN0LmZyZWV6ZSA/IE9iamVjdC5mcmVlemUoW10pIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gW107IC8vIHVzZWQgb24gcHJvdG90eXBlc1xyXG5cclxuLyoqXHJcbiAqIEFuIGltbXV0YWJsZSBlbXB0eSBvYmplY3QuXHJcbiAqIEB0eXBlIHtPYmplY3R9XHJcbiAqIEBjb25zdFxyXG4gKi9cclxudXRpbC5lbXB0eU9iamVjdCA9IE9iamVjdC5mcmVlemUgPyBPYmplY3QuZnJlZXplKHt9KSA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHt9OyAvLyB1c2VkIG9uIHByb3RvdHlwZXNcclxuXHJcbi8qKlxyXG4gKiBXaGV0aGVyIHJ1bm5pbmcgd2l0aGluIG5vZGUgb3Igbm90LlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAdHlwZSB7Ym9vbGVhbn1cclxuICogQGNvbnN0XHJcbiAqL1xyXG51dGlsLmlzTm9kZSA9IEJvb2xlYW4odXRpbC5nbG9iYWwucHJvY2VzcyAmJiB1dGlsLmdsb2JhbC5wcm9jZXNzLnZlcnNpb25zICYmIHV0aWwuZ2xvYmFsLnByb2Nlc3MudmVyc2lvbnMubm9kZSk7XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhbiBpbnRlZ2VyLlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byB0ZXN0XHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIGFuIGludGVnZXJcclxuICovXHJcbnV0aWwuaXNJbnRlZ2VyID0gTnVtYmVyLmlzSW50ZWdlciB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBmdW5jdGlvbiBpc0ludGVnZXIodmFsdWUpIHtcclxuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgJiYgaXNGaW5pdGUodmFsdWUpICYmIE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGEgc3RyaW5nLlxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHRlc3RcclxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgYSBzdHJpbmdcclxuICovXHJcbnV0aWwuaXNTdHJpbmcgPSBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGEgbm9uLW51bGwgb2JqZWN0LlxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHRlc3RcclxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgYSBub24tbnVsbCBvYmplY3RcclxuICovXHJcbnV0aWwuaXNPYmplY3QgPSBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYSBwcm9wZXJ0eSBvbiBhIG1lc3NhZ2UgaXMgY29uc2lkZXJlZCB0byBiZSBwcmVzZW50LlxyXG4gKiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayB1dGlsLmlzU2V0fS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogUGxhaW4gb2JqZWN0IG9yIG1lc3NhZ2UgaW5zdGFuY2VcclxuICogQHBhcmFtIHtzdHJpbmd9IHByb3AgUHJvcGVydHkgbmFtZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIGNvbnNpZGVyZWQgdG8gYmUgcHJlc2VudCwgb3RoZXJ3aXNlIGBmYWxzZWBcclxuICovXHJcbnV0aWwuaXNzZXQgPVxyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBhIHByb3BlcnR5IG9uIGEgbWVzc2FnZSBpcyBjb25zaWRlcmVkIHRvIGJlIHByZXNlbnQuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogUGxhaW4gb2JqZWN0IG9yIG1lc3NhZ2UgaW5zdGFuY2VcclxuICogQHBhcmFtIHtzdHJpbmd9IHByb3AgUHJvcGVydHkgbmFtZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIGNvbnNpZGVyZWQgdG8gYmUgcHJlc2VudCwgb3RoZXJ3aXNlIGBmYWxzZWBcclxuICovXHJcbnV0aWwuaXNTZXQgPSBmdW5jdGlvbiBpc1NldChvYmosIHByb3ApIHtcclxuICAgIHZhciB2YWx1ZSA9IG9ialtwcm9wXTtcclxuICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXEsIG5vLXByb3RvdHlwZS1idWlsdGluc1xyXG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgKEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUubGVuZ3RoIDogT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCkgPiAwO1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFueSBjb21wYXRpYmxlIEJ1ZmZlciBpbnN0YW5jZS5cclxuICogVGhpcyBpcyBhIG1pbmltYWwgc3RhbmQtYWxvbmUgZGVmaW5pdGlvbiBvZiBhIEJ1ZmZlciBpbnN0YW5jZS4gVGhlIGFjdHVhbCB0eXBlIGlzIHRoYXQgZXhwb3J0ZWQgYnkgbm9kZSdzIHR5cGluZ3MuXHJcbiAqIEBpbnRlcmZhY2UgQnVmZmVyXHJcbiAqIEBleHRlbmRzIFVpbnQ4QXJyYXlcclxuICovXHJcblxyXG4vKipcclxuICogTm9kZSdzIEJ1ZmZlciBjbGFzcyBpZiBhdmFpbGFibGUuXHJcbiAqIEB0eXBlIHtDb25zdHJ1Y3RvcjxCdWZmZXI+fVxyXG4gKi9cclxudXRpbC5CdWZmZXIgPSAoZnVuY3Rpb24oKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHZhciBCdWZmZXIgPSB1dGlsLmlucXVpcmUoXCJidWZmZXJcIikuQnVmZmVyO1xyXG4gICAgICAgIC8vIHJlZnVzZSB0byB1c2Ugbm9uLW5vZGUgYnVmZmVycyBpZiBub3QgZXhwbGljaXRseSBhc3NpZ25lZCAocGVyZiByZWFzb25zKTpcclxuICAgICAgICByZXR1cm4gQnVmZmVyLnByb3RvdHlwZS51dGY4V3JpdGUgPyBCdWZmZXIgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBudWxsO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn0pKCk7XHJcblxyXG4vLyBJbnRlcm5hbCBhbGlhcyBvZiBvciBwb2x5ZnVsbCBmb3IgQnVmZmVyLmZyb20uXHJcbnV0aWwuX0J1ZmZlcl9mcm9tID0gbnVsbDtcclxuXHJcbi8vIEludGVybmFsIGFsaWFzIG9mIG9yIHBvbHlmaWxsIGZvciBCdWZmZXIuYWxsb2NVbnNhZmUuXHJcbnV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZSA9IG51bGw7XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBidWZmZXIgb2Ygd2hhdGV2ZXIgdHlwZSBzdXBwb3J0ZWQgYnkgdGhlIGVudmlyb25tZW50LlxyXG4gKiBAcGFyYW0ge251bWJlcnxudW1iZXJbXX0gW3NpemVPckFycmF5PTBdIEJ1ZmZlciBzaXplIG9yIG51bWJlciBhcnJheVxyXG4gKiBAcmV0dXJucyB7VWludDhBcnJheXxCdWZmZXJ9IEJ1ZmZlclxyXG4gKi9cclxudXRpbC5uZXdCdWZmZXIgPSBmdW5jdGlvbiBuZXdCdWZmZXIoc2l6ZU9yQXJyYXkpIHtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICByZXR1cm4gdHlwZW9mIHNpemVPckFycmF5ID09PSBcIm51bWJlclwiXHJcbiAgICAgICAgPyB1dGlsLkJ1ZmZlclxyXG4gICAgICAgICAgICA/IHV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZShzaXplT3JBcnJheSlcclxuICAgICAgICAgICAgOiBuZXcgdXRpbC5BcnJheShzaXplT3JBcnJheSlcclxuICAgICAgICA6IHV0aWwuQnVmZmVyXHJcbiAgICAgICAgICAgID8gdXRpbC5fQnVmZmVyX2Zyb20oc2l6ZU9yQXJyYXkpXHJcbiAgICAgICAgICAgIDogdHlwZW9mIFVpbnQ4QXJyYXkgPT09IFwidW5kZWZpbmVkXCJcclxuICAgICAgICAgICAgICAgID8gc2l6ZU9yQXJyYXlcclxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoc2l6ZU9yQXJyYXkpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFycmF5IGltcGxlbWVudGF0aW9uIHVzZWQgaW4gdGhlIGJyb3dzZXIuIGBVaW50OEFycmF5YCBpZiBzdXBwb3J0ZWQsIG90aGVyd2lzZSBgQXJyYXlgLlxyXG4gKiBAdHlwZSB7Q29uc3RydWN0b3I8VWludDhBcnJheT59XHJcbiAqL1xyXG51dGlsLkFycmF5ID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09IFwidW5kZWZpbmVkXCIgPyBVaW50OEFycmF5IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIDogQXJyYXk7XHJcblxyXG4vKipcclxuICogQW55IGNvbXBhdGlibGUgTG9uZyBpbnN0YW5jZS5cclxuICogVGhpcyBpcyBhIG1pbmltYWwgc3RhbmQtYWxvbmUgZGVmaW5pdGlvbiBvZiBhIExvbmcgaW5zdGFuY2UuIFRoZSBhY3R1YWwgdHlwZSBpcyB0aGF0IGV4cG9ydGVkIGJ5IGxvbmcuanMuXHJcbiAqIEBpbnRlcmZhY2UgTG9uZ1xyXG4gKiBAcHJvcGVydHkge251bWJlcn0gbG93IExvdyBiaXRzXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoaWdoIEhpZ2ggYml0c1xyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIExvbmcuanMncyBMb25nIGNsYXNzIGlmIGF2YWlsYWJsZS5cclxuICogQHR5cGUge0NvbnN0cnVjdG9yPExvbmc+fVxyXG4gKi9cclxudXRpbC5Mb25nID0gLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gdXRpbC5nbG9iYWwuZGNvZGVJTyAmJiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB1dGlsLmdsb2JhbC5kY29kZUlPLkxvbmdcclxuICAgICAgICAgfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gdXRpbC5nbG9iYWwuTG9uZ1xyXG4gICAgICAgICB8fCB1dGlsLmlucXVpcmUoXCJsb25nXCIpO1xyXG5cclxuLyoqXHJcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIHZlcmlmeSAyIGJpdCAoYGJvb2xgKSBtYXAga2V5cy5cclxuICogQHR5cGUge1JlZ0V4cH1cclxuICogQGNvbnN0XHJcbiAqL1xyXG51dGlsLmtleTJSZSA9IC9edHJ1ZXxmYWxzZXwwfDEkLztcclxuXHJcbi8qKlxyXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gdXNlZCB0byB2ZXJpZnkgMzIgYml0IChgaW50MzJgIGV0Yy4pIG1hcCBrZXlzLlxyXG4gKiBAdHlwZSB7UmVnRXhwfVxyXG4gKiBAY29uc3RcclxuICovXHJcbnV0aWwua2V5MzJSZSA9IC9eLT8oPzowfFsxLTldWzAtOV0qKSQvO1xyXG5cclxuLyoqXHJcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIHZlcmlmeSA2NCBiaXQgKGBpbnQ2NGAgZXRjLikgbWFwIGtleXMuXHJcbiAqIEB0eXBlIHtSZWdFeHB9XHJcbiAqIEBjb25zdFxyXG4gKi9cclxudXRpbC5rZXk2NFJlID0gL14oPzpbXFxcXHgwMC1cXFxceGZmXXs4fXwtPyg/OjB8WzEtOV1bMC05XSopKSQvO1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIGEgbnVtYmVyIG9yIGxvbmcgdG8gYW4gOCBjaGFyYWN0ZXJzIGxvbmcgaGFzaCBzdHJpbmcuXHJcbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIGNvbnZlcnRcclxuICogQHJldHVybnMge3N0cmluZ30gSGFzaFxyXG4gKi9cclxudXRpbC5sb25nVG9IYXNoID0gZnVuY3Rpb24gbG9uZ1RvSGFzaCh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlXHJcbiAgICAgICAgPyB1dGlsLkxvbmdCaXRzLmZyb20odmFsdWUpLnRvSGFzaCgpXHJcbiAgICAgICAgOiB1dGlsLkxvbmdCaXRzLnplcm9IYXNoO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIGFuIDggY2hhcmFjdGVycyBsb25nIGhhc2ggc3RyaW5nIHRvIGEgbG9uZyBvciBudW1iZXIuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBoYXNoIEhhc2hcclxuICogQHBhcmFtIHtib29sZWFufSBbdW5zaWduZWQ9ZmFsc2VdIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90XHJcbiAqIEByZXR1cm5zIHtMb25nfG51bWJlcn0gT3JpZ2luYWwgdmFsdWVcclxuICovXHJcbnV0aWwubG9uZ0Zyb21IYXNoID0gZnVuY3Rpb24gbG9uZ0Zyb21IYXNoKGhhc2gsIHVuc2lnbmVkKSB7XHJcbiAgICB2YXIgYml0cyA9IHV0aWwuTG9uZ0JpdHMuZnJvbUhhc2goaGFzaCk7XHJcbiAgICBpZiAodXRpbC5Mb25nKVxyXG4gICAgICAgIHJldHVybiB1dGlsLkxvbmcuZnJvbUJpdHMoYml0cy5sbywgYml0cy5oaSwgdW5zaWduZWQpO1xyXG4gICAgcmV0dXJuIGJpdHMudG9OdW1iZXIoQm9vbGVhbih1bnNpZ25lZCkpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiB0aGUgc291cmNlIG9iamVjdCBpbnRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IGRzdCBEZXN0aW5hdGlvbiBvYmplY3RcclxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gc3JjIFNvdXJjZSBvYmplY3RcclxuICogQHBhcmFtIHtib29sZWFufSBbaWZOb3RTZXQ9ZmFsc2VdIE1lcmdlcyBvbmx5IGlmIHRoZSBrZXkgaXMgbm90IGFscmVhZHkgc2V0XHJcbiAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gRGVzdGluYXRpb24gb2JqZWN0XHJcbiAqL1xyXG5mdW5jdGlvbiBtZXJnZShkc3QsIHNyYywgaWZOb3RTZXQpIHsgLy8gdXNlZCBieSBjb252ZXJ0ZXJzXHJcbiAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMoc3JjKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxyXG4gICAgICAgIGlmIChkc3Rba2V5c1tpXV0gPT09IHVuZGVmaW5lZCB8fCAhaWZOb3RTZXQpXHJcbiAgICAgICAgICAgIGRzdFtrZXlzW2ldXSA9IHNyY1trZXlzW2ldXTtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuXHJcbnV0aWwubWVyZ2UgPSBtZXJnZTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGEgc3RyaW5nIHRvIGxvd2VyIGNhc2UuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIGNvbnZlcnRcclxuICogQHJldHVybnMge3N0cmluZ30gQ29udmVydGVkIHN0cmluZ1xyXG4gKi9cclxudXRpbC5sY0ZpcnN0ID0gZnVuY3Rpb24gbGNGaXJzdChzdHIpIHtcclxuICAgIHJldHVybiBzdHIuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyBzdHIuc3Vic3RyaW5nKDEpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBjdXN0b20gZXJyb3IgY29uc3RydWN0b3IuXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEVycm9yIG5hbWVcclxuICogQHJldHVybnMge0NvbnN0cnVjdG9yPEVycm9yPn0gQ3VzdG9tIGVycm9yIGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBuZXdFcnJvcihuYW1lKSB7XHJcblxyXG4gICAgZnVuY3Rpb24gQ3VzdG9tRXJyb3IobWVzc2FnZSwgcHJvcGVydGllcykge1xyXG5cclxuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ3VzdG9tRXJyb3IpKVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEN1c3RvbUVycm9yKG1lc3NhZ2UsIHByb3BlcnRpZXMpO1xyXG5cclxuICAgICAgICAvLyBFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xyXG4gICAgICAgIC8vIF4ganVzdCByZXR1cm5zIGEgbmV3IGVycm9yIGluc3RhbmNlIGJlY2F1c2UgdGhlIGN0b3IgY2FuIGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uXHJcblxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1lc3NhZ2VcIiwgeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbWVzc2FnZTsgfSB9KTtcclxuXHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIC8vIG5vZGVcclxuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgQ3VzdG9tRXJyb3IpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhY2tcIiwgeyB2YWx1ZTogKG5ldyBFcnJvcigpKS5zdGFjayB8fCBcIlwiIH0pO1xyXG5cclxuICAgICAgICBpZiAocHJvcGVydGllcylcclxuICAgICAgICAgICAgbWVyZ2UodGhpcywgcHJvcGVydGllcyk7XHJcbiAgICB9XHJcblxyXG4gICAgKEN1c3RvbUVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBDdXN0b21FcnJvcjtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ3VzdG9tRXJyb3IucHJvdG90eXBlLCBcIm5hbWVcIiwgeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbmFtZTsgfSB9KTtcclxuXHJcbiAgICBDdXN0b21FcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5uYW1lICsgXCI6IFwiICsgdGhpcy5tZXNzYWdlO1xyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gQ3VzdG9tRXJyb3I7XHJcbn1cclxuXHJcbnV0aWwubmV3RXJyb3IgPSBuZXdFcnJvcjtcclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHByb3RvY29sIGVycm9yLlxyXG4gKiBAY2xhc3NkZXNjIEVycm9yIHN1YmNsYXNzIGluZGljYXRpbmcgYSBwcm90b2NvbCBzcGVjaWZjIGVycm9yLlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAZXh0ZW5kcyBFcnJvclxyXG4gKiBAdGVtcGxhdGUgVCBleHRlbmRzIE1lc3NhZ2U8VD5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIEVycm9yIG1lc3NhZ2VcclxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gW3Byb3BlcnRpZXNdIEFkZGl0aW9uYWwgcHJvcGVydGllc1xyXG4gKiBAZXhhbXBsZVxyXG4gKiB0cnkge1xyXG4gKiAgICAgTXlNZXNzYWdlLmRlY29kZShzb21lQnVmZmVyKTsgLy8gdGhyb3dzIGlmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xyXG4gKiB9IGNhdGNoIChlKSB7XHJcbiAqICAgICBpZiAoZSBpbnN0YW5jZW9mIFByb3RvY29sRXJyb3IgJiYgZS5pbnN0YW5jZSlcclxuICogICAgICAgICBjb25zb2xlLmxvZyhcImRlY29kZWQgc28gZmFyOiBcIiArIEpTT04uc3RyaW5naWZ5KGUuaW5zdGFuY2UpKTtcclxuICogfVxyXG4gKi9cclxudXRpbC5Qcm90b2NvbEVycm9yID0gbmV3RXJyb3IoXCJQcm90b2NvbEVycm9yXCIpO1xyXG5cclxuLyoqXHJcbiAqIFNvIGZhciBkZWNvZGVkIG1lc3NhZ2UgaW5zdGFuY2UuXHJcbiAqIEBuYW1lIHV0aWwuUHJvdG9jb2xFcnJvciNpbnN0YW5jZVxyXG4gKiBAdHlwZSB7TWVzc2FnZTxUPn1cclxuICovXHJcblxyXG4vKipcclxuICogQSBPbmVPZiBnZXR0ZXIgYXMgcmV0dXJuZWQgYnkge0BsaW5rIHV0aWwub25lT2ZHZXR0ZXJ9LlxyXG4gKiBAdHlwZWRlZiBPbmVPZkdldHRlclxyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBTZXQgZmllbGQgbmFtZSwgaWYgYW55XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEJ1aWxkcyBhIGdldHRlciBmb3IgYSBvbmVvZidzIHByZXNlbnQgZmllbGQgbmFtZS5cclxuICogQHBhcmFtIHtzdHJpbmdbXX0gZmllbGROYW1lcyBGaWVsZCBuYW1lc1xyXG4gKiBAcmV0dXJucyB7T25lT2ZHZXR0ZXJ9IFVuYm91bmQgZ2V0dGVyXHJcbiAqL1xyXG51dGlsLm9uZU9mR2V0dGVyID0gZnVuY3Rpb24gZ2V0T25lT2YoZmllbGROYW1lcykge1xyXG4gICAgdmFyIGZpZWxkTWFwID0ge307XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkTmFtZXMubGVuZ3RoOyArK2kpXHJcbiAgICAgICAgZmllbGRNYXBbZmllbGROYW1lc1tpXV0gPSAxO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFNldCBmaWVsZCBuYW1lLCBpZiBhbnlcclxuICAgICAqIEB0aGlzIE9iamVjdFxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICovXHJcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC1yZXR1cm5cclxuICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXModGhpcyksIGkgPSBrZXlzLmxlbmd0aCAtIDE7IGkgPiAtMTsgLS1pKVxyXG4gICAgICAgICAgICBpZiAoZmllbGRNYXBba2V5c1tpXV0gPT09IDEgJiYgdGhpc1trZXlzW2ldXSAhPT0gdW5kZWZpbmVkICYmIHRoaXNba2V5c1tpXV0gIT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5c1tpXTtcclxuICAgIH07XHJcbn07XHJcblxyXG4vKipcclxuICogQSBPbmVPZiBzZXR0ZXIgYXMgcmV0dXJuZWQgYnkge0BsaW5rIHV0aWwub25lT2ZTZXR0ZXJ9LlxyXG4gKiBAdHlwZWRlZiBPbmVPZlNldHRlclxyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gdmFsdWUgRmllbGQgbmFtZVxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBCdWlsZHMgYSBzZXR0ZXIgZm9yIGEgb25lb2YncyBwcmVzZW50IGZpZWxkIG5hbWUuXHJcbiAqIEBwYXJhbSB7c3RyaW5nW119IGZpZWxkTmFtZXMgRmllbGQgbmFtZXNcclxuICogQHJldHVybnMge09uZU9mU2V0dGVyfSBVbmJvdW5kIHNldHRlclxyXG4gKi9cclxudXRpbC5vbmVPZlNldHRlciA9IGZ1bmN0aW9uIHNldE9uZU9mKGZpZWxkTmFtZXMpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEZpZWxkIG5hbWVcclxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAgICAgKiBAdGhpcyBPYmplY3RcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqL1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG5hbWUpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkTmFtZXMubGVuZ3RoOyArK2kpXHJcbiAgICAgICAgICAgIGlmIChmaWVsZE5hbWVzW2ldICE9PSBuYW1lKVxyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXNbZmllbGROYW1lc1tpXV07XHJcbiAgICB9O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIERlZmF1bHQgY29udmVyc2lvbiBvcHRpb25zIHVzZWQgZm9yIHtAbGluayBNZXNzYWdlI3RvSlNPTn0gaW1wbGVtZW50YXRpb25zLlxyXG4gKlxyXG4gKiBUaGVzZSBvcHRpb25zIGFyZSBjbG9zZSB0byBwcm90bzMncyBKU09OIG1hcHBpbmcgd2l0aCB0aGUgZXhjZXB0aW9uIHRoYXQgaW50ZXJuYWwgdHlwZXMgbGlrZSBBbnkgYXJlIGhhbmRsZWQganVzdCBsaWtlIG1lc3NhZ2VzLiBNb3JlIHByZWNpc2VseTpcclxuICpcclxuICogLSBMb25ncyBiZWNvbWUgc3RyaW5nc1xyXG4gKiAtIEVudW1zIGJlY29tZSBzdHJpbmcga2V5c1xyXG4gKiAtIEJ5dGVzIGJlY29tZSBiYXNlNjQgZW5jb2RlZCBzdHJpbmdzXHJcbiAqIC0gKFN1Yi0pTWVzc2FnZXMgYmVjb21lIHBsYWluIG9iamVjdHNcclxuICogLSBNYXBzIGJlY29tZSBwbGFpbiBvYmplY3RzIHdpdGggYWxsIHN0cmluZyBrZXlzXHJcbiAqIC0gUmVwZWF0ZWQgZmllbGRzIGJlY29tZSBhcnJheXNcclxuICogLSBOYU4gYW5kIEluZmluaXR5IGZvciBmbG9hdCBhbmQgZG91YmxlIGZpZWxkcyBiZWNvbWUgc3RyaW5nc1xyXG4gKlxyXG4gKiBAdHlwZSB7SUNvbnZlcnNpb25PcHRpb25zfVxyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3Byb3RvY29sLWJ1ZmZlcnMvZG9jcy9wcm90bzM/aGw9ZW4janNvblxyXG4gKi9cclxudXRpbC50b0pTT05PcHRpb25zID0ge1xyXG4gICAgbG9uZ3M6IFN0cmluZyxcclxuICAgIGVudW1zOiBTdHJpbmcsXHJcbiAgICBieXRlczogU3RyaW5nLFxyXG4gICAganNvbjogdHJ1ZVxyXG59O1xyXG5cclxuLy8gU2V0cyB1cCBidWZmZXIgdXRpbGl0eSBhY2NvcmRpbmcgdG8gdGhlIGVudmlyb25tZW50IChjYWxsZWQgaW4gaW5kZXgtbWluaW1hbClcclxudXRpbC5fY29uZmlndXJlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgQnVmZmVyID0gdXRpbC5CdWZmZXI7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmICghQnVmZmVyKSB7XHJcbiAgICAgICAgdXRpbC5fQnVmZmVyX2Zyb20gPSB1dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmUgPSBudWxsO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIC8vIGJlY2F1c2Ugbm9kZSA0LnggYnVmZmVycyBhcmUgaW5jb21wYXRpYmxlICYgaW1tdXRhYmxlXHJcbiAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kY29kZUlPL3Byb3RvYnVmLmpzL3B1bGwvNjY1XHJcbiAgICB1dGlsLl9CdWZmZXJfZnJvbSA9IEJ1ZmZlci5mcm9tICE9PSBVaW50OEFycmF5LmZyb20gJiYgQnVmZmVyLmZyb20gfHxcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIEJ1ZmZlcl9mcm9tKHZhbHVlLCBlbmNvZGluZykge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmcpO1xyXG4gICAgICAgIH07XHJcbiAgICB1dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmUgPSBCdWZmZXIuYWxsb2NVbnNhZmUgfHxcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIEJ1ZmZlcl9hbGxvY1Vuc2FmZShzaXplKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyKHNpemUpO1xyXG4gICAgICAgIH07XHJcbn07XHJcbiIsInZhciBnO1xuXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuZyA9IChmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXM7XG59KSgpO1xuXG50cnkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcblx0ZyA9IGcgfHwgbmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbn0gY2F0Y2ggKGUpIHtcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XG59XG5cbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cbm1vZHVsZS5leHBvcnRzID0gZztcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGFzUHJvbWlzZTtcclxuXHJcbi8qKlxyXG4gKiBDYWxsYmFjayBhcyB1c2VkIGJ5IHtAbGluayB1dGlsLmFzUHJvbWlzZX0uXHJcbiAqIEB0eXBlZGVmIGFzUHJvbWlzZUNhbGxiYWNrXHJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cclxuICogQHBhcmFtIHtFcnJvcnxudWxsfSBlcnJvciBFcnJvciwgaWYgYW55XHJcbiAqIEBwYXJhbSB7Li4uKn0gcGFyYW1zIEFkZGl0aW9uYWwgYXJndW1lbnRzXHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBwcm9taXNlIGZyb20gYSBub2RlLXN0eWxlIGNhbGxiYWNrIGZ1bmN0aW9uLlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAcGFyYW0ge2FzUHJvbWlzZUNhbGxiYWNrfSBmbiBGdW5jdGlvbiB0byBjYWxsXHJcbiAqIEBwYXJhbSB7Kn0gY3R4IEZ1bmN0aW9uIGNvbnRleHRcclxuICogQHBhcmFtIHsuLi4qfSBwYXJhbXMgRnVuY3Rpb24gYXJndW1lbnRzXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPCo+fSBQcm9taXNpZmllZCBmdW5jdGlvblxyXG4gKi9cclxuZnVuY3Rpb24gYXNQcm9taXNlKGZuLCBjdHgvKiwgdmFyYXJncyAqLykge1xyXG4gICAgdmFyIHBhcmFtcyAgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpLFxyXG4gICAgICAgIG9mZnNldCAgPSAwLFxyXG4gICAgICAgIGluZGV4ICAgPSAyLFxyXG4gICAgICAgIHBlbmRpbmcgPSB0cnVlO1xyXG4gICAgd2hpbGUgKGluZGV4IDwgYXJndW1lbnRzLmxlbmd0aClcclxuICAgICAgICBwYXJhbXNbb2Zmc2V0KytdID0gYXJndW1lbnRzW2luZGV4KytdO1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIGV4ZWN1dG9yKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIHBhcmFtc1tvZmZzZXRdID0gZnVuY3Rpb24gY2FsbGJhY2soZXJyLyosIHZhcmFyZ3MgKi8pIHtcclxuICAgICAgICAgICAgaWYgKHBlbmRpbmcpIHtcclxuICAgICAgICAgICAgICAgIHBlbmRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGlmIChlcnIpXHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAob2Zmc2V0IDwgcGFyYW1zLmxlbmd0aClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zW29mZnNldCsrXSA9IGFyZ3VtZW50c1tvZmZzZXRdO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUuYXBwbHkobnVsbCwgcGFyYW1zKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgZm4uYXBwbHkoY3R4IHx8IG51bGwsIHBhcmFtcyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgIGlmIChwZW5kaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBwZW5kaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLyoqXHJcbiAqIEEgbWluaW1hbCBiYXNlNjQgaW1wbGVtZW50YXRpb24gZm9yIG51bWJlciBhcnJheXMuXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBuYW1lc3BhY2VcclxuICovXHJcbnZhciBiYXNlNjQgPSBleHBvcnRzO1xyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGJ5dGUgbGVuZ3RoIG9mIGEgYmFzZTY0IGVuY29kZWQgc3RyaW5nLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIEJhc2U2NCBlbmNvZGVkIHN0cmluZ1xyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBCeXRlIGxlbmd0aFxyXG4gKi9cclxuYmFzZTY0Lmxlbmd0aCA9IGZ1bmN0aW9uIGxlbmd0aChzdHJpbmcpIHtcclxuICAgIHZhciBwID0gc3RyaW5nLmxlbmd0aDtcclxuICAgIGlmICghcClcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIHZhciBuID0gMDtcclxuICAgIHdoaWxlICgtLXAgJSA0ID4gMSAmJiBzdHJpbmcuY2hhckF0KHApID09PSBcIj1cIilcclxuICAgICAgICArK247XHJcbiAgICByZXR1cm4gTWF0aC5jZWlsKHN0cmluZy5sZW5ndGggKiAzKSAvIDQgLSBuO1xyXG59O1xyXG5cclxuLy8gQmFzZTY0IGVuY29kaW5nIHRhYmxlXHJcbnZhciBiNjQgPSBuZXcgQXJyYXkoNjQpO1xyXG5cclxuLy8gQmFzZTY0IGRlY29kaW5nIHRhYmxlXHJcbnZhciBzNjQgPSBuZXcgQXJyYXkoMTIzKTtcclxuXHJcbi8vIDY1Li45MCwgOTcuLjEyMiwgNDguLjU3LCA0MywgNDdcclxuZm9yICh2YXIgaSA9IDA7IGkgPCA2NDspXHJcbiAgICBzNjRbYjY0W2ldID0gaSA8IDI2ID8gaSArIDY1IDogaSA8IDUyID8gaSArIDcxIDogaSA8IDYyID8gaSAtIDQgOiBpIC0gNTkgfCA0M10gPSBpKys7XHJcblxyXG4vKipcclxuICogRW5jb2RlcyBhIGJ1ZmZlciB0byBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZy5cclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZmZXIgU291cmNlIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgU291cmNlIHN0YXJ0XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgU291cmNlIGVuZFxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBCYXNlNjQgZW5jb2RlZCBzdHJpbmdcclxuICovXHJcbmJhc2U2NC5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUoYnVmZmVyLCBzdGFydCwgZW5kKSB7XHJcbiAgICB2YXIgcGFydHMgPSBudWxsLFxyXG4gICAgICAgIGNodW5rID0gW107XHJcbiAgICB2YXIgaSA9IDAsIC8vIG91dHB1dCBpbmRleFxyXG4gICAgICAgIGogPSAwLCAvLyBnb3RvIGluZGV4XHJcbiAgICAgICAgdDsgICAgIC8vIHRlbXBvcmFyeVxyXG4gICAgd2hpbGUgKHN0YXJ0IDwgZW5kKSB7XHJcbiAgICAgICAgdmFyIGIgPSBidWZmZXJbc3RhcnQrK107XHJcbiAgICAgICAgc3dpdGNoIChqKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgIGNodW5rW2krK10gPSBiNjRbYiA+PiAyXTtcclxuICAgICAgICAgICAgICAgIHQgPSAoYiAmIDMpIDw8IDQ7XHJcbiAgICAgICAgICAgICAgICBqID0gMTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICBjaHVua1tpKytdID0gYjY0W3QgfCBiID4+IDRdO1xyXG4gICAgICAgICAgICAgICAgdCA9IChiICYgMTUpIDw8IDI7XHJcbiAgICAgICAgICAgICAgICBqID0gMjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICBjaHVua1tpKytdID0gYjY0W3QgfCBiID4+IDZdO1xyXG4gICAgICAgICAgICAgICAgY2h1bmtbaSsrXSA9IGI2NFtiICYgNjNdO1xyXG4gICAgICAgICAgICAgICAgaiA9IDA7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGkgPiA4MTkxKSB7XHJcbiAgICAgICAgICAgIChwYXJ0cyB8fCAocGFydHMgPSBbXSkpLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNodW5rKSk7XHJcbiAgICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChqKSB7XHJcbiAgICAgICAgY2h1bmtbaSsrXSA9IGI2NFt0XTtcclxuICAgICAgICBjaHVua1tpKytdID0gNjE7XHJcbiAgICAgICAgaWYgKGogPT09IDEpXHJcbiAgICAgICAgICAgIGNodW5rW2krK10gPSA2MTtcclxuICAgIH1cclxuICAgIGlmIChwYXJ0cykge1xyXG4gICAgICAgIGlmIChpKVxyXG4gICAgICAgICAgICBwYXJ0cy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaHVuay5zbGljZSgwLCBpKSkpO1xyXG4gICAgICAgIHJldHVybiBwYXJ0cy5qb2luKFwiXCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaHVuay5zbGljZSgwLCBpKSk7XHJcbn07XHJcblxyXG52YXIgaW52YWxpZEVuY29kaW5nID0gXCJpbnZhbGlkIGVuY29kaW5nXCI7XHJcblxyXG4vKipcclxuICogRGVjb2RlcyBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZyB0byBhIGJ1ZmZlci5cclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBTb3VyY2Ugc3RyaW5nXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmZmVyIERlc3RpbmF0aW9uIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IERlc3RpbmF0aW9uIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBOdW1iZXIgb2YgYnl0ZXMgd3JpdHRlblxyXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgZW5jb2RpbmcgaXMgaW52YWxpZFxyXG4gKi9cclxuYmFzZTY0LmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShzdHJpbmcsIGJ1ZmZlciwgb2Zmc2V0KSB7XHJcbiAgICB2YXIgc3RhcnQgPSBvZmZzZXQ7XHJcbiAgICB2YXIgaiA9IDAsIC8vIGdvdG8gaW5kZXhcclxuICAgICAgICB0OyAgICAgLy8gdGVtcG9yYXJ5XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7KSB7XHJcbiAgICAgICAgdmFyIGMgPSBzdHJpbmcuY2hhckNvZGVBdChpKyspO1xyXG4gICAgICAgIGlmIChjID09PSA2MSAmJiBqID4gMSlcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgaWYgKChjID0gczY0W2NdKSA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihpbnZhbGlkRW5jb2RpbmcpO1xyXG4gICAgICAgIHN3aXRjaCAoaikge1xyXG4gICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICB0ID0gYztcclxuICAgICAgICAgICAgICAgIGogPSAxO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSB0IDw8IDIgfCAoYyAmIDQ4KSA+PiA0O1xyXG4gICAgICAgICAgICAgICAgdCA9IGM7XHJcbiAgICAgICAgICAgICAgICBqID0gMjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gKHQgJiAxNSkgPDwgNCB8IChjICYgNjApID4+IDI7XHJcbiAgICAgICAgICAgICAgICB0ID0gYztcclxuICAgICAgICAgICAgICAgIGogPSAzO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSAodCAmIDMpIDw8IDYgfCBjO1xyXG4gICAgICAgICAgICAgICAgaiA9IDA7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoaiA9PT0gMSlcclxuICAgICAgICB0aHJvdyBFcnJvcihpbnZhbGlkRW5jb2RpbmcpO1xyXG4gICAgcmV0dXJuIG9mZnNldCAtIHN0YXJ0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgc3RyaW5nIGFwcGVhcnMgdG8gYmUgYmFzZTY0IGVuY29kZWQuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgU3RyaW5nIHRvIHRlc3RcclxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiBwcm9iYWJseSBiYXNlNjQgZW5jb2RlZCwgb3RoZXJ3aXNlIGZhbHNlXHJcbiAqL1xyXG5iYXNlNjQudGVzdCA9IGZ1bmN0aW9uIHRlc3Qoc3RyaW5nKSB7XHJcbiAgICByZXR1cm4gL14oPzpbQS1aYS16MC05Ky9dezR9KSooPzpbQS1aYS16MC05Ky9dezJ9PT18W0EtWmEtejAtOSsvXXszfT0pPyQvLnRlc3Qoc3RyaW5nKTtcclxufTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdHMgYSBuZXcgZXZlbnQgZW1pdHRlciBpbnN0YW5jZS5cclxuICogQGNsYXNzZGVzYyBBIG1pbmltYWwgZXZlbnQgZW1pdHRlci5cclxuICogQG1lbWJlcm9mIHV0aWxcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlcmVkIGxpc3RlbmVycy5cclxuICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywqPn1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xyXG59XHJcblxyXG4vKipcclxuICogUmVnaXN0ZXJzIGFuIGV2ZW50IGxpc3RlbmVyLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZ0IEV2ZW50IG5hbWVcclxuICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gTGlzdGVuZXJcclxuICogQHBhcmFtIHsqfSBbY3R4XSBMaXN0ZW5lciBjb250ZXh0XHJcbiAqIEByZXR1cm5zIHt1dGlsLkV2ZW50RW1pdHRlcn0gYHRoaXNgXHJcbiAqL1xyXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24oZXZ0LCBmbiwgY3R4KSB7XHJcbiAgICAodGhpcy5fbGlzdGVuZXJzW2V2dF0gfHwgKHRoaXMuX2xpc3RlbmVyc1tldnRdID0gW10pKS5wdXNoKHtcclxuICAgICAgICBmbiAgOiBmbixcclxuICAgICAgICBjdHggOiBjdHggfHwgdGhpc1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZW1vdmVzIGFuIGV2ZW50IGxpc3RlbmVyIG9yIGFueSBtYXRjaGluZyBsaXN0ZW5lcnMgaWYgYXJndW1lbnRzIGFyZSBvbWl0dGVkLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gW2V2dF0gRXZlbnQgbmFtZS4gUmVtb3ZlcyBhbGwgbGlzdGVuZXJzIGlmIG9taXR0ZWQuXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtmbl0gTGlzdGVuZXIgdG8gcmVtb3ZlLiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMgb2YgYGV2dGAgaWYgb21pdHRlZC5cclxuICogQHJldHVybnMge3V0aWwuRXZlbnRFbWl0dGVyfSBgdGhpc2BcclxuICovXHJcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gb2ZmKGV2dCwgZm4pIHtcclxuICAgIGlmIChldnQgPT09IHVuZGVmaW5lZClcclxuICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmIChmbiA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnNbZXZ0XSA9IFtdO1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW2V2dF07XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDspXHJcbiAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXJzW2ldLmZuID09PSBmbilcclxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICsraTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBFbWl0cyBhbiBldmVudCBieSBjYWxsaW5nIGl0cyBsaXN0ZW5lcnMgd2l0aCB0aGUgc3BlY2lmaWVkIGFyZ3VtZW50cy5cclxuICogQHBhcmFtIHtzdHJpbmd9IGV2dCBFdmVudCBuYW1lXHJcbiAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcmd1bWVudHNcclxuICogQHJldHVybnMge3V0aWwuRXZlbnRFbWl0dGVyfSBgdGhpc2BcclxuICovXHJcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZ0KSB7XHJcbiAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW2V2dF07XHJcbiAgICBpZiAobGlzdGVuZXJzKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSxcclxuICAgICAgICAgICAgaSA9IDE7XHJcbiAgICAgICAgZm9yICg7IGkgPCBhcmd1bWVudHMubGVuZ3RoOylcclxuICAgICAgICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDspXHJcbiAgICAgICAgICAgIGxpc3RlbmVyc1tpXS5mbi5hcHBseShsaXN0ZW5lcnNbaSsrXS5jdHgsIGFyZ3MpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KGZhY3RvcnkpO1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIC8gd3JpdGVzIGZsb2F0cyAvIGRvdWJsZXMgZnJvbSAvIHRvIGJ1ZmZlcnMuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXRcclxuICogQG5hbWVzcGFjZVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYSAzMiBiaXQgZmxvYXQgdG8gYSBidWZmZXIgdXNpbmcgbGl0dGxlIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LndyaXRlRmxvYXRMRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBUYXJnZXQgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgVGFyZ2V0IGJ1ZmZlciBvZmZzZXRcclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICovXHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgMzIgYml0IGZsb2F0IHRvIGEgYnVmZmVyIHVzaW5nIGJpZyBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC53cml0ZUZsb2F0QkVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgVmFsdWUgdG8gd3JpdGVcclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgVGFyZ2V0IGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFRhcmdldCBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIGEgMzIgYml0IGZsb2F0IGZyb20gYSBidWZmZXIgdXNpbmcgbGl0dGxlIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LnJlYWRGbG9hdExFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBTb3VyY2UgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgU291cmNlIGJ1ZmZlciBvZmZzZXRcclxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBhIDMyIGJpdCBmbG9hdCBmcm9tIGEgYnVmZmVyIHVzaW5nIGJpZyBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC5yZWFkRmxvYXRCRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgU291cmNlIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFNvdXJjZSBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICovXHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgNjQgYml0IGRvdWJsZSB0byBhIGJ1ZmZlciB1c2luZyBsaXR0bGUgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQud3JpdGVEb3VibGVMRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBUYXJnZXQgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgVGFyZ2V0IGJ1ZmZlciBvZmZzZXRcclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICovXHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgNjQgYml0IGRvdWJsZSB0byBhIGJ1ZmZlciB1c2luZyBiaWcgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQud3JpdGVEb3VibGVCRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBUYXJnZXQgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgVGFyZ2V0IGJ1ZmZlciBvZmZzZXRcclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICovXHJcblxyXG4vKipcclxuICogUmVhZHMgYSA2NCBiaXQgZG91YmxlIGZyb20gYSBidWZmZXIgdXNpbmcgbGl0dGxlIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LnJlYWREb3VibGVMRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgU291cmNlIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFNvdXJjZSBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICovXHJcblxyXG4vKipcclxuICogUmVhZHMgYSA2NCBiaXQgZG91YmxlIGZyb20gYSBidWZmZXIgdXNpbmcgYmlnIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LnJlYWREb3VibGVCRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgU291cmNlIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFNvdXJjZSBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICovXHJcblxyXG4vLyBGYWN0b3J5IGZ1bmN0aW9uIGZvciB0aGUgcHVycG9zZSBvZiBub2RlLWJhc2VkIHRlc3RpbmcgaW4gbW9kaWZpZWQgZ2xvYmFsIGVudmlyb25tZW50c1xyXG5mdW5jdGlvbiBmYWN0b3J5KGV4cG9ydHMpIHtcclxuXHJcbiAgICAvLyBmbG9hdDogdHlwZWQgYXJyYXlcclxuICAgIGlmICh0eXBlb2YgRmxvYXQzMkFycmF5ICE9PSBcInVuZGVmaW5lZFwiKSAoZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIHZhciBmMzIgPSBuZXcgRmxvYXQzMkFycmF5KFsgLTAgXSksXHJcbiAgICAgICAgICAgIGY4YiA9IG5ldyBVaW50OEFycmF5KGYzMi5idWZmZXIpLFxyXG4gICAgICAgICAgICBsZSAgPSBmOGJbM10gPT09IDEyODtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVGbG9hdF9mMzJfY3B5KHZhbCwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjMyWzBdID0gdmFsO1xyXG4gICAgICAgICAgICBidWZbcG9zICAgIF0gPSBmOGJbMF07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAxXSA9IGY4YlsxXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDJdID0gZjhiWzJdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgM10gPSBmOGJbM107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiB3cml0ZUZsb2F0X2YzMl9yZXYodmFsLCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmMzJbMF0gPSB2YWw7XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgICAgXSA9IGY4YlszXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDFdID0gZjhiWzJdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMl0gPSBmOGJbMV07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAzXSA9IGY4YlswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy53cml0ZUZsb2F0TEUgPSBsZSA/IHdyaXRlRmxvYXRfZjMyX2NweSA6IHdyaXRlRmxvYXRfZjMyX3JldjtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMud3JpdGVGbG9hdEJFID0gbGUgPyB3cml0ZUZsb2F0X2YzMl9yZXYgOiB3cml0ZUZsb2F0X2YzMl9jcHk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRGbG9hdF9mMzJfY3B5KGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGY4YlswXSA9IGJ1Zltwb3MgICAgXTtcclxuICAgICAgICAgICAgZjhiWzFdID0gYnVmW3BvcyArIDFdO1xyXG4gICAgICAgICAgICBmOGJbMl0gPSBidWZbcG9zICsgMl07XHJcbiAgICAgICAgICAgIGY4YlszXSA9IGJ1Zltwb3MgKyAzXTtcclxuICAgICAgICAgICAgcmV0dXJuIGYzMlswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRGbG9hdF9mMzJfcmV2KGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGY4YlszXSA9IGJ1Zltwb3MgICAgXTtcclxuICAgICAgICAgICAgZjhiWzJdID0gYnVmW3BvcyArIDFdO1xyXG4gICAgICAgICAgICBmOGJbMV0gPSBidWZbcG9zICsgMl07XHJcbiAgICAgICAgICAgIGY4YlswXSA9IGJ1Zltwb3MgKyAzXTtcclxuICAgICAgICAgICAgcmV0dXJuIGYzMlswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRmxvYXRMRSA9IGxlID8gcmVhZEZsb2F0X2YzMl9jcHkgOiByZWFkRmxvYXRfZjMyX3JldjtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMucmVhZEZsb2F0QkUgPSBsZSA/IHJlYWRGbG9hdF9mMzJfcmV2IDogcmVhZEZsb2F0X2YzMl9jcHk7XHJcblxyXG4gICAgLy8gZmxvYXQ6IGllZWU3NTRcclxuICAgIH0pKCk7IGVsc2UgKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICBmdW5jdGlvbiB3cml0ZUZsb2F0X2llZWU3NTQod3JpdGVVaW50LCB2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIHZhciBzaWduID0gdmFsIDwgMCA/IDEgOiAwO1xyXG4gICAgICAgICAgICBpZiAoc2lnbilcclxuICAgICAgICAgICAgICAgIHZhbCA9IC12YWw7XHJcbiAgICAgICAgICAgIGlmICh2YWwgPT09IDApXHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoMSAvIHZhbCA+IDAgPyAvKiBwb3NpdGl2ZSAqLyAwIDogLyogbmVnYXRpdmUgMCAqLyAyMTQ3NDgzNjQ4LCBidWYsIHBvcyk7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzTmFOKHZhbCkpXHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoMjE0MzI4OTM0NCwgYnVmLCBwb3MpO1xyXG4gICAgICAgICAgICBlbHNlIGlmICh2YWwgPiAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KSAvLyArLUluZmluaXR5XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoKHNpZ24gPDwgMzEgfCAyMTM5MDk1MDQwKSA+Pj4gMCwgYnVmLCBwb3MpO1xyXG4gICAgICAgICAgICBlbHNlIGlmICh2YWwgPCAxLjE3NTQ5NDM1MDgyMjI4NzVlLTM4KSAvLyBkZW5vcm1hbFxyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KChzaWduIDw8IDMxIHwgTWF0aC5yb3VuZCh2YWwgLyAxLjQwMTI5ODQ2NDMyNDgxN2UtNDUpKSA+Pj4gMCwgYnVmLCBwb3MpO1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBleHBvbmVudCA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsKSAvIE1hdGguTE4yKSxcclxuICAgICAgICAgICAgICAgICAgICBtYW50aXNzYSA9IE1hdGgucm91bmQodmFsICogTWF0aC5wb3coMiwgLWV4cG9uZW50KSAqIDgzODg2MDgpICYgODM4ODYwNztcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgoc2lnbiA8PCAzMSB8IGV4cG9uZW50ICsgMTI3IDw8IDIzIHwgbWFudGlzc2EpID4+PiAwLCBidWYsIHBvcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGV4cG9ydHMud3JpdGVGbG9hdExFID0gd3JpdGVGbG9hdF9pZWVlNzU0LmJpbmQobnVsbCwgd3JpdGVVaW50TEUpO1xyXG4gICAgICAgIGV4cG9ydHMud3JpdGVGbG9hdEJFID0gd3JpdGVGbG9hdF9pZWVlNzU0LmJpbmQobnVsbCwgd3JpdGVVaW50QkUpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiByZWFkRmxvYXRfaWVlZTc1NChyZWFkVWludCwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgdmFyIHVpbnQgPSByZWFkVWludChidWYsIHBvcyksXHJcbiAgICAgICAgICAgICAgICBzaWduID0gKHVpbnQgPj4gMzEpICogMiArIDEsXHJcbiAgICAgICAgICAgICAgICBleHBvbmVudCA9IHVpbnQgPj4+IDIzICYgMjU1LFxyXG4gICAgICAgICAgICAgICAgbWFudGlzc2EgPSB1aW50ICYgODM4ODYwNztcclxuICAgICAgICAgICAgcmV0dXJuIGV4cG9uZW50ID09PSAyNTVcclxuICAgICAgICAgICAgICAgID8gbWFudGlzc2FcclxuICAgICAgICAgICAgICAgID8gTmFOXHJcbiAgICAgICAgICAgICAgICA6IHNpZ24gKiBJbmZpbml0eVxyXG4gICAgICAgICAgICAgICAgOiBleHBvbmVudCA9PT0gMCAvLyBkZW5vcm1hbFxyXG4gICAgICAgICAgICAgICAgPyBzaWduICogMS40MDEyOTg0NjQzMjQ4MTdlLTQ1ICogbWFudGlzc2FcclxuICAgICAgICAgICAgICAgIDogc2lnbiAqIE1hdGgucG93KDIsIGV4cG9uZW50IC0gMTUwKSAqIChtYW50aXNzYSArIDgzODg2MDgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRmxvYXRMRSA9IHJlYWRGbG9hdF9pZWVlNzU0LmJpbmQobnVsbCwgcmVhZFVpbnRMRSk7XHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRmxvYXRCRSA9IHJlYWRGbG9hdF9pZWVlNzU0LmJpbmQobnVsbCwgcmVhZFVpbnRCRSk7XHJcblxyXG4gICAgfSkoKTtcclxuXHJcbiAgICAvLyBkb3VibGU6IHR5cGVkIGFycmF5XHJcbiAgICBpZiAodHlwZW9mIEZsb2F0NjRBcnJheSAhPT0gXCJ1bmRlZmluZWRcIikgKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICB2YXIgZjY0ID0gbmV3IEZsb2F0NjRBcnJheShbLTBdKSxcclxuICAgICAgICAgICAgZjhiID0gbmV3IFVpbnQ4QXJyYXkoZjY0LmJ1ZmZlciksXHJcbiAgICAgICAgICAgIGxlICA9IGY4Yls3XSA9PT0gMTI4O1xyXG5cclxuICAgICAgICBmdW5jdGlvbiB3cml0ZURvdWJsZV9mNjRfY3B5KHZhbCwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjY0WzBdID0gdmFsO1xyXG4gICAgICAgICAgICBidWZbcG9zICAgIF0gPSBmOGJbMF07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAxXSA9IGY4YlsxXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDJdID0gZjhiWzJdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgM10gPSBmOGJbM107XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA0XSA9IGY4Yls0XTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDVdID0gZjhiWzVdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgNl0gPSBmOGJbNl07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA3XSA9IGY4Yls3XTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlRG91YmxlX2Y2NF9yZXYodmFsLCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmNjRbMF0gPSB2YWw7XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgICAgXSA9IGY4Yls3XTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDFdID0gZjhiWzZdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMl0gPSBmOGJbNV07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAzXSA9IGY4Yls0XTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDRdID0gZjhiWzNdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgNV0gPSBmOGJbMl07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA2XSA9IGY4YlsxXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDddID0gZjhiWzBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLndyaXRlRG91YmxlTEUgPSBsZSA/IHdyaXRlRG91YmxlX2Y2NF9jcHkgOiB3cml0ZURvdWJsZV9mNjRfcmV2O1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy53cml0ZURvdWJsZUJFID0gbGUgPyB3cml0ZURvdWJsZV9mNjRfcmV2IDogd3JpdGVEb3VibGVfZjY0X2NweTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVhZERvdWJsZV9mNjRfY3B5KGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGY4YlswXSA9IGJ1Zltwb3MgICAgXTtcclxuICAgICAgICAgICAgZjhiWzFdID0gYnVmW3BvcyArIDFdO1xyXG4gICAgICAgICAgICBmOGJbMl0gPSBidWZbcG9zICsgMl07XHJcbiAgICAgICAgICAgIGY4YlszXSA9IGJ1Zltwb3MgKyAzXTtcclxuICAgICAgICAgICAgZjhiWzRdID0gYnVmW3BvcyArIDRdO1xyXG4gICAgICAgICAgICBmOGJbNV0gPSBidWZbcG9zICsgNV07XHJcbiAgICAgICAgICAgIGY4Yls2XSA9IGJ1Zltwb3MgKyA2XTtcclxuICAgICAgICAgICAgZjhiWzddID0gYnVmW3BvcyArIDddO1xyXG4gICAgICAgICAgICByZXR1cm4gZjY0WzBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVhZERvdWJsZV9mNjRfcmV2KGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGY4Yls3XSA9IGJ1Zltwb3MgICAgXTtcclxuICAgICAgICAgICAgZjhiWzZdID0gYnVmW3BvcyArIDFdO1xyXG4gICAgICAgICAgICBmOGJbNV0gPSBidWZbcG9zICsgMl07XHJcbiAgICAgICAgICAgIGY4Yls0XSA9IGJ1Zltwb3MgKyAzXTtcclxuICAgICAgICAgICAgZjhiWzNdID0gYnVmW3BvcyArIDRdO1xyXG4gICAgICAgICAgICBmOGJbMl0gPSBidWZbcG9zICsgNV07XHJcbiAgICAgICAgICAgIGY4YlsxXSA9IGJ1Zltwb3MgKyA2XTtcclxuICAgICAgICAgICAgZjhiWzBdID0gYnVmW3BvcyArIDddO1xyXG4gICAgICAgICAgICByZXR1cm4gZjY0WzBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLnJlYWREb3VibGVMRSA9IGxlID8gcmVhZERvdWJsZV9mNjRfY3B5IDogcmVhZERvdWJsZV9mNjRfcmV2O1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRG91YmxlQkUgPSBsZSA/IHJlYWREb3VibGVfZjY0X3JldiA6IHJlYWREb3VibGVfZjY0X2NweTtcclxuXHJcbiAgICAvLyBkb3VibGU6IGllZWU3NTRcclxuICAgIH0pKCk7IGVsc2UgKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICBmdW5jdGlvbiB3cml0ZURvdWJsZV9pZWVlNzU0KHdyaXRlVWludCwgb2ZmMCwgb2ZmMSwgdmFsLCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICB2YXIgc2lnbiA9IHZhbCA8IDAgPyAxIDogMDtcclxuICAgICAgICAgICAgaWYgKHNpZ24pXHJcbiAgICAgICAgICAgICAgICB2YWwgPSAtdmFsO1xyXG4gICAgICAgICAgICBpZiAodmFsID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoMCwgYnVmLCBwb3MgKyBvZmYwKTtcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgxIC8gdmFsID4gMCA/IC8qIHBvc2l0aXZlICovIDAgOiAvKiBuZWdhdGl2ZSAwICovIDIxNDc0ODM2NDgsIGJ1ZiwgcG9zICsgb2ZmMSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNOYU4odmFsKSkge1xyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KDAsIGJ1ZiwgcG9zICsgb2ZmMCk7XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoMjE0Njk1OTM2MCwgYnVmLCBwb3MgKyBvZmYxKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWwgPiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOCkgeyAvLyArLUluZmluaXR5XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoMCwgYnVmLCBwb3MgKyBvZmYwKTtcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgoc2lnbiA8PCAzMSB8IDIxNDY0MzUwNzIpID4+PiAwLCBidWYsIHBvcyArIG9mZjEpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1hbnRpc3NhO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbCA8IDIuMjI1MDczODU4NTA3MjAxNGUtMzA4KSB7IC8vIGRlbm9ybWFsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFudGlzc2EgPSB2YWwgLyA1ZS0zMjQ7XHJcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVVaW50KG1hbnRpc3NhID4+PiAwLCBidWYsIHBvcyArIG9mZjApO1xyXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlVWludCgoc2lnbiA8PCAzMSB8IG1hbnRpc3NhIC8gNDI5NDk2NzI5NikgPj4+IDAsIGJ1ZiwgcG9zICsgb2ZmMSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBleHBvbmVudCA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsKSAvIE1hdGguTE4yKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXhwb25lbnQgPT09IDEwMjQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9uZW50ID0gMTAyMztcclxuICAgICAgICAgICAgICAgICAgICBtYW50aXNzYSA9IHZhbCAqIE1hdGgucG93KDIsIC1leHBvbmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVVaW50KG1hbnRpc3NhICogNDUwMzU5OTYyNzM3MDQ5NiA+Pj4gMCwgYnVmLCBwb3MgKyBvZmYwKTtcclxuICAgICAgICAgICAgICAgICAgICB3cml0ZVVpbnQoKHNpZ24gPDwgMzEgfCBleHBvbmVudCArIDEwMjMgPDwgMjAgfCBtYW50aXNzYSAqIDEwNDg1NzYgJiAxMDQ4NTc1KSA+Pj4gMCwgYnVmLCBwb3MgKyBvZmYxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZXhwb3J0cy53cml0ZURvdWJsZUxFID0gd3JpdGVEb3VibGVfaWVlZTc1NC5iaW5kKG51bGwsIHdyaXRlVWludExFLCAwLCA0KTtcclxuICAgICAgICBleHBvcnRzLndyaXRlRG91YmxlQkUgPSB3cml0ZURvdWJsZV9pZWVlNzU0LmJpbmQobnVsbCwgd3JpdGVVaW50QkUsIDQsIDApO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiByZWFkRG91YmxlX2llZWU3NTQocmVhZFVpbnQsIG9mZjAsIG9mZjEsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIHZhciBsbyA9IHJlYWRVaW50KGJ1ZiwgcG9zICsgb2ZmMCksXHJcbiAgICAgICAgICAgICAgICBoaSA9IHJlYWRVaW50KGJ1ZiwgcG9zICsgb2ZmMSk7XHJcbiAgICAgICAgICAgIHZhciBzaWduID0gKGhpID4+IDMxKSAqIDIgKyAxLFxyXG4gICAgICAgICAgICAgICAgZXhwb25lbnQgPSBoaSA+Pj4gMjAgJiAyMDQ3LFxyXG4gICAgICAgICAgICAgICAgbWFudGlzc2EgPSA0Mjk0OTY3Mjk2ICogKGhpICYgMTA0ODU3NSkgKyBsbztcclxuICAgICAgICAgICAgcmV0dXJuIGV4cG9uZW50ID09PSAyMDQ3XHJcbiAgICAgICAgICAgICAgICA/IG1hbnRpc3NhXHJcbiAgICAgICAgICAgICAgICA/IE5hTlxyXG4gICAgICAgICAgICAgICAgOiBzaWduICogSW5maW5pdHlcclxuICAgICAgICAgICAgICAgIDogZXhwb25lbnQgPT09IDAgLy8gZGVub3JtYWxcclxuICAgICAgICAgICAgICAgID8gc2lnbiAqIDVlLTMyNCAqIG1hbnRpc3NhXHJcbiAgICAgICAgICAgICAgICA6IHNpZ24gKiBNYXRoLnBvdygyLCBleHBvbmVudCAtIDEwNzUpICogKG1hbnRpc3NhICsgNDUwMzU5OTYyNzM3MDQ5Nik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBleHBvcnRzLnJlYWREb3VibGVMRSA9IHJlYWREb3VibGVfaWVlZTc1NC5iaW5kKG51bGwsIHJlYWRVaW50TEUsIDAsIDQpO1xyXG4gICAgICAgIGV4cG9ydHMucmVhZERvdWJsZUJFID0gcmVhZERvdWJsZV9pZWVlNzU0LmJpbmQobnVsbCwgcmVhZFVpbnRCRSwgNCwgMCk7XHJcblxyXG4gICAgfSkoKTtcclxuXHJcbiAgICByZXR1cm4gZXhwb3J0cztcclxufVxyXG5cclxuLy8gdWludCBoZWxwZXJzXHJcblxyXG5mdW5jdGlvbiB3cml0ZVVpbnRMRSh2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICBidWZbcG9zICAgIF0gPSAgdmFsICAgICAgICAmIDI1NTtcclxuICAgIGJ1Zltwb3MgKyAxXSA9ICB2YWwgPj4+IDggICYgMjU1O1xyXG4gICAgYnVmW3BvcyArIDJdID0gIHZhbCA+Pj4gMTYgJiAyNTU7XHJcbiAgICBidWZbcG9zICsgM10gPSAgdmFsID4+PiAyNDtcclxufVxyXG5cclxuZnVuY3Rpb24gd3JpdGVVaW50QkUodmFsLCBidWYsIHBvcykge1xyXG4gICAgYnVmW3BvcyAgICBdID0gIHZhbCA+Pj4gMjQ7XHJcbiAgICBidWZbcG9zICsgMV0gPSAgdmFsID4+PiAxNiAmIDI1NTtcclxuICAgIGJ1Zltwb3MgKyAyXSA9ICB2YWwgPj4+IDggICYgMjU1O1xyXG4gICAgYnVmW3BvcyArIDNdID0gIHZhbCAgICAgICAgJiAyNTU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlYWRVaW50TEUoYnVmLCBwb3MpIHtcclxuICAgIHJldHVybiAoYnVmW3BvcyAgICBdXHJcbiAgICAgICAgICB8IGJ1Zltwb3MgKyAxXSA8PCA4XHJcbiAgICAgICAgICB8IGJ1Zltwb3MgKyAyXSA8PCAxNlxyXG4gICAgICAgICAgfCBidWZbcG9zICsgM10gPDwgMjQpID4+PiAwO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZWFkVWludEJFKGJ1ZiwgcG9zKSB7XHJcbiAgICByZXR1cm4gKGJ1Zltwb3MgICAgXSA8PCAyNFxyXG4gICAgICAgICAgfCBidWZbcG9zICsgMV0gPDwgMTZcclxuICAgICAgICAgIHwgYnVmW3BvcyArIDJdIDw8IDhcclxuICAgICAgICAgIHwgYnVmW3BvcyArIDNdKSA+Pj4gMDtcclxufVxyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSBpbnF1aXJlO1xyXG5cclxuLyoqXHJcbiAqIFJlcXVpcmVzIGEgbW9kdWxlIG9ubHkgaWYgYXZhaWxhYmxlLlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbW9kdWxlTmFtZSBNb2R1bGUgdG8gcmVxdWlyZVxyXG4gKiBAcmV0dXJucyB7P09iamVjdH0gUmVxdWlyZWQgbW9kdWxlIGlmIGF2YWlsYWJsZSBhbmQgbm90IGVtcHR5LCBvdGhlcndpc2UgYG51bGxgXHJcbiAqL1xyXG5mdW5jdGlvbiBpbnF1aXJlKG1vZHVsZU5hbWUpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdmFyIG1vZCA9IGV2YWwoXCJxdWlyZVwiLnJlcGxhY2UoL14vLFwicmVcIikpKG1vZHVsZU5hbWUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWV2YWxcclxuICAgICAgICBpZiAobW9kICYmIChtb2QubGVuZ3RoIHx8IE9iamVjdC5rZXlzKG1vZCkubGVuZ3RoKSlcclxuICAgICAgICAgICAgcmV0dXJuIG1vZDtcclxuICAgIH0gY2F0Y2ggKGUpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHlcclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLyoqXHJcbiAqIEEgbWluaW1hbCBVVEY4IGltcGxlbWVudGF0aW9uIGZvciBudW1iZXIgYXJyYXlzLlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAbmFtZXNwYWNlXHJcbiAqL1xyXG52YXIgdXRmOCA9IGV4cG9ydHM7XHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgVVRGOCBieXRlIGxlbmd0aCBvZiBhIHN0cmluZy5cclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBTdHJpbmdcclxuICogQHJldHVybnMge251bWJlcn0gQnl0ZSBsZW5ndGhcclxuICovXHJcbnV0ZjgubGVuZ3RoID0gZnVuY3Rpb24gdXRmOF9sZW5ndGgoc3RyaW5nKSB7XHJcbiAgICB2YXIgbGVuID0gMCxcclxuICAgICAgICBjID0gMDtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgYyA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgIGlmIChjIDwgMTI4KVxyXG4gICAgICAgICAgICBsZW4gKz0gMTtcclxuICAgICAgICBlbHNlIGlmIChjIDwgMjA0OClcclxuICAgICAgICAgICAgbGVuICs9IDI7XHJcbiAgICAgICAgZWxzZSBpZiAoKGMgJiAweEZDMDApID09PSAweEQ4MDAgJiYgKHN0cmluZy5jaGFyQ29kZUF0KGkgKyAxKSAmIDB4RkMwMCkgPT09IDB4REMwMCkge1xyXG4gICAgICAgICAgICArK2k7XHJcbiAgICAgICAgICAgIGxlbiArPSA0O1xyXG4gICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICBsZW4gKz0gMztcclxuICAgIH1cclxuICAgIHJldHVybiBsZW47XHJcbn07XHJcblxyXG4vKipcclxuICogUmVhZHMgVVRGOCBieXRlcyBhcyBhIHN0cmluZy5cclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZmZXIgU291cmNlIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgU291cmNlIHN0YXJ0XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgU291cmNlIGVuZFxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBTdHJpbmcgcmVhZFxyXG4gKi9cclxudXRmOC5yZWFkID0gZnVuY3Rpb24gdXRmOF9yZWFkKGJ1ZmZlciwgc3RhcnQsIGVuZCkge1xyXG4gICAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0O1xyXG4gICAgaWYgKGxlbiA8IDEpXHJcbiAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICB2YXIgcGFydHMgPSBudWxsLFxyXG4gICAgICAgIGNodW5rID0gW10sXHJcbiAgICAgICAgaSA9IDAsIC8vIGNoYXIgb2Zmc2V0XHJcbiAgICAgICAgdDsgICAgIC8vIHRlbXBvcmFyeVxyXG4gICAgd2hpbGUgKHN0YXJ0IDwgZW5kKSB7XHJcbiAgICAgICAgdCA9IGJ1ZmZlcltzdGFydCsrXTtcclxuICAgICAgICBpZiAodCA8IDEyOClcclxuICAgICAgICAgICAgY2h1bmtbaSsrXSA9IHQ7XHJcbiAgICAgICAgZWxzZSBpZiAodCA+IDE5MSAmJiB0IDwgMjI0KVxyXG4gICAgICAgICAgICBjaHVua1tpKytdID0gKHQgJiAzMSkgPDwgNiB8IGJ1ZmZlcltzdGFydCsrXSAmIDYzO1xyXG4gICAgICAgIGVsc2UgaWYgKHQgPiAyMzkgJiYgdCA8IDM2NSkge1xyXG4gICAgICAgICAgICB0ID0gKCh0ICYgNykgPDwgMTggfCAoYnVmZmVyW3N0YXJ0KytdICYgNjMpIDw8IDEyIHwgKGJ1ZmZlcltzdGFydCsrXSAmIDYzKSA8PCA2IHwgYnVmZmVyW3N0YXJ0KytdICYgNjMpIC0gMHgxMDAwMDtcclxuICAgICAgICAgICAgY2h1bmtbaSsrXSA9IDB4RDgwMCArICh0ID4+IDEwKTtcclxuICAgICAgICAgICAgY2h1bmtbaSsrXSA9IDB4REMwMCArICh0ICYgMTAyMyk7XHJcbiAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgIGNodW5rW2krK10gPSAodCAmIDE1KSA8PCAxMiB8IChidWZmZXJbc3RhcnQrK10gJiA2MykgPDwgNiB8IGJ1ZmZlcltzdGFydCsrXSAmIDYzO1xyXG4gICAgICAgIGlmIChpID4gODE5MSkge1xyXG4gICAgICAgICAgICAocGFydHMgfHwgKHBhcnRzID0gW10pKS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaHVuaykpO1xyXG4gICAgICAgICAgICBpID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAocGFydHMpIHtcclxuICAgICAgICBpZiAoaSlcclxuICAgICAgICAgICAgcGFydHMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2h1bmsuc2xpY2UoMCwgaSkpKTtcclxuICAgICAgICByZXR1cm4gcGFydHMuam9pbihcIlwiKTtcclxuICAgIH1cclxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2h1bmsuc2xpY2UoMCwgaSkpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhIHN0cmluZyBhcyBVVEY4IGJ5dGVzLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFNvdXJjZSBzdHJpbmdcclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZmZXIgRGVzdGluYXRpb24gYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgRGVzdGluYXRpb24gb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IEJ5dGVzIHdyaXR0ZW5cclxuICovXHJcbnV0Zjgud3JpdGUgPSBmdW5jdGlvbiB1dGY4X3dyaXRlKHN0cmluZywgYnVmZmVyLCBvZmZzZXQpIHtcclxuICAgIHZhciBzdGFydCA9IG9mZnNldCxcclxuICAgICAgICBjMSwgLy8gY2hhcmFjdGVyIDFcclxuICAgICAgICBjMjsgLy8gY2hhcmFjdGVyIDJcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgYzEgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcclxuICAgICAgICBpZiAoYzEgPCAxMjgpIHtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYzEgPCAyMDQ4KSB7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSA+PiA2ICAgICAgIHwgMTkyO1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgICAgICAgJiA2MyB8IDEyODtcclxuICAgICAgICB9IGVsc2UgaWYgKChjMSAmIDB4RkMwMCkgPT09IDB4RDgwMCAmJiAoKGMyID0gc3RyaW5nLmNoYXJDb2RlQXQoaSArIDEpKSAmIDB4RkMwMCkgPT09IDB4REMwMCkge1xyXG4gICAgICAgICAgICBjMSA9IDB4MTAwMDAgKyAoKGMxICYgMHgwM0ZGKSA8PCAxMCkgKyAoYzIgJiAweDAzRkYpO1xyXG4gICAgICAgICAgICArK2k7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSA+PiAxOCAgICAgIHwgMjQwO1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgPj4gMTIgJiA2MyB8IDEyODtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxID4+IDYgICYgNjMgfCAxMjg7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSAgICAgICAmIDYzIHwgMTI4O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSA+PiAxMiAgICAgIHwgMjI0O1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgPj4gNiAgJiA2MyB8IDEyODtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxICAgICAgICYgNjMgfCAxMjg7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9mZnNldCAtIHN0YXJ0O1xyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSBwb29sO1xyXG5cclxuLyoqXHJcbiAqIEFuIGFsbG9jYXRvciBhcyB1c2VkIGJ5IHtAbGluayB1dGlsLnBvb2x9LlxyXG4gKiBAdHlwZWRlZiBQb29sQWxsb2NhdG9yXHJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cclxuICogQHBhcmFtIHtudW1iZXJ9IHNpemUgQnVmZmVyIHNpemVcclxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IEJ1ZmZlclxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBBIHNsaWNlciBhcyB1c2VkIGJ5IHtAbGluayB1dGlsLnBvb2x9LlxyXG4gKiBAdHlwZWRlZiBQb29sU2xpY2VyXHJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cclxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFN0YXJ0IG9mZnNldFxyXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZCBvZmZzZXRcclxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IEJ1ZmZlciBzbGljZVxyXG4gKiBAdGhpcyB7VWludDhBcnJheX1cclxuICovXHJcblxyXG4vKipcclxuICogQSBnZW5lcmFsIHB1cnBvc2UgYnVmZmVyIHBvb2wuXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge1Bvb2xBbGxvY2F0b3J9IGFsbG9jIEFsbG9jYXRvclxyXG4gKiBAcGFyYW0ge1Bvb2xTbGljZXJ9IHNsaWNlIFNsaWNlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gW3NpemU9ODE5Ml0gU2xhYiBzaXplXHJcbiAqIEByZXR1cm5zIHtQb29sQWxsb2NhdG9yfSBQb29sZWQgYWxsb2NhdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBwb29sKGFsbG9jLCBzbGljZSwgc2l6ZSkge1xyXG4gICAgdmFyIFNJWkUgICA9IHNpemUgfHwgODE5MjtcclxuICAgIHZhciBNQVggICAgPSBTSVpFID4+PiAxO1xyXG4gICAgdmFyIHNsYWIgICA9IG51bGw7XHJcbiAgICB2YXIgb2Zmc2V0ID0gU0laRTtcclxuICAgIHJldHVybiBmdW5jdGlvbiBwb29sX2FsbG9jKHNpemUpIHtcclxuICAgICAgICBpZiAoc2l6ZSA8IDEgfHwgc2l6ZSA+IE1BWClcclxuICAgICAgICAgICAgcmV0dXJuIGFsbG9jKHNpemUpO1xyXG4gICAgICAgIGlmIChvZmZzZXQgKyBzaXplID4gU0laRSkge1xyXG4gICAgICAgICAgICBzbGFiID0gYWxsb2MoU0laRSk7XHJcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBidWYgPSBzbGljZS5jYWxsKHNsYWIsIG9mZnNldCwgb2Zmc2V0ICs9IHNpemUpO1xyXG4gICAgICAgIGlmIChvZmZzZXQgJiA3KSAvLyBhbGlnbiB0byAzMiBiaXRcclxuICAgICAgICAgICAgb2Zmc2V0ID0gKG9mZnNldCB8IDcpICsgMTtcclxuICAgICAgICByZXR1cm4gYnVmO1xyXG4gICAgfTtcclxufVxyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSBMb25nQml0cztcclxuXHJcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWwvbWluaW1hbFwiKTtcclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3RzIG5ldyBsb25nIGJpdHMuXHJcbiAqIEBjbGFzc2Rlc2MgSGVscGVyIGNsYXNzIGZvciB3b3JraW5nIHdpdGggdGhlIGxvdyBhbmQgaGlnaCBiaXRzIG9mIGEgNjQgYml0IHZhbHVlLlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtudW1iZXJ9IGxvIExvdyAzMiBiaXRzLCB1bnNpZ25lZFxyXG4gKiBAcGFyYW0ge251bWJlcn0gaGkgSGlnaCAzMiBiaXRzLCB1bnNpZ25lZFxyXG4gKi9cclxuZnVuY3Rpb24gTG9uZ0JpdHMobG8sIGhpKSB7XHJcblxyXG4gICAgLy8gbm90ZSB0aGF0IHRoZSBjYXN0cyBiZWxvdyBhcmUgdGhlb3JldGljYWxseSB1bm5lY2Vzc2FyeSBhcyBvZiB0b2RheSwgYnV0IG9sZGVyIHN0YXRpY2FsbHlcclxuICAgIC8vIGdlbmVyYXRlZCBjb252ZXJ0ZXIgY29kZSBtaWdodCBzdGlsbCBjYWxsIHRoZSBjdG9yIHdpdGggc2lnbmVkIDMyYml0cy4ga2VwdCBmb3IgY29tcGF0LlxyXG5cclxuICAgIC8qKlxyXG4gICAgICogTG93IGJpdHMuXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmxvID0gbG8gPj4+IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIaWdoIGJpdHMuXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmhpID0gaGkgPj4+IDA7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBaZXJvIGJpdHMuXHJcbiAqIEBtZW1iZXJvZiB1dGlsLkxvbmdCaXRzXHJcbiAqIEB0eXBlIHt1dGlsLkxvbmdCaXRzfVxyXG4gKi9cclxudmFyIHplcm8gPSBMb25nQml0cy56ZXJvID0gbmV3IExvbmdCaXRzKDAsIDApO1xyXG5cclxuemVyby50b051bWJlciA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcclxuemVyby56ekVuY29kZSA9IHplcm8uenpEZWNvZGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH07XHJcbnplcm8ubGVuZ3RoID0gZnVuY3Rpb24oKSB7IHJldHVybiAxOyB9O1xyXG5cclxuLyoqXHJcbiAqIFplcm8gaGFzaC5cclxuICogQG1lbWJlcm9mIHV0aWwuTG9uZ0JpdHNcclxuICogQHR5cGUge3N0cmluZ31cclxuICovXHJcbnZhciB6ZXJvSGFzaCA9IExvbmdCaXRzLnplcm9IYXNoID0gXCJcXDBcXDBcXDBcXDBcXDBcXDBcXDBcXDBcIjtcclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3RzIG5ldyBsb25nIGJpdHMgZnJvbSB0aGUgc3BlY2lmaWVkIG51bWJlci5cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlXHJcbiAqIEByZXR1cm5zIHt1dGlsLkxvbmdCaXRzfSBJbnN0YW5jZVxyXG4gKi9cclxuTG9uZ0JpdHMuZnJvbU51bWJlciA9IGZ1bmN0aW9uIGZyb21OdW1iZXIodmFsdWUpIHtcclxuICAgIGlmICh2YWx1ZSA9PT0gMClcclxuICAgICAgICByZXR1cm4gemVybztcclxuICAgIHZhciBzaWduID0gdmFsdWUgPCAwO1xyXG4gICAgaWYgKHNpZ24pXHJcbiAgICAgICAgdmFsdWUgPSAtdmFsdWU7XHJcbiAgICB2YXIgbG8gPSB2YWx1ZSA+Pj4gMCxcclxuICAgICAgICBoaSA9ICh2YWx1ZSAtIGxvKSAvIDQyOTQ5NjcyOTYgPj4+IDA7XHJcbiAgICBpZiAoc2lnbikge1xyXG4gICAgICAgIGhpID0gfmhpID4+PiAwO1xyXG4gICAgICAgIGxvID0gfmxvID4+PiAwO1xyXG4gICAgICAgIGlmICgrK2xvID4gNDI5NDk2NzI5NSkge1xyXG4gICAgICAgICAgICBsbyA9IDA7XHJcbiAgICAgICAgICAgIGlmICgrK2hpID4gNDI5NDk2NzI5NSlcclxuICAgICAgICAgICAgICAgIGhpID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IExvbmdCaXRzKGxvLCBoaSk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29uc3RydWN0cyBuZXcgbG9uZyBiaXRzIGZyb20gYSBudW1iZXIsIGxvbmcgb3Igc3RyaW5nLlxyXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWVcclxuICogQHJldHVybnMge3V0aWwuTG9uZ0JpdHN9IEluc3RhbmNlXHJcbiAqL1xyXG5Mb25nQml0cy5mcm9tID0gZnVuY3Rpb24gZnJvbSh2YWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIilcclxuICAgICAgICByZXR1cm4gTG9uZ0JpdHMuZnJvbU51bWJlcih2YWx1ZSk7XHJcbiAgICBpZiAodXRpbC5pc1N0cmluZyh2YWx1ZSkpIHtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xyXG4gICAgICAgIGlmICh1dGlsLkxvbmcpXHJcbiAgICAgICAgICAgIHZhbHVlID0gdXRpbC5Mb25nLmZyb21TdHJpbmcodmFsdWUpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcmV0dXJuIExvbmdCaXRzLmZyb21OdW1iZXIocGFyc2VJbnQodmFsdWUsIDEwKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsdWUubG93IHx8IHZhbHVlLmhpZ2ggPyBuZXcgTG9uZ0JpdHModmFsdWUubG93ID4+PiAwLCB2YWx1ZS5oaWdoID4+PiAwKSA6IHplcm87XHJcbn07XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhpcyBsb25nIGJpdHMgdG8gYSBwb3NzaWJseSB1bnNhZmUgSmF2YVNjcmlwdCBudW1iZXIuXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Vuc2lnbmVkPWZhbHNlXSBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBQb3NzaWJseSB1bnNhZmUgbnVtYmVyXHJcbiAqL1xyXG5Mb25nQml0cy5wcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiB0b051bWJlcih1bnNpZ25lZCkge1xyXG4gICAgaWYgKCF1bnNpZ25lZCAmJiB0aGlzLmhpID4+PiAzMSkge1xyXG4gICAgICAgIHZhciBsbyA9IH50aGlzLmxvICsgMSA+Pj4gMCxcclxuICAgICAgICAgICAgaGkgPSB+dGhpcy5oaSAgICAgPj4+IDA7XHJcbiAgICAgICAgaWYgKCFsbylcclxuICAgICAgICAgICAgaGkgPSBoaSArIDEgPj4+IDA7XHJcbiAgICAgICAgcmV0dXJuIC0obG8gKyBoaSAqIDQyOTQ5NjcyOTYpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMubG8gKyB0aGlzLmhpICogNDI5NDk2NzI5NjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGlzIGxvbmcgYml0cyB0byBhIGxvbmcuXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Vuc2lnbmVkPWZhbHNlXSBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdFxyXG4gKiBAcmV0dXJucyB7TG9uZ30gTG9uZ1xyXG4gKi9cclxuTG9uZ0JpdHMucHJvdG90eXBlLnRvTG9uZyA9IGZ1bmN0aW9uIHRvTG9uZyh1bnNpZ25lZCkge1xyXG4gICAgcmV0dXJuIHV0aWwuTG9uZ1xyXG4gICAgICAgID8gbmV3IHV0aWwuTG9uZyh0aGlzLmxvIHwgMCwgdGhpcy5oaSB8IDAsIEJvb2xlYW4odW5zaWduZWQpKVxyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgOiB7IGxvdzogdGhpcy5sbyB8IDAsIGhpZ2g6IHRoaXMuaGkgfCAwLCB1bnNpZ25lZDogQm9vbGVhbih1bnNpZ25lZCkgfTtcclxufTtcclxuXHJcbnZhciBjaGFyQ29kZUF0ID0gU3RyaW5nLnByb3RvdHlwZS5jaGFyQ29kZUF0O1xyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdHMgbmV3IGxvbmcgYml0cyBmcm9tIHRoZSBzcGVjaWZpZWQgOCBjaGFyYWN0ZXJzIGxvbmcgaGFzaC5cclxuICogQHBhcmFtIHtzdHJpbmd9IGhhc2ggSGFzaFxyXG4gKiBAcmV0dXJucyB7dXRpbC5Mb25nQml0c30gQml0c1xyXG4gKi9cclxuTG9uZ0JpdHMuZnJvbUhhc2ggPSBmdW5jdGlvbiBmcm9tSGFzaChoYXNoKSB7XHJcbiAgICBpZiAoaGFzaCA9PT0gemVyb0hhc2gpXHJcbiAgICAgICAgcmV0dXJuIHplcm87XHJcbiAgICByZXR1cm4gbmV3IExvbmdCaXRzKFxyXG4gICAgICAgICggY2hhckNvZGVBdC5jYWxsKGhhc2gsIDApXHJcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgMSkgPDwgOFxyXG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDIpIDw8IDE2XHJcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgMykgPDwgMjQpID4+PiAwXHJcbiAgICAsXHJcbiAgICAgICAgKCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgNClcclxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCA1KSA8PCA4XHJcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgNikgPDwgMTZcclxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCA3KSA8PCAyNCkgPj4+IDBcclxuICAgICk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhpcyBsb25nIGJpdHMgdG8gYSA4IGNoYXJhY3RlcnMgbG9uZyBoYXNoLlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBIYXNoXHJcbiAqL1xyXG5Mb25nQml0cy5wcm90b3R5cGUudG9IYXNoID0gZnVuY3Rpb24gdG9IYXNoKCkge1xyXG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoXHJcbiAgICAgICAgdGhpcy5sbyAgICAgICAgJiAyNTUsXHJcbiAgICAgICAgdGhpcy5sbyA+Pj4gOCAgJiAyNTUsXHJcbiAgICAgICAgdGhpcy5sbyA+Pj4gMTYgJiAyNTUsXHJcbiAgICAgICAgdGhpcy5sbyA+Pj4gMjQgICAgICAsXHJcbiAgICAgICAgdGhpcy5oaSAgICAgICAgJiAyNTUsXHJcbiAgICAgICAgdGhpcy5oaSA+Pj4gOCAgJiAyNTUsXHJcbiAgICAgICAgdGhpcy5oaSA+Pj4gMTYgJiAyNTUsXHJcbiAgICAgICAgdGhpcy5oaSA+Pj4gMjRcclxuICAgICk7XHJcbn07XHJcblxyXG4vKipcclxuICogWmlnLXphZyBlbmNvZGVzIHRoaXMgbG9uZyBiaXRzLlxyXG4gKiBAcmV0dXJucyB7dXRpbC5Mb25nQml0c30gYHRoaXNgXHJcbiAqL1xyXG5Mb25nQml0cy5wcm90b3R5cGUuenpFbmNvZGUgPSBmdW5jdGlvbiB6ekVuY29kZSgpIHtcclxuICAgIHZhciBtYXNrID0gICB0aGlzLmhpID4+IDMxO1xyXG4gICAgdGhpcy5oaSAgPSAoKHRoaXMuaGkgPDwgMSB8IHRoaXMubG8gPj4+IDMxKSBeIG1hc2spID4+PiAwO1xyXG4gICAgdGhpcy5sbyAgPSAoIHRoaXMubG8gPDwgMSAgICAgICAgICAgICAgICAgICBeIG1hc2spID4+PiAwO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogWmlnLXphZyBkZWNvZGVzIHRoaXMgbG9uZyBiaXRzLlxyXG4gKiBAcmV0dXJucyB7dXRpbC5Mb25nQml0c30gYHRoaXNgXHJcbiAqL1xyXG5Mb25nQml0cy5wcm90b3R5cGUuenpEZWNvZGUgPSBmdW5jdGlvbiB6ekRlY29kZSgpIHtcclxuICAgIHZhciBtYXNrID0gLSh0aGlzLmxvICYgMSk7XHJcbiAgICB0aGlzLmxvICA9ICgodGhpcy5sbyA+Pj4gMSB8IHRoaXMuaGkgPDwgMzEpIF4gbWFzaykgPj4+IDA7XHJcbiAgICB0aGlzLmhpICA9ICggdGhpcy5oaSA+Pj4gMSAgICAgICAgICAgICAgICAgIF4gbWFzaykgPj4+IDA7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgdGhpcyBsb25nYml0cyB3aGVuIGVuY29kZWQgYXMgYSB2YXJpbnQuXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IExlbmd0aFxyXG4gKi9cclxuTG9uZ0JpdHMucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uIGxlbmd0aCgpIHtcclxuICAgIHZhciBwYXJ0MCA9ICB0aGlzLmxvLFxyXG4gICAgICAgIHBhcnQxID0gKHRoaXMubG8gPj4+IDI4IHwgdGhpcy5oaSA8PCA0KSA+Pj4gMCxcclxuICAgICAgICBwYXJ0MiA9ICB0aGlzLmhpID4+PiAyNDtcclxuICAgIHJldHVybiBwYXJ0MiA9PT0gMFxyXG4gICAgICAgICA/IHBhcnQxID09PSAwXHJcbiAgICAgICAgICAgPyBwYXJ0MCA8IDE2Mzg0XHJcbiAgICAgICAgICAgICA/IHBhcnQwIDwgMTI4ID8gMSA6IDJcclxuICAgICAgICAgICAgIDogcGFydDAgPCAyMDk3MTUyID8gMyA6IDRcclxuICAgICAgICAgICA6IHBhcnQxIDwgMTYzODRcclxuICAgICAgICAgICAgID8gcGFydDEgPCAxMjggPyA1IDogNlxyXG4gICAgICAgICAgICAgOiBwYXJ0MSA8IDIwOTcxNTIgPyA3IDogOFxyXG4gICAgICAgICA6IHBhcnQyIDwgMTI4ID8gOSA6IDEwO1xyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXJXcml0ZXI7XHJcblxyXG4vLyBleHRlbmRzIFdyaXRlclxyXG52YXIgV3JpdGVyID0gcmVxdWlyZShcIi4vd3JpdGVyXCIpO1xyXG4oQnVmZmVyV3JpdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoV3JpdGVyLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gQnVmZmVyV3JpdGVyO1xyXG5cclxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XHJcblxyXG52YXIgQnVmZmVyID0gdXRpbC5CdWZmZXI7XHJcblxyXG4vKipcclxuICogQ29uc3RydWN0cyBhIG5ldyBidWZmZXIgd3JpdGVyIGluc3RhbmNlLlxyXG4gKiBAY2xhc3NkZXNjIFdpcmUgZm9ybWF0IHdyaXRlciB1c2luZyBub2RlIGJ1ZmZlcnMuXHJcbiAqIEBleHRlbmRzIFdyaXRlclxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIEJ1ZmZlcldyaXRlcigpIHtcclxuICAgIFdyaXRlci5jYWxsKHRoaXMpO1xyXG59XHJcblxyXG4vKipcclxuICogQWxsb2NhdGVzIGEgYnVmZmVyIG9mIHRoZSBzcGVjaWZpZWQgc2l6ZS5cclxuICogQHBhcmFtIHtudW1iZXJ9IHNpemUgQnVmZmVyIHNpemVcclxuICogQHJldHVybnMge0J1ZmZlcn0gQnVmZmVyXHJcbiAqL1xyXG5CdWZmZXJXcml0ZXIuYWxsb2MgPSBmdW5jdGlvbiBhbGxvY19idWZmZXIoc2l6ZSkge1xyXG4gICAgcmV0dXJuIChCdWZmZXJXcml0ZXIuYWxsb2MgPSB1dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmUpKHNpemUpO1xyXG59O1xyXG5cclxudmFyIHdyaXRlQnl0ZXNCdWZmZXIgPSBCdWZmZXIgJiYgQnVmZmVyLnByb3RvdHlwZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgQnVmZmVyLnByb3RvdHlwZS5zZXQubmFtZSA9PT0gXCJzZXRcIlxyXG4gICAgPyBmdW5jdGlvbiB3cml0ZUJ5dGVzQnVmZmVyX3NldCh2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgYnVmLnNldCh2YWwsIHBvcyk7IC8vIGZhc3RlciB0aGFuIGNvcHkgKHJlcXVpcmVzIG5vZGUgPj0gNCB3aGVyZSBCdWZmZXJzIGV4dGVuZCBVaW50OEFycmF5IGFuZCBzZXQgaXMgcHJvcGVybHkgaW5oZXJpdGVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbHNvIHdvcmtzIGZvciBwbGFpbiBhcnJheSB2YWx1ZXNcclxuICAgIH1cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICA6IGZ1bmN0aW9uIHdyaXRlQnl0ZXNCdWZmZXJfY29weSh2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgaWYgKHZhbC5jb3B5KSAvLyBCdWZmZXIgdmFsdWVzXHJcbiAgICAgICAgICAgIHZhbC5jb3B5KGJ1ZiwgcG9zLCAwLCB2YWwubGVuZ3RoKTtcclxuICAgICAgICBlbHNlIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsLmxlbmd0aDspIC8vIHBsYWluIGFycmF5IHZhbHVlc1xyXG4gICAgICAgICAgICBidWZbcG9zKytdID0gdmFsW2krK107XHJcbiAgICB9O1xyXG5cclxuLyoqXHJcbiAqIEBvdmVycmlkZVxyXG4gKi9cclxuQnVmZmVyV3JpdGVyLnByb3RvdHlwZS5ieXRlcyA9IGZ1bmN0aW9uIHdyaXRlX2J5dGVzX2J1ZmZlcih2YWx1ZSkge1xyXG4gICAgaWYgKHV0aWwuaXNTdHJpbmcodmFsdWUpKVxyXG4gICAgICAgIHZhbHVlID0gdXRpbC5fQnVmZmVyX2Zyb20odmFsdWUsIFwiYmFzZTY0XCIpO1xyXG4gICAgdmFyIGxlbiA9IHZhbHVlLmxlbmd0aCA+Pj4gMDtcclxuICAgIHRoaXMudWludDMyKGxlbik7XHJcbiAgICBpZiAobGVuKVxyXG4gICAgICAgIHRoaXMuX3B1c2god3JpdGVCeXRlc0J1ZmZlciwgbGVuLCB2YWx1ZSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbmZ1bmN0aW9uIHdyaXRlU3RyaW5nQnVmZmVyKHZhbCwgYnVmLCBwb3MpIHtcclxuICAgIGlmICh2YWwubGVuZ3RoIDwgNDApIC8vIHBsYWluIGpzIGlzIGZhc3RlciBmb3Igc2hvcnQgc3RyaW5ncyAocHJvYmFibHkgZHVlIHRvIHJlZHVuZGFudCBhc3NlcnRpb25zKVxyXG4gICAgICAgIHV0aWwudXRmOC53cml0ZSh2YWwsIGJ1ZiwgcG9zKTtcclxuICAgIGVsc2VcclxuICAgICAgICBidWYudXRmOFdyaXRlKHZhbCwgcG9zKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBvdmVycmlkZVxyXG4gKi9cclxuQnVmZmVyV3JpdGVyLnByb3RvdHlwZS5zdHJpbmcgPSBmdW5jdGlvbiB3cml0ZV9zdHJpbmdfYnVmZmVyKHZhbHVlKSB7XHJcbiAgICB2YXIgbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsdWUpO1xyXG4gICAgdGhpcy51aW50MzIobGVuKTtcclxuICAgIGlmIChsZW4pXHJcbiAgICAgICAgdGhpcy5fcHVzaCh3cml0ZVN0cmluZ0J1ZmZlciwgbGVuLCB2YWx1ZSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcblxyXG4vKipcclxuICogRmluaXNoZXMgdGhlIHdyaXRlIG9wZXJhdGlvbi5cclxuICogQG5hbWUgQnVmZmVyV3JpdGVyI2ZpbmlzaFxyXG4gKiBAZnVuY3Rpb25cclxuICogQHJldHVybnMge0J1ZmZlcn0gRmluaXNoZWQgYnVmZmVyXHJcbiAqL1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSBSZWFkZXI7XHJcblxyXG52YXIgdXRpbCAgICAgID0gcmVxdWlyZShcIi4vdXRpbC9taW5pbWFsXCIpO1xyXG5cclxudmFyIEJ1ZmZlclJlYWRlcjsgLy8gY3ljbGljXHJcblxyXG52YXIgTG9uZ0JpdHMgID0gdXRpbC5Mb25nQml0cyxcclxuICAgIHV0ZjggICAgICA9IHV0aWwudXRmODtcclxuXHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbmZ1bmN0aW9uIGluZGV4T3V0T2ZSYW5nZShyZWFkZXIsIHdyaXRlTGVuZ3RoKSB7XHJcbiAgICByZXR1cm4gUmFuZ2VFcnJvcihcImluZGV4IG91dCBvZiByYW5nZTogXCIgKyByZWFkZXIucG9zICsgXCIgKyBcIiArICh3cml0ZUxlbmd0aCB8fCAxKSArIFwiID4gXCIgKyByZWFkZXIubGVuKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdHMgYSBuZXcgcmVhZGVyIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgYnVmZmVyLlxyXG4gKiBAY2xhc3NkZXNjIFdpcmUgZm9ybWF0IHJlYWRlciB1c2luZyBgVWludDhBcnJheWAgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgYEFycmF5YC5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmZmVyIEJ1ZmZlciB0byByZWFkIGZyb21cclxuICovXHJcbmZ1bmN0aW9uIFJlYWRlcihidWZmZXIpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlYWQgYnVmZmVyLlxyXG4gICAgICogQHR5cGUge1VpbnQ4QXJyYXl9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuYnVmID0gYnVmZmVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVhZCBidWZmZXIgcG9zaXRpb24uXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLnBvcyA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkIGJ1ZmZlciBsZW5ndGguXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmxlbiA9IGJ1ZmZlci5sZW5ndGg7XHJcbn1cclxuXHJcbnZhciBjcmVhdGVfYXJyYXkgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gXCJ1bmRlZmluZWRcIlxyXG4gICAgPyBmdW5jdGlvbiBjcmVhdGVfdHlwZWRfYXJyYXkoYnVmZmVyKSB7XHJcbiAgICAgICAgaWYgKGJ1ZmZlciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgQXJyYXkuaXNBcnJheShidWZmZXIpKVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlYWRlcihidWZmZXIpO1xyXG4gICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBidWZmZXJcIik7XHJcbiAgICB9XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgOiBmdW5jdGlvbiBjcmVhdGVfYXJyYXkoYnVmZmVyKSB7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYnVmZmVyKSlcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWFkZXIoYnVmZmVyKTtcclxuICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgYnVmZmVyXCIpO1xyXG4gICAgfTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IHJlYWRlciB1c2luZyB0aGUgc3BlY2lmaWVkIGJ1ZmZlci5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheXxCdWZmZXJ9IGJ1ZmZlciBCdWZmZXIgdG8gcmVhZCBmcm9tXHJcbiAqIEByZXR1cm5zIHtSZWFkZXJ8QnVmZmVyUmVhZGVyfSBBIHtAbGluayBCdWZmZXJSZWFkZXJ9IGlmIGBidWZmZXJgIGlzIGEgQnVmZmVyLCBvdGhlcndpc2UgYSB7QGxpbmsgUmVhZGVyfVxyXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgYGJ1ZmZlcmAgaXMgbm90IGEgdmFsaWQgYnVmZmVyXHJcbiAqL1xyXG5SZWFkZXIuY3JlYXRlID0gdXRpbC5CdWZmZXJcclxuICAgID8gZnVuY3Rpb24gY3JlYXRlX2J1ZmZlcl9zZXR1cChidWZmZXIpIHtcclxuICAgICAgICByZXR1cm4gKFJlYWRlci5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGVfYnVmZmVyKGJ1ZmZlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdXRpbC5CdWZmZXIuaXNCdWZmZXIoYnVmZmVyKVxyXG4gICAgICAgICAgICAgICAgPyBuZXcgQnVmZmVyUmVhZGVyKGJ1ZmZlcilcclxuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgICAgICAgICA6IGNyZWF0ZV9hcnJheShidWZmZXIpO1xyXG4gICAgICAgIH0pKGJ1ZmZlcik7XHJcbiAgICB9XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgOiBjcmVhdGVfYXJyYXk7XHJcblxyXG5SZWFkZXIucHJvdG90eXBlLl9zbGljZSA9IHV0aWwuQXJyYXkucHJvdG90eXBlLnN1YmFycmF5IHx8IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHV0aWwuQXJyYXkucHJvdG90eXBlLnNsaWNlO1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIGEgdmFyaW50IGFzIGFuIHVuc2lnbmVkIDMyIGJpdCB2YWx1ZS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICovXHJcblJlYWRlci5wcm90b3R5cGUudWludDMyID0gKGZ1bmN0aW9uIHJlYWRfdWludDMyX3NldHVwKCkge1xyXG4gICAgdmFyIHZhbHVlID0gNDI5NDk2NzI5NTsgLy8gb3B0aW1pemVyIHR5cGUtaGludCwgdGVuZHMgdG8gZGVvcHQgb3RoZXJ3aXNlICg/ISlcclxuICAgIHJldHVybiBmdW5jdGlvbiByZWFkX3VpbnQzMigpIHtcclxuICAgICAgICB2YWx1ZSA9ICggICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcgICAgICAgKSA+Pj4gMDsgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCAgNykgPj4+IDA7IGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIHZhbHVlID0gKHZhbHVlIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgMTQpID4+PiAwOyBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IDIxKSA+Pj4gMDsgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgIDE1KSA8PCAyOCkgPj4+IDA7IGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIHZhbHVlO1xyXG5cclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICBpZiAoKHRoaXMucG9zICs9IDUpID4gdGhpcy5sZW4pIHtcclxuICAgICAgICAgICAgdGhpcy5wb3MgPSB0aGlzLmxlbjtcclxuICAgICAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDEwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfTtcclxufSkoKTtcclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBhIHZhcmludCBhcyBhIHNpZ25lZCAzMiBiaXQgdmFsdWUuXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICovXHJcblJlYWRlci5wcm90b3R5cGUuaW50MzIgPSBmdW5jdGlvbiByZWFkX2ludDMyKCkge1xyXG4gICAgcmV0dXJuIHRoaXMudWludDMyKCkgfCAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIGEgemlnLXphZyBlbmNvZGVkIHZhcmludCBhcyBhIHNpZ25lZCAzMiBiaXQgdmFsdWUuXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICovXHJcblJlYWRlci5wcm90b3R5cGUuc2ludDMyID0gZnVuY3Rpb24gcmVhZF9zaW50MzIoKSB7XHJcbiAgICB2YXIgdmFsdWUgPSB0aGlzLnVpbnQzMigpO1xyXG4gICAgcmV0dXJuIHZhbHVlID4+PiAxIF4gLSh2YWx1ZSAmIDEpIHwgMDtcclxufTtcclxuXHJcbi8qIGVzbGludC1kaXNhYmxlIG5vLWludmFsaWQtdGhpcyAqL1xyXG5cclxuZnVuY3Rpb24gcmVhZExvbmdWYXJpbnQoKSB7XHJcbiAgICAvLyB0ZW5kcyB0byBkZW9wdCB3aXRoIGxvY2FsIHZhcnMgZm9yIG9jdGV0IGV0Yy5cclxuICAgIHZhciBiaXRzID0gbmV3IExvbmdCaXRzKDAsIDApO1xyXG4gICAgdmFyIGkgPSAwO1xyXG4gICAgaWYgKHRoaXMubGVuIC0gdGhpcy5wb3MgPiA0KSB7IC8vIGZhc3Qgcm91dGUgKGxvKVxyXG4gICAgICAgIGZvciAoOyBpIDwgNDsgKytpKSB7XHJcbiAgICAgICAgICAgIC8vIDFzdC4uNHRoXHJcbiAgICAgICAgICAgIGJpdHMubG8gPSAoYml0cy5sbyB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IGkgKiA3KSA+Pj4gMDtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpdHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDV0aFxyXG4gICAgICAgIGJpdHMubG8gPSAoYml0cy5sbyB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IDI4KSA+Pj4gMDtcclxuICAgICAgICBiaXRzLmhpID0gKGJpdHMuaGkgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA+PiAgNCkgPj4+IDA7XHJcbiAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxyXG4gICAgICAgICAgICByZXR1cm4gYml0cztcclxuICAgICAgICBpID0gMDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZm9yICg7IGkgPCAzOyArK2kpIHtcclxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmxlbilcclxuICAgICAgICAgICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzKTtcclxuICAgICAgICAgICAgLy8gMXN0Li4zdGhcclxuICAgICAgICAgICAgYml0cy5sbyA9IChiaXRzLmxvIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgaSAqIDcpID4+PiAwO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYml0cztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gNHRoXHJcbiAgICAgICAgYml0cy5sbyA9IChiaXRzLmxvIHwgKHRoaXMuYnVmW3RoaXMucG9zKytdICYgMTI3KSA8PCBpICogNykgPj4+IDA7XHJcbiAgICAgICAgcmV0dXJuIGJpdHM7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5sZW4gLSB0aGlzLnBvcyA+IDQpIHsgLy8gZmFzdCByb3V0ZSAoaGkpXHJcbiAgICAgICAgZm9yICg7IGkgPCA1OyArK2kpIHtcclxuICAgICAgICAgICAgLy8gNnRoLi4xMHRoXHJcbiAgICAgICAgICAgIGJpdHMuaGkgPSAoYml0cy5oaSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IGkgKiA3ICsgMykgPj4+IDA7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOClcclxuICAgICAgICAgICAgICAgIHJldHVybiBiaXRzO1xyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZm9yICg7IGkgPCA1OyArK2kpIHtcclxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmxlbilcclxuICAgICAgICAgICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzKTtcclxuICAgICAgICAgICAgLy8gNnRoLi4xMHRoXHJcbiAgICAgICAgICAgIGJpdHMuaGkgPSAoYml0cy5oaSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IGkgKiA3ICsgMykgPj4+IDA7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOClcclxuICAgICAgICAgICAgICAgIHJldHVybiBiaXRzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICB0aHJvdyBFcnJvcihcImludmFsaWQgdmFyaW50IGVuY29kaW5nXCIpO1xyXG59XHJcblxyXG4vKiBlc2xpbnQtZW5hYmxlIG5vLWludmFsaWQtdGhpcyAqL1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIGEgdmFyaW50IGFzIGEgc2lnbmVkIDY0IGJpdCB2YWx1ZS5cclxuICogQG5hbWUgUmVhZGVyI2ludDY0XHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBhIHZhcmludCBhcyBhbiB1bnNpZ25lZCA2NCBiaXQgdmFsdWUuXHJcbiAqIEBuYW1lIFJlYWRlciN1aW50NjRcclxuICogQGZ1bmN0aW9uXHJcbiAqIEByZXR1cm5zIHtMb25nfSBWYWx1ZSByZWFkXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIGEgemlnLXphZyBlbmNvZGVkIHZhcmludCBhcyBhIHNpZ25lZCA2NCBiaXQgdmFsdWUuXHJcbiAqIEBuYW1lIFJlYWRlciNzaW50NjRcclxuICogQGZ1bmN0aW9uXHJcbiAqIEByZXR1cm5zIHtMb25nfSBWYWx1ZSByZWFkXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIGEgdmFyaW50IGFzIGEgYm9vbGVhbi5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFZhbHVlIHJlYWRcclxuICovXHJcblJlYWRlci5wcm90b3R5cGUuYm9vbCA9IGZ1bmN0aW9uIHJlYWRfYm9vbCgpIHtcclxuICAgIHJldHVybiB0aGlzLnVpbnQzMigpICE9PSAwO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gcmVhZEZpeGVkMzJfZW5kKGJ1ZiwgZW5kKSB7IC8vIG5vdGUgdGhhdCB0aGlzIHVzZXMgYGVuZGAsIG5vdCBgcG9zYFxyXG4gICAgcmV0dXJuIChidWZbZW5kIC0gNF1cclxuICAgICAgICAgIHwgYnVmW2VuZCAtIDNdIDw8IDhcclxuICAgICAgICAgIHwgYnVmW2VuZCAtIDJdIDw8IDE2XHJcbiAgICAgICAgICB8IGJ1ZltlbmQgLSAxXSA8PCAyNCkgPj4+IDA7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBmaXhlZCAzMiBiaXRzIGFzIGFuIHVuc2lnbmVkIDMyIGJpdCBpbnRlZ2VyLlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAqL1xyXG5SZWFkZXIucHJvdG90eXBlLmZpeGVkMzIgPSBmdW5jdGlvbiByZWFkX2ZpeGVkMzIoKSB7XHJcblxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAodGhpcy5wb3MgKyA0ID4gdGhpcy5sZW4pXHJcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDQpO1xyXG5cclxuICAgIHJldHVybiByZWFkRml4ZWQzMl9lbmQodGhpcy5idWYsIHRoaXMucG9zICs9IDQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIGZpeGVkIDMyIGJpdHMgYXMgYSBzaWduZWQgMzIgYml0IGludGVnZXIuXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICovXHJcblJlYWRlci5wcm90b3R5cGUuc2ZpeGVkMzIgPSBmdW5jdGlvbiByZWFkX3NmaXhlZDMyKCkge1xyXG5cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKHRoaXMucG9zICsgNCA+IHRoaXMubGVuKVxyXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA0KTtcclxuXHJcbiAgICByZXR1cm4gcmVhZEZpeGVkMzJfZW5kKHRoaXMuYnVmLCB0aGlzLnBvcyArPSA0KSB8IDA7XHJcbn07XHJcblxyXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1pbnZhbGlkLXRoaXMgKi9cclxuXHJcbmZ1bmN0aW9uIHJlYWRGaXhlZDY0KC8qIHRoaXM6IFJlYWRlciAqLykge1xyXG5cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKHRoaXMucG9zICsgOCA+IHRoaXMubGVuKVxyXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA4KTtcclxuXHJcbiAgICByZXR1cm4gbmV3IExvbmdCaXRzKHJlYWRGaXhlZDMyX2VuZCh0aGlzLmJ1ZiwgdGhpcy5wb3MgKz0gNCksIHJlYWRGaXhlZDMyX2VuZCh0aGlzLmJ1ZiwgdGhpcy5wb3MgKz0gNCkpO1xyXG59XHJcblxyXG4vKiBlc2xpbnQtZW5hYmxlIG5vLWludmFsaWQtdGhpcyAqL1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIGZpeGVkIDY0IGJpdHMuXHJcbiAqIEBuYW1lIFJlYWRlciNmaXhlZDY0XHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZWFkcyB6aWctemFnIGVuY29kZWQgZml4ZWQgNjQgYml0cy5cclxuICogQG5hbWUgUmVhZGVyI3NmaXhlZDY0XHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBhIGZsb2F0ICgzMiBiaXQpIGFzIGEgbnVtYmVyLlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gKi9cclxuUmVhZGVyLnByb3RvdHlwZS5mbG9hdCA9IGZ1bmN0aW9uIHJlYWRfZmxvYXQoKSB7XHJcblxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICBpZiAodGhpcy5wb3MgKyA0ID4gdGhpcy5sZW4pXHJcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDQpO1xyXG5cclxuICAgIHZhciB2YWx1ZSA9IHV0aWwuZmxvYXQucmVhZEZsb2F0TEUodGhpcy5idWYsIHRoaXMucG9zKTtcclxuICAgIHRoaXMucG9zICs9IDQ7XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVhZHMgYSBkb3VibGUgKDY0IGJpdCBmbG9hdCkgYXMgYSBudW1iZXIuXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAqL1xyXG5SZWFkZXIucHJvdG90eXBlLmRvdWJsZSA9IGZ1bmN0aW9uIHJlYWRfZG91YmxlKCkge1xyXG5cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKHRoaXMucG9zICsgOCA+IHRoaXMubGVuKVxyXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA0KTtcclxuXHJcbiAgICB2YXIgdmFsdWUgPSB1dGlsLmZsb2F0LnJlYWREb3VibGVMRSh0aGlzLmJ1ZiwgdGhpcy5wb3MpO1xyXG4gICAgdGhpcy5wb3MgKz0gODtcclxuICAgIHJldHVybiB2YWx1ZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBhIHNlcXVlbmNlIG9mIGJ5dGVzIHByZWNlZWRlZCBieSBpdHMgbGVuZ3RoIGFzIGEgdmFyaW50LlxyXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX0gVmFsdWUgcmVhZFxyXG4gKi9cclxuUmVhZGVyLnByb3RvdHlwZS5ieXRlcyA9IGZ1bmN0aW9uIHJlYWRfYnl0ZXMoKSB7XHJcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy51aW50MzIoKSxcclxuICAgICAgICBzdGFydCAgPSB0aGlzLnBvcyxcclxuICAgICAgICBlbmQgICAgPSB0aGlzLnBvcyArIGxlbmd0aDtcclxuXHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgIGlmIChlbmQgPiB0aGlzLmxlbilcclxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgbGVuZ3RoKTtcclxuXHJcbiAgICB0aGlzLnBvcyArPSBsZW5ndGg7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLmJ1ZikpIC8vIHBsYWluIGFycmF5XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmLnNsaWNlKHN0YXJ0LCBlbmQpO1xyXG4gICAgcmV0dXJuIHN0YXJ0ID09PSBlbmQgLy8gZml4IGZvciBJRSAxMC9XaW44IGFuZCBvdGhlcnMnIHN1YmFycmF5IHJldHVybmluZyBhcnJheSBvZiBzaXplIDFcclxuICAgICAgICA/IG5ldyB0aGlzLmJ1Zi5jb25zdHJ1Y3RvcigwKVxyXG4gICAgICAgIDogdGhpcy5fc2xpY2UuY2FsbCh0aGlzLmJ1Ziwgc3RhcnQsIGVuZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVhZHMgYSBzdHJpbmcgcHJlY2VlZGVkIGJ5IGl0cyBieXRlIGxlbmd0aCBhcyBhIHZhcmludC5cclxuICogQHJldHVybnMge3N0cmluZ30gVmFsdWUgcmVhZFxyXG4gKi9cclxuUmVhZGVyLnByb3RvdHlwZS5zdHJpbmcgPSBmdW5jdGlvbiByZWFkX3N0cmluZygpIHtcclxuICAgIHZhciBieXRlcyA9IHRoaXMuYnl0ZXMoKTtcclxuICAgIHJldHVybiB1dGY4LnJlYWQoYnl0ZXMsIDAsIGJ5dGVzLmxlbmd0aCk7XHJcbn07XHJcblxyXG4vKipcclxuICogU2tpcHMgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgYnl0ZXMgaWYgc3BlY2lmaWVkLCBvdGhlcndpc2Ugc2tpcHMgYSB2YXJpbnQuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBMZW5ndGggaWYga25vd24sIG90aGVyd2lzZSBhIHZhcmludCBpcyBhc3N1bWVkXHJcbiAqIEByZXR1cm5zIHtSZWFkZXJ9IGB0aGlzYFxyXG4gKi9cclxuUmVhZGVyLnByb3RvdHlwZS5za2lwID0gZnVuY3Rpb24gc2tpcChsZW5ndGgpIHtcclxuICAgIGlmICh0eXBlb2YgbGVuZ3RoID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXHJcbiAgICAgICAgaWYgKHRoaXMucG9zICsgbGVuZ3RoID4gdGhpcy5sZW4pXHJcbiAgICAgICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCBsZW5ndGgpO1xyXG4gICAgICAgIHRoaXMucG9zICs9IGxlbmd0aDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cclxuICAgICAgICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMubGVuKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMpO1xyXG4gICAgICAgIH0gd2hpbGUgKHRoaXMuYnVmW3RoaXMucG9zKytdICYgMTI4KTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFNraXBzIHRoZSBuZXh0IGVsZW1lbnQgb2YgdGhlIHNwZWNpZmllZCB3aXJlIHR5cGUuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aXJlVHlwZSBXaXJlIHR5cGUgcmVjZWl2ZWRcclxuICogQHJldHVybnMge1JlYWRlcn0gYHRoaXNgXHJcbiAqL1xyXG5SZWFkZXIucHJvdG90eXBlLnNraXBUeXBlID0gZnVuY3Rpb24od2lyZVR5cGUpIHtcclxuICAgIHN3aXRjaCAod2lyZVR5cGUpIHtcclxuICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgIHRoaXMuc2tpcCgpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgIHRoaXMuc2tpcCg4KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICB0aGlzLnNraXAodGhpcy51aW50MzIoKSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgd2hpbGUgKCh3aXJlVHlwZSA9IHRoaXMudWludDMyKCkgJiA3KSAhPT0gNCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5za2lwVHlwZSh3aXJlVHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSA1OlxyXG4gICAgICAgICAgICB0aGlzLnNraXAoNCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiaW52YWxpZCB3aXJlIHR5cGUgXCIgKyB3aXJlVHlwZSArIFwiIGF0IG9mZnNldCBcIiArIHRoaXMucG9zKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuUmVhZGVyLl9jb25maWd1cmUgPSBmdW5jdGlvbihCdWZmZXJSZWFkZXJfKSB7XHJcbiAgICBCdWZmZXJSZWFkZXIgPSBCdWZmZXJSZWFkZXJfO1xyXG5cclxuICAgIHZhciBmbiA9IHV0aWwuTG9uZyA/IFwidG9Mb25nXCIgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBcInRvTnVtYmVyXCI7XHJcbiAgICB1dGlsLm1lcmdlKFJlYWRlci5wcm90b3R5cGUsIHtcclxuXHJcbiAgICAgICAgaW50NjQ6IGZ1bmN0aW9uIHJlYWRfaW50NjQoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZWFkTG9uZ1ZhcmludC5jYWxsKHRoaXMpW2ZuXShmYWxzZSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgdWludDY0OiBmdW5jdGlvbiByZWFkX3VpbnQ2NCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlYWRMb25nVmFyaW50LmNhbGwodGhpcylbZm5dKHRydWUpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHNpbnQ2NDogZnVuY3Rpb24gcmVhZF9zaW50NjQoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZWFkTG9uZ1ZhcmludC5jYWxsKHRoaXMpLnp6RGVjb2RlKClbZm5dKGZhbHNlKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBmaXhlZDY0OiBmdW5jdGlvbiByZWFkX2ZpeGVkNjQoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZWFkRml4ZWQ2NC5jYWxsKHRoaXMpW2ZuXSh0cnVlKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBzZml4ZWQ2NDogZnVuY3Rpb24gcmVhZF9zZml4ZWQ2NCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlYWRGaXhlZDY0LmNhbGwodGhpcylbZm5dKGZhbHNlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfSk7XHJcbn07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlclJlYWRlcjtcclxuXHJcbi8vIGV4dGVuZHMgUmVhZGVyXHJcbnZhciBSZWFkZXIgPSByZXF1aXJlKFwiLi9yZWFkZXJcIik7XHJcbihCdWZmZXJSZWFkZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShSZWFkZXIucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBCdWZmZXJSZWFkZXI7XHJcblxyXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWwvbWluaW1hbFwiKTtcclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IGJ1ZmZlciByZWFkZXIgaW5zdGFuY2UuXHJcbiAqIEBjbGFzc2Rlc2MgV2lyZSBmb3JtYXQgcmVhZGVyIHVzaW5nIG5vZGUgYnVmZmVycy5cclxuICogQGV4dGVuZHMgUmVhZGVyXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIEJ1ZmZlciB0byByZWFkIGZyb21cclxuICovXHJcbmZ1bmN0aW9uIEJ1ZmZlclJlYWRlcihidWZmZXIpIHtcclxuICAgIFJlYWRlci5jYWxsKHRoaXMsIGJ1ZmZlcik7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkIGJ1ZmZlci5cclxuICAgICAqIEBuYW1lIEJ1ZmZlclJlYWRlciNidWZcclxuICAgICAqIEB0eXBlIHtCdWZmZXJ9XHJcbiAgICAgKi9cclxufVxyXG5cclxuLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cclxuaWYgKHV0aWwuQnVmZmVyKVxyXG4gICAgQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5fc2xpY2UgPSB1dGlsLkJ1ZmZlci5wcm90b3R5cGUuc2xpY2U7XHJcblxyXG4vKipcclxuICogQG92ZXJyaWRlXHJcbiAqL1xyXG5CdWZmZXJSZWFkZXIucHJvdG90eXBlLnN0cmluZyA9IGZ1bmN0aW9uIHJlYWRfc3RyaW5nX2J1ZmZlcigpIHtcclxuICAgIHZhciBsZW4gPSB0aGlzLnVpbnQzMigpOyAvLyBtb2RpZmllcyBwb3NcclxuICAgIHJldHVybiB0aGlzLmJ1Zi51dGY4U2xpY2UodGhpcy5wb3MsIHRoaXMucG9zID0gTWF0aC5taW4odGhpcy5wb3MgKyBsZW4sIHRoaXMubGVuKSk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVhZHMgYSBzZXF1ZW5jZSBvZiBieXRlcyBwcmVjZWVkZWQgYnkgaXRzIGxlbmd0aCBhcyBhIHZhcmludC5cclxuICogQG5hbWUgQnVmZmVyUmVhZGVyI2J5dGVzXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBWYWx1ZSByZWFkXHJcbiAqL1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8qKlxyXG4gKiBTdHJlYW1pbmcgUlBDIGhlbHBlcnMuXHJcbiAqIEBuYW1lc3BhY2VcclxuICovXHJcbnZhciBycGMgPSBleHBvcnRzO1xyXG5cclxuLyoqXHJcbiAqIFJQQyBpbXBsZW1lbnRhdGlvbiBwYXNzZWQgdG8ge0BsaW5rIFNlcnZpY2UjY3JlYXRlfSBwZXJmb3JtaW5nIGEgc2VydmljZSByZXF1ZXN0IG9uIG5ldHdvcmsgbGV2ZWwsIGkuZS4gYnkgdXRpbGl6aW5nIGh0dHAgcmVxdWVzdHMgb3Igd2Vic29ja2V0cy5cclxuICogQHR5cGVkZWYgUlBDSW1wbFxyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAqIEBwYXJhbSB7TWV0aG9kfHJwYy5TZXJ2aWNlTWV0aG9kPE1lc3NhZ2U8e30+LE1lc3NhZ2U8e30+Pn0gbWV0aG9kIFJlZmxlY3RlZCBvciBzdGF0aWMgbWV0aG9kIGJlaW5nIGNhbGxlZFxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHJlcXVlc3REYXRhIFJlcXVlc3QgZGF0YVxyXG4gKiBAcGFyYW0ge1JQQ0ltcGxDYWxsYmFja30gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb25cclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICogQGV4YW1wbGVcclxuICogZnVuY3Rpb24gcnBjSW1wbChtZXRob2QsIHJlcXVlc3REYXRhLCBjYWxsYmFjaykge1xyXG4gKiAgICAgaWYgKHByb3RvYnVmLnV0aWwubGNGaXJzdChtZXRob2QubmFtZSkgIT09IFwibXlNZXRob2RcIikgLy8gY29tcGF0aWJsZSB3aXRoIHN0YXRpYyBjb2RlXHJcbiAqICAgICAgICAgdGhyb3cgRXJyb3IoXCJubyBzdWNoIG1ldGhvZFwiKTtcclxuICogICAgIGFzeW5jaHJvbm91c2x5T2J0YWluQVJlc3BvbnNlKHJlcXVlc3REYXRhLCBmdW5jdGlvbihlcnIsIHJlc3BvbnNlRGF0YSkge1xyXG4gKiAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzcG9uc2VEYXRhKTtcclxuICogICAgIH0pO1xyXG4gKiB9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIE5vZGUtc3R5bGUgY2FsbGJhY2sgYXMgdXNlZCBieSB7QGxpbmsgUlBDSW1wbH0uXHJcbiAqIEB0eXBlZGVmIFJQQ0ltcGxDYWxsYmFja1xyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAqIEBwYXJhbSB7RXJyb3J8bnVsbH0gZXJyb3IgRXJyb3IsIGlmIGFueSwgb3RoZXJ3aXNlIGBudWxsYFxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl8bnVsbH0gW3Jlc3BvbnNlXSBSZXNwb25zZSBkYXRhIG9yIGBudWxsYCB0byBzaWduYWwgZW5kIG9mIHN0cmVhbSwgaWYgdGhlcmUgaGFzbid0IGJlZW4gYW4gZXJyb3JcclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICovXHJcblxyXG5ycGMuU2VydmljZSA9IHJlcXVpcmUoXCIuL3JwYy9zZXJ2aWNlXCIpO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSBTZXJ2aWNlO1xyXG5cclxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC9taW5pbWFsXCIpO1xyXG5cclxuLy8gRXh0ZW5kcyBFdmVudEVtaXR0ZXJcclxuKFNlcnZpY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh1dGlsLkV2ZW50RW1pdHRlci5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IFNlcnZpY2U7XHJcblxyXG4vKipcclxuICogQSBzZXJ2aWNlIG1ldGhvZCBjYWxsYmFjayBhcyB1c2VkIGJ5IHtAbGluayBycGMuU2VydmljZU1ldGhvZHxTZXJ2aWNlTWV0aG9kfS5cclxuICpcclxuICogRGlmZmVycyBmcm9tIHtAbGluayBSUENJbXBsQ2FsbGJhY2t9IGluIHRoYXQgaXQgaXMgYW4gYWN0dWFsIGNhbGxiYWNrIG9mIGEgc2VydmljZSBtZXRob2Qgd2hpY2ggbWF5IG5vdCByZXR1cm4gYHJlc3BvbnNlID0gbnVsbGAuXHJcbiAqIEB0eXBlZGVmIHJwYy5TZXJ2aWNlTWV0aG9kQ2FsbGJhY2tcclxuICogQHRlbXBsYXRlIFRSZXMgZXh0ZW5kcyBNZXNzYWdlPFRSZXM+XHJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cclxuICogQHBhcmFtIHtFcnJvcnxudWxsfSBlcnJvciBFcnJvciwgaWYgYW55XHJcbiAqIEBwYXJhbSB7VFJlc30gW3Jlc3BvbnNlXSBSZXNwb25zZSBtZXNzYWdlXHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEEgc2VydmljZSBtZXRob2QgcGFydCBvZiBhIHtAbGluayBycGMuU2VydmljZX0gYXMgY3JlYXRlZCBieSB7QGxpbmsgU2VydmljZS5jcmVhdGV9LlxyXG4gKiBAdHlwZWRlZiBycGMuU2VydmljZU1ldGhvZFxyXG4gKiBAdGVtcGxhdGUgVFJlcSBleHRlbmRzIE1lc3NhZ2U8VFJlcT5cclxuICogQHRlbXBsYXRlIFRSZXMgZXh0ZW5kcyBNZXNzYWdlPFRSZXM+XHJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cclxuICogQHBhcmFtIHtUUmVxfFByb3BlcnRpZXM8VFJlcT59IHJlcXVlc3QgUmVxdWVzdCBtZXNzYWdlIG9yIHBsYWluIG9iamVjdFxyXG4gKiBAcGFyYW0ge3JwYy5TZXJ2aWNlTWV0aG9kQ2FsbGJhY2s8VFJlcz59IFtjYWxsYmFja10gTm9kZS1zdHlsZSBjYWxsYmFjayBjYWxsZWQgd2l0aCB0aGUgZXJyb3IsIGlmIGFueSwgYW5kIHRoZSByZXNwb25zZSBtZXNzYWdlXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPE1lc3NhZ2U8VFJlcz4+fSBQcm9taXNlIGlmIGBjYWxsYmFja2AgaGFzIGJlZW4gb21pdHRlZCwgb3RoZXJ3aXNlIGB1bmRlZmluZWRgXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdHMgYSBuZXcgUlBDIHNlcnZpY2UgaW5zdGFuY2UuXHJcbiAqIEBjbGFzc2Rlc2MgQW4gUlBDIHNlcnZpY2UgYXMgcmV0dXJuZWQgYnkge0BsaW5rIFNlcnZpY2UjY3JlYXRlfS5cclxuICogQGV4cG9ydHMgcnBjLlNlcnZpY2VcclxuICogQGV4dGVuZHMgdXRpbC5FdmVudEVtaXR0ZXJcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7UlBDSW1wbH0gcnBjSW1wbCBSUEMgaW1wbGVtZW50YXRpb25cclxuICogQHBhcmFtIHtib29sZWFufSBbcmVxdWVzdERlbGltaXRlZD1mYWxzZV0gV2hldGhlciByZXF1ZXN0cyBhcmUgbGVuZ3RoLWRlbGltaXRlZFxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXNwb25zZURlbGltaXRlZD1mYWxzZV0gV2hldGhlciByZXNwb25zZXMgYXJlIGxlbmd0aC1kZWxpbWl0ZWRcclxuICovXHJcbmZ1bmN0aW9uIFNlcnZpY2UocnBjSW1wbCwgcmVxdWVzdERlbGltaXRlZCwgcmVzcG9uc2VEZWxpbWl0ZWQpIHtcclxuXHJcbiAgICBpZiAodHlwZW9mIHJwY0ltcGwgIT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJycGNJbXBsIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcclxuXHJcbiAgICB1dGlsLkV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUlBDIGltcGxlbWVudGF0aW9uLiBCZWNvbWVzIGBudWxsYCBvbmNlIHRoZSBzZXJ2aWNlIGlzIGVuZGVkLlxyXG4gICAgICogQHR5cGUge1JQQ0ltcGx8bnVsbH1cclxuICAgICAqL1xyXG4gICAgdGhpcy5ycGNJbXBsID0gcnBjSW1wbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgcmVxdWVzdHMgYXJlIGxlbmd0aC1kZWxpbWl0ZWQuXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5yZXF1ZXN0RGVsaW1pdGVkID0gQm9vbGVhbihyZXF1ZXN0RGVsaW1pdGVkKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgcmVzcG9uc2VzIGFyZSBsZW5ndGgtZGVsaW1pdGVkLlxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVzcG9uc2VEZWxpbWl0ZWQgPSBCb29sZWFuKHJlc3BvbnNlRGVsaW1pdGVkKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENhbGxzIGEgc2VydmljZSBtZXRob2QgdGhyb3VnaCB7QGxpbmsgcnBjLlNlcnZpY2UjcnBjSW1wbHxycGNJbXBsfS5cclxuICogQHBhcmFtIHtNZXRob2R8cnBjLlNlcnZpY2VNZXRob2Q8VFJlcSxUUmVzPn0gbWV0aG9kIFJlZmxlY3RlZCBvciBzdGF0aWMgbWV0aG9kXHJcbiAqIEBwYXJhbSB7Q29uc3RydWN0b3I8VFJlcT59IHJlcXVlc3RDdG9yIFJlcXVlc3QgY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtDb25zdHJ1Y3RvcjxUUmVzPn0gcmVzcG9uc2VDdG9yIFJlc3BvbnNlIGNvbnN0cnVjdG9yXHJcbiAqIEBwYXJhbSB7VFJlcXxQcm9wZXJ0aWVzPFRSZXE+fSByZXF1ZXN0IFJlcXVlc3QgbWVzc2FnZSBvciBwbGFpbiBvYmplY3RcclxuICogQHBhcmFtIHtycGMuU2VydmljZU1ldGhvZENhbGxiYWNrPFRSZXM+fSBjYWxsYmFjayBTZXJ2aWNlIGNhbGxiYWNrXHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqIEB0ZW1wbGF0ZSBUUmVxIGV4dGVuZHMgTWVzc2FnZTxUUmVxPlxyXG4gKiBAdGVtcGxhdGUgVFJlcyBleHRlbmRzIE1lc3NhZ2U8VFJlcz5cclxuICovXHJcblNlcnZpY2UucHJvdG90eXBlLnJwY0NhbGwgPSBmdW5jdGlvbiBycGNDYWxsKG1ldGhvZCwgcmVxdWVzdEN0b3IsIHJlc3BvbnNlQ3RvciwgcmVxdWVzdCwgY2FsbGJhY2spIHtcclxuXHJcbiAgICBpZiAoIXJlcXVlc3QpXHJcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwicmVxdWVzdCBtdXN0IGJlIHNwZWNpZmllZFwiKTtcclxuXHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICBpZiAoIWNhbGxiYWNrKVxyXG4gICAgICAgIHJldHVybiB1dGlsLmFzUHJvbWlzZShycGNDYWxsLCBzZWxmLCBtZXRob2QsIHJlcXVlc3RDdG9yLCByZXNwb25zZUN0b3IsIHJlcXVlc3QpO1xyXG5cclxuICAgIGlmICghc2VsZi5ycGNJbXBsKSB7XHJcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgY2FsbGJhY2soRXJyb3IoXCJhbHJlYWR5IGVuZGVkXCIpKTsgfSwgMCk7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiBzZWxmLnJwY0ltcGwoXHJcbiAgICAgICAgICAgIG1ldGhvZCxcclxuICAgICAgICAgICAgcmVxdWVzdEN0b3Jbc2VsZi5yZXF1ZXN0RGVsaW1pdGVkID8gXCJlbmNvZGVEZWxpbWl0ZWRcIiA6IFwiZW5jb2RlXCJdKHJlcXVlc3QpLmZpbmlzaCgpLFxyXG4gICAgICAgICAgICBmdW5jdGlvbiBycGNDYWxsYmFjayhlcnIsIHJlc3BvbnNlKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZW1pdChcImVycm9yXCIsIGVyciwgbWV0aG9kKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxmLmVuZCgvKiBlbmRlZEJ5UlBDICovIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCEocmVzcG9uc2UgaW5zdGFuY2VvZiByZXNwb25zZUN0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSByZXNwb25zZUN0b3Jbc2VsZi5yZXNwb25zZURlbGltaXRlZCA/IFwiZGVjb2RlRGVsaW1pdGVkXCIgOiBcImRlY29kZVwiXShyZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZW1pdChcImVycm9yXCIsIGVyciwgbWV0aG9kKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHNlbGYuZW1pdChcImRhdGFcIiwgcmVzcG9uc2UsIG1ldGhvZCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgcmVzcG9uc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgKTtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgIHNlbGYuZW1pdChcImVycm9yXCIsIGVyciwgbWV0aG9kKTtcclxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBjYWxsYmFjayhlcnIpOyB9LCAwKTtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEVuZHMgdGhpcyBzZXJ2aWNlIGFuZCBlbWl0cyB0aGUgYGVuZGAgZXZlbnQuXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2VuZGVkQnlSUEM9ZmFsc2VdIFdoZXRoZXIgdGhlIHNlcnZpY2UgaGFzIGJlZW4gZW5kZWQgYnkgdGhlIFJQQyBpbXBsZW1lbnRhdGlvbi5cclxuICogQHJldHVybnMge3JwYy5TZXJ2aWNlfSBgdGhpc2BcclxuICovXHJcblNlcnZpY2UucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIGVuZChlbmRlZEJ5UlBDKSB7XHJcbiAgICBpZiAodGhpcy5ycGNJbXBsKSB7XHJcbiAgICAgICAgaWYgKCFlbmRlZEJ5UlBDKSAvLyBzaWduYWwgZW5kIHRvIHJwY0ltcGxcclxuICAgICAgICAgICAgdGhpcy5ycGNJbXBsKG51bGwsIG51bGwsIG51bGwpO1xyXG4gICAgICAgIHRoaXMucnBjSW1wbCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5lbWl0KFwiZW5kXCIpLm9mZigpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5tb2R1bGUuZXhwb3J0cyA9IHt9O1xyXG5cclxuLyoqXHJcbiAqIE5hbWVkIHJvb3RzLlxyXG4gKiBUaGlzIGlzIHdoZXJlIHBianMgc3RvcmVzIGdlbmVyYXRlZCBzdHJ1Y3R1cmVzICh0aGUgb3B0aW9uIGAtciwgLS1yb290YCBzcGVjaWZpZXMgYSBuYW1lKS5cclxuICogQ2FuIGFsc28gYmUgdXNlZCBtYW51YWxseSB0byBtYWtlIHJvb3RzIGF2YWlsYWJsZSBhY2Nyb3NzIG1vZHVsZXMuXHJcbiAqIEBuYW1lIHJvb3RzXHJcbiAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxSb290Pn1cclxuICogQGV4YW1wbGVcclxuICogLy8gcGJqcyAtciBteXJvb3QgLW8gY29tcGlsZWQuanMgLi4uXHJcbiAqXHJcbiAqIC8vIGluIGFub3RoZXIgbW9kdWxlOlxyXG4gKiByZXF1aXJlKFwiLi9jb21waWxlZC5qc1wiKTtcclxuICpcclxuICogLy8gaW4gYW55IHN1YnNlcXVlbnQgbW9kdWxlOlxyXG4gKiB2YXIgcm9vdCA9IHByb3RvYnVmLnJvb3RzW1wibXlyb290XCJdO1xyXG4gKi9cclxuIiwiLyoqXHJcbiAqIFRoaXMgY2xhc3MgaXMgcmVzcG9uc2libGUgZm9yIGVucmljaGluZyBmb250IGFuZCB0aGUgYXRsYXMgYnkgbmV3IGdseXBocy4gVGhlIGdseXBoIHNvdXJjZSBpcyBhYnN0cmFjdGVkIGFuZFxyXG4gKiBzaG91bGQgYmUgc3BlY2lmaWVkIGluIGNvbmNyZXRlIGRlc2NlbmRhbnRzIGJ5IGltcGxlbWVudGluZyBfZ2V0R2x5cGhSYW5nZSgpLCBtb3JlIGxpa2VseSBpdCB3aWxsIGJlIGFuIGh0dHAgY2FsbC5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERmR2x5cGhEZWxpdmVyeU1hbmFnZXIge1xyXG4gICAgY29uc3RydWN0b3IoZm9udFJlZ2lzdHJ5LCBhdGxhcykge1xyXG4gICAgICAgIHRoaXMuX2ZvbnRSZWdpc3RyeSA9IGZvbnRSZWdpc3RyeTtcclxuICAgICAgICB0aGlzLl9hdGxhcyA9IGF0bGFzO1xyXG4gICAgICAgIHRoaXMuX3JhbmdlUmVxdWVzdHMgPSBuZXcgTWFwKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlcXVlc3RzIGdseXBocyB2aWEgcHJvdmlkZXIgYW5kIHN0b3JlcyB0aGVtLiBHbHlwaHMgYXJlIHJlcXVlc3RlZCBieSByYW5nZXMsIHRoYXQgaXMga2luZCBvZiBhbiBvcHRpbWlzYXRpb24sXHJcbiAgICAgKiBhcyBpdCBpcyBtb3JlIGxpa2VseSB0aGF0IHN1YnNlcXVlbnQgZ2x5cGggcmVxdWVzdHMgd2lsbCBiZSBpbiB0aG9zZSByYW5nZXMgdG9vLlxyXG4gICAgICovXHJcbiAgICBmZXRjaEdseXBocyhmb250SWQsIGdseXBoSWRzKSB7XHJcbiAgICAgICAgY29uc3QgcmVxdWVzdHMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgZm9yIChjb25zdCBnbHlwaElkIG9mIGdseXBoSWRzKSB7XHJcbiAgICAgICAgICAgIC8vIHRvIHNhdmUgSFRUUCByZXF1ZXN0cyBnbHlwaHMgYXJlIHJlcXVlc3RlZCBieSByYW5nZXMsIGJ1dCB0aGlzIG9wdGltaXNhdGlvbiBkb2Vzbid0IHdvcmsgd2VsbCBmb3IgYXNpYW5cclxuICAgICAgICAgICAgLy8gd3JpdGluZ3MsIHdoZXJlIGdseXBocyBhcmUgaGlnaGx5IHNjYXR0ZXJlZCAoc3VjaCByYW5nZXMgY29udGFpbnMgbm90IHNvIG1hbnkgcmVhbGx5IHVzZWQgZ2x5cGhzKS5cclxuICAgICAgICAgICAgLy8gMTAwMDAgdGhyZXNob2xkIGlzIGp1c3QgYSBtYWdpYyBudW1iZXIgdGhhdCBcIndvcmtzXCIgKHRoZXJlIGlzIG5vIHJlbGlhYmxlIG1ldGhvZCB0byBjaG9vc2UgdGhlIHN0cmF0ZWd5KVxyXG4gICAgICAgICAgICAvLyBUT0RPOiBjaGVja291dCBodHRwczovL3N0LnlhbmRleC10ZWFtLnJ1L01BUFNSRU5ERVItMjEyNyByZXNvbHV0aW9uIGFuZCB1cGRhdGUgdGhpcyBoYWNrIGFjY29yZGluZ2x5XHJcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlTGVuZ3RoID0gZ2x5cGhJZCA+IDEwMDAwID8gMSA6IDI1NjtcclxuICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBnbHlwaElkIC0gZ2x5cGhJZCAlIHJhbmdlTGVuZ3RoO1xyXG4gICAgICAgICAgICBjb25zdCBmdWxsUmFuZ2VOYW1lID0gZm9udElkICsgcmFuZ2U7XHJcbiAgICAgICAgICAgIGxldCByZXF1ZXN0ID0gdGhpcy5fcmFuZ2VSZXF1ZXN0cy5nZXQoZnVsbFJhbmdlTmFtZSk7XHJcbiAgICAgICAgICAgIGlmICghcmVxdWVzdCkge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdCA9IHRoaXMuX2dldEdseXBoUmFuZ2UoZm9udElkLCByYW5nZSwgcmFuZ2UgKyByYW5nZUxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC50aGVuKHRoaXMuX29uTmV3UmFuZ2UuYmluZCh0aGlzLCBmb250SWQpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JhbmdlUmVxdWVzdHMuc2V0KGZ1bGxSYW5nZU5hbWUsIHJlcXVlc3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlcXVlc3RzLmFkZChyZXF1ZXN0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHJlcXVlc3RzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlcyBpbmNvbWluZyBnbHlwaCByYW5nZSByZXNwb25zZS4gSXQgYWRkcyBuZXcgZ2x5cGhzIHRvIGZvbnQgYW5kIGF0bGFzLlxyXG4gICAgICovXHJcbiAgICBfb25OZXdSYW5nZShmb250SWQsIGdseXBocykge1xyXG4gICAgICAgIGZvciAoY29uc3QgZ2x5cGggb2YgZ2x5cGhzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZvbnQgPSB0aGlzLl9mb250UmVnaXN0cnkuZ2V0KGZvbnRJZCk7XHJcbiAgICAgICAgICAgIGZvbnQuYWRkR2x5cGgoZ2x5cGgpO1xyXG4gICAgICAgICAgICB0aGlzLl9hdGxhcy5hbGxvY2F0ZUdseXBoKGZvbnRJZCwgZ2x5cGgsIGZvbnQubWFyZ2luKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiY29uc3QgSE9TVF9BTElBU0VTX04gPSA0O1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0SG9zdEFsaWFzQnlVaWQodWlkKSB7XHJcbiAgICBsZXQgc3VtID0gMDtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdWlkLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgc3VtICs9IHVpZC5jaGFyQ29kZUF0KGkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIChzdW0gJSBIT1NUX0FMSUFTRVNfTiArIDEpLnRvU3RyaW5nKCk7XHJcbn1cclxuIiwiZXhwb3J0IGZ1bmN0aW9uIGdldFRpbGVJZEJ5UmF3VmFsdWVzKHgsIHksIHpvb20pIHtcclxuICAgIHJldHVybiBgJHt4fToke3l9OiR7em9vbX1gO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRUaWxlSWQodGlsZSkge1xyXG4gICAgcmV0dXJuIGdldFRpbGVJZEJ5UmF3VmFsdWVzKHRpbGUueCwgdGlsZS55LCB0aWxlLnpvb20pO1xyXG59XHJcbiIsImV4cG9ydCBjb25zdCBPUEFRVUVfQkxBQ0sgPSBjcmVhdGUoMCwgMCwgMCwgMSk7XHJcbmV4cG9ydCBjb25zdCBUUkFOU1BBUkVOVF9CTEFDSyA9IGNyZWF0ZSgwLCAwLCAwLCAwKTtcclxuLyoqXHJcbiAqIEBwYXJhbSByIFJlZCBjb21wb25lbnQgYXMgYSBub3JtYWxpemVkIHZhbHVlIFswLi4xXVxyXG4gKiBAcGFyYW0gZyBHcmVlbiBjb21wb25lbnQgYXMgYSBub3JtYWxpemVkIHZhbHVlIFswLi4xXVxyXG4gKiBAcGFyYW0gYiBCbHVlIGNvbXBvbmVudCBhcyBhIG5vcm1hbGl6ZWQgdmFsdWUgWzAuLjFdXHJcbiAqIEBwYXJhbSBhIEFscGhhIGNvbXBvbmVudCBhcyBhIG5vcm1hbGl6ZWQgdmFsdWUgWzAuLjFdXHJcbiAqXHJcbiAqIEByZXR1cm5zIEEgY29sb3Igd2l0aCBnaXZlbiB2YWx1ZXMgYXNzaWduZWQgdG8gY29tcG9uZW50cy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUociwgZywgYiwgYSA9IDEpIHtcclxuICAgIHJldHVybiB7IHIsIGcsIGIsIGEgfTtcclxufVxyXG4vKipcclxuICogQ29waWVzIGEgY29sb3IgdG8gYW5vdGhlciBvbmUuXHJcbiAqXHJcbiAqIEBwYXJhbSBzcmMgVGhlIHNvdXJjZSBjb2xvci5cclxuICogQHBhcmFtIGRzdCBUaGUgY29sb3IgdGhlIHNvdXJjZSBjb2xvciB3aWxsIGJlIGNvcGllZCB0by5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29weShzcmMsIGRzdCA9IGNyZWF0ZSgwLCAwLCAwLCAwKSkge1xyXG4gICAgZHN0LnIgPSBzcmMucjtcclxuICAgIGRzdC5nID0gc3JjLmc7XHJcbiAgICBkc3QuYiA9IHNyYy5iO1xyXG4gICAgZHN0LmEgPSBzcmMuYTtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGFyZUVxdWFsKGMxLCBjMikge1xyXG4gICAgcmV0dXJuIGMxLnIgPT09IGMyLnIgJiYgYzEuZyA9PT0gYzIuZyAmJiBjMS5iID09PSBjMi5iICYmIGMxLmEgPT09IGMyLmE7XHJcbn1cclxuLyoqXHJcbiAqIERlY29kZXMgYSBjb2xvciByZXByZXNlbnRlZCBhcyBmb3VyIDgtYml0IGNoYW5uZWxzIGVuY29kZWQgaW50byBhIDMyLWJpdFxyXG4gKiBudW1iZXIgaW4gQUJHUiBvcmRlciAoZnJvbSBNU0IgdG8gTFNCKS5cclxuICpcclxuICogQHBhcmFtIGNvbG9yIENvbG9yIGVuY29kZWQgaW50byB1bnNpZ25lZCAzMi1iaXQgaW50ZWdlci5cclxuICogQHJldHVybnMgRGVjb2RlZCBjb2xvci5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVBYmdyOChjb2xvcikge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByOiAoY29sb3IgPj4+IDI0KSAvIDB4ZmYsXHJcbiAgICAgICAgZzogKGNvbG9yID4+PiAxNiAmIDB4ZmYpIC8gMHhmZixcclxuICAgICAgICBiOiAoY29sb3IgPj4+IDggJiAweGZmKSAvIDB4ZmYsXHJcbiAgICAgICAgYTogKGNvbG9yICYgMHhmZikgLyAweGZmXHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBFbmNvZGVzIGEgY29sb3IgY29tcG9uZW50cyBpbnRvIGZvdXIgOCBiaXQgbnVtYmVycyBwYWNrZWQgaW50byAzMi1iaXQgb25lLlxyXG4gKlxyXG4gKiBAcGFyYW0gYyBUaGUgY29sb3IgdG8gYmUgZW5jb2RlZC5cclxuICogQHJldHVybnMgVGhlIGNvbG9yIGFzIDMyLWJpdCBpbnRlZ2VyLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZVJnYmE4KGMpIHtcclxuICAgIHJldHVybiAoYy5yICogMHhmZiB8XHJcbiAgICAgICAgKGMuZyAqIDB4ZmYgPDwgOCkgfFxyXG4gICAgICAgIChjLmIgKiAweGZmIDw8IDE2KSB8XHJcbiAgICAgICAgKGMuYSAqIDB4ZmYgPDwgMjQpKTtcclxufVxyXG4vKipcclxuICogQ2hlY2tzIGlmIGEgY29sb3IgaXMgY29tcGxldGVseSBvcGFxdWUuXHJcbiAqXHJcbiAqIEBwYXJhbSBjb2xvciBUaGUgY29sb3IgdG8gYmUgY2hlY2tlZC5cclxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBjb2xvciBpcyBvcGFxdWUgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzT3BhcXVlKGNvbG9yKSB7XHJcbiAgICByZXR1cm4gY29sb3IuYSA9PT0gMTtcclxufVxyXG4iLCJpbXBvcnQgVGlsZVdvcmxkQ29vcmRpbmF0ZXNDb252ZXJ0ZXIgZnJvbSAnLi90aWxlX3dvcmxkX2Nvb3JkaW5hdGVzX2NvbnZlcnRlcic7XHJcbmltcG9ydCAqIGFzIHZlY3RvcjIgZnJvbSAnLi4vLi4vLi4vLi4vbWF0aC92ZWN0b3IyJztcclxuaW1wb3J0IGV4dHJhY3RTdHlsZXMgZnJvbSAnLi9leHRyYWN0X3N0eWxlcyc7XHJcbi8qKlxyXG4gKiBVdGlsaXR5IG1ldGhvZCBmb3IgZ2V0dGluZyBwb2ludCBzcGVjaWZpYyBzdHlsZSBkZXRhaWxzIGZyb20gYSB6b29tIHNsaWNlLlxyXG4gKiBUbyBiZSB1c2VkIGFzIGEgem9vbSBzbGljZSBzdHlsZSBjb252ZXJ0ZXIgZm9yIHN0eWxlIGV4dHJhY3Rvci5cclxuICovXHJcbmZ1bmN0aW9uIGNvbnZlcnRab29tU2xpY2VUb1N0eWxlKHNsaWNlLCBzdHlsZUJhc2UpIHtcclxuICAgIGNvbnN0IHN0eWxlID0gc2xpY2UucG9pbnQ7XHJcbiAgICByZXR1cm4gc3R5bGUgJiYgc3R5bGUuaWNvbiA/IE9iamVjdC5hc3NpZ24oe30sIHN0eWxlQmFzZSwgeyBpbWFnZUlkOiBzdHlsZS5pY29uLmlkLCBcclxuICAgICAgICAvLyBPZmZzZXRzIGFyZSBzcGVjaWZpZWQgaW4gdGhlIGNvb3JkaW5hdGUgc3lzdGVtIHdpdGggdG9wLXRvLWJvdHRvbSBZIGF4ZSwgc28gYDEgLSBzdHlsZS5hbmNob3JZYCBpbnN0ZWFkXHJcbiAgICAgICAgLy8gb2YgYHN0eWxlLmFuY2hvcllgIGlzIHVzZWQuXHJcbiAgICAgICAgb2Zmc2V0OiB2ZWN0b3IyLmNyZWF0ZSgtc3R5bGUuYW5jaG9yWCAqIHN0eWxlLmljb24ud2lkdGgsIChzdHlsZS5hbmNob3JZIC0gMSkgKiBzdHlsZS5pY29uLndpZHRoKSwgd2lkdGg6IHN0eWxlLmljb24ud2lkdGggfSkgOlxyXG4gICAgICAgIHVuZGVmaW5lZDtcclxufVxyXG4vKipcclxuICogVXRpbGl0eSBtZXRob2QgZm9yIGdldHRpbmcgcG9pbnRzIGZyb20gQVBJIHRpbGUgcmVzcG9uc2UuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiogZXh0cmFjdFBvaW50cyh0aWxlLCBkZWNvZGVkQXBpVGlsZSwgdGlsZU1pblpvb20sIHRpbGVNYXhab29tKSB7XHJcbiAgICBjb25zdCBwb2ludHMgPSBkZWNvZGVkQXBpVGlsZS5wb2ludHM7XHJcbiAgICBpZiAocG9pbnRzKSB7XHJcbiAgICAgICAgY29uc3QgY29udmVydGVyID0gbmV3IFRpbGVXb3JsZENvb3JkaW5hdGVzQ29udmVydGVyKHRpbGUpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzLmNsYXNzSWQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgeWllbGQge1xyXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IGNvbnZlcnRlci50b1dvcmxkQ29vcmRpbmF0ZXMocG9pbnRzLmNvb3Jkc3hbaV0sIHBvaW50cy5jb29yZHN5W2ldKSxcclxuICAgICAgICAgICAgICAgIHN0eWxlczogW1xyXG4gICAgICAgICAgICAgICAgICAgIC4uLmV4dHJhY3RTdHlsZXMoZGVjb2RlZEFwaVRpbGUucHJlc2VudGF0aW9uLCBwb2ludHMuY2xhc3NJZFtpXSwgY29udmVydFpvb21TbGljZVRvU3R5bGUsIHRpbGVNaW5ab29tLCB0aWxlTWF4Wm9vbSlcclxuICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IFRpbGVDb29yZGluYXRlU3lzdGVtIGZyb20gJy4uLy4uLy4uL3RpbGVfYmFzZWRfYWRhcHRlci91dGlsL3RpbGVfc3lzdGVtJztcclxuaW1wb3J0ICogYXMgdmVjdG9yMiBmcm9tICcuLi8uLi8uLi8uLi9tYXRoL3ZlY3RvcjInO1xyXG5pbXBvcnQgeyBjbGFtcCB9IGZyb20gJy4uLy4uLy4uLy4uL21hdGgvc2NhbGFyJztcclxuLy8gVGlsZXMgZnJvbSBBUEkgY29vcmRpbmF0ZXMgYXJlIGRlZmluZWQgaW4gWy0weDQwMDA7IDB4M0ZGRl0gcmFuZ2UuIFNlZSB0aWxlLnByb3RvIGZvciBkZXRhaWxzLlxyXG5jb25zdCBUSUxFX01JTl9DT09SRElOQVRFID0gLTB4NDAwMDtcclxuY29uc3QgVElMRV9NQVhfQ09PUkRJTkFURSA9IDB4M0ZGRjtcclxuLyoqXHJcbiAqIENoZWNrIGlmIHBvaW50IHdpdGggc3BlY2lmaWVkIGNvb3JkaW5hdGVzIGxheXMgb24gYW4gZWRnZSBvZiBhIHRpbGUuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNUaWxlRWRnZUNvb3JkaW5hdGVzKHRpbGVYQ29vcmRpbmF0ZSwgdGlsZVlDb29yZGluYXRlKSB7XHJcbiAgICByZXR1cm4gKHRpbGVYQ29vcmRpbmF0ZSA9PT0gVElMRV9NSU5fQ09PUkRJTkFURSB8fFxyXG4gICAgICAgIHRpbGVYQ29vcmRpbmF0ZSA9PT0gVElMRV9NQVhfQ09PUkRJTkFURSB8fFxyXG4gICAgICAgIHRpbGVZQ29vcmRpbmF0ZSA9PT0gVElMRV9NSU5fQ09PUkRJTkFURSB8fFxyXG4gICAgICAgIHRpbGVZQ29vcmRpbmF0ZSA9PT0gVElMRV9NQVhfQ09PUkRJTkFURSk7XHJcbn1cclxuLyoqXHJcbiAqIENvb3JkaW5hdGVzIGNvbnZlcnRlciwgZnJvbSB0aWxlIHVuaXRzICh0YWtpbmcgaW50byBhY2NvdW50IHRpbGUgcG9zaXRpb24pIHRvIHdvcmxkIHVuaXRzLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGlsZVdvcmxkQ29vcmRpbmF0ZXNDb252ZXJ0ZXIge1xyXG4gICAgY29uc3RydWN0b3IodGlsZSkge1xyXG4gICAgICAgIGNvbnN0IHdvcmxkVGlsZVN5c3RlbSA9IG5ldyBUaWxlQ29vcmRpbmF0ZVN5c3RlbSh0aWxlLnpvb20pO1xyXG4gICAgICAgIGNvbnN0IHRpbGVPZmZzZXQgPSB3b3JsZFRpbGVTeXN0ZW0uZ2V0VGlsZU9mZnNldCh0aWxlKTtcclxuICAgICAgICBjb25zdCB0aWxlU2l6ZSA9IHdvcmxkVGlsZVN5c3RlbS5nZXRUaWxlU2l6ZSgpO1xyXG4gICAgICAgIGNvbnN0IHRpbGVDZW50ZXJPZmZzZXQgPSB0aWxlU2l6ZSAvIDI7XHJcbiAgICAgICAgdGhpcy5fdGlsZUNlbnRlciA9IHZlY3RvcjIuY3JlYXRlKHRpbGVPZmZzZXQueCArIHRpbGVDZW50ZXJPZmZzZXQsIHRpbGVPZmZzZXQueSAtIHRpbGVDZW50ZXJPZmZzZXQpO1xyXG4gICAgICAgIHRoaXMuX3RpbGVXb3JsZFJhdGlvID0gdGlsZVNpemUgLyAoVElMRV9NQVhfQ09PUkRJTkFURSAtIFRJTEVfTUlOX0NPT1JESU5BVEUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIFdvcmxkJ3MgeCBjb29yZGluYXRlIHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIHRpbGUncyBvbmUuXHJcbiAgICAgKi9cclxuICAgIHRvV29ybGRYQ29vcmRpbmF0ZSh0aWxlWENvb3JkaW5hdGUpIHtcclxuICAgICAgICByZXR1cm4gY2xhbXAodGhpcy5fdGlsZUNlbnRlci54ICsgdGlsZVhDb29yZGluYXRlICogdGhpcy5fdGlsZVdvcmxkUmF0aW8sIC0xLCAxKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiBXb3JsZCdzIHkgY29vcmRpbmF0ZSB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZSB0aWxlJ3Mgb25lLlxyXG4gICAgICovXHJcbiAgICB0b1dvcmxkWUNvb3JkaW5hdGUodGlsZVlDb29yZGluYXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIGNsYW1wKHRoaXMuX3RpbGVDZW50ZXIueSAtIHRpbGVZQ29vcmRpbmF0ZSAqIHRoaXMuX3RpbGVXb3JsZFJhdGlvLCAtMSwgMSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gV29ybGQncyB6IGNvb3JkaW5hdGUgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgdGlsZSdzIG9uZS5cclxuICAgICAqL1xyXG4gICAgdG9Xb3JsZFpDb29yZGluYXRlKHRpbGVaQ29vcmRpbmF0ZSkge1xyXG4gICAgICAgIHJldHVybiB0aWxlWkNvb3JkaW5hdGUgKiB0aGlzLl90aWxlV29ybGRSYXRpbztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiBXb3JsZCdzIGNvb3JkaW5hdGVzIHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIHRpbGUncyBvbmVzLlxyXG4gICAgICovXHJcbiAgICB0b1dvcmxkQ29vcmRpbmF0ZXModGlsZVhDb29yZGluYXRlLCB0aWxlWUNvb3JkaW5hdGUpIHtcclxuICAgICAgICByZXR1cm4gdmVjdG9yMi5jcmVhdGUodGhpcy50b1dvcmxkWENvb3JkaW5hdGUodGlsZVhDb29yZGluYXRlKSwgdGhpcy50b1dvcmxkWUNvb3JkaW5hdGUodGlsZVlDb29yZGluYXRlKSk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgY2xhbXAgfSBmcm9tICcuLi8uLi8uLi9tYXRoL3NjYWxhcic7XHJcbi8qKlxyXG4gKiBAcmV0dXJuIGB0cnVlYCBpZiB0aGUgZmlyc3QgcGFyYW0gb3ZlcmxhcHMgdGhlIHNlY29uZCBpbiB0aWxlIGhpZXJhcmNoeS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1BhcmVudChwb3RlbnRpYWxQYXJlbnQsIHBvc3NpYmxlQ2hpbGQpIHtcclxuICAgIGNvbnN0IHpvb21EaWZmID0gcG9zc2libGVDaGlsZC56b29tIC0gcG90ZW50aWFsUGFyZW50Lnpvb207XHJcbiAgICByZXR1cm4gem9vbURpZmYgPiAwICYmXHJcbiAgICAgICAgcG9zc2libGVDaGlsZC54ID4+IHpvb21EaWZmID09PSBwb3RlbnRpYWxQYXJlbnQueCAmJlxyXG4gICAgICAgIHBvc3NpYmxlQ2hpbGQueSA+PiB6b29tRGlmZiA9PT0gcG90ZW50aWFsUGFyZW50Lnk7XHJcbn1cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGlsZUNvb3JkaW5hdGVTeXN0ZW0ge1xyXG4gICAgY29uc3RydWN0b3Ioem9vbSkge1xyXG4gICAgICAgIHRoaXMuX3pvb20gPSBNYXRoLmNlaWwoY2xhbXAoem9vbSwgMCwgMzEpKTtcclxuICAgICAgICB0aGlzLl90aWxlU2l6ZSA9IDIgLyAoMSA8PCB0aGlzLl96b29tKTtcclxuICAgIH1cclxuICAgIGdldFpvb20oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3pvb207XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gVGlsZSBzaWRlIGxlbmd0aCBpbiB1bml0cyBvZiB0aGUgd29ybGQgY29vcmRpbmF0ZSBzeXN0ZW0uXHJcbiAgICAgKi9cclxuICAgIGdldFRpbGVTaXplKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90aWxlU2l6ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiBUb3AgbGVmdCBjb3JuZXIgY29vcmRpbmF0ZXMgb2YgdGhlIHRpbGUuXHJcbiAgICAgKi9cclxuICAgIGdldFRpbGVPZmZzZXQodGlsZSkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHg6IHRoaXMuZ2V0VGlsZVNpemUoKSAqIHRpbGUueCAtIDEsXHJcbiAgICAgICAgICAgIHk6IDEgLSB0aGlzLmdldFRpbGVTaXplKCkgKiB0aWxlLnlcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgdG9UaWxlQ29vcmRpbmF0ZXMod29ybGRDb29yZGluYXRlcykge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHg6ICh3b3JsZENvb3JkaW5hdGVzLnggKyAxKSAvIHRoaXMuX3RpbGVTaXplLFxyXG4gICAgICAgICAgICB5OiAoMSAtIHdvcmxkQ29vcmRpbmF0ZXMueSkgLyB0aGlzLl90aWxlU2l6ZVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuIiwiLyoqXHJcbiAqIENsYW1wcyBhIHZhbHVlIHRvIGEgZ2l2ZW4gcmFuZ2UuXHJcbiAqXHJcbiAqIEBwYXJhbSB4IFRoZSB2YWx1ZS5cclxuICogQHBhcmFtIG1pbiBTdGFydCBvZiB0aGUgcmFuZ2UuXHJcbiAqIEBwYXJhbSBtYXggRW5kIG9mIHRoZSByYW5nZS5cclxuICogQHJldHVybnMgQ2xhbXBlZCB2YWx1ZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjbGFtcCh4LCBtaW4sIG1heCkge1xyXG4gICAgcmV0dXJuIG1pbiA8IHggPyB4IDwgbWF4ID8geCA6IG1heCA6IG1pbjtcclxufVxyXG4vKipcclxuICogUmVzdHJpY3RzIGEgdmFsdWUgdG8gYSBnaXZlbiBjeWNsZWQgcmFuZ2UsIGkuZS4gZW5kcyBvZiB0aGUgcmFuZ2UgYXJlXHJcbiAqIGVxdWl2YWxlbnQuIEUuZy4gbGlrZSBhbmdsZXMgY2FuIGJlIHJlc3RyaWN0ZWQgdG8gYW55IHJhbmdlIG9mIHNpemUgYDIgKiBQSWAuXHJcbiAqXHJcbiAqIEBwYXJhbSB4IFRoZSB2YWx1ZS5cclxuICogQHBhcmFtIG1pbiBTdGFydCBvZiB0aGUgcmFuZ2UuXHJcbiAqIEBwYXJhbSBtYXggRW5kIG9mIHRoZSByYW5nZS5cclxuICogQHJldHVybnMgUmVzdHJpY3RlZCB2YWx1ZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjeWNsZVJlc3RyaWN0KHgsIG1pbiwgbWF4KSB7XHJcbiAgICBjb25zdCBkID0gbWF4IC0gbWluO1xyXG4gICAgY29uc3QgcyA9ICh4IC0gbWluKSAvIChtYXggLSBtaW4pO1xyXG4gICAgcmV0dXJuIG1pbiArIGQgKiAocyAtIE1hdGguZmxvb3IocykpO1xyXG59XHJcbi8qKlxyXG4gKiBMaW5lYXIgaW50ZXJwb2xhdGlvbi5cclxuICpcclxuICogQHBhcmFtIG1pbiBWYWx1ZSB0aGF0IGNvcnJlc3BvbmQgdG8gMCUgcHJvZ3Jlc3MuXHJcbiAqIEBwYXJhbSBtYXggVmFsdWUgdGhhdCBjb3JyZXNwb25kIHRvIDEwMCUgcHJvZ3Jlc3MuXHJcbiAqIEBwYXJhbSBwcm9ncmVzcyBJbiAwLi4xLjAgcmFuZ2UgdGhhdCBtYXBzIHRvIDAuLjEwMCUgcHJvZ3Jlc3MuIEl0IGlzIGFsbG93ZWQgdG8gcGFzcyBhIHZhbHVlXHJcbiAqICAgICAgb3V0c2lkZSBvZiB0aGlzIHJhbmdlLCB0aGF0IG1lYW5zIHByb2dyZXNzIGdyZWF0ZXIgdGhlbiAxMDAlIG9yIG5lZ2F0aXZlIHByb2dyZXNzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG1peChtaW4sIG1heCwgcHJvZ3Jlc3MpIHtcclxuICAgIHJldHVybiAoMSAtIHByb2dyZXNzKSAqIG1pbiArIHByb2dyZXNzICogbWF4O1xyXG59XHJcbi8qKlxyXG4gKiBBIHN0ZXAgZnVuY3Rpb24gd2l0aCBhIHNtb290aCB0cmFuc2l0aW9uIGJldHdlZW4gZ2l2ZW4gZWRnZXMuIENvbXBsZXRlbHlcclxuICogYW5hbG9nb3VzIHRvIGBzbW9vdGhzdGVwYCBpbiBHTFNMIChHTFNMIEVTIDEuMCDCpzguMykuXHJcbiAqXHJcbiAqIEBwYXJhbSBlZGdlMSBUaGUgc21hbGxlciBlZGdlLlxyXG4gKiBAcGFyYW0gZWRnZTJcclxuICogQHBhcmFtIHggYDBgIGlmIGB4IDwgZWRnZTFgLCBgMWAgaWYgYHggPiBlZGdlMmAgYW5kIGFuIGludGVycG9sYXRlZCB2YWx1ZSBmb3JcclxuICogICAgICBgZWRnZTEgPCB4IDwgZWRnZTJgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNtb290aFN0ZXAoZWRnZTEsIGVkZ2UyLCB4KSB7XHJcbiAgICBjb25zdCBmYWN0b3IgPSBjbGFtcCgoeCAtIGVkZ2UxKSAvIChlZGdlMiAtIGVkZ2UxKSwgMCwgMSk7XHJcbiAgICByZXR1cm4gZmFjdG9yICogZmFjdG9yICogKDMgLSAyICogZmFjdG9yKTtcclxufVxyXG4iLCJpbXBvcnQgYXJlRnV6enlFcXVhbFNjYWxhciwgeyBERUZBVUxUX1RPTEVSQU5DRSB9IGZyb20gJy4uL3V0aWwvZnV6enlfZXF1YWwnO1xyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyB2ZWN0b3IgYW5kIGluaXRpYWxpemVzIGl0IHdpdGggZ2l2ZW4gY29tcG9uZW50cy5cclxuICpcclxuICogQHBhcmFtIHggWCBjb21wb25lbnQgb2YgdGhlIHZlY3Rvci5cclxuICogQHBhcmFtIHkgWSBjb21wb25lbnQgb2YgdGhlIHZlY3Rvci5cclxuICogQHJldHVybnMgVGhlIHZlY3Rvci5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoeCwgeSkge1xyXG4gICAgcmV0dXJuIHsgeCwgeSB9O1xyXG59XHJcbmV4cG9ydCBjb25zdCBaRVJPID0gY3JlYXRlKDAsIDApO1xyXG5leHBvcnQgY29uc3QgT1JJR0lOID0gWkVSTztcclxuZXhwb3J0IGNvbnN0IFBPU0lUSVZFX1ggPSBjcmVhdGUoMSwgMCk7XHJcbmV4cG9ydCBjb25zdCBORUdBVElWRV9YID0gY3JlYXRlKC0xLCAwKTtcclxuZXhwb3J0IGNvbnN0IFBPU0lUSVZFX1kgPSBjcmVhdGUoMCwgMSk7XHJcbmV4cG9ydCBjb25zdCBORUdBVElWRV9ZID0gY3JlYXRlKDAsIC0xKTtcclxuLyoqXHJcbiAqIENvcGllcyBhIHZlY3RvciB0byBhbm90aGVyIG9uZS5cclxuICpcclxuICogQHBhcmFtIHNyYyBUaGUgc291cmNlIHZlY3Rvci5cclxuICogQHBhcmFtIGRzdCBUaGUgdmVjdG9yIHRoZSBzb3VyY2UgdmVjdG9yIHdpbGwgYmUgY29waWVkIHRvLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb3B5KHNyYywgZHN0ID0gY3JlYXRlKDAsIDApKSB7XHJcbiAgICBkc3QueCA9IHNyYy54O1xyXG4gICAgZHN0LnkgPSBzcmMueTtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIENoZWNrcyBpZiB0d28gdmVjdG9ycyBhcmUgc3RyaWN0bHkgZXF1YWwgY29tcG9uZW50LXdpc2UuXHJcbiAqXHJcbiAqIEBwYXJhbSB2MSBUaGUgZmlyc3QgdmVjdG9yLlxyXG4gKiBAcGFyYW0gdjIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGFyZUVxdWFsKHYxLCB2Mikge1xyXG4gICAgcmV0dXJuIHYxLnggPT09IHYyLnggJiYgdjEueSA9PT0gdjIueTtcclxufVxyXG4vKipcclxuICogQ2hlY2tzIGlmIHR3byB2ZWN0b3JzIGFyZSBjb2xsaW5lYXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB2MSBUaGUgZmlyc3QgdmVjdG9yLlxyXG4gKiBAcGFyYW0gdjIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmVjdG9ycyBhcmUgY29sbGluZWFyIGFuZCBgZmFsc2VgIG90aGVyd2lzZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBhcmVDb2xsaW5lYXIodjEsIHYyKSB7XHJcbiAgICByZXR1cm4gdjEueCAvIHYyLnggPT09IHYxLnkgLyB2Mi55O1xyXG59XHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgY29ycmVzcG9uZGluZyBjb21wb25lbnRzIG9mIHR3byB2ZWN0b3JzIGFyZSBhbGwgd2l0aGluIGdpdmVuXHJcbiAqIHRvbGVyYW5jZSBmcm9tIGVhY2ggb3RoZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB2MSBUaGUgZmlyc3QgdmVjdG9yLlxyXG4gKiBAcGFyYW0gdjIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSB0b2xlcmFuY2UgVGhlIHRvbGVyYW5jZS5cclxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB2ZWN0b3JzIGFyZSBcImZ1enp5XCIgZXF1YWwgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGFyZUZ1enp5RXF1YWwodjEsIHYyLCB0b2xlcmFuY2UgPSBERUZBVUxUX1RPTEVSQU5DRSkge1xyXG4gICAgcmV0dXJuIChhcmVGdXp6eUVxdWFsU2NhbGFyKHYxLngsIHYyLngsIHRvbGVyYW5jZSkgJiZcclxuICAgICAgICBhcmVGdXp6eUVxdWFsU2NhbGFyKHYxLnksIHYyLnksIHRvbGVyYW5jZSkpO1xyXG59XHJcbi8qKlxyXG4gKiBBZGRzIHR3byB2ZWN0b3IgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGludG8gYSB0aGlyZCBvbmUsIGkuZS4gYGRzdCA9IGEgKyBiYC5cclxuICpcclxuICogQHBhcmFtIGEgVGhlIGZpcnN0IHZlY3Rvci5cclxuICogQHBhcmFtIGIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBkc3QgVGhlIHZlY3RvciB0aGUgcmVzdWx0IHdpbGwgYmUgc3RvcmVkIHRvLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBhZGQoYSwgYiwgZHN0ID0gY3JlYXRlKDAsIDApKSB7XHJcbiAgICBkc3QueCA9IGEueCArIGIueDtcclxuICAgIGRzdC55ID0gYS55ICsgYi55O1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogU3VidHJhY3RzIGEgdmVjdG9yIGZyb20gYW5vdGhlciBvbmUgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IHRvIGEgdGhpcmQgb25lLCBpLmUuXHJcbiAqIGBkc3QgPSBhIC0gYmAuXHJcbiAqXHJcbiAqIEBwYXJhbSBhIFRoZSBtaW51ZW5kIHZlY3Rvci5cclxuICogQHBhcmFtIGIgVGhlIHN1YnRyYWhlbmQgdmVjdG9yLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSB2ZWN0b3IgdGhlIHJlc3VsdCB3aWxsIGJlIHN0b3JlZCB0by5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc3ViKGEsIGIsIGRzdCA9IGNyZWF0ZSgwLCAwKSkge1xyXG4gICAgZHN0LnggPSBhLnggLSBiLng7XHJcbiAgICBkc3QueSA9IGEueSAtIGIueTtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIE11bHRpcGxpZXMgdHdvIHZlY3RvcnMgY29tcG9uZW50LXdpc2UgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGludG8gYSB0aGlyZCBvbmUuXHJcbiAqXHJcbiAqIEBwYXJhbSBhIFRoZSBmaXJzdCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSB2ZWN0b3IgdGhlIHJlc3VsdCB3aWxsIGJlIHN0b3JlZCB0by5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbXVsdihhLCBiLCBkc3QgPSBjcmVhdGUoMCwgMCkpIHtcclxuICAgIGRzdC54ID0gYS54ICogYi54O1xyXG4gICAgZHN0LnkgPSBhLnkgKiBiLnk7XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbi8qKlxyXG4gKiBNdWx0aXBsaWVzIGEgdmVjdG9yIGJ5IGEgc2NhbGFyIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbnRvIGEgdGhpcmQgdmVjdG9yLlxyXG4gKlxyXG4gKiBAcGFyYW0gYSBUaGUgdmVjdG9yLlxyXG4gKiBAcGFyYW0gbiBUaGUgc2NhbGFyLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSB2ZWN0b3IgdGhlIHJlc3VsdCB3aWxsIGJlIHN0b3JlZCB0by5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbXVsbihhLCBuLCBkc3QgPSBjcmVhdGUoMCwgMCkpIHtcclxuICAgIGRzdC54ID0gYS54ICogbjtcclxuICAgIGRzdC55ID0gYS55ICogbjtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIERpdmlkZXMgYSB2ZWN0b3IgYnkgYW5vdGhlciBvbmUgY29tcG9uZW50IHdpc2UgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGludG8gYVxyXG4gKiB0aGlyZCBvbmUuXHJcbiAqXHJcbiAqIEBwYXJhbSBhIFRoZSBkaXZpZGVuZCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBiIFRoZSBkaXZpc29yIHZlY3Rvci5cclxuICogQHBhcmFtIGRzdCBUaGUgdmVjdG9yIHRoZSByZXN1bHQgd2lsbCBiZSBzdG9yZWQgdG8uXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRpdnYoYSwgYiwgZHN0ID0gY3JlYXRlKDAsIDApKSB7XHJcbiAgICBkc3QueCA9IGEueCAvIGIueDtcclxuICAgIGRzdC55ID0gYS55IC8gYi55O1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogRGl2aWRlcyBhIHZlY3RvciBieSBhIHNjYWxhciBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW50byBhIHRoaXJkIHZlY3Rvci5cclxuICpcclxuICogQHBhcmFtIGEgVGhlIGRpdmlkZW5kIHZlY3Rvci5cclxuICogQHBhcmFtIG4gVGhlIHNjYWxhci5cclxuICogQHBhcmFtIGRzdCBUaGUgdmVjdG9yIHRoZSByZXN1bHQgd2lsbCBiZSBzdG9yZWQgdG8uXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRpdm4oYSwgbiwgZHN0ID0gY3JlYXRlKDAsIDApKSB7XHJcbiAgICBkc3QueCA9IGEueCAvIG47XHJcbiAgICBkc3QueSA9IGEueSAvIG47XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSByZW1pbmRlciBhZnRlciBkaXZpc2lvbiBvZiBhJ3MgY29tcG9uZW50cyBieSBuIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbnRvIGEgdGhpcmQgdmVjdG9yLlxyXG4gKlxyXG4gKiBAcGFyYW0gYSBUaGUgZGl2aWRlbmQgdmVjdG9yLlxyXG4gKiBAcGFyYW0gbiBUaGUgc2NhbGFyLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSB2ZWN0b3IgdGhlIHJlc3VsdCB3aWxsIGJlIHN0b3JlZCB0by5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbW9kKGEsIG4sIGRzdCA9IGNyZWF0ZSgwLCAwKSkge1xyXG4gICAgZHN0LnggPSBhLnggJSBuO1xyXG4gICAgZHN0LnkgPSBhLnkgJSBuO1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogTGluZWFybHkgaW50ZXJwb2xhdGVzIGJldHdlZW4gdHdvIHZlY3RvcnMsIGkuZS4gY29tcHV0ZXNcclxuICogYCgxIC0gZmFjdG9yKSAqIGEgKyBmYWN0b3IgKiBiYCwgYW5kIHdyaXRlcyB0aGUgcmVzdWx0IGludG8gYSB0aGlyZCB2ZWN0b3IuXHJcbiAqXHJcbiAqIEBwYXJhbSBhIFRoZSBmaXJzdCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBAcGFyYW0gZmFjdG9yIFRoZSBpbnRlcnBvbGF0aW9uIGZhY3Rvci5cclxuICogQHBhcmFtIGRzdCBUaGUgdmVjdG9yIHRoZSByZXN1bHQgd2lsbCBiZSB3cml0dGVuIHRvLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBtaXgoYSwgYiwgZmFjdG9yLCBkc3QgPSBjcmVhdGUoMCwgMCkpIHtcclxuICAgIGRzdC54ID0gKDEgLSBmYWN0b3IpICogYS54ICsgZmFjdG9yICogYi54O1xyXG4gICAgZHN0LnkgPSAoMSAtIGZhY3RvcikgKiBhLnkgKyBmYWN0b3IgKiBiLnk7XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbi8qKlxyXG4gKiBSb3RhdGVzIGEgdmVjdG9yIGJ5IGEgZ2l2ZW4gYW5nbGUgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGludG8gYSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBQb3NpdGl2ZSBkaXJlY3Rpb24gaXMgZnJvbSArWCB0byArWS5cclxuICpcclxuICogQHBhcmFtIHYgVGhlIHZlY3RvciB0byByb3RhdGUuXHJcbiAqIEBwYXJhbSBhbmdsZSBUaGUgYW5nbGUgb2Ygcm90YXRpb24uXHJcbiAqIEBwYXJhbSBkc3QgVGhlIHZlY3RvciB0aGUgcmVzdWx0IHdpbGwgYmUgc3RvcmVkIHRvLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiByb3RhdGUodiwgYW5nbGUsIGRzdCA9IGNyZWF0ZSgwLCAwKSkge1xyXG4gICAgY29uc3QgeCA9IHYueDtcclxuICAgIGNvbnN0IHkgPSB2Lnk7XHJcbiAgICBjb25zdCBhbmdsZUNvcyA9IE1hdGguY29zKGFuZ2xlKTtcclxuICAgIGNvbnN0IGFuZ2xlU2luID0gTWF0aC5zaW4oYW5nbGUpO1xyXG4gICAgZHN0LnggPSBhbmdsZUNvcyAqIHggLSBhbmdsZVNpbiAqIHk7XHJcbiAgICBkc3QueSA9IGFuZ2xlU2luICogeCArIGFuZ2xlQ29zICogeTtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIFJvdGF0ZXMgYSB2ZWN0b3IgYnkgNDUgZGVncmVlcyBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW50byBhIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEFuYWxvZ291cyB0byBgcm90YXRlKHYsIE1hdGguUEkgLyA0LCBkc3QpYCwgYnV0IGZhc3Rlci5cclxuICpcclxuICogQHBhcmFtIHYgVGhlIHZlY3RvciB0byByb3RhdGUuXHJcbiAqIEBwYXJhbSBkc3QgVGhlIHZlY3RvciB0aGUgcmVzdWx0IHdpbGwgYmUgc3RvcmVkIHRvLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiByb3RhdGU0NSh2LCBkc3QgPSBjcmVhdGUoMCwgMCkpIHtcclxuICAgIGNvbnN0IHkgPSB2Lnk7XHJcbiAgICBjb25zdCBzID0gTWF0aC5TUVJUMV8yO1xyXG4gICAgZHN0LnkgPSBzICogdi54ICsgcyAqIHYueTtcclxuICAgIGRzdC54ID0gcyAqIHYueCAtIHMgKiB5O1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogUm90YXRlcyBhIHZlY3RvciBieSA5MCBkZWdyZWVzIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbnRvIGEgc2Vjb25kIHZlY3Rvci5cclxuICogQW5hbG9nb3VzIHRvIGByb3RhdGUodiwgTWF0aC5QSSAvIDIsIGRzdClgLCBidXQgZmFzdGVyLlxyXG4gKlxyXG4gKiBAcGFyYW0gdiBUaGUgdmVjdG9yIHRvIHJvdGF0ZS5cclxuICogQHBhcmFtIGRzdCBUaGUgdmVjdG9yIHRoZSByZXN1bHQgd2lsbCBiZSBzdG9yZWQgdG8uXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZTkwKHYsIGRzdCA9IGNyZWF0ZSgwLCAwKSkge1xyXG4gICAgY29uc3QgeSA9IHYueTtcclxuICAgIGRzdC55ID0gdi54O1xyXG4gICAgZHN0LnggPSAteTtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIFJvdGF0ZXMgYSB2ZWN0b3IgYnkgLTkwIGRlZ3JlZXMgYW5kIHN0b3JlcyB0aGUgcmVzdWx0IGludG8gYSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBBbmFsb2dvdXMgdG8gYHJvdGF0ZSh2LCAtTWF0aC5QSSAvIDIsIGRzdClgLCBidXQgZmFzdGVyLlxyXG4gKlxyXG4gKiBAcGFyYW0gdiBUaGUgdmVjdG9yIHRvIHJvdGF0ZS5cclxuICogQHBhcmFtIGRzdCBUaGUgdmVjdG9yIHRoZSByZXN1bHQgd2lsbCBiZSBzdG9yZWQgdG8uXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZU5lZzkwKHYsIGRzdCA9IGNyZWF0ZSgwLCAwKSkge1xyXG4gICAgY29uc3QgeSA9IHYueTtcclxuICAgIGRzdC55ID0gLXYueDtcclxuICAgIGRzdC54ID0geTtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIEludmVydHMgc2lnbnMgb2YgY29tcG9uZW50cyBvZiBhIHZlY3RvciBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW50byBhIHNlY29uZFxyXG4gKiB2ZWN0b3IuIEFuYWxvZ291cyB0byBgcm90YXRlKHYsIE1hdGguUEksIGRzdClgIChvciBgcm90YXRlKHYsIC1NYXRoLlBJLCBkc3QpYCxcclxuICogd2hpY2ggaXMgdGhlIHNhbWUpLCBidXQgZmFzdGVyLlxyXG4gKlxyXG4gKiBAcGFyYW0gdiBUaGUgdmVjdG9yIHRvIGludmVydC5cclxuICogQHBhcmFtIGRzdCBUaGUgdmVjdG9yIHRoZSByZXN1bHQgd2lsbCBiZSBzdG9yZWQgdG8uXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGludmVydCh2LCBkc3QgPSBjcmVhdGUoMCwgMCkpIHtcclxuICAgIGRzdC54ID0gLXYueDtcclxuICAgIGRzdC55ID0gLXYueTtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIENvbXB1dGVzIGxlbmd0aCBvZiBhIHZlY3Rvci5cclxuICpcclxuICogQHBhcmFtIHYgVGhlIHZlY3Rvci5cclxuICogQHJldHVybnMgVGhlIGxlbmd0aC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBsZW5ndGgodikge1xyXG4gICAgcmV0dXJuIE1hdGguaHlwb3Qodi54LCB2LnkpO1xyXG59XHJcbi8qKlxyXG4gKiBDb21wdXRlcyBkaXN0YW5jZSBiZXR3ZWVuIGVuZHMgb2YgdHdvIHZlY3RvcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSBhIFRoZSBmaXJzdCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBAcmV0dXJucyBUaGUgZGlzdGFuY2UsIGkuZS4gYGxlbmd0aChzdWIoYSwgYikpYC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XHJcbiAgICByZXR1cm4gTWF0aC5oeXBvdChhLnggLSBiLngsIGEueSAtIGIueSk7XHJcbn1cclxuLyoqXHJcbiAqIERpdmlkZXMgYSB2ZWN0b3IgYnkgaXRzIGxlbmd0aCAodGh1cyBtYWtpbmcgaXQgYSB1bml0IHZlY3RvcikgYW5kIHN0b3JlcyB0aGVcclxuICogcmVzdWx0IHRvIGFub3RoZXIgb25lLlxyXG4gKlxyXG4gKiBAcGFyYW0gdiBUaGUgdmVjdG9yIHRvIGJlIG5vcm1hbGl6ZWQuXHJcbiAqIEBwYXJhbSBkc3QgVGhlIHZlY3RvciB0aGUgcmVzdWx0IHdpbGwgYmUgc3RvcmVkIHRvLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUodiwgZHN0ID0gY3JlYXRlKDAsIDApKSB7XHJcbiAgICByZXR1cm4gZGl2bih2LCBsZW5ndGgodiksIGRzdCk7XHJcbn1cclxuLyoqXHJcbiAqIENvbnZlcnRzIGVhY2ggY29tcG9uZW50IG9mIHZlY3Rvci5cclxuICpcclxuICogQHBhcmFtIHYgVGhlIHZlY3RvciB0byBiZSBjb252ZXJ0ZWQuXHJcbiAqIEBwYXJhbSBjb252ZXJ0ZXIgVGhlIGNvbXBvbmVudCBjb252ZXJ0ZXIuXHJcbiAqIEBwYXJhbSBkc3QgVGhlIHZlY3RvciB0aGUgcmVzdWx0IHdpbGwgYmUgc3RvcmVkIHRvLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0KHYsIGNvbnZlcnRlciwgZHN0ID0gY3JlYXRlKDAsIDApKSB7XHJcbiAgICBkc3QueCA9IGNvbnZlcnRlcih2LngpO1xyXG4gICAgZHN0LnkgPSBjb252ZXJ0ZXIodi55KTtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIENvbXB1dGVzIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWN0b3JzLlxyXG4gKlxyXG4gKiBAcGFyYW0gYSBUaGUgZmlyc3QgdmVjdG9yLlxyXG4gKiBAcGFyYW0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cclxuICogQHJldHVybnMgVGhlIGRvdCBwcm9kdWN0LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRvdChhLCBiKSB7XHJcbiAgICByZXR1cm4gYS54ICogYi54ICsgYS55ICogYi55O1xyXG59XHJcbi8qKlxyXG4gKiBDb21wdXRlcyBaLWNvbXBvbmVudCBvZiBhIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIHZlY3RvcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSBhIFRoZSBmaXJzdCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBAcmV0dXJucyBaLWNvbXBvbmVudCBvZiB0aGUgY3Jvc3MgcHJvZHVjdC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjcm9zc1ooYSwgYikge1xyXG4gICAgcmV0dXJuIGEueCAqIGIueSAtIGEueSAqIGIueDtcclxufVxyXG5leHBvcnQgY29uc3QgRU1QVFkgPSB7XHJcbiAgICBtaW5YOiAwLFxyXG4gICAgbWF4WDogMCxcclxuICAgIG1pblk6IDAsXHJcbiAgICBtYXhZOiAwXHJcbn07XHJcbmV4cG9ydCBjb25zdCBVTklUX0JCT1ggPSB7XHJcbiAgICBtaW5YOiAtMSxcclxuICAgIG1heFg6IDEsXHJcbiAgICBtaW5ZOiAtMSxcclxuICAgIG1heFk6IDFcclxufTtcclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgYmJveCBhbmQgaW5pdGlhbGl6ZXMgaXQgd2l0aCBnaXZlbiBjb21wb25lbnRzLlxyXG4gKlxyXG4gKiBAcGFyYW0gbWluWCBMZWZ0IGJvcmRlciBvZiB0aGUgYmJveC5cclxuICogQHBhcmFtIG1heFggUmlnaHQgYm9yZGVyIG9mIHRoZSBiYm94LlxyXG4gKiBAcGFyYW0gbWluWSBMb3dlciBib3JkZXIgb2YgdGhlIGJib3guXHJcbiAqIEBwYXJhbSBtYXhZIFVwcGVyIGJvcmRlciBvZiB0aGUgYmJveC5cclxuICogQHJldHVybnMgVGhlIGJib3guXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQkJveDIobWluWCwgbWF4WCwgbWluWSwgbWF4WSkge1xyXG4gICAgcmV0dXJuIHsgbWluWCwgbWF4WCwgbWluWSwgbWF4WSB9O1xyXG59XHJcbi8qKlxyXG4gKiBDb3BpZXMgYSBiYm94IHRvIGFub3RoZXIgb25lLlxyXG4gKlxyXG4gKiBAcGFyYW0gc3JjIFRoZSBzb3VyY2UgYmJveC5cclxuICogQHBhcmFtIGRzdCBUaGUgYmJveCB0aGUgc291cmNlIGJib3ggd2lsbCBiZSBjb3BpZWQgdG8uXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvcHlCQm94MihzcmMsIGRzdCA9IGNyZWF0ZUJCb3gyKDAsIDAsIDAsIDApKSB7XHJcbiAgICBkc3QubWluWCA9IHNyYy5taW5YO1xyXG4gICAgZHN0Lm1heFggPSBzcmMubWF4WDtcclxuICAgIGRzdC5taW5ZID0gc3JjLm1pblk7XHJcbiAgICBkc3QubWF4WSA9IHNyYy5tYXhZO1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogQ2hlY2tzIGlmIHR3byBib3VuZGluZyBib3hlcyBvdmVybGFwLlxyXG4gKlxyXG4gKiBAcGFyYW0gYmJveDEgQSBib3VuZGluZyBib3guXHJcbiAqIEBwYXJhbSBiYm94MiBBbm90aGVyIGJvdW5kaW5nIGJveC5cclxuICogQHJldHVybnMgYHRydWVgIGlmIGdpdmVuIGJvdW5kaW5nIGJveGVzIGRvIG92ZXJsYXAgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGJib3hlc092ZXJsYXAoYmJveDEsIGJib3gyKSB7XHJcbiAgICBsZXQgbGVmdEJCb3g7XHJcbiAgICBsZXQgcmlnaHRCQm94O1xyXG4gICAgaWYgKGJib3gxLm1pblggPCBiYm94Mi5taW5YKSB7XHJcbiAgICAgICAgbGVmdEJCb3ggPSBiYm94MTtcclxuICAgICAgICByaWdodEJCb3ggPSBiYm94MjtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGxlZnRCQm94ID0gYmJveDI7XHJcbiAgICAgICAgcmlnaHRCQm94ID0gYmJveDE7XHJcbiAgICB9XHJcbiAgICBsZXQgdG9wQkJveDtcclxuICAgIGxldCBib3R0b21CQm94O1xyXG4gICAgaWYgKGJib3gxLm1heFkgPiBiYm94Mi5tYXhZKSB7XHJcbiAgICAgICAgdG9wQkJveCA9IGJib3gxO1xyXG4gICAgICAgIGJvdHRvbUJCb3ggPSBiYm94MjtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHRvcEJCb3ggPSBiYm94MjtcclxuICAgICAgICBib3R0b21CQm94ID0gYmJveDE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmlnaHRCQm94Lm1pblggPCBsZWZ0QkJveC5tYXhYICYmIGJvdHRvbUJCb3gubWF4WSA+IHRvcEJCb3gubWluWTtcclxufVxyXG4vKipcclxuICogQ2hlY2tzIGlmIGEgMkQgcG9pbnQgbGllcyBpbnNpZGUgYSBib3VuZGluZyBib3ggb3Igb24gaXRzIGJvcmRlci5cclxuICpcclxuICogQHBhcmFtIHBvaW50IFRoZSBwb2ludC5cclxuICogQHBhcmFtIGJib3ggVGhlIGJvdW5kaW5nIGJveC5cclxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBwb2ludCBpcyBpbnNpZGUgb2YgdGhlIGJveCBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcG9pbnRJc0luQkJveChwb2ludCwgYmJveCkge1xyXG4gICAgcmV0dXJuIGJib3gubWluWCA8PSBwb2ludC54ICYmIHBvaW50LnggPD0gYmJveC5tYXhYICYmXHJcbiAgICAgICAgYmJveC5taW5ZIDw9IHBvaW50LnkgJiYgcG9pbnQueSA8PSBiYm94Lm1heFk7XHJcbn1cclxuLyoqXHJcbiAqIENvbXB1dGVzIGJvdW5kaW5nIGJveCBvZiBhbiBhcnJheSBvZiBwb2ludHMgYW5kIHN0b3JlcyBpdCB0byBhIGdpdmVuIG9iamVjdC5cclxuICpcclxuICogQHBhcmFtIHBvaW50cyBUaGUgYXJyYXkgb2YgcG9pbnRzLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSBiYm94IHRoZSByZXN1bHQgd2lsbCBiZSB3cml0dGVuIHRvLiBMZWZ0IHVubW9kaWZpZWQgaWYgdGhlIGFycmF5XHJcbiAqICAgICAgb2YgcG9pbnRzIGlzIGVtcHR5LlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlQkJveEZvclBvaW50cyhwb2ludHMsIGRzdCA9IHsgbWluWDogMCwgbWF4WDogMCwgbWluWTogMCwgbWF4WTogMCB9KSB7XHJcbiAgICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBkc3Q7XHJcbiAgICB9XHJcbiAgICBkc3QubWluWCA9IGRzdC5tYXhYID0gcG9pbnRzWzBdLng7XHJcbiAgICBkc3QubWluWSA9IGRzdC5tYXhZID0gcG9pbnRzWzBdLnk7XHJcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHBvaW50cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gcG9pbnRzW2ldO1xyXG4gICAgICAgIGlmICh4IDwgZHN0Lm1pblgpIHtcclxuICAgICAgICAgICAgZHN0Lm1pblggPSB4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoeCA+IGRzdC5tYXhYKSB7XHJcbiAgICAgICAgICAgIGRzdC5tYXhYID0geDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHkgPCBkc3QubWluWSkge1xyXG4gICAgICAgICAgICBkc3QubWluWSA9IHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh5ID4gZHN0Lm1heFkpIHtcclxuICAgICAgICAgICAgZHN0Lm1heFkgPSB5O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuZXhwb3J0IGNvbnN0IFhfQVhJUyA9IHtcclxuICAgIG9yaWdpbjogT1JJR0lOLFxyXG4gICAgdGFuZ2VudDogUE9TSVRJVkVfWFxyXG59O1xyXG5leHBvcnQgY29uc3QgWV9BWElTID0ge1xyXG4gICAgb3JpZ2luOiBPUklHSU4sXHJcbiAgICB0YW5nZW50OiBQT1NJVElWRV9ZXHJcbn07XHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRMaW5lRnJvbVBvaW50cyhwMSwgcDIsIGRzdCA9IHtcclxuICAgIG9yaWdpbjogY3JlYXRlKDAsIDApLFxyXG4gICAgdGFuZ2VudDogY3JlYXRlKDAsIDApXHJcbn0pIHtcclxuICAgIGNvcHkocDEsIGRzdC5vcmlnaW4pO1xyXG4gICAgc3ViKHAyLCBwMSwgZHN0LnRhbmdlbnQpO1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogQ29tcHV0ZXMgc2lnbmVkIGRpc3RhbmNlIGZyb20gYSBwb2ludCB0byBhIGxpbmUuXHJcbiAqXHJcbiAqIEBwYXJhbSBwIFRoZSBwb2ludC5cclxuICogQHBhcmFtIGwxIFN0YXJ0IHBvaW50IG9mIHRoZSBsaW5lLlxyXG4gKiBAcGFyYW0gbDIgRW5kIHBvaW50IG9mIHRoZSBsaW5lLlxyXG4gKiBAcmV0dXJucyBEaXN0YW5jZSBmcm9tIHRoZSBwb2ludCB0byB0aGUgbGluZS4gSXQnbGwgYmUgZ3JlYXRlciB0aGFuIDAgaWYgdGhlXHJcbiAqICAgICAgcG9pbnQgbGllcyB0byB0aGUgbGVmdCBvZiB0aGUgbGluZSBhbmQgbGVzcyB0aGFuIDAgb3RoZXJ3aXNlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFNpZ25lZERpc3RhbmNlVG9MaW5lKHAsIGwpIHtcclxuICAgIGNvbnN0IHRhbmdlbnQgPSBsLnRhbmdlbnQ7XHJcbiAgICByZXR1cm4gZG90KHN1YihwLCBsLm9yaWdpbiksIGNyZWF0ZSgtdGFuZ2VudC55LCB0YW5nZW50LngpKSAvIGxlbmd0aCh0YW5nZW50KTtcclxufVxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBleHRlbnQgYW5kIGluaXRpYWxpemVzIGl0IHdpdGggZ2l2ZW4gY29tcG9uZW50cy5cclxuICpcclxuICogQHBhcmFtIHdpZHRoIFdpZHRoIG9mIHRoZSBleHRlbnQuXHJcbiAqIEBwYXJhbSBIZWlnaHQgSGVpZ2h0IG9mIHRoZSBleHRlbnQuXHJcbiAqIEByZXR1cm5zIFRoZSBleHRlbnQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRXh0ZW50Mih3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICByZXR1cm4geyB3aWR0aCwgaGVpZ2h0IH07XHJcbn1cclxuLyoqXHJcbiAqIENvcGllcyBhbiBleHRlbnQgdG8gYW5vdGhlciBvbmUuXHJcbiAqXHJcbiAqIEBwYXJhbSBzcmMgVGhlIHNvdXJjZSBiYm94LlxyXG4gKiBAcGFyYW0gZHN0IFRoZSBleHRlbnQgdGhlIHNvdXJjZSBleHRlbnQgd2lsbCBiZSBjb3BpZWQgdG8uXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvcHlFeHRlbnQyKHNyYywgZHN0ID0gY3JlYXRlRXh0ZW50MigwLCAwKSkge1xyXG4gICAgZHN0LndpZHRoID0gc3JjLndpZHRoO1xyXG4gICAgZHN0LmhlaWdodCA9IHNyYy5oZWlnaHQ7XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbiIsImV4cG9ydCBjb25zdCBERUZBVUxUX1RPTEVSQU5DRSA9IDFlLTY7XHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgdHdvIGZsb2F0aW5nIHBvaW50IG51bWJlciBhcmUgd2l0aGluIGEgdG9sZXJhbmNlIGZyb20gZWFjaCBvdGhlci5cclxuICpcclxuICogQHBhcmFtIGEgVGhlIGZpcnN0IG51bWJlci5cclxuICogQHBhcmFtIGIgVGhlIHNlY29uZCBudW1iZXIuXHJcbiAqIEBwYXJhbSB0b2xlcmFuY2UgVGhlIHRvbGVyYW5jZS5cclxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBudW1iZXIgYXJlIHdpdGhpbiB0aGUgdG9sZXJhbmNlIGFuZCBgZmFsc2VgIG90aGVyd2lzZS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFyZUZ1enp5RXF1YWwoYSwgYiwgdG9sZXJhbmNlID0gREVGQVVMVF9UT0xFUkFOQ0UpIHtcclxuICAgIGNvbnN0IGQgPSBhIC0gYjtcclxuICAgIHJldHVybiAtdG9sZXJhbmNlIDwgZCAmJiBkIDwgdG9sZXJhbmNlO1xyXG59XHJcbiIsIi8qKlxyXG4gKiBPbmUgb2JqZWN0IGlzIHVzZWQgYXMgYSBidWZmZXIgdG8gcGFzcyBjb21tb24gcHJvcGVydGllcyB0byBzdHlsZSBleHRyYWN0b3JzLFxyXG4gKiB0byBwcmV2ZW50IGNyZWF0aW9uIG9mIG1hbnkgdGVtcG9yYXJ5IG9iamVjdHMuXHJcbiAqL1xyXG5jb25zdCBzdHlsZUJhc2UgPSB7XHJcbiAgICBtaW5ab29tOiAwLFxyXG4gICAgbWF4Wm9vbTogMCxcclxuICAgIHpJbmRleDogMFxyXG59O1xyXG4vKipcclxuICogVXRpbGl0eSBtZXRob2QgZm9yIHBhcnNpbmcgc3R5bGVzIGZyb20gZGVjb2RlZCBBUEkgdGlsZSByZXNwb25zZS4gSXQgaGFuZGxlcyBzb21lIGNvbW1vbiBsb2dpYyByZWdhcmRpbmdcclxuICogem9vbSBzbGljZXMgYW5kIGRlbGVnYXRlcyBmZXRjaGluZyBzdHlsZSBkZXRhaWxzIHRvIGEgU3R5bGVIYW5kbGVyLlxyXG4gKiBUaWxlIG1pbi9tYXggem9vbSBwYXJhbXMgYXJlIHVzZWQgdG8gc2V0IHByb3BlciBzdHlsZXMgdG8gYmUgdXNlZCBpbiBvdmVyL3VuZGVyIHpvb21pbmcsIHN0aWxsIGFkaGVyaW5nXHJcbiAqIHRoZSBBUEkgY29udmVudGlvbiB3aGVyZSBtaXNzaW5nIHpvb20gcmFuZ2Ugc2xpY2UgbWVhbnMgb2JqZWN0IGludmlzaWJpbGl0eS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKiBleHRyYWN0U3R5bGVzKHByZXNlbnRhdGlvbnMsIGNsYXNzSWQsIHRvU3R5bGUsIHRpbGVNaW5ab29tLCB0aWxlTWF4Wm9vbSwgcHJlc2VudGF0aW9uTmFtZSA9ICdtYXAnKSB7XHJcbiAgICBjb25zdCBwcmVzZW50YXRpb24gPSBwcmVzZW50YXRpb25zLmZpbmQoKHByZXNlbnRhdGlvbikgPT4gcHJlc2VudGF0aW9uLm5hbWUgPT09IHByZXNlbnRhdGlvbk5hbWUpIHx8XHJcbiAgICAgICAgcHJlc2VudGF0aW9uc1swXTtcclxuICAgIGNvbnN0IHN0eWxlQ2xhc3MgPSBwcmVzZW50YXRpb24uY2xhc3Nlc1tjbGFzc0lkXTtcclxuICAgIGlmIChzdHlsZUNsYXNzKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBzbGljZSBvZiBzdHlsZUNsYXNzLnNsaWNlcykge1xyXG4gICAgICAgICAgICBpZiAoc2xpY2UudmlzaWJpbGl0eSkge1xyXG4gICAgICAgICAgICAgICAgc3R5bGVCYXNlLm1pblpvb20gPSBzbGljZS52aXNpYmlsaXR5Lm1pbiA9PT0gdGlsZU1pblpvb20gPyAtSW5maW5pdHkgOiBzbGljZS52aXNpYmlsaXR5Lm1pbjtcclxuICAgICAgICAgICAgICAgIHN0eWxlQmFzZS5tYXhab29tID0gc2xpY2UudmlzaWJpbGl0eS5tYXggPT09IHRpbGVNYXhab29tID8gK0luZmluaXR5IDogc2xpY2UudmlzaWJpbGl0eS5tYXg7XHJcbiAgICAgICAgICAgICAgICBzdHlsZUJhc2UuekluZGV4ID0gc2xpY2UuekluZGV4O1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3R5bGUgPSB0b1N0eWxlKHNsaWNlLCBzdHlsZUJhc2UpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgc3R5bGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgUHJlc2VudGF0aW9uIH0gZnJvbSAnLi4vcHJvdG9fYWxpYXNlcyc7XHJcbmltcG9ydCAqIGFzIHZlY3RvcjIgZnJvbSAnLi4vLi4vLi4vLi4vbWF0aC92ZWN0b3IyJztcclxuaW1wb3J0IFRpbGVXb3JsZENvb3JkaW5hdGVzQ29udmVydGVyLCB7IGlzVGlsZUVkZ2VDb29yZGluYXRlcyB9IGZyb20gJy4vdGlsZV93b3JsZF9jb29yZGluYXRlc19jb252ZXJ0ZXInO1xyXG5pbXBvcnQgZXh0cmFjdFN0eWxlcyBmcm9tICcuL2V4dHJhY3Rfc3R5bGVzJztcclxuaW1wb3J0IHsgZGVjb2RlQWJncjggfSBmcm9tICcuLi8uLi8uLi8uLi91dGlsL2NvbG9yJztcclxuaW1wb3J0IHsgVFJBTlNQQVJFTlRfQkxBQ0sgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlsL2NvbG9yJztcclxuaW1wb3J0IHsgc3BsaXRQb2x5bGluZSB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWwvcG9seWxpbmUnO1xyXG5jb25zdCBKT0lOUyA9IHtcclxuICAgIFtQcmVzZW50YXRpb24uQ2xhc3MuTGluZVN0eWxlLkpvaW5TdHlsZS5Kb2luTWl0ZXJdOiAwIC8qIE1JVEVSICovLFxyXG4gICAgW1ByZXNlbnRhdGlvbi5DbGFzcy5MaW5lU3R5bGUuSm9pblN0eWxlLkpvaW5Sb3VuZF06IDEgLyogUk9VTkQgKi8sXHJcbiAgICBbUHJlc2VudGF0aW9uLkNsYXNzLkxpbmVTdHlsZS5Kb2luU3R5bGUuSm9pbkJldmVsXTogMiAvKiBCRVZFTCAqL1xyXG59O1xyXG5jb25zdCBDQVBTID0ge1xyXG4gICAgW1ByZXNlbnRhdGlvbi5DbGFzcy5MaW5lU3R5bGUuQ2FwU3R5bGUuQ2FwQmV2ZWxdOiAwIC8qIEJVVFQgKi8sXHJcbiAgICBbUHJlc2VudGF0aW9uLkNsYXNzLkxpbmVTdHlsZS5DYXBTdHlsZS5DYXBTcXVhcmVdOiAyIC8qIFNRVUFSRSAqLyxcclxuICAgIFtQcmVzZW50YXRpb24uQ2xhc3MuTGluZVN0eWxlLkNhcFN0eWxlLkNhcFJvdW5kXTogMSAvKiBST1VORCAqL1xyXG59O1xyXG5mdW5jdGlvbiBleHRyYWN0UG9seWxpbmVTdHlsZSh6b29tU2xpY2UsIHN0eWxlQmFzZSkge1xyXG4gICAgY29uc3QgaW5saW5lU3R5bGUgPSAoem9vbVNsaWNlLmxpbmUgJiYgem9vbVNsaWNlLmxpbmUubGluZSkgfHwgKHpvb21TbGljZS5wb2x5ICYmIHpvb21TbGljZS5wb2x5LmNvbnRvdXIpO1xyXG4gICAgY29uc3Qgb3V0bGluZVN0eWxlID0gem9vbVNsaWNlLmxpbmUgJiYgem9vbVNsaWNlLmxpbmUub3V0bGluZTtcclxuICAgIHJldHVybiBpbmxpbmVTdHlsZSB8fCBvdXRsaW5lU3R5bGUgPyBPYmplY3QuYXNzaWduKHt9LCBzdHlsZUJhc2UsIHsgaW5saW5lOiBpbmxpbmVTdHlsZSA/IHtcclxuICAgICAgICAgICAgc3Ryb2tlQ29sb3I6IGlubGluZVN0eWxlLnBhdHRlcm4gPyBUUkFOU1BBUkVOVF9CTEFDSyA6IGRlY29kZUFiZ3I4KGlubGluZVN0eWxlLmNvbG9yKSxcclxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IGlubGluZVN0eWxlLndpZHRoLFxyXG4gICAgICAgICAgICBqb2luOiBKT0lOU1tpbmxpbmVTdHlsZS5qb2luc10sXHJcbiAgICAgICAgICAgIHN0YXJ0Q2FwOiBDQVBTW2lubGluZVN0eWxlLmNhcHNdLFxyXG4gICAgICAgICAgICBlbmRDYXA6IENBUFNbaW5saW5lU3R5bGUuY2Fwc10sXHJcbiAgICAgICAgICAgIGRhc2g6IGlubGluZVN0eWxlLmRhc2ggPyB7XHJcbiAgICAgICAgICAgICAgICBmaWxsOiBpbmxpbmVTdHlsZS5kYXNoLmRhc2hlc1swXS5maWxsLFxyXG4gICAgICAgICAgICAgICAgZ2FwOiBpbmxpbmVTdHlsZS5kYXNoLmRhc2hlc1swXS5nYXBcclxuICAgICAgICAgICAgfSA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgcGF0dGVybjogaW5saW5lU3R5bGUucGF0dGVybiA/IHtcclxuICAgICAgICAgICAgICAgIGltYWdlSWQ6IGlubGluZVN0eWxlLnBhdHRlcm4uaWQsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogaW5saW5lU3R5bGUucGF0dGVybi53aWR0aCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogaW5saW5lU3R5bGUud2lkdGhcclxuICAgICAgICAgICAgfSA6IHVuZGVmaW5lZFxyXG4gICAgICAgIH0gOiB1bmRlZmluZWQsIG91dGxpbmU6IG91dGxpbmVTdHlsZSA/IHtcclxuICAgICAgICAgICAgc3Ryb2tlQ29sb3I6IG91dGxpbmVTdHlsZS5wYXR0ZXJuID8gVFJBTlNQQVJFTlRfQkxBQ0sgOiBkZWNvZGVBYmdyOChvdXRsaW5lU3R5bGUuY29sb3IpLFxyXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogb3V0bGluZVN0eWxlLndpZHRoLFxyXG4gICAgICAgICAgICBqb2luOiBKT0lOU1tvdXRsaW5lU3R5bGUuam9pbnNdLFxyXG4gICAgICAgICAgICBzdGFydENhcDogQ0FQU1tvdXRsaW5lU3R5bGUuY2Fwc10sXHJcbiAgICAgICAgICAgIGVuZENhcDogQ0FQU1tvdXRsaW5lU3R5bGUuY2Fwc10sXHJcbiAgICAgICAgICAgIGRhc2g6IG91dGxpbmVTdHlsZS5kYXNoID8ge1xyXG4gICAgICAgICAgICAgICAgZmlsbDogb3V0bGluZVN0eWxlLmRhc2guZGFzaGVzWzBdLmZpbGwsXHJcbiAgICAgICAgICAgICAgICBnYXA6IG91dGxpbmVTdHlsZS5kYXNoLmRhc2hlc1swXS5nYXBcclxuICAgICAgICAgICAgfSA6IHVuZGVmaW5lZFxyXG4gICAgICAgIH0gOiB1bmRlZmluZWQgfSkgOiB1bmRlZmluZWQ7XHJcbn1cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24qIGV4dHJhY3RQb2x5bGluZXModGlsZSwgZGVjb2RlZEFwaVRpbGUsIHRpbGVNaW5ab29tLCB0aWxlTWF4Wm9vbSkge1xyXG4gICAgY29uc3QgcG9seWxpbmVzID0gZGVjb2RlZEFwaVRpbGUucG9seWxpbmVzO1xyXG4gICAgaWYgKCFwb2x5bGluZXMpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBwcmVwYXJlUG9seWxpbmUgPSAodmVydGljZXMsIGNsYXNzSWQsIHpPcmRlciwgZm9yY2VkU3RhcnRDYXAsIGZvcmNlZEVuZENhcCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHN0eWxlcyA9IFsuLi5leHRyYWN0U3R5bGVzKGRlY29kZWRBcGlUaWxlLnByZXNlbnRhdGlvbiwgY2xhc3NJZCwgZXh0cmFjdFBvbHlsaW5lU3R5bGUsIHRpbGVNaW5ab29tLCB0aWxlTWF4Wm9vbSldO1xyXG4gICAgICAgIGZvciAoY29uc3Qgc3R5bGUgb2Ygc3R5bGVzKSB7XHJcbiAgICAgICAgICAgIHN0eWxlLnpJbmRleCArPSB6T3JkZXI7XHJcbiAgICAgICAgICAgIGlmIChmb3JjZWRTdGFydENhcCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3R5bGUuaW5saW5lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUuaW5saW5lLnN0YXJ0Q2FwID0gZm9yY2VkU3RhcnRDYXA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoc3R5bGUub3V0bGluZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLm91dGxpbmUuc3RhcnRDYXAgPSBmb3JjZWRTdGFydENhcDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZm9yY2VkRW5kQ2FwICE9PSB1bmRlZmluZWQgJiYgc3R5bGUuaW5saW5lKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3R5bGUuaW5saW5lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUuaW5saW5lLmVuZENhcCA9IGZvcmNlZEVuZENhcDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChzdHlsZS5vdXRsaW5lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUub3V0bGluZS5lbmRDYXAgPSBmb3JjZWRFbmRDYXA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgdmVydGljZXMsIHN0eWxlcyB9O1xyXG4gICAgfTtcclxuICAgIGNvbnN0IGNvbnZlcnRlciA9IG5ldyBUaWxlV29ybGRDb29yZGluYXRlc0NvbnZlcnRlcih0aWxlKTtcclxuICAgIGZvciAobGV0IGxpbmVJZHggPSAwLCB2ZXJ0ZXhJZHggPSAwOyBsaW5lSWR4IDwgcG9seWxpbmVzLmxpbmVTaXplLmxlbmd0aDsgKytsaW5lSWR4KSB7XHJcbiAgICAgICAgY29uc3Qgek9yZGVyQmVnaW4gPSBwb2x5bGluZXMuek9yZGVyQmVnaW5bbGluZUlkeF0gfCAwO1xyXG4gICAgICAgIGNvbnN0IHpPcmRlckVuZCA9IHBvbHlsaW5lcy56T3JkZXJFbmRbbGluZUlkeF0gfCAwO1xyXG4gICAgICAgIGNvbnN0IHNpemUgPSBwb2x5bGluZXMubGluZVNpemVbbGluZUlkeF07XHJcbiAgICAgICAgY29uc3QgdmVydGljZXMgPSBuZXcgQXJyYXkoc2l6ZSk7XHJcbiAgICAgICAgbGV0IGZvcmNlZFN0YXJ0Q2FwO1xyXG4gICAgICAgIGxldCBmb3JjZWRFbmRDYXA7XHJcbiAgICAgICAgbGV0IHggPSAwO1xyXG4gICAgICAgIGxldCB5ID0gMDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7ICsraSwgKyt2ZXJ0ZXhJZHgpIHtcclxuICAgICAgICAgICAgeCArPSBwb2x5bGluZXMuY29vcmRzeFt2ZXJ0ZXhJZHhdO1xyXG4gICAgICAgICAgICB5ICs9IHBvbHlsaW5lcy5jb29yZHN5W3ZlcnRleElkeF07XHJcbiAgICAgICAgICAgIC8vIHBvbHlsaW5lcyBiZXR3ZWVuIHRpbGVzIHRoYXQgYXJlIGFjdHVhbGx5IG9uZSBsaW5lIG9uIHRoZSBtYXAgb3ZlcmxhcHMgdGhlbXNlbGYgYXQgdGhlIGVkZ2UsXHJcbiAgICAgICAgICAgIC8vIHRvIGhhbmRsZSB0aGlzIGNhc2UgdGhlaXIgY2FwcyBhcmUgZm9yY2libGUgcmVtb3ZlZCwgaXQgaXMga2luZCBvZiBoYWNrIGFuZCBnZW5lcmFsbHkgaXQgaXMgaW5jb3JyZWN0LFxyXG4gICAgICAgICAgICAvLyBidXQgd29ya3Mgd2VsbCBlbm91Z2ggZm9yIHRoZSBkYXRhIGJlaW5nIGNvbWUgZnJvbSBBUEkuXHJcbiAgICAgICAgICAgIGlmIChpID09PSAwICYmIGlzVGlsZUVkZ2VDb29yZGluYXRlcyh4LCB5KSkge1xyXG4gICAgICAgICAgICAgICAgZm9yY2VkU3RhcnRDYXAgPSAwIC8qIEJVVFQgKi87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGkgPT09IHNpemUgLSAxICYmIGlzVGlsZUVkZ2VDb29yZGluYXRlcyh4LCB5KSkge1xyXG4gICAgICAgICAgICAgICAgZm9yY2VkRW5kQ2FwID0gMCAvKiBCVVRUICovO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZlcnRpY2VzW2ldID0gdmVjdG9yMi5jcmVhdGUoY29udmVydGVyLnRvV29ybGRYQ29vcmRpbmF0ZSh4KSwgY29udmVydGVyLnRvV29ybGRZQ29vcmRpbmF0ZSh5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh6T3JkZXJCZWdpbiAhPT0gek9yZGVyRW5kKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZlcnRpY2VzU3BsaXQgPSBzcGxpdFBvbHlsaW5lKHZlcnRpY2VzKTtcclxuICAgICAgICAgICAgeWllbGQgcHJlcGFyZVBvbHlsaW5lKHZlcnRpY2VzU3BsaXRbMF0sIHBvbHlsaW5lcy5jbGFzc0lkW2xpbmVJZHhdLCB6T3JkZXJCZWdpbiwgZm9yY2VkU3RhcnRDYXAsIGZvcmNlZEVuZENhcCk7XHJcbiAgICAgICAgICAgIHlpZWxkIHByZXBhcmVQb2x5bGluZSh2ZXJ0aWNlc1NwbGl0WzFdLCBwb2x5bGluZXMuY2xhc3NJZFtsaW5lSWR4XSwgek9yZGVyRW5kLCBmb3JjZWRTdGFydENhcCwgZm9yY2VkRW5kQ2FwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHlpZWxkIHByZXBhcmVQb2x5bGluZSh2ZXJ0aWNlcywgcG9seWxpbmVzLmNsYXNzSWRbbGluZUlkeF0sIHpPcmRlckJlZ2luLCBmb3JjZWRTdGFydENhcCwgZm9yY2VkRW5kQ2FwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0ICogYXMgdmVjMiBmcm9tICcuLi9tYXRoL3ZlY3RvcjInO1xyXG5pbXBvcnQgeyBhcmVGdXp6eUVxdWFsIH0gZnJvbSAnLi4vbWF0aC92ZWN0b3IyJztcclxuaW1wb3J0IHsgREVGQVVMVF9UT0xFUkFOQ0UgfSBmcm9tICcuL2Z1enp5X2VxdWFsJztcclxuLyoqXHJcbiAqIFNwaWx0cyBhIHBvbHlsaW5lIGluIHR3byBwYXJ0czogdHdvIHBvbHlsaW5lcyBjb3ZlcmluZyB0aGUgaW5wdXQgcG9seWxpbmUgd2l0aCBhIGNvaW5jaWRlbnQgc3BpbHQgcG9pbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSBwb2x5bGluZSBQb2x5bGluZSB0byBiZSBzZXBhcmF0ZWQuXHJcbiAqIEBwYXJhbSBwcm9wb3J0aW9uIExlbmd0aCBvZiB0aGUgZmlyc3QgcGFydCBhcyBwZXJjZW50YWdlICgwLi4xKSBvZiB0aGUgbGVuZ3RoIG9mIHRoZSBwb2x5bGluZS5cclxuICogQHJldHVybnMgVHdvIHBvbHlsaW5lcy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzcGxpdFBvbHlsaW5lKHBvbHlsaW5lLCBwcm9wb3J0aW9uID0gMC41KSB7XHJcbiAgICBjb25zdCBzdWJMZW5ndGhzID0gbmV3IEFycmF5KHBvbHlsaW5lLmxlbmd0aCk7XHJcbiAgICBzdWJMZW5ndGhzWzBdID0gMDtcclxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcG9seWxpbmUubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBzdWJMZW5ndGhzW2ldID0gc3ViTGVuZ3Roc1tpIC0gMV0gKyB2ZWMyLmRpc3RhbmNlKHBvbHlsaW5lW2kgLSAxXSwgcG9seWxpbmVbaV0pO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgc3BsaXRMZW5ndGggPSBwcm9wb3J0aW9uICogc3ViTGVuZ3Roc1twb2x5bGluZS5sZW5ndGggLSAxXTtcclxuICAgIGNvbnN0IHNwbGl0SW5kZXggPSBzdWJMZW5ndGhzLmZpbmRJbmRleCgobGVuZ3RoKSA9PiBsZW5ndGggPj0gc3BsaXRMZW5ndGgpIHx8IDE7IC8vIFwifHwgMVwiIHRvIGhhbmRsZSAwLWxlbmd0aCBjYXNlXHJcbiAgICBjb25zdCBzcGxpdFBvaW50ID0gdmVjMi5taXgocG9seWxpbmVbc3BsaXRJbmRleCAtIDFdLCBwb2x5bGluZVtzcGxpdEluZGV4XSwgXHJcbiAgICAvLyBcInx8IDFcIiB0byBoYW5kbGUgMC1sZW5ndGggY2FzZVxyXG4gICAgKHNwbGl0TGVuZ3RoIC0gc3ViTGVuZ3Roc1tzcGxpdEluZGV4IC0gMV0pIC8gKChzdWJMZW5ndGhzW3NwbGl0SW5kZXhdIC0gc3ViTGVuZ3Roc1tzcGxpdEluZGV4IC0gMV0pIHx8IDEpKTtcclxuICAgIGNvbnN0IGxlZnRQYXJ0TGVuZ3RoID0gc3BsaXRJbmRleCArIDE7XHJcbiAgICBjb25zdCBsZWZ0UGFydCA9IG5ldyBBcnJheShsZWZ0UGFydExlbmd0aCk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNwbGl0SW5kZXg7ICsraSkge1xyXG4gICAgICAgIGxlZnRQYXJ0W2ldID0gcG9seWxpbmVbaV07XHJcbiAgICB9XHJcbiAgICBsZWZ0UGFydFtzcGxpdEluZGV4XSA9IHNwbGl0UG9pbnQ7XHJcbiAgICBjb25zdCBpc1NwbGl0RXhpc3RpbmdQb2ludCA9IGFyZUZ1enp5RXF1YWwocG9seWxpbmVbc3BsaXRJbmRleF0sIHNwbGl0UG9pbnQsIHNwbGl0TGVuZ3RoICogREVGQVVMVF9UT0xFUkFOQ0UpO1xyXG4gICAgY29uc3QgcmlnaHRQYXJ0TGVuZ3RoID0gcG9seWxpbmUubGVuZ3RoIC0gc3BsaXRJbmRleDtcclxuICAgIGNvbnN0IHJpZ2h0UGFydCA9IG5ldyBBcnJheShyaWdodFBhcnRMZW5ndGggKyAoaXNTcGxpdEV4aXN0aW5nUG9pbnQgPyAwIDogMSkpO1xyXG4gICAgbGV0IHJpZ2h0UGFydEluZGV4ID0gMDtcclxuICAgIC8vIGRvbid0IGluY2x1ZGUgc3BsaXRQb2ludCBpZiBzcGxpdHRpbmcgaGFzIGhhcHBlbmVkIGF0IGEgcG9seWxpbmUncyBwb2ludFxyXG4gICAgaWYgKCFpc1NwbGl0RXhpc3RpbmdQb2ludCkge1xyXG4gICAgICAgIHJpZ2h0UGFydFtyaWdodFBhcnRJbmRleCsrXSA9IHZlYzIuY29weShzcGxpdFBvaW50KTtcclxuICAgIH1cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmlnaHRQYXJ0TGVuZ3RoOyBpKyspIHtcclxuICAgICAgICByaWdodFBhcnRbcmlnaHRQYXJ0SW5kZXgrK10gPSBwb2x5bGluZVtzcGxpdEluZGV4ICsgaV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gW2xlZnRQYXJ0LCByaWdodFBhcnRdO1xyXG59XHJcbiIsImltcG9ydCBCdWZmZXJXcml0ZXIgZnJvbSAnLi4vLi4vdXRpbC9idWZmZXJfd3JpdGVyJztcclxuaW1wb3J0IHRyaWFuZ3VsYXRlIGZyb20gJy4uLy4uL3V0aWwvdHJpYW5ndWxhdGUnO1xyXG5pbXBvcnQgeyBQT0xZR09OX0FUVFJJQlVURV9NQVBQSU5HIH0gZnJvbSAnLi9wb2x5Z29uX2F0dHJpYnV0ZV9tYXBwaW5nJztcclxuaW1wb3J0IHsgZW5jb2RlUmdiYTggfSBmcm9tICcuLi8uLi91dGlsL2NvbG9yJztcclxuaW1wb3J0IHsgaW50VG9aSW5kZXggfSBmcm9tICcuLi8uLi91dGlsL3pfaW5kZXgnO1xyXG4vKipcclxuICogV3JpdGVyIG9mIGdlb21ldHJ5IGRhdGEgb2YgbGFiZWxzLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9seWdvbkJ1ZmZlcldyaXRlciBleHRlbmRzIEJ1ZmZlcldyaXRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcihQT0xZR09OX0FUVFJJQlVURV9NQVBQSU5HLnZlcnRleEJ5dGVTaXplKTtcclxuICAgIH1cclxuICAgIHdyaXRlUG9seWdvbihwb2x5Z29uLCB6SW5kZXgsIGNvbG9yKSB7XHJcbiAgICAgICAgY29uc3QgekluZGV4SW50MjQgPSBpbnRUb1pJbmRleCh6SW5kZXgpO1xyXG4gICAgICAgIGNvbnN0IGNvbG9yUmdiYTggPSBlbmNvZGVSZ2JhOChjb2xvcik7XHJcbiAgICAgICAgZm9yIChjb25zdCByaW5nIG9mIHBvbHlnb24udmVydGV4UmluZ3MpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCB2ZXJ0ZXggb2YgcmluZykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fd3JpdGVXb3JsZENvb3JkaW5hdGUodmVydGV4KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3dyaXRlV29yZChjb2xvclJnYmE4KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3dyaXRlRmxvYXQzMih6SW5kZXhJbnQyNCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy53cml0ZUluZGljZXModHJpYW5ndWxhdGUocG9seWdvbi52ZXJ0ZXhSaW5ncykpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVuZE1lc2goKTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBmbG9hdFRvVWludDMyIH0gZnJvbSAnLi9ncHV0eXBlcyc7XHJcbmltcG9ydCB7IHppcCB9IGZyb20gJy4vYXJyYXknO1xyXG5leHBvcnQgY29uc3QgV09SRF9CWVRFX1NJWkUgPSA0O1xyXG4vKipcclxuICogR2VuZXJhdGVzIHRyaWFuZ2xlcyBvZiBhIGZhbiBvZiBhIGdpdmVuIGxlbmd0aCBhcyBpZiBpdCBpcyBjb250aW51b3VzIGFuZFxyXG4gKiBzdGFydHMgd2l0aCAwLlxyXG4gKlxyXG4gKiBAcGFyYW0gY291bnQgTnVtYmVyIG9mIHZlcnRpY2VzIGluIHRoZSBmYW4uXHJcbiAqIEByZXR1cm5zIEl0ZXJhdG9yIG92ZXIgaW5kaWNlcyBvZiB0cmlhbmdsZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiogZ2VuZXJhdGVGYW4oY291bnQpIHtcclxuICAgIGZvciAobGV0IGkgPSAyOyBpIDwgY291bnQ7ICsraSkge1xyXG4gICAgICAgIHlpZWxkIDA7XHJcbiAgICAgICAgeWllbGQgaSAtIDE7XHJcbiAgICAgICAgeWllbGQgaTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogR2VuZXJhdGVzIHRyaWFuZ2xlcyBvZiBhIHN0cmlwIG9mIGEgZ2l2ZW4gbGVuZ3RoIGFzIGlmIGl0IGlzIGNvbnRpbnVvdXMgYW5kXHJcbiAqIHN0YXJ0cyB3aXRoIDAuXHJcbiAqXHJcbiAqIEBwYXJhbSBjb3VudCBOdW1iZXIgb2YgdmVydGljZXMgaW4gdGhlIGZhbi5cclxuICogQHJldHVybnMgSXRlcmF0b3Igb3ZlciBpbmRpY2VzIG9mIHRyaWFuZ2xlcy5cclxuICovXHJcbmZ1bmN0aW9uKiBnZW5lcmF0ZVN0cmlwKGNvdW50KSB7XHJcbiAgICB5aWVsZCAwO1xyXG4gICAgeWllbGQgMTtcclxuICAgIHlpZWxkIDI7XHJcbiAgICBsZXQgb2Zmc2V0MCA9IDE7XHJcbiAgICBsZXQgb2Zmc2V0MSA9IDI7XHJcbiAgICBmb3IgKGxldCBpID0gMzsgaSA8IGNvdW50OyArK2kpIHtcclxuICAgICAgICB5aWVsZCBpIC0gb2Zmc2V0MDtcclxuICAgICAgICB5aWVsZCBpIC0gb2Zmc2V0MTtcclxuICAgICAgICB5aWVsZCBpO1xyXG4gICAgICAgIGNvbnN0IHRtcCA9IG9mZnNldDA7XHJcbiAgICAgICAgb2Zmc2V0MCA9IG9mZnNldDE7XHJcbiAgICAgICAgb2Zmc2V0MSA9IHRtcDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVmVydGV4IGJ1ZmZlciBoZWxwZXIgY2xhc3MsIHRoYXQgc3VwcG9ydHMgc2VxdWVudGlhbCB3cml0aW5nIGludGVyZmFjZSBhbmQgdGFrZXMgb3ZlciBzb21lIHNpbmdsZS1idWZmZXIgb3BlcmF0aW9ucy5cclxuICogSXQgaXMgYW4gaW50ZWdyYWwgcGFydCBvZiB0aGUgYnVmZmVyIHdyaXRlciBjbGFzcyBhbmQgaXRzIG1haW4gcHVycG9zZSBpcyB0byBtYWtlIHRoZSB3cml0ZXIncyBjb2RlIGVhc2llci5cclxuICovXHJcbmNsYXNzIFZlcnRleEJ1ZmZlciB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBieXRlU2l6ZSBJbml0aWFsIHNpemUgb2YgdGhlIGJ1ZmZlciBpbiBieXRlcy4gQXMgaXQgZ2V0cyBmaWxsZWQgYnkgd29yZHNcclxuICAgICAqICAgICAgdGhlIHNpemUgbXVzdCBiZSBhIG11bHRpcGx5IG9mIDQuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGJ5dGVTaXplKSB7XHJcbiAgICAgICAgdGhpcy5fbmV4dFdvcmRPZmZzZXQgPSAwO1xyXG4gICAgICAgIHRoaXMuX2luaXRCdWZmZXJzKGJ5dGVTaXplKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGVyZSBpcyBubyBmcmVlIHNwYWNlIHJlbWFpbmluZyBpbiBidWZmZXIuXHJcbiAgICAgKi9cclxuICAgIGdldCBpc0Z1bGwoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX25leHRXb3JkT2Zmc2V0ID49IHRoaXMuX3VpbnQzMlZpZXcubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIHdvcmRzICg0IGJ5dGVzIHZhbHVlcykgYWxyZWFkeSB3cml0dGVuLlxyXG4gICAgICovXHJcbiAgICBnZXQgb2NjdXBpZWRTaXplKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9uZXh0V29yZE9mZnNldDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiBNYXggbnVtYmVyIG9mIGJ5dGVzIHRoaXMgYnVmZmVyIGlzIGFibGUgdG8gc3RvcmUuIEl0IGNhbiBiZSBpbmNyZWFzZWQgYnkgdGhlIGV4dGVuZCgpIG1ldGhvZC5cclxuICAgICAqL1xyXG4gICAgZ2V0IGJ5dGVTaXplKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl91aW50MzJWaWV3LmJ5dGVMZW5ndGg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEV4dGVuZHMgYnVmZmVyIHRvIHRoZSBuZXcgc2l6ZS4gVGhlIG5ldyBzaXplIG11c3QgYmUgbm90IGxlc3MgdGhhbiBjdXJyZW50IG9uZSBhbmQgaXQgbXVzdCBiZSBhIG11bHRpcGx5IG9mIDQuXHJcbiAgICAgKi9cclxuICAgIGV4dGVuZChuZXdCeXRlU2l6ZSkge1xyXG4gICAgICAgIC8vIFRPRE8gYXNzZXJ0IG5ld0J5dGVMZW5ndGggaXMgbGFyZ2VyIHRoYW4gY3VycmVudCBfYXJyYXlCdWZmZXIgYW5kIGl0cyBpcyBhIG11bHRpcGx5IG9mIHRoZSB3b3JkIHNpemUuXHJcbiAgICAgICAgY29uc3Qgb2xkVWludDMyVmlldyA9IHRoaXMuX3VpbnQzMlZpZXc7XHJcbiAgICAgICAgdGhpcy5faW5pdEJ1ZmZlcnMobmV3Qnl0ZVNpemUpO1xyXG4gICAgICAgIHRoaXMuX3VpbnQzMlZpZXcuc2V0KG9sZFVpbnQzMlZpZXcpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBlbmRzIHZhbHVlIGFzIGEgdWludDMyIG51bWJlci5cclxuICAgICAqL1xyXG4gICAgcHVzaFVpbnQzMih2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX3VpbnQzMlZpZXdbdGhpcy5fbmV4dFdvcmRPZmZzZXQrK10gPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXBwZW5kcyB2YWx1ZSBhcyBhIGZsb2F0MzIgbnVtYmVyLlxyXG4gICAgICovXHJcbiAgICBwdXNoRmxvYXQzMih2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX2Zsb2F0MzJWaWV3W3RoaXMuX25leHRXb3JkT2Zmc2V0KytdID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIHVpbnQ4IHZpZXcgb2YgdGhpcyBidWZmZXIuIFRoZSBzaXplIG9mIHRoZSB2aWV3IG1hdGNoZXMgdGhlIGFtb3VudCBvZiB3cml0dGVuIGRhdGEuXHJcbiAgICAgKi9cclxuICAgIGFzVWludDMyQXJyYXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VpbnQzMlZpZXcuc3ViYXJyYXkoMCwgdGhpcy5vY2N1cGllZFNpemUpO1xyXG4gICAgfVxyXG4gICAgX2luaXRCdWZmZXJzKGJ5dGVMZW5ndGgpIHtcclxuICAgICAgICBjb25zdCBhcnJheUJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihieXRlTGVuZ3RoKTtcclxuICAgICAgICB0aGlzLl91aW50MzJWaWV3ID0gbmV3IFVpbnQzMkFycmF5KGFycmF5QnVmZmVyKTtcclxuICAgICAgICB0aGlzLl9mbG9hdDMyVmlldyA9IG5ldyBGbG9hdDMyQXJyYXkoYXJyYXlCdWZmZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBNb3ZlcyBcInRhaWxcIiBkYXRhIChmcm9tIHRoZSBvZmZzZXQgc3BlY2lmaWVkIHRvIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlcikgb2Ygb25lIGJ1ZmZlciB0byBhbm90aGVyLiBUaGUgY3Vyc29ycyBvZlxyXG4gICAgICogYnVmZmVycyB3aWxsIGJlIGFwcHJvcHJpYXRlbHkgdXBkYXRlZCB0byByZWZsZWN0IGRhdGEgY2hhbmdlcy5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHRyYW5zZmVyRGF0YVRhaWwoc3JjLCBkc3QsIHNyY1dvcmRPZmZzZXQsIGRzdE9mZnNldCA9IDApIHtcclxuICAgICAgICBjb25zdCB0YWlsTGVuZ3RoID0gc3JjLm9jY3VwaWVkU2l6ZSAtIHNyY1dvcmRPZmZzZXQ7XHJcbiAgICAgICAgY29uc3Qgc3JjVGFpbCA9IHNyYy5fdWludDMyVmlldy5zdWJhcnJheShzcmNXb3JkT2Zmc2V0LCBzcmMub2NjdXBpZWRTaXplKTtcclxuICAgICAgICBkc3QuX3VpbnQzMlZpZXcuc2V0KHNyY1RhaWwsIGRzdE9mZnNldCk7XHJcbiAgICAgICAgZHN0Ll9uZXh0V29yZE9mZnNldCA9IHRhaWxMZW5ndGg7XHJcbiAgICAgICAgc3JjLl9uZXh0V29yZE9mZnNldCA9IHNyY1dvcmRPZmZzZXQ7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEluZGV4IGJ1ZmZlciBoZWxwZXIgY2xhc3MsIHRoYXQgc3VwcG9ydHMgc2VxdWVudGlhbCB3cml0aW5nIGludGVyZmFjZSBhbmQgdGFrZXMgb3ZlciBzb21lIHNpbmdsZS1idWZmZXIgb3BlcmF0aW9ucy5cclxuICogSXQgaXMgYW4gaW50ZWdyYWwgcGFydCBvZiB0aGUgYnVmZmVyIHdyaXRlciBjbGFzcyBhbmQgaXRzIG1haW4gcHVycG9zZSBpcyB0byBtYWtlIHRoZSB3cml0ZXIncyBjb2RlIGVhc2llci5cclxuICovXHJcbmNsYXNzIEluZGV4QnVmZmVyIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHNpemUgSW5pdGlhbCBzaXplIG9mIHRoZSBidWZmZXIuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHNpemUpIHtcclxuICAgICAgICB0aGlzLl9uZXh0SW5kZXhPZmZzZXQgPSAwO1xyXG4gICAgICAgIHRoaXMuX3VpbnQxNlZpZXcgPSBuZXcgVWludDE2QXJyYXkoc2l6ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgaW5kaWNlcyBhbHJlYWR5IHdyaXR0ZW4uXHJcbiAgICAgKi9cclxuICAgIGdldCBvY2N1cGllZFNpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX25leHRJbmRleE9mZnNldDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiBNYXggbnVtYmVyIG9mIGluZGljZXMgdGhpcyBidWZmZXIgaXMgYWJsZSB0byBzdG9yZS4gSXQgY2FuIGJlIGluY3JlYXNlZCBieSB0aGUgZXh0ZW5kKCkgbWV0aG9kLlxyXG4gICAgICovXHJcbiAgICBnZXQgc2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdWludDE2Vmlldy5sZW5ndGg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEV4dGVuZHMgYnVmZmVyIHRvIHRoZSBuZXcgc2l6ZS5cclxuICAgICAqL1xyXG4gICAgZXh0ZW5kKG5ld1NpemUpIHtcclxuICAgICAgICAvLyBUT0RPIGFzc2VydCBuZXdCeXRlTGVuZ3RoIGlzIGxhcmdlciB0aGFuIGN1cnJlbnQgX2FycmF5QnVmZmVyXHJcbiAgICAgICAgY29uc3Qgb2xkVWludDE2VmlldyA9IHRoaXMuX3VpbnQxNlZpZXc7XHJcbiAgICAgICAgdGhpcy5fdWludDE2VmlldyA9IG5ldyBVaW50MTZBcnJheShuZXdTaXplKTtcclxuICAgICAgICB0aGlzLl91aW50MTZWaWV3LnNldChvbGRVaW50MTZWaWV3KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXBwZW5kcyBpbmRleCB0byB0aGUgZW5kIG9mIHRoZSBidWZmZXIuXHJcbiAgICAgKi9cclxuICAgIHB1c2goaW5kZXgpIHtcclxuICAgICAgICB0aGlzLl91aW50MTZWaWV3W3RoaXMuX25leHRJbmRleE9mZnNldCsrXSA9IGluZGV4O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyB1aW50MTYgdmlldyBvZiB0aGlzIGJ1ZmZlci4gVGhlIHNpemUgb2YgdGhlIHZpZXcgbWF0Y2hlcyB0aGUgYW1vdW50IG9mIHdyaXR0ZW4gZGF0YS5cclxuICAgICAqL1xyXG4gICAgYXNVaW50MTZBcnJheSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFVpbnQxNkFycmF5KHRoaXMuX3VpbnQxNlZpZXcuYnVmZmVyLCAwLCB0aGlzLm9jY3VwaWVkU2l6ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE1vdmVzIFwidGFpbFwiIGRhdGEgKGZyb20gdGhlIG9mZnNldCBzcGVjaWZpZWQgdG8gdGhlIGVuZCBvZiB0aGUgYnVmZmVyKSBvZiBvbmUgYnVmZmVyIHRvIGFub3RoZXIuIFRoZSBvZmZzZXRzIG9mXHJcbiAgICAgKiBidWZmZXJzIHdpbGwgYmUgYXBwcm9wcmlhdGVseSB1cGRhdGVkIHRvIHJlZmxlY3QgZGF0YSBjaGFuZ2VzLlxyXG4gICAgICogYmFzZUluZGV4IHdpbGwgYmUgZGVkdWN0ZWQgZnJvbSBhbGwgbW92ZWQgaW5kaWNlcy5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHRyYW5zZmVyRGF0YVRhaWwoc3JjLCBkc3QsIGJhc2VJbmRleCwgc3JjT2Zmc2V0LCBkc3RPZmZzZXQgPSAwKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IHNyY09mZnNldCwgaiA9IGRzdE9mZnNldDsgaSA8IHNyYy5vY2N1cGllZFNpemU7IGkrKywgaisrKSB7XHJcbiAgICAgICAgICAgIGRzdC5fdWludDE2Vmlld1tqXSA9IHNyYy5fdWludDE2Vmlld1tpXSAtIGJhc2VJbmRleDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZHN0Ll9uZXh0SW5kZXhPZmZzZXQgPSBzcmMub2NjdXBpZWRTaXplIC0gc3JjT2Zmc2V0O1xyXG4gICAgICAgIHNyYy5fbmV4dEluZGV4T2Zmc2V0ID0gc3JjT2Zmc2V0O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBCYXNlIGJ1ZmZlciB3cml0ZXIgaW1wbGVtZW50YXRpb24uIENhbiB3cml0ZSB1bnNpZ25lZCBzaG9ydCBpbmRpY2VzIGFuZFxyXG4gKiBwcm92aWRlcyBmYWNpbGl0aWVzIGZvciBjaGlsZCBjbGFzc2VzIHRvIGhhbmRsZSB3cml0aW5nIHZlcnRleCBkYXRhLiBEZWZpbmVzXHJcbiAqIGEgY29uY2VwdCBvZiBjdXJyZW50IG1lc2guIEJhc2ljYWxseSwgaXQgbWVhbiB0aGF0IGFsbCB2ZXJ0aWNlcyBhbmQgaW5kaWNlc1xyXG4gKiB3cml0dGVuIHRvIGEgd3JpdGVyIGJldHdlZW4gdHdvIGBlbmRNZXNoYCBjYWxscyAob3IgY29uc3RydWN0aW9uIG9mIHRoZSB3cml0ZXJcclxuICogYW5kIGFuIGBlbmRNZXNoYCBjYWxsKSBtdXN0IGJlIGNvbnNpZGVyZWQgYmVsb25naW5nIHRvIG9uZSBhdG9taWMgcGllY2Ugb2ZcclxuICogZ2VvbWV0cnkgYW5kIHNob3VsZCBub3QgYmUgc3BpdHRlZCBiZXR3ZWVuIHNlcGFyYXRlIGJ1ZmZlcnMuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCdWZmZXJXcml0ZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHdyaXRlciBhbmQgYWxsb2NhdGVzIGluaXRpYWwgYW1vdW50IG9mIG1lbW9yeSB0byBzdG9yZSBkYXRhLlxyXG4gICAgICogQWxzbyBpbXBsaWNpdGx5IFwic3RhcnRcIiBhIG1lc2guXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZlcnRleEJ5dGVTaXplXHJcbiAgICAgKiBAcGFyYW0gaW5pdFZlcnRleEJ1ZmZlclNpemUgSW5pdCBzaXplIChpbiB2ZXJ0aWNlcykgb2YgZ3Jvd2luZyB2ZXJ0ZXggYnVmZmVycy5cclxuICAgICAqIEBwYXJhbSBtYXhWZXJ0ZXhCdWZmZXJTaXplIE1heCBzaXplIChpbiB2ZXJ0aWNlcykgb2YgdmVydGV4IGJ1ZmZlcnMuXHJcbiAgICAgKiBAcGFyYW0gaW5pdEluZGV4QnVmZmVyVWludDE2U2l6ZSBJbml0IHNpemUgKGluIHVpbnQxNiBudW1iZXIpIG9mIGdyb3dpbmcgaW5kZXggYnVmZmVycy5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IodmVydGV4Qnl0ZVNpemUsIGluaXRWZXJ0ZXhCdWZmZXJTaXplID0gMHg0MDAsIG1heFZlcnRleEJ1ZmZlclNpemUgPSAweDEwMDAwLCBpbml0SW5kZXhCdWZmZXJVaW50MTZTaXplID0gMHhjMDApIHtcclxuICAgICAgICB0aGlzLl92ZXJ0ZXhCeXRlU2l6ZSA9IHZlcnRleEJ5dGVTaXplO1xyXG4gICAgICAgIHRoaXMuX2luaXRWZXJ0ZXhCdWZmZXJCeXRlU2l6ZSA9IHZlcnRleEJ5dGVTaXplICogaW5pdFZlcnRleEJ1ZmZlclNpemU7XHJcbiAgICAgICAgdGhpcy5fbWF4VmVydGV4QnVmZmVyQnl0ZVNpemUgPSB2ZXJ0ZXhCeXRlU2l6ZSAqIG1heFZlcnRleEJ1ZmZlclNpemU7XHJcbiAgICAgICAgdGhpcy5faW5pdEluZGV4QnVmZmVyVWludDE2U2l6ZSA9IGluaXRJbmRleEJ1ZmZlclVpbnQxNlNpemU7XHJcbiAgICAgICAgdGhpcy5fdmVydGV4QnVmZmVyID0gbmV3IFZlcnRleEJ1ZmZlcih0aGlzLl9pbml0VmVydGV4QnVmZmVyQnl0ZVNpemUpO1xyXG4gICAgICAgIHRoaXMuX3ZlcnRleEJ1ZmZlcnMgPSBbdGhpcy5fdmVydGV4QnVmZmVyXTtcclxuICAgICAgICB0aGlzLl9pbmRleEJ1ZmZlciA9IG5ldyBJbmRleEJ1ZmZlcih0aGlzLl9pbml0SW5kZXhCdWZmZXJVaW50MTZTaXplKTtcclxuICAgICAgICB0aGlzLl9pbmRleEJ1ZmZlcnMgPSBbdGhpcy5faW5kZXhCdWZmZXJdO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRNZXNoVmVydGV4T2Zmc2V0ID0gMDtcclxuICAgICAgICB0aGlzLl9jdXJyZW50TWVzaEluZGV4T2Zmc2V0ID0gMDtcclxuICAgICAgICB0aGlzLl9jdXJyZW50TWVzaEJhc2VJbmRleCA9IDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIGJ1bmNoIG9mIGluZGljZXMgdG8gdGhlIHVuZGVybHlpbmcgc3RvcmFnZSBhcyB1bnNpZ25lZCBzaG9ydFxyXG4gICAgICogbnVtYmVycy4gSWYgY3VycmVudCBzdG9yYWdlIGRvZXNuJ3QgaGF2ZSBlbm91Z2ggc3BhY2UgdG8gYWNjb21tb2RhdGVcclxuICAgICAqIGdpdmVuIGluZGljZXMsIHRoZSB3cml0ZXIgd2lsbCBhdXRvbWF0aWNhbGx5IHJlc2l6ZSBpdC4gVGhlIHdyaXRlclxyXG4gICAgICogYXV0b21hdGljYWxseSBhZGRzIGJhc2UgaW5kZXggdG8gdGhlIHN1cHBsaWVkIHZhbHVlcywgc28gZnJvbSBhIHVzZXJcclxuICAgICAqIHBvaW50IG9mIHZpZXcgZmlyc3QgdmVydGV4IG9mIGEgbWVzaCBoYXMgaW5kZXggMCBhbmQgdGhlcmUncyBubyBuZWVkXHJcbiAgICAgKiB0byB0YWtlIGludG8gYWNjb3VudCBpdCdzIG9mZnNldCB3aGlsZSBnZW5lcmF0aW5nIG1lc2gncyB0b3BvbG9neS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaW5kaWNlcyBBcnJheSBvZiBpbmRpY2VzIHRvIHdyaXRlLlxyXG4gICAgICovXHJcbiAgICB3cml0ZUluZGljZXMoaW5kaWNlcykge1xyXG4gICAgICAgIHRoaXMuX2Vuc3VyZUVub3VnaEluZGV4QnVmZmVyU3BhY2UoaW5kaWNlcy5sZW5ndGgpO1xyXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuX2luZGV4QnVmZmVyO1xyXG4gICAgICAgIGNvbnN0IGJhc2VJbmRleCA9IHRoaXMuX2N1cnJlbnRNZXNoQmFzZUluZGV4O1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kaWNlcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBidWZmZXIucHVzaChiYXNlSW5kZXggKyBpbmRpY2VzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlcyB0cmlhbmdsZSBpbmRpY2VzIGZyb20gYW4gYXJyYXkgb2YgaW5kaWNlcyBvZiBhIHRyaWFuZ2xlIHN0cmlwXHJcbiAgICAgKiAoYXMgaW4gR0wpIGFuZCB3cml0ZXMgZ2VuZXJhdGVkIHRyaXBsZXRzIHRvIHRoZSBtYW5hZ2VkIGluZGV4IGJ1ZmZlci5cclxuICAgICAqIEBzZWUgT3BlbkdMIEVTIDIuMCBTcGVjLCDCpzIuNi4xXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGluZGljZXMgSW5kaWNlcyBvZiB0aGUgc3RyaXAuXHJcbiAgICAgKi9cclxuICAgIHdyaXRlSW5kaWNlc0ZvclN0cmlwKGluZGljZXMpIHtcclxuICAgICAgICB0aGlzLl9lbnN1cmVFbm91Z2hJbmRleEJ1ZmZlclNwYWNlKDMgKiAoaW5kaWNlcy5sZW5ndGggLSAyKSk7XHJcbiAgICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5faW5kZXhCdWZmZXI7XHJcbiAgICAgICAgY29uc3QgYmFzZUluZGV4ID0gdGhpcy5fY3VycmVudE1lc2hCYXNlSW5kZXg7XHJcbiAgICAgICAgZm9yIChjb25zdCBpIG9mIGdlbmVyYXRlU3RyaXAoaW5kaWNlcy5sZW5ndGgpKSB7XHJcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoKGJhc2VJbmRleCArIGluZGljZXNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJhdGVzIHRyaWFuZ2xlIGluZGljZXMgZnJvbSBhIGNvbnRpbnVvdXMgdHJpYW5nbGUgc3RyaXAgb2YgYSBnaXZlblxyXG4gICAgICogbGVuZ3RoIGFuZCB3cml0ZXMgZ2VuZXJhdGVkIHRyaXBsZXRzIHRvIG1hbmFnZWQgaW5kZXggYnVmZmVyLlxyXG4gICAgICogQHNlZSBPcGVuR0wgRVMgMi4wIFNwZWMsIMKnMi42LjFcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaW5kZXhDb3VudFxyXG4gICAgICogQHBhcmFtIGJhc2VJbmRleEluTWVzaFxyXG4gICAgICovXHJcbiAgICB3cml0ZUluZGljZXNGb3JDb250aW51b3VzU3RyaXAoaW5kZXhDb3VudCwgYmFzZUluZGV4SW5NZXNoID0gMCkge1xyXG4gICAgICAgIHRoaXMuX2Vuc3VyZUVub3VnaEluZGV4QnVmZmVyU3BhY2UoMyAqIChpbmRleENvdW50IC0gMikpO1xyXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuX2luZGV4QnVmZmVyO1xyXG4gICAgICAgIGNvbnN0IGJhc2VJbmRleCA9IHRoaXMuX2N1cnJlbnRNZXNoQmFzZUluZGV4ICsgYmFzZUluZGV4SW5NZXNoO1xyXG4gICAgICAgIGZvciAoY29uc3QgaSBvZiBnZW5lcmF0ZVN0cmlwKGluZGV4Q291bnQpKSB7XHJcbiAgICAgICAgICAgIGJ1ZmZlci5wdXNoKGJhc2VJbmRleCArIGkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJhdGVzIHRyaWFuZ2xlIGluZGljZXMgZnJvbSBhbiBhcnJheSBvZiBpbmRpY2VzIG9mIGEgdHJpYW5nbGUgZmFuIChhc1xyXG4gICAgICogaW4gR0wpIGFuZCB3cml0ZXMgZ2VuZXJhdGVkIHRyaXBsZXRzIHRvIHRoZSBtYW5hZ2VkIGluZGV4IGJ1ZmZlci5cclxuICAgICAqIEBzZWUgT3BlbkdMIEVTIDIuMCBTcGVjLCDCpzIuNi4xXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGluZGljZXMgSW5kaWNlcyBvZiB0aGUgc3RyaXAuXHJcbiAgICAgKi9cclxuICAgIHdyaXRlSW5kaWNlc0ZvckZhbihpbmRpY2VzKSB7XHJcbiAgICAgICAgdGhpcy5fZW5zdXJlRW5vdWdoSW5kZXhCdWZmZXJTcGFjZSgzICogKGluZGljZXMubGVuZ3RoIC0gMikpO1xyXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuX2luZGV4QnVmZmVyO1xyXG4gICAgICAgIGNvbnN0IGJhc2VJbmRleCA9IHRoaXMuX2N1cnJlbnRNZXNoQmFzZUluZGV4O1xyXG4gICAgICAgIGZvciAoY29uc3QgaSBvZiBnZW5lcmF0ZUZhbihpbmRpY2VzLmxlbmd0aCkpIHtcclxuICAgICAgICAgICAgYnVmZmVyLnB1c2goYmFzZUluZGV4ICsgaW5kaWNlc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZXMgdHJpYW5nbGUgaW5kaWNlcyBmcm9tIGEgY29udGludW91cyB0cmlhbmdsZSBmYW4gb2YgYSBnaXZlbiBsZW5ndGhcclxuICAgICAqIGFuZCB3cml0ZXMgZ2VuZXJhdGVkIHRyaXBsZXRzIHRvIG1hbmFnZWQgaW5kZXggYnVmZmVyLlxyXG4gICAgICogQHNlZSBPcGVuR0wgRVMgMi4wIFNwZWMsIMKnMi42LjFcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaW5kZXhDb3VudFxyXG4gICAgICogQHBhcmFtIGJhc2VJbmRleEluTWVzaFxyXG4gICAgICovXHJcbiAgICB3cml0ZUluZGljZXNGb3JDb250aW51b3VzRmFuKGluZGV4Q291bnQsIGJhc2VJbmRleEluTWVzaCA9IDApIHtcclxuICAgICAgICB0aGlzLl9lbnN1cmVFbm91Z2hJbmRleEJ1ZmZlclNwYWNlKDMgKiAoaW5kZXhDb3VudCAtIDIpKTtcclxuICAgICAgICBjb25zdCBidWZmZXIgPSB0aGlzLl9pbmRleEJ1ZmZlcjtcclxuICAgICAgICBjb25zdCBiYXNlSW5kZXggPSBiYXNlSW5kZXhJbk1lc2ggKyB0aGlzLl9jdXJyZW50TWVzaEJhc2VJbmRleDtcclxuICAgICAgICBmb3IgKGNvbnN0IGkgb2YgZ2VuZXJhdGVGYW4oaW5kZXhDb3VudCkpIHtcclxuICAgICAgICAgICAgYnVmZmVyLnB1c2goYmFzZUluZGV4ICsgaSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmRzIGN1cnJlbnQgbWVzaCBhbmQgaW1wbGljaXRseSBzdGFydHMgYSBuZXcgb25lLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIEludGVybmFsIGluZGV4IG9mIHZlcnRleCBhbmQgaW5kZXggYnVmZmVycyB0aGUgbWVzaCB3YXMgd3JpdHRlblxyXG4gICAgICogICAgICB0byBhbmQgaXRzIG1lbW9yeSBsb2NhdGlvbiBpbiB0aGVtLlxyXG4gICAgICovXHJcbiAgICBlbmRNZXNoKCkge1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRNZXNoVmVydGV4T2Zmc2V0ID0gdGhpcy5fY3VycmVudE1lc2hWZXJ0ZXhPZmZzZXQ7XHJcbiAgICAgICAgY29uc3QgdmVydGV4T2NjdXBpZWRTaXplID0gdGhpcy5fdmVydGV4QnVmZmVyLm9jY3VwaWVkU2l6ZTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50TWVzaFZlcnRleE9mZnNldCA9IHZlcnRleE9jY3VwaWVkU2l6ZTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50TWVzaEJhc2VJbmRleCA9ICh2ZXJ0ZXhPY2N1cGllZFNpemUgPDwgMikgLyB0aGlzLl92ZXJ0ZXhCeXRlU2l6ZTtcclxuICAgICAgICBjb25zdCBjdXJyZW50TWVzaEluZGV4T2Zmc2V0ID0gdGhpcy5fY3VycmVudE1lc2hJbmRleE9mZnNldDtcclxuICAgICAgICBjb25zdCBpbmRleE9jY3VwaWVkU2l6ZSA9IHRoaXMuX2luZGV4QnVmZmVyLm9jY3VwaWVkU2l6ZTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50TWVzaEluZGV4T2Zmc2V0ID0gaW5kZXhPY2N1cGllZFNpemU7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdmVydGV4Qnl0ZU9mZnNldDogY3VycmVudE1lc2hWZXJ0ZXhPZmZzZXQgPDwgMixcclxuICAgICAgICAgICAgdmVydGV4Qnl0ZUxlbmd0aDogdmVydGV4T2NjdXBpZWRTaXplIC0gY3VycmVudE1lc2hWZXJ0ZXhPZmZzZXQgPDwgMixcclxuICAgICAgICAgICAgaW5kZXhCeXRlT2Zmc2V0OiBjdXJyZW50TWVzaEluZGV4T2Zmc2V0IDw8IDEsXHJcbiAgICAgICAgICAgIGluZGV4Qnl0ZUxlbmd0aDogaW5kZXhPY2N1cGllZFNpemUgLSBjdXJyZW50TWVzaEluZGV4T2Zmc2V0IDw8IDEsXHJcbiAgICAgICAgICAgIC8vIFdlIGNhbid0IHJldHVybiBhY3R1YWwgYnVmZmVyIHJlZmVyZW5jZSBzaW5jZSBpdCBjYW4gY2hhbmdlIGlmXHJcbiAgICAgICAgICAgIC8vIHRoZSBidWZmZXIgZ2V0cyByZWFsbG9jYXRlZC5cclxuICAgICAgICAgICAgYnVmZmVySW5kZXg6IHRoaXMuX3ZlcnRleEJ1ZmZlcnMubGVuZ3RoIC0gMVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgY3VycmVudGx5IG93bmVkIGJ1ZmZlciBkYXRhLiBUaGlzIGNhbGwncyBiZXR0ZXJcclxuICAgICAqIG1hZGUgd2hlbiB5b3UncmUgZG9uZSB3aXRoIHRoZSB3cml0ZXIgc2luY2UgaWYgdGhlIHdyaXRlciBkZWNpZGVzIHRvXHJcbiAgICAgKiByZXNpemUgYW55IG9mIHRoZSBidWZmZXJzIHNvbWUgb2YgdGhlIHJlZmVyZW5jZXMgaW4gdGhlIHJldHVybmVkIGFycmF5XHJcbiAgICAgKiBtYXkgYmVjb21lIG91dGRhdGVkLlxyXG4gICAgICovXHJcbiAgICBnZXRCdWZmZXJzKCkge1xyXG4gICAgICAgIHJldHVybiB6aXAodGhpcy5fdmVydGV4QnVmZmVycywgdGhpcy5faW5kZXhCdWZmZXJzLCAodmVydGV4QnVmZmVyLCBpbmRleEJ1ZmZlcikgPT4gKHtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyOiB2ZXJ0ZXhCdWZmZXIuYXNVaW50MzJBcnJheSgpLFxyXG4gICAgICAgICAgICBpbmRleEJ1ZmZlcjogaW5kZXhCdWZmZXIuYXNVaW50MTZBcnJheSgpXHJcbiAgICAgICAgfSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFuIG9mZnNldCBpbiB0aGUgY3VycmVudCB2ZXJ0ZXggYnVmZmVyIHRvIHRoZSBsb2NhdGlvbiB3aGVyZSBuZXh0XHJcbiAgICAgKiBwaWVjZSBvZiBkYXRhIHdpbGwgYmUgd3JpdHRlbi5cclxuICAgICAqL1xyXG4gICAgZ2V0Q3VycmVudFZlcnRleEJ1ZmZlckJ5dGVPZmZzZXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZlcnRleEJ1ZmZlci5vY2N1cGllZFNpemUgPDwgMjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBpbmRleCBvZiBjdXJyZW50bHkgd3JpdHRlbiB2ZXJ0ZXggc3RydWN0dXJlIGluIHRoZSBjdXJyZW50IHZlcnRleFxyXG4gICAgICogYnVmZmVyLlxyXG4gICAgICovXHJcbiAgICBnZXRDdXJyZW50VmVydGV4SWR4KCkge1xyXG4gICAgICAgIHJldHVybiAoKHRoaXMuX3ZlcnRleEJ1ZmZlci5vY2N1cGllZFNpemUgPDwgMikgLyB0aGlzLl92ZXJ0ZXhCeXRlU2l6ZSB8IDApIC0gdGhpcy5fY3VycmVudE1lc2hCYXNlSW5kZXg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIGZsb2F0aW5nIHBvaW50IHZhbHVlIHRvIHRoZSBjdXJyZW50IHZlcnRleCBidWZmZXIgYW5kIGFkdmFuY2VzXHJcbiAgICAgKiB0aGUgb2Zmc2V0IGJ5IDQgYnl0ZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBiZSB3cml0dGVuLlxyXG4gICAgICovXHJcbiAgICBfd3JpdGVGbG9hdDMyKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fZW5zdXJlRW5vdWdoVmVydGV4QnVmZmVyU3BhY2UoKTtcclxuICAgICAgICB0aGlzLl92ZXJ0ZXhCdWZmZXIucHVzaEZsb2F0MzIodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYW4gdW5zaWduZWQgaW50ZWdlciB2YWx1ZSB0byB0aGUgY3VycmVudCB2ZXJ0ZXggYnVmZmVyIGFuZCBhZHZhbmNlc1xyXG4gICAgICogdGhlIG9mZnNldCBieSA0IGJ5dGVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgd3JpdHRlbi5cclxuICAgICAqL1xyXG4gICAgX3dyaXRlV29yZCh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX2Vuc3VyZUVub3VnaFZlcnRleEJ1ZmZlclNwYWNlKCk7XHJcbiAgICAgICAgdGhpcy5fdmVydGV4QnVmZmVyLnB1c2hVaW50MzIodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYW4gdW5zaWduZWQgc2hvcnQgdmFsdWUgdG8gdGhlIGN1cnJlbnQgdmVydGV4IGJ1ZmZlciBhbmQgYWR2YW5jZXNcclxuICAgICAqIHRoZSBvZmZzZXQgYnkgMiBieXRlcy4gUGFzc2VkIHZhbHVlcyB3aWxsIGJlIHRydW5jYXRlZCB0byAxNiBiaXRzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgd3JpdHRlbi5cclxuICAgICAqL1xyXG4gICAgX3dyaXRlSGFsZldvcmRzKHYxLCB2Mikge1xyXG4gICAgICAgIHRoaXMuX3dyaXRlV29yZCh2MiA8PCAxNiB8IHYxICYgMHhmZmZmKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGFuIHVuc2lnbmVkIGJ5dGUgdmFsdWUgdG8gdGhlIGN1cnJlbnQgdmVydGV4IGJ1ZmZlciBhbmQgYWR2YW5jZXNcclxuICAgICAqIHRoZSBvZmZzZXQgYnkgMSBieXRlLiBQYXNzZWQgdmFsdWVzIHdpbGwgYmUgdHJ1bmNhdGVkIHRvIDggYml0cy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIHdyaXR0ZW4uXHJcbiAgICAgKi9cclxuICAgIF93cml0ZUJ5dGVzKHYxLCB2MiwgdjMsIHY0KSB7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVXb3JkKHY0IDw8IDI0IHxcclxuICAgICAgICAgICAgKHYzICYgMHhmZikgPDwgMTYgfFxyXG4gICAgICAgICAgICAodjIgJiAweGZmKSA8PCA4IHxcclxuICAgICAgICAgICAgdjEgJiAweGZmKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRW5jb2RlcyBhIHdvcmxkIGNvb3JkaW5hdGUgdmVjdG9yIGFzIGEgcGFpciBvZiAzMi1iaXQgaW50ZWdlcnMgKHNwbGl0dGluZ1xyXG4gICAgICogdGhlbSBpbiB0dXJuIGludG8gdG8gMTYtYml0IG9uZXMpLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjIFRoZSB3b3JsZCBjb29yZGluYXRlLlxyXG4gICAgICovXHJcbiAgICBfd3JpdGVXb3JsZENvb3JkaW5hdGUoYykge1xyXG4gICAgICAgIC8vIFRvIGF2b2lkIHVzaW5nIEdQVSBzaW5nZWQgaW50ZWdlciBjb252ZXJzaW9ucyB3ZSBzaGlmdCBhbmQgc2NhbGUgd29ybGRcclxuICAgICAgICAvLyBjb29yZGluYXRlcyBzbyB0aGV5J3JlIGluIFswLCAxXSByYW5nZSAoaW5zdGVhZCBvZiBbLTEsIDFdKSBhbmQgdGhlblxyXG4gICAgICAgIC8vIGVuY29kZWQgYXMgdW5zaWduZWQgMzIgYml0IGludGVnZXJzIHNwbGl0IGludG8gdG8gMTYgYml0IG9uZXMuXHJcbiAgICAgICAgY29uc3QgeFVpbnQzMiA9IGZsb2F0VG9VaW50MzIoMC41ICogKGMueCArIDEpKTtcclxuICAgICAgICBjb25zdCB5VWludDMyID0gZmxvYXRUb1VpbnQzMigwLjUgKiAoYy55ICsgMSkpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlSGFsZldvcmRzKHhVaW50MzIgPj4+IDE2LCB5VWludDMyID4+PiAxNik7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVIYWxmV29yZHMoeFVpbnQzMiwgeVVpbnQzMik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbXB1dGVzIG5ldyBiaWdnZXIgc2l6ZSBvZiBhIHZlcnRleCBidWZmZXIgYmFzZWQgb24gaXRzIGN1cnJlbnQgc2l6ZS4gQnlcclxuICAgICAqIGRlZmF1bHQganVzdCBkb3VibGUgdGhlIGN1cnJlbnQgc2l6ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3VycmVudEJ5dGVTaXplIEN1cnJlbnQgc2l6ZSBvZiB0aGUgaW5kZXggYnVmZmVyIGluIGJ5dGVzLlxyXG4gICAgICogQHJldHVybnMgVGhlIG5ldyBzaXplLlxyXG4gICAgICovXHJcbiAgICBfZ2V0TmV4dFZlcnRleEJ1ZmZlckJ5dGVTaXplKGN1cnJlbnRCeXRlU2l6ZSkge1xyXG4gICAgICAgIHJldHVybiBjdXJyZW50Qnl0ZVNpemUgPDwgMTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgbmV3IGJpZ2dlciBzaXplIG9mIGFuIGluZGV4IGJ1ZmZlciBiYXNlZCBvbiBpdHMgY3VycmVudCBzaXplLiBCeVxyXG4gICAgICogZGVmYXVsdCBqdXN0IGRvdWJsZSB0aGUgY3VycmVudCBzaXplLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjdXJyZW50VWludDE2U2l6ZSBDdXJyZW50IHNpemUgb2YgdGhlIGluZGV4IGJ1ZmZlciBpbiBzaG9ydHMuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgbmV3IHNpemUuXHJcbiAgICAgKi9cclxuICAgIF9nZXROZXh0SW5kZXhCdWZmZXJVaW50MTZTaXplKGN1cnJlbnRVaW50MTZTaXplKSB7XHJcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRVaW50MTZTaXplIDw8IDE7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVuc3VyZXMgdGhhdCB0aGUgbWFuYWdlZCB2ZXJ0ZXggYnVmZmVyIGhhcyBlbm91Z2ggc3BhY2UgdG8gZml0IGluIGEgY2h1bmtcclxuICAgICAqIG9mIGRhdGEgb2YgYSBnaXZlbiBzaXplLiBFaXRoZXIgZG9lcyBub3RoaW5nLCByZXNpemVzIHRoZSBjdXJyZW50IHZlcnRleFxyXG4gICAgICogYnVmZmVyIG9yIGNyZWF0ZXMgZW50aXJlbHkgbmV3IHBhaXIgb2YgdmVydGV4IGFuZCBpbmRleCBidWZmZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB2YWx1ZVNpemUgQnl0ZSBzaXplIG9mIHRoZSBkYXRhIHRoYXQgbmVlZHMgdG8gYmUgYWNjb21tb2RhdGVkIGJ5XHJcbiAgICAgKiAgICAgIHRoZSB2ZXJ0ZXggYnVmZmVyLlxyXG4gICAgICovXHJcbiAgICBfZW5zdXJlRW5vdWdoVmVydGV4QnVmZmVyU3BhY2UoKSB7XHJcbiAgICAgICAgY29uc3QgdmVydGV4QnVmZmVyID0gdGhpcy5fdmVydGV4QnVmZmVyO1xyXG4gICAgICAgIGlmICghdmVydGV4QnVmZmVyLmlzRnVsbCkge1xyXG4gICAgICAgICAgICAvLyBXZSBoYXZlIGVub3VnaCBzcGFjZSwgc28gbm90aGluZyB0byBiZSBkb25lLlxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2ZXJ0ZXhCdWZmZXIuYnl0ZVNpemUgPCB0aGlzLl9tYXhWZXJ0ZXhCdWZmZXJCeXRlU2l6ZSkge1xyXG4gICAgICAgICAgICAvLyBJZiB3ZSBjYW4ganVzdCByZXNpemUgdGhlIGN1cnJlbnQgdmVydGV4IGJ1ZmZlciwgZG8gdGhhdC5cclxuICAgICAgICAgICAgdGhpcy5fdmVydGV4QnVmZmVyLmV4dGVuZCh0aGlzLl9nZXROZXh0VmVydGV4QnVmZmVyQnl0ZVNpemUodmVydGV4QnVmZmVyLmJ5dGVTaXplKSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWYgdGhlcmUncyBubyBlbm91Z2ggc3BhY2UgaW4gdGhlIGN1cnJlbnQgdmVydGV4IGJ1ZmZlciBhbmQgaXQnc1xyXG4gICAgICAgIC8vIGFscmVhZHkgb2YgbWF4aW11bSBzaXplLCBhbGxvY2F0ZSBuZXcgdmVydGV4IGFuZCBpbmRleCBidWZmZXJzIGFuZFxyXG4gICAgICAgIC8vIGNvcHkgZGF0YSBvZiB0aGUgY3VycmVudCBtZXNoIHRvIHRoZW0gZnJvbSB0aGUgY3VycmVudCBidWZmZXJzLlxyXG4gICAgICAgIC8vIFRoZW4gbWFrZSB0aG9zZSBidWZmZXIgdGhlIGN1cnJlbnQgb25lcy5cclxuICAgICAgICBjb25zdCBjdXJyZW50TWVzaFZlcnRleE9mZnNldCA9IHRoaXMuX2N1cnJlbnRNZXNoVmVydGV4T2Zmc2V0O1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRNZXNoVmVydGV4Qnl0ZVNpemUgPSAodmVydGV4QnVmZmVyLm9jY3VwaWVkU2l6ZSAtIGN1cnJlbnRNZXNoVmVydGV4T2Zmc2V0KSAqIDQ7XHJcbiAgICAgICAgY29uc3QgbWF4VmVydGV4QnVmZmVyQnl0ZVNpemUgPSB0aGlzLl9tYXhWZXJ0ZXhCdWZmZXJCeXRlU2l6ZTtcclxuICAgICAgICBpZiAoY3VycmVudE1lc2hWZXJ0ZXhCeXRlU2l6ZSA9PT0gbWF4VmVydGV4QnVmZmVyQnl0ZVNpemUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXNoIGlzIHRvbyBiaWcgdG8gZml0IGluLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgbmV3VmVydGV4QnVmZmVyQnl0ZVNpemUgPSB0aGlzLl9pbml0VmVydGV4QnVmZmVyQnl0ZVNpemU7XHJcbiAgICAgICAgLy8gSW5pdGlhbCB2ZXJ0ZXggYnVmZmVyIHNpemUgbWF5IGJlIHRvbyBzbWFsbCB0byBhY2NvbW1vZGF0ZSB0aGUgY3VycmVudFxyXG4gICAgICAgIC8vIG1lc2gsIHNvIHdlIGZpbmQgbmV4dCBiaWdnZXIgc2l6ZSB0aGF0IGlzIHN1ZmZpY2llbnQuXHJcbiAgICAgICAgd2hpbGUgKG5ld1ZlcnRleEJ1ZmZlckJ5dGVTaXplIDw9IGN1cnJlbnRNZXNoVmVydGV4Qnl0ZVNpemUpIHtcclxuICAgICAgICAgICAgbmV3VmVydGV4QnVmZmVyQnl0ZVNpemUgPSB0aGlzLl9nZXROZXh0VmVydGV4QnVmZmVyQnl0ZVNpemUobmV3VmVydGV4QnVmZmVyQnl0ZVNpemUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBuZXdWZXJ0ZXhCdWZmZXIgPSBuZXcgVmVydGV4QnVmZmVyKG5ld1ZlcnRleEJ1ZmZlckJ5dGVTaXplKTtcclxuICAgICAgICBWZXJ0ZXhCdWZmZXIudHJhbnNmZXJEYXRhVGFpbCh2ZXJ0ZXhCdWZmZXIsIG5ld1ZlcnRleEJ1ZmZlciwgY3VycmVudE1lc2hWZXJ0ZXhPZmZzZXQpO1xyXG4gICAgICAgIHRoaXMuX3ZlcnRleEJ1ZmZlciA9IG5ld1ZlcnRleEJ1ZmZlcjtcclxuICAgICAgICB0aGlzLl92ZXJ0ZXhCdWZmZXJzLnB1c2gobmV3VmVydGV4QnVmZmVyKTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50TWVzaFZlcnRleE9mZnNldCA9IDA7XHJcbiAgICAgICAgY29uc3QgaW5kZXhCdWZmZXIgPSB0aGlzLl9pbmRleEJ1ZmZlcjtcclxuICAgICAgICBjb25zdCBjdXJyZW50TWVzaEluZGV4T2Zmc2V0ID0gdGhpcy5fY3VycmVudE1lc2hJbmRleE9mZnNldDtcclxuICAgICAgICBjb25zdCBjdXJyZW50TWVzaEluZGV4U2l6ZSA9IGluZGV4QnVmZmVyLm9jY3VwaWVkU2l6ZSAtIGN1cnJlbnRNZXNoSW5kZXhPZmZzZXQ7XHJcbiAgICAgICAgbGV0IG5ld0luZGV4QnVmZmVyU2l6ZSA9IHRoaXMuX2luaXRJbmRleEJ1ZmZlclVpbnQxNlNpemU7XHJcbiAgICAgICAgLy8gSW5pdGlhbCBpbmRleCBidWZmZXIgc2l6ZSBtYXkgYmUgdG9vIHNtYWxsIHRvIGFjY29tbW9kYXRlIHRoZSBjdXJyZW50XHJcbiAgICAgICAgLy8gbWVzaCwgc28gd2UgZmluZCBuZXh0IGJpZ2dlciBzaXplIHRoYXQgaXMgc3VmZmljaWVudC5cclxuICAgICAgICB3aGlsZSAobmV3SW5kZXhCdWZmZXJTaXplIDw9IGN1cnJlbnRNZXNoSW5kZXhTaXplKSB7XHJcbiAgICAgICAgICAgIG5ld0luZGV4QnVmZmVyU2l6ZSA9IHRoaXMuX2dldE5leHRJbmRleEJ1ZmZlclVpbnQxNlNpemUobmV3SW5kZXhCdWZmZXJTaXplKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbmV3SW5kZXhCdWZmZXIgPSBuZXcgSW5kZXhCdWZmZXIobmV3SW5kZXhCdWZmZXJTaXplKTtcclxuICAgICAgICAvLyBTaW5jZSB0aGUgY3VycmVudCBtZXNoJ3MgY29waWVkIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIG5ldyB2ZXJ0ZXhcclxuICAgICAgICAvLyBidWZmZXIsIGl0J3MgYmFzZSBpbmRleCBub3cgaXMgMC4gSWYgdGhlIG1lc2ggaGFzIGFueSB3cml0dGVuIGluZGljZXMsXHJcbiAgICAgICAgLy8gdGhleSdyZSBhbHJlYWR5IG9mZnNldCBieSB0aGUgb2xkIGJhc2UgaW5kZXguXHJcbiAgICAgICAgSW5kZXhCdWZmZXIudHJhbnNmZXJEYXRhVGFpbChpbmRleEJ1ZmZlciwgbmV3SW5kZXhCdWZmZXIsIHRoaXMuX2N1cnJlbnRNZXNoQmFzZUluZGV4LCBjdXJyZW50TWVzaEluZGV4T2Zmc2V0KTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50TWVzaEJhc2VJbmRleCA9IDA7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudE1lc2hJbmRleE9mZnNldCA9IDA7XHJcbiAgICAgICAgdGhpcy5faW5kZXhCdWZmZXIgPSBuZXdJbmRleEJ1ZmZlcjtcclxuICAgICAgICB0aGlzLl9pbmRleEJ1ZmZlcnMucHVzaChuZXdJbmRleEJ1ZmZlcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVuc3VyZXMgdGhhdCB0aGUgbWFuYWdlZCBpbmRleCBidWZmZXIgaGFzIGVub3VnaCBzcGFjZSB0byBmaXQgaW4gYSBnaXZlblxyXG4gICAgICogbnVtYmVyIG9mIGluZGljZXMuIEVpdGhlciBkb2VzIG5vdGhpbmcgb3IgcmVzaXplcyB0aGUgY3VycmVudCBpbmRleFxyXG4gICAgICogYnVmZmVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpbmRleENvdW50IE51bWJlciBvZiBpbmRpY2VzIGNsaWVudCB3YW50cyB0byB3cml0ZSB0byB0aGUgbWFuYWdlZFxyXG4gICAgICogICAgICBpbmRleCBidWZmZXIuXHJcbiAgICAgKi9cclxuICAgIF9lbnN1cmVFbm91Z2hJbmRleEJ1ZmZlclNwYWNlKGluZGV4Q291bnQpIHtcclxuICAgICAgICBjb25zdCBidWZmZXIgPSB0aGlzLl9pbmRleEJ1ZmZlcjtcclxuICAgICAgICBjb25zdCByZXF1aXJlZFNpemUgPSBidWZmZXIub2NjdXBpZWRTaXplICsgaW5kZXhDb3VudDtcclxuICAgICAgICBpZiAocmVxdWlyZWRTaXplIDw9IGJ1ZmZlci5zaXplKSB7XHJcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgZW5vdWdoIHNwYWNlIHNvIG5vdGhpbmcgdG8gYmUgZG9uZS5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgbmV3QnVmZmVyU2l6ZSA9IGJ1ZmZlci5zaXplO1xyXG4gICAgICAgIC8vIExldCdzIGNvbXB1dGUgbmV3IGxhcmdlciBzaXplIG9mIHRoZSBpbmRleCBidWZmZXIgdW50aWwgd2UgY2FuXHJcbiAgICAgICAgLy8gYWNjb21tb2RhdGUgaW5jb21pbmcgZGF0YS5cclxuICAgICAgICB3aGlsZSAocmVxdWlyZWRTaXplID4gbmV3QnVmZmVyU2l6ZSkge1xyXG4gICAgICAgICAgICBuZXdCdWZmZXJTaXplID0gdGhpcy5fZ2V0TmV4dEluZGV4QnVmZmVyVWludDE2U2l6ZShuZXdCdWZmZXJTaXplKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5faW5kZXhCdWZmZXIuZXh0ZW5kKG5ld0J1ZmZlclNpemUpO1xyXG4gICAgfVxyXG59XHJcbiIsImNvbnN0IFVJTlQ4X01BWCA9IDB4ZmY7XHJcbmNvbnN0IFVJTlQxNl9NQVggPSAweGZmZmY7XHJcbmNvbnN0IFVJTlQzMl9NQVggPSAweGZmZmZmZmZmO1xyXG5leHBvcnQgZnVuY3Rpb24gZmxvYXRUb1VpbnQ4KHgpIHtcclxuICAgIHJldHVybiBVSU5UOF9NQVggKiB4IHwgMDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gZmxvYXRUb1VpbnQxNih4KSB7XHJcbiAgICByZXR1cm4geCAqIFVJTlQxNl9NQVggfCAwO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBmbG9hdFRvSW50MTYoeCkge1xyXG4gICAgcmV0dXJuICh4ICogVUlOVDE2X01BWCAtIDEpIC8gMiB8IDA7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGZsb2F0VG9VaW50MzIoeCkge1xyXG4gICAgcmV0dXJuIHggKiBVSU5UMzJfTUFYIHwgMDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gZmxvYXRUb0ludDMyKHgpIHtcclxuICAgIHJldHVybiAoeCAqIFVJTlQzMl9NQVggLSAxKSAvIDIgfCAwO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBpbnQzMlRvRmxvYXQoeCkge1xyXG4gICAgcmV0dXJuICgyICogeCArIDEpIC8gVUlOVDMyX01BWDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gdWludDMyVG9GbG9hdCh4KSB7XHJcbiAgICByZXR1cm4geCAvIFVJTlQzMl9NQVg7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGludDE2VG9GbG9hdCh4KSB7XHJcbiAgICByZXR1cm4gKDIgKiB4ICsgMSkgLyBVSU5UMTZfTUFYO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiB1aW50MTZUb0Zsb2F0KHgpIHtcclxuICAgIHJldHVybiB4IC8gVUlOVDE2X01BWDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gdWludDhUb0Zsb2F0KHgpIHtcclxuICAgIHJldHVybiB4IC8gVUlOVDhfTUFYO1xyXG59XHJcbiIsImltcG9ydCB7IERFRkFVTFRfQ09NUEFSQVRPUiB9IGZyb20gJy4vY29tcGFyYXRvcic7XHJcbi8qKlxyXG4gKiBTd2FwcyB0d28gdmFsdWVzIGluIGFuIGFycmF5LlxyXG4gKlxyXG4gKiBAcGFyYW0gYXJyYXkgVGhlIGFycmF5LlxyXG4gKiBAcGFyYW0gaSBJbmRleCBvZiBhIHZhbHVlIHRvIGJlIHN3YXBwZWQuXHJcbiAqIEBwYXJhbSBqIEluZGV4IG9mIGEgdmFsdWUgdG8gYmUgc3dhcHBlZC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzd2FwKGFycmF5LCBpLCBqKSB7XHJcbiAgICBjb25zdCB0ID0gYXJyYXlbaV07XHJcbiAgICBhcnJheVtpXSA9IGFycmF5W2pdO1xyXG4gICAgYXJyYXlbal0gPSB0O1xyXG59XHJcbi8qKlxyXG4gKiBSZXZlcnNlcyBvcmRlciBvZiBlbGVtZW50cyBpbiBhIHJhbmdlIGluIGFuIGFycmF5LlxyXG4gKlxyXG4gKiBAcGFyYW0gYXJyYXkgVGhlIGFycmF5LlxyXG4gKiBAcGFyYW0gc3RhcnQgVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cclxuICogQHBhcmFtIGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiByZXZlcnNlKGFycmF5LCBzdGFydCA9IDAsIGVuZCA9IGFycmF5Lmxlbmd0aCkge1xyXG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0LCBqID0gZW5kIC0gMTsgaSA8IGo7ICsraSwgLS1qKSB7XHJcbiAgICAgICAgc3dhcChhcnJheSwgaSwgaik7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJvdGF0ZXMgYSByYW5nZSBvZiBlbGVtZW50cyBpbiBhbiBhcnJheSBieSBnaXZlbiBhbW91bnQuXHJcbiAqXHJcbiAqIEBwYXJhbSBhcnJheSBUaGUgYXJyYXkuXHJcbiAqIEBwYXJhbSBhbW91bnQgVGhlIGFtb3VudC5cclxuICogQHBhcmFtIHN0YXJ0IFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXHJcbiAqIEBwYXJhbSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlKGFycmF5LCBhbW91bnQgPSAxLCBzdGFydCA9IDAsIGVuZCA9IGFycmF5Lmxlbmd0aCkge1xyXG4gICAgcmV2ZXJzZShhcnJheSwgc3RhcnQsIGVuZCk7XHJcbiAgICByZXZlcnNlKGFycmF5LCBzdGFydCwgc3RhcnQgKyBhbW91bnQpO1xyXG4gICAgcmV2ZXJzZShhcnJheSwgc3RhcnQgKyBhbW91bnQsIGVuZCk7XHJcbn1cclxuLyoqXHJcbiAqIENvcGllcyBhIHJhbmdlIG9mIGVsZW1lbnRzIGZyb20gYSBzb3VyY2UgYXJyYXkgdG8gYSByYW5nZSBpbiBhIGRlc3RpbmF0aW9uXHJcbiAqIGFycmF5LlxyXG4gKlxyXG4gKiBAcGFyYW0gc3JjIFRoZSBzb3VyY2UgYXJyYXkuXHJcbiAqIEBwYXJhbSBkc3QgVGhlIGRlc3RpbmF0aW9uIGFycmF5LlxyXG4gKiBAcGFyYW0gc3JjU3RhcnQgVGhlIHN0YXJ0IG9mIHRoZSBzb3VyY2UgcmFuZ2UuXHJcbiAqIEBwYXJhbSBzcmNTdGFydCBUaGUgc3RhcnQgb2YgdGhlIHNvdXJjZSByYW5nZS5cclxuICogQHBhcmFtIGRzdFN0YXJ0IFRoZSBzdGFydCBvZiB0aGUgZGVzdGluYXRpb24gcmFuZ2UuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29weShzcmMsIGRzdCwgc3JjU3RhcnQgPSAwLCBzcmNFbmQgPSBzcmMubGVuZ3RoLCBkc3RTdGFydCA9IDApIHtcclxuICAgIGZvciAobGV0IGkgPSBzcmNTdGFydCwgaiA9IGRzdFN0YXJ0OyBpIDwgc3JjRW5kOyArK2ksICsraikge1xyXG4gICAgICAgIGRzdFtqXSA9IHNyY1tpXTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogU2h1ZmZsZXMgcmFuZG9tbHkgYSByYW5nZSBvZiBlbGVtZW50cyBpbiBhbiBhcnJheS5cclxuICpcclxuICogQHBhcmFtIGFycmF5IFRoZSBhcnJheS5cclxuICogQHBhcmFtIHN0YXJ0IFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXHJcbiAqIEBwYXJhbSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc2h1ZmZsZShhcnJheSwgc3RhcnQgPSAwLCBlbmQgPSBhcnJheS5sZW5ndGgpIHtcclxuICAgIGZvciAobGV0IGkgPSBzdGFydCwgaiA9IGkgKyAxOyBpIDwgZW5kOyArK2ksICsraikge1xyXG4gICAgICAgIHN3YXAoYXJyYXksIGksIGogKyAoTWF0aC5yYW5kb20oKSAqIChlbmQgLSBqKSB8IDApKTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgZnVuY3Rpb24gemlwKHRzLCB1cywgemlwcGVyID0gKHQsIHUpID0+IFt0LCB1XSkge1xyXG4gICAgY29uc3QgbCA9IE1hdGgubWluKHRzLmxlbmd0aCwgdXMubGVuZ3RoKTtcclxuICAgIGNvbnN0IHZzID0gbmV3IEFycmF5KGwpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyArK2kpIHtcclxuICAgICAgICB2c1tpXSA9IHppcHBlcih0c1tpXSwgdXNbaV0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZzO1xyXG59XHJcbi8qKlxyXG4gKiBDb21wYXJlcyB0d28gYXJyYXlzIGxleGljb2dyYXBoaWNhbGx5LiBUaGUgb3JkZXIgaXMgc3BlY2lmaWVkIGJlIHRoZSBjb21wYXJhdG9yIHBhcmFtZXRlci5cclxuICpcclxuICogQHBhcmFtIGNvbXBhcmF0b3IgRWxlbWVudHMgY29tcGFyYXRvciB3aXRoIHN0YW5kYXJkIHNpZ25hdHVyZS5cclxuICogQHBhcmFtIGEgVGhlIGZpcnN0IGFycmF5IHRvIGNvbXBhcmUuXHJcbiAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgYXJyYXkgdG8gY29tcGFyZS5cclxuICogQHJldHVybnMgMCBpZiBhbGwgZWxlbWVudHMgYW5kIGxlbmd0aHMgYXJlIGVxdWFsLFxyXG4gKiAgICAgIG5lZ2F0aXZlIG51bWJlciBpZiB0aGUgZmlyc3QgZWxlbWVudCBpcyBsZXNzIHRoZW4gdGhlIHNlY29uZCAobGV4aWNvZ3JhcGhpY2FsbHkpLFxyXG4gKiAgICAgIHBvc2l0aXZlIG51bWJlciBpZiB0aGUgZmlyc3QgZWxlbWVudCBpcyBncmVhdGVyIHRoZW4gdGhlIHNlY29uZCxcclxuICogICAgICBpZiBhbGwgdGhlIGVsZW1lbnRzIGFyZSBlcXVhbCB0aGUgbGVuZ3RocyBhcmUgYmVpbmcgY29tcGFyZWQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZShjb21wYXJhdG9yLCBhLCBiKSB7XHJcbiAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1pbihhLmxlbmd0aCwgYi5sZW5ndGgpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbXBhcmF0b3IoYVtpXSwgYltpXSk7XHJcbiAgICAgICAgaWYgKHJlc3VsdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBhLmxlbmd0aCAtIGIubGVuZ3RoO1xyXG59XHJcbi8qKlxyXG4gKiBTb3J0cyBhIHJhbmdlIG9mIGVsZW1lbnRzIG9mIGFuIGFycmF5IGluIHBsYWNlIHdpdGggaW5zZXJ0aW9uIHNvcnQuXHJcbiAqXHJcbiAqIEBwYXJhbSBhcnJheSBUaGUgYXJyYXkgdG8gYmUgc29ydGVkLlxyXG4gKiBAcGFyYW0gY29tcGFyYXRvciBDb21wYXJhdG9yIGZvciBhcnJheSBlbGVtZW50cy5cclxuICogQHBhcmFtIHN0YXJ0IEluZGV4IG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSByYW5nZSB0byBiZSBzb3J0ZWQuXHJcbiAqIEBwYXJhbSBlbmQgSW5kZXggb2YgYW4gZWxlbWVudCBiZWhpbmQgdGhlIGxhc3QgZWxlbWVudCBpbiB0aGUgcmFuZ2UgdG8gYmVcclxuICogICAgICBzb3J0ZWQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaW5zZXJ0aW9uU29ydChhcnJheSwgY29tcGFyYXRvciA9IERFRkFVTFRfQ09NUEFSQVRPUiwgc3RhcnQgPSAwLCBlbmQgPSBhcnJheS5sZW5ndGgpIHtcclxuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaiA9IGk7IGogPiBzdGFydCAmJiBjb21wYXJhdG9yKGFycmF5W2ogLSAxXSwgYXJyYXlbal0pID4gMDsgLS1qKSB7XHJcbiAgICAgICAgICAgIHN3YXAoYXJyYXksIGogLSAxLCBqKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuY29uc3QgQkxPQ0tfU0laRSA9IDMyO1xyXG4vKipcclxuICogTWVyZ2VzIHR3byBzb3J0ZWQgcmFuZ2VzIG9mIGFuIGFycmF5LiBTdG9yZXMgdGhlIHJlc3VsdCBpbnRvIGFub3RoZXIgb25lLlxyXG4gKlxyXG4gKiBAcGFyYW0gc3JjIFRoZSBhcnJheSB3aXRoIHRoZSByYW5nZXMgdG8gYmUgbWVyZ2VkLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSBhcnJheSB0aGUgcmVzdWx0aW5nIHJhbmdlIHdpbGwgYmUgc3RvcmVkIHRvLlxyXG4gKiBAcGFyYW0gY29tcGFyYXRvciBUaGUgY29tcGFyYXRvciBmb3IgYXJyYXkgZWxlbWVudHMuXHJcbiAqIEBwYXJhbSBzdGFydCBTdGFydCBvZiB0aGUgZmlyc3QgcmFuZ2UgdG8gYmUgbWVyZ2VkLlxyXG4gKiBAcGFyYW0gbWlkZGxlIEVuZCBvZiB0aGUgZmlyc3QgYW5kIHNpbXVsdGFuZW91c2x5IHN0YXJ0IG9mIHRoZSBzZWNvbmQgcmFuZ2VcclxuICogICAgICB0byBiZSBtZXJnZWQuXHJcbiAqIEBwYXJhbSBlbmQgRW5kIG9mIHRoZSBzZWNvbmQgcmFuZ2UgdG8gYmUgbWVyZ2VkLlxyXG4gKiBAcGFyYW0gZHN0T2Zmc2V0IE9mZnNldCBvZiBtZXJnZWQgcmFuZ2UgaW4gdGhlIHJlc3VsdCBhcnJheS5cclxuICovXHJcbmZ1bmN0aW9uIG1lcmdlKHNyYywgZHN0LCBjb21wYXJhdG9yLCBzdGFydCwgbWlkZGxlLCBlbmQsIGRzdE9mZnNldCkge1xyXG4gICAgbGV0IGkgPSBkc3RPZmZzZXQ7XHJcbiAgICBsZXQgaiA9IHN0YXJ0O1xyXG4gICAgbGV0IGsgPSBtaWRkbGU7XHJcbiAgICB3aGlsZSAoaiA8IG1pZGRsZSAmJiBrIDwgZW5kKSB7XHJcbiAgICAgICAgZHN0W2krK10gPSBjb21wYXJhdG9yKHNyY1tqXSwgc3JjW2tdKSA+IDAgPyBzcmNbaysrXSA6IHNyY1tqKytdO1xyXG4gICAgfVxyXG4gICAgY29weShzcmMsIGRzdCwgaiwgbWlkZGxlLCBpKTtcclxuICAgIGNvcHkoc3JjLCBkc3QsIGssIGVuZCwgaSk7XHJcbn1cclxuLyoqXHJcbiAqIFNvcnRzIGEgcmFuZ2Ugb2YgZWxlbWVudHMgb2YgYW4gYXJyYXkgd2l0aCBtZXJnZSBzb3J0LlxyXG4gKlxyXG4gKiBAcGFyYW0gYXJyYXkgIFRoZSBhcnJheSB0byBiZSBzb3J0ZWQuXHJcbiAqIEBwYXJhbSBjb21wYXJhdG9yIENvbXBhcmF0b3IgZm9yIGFycmF5IGVsZW1lbnRzLlxyXG4gKiBAcGFyYW0gZW5kIEluZGV4IG9mIGFuIGVsZW1lbnQgYmVoaW5kIHRoZSBsYXN0IGVsZW1lbnQgaW4gdGhlIHJhbmdlIHRvIGJlXHJcbiAqICAgICAgc29ydGVkLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlU29ydChhcnJheSwgY29tcGFyYXRvciA9IERFRkFVTFRfQ09NUEFSQVRPUiwgc3RhcnQgPSAwLCBlbmQgPSBhcnJheS5sZW5ndGgpIHtcclxuICAgIC8vIEZpcnN0IGFuZCBmb3JlbW9zdDogaWYgdGhlIHJhbmdlIGlzIHNtYWxsZXIgdGhhbiB0aGUgYmxvY2sgc2l6ZSwganVzdFxyXG4gICAgLy8gcGVyZm9ybSBpbnNlcnRpb24gc29ydCBvbiBpdC5cclxuICAgIGlmIChlbmQgLSBzdGFydCA8PSBCTE9DS19TSVpFKSB7XHJcbiAgICAgICAgaW5zZXJ0aW9uU29ydChhcnJheSwgY29tcGFyYXRvciwgc3RhcnQsIGVuZCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgLy8gRmlyc3Qgd2Ugc3BsaXQgdGhlIGdpdmVuIHJhbmdlIGludG8gc3VicmFuZ2VzIG9mIHNpemUgQkxPQ0tfU0laRSBhbmRcclxuICAgIC8vIHNvcnQgZXZlcnkgcmFuZ2Ugd2l0aCBpbnNlcnRpb24gc29ydC5cclxuICAgIHtcclxuICAgICAgICBsZXQgcyA9IHN0YXJ0O1xyXG4gICAgICAgIGxldCBlID0gcyArIEJMT0NLX1NJWkU7XHJcbiAgICAgICAgd2hpbGUgKGUgPCBlbmQpIHtcclxuICAgICAgICAgICAgaW5zZXJ0aW9uU29ydChhcnJheSwgY29tcGFyYXRvciwgcywgZSk7XHJcbiAgICAgICAgICAgIHMgPSBlO1xyXG4gICAgICAgICAgICBlICs9IEJMT0NLX1NJWkU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluc2VydGlvblNvcnQoYXJyYXksIGNvbXBhcmF0b3IsIHMsIGVuZCk7XHJcbiAgICB9XHJcbiAgICAvLyBUT0RPKGRtaWtpcyk6IEltcGxlbWVudCBpbi1wbGFjZSBtZXJnZS4gSXQgc2VlbXMgdGhlcmUncmUgcmVhc29uYWJseVxyXG4gICAgLy8gICAgICBjb21wbGV4IHNvbHV0aW9ucyBvdXQgdGhlcmUuXHJcbiAgICBjb25zdCBhdXhBcnJheSA9IG5ldyBBcnJheShlbmQgLSBzdGFydCk7XHJcbiAgICAvLyBUaGVuIHdlIG1lcmdlIGJsb2NrcyBwYWlycywgaW5jcmVhc2UgYmxvY2sgc2l6ZSBieSAyIGFuZCByZXBlYXQuXHJcbiAgICBmb3IgKGxldCBibG9ja1NpemUgPSBCTE9DS19TSVpFOyBibG9ja1NpemUgPCBlbmQgLSBzdGFydDsgYmxvY2tTaXplICs9IGJsb2NrU2l6ZSkge1xyXG4gICAgICAgIC8vIFRPRE8oZG1pa2lzKTogQmVmb3JlIGFmb3JlbWVudGlvbmVkIHRvZG8gbWF5YmUgaW1wbGVtZW50IGFycmF5XHJcbiAgICAgICAgLy8gcGluZ3BvbmdpbmcgdG8gY3V0IGRvd24gYW1vdW50IG9mIGZ1bGwgY29waWVzLlxyXG4gICAgICAgIGNvcHkoYXJyYXksIGF1eEFycmF5LCBzdGFydCwgZW5kKTtcclxuICAgICAgICBsZXQgaSA9IHN0YXJ0O1xyXG4gICAgICAgIGxldCBzID0gMDtcclxuICAgICAgICBsZXQgbSA9IGJsb2NrU2l6ZTtcclxuICAgICAgICBsZXQgZSA9IG0gKyBibG9ja1NpemU7XHJcbiAgICAgICAgd2hpbGUgKGUgPCBlbmQgLSBzdGFydCkge1xyXG4gICAgICAgICAgICBtZXJnZShhdXhBcnJheSwgYXJyYXksIGNvbXBhcmF0b3IsIHMsIG0sIGUsIGkpO1xyXG4gICAgICAgICAgICBzID0gZTtcclxuICAgICAgICAgICAgbSA9IHMgKyBibG9ja1NpemU7XHJcbiAgICAgICAgICAgIGUgPSBtICsgYmxvY2tTaXplO1xyXG4gICAgICAgICAgICBpICs9IDIgKiBibG9ja1NpemU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1lcmdlKGF1eEFycmF5LCBhcnJheSwgY29tcGFyYXRvciwgcywgTWF0aC5taW4obSwgZW5kIC0gc3RhcnQpLCBlbmQgLSBzdGFydCwgaSk7XHJcbiAgICB9XHJcbn1cclxuIiwiZXhwb3J0IGZ1bmN0aW9uIERFRkFVTFRfQ09NUEFSQVRPUihhLCBiKSB7XHJcbiAgICBpZiAoYSA+IGIpIHtcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIH1cclxuICAgIGlmIChhIDwgYikge1xyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuICAgIHJldHVybiAwO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBOVU1FUklDQUxfQ09NUEFSQVRPUihhLCBiKSB7XHJcbiAgICByZXR1cm4gYSAtIGI7XHJcbn1cclxuIiwiaW1wb3J0IGVhcmN1dCBmcm9tICdlYXJjdXQnO1xyXG4vKipcclxuICogVHJpYW5ndWxhdGVzIGNvbXBsZXggMkQgcG9seWdvbnMgd2l0aCBob2xlcy5cclxuICpcclxuICogQHBhcmFtIHBvbHlnb24gUG9seWdvbiB3aXRoIGhvbGVzIGVuY29kZWQgYXMgYSBzZXQgb2YgcmluZ3MsIHdpdGggdGhlIGZpcnN0IHJpbmcgcmVwcmVzZW50aW5nXHJcbiAqICAgICAgdGhlIG91dGVyIGNvbnRvdXIgYW5kIG90aGVycyAtIHRoZSBob2xlcy5cclxuICogQHJldHVybnMgVHJpYW5nbGUgaW5kaWNlcyB0aGF0IGNvcnJlc3BvbmQgdG8gdmVydGljZXMgb2YgYWxsIHRoZSByaW5ncyBhcyBpZiB0aGV5XHJcbiAqICAgICAgd2VyZSBmbGF0dGVuZWQgaW50byBhIHNpbmdsZSBhcnJheS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRyaWFuZ3VsYXRlKHBvbHlnb24pIHtcclxuICAgIGNvbnN0IGVhcmN1dFZlcnRpY2VzID0gW107XHJcbiAgICBjb25zdCBlYXJjdXRIb2xlcyA9IFtdO1xyXG4gICAgbGV0IHJpbmdDb29yZHNPZmZzZXQgPSAwO1xyXG4gICAgZm9yIChjb25zdCByaW5nIG9mIHBvbHlnb24pIHtcclxuICAgICAgICAvLyBza2lwIHRoZSBmaXJzdCByaW5nIHRoYXQgaXMgbm90IGEgaG9sZVxyXG4gICAgICAgIGlmIChyaW5nQ29vcmRzT2Zmc2V0ICE9PSAwKSB7XHJcbiAgICAgICAgICAgIGVhcmN1dEhvbGVzLnB1c2gocmluZ0Nvb3Jkc09mZnNldCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3QgdmVydGV4IG9mIHJpbmcpIHtcclxuICAgICAgICAgICAgZWFyY3V0VmVydGljZXMucHVzaCh2ZXJ0ZXgueCwgdmVydGV4LnkpO1xyXG4gICAgICAgICAgICByaW5nQ29vcmRzT2Zmc2V0Kys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGVhcmN1dChlYXJjdXRWZXJ0aWNlcywgZWFyY3V0SG9sZXMpO1xyXG59XHJcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBlYXJjdXQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZWFyY3V0O1xuXG5mdW5jdGlvbiBlYXJjdXQoZGF0YSwgaG9sZUluZGljZXMsIGRpbSkge1xuXG4gICAgZGltID0gZGltIHx8IDI7XG5cbiAgICB2YXIgaGFzSG9sZXMgPSBob2xlSW5kaWNlcyAmJiBob2xlSW5kaWNlcy5sZW5ndGgsXG4gICAgICAgIG91dGVyTGVuID0gaGFzSG9sZXMgPyBob2xlSW5kaWNlc1swXSAqIGRpbSA6IGRhdGEubGVuZ3RoLFxuICAgICAgICBvdXRlck5vZGUgPSBsaW5rZWRMaXN0KGRhdGEsIDAsIG91dGVyTGVuLCBkaW0sIHRydWUpLFxuICAgICAgICB0cmlhbmdsZXMgPSBbXTtcblxuICAgIGlmICghb3V0ZXJOb2RlKSByZXR1cm4gdHJpYW5nbGVzO1xuXG4gICAgdmFyIG1pblgsIG1pblksIG1heFgsIG1heFksIHgsIHksIGludlNpemU7XG5cbiAgICBpZiAoaGFzSG9sZXMpIG91dGVyTm9kZSA9IGVsaW1pbmF0ZUhvbGVzKGRhdGEsIGhvbGVJbmRpY2VzLCBvdXRlck5vZGUsIGRpbSk7XG5cbiAgICAvLyBpZiB0aGUgc2hhcGUgaXMgbm90IHRvbyBzaW1wbGUsIHdlJ2xsIHVzZSB6LW9yZGVyIGN1cnZlIGhhc2ggbGF0ZXI7IGNhbGN1bGF0ZSBwb2x5Z29uIGJib3hcbiAgICBpZiAoZGF0YS5sZW5ndGggPiA4MCAqIGRpbSkge1xuICAgICAgICBtaW5YID0gbWF4WCA9IGRhdGFbMF07XG4gICAgICAgIG1pblkgPSBtYXhZID0gZGF0YVsxXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gZGltOyBpIDwgb3V0ZXJMZW47IGkgKz0gZGltKSB7XG4gICAgICAgICAgICB4ID0gZGF0YVtpXTtcbiAgICAgICAgICAgIHkgPSBkYXRhW2kgKyAxXTtcbiAgICAgICAgICAgIGlmICh4IDwgbWluWCkgbWluWCA9IHg7XG4gICAgICAgICAgICBpZiAoeSA8IG1pblkpIG1pblkgPSB5O1xuICAgICAgICAgICAgaWYgKHggPiBtYXhYKSBtYXhYID0geDtcbiAgICAgICAgICAgIGlmICh5ID4gbWF4WSkgbWF4WSA9IHk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtaW5YLCBtaW5ZIGFuZCBpbnZTaXplIGFyZSBsYXRlciB1c2VkIHRvIHRyYW5zZm9ybSBjb29yZHMgaW50byBpbnRlZ2VycyBmb3Igei1vcmRlciBjYWxjdWxhdGlvblxuICAgICAgICBpbnZTaXplID0gTWF0aC5tYXgobWF4WCAtIG1pblgsIG1heFkgLSBtaW5ZKTtcbiAgICAgICAgaW52U2l6ZSA9IGludlNpemUgIT09IDAgPyAxIC8gaW52U2l6ZSA6IDA7XG4gICAgfVxuXG4gICAgZWFyY3V0TGlua2VkKG91dGVyTm9kZSwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUpO1xuXG4gICAgcmV0dXJuIHRyaWFuZ2xlcztcbn1cblxuLy8gY3JlYXRlIGEgY2lyY3VsYXIgZG91Ymx5IGxpbmtlZCBsaXN0IGZyb20gcG9seWdvbiBwb2ludHMgaW4gdGhlIHNwZWNpZmllZCB3aW5kaW5nIG9yZGVyXG5mdW5jdGlvbiBsaW5rZWRMaXN0KGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSwgY2xvY2t3aXNlKSB7XG4gICAgdmFyIGksIGxhc3Q7XG5cbiAgICBpZiAoY2xvY2t3aXNlID09PSAoc2lnbmVkQXJlYShkYXRhLCBzdGFydCwgZW5kLCBkaW0pID4gMCkpIHtcbiAgICAgICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gZGltKSBsYXN0ID0gaW5zZXJ0Tm9kZShpLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgbGFzdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChpID0gZW5kIC0gZGltOyBpID49IHN0YXJ0OyBpIC09IGRpbSkgbGFzdCA9IGluc2VydE5vZGUoaSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIGxhc3QpO1xuICAgIH1cblxuICAgIGlmIChsYXN0ICYmIGVxdWFscyhsYXN0LCBsYXN0Lm5leHQpKSB7XG4gICAgICAgIHJlbW92ZU5vZGUobGFzdCk7XG4gICAgICAgIGxhc3QgPSBsYXN0Lm5leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxhc3Q7XG59XG5cbi8vIGVsaW1pbmF0ZSBjb2xpbmVhciBvciBkdXBsaWNhdGUgcG9pbnRzXG5mdW5jdGlvbiBmaWx0ZXJQb2ludHMoc3RhcnQsIGVuZCkge1xuICAgIGlmICghc3RhcnQpIHJldHVybiBzdGFydDtcbiAgICBpZiAoIWVuZCkgZW5kID0gc3RhcnQ7XG5cbiAgICB2YXIgcCA9IHN0YXJ0LFxuICAgICAgICBhZ2FpbjtcbiAgICBkbyB7XG4gICAgICAgIGFnYWluID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKCFwLnN0ZWluZXIgJiYgKGVxdWFscyhwLCBwLm5leHQpIHx8IGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID09PSAwKSkge1xuICAgICAgICAgICAgcmVtb3ZlTm9kZShwKTtcbiAgICAgICAgICAgIHAgPSBlbmQgPSBwLnByZXY7XG4gICAgICAgICAgICBpZiAocCA9PT0gcC5uZXh0KSBicmVhaztcbiAgICAgICAgICAgIGFnYWluID0gdHJ1ZTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcCA9IHAubmV4dDtcbiAgICAgICAgfVxuICAgIH0gd2hpbGUgKGFnYWluIHx8IHAgIT09IGVuZCk7XG5cbiAgICByZXR1cm4gZW5kO1xufVxuXG4vLyBtYWluIGVhciBzbGljaW5nIGxvb3Agd2hpY2ggdHJpYW5ndWxhdGVzIGEgcG9seWdvbiAoZ2l2ZW4gYXMgYSBsaW5rZWQgbGlzdClcbmZ1bmN0aW9uIGVhcmN1dExpbmtlZChlYXIsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCBwYXNzKSB7XG4gICAgaWYgKCFlYXIpIHJldHVybjtcblxuICAgIC8vIGludGVybGluayBwb2x5Z29uIG5vZGVzIGluIHotb3JkZXJcbiAgICBpZiAoIXBhc3MgJiYgaW52U2l6ZSkgaW5kZXhDdXJ2ZShlYXIsIG1pblgsIG1pblksIGludlNpemUpO1xuXG4gICAgdmFyIHN0b3AgPSBlYXIsXG4gICAgICAgIHByZXYsIG5leHQ7XG5cbiAgICAvLyBpdGVyYXRlIHRocm91Z2ggZWFycywgc2xpY2luZyB0aGVtIG9uZSBieSBvbmVcbiAgICB3aGlsZSAoZWFyLnByZXYgIT09IGVhci5uZXh0KSB7XG4gICAgICAgIHByZXYgPSBlYXIucHJldjtcbiAgICAgICAgbmV4dCA9IGVhci5uZXh0O1xuXG4gICAgICAgIGlmIChpbnZTaXplID8gaXNFYXJIYXNoZWQoZWFyLCBtaW5YLCBtaW5ZLCBpbnZTaXplKSA6IGlzRWFyKGVhcikpIHtcbiAgICAgICAgICAgIC8vIGN1dCBvZmYgdGhlIHRyaWFuZ2xlXG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChwcmV2LmkgLyBkaW0pO1xuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2goZWFyLmkgLyBkaW0pO1xuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2gobmV4dC5pIC8gZGltKTtcblxuICAgICAgICAgICAgcmVtb3ZlTm9kZShlYXIpO1xuXG4gICAgICAgICAgICAvLyBza2lwcGluZyB0aGUgbmV4dCB2ZXJ0aWNlIGxlYWRzIHRvIGxlc3Mgc2xpdmVyIHRyaWFuZ2xlc1xuICAgICAgICAgICAgZWFyID0gbmV4dC5uZXh0O1xuICAgICAgICAgICAgc3RvcCA9IG5leHQubmV4dDtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBlYXIgPSBuZXh0O1xuXG4gICAgICAgIC8vIGlmIHdlIGxvb3BlZCB0aHJvdWdoIHRoZSB3aG9sZSByZW1haW5pbmcgcG9seWdvbiBhbmQgY2FuJ3QgZmluZCBhbnkgbW9yZSBlYXJzXG4gICAgICAgIGlmIChlYXIgPT09IHN0b3ApIHtcbiAgICAgICAgICAgIC8vIHRyeSBmaWx0ZXJpbmcgcG9pbnRzIGFuZCBzbGljaW5nIGFnYWluXG4gICAgICAgICAgICBpZiAoIXBhc3MpIHtcbiAgICAgICAgICAgICAgICBlYXJjdXRMaW5rZWQoZmlsdGVyUG9pbnRzKGVhciksIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCAxKTtcblxuICAgICAgICAgICAgLy8gaWYgdGhpcyBkaWRuJ3Qgd29yaywgdHJ5IGN1cmluZyBhbGwgc21hbGwgc2VsZi1pbnRlcnNlY3Rpb25zIGxvY2FsbHlcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFzcyA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGVhciA9IGN1cmVMb2NhbEludGVyc2VjdGlvbnMoZWFyLCB0cmlhbmdsZXMsIGRpbSk7XG4gICAgICAgICAgICAgICAgZWFyY3V0TGlua2VkKGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIDIpO1xuXG4gICAgICAgICAgICAvLyBhcyBhIGxhc3QgcmVzb3J0LCB0cnkgc3BsaXR0aW5nIHRoZSByZW1haW5pbmcgcG9seWdvbiBpbnRvIHR3b1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXNzID09PSAyKSB7XG4gICAgICAgICAgICAgICAgc3BsaXRFYXJjdXQoZWFyLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBjaGVjayB3aGV0aGVyIGEgcG9seWdvbiBub2RlIGZvcm1zIGEgdmFsaWQgZWFyIHdpdGggYWRqYWNlbnQgbm9kZXNcbmZ1bmN0aW9uIGlzRWFyKGVhcikge1xuICAgIHZhciBhID0gZWFyLnByZXYsXG4gICAgICAgIGIgPSBlYXIsXG4gICAgICAgIGMgPSBlYXIubmV4dDtcblxuICAgIGlmIChhcmVhKGEsIGIsIGMpID49IDApIHJldHVybiBmYWxzZTsgLy8gcmVmbGV4LCBjYW4ndCBiZSBhbiBlYXJcblxuICAgIC8vIG5vdyBtYWtlIHN1cmUgd2UgZG9uJ3QgaGF2ZSBvdGhlciBwb2ludHMgaW5zaWRlIHRoZSBwb3RlbnRpYWwgZWFyXG4gICAgdmFyIHAgPSBlYXIubmV4dC5uZXh0O1xuXG4gICAgd2hpbGUgKHAgIT09IGVhci5wcmV2KSB7XG4gICAgICAgIGlmIChwb2ludEluVHJpYW5nbGUoYS54LCBhLnksIGIueCwgYi55LCBjLngsIGMueSwgcC54LCBwLnkpICYmXG4gICAgICAgICAgICBhcmVhKHAucHJldiwgcCwgcC5uZXh0KSA+PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzRWFySGFzaGVkKGVhciwgbWluWCwgbWluWSwgaW52U2l6ZSkge1xuICAgIHZhciBhID0gZWFyLnByZXYsXG4gICAgICAgIGIgPSBlYXIsXG4gICAgICAgIGMgPSBlYXIubmV4dDtcblxuICAgIGlmIChhcmVhKGEsIGIsIGMpID49IDApIHJldHVybiBmYWxzZTsgLy8gcmVmbGV4LCBjYW4ndCBiZSBhbiBlYXJcblxuICAgIC8vIHRyaWFuZ2xlIGJib3g7IG1pbiAmIG1heCBhcmUgY2FsY3VsYXRlZCBsaWtlIHRoaXMgZm9yIHNwZWVkXG4gICAgdmFyIG1pblRYID0gYS54IDwgYi54ID8gKGEueCA8IGMueCA/IGEueCA6IGMueCkgOiAoYi54IDwgYy54ID8gYi54IDogYy54KSxcbiAgICAgICAgbWluVFkgPSBhLnkgPCBiLnkgPyAoYS55IDwgYy55ID8gYS55IDogYy55KSA6IChiLnkgPCBjLnkgPyBiLnkgOiBjLnkpLFxuICAgICAgICBtYXhUWCA9IGEueCA+IGIueCA/IChhLnggPiBjLnggPyBhLnggOiBjLngpIDogKGIueCA+IGMueCA/IGIueCA6IGMueCksXG4gICAgICAgIG1heFRZID0gYS55ID4gYi55ID8gKGEueSA+IGMueSA/IGEueSA6IGMueSkgOiAoYi55ID4gYy55ID8gYi55IDogYy55KTtcblxuICAgIC8vIHotb3JkZXIgcmFuZ2UgZm9yIHRoZSBjdXJyZW50IHRyaWFuZ2xlIGJib3g7XG4gICAgdmFyIG1pblogPSB6T3JkZXIobWluVFgsIG1pblRZLCBtaW5YLCBtaW5ZLCBpbnZTaXplKSxcbiAgICAgICAgbWF4WiA9IHpPcmRlcihtYXhUWCwgbWF4VFksIG1pblgsIG1pblksIGludlNpemUpO1xuXG4gICAgdmFyIHAgPSBlYXIucHJldlosXG4gICAgICAgIG4gPSBlYXIubmV4dFo7XG5cbiAgICAvLyBsb29rIGZvciBwb2ludHMgaW5zaWRlIHRoZSB0cmlhbmdsZSBpbiBib3RoIGRpcmVjdGlvbnNcbiAgICB3aGlsZSAocCAmJiBwLnogPj0gbWluWiAmJiBuICYmIG4ueiA8PSBtYXhaKSB7XG4gICAgICAgIGlmIChwICE9PSBlYXIucHJldiAmJiBwICE9PSBlYXIubmV4dCAmJlxuICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlKGEueCwgYS55LCBiLngsIGIueSwgYy54LCBjLnksIHAueCwgcC55KSAmJlxuICAgICAgICAgICAgYXJlYShwLnByZXYsIHAsIHAubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBwID0gcC5wcmV2WjtcblxuICAgICAgICBpZiAobiAhPT0gZWFyLnByZXYgJiYgbiAhPT0gZWFyLm5leHQgJiZcbiAgICAgICAgICAgIHBvaW50SW5UcmlhbmdsZShhLngsIGEueSwgYi54LCBiLnksIGMueCwgYy55LCBuLngsIG4ueSkgJiZcbiAgICAgICAgICAgIGFyZWEobi5wcmV2LCBuLCBuLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgbiA9IG4ubmV4dFo7XG4gICAgfVxuXG4gICAgLy8gbG9vayBmb3IgcmVtYWluaW5nIHBvaW50cyBpbiBkZWNyZWFzaW5nIHotb3JkZXJcbiAgICB3aGlsZSAocCAmJiBwLnogPj0gbWluWikge1xuICAgICAgICBpZiAocCAhPT0gZWFyLnByZXYgJiYgcCAhPT0gZWFyLm5leHQgJiZcbiAgICAgICAgICAgIHBvaW50SW5UcmlhbmdsZShhLngsIGEueSwgYi54LCBiLnksIGMueCwgYy55LCBwLngsIHAueSkgJiZcbiAgICAgICAgICAgIGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgcCA9IHAucHJldlo7XG4gICAgfVxuXG4gICAgLy8gbG9vayBmb3IgcmVtYWluaW5nIHBvaW50cyBpbiBpbmNyZWFzaW5nIHotb3JkZXJcbiAgICB3aGlsZSAobiAmJiBuLnogPD0gbWF4Wikge1xuICAgICAgICBpZiAobiAhPT0gZWFyLnByZXYgJiYgbiAhPT0gZWFyLm5leHQgJiZcbiAgICAgICAgICAgIHBvaW50SW5UcmlhbmdsZShhLngsIGEueSwgYi54LCBiLnksIGMueCwgYy55LCBuLngsIG4ueSkgJiZcbiAgICAgICAgICAgIGFyZWEobi5wcmV2LCBuLCBuLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgbiA9IG4ubmV4dFo7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8vIGdvIHRocm91Z2ggYWxsIHBvbHlnb24gbm9kZXMgYW5kIGN1cmUgc21hbGwgbG9jYWwgc2VsZi1pbnRlcnNlY3Rpb25zXG5mdW5jdGlvbiBjdXJlTG9jYWxJbnRlcnNlY3Rpb25zKHN0YXJ0LCB0cmlhbmdsZXMsIGRpbSkge1xuICAgIHZhciBwID0gc3RhcnQ7XG4gICAgZG8ge1xuICAgICAgICB2YXIgYSA9IHAucHJldixcbiAgICAgICAgICAgIGIgPSBwLm5leHQubmV4dDtcblxuICAgICAgICBpZiAoIWVxdWFscyhhLCBiKSAmJiBpbnRlcnNlY3RzKGEsIHAsIHAubmV4dCwgYikgJiYgbG9jYWxseUluc2lkZShhLCBiKSAmJiBsb2NhbGx5SW5zaWRlKGIsIGEpKSB7XG5cbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKGEuaSAvIGRpbSk7XG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChwLmkgLyBkaW0pO1xuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2goYi5pIC8gZGltKTtcblxuICAgICAgICAgICAgLy8gcmVtb3ZlIHR3byBub2RlcyBpbnZvbHZlZFxuICAgICAgICAgICAgcmVtb3ZlTm9kZShwKTtcbiAgICAgICAgICAgIHJlbW92ZU5vZGUocC5uZXh0KTtcblxuICAgICAgICAgICAgcCA9IHN0YXJ0ID0gYjtcbiAgICAgICAgfVxuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IHN0YXJ0KTtcblxuICAgIHJldHVybiBwO1xufVxuXG4vLyB0cnkgc3BsaXR0aW5nIHBvbHlnb24gaW50byB0d28gYW5kIHRyaWFuZ3VsYXRlIHRoZW0gaW5kZXBlbmRlbnRseVxuZnVuY3Rpb24gc3BsaXRFYXJjdXQoc3RhcnQsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplKSB7XG4gICAgLy8gbG9vayBmb3IgYSB2YWxpZCBkaWFnb25hbCB0aGF0IGRpdmlkZXMgdGhlIHBvbHlnb24gaW50byB0d29cbiAgICB2YXIgYSA9IHN0YXJ0O1xuICAgIGRvIHtcbiAgICAgICAgdmFyIGIgPSBhLm5leHQubmV4dDtcbiAgICAgICAgd2hpbGUgKGIgIT09IGEucHJldikge1xuICAgICAgICAgICAgaWYgKGEuaSAhPT0gYi5pICYmIGlzVmFsaWREaWFnb25hbChhLCBiKSkge1xuICAgICAgICAgICAgICAgIC8vIHNwbGl0IHRoZSBwb2x5Z29uIGluIHR3byBieSB0aGUgZGlhZ29uYWxcbiAgICAgICAgICAgICAgICB2YXIgYyA9IHNwbGl0UG9seWdvbihhLCBiKTtcblxuICAgICAgICAgICAgICAgIC8vIGZpbHRlciBjb2xpbmVhciBwb2ludHMgYXJvdW5kIHRoZSBjdXRzXG4gICAgICAgICAgICAgICAgYSA9IGZpbHRlclBvaW50cyhhLCBhLm5leHQpO1xuICAgICAgICAgICAgICAgIGMgPSBmaWx0ZXJQb2ludHMoYywgYy5uZXh0KTtcblxuICAgICAgICAgICAgICAgIC8vIHJ1biBlYXJjdXQgb24gZWFjaCBoYWxmXG4gICAgICAgICAgICAgICAgZWFyY3V0TGlua2VkKGEsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcbiAgICAgICAgICAgICAgICBlYXJjdXRMaW5rZWQoYywgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGIgPSBiLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgYSA9IGEubmV4dDtcbiAgICB9IHdoaWxlIChhICE9PSBzdGFydCk7XG59XG5cbi8vIGxpbmsgZXZlcnkgaG9sZSBpbnRvIHRoZSBvdXRlciBsb29wLCBwcm9kdWNpbmcgYSBzaW5nbGUtcmluZyBwb2x5Z29uIHdpdGhvdXQgaG9sZXNcbmZ1bmN0aW9uIGVsaW1pbmF0ZUhvbGVzKGRhdGEsIGhvbGVJbmRpY2VzLCBvdXRlck5vZGUsIGRpbSkge1xuICAgIHZhciBxdWV1ZSA9IFtdLFxuICAgICAgICBpLCBsZW4sIHN0YXJ0LCBlbmQsIGxpc3Q7XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBob2xlSW5kaWNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBzdGFydCA9IGhvbGVJbmRpY2VzW2ldICogZGltO1xuICAgICAgICBlbmQgPSBpIDwgbGVuIC0gMSA/IGhvbGVJbmRpY2VzW2kgKyAxXSAqIGRpbSA6IGRhdGEubGVuZ3RoO1xuICAgICAgICBsaXN0ID0gbGlua2VkTGlzdChkYXRhLCBzdGFydCwgZW5kLCBkaW0sIGZhbHNlKTtcbiAgICAgICAgaWYgKGxpc3QgPT09IGxpc3QubmV4dCkgbGlzdC5zdGVpbmVyID0gdHJ1ZTtcbiAgICAgICAgcXVldWUucHVzaChnZXRMZWZ0bW9zdChsaXN0KSk7XG4gICAgfVxuXG4gICAgcXVldWUuc29ydChjb21wYXJlWCk7XG5cbiAgICAvLyBwcm9jZXNzIGhvbGVzIGZyb20gbGVmdCB0byByaWdodFxuICAgIGZvciAoaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBlbGltaW5hdGVIb2xlKHF1ZXVlW2ldLCBvdXRlck5vZGUpO1xuICAgICAgICBvdXRlck5vZGUgPSBmaWx0ZXJQb2ludHMob3V0ZXJOb2RlLCBvdXRlck5vZGUubmV4dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dGVyTm9kZTtcbn1cblxuZnVuY3Rpb24gY29tcGFyZVgoYSwgYikge1xuICAgIHJldHVybiBhLnggLSBiLng7XG59XG5cbi8vIGZpbmQgYSBicmlkZ2UgYmV0d2VlbiB2ZXJ0aWNlcyB0aGF0IGNvbm5lY3RzIGhvbGUgd2l0aCBhbiBvdXRlciByaW5nIGFuZCBhbmQgbGluayBpdFxuZnVuY3Rpb24gZWxpbWluYXRlSG9sZShob2xlLCBvdXRlck5vZGUpIHtcbiAgICBvdXRlck5vZGUgPSBmaW5kSG9sZUJyaWRnZShob2xlLCBvdXRlck5vZGUpO1xuICAgIGlmIChvdXRlck5vZGUpIHtcbiAgICAgICAgdmFyIGIgPSBzcGxpdFBvbHlnb24ob3V0ZXJOb2RlLCBob2xlKTtcbiAgICAgICAgZmlsdGVyUG9pbnRzKGIsIGIubmV4dCk7XG4gICAgfVxufVxuXG4vLyBEYXZpZCBFYmVybHkncyBhbGdvcml0aG0gZm9yIGZpbmRpbmcgYSBicmlkZ2UgYmV0d2VlbiBob2xlIGFuZCBvdXRlciBwb2x5Z29uXG5mdW5jdGlvbiBmaW5kSG9sZUJyaWRnZShob2xlLCBvdXRlck5vZGUpIHtcbiAgICB2YXIgcCA9IG91dGVyTm9kZSxcbiAgICAgICAgaHggPSBob2xlLngsXG4gICAgICAgIGh5ID0gaG9sZS55LFxuICAgICAgICBxeCA9IC1JbmZpbml0eSxcbiAgICAgICAgbTtcblxuICAgIC8vIGZpbmQgYSBzZWdtZW50IGludGVyc2VjdGVkIGJ5IGEgcmF5IGZyb20gdGhlIGhvbGUncyBsZWZ0bW9zdCBwb2ludCB0byB0aGUgbGVmdDtcbiAgICAvLyBzZWdtZW50J3MgZW5kcG9pbnQgd2l0aCBsZXNzZXIgeCB3aWxsIGJlIHBvdGVudGlhbCBjb25uZWN0aW9uIHBvaW50XG4gICAgZG8ge1xuICAgICAgICBpZiAoaHkgPD0gcC55ICYmIGh5ID49IHAubmV4dC55ICYmIHAubmV4dC55ICE9PSBwLnkpIHtcbiAgICAgICAgICAgIHZhciB4ID0gcC54ICsgKGh5IC0gcC55KSAqIChwLm5leHQueCAtIHAueCkgLyAocC5uZXh0LnkgLSBwLnkpO1xuICAgICAgICAgICAgaWYgKHggPD0gaHggJiYgeCA+IHF4KSB7XG4gICAgICAgICAgICAgICAgcXggPSB4O1xuICAgICAgICAgICAgICAgIGlmICh4ID09PSBoeCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaHkgPT09IHAueSkgcmV0dXJuIHA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoeSA9PT0gcC5uZXh0LnkpIHJldHVybiBwLm5leHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG0gPSBwLnggPCBwLm5leHQueCA/IHAgOiBwLm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBvdXRlck5vZGUpO1xuXG4gICAgaWYgKCFtKSByZXR1cm4gbnVsbDtcblxuICAgIGlmIChoeCA9PT0gcXgpIHJldHVybiBtLnByZXY7IC8vIGhvbGUgdG91Y2hlcyBvdXRlciBzZWdtZW50OyBwaWNrIGxvd2VyIGVuZHBvaW50XG5cbiAgICAvLyBsb29rIGZvciBwb2ludHMgaW5zaWRlIHRoZSB0cmlhbmdsZSBvZiBob2xlIHBvaW50LCBzZWdtZW50IGludGVyc2VjdGlvbiBhbmQgZW5kcG9pbnQ7XG4gICAgLy8gaWYgdGhlcmUgYXJlIG5vIHBvaW50cyBmb3VuZCwgd2UgaGF2ZSBhIHZhbGlkIGNvbm5lY3Rpb247XG4gICAgLy8gb3RoZXJ3aXNlIGNob29zZSB0aGUgcG9pbnQgb2YgdGhlIG1pbmltdW0gYW5nbGUgd2l0aCB0aGUgcmF5IGFzIGNvbm5lY3Rpb24gcG9pbnRcblxuICAgIHZhciBzdG9wID0gbSxcbiAgICAgICAgbXggPSBtLngsXG4gICAgICAgIG15ID0gbS55LFxuICAgICAgICB0YW5NaW4gPSBJbmZpbml0eSxcbiAgICAgICAgdGFuO1xuXG4gICAgcCA9IG0ubmV4dDtcblxuICAgIHdoaWxlIChwICE9PSBzdG9wKSB7XG4gICAgICAgIGlmIChoeCA+PSBwLnggJiYgcC54ID49IG14ICYmIGh4ICE9PSBwLnggJiZcbiAgICAgICAgICAgICAgICBwb2ludEluVHJpYW5nbGUoaHkgPCBteSA/IGh4IDogcXgsIGh5LCBteCwgbXksIGh5IDwgbXkgPyBxeCA6IGh4LCBoeSwgcC54LCBwLnkpKSB7XG5cbiAgICAgICAgICAgIHRhbiA9IE1hdGguYWJzKGh5IC0gcC55KSAvIChoeCAtIHAueCk7IC8vIHRhbmdlbnRpYWxcblxuICAgICAgICAgICAgaWYgKCh0YW4gPCB0YW5NaW4gfHwgKHRhbiA9PT0gdGFuTWluICYmIHAueCA+IG0ueCkpICYmIGxvY2FsbHlJbnNpZGUocCwgaG9sZSkpIHtcbiAgICAgICAgICAgICAgICBtID0gcDtcbiAgICAgICAgICAgICAgICB0YW5NaW4gPSB0YW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH1cblxuICAgIHJldHVybiBtO1xufVxuXG4vLyBpbnRlcmxpbmsgcG9seWdvbiBub2RlcyBpbiB6LW9yZGVyXG5mdW5jdGlvbiBpbmRleEN1cnZlKHN0YXJ0LCBtaW5YLCBtaW5ZLCBpbnZTaXplKSB7XG4gICAgdmFyIHAgPSBzdGFydDtcbiAgICBkbyB7XG4gICAgICAgIGlmIChwLnogPT09IG51bGwpIHAueiA9IHpPcmRlcihwLngsIHAueSwgbWluWCwgbWluWSwgaW52U2l6ZSk7XG4gICAgICAgIHAucHJldlogPSBwLnByZXY7XG4gICAgICAgIHAubmV4dFogPSBwLm5leHQ7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gc3RhcnQpO1xuXG4gICAgcC5wcmV2Wi5uZXh0WiA9IG51bGw7XG4gICAgcC5wcmV2WiA9IG51bGw7XG5cbiAgICBzb3J0TGlua2VkKHApO1xufVxuXG4vLyBTaW1vbiBUYXRoYW0ncyBsaW5rZWQgbGlzdCBtZXJnZSBzb3J0IGFsZ29yaXRobVxuLy8gaHR0cDovL3d3dy5jaGlhcmsuZ3JlZW5lbmQub3JnLnVrL35zZ3RhdGhhbS9hbGdvcml0aG1zL2xpc3Rzb3J0Lmh0bWxcbmZ1bmN0aW9uIHNvcnRMaW5rZWQobGlzdCkge1xuICAgIHZhciBpLCBwLCBxLCBlLCB0YWlsLCBudW1NZXJnZXMsIHBTaXplLCBxU2l6ZSxcbiAgICAgICAgaW5TaXplID0gMTtcblxuICAgIGRvIHtcbiAgICAgICAgcCA9IGxpc3Q7XG4gICAgICAgIGxpc3QgPSBudWxsO1xuICAgICAgICB0YWlsID0gbnVsbDtcbiAgICAgICAgbnVtTWVyZ2VzID0gMDtcblxuICAgICAgICB3aGlsZSAocCkge1xuICAgICAgICAgICAgbnVtTWVyZ2VzKys7XG4gICAgICAgICAgICBxID0gcDtcbiAgICAgICAgICAgIHBTaXplID0gMDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBpblNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIHBTaXplKys7XG4gICAgICAgICAgICAgICAgcSA9IHEubmV4dFo7XG4gICAgICAgICAgICAgICAgaWYgKCFxKSBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHFTaXplID0gaW5TaXplO1xuXG4gICAgICAgICAgICB3aGlsZSAocFNpemUgPiAwIHx8IChxU2l6ZSA+IDAgJiYgcSkpIHtcblxuICAgICAgICAgICAgICAgIGlmIChwU2l6ZSAhPT0gMCAmJiAocVNpemUgPT09IDAgfHwgIXEgfHwgcC56IDw9IHEueikpIHtcbiAgICAgICAgICAgICAgICAgICAgZSA9IHA7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLm5leHRaO1xuICAgICAgICAgICAgICAgICAgICBwU2l6ZS0tO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGUgPSBxO1xuICAgICAgICAgICAgICAgICAgICBxID0gcS5uZXh0WjtcbiAgICAgICAgICAgICAgICAgICAgcVNpemUtLTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGFpbCkgdGFpbC5uZXh0WiA9IGU7XG4gICAgICAgICAgICAgICAgZWxzZSBsaXN0ID0gZTtcblxuICAgICAgICAgICAgICAgIGUucHJldlogPSB0YWlsO1xuICAgICAgICAgICAgICAgIHRhaWwgPSBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwID0gcTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhaWwubmV4dFogPSBudWxsO1xuICAgICAgICBpblNpemUgKj0gMjtcblxuICAgIH0gd2hpbGUgKG51bU1lcmdlcyA+IDEpO1xuXG4gICAgcmV0dXJuIGxpc3Q7XG59XG5cbi8vIHotb3JkZXIgb2YgYSBwb2ludCBnaXZlbiBjb29yZHMgYW5kIGludmVyc2Ugb2YgdGhlIGxvbmdlciBzaWRlIG9mIGRhdGEgYmJveFxuZnVuY3Rpb24gek9yZGVyKHgsIHksIG1pblgsIG1pblksIGludlNpemUpIHtcbiAgICAvLyBjb29yZHMgYXJlIHRyYW5zZm9ybWVkIGludG8gbm9uLW5lZ2F0aXZlIDE1LWJpdCBpbnRlZ2VyIHJhbmdlXG4gICAgeCA9IDMyNzY3ICogKHggLSBtaW5YKSAqIGludlNpemU7XG4gICAgeSA9IDMyNzY3ICogKHkgLSBtaW5ZKSAqIGludlNpemU7XG5cbiAgICB4ID0gKHggfCAoeCA8PCA4KSkgJiAweDAwRkYwMEZGO1xuICAgIHggPSAoeCB8ICh4IDw8IDQpKSAmIDB4MEYwRjBGMEY7XG4gICAgeCA9ICh4IHwgKHggPDwgMikpICYgMHgzMzMzMzMzMztcbiAgICB4ID0gKHggfCAoeCA8PCAxKSkgJiAweDU1NTU1NTU1O1xuXG4gICAgeSA9ICh5IHwgKHkgPDwgOCkpICYgMHgwMEZGMDBGRjtcbiAgICB5ID0gKHkgfCAoeSA8PCA0KSkgJiAweDBGMEYwRjBGO1xuICAgIHkgPSAoeSB8ICh5IDw8IDIpKSAmIDB4MzMzMzMzMzM7XG4gICAgeSA9ICh5IHwgKHkgPDwgMSkpICYgMHg1NTU1NTU1NTtcblxuICAgIHJldHVybiB4IHwgKHkgPDwgMSk7XG59XG5cbi8vIGZpbmQgdGhlIGxlZnRtb3N0IG5vZGUgb2YgYSBwb2x5Z29uIHJpbmdcbmZ1bmN0aW9uIGdldExlZnRtb3N0KHN0YXJ0KSB7XG4gICAgdmFyIHAgPSBzdGFydCxcbiAgICAgICAgbGVmdG1vc3QgPSBzdGFydDtcbiAgICBkbyB7XG4gICAgICAgIGlmIChwLnggPCBsZWZ0bW9zdC54KSBsZWZ0bW9zdCA9IHA7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gc3RhcnQpO1xuXG4gICAgcmV0dXJuIGxlZnRtb3N0O1xufVxuXG4vLyBjaGVjayBpZiBhIHBvaW50IGxpZXMgd2l0aGluIGEgY29udmV4IHRyaWFuZ2xlXG5mdW5jdGlvbiBwb2ludEluVHJpYW5nbGUoYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgcHgsIHB5KSB7XG4gICAgcmV0dXJuIChjeCAtIHB4KSAqIChheSAtIHB5KSAtIChheCAtIHB4KSAqIChjeSAtIHB5KSA+PSAwICYmXG4gICAgICAgICAgIChheCAtIHB4KSAqIChieSAtIHB5KSAtIChieCAtIHB4KSAqIChheSAtIHB5KSA+PSAwICYmXG4gICAgICAgICAgIChieCAtIHB4KSAqIChjeSAtIHB5KSAtIChjeCAtIHB4KSAqIChieSAtIHB5KSA+PSAwO1xufVxuXG4vLyBjaGVjayBpZiBhIGRpYWdvbmFsIGJldHdlZW4gdHdvIHBvbHlnb24gbm9kZXMgaXMgdmFsaWQgKGxpZXMgaW4gcG9seWdvbiBpbnRlcmlvcilcbmZ1bmN0aW9uIGlzVmFsaWREaWFnb25hbChhLCBiKSB7XG4gICAgcmV0dXJuIGEubmV4dC5pICE9PSBiLmkgJiYgYS5wcmV2LmkgIT09IGIuaSAmJiAhaW50ZXJzZWN0c1BvbHlnb24oYSwgYikgJiZcbiAgICAgICAgICAgbG9jYWxseUluc2lkZShhLCBiKSAmJiBsb2NhbGx5SW5zaWRlKGIsIGEpICYmIG1pZGRsZUluc2lkZShhLCBiKTtcbn1cblxuLy8gc2lnbmVkIGFyZWEgb2YgYSB0cmlhbmdsZVxuZnVuY3Rpb24gYXJlYShwLCBxLCByKSB7XG4gICAgcmV0dXJuIChxLnkgLSBwLnkpICogKHIueCAtIHEueCkgLSAocS54IC0gcC54KSAqIChyLnkgLSBxLnkpO1xufVxuXG4vLyBjaGVjayBpZiB0d28gcG9pbnRzIGFyZSBlcXVhbFxuZnVuY3Rpb24gZXF1YWxzKHAxLCBwMikge1xuICAgIHJldHVybiBwMS54ID09PSBwMi54ICYmIHAxLnkgPT09IHAyLnk7XG59XG5cbi8vIGNoZWNrIGlmIHR3byBzZWdtZW50cyBpbnRlcnNlY3RcbmZ1bmN0aW9uIGludGVyc2VjdHMocDEsIHExLCBwMiwgcTIpIHtcbiAgICBpZiAoKGVxdWFscyhwMSwgcTEpICYmIGVxdWFscyhwMiwgcTIpKSB8fFxuICAgICAgICAoZXF1YWxzKHAxLCBxMikgJiYgZXF1YWxzKHAyLCBxMSkpKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gYXJlYShwMSwgcTEsIHAyKSA+IDAgIT09IGFyZWEocDEsIHExLCBxMikgPiAwICYmXG4gICAgICAgICAgIGFyZWEocDIsIHEyLCBwMSkgPiAwICE9PSBhcmVhKHAyLCBxMiwgcTEpID4gMDtcbn1cblxuLy8gY2hlY2sgaWYgYSBwb2x5Z29uIGRpYWdvbmFsIGludGVyc2VjdHMgYW55IHBvbHlnb24gc2VnbWVudHNcbmZ1bmN0aW9uIGludGVyc2VjdHNQb2x5Z29uKGEsIGIpIHtcbiAgICB2YXIgcCA9IGE7XG4gICAgZG8ge1xuICAgICAgICBpZiAocC5pICE9PSBhLmkgJiYgcC5uZXh0LmkgIT09IGEuaSAmJiBwLmkgIT09IGIuaSAmJiBwLm5leHQuaSAhPT0gYi5pICYmXG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0cyhwLCBwLm5leHQsIGEsIGIpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBhKTtcblxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLy8gY2hlY2sgaWYgYSBwb2x5Z29uIGRpYWdvbmFsIGlzIGxvY2FsbHkgaW5zaWRlIHRoZSBwb2x5Z29uXG5mdW5jdGlvbiBsb2NhbGx5SW5zaWRlKGEsIGIpIHtcbiAgICByZXR1cm4gYXJlYShhLnByZXYsIGEsIGEubmV4dCkgPCAwID9cbiAgICAgICAgYXJlYShhLCBiLCBhLm5leHQpID49IDAgJiYgYXJlYShhLCBhLnByZXYsIGIpID49IDAgOlxuICAgICAgICBhcmVhKGEsIGIsIGEucHJldikgPCAwIHx8IGFyZWEoYSwgYS5uZXh0LCBiKSA8IDA7XG59XG5cbi8vIGNoZWNrIGlmIHRoZSBtaWRkbGUgcG9pbnQgb2YgYSBwb2x5Z29uIGRpYWdvbmFsIGlzIGluc2lkZSB0aGUgcG9seWdvblxuZnVuY3Rpb24gbWlkZGxlSW5zaWRlKGEsIGIpIHtcbiAgICB2YXIgcCA9IGEsXG4gICAgICAgIGluc2lkZSA9IGZhbHNlLFxuICAgICAgICBweCA9IChhLnggKyBiLngpIC8gMixcbiAgICAgICAgcHkgPSAoYS55ICsgYi55KSAvIDI7XG4gICAgZG8ge1xuICAgICAgICBpZiAoKChwLnkgPiBweSkgIT09IChwLm5leHQueSA+IHB5KSkgJiYgcC5uZXh0LnkgIT09IHAueSAmJlxuICAgICAgICAgICAgICAgIChweCA8IChwLm5leHQueCAtIHAueCkgKiAocHkgLSBwLnkpIC8gKHAubmV4dC55IC0gcC55KSArIHAueCkpXG4gICAgICAgICAgICBpbnNpZGUgPSAhaW5zaWRlO1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IGEpO1xuXG4gICAgcmV0dXJuIGluc2lkZTtcbn1cblxuLy8gbGluayB0d28gcG9seWdvbiB2ZXJ0aWNlcyB3aXRoIGEgYnJpZGdlOyBpZiB0aGUgdmVydGljZXMgYmVsb25nIHRvIHRoZSBzYW1lIHJpbmcsIGl0IHNwbGl0cyBwb2x5Z29uIGludG8gdHdvO1xuLy8gaWYgb25lIGJlbG9uZ3MgdG8gdGhlIG91dGVyIHJpbmcgYW5kIGFub3RoZXIgdG8gYSBob2xlLCBpdCBtZXJnZXMgaXQgaW50byBhIHNpbmdsZSByaW5nXG5mdW5jdGlvbiBzcGxpdFBvbHlnb24oYSwgYikge1xuICAgIHZhciBhMiA9IG5ldyBOb2RlKGEuaSwgYS54LCBhLnkpLFxuICAgICAgICBiMiA9IG5ldyBOb2RlKGIuaSwgYi54LCBiLnkpLFxuICAgICAgICBhbiA9IGEubmV4dCxcbiAgICAgICAgYnAgPSBiLnByZXY7XG5cbiAgICBhLm5leHQgPSBiO1xuICAgIGIucHJldiA9IGE7XG5cbiAgICBhMi5uZXh0ID0gYW47XG4gICAgYW4ucHJldiA9IGEyO1xuXG4gICAgYjIubmV4dCA9IGEyO1xuICAgIGEyLnByZXYgPSBiMjtcblxuICAgIGJwLm5leHQgPSBiMjtcbiAgICBiMi5wcmV2ID0gYnA7XG5cbiAgICByZXR1cm4gYjI7XG59XG5cbi8vIGNyZWF0ZSBhIG5vZGUgYW5kIG9wdGlvbmFsbHkgbGluayBpdCB3aXRoIHByZXZpb3VzIG9uZSAoaW4gYSBjaXJjdWxhciBkb3VibHkgbGlua2VkIGxpc3QpXG5mdW5jdGlvbiBpbnNlcnROb2RlKGksIHgsIHksIGxhc3QpIHtcbiAgICB2YXIgcCA9IG5ldyBOb2RlKGksIHgsIHkpO1xuXG4gICAgaWYgKCFsYXN0KSB7XG4gICAgICAgIHAucHJldiA9IHA7XG4gICAgICAgIHAubmV4dCA9IHA7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBwLm5leHQgPSBsYXN0Lm5leHQ7XG4gICAgICAgIHAucHJldiA9IGxhc3Q7XG4gICAgICAgIGxhc3QubmV4dC5wcmV2ID0gcDtcbiAgICAgICAgbGFzdC5uZXh0ID0gcDtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZU5vZGUocCkge1xuICAgIHAubmV4dC5wcmV2ID0gcC5wcmV2O1xuICAgIHAucHJldi5uZXh0ID0gcC5uZXh0O1xuXG4gICAgaWYgKHAucHJldlopIHAucHJldloubmV4dFogPSBwLm5leHRaO1xuICAgIGlmIChwLm5leHRaKSBwLm5leHRaLnByZXZaID0gcC5wcmV2Wjtcbn1cblxuZnVuY3Rpb24gTm9kZShpLCB4LCB5KSB7XG4gICAgLy8gdmVydGljZSBpbmRleCBpbiBjb29yZGluYXRlcyBhcnJheVxuICAgIHRoaXMuaSA9IGk7XG5cbiAgICAvLyB2ZXJ0ZXggY29vcmRpbmF0ZXNcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG5cbiAgICAvLyBwcmV2aW91cyBhbmQgbmV4dCB2ZXJ0aWNlIG5vZGVzIGluIGEgcG9seWdvbiByaW5nXG4gICAgdGhpcy5wcmV2ID0gbnVsbDtcbiAgICB0aGlzLm5leHQgPSBudWxsO1xuXG4gICAgLy8gei1vcmRlciBjdXJ2ZSB2YWx1ZVxuICAgIHRoaXMueiA9IG51bGw7XG5cbiAgICAvLyBwcmV2aW91cyBhbmQgbmV4dCBub2RlcyBpbiB6LW9yZGVyXG4gICAgdGhpcy5wcmV2WiA9IG51bGw7XG4gICAgdGhpcy5uZXh0WiA9IG51bGw7XG5cbiAgICAvLyBpbmRpY2F0ZXMgd2hldGhlciB0aGlzIGlzIGEgc3RlaW5lciBwb2ludFxuICAgIHRoaXMuc3RlaW5lciA9IGZhbHNlO1xufVxuXG4vLyByZXR1cm4gYSBwZXJjZW50YWdlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgcG9seWdvbiBhcmVhIGFuZCBpdHMgdHJpYW5ndWxhdGlvbiBhcmVhO1xuLy8gdXNlZCB0byB2ZXJpZnkgY29ycmVjdG5lc3Mgb2YgdHJpYW5ndWxhdGlvblxuZWFyY3V0LmRldmlhdGlvbiA9IGZ1bmN0aW9uIChkYXRhLCBob2xlSW5kaWNlcywgZGltLCB0cmlhbmdsZXMpIHtcbiAgICB2YXIgaGFzSG9sZXMgPSBob2xlSW5kaWNlcyAmJiBob2xlSW5kaWNlcy5sZW5ndGg7XG4gICAgdmFyIG91dGVyTGVuID0gaGFzSG9sZXMgPyBob2xlSW5kaWNlc1swXSAqIGRpbSA6IGRhdGEubGVuZ3RoO1xuXG4gICAgdmFyIHBvbHlnb25BcmVhID0gTWF0aC5hYnMoc2lnbmVkQXJlYShkYXRhLCAwLCBvdXRlckxlbiwgZGltKSk7XG4gICAgaWYgKGhhc0hvbGVzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBob2xlSW5kaWNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gaG9sZUluZGljZXNbaV0gKiBkaW07XG4gICAgICAgICAgICB2YXIgZW5kID0gaSA8IGxlbiAtIDEgPyBob2xlSW5kaWNlc1tpICsgMV0gKiBkaW0gOiBkYXRhLmxlbmd0aDtcbiAgICAgICAgICAgIHBvbHlnb25BcmVhIC09IE1hdGguYWJzKHNpZ25lZEFyZWEoZGF0YSwgc3RhcnQsIGVuZCwgZGltKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdHJpYW5nbGVzQXJlYSA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IHRyaWFuZ2xlcy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICB2YXIgYSA9IHRyaWFuZ2xlc1tpXSAqIGRpbTtcbiAgICAgICAgdmFyIGIgPSB0cmlhbmdsZXNbaSArIDFdICogZGltO1xuICAgICAgICB2YXIgYyA9IHRyaWFuZ2xlc1tpICsgMl0gKiBkaW07XG4gICAgICAgIHRyaWFuZ2xlc0FyZWEgKz0gTWF0aC5hYnMoXG4gICAgICAgICAgICAoZGF0YVthXSAtIGRhdGFbY10pICogKGRhdGFbYiArIDFdIC0gZGF0YVthICsgMV0pIC1cbiAgICAgICAgICAgIChkYXRhW2FdIC0gZGF0YVtiXSkgKiAoZGF0YVtjICsgMV0gLSBkYXRhW2EgKyAxXSkpO1xuICAgIH1cblxuICAgIHJldHVybiBwb2x5Z29uQXJlYSA9PT0gMCAmJiB0cmlhbmdsZXNBcmVhID09PSAwID8gMCA6XG4gICAgICAgIE1hdGguYWJzKCh0cmlhbmdsZXNBcmVhIC0gcG9seWdvbkFyZWEpIC8gcG9seWdvbkFyZWEpO1xufTtcblxuZnVuY3Rpb24gc2lnbmVkQXJlYShkYXRhLCBzdGFydCwgZW5kLCBkaW0pIHtcbiAgICB2YXIgc3VtID0gMDtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQsIGogPSBlbmQgLSBkaW07IGkgPCBlbmQ7IGkgKz0gZGltKSB7XG4gICAgICAgIHN1bSArPSAoZGF0YVtqXSAtIGRhdGFbaV0pICogKGRhdGFbaSArIDFdICsgZGF0YVtqICsgMV0pO1xuICAgICAgICBqID0gaTtcbiAgICB9XG4gICAgcmV0dXJuIHN1bTtcbn1cblxuLy8gdHVybiBhIHBvbHlnb24gaW4gYSBtdWx0aS1kaW1lbnNpb25hbCBhcnJheSBmb3JtIChlLmcuIGFzIGluIEdlb0pTT04pIGludG8gYSBmb3JtIEVhcmN1dCBhY2NlcHRzXG5lYXJjdXQuZmxhdHRlbiA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIGRpbSA9IGRhdGFbMF1bMF0ubGVuZ3RoLFxuICAgICAgICByZXN1bHQgPSB7dmVydGljZXM6IFtdLCBob2xlczogW10sIGRpbWVuc2lvbnM6IGRpbX0sXG4gICAgICAgIGhvbGVJbmRleCA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkYXRhW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBkID0gMDsgZCA8IGRpbTsgZCsrKSByZXN1bHQudmVydGljZXMucHVzaChkYXRhW2ldW2pdW2RdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgIGhvbGVJbmRleCArPSBkYXRhW2kgLSAxXS5sZW5ndGg7XG4gICAgICAgICAgICByZXN1bHQuaG9sZXMucHVzaChob2xlSW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuIiwiaW1wb3J0IHsgQXR0cmlidXRlTWFwcGluZyB9IGZyb20gJy4uLy4uL3JlbmRlci9hdHRyaWJfbWFwcGluZyc7XHJcbi8qKlxyXG4gKiBEZXNjcmlwdGlvbiBvZiBob3cgYXR0cmlidXRlcyBvZiB2ZXJ0aWNlcyBhcmUgcGFja2VkIGludG8gYSB2ZXJ0ZXggYnVmZmVyLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IFBPTFlHT05fQVRUUklCVVRFX01BUFBJTkcgPSBuZXcgQXR0cmlidXRlTWFwcGluZyhbXHJcbiAgICBbXHJcbiAgICAgICAgMCAvKiBQT1NJVElPTl9ISUdIICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMixcclxuICAgICAgICAgICAgdHlwZTogNTEyMyAvKiBVTlNJR05FRF9TSE9SVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgMSAvKiBQT1NJVElPTl9MT1cgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIzIC8qIFVOU0lHTkVEX1NIT1JUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICA3IC8qIENPTE9SICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogNCxcclxuICAgICAgICAgICAgdHlwZTogNTEyMSAvKiBVTlNJR05FRF9CWVRFICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICAxMCAvKiBaX0lOREVYICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMSxcclxuICAgICAgICAgICAgdHlwZTogNTEyNiAvKiBGTE9BVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICBdXHJcbl0pO1xyXG4iLCJpbXBvcnQgeyBtYXBJdGVyYWJsZSB9IGZyb20gJy4uL3V0aWwvaXRlcmFibGUnO1xyXG5pbXBvcnQgeyBhbGlnbiB9IGZyb20gJy4uL3V0aWwvcG93X29mXzInO1xyXG4vKipcclxuICogR2l2ZXMgc2l6ZSBvZiBhIEdMIHR5cGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB0eXBlIFRoZSB0eXBlLlxyXG4gKiBAcmV0dXJucyBTaXplIG9mIHRoZSB0eXBlIGluIGJ5dGVzLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0VHlwZVNpemUodHlwZSkge1xyXG4gICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgY2FzZSA1MTIwIC8qIEJZVEUgKi86XHJcbiAgICAgICAgY2FzZSA1MTIxIC8qIFVOU0lHTkVEX0JZVEUgKi86XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIGNhc2UgNTEyMiAvKiBTSE9SVCAqLzpcclxuICAgICAgICBjYXNlIDUxMjMgLyogVU5TSUdORURfU0hPUlQgKi86XHJcbiAgICAgICAgICAgIHJldHVybiAyO1xyXG4gICAgICAgIGNhc2UgNTEyNCAvKiBJTlQgKi86XHJcbiAgICAgICAgY2FzZSA1MTI1IC8qIFVOU0lHTkVEX0lOVCAqLzpcclxuICAgICAgICBjYXNlIDUxMjYgLyogRkxPQVQgKi86XHJcbiAgICAgICAgICAgIHJldHVybiA0O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBEZXNjcmlwdGlvbiBvZiBob3cgcGFydGljdWxhciBhdHRyaWJ1dGVzIG9mIGEgdmVydGV4IGFyZSBwYWNrZWQgaW50byBhIHZlcnRleFxyXG4gKiBidWZmZXIuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQXR0cmlidXRlTWFwcGluZyBleHRlbmRzIE1hcCB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgYXR0cmlidXRlIG1hcHBpbmcgd2l0aCBhIHNldCBvZiBhdHRyaWJ1dGVzIG9mIGdpdmVuIHR5cGVzIGFuZFxyXG4gICAgICogc2l6ZXMuIEF1dG9tYXRpY2FsbHkgY29tcHV0ZXMgb2Zmc2V0cyBvZiB0aGUgYXR0cmlidXRlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbWFwcGluZyBUaGUgbWFwcGluZyBmcm9tIGF0dHJpYnV0ZSBJRHMgdG8gdHlwZXMgYW5kIHNpemVzLlxyXG4gICAgICogQHBhcmFtIGFsaWdubWVudCBEZXNpcmVkIGFsaWdubWVudCBvZiBhdHRyaWJ1dGVzIGluIHRoZSB2ZXJ0ZXggZGF0YVxyXG4gICAgICogICAgICBzdHJ1Y3R1cmUuIE11c3QgYmUgYSBwb3dlciBvZiAyLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihtYXBwaW5nLCBhbGlnbm1lbnQgPSA0IC8qIEFMSUdOXzRfQllURVMgKi8pIHtcclxuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcclxuICAgICAgICBzdXBlcihtYXBJdGVyYWJsZShtYXBwaW5nLCAoW2lkeCwgeyB0eXBlLCBzaXplLCBub3JtYWxpemVkIH1dKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBvaW50ZXIgPSBbXHJcbiAgICAgICAgICAgICAgICBpZHgsXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZSxcclxuICAgICAgICAgICAgICAgICAgICBzaXplLFxyXG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZVNpemUgPSBzaXplICogZ2V0VHlwZVNpemUodHlwZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld09mZnNldCA9IGFsaWduKG9mZnNldCArIGF0dHJpYnV0ZVNpemUsIC1hbGlnbm1lbnQpO1xyXG4gICAgICAgICAgICAvLyBUT0RPKGRtaWtpcykgQ2hlY2sgdGhpcyBpbiBkZWJ1ZyBtb2RlLlxyXG4gICAgICAgICAgICAvLyBpZiAobmV3T2Zmc2V0IC0gb2Zmc2V0ID4gYXR0cmlidXRlU2l6ZSkge1xyXG4gICAgICAgICAgICAvLyAgICBjb25zb2xlLndhcm4oYCR7bmV3T2Zmc2V0IC0gb2Zmc2V0fSBieXRlIHBhZGRpbmcncyBpbnNlcnRlZGApO1xyXG4gICAgICAgICAgICAvLyB9XHJcbiAgICAgICAgICAgIG9mZnNldCA9IG5ld09mZnNldDtcclxuICAgICAgICAgICAgcmV0dXJuIHBvaW50ZXI7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIHRoaXMudmVydGV4Qnl0ZVNpemUgPSBvZmZzZXQ7XHJcbiAgICB9XHJcbn1cclxuIiwiLyoqXHJcbiAqIFNlYXJjaGVzIGZvciB0aGUgZmlyc3QgY29sbGVjdGlvbiBpdGVtIHNhdGlzZnlpbmcgYSBwcmVkaWNhdGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uLlxyXG4gKiBAcGFyYW0gcHJlZGljYXRlIFRoZSBwcmVkaWNhdGUuXHJcbiAqIEByZXR1cm5zIFRoZSBmaXJzdCBpdGVtIHNhdGlzZnlpbmcgdGhlIHByZWRpY2F0ZSBvciBgdW5kZWZpbmVkYCBpZiBub25lIGZvdW5kLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRJbkl0ZXJhYmxlKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xyXG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGNvbGxlY3Rpb24pIHtcclxuICAgICAgICBpZiAocHJlZGljYXRlKGl0ZW0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybjtcclxufVxyXG4vKipcclxuICogVHJhbnNmb3JtcyBhIGNvbGxlY3Rpb24gdG8gYW5vdGhlciBvbmUuXHJcbiAqXHJcbiAqIEBwYXJhbSBjb2xsZWN0aW9uIFRoZSBzb3VyY2UgY29sbGVjdGlvbi5cclxuICogQHBhcmFtIG1hcHBlciBBIGZ1bmN0aW9uIHByb2R1Y2luZyBpdGVtcyBmb3IgZGVzdGluYXRpb24gY29sbGVjdGlvbi5cclxuICogQHJldHVybnMgQ29sbGVjdGlvbiBvZiBwcm9kdWNlZCBpdGVtcy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiogbWFwSXRlcmFibGUoY29sbGVjdGlvbiwgbWFwcGVyKSB7XHJcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgY29sbGVjdGlvbikge1xyXG4gICAgICAgIHlpZWxkIG1hcHBlcihpdGVtKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ2hvb3NlcyBpdGVtcyBvZiBhIGNvbGxlY3Rpb24gc2F0aXNmeWluZyBhIHByZWRpY2F0ZS5cclxuICpcclxuICogQHBhcmFtIGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24uXHJcbiAqIEBwYXJhbSBwcmVkaWNhdGUgVGhlIHByZWRpY2F0ZS5cclxuICogQHJldHVybnMgQ29sbGVjdGlvbiBvZiBjaG9zZW4gaXRlbXMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24qIGZpbHRlckl0ZXJhYmxlKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xyXG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGNvbGxlY3Rpb24pIHtcclxuICAgICAgICBpZiAocHJlZGljYXRlKGl0ZW0pKSB7XHJcbiAgICAgICAgICAgIHlpZWxkIGl0ZW07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUcmF2ZXJzZXMgYSBjb2xsZWN0aW9uIGZyb20gbGVmdCB0byByaWdodCByZWNvbXB1dGluZyBhbiBhY2N1bXVsYXRvciBvbiBldmVyeVxyXG4gKiBpdGVyYXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uLlxyXG4gKiBAcGFyYW0gcmVkdWNlciBUaGUgZnVuY3Rpb24gdXNlZCB0byBjb21wdXRlIG5leHQgdmFsdWUgb2YgdGhlIGFjY3VtdWxhdG9yLlxyXG4gKiBAcGFyYW0gaW5pdGlhbFxyXG4gKiBAcmV0dXJucyBWYWx1ZSBvZiB0aGUgYWNjdW11bGF0b3IuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcmVkdWNlSXRlcmFibGUoY29sbGVjdGlvbiwgcmVkdWNlciwgaW5pdGlhbCkge1xyXG4gICAgbGV0IHJlc3VsdCA9IGluaXRpYWw7XHJcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgY29sbGVjdGlvbikge1xyXG4gICAgICAgIHJlc3VsdCA9IHJlZHVjZXIocmVzdWx0LCBpdGVtKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuLyoqXHJcbiAqIENoZWNrcyBpZiB0aGVyZSdzIGF0IGxlYXN0IG9uZSBpdGVtIGluIGEgY29sbGVjdGlvbiBzYXRpc2Z5aW5nIGEgcHJlZGljYXRlLlxyXG4gKlxyXG4gKiBAcGFyYW0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbi5cclxuICogQHBhcmFtIHByZWRpY2F0ZSBUaGUgcHJlZGljYXRlLlxyXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgZm9yIGF0IGxlYXN0IG9uZSBpdGVtIGluIHRoZSBjb2xsZWN0aW9uIHRoZSBwcmVkaWNhdGUgcmV0dXJuc1xyXG4gKiAgICAgIGB0cnVlYCBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gb25lT2ZJdGVyYWJsZShjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcclxuICAgIGZvciAoY29uc3QgaXRlbSBvZiBjb2xsZWN0aW9uKSB7XHJcbiAgICAgICAgaWYgKHByZWRpY2F0ZShpdGVtKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuLyoqXHJcbiAqIENoZWNrcyBpZiBhbGwgaXRlbXMgb2YgYSBjb2xsZWN0aW9uIHNhdGlzZnkgYSBwcmVkaWNhdGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uLlxyXG4gKiBAcGFyYW0gcHJlZGljYXRlIFRoZSBwcmVkaWNhdGUuXHJcbiAqIEByZXR1cm5zIGBmYWxzZWAgaWYgZm9yIGF0IGxlYXN0IG9uZSBpdGVtIGluIHRoZSBjb2xsZWN0aW9uIHRoZSBwcmVkaWNhdGUgcmV0dXJuc1xyXG4gKiAgICAgIGBmYWxzZWAgYW5kIGB0cnVlYCBvdGhlcndpc2UuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYWxsT2ZJdGVyYWJsZShjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcclxuICAgIGZvciAoY29uc3QgaXRlbSBvZiBjb2xsZWN0aW9uKSB7XHJcbiAgICAgICAgaWYgKCFwcmVkaWNhdGUoaXRlbSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGFuIGl0ZXJhdG9yIGZvciBbc3RhcnRJbmRleCwgc3RhcnRJbmRleCtsZW5ndGgpIHJhbmdlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uKiByYW5nZUl0ZXJhYmxlKGxlbmd0aCwgc3RhcnRJbmRleCA9IDApIHtcclxuICAgIGNvbnN0IGVuZEluZGV4ID0gc3RhcnRJbmRleCArIGxlbmd0aDtcclxuICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpIDwgZW5kSW5kZXg7IGkrKykge1xyXG4gICAgICAgIHlpZWxkIGk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uKiB6aXBJdGVyYWJsZXModHMsIHVzLCB6aXBwZXIgPSAodCwgdSkgPT4gW3QsIHVdKSB7XHJcbiAgICBjb25zdCB0SXRlcmF0b3IgPSB0c1tTeW1ib2wuaXRlcmF0b3JdKCk7XHJcbiAgICBjb25zdCB1SXRlcmF0b3IgPSB1c1tTeW1ib2wuaXRlcmF0b3JdKCk7XHJcbiAgICBmb3IgKGxldCB0ID0gdEl0ZXJhdG9yLm5leHQoKSwgdSA9IHVJdGVyYXRvci5uZXh0KCk7ICEodC5kb25lIHx8IHUuZG9uZSk7IHQgPSB0SXRlcmF0b3IubmV4dCgpLCB1ID0gdUl0ZXJhdG9yLm5leHQoKSkge1xyXG4gICAgICAgIHlpZWxkIHppcHBlcih0LnZhbHVlLCB1LnZhbHVlKTtcclxuICAgIH1cclxufVxyXG4iLCIvKipcclxuICogQ2hlY2tzIGlmIGEgbnVtYmVyIGlzIGEgcG93ZXIgb2YgMi5cclxuICpcclxuICogQHBhcmFtIHggVGhlIG51bWJlciB0byBjaGVjay5cclxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBudW1iZXIgaXMgYW4gaW50ZWdlciBwb3dlciBvZiAyIGFuZCBgZmFsc2VgIG90aGVyd2lzZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1Bvd09mMih4KSB7XHJcbiAgICByZXR1cm4geCA+IDAgJiYgISh4ICYgKHggLSAxKSk7XHJcbn1cclxuLyoqXHJcbiAqIEFsaWducyBhbiBvZmZzZXQgYnkgYW4gYWxpZ25tZW50IGdpdmVuIGJ5IGEgbWFzay5cclxuICpcclxuICogQHBhcmFtIG9mZnNldCBUaGUgb2Zmc2V0LlxyXG4gKiBAcGFyYW0gYWxpZ25tZW50TWFzayBUaGUgYWxpZ25tZW50IG1hc2sg4oCUIGEgYml0IGZpZWxkIHRoYXQgaGFzIGBsb2cyKGFsaWdubWVudClgXHJcbiAqICAgICAgb2YgbGVhc3Qgc2lnbmlmaWNhbnQgYml0cyB1bnNldCBhbmQgb3RoZXIgc2V0LCBlLmcuIGlmIGBhbGlnbm1lbnRgIGlzIDRcclxuICogICAgICB0aGVuIHRoZSBgYWxpZ25tZW50TWFza2Agd2lsbCBiZSBgMHhmZmZmZmZjYFxyXG4gKiBAcmV0dXJucyBBbGlnbmVkIG9mZnNldC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBhbGlnbihvZmZzZXQsIGFsaWdubWVudE1hc2spIHtcclxuICAgIHJldHVybiAob2Zmc2V0IC0gMSAmIGFsaWdubWVudE1hc2spIC0gYWxpZ25tZW50TWFzaztcclxufVxyXG4iLCJjb25zdCBNSU5fWklOREVYID0gLTEgKyBNYXRoLnBvdygyLCAxIC0gMjQpOyAvLyBlcHNpbG9uIGlzIGFkZGVkIChmb3Igbm9ybWFsaXplZCAyNC1iaXQgdmFsdWUpIHRvIGZyZWUgdXAgcmVzZXJ2ZWQgdmFsdWVcclxuZXhwb3J0IGZ1bmN0aW9uIGludFRvWkluZGV4KHgpIHtcclxuICAgIHJldHVybiBNYXRoLm1heChNSU5fWklOREVYLCB4IC8gMHg3ZmZmZmYpO1xyXG59XHJcbiIsImltcG9ydCBCdWZmZXJXcml0ZXIgZnJvbSAnLi4vLi4vdXRpbC9idWZmZXJfd3JpdGVyJztcclxuaW1wb3J0IHRyaWFuZ3VsYXRlIGZyb20gJy4uLy4uL3V0aWwvdHJpYW5ndWxhdGUnO1xyXG5pbXBvcnQgeyBURVhUVVJFRF9QT0xZR09OX0FUVFJJQlVURV9NQVBQSU5HIH0gZnJvbSAnLi90ZXh0dXJlZF9wb2x5Z29uX2F0dHJpYnV0ZV9tYXBwaW5nJztcclxuaW1wb3J0IHsgaW50VG9aSW5kZXggfSBmcm9tICcuLi8uLi91dGlsL3pfaW5kZXgnO1xyXG4vKipcclxuICogV3JpdGVyIG9mIGdlb21ldHJ5IGRhdGEgb2YgcG9seWdvbiBpbWFnZXMuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXh0dXJlZFBvbHlnb25CdWZmZXJXcml0ZXIgZXh0ZW5kcyBCdWZmZXJXcml0ZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoVEVYVFVSRURfUE9MWUdPTl9BVFRSSUJVVEVfTUFQUElORy52ZXJ0ZXhCeXRlU2l6ZSk7XHJcbiAgICB9XHJcbiAgICB3cml0ZVBvbHlnb24ocG9seWdvbiwgaW1hZ2VMb2NhdGlvbiwgekluZGV4KSB7XHJcbiAgICAgICAgZm9yIChjb25zdCByaW5nIG9mIHBvbHlnb24udmVydGV4UmluZ3MpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCB2ZXJ0ZXggb2YgcmluZykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fd3JpdGVWZXJ0ZXgodmVydGV4LCBpbWFnZUxvY2F0aW9uLCAwLCBpbnRUb1pJbmRleCh6SW5kZXgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLndyaXRlSW5kaWNlcyh0cmlhbmd1bGF0ZShwb2x5Z29uLnZlcnRleFJpbmdzKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kTWVzaCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gcG9zaXRpb24gV29ybGQgY29vcmRpbmF0ZXMgb2YgdGhlIHZlcnRleC5cclxuICAgICAqIEBwYXJhbSBpbWFnZUxvY2F0aW9uIExvY2F0aW9uIG9mIHRoZSBwYXRlZXJuIGluIGF0bGFzLlxyXG4gICAgICogQHBhcmFtIGltYWdlU2NhbGUgSG93IHdvcmxkIGNvb3JkaW5hdGVzIHJlbGF0ZSB0byB0aGUgaW1hZ2Ugc2l6ZS5cclxuICAgICAqIEBwYXJhbSB6SW5kZXggVmVydGV4IHotY29vcmRpbmF0ZS5cclxuICAgICAqL1xyXG4gICAgX3dyaXRlVmVydGV4KHBvc2l0aW9uLCBpbWFnZUxvY2F0aW9uLCBpbWFnZVNjYWxlLCB6SW5kZXgpIHtcclxuICAgICAgICB0aGlzLl93cml0ZVdvcmxkQ29vcmRpbmF0ZShwb3NpdGlvbik7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVIYWxmV29yZHMoaW1hZ2VMb2NhdGlvbi5taW5YLCBpbWFnZUxvY2F0aW9uLm1pblkpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlSGFsZldvcmRzKGltYWdlTG9jYXRpb24ubWF4WCAtIGltYWdlTG9jYXRpb24ubWluWCwgaW1hZ2VMb2NhdGlvbi5tYXhZIC0gaW1hZ2VMb2NhdGlvbi5taW5ZKTtcclxuICAgICAgICB0aGlzLl93cml0ZUZsb2F0MzIoaW1hZ2VTY2FsZSk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVGbG9hdDMyKHpJbmRleCk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgQXR0cmlidXRlTWFwcGluZyB9IGZyb20gJy4uLy4uL3JlbmRlci9hdHRyaWJfbWFwcGluZyc7XHJcbi8qKlxyXG4gKiBEZXNjcmlwdGlvbiBvZiBob3cgYXR0cmlidXRlcyBvZiB2ZXJ0aWNlcyBhcmUgcGFja2VkIGludG8gYSB2ZXJ0ZXggYnVmZmVyLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IFRFWFRVUkVEX1BPTFlHT05fQVRUUklCVVRFX01BUFBJTkcgPSBuZXcgQXR0cmlidXRlTWFwcGluZyhbXHJcbiAgICBbXHJcbiAgICAgICAgMCAvKiBQT1NJVElPTl9ISUdIICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMixcclxuICAgICAgICAgICAgdHlwZTogNTEyMyAvKiBVTlNJR05FRF9TSE9SVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgMSAvKiBQT1NJVElPTl9MT1cgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIzIC8qIFVOU0lHTkVEX1NIT1JUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICA0IC8qIFVWICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogNCxcclxuICAgICAgICAgICAgdHlwZTogNTEyMyAvKiBVTlNJR05FRF9TSE9SVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDExIC8qIEFVWCAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDEsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjYgLyogRkxPQVQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICAxMCAvKiBaX0lOREVYICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMSxcclxuICAgICAgICAgICAgdHlwZTogNTEyNiAvKiBGTE9BVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICBdXHJcbl0pO1xyXG4iLCJpbXBvcnQgKiBhcyB2ZWMyIGZyb20gJy4uLy4uL21hdGgvdmVjdG9yMic7XHJcbmltcG9ydCB7IGVuY29kZVJnYmE4IH0gZnJvbSAnLi4vLi4vdXRpbC9jb2xvcic7XHJcbmltcG9ydCBCdWZmZXJXcml0ZXIgZnJvbSAnLi4vLi4vdXRpbC9idWZmZXJfd3JpdGVyJztcclxuaW1wb3J0IHsgUE9MWUxJTkVfQVRUUklCVVRFX01BUFBJTkcgfSBmcm9tICcuL3BvbHlsaW5lX2F0dHJpYnV0ZV9tYXBwaW5nJztcclxuaW1wb3J0IHsgZmxvYXRUb1VpbnQ4LCBmbG9hdFRvVWludDE2IH0gZnJvbSAnLi4vLi4vdXRpbC9ncHV0eXBlcyc7XHJcbmltcG9ydCB7IGludFRvWkluZGV4IH0gZnJvbSAnLi4vLi4vdXRpbC96X2luZGV4JztcclxuaW1wb3J0IHsgY2xhbXAgfSBmcm9tICcuLi8uLi9tYXRoL3NjYWxhcic7XHJcbi8qKlxyXG4gKiBDb21wdXRlcyBtaXRlciBvZiBhIGpvaW4gYmV0d2VlbiB0d28gc2VnbWVudHMuXHJcbiAqXHJcbiAqIEBwYXJhbSBuMSBOb3JtYWwgdmVjdG9yIG9mIHRoZSBmaXJzdCBzZWdtZW50LlxyXG4gKiBAcGFyYW0gbjIgTm9ybWFsIHZlY3RvciBvZiB0aGUgc2Vjb25kIHNlZ21lbnQuXHJcbiAqIEByZXR1cm5zIE1pdGVyIHZhbHVlLCBpLmUuIGJ5IGhvdyBtYXRjaCBkaXNwbGFjZW1lbnQgaXMgbG9uZ2VyIHRoYW4gYSBub3JtYWxcclxuICogICAgICBvbmUuXHJcbiAqL1xyXG5mdW5jdGlvbiBjb21wdXRlTWl0ZXIobjEsIG4yKSB7XHJcbiAgICByZXR1cm4gTWF0aC5zcXJ0KDIgLyAoMSArIHZlYzIuZG90KG4xLCBuMikpKTtcclxufVxyXG5jb25zdCBTRUdNRU5UX1ZFUlRFWF9DT1VOVCA9IDQ7XHJcbmNvbnN0IFNRVUFSRV9DQVBfVkVSVEVYX0NPVU5UID0gNTtcclxuY29uc3QgUk9VTkRfQ0FQX1ZFUlRFWF9DT1VOVCA9IDQ7XHJcbmNvbnN0IEZMT0FUX01BWCA9IDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzg7XHJcbmNvbnN0IE1JVEVSX0xJTUlUID0gNDtcclxuY29uc3QgVVZfUE9TX09ORV9QQUNLRUQgPSAyNTU7IC8vIHBhY2tlZCAxXHJcbmNvbnN0IFVWX05FR19PTkVfUEFDS0VEID0gMTsgLy8gcGFja2VkIC0xXHJcbmNvbnN0IFVWX1pFUk9fUEFDS0VEID0gMTI4O1xyXG4vKipcclxuICogUGFja3MgYSBjb21wb25lbnQgb2YgdXYgaW50byBhIHVuc2lnbmVkIDgtYml0IHZhbHVlLiBBZnRlciBwYWNraW5nIC0xIHdpbGxcclxuICogYmVjb21lIDEgYW5kIDEgd2lsbCBiZWNvbWUgMjU1LiBUaGF0J3MgbmVlZCB0byBlbXVsYXRlIHplcm8tcHJlc2VydmluZ1xyXG4gKiBub3JtYWxpemF0aW9uICh3ZSBjYW4ndCByZWx5IG9uIFdlYkdMIHRvIGRvIGl0IGZvciB1cyA6KCkuXHJcbiAqXHJcbiAqIEBwYXJhbSBjIFRoZSBjb21wb25lbnQuXHJcbiAqIEByZXR1cm5zIFBhY2tlZCBjb21wb25lbnQuXHJcbiAqL1xyXG5mdW5jdGlvbiBwYWNrVXZDb21wb25lbnQoYykge1xyXG4gICAgLy8gV2UgZG9uJ3QgdHJ1bmNhdGUgaGVyZSBiZWNhdXNlIGJ1ZmZlciB3cml0ZXIgd2lsbCBkbyB0aGF0IGZvciB1cy5cclxuICAgIHJldHVybiAxMjggKyAoMTI3ICogYyk7XHJcbn1cclxuLyoqXHJcbiAqIEhhbGYgd2lkdGggb2YgdGhlIHBvbHlsaW5lIGlzIHN0b3JlZCBpbiBhIG5vcm1hbGl6ZWQgYXR0cmlidXRlLiBUaGlzIGNvbnN0YW50XHJcbiAqIGRlZmluZXMgaGFsZiB3aWR0aCB2YWx1ZSBvZiAxIGNvcnJlc3BvbmRzIHRvLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IE1BWF9IQUxGX1dJRFRIID0gMjU1IC8gNDsgLy8gcHhcclxuLyoqXHJcbiAqIFNhbWUgYXMgZm9yIHBvbHlsaW5lIGhhbGYgd2lkdGgsIGJ1dCBmb3IgZGFzaCBwYXR0ZXJuIGRlZmluaXRpb24uXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgTUFYX0ZJTExfR0FQID0gMjU1OyAvLyBweFxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb2x5bGluZUJ1ZmZlcldyaXRlciBleHRlbmRzIEJ1ZmZlcldyaXRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcihQT0xZTElORV9BVFRSSUJVVEVfTUFQUElORy52ZXJ0ZXhCeXRlU2l6ZSk7XHJcbiAgICAgICAgdGhpcy5fZGlzcGxhY2VtZW50ID0gdmVjMi5jcmVhdGUoMCwgMCk7XHJcbiAgICAgICAgdGhpcy5fcHJldkRpc3BsYWNlbWVudCA9IHZlYzIuY3JlYXRlKDAsIDApO1xyXG4gICAgICAgIHRoaXMuX2luaXRQb2x5bGluZVN0YXRlKFt2ZWMyLlpFUk8sIHZlYzIuWkVST10sIDAsIDAsIDAsIDAsIDAgLyogTUlURVIgKi8sIDApO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZXMgYSBtZXNoIGZvciBhIHBvbHlsaW5lIHdpdGggYSBnaXZlbiBzdHlsZSwgYmFraW5nIGFsbCBuZWNlc3NhcnlcclxuICAgICAqIHBhcmFtZXRlcnMgaW50byBhdHRyaWJ1dGVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwb2x5bGluZSBUaGUgcG9seWxpbmUuXHJcbiAgICAgKiBAcGFyYW0gc3R5bGUgVGhlIHBvbHlsaW5lIHN0eWxlLlxyXG4gICAgICogQHJldHVybnMgTG9jYXRpb24gb2YgdGhlIHdyaXR0ZW4gbWVzaCBpbiB0aGUgbWFuYWdlZCBidWZmZXJzLlxyXG4gICAgICovXHJcbiAgICB3cml0ZVBvbHlsaW5lKHBvbHlsaW5lLCBzdHlsZSwgekluZGV4KSB7XHJcbiAgICAgICAgY29uc3QgeyB2ZXJ0aWNlcyB9ID0gcG9seWxpbmU7XHJcbiAgICAgICAgY29uc3QgbGFzdElkeCA9IHZlcnRpY2VzLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgaWYgKGxhc3RJZHggPCAxKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT25lIHZlcnRleCBpbiBub3QgYSBwb2x5bGluZS4gSXRcXCdzIG5vdCBldmVuIGEgbGluZS4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5faW5pdFBvbHlsaW5lU3RhdGUodmVydGljZXMsIGVuY29kZVJnYmE4KHN0eWxlLnN0cm9rZUNvbG9yKSwgc3R5bGUuc3Ryb2tlV2lkdGgsIHN0eWxlLmRhc2ggPyBzdHlsZS5kYXNoLmZpbGwgOiAwLCBzdHlsZS5kYXNoID8gc3R5bGUuZGFzaC5nYXAgOiAwLCBzdHlsZS5qb2luLCBpbnRUb1pJbmRleCh6SW5kZXgpKTtcclxuICAgICAgICB0aGlzLl93cml0ZUNhcChzdHlsZS5zdGFydENhcCwgdmVydGljZXNbMF0sIDEpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGFzdElkeDsgKytpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3dyaXRlU2VnbWVudCh2ZXJ0aWNlc1tpIC0gMV0sIHZlcnRpY2VzW2ldLCB2ZXJ0aWNlc1tpICsgMV0pO1xyXG4gICAgICAgICAgICB0aGlzLl93cml0ZUpvaW4odmVydGljZXNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl93cml0ZUxhc3RTZWdtZW50KHZlcnRpY2VzW2xhc3RJZHggLSAxXSwgdmVydGljZXNbbGFzdElkeF0pO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlQ2FwKHN0eWxlLmVuZENhcCwgdmVydGljZXNbbGFzdElkeF0sIDEpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVuZE1lc2goKTtcclxuICAgIH1cclxuICAgIF9pbml0UG9seWxpbmVTdGF0ZSh2ZXJ0aWNlcywgY29sb3JSZ2JhOCwgd2lkdGgsIGZpbGwsIGdhcCwgam9pbiwgekluZGV4KSB7XHJcbiAgICAgICAgdGhpcy5fYmFzZUluZGV4ID0gdGhpcy5fcG9seWxpbmVMZW5ndGggPSB0aGlzLl9sYXN0RGlyZWN0aW9uID0gMDtcclxuICAgICAgICB0aGlzLl9sYXN0U2lnbmVkTWl0ZXIgPSAxO1xyXG4gICAgICAgIGNvbnN0IGRpc3BsYWNlbWVudCA9IHZlYzIuc3ViKHZlcnRpY2VzWzFdLCB2ZXJ0aWNlc1swXSwgdGhpcy5fZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB0aGlzLl9zZWdtZW50TGVuZ3RoID0gdmVjMi5sZW5ndGgoZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB2ZWMyLmRpdm4oZGlzcGxhY2VtZW50LCB0aGlzLl9zZWdtZW50TGVuZ3RoLCBkaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHZlYzIucm90YXRlOTAoZGlzcGxhY2VtZW50LCBkaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHRoaXMuX2NvbG9yUmdiYTggPSBjb2xvclJnYmE4O1xyXG4gICAgICAgIHRoaXMuX2hhbGZXaWR0aEZpbGxHYXBQYWNrZWQgPVxyXG4gICAgICAgICAgICBmbG9hdFRvVWludDgoY2xhbXAoMC41ICogd2lkdGgsIDAsIE1BWF9IQUxGX1dJRFRIKSAvIE1BWF9IQUxGX1dJRFRIKSB8XHJcbiAgICAgICAgICAgICAgICBmbG9hdFRvVWludDgoY2xhbXAoZmlsbCwgMCwgTUFYX0ZJTExfR0FQKSAvIE1BWF9GSUxMX0dBUCkgPDwgOCB8XHJcbiAgICAgICAgICAgICAgICBmbG9hdFRvVWludDgoY2xhbXAoZ2FwLCAwLCBNQVhfRklMTF9HQVApIC8gTUFYX0ZJTExfR0FQKSA8PCAxNjtcclxuICAgICAgICB0aGlzLl9qb2luID0gam9pbjtcclxuICAgICAgICB0aGlzLl96SW5kZXggPSB6SW5kZXg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIHNpbmdsZSB2ZXJ0ZXggaW50byBtYW5hZ2VkIHZlcnRleCBidWZmZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBvc2l0aW9uIFZlcnRleCB3b3JsZCBwb3NpdGlvbi5cclxuICAgICAqIEBwYXJhbSBub3JtYWwgTm9ybWFsIG9mIHNlZ21lbnQgdGhlIHZlcnRleCBiZWxvbmdzIHRvLlxyXG4gICAgICogQHBhcmFtIHUgTm9ybWFsaXplZCBkaXN0YW5jZSB0byB0aGUgcG9seWxpbmUgYWxvbmcgdGhlIG5vcm1hbC5cclxuICAgICAqIEBwYXJhbSB2IE5vcm1hbGl6ZWQgZGlzdGFuY2UgdG8gdGhlIHBvbHlsaW5lIGFsb25nIHRoZSB0YW5nZW50LlxyXG4gICAgICogQHBhcmFtIHBvbHlsaW5lTGVuZ3RoIERpc3RhbmNlIHRvIHRoZSBmaXJzdCB2ZXJ0ZXggYWxvbmcgdGhlIHBvbHlsaW5lLlxyXG4gICAgICogQHBhcmFtIG1pdGVyIEpvaW4gbWl0ZXIuXHJcbiAgICAgKiBAcGFyYW0gbGVuZ3RoQ29ycmVjdGlvbkxpbWl0IExpbWl0IG9uIHRoZSB2ZXJ0ZXggZGlzcGxhY2VtZW50IGFsb25nIHRoZVxyXG4gICAgICogICAgICBwb2x5bGluZS5cclxuICAgICAqL1xyXG4gICAgX3dyaXRlVmVydGV4KHBvc2l0aW9uLCBub3JtYWwsIHVQYWNrZWQsIHZQYWNrZWQsIHBvbHlsaW5lTGVuZ3RoLCBtaXRlciwgbGVuZ3RoQ29ycmVjdGlvbkxpbWl0KSB7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVXb3JsZENvb3JkaW5hdGUocG9zaXRpb24pO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlSGFsZldvcmRzKGZsb2F0VG9VaW50MTYoMC41ICogKG5vcm1hbC54ICogTWF0aC5TUVJUMV8yICsgMSkpLCBmbG9hdFRvVWludDE2KDAuNSAqIChub3JtYWwueSAqIE1hdGguU1FSVDFfMiArIDEpKSk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVIYWxmV29yZHModVBhY2tlZCwgdlBhY2tlZCk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVXb3JkKHRoaXMuX2hhbGZXaWR0aEZpbGxHYXBQYWNrZWQpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlRmxvYXQzMihtaXRlcik7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVGbG9hdDMyKGxlbmd0aENvcnJlY3Rpb25MaW1pdCk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVGbG9hdDMyKHBvbHlsaW5lTGVuZ3RoKTtcclxuICAgICAgICB0aGlzLl93cml0ZVdvcmQodGhpcy5fY29sb3JSZ2JhOCk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVGbG9hdDMyKHRoaXMuX3pJbmRleCk7XHJcbiAgICB9XHJcbiAgICBfd3JpdGVDYXAoY2FwLCBlbmRWZXJ0ZXgsIGRpc3BsYWNlbWVudFNpZ24pIHtcclxuICAgICAgICBzd2l0Y2ggKGNhcCkge1xyXG4gICAgICAgICAgICBjYXNlIDEgLyogUk9VTkQgKi86XHJcbiAgICAgICAgICAgICAgICB0aGlzLl93cml0ZVJvdW5kQ2FwKGVuZFZlcnRleCwgZGlzcGxhY2VtZW50U2lnbik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAyIC8qIFNRVUFSRSAqLzpcclxuICAgICAgICAgICAgICAgIHRoaXMuX3dyaXRlU3F1YXJlQ2FwKGVuZFZlcnRleCwgZGlzcGxhY2VtZW50U2lnbik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfd3JpdGVSb3VuZENhcChlbmRWZXJ0ZXgsIGRpc3BsYWNlbWVudFNpZ24pIHtcclxuICAgICAgICBjb25zdCBkaXNwbGFjZW1lbnQgPSB2ZWMyLmNyZWF0ZSgwLCAwKTtcclxuICAgICAgICBjb25zdCBwb2x5bGluZUxlbmd0aCA9IHRoaXMuX3BvbHlsaW5lTGVuZ3RoO1xyXG4gICAgICAgIHZlYzIubXVsbih0aGlzLl9kaXNwbGFjZW1lbnQsIC1kaXNwbGFjZW1lbnRTaWduLCBkaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlVmVydGV4KGVuZFZlcnRleCwgZGlzcGxhY2VtZW50LCBVVl9ORUdfT05FX1BBQ0tFRCwgVVZfWkVST19QQUNLRUQsIHBvbHlsaW5lTGVuZ3RoLCAxLCBGTE9BVF9NQVgpO1xyXG4gICAgICAgIHZlYzIucm90YXRlOTAodGhpcy5fZGlzcGxhY2VtZW50LCBkaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHZlYzIuc3ViKGRpc3BsYWNlbWVudCwgdGhpcy5fZGlzcGxhY2VtZW50LCBkaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHZlYzIubXVsbihkaXNwbGFjZW1lbnQsIGRpc3BsYWNlbWVudFNpZ24sIGRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVWZXJ0ZXgoZW5kVmVydGV4LCBkaXNwbGFjZW1lbnQsIFVWX05FR19PTkVfUEFDS0VELCBVVl9QT1NfT05FX1BBQ0tFRCwgcG9seWxpbmVMZW5ndGgsIDEsIEZMT0FUX01BWCk7XHJcbiAgICAgICAgdmVjMi5tdWxuKHRoaXMuX2Rpc3BsYWNlbWVudCwgZGlzcGxhY2VtZW50U2lnbiwgZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB0aGlzLl93cml0ZVZlcnRleChlbmRWZXJ0ZXgsIGRpc3BsYWNlbWVudCwgVVZfUE9TX09ORV9QQUNLRUQsIFVWX1pFUk9fUEFDS0VELCBwb2x5bGluZUxlbmd0aCwgMSwgRkxPQVRfTUFYKTtcclxuICAgICAgICB2ZWMyLnJvdGF0ZTkwKHRoaXMuX2Rpc3BsYWNlbWVudCwgZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB2ZWMyLmFkZChkaXNwbGFjZW1lbnQsIHRoaXMuX2Rpc3BsYWNlbWVudCwgZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB2ZWMyLm11bG4oZGlzcGxhY2VtZW50LCBkaXNwbGFjZW1lbnRTaWduLCBkaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlVmVydGV4KGVuZFZlcnRleCwgZGlzcGxhY2VtZW50LCBVVl9QT1NfT05FX1BBQ0tFRCwgVVZfUE9TX09ORV9QQUNLRUQsIHBvbHlsaW5lTGVuZ3RoLCAxLCBGTE9BVF9NQVgpO1xyXG4gICAgICAgIHRoaXMud3JpdGVJbmRpY2VzRm9yQ29udGludW91c1N0cmlwKFJPVU5EX0NBUF9WRVJURVhfQ09VTlQsIHRoaXMuX2Jhc2VJbmRleCk7XHJcbiAgICAgICAgdGhpcy5fYmFzZUluZGV4ICs9IFJPVU5EX0NBUF9WRVJURVhfQ09VTlQ7XHJcbiAgICB9XHJcbiAgICBfd3JpdGVTcXVhcmVDYXAoZW5kVmVydGV4LCBkaXNwbGFjZW1lbnRTaWduKSB7XHJcbiAgICAgICAgY29uc3QgZGlzcGxhY2VtZW50ID0gdmVjMi5jcmVhdGUoMCwgMCk7XHJcbiAgICAgICAgY29uc3QgcG9seWxpbmVMZW5ndGggPSB0aGlzLl9wb2x5bGluZUxlbmd0aDtcclxuICAgICAgICB0aGlzLl93cml0ZVZlcnRleChlbmRWZXJ0ZXgsIHZlYzIuWkVSTywgVVZfWkVST19QQUNLRUQsIFVWX1pFUk9fUEFDS0VELCBwb2x5bGluZUxlbmd0aCwgMSwgMCk7XHJcbiAgICAgICAgdmVjMi5tdWxuKHRoaXMuX2Rpc3BsYWNlbWVudCwgLWRpc3BsYWNlbWVudFNpZ24sIGRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVWZXJ0ZXgoZW5kVmVydGV4LCBkaXNwbGFjZW1lbnQsIFVWX1BPU19PTkVfUEFDS0VELCBVVl9aRVJPX1BBQ0tFRCwgcG9seWxpbmVMZW5ndGgsIDEsIEZMT0FUX01BWCk7XHJcbiAgICAgICAgdmVjMi5yb3RhdGU5MCh0aGlzLl9kaXNwbGFjZW1lbnQsIGRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdmVjMi5zdWIoZGlzcGxhY2VtZW50LCB0aGlzLl9kaXNwbGFjZW1lbnQsIGRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdmVjMi5tdWxuKGRpc3BsYWNlbWVudCwgZGlzcGxhY2VtZW50U2lnbiwgZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB0aGlzLl93cml0ZVZlcnRleChlbmRWZXJ0ZXgsIGRpc3BsYWNlbWVudCwgVVZfUE9TX09ORV9QQUNLRUQsIFVWX1pFUk9fUEFDS0VELCBwb2x5bGluZUxlbmd0aCwgMSwgRkxPQVRfTUFYKTtcclxuICAgICAgICB2ZWMyLnJvdGF0ZTkwKHRoaXMuX2Rpc3BsYWNlbWVudCwgZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB2ZWMyLnN1YihkaXNwbGFjZW1lbnQsIHRoaXMuX2Rpc3BsYWNlbWVudCwgZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB2ZWMyLm11bG4oZGlzcGxhY2VtZW50LCBkaXNwbGFjZW1lbnRTaWduLCBkaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlVmVydGV4KGVuZFZlcnRleCwgZGlzcGxhY2VtZW50LCBVVl9QT1NfT05FX1BBQ0tFRCwgVVZfWkVST19QQUNLRUQsIHBvbHlsaW5lTGVuZ3RoLCAxLCBGTE9BVF9NQVgpO1xyXG4gICAgICAgIHZlYzIubXVsbih0aGlzLl9kaXNwbGFjZW1lbnQsIGRpc3BsYWNlbWVudFNpZ24sIGRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVWZXJ0ZXgoZW5kVmVydGV4LCB0aGlzLl9kaXNwbGFjZW1lbnQsIFVWX1BPU19PTkVfUEFDS0VELCBVVl9aRVJPX1BBQ0tFRCwgcG9seWxpbmVMZW5ndGgsIDEsIEZMT0FUX01BWCk7XHJcbiAgICAgICAgdGhpcy53cml0ZUluZGljZXNGb3JDb250aW51b3VzRmFuKFNRVUFSRV9DQVBfVkVSVEVYX0NPVU5ULCB0aGlzLl9iYXNlSW5kZXgpO1xyXG4gICAgICAgIHRoaXMuX2Jhc2VJbmRleCArPSBTUVVBUkVfQ0FQX1ZFUlRFWF9DT1VOVDtcclxuICAgIH1cclxuICAgIF93cml0ZVNlZ21lbnQoc3RhcnQsIGVuZCwgbmV4dEVuZCkge1xyXG4gICAgICAgIGNvbnN0IGRpc3BsYWNlbWVudCA9IHRoaXMuX2Rpc3BsYWNlbWVudDtcclxuICAgICAgICBjb25zdCBwb2x5bGluZUxlbmd0aCA9IHRoaXMuX3BvbHlsaW5lTGVuZ3RoO1xyXG4gICAgICAgIGNvbnN0IG5leHRTZWdtZW50TGVuZ3RoID0gdmVjMi5kaXN0YW5jZShuZXh0RW5kLCBlbmQpO1xyXG4gICAgICAgIGNvbnN0IG5leHRTZWdtZW50Tm9ybWFsID0gdmVjMi5zdWIobmV4dEVuZCwgZW5kKTtcclxuICAgICAgICB2ZWMyLmRpdm4obmV4dFNlZ21lbnROb3JtYWwsIG5leHRTZWdtZW50TGVuZ3RoLCBuZXh0U2VnbWVudE5vcm1hbCk7XHJcbiAgICAgICAgdmVjMi5yb3RhdGU5MChuZXh0U2VnbWVudE5vcm1hbCwgbmV4dFNlZ21lbnROb3JtYWwpO1xyXG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbjEgPSB0aGlzLl9sYXN0RGlyZWN0aW9uO1xyXG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbjIgPSBNYXRoLnNpZ24odmVjMi5jcm9zc1ooZGlzcGxhY2VtZW50LCBuZXh0U2VnbWVudE5vcm1hbCkpO1xyXG4gICAgICAgIGNvbnN0IG1pdGVyMSA9IHRoaXMuX2xhc3RTaWduZWRNaXRlcjtcclxuICAgICAgICBjb25zdCBtaXRlcjIgPSBjb21wdXRlTWl0ZXIoZGlzcGxhY2VtZW50LCBuZXh0U2VnbWVudE5vcm1hbCk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVWZXJ0ZXgoc3RhcnQsIGRpc3BsYWNlbWVudCwgVVZfUE9TX09ORV9QQUNLRUQsIFVWX1pFUk9fUEFDS0VELCBwb2x5bGluZUxlbmd0aCwgZGlyZWN0aW9uMSA9PT0gLTEgJiYgKHRoaXMuX2pvaW4gIT09IDAgLyogTUlURVIgKi8gfHwgTWF0aC5hYnMobWl0ZXIxKSA+IE1JVEVSX0xJTUlUKSA/XHJcbiAgICAgICAgICAgIDEgOlxyXG4gICAgICAgICAgICBtaXRlcjEsIGRpcmVjdGlvbjEgPT09IC0xID8gLUZMT0FUX01BWCA6IDAuNSAqIHRoaXMuX3NlZ21lbnRMZW5ndGgpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlVmVydGV4KGVuZCwgZGlzcGxhY2VtZW50LCBVVl9QT1NfT05FX1BBQ0tFRCwgVVZfWkVST19QQUNLRUQsIHBvbHlsaW5lTGVuZ3RoICsgdGhpcy5fc2VnbWVudExlbmd0aCwgZGlyZWN0aW9uMiA9PT0gLTEgJiYgKHRoaXMuX2pvaW4gIT09IDAgLyogTUlURVIgKi8gfHwgbWl0ZXIyID4gTUlURVJfTElNSVQpID9cclxuICAgICAgICAgICAgMSA6XHJcbiAgICAgICAgICAgIGRpcmVjdGlvbjIgKiBtaXRlcjIsIGRpcmVjdGlvbjIgPT09IC0xID8gRkxPQVRfTUFYIDogLTAuNSAqIHRoaXMuX3NlZ21lbnRMZW5ndGgpO1xyXG4gICAgICAgIHZlYzIuaW52ZXJ0KGRpc3BsYWNlbWVudCwgZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB0aGlzLl93cml0ZVZlcnRleChzdGFydCwgZGlzcGxhY2VtZW50LCBVVl9ORUdfT05FX1BBQ0tFRCwgVVZfWkVST19QQUNLRUQsIHBvbHlsaW5lTGVuZ3RoLCBkaXJlY3Rpb24xID09PSAxICYmICh0aGlzLl9qb2luICE9PSAwIC8qIE1JVEVSICovIHx8IE1hdGguYWJzKG1pdGVyMSkgPiBNSVRFUl9MSU1JVCkgP1xyXG4gICAgICAgICAgICAxIDpcclxuICAgICAgICAgICAgbWl0ZXIxLCBkaXJlY3Rpb24xID09PSAxID8gLUZMT0FUX01BWCA6IDAuNSAqIHRoaXMuX3NlZ21lbnRMZW5ndGgpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlVmVydGV4KGVuZCwgZGlzcGxhY2VtZW50LCBVVl9ORUdfT05FX1BBQ0tFRCwgVVZfWkVST19QQUNLRUQsIHBvbHlsaW5lTGVuZ3RoICsgdGhpcy5fc2VnbWVudExlbmd0aCwgZGlyZWN0aW9uMiA9PT0gMSAmJiAodGhpcy5fam9pbiAhPT0gMCAvKiBNSVRFUiAqLyB8fCBtaXRlcjIgPiBNSVRFUl9MSU1JVCkgP1xyXG4gICAgICAgICAgICAxIDpcclxuICAgICAgICAgICAgZGlyZWN0aW9uMiAqIG1pdGVyMiwgZGlyZWN0aW9uMiA9PT0gMSA/IEZMT0FUX01BWCA6IC0wLjUgKiB0aGlzLl9zZWdtZW50TGVuZ3RoKTtcclxuICAgICAgICB0aGlzLndyaXRlSW5kaWNlc0ZvckNvbnRpbnVvdXNTdHJpcChTRUdNRU5UX1ZFUlRFWF9DT1VOVCwgdGhpcy5fYmFzZUluZGV4KTtcclxuICAgICAgICB0aGlzLl9iYXNlSW5kZXggKz0gU0VHTUVOVF9WRVJURVhfQ09VTlQ7XHJcbiAgICAgICAgdGhpcy5fbGFzdFNpZ25lZE1pdGVyID0gLWRpcmVjdGlvbjIgKiBtaXRlcjI7XHJcbiAgICAgICAgdGhpcy5fbGFzdERpcmVjdGlvbiA9IGRpcmVjdGlvbjI7XHJcbiAgICAgICAgdmVjMi5jb3B5KGRpc3BsYWNlbWVudCwgdGhpcy5fcHJldkRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdmVjMi5jb3B5KG5leHRTZWdtZW50Tm9ybWFsLCBkaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHRoaXMuX3BvbHlsaW5lTGVuZ3RoICs9IHRoaXMuX3NlZ21lbnRMZW5ndGg7XHJcbiAgICAgICAgdGhpcy5fc2VnbWVudExlbmd0aCA9IG5leHRTZWdtZW50TGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgX3dyaXRlSm9pbihqb2luVmVydGV4KSB7XHJcbiAgICAgICAgc3dpdGNoICh0aGlzLl9qb2luKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMiAvKiBCRVZFTCAqLzpcclxuICAgICAgICAgICAgICAgIHRoaXMuX3dyaXRlQmV2ZWxKb2luKGpvaW5WZXJ0ZXgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMSAvKiBST1VORCAqLzpcclxuICAgICAgICAgICAgICAgIHRoaXMuX3dyaXRlUm91bmRKb2luKGpvaW5WZXJ0ZXgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMCAvKiBNSVRFUiAqLzpcclxuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyh0aGlzLl9sYXN0U2lnbmVkTWl0ZXIpID4gTUlURVJfTElNSVQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl93cml0ZUJldmVsSm9pbihqb2luVmVydGV4KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF93cml0ZUJldmVsSm9pbihqb2luVmVydGV4KSB7XHJcbiAgICAgICAgY29uc3QgbGFzdERpcmVjdGlvbiA9IHRoaXMuX2xhc3REaXJlY3Rpb247XHJcbiAgICAgICAgY29uc3QgZGlzcGxhY2VtZW50ID0gdmVjMi5pbnZlcnQodGhpcy5fZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB2ZWMyLmFkZChkaXNwbGFjZW1lbnQsIHRoaXMuX3ByZXZEaXNwbGFjZW1lbnQsIGRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdmVjMi5tdWxuKGRpc3BsYWNlbWVudCwgMC41ICogbGFzdERpcmVjdGlvbiwgZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB0aGlzLl93cml0ZVZlcnRleChqb2luVmVydGV4LCBkaXNwbGFjZW1lbnQsIGxhc3REaXJlY3Rpb24gPT09IC0xIC8qIExFRlQgKi8gP1xyXG4gICAgICAgICAgICBVVl9QT1NfT05FX1BBQ0tFRCA6XHJcbiAgICAgICAgICAgIFVWX05FR19PTkVfUEFDS0VELCBVVl9aRVJPX1BBQ0tFRCwgdGhpcy5fcG9seWxpbmVMZW5ndGgsIDEsIDEpO1xyXG4gICAgICAgIGNvbnN0IGJhc2VJbmRleCA9IHRoaXMuX2Jhc2VJbmRleDtcclxuICAgICAgICB0aGlzLndyaXRlSW5kaWNlcyhbXHJcbiAgICAgICAgICAgIGJhc2VJbmRleCAtIDEsXHJcbiAgICAgICAgICAgIGJhc2VJbmRleCAtIDMsXHJcbiAgICAgICAgICAgIGJhc2VJbmRleCxcclxuICAgICAgICAgICAgYmFzZUluZGV4LFxyXG4gICAgICAgICAgICBsYXN0RGlyZWN0aW9uID09PSAtMSAvKiBMRUZUICovID8gYmFzZUluZGV4ICsgMSA6IGJhc2VJbmRleCArIDMsXHJcbiAgICAgICAgICAgIGxhc3REaXJlY3Rpb24gPT09IC0xIC8qIExFRlQgKi8gPyBiYXNlSW5kZXggKyAzIDogYmFzZUluZGV4ICsgMVxyXG4gICAgICAgIF0pO1xyXG4gICAgICAgIHRoaXMuX2Jhc2VJbmRleCArPSAxO1xyXG4gICAgfVxyXG4gICAgX3dyaXRlUm91bmRKb2luKGpvaW5WZXJ0ZXgpIHtcclxuICAgICAgICBjb25zdCBwb2x5bGluZUxlbmd0aCA9IHRoaXMuX3BvbHlsaW5lTGVuZ3RoO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlVmVydGV4KGpvaW5WZXJ0ZXgsIHZlYzIuWkVSTywgVVZfWkVST19QQUNLRUQsIFVWX1pFUk9fUEFDS0VELCBwb2x5bGluZUxlbmd0aCwgMCwgMCk7XHJcbiAgICAgICAgY29uc3QgbGFzdERpcmVjdGlvbiA9IHRoaXMuX2xhc3REaXJlY3Rpb247XHJcbiAgICAgICAgY29uc3QgbWlkZGxlRGlzcGxhY2VtZW50ID0gdmVjMi5pbnZlcnQodGhpcy5fcHJldkRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdmVjMi5hZGQodGhpcy5fZGlzcGxhY2VtZW50LCBtaWRkbGVEaXNwbGFjZW1lbnQsIG1pZGRsZURpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdmVjMi5ub3JtYWxpemUobWlkZGxlRGlzcGxhY2VtZW50LCBtaWRkbGVEaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIGNvbnN0IGRpc3BsYWNlbWVudCA9IHZlYzIuaW52ZXJ0KHRoaXMuX3ByZXZEaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIGNvbnN0IG1pdGVyMSA9IGNvbXB1dGVNaXRlcihtaWRkbGVEaXNwbGFjZW1lbnQsIGRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdmVjMi5hZGQoZGlzcGxhY2VtZW50LCBtaWRkbGVEaXNwbGFjZW1lbnQsIGRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdmVjMi5ub3JtYWxpemUoZGlzcGxhY2VtZW50LCBkaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHZlYzIubXVsbihkaXNwbGFjZW1lbnQsIC1sYXN0RGlyZWN0aW9uICogbWl0ZXIxLCBkaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlVmVydGV4KGpvaW5WZXJ0ZXgsIGRpc3BsYWNlbWVudCwgbGFzdERpcmVjdGlvbiA9PT0gLTEgLyogTEVGVCAqLyA/XHJcbiAgICAgICAgICAgIFVWX1BPU19PTkVfUEFDS0VEIDpcclxuICAgICAgICAgICAgVVZfTkVHX09ORV9QQUNLRUQsIHBhY2tVdkNvbXBvbmVudChNYXRoLnNxcnQobWl0ZXIxICogbWl0ZXIxIC0gMSkpLCBwb2x5bGluZUxlbmd0aCwgMSwgRkxPQVRfTUFYKTtcclxuICAgICAgICB2ZWMyLm11bG4obWlkZGxlRGlzcGxhY2VtZW50LCAtbGFzdERpcmVjdGlvbiwgZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB0aGlzLl93cml0ZVZlcnRleChqb2luVmVydGV4LCBkaXNwbGFjZW1lbnQsIGxhc3REaXJlY3Rpb24gPT09IC0xIC8qIExFRlQgKi8gP1xyXG4gICAgICAgICAgICBVVl9QT1NfT05FX1BBQ0tFRCA6XHJcbiAgICAgICAgICAgIFVWX05FR19PTkVfUEFDS0VELCBVVl9aRVJPX1BBQ0tFRCwgcG9seWxpbmVMZW5ndGgsIDEsIEZMT0FUX01BWCk7XHJcbiAgICAgICAgY29uc3QgbWl0ZXIyID0gY29tcHV0ZU1pdGVyKG1pZGRsZURpc3BsYWNlbWVudCwgdGhpcy5fZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB2ZWMyLmFkZCh0aGlzLl9kaXNwbGFjZW1lbnQsIG1pZGRsZURpc3BsYWNlbWVudCwgZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB2ZWMyLm5vcm1hbGl6ZShkaXNwbGFjZW1lbnQsIGRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdmVjMi5tdWxuKGRpc3BsYWNlbWVudCwgLWxhc3REaXJlY3Rpb24gKiBtaXRlcjIsIGRpc3BsYWNlbWVudCk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVWZXJ0ZXgoam9pblZlcnRleCwgZGlzcGxhY2VtZW50LCBsYXN0RGlyZWN0aW9uID09PSAtMSAvKiBMRUZUICovID9cclxuICAgICAgICAgICAgVVZfUE9TX09ORV9QQUNLRUQgOlxyXG4gICAgICAgICAgICBVVl9ORUdfT05FX1BBQ0tFRCwgcGFja1V2Q29tcG9uZW50KE1hdGguc3FydChtaXRlcjIgKiBtaXRlcjIgLSAxKSksIHBvbHlsaW5lTGVuZ3RoLCAxLCBGTE9BVF9NQVgpO1xyXG4gICAgICAgIGNvbnN0IGJhc2VJbmRleCA9IHRoaXMuX2Jhc2VJbmRleDtcclxuICAgICAgICB0aGlzLndyaXRlSW5kaWNlcyhbXHJcbiAgICAgICAgICAgIGJhc2VJbmRleCAtIDMsXHJcbiAgICAgICAgICAgIGJhc2VJbmRleCAtIDEsXHJcbiAgICAgICAgICAgIGJhc2VJbmRleCxcclxuICAgICAgICAgICAgYmFzZUluZGV4LFxyXG4gICAgICAgICAgICBsYXN0RGlyZWN0aW9uID09PSAtMSAvKiBMRUZUICovID8gYmFzZUluZGV4IC0gMyA6IGJhc2VJbmRleCAtIDEsXHJcbiAgICAgICAgICAgIGJhc2VJbmRleCArIDEsXHJcbiAgICAgICAgICAgIGJhc2VJbmRleCxcclxuICAgICAgICAgICAgYmFzZUluZGV4ICsgMSxcclxuICAgICAgICAgICAgYmFzZUluZGV4ICsgMixcclxuICAgICAgICAgICAgYmFzZUluZGV4LFxyXG4gICAgICAgICAgICBiYXNlSW5kZXggKyAyLFxyXG4gICAgICAgICAgICBiYXNlSW5kZXggKyAzLFxyXG4gICAgICAgICAgICBiYXNlSW5kZXgsXHJcbiAgICAgICAgICAgIGJhc2VJbmRleCArIDMsXHJcbiAgICAgICAgICAgIGxhc3REaXJlY3Rpb24gPT09IC0xIC8qIExFRlQgKi8gPyBiYXNlSW5kZXggKyA0IDogYmFzZUluZGV4ICsgNixcclxuICAgICAgICAgICAgYmFzZUluZGV4LFxyXG4gICAgICAgICAgICBiYXNlSW5kZXggKyA0LFxyXG4gICAgICAgICAgICBiYXNlSW5kZXggKyA2XHJcbiAgICAgICAgXSk7XHJcbiAgICAgICAgdGhpcy5fYmFzZUluZGV4ICs9IDQ7XHJcbiAgICB9XHJcbiAgICBfd3JpdGVMYXN0U2VnbWVudChzdGFydCwgZW5kKSB7XHJcbiAgICAgICAgY29uc3QgZGlzcGxhY2VtZW50ID0gdGhpcy5fZGlzcGxhY2VtZW50O1xyXG4gICAgICAgIGNvbnN0IGxhc3REaXJlY3Rpb24gPSB0aGlzLl9sYXN0RGlyZWN0aW9uO1xyXG4gICAgICAgIGNvbnN0IHBvbHlsaW5lTGVuZ3RoID0gdGhpcy5fcG9seWxpbmVMZW5ndGg7XHJcbiAgICAgICAgY29uc3QgbWl0ZXIgPSB0aGlzLl9sYXN0U2lnbmVkTWl0ZXI7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVWZXJ0ZXgoc3RhcnQsIGRpc3BsYWNlbWVudCwgVVZfUE9TX09ORV9QQUNLRUQsIFVWX1pFUk9fUEFDS0VELCBwb2x5bGluZUxlbmd0aCwgbGFzdERpcmVjdGlvbiA9PT0gLTEgLyogTEVGVCAqLyAmJiAodGhpcy5fam9pbiAhPT0gMCAvKiBNSVRFUiAqLyB8fCBNYXRoLmFicyhtaXRlcikgPiBNSVRFUl9MSU1JVCkgP1xyXG4gICAgICAgICAgICAxIDpcclxuICAgICAgICAgICAgbWl0ZXIsIGxhc3REaXJlY3Rpb24gPT09IC0xIC8qIExFRlQgKi8gPyAtRkxPQVRfTUFYIDogdGhpcy5fc2VnbWVudExlbmd0aCk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVWZXJ0ZXgoZW5kLCBkaXNwbGFjZW1lbnQsIFVWX1BPU19PTkVfUEFDS0VELCBVVl9aRVJPX1BBQ0tFRCwgcG9seWxpbmVMZW5ndGggKyB0aGlzLl9zZWdtZW50TGVuZ3RoLCAxLCBGTE9BVF9NQVgpO1xyXG4gICAgICAgIHZlYzIuaW52ZXJ0KGRpc3BsYWNlbWVudCwgZGlzcGxhY2VtZW50KTtcclxuICAgICAgICB0aGlzLl93cml0ZVZlcnRleChzdGFydCwgZGlzcGxhY2VtZW50LCBVVl9ORUdfT05FX1BBQ0tFRCwgVVZfWkVST19QQUNLRUQsIHBvbHlsaW5lTGVuZ3RoLCBsYXN0RGlyZWN0aW9uID09PSAxIC8qIFJJR0hUICovICYmICh0aGlzLl9qb2luICE9PSAwIC8qIE1JVEVSICovIHx8IE1hdGguYWJzKG1pdGVyKSA+IE1JVEVSX0xJTUlUKSA/XHJcbiAgICAgICAgICAgIDEgOlxyXG4gICAgICAgICAgICBtaXRlciwgbGFzdERpcmVjdGlvbiA9PT0gMSAvKiBSSUdIVCAqLyA/IC1GTE9BVF9NQVggOiB0aGlzLl9zZWdtZW50TGVuZ3RoKTtcclxuICAgICAgICB0aGlzLl93cml0ZVZlcnRleChlbmQsIGRpc3BsYWNlbWVudCwgVVZfTkVHX09ORV9QQUNLRUQsIFVWX1pFUk9fUEFDS0VELCBwb2x5bGluZUxlbmd0aCArIHRoaXMuX3NlZ21lbnRMZW5ndGgsIDEsIEZMT0FUX01BWCk7XHJcbiAgICAgICAgdGhpcy53cml0ZUluZGljZXNGb3JDb250aW51b3VzU3RyaXAoU0VHTUVOVF9WRVJURVhfQ09VTlQsIHRoaXMuX2Jhc2VJbmRleCk7XHJcbiAgICAgICAgdGhpcy5fYmFzZUluZGV4ICs9IFNFR01FTlRfVkVSVEVYX0NPVU5UO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IEF0dHJpYnV0ZU1hcHBpbmcgfSBmcm9tICcuLi8uLi9yZW5kZXIvYXR0cmliX21hcHBpbmcnO1xyXG4vKipcclxuICogRGVzY3JpcHRpb24gb2YgaG93IGF0dHJpYnV0ZXMgb2YgdmVydGljZXMgYXJlIHBhY2tlZCBpbnRvIGEgdmVydGV4IGJ1ZmZlci5cclxuICovXHJcbmV4cG9ydCBjb25zdCBQT0xZTElORV9BVFRSSUJVVEVfTUFQUElORyA9IG5ldyBBdHRyaWJ1dGVNYXBwaW5nKFtcclxuICAgIC8qKiBWZXJ0ZXggd29ybGQgcG9zaXRpb24uICovXHJcbiAgICBbXHJcbiAgICAgICAgMCAvKiBQT1NJVElPTiAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDQsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjMgLyogVU5TSUdORURfU0hPUlQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgLyoqIE5vcm1hbCB0byBwb2x5bGluZSBzZWdtZW50IHRoZSB2ZXJ0ZXggYmVsb25nIHRvLiAqL1xyXG4gICAgW1xyXG4gICAgICAgIDUgLyogTk9STUFMICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMixcclxuICAgICAgICAgICAgdHlwZTogNTEyMyAvKiBVTlNJR05FRF9TSE9SVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICAvKipcclxuICAgICAqIFwiVVZcIiB2ZXJ0ZXggdGhhdCB1c2VkIHRvIGNvbXB1dGUgc3Ryb2tlIGFuZCBkYXNoZXMuIEl0J3MgY29tcG9uZW50czpcclxuICAgICAqXHJcbiAgICAgKiAgIC0gZGlzdGFuY2UgdG8gdGhlIGFuYWx5dGljYWwgcG9seWxpbmUgYWxvbmcgc2VnbWVudCdzIG5vcm1hbDtcclxuICAgICAqICAgLSBkaXN0YW5jZSB0byB0aGUgYW5hbHl0aWNhbCBwb2x5bGluZSBhbG9uZyBzZWdtZW50LlxyXG4gICAgICovXHJcbiAgICBbXHJcbiAgICAgICAgNCAvKiBVViAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDIsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjMgLyogVU5TSUdORURfU0hPUlQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIC8qKlxyXG4gICAgICogVmVjdG9yIHdpdGggcG9seWxpbmUncyBoYWxmIHdpZHRoIGFuZCBkYXNoIHN0eWxlLiBJdCdzIGNvbXBvbmVudHM6XHJcbiAgICAgKlxyXG4gICAgICogICAtIGhhbGYgd2lkdGg7XHJcbiAgICAgKiAgIC0gbGVuZ3RoIG9mIGEgZGFzaDtcclxuICAgICAqICAgLSBkaXN0YW5jZSBiZXR3ZWVuIGRhc2hlcy5cclxuICAgICAqL1xyXG4gICAgW1xyXG4gICAgICAgIDExIC8qIEFVWCAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDMsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjEgLyogVU5TSUdORURfQllURSAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICAvKipcclxuICAgICAqIE1pdGVyIChpLmUuIGhvdyBtdWNoIGRpc3BsYWNlbWVudCBvZiB0aGUgdmVydGV4IGlzIGxvbmdlciB0aGVuIHRoZVxyXG4gICAgICogbm9ybWFsKS5cclxuICAgICAqL1xyXG4gICAgW1xyXG4gICAgICAgIDEyIC8qIEFVWDEgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAxLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTI2IC8qIEZMT0FUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICAvKipcclxuICAgICAqIExpbWl0IG9uIGRpc3BsYWNlbWVudCB0YW5nZW50IGNvbXBvbmVudC5BcHBsaWVkIHRvIGF2b2lkIGdlb21ldHJ5XHJcbiAgICAgKiBnbGl0Y2hlcyBpbiBvdmVyLWRlZ2VuZXJhdGl2ZSBjYXNlcy5cclxuICAgICAqL1xyXG4gICAgW1xyXG4gICAgICAgIDEzIC8qIEFVWDIgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAxLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTI2IC8qIEZMT0FUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICAvKipcclxuICAgICAqIERpc3RhbmNlIHRvIHRoZSBmaXJzdCB2ZXJ0ZXggYWxvbmcgdGhlIHBvbHlsaW5lLlxyXG4gICAgICovXHJcbiAgICBbXHJcbiAgICAgICAgMTQgLyogQVVYMyAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDEsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjYgLyogRkxPQVQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIC8qKiBQb2x5bGluZSdzIGNvbG9yLiAqL1xyXG4gICAgW1xyXG4gICAgICAgIDcgLyogQ09MT1IgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiA0LFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIxIC8qIFVOU0lHTkVEX0JZVEUgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgLyoqIFBvbHlsaW5lJ3MgWiBpbmRleC4gKi9cclxuICAgIFtcclxuICAgICAgICAxMCAvKiBaX0lOREVYICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMSxcclxuICAgICAgICAgICAgdHlwZTogNTEyNiAvKiBGTE9BVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICBdXHJcbl0pO1xyXG4iLCJpbXBvcnQgVGlsZVdvcmxkQ29vcmRpbmF0ZXNDb252ZXJ0ZXIgZnJvbSAnLi90aWxlX3dvcmxkX2Nvb3JkaW5hdGVzX2NvbnZlcnRlcic7XHJcbmltcG9ydCB7IGRlY29kZUFiZ3I4IH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbC9jb2xvcic7XHJcbmltcG9ydCBzdHlsZUl0ZXJhdG9yIGZyb20gJy4vZXh0cmFjdF9zdHlsZXMnO1xyXG5pbXBvcnQgeyBtYXBJdGVyYWJsZSB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWwvaXRlcmFibGUnO1xyXG4vKipcclxuICogVXRpbGl0eSBtZXRob2QgZm9yIGdldHRpbmcgcG9seWdvbiByaW5nIHZlcnRpY2VzIGZyb20gQVBJIHRpbGUgcmVzcG9uc2UuXHJcbiAqL1xyXG5mdW5jdGlvbiogZXh0cmFjdFZlcnRpY2VzKHBvbHlnb25zLCBjb29yZHNPZmZzZXQsIHJpbmdTaXplLCBjb252ZXJ0ZXIpIHtcclxuICAgIC8vIGNvb3JkaW5hdGVzIGFyZSBzdG9yZWQgaW4gZGVsdGFzIHJlbGF0aXZlbHkgdG8gdGhlIGZpcnN0IHZhbHVlcyBpbiByaW5nXHJcbiAgICAvLyBzbyB3ZSBuZWVkIHRvIGFjY3VtdWxhdGUgeCBhbmQgeSB0byBkZXRlcm1pbmUgc3Vic2VxdWVudCBjb29yZGluYXRlc1xyXG4gICAgbGV0IHggPSAwO1xyXG4gICAgbGV0IHkgPSAwO1xyXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCByaW5nU2l6ZTsgaisrKSB7XHJcbiAgICAgICAgeCArPSBwb2x5Z29ucy5jb29yZHN4W2Nvb3Jkc09mZnNldF07XHJcbiAgICAgICAgeSArPSBwb2x5Z29ucy5jb29yZHN5W2Nvb3Jkc09mZnNldF07XHJcbiAgICAgICAgeWllbGQgY29udmVydGVyLnRvV29ybGRDb29yZGluYXRlcyh4LCB5KTtcclxuICAgICAgICBjb29yZHNPZmZzZXQrKztcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVXRpbGl0eSBtZXRob2QgZm9yIGdldHRpbmcgcG9seWdvbiByaW5ncyBmcm9tIEFQSSB0aWxlIHJlc3BvbnNlLlxyXG4gKi9cclxuZnVuY3Rpb24qIGV4dHJhY3RSaW5ncyhwb2x5Z29ucywgY29vcmRzT2Zmc2V0LCByaW5nU2l6ZU9mZnNldCwgcmluZ1NpemVMZW5ndGgsIGNvbnZlcnRlcikge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByaW5nU2l6ZUxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgcmluZ1NpemUgPSBwb2x5Z29ucy5yaW5nU2l6ZVtyaW5nU2l6ZU9mZnNldCArIGldO1xyXG4gICAgICAgIHlpZWxkIGV4dHJhY3RWZXJ0aWNlcyhwb2x5Z29ucywgY29vcmRzT2Zmc2V0LCByaW5nU2l6ZSwgY29udmVydGVyKTtcclxuICAgICAgICBjb29yZHNPZmZzZXQgKz0gcmluZ1NpemU7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY29udmVydE1lc2hEZXNjcmlwdGlvbihoZWlnaHQsIGNvbnZlcnRlciwgc3R5bGVzLCBtZXNoKSB7XHJcbiAgICBpZiAobWVzaCAmJiBtZXNoLmJib3gpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBvYmplY3RJZDogbWVzaC5vYmplY3RJZCxcclxuICAgICAgICAgICAgbWVzaElkOiBtZXNoLm1lc2hJZCxcclxuICAgICAgICAgICAgYmJveDoge1xyXG4gICAgICAgICAgICAgICAgbWluWDogY29udmVydGVyLnRvV29ybGRYQ29vcmRpbmF0ZShtZXNoLmJib3gubWluWCksXHJcbiAgICAgICAgICAgICAgICBtYXhYOiBjb252ZXJ0ZXIudG9Xb3JsZFhDb29yZGluYXRlKG1lc2guYmJveC5tYXhYKSxcclxuICAgICAgICAgICAgICAgIG1pblk6IGNvbnZlcnRlci50b1dvcmxkWUNvb3JkaW5hdGUobWVzaC5iYm94Lm1heFkpLFxyXG4gICAgICAgICAgICAgICAgbWF4WTogY29udmVydGVyLnRvV29ybGRZQ29vcmRpbmF0ZShtZXNoLmJib3gubWluWSksXHJcbiAgICAgICAgICAgICAgICBtaW5aOiBoZWlnaHQsXHJcbiAgICAgICAgICAgICAgICBtYXhaOiAwXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNvbG9yOiBzdHlsZXNbMF0uY29sb3JcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVXRpbGl0eSBtZXRob2QgZm9yIGdldHRpbmcgcG9seWdvbiBzcGVjaWZpYyBzdHlsZSBkZXRhaWxzIGZyb20gYSB6b29tIHNsaWNlLlxyXG4gKiBUbyBiZSB1c2VkIGFzIGEgem9vbSBzbGljZSBzdHlsZSBjb252ZXJ0ZXIgZm9yIHN0eWxlIGV4dHJhY3Rvci5cclxuICovXHJcbmZ1bmN0aW9uIGNvbnZlcnRab29tU2xpY2VUb1N0eWxlKHNsaWNlLCBzdHlsZUJhc2UpIHtcclxuICAgIGlmIChzbGljZS5wb2x5KSB7XHJcbiAgICAgICAgY29uc3QgZXh0cnVkZWQgPSAhIXNsaWNlLnBvbHkuZXh0cnVzaW9uICYmIHNsaWNlLnBvbHkuZXh0cnVzaW9uLmVuYWJsZWQ7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0eWxlQmFzZSwgeyBjb2xvcjogZGVjb2RlQWJncjgoc2xpY2UucG9seS5jb2xvciksIHBhdHRlcm46IHNsaWNlLnBvbHkucGF0dGVybiA/IHtcclxuICAgICAgICAgICAgICAgIGltYWdlSWQ6IHNsaWNlLnBvbHkucGF0dGVybi5pZCxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBzbGljZS5wb2x5LnBhdHRlcm4ud2lkdGhcclxuICAgICAgICAgICAgfSA6IHVuZGVmaW5lZCwgZXh0cnVkZWQsIGhlaWdodDogZXh0cnVkZWQgPyBzbGljZS5wb2x5LmV4dHJ1c2lvbi5oZWlnaHQgOiAwIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxufVxyXG4vKipcclxuICogVXRpbGl0eSBtZXRob2QgZm9yIGdldHRpbmcgcG9pbnQgbGFiZWxzIGZyb20gQVBJIHRpbGUgcmVzcG9uc2UuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiogZXh0cmFjdFBvbHlnb25zKHRpbGUsIGRlY29kZWRBcGlUaWxlLCB0aWxlTWluWm9vbSwgdGlsZU1heFpvb20pIHtcclxuICAgIGNvbnN0IHBvbHlnb25zID0gZGVjb2RlZEFwaVRpbGUucG9seWdvbnM7XHJcbiAgICBpZiAocG9seWdvbnMpIHtcclxuICAgICAgICBjb25zdCBjb252ZXJ0ZXIgPSBuZXcgVGlsZVdvcmxkQ29vcmRpbmF0ZXNDb252ZXJ0ZXIodGlsZSk7XHJcbiAgICAgICAgbGV0IHJpbmdDb3VudE9mZnNldCA9IDA7XHJcbiAgICAgICAgbGV0IHJpbmdTaXplT2Zmc2V0ID0gMDtcclxuICAgICAgICBsZXQgY29vcmRzT2Zmc2V0ID0gMDtcclxuICAgICAgICBjb25zdCBtZXNoZXMgPSBwb2x5Z29ucy5tZXNoLnJlZHVjZSgobWVzaGVzLCBtZXNoKSA9PiAobWVzaGVzLnNldChtZXNoLnBvbHlnb25JZCwgbWVzaCksIG1lc2hlcyksIG5ldyBNYXAoKSk7XHJcbiAgICAgICAgd2hpbGUgKHJpbmdDb3VudE9mZnNldCA8IHBvbHlnb25zLnJpbmdDb3VudC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgY29uc3QgcG9seWdvblJpbmdTaXplTGVuZ3RoID0gcG9seWdvbnMucmluZ0NvdW50W3JpbmdDb3VudE9mZnNldF07XHJcbiAgICAgICAgICAgIGNvbnN0IHBvbHlnb25SaW5nU2l6ZU9mZnNldCA9IHJpbmdTaXplT2Zmc2V0O1xyXG4gICAgICAgICAgICBjb25zdCBwb2x5Z29uQ29vcmRzT2Zmc2V0ID0gY29vcmRzT2Zmc2V0O1xyXG4gICAgICAgICAgICBjb25zdCBjbGFzc0lkID0gcG9seWdvbnMuY2xhc3NJZFtyaW5nQ291bnRPZmZzZXRdO1xyXG4gICAgICAgICAgICBjb25zdCBzdHlsZXMgPSBbXHJcbiAgICAgICAgICAgICAgICAuLi5zdHlsZUl0ZXJhdG9yKGRlY29kZWRBcGlUaWxlLnByZXNlbnRhdGlvbiwgY2xhc3NJZCwgY29udmVydFpvb21TbGljZVRvU3R5bGUsIHRpbGVNaW5ab29tLCB0aWxlTWF4Wm9vbSlcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgY29uc3QgaXNFeHRydWRlZCA9IHN0eWxlc1swXSAmJiBzdHlsZXNbMF0uZXh0cnVkZWQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IGlzRXh0cnVkZWQgP1xyXG4gICAgICAgICAgICAgICAgY29udmVydGVyLnRvV29ybGRaQ29vcmRpbmF0ZShwb2x5Z29ucy5oZWlnaHRbcmluZ0NvdW50T2Zmc2V0XSB8fCBzdHlsZXNbMF0uaGVpZ2h0IHx8IDApIDpcclxuICAgICAgICAgICAgICAgIDA7XHJcbiAgICAgICAgICAgIGNvbnN0IGV4dGVybmFsTWVzaCA9IGlzRXh0cnVkZWQgP1xyXG4gICAgICAgICAgICAgICAgY29udmVydE1lc2hEZXNjcmlwdGlvbihoZWlnaHQsIGNvbnZlcnRlciwgc3R5bGVzLCBtZXNoZXMuZ2V0KHJpbmdDb3VudE9mZnNldCkpIDpcclxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgbGV0IGNvb3Jkc0xlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9seWdvblJpbmdTaXplTGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvb3Jkc0xlbmd0aCArPSBwb2x5Z29ucy5yaW5nU2l6ZVtyaW5nU2l6ZU9mZnNldCArIGldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHlpZWxkIHtcclxuICAgICAgICAgICAgICAgIHZlcnRleFJpbmdzOiBbLi4ubWFwSXRlcmFibGUoZXh0cmFjdFJpbmdzKHBvbHlnb25zLCBwb2x5Z29uQ29vcmRzT2Zmc2V0LCBwb2x5Z29uUmluZ1NpemVPZmZzZXQsIHBvbHlnb25SaW5nU2l6ZUxlbmd0aCwgY29udmVydGVyKSwgKHJpbmdJdGVyYWJsZSkgPT4gWy4uLnJpbmdJdGVyYWJsZV0pXSxcclxuICAgICAgICAgICAgICAgIGhlaWdodCxcclxuICAgICAgICAgICAgICAgIGV4dGVybmFsTWVzaCxcclxuICAgICAgICAgICAgICAgIHN0eWxlc1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByaW5nU2l6ZU9mZnNldCArPSBwb2x5Z29uUmluZ1NpemVMZW5ndGg7XHJcbiAgICAgICAgICAgIGNvb3Jkc09mZnNldCArPSBjb29yZHNMZW5ndGg7XHJcbiAgICAgICAgICAgIHJpbmdDb3VudE9mZnNldCsrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgdHJpYW5ndWxhdGUgZnJvbSAnLi4vLi4vLi4vdXRpbC90cmlhbmd1bGF0ZSc7XHJcbmltcG9ydCBNb2RlbEJ1ZmZlcldyaXRlciBmcm9tICcuLi8uLi8uLi9wcmltaXRpdmUvbW9kZWwvbW9kZWxfYnVmZmVyX3dyaXRlcic7XHJcbmltcG9ydCB7IGVuY29kZVJnYmE4IH0gZnJvbSAnLi4vLi4vLi4vdXRpbC9jb2xvcic7XHJcbi8qKlxyXG4gKiBCdWZmZXIgd3JpdGVyIHRoYXQgd3JpdGVzIGV4dHJ1ZGVkIHBvbHlnb25zIGFzIDNEIG1lc2hlcy5cclxuICogSXQganVzdCBtb3ZlcyBhIHBvbHlnb24gdXAgdG8gdGhlIGhlaWdodCBhbmQgYWRkcyB0aGUgXCJ3YWxsc1wiIGFyb3VuZC5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBFeHRydWRlZFBvbHlnb25CdWZmZXJXcml0ZXIgZXh0ZW5kcyBNb2RlbEJ1ZmZlcldyaXRlciB7XHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIHBvbHlnb24gYXMgYSBwcmlzbSB3aXRoIHNwZWNpZmllZCBoZWlnaHQgYW5kIHdpdGggb25seSBvbmUgdXBwZXIgYmFzZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcG9seWdvbiBUaGUgZm9ybSBvZiB0aGUgcHJpc20ncyBiYXNlLlxyXG4gICAgICogQHBhcmFtIGhlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSBwcmlzbSwgd29ybGQgei1jb29yZGluYXRlLlxyXG4gICAgICogQHJldHVybnMgVGhlIGxvY2F0aW9uIG9mIHRoZSBtZXNoIGluIGEgYnVmZmVyLlxyXG4gICAgICovXHJcbiAgICB3cml0ZVBvbHlnb24ocG9seWdvbiwgaGVpZ2h0LCBjb2xvcikge1xyXG4gICAgICAgIGNvbnN0IGVuY29kZWRDb2xvciA9IGVuY29kZVJnYmE4KGNvbG9yKTtcclxuICAgICAgICBjb25zdCB2ZXJ0aWNlcyA9IHBvbHlnb24udmVydGV4UmluZ3MucmVkdWNlKCh2ZXJ0aWNlcywgcmluZykgPT4gKHZlcnRpY2VzLnB1c2goLi4ucmluZyksIHZlcnRpY2VzKSwgW10pO1xyXG4gICAgICAgIGZvciAoY29uc3QgdmVydGV4IG9mIHZlcnRpY2VzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3dyaXRlVmVydGV4KE9iamVjdC5hc3NpZ24oe30sIHZlcnRleCwgeyB6OiBoZWlnaHQgfSksIGVuY29kZWRDb2xvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3QgdmVydGV4IG9mIHZlcnRpY2VzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3dyaXRlVmVydGV4KE9iamVjdC5hc3NpZ24oe30sIHZlcnRleCwgeyB6OiAwIH0pLCBlbmNvZGVkQ29sb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLndyaXRlSW5kaWNlcyh0cmlhbmd1bGF0ZShwb2x5Z29uLnZlcnRleFJpbmdzKSk7XHJcbiAgICAgICAgdGhpcy5fYnVpbGRXYWxsKHBvbHlnb24udmVydGV4UmluZ3MsIHZlcnRpY2VzLmxlbmd0aCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kTWVzaCgpO1xyXG4gICAgfVxyXG4gICAgX2J1aWxkV2FsbCh2ZXJ0ZXhSaW5ncywgdmVydGljZXNDb3VudCkge1xyXG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xyXG4gICAgICAgIGZvciAoY29uc3QgcmluZyBvZiB2ZXJ0ZXhSaW5ncykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJpbmcubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZyb20gPSBvZmZzZXQgKyBpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdG8gPSBvZmZzZXQgKyAoaSArIDEpICUgcmluZy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlSW5kaWNlcyhbXHJcbiAgICAgICAgICAgICAgICAgICAgZnJvbSArIHZlcnRpY2VzQ291bnQsXHJcbiAgICAgICAgICAgICAgICAgICAgdG8sXHJcbiAgICAgICAgICAgICAgICAgICAgZnJvbSxcclxuICAgICAgICAgICAgICAgICAgICBmcm9tICsgdmVydGljZXNDb3VudCxcclxuICAgICAgICAgICAgICAgICAgICB0byArIHZlcnRpY2VzQ291bnQsXHJcbiAgICAgICAgICAgICAgICAgICAgdG9cclxuICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9mZnNldCArPSByaW5nLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgQXR0cmlidXRlTWFwcGluZyB9IGZyb20gJy4uLy4uL3JlbmRlci9hdHRyaWJfbWFwcGluZyc7XHJcbmltcG9ydCBCdWZmZXJXcml0ZXIgZnJvbSAnLi4vLi4vdXRpbC9idWZmZXJfd3JpdGVyJztcclxuLyoqXHJcbiAqIEJhc2UgY2xhc3MgZm9yIDNEIG1vZGVscyBidWZmZXIgd3JpdGVycy4gSXQgaXMgbm90IHN1cHBvc2VkIHRvIHdyaXRlIGluZGljZXMsIGluc3RlYWQgaXQgd3JpdGVzIHZlcnRpY2VzIChwb3NzaWJseVxyXG4gKiBkdXBsaWNhdGVkKSBpbiBvcmRlciB0aGF0IGNvcnJlc3BvbmQgdG8gdHJpYW5ndWxhciBmYWNldHMgb2YgdGhlIG1lc2guXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb2RlbEJ1ZmZlcldyaXRlciBleHRlbmRzIEJ1ZmZlcldyaXRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcihNb2RlbEJ1ZmZlcldyaXRlci5BVFRSSUJVVEVfTUFQUElORy52ZXJ0ZXhCeXRlU2l6ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIHZlcnRleCB0byB0aGUgdmVydGV4IGJ1ZmZlci5cclxuICAgICAqL1xyXG4gICAgX3dyaXRlVmVydGV4KHYsIGNvbG9yUmdiYTgpIHtcclxuICAgICAgICBjb25zdCB2ZXJ0ZXhJZHggPSB0aGlzLmdldEN1cnJlbnRWZXJ0ZXhJZHgoKTtcclxuICAgICAgICB0aGlzLl93cml0ZVdvcmxkQ29vcmRpbmF0ZSh2KTtcclxuICAgICAgICB0aGlzLl93cml0ZUZsb2F0MzIodi56KTtcclxuICAgICAgICB0aGlzLl93cml0ZVdvcmQoY29sb3JSZ2JhOCk7XHJcbiAgICAgICAgcmV0dXJuIHZlcnRleElkeDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogRGVzY3JpcHRpb24gb2YgaG93IGF0dHJpYnV0ZXMgb2YgdmVydGljZXMgYXJlIHBhY2tlZCBpbnRvIGEgdmVydGV4IGJ1ZmZlci5cclxuICovXHJcbk1vZGVsQnVmZmVyV3JpdGVyLkFUVFJJQlVURV9NQVBQSU5HID0gbmV3IEF0dHJpYnV0ZU1hcHBpbmcoW1xyXG4gICAgW1xyXG4gICAgICAgIDAgLyogUE9TSVRJT05fSElHSCAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDIsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjMgLyogVU5TSUdORURfU0hPUlQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDEgLyogUE9TSVRJT05fTE9XICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMixcclxuICAgICAgICAgICAgdHlwZTogNTEyMyAvKiBVTlNJR05FRF9TSE9SVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgMyAvKiBIRUlHSFQgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAxLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTI2IC8qIEZMT0FUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgNyAvKiBDT0xPUiAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDQsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjEgLyogVU5TSUdORURfQllURSAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF1cclxuXSk7XHJcbiIsImltcG9ydCBUaWxlV29ybGRDb29yZGluYXRlc0NvbnZlcnRlciBmcm9tICcuL3RpbGVfd29ybGRfY29vcmRpbmF0ZXNfY29udmVydGVyJztcclxuaW1wb3J0IGV4dHJhY3RTdHlsZXMgZnJvbSAnLi9leHRyYWN0X3N0eWxlcyc7XHJcbmltcG9ydCB7IGNvbnZlcnRab29tU2xpY2VUb0xhYmVsU3R5bGUgfSBmcm9tICcuL2V4dHJhY3RfbGFiZWxzJztcclxuLyoqXHJcbiAqIFV0aWxpdHkgbWV0aG9kIGZvciBnZXR0aW5nIGxhYmVsIHBvbHlsaW5lIGZyb20gQVBJIHRpbGUgcmVzcG9uc2UuXHJcbiAqXHJcbiAqIEBwYXJhbSBjdXJ2ZWRMYWJlbHMgQVBJIHRpbGUgcmVzcG9uc2UuXHJcbiAqIEBwYXJhbSBwb2x5bGluZU9mZnNldCBPZmZzZXQgb2YgcG9seWxpbmUgaW4gdmVydGV4IGFycmF5cy5cclxuICogQHBhcmFtIHBvbHlsaW5lTGVuZ3RoIE51bWJlciBvZiBwb2ludHMgaW4gcG9seWxpbmUuXHJcbiAqIEBwYXJhbSBjb252ZXJ0ZXIgVmVydGV4IGNvb3JkaW5hdGVzIGFyZSBzdG9yZWQgaW4gdGlsZSBjb29yZGluYXRlcywgb3V0cHV0IHNob3VsZCBiZSBjb252ZXJ0ZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiogZXh0cmFjdFBvbHlsaW5lKGN1cnZlZExhYmVscywgcG9seWxpbmVPZmZzZXQsIHBvbHlsaW5lTGVuZ3RoLCBjb252ZXJ0ZXIpIHtcclxuICAgIC8vIHRoZSBmaXJzdCB2ZXJ0ZXggaXMgaW4gYWJzb2x1dGUgdGlsZSBjb29yZGluYXRlcyxcclxuICAgIC8vIG90aGVycyAtIGluIGRlbHRhcyB0aGF0IHNob3VsZCBiZSBhZGRlZCB0byB0aGUgcHJldmlvdXMgKGFjY3VtdWxhdGVkKSB2YWx1ZVxyXG4gICAgbGV0IHggPSAwO1xyXG4gICAgbGV0IHkgPSAwO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2x5bGluZUxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgeWllbGQgY29udmVydGVyLnRvV29ybGRDb29yZGluYXRlcyh4ICs9IGN1cnZlZExhYmVscy52ZXJ0ZXhYW3BvbHlsaW5lT2Zmc2V0ICsgaV0sIHkgKz0gY3VydmVkTGFiZWxzLnZlcnRleFlbcG9seWxpbmVPZmZzZXQgKyBpXSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFV0aWxpdHkgbWV0aG9kIGZvciBnZXR0aW5nIHRleHRzICh0ZXh0IGFuZCBhbHRUZXh0KSBmcm9tIEFQSSB0aWxlIHJlc3BvbnNlLiBUaGVzZSB0ZXh0cyBhcmUgYm90aCBvcHRpb25hbCBhbmRcclxuICogcmV0dXJuZWQgaXRlcmFibGUgbWF5IGNvbnRhaW5zIGZyb20gMCB0byAyIHRleHRzLlxyXG4gKlxyXG4gKiBAcGFyYW0gY3VydmVkTGFiZWxzIEFQSSB0aWxlIHJlc3BvbnNlLlxyXG4gKiBAcGFyYW0gaW5kZXggTGFiZWwgcG9zaXRpb24gaW4gY3VydmVkTGFiZWxzJ3MgdGV4dC90ZXh0QWx0IGFycmF5cy5cclxuICovXHJcbmZ1bmN0aW9uKiBleHRyYWN0VGV4dHMoY3VydmVkTGFiZWxzLCBpbmRleCkge1xyXG4gICAgaWYgKGN1cnZlZExhYmVscy50ZXh0W2luZGV4XSkge1xyXG4gICAgICAgIHlpZWxkIHtcclxuICAgICAgICAgICAgdGV4dExpbmVzOiBbeyBnbHlwaElkczogY3VydmVkTGFiZWxzLnRleHRbaW5kZXhdLmdseXBocyB9XVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBpZiAoY3VydmVkTGFiZWxzLnRleHRBbHRbaW5kZXhdICYmIGN1cnZlZExhYmVscy50ZXh0QWx0W2luZGV4XS5nbHlwaHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHlpZWxkIHtcclxuICAgICAgICAgICAgdGV4dExpbmVzOiBbeyBnbHlwaElkczogY3VydmVkTGFiZWxzLnRleHRBbHRbaW5kZXhdLmdseXBocyB9XVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIE92ZXJyaWRkZW4gc3R5bGUgY29udmVydGVyLCB0YWtlcyBjYXJlIG9mIHZlcnRpY2FsIGRpc3RhbmNlIGV4dHJhY3Rpb24uXHJcbiAqL1xyXG5mdW5jdGlvbiBjb252ZXJ0Wm9vbVNsaWNlVG9DdXJ2ZWRMYWJlbFN0eWxlKHNsaWNlLCBzdHlsZUJhc2UpIHtcclxuICAgIGNvbnN0IHN0eWxlID0gY29udmVydFpvb21TbGljZVRvTGFiZWxTdHlsZShzbGljZSwgc3R5bGVCYXNlKTtcclxuICAgIGlmIChzdHlsZSAmJiBzbGljZS5sYWJlbCAmJiBzbGljZS5sYWJlbC5oZGlzdGFuY2UpIHtcclxuICAgICAgICBzdHlsZS5kaXN0YW5jZSA9IHNsaWNlLmxhYmVsLmhkaXN0YW5jZTtcclxuICAgIH1cclxuICAgIHJldHVybiBzdHlsZTtcclxufVxyXG4vKipcclxuICogVXRpbGl0eSBtZXRob2QgZm9yIGdldHRpbmcgY3VydmVkIGxhYmVscyBmcm9tIEFQSSB0aWxlIHJlc3BvbnNlLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24qIGV4dHJhY3RDdXJ2ZWRMYWJlbHModGlsZSwgZGVjb2RlZEFwaVRpbGUsIHRpbGVNaW5ab29tLCB0aWxlTWF4Wm9vbSkge1xyXG4gICAgY29uc3QgbGFiZWxzID0gZGVjb2RlZEFwaVRpbGUucG9seWxpbmVMYWJlbHM7XHJcbiAgICBpZiAobGFiZWxzKSB7XHJcbiAgICAgICAgY29uc3QgY29udmVydGVyID0gbmV3IFRpbGVXb3JsZENvb3JkaW5hdGVzQ29udmVydGVyKHRpbGUpO1xyXG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGFiZWxzLnRleHQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgY2xhc3NJZCA9IGxhYmVscy5jbGFzc0lkW2ldO1xyXG4gICAgICAgICAgICBjb25zdCB2ZXJ0ZXhDb3VudCA9IGxhYmVscy52ZXJ0aWNlc0NvdW50W2ldO1xyXG4gICAgICAgICAgICB5aWVsZCB7XHJcbiAgICAgICAgICAgICAgICBwb2x5bGluZTogWy4uLmV4dHJhY3RQb2x5bGluZShsYWJlbHMsIG9mZnNldCwgdmVydGV4Q291bnQsIGNvbnZlcnRlcildLFxyXG4gICAgICAgICAgICAgICAgcHJpb3JpdHk6IGxhYmVscy5wcmlvcml0eVtpXSxcclxuICAgICAgICAgICAgICAgIHRleHRzOiBbLi4uZXh0cmFjdFRleHRzKGxhYmVscywgaSldLFxyXG4gICAgICAgICAgICAgICAgc3R5bGVzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgLi4uZXh0cmFjdFN0eWxlcyhkZWNvZGVkQXBpVGlsZS5wcmVzZW50YXRpb24sIGNsYXNzSWQsIGNvbnZlcnRab29tU2xpY2VUb0N1cnZlZExhYmVsU3R5bGUsIHRpbGVNaW5ab29tLCB0aWxlTWF4Wm9vbSlcclxuICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgb2Zmc2V0ICs9IHZlcnRleENvdW50O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBkZWNvZGVBYmdyOCB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWwvY29sb3InO1xyXG5mdW5jdGlvbiBjb252ZXJ0VGV4dFN0eWxlKHN0eWxlKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGNvbG9yOiBkZWNvZGVBYmdyOChzdHlsZS5jb2xvciksXHJcbiAgICAgICAgb3V0bGluZUNvbG9yOiBkZWNvZGVBYmdyOChzdHlsZS5vdXRsaW5lQ29sb3IpLFxyXG4gICAgICAgIGZvbnRJZDogc3R5bGUuZm9udElkLFxyXG4gICAgICAgIGZvbnRTaXplOiBzdHlsZS5mb250U2l6ZVxyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogVXRpbGl0eSBtZXRob2QgZm9yIGdldHRpbmcgcG9pbnQgbGFiZWwgc3BlY2lmaWMgc3R5bGUgZGV0YWlscyBmcm9tIGEgem9vbSBzbGljZS5cclxuICogVG8gYmUgdXNlZCBhcyBhIHpvb20gc2xpY2Ugc3R5bGUgY29udmVydGVyIGZvciBzdHlsZSBleHRyYWN0b3IuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFpvb21TbGljZVRvTGFiZWxTdHlsZShzbGljZSwgc3R5bGVCYXNlKSB7XHJcbiAgICBjb25zdCBzdHlsZXMgPSBbXTtcclxuICAgIGlmIChzbGljZS5sYWJlbCkge1xyXG4gICAgICAgIGlmIChzbGljZS5sYWJlbC50ZXh0KSB7XHJcbiAgICAgICAgICAgIHN0eWxlcy5wdXNoKGNvbnZlcnRUZXh0U3R5bGUoc2xpY2UubGFiZWwudGV4dCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2xpY2UubGFiZWwudGV4dEFsdCkge1xyXG4gICAgICAgICAgICBzdHlsZXMucHVzaChjb252ZXJ0VGV4dFN0eWxlKHNsaWNlLmxhYmVsLnRleHRBbHQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0eWxlQmFzZSwgeyBkaXN0YW5jZTogMCwgc3R5bGVzOiBzdHlsZXMsIGFsaWduOiAxIC8qIENFTlRFUiAqLywgYmFja2dyb3VuZDogc2xpY2UubGFiZWwuYmFja2dyb3VuZCA/XHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IGRlY29kZUFiZ3I4KHNsaWNlLmxhYmVsLmJhY2tncm91bmQuY29sb3IpLFxyXG4gICAgICAgICAgICAgICAgICAgIHZlcnRpY2FsUGFkZGluZzogc2xpY2UubGFiZWwuYmFja2dyb3VuZC52UGFkZGluZyxcclxuICAgICAgICAgICAgICAgICAgICBob3Jpem9udGFsUGFkZGluZzogc2xpY2UubGFiZWwuYmFja2dyb3VuZC5oUGFkZGluZ1xyXG4gICAgICAgICAgICAgICAgfSA6XHJcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG59XHJcbiIsImltcG9ydCB7IFRpbGUgfSBmcm9tICcuLi9wcm90b19hbGlhc2VzJztcclxuaW1wb3J0IFRpbGVXb3JsZENvb3JkaW5hdGVzQ29udmVydGVyIGZyb20gJy4vdGlsZV93b3JsZF9jb29yZGluYXRlc19jb252ZXJ0ZXInO1xyXG5pbXBvcnQgKiBhcyB2ZWN0b3IyIGZyb20gJy4uLy4uLy4uLy4uL21hdGgvdmVjdG9yMic7XHJcbmltcG9ydCBleHRyYWN0U3R5bGVzIGZyb20gJy4vZXh0cmFjdF9zdHlsZXMnO1xyXG5pbXBvcnQgeyBjb252ZXJ0Wm9vbVNsaWNlVG9MYWJlbFN0eWxlIH0gZnJvbSAnLi9leHRyYWN0X2xhYmVscyc7XHJcbmNvbnN0IEFMSUdOTUVOVCA9IHtcclxuICAgIFtUaWxlLlN0cmFpZ2h0TGFiZWxzLkFsaWduVHlwZS5MZWZ0XTogMCAvKiBMRUZUICovLFxyXG4gICAgW1RpbGUuU3RyYWlnaHRMYWJlbHMuQWxpZ25UeXBlLlJpZ2h0XTogMiAvKiBSSUdIVCAqLyxcclxuICAgIFtUaWxlLlN0cmFpZ2h0TGFiZWxzLkFsaWduVHlwZS5DZW50ZXJdOiAxIC8qIENFTlRFUiAqL1xyXG59O1xyXG4vKipcclxuICogVXRpbGl0eSBtZXRob2QgZm9yIGdldHRpbmcgdGV4dHMgKHRleHQgYW5kIGFsdFRleHQpIGZyb20gQVBJIHRpbGUgcmVzcG9uc2UuIFRoZXNlIHRleHRzIGFyZSBib3RoIG9wdGlvbmFsIGFuZFxyXG4gKiByZXR1cm5lZCBpdGVyYWJsZSBtYXkgY29udGFpbnMgZnJvbSAwIHRvIDIgdGV4dHMuXHJcbiAqXHJcbiAqIEBwYXJhbSBwb2ludExhYmVscyBBUEkgdGlsZSByZXNwb25zZS5cclxuICogQHBhcmFtIGluZGV4IExhYmVsIHBvc2l0aW9uIGluIHBvaW50TGFiZWwncyB0ZXh0L3RleHRBbHQgYXJyYXlzLlxyXG4gKi9cclxuZnVuY3Rpb24qIGV4dHJhY3RUZXh0cyhwb2ludExhYmVscywgaW5kZXgpIHtcclxuICAgIGlmIChwb2ludExhYmVscy50ZXh0W2luZGV4XSkge1xyXG4gICAgICAgIHlpZWxkIHtcclxuICAgICAgICAgICAgdGV4dExpbmVzOiBwb2ludExhYmVscy50ZXh0W2luZGV4XS5zdHJpbmdzLm1hcCgoc3RyKSA9PiAoeyBnbHlwaElkczogc3RyLmdseXBocyB9KSlcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgaWYgKHBvaW50TGFiZWxzLnRleHRBbHRbaW5kZXhdICYmIHBvaW50TGFiZWxzLnRleHRBbHRbaW5kZXhdLnN0cmluZ3MubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHlpZWxkIHtcclxuICAgICAgICAgICAgdGV4dExpbmVzOiBwb2ludExhYmVscy50ZXh0QWx0W2luZGV4XS5zdHJpbmdzLm1hcCgoc3RyKSA9PiAoeyBnbHlwaElkczogc3RyLmdseXBocyB9KSlcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBPdmVycmlkZGVuIHN0eWxlIGNvbnZlcnRlciwgdGFrZXMgY2FyZSBvZiB2ZXJ0aWNhbCBkaXN0YW5jZSBleHRyYWN0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gY29udmVydFpvb21TbGljZVRvU3RyYWlnaHRMYWJlbFN0eWxlKHNsaWNlLCBzdHlsZUJhc2UpIHtcclxuICAgIGNvbnN0IHN0eWxlID0gY29udmVydFpvb21TbGljZVRvTGFiZWxTdHlsZShzbGljZSwgc3R5bGVCYXNlKTtcclxuICAgIGlmIChzdHlsZSAmJiBzbGljZS5sYWJlbCkge1xyXG4gICAgICAgIHN0eWxlLmRpc3RhbmNlID0gc2xpY2UubGFiZWwudmRpc3RhbmNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHN0eWxlO1xyXG59XHJcbi8qKlxyXG4gKiBVdGlsaXR5IG1ldGhvZCBmb3IgZ2V0dGluZyBwb2ludCBsYWJlbHMgZnJvbSBBUEkgdGlsZSByZXNwb25zZS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKiBleHRyYWN0UG9pbnRMYWJlbCh0aWxlLCBkZWNvZGVkQXBpVGlsZSwgdGlsZU1pblpvb20sIHRpbGVNYXhab29tKSB7XHJcbiAgICBjb25zdCBwb2ludExhYmVscyA9IGRlY29kZWRBcGlUaWxlLnBvaW50TGFiZWxzO1xyXG4gICAgaWYgKHBvaW50TGFiZWxzKSB7XHJcbiAgICAgICAgY29uc3QgY29udmVydGVyID0gbmV3IFRpbGVXb3JsZENvb3JkaW5hdGVzQ29udmVydGVyKHRpbGUpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRMYWJlbHMudGV4dC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBjbGFzc0lkID0gcG9pbnRMYWJlbHMuY2xhc3NJZFtpXTtcclxuICAgICAgICAgICAgY29uc3Qgc3R5bGVzID0gWy4uLmV4dHJhY3RTdHlsZXMoZGVjb2RlZEFwaVRpbGUucHJlc2VudGF0aW9uLCBjbGFzc0lkLCBjb252ZXJ0Wm9vbVNsaWNlVG9TdHJhaWdodExhYmVsU3R5bGUsIHRpbGVNaW5ab29tLCB0aWxlTWF4Wm9vbSldO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHN0eWxlIG9mIHN0eWxlcykge1xyXG4gICAgICAgICAgICAgICAgc3R5bGUuYWxpZ24gPSBBTElHTk1FTlRbcG9pbnRMYWJlbHMuYWxpZ25baV1dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHlpZWxkIHtcclxuICAgICAgICAgICAgICAgIGFuY2hvclBvaW50OiBjb252ZXJ0ZXIudG9Xb3JsZENvb3JkaW5hdGVzKHBvaW50TGFiZWxzLmNlbnRlclhbaV0sIHBvaW50TGFiZWxzLmNlbnRlcllbaV0pLFxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiB2ZWN0b3IyLmNyZWF0ZShwb2ludExhYmVscy5vZmZzZXRYW2ldLCBwb2ludExhYmVscy5vZmZzZXRZW2ldKSxcclxuICAgICAgICAgICAgICAgIHByaW9yaXR5OiBwb2ludExhYmVscy5wcmlvcml0eVtpXSxcclxuICAgICAgICAgICAgICAgIHRleHRzOiBbLi4uZXh0cmFjdFRleHRzKHBvaW50TGFiZWxzLCBpKV0sXHJcbiAgICAgICAgICAgICAgICBzdHlsZXM6IHN0eWxlc1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgKiBhcyB2ZWN0b3IyIGZyb20gJy4uLy4uL21hdGgvdmVjdG9yMic7XHJcbi8qKlxyXG4gKiBAcmV0dXJucyBGdWxsIHdpZHRoIG9mIGFsbCBsaW5lIGdseXBocyB1c2luZyBnbHlwaCdzIGFkdmFuY2UgbWV0cmljIChpdCBkb2Vzbid0IHRha2UgaW50byBhY2NvdW50IHRoZSBmb250IHNpemUpLlxyXG4gKi9cclxuZnVuY3Rpb24gY2FsY3VsYXRlTGluZVdpZHRoKGZvbnQsIGxpbmUpIHtcclxuICAgIHJldHVybiBsaW5lLmdseXBoSWRzLnJlZHVjZSgod2lkdGgsIGdseXBoSWQpID0+IHtcclxuICAgICAgICByZXR1cm4gd2lkdGggKyBmb250LmdldEdseXBoKGdseXBoSWQpLmFkdmFuY2U7XHJcbiAgICB9LCAwKTtcclxufVxyXG4vKipcclxuICogQHJldHVybnMgUmVhbCBtYXggaGVpZ2h0IG9mIHRoZSBsaW5lIGxvb2tpbmcgdGhyb3VnaCBhbGwgdGhlIGdseXBocyBhbmQgdGhlaXIgYmVhcmluZ1kgYW5kIGhlaWdodCBtZXRyaWNzLlxyXG4gKi9cclxuZnVuY3Rpb24gY2FsY3VsYXRlTGluZUhlaWdodChmb250LCBsaW5lKSB7XHJcbiAgICBsZXQgbWF4SGVpZ2h0QWJvdmVCYXNlbGluZSA9IDA7XHJcbiAgICBsZXQgbWF4SGVpZ2h0QmVsb3dCYXNlbGluZSA9IDA7XHJcbiAgICBmb3IgKGNvbnN0IGdseXBoSWQgb2YgbGluZS5nbHlwaElkcykge1xyXG4gICAgICAgIGNvbnN0IGdseXBoID0gZm9udC5nZXRHbHlwaChnbHlwaElkKTtcclxuICAgICAgICBtYXhIZWlnaHRBYm92ZUJhc2VsaW5lID0gTWF0aC5tYXgobWF4SGVpZ2h0QWJvdmVCYXNlbGluZSwgZ2x5cGguYmVhcmluZ1kpO1xyXG4gICAgICAgIG1heEhlaWdodEJlbG93QmFzZWxpbmUgPSBNYXRoLm1heChtYXhIZWlnaHRCZWxvd0Jhc2VsaW5lLCBnbHlwaC5oZWlnaHQgLSBnbHlwaC5iZWFyaW5nWSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWF4SGVpZ2h0QWJvdmVCYXNlbGluZSArIG1heEhlaWdodEJlbG93QmFzZWxpbmU7XHJcbn1cclxuLyoqXHJcbiAqIExheW91dCBvbmUgc3RyYWlnaHQgbGluZSBpbiBhYnNvbHV0ZSAodG8gdGhlIHdob2xlIGxhYmVsKSBjb29yZGluYXRlcyB1c2luZyB0aGUgb3JpZ2luIHBvaW50IGFzIGFuIG9mZnNldCB2ZWN0b3IuXHJcbiAqL1xyXG5mdW5jdGlvbiogbGF5b3V0TGluZSh0ZXh0TGluZSwgeE9yaWdpbiwgeU9yaWdpbiwgZm9udCwgc2NhbGUpIHtcclxuICAgIGNvbnN0IGdseXBoSWRzID0gdGV4dExpbmUuZ2x5cGhJZHM7XHJcbiAgICBjb25zdCBsZW5ndGggPSBnbHlwaElkcy5sZW5ndGg7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgZ2x5cGggPSBmb250LmdldEdseXBoKGdseXBoSWRzW2ldKTtcclxuICAgICAgICBjb25zdCBsZWZ0ID0geE9yaWdpbiArIChnbHlwaC5iZWFyaW5nWCAtIGZvbnQubWFyZ2luKSAqIHNjYWxlO1xyXG4gICAgICAgIGNvbnN0IHJpZ2h0ID0geE9yaWdpbiArIChnbHlwaC5iZWFyaW5nWCArIGdseXBoLndpZHRoICsgZm9udC5tYXJnaW4pICogc2NhbGU7XHJcbiAgICAgICAgY29uc3QgdG9wID0geU9yaWdpbiArIChnbHlwaC5iZWFyaW5nWSArIGZvbnQubWFyZ2luKSAqIHNjYWxlO1xyXG4gICAgICAgIGNvbnN0IGJvdHRvbSA9IHlPcmlnaW4gKyAoZ2x5cGguYmVhcmluZ1kgLSBnbHlwaC5oZWlnaHQgLSBmb250Lm1hcmdpbikgKiBzY2FsZTtcclxuICAgICAgICBjb25zdCB0b3BMZWZ0ID0gdmVjdG9yMi5jcmVhdGUobGVmdCwgdG9wKTtcclxuICAgICAgICBjb25zdCB0b3BSaWdodCA9IHZlY3RvcjIuY3JlYXRlKHJpZ2h0LCB0b3ApO1xyXG4gICAgICAgIGNvbnN0IGJvdHRvbVJpZ2h0ID0gdmVjdG9yMi5jcmVhdGUocmlnaHQsIGJvdHRvbSk7XHJcbiAgICAgICAgY29uc3QgYm90dG9tTGVmdCA9IHZlY3RvcjIuY3JlYXRlKGxlZnQsIGJvdHRvbSk7XHJcbiAgICAgICAgeWllbGQge1xyXG4gICAgICAgICAgICBmb250SWQ6IGZvbnQuaWQsXHJcbiAgICAgICAgICAgIGdseXBoSWQ6IGdseXBoLmlkLFxyXG4gICAgICAgICAgICBzY2FsZSxcclxuICAgICAgICAgICAgdG9wTGVmdCxcclxuICAgICAgICAgICAgdG9wUmlnaHQsXHJcbiAgICAgICAgICAgIGJvdHRvbVJpZ2h0LFxyXG4gICAgICAgICAgICBib3R0b21MZWZ0XHJcbiAgICAgICAgfTtcclxuICAgICAgICB4T3JpZ2luICs9IGdseXBoLmFkdmFuY2UgKiBzY2FsZTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogSG93IGJpZ2dlciB0aGUgbGluZSBoZWlnaHQgdG8gdGhlIGZvbnQgc2l6ZS5cclxuICovXHJcbmNvbnN0IExJTkVfSEVJR0hUX0ZBQ1RPUiA9IDEuNTtcclxuLyoqXHJcbiAqIEFkZGl0aW9uYWwgc3BhY2UgYmV0d2VlbiB0aGUgbGluZXMuXHJcbiAqL1xyXG5jb25zdCBGT05UX0xFQURJTkcgPSAzO1xyXG4vKipcclxuICogQ3JlYXRlcyBsYXlvdXQgb2YgZ2x5cGhzIGluIGFic3RyYWN0IHBvaW50cywgdGhhdCBhcmUgcm91Z2hseSBjb3JyZXNwb25kIHRvIENTUyBwaXhlbHMgYW5kIHNob3VsZCBiZSByZW5kZXJlZFxyXG4gKiBhY2NvcmRpbmdseS4gVGV4dCdzIHRleHRMaW5lcyBhbGwgc3RhcnQgZnJvbSBuZXcgbGluZXMsIGEgdGV4dCBpcyBqdXN0IGEgc2V0IG9mIGxpbmVzIHdpdGggY29tbW9uIHN0eWxlcy5cclxuICogVGhlIG9yaWdpbiAoMCwgMCkgZGVwZW5kaW5nIG9uIHRoZSBhbGlnbm1lbnQgaXMgbG9jYXRlZCBhdDpcclxuICogICogdGhlIGZpcnN0IGxpbmUncyBiYXNlbGluZSBsZWZ0bW9zdCBwb2ludCBmb3IgTEVGVFxyXG4gKiAgKiB0aGUgZmlyc3QgbGluZSdzIGJhc2VsaW5lIGNlbnRlciBwb2ludCBmb3IgQ0VOVEVSXHJcbiAqICAqIHRoZSBmaXJzdCBsaW5lJ3MgYmFzZWxpbmUgcmlnaHRtb3N0IHBvaW50IGZvciBSSUdIVFxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbGF5b3V0UG9pbnRMYWJlbChsYWJlbCwgbGFiZWxTdHlsZSwgZm9udFJlZ2lzdHJ5KSB7XHJcbiAgICBjb25zdCBsYXlvdXQgPSBbXTtcclxuICAgIGNvbnN0IHRleHRMaW5lRGV0YWlscyA9IGxhYmVsLnRleHRzLm1hcCgodGV4dCwgaSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHRleHRTdHlsZSA9IGxhYmVsU3R5bGUuc3R5bGVzW2ldO1xyXG4gICAgICAgIGNvbnN0IGZvbnQgPSBmb250UmVnaXN0cnkuZ2V0KHRleHRTdHlsZS5mb250SWQpO1xyXG4gICAgICAgIGNvbnN0IHNjYWxlID0gdGV4dFN0eWxlLmZvbnRTaXplIC8gZm9udC54aGVpZ2h0O1xyXG4gICAgICAgIGNvbnN0IGhlaWdodCA9IHRleHRTdHlsZS5mb250U2l6ZSAqIExJTkVfSEVJR0hUX0ZBQ1RPUjtcclxuICAgICAgICByZXR1cm4gdGV4dC50ZXh0TGluZXMubWFwKChsaW5lKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gY2FsY3VsYXRlTGluZVdpZHRoKGZvbnQsIGxpbmUpICogc2NhbGU7XHJcbiAgICAgICAgICAgIGNvbnN0IG1heEhlaWdodCA9IGNhbGN1bGF0ZUxpbmVIZWlnaHQoZm9udCwgbGluZSkgKiBzY2FsZTtcclxuICAgICAgICAgICAgcmV0dXJuIHsgbGluZSwgZm9udCwgc2NhbGUsIHdpZHRoLCBoZWlnaHQsIG1heEhlaWdodCB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgICBjb25zdCBiYm94U2l6ZSA9IHRleHRMaW5lRGV0YWlscy5yZWR1Y2UoKGJib3hTaXplLCBsaW5lU2l6ZXMpID0+IHtcclxuICAgICAgICByZXR1cm4gbGluZVNpemVzLnJlZHVjZSgoYmJveFNpemUsIGxpbmVTaXplKSA9PiB7XHJcbiAgICAgICAgICAgIGJib3hTaXplLndpZHRoID0gTWF0aC5tYXgoYmJveFNpemUud2lkdGgsIGxpbmVTaXplLndpZHRoKTtcclxuICAgICAgICAgICAgYmJveFNpemUuaGVpZ2h0ICs9IGxpbmVTaXplLm1heEhlaWdodDtcclxuICAgICAgICAgICAgcmV0dXJuIGJib3hTaXplO1xyXG4gICAgICAgIH0sIGJib3hTaXplKTtcclxuICAgIH0sIHtcclxuICAgICAgICB3aWR0aDogMCxcclxuICAgICAgICBoZWlnaHQ6IGxhYmVsU3R5bGUuZGlzdGFuY2UgKiAodGV4dExpbmVEZXRhaWxzLmxlbmd0aCAtIDEpXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IHhPcmlnaW4gPSBsYWJlbC5vZmZzZXQueCAtIGJib3hTaXplLndpZHRoIC8gMjtcclxuICAgIGxldCB5T3JpZ2luID0gbGFiZWwub2Zmc2V0LnkgKyBiYm94U2l6ZS5oZWlnaHQgLyAyO1xyXG4gICAgbGV0IGlzRmlyc3RUZXh0TGluZSA9IHRydWU7XHJcbiAgICBmb3IgKGNvbnN0IHRleHRMaW5lcyBvZiB0ZXh0TGluZURldGFpbHMpIHtcclxuICAgICAgICBjb25zdCB0ZXh0TGF5b3V0ID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIHRleHRMaW5lcykge1xyXG4gICAgICAgICAgICBjb25zdCBsaW5lWU9yaWdpbiA9ICh5T3JpZ2luIC09IGxpbmUuaGVpZ2h0ICsgKGlzRmlyc3RUZXh0TGluZSA/IDAgOiBGT05UX0xFQURJTkcpKTtcclxuICAgICAgICAgICAgY29uc3QgbGluZVhPcmlnaW4gPSB4T3JpZ2luICsgKChsYWJlbFN0eWxlLmFsaWduID09PSAwIC8qIExFRlQgKi8pID8gMCA6XHJcbiAgICAgICAgICAgICAgICAobGFiZWxTdHlsZS5hbGlnbiA9PT0gMSAvKiBDRU5URVIgKi8pID8gKGJib3hTaXplLndpZHRoIC0gbGluZS53aWR0aCkgLyAyIDpcclxuICAgICAgICAgICAgICAgICAgICAobGFiZWxTdHlsZS5hbGlnbiA9PT0gMiAvKiBSSUdIVCAqLykgPyAoYmJveFNpemUud2lkdGggLSBsaW5lLndpZHRoKSA6IDApO1xyXG4gICAgICAgICAgICBpc0ZpcnN0VGV4dExpbmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBnbHlwaExheW91dCBvZiBsYXlvdXRMaW5lKGxpbmUubGluZSwgbGluZVhPcmlnaW4sIGxpbmVZT3JpZ2luLCBsaW5lLmZvbnQsIGxpbmUuc2NhbGUpKSB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0TGF5b3V0LnB1c2goZ2x5cGhMYXlvdXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHlPcmlnaW4gLT0gbGFiZWxTdHlsZS5kaXN0YW5jZTtcclxuICAgICAgICBsYXlvdXQucHVzaCh0ZXh0TGF5b3V0KTtcclxuICAgIH1cclxuICAgIHJldHVybiBsYXlvdXQ7XHJcbn1cclxuIiwiaW1wb3J0IEJ1ZmZlcldyaXRlciBmcm9tICcuLi8uLi91dGlsL2J1ZmZlcl93cml0ZXInO1xyXG5pbXBvcnQgKiBhcyB2ZWMyIGZyb20gJy4uLy4uL21hdGgvdmVjdG9yMic7XHJcbmltcG9ydCB7IGVuY29kZVJnYmE4IH0gZnJvbSAnLi4vLi4vdXRpbC9jb2xvcic7XHJcbmltcG9ydCB7IEJJTExCT0FSRF9SRUNUQU5HTEVfQVRUUklCVVRFX01BUFBJTkcgfSBmcm9tICcuL2F0dHJpYnV0ZV9tYXBwaW5nJztcclxuaW1wb3J0IHsgZmxvYXRUb1VpbnQxNiB9IGZyb20gJy4uLy4uL3V0aWwvZ3B1dHlwZXMnO1xyXG5jb25zdCBCT1RUT01fTEVGVF9VVl9JTlQxNiA9IHZlYzIuY3JlYXRlKC0weDgwMDAsIC0weDgwMDApO1xyXG5jb25zdCBUT1BfTEVGVF9VVl9JTlQxNiA9IHZlYzIuY3JlYXRlKC0weDgwMDAsIDB4N2ZmZik7XHJcbmNvbnN0IEJPVFRPTV9SSUdIVF9VVl9JTlQxNiA9IHZlYzIuY3JlYXRlKDB4N2ZmZiwgLTB4ODAwMCk7XHJcbmNvbnN0IFRPUF9SSUdIVF9VVl9JTlQxNiA9IHZlYzIuY3JlYXRlKDB4N2ZmZiwgMHg3ZmZmKTtcclxuLyoqXHJcbiAqIFdyaXRlciBvZiBnZW9tZXRyeSBkYXRhIG9mIHJlY3RhbmdsZXMuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCaWxsYm9hcmRSZWN0YW5nbGVCdWZmZXJXcml0ZXIgZXh0ZW5kcyBCdWZmZXJXcml0ZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoQklMTEJPQVJEX1JFQ1RBTkdMRV9BVFRSSUJVVEVfTUFQUElORy52ZXJ0ZXhCeXRlU2l6ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIHJlY3RhbmdsZSB0byBidWZmZXJzLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIExvY2F0aW9uIG9mIHRoZSBpbWFnZSBkYXRhIGluIGJ1ZmZlcnMuXHJcbiAgICAgKi9cclxuICAgIHdyaXRlUmVjdGFuZ2xlKGlkLCByZWN0YW5nbGUsIHN0eWxlKSB7XHJcbiAgICAgICAgY29uc3QgaWRIaWdoID0gaWQgPj4gODtcclxuICAgICAgICBjb25zdCBpZExvdyA9IGlkICYgMHhmZjtcclxuICAgICAgICBjb25zdCB7IGJvcmRlclJhZGl1cywgb2Zmc2V0LCB3aWR0aCwgaGVpZ2h0IH0gPSBzdHlsZTtcclxuICAgICAgICBjb25zdCBoYWxmV2lkdGggPSB3aWR0aCAvIDI7XHJcbiAgICAgICAgY29uc3QgaGFsZkhlaWdodCA9IGhlaWdodCAvIDI7XHJcbiAgICAgICAgY29uc3QgY29sb3JSZ2JhOCA9IGVuY29kZVJnYmE4KHN0eWxlLmNvbG9yKTtcclxuICAgICAgICBjb25zdCBib3JkZXJSYWRpdXNYID0gYm9yZGVyUmFkaXVzIC8gaGFsZldpZHRoO1xyXG4gICAgICAgIGNvbnN0IGJvcmRlclJhZGl1c1kgPSBib3JkZXJSYWRpdXMgLyBoYWxmSGVpZ2h0O1xyXG4gICAgICAgIHRoaXMuX3dyaXRlVmVydGV4KGlkSGlnaCwgaWRMb3csIHJlY3RhbmdsZS5wb3NpdGlvbiwgLWhhbGZXaWR0aCwgLWhhbGZIZWlnaHQsIG9mZnNldCwgQk9UVE9NX0xFRlRfVVZfSU5UMTYsIGNvbG9yUmdiYTgsIGJvcmRlclJhZGl1c1gsIGJvcmRlclJhZGl1c1kpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlVmVydGV4KGlkSGlnaCwgaWRMb3csIHJlY3RhbmdsZS5wb3NpdGlvbiwgLWhhbGZXaWR0aCwgaGFsZkhlaWdodCwgb2Zmc2V0LCBUT1BfTEVGVF9VVl9JTlQxNiwgY29sb3JSZ2JhOCwgYm9yZGVyUmFkaXVzWCwgYm9yZGVyUmFkaXVzWSk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVWZXJ0ZXgoaWRIaWdoLCBpZExvdywgcmVjdGFuZ2xlLnBvc2l0aW9uLCBoYWxmV2lkdGgsIC1oYWxmSGVpZ2h0LCBvZmZzZXQsIEJPVFRPTV9SSUdIVF9VVl9JTlQxNiwgY29sb3JSZ2JhOCwgYm9yZGVyUmFkaXVzWCwgYm9yZGVyUmFkaXVzWSk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVWZXJ0ZXgoaWRIaWdoLCBpZExvdywgcmVjdGFuZ2xlLnBvc2l0aW9uLCBoYWxmV2lkdGgsIGhhbGZIZWlnaHQsIG9mZnNldCwgVE9QX1JJR0hUX1VWX0lOVDE2LCBjb2xvclJnYmE4LCBib3JkZXJSYWRpdXNYLCBib3JkZXJSYWRpdXNZKTtcclxuICAgICAgICB0aGlzLndyaXRlSW5kaWNlc0ZvckNvbnRpbnVvdXNTdHJpcCg0KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5lbmRNZXNoKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIHZlcnRleCB0byB0aGUgdmVydGV4IGJ1ZmZlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaWRIaWdoIE1vc3Qgc2lnbmlmaWNhbnQgOCBiaXRzIG9mIHJlY3RhbmdsZSBpZC5cclxuICAgICAqIEBwYXJhbSBpZExvdyBMZWFzdCBzaWduaWZpY2FudCA4IGJpdHMgb2YgcmVjdGFuZ2xlIGlkLlxyXG4gICAgICogQHBhcmFtIHBvc2l0aW9uIFdvcmxkIGNvb3JkaW5hdGUgb2YgcmVjdGFuZ2xlLlxyXG4gICAgICogQHBhcmFtIGRpc3BsYWNlbWVudFggWCBjb29yZGluYXRlIGRpc3BsYWNlbWVudCBpbiBwaXhlbHMgb2YgY29uY3JldGUgdmVydGV4LlxyXG4gICAgICogQHBhcmFtIGRpc3BsYWNlbWVudFkgWSBjb29yZGluYXRlIGRpc3BsYWNlbWVudCBpbiBwaXhlbHMgb2YgY29uY3JldGUgdmVydGV4LlxyXG4gICAgICogQHBhcmFtIG9mZnNldCBBZGRpdGlvbmFsIGRpc3BsYWNlbWVudCBmb3IgYWxsIHZlcnRpY2VzIHNwZWNpZmllZCBpbiBzdHlsZS5cclxuICAgICAqIEBwYXJhbSB1diBVViBjb29yZGluYXRlZCBvZiB0aGUgdmVydGV4IG9mIHRoZSByZWN0YW5nbGUuXHJcbiAgICAgKiBAcGFyYW0gY29sb3IgQmFja2dyb3VuZCBjb2xvciBlbmNvZGVkIGludG8gUkdCQThcclxuICAgICAqIEBwYXJhbSBib3JkZXJSYWRpdXNYIFJhZGl1cyBvZiBjb3JuZXIgcm91bmRpbmcgYWxvbmcgWCBheGlzIChpLmUuLCBob3Jpem9udGFsXHJcbiAgICAgKiAgICAgIGF4aXMgb2Ygcm91bmRpbmcgZWxsaXBzZSkuXHJcbiAgICAgKiBAcGFyYW0gYm9yZGVyUmFkaXVzWSBSYWRpdXMgb2YgY29ybmVyIHJvdW5kaW5nIGFsb25nIFkgYXhpcyAoaS5lLiwgdmVydGljYWxcclxuICAgICAqICAgICAgYXhpcyBvZiByb3VuZGluZyBlbGxpcHNlKS5cclxuICAgICAqIEByZXR1cm5zIEluZGV4IG9mIHRoZSB3cml0dGVuIHZlcnRleC5cclxuICAgICAqL1xyXG4gICAgX3dyaXRlVmVydGV4KGlkSGlnaCwgaWRMb3csIHBvc2l0aW9uLCBkaXNwbGFjZW1lbnRYLCBkaXNwbGFjZW1lbnRZLCBvZmZzZXQsIHV2LCBjb2xvclJnYmE4LCBib3JkZXJSYWRpdXNYLCBib3JkZXJSYWRpdXNZKSB7XHJcbiAgICAgICAgY29uc3QgdmVydGV4SWR4ID0gdGhpcy5nZXRDdXJyZW50VmVydGV4SWR4KCk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVCeXRlcyhpZEhpZ2gsIGlkTG93LCAwLCAwKTtcclxuICAgICAgICB0aGlzLl93cml0ZVdvcmxkQ29vcmRpbmF0ZShwb3NpdGlvbik7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVGbG9hdDMyKGRpc3BsYWNlbWVudFggKyBvZmZzZXQueCk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVGbG9hdDMyKGRpc3BsYWNlbWVudFkgKyBvZmZzZXQueSk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVIYWxmV29yZHModXYueCwgdXYueSk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVXb3JkKGNvbG9yUmdiYTgpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlSGFsZldvcmRzKGZsb2F0VG9VaW50MTYoYm9yZGVyUmFkaXVzWCksIGZsb2F0VG9VaW50MTYoYm9yZGVyUmFkaXVzWSkpO1xyXG4gICAgICAgIHJldHVybiB2ZXJ0ZXhJZHg7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgQXR0cmlidXRlTWFwcGluZyB9IGZyb20gJy4uLy4uL3JlbmRlci9hdHRyaWJfbWFwcGluZyc7XHJcbi8qKiBEZXNjcmlwdGlvbiBvZiBob3cgYSB3cml0ZXIgc3RvcmVzIHZlcnRleCBkYXRhLiAqL1xyXG5leHBvcnQgY29uc3QgQklMTEJPQVJEX1JFQ1RBTkdMRV9BVFRSSUJVVEVfTUFQUElORyA9IG5ldyBBdHRyaWJ1dGVNYXBwaW5nKFtcclxuICAgIFtcclxuICAgICAgICAyIC8qIElEICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogNCxcclxuICAgICAgICAgICAgdHlwZTogNTEyMSAvKiBVTlNJR05FRF9CWVRFICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICAwIC8qIFBPU0lUSU9OX0hJR0ggKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIzIC8qIFVOU0lHTkVEX1NIT1JUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICAxIC8qIFBPU0lUSU9OX0xPVyAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDIsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjMgLyogVU5TSUdORURfU0hPUlQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDYgLyogRElTUExBQ0VNRU5UICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMixcclxuICAgICAgICAgICAgdHlwZTogNTEyNiAvKiBGTE9BVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDQgLyogVVYgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIyIC8qIFNIT1JUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICA3IC8qIENPTE9SICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogNCxcclxuICAgICAgICAgICAgdHlwZTogNTEyMSAvKiBVTlNJR05FRF9CWVRFICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICAxMSAvKiBBVVggKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIzIC8qIFVOU0lHTkVEX1NIT1JUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXVxyXG5dKTtcclxuIiwiaW1wb3J0IEJ1ZmZlcldyaXRlciBmcm9tICcuLi8uLi91dGlsL2J1ZmZlcl93cml0ZXInO1xyXG5pbXBvcnQgeyB6aXBJdGVyYWJsZXMgfSBmcm9tICcuLi8uLi91dGlsL2l0ZXJhYmxlJztcclxuaW1wb3J0IHsgZW5jb2RlUmdiYTggfSBmcm9tICcuLi8uLi91dGlsL2NvbG9yJztcclxuaW1wb3J0IHsgaW50VG9aSW5kZXggfSBmcm9tICcuLi8uLi91dGlsL3pfaW5kZXgnO1xyXG5pbXBvcnQgeyBQT0lOVF9MQUJFTF9BVFRSSUJVVEVfTUFQUElORyB9IGZyb20gJy4vcG9pbnRfbGFiZWxfYXR0cmlidXRlX21hcHBpbmcnO1xyXG4vKipcclxuICogV3JpdGVyIG9mIGdlb21ldHJ5IGRhdGEgb2YgcG9pbnQgbGFiZWxzLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9pbnRMYWJlbEJ1ZmZlcldyaXRlciBleHRlbmRzIEJ1ZmZlcldyaXRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcihQT0lOVF9MQUJFTF9BVFRSSUJVVEVfTUFQUElORy52ZXJ0ZXhCeXRlU2l6ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBwb2ludCBsYWJlbCB0byBidWZmZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpZCBMYWJlbCBpZC5cclxuICAgICAqIEBwYXJhbSBsYWJlbCBMYWJlbCB0byBiZSB3cml0dGVuIHRvIGJ1ZmZlcnMuXHJcbiAgICAgKiBAcGFyYW0gc3R5bGUgU3R5bGUgb2YgdGhlIGxhYmVsLCB0aGF0IGRpcmVjdGx5IGFmZmVjdHMgd3JpdHRlbiBkYXRhLlxyXG4gICAgICogQHBhcmFtIGZvbnRSZWdpc3RyeSBSZWdpc3RyeSBvZiBhbGwgc3lzdGVtIGZvbnRzLCBpdCBzaG91bGQgY29udGFpbiBmb250cyB1c2VkIGluIHRoaXMgbGFiZWwgc3R5bGVzLlxyXG4gICAgICogQHBhcmFtIGdseXBoQXRsYXMgQXRsYXMgb2YgYWxsIHN5c3RlbSBnbHlwaHMsIGl0IHNob3VsZCBjb250YWluIGdseXBocyB1c2VkIGluIHRoaXMgbGFiZWwuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgTG9jYXRpb24gb2YgdGhlIGRhdGEgaW4gYnVmZmVycy5cclxuICAgICAqL1xyXG4gICAgd3JpdGVQb2ludExhYmVsKGlkLCBsYWJlbCwgc3R5bGUsIGxheW91dCwgZ2x5cGhBdGxhcykge1xyXG4gICAgICAgIGNvbnN0IGlkSGlnaCA9IGlkID4+IDg7XHJcbiAgICAgICAgY29uc3QgaWRMb3cgPSBpZCAmIDB4ZmY7XHJcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBsYWJlbC5hbmNob3JQb2ludDtcclxuICAgICAgICBjb25zdCBwcmlvcml0eSA9IGludFRvWkluZGV4KGxhYmVsLnByaW9yaXR5KTtcclxuICAgICAgICBmb3IgKGNvbnN0IFt0ZXh0TGF5b3V0LCB0ZXh0U3R5bGVdIG9mIHppcEl0ZXJhYmxlcyhsYXlvdXQsIHN0eWxlLnN0eWxlcykpIHtcclxuICAgICAgICAgICAgY29uc3QgdGV4dENvbG9yUmdiYTggPSBlbmNvZGVSZ2JhOCh0ZXh0U3R5bGUuY29sb3IpO1xyXG4gICAgICAgICAgICBjb25zdCBvdXRsaW5lQ29sb3JSZ2JhOCA9IGVuY29kZVJnYmE4KHRleHRTdHlsZS5vdXRsaW5lQ29sb3IpO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGdseXBoIG9mIHRleHRMYXlvdXQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFsbG9jYXRlZEdseXBoID0gZ2x5cGhBdGxhcy5nZXRHbHlwaExvY2F0aW9uKGdseXBoLmZvbnRJZCwgZ2x5cGguZ2x5cGhJZCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2MSA9IHRoaXMuX3dyaXRlVmVydGV4KGlkSGlnaCwgaWRMb3csIHBvc2l0aW9uLCBnbHlwaC50b3BMZWZ0LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgeDogYWxsb2NhdGVkR2x5cGgubWluWCxcclxuICAgICAgICAgICAgICAgICAgICB5OiBhbGxvY2F0ZWRHbHlwaC5taW5ZXHJcbiAgICAgICAgICAgICAgICB9LCB0ZXh0Q29sb3JSZ2JhOCwgb3V0bGluZUNvbG9yUmdiYTgsIHByaW9yaXR5LCBnbHlwaC5zY2FsZSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2MiA9IHRoaXMuX3dyaXRlVmVydGV4KGlkSGlnaCwgaWRMb3csIHBvc2l0aW9uLCBnbHlwaC50b3BSaWdodCwge1xyXG4gICAgICAgICAgICAgICAgICAgIHg6IGFsbG9jYXRlZEdseXBoLm1heFgsXHJcbiAgICAgICAgICAgICAgICAgICAgeTogYWxsb2NhdGVkR2x5cGgubWluWVxyXG4gICAgICAgICAgICAgICAgfSwgdGV4dENvbG9yUmdiYTgsIG91dGxpbmVDb2xvclJnYmE4LCBwcmlvcml0eSwgZ2x5cGguc2NhbGUpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdjMgPSB0aGlzLl93cml0ZVZlcnRleChpZEhpZ2gsIGlkTG93LCBwb3NpdGlvbiwgZ2x5cGguYm90dG9tUmlnaHQsIHtcclxuICAgICAgICAgICAgICAgICAgICB4OiBhbGxvY2F0ZWRHbHlwaC5tYXhYLFxyXG4gICAgICAgICAgICAgICAgICAgIHk6IGFsbG9jYXRlZEdseXBoLm1heFlcclxuICAgICAgICAgICAgICAgIH0sIHRleHRDb2xvclJnYmE4LCBvdXRsaW5lQ29sb3JSZ2JhOCwgcHJpb3JpdHksIGdseXBoLnNjYWxlKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHY0ID0gdGhpcy5fd3JpdGVWZXJ0ZXgoaWRIaWdoLCBpZExvdywgcG9zaXRpb24sIGdseXBoLmJvdHRvbUxlZnQsIHtcclxuICAgICAgICAgICAgICAgICAgICB4OiBhbGxvY2F0ZWRHbHlwaC5taW5YLFxyXG4gICAgICAgICAgICAgICAgICAgIHk6IGFsbG9jYXRlZEdseXBoLm1heFlcclxuICAgICAgICAgICAgICAgIH0sIHRleHRDb2xvclJnYmE4LCBvdXRsaW5lQ29sb3JSZ2JhOCwgcHJpb3JpdHksIGdseXBoLnNjYWxlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVJbmRpY2VzKFt2MSwgdjIsIHYzLCB2MSwgdjMsIHY0XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kTWVzaCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYSB2ZXJ0ZXggdG8gdGhlIHZlcnRleCBidWZmZXIuIFNlZSBhdHRyaWJ1dGUgZGVzY3JpcHRpb25zIGluIHRoZSBBVFRSSUJVVEVfTUFQUElORyBwcm9wZXJ0eS5cclxuICAgICAqL1xyXG4gICAgX3dyaXRlVmVydGV4KGlkSGlnaCwgaWRMb3csIHBvc2l0aW9uLCBkaXNwbGFjZW1lbnQsIHV2LCBjb2xvclJnYmE4LCBvdXRsaW5lQ29sb3JSZ2JhOCwgcHJpb3JpdHksIHNjYWxlKSB7XHJcbiAgICAgICAgY29uc3QgdmVydGV4SWR4ID0gdGhpcy5nZXRDdXJyZW50VmVydGV4SWR4KCk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVCeXRlcyhpZEhpZ2gsIGlkTG93LCAwLCAwKTtcclxuICAgICAgICB0aGlzLl93cml0ZVdvcmxkQ29vcmRpbmF0ZShwb3NpdGlvbik7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVGbG9hdDMyKGRpc3BsYWNlbWVudC54KTtcclxuICAgICAgICB0aGlzLl93cml0ZUZsb2F0MzIoZGlzcGxhY2VtZW50LnkpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlSGFsZldvcmRzKHV2LngsIHV2LnkpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlV29yZChjb2xvclJnYmE4KTtcclxuICAgICAgICB0aGlzLl93cml0ZVdvcmQob3V0bGluZUNvbG9yUmdiYTgpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlRmxvYXQzMihwcmlvcml0eSk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVGbG9hdDMyKHNjYWxlKTtcclxuICAgICAgICByZXR1cm4gdmVydGV4SWR4O1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IEF0dHJpYnV0ZU1hcHBpbmcgfSBmcm9tICcuLi8uLi9yZW5kZXIvYXR0cmliX21hcHBpbmcnO1xyXG4vKiogRGVzY3JpcHRpb24gb2YgaG93IGEgd3JpdGVyIHN0b3JlcyB2ZXJ0ZXggZGF0YS4gKi9cclxuZXhwb3J0IGNvbnN0IFBPSU5UX0xBQkVMX0FUVFJJQlVURV9NQVBQSU5HID0gbmV3IEF0dHJpYnV0ZU1hcHBpbmcoW1xyXG4gICAgW1xyXG4gICAgICAgIDIgLyogSUQgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiA0LFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIxIC8qIFVOU0lHTkVEX0JZVEUgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDAgLyogUE9TSVRJT05fSElHSCAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDIsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjMgLyogVU5TSUdORURfU0hPUlQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDEgLyogUE9TSVRJT05fTE9XICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMixcclxuICAgICAgICAgICAgdHlwZTogNTEyMyAvKiBVTlNJR05FRF9TSE9SVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgNiAvKiBESVNQTEFDRU1FTlQgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTI2IC8qIEZMT0FUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgNCAvKiBVViAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDIsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjMgLyogVU5TSUdORURfU0hPUlQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICA3IC8qIENPTE9SICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogNCxcclxuICAgICAgICAgICAgdHlwZTogNTEyMSAvKiBVTlNJR05FRF9CWVRFICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICA4IC8qIE9VVExJTkVfQ09MT1IgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiA0LFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIxIC8qIFVOU0lHTkVEX0JZVEUgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDkgLyogUFJJT1JJVFkgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAxLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTI2IC8qIEZMT0FUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgMTEgLyogQVVYICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMSxcclxuICAgICAgICAgICAgdHlwZTogNTEyNiAvKiBGTE9BVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICBdXHJcbl0pO1xyXG4iLCJpbXBvcnQgKiBhcyB2ZWMyIGZyb20gJy4uLy4uL21hdGgvdmVjdG9yMic7XHJcbmltcG9ydCBCdWZmZXJXcml0ZXIgZnJvbSAnLi4vLi4vdXRpbC9idWZmZXJfd3JpdGVyJztcclxuaW1wb3J0IHsgZmxvYXRUb1VpbnQ4LCBmbG9hdFRvVWludDE2IH0gZnJvbSAnLi4vLi4vdXRpbC9ncHV0eXBlcyc7XHJcbmltcG9ydCB7IGludFRvWkluZGV4IH0gZnJvbSAnLi4vLi4vdXRpbC96X2luZGV4JztcclxuaW1wb3J0IHsgemlwSXRlcmFibGVzIH0gZnJvbSAnLi4vLi4vdXRpbC9pdGVyYWJsZSc7XHJcbmltcG9ydCB7IGVuY29kZVJnYmE4IH0gZnJvbSAnLi4vLi4vdXRpbC9jb2xvcic7XHJcbmltcG9ydCBsYXlvdXRDdXJ2ZWRUZXh0IGZyb20gJy4vbGF5b3V0X2N1cnZlZF9sYWJlbCc7XHJcbmltcG9ydCB7IHNwbGl0UG9seWxpbmUgfSBmcm9tICcuLi8uLi91dGlsL3BvbHlsaW5lJztcclxuaW1wb3J0IHsgQ1VSVkVEX0xBQkVMX0FUVFJJQlVURV9NQVBQSU5HIH0gZnJvbSAnLi9jdXJ2ZWRfbGFiZWxfYXR0cmlidXRlX21hcHBpbmcnO1xyXG5pbXBvcnQgeyBnZXRJZCB9IGZyb20gJy4uLy4uL2lkX21hbmFnZXInO1xyXG5jb25zdCBQT0xZTElORV9TSURFX0xFTkdUSCA9IDQ7XHJcbi8qKlxyXG4gKiBXcml0ZXIgb2YgZ2VvbWV0cnkgZGF0YSBvZiBjdXJ2ZWQgbGFiZWxzLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ3VydmVkTGFiZWxCdWZmZXJXcml0ZXIgZXh0ZW5kcyBCdWZmZXJXcml0ZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoQ1VSVkVEX0xBQkVMX0FUVFJJQlVURV9NQVBQSU5HLnZlcnRleEJ5dGVTaXplKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGN1cnZlZCBsYWJlbCB0byBidWZmZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsYWJlbCBMYWJlbCB0byBiZSB3cml0dGVuIHRvIGJ1ZmZlcnMuXHJcbiAgICAgKiBAcGFyYW0gc3R5bGUgU3R5bGUgb2YgdGhlIGxhYmVsLCB0aGF0IGRpcmVjdGx5IGFmZmVjdHMgd3JpdHRlbiBkYXRhLlxyXG4gICAgICogQHBhcmFtIGZvbnRSZWdpc3RyeSBSZWdpc3RyeSBvZiBhbGwgc3lzdGVtIGZvbnRzLCBpdCBzaG91bGQgY29udGFpbiBmb250cyB1c2VkIGluIHRoaXMgbGFiZWwgc3R5bGVzLlxyXG4gICAgICogQHBhcmFtIGdseXBoQXRsYXMgQXRsYXMgb2YgYWxsIHN5c3RlbSBnbHlwaHMsIGl0IHNob3VsZCBjb250YWluIGdseXBocyB1c2VkIGluIHRoaXMgbGFiZWwuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgTG9jYXRpb24gb2YgdGhlIGRhdGEgaW4gYnVmZmVycy5cclxuICAgICAqL1xyXG4gICAgd3JpdGVMYWJlbChsYWJlbCwgc3R5bGUsIGZvbnRSZWdpc3RyeSwgZ2x5cGhBdGxhcykge1xyXG4gICAgICAgIGNvbnN0IGlkID0gZ2V0SWQoKTtcclxuICAgICAgICBjb25zdCBpZEhpZ2ggPSBpZCA+PiA4O1xyXG4gICAgICAgIGNvbnN0IGlkTG93ID0gaWQgJiAweGZmO1xyXG4gICAgICAgIGNvbnN0IHRleHRMYXlvdXRzID0gbGF5b3V0Q3VydmVkVGV4dChsYWJlbCwgc3R5bGUsIGZvbnRSZWdpc3RyeSk7XHJcbiAgICAgICAgY29uc3QgcHJpb3JpdHkgPSBpbnRUb1pJbmRleChsYWJlbC5wcmlvcml0eSk7XHJcbiAgICAgICAgLy8gVG8gbWFrZSBsYXlvdXRpbmcgb24gR1BVIHBvc3NpYmxlIGd1aWRpbmcgcG9seWxpbmUgc2hvdWxkIGJlIHNwbGl0dGVkIG9uIGxlZnQvcmlnaHQgcGFydHMsXHJcbiAgICAgICAgLy8gbWlkIHBvaW50IG9mIHRoZSBwb2x5bGluZSBpcyB1c2VkIHRvIGFuY2hvciB0aGUgbGFiZWwuIFRoaXMgaW5mb3JtYXRpb24gaXMgbm90IGNoYW5nZWQgYXQgcnVudGltZSBhbmRcclxuICAgICAgICAvLyBzaW1wbGlmaWVzIGNhbGN1bGF0aW9ucyBpbiBzaGFkZXJzLlxyXG4gICAgICAgIGNvbnN0IHBvbHlsaW5lID0gc3BsaXRQb2x5bGluZShsYWJlbC5wb2x5bGluZSk7XHJcbiAgICAgICAgY29uc3QgbWlkUG9pbnQgPSBwb2x5bGluZVsxXVswXTtcclxuICAgICAgICBwb2x5bGluZVswXS5yZXZlcnNlKCk7IC8vIGxlZnQgcGFydCBtdXN0IGJlIHJldmVyc2VkIHRvIHdyaXRlIGJvdGggcGFydHMgYWxpa2VcclxuICAgICAgICBmb3IgKGNvbnN0IHBvbHlsaW5lUGFydCBvZiBwb2x5bGluZSkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHBvbHlsaW5lUGFydC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgLy8gd3JpdGUgcG9seWxpbmUgdmVydGV4IGFzIGRlbHRhIHRvIHRoZSBtaWQgcG9pbnQgdG8gZ2V0IHJlYXNvbmFibGUgcHJlY2lzaW9uIGZyb20gZmxvYXRcclxuICAgICAgICAgICAgICAgIHZlYzIuc3ViKHBvbHlsaW5lUGFydFtpXSwgbWlkUG9pbnQsIHBvbHlsaW5lUGFydFtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChjb25zdCBbdGV4dExheW91dCwgdGV4dFN0eWxlXSBvZiB6aXBJdGVyYWJsZXModGV4dExheW91dHMsIHN0eWxlLnN0eWxlcykpIHtcclxuICAgICAgICAgICAgY29uc3QgdGV4dENvbG9yUmdiYTggPSBlbmNvZGVSZ2JhOCh0ZXh0U3R5bGUuY29sb3IpO1xyXG4gICAgICAgICAgICBjb25zdCBvdXRsaW5lQ29sb3JSZ2JhOCA9IGVuY29kZVJnYmE4KHRleHRTdHlsZS5vdXRsaW5lQ29sb3IpO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGdseXBoIG9mIHRleHRMYXlvdXQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFsbG9jYXRlZEdseXBoID0gZ2x5cGhBdGxhcy5nZXRHbHlwaExvY2F0aW9uKGdseXBoLmZvbnRJZCwgZ2x5cGguZ2x5cGhJZCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2MSA9IHRoaXMuX3dyaXRlVmVydGV4KGlkSGlnaCwgaWRMb3csIG1pZFBvaW50LCBnbHlwaC50b3BMZWZ0LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgeDogYWxsb2NhdGVkR2x5cGgubWluWCxcclxuICAgICAgICAgICAgICAgICAgICB5OiBhbGxvY2F0ZWRHbHlwaC5taW5ZXHJcbiAgICAgICAgICAgICAgICB9LCB0ZXh0Q29sb3JSZ2JhOCwgb3V0bGluZUNvbG9yUmdiYTgsIHByaW9yaXR5LCBnbHlwaC5saW5lRGlzcGxhY2VtZW50LCBwb2x5bGluZSwgZ2x5cGguc2NhbGUpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdjIgPSB0aGlzLl93cml0ZVZlcnRleChpZEhpZ2gsIGlkTG93LCBtaWRQb2ludCwgZ2x5cGgudG9wUmlnaHQsIHtcclxuICAgICAgICAgICAgICAgICAgICB4OiBhbGxvY2F0ZWRHbHlwaC5tYXhYLFxyXG4gICAgICAgICAgICAgICAgICAgIHk6IGFsbG9jYXRlZEdseXBoLm1pbllcclxuICAgICAgICAgICAgICAgIH0sIHRleHRDb2xvclJnYmE4LCBvdXRsaW5lQ29sb3JSZ2JhOCwgcHJpb3JpdHksIGdseXBoLmxpbmVEaXNwbGFjZW1lbnQsIHBvbHlsaW5lLCBnbHlwaC5zY2FsZSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2MyA9IHRoaXMuX3dyaXRlVmVydGV4KGlkSGlnaCwgaWRMb3csIG1pZFBvaW50LCBnbHlwaC5ib3R0b21SaWdodCwge1xyXG4gICAgICAgICAgICAgICAgICAgIHg6IGFsbG9jYXRlZEdseXBoLm1heFgsXHJcbiAgICAgICAgICAgICAgICAgICAgeTogYWxsb2NhdGVkR2x5cGgubWF4WVxyXG4gICAgICAgICAgICAgICAgfSwgdGV4dENvbG9yUmdiYTgsIG91dGxpbmVDb2xvclJnYmE4LCBwcmlvcml0eSwgZ2x5cGgubGluZURpc3BsYWNlbWVudCwgcG9seWxpbmUsIGdseXBoLnNjYWxlKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHY0ID0gdGhpcy5fd3JpdGVWZXJ0ZXgoaWRIaWdoLCBpZExvdywgbWlkUG9pbnQsIGdseXBoLmJvdHRvbUxlZnQsIHtcclxuICAgICAgICAgICAgICAgICAgICB4OiBhbGxvY2F0ZWRHbHlwaC5taW5YLFxyXG4gICAgICAgICAgICAgICAgICAgIHk6IGFsbG9jYXRlZEdseXBoLm1heFlcclxuICAgICAgICAgICAgICAgIH0sIHRleHRDb2xvclJnYmE4LCBvdXRsaW5lQ29sb3JSZ2JhOCwgcHJpb3JpdHksIGdseXBoLmxpbmVEaXNwbGFjZW1lbnQsIHBvbHlsaW5lLCBnbHlwaC5zY2FsZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlSW5kaWNlcyhbdjEsIHYyLCB2MywgdjEsIHYzLCB2NF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmVuZE1lc2goKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGEgdmVydGV4IHRvIHRoZSB2ZXJ0ZXggYnVmZmVyLiBTZWUgYXR0cmlidXRlIGRlc2NyaXB0aW9ucyBpbiB0aGUgQVRUUklCVVRFX01BUFBJTkcgcHJvcGVydHkuXHJcbiAgICAgKi9cclxuICAgIF93cml0ZVZlcnRleChpZEhpZ2gsIGlkTG93LCBwb3NpdGlvbiwgZGlzcGxhY2VtZW50LCB1diwgY29sb3JSZ2JhOCwgb3V0bGluZUNvbG9yUmdiYTgsIHByaW9yaXR5LCBsaW5lRGlzcGxhY2VtZW50LCBwb2x5bGluZSwgc2NhbGUpIHtcclxuICAgICAgICBjb25zdCB2ZXJ0ZXhJZHggPSB0aGlzLmdldEN1cnJlbnRWZXJ0ZXhJZHgoKTtcclxuICAgICAgICB0aGlzLl93cml0ZUJ5dGVzKGlkSGlnaCwgaWRMb3csIDAsIDApO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlV29ybGRDb29yZGluYXRlKHBvc2l0aW9uKTtcclxuICAgICAgICB0aGlzLl93cml0ZUZsb2F0MzIoZGlzcGxhY2VtZW50LngpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlRmxvYXQzMihkaXNwbGFjZW1lbnQueSk7XHJcbiAgICAgICAgdGhpcy5fd3JpdGVGbG9hdDMyKGxpbmVEaXNwbGFjZW1lbnQpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlSGFsZldvcmRzKHV2LngsIHV2LnkpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlV29yZChjb2xvclJnYmE4KTtcclxuICAgICAgICB0aGlzLl93cml0ZVdvcmQob3V0bGluZUNvbG9yUmdiYTgpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlRmxvYXQzMihwcmlvcml0eSk7XHJcbiAgICAgICAgY29uc3QgcG9seWxpbmVMZW5ndGggPSB0aGlzLl9jb21wdXRlUG9seWxpbmVMZW5ndGgocG9seWxpbmUpO1xyXG4gICAgICAgIGZvciAoY29uc3QgcG9seWxpbmVQYXJ0IG9mIHBvbHlsaW5lKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3dyaXRlUG9seWxpbmVQYXJ0KHBvbHlsaW5lUGFydCwgcG9seWxpbmVMZW5ndGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl93cml0ZUZsb2F0MzIocG9seWxpbmVMZW5ndGgpO1xyXG4gICAgICAgIHRoaXMuX3dyaXRlRmxvYXQzMihzY2FsZSk7XHJcbiAgICAgICAgcmV0dXJuIHZlcnRleElkeDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIHBvbHlsaW5lJ3MgbGVmdCBvciByaWdodCBwYXJ0IHRvIGJ1ZmZlcnMuIFBvbHlsaW5lIHBhcnQgY29uc2lzdHMgb2Ygc2VnbWVudHMgKHR3byBjb25zZWN1dGl2ZSBwb2ludHMgaW5cclxuICAgICAqIHRoZSBwb2x5bGluZVBhcnQgYXJyYXkpLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwb2x5bGluZVBhcnQgUG9seWxpbmUgcGFydCB0byBiZSB3cml0dGVuLlxyXG4gICAgICogQHBhcmFtIHBvbHlsaW5lTGVuZ3RoIFRvdGFsIGxlbmd0aCBvZiB0aGUgcG9seWxpbmUuXHJcbiAgICAgKi9cclxuICAgIF93cml0ZVBvbHlsaW5lUGFydChwb2x5bGluZVBhcnQsIHBvbHlsaW5lTGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3QgcG9pbnRzID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gUE9MWUxJTkVfU0lERV9MRU5HVEg7IGkrKykge1xyXG4gICAgICAgICAgICBwb2ludHMucHVzaCh0aGlzLl9lbmNvZGVQb2ludChwb2x5bGluZVBhcnRbaV0sIHBvbHlsaW5lTGVuZ3RoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJhdGlvcyBhbmQgYW5nbGVzIG9mIHRoZSBwb2ludHMgYXJlIGVuY29kZWQgaW4gZGlmZmVyZW50IHNpemVzIHNvIGVhY2ggcG9pbnQgb2YgdGhlIHBvbHlsaW5lIGlzIHN0b3JlZCBpbiB0d29cclxuICAgICAgICAvLyBhdHRyaWJ1dGUncyBjb3JyZXNwb25kaW5nIGNvbXBvbmVudHMuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBQT0xZTElORV9TSURFX0xFTkdUSDsgaSArPSA0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3dyaXRlQnl0ZXMoZmxvYXRUb1VpbnQ4KHBvaW50c1tpXS5yYXRpbyksIGZsb2F0VG9VaW50OChwb2ludHNbaSArIDFdLnJhdGlvKSwgZmxvYXRUb1VpbnQ4KHBvaW50c1tpICsgMl0ucmF0aW8pLCBmbG9hdFRvVWludDgocG9pbnRzW2kgKyAzXS5yYXRpbykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IFBPTFlMSU5FX1NJREVfTEVOR1RIOyBpICs9IDIpIHtcclxuICAgICAgICAgICAgdGhpcy5fd3JpdGVIYWxmV29yZHMoZmxvYXRUb1VpbnQxNihwb2ludHNbaV0uYW5nbGUpLCBmbG9hdFRvVWludDE2KHBvaW50c1tpICsgMV0uYW5nbGUpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVuY29kZXMgYSBwb2ludCBvZiB0aGUgcG9seWxpbmUncyBzZWdtZW50IGFzIGEgdmVjdG9yIChmcm9tIHRoZSBwb2x5bGluZSBjZW50ZXIpIGJ5IGl0cyBub3JtYWxpemVkIGFuZ2xlIGFuZCB0aGVcclxuICAgICAqIHJhdGlvIG9mIGl0cyBsZW5ndGggdG8gdGhlIHBvbHlsaW5lJ3MgbGVuZ3RoLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwb2ludCBQb2ludCB0byBiZSBlbmNvZGVkLlxyXG4gICAgICogQHBhcmFtIHBvbHlsaW5lTGVuZ3RoIFRvdGFsIGxlbmd0aCBvZiB0aGUgcG9seWxpbmUuXHJcbiAgICAgKi9cclxuICAgIF9lbmNvZGVQb2ludChwb2ludCA9IHZlYzIuY3JlYXRlKDAsIDApLCBwb2x5bGluZUxlbmd0aCkge1xyXG4gICAgICAgIGNvbnN0IHJhdGlvID0gdmVjMi5sZW5ndGgocG9pbnQpIC8gcG9seWxpbmVMZW5ndGg7XHJcbiAgICAgICAgY29uc3QgYW5nbGUgPSAoTWF0aC5hdGFuMihwb2ludC55LCBwb2ludC54KSArIE1hdGguUEkpIC8gKDIgKiBNYXRoLlBJKTtcclxuICAgICAgICByZXR1cm4geyByYXRpbywgYW5nbGUgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZXMgdGhlIHRvdGFsIGxlbmd0aCBvZiB0aGUgcG9seWluZS4gUG9seWxpbmUgd2lsbCBiZSBsaW1pdGVkIGJ5IGBQT0xZTElORV9TSURFX0xFTkdUSGAgc2VnbWVudHMgb24gZWFjaFxyXG4gICAgICogc2lkZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcG9seWxpbmVcclxuICAgICAqL1xyXG4gICAgX2NvbXB1dGVQb2x5bGluZUxlbmd0aChwb2x5bGluZSkge1xyXG4gICAgICAgIGxldCBwb2x5bGluZUxlbmd0aCA9IDA7XHJcbiAgICAgICAgZm9yIChjb25zdCBwb2x5bGluZVBhcnQgb2YgcG9seWxpbmUpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gUE9MWUxJTkVfU0lERV9MRU5HVEg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHBvbHlsaW5lUGFydFtpXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvbHlsaW5lTGVuZ3RoICs9IHZlYzIubGVuZ3RoKHBvbHlsaW5lUGFydFtpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBvbHlsaW5lTGVuZ3RoO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IHppcCB9IGZyb20gJy4uLy4uL3V0aWwvYXJyYXknO1xyXG4vKipcclxuICogTGFiZWwgbGF5b3V0aW5nIGlzIGRvbmUgcGFydGlhbGx5IG9uIENQVSBhbmQgcGFydGlhbGx5IG9uIEdQVS4gVGhpcyBoZWxwZXIgbWV0aG9kIGlzIHJlc3BvbnNpYmxlIGZvciB0aGUgQ1BVIHBhcnQsXHJcbiAqIGl0IGNhbGN1bGF0ZXMgZ2x5cGgncyBjb3JuZXIgcG9zaXRpb25zIG9uIGEgc3RyYWlnaHQgbGluZSwgdGhhdCB3aWxsIGxheSBvbiBhIGN1cnZlZCAgcG9seWxpbmUgbGF0ZXIgaW4gR1BVLlxyXG4gKiBBbGwgdGhlIG1ldHJpY3MgYXJlIGdpdmVuIGluIHBpeGVscy5cclxuICpcclxuICogQHJldHVybnMgUG9zaXRpb24gb2YgZWFjaCBnbHlwaCBmb3IgZWFjaCB0ZXh0IHNlcGFyYXRlbHkuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBsYXlvdXRDdXJ2ZWRMYWJlbChsYWJlbCwgbGFiZWxTdHlsZSwgZm9udFJlZ2lzdHJ5KSB7XHJcbiAgICBjb25zdCBsYXlvdXQgPSBbXTtcclxuICAgIGxldCBsaW5lRGlzcGxhY2VtZW50ID0gMDtcclxuICAgIGZvciAoY29uc3QgW3RleHQsIHN0eWxlXSBvZiB6aXAobGFiZWwudGV4dHMsIGxhYmVsU3R5bGUuc3R5bGVzKSkge1xyXG4gICAgICAgIGNvbnN0IHRleHRMYXlvdXQgPSBbXTtcclxuICAgICAgICBjb25zdCBmb250ID0gZm9udFJlZ2lzdHJ5LmdldChzdHlsZS5mb250SWQpO1xyXG4gICAgICAgIGNvbnN0IHNjYWxlID0gc3R5bGUuZm9udFNpemUgLyBmb250LnhoZWlnaHQ7XHJcbiAgICAgICAgY29uc3QgYmFzZWxpbmVPZmZzZXQgPSBzdHlsZS5mb250U2l6ZSAvIDI7XHJcbiAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIHRleHQudGV4dExpbmVzKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgZ2x5cGhJZCBvZiBsaW5lLmdseXBoSWRzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBnbHlwaCA9IGZvbnQuZ2V0R2x5cGgoZ2x5cGhJZCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0b3AgPSAoZ2x5cGguYmVhcmluZ1kgKyBmb250Lm1hcmdpbikgKiBzY2FsZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJvdHRvbSA9IChnbHlwaC5iZWFyaW5nWSAtIGdseXBoLmhlaWdodCAtIGZvbnQubWFyZ2luKSAqIHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGVmdCA9IChnbHlwaC5iZWFyaW5nWCAtIGZvbnQubWFyZ2luKSAqIHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmlnaHQgPSAoZ2x5cGguYmVhcmluZ1ggKyBnbHlwaC53aWR0aCArIGZvbnQubWFyZ2luKSAqIHNjYWxlO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgd2lkdGhIYWxmID0gKHJpZ2h0IC0gbGVmdCkgLyAyO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGVmdFNoaWZ0ZWQgPSBsZWZ0IC0gd2lkdGhIYWxmO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmlnaHRTaGlmdGVkID0gcmlnaHQgLSB3aWR0aEhhbGY7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0b3BTaGlmdGVkID0gdG9wIC0gYmFzZWxpbmVPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBib3R0b21TaGlmdGVkID0gYm90dG9tIC0gYmFzZWxpbmVPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICB0ZXh0TGF5b3V0LnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIGZvbnRJZDogZm9udC5pZCxcclxuICAgICAgICAgICAgICAgICAgICBnbHlwaElkOiBnbHlwaElkLFxyXG4gICAgICAgICAgICAgICAgICAgIHNjYWxlLFxyXG4gICAgICAgICAgICAgICAgICAgIHRvcExlZnQ6IHsgeDogbGVmdFNoaWZ0ZWQsIHk6IHRvcFNoaWZ0ZWQgfSxcclxuICAgICAgICAgICAgICAgICAgICB0b3BSaWdodDogeyB4OiByaWdodFNoaWZ0ZWQsIHk6IHRvcFNoaWZ0ZWQgfSxcclxuICAgICAgICAgICAgICAgICAgICBib3R0b21SaWdodDogeyB4OiByaWdodFNoaWZ0ZWQsIHk6IGJvdHRvbVNoaWZ0ZWQgfSxcclxuICAgICAgICAgICAgICAgICAgICBib3R0b21MZWZ0OiB7IHg6IGxlZnRTaGlmdGVkLCB5OiBib3R0b21TaGlmdGVkIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgbGluZURpc3BsYWNlbWVudDogbGluZURpc3BsYWNlbWVudCArIHdpZHRoSGFsZlxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBsaW5lRGlzcGxhY2VtZW50ICs9IGdseXBoLmFkdmFuY2UgKiBzY2FsZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBsaW5lRGlzcGxhY2VtZW50ICs9IGxhYmVsU3R5bGUuZGlzdGFuY2U7XHJcbiAgICAgICAgbGF5b3V0LnB1c2godGV4dExheW91dCk7XHJcbiAgICB9XHJcbiAgICAvLyByZW1vdmUgdHJhaWxpbmcgc3R5bGUgZGlzdGFuY2UgKGFkZGVkIGF0IHRoZSBlbmQgb2YgZWFjaCB0ZXh0IGFib3ZlKSwgYXMgaXQgbXVzdCBiZSBpbiBiZXR3ZWVuIHRleHRzIG9ubHlcclxuICAgIGxpbmVEaXNwbGFjZW1lbnQgLT0gbGFiZWxTdHlsZS5kaXN0YW5jZTtcclxuICAgIGNvbnN0IGxpbmVEaXNwbGFjZW1lbnRIYWxmID0gbGluZURpc3BsYWNlbWVudCAvIDI7XHJcbiAgICBmb3IgKGNvbnN0IHRleHRMYXlvdXQgb2YgbGF5b3V0KSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBnbHlwaExheW91dCBvZiB0ZXh0TGF5b3V0KSB7XHJcbiAgICAgICAgICAgIGdseXBoTGF5b3V0LmxpbmVEaXNwbGFjZW1lbnQgLT0gbGluZURpc3BsYWNlbWVudEhhbGY7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxheW91dDtcclxufVxyXG4iLCJpbXBvcnQgeyBBdHRyaWJ1dGVNYXBwaW5nIH0gZnJvbSAnLi4vLi4vcmVuZGVyL2F0dHJpYl9tYXBwaW5nJztcclxuLyoqIERlc2NyaXB0aW9uIG9mIGhvdyBhIHdyaXRlciBzdG9yZXMgdmVydGV4IGRhdGEuICovXHJcbmV4cG9ydCBjb25zdCBDVVJWRURfTEFCRUxfQVRUUklCVVRFX01BUFBJTkcgPSBuZXcgQXR0cmlidXRlTWFwcGluZyhbXHJcbiAgICBbXHJcbiAgICAgICAgMiAvKiBJRCAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDQsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjEgLyogVU5TSUdORURfQllURSAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgMCAvKiBQT1NJVElPTl9ISUdIICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMixcclxuICAgICAgICAgICAgdHlwZTogNTEyMyAvKiBVTlNJR05FRF9TSE9SVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgMSAvKiBQT1NJVElPTl9MT1cgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIzIC8qIFVOU0lHTkVEX1NIT1JUICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICA2IC8qIERJU1BMQUNFTUVOVCAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDMsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjYgLyogRkxPQVQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICA0IC8qIFVWICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogMixcclxuICAgICAgICAgICAgdHlwZTogNTEyMyAvKiBVTlNJR05FRF9TSE9SVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogZmFsc2VcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDcgLyogQ09MT1IgKi8sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBzaXplOiA0LFxyXG4gICAgICAgICAgICB0eXBlOiA1MTIxIC8qIFVOU0lHTkVEX0JZVEUgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDggLyogT1VUTElORV9DT0xPUiAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDQsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjEgLyogVU5TSUdORURfQllURSAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgOSAvKiBQUklPUklUWSAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDEsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjYgLyogRkxPQVQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICAxMiAvKiBBVVgxICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogNCxcclxuICAgICAgICAgICAgdHlwZTogNTEyMSAvKiBVTlNJR05FRF9CWVRFICovLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgXSxcclxuICAgIFtcclxuICAgICAgICAxMyAvKiBBVVgyICovLFxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgc2l6ZTogNCxcclxuICAgICAgICAgICAgdHlwZTogNTEyMyAvKiBVTlNJR05FRF9TSE9SVCAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgMTQgLyogQVVYMyAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDQsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjEgLyogVU5TSUdORURfQllURSAqLyxcclxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgIF0sXHJcbiAgICBbXHJcbiAgICAgICAgMTUgLyogQVVYNCAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDQsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjMgLyogVU5TSUdORURfU0hPUlQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcclxuICAgICAgICB9XHJcbiAgICBdLFxyXG4gICAgW1xyXG4gICAgICAgIDExIC8qIEFVWCAqLyxcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHNpemU6IDIsXHJcbiAgICAgICAgICAgIHR5cGU6IDUxMjYgLyogRkxPQVQgKi8sXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgXVxyXG5dKTtcclxuIiwiLy8gdGhpcyB2YWx1ZSBpcyBtb3N0bHkgZGljdGF0ZWQgYnkgdGVjaG5pY2FsIGRldGFpbHMgb2YgaG93IHZpc2liaWxpdHkgcmVzb2x1dGlvbiBpcyBpbXBsZW1lbnRlZDogaXQgdXNlc1xyXG4vLyBhIDI1NngyNTYgdGV4dHVyZSBhbmQgbWF4IG51bWJlciBvZiBkaXN0aW5jdCB2YWx1ZXMgdGhhdCBjYW4gYmUgc3RvcmVkIHRoZXJlIGlzIDI1NioyNTYuXHJcbi8vIE9mIGNvdXJzZSwgd2UgY2FuIGNvbXByZXNzIGl0IGFuZCB1c2Ugb25lIHBpeGVsLCBzYXksIGZvciB0d28vZm91ciBpZHMsIG9yIHVzZSBtdWx0aXBsZSB0ZXh0dXJlcywgYnV0IGl0XHJcbi8vIG5hdHVyYWxseSBjb21wbGljYXRlcyB0aGUgc29sdXRpb24sIHdoaWxlIH42NWsgaWRzIGlzIHNlZW4gYXMgXCJtb3JlIHRoYW4gZW5vdWdoXCIgKHRha2luZyBpbnRvIGFjY291bnQgdGhhdFxyXG4vLyBpZHMgYXJlIHJldXNlZCkuXHJcbmNvbnN0IE1BWF9JRCA9IDB4ZmZmZjtcclxubGV0IGlkID0gMDtcclxuLyoqXHJcbiAqIE1hbmFnZXMgYXNzaWdubWVudHMgb2YgaWRzIGZvciBwcmltaXRpdmVzIHRoYXQgbXVzdCBiZSBkaXN0aW5ndWlzaGVkIGluIGdsb2JhbCBzcGFjZSAoZS5nLiBmb3IgY29sbGlzaW9uIHJlc29sdXRpb24pLlxyXG4gKiBOb3RlIHRoYXQgdGhpcyBjbGFzcyBpcyBub3QgXCJ0aHJlYWQgc2FmZVwiLCB0byB1c2UgaXQgaW4gZGlmZmVyZW50IG1lbW9yeSBzcGFjZXMgc29tZXRoaW5nIGxpa2UgXCJpZCByZWdpb25zXCJcclxuICogKHNpbWlsYXIgdG8gaXAgYWRkcmVzcyBhc3NpZ25tZW50IHByb2JsZW0pIGlzIHRvIGJlIGltcGxlbWVudGVkLlxyXG4gKlxyXG4gKiAgQHJldHVybnMgUHNldWRvIHVuaXF1ZSBpZCBudW1iZXIgZnJvbSBbMHgwOjB4ZmZmZl0gcmFuZ2UsIGl0IGluY3JlbWVudHMgcHJldmlvdXNseSByZXR1cm5lZCBpZCBhbmQgc3RhcnRzIGZyb20gMFxyXG4gKiAgICAgd2hlbiB0aGUgcHJldiBvbmUgaXMgdGhlIG1heCBhdmFpbGFibGUsIHRoYXQgZ2l2ZXMgYWNjZXB0YWJsZSBkZWdyZWUgb2YgdW5pcXVlbmVzcyBmb3IgY29sbGlkaW5nIHByaW1pdGl2ZXMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0SWQoKSB7XHJcbiAgICByZXR1cm4gaWQgPSArK2lkICUgTUFYX0lEO1xyXG59XHJcbiIsIi8qKlxyXG4gKiBDYWxjdWxhdGVzIGJib3ggb2YgYSBsYXlvdXRlZCBsYWJlbCwgaXQganVzdCBmaW5kIHRoZSBsZWZ0L3JpZ2h0L3RvcC9ib3R0b20tbW9zdCBwb2ludHMgYW5kIGFkZHMgcGFkZGluZ3MuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlUG9pbnRMYWJlbEJCb3gobGF5b3V0LCB2ZXJ0aWNhbFBhZGRpbmcsIGhvcml6b250YWxQYWRkaW5nKSB7XHJcbiAgICBjb25zdCBiYm94ID0ge1xyXG4gICAgICAgIG1pblg6IE51bWJlci5NQVhfVkFMVUUsXHJcbiAgICAgICAgbWF4WDogLU51bWJlci5NQVhfVkFMVUUsXHJcbiAgICAgICAgbWluWTogTnVtYmVyLk1BWF9WQUxVRSxcclxuICAgICAgICBtYXhZOiAtTnVtYmVyLk1BWF9WQUxVRVxyXG4gICAgfTtcclxuICAgIGZvciAoY29uc3QgdGV4dExheW91dCBvZiBsYXlvdXQpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGdseXBoTGF5b3V0IG9mIHRleHRMYXlvdXQpIHtcclxuICAgICAgICAgICAgYmJveC5taW5YID0gTWF0aC5taW4oYmJveC5taW5YLCBnbHlwaExheW91dC50b3BMZWZ0LngpO1xyXG4gICAgICAgICAgICBiYm94Lm1heFggPSBNYXRoLm1heChiYm94Lm1heFgsIGdseXBoTGF5b3V0LnRvcFJpZ2h0LngpO1xyXG4gICAgICAgICAgICBiYm94Lm1pblkgPSBNYXRoLm1pbihiYm94Lm1pblksIGdseXBoTGF5b3V0LmJvdHRvbUxlZnQueSk7XHJcbiAgICAgICAgICAgIGJib3gubWF4WSA9IE1hdGgubWF4KGJib3gubWF4WSwgZ2x5cGhMYXlvdXQudG9wTGVmdC55KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBiYm94Lm1pblggLT0gaG9yaXpvbnRhbFBhZGRpbmc7XHJcbiAgICBiYm94Lm1heFggKz0gaG9yaXpvbnRhbFBhZGRpbmc7XHJcbiAgICBiYm94Lm1pblkgLT0gdmVydGljYWxQYWRkaW5nO1xyXG4gICAgYmJveC5tYXhZICs9IHZlcnRpY2FsUGFkZGluZztcclxuICAgIHJldHVybiBiYm94O1xyXG59XHJcbiIsImltcG9ydCB7IHBhcnNlVHJpbWVzaCB9IGZyb20gJy4vdHJpbWVzaC9wYXJzZV90cmltZXNoJztcclxuaW1wb3J0ICogYXMgc2NhbGFyIGZyb20gJy4uLy4uLy4uL21hdGgvc2NhbGFyJztcclxuaW1wb3J0IE1vZGVsQnVmZmVyV3JpdGVyIGZyb20gJy4uLy4uLy4uL3ByaW1pdGl2ZS9tb2RlbC9tb2RlbF9idWZmZXJfd3JpdGVyJztcclxuaW1wb3J0IHsgZW5jb2RlUmdiYTggfSBmcm9tICcuLi8uLi8uLi91dGlsL2NvbG9yJztcclxuLyoqXHJcbiAqIEJ1ZmZlciB3cml0ZXIgdGhhdCB3cml0ZXMgdHJpbWVzaCBvYmplY3QgaW50byBjb21tb24gbWVzaCBidWZmZXJzLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFRyaW1lc2hQb2x5Z29uQnVmZmVyV3JpdGVyIGV4dGVuZHMgTW9kZWxCdWZmZXJXcml0ZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYSBtZXNoIGZyb20gcmF3IHRyaW1lc2ggZmlsZSBkYXRhLiBVc2VzIHBhcnNlVHJpbWVzaCgpIHV0aWxpdHkgZnVuY3Rpb25cclxuICAgICAqIHRvIGdldCB2ZXJ0aWNlcyBhbmQgd3JpdGUgdGhlbSBpbiBjb3JyZWN0IG9yZGVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBkYXRhIFJhdyAodW56aXBwZWQpIHRyaW1lc2ggZmlsZSBkYXRhLlxyXG4gICAgICogQHBhcmFtIG1lc2ggRGVzY3JpcHRpb24gb2YgdGhlIG1lc2ggaW4gdGhlIHdvcmxkIHNwYWNlLlxyXG4gICAgICogQHJldHVybnMgVGhlIGxvY2F0aW9uIG9mIHRoZSBtZXNoIGluIGEgYnVmZmVyLlxyXG4gICAgICovXHJcbiAgICB3cml0ZU1vZGVsKGRhdGEsIG1lc2gsIGNvbG9yKSB7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudE1lc2ggPSBtZXNoO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRDb2xvciA9IGVuY29kZVJnYmE4KGNvbG9yKTtcclxuICAgICAgICBsZXQgcHJldk1hbmlmb2xkTG9jYXRpb247XHJcbiAgICAgICAgZm9yIChjb25zdCBtYW5pZm9sZExvY2F0aW9uIG9mIHBhcnNlVHJpbWVzaChkYXRhLCB0aGlzKSkge1xyXG4gICAgICAgICAgICBpZiAocHJldk1hbmlmb2xkTG9jYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIC8vIG1hbmlmb2xkcyBhcmUgd3JpdHRlbiBjb25zZXF1ZW50bHksIGl0IGFsbG93cyB0byBcImFjY3VtdWxhdGVcIiB2ZXJ0aWNlcyBhbmQgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgbG9jYXRpb24gb2YgdGhlIGZpcnN0IG9uZSBhbmQgdGhlIHN1bSBvZiB0aGUgbGVuZ3Roc1xyXG4gICAgICAgICAgICAgICAgaWYgKHByZXZNYW5pZm9sZExvY2F0aW9uLmJ1ZmZlckluZGV4ID09PSBtYW5pZm9sZExvY2F0aW9uLmJ1ZmZlckluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJldk1hbmlmb2xkTG9jYXRpb24udmVydGV4Qnl0ZUxlbmd0aCArPSBtYW5pZm9sZExvY2F0aW9uLnZlcnRleEJ5dGVMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJldk1hbmlmb2xkTG9jYXRpb24uaW5kZXhCeXRlTGVuZ3RoICs9IG1hbmlmb2xkTG9jYXRpb24uaW5kZXhCeXRlTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJuIHRoZSBmaXJzdCBwb3J0aW9uLCB2ZXJ5IGxhcmdlICh+NjVrIHZlcnRpY2VzKSBvYmplY3Qgd2lsbCBiZSB0cnVuY2F0ZWRcclxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBjb25zaWRlciBzdXBwb3J0IG9mIHN1Y2ggb2JqZWN0c1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcHJldk1hbmlmb2xkTG9jYXRpb24gPSBtYW5pZm9sZExvY2F0aW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwcmV2TWFuaWZvbGRMb2NhdGlvbjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3RvcmVzIGNvbnZlcnRlZCB0byB3b3JsZCBzcGFjZSB2ZXJ0aWNlcyB0byByZWZlciB0aGVtIGxhdGVyIGluIGluZGljZXMgd3JpdGluZy5cclxuICAgICAqL1xyXG4gICAgd3JpdGVWZXJ0ZXgodmVydGV4KSB7XHJcbiAgICAgICAgY29uc3QgbWVzaCA9IHRoaXMuX2N1cnJlbnRNZXNoO1xyXG4gICAgICAgIGlmIChtZXNoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJib3ggPSBtZXNoLmJib3g7XHJcbiAgICAgICAgICAgIHZlcnRleC54ID0gc2NhbGFyLm1peChiYm94Lm1pblgsIGJib3gubWF4WCwgdmVydGV4LngpO1xyXG4gICAgICAgICAgICB2ZXJ0ZXgueSA9IHNjYWxhci5taXgoYmJveC5taW5ZLCBiYm94Lm1heFksIHZlcnRleC55KTtcclxuICAgICAgICAgICAgdmVydGV4LnogPSBzY2FsYXIubWl4KGJib3gubWF4WiwgYmJveC5taW5aLCB2ZXJ0ZXgueik7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93cml0ZVZlcnRleCh2ZXJ0ZXgsIHRoaXMuX2N1cnJlbnRDb2xvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5pc2hlcyBjdXJyZW50IG1hbmlmb2xkIGFuZCByZXR1cm5zIGl0cyBsb2NhdGlvbiBpbiBhIGJ1ZmZlci5cclxuICAgICAqL1xyXG4gICAgZmx1c2goKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kTWVzaCgpO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCBGaWxlUmVhZGVyIGZyb20gJy4vZmlsZV9yZWFkZXInO1xyXG5pbXBvcnQgeyBwYXJzZU1hbmlmb2xkIH0gZnJvbSAnLi9wYXJzZV9tYW5pZm9sZCc7XHJcbmltcG9ydCBWZXJ0ZXhEZWNvZGVyIGZyb20gJy4vdmVydGV4X2RlY29kZXInO1xyXG4vKipcclxuICogU3RyZWFtaW5nIHBhcnNlciBvZiBhIHRyaW1lc2ggZmlsZS4gSXQgd3JpdGVzIHRoZSBtb2RlbCBpbnRvIGFuIGFic3RyYWN0IG91dHB1dCBidWZmZXIsIHRoYXQgaGF2ZSB0byBtYW5hZ2VcclxuICogdmVydGljZXMgc3RvcmluZy4gVGhlIG1vZGVsIGNhbiBiZSBxdWl0ZSBiaWcsIHRoYXQgaXMgd2h5IGl0IGlzIGZsdXNoZWQgb3V0IGJ5IHBvcnRpb25zIChtYW5pZm9sZHMpIHRoYXQgY291bGRcclxuICogYmUgcGxhY2VkIGludG8gc2VwYXJhdGUgYnVmZmVycy5cclxuICogVGhlIGZvcm1hdCBvdmVydmlldyBhbmQgbW90aXZhdGlvbiBzZWUgaGVyZTogaHR0cHM6Ly93aWtpLnlhbmRleC10ZWFtLnJ1L21hcHMvZGV2L2NvcmUvcmVuZGVyZXIvdmVjM2QvLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uKiBwYXJzZVRyaW1lc2goZGF0YSwgb3V0cHV0KSB7XHJcbiAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcihkYXRhKTtcclxuICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVmVydGV4RGVjb2RlcihyZWFkZXIuaGVhZGVyLnByZWNpc2lvbik7XHJcbiAgICB3aGlsZSAocmVhZGVyLmhhc0NvbW1hbmRzKCkpIHtcclxuICAgICAgICB5aWVsZCBwYXJzZU1hbmlmb2xkKHJlYWRlciwgZGVjb2Rlciwgb3V0cHV0KTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgKiBhcyB2ZWN0b3IzIGZyb20gJy4uLy4uLy4uLy4uL21hdGgvdmVjdG9yMyc7XHJcbmltcG9ydCB7IHppZ1phZ1VucGFjayB9IGZyb20gJy4vdXRpbHMnO1xyXG5jb25zdCBWQUxFTkNFX0JJQVMgPSB7XHJcbiAgICBbMCAvKiBBREQgKi9dOiAzLFxyXG4gICAgWzEgLyogSE9MRSAqL106IDMsXHJcbiAgICBbMiAvKiBTUExJVCAqL106IDEsXHJcbiAgICBbMyAvKiBNRVJHRSAqL106IDFcclxufTtcclxuY29uc3QgSEVBREVSX0JZVEVfU0laRSA9IDEzO1xyXG4vKipcclxuICogUGFyc2VzIHJhdyB0cmltZXNoIGZpbGUgZGF0YS4gU2VlIHRoZSBmb3JtYXQgZGVzY3JpYmVkIGhlcmU6XHJcbiAqIGh0dHBzOi8vd2lraS55YW5kZXgtdGVhbS5ydS9tYXBzL2Rldi9jb3JlL3JlbmRlcmVyL3ZlYzNkLyNzdHJ1a3R1cmFmYWpqbGEuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGaWxlUmVhZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcclxuICAgICAgICB0aGlzLl92aWV3ID0gbmV3IERhdGFWaWV3KGRhdGEpO1xyXG4gICAgICAgIHRoaXMuaGVhZGVyID0ge1xyXG4gICAgICAgICAgICBzaWduYXR1cmU6IHRoaXMuX3ZpZXcuZ2V0VWludDMyKDAsIHRydWUpLFxyXG4gICAgICAgICAgICBuQ21kQWRkOiB0aGlzLl92aWV3LmdldFVpbnQzMig0LCB0cnVlKSxcclxuICAgICAgICAgICAgbkNtZEV0YzogdGhpcy5fdmlldy5nZXRVaW50MTYoOCwgdHJ1ZSksXHJcbiAgICAgICAgICAgIG5BdXg6IHRoaXMuX3ZpZXcuZ2V0VWludDE2KDEwLCB0cnVlKSxcclxuICAgICAgICAgICAgcHJlY2lzaW9uOiB0aGlzLl92aWV3LmdldFVpbnQ4KDEyKVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5fYXV4T2Zmc2V0ID0gSEVBREVSX0JZVEVfU0laRTtcclxuICAgICAgICB0aGlzLl9jbWRPZmZzZXQgPSB0aGlzLl9hdXhPZmZzZXQgKyB0aGlzLmhlYWRlci5uQXV4ICogMjtcclxuICAgICAgICB0aGlzLl9kaWZmT2Zmc2V0ID0gdGhpcy5fY21kT2Zmc2V0ICsgdGhpcy5oZWFkZXIubkNtZEFkZCArIHRoaXMuaGVhZGVyLm5DbWRFdGM7XHJcbiAgICAgICAgdGhpcy5fY21kRW5kID0gdGhpcy5fZGlmZk9mZnNldDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgVGhlIG5leHQgY29tbWFuZCBhbmQgaW5jcmVhc2VzIHRoZSBjb21tYW5kIGN1cnNvci5cclxuICAgICAqL1xyXG4gICAgcmVhZENvbW1hbmQoZHN0ID0geyB0eXBlOiAwIC8qIEFERCAqLywgdmFsZW5jZTogMCwgc2hpZnQ6IDAgfSkge1xyXG4gICAgICAgIGNvbnN0IGNvbW1hbmRQYWNrZWQgPSB0aGlzLl92aWV3LmdldFVpbnQ4KHRoaXMuX2NtZE9mZnNldCsrKTtcclxuICAgICAgICBjb25zdCB0eXBlID0gY29tbWFuZFBhY2tlZCAmIDBiMTE7XHJcbiAgICAgICAgbGV0IHZhbGVuY2UgPSBjb21tYW5kUGFja2VkID4+IDI7XHJcbiAgICAgICAgdmFsZW5jZSA9IHZhbGVuY2UgIT09IDAgPyB2YWxlbmNlIC0gMSA6IHRoaXMuX3JlYWRBdXgoKSArIDYyO1xyXG4gICAgICAgIHZhbGVuY2UgKz0gVkFMRU5DRV9CSUFTW3R5cGVdO1xyXG4gICAgICAgIGNvbnN0IHNoaWZ0ID0gdHlwZSA9PT0gMiAvKiBTUExJVCAqLyB8fCB0eXBlID09PSAzIC8qIE1FUkdFICovID8gdGhpcy5fcmVhZEF1eCgpIDogMDtcclxuICAgICAgICBkc3QudHlwZSA9IHR5cGU7XHJcbiAgICAgICAgZHN0LnZhbGVuY2UgPSB2YWxlbmNlO1xyXG4gICAgICAgIGRzdC5zaGlmdCA9IHNoaWZ0O1xyXG4gICAgICAgIHJldHVybiBkc3Q7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFRoZSBuZXh0IGRpZmYgYW5kIGluY3JlYXNlcyB0aGUgZGlmZiBjdXJzb3IuXHJcbiAgICAgKi9cclxuICAgIHJlYWREaWZmKGRzdCA9IHZlY3RvcjMuY3JlYXRlKDAsIDAsIDApKSB7XHJcbiAgICAgICAgZHN0LnggPSB0aGlzLl9yZWFkRGlmZih0aGlzLl9kaWZmT2Zmc2V0ICsgdGhpcy5oZWFkZXIubkNtZEFkZCAqIDMsIHRoaXMuX2RpZmZPZmZzZXQgKyB0aGlzLmhlYWRlci5uQ21kQWRkICogMCk7XHJcbiAgICAgICAgZHN0LnkgPSB0aGlzLl9yZWFkRGlmZih0aGlzLl9kaWZmT2Zmc2V0ICsgdGhpcy5oZWFkZXIubkNtZEFkZCAqIDQsIHRoaXMuX2RpZmZPZmZzZXQgKyB0aGlzLmhlYWRlci5uQ21kQWRkICogMSk7XHJcbiAgICAgICAgZHN0LnogPSB0aGlzLl9yZWFkRGlmZih0aGlzLl9kaWZmT2Zmc2V0ICsgdGhpcy5oZWFkZXIubkNtZEFkZCAqIDUsIHRoaXMuX2RpZmZPZmZzZXQgKyB0aGlzLmhlYWRlci5uQ21kQWRkICogMik7XHJcbiAgICAgICAgdGhpcy5fZGlmZk9mZnNldCsrO1xyXG4gICAgICAgIHJldHVybiBkc3Q7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIElzIHRoZXJlIGNvbW1hbmQgdW5yZWFkLlxyXG4gICAgICovXHJcbiAgICBoYXNDb21tYW5kcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY21kT2Zmc2V0IDwgdGhpcy5fY21kRW5kO1xyXG4gICAgfVxyXG4gICAgX3JlYWRBdXgoKSB7XHJcbiAgICAgICAgY29uc3QgbG93ID0gdGhpcy5fdmlldy5nZXRVaW50OCh0aGlzLl9hdXhPZmZzZXQpO1xyXG4gICAgICAgIGNvbnN0IGhpZ2ggPSB0aGlzLl92aWV3LmdldFVpbnQ4KHRoaXMuX2F1eE9mZnNldCArIHRoaXMuaGVhZGVyLm5BdXgpO1xyXG4gICAgICAgIGNvbnN0IGF1eCA9IChoaWdoIDw8IDgpIHwgbG93O1xyXG4gICAgICAgIHRoaXMuX2F1eE9mZnNldCsrO1xyXG4gICAgICAgIHJldHVybiBhdXg7XHJcbiAgICB9XHJcbiAgICBfcmVhZERpZmYoaGlnaFBhcnRJbmRleCwgbG93UGFydEluZGV4KSB7XHJcbiAgICAgICAgcmV0dXJuIHppZ1phZ1VucGFjayh0aGlzLl92aWV3LmdldFVpbnQ4KGhpZ2hQYXJ0SW5kZXgpIDw8IDggfFxyXG4gICAgICAgICAgICB0aGlzLl92aWV3LmdldFVpbnQ4KGxvd1BhcnRJbmRleCkpO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCAqIGFzIG1hdHJpeDMgZnJvbSAnLi9tYXRyaXgzJztcclxuaW1wb3J0IGFyZUZ1enp5RXF1YWxTY2FsYXIsIHsgREVGQVVMVF9UT0xFUkFOQ0UgfSBmcm9tICcuLi91dGlsL2Z1enp5X2VxdWFsJztcclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgdmVjdG9yIGFuZCBpbml0aWFsaXplcyBpdCB3aXRoIGdpdmVuIGNvbXBvbmVudHMuXHJcbiAqXHJcbiAqIEBwYXJhbSB4IFggY29tcG9uZW50IG9mIHRoZSB2ZWN0b3IuXHJcbiAqIEBwYXJhbSB5IFkgY29tcG9uZW50IG9mIHRoZSB2ZWN0b3IuXHJcbiAqIEBwYXJhbSB6IFogY29tcG9uZW50IG9mIHRoZSB2ZWN0b3IuXHJcbiAqIEByZXR1cm5zIFRoZSB2ZWN0b3IuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKHgsIHksIHopIHtcclxuICAgIHJldHVybiB7IHgsIHksIHogfTtcclxufVxyXG5leHBvcnQgY29uc3QgT1JJR0lOID0gY3JlYXRlKDAsIDAsIDApO1xyXG5leHBvcnQgY29uc3QgUE9TSVRJVkVfWCA9IGNyZWF0ZSgxLCAwLCAwKTtcclxuZXhwb3J0IGNvbnN0IE5FR0FUSVZFX1ggPSBjcmVhdGUoLTEsIDAsIDApO1xyXG5leHBvcnQgY29uc3QgUE9TSVRJVkVfWSA9IGNyZWF0ZSgwLCAxLCAwKTtcclxuZXhwb3J0IGNvbnN0IE5FR0FUSVZFX1kgPSBjcmVhdGUoMCwgLTEsIDApO1xyXG5leHBvcnQgY29uc3QgUE9TSVRJVkVfWiA9IGNyZWF0ZSgwLCAwLCAxKTtcclxuZXhwb3J0IGNvbnN0IE5FR0FUSVZFX1ogPSBjcmVhdGUoMCwgMCwgLTEpO1xyXG4vKipcclxuICogQ29waWVzIGEgdmVjdG9yIHRvIGFub3RoZXIgb25lLlxyXG4gKlxyXG4gKiBAcGFyYW0gc3JjIFRoZSBzb3VyY2UgdmVjdG9yLlxyXG4gKiBAcGFyYW0gZHN0IFRoZSB2ZWN0b3IgdGhlIHNvdXJjZSB2ZWN0b3Igd2lsbCBiZSBjb3BpZWQgdG8uXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvcHkoc3JjLCBkc3QgPSBjcmVhdGUoMCwgMCwgMCkpIHtcclxuICAgIGRzdC54ID0gc3JjLng7XHJcbiAgICBkc3QueSA9IHNyYy55O1xyXG4gICAgZHN0LnogPSBzcmMuejtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIENoZWNrcyBpZiB0d28gdmVjdG9ycyBhcmUgc3RyaWN0bHkgZXF1YWwgY29tcG9uZW50LXdpc2UuXHJcbiAqXHJcbiAqIEBwYXJhbSB2MSBUaGUgZmlyc3QgdmVjdG9yLlxyXG4gKiBAcGFyYW0gdjIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGFyZUVxdWFsKHYxLCB2Mikge1xyXG4gICAgcmV0dXJuIHYxLnggPT09IHYyLnggJiYgdjEueSA9PT0gdjIueSAmJiB2MS56ID09PSB2Mi56O1xyXG59XHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgY29ycmVzcG9uZGluZyBjb21wb25lbnRzIG9mIHR3byB2ZWN0b3JzIGFyZSBhbGwgd2l0aGluIGdpdmVuXHJcbiAqIHRvbGVyYW5jZSBmcm9tIGVhY2ggb3RoZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB2MSBUaGUgZmlyc3QgdmVjdG9yLlxyXG4gKiBAcGFyYW0gdjIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSB0b2xlcmFuY2UgVGhlIHRvbGVyYW5jZS5cclxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB2ZWN0b3JzIGFyZSBcImZ1enp5XCIgZXF1YWwgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGFyZUZ1enp5RXF1YWwodjEsIHYyLCB0b2xlcmFuY2UgPSBERUZBVUxUX1RPTEVSQU5DRSkge1xyXG4gICAgcmV0dXJuIChhcmVGdXp6eUVxdWFsU2NhbGFyKHYxLngsIHYyLngsIHRvbGVyYW5jZSkgJiZcclxuICAgICAgICBhcmVGdXp6eUVxdWFsU2NhbGFyKHYxLnksIHYyLnksIHRvbGVyYW5jZSkgJiZcclxuICAgICAgICBhcmVGdXp6eUVxdWFsU2NhbGFyKHYxLnosIHYyLnosIHRvbGVyYW5jZSkpO1xyXG59XHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgdHdvIHZlY3RvcnMgYXJlIGNvbGxpbmVhci5cclxuICpcclxuICogQHBhcmFtIHYxIFRoZSBmaXJzdCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSB2MiBUaGUgc2Vjb25kIHZlY3Rvci5cclxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB2ZWN0b3JzIGFyZSBjb2xsaW5lYXIgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGFyZUNvbGxpbmVhcih2MSwgdjIpIHtcclxuICAgIGNvbnN0IGxhbWJkYVggPSB2MS54IC8gdjIueDtcclxuICAgIGNvbnN0IGxhbWJkYVkgPSB2MS55IC8gdjIueTtcclxuICAgIGNvbnN0IGxhbWJkYVogPSB2MS56IC8gdjIuejtcclxuICAgIHJldHVybiBsYW1iZGFYID09PSBsYW1iZGFZICYmIGxhbWJkYVkgPT09IGxhbWJkYVo7XHJcbn1cclxuLyoqXHJcbiAqIEFkZHMgdHdvIHZlY3RvciBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW50byBhIHRoaXJkIG9uZSwgaS5lLiBgZHN0ID0gYSArIGJgLlxyXG4gKlxyXG4gKiBAcGFyYW0gYSBUaGUgZmlyc3QgdmVjdG9yLlxyXG4gKiBAcGFyYW0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cclxuICogQHBhcmFtIGRzdCBUaGUgdmVjdG9yIHRoZSByZXN1bHQgd2lsbCBiZSBzdG9yZWQgdG8uXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGFkZChhLCBiLCBkc3QgPSBjcmVhdGUoMCwgMCwgMCkpIHtcclxuICAgIGRzdC54ID0gYS54ICsgYi54O1xyXG4gICAgZHN0LnkgPSBhLnkgKyBiLnk7XHJcbiAgICBkc3QueiA9IGEueiArIGIuejtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIFN1YnRyYWN0cyBhIHZlY3RvciBmcm9tIGFub3RoZXIgb25lIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCB0byBhIHRoaXJkIG9uZSwgaS5lLlxyXG4gKiBgZHN0ID0gYSAtIGJgLlxyXG4gKlxyXG4gKiBAcGFyYW0gYSBUaGUgbWludWVuZCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBiIFRoZSBzdWJ0cmFoZW5kIHZlY3Rvci5cclxuICogQHBhcmFtIGRzdCBUaGUgdmVjdG9yIHRoZSByZXN1bHQgd2lsbCBiZSBzdG9yZWQgdG8uXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc3ViKGEsIGIsIGRzdCA9IGNyZWF0ZSgwLCAwLCAwKSkge1xyXG4gICAgZHN0LnggPSBhLnggLSBiLng7XHJcbiAgICBkc3QueSA9IGEueSAtIGIueTtcclxuICAgIGRzdC56ID0gYS56IC0gYi56O1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogTXVsdGlwbGllcyB0d28gdmVjdG9ycyBjb21wb25lbnQtd2lzZSBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW50byBhIHRoaXJkIG9uZS5cclxuICpcclxuICogQHBhcmFtIGEgVGhlIGZpcnN0IHZlY3Rvci5cclxuICogQHBhcmFtIGIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBkc3QgVGhlIHZlY3RvciB0aGUgcmVzdWx0IHdpbGwgYmUgc3RvcmVkIHRvLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBtdWx2KGEsIGIsIGRzdCA9IGNyZWF0ZSgwLCAwLCAwKSkge1xyXG4gICAgZHN0LnggPSBhLnggKiBiLng7XHJcbiAgICBkc3QueSA9IGEueSAqIGIueTtcclxuICAgIGRzdC56ID0gYS56ICogYi56O1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogTXVsdGlwbGllcyBhIHZlY3RvciBieSBhIHNjYWxhciBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW50byBhIHRoaXJkIHZlY3Rvci5cclxuICpcclxuICogQHBhcmFtIGEgVGhlIHZlY3Rvci5cclxuICogQHBhcmFtIG4gVGhlIHNjYWxhci5cclxuICogQHBhcmFtIGRzdCBUaGUgdmVjdG9yIHRoZSByZXN1bHQgd2lsbCBiZSBzdG9yZWQgdG8uXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG11bG4oYSwgbiwgZHN0ID0gY3JlYXRlKDAsIDAsIDApKSB7XHJcbiAgICBkc3QueCA9IGEueCAqIG47XHJcbiAgICBkc3QueSA9IGEueSAqIG47XHJcbiAgICBkc3QueiA9IGEueiAqIG47XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbi8qKlxyXG4gKiBEaXZpZGVzIGEgdmVjdG9yIGJ5IGFub3RoZXIgb25lIGNvbXBvbmVudCB3aXNlIGFuZCBzdG9yZXMgdGhlIHJlc3VsdCBpbnRvIGFcclxuICogdGhpcmQgb25lLlxyXG4gKlxyXG4gKiBAcGFyYW0gYSBUaGUgZGl2aWRlbmQgdmVjdG9yLlxyXG4gKiBAcGFyYW0gYiBUaGUgZGl2aXNvciB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBkc3QgVGhlIHZlY3RvciB0aGUgcmVzdWx0IHdpbGwgYmUgc3RvcmVkIHRvLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBkaXZ2KGEsIGIsIGRzdCA9IGNyZWF0ZSgwLCAwLCAwKSkge1xyXG4gICAgZHN0LnggPSBhLnggLyBiLng7XHJcbiAgICBkc3QueSA9IGEueSAvIGIueTtcclxuICAgIGRzdC56ID0gYS56IC8gYi56O1xyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogRGl2aWRlcyBhIHZlY3RvciBieSBhIHNjYWxhciBhbmQgc3RvcmVzIHRoZSByZXN1bHQgaW50byBhIHRoaXJkIHZlY3Rvci5cclxuICpcclxuICogQHBhcmFtIGEgVGhlIGRpdmlkZW5kIHZlY3Rvci5cclxuICogQHBhcmFtIG4gVGhlIHNjYWxhci5cclxuICogQHBhcmFtIGRzdCBUaGUgdmVjdG9yIHRoZSByZXN1bHQgd2lsbCBiZSBzdG9yZWQgdG8uXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRpdm4oYSwgbiwgZHN0ID0gY3JlYXRlKDAsIDAsIDApKSB7XHJcbiAgICBkc3QueCA9IGEueCAvIG47XHJcbiAgICBkc3QueSA9IGEueSAvIG47XHJcbiAgICBkc3QueiA9IGEueiAvIG47XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbi8qKlxyXG4gKiBDb21wdXRlcyBsZW5ndGggb2YgYSB2ZWN0b3IuXHJcbiAqXHJcbiAqIEBwYXJhbSB2IFRoZSB2ZWN0b3IuXHJcbiAqIEByZXR1cm5zIFRoZSBsZW5ndGguXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbGVuZ3RoKHYpIHtcclxuICAgIHJldHVybiBNYXRoLmh5cG90KHYueCwgdi55LCB2LnopO1xyXG59XHJcbi8qKlxyXG4gKiBDb21wdXRlcyBkaXN0YW5jZSBiZXR3ZWVuIGVuZHMgb2YgdHdvIHZlY3RvcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSBhIFRoZSBmaXJzdCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBAcmV0dXJucyBUaGUgZGlzdGFuY2UsIGkuZS4gYGxlbmd0aChzdWIoYSwgYikpYC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XHJcbiAgICByZXR1cm4gTWF0aC5oeXBvdChhLnggLSBiLngsIGEueSAtIGIueSwgYS56IC0gYi56KTtcclxufVxyXG4vKipcclxuICogRGl2aWRlcyBhIHZlY3RvciBieSBpdHMgbGVuZ3RoICh0aHVzIG1ha2luZyBpdCBhIHVuaXQgdmVjdG9yKSBhbmQgc3RvcmVzIHRoZVxyXG4gKiByZXN1bHQgdG8gYW5vdGhlciBvbmUuXHJcbiAqXHJcbiAqIEBwYXJhbSB2IFRoZSB2ZWN0b3IgdG8gYmUgbm9ybWFsaXplZC5cclxuICogQHBhcmFtIGRzdCBUaGUgdmVjdG9yIHRoZSByZXN1bHQgd2lsbCBiZSBzdG9yZWQgdG8uXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZSh2LCBkc3QgPSBjcmVhdGUoMCwgMCwgMCkpIHtcclxuICAgIHJldHVybiBkaXZuKHYsIGxlbmd0aCh2KSwgZHN0KTtcclxufVxyXG4vKipcclxuICogQ29tcHV0ZXMgZG90IHByb2R1Y3Qgb2YgdHdvIHZlY3RvcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSBhIFRoZSBmaXJzdCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBAcmV0dXJucyBUaGUgZG90IHByb2R1Y3QuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZG90KGEsIGIpIHtcclxuICAgIHJldHVybiBhLnggKiBiLnggKyBhLnkgKiBiLnkgKyBhLnogKiBiLno7XHJcbn1cclxuLyoqXHJcbiAqIENvbXB1dGVzIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIHZlY3RvcnMgYW5kIHN0b3JlcyBpdCB0byBhIHRoaXJkIG9uZS5cclxuICpcclxuICogQHBhcmFtIGEgVGhlIGZpcnN0IHZlY3Rvci5cclxuICogQHBhcmFtIGIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSBkc3QgVGhlIHZlY3RvciB0aGUgcmVzdWx0IHdpbGwgYmUgc3RvcmVkIHRvLlxyXG4gKiBAcmV0dXJucyBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjcm9zcyhhLCBiLCBkc3QgPSBjcmVhdGUoMCwgMCwgMCkpIHtcclxuICAgIC8vIFdyaXRlIGNvbXBvbmVudHMgdG8gYSBzZXBhcmF0ZSB2YXJpYWJsZXMgc28gd2UgZG9uJ3QgcHJvZHVjZSBpbmNvcnJlY3RcclxuICAgIC8vIHJlc3VsdHMgaW4gY2FzZXMgd2hlbiBhID09IGRzdCBvciBiID09IGRzdC5cclxuICAgIGNvbnN0IHggPSBhLnkgKiBiLnogLSBhLnogKiBiLnk7XHJcbiAgICBjb25zdCB5ID0gYS56ICogYi54IC0gYS54ICogYi56O1xyXG4gICAgY29uc3QgeiA9IGEueCAqIGIueSAtIGEueSAqIGIueDtcclxuICAgIGRzdC54ID0geDtcclxuICAgIGRzdC55ID0geTtcclxuICAgIGRzdC56ID0gejtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIFJvdGF0ZXMgdmVjdG9yIGFib3V0IHRoZSBYIGF4aXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB2IFRoZSB2ZWN0b3IgdG8gYmUgcm90YXRlZC5cclxuICogQHBhcmFtIGFuZ2xlIFRoZSBhbmdsZSBvZiByb3RhdGlvbiAoaW4gcmFkaWFucyksIHBvc2l0aXZlIHZhbHVlcyByb3RhdGVzIGZyb20gK1kgdG8gK1pcclxuICogQHBhcmFtIGRzdCBUaGUgdmVjdG9yIHRoZSByZXN1bHQgd2lsbCBiZSBzdG9yZWQgdG8uXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWCh2LCBhbmdsZSwgZHN0ID0gY3JlYXRlKDAsIDAsIDApKSB7XHJcbiAgICBjb25zdCBjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XHJcbiAgICBjb25zdCBzaW4gPSBNYXRoLnNpbihhbmdsZSk7XHJcbiAgICBjb25zdCB5ID0gdi55O1xyXG4gICAgZHN0LnggPSB2Lng7XHJcbiAgICBkc3QueSA9IHkgKiBjb3MgLSB2LnogKiBzaW47XHJcbiAgICBkc3QueiA9IHkgKiBzaW4gKyB2LnogKiBjb3M7XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbi8qKlxyXG4gKiBSb3RhdGVzIHZlY3RvciBhYm91dCB0aGUgWSBheGlzLlxyXG4gKlxyXG4gKiBAcGFyYW0gdiBUaGUgdmVjdG9yIHRvIGJlIHJvdGF0ZWQuXHJcbiAqIEBwYXJhbSBhbmdsZSBUaGUgYW5nbGUgb2Ygcm90YXRpb24gKGluIHJhZGlhbnMpLCBwb3NpdGl2ZSB2YWx1ZXMgcm90YXRlcyBmcm9tICtYIHRvICtaXHJcbiAqIEBwYXJhbSBkc3QgVGhlIHZlY3RvciB0aGUgcmVzdWx0IHdpbGwgYmUgc3RvcmVkIHRvLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVkodiwgYW5nbGUsIGRzdCA9IGNyZWF0ZSgwLCAwLCAwKSkge1xyXG4gICAgY29uc3QgY29zID0gTWF0aC5jb3MoYW5nbGUpO1xyXG4gICAgY29uc3Qgc2luID0gTWF0aC5zaW4oYW5nbGUpO1xyXG4gICAgLy8gaGFuZGxlIHRoZSBjYXNlIHdoZW4gc291cmNlIGFuZCBkZXN0aW5hdGlvbiBhcmUgdGhlIHNhbWUgb2JqZWN0OiByZWxhdGVkIGNvbXBvbmVudHMgY2FuIGJyZWFrIGVhY2ggb3RoZXJcclxuICAgIHYgPSAodiA9PT0gZHN0KSA/IGNvcHkodikgOiB2O1xyXG4gICAgZHN0LnggPSB2LnggKiBjb3MgKyB2LnogKiBzaW47XHJcbiAgICBkc3QueSA9IHYueTtcclxuICAgIGRzdC56ID0gLXYueCAqIHNpbiArIHYueiAqIGNvcztcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIFJvdGF0ZXMgdmVjdG9yIGFib3V0IHRoZSBaIGF4aXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB2IFRoZSB2ZWN0b3IgdG8gYmUgcm90YXRlZC5cclxuICogQHBhcmFtIGFuZ2xlIFRoZSBhbmdsZSBvZiByb3RhdGlvbiAoaW4gcmFkaWFucyksIHBvc2l0aXZlIHZhbHVlcyByb3RhdGVzIGZyb20gK1ggdG8gK1lcclxuICogQHBhcmFtIGRzdCBUaGUgdmVjdG9yIHRoZSByZXN1bHQgd2lsbCBiZSBzdG9yZWQgdG8uXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWih2LCBhbmdsZSwgZHN0ID0gY3JlYXRlKDAsIDAsIDApKSB7XHJcbiAgICBjb25zdCBjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XHJcbiAgICBjb25zdCBzaW4gPSBNYXRoLnNpbihhbmdsZSk7XHJcbiAgICAvLyBoYW5kbGUgdGhlIGNhc2Ugd2hlbiBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGFyZSB0aGUgc2FtZSBvYmplY3Q6IHJlbGF0ZWQgY29tcG9uZW50cyBjYW4gYnJlYWsgZWFjaCBvdGhlclxyXG4gICAgdiA9ICh2ID09PSBkc3QpID8gY29weSh2KSA6IHY7XHJcbiAgICBkc3QueCA9IHYueCAqIGNvcyAtIHYueSAqIHNpbjtcclxuICAgIGRzdC55ID0gdi54ICogc2luICsgdi55ICogY29zO1xyXG4gICAgZHN0LnogPSB2Lno7XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbmV4cG9ydCBjb25zdCBYX0FYSVMgPSB7XHJcbiAgICBvcmlnaW46IE9SSUdJTixcclxuICAgIHRhbmdlbnQ6IFBPU0lUSVZFX1hcclxufTtcclxuZXhwb3J0IGNvbnN0IFlfQVhJUyA9IHtcclxuICAgIG9yaWdpbjogT1JJR0lOLFxyXG4gICAgdGFuZ2VudDogUE9TSVRJVkVfWVxyXG59O1xyXG5leHBvcnQgY29uc3QgWl9BWElTID0ge1xyXG4gICAgb3JpZ2luOiBPUklHSU4sXHJcbiAgICB0YW5nZW50OiBQT1NJVElWRV9aXHJcbn07XHJcbmV4cG9ydCBjb25zdCBYWSA9IHtcclxuICAgIG5vcm1hbDogUE9TSVRJVkVfWixcclxuICAgIGRpc3RhbmNlOiAwXHJcbn07XHJcbmV4cG9ydCBjb25zdCBZWiA9IHtcclxuICAgIG5vcm1hbDogUE9TSVRJVkVfWCxcclxuICAgIGRpc3RhbmNlOiAwXHJcbn07XHJcbmV4cG9ydCBjb25zdCBaWCA9IHtcclxuICAgIG5vcm1hbDogUE9TSVRJVkVfWSxcclxuICAgIGRpc3RhbmNlOiAwXHJcbn07XHJcbi8qKlxyXG4gKiBDb21wdXRlcyBpbnRlcnNlY3Rpb24gb2YgYSBwbGFuZSBhbmQgYSBsaW5lLlxyXG4gKlxyXG4gKiBAcGFyYW0gcCBUaGUgcGxhbmUuXHJcbiAqIEBwYXJhbSBsIFRoZSBsaW5lLlxyXG4gKiBAcmV0dXJucyBUaGUgcG9pbnQgb3IgYG51bGxgIGlmIHRoZSBsaW5lIGlzIHBhcmFsbGVsIHRvIHRoZSBwbGFuZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRQbGFuZUxpbmVJbnRlcnNlY3Rpb24ocCwgbCkge1xyXG4gICAgY29uc3QgZG90TFAgPSBkb3QobC50YW5nZW50LCBwLm5vcm1hbCk7XHJcbiAgICAvLyBJZiBwbGFuZSBub3JtYWwgYW5kIGxpbmUgdGFuZ2VudCB2ZWN0b3IgYXJlIHBlcnBlbmRpY3VsYXIgaW50ZXJzZWN0aW9uIGlzXHJcbiAgICAvLyBlaXRoZXIgYW4gZW1wdHkgc2V0IG9yIHRoZSBsaW5lIGl0c2VsZi5cclxuICAgIGlmIChkb3RMUCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgY29uc3QgaW50ZXJzZWN0aW9uID0gY29weShsLnRhbmdlbnQpO1xyXG4gICAgbXVsbihpbnRlcnNlY3Rpb24sIChwLmRpc3RhbmNlIC0gZG90KHAubm9ybWFsLCBsLm9yaWdpbikpIC8gZG90TFAsIGludGVyc2VjdGlvbik7XHJcbiAgICBhZGQoaW50ZXJzZWN0aW9uLCBsLm9yaWdpbiwgaW50ZXJzZWN0aW9uKTtcclxuICAgIHJldHVybiBpbnRlcnNlY3Rpb247XHJcbn1cclxuLyoqXHJcbiAqIENvbXB1dGVzIGFuIGludGVyc2VjdGlvbiBvZiBhIHBsYW5lIGFuZCBhIHJheSBhbmQgc3RvcmVzIGl0IGludG8gYSBnaXZlblxyXG4gKiB2ZWN0b3IuXHJcbiAqXHJcbiAqIEBwYXJhbSBwbGFuZSBUaGUgcGxhbmUuXHJcbiAqIEBwYXJhbSByYXkgVGhlIHJheS5cclxuICogQHBhcmFtIGRzdCBUaGUgdmVjdG9yIHRoZSBpbnRlcnNlY3Rpb24gcG9pbnQgd2lsbCBiZSBzdG9yZWQgdG8uIElmIHRoZXJlJ3Mgbm9cclxuICogICAgICBpbnRlcnNlY3Rpb24sIHRoaXMgdmVjdG9yIHdpbGwgYmUgbGVmdCB1bm1vZGlmaWVkLlxyXG4gKiBAcmV0dXJucyBUaGUgYGRzdGAgb3IgYG51bGxgIGlmIHRoZSByYXkgZG9lc24ndCBoYXZlIGEgY29tbW9uIHBvaW50IHdpdGggdGhlXHJcbiAqICAgICAgcGxhbmUuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGxhbmVSYXlJbnRlcnNlY3Rpb24ocGxhbmUsIHJheSwgZHN0ID0gY3JlYXRlKDAsIDAsIDApKSB7XHJcbiAgICBjb25zdCBkb3RSUCA9IGRvdChyYXkuZGlyZWN0aW9uLCBwbGFuZS5ub3JtYWwpO1xyXG4gICAgaWYgKGRvdFJQID09PSAwKSB7XHJcbiAgICAgICAgLy8gVGhlIHBsYW5lIG5vcm1hbCBhbmQgdGhlIHJheSBkaXJlY3Rpb24gdmVjdG9yIGFyZSBwZXJwZW5kaWN1bGFyLCBzb1xyXG4gICAgICAgIC8vIGludGVyc2VjdGlvbiBpcyBlaXRoZXIgYW4gZW1wdHkgc2V0IG9yIHRoZSByYXkgaXRzZWxmLlxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbGFtYmRhID0gKHBsYW5lLmRpc3RhbmNlIC0gZG90KHBsYW5lLm5vcm1hbCwgcmF5Lm9yaWdpbikpIC8gZG90UlA7XHJcbiAgICBpZiAobGFtYmRhIDwgMCkge1xyXG4gICAgICAgIC8vIFRoZSBpbnRlcnNlY3Rpb24gcG9pbnQgaXMgb24gYSBsaW5lIHRoYXQgY29udGFpbnMgdGhlIHJheSwgYnV0IG5vdCBvblxyXG4gICAgICAgIC8vIHRoZSByYXkgaXRzZWxmLlxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgY29weShyYXkuZGlyZWN0aW9uLCBkc3QpO1xyXG4gICAgbXVsbihkc3QsIGxhbWJkYSwgZHN0KTtcclxuICAgIGFkZChkc3QsIHJheS5vcmlnaW4sIGRzdCk7XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbi8qKlxyXG4gKiBDb21wdXRlcyBpbnRlcnNlY3Rpb24gb2YgdHdvIHBsYW5lcy5cclxuICpcclxuICogQHBhcmFtIHAxIFRoZSBmaXJzdCBwbGFuZS5cclxuICogQHBhcmFtIHAyIFRoZSBzZWNvbmQgcGxhbmUuXHJcbiAqIEByZXR1cm5zIFRoZSBsaW5lIG9yIGBudWxsYCBpZiB0aGUgcGxhbmVzIGFyZSBwYXJhbGxlbCB0byBlYWNoIG90aGVyLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFBsYW5lUGxhbmVJbnRlcnNlY3Rpb24ocDEsIHAyKSB7XHJcbiAgICBjb25zdCBuMSA9IHAxLm5vcm1hbDtcclxuICAgIGNvbnN0IG4yID0gcDIubm9ybWFsO1xyXG4gICAgaWYgKGFyZUNvbGxpbmVhcihuMSwgbjIpKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBjb25zdCB0YW5nZW50ID0gY3Jvc3MobjEsIG4yKTtcclxuICAgIG5vcm1hbGl6ZSh0YW5nZW50KTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdGFuZ2VudCxcclxuICAgICAgICBvcmlnaW46IG1hdHJpeDMuc29sdmUobWF0cml4My5mcm9tUm93cyhuMSwgbjIsIHRhbmdlbnQpLCBjcmVhdGUocDEuZGlzdGFuY2UsIHAyLmRpc3RhbmNlLCAwKSlcclxuICAgIH07XHJcbn1cclxuIiwiaW1wb3J0ICogYXMgdmVjdG9yMyBmcm9tICcuL3ZlY3RvcjMnO1xyXG5jb25zdCBNQVRSSVhfU0laRSA9IDk7XHJcbi8qKlxyXG4gKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgbmV3ICoqdW5pbml0aWFsaXplZCoqIG1hdHJpeC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoKSB7XHJcbiAgICByZXR1cm4gbmV3IEFycmF5KE1BVFJJWF9TSVpFKTtcclxufVxyXG4vKipcclxuICogWmVyb2VzIGEgbWF0cml4LlxyXG4gKlxyXG4gKiBAcGFyYW0gZHN0IFRoZSBtYXRyaXguXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHplcm8oZHN0ID0gY3JlYXRlKCkpIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTUFUUklYX1NJWkU7ICsraSkge1xyXG4gICAgICAgIGRzdFtpXSA9IDA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbi8qKlxyXG4gKiBDb3BpZXMgdGhyZWUgdmVjdG9ycyB0byBhIG1hdHJpeCBhcyByb3dzLlxyXG4gKlxyXG4gKiBAcGFyYW0gcjAgVGhlIGZpcnN0IHJvdy5cclxuICogQHBhcmFtIHIxIFRoZSBzZWNvbmQgcm93LlxyXG4gKiBAcGFyYW0gcjIgVGhlIHRoaXJkIHJvdy5cclxuICogQHBhcmFtIGRzdCBUaGUgbWF0cml4IHRoZSByb3dzIHdpbGwgYmUgd3JpdHRlbiB0by5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJvd3MocjAsIHIxLCByMiwgZHN0ID0gY3JlYXRlKCkpIHtcclxuICAgIGRzdFswXSA9IHIwLng7XHJcbiAgICBkc3RbMV0gPSByMS54O1xyXG4gICAgZHN0WzJdID0gcjIueDtcclxuICAgIGRzdFszXSA9IHIwLnk7XHJcbiAgICBkc3RbNF0gPSByMS55O1xyXG4gICAgZHN0WzVdID0gcjIueTtcclxuICAgIGRzdFs2XSA9IHIwLno7XHJcbiAgICBkc3RbN10gPSByMS56O1xyXG4gICAgZHN0WzhdID0gcjIuejtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYXJyYXkgb2YgY29sdW1ucyBvZiBhIG1hdHJpeC5cclxuICpcclxuICogQHBhcmFtIG0gVGhlIG1hdHJpeC5cclxuICogQHBhcmFtIGRzdCBUaGUgYXJyYXkgY29sdW1ucyBvZiB0aGUgbWF0cml4IHdpbGwgYmUgd3JpdHRlbiB0by5cclxuICogQHJldHVybnMgYGRzdGAuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29sdW1ucyhtLCBkc3QgPSBbXHJcbiAgICB2ZWN0b3IzLmNyZWF0ZSgwLCAwLCAwKSxcclxuICAgIHZlY3RvcjMuY3JlYXRlKDAsIDAsIDApLFxyXG4gICAgdmVjdG9yMy5jcmVhdGUoMCwgMCwgMClcclxuXSkge1xyXG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSAwOyBpIDwgMzsgKytpLCBqICs9IDMpIHtcclxuICAgICAgICBkc3RbaV0ueCA9IG1bal07XHJcbiAgICAgICAgZHN0W2ldLnkgPSBtW2ogKyAxXTtcclxuICAgICAgICBkc3RbaV0ueiA9IG1baiArIDJdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRzdDtcclxufVxyXG4vKipcclxuICogQ29waWVzIHRocmVlIHZlY3RvcnMgdG8gYSBtYXRyaXggYXMgY29sdW1ucy5cclxuICpcclxuICogQHBhcmFtIGMwIFRoZSBmaXJzdCBjb2x1bW4uXHJcbiAqIEBwYXJhbSBjMSBUaGUgc2Vjb25kIGNvbHVtbi5cclxuICogQHBhcmFtIGMyIFRoZSB0aGlyZCBjb2x1bW4uXHJcbiAqIEBwYXJhbSBkc3QgVGhlIG1hdHJpeCB0aGUgY29sdW1ucyB3aWxsIGJlIHdyaXR0ZW4gdG8uXHJcbiAqIEByZXR1cm5zIGBkc3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGZyb21Db2x1bW5zKGMwLCBjMSwgYzIsIGRzdCA9IGNyZWF0ZSgpKSB7XHJcbiAgICBkc3RbMF0gPSBjMC54O1xyXG4gICAgZHN0WzFdID0gYzAueTtcclxuICAgIGRzdFsyXSA9IGMwLno7XHJcbiAgICBkc3RbM10gPSBjMS54O1xyXG4gICAgZHN0WzRdID0gYzEueTtcclxuICAgIGRzdFs1XSA9IGMxLno7XHJcbiAgICBkc3RbNl0gPSBjMi54O1xyXG4gICAgZHN0WzddID0gYzIueTtcclxuICAgIGRzdFs4XSA9IGMyLno7XHJcbiAgICByZXR1cm4gZHN0O1xyXG59XHJcbi8qKlxyXG4gKiBDb21wdXRlcyBkZXRlcm1pbmFudCBvZiBhIG1hdHJpeC5cclxuICpcclxuICogQHBhcmFtIG0gVGhlIG1hdHJpeC5cclxuICogQHJldHVybnMgVGhlIGRldGVybWluYW50LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGRldGVybWluYW50KG0pIHtcclxuICAgIHJldHVybiBtWzBdICogKG1bNF0gKiBtWzhdIC0gbVs3XSAqIG1bNV0pICtcclxuICAgICAgICBtWzNdICogKG1bMV0gKiBtWzhdIC0gbVs3XSAqIG1bMl0pICtcclxuICAgICAgICBtWzZdICogKG1bMV0gKiBtWzVdIC0gbVs0XSAqIG1bMl0pO1xyXG59XHJcbmNvbnN0IHN0YXRpY01hdHJpeENvbHVtbnMgPSBbXHJcbiAgICAvLyBOb3QgdXNpbmcgdmVjdG9yMy5jcmVhdGUgaGVyZSBkdWUgdG8gY2lyY3VsYXIgZGVwZW5kZW5jeS5cclxuICAgIHsgeDogMCwgeTogMCwgejogMCB9LFxyXG4gICAgeyB4OiAwLCB5OiAwLCB6OiAwIH0sXHJcbiAgICB7IHg6IDAsIHk6IDAsIHo6IDAgfVxyXG5dO1xyXG5jb25zdCBzdGF0aWNNYXRyaXggPSBjcmVhdGUoKTtcclxuLyoqXHJcbiAqIFNvbHZlcyBhIHN5c3RlbSBvZiBsaW5lYXIgZXF1YXRpb25zIHJlcHJlc2VudGVkIHdpdGggYSBtYXRyaXggYW5kIGEgdmVjdG9yLFxyXG4gKiBpLmUuOlxyXG4gKlxyXG4gKiBgYGBcclxuICogbSAqICh4LCB5ICx6KV5UID0gdlxyXG4gKiBgYGBcclxuICpcclxuICogVXNlcyBDcmFtZXIncyBydWxlLlxyXG4gKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NyYW1lcidzX3J1bGVcclxuICpcclxuICogQHBhcmFtIG0gVGhlIG1hdHJpeCBvZiB0aGUgc3lzdGVtLlxyXG4gKiBAcGFyYW0gdiBUaGUgdmVjdG9yIG9mIHRoZSBzeXN0ZW0uXHJcbiAqIEBwYXJhbSBkc3QgVGhlIHZlY3RvciBzb2x1dGlvbiBvZiB0aGUgc3lzdGVtIHdpbGwgYmUgd3JpdHRlbiB0by5cclxuICogQHJldHVybiBgZHN0YC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzb2x2ZShtLCB2LCBkc3QgPSB2ZWN0b3IzLmNyZWF0ZSgwLCAwLCAwKSkge1xyXG4gICAgY29uc3QgcmV2RGV0ID0gMSAvIGRldGVybWluYW50KG0pO1xyXG4gICAgY29uc3QgW2MwLCBjMSwgYzJdID0gY29sdW1ucyhtLCBzdGF0aWNNYXRyaXhDb2x1bW5zKTtcclxuICAgIGRzdC54ID0gcmV2RGV0ICogZGV0ZXJtaW5hbnQoZnJvbUNvbHVtbnModiwgYzEsIGMyLCBzdGF0aWNNYXRyaXgpKTtcclxuICAgIGRzdC55ID0gcmV2RGV0ICogZGV0ZXJtaW5hbnQoZnJvbUNvbHVtbnMoYzAsIHYsIGMyLCBzdGF0aWNNYXRyaXgpKTtcclxuICAgIGRzdC56ID0gcmV2RGV0ICogZGV0ZXJtaW5hbnQoZnJvbUNvbHVtbnMoYzAsIGMxLCB2LCBzdGF0aWNNYXRyaXgpKTtcclxuICAgIHJldHVybiBkc3Q7XHJcbn1cclxuIiwiLyoqXHJcbiAqIEByZXR1cm5zIFRoZSBuZXh0IGluZGV4IG9mIHNwZWNpZmllZCBhcnJheSBvciBcIjBcIiBpZiB0aGUgaW5kZXggcG9pbnRzIHRvIHRlIGxhc3QgZWxlbWVudC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjeWNsaWNOZXh0SW5kZXgobGlzdCwgaW5kZXgpIHtcclxuICAgIHJldHVybiAoaW5kZXggKyAxKSAlIGxpc3QubGVuZ3RoO1xyXG59XHJcbi8qKlxyXG4gKiBAcmV0dXJucyBUaGUgcHJldiBpbmRleCBvZiBzcGVjaWZpZWQgYXJyYXkgb3IgXCJsaXN0Lmxlbmd0aC0xXCIgaWYgdGhlIGluZGV4IHBvaW50cyB0byB0ZSBmaXJzdCBlbGVtZW50LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGN5Y2xpY1ByZXZJbmRleChsaXN0LCBpbmRleCkge1xyXG4gICAgcmV0dXJuIChpbmRleCB8fCBsaXN0Lmxlbmd0aCkgLSAxO1xyXG59XHJcbi8qKlxyXG4gKiBAcmV0dXJucyBUaGUgbmV4dCB0byBzcGVjaWZpZWQgYnkgaW5kZXggZWxlbWVudCBvciB0aGUgZmlyc3QgZWxlbWVudCBpZiB0aGUgaW5kZXggcG9pbnRzIHRvIHRlIGxhc3QuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY3ljbGljTmV4dChsaXN0LCBpbmRleCkge1xyXG4gICAgcmV0dXJuIGxpc3RbY3ljbGljTmV4dEluZGV4KGxpc3QsIGluZGV4KV07XHJcbn1cclxuLyoqXHJcbiAqIEByZXR1cm5zIFRoZSBwcmV2IHRvIHNwZWNpZmllZCBieSBpbmRleCBlbGVtZW50IG9yIHRoZSBsYXN0IGVsZW1lbnQgaWYgdGhlIGluZGV4IHBvaW50cyB0byB0ZSBmaXJzdC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjeWNsaWNQcmV2KGxpc3QsIGluZGV4KSB7XHJcbiAgICByZXR1cm4gbGlzdFtjeWNsaWNQcmV2SW5kZXgobGlzdCwgaW5kZXgpXTtcclxufVxyXG4vKipcclxuICogVGhlIHNhbWUgaWRlYSBhcyBkZXNjcmliZWQgaGVyZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WYXJpYWJsZS1sZW5ndGhfcXVhbnRpdHkjWmlnemFnX2VuY29kaW5nLy5cclxuICpcclxuICogQHJldHVybnMgRGVjb2RlZCBudW1iZXIuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gemlnWmFnVW5wYWNrKHYpIHtcclxuICAgIHJldHVybiAodiA+PiAxKSBeICgtKHYgJiAxKSk7XHJcbn1cclxuIiwiaW1wb3J0ICogYXMgdmVjdG9yMyBmcm9tICcuLi8uLi8uLi8uLi9tYXRoL3ZlY3RvcjMnO1xyXG5pbXBvcnQgKiBhcyBhcnJheSBmcm9tICcuLi8uLi8uLi8uLi91dGlsL2FycmF5JztcclxuaW1wb3J0IE5vZGUsIHsgSG9sZU5vZGUgfSBmcm9tICcuL25vZGUnO1xyXG5pbXBvcnQgeyBjeWNsaWNOZXh0LCBjeWNsaWNOZXh0SW5kZXgsIGN5Y2xpY1ByZXYsIGN5Y2xpY1ByZXZJbmRleCB9IGZyb20gJy4vdXRpbHMnO1xyXG5jb25zdCB0bXBEaWZmID0gdmVjdG9yMy5jcmVhdGUoMCwgMCwgMCk7XHJcbmNvbnN0IHRtcFZlcnRleCA9IHZlY3RvcjMuY3JlYXRlKDAsIDAsIDApO1xyXG5jb25zdCB0bXBDb21tYW5kID0geyB0eXBlOiAwIC8qIEFERCAqLywgdmFsZW5jZTogMCwgc2hpZnQ6IDAgfTtcclxuLyoqXHJcbiAqIFdyaXRlcyB2ZXJ0aWNlcyBvZiB0aHJlZSBub2RlIGludG8gdGhlIG91dHB1dCBidWZmZXIgaWYgdGhlIGlzIG5vIGEgaG9sZSBub2RlIGJldHdlZW4gdGhlbS5cclxuICovXHJcbmZ1bmN0aW9uIHdyaXRlVHJpYW5nbGUobm9kZTEsIG5vZGUyLCBub2RlMywgb3V0cHV0KSB7XHJcbiAgICBpZiAoIUhvbGVOb2RlLmlzSG9sZU5vZGUobm9kZTEpICYmXHJcbiAgICAgICAgIUhvbGVOb2RlLmlzSG9sZU5vZGUobm9kZTIpICYmXHJcbiAgICAgICAgIUhvbGVOb2RlLmlzSG9sZU5vZGUobm9kZTMpKSB7XHJcbiAgICAgICAgb3V0cHV0LndyaXRlSW5kaWNlcyhbbm9kZTEuaW5kZXgsIG5vZGUyLmluZGV4LCBub2RlMy5pbmRleF0pO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBFYWNoIG1hbmlmb2xkIHJlc3RvcmluZyBzdGFydHMgd2l0aCBhIHRyaWFuZ2xlLiBUaGlzIGZ1bmN0aW9uIHJlYWQgdGhlIGZpcnN0IHRocmVlIHZlcnRpY2VzLCBmb3JtcyBhIHRyaWFuZ2xlXHJcbiAqIG9mIHRoZW0gYW5kIHJldHVybiB0aGlzIGluaXRpYWxpemVkIG5vZGUgcmluZyB0byBiZSBwcm9jZXNzZWQgZnVydGhlci5cclxuICovXHJcbmZ1bmN0aW9uIGdldEluaXRUcmlhbmdsZShyZWFkZXIsIGRlY29kZXIsIG91dHB1dCkge1xyXG4gICAgY29uc3QgdmVydGV4ID0gdmVjdG9yMy5jcmVhdGUoMCwgMCwgMCk7XHJcbiAgICBjb25zdCByaW5nID0gbmV3IEFycmF5KDMpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcclxuICAgICAgICBjb25zdCBjb21tYW5kID0gcmVhZGVyLnJlYWRDb21tYW5kKCk7XHJcbiAgICAgICAgaWYgKGNvbW1hbmQudHlwZSA9PT0gMSAvKiBIT0xFICovKSB7XHJcbiAgICAgICAgICAgIHJpbmdbaV0gPSBuZXcgSG9sZU5vZGUoY29tbWFuZC52YWxlbmNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY29tbWFuZC50eXBlID09PSAwIC8qIEFERCAqLykge1xyXG4gICAgICAgICAgICByZWFkZXIucmVhZERpZmYodG1wRGlmZik7XHJcbiAgICAgICAgICAgIHZlY3RvcjMuYWRkKHZlcnRleCwgdG1wRGlmZiwgdmVydGV4KTtcclxuICAgICAgICAgICAgcmluZ1tpXSA9IG5ldyBOb2RlKGNvbW1hbmQudmFsZW5jZSwgdmVjdG9yMy5jb3B5KHZlcnRleCksIG91dHB1dC53cml0ZVZlcnRleChkZWNvZGVyLmRlY29kZSh2ZXJ0ZXgpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByaW5nLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgcmluZ1tpXS5zZXROZWlnaGJvcnMoY3ljbGljTmV4dChyaW5nLCBpKSwgY3ljbGljUHJldihyaW5nLCBpKSk7XHJcbiAgICB9XHJcbiAgICB3cml0ZVRyaWFuZ2xlKHJpbmdbMF0sIHJpbmdbMV0sIHJpbmdbMl0sIG91dHB1dCk7XHJcbiAgICByZXR1cm4gcmluZztcclxufVxyXG5jb25zdCBzcGFuQ29tcGFyYXRvciA9IChhLCBiKSA9PiBhIC0gYjtcclxuLyoqXHJcbiAqIFJlbW92ZXMgZmluaXNoZWQgKHdpdGggYWxsIGVkZ2VzIHByb2Nlc3NlZCkgbm9kZXMgZnJvbSB0aGUgYWN0aXZlIHJpbmcgYmVmb3JlIHByb2Nlc3NpbmcgdGhlIG5leHQgY29tbWFuZC5cclxuICovXHJcbmZ1bmN0aW9uIHByZXBhcmVBY3RpdmVSaW5nKHJpbmcsIG91dHB1dCkge1xyXG4gICAgY29uc3Qgc3BhbnMgPSBuZXcgQXJyYXkocmluZy5sZW5ndGgpO1xyXG4gICAgZm9yIChsZXQgaSA9IDAsIHVucHJvY2Vzc2VkTm9kZXMgPSByaW5nLmxlbmd0aDsgdW5wcm9jZXNzZWROb2RlcyA+IDA7KSB7XHJcbiAgICAgICAgc3BhbnNbaV0gPSByaW5nW2ldLmNhbGN1bGF0ZVNwYW4oY3ljbGljUHJldihyaW5nLCBpKSwgY3ljbGljTmV4dChyaW5nLCBpKSk7XHJcbiAgICAgICAgaWYgKHNwYW5zW2ldID4gMSkge1xyXG4gICAgICAgICAgICBpID0gY3ljbGljTmV4dEluZGV4KHJpbmcsIGkpO1xyXG4gICAgICAgICAgICB1bnByb2Nlc3NlZE5vZGVzLS07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHNwYW5zW2ldID09PSAxKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vZGUxID0gcmluZ1tpXTtcclxuICAgICAgICAgICAgY29uc3Qgbm9kZTIgPSBjeWNsaWNQcmV2KHJpbmcsIGkpO1xyXG4gICAgICAgICAgICBjb25zdCBub2RlMyA9IGN5Y2xpY05leHQocmluZywgaSk7XHJcbiAgICAgICAgICAgIG5vZGUzLnNldEFmdGVyKG5vZGUxLCBub2RlMik7XHJcbiAgICAgICAgICAgIG5vZGUyLnNldEJlZm9yZShub2RlMSwgbm9kZTMpO1xyXG4gICAgICAgICAgICB3cml0ZVRyaWFuZ2xlKG5vZGUxLCBub2RlMiwgbm9kZTMsIG91dHB1dCk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpOyBqIDwgc3BhbnMubGVuZ3RoIC0gMTsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBzcGFuc1tqXSA9IHNwYW5zW2ogKyAxXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByaW5nLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgaSA9IGN5Y2xpY1ByZXZJbmRleChyaW5nLCBpKTtcclxuICAgICAgICAgICAgdW5wcm9jZXNzZWROb2RlcysrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYXJyYXkucm90YXRlKHJpbmcsIHJpbmcubGVuZ3RoIC0gY3ljbGljTmV4dEluZGV4KHJpbmcsIGkpKTtcclxuICAgICAgICAgICAgcmluZy5zcGxpY2UocmluZy5sZW5ndGggLSAyLCAyKTtcclxuICAgICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgICAgIHVucHJvY2Vzc2VkTm9kZXMgPSByaW5nLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJpbmcubGVuZ3RoIDwgMykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbGV0IG1pbkluZGV4ID0gMDtcclxuICAgIGxldCBtaW4gPSBbc3BhbnNbbWluSW5kZXhdLCBzcGFuc1tjeWNsaWNQcmV2SW5kZXgocmluZywgbWluSW5kZXgpXSwgc3BhbnNbY3ljbGljTmV4dEluZGV4KHJpbmcsIG1pbkluZGV4KV1dO1xyXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCByaW5nLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgdHJpYW5nbGVTcGFucyA9IFtzcGFuc1tpXSwgc3BhbnNbY3ljbGljUHJldkluZGV4KHJpbmcsIGkpXSwgc3BhbnNbY3ljbGljTmV4dEluZGV4KHJpbmcsIGkpXV07XHJcbiAgICAgICAgaWYgKGFycmF5LmNvbXBhcmUoc3BhbkNvbXBhcmF0b3IsIHRyaWFuZ2xlU3BhbnMsIG1pbikgPCAwKSB7XHJcbiAgICAgICAgICAgIG1pbiA9IHRyaWFuZ2xlU3BhbnM7XHJcbiAgICAgICAgICAgIG1pbkluZGV4ID0gaTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBhcnJheS5yb3RhdGUocmluZywgcmluZy5sZW5ndGggLSBtaW5JbmRleCk7XHJcbn1cclxuLyoqXHJcbiAqIFdyaXRlcyB0cmlhbmdsZSB0aGF0IGFyaXNlcyBmcm9tIHRoZSBuZXh0IG5vZGUgdXNpbmcgdGhlIHR3byBlbmRzIG9mIHRoZSBhY3RpdmUgcmluZy5cclxuICovXHJcbmZ1bmN0aW9uIGNsb3NlVHJpYW5nbGUob3V0cHV0LCBmcm9udCwgYmFjaywgYWRkLCBkaXN0LCBiYXNlKSB7XHJcbiAgICBhZGQuc2V0TmVpZ2hib3JzKGZyb250LCBiYWNrLCBkaXN0LCBiYXNlKTtcclxuICAgIGZyb250LnNldEFmdGVyKGJhY2ssIGFkZCk7XHJcbiAgICBiYWNrLnNldEJlZm9yZShmcm9udCwgYWRkKTtcclxuICAgIHdyaXRlVHJpYW5nbGUoYWRkLCBmcm9udCwgYmFjaywgb3V0cHV0KTtcclxufVxyXG4vKipcclxuICogUHJvY2VzcyB0aGUgbmV4dCBjb21tYW5kLlxyXG4gKi9cclxuZnVuY3Rpb24gcHJvY2Vzc0NvbW1hbmQoY21kLCBxdWV1ZSwgcmVhZGVyLCBkZWNvZGVyLCBvdXRwdXQpIHtcclxuICAgIGNvbnN0IGFjdGl2ZSA9IHF1ZXVlWzBdO1xyXG4gICAgY29uc3QgZnJvbnQgPSBhY3RpdmVbMF07XHJcbiAgICBjb25zdCBiYWNrID0gYWN0aXZlW2FjdGl2ZS5sZW5ndGggLSAxXTtcclxuICAgIHN3aXRjaCAoY21kLnR5cGUpIHtcclxuICAgICAgICBjYXNlIDAgLyogQUREICovOiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG0gPSBmcm9udC5nZXRQcmV2TmVpZ2hib3IoYmFjayk7XHJcbiAgICAgICAgICAgIGxldCBiYXNlO1xyXG4gICAgICAgICAgICBpZiAoSG9sZU5vZGUuaXNIb2xlTm9kZShmcm9udCkgfHwgSG9sZU5vZGUuaXNIb2xlTm9kZShiYWNrKSB8fCBIb2xlTm9kZS5pc0hvbGVOb2RlKG0pKSB7XHJcbiAgICAgICAgICAgICAgICBiYXNlID0gSG9sZU5vZGUuaXNIb2xlTm9kZShmcm9udCkgPyBiYWNrLnZlcnRleCA6IGZyb250LnZlcnRleDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGRpZmYgaXMgYSBkaWZmIHRvIHByZWRpY3RlZCBwb3NpdGlvbjpcclxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vd2lraS55YW5kZXgtdGVhbS5ydS9tYXBzL2Rldi9jb3JlL3JlbmRlcmVyL3ZlYzNkLyNnZW9tZXRyaWphdXBha292a2Frb29yZGluYXR2ZXJzaGluXHJcbiAgICAgICAgICAgICAgICB2ZWN0b3IzLmFkZChiYWNrLnZlcnRleCwgZnJvbnQudmVydGV4LCB0bXBWZXJ0ZXgpO1xyXG4gICAgICAgICAgICAgICAgdmVjdG9yMy5zdWIodG1wVmVydGV4LCBtLnZlcnRleCwgdG1wVmVydGV4KTtcclxuICAgICAgICAgICAgICAgIGRlY29kZXIuY2xhbXAodG1wVmVydGV4LCB0bXBWZXJ0ZXgpO1xyXG4gICAgICAgICAgICAgICAgYmFzZSA9IHRtcFZlcnRleDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZWFkZXIucmVhZERpZmYodG1wRGlmZik7XHJcbiAgICAgICAgICAgIHZlY3RvcjMuYWRkKGJhc2UsIHRtcERpZmYsIHRtcFZlcnRleCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHZlcnRleCA9IHZlY3RvcjMuY29weSh0bXBWZXJ0ZXgpO1xyXG4gICAgICAgICAgICBjb25zdCB2ZXJ0ZXhEZWNvZGVkID0gZGVjb2Rlci5kZWNvZGUodmVydGV4KTtcclxuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5ldyBOb2RlKGNtZC52YWxlbmNlLCB2ZXJ0ZXgsIG91dHB1dC53cml0ZVZlcnRleCh2ZXJ0ZXhEZWNvZGVkKSk7XHJcbiAgICAgICAgICAgIGNsb3NlVHJpYW5nbGUob3V0cHV0LCBmcm9udCwgYmFjaywgbm9kZSwgMCk7XHJcbiAgICAgICAgICAgIGFjdGl2ZS5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSAxIC8qIEhPTEUgKi86IHtcclxuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5ldyBIb2xlTm9kZShjbWQudmFsZW5jZSk7XHJcbiAgICAgICAgICAgIGNsb3NlVHJpYW5nbGUob3V0cHV0LCBmcm9udCwgYmFjaywgbm9kZSwgMCk7XHJcbiAgICAgICAgICAgIGFjdGl2ZS5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSAyIC8qIFNQTElUICovOiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGFkZCA9IGNtZC5zaGlmdDtcclxuICAgICAgICAgICAgY2xvc2VUcmlhbmdsZShvdXRwdXQsIGZyb250LCBiYWNrLCBhY3RpdmVbYWRkXSwgY21kLnZhbGVuY2UsIGFjdGl2ZVthZGQgLSAxXSk7XHJcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goYWN0aXZlLnNsaWNlKDAsIGFkZCArIDEpKTtcclxuICAgICAgICAgICAgYWN0aXZlLnNwbGljZSgwLCBhZGQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSAzIC8qIE1FUkdFICovOiB7XHJcbiAgICAgICAgICAgIGxldCBvdGhlciA9IDE7XHJcbiAgICAgICAgICAgIGZvciAoOyBvdGhlciAhPT0gcXVldWUubGVuZ3RoICYmIHF1ZXVlW290aGVyXS5sZW5ndGggPD0gY21kLnNoaWZ0OyBvdGhlcisrKSB7XHJcbiAgICAgICAgICAgICAgICBjbWQuc2hpZnQgLT0gcXVldWVbb3RoZXJdLmxlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhcnJheS5yb3RhdGUocXVldWVbb3RoZXJdLCBxdWV1ZVtvdGhlcl0ubGVuZ3RoIC0gY21kLnNoaWZ0KTtcclxuICAgICAgICAgICAgY29uc3QgYWRkID0gcXVldWVbb3RoZXJdWzBdO1xyXG4gICAgICAgICAgICBjbG9zZVRyaWFuZ2xlKG91dHB1dCwgZnJvbnQsIGJhY2ssIGFkZCwgY21kLnZhbGVuY2UsIHF1ZXVlW290aGVyXVtxdWV1ZVtvdGhlcl0ubGVuZ3RoIC0gMV0pO1xyXG4gICAgICAgICAgICBxdWV1ZVtvdGhlcl0ucHVzaChxdWV1ZVtvdGhlcl1bMF0pO1xyXG4gICAgICAgICAgICBhY3RpdmUuc3BsaWNlKDAsIDAsIC4uLnF1ZXVlW290aGVyXSk7XHJcbiAgICAgICAgICAgIHF1ZXVlLnNwbGljZShvdGhlciwgMSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogUmVhZCBhIHBvcnRpb24gb2YgdGhlIG1vZGVsIChtYW5pZm9sZCkgZnJvbSB0aGUgZmlsZSBhbmQgd3JpdGVzIHZlcnRpY2VzL3RyaWFuZ2xlcyBpbnRvIHRoZSBvdXRwdXQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VNYW5pZm9sZChyZWFkZXIsIGRlY29kZXIsIG91dHB1dCkge1xyXG4gICAgY29uc3QgcmluZyA9IGdldEluaXRUcmlhbmdsZShyZWFkZXIsIGRlY29kZXIsIG91dHB1dCk7XHJcbiAgICBjb25zdCBxdWV1ZSA9IFtyaW5nXTtcclxuICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggIT09IDApIHtcclxuICAgICAgICAvLyBhY3RpdmUgcmluZyBpcyB0aGUgZmlyc3QgZWxlbWVudCBpbnQgdGhlIHF1ZXVlXHJcbiAgICAgICAgcHJlcGFyZUFjdGl2ZVJpbmcocXVldWVbMF0sIG91dHB1dCk7XHJcbiAgICAgICAgd2hpbGUgKHF1ZXVlWzBdLmxlbmd0aCA+IDIpIHtcclxuICAgICAgICAgICAgcHJvY2Vzc0NvbW1hbmQocmVhZGVyLnJlYWRDb21tYW5kKHRtcENvbW1hbmQpLCBxdWV1ZSwgcmVhZGVyLCBkZWNvZGVyLCBvdXRwdXQpO1xyXG4gICAgICAgICAgICBwcmVwYXJlQWN0aXZlUmluZyhxdWV1ZVswXSwgb3V0cHV0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcXVldWUuc2hpZnQoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBvdXRwdXQuZmx1c2goKTtcclxufVxyXG4iLCJpbXBvcnQgeyBjeWNsaWNOZXh0LCBjeWNsaWNOZXh0SW5kZXgsIGN5Y2xpY1ByZXYsIGN5Y2xpY1ByZXZJbmRleCB9IGZyb20gJy4vdXRpbHMnO1xyXG5pbXBvcnQgKiBhcyB2ZWN0b3IzIGZyb20gJy4uLy4uLy4uLy4uL21hdGgvdmVjdG9yMyc7XHJcbi8qKlxyXG4gKiBBIG5vZGUgb2YgdGhlIG1vZGVsIG1lc2guIEJhc2ljYWxseSBpdCBpcyBhIHZlcnRleCwgYnV0IGFsc28gY29udGFpbnMgc29tZSBpbnRlcm1lZGlhdGUgZGF0YSB0b1xyXG4gKiByZXN0b3JlIHRoZSBtZXNoIGR1cmluZyBwYXJzaW5nLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTm9kZSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB2YWxlbmNlIE51bWJlciBhZGphY2VudCB2ZXJ0aWNlcy5cclxuICAgICAqIEBwYXJhbSB2ZXJ0ZXggQ29vcmRpbmF0ZXMgb2YgdGhlIG5vZGUuXHJcbiAgICAgKiBAcGFyYW0gaW5kZXggUG9zaXRpb24gb2YgdGhlIHZlcnRleCBpbiBhIHN0b3JhZ2UgKGxpa2UgR0wgYnVmZmVyIG9yIGFuIGludGVybWVkaWF0ZSBhcnJheSBidWZmZXIpLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcih2YWxlbmNlLCB2ZXJ0ZXgsIGluZGV4KSB7XHJcbiAgICAgICAgdGhpcy52ZXJ0ZXggPSB2ZXJ0ZXg7XHJcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xyXG4gICAgICAgIHRoaXMuX25laWdoYm91cnMgPSBuZXcgQXJyYXkodmFsZW5jZSkuZmlsbCh1bmRlZmluZWQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBEaXN0YW5jZSBiZXR3ZWVuIHR3byBuZWlnaGJvcnMgaW4gdGhlIG5vZGUncyBuZWlnaGJvcnMgbGlzdC5cclxuICAgICAqL1xyXG4gICAgY2FsY3VsYXRlU3BhbihhLCBiKSB7XHJcbiAgICAgICAgY29uc3QgYUluZGV4ID0gdGhpcy5fbmVpZ2hib3Vycy5pbmRleE9mKGEpO1xyXG4gICAgICAgIGNvbnN0IGJJbmRleCA9IHRoaXMuX25laWdoYm91cnMuaW5kZXhPZihiKTtcclxuICAgICAgICByZXR1cm4gKHRoaXMuX25laWdoYm91cnMubGVuZ3RoICsgKGJJbmRleCAtIGFJbmRleCkpICUgdGhpcy5fbmVpZ2hib3Vycy5sZW5ndGg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdHdvIG5laWdoYm9ycyB0aGF0IGZvcm1zIGEgdHJpYW5nbGUgd2l0aCB0aGUgY3VycmVudCBvbmUuXHJcbiAgICAgKi9cclxuICAgIHNldE5laWdoYm9ycyhhLCBiLCBzcGFuID0gMCwgcHJldikge1xyXG4gICAgICAgIGxldCBpbmRleCA9ICh0aGlzLl9uZWlnaGJvdXJzLmluZGV4T2YocHJldikgKyBzcGFuKSAlIHRoaXMuX25laWdoYm91cnMubGVuZ3RoO1xyXG4gICAgICAgIHRoaXMuX25laWdoYm91cnNbaW5kZXhdID0gYTtcclxuICAgICAgICBpbmRleCA9IGN5Y2xpY05leHRJbmRleCh0aGlzLl9uZWlnaGJvdXJzLCBpbmRleCk7XHJcbiAgICAgICAgdGhpcy5fbmVpZ2hib3Vyc1tpbmRleF0gPSBiO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIGEgbmVpZ2hib3IgYmVmb3JlIHRoZSBzcGVjaWZpZWQgb25lLlxyXG4gICAgICovXHJcbiAgICBzZXRCZWZvcmUobmV4dCwgdmFsKSB7XHJcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9uZWlnaGJvdXJzLmluZGV4T2YobmV4dCk7XHJcbiAgICAgICAgdGhpcy5fbmVpZ2hib3Vyc1tjeWNsaWNQcmV2SW5kZXgodGhpcy5fbmVpZ2hib3VycywgaW5kZXgpXSA9IHZhbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBhIG5laWdoYm9yIG5leHQgdG8gdGhlIHNwZWNpZmllZCBvbmUuXHJcbiAgICAgKi9cclxuICAgIHNldEFmdGVyKHByZXYsIHZhbCkge1xyXG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fbmVpZ2hib3Vycy5pbmRleE9mKHByZXYpO1xyXG4gICAgICAgIHRoaXMuX25laWdoYm91cnNbY3ljbGljTmV4dEluZGV4KHRoaXMuX25laWdoYm91cnMsIGluZGV4KV0gPSB2YWw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIE5laWdoYm9yIHByZXZpb3VzIHRvIHRoZSBzcGVjaWZpZWQgb25lLlxyXG4gICAgICovXHJcbiAgICBnZXRQcmV2TmVpZ2hib3IodmFsKSB7XHJcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9uZWlnaGJvdXJzLmluZGV4T2YodmFsKTtcclxuICAgICAgICByZXR1cm4gY3ljbGljUHJldih0aGlzLl9uZWlnaGJvdXJzLCBpbmRleCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIE5laWdoYm9yIG5leHQgdG8gdGhlIHNwZWNpZmllZCBvbmUuXHJcbiAgICAgKi9cclxuICAgIGdldE5leHROZWlnaGJvcih2YWwpIHtcclxuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuX25laWdoYm91cnMuaW5kZXhPZih2YWwpO1xyXG4gICAgICAgIHJldHVybiBjeWNsaWNOZXh0KHRoaXMuX25laWdoYm91cnMsIGluZGV4KTtcclxuICAgIH1cclxufVxyXG5jb25zdCBTVFVCX0hPTEVfTk9ERV9WRVJURVggPSB2ZWN0b3IzLmNyZWF0ZSgtMSwgLTEsIC0xKTtcclxuY29uc3QgU1RVQl9IT0xFX05PREVfSU5ERVggPSAtMTtcclxuLyoqXHJcbiAqIEEgc3BlY2lhbCB0eXBlIG9mIG5vZGVzIHRoYXQgZG8gbm90IHJlcHJlc2VudCBhIHJlYWwgdmVydGV4IChhbmQgaXMgbm90IHN1cHBvc2VkIHRvIGJlIHdyaXR0ZW4gaW50byBhIGJ1ZmZlciksXHJcbiAqIGJ1dCByZXF1aXJlZCB0byBzdXBwb3J0IHRoZSBtZXNoIHN0cnVjdHVyZS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBIb2xlTm9kZSBleHRlbmRzIE5vZGUge1xyXG4gICAgY29uc3RydWN0b3IodmFsZW5jZSkge1xyXG4gICAgICAgIHN1cGVyKHZhbGVuY2UsIFNUVUJfSE9MRV9OT0RFX1ZFUlRFWCwgU1RVQl9IT0xFX05PREVfSU5ERVgpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGlzSG9sZU5vZGUobm9kZSkge1xyXG4gICAgICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgSG9sZU5vZGU7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0ICogYXMgdmVjdG9yMyBmcm9tICcuLi8uLi8uLi8uLi9tYXRoL3ZlY3RvcjMnO1xyXG5pbXBvcnQgeyBjbGFtcCB9IGZyb20gJy4uLy4uLy4uLy4uL21hdGgvc2NhbGFyJztcclxuaW1wb3J0IHsgdWludDE2VG9GbG9hdCB9IGZyb20gJy4uLy4uLy4uLy4uL3V0aWwvZ3B1dHlwZXMnO1xyXG4vKipcclxuICogVmVydGV4IGNvbXBvbmVudHMgYXJlIGVuY29kZWQgaW4gdHdvIGJ5dGVzIHdpdGggc3BlY2lmaWVkIHByZWNpc2lvbiB0byBmYWNpbGl0YXRlIGJldHRlciBjb21wcmVzc2lvbi5cclxuICogVGhpcyBkZWNvZGVyIHRyYW5zbGF0ZSB0aG9zZSB2YWx1ZXMgaW50byBmbG9hdHMuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWZXJ0ZXhEZWNvZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHByZWNpc2lvbikge1xyXG4gICAgICAgIHRoaXMuX3ByZWNpc2lvblhZID0gcHJlY2lzaW9uICYgMHhGO1xyXG4gICAgICAgIHRoaXMuX3ByZWNpc2lvblogPSBwcmVjaXNpb24gPj4gNDtcclxuICAgICAgICB0aGlzLl9zaGlmdFhZID0gMTYgLSB0aGlzLl9wcmVjaXNpb25YWTtcclxuICAgICAgICB0aGlzLl9zaGlmdFogPSAxNiAtIHRoaXMuX3ByZWNpc2lvblo7XHJcbiAgICAgICAgdGhpcy5fbWF4WFkgPSAoMSA8PCB0aGlzLl9wcmVjaXNpb25YWSkgLSAxO1xyXG4gICAgICAgIHRoaXMuX21heFogPSAoMSA8PCB0aGlzLl9wcmVjaXNpb25aKSAtIDE7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIFZlY3RvciB3aXRoIGNvbXBvbmVudHMgY2xhbXBlZCB0byB0aGVpciBtYXggdmFsdWVzLlxyXG4gICAgICovXHJcbiAgICBjbGFtcCh2ZXJ0ZXgsIGRzdCA9IHZlY3RvcjMuY3JlYXRlKDAsIDAsIDApKSB7XHJcbiAgICAgICAgZHN0LnggPSBjbGFtcCh2ZXJ0ZXgueCwgMCwgdGhpcy5fbWF4WFkpO1xyXG4gICAgICAgIGRzdC55ID0gY2xhbXAodmVydGV4LnksIDAsIHRoaXMuX21heFhZKTtcclxuICAgICAgICBkc3QueiA9IGNsYW1wKHZlcnRleC56LCAwLCB0aGlzLl9tYXhaKTtcclxuICAgICAgICByZXR1cm4gZHN0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gdmVydGV4IEVuY29kZWQgdmVydGV4LlxyXG4gICAgICogQHBhcmFtIGRzdCBUaGUgb3V0cHV0IHZlY3Rvci5cclxuICAgICAqIEByZXR1cm5zIERlY29kZWQgdmVydGV4IChjb21wb25lbnRzIGFyZSBhZGp1c3RlZCBieSB0aGUgcHJlY2lzaW9uIGFuZCBjb252ZXJ0ZWQgaW50byBmbG9hdHMpXHJcbiAgICAgKi9cclxuICAgIGRlY29kZSh2ZXJ0ZXgsIGRzdCA9IHZlY3RvcjMuY3JlYXRlKDAsIDAsIDApKSB7XHJcbiAgICAgICAgZHN0LnggPSBWZXJ0ZXhEZWNvZGVyLl9kZWNvZGUodmVydGV4LngsIHRoaXMuX3ByZWNpc2lvblhZLCB0aGlzLl9zaGlmdFhZKTtcclxuICAgICAgICBkc3QueSA9IFZlcnRleERlY29kZXIuX2RlY29kZSh2ZXJ0ZXgueSwgdGhpcy5fcHJlY2lzaW9uWFksIHRoaXMuX3NoaWZ0WFkpO1xyXG4gICAgICAgIGRzdC56ID0gVmVydGV4RGVjb2Rlci5fZGVjb2RlKHZlcnRleC56LCB0aGlzLl9wcmVjaXNpb25aLCB0aGlzLl9zaGlmdFopO1xyXG4gICAgICAgIHJldHVybiBkc3Q7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgX2RlY29kZSh2YWx1ZSwgcHJlY2lzaW9uLCBzaGlmdCkge1xyXG4gICAgICAgIHZhbHVlID0gdmFsdWUgPDwgc2hpZnQ7XHJcbiAgICAgICAgdmFsdWUgfD0gdmFsdWUgPj4gcHJlY2lzaW9uO1xyXG4gICAgICAgIHZhbHVlID0gdWludDE2VG9GbG9hdCh2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG59XHJcbiIsIi8qKlxyXG4gKiBBcHBlbmRzIHBvcnRpb24gb2YgbWVtb3J5IHRvIGJhdGNoIGlmIHRoZXkgYXJlIGFkamFjZW50LlxyXG4gKlxyXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgYm90aCBwYXJhbXMgYXJlIGFkamFjZW50IGFuZCB0aGUgYmF0Y2ggd2FzIHN1Y2Nlc3NmdWxseSB1cGRhdGVkLCBgZmFsc2VgIG90aGVyd2lzZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRUb0JhdGNoKG1lbW9yeUxvY2F0aW9uLCBiYXRjaCkge1xyXG4gICAgaWYgKGJhdGNoLnZlcnRleEJ5dGVPZmZzZXQgKyBiYXRjaC52ZXJ0ZXhCeXRlTGVuZ3RoID09PSBtZW1vcnlMb2NhdGlvbi52ZXJ0ZXhCeXRlT2Zmc2V0ICYmXHJcbiAgICAgICAgYmF0Y2guaW5kZXhCeXRlT2Zmc2V0ICsgYmF0Y2guaW5kZXhCeXRlTGVuZ3RoID09PSBtZW1vcnlMb2NhdGlvbi5pbmRleEJ5dGVPZmZzZXQpIHtcclxuICAgICAgICBiYXRjaC52ZXJ0ZXhCeXRlTGVuZ3RoICs9IG1lbW9yeUxvY2F0aW9uLnZlcnRleEJ5dGVMZW5ndGg7XHJcbiAgICAgICAgYmF0Y2guaW5kZXhCeXRlTGVuZ3RoICs9IG1lbW9yeUxvY2F0aW9uLmluZGV4Qnl0ZUxlbmd0aDtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG4vKipcclxuICogQ29tYmluZXMgb2JqZWN0cyBhbGxvY2F0ZWQgaW4gbWVtb3J5IGludG8gYmF0Y2hlcy4gTm8gc29ydGluZyBpcyBkb25lIGluIHRoaXMgbWV0aG9kLCB0aGUgb2JqZWN0cyBhcmUgc3VwcG9zZWRcclxuICogdG8gYmUgc29ydGVkIGJ5IGluZGV4L3ZlcnRleCBvZmZzZXRzIHRvIG1ha2UgYmF0Y2hpbmcgZWZmZWN0aXZlLiBUaGUgYmF0Y2ggaXMgY3JlYXRlZCBieSBmYWN0b3J5IHNpbmNlIGl0IGNhblxyXG4gKiBjb250YWlucyBwcm9ibGVtIHNwZWNpZmljIGluZm9ybWF0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0gb2JqZWN0cyBMaXN0IG9mIGFsbG9jYXRlZCBvYmplY3RzLlxyXG4gKiBAcGFyYW0gZ2V0TWVtb3J5TG9jYXRpb24gUmV0dXJucyBtZW1vcnkgbG9jYXRpb24gb2Ygc3BlY2lmaWMgb2JqZWN0LlxyXG4gKiBAcGFyYW0gY3JlYXRlQmF0Y2ggSW5pdGlhdGVzIGJhdGNoIGJ5IHRoZSBmaXJzdCBvYmplY3QuXHJcbiAqIEBwYXJhbSBjYW5CYXRjaCBDaGVja3MgaWYgdHdvIG9iamVjdHMgY2FuIGJlIGFsbG9jYXRlZC5cclxuICogQHJldHVybnMgSXRlcmFibGUgbGlzdCBvZiBiYXRjaGVzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uKiBiYXRjaEFsbG9jYXRlZE9iamVjdHMob2JqZWN0cywgZ2V0TWVtb3J5TG9jYXRpb24sIGNyZWF0ZUJhdGNoLCBjYW5CYXRjaCA9ICgpID0+IHRydWUpIHtcclxuICAgIGNvbnN0IGl0ZXJhdG9yID0gb2JqZWN0c1tTeW1ib2wuaXRlcmF0b3JdKCk7XHJcbiAgICBsZXQgcHJpbWl0aXZlID0gaXRlcmF0b3IubmV4dCgpLnZhbHVlO1xyXG4gICAgaWYgKCFwcmltaXRpdmUpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBsZXQgcHJldiA9IHByaW1pdGl2ZTtcclxuICAgIGxldCBiYXRjaCA9IGNyZWF0ZUJhdGNoKHByZXYpO1xyXG4gICAgcHJpbWl0aXZlID0gaXRlcmF0b3IubmV4dCgpLnZhbHVlO1xyXG4gICAgd2hpbGUgKHByaW1pdGl2ZSkge1xyXG4gICAgICAgIGNvbnN0IHByaW1pdGl2ZU1lbW9yeUxvY2F0aW9uID0gZ2V0TWVtb3J5TG9jYXRpb24ocHJpbWl0aXZlKTtcclxuICAgICAgICBpZiAoIWNhbkJhdGNoKHByZXYsIHByaW1pdGl2ZSwgYmF0Y2gpIHx8ICFhcHBlbmRUb0JhdGNoKHByaW1pdGl2ZU1lbW9yeUxvY2F0aW9uLCBiYXRjaCkpIHtcclxuICAgICAgICAgICAgeWllbGQgYmF0Y2g7XHJcbiAgICAgICAgICAgIGJhdGNoID0gY3JlYXRlQmF0Y2gocHJpbWl0aXZlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHJldiA9IHByaW1pdGl2ZTtcclxuICAgICAgICBwcmltaXRpdmUgPSBpdGVyYXRvci5uZXh0KCkudmFsdWU7XHJcbiAgICB9XHJcbiAgICB5aWVsZCBiYXRjaDtcclxufVxyXG4iLCJpbXBvcnQgUHJpb3JpdHlRZXVldWUgZnJvbSAnLi9wcmlvcml0eV9xdWV1ZSc7XHJcbmltcG9ydCB7IFZvaWRFdmVudEVtaXR0ZXIgfSBmcm9tICcuLi91dGlsL2V2ZW50X2VtaXR0ZXInO1xyXG5jb25zdCBERVFVRVVFX1RJTUVPVVQgPSAxOyAvLyBtc1xyXG4vKipcclxuICogUHJpb3JpdGl6ZWQgdGFzayBxdWV1ZS5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRhc2tRdWV1ZSB7XHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cnVjdHMgYW4gZW1wdHkgdGFzayBxdWV1ZS5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5fcXVldWUgPSBuZXcgUHJpb3JpdHlRZXVldWUoKTtcclxuICAgICAgICB0aGlzLl9mcm96ZW4gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9kZXF1ZXVlVGltZW91dEhhbmRsZSA9IDA7XHJcbiAgICAgICAgdGhpcy5vbkVtcHR5ID0gbmV3IFZvaWRFdmVudEVtaXR0ZXIoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGVzdHJveXMgdGhlIHF1ZXVlLiBBbnkgcmVtYWluaW5nIHRhc2tzIHdvbid0IGJlIGV4ZWN1dGVkLlxyXG4gICAgICovXHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9kZXF1ZXVlVGltZW91dEhhbmRsZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVucXVldWVzIGEgdGFzayB0byB0aGUgcXVldWUgYW5kIHNjaGVkdWxlcyBwcm9jZXNzaW5nIG9mIHRoZSBxdWV1ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdGFzayBUaGUgdGFzay5cclxuICAgICAqIEByZXR1cm5zIFByb21pc2UgdGhhdCB3aWxsIGJlIGZ1bGxmaWxsZWQgd2hlbiB0aGUgdGFzayBzdWNjZXNzZnVsbHlcclxuICAgICAqICAgICAgZmluaXNoZXMgb3IgcmVqZWN0ZWQgaWYgdGhlcmUncyBhbiBlcnJvci5cclxuICAgICAqL1xyXG4gICAgZW5xdWV1ZSh0YXNrKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9mcm96ZW4pIHtcclxuICAgICAgICAgICAgdGhpcy5fc2V0RGVxdWV1ZVRpbWVvdXQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fcXVldWUuZW5xdWV1ZSh7XHJcbiAgICAgICAgICAgICAgICBleGVjdXRlKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2suZXhlY3V0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBwcmlvcml0eTogdGFzay5wcmlvcml0eVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGlzRW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3F1ZXVlLmlzRW1wdHkoKTtcclxuICAgIH1cclxuICAgIGZyZWV6ZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5fZGVxdWV1ZVRpbWVvdXRIYW5kbGUpIHtcclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2RlcXVldWVUaW1lb3V0SGFuZGxlKTtcclxuICAgICAgICAgICAgdGhpcy5fZGVxdWV1ZVRpbWVvdXRIYW5kbGUgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9mcm96ZW4gPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgdW5mcmVlemUoKSB7XHJcbiAgICAgICAgdGhpcy5fZnJvemVuID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9xdWV1ZS5pc0VtcHR5KCkpIHtcclxuICAgICAgICAgICAgdGhpcy5fc2V0RGVxdWV1ZVRpbWVvdXQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfZGVxdWV1ZSgpIHtcclxuICAgICAgICBjb25zdCB0YXNrID0gdGhpcy5fcXVldWUuZGVxdWV1ZSgpO1xyXG4gICAgICAgIGlmICh0YXNrKSB7XHJcbiAgICAgICAgICAgIHRhc2suZXhlY3V0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fcXVldWUuaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RlcXVldWVUaW1lb3V0SGFuZGxlID0gMDtcclxuICAgICAgICAgICAgdGhpcy5vbkVtcHR5LmZpcmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RlcXVldWVUaW1lb3V0SGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLl9kZXF1ZXVlKCksIERFUVVFVUVfVElNRU9VVCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3NldERlcXVldWVUaW1lb3V0KCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fZGVxdWV1ZVRpbWVvdXRIYW5kbGUpIHtcclxuICAgICAgICAgICAgdGhpcy5fZGVxdWV1ZVRpbWVvdXRIYW5kbGUgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuX2RlcXVldWUoKSwgREVRVUVVRV9USU1FT1VUKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IEJpbmFyeUhlYXAgZnJvbSAnLi9iaW5hcnlfaGVhcCc7XHJcbmZ1bmN0aW9uIGl0ZW1Db21wYXJhdG9yKGEsIGIpIHtcclxuICAgIHJldHVybiBhLnByaW9yaXR5IC0gYi5wcmlvcml0eTtcclxufVxyXG4vKipcclxuICogUHJpb3JpdHkgcXVldWUgYmFzZWQgb24gYSBoZWFwLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJpb3JpdHlRdWV1ZSB7XHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cnVjdHMgbmV3IGVtcHR5IHByaW9yaXR5IHF1ZXVlLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLl9oZWFwID0gbmV3IEJpbmFyeUhlYXAoaXRlbUNvbXBhcmF0b3IpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGFuIGl0ZW0gaW50byB0aGUgcXVldWUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGl0ZW0gVGhlIGl0ZW0uXHJcbiAgICAgKi9cclxuICAgIGVucXVldWUoaXRlbSkge1xyXG4gICAgICAgIHRoaXMuX2hlYXAuaW5zZXJ0KGl0ZW0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIG5leHQgaXRlbSBmcm9tIHRoZSBxdWV1ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgbmV4dCBpdGVtIG9yIGB1bmRlZmluZWRgIGlmIHRoZSBxdWV1ZSdzIGVtcHR5LlxyXG4gICAgICovXHJcbiAgICBkZXF1ZXVlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9oZWFwLnBvcCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgdGhlIHF1ZXVlIGhhcyBubyBpdGVtcyBpbiBpdC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlcmUncmUgbm8gaXRlbXMgaXQgdGhlIHF1ZXVlIGFuZCBgZmFsc2VgIG90aGVyd2lzZS5cclxuICAgICAqL1xyXG4gICAgaXNFbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faGVhcC5zaXplID09PSAwO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IHN3YXAgfSBmcm9tICcuL2FycmF5JztcclxuaW1wb3J0IHsgREVGQVVMVF9DT01QQVJBVE9SIH0gZnJvbSAnLi9jb21wYXJhdG9yJztcclxuLyoqXHJcbiAqIENvbXB1dGVzIGluZGV4IG9mIHRoZSBwYXJlbnQgb2YgYW4gaXRlbS5cclxuICpcclxuICogQHBhcmFtIGlkeCBJbmRleCBvZiB0aGUgaXRlbS5cclxuICogQHJldHVybnMgSW5kZXggb2YgdGhlIHBhcmVudC5cclxuICovXHJcbmZ1bmN0aW9uIGdldFBhcmVudElkeChpZHgpIHtcclxuICAgIHJldHVybiAoaWR4ICsgMSA+PiAxKSAtIDE7XHJcbn1cclxuLyoqXHJcbiAqIENvbXB1dGVzIGluZGV4IG9mIHRoZSBsZWZ0IGNoaWxkIG9mIGFuIGl0ZW0uXHJcbiAqXHJcbiAqIEBwYXJhbSBpZHggSW5kZXggb2YgdGhlIGl0ZW0uXHJcbiAqIEByZXR1cm5zIEluZGV4IG9mIHRoZSBjaGlsZC5cclxuICovXHJcbmZ1bmN0aW9uIGdldEZpcnN0Q2hpbGRJZHgoaWR4KSB7XHJcbiAgICByZXR1cm4gKGlkeCArIDEgPDwgMSkgLSAxO1xyXG59XHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJpbmFyeUhlYXAge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGVtcHR5IGhlYXAuIE9yZGVyIG9mIGl0ZW1zIGluIHRoZSBoZWFwIHdpbGwgYmUgZGVmaW5lZFxyXG4gICAgICogYnkgYSBnaXZlbiBjb21wYXJhdG9yLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb21wYXJhdG9yIFRoZSBjb21wYXJhdG9yLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihjb21wYXJhdG9yID0gREVGQVVMVF9DT01QQVJBVE9SKSB7XHJcbiAgICAgICAgLy8gVE9ETyhkbWlraXMpIEludmVzdGlnYXRlIHByZWFsbG9jYXRpb24uXHJcbiAgICAgICAgdGhpcy5faXRlbXMgPSBbXTtcclxuICAgICAgICB0aGlzLl9jb21wYXJhdG9yID0gY29tcGFyYXRvcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSW5zZXJ0cyBhbiBpdGVtIGludG8gdGhlIGhlYXAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGl0ZW0gVGhlIGl0ZW0gdG8gYmUgaW5zZXJ0ZWQuXHJcbiAgICAgKi9cclxuICAgIGluc2VydChpdGVtKSB7XHJcbiAgICAgICAgY29uc3QgaXRlbXMgPSB0aGlzLl9pdGVtcztcclxuICAgICAgICBjb25zdCBjb21wYXJhdG9yID0gdGhpcy5fY29tcGFyYXRvcjtcclxuICAgICAgICAvLyBJbnNlcnQgdGhlIG5ldyBpdGVtIGFzIGJvdHRvbSByaWdodC1tb3N0IGNoaWxkIG9mIHRoZSBoZWFwLlxyXG4gICAgICAgIGxldCBpZHggPSBpdGVtcy5wdXNoKGl0ZW0pIC0gMTtcclxuICAgICAgICBsZXQgcGFyZW50SWR4ID0gZ2V0UGFyZW50SWR4KGlkeCk7XHJcbiAgICAgICAgLy8gV2FsayB0aGUgaGVhcCB1cHdhcmQgYW5kIHJlc3RvcmUgaGVhcCBwcm9wZXJ0eSBvbiB0aGUgd2F5LlxyXG4gICAgICAgIHdoaWxlIChwYXJlbnRJZHggPiAtMSAmJlxyXG4gICAgICAgICAgICBjb21wYXJhdG9yKGl0ZW1zW2lkeF0sIGl0ZW1zW3BhcmVudElkeF0pID4gMCkge1xyXG4gICAgICAgICAgICBzd2FwKGl0ZW1zLCBpZHgsIHBhcmVudElkeCk7XHJcbiAgICAgICAgICAgIGlkeCA9IHBhcmVudElkeDtcclxuICAgICAgICAgICAgcGFyZW50SWR4ID0gZ2V0UGFyZW50SWR4KGlkeCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIFwibWF4aW11bVwiIGl0ZW0gZnJvbSB0aGUgaGVhZC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgcmVtb3ZlZCBpdGVtIG9yIGB1bmRlZmluZWRgIGlzIHRoZSBoZWFwJ3MgZW1wdHkuXHJcbiAgICAgKi9cclxuICAgIHBvcCgpIHtcclxuICAgICAgICBjb25zdCBpdGVtcyA9IHRoaXMuX2l0ZW1zO1xyXG4gICAgICAgIGlmIChpdGVtcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbmV3U2l6ZSA9IGl0ZW1zLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgLy8gUGxhY2UgbWF4IGl0ZW0gYXQgdGhlIGVuZCBvZiB0aGUgaXRlbXMgYXJyYXkuXHJcbiAgICAgICAgc3dhcChpdGVtcywgMCwgbmV3U2l6ZSk7XHJcbiAgICAgICAgLy8gV2FsayBkb3dud2FyZCBmcm9tIHRoZSBuZXcgcm9vdCB0byByZXN0b3JlIGhlYXAgcHJvcGVydHkuXHJcbiAgICAgICAgbGV0IGlkeCA9IDA7XHJcbiAgICAgICAgbGV0IGNoaWxkSWR4ID0gMTtcclxuICAgICAgICBjb25zdCBjb21wYXJhdG9yID0gdGhpcy5fY29tcGFyYXRvcjtcclxuICAgICAgICB3aGlsZSAoY2hpbGRJZHggPCBuZXdTaXplKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZElkeCArIDEgPCBuZXdTaXplICYmXHJcbiAgICAgICAgICAgICAgICBjb21wYXJhdG9yKGl0ZW1zW2NoaWxkSWR4XSwgaXRlbXNbY2hpbGRJZHggKyAxXSkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZElkeCArPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjb21wYXJhdG9yKGl0ZW1zW2lkeF0sIGl0ZW1zW2NoaWxkSWR4XSkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzd2FwKGl0ZW1zLCBpZHgsIGNoaWxkSWR4KTtcclxuICAgICAgICAgICAgaWR4ID0gY2hpbGRJZHg7XHJcbiAgICAgICAgICAgIGNoaWxkSWR4ID0gZ2V0Rmlyc3RDaGlsZElkeChjaGlsZElkeCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJlbW92ZSBwcmV2aW91c2x5IHBsYWNlZCBhdCB0aGUgZW5kIHByZXZpb3VzIG1heCBpdGVtLlxyXG4gICAgICAgIHJldHVybiBpdGVtcy5wb3AoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgXCJNYXhpbXVtXCIgaXRlbSBpbiB0aGUgaGVhcCBvciBgdW5kZWZpbmVkYCBpZiB0aGUgaGVhZCBpcyBlbXB0eS5cclxuICAgICAqL1xyXG4gICAgcGVlaygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faXRlbXNbMF07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIEl0ZXJhdG9yIG92ZXIgYWxsIGl0ZW1zIGluIHRoZSBoZWFwLiBOb3RlIHRoYXQgb3JkZXIgb2YgaXRlbXNcclxuICAgICAqICAgICAgaXMgdW5kZWZpbmVkLlxyXG4gICAgICovXHJcbiAgICAqW1N5bWJvbC5pdGVyYXRvcl0oKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuX2l0ZW1zKSB7XHJcbiAgICAgICAgICAgIHlpZWxkIGl0ZW07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBOdW1iZXIgb2YgaXRlbXMgaW4gdGhlIGhlYXAuXHJcbiAgICAgKi9cclxuICAgIGdldCBzaXplKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtcy5sZW5ndGg7XHJcbiAgICB9XHJcbn1cclxuIl0sInNvdXJjZVJvb3QiOiIifQ==